<html><head></head><body><div id="sbo-rt-content"><section class="frontmatter">&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="1" id="Page_1"/>CRYPTO DICTIONARY</span>&#13;
</h1>&#13;
</header>&#13;
<h1 id="letter-chung" class="nobreak"><span class="ChapterTitle"><span epub:type="pagebreak" title="2" id="Page_2"/>#</span></h1>&#13;
<h2 id="2013">2013</h2>&#13;
<p class="BodyFirst">The year of Edward Snowden’s leaks about the NSA’s classified activities, a turning point in cryptography. End-to-end encryption suddenly becomes an appealing topic.</p>&#13;
<h2 id="65537">65537</h2>&#13;
<p class="BodyFirst">The most common RSA public exponent; large enough to not be insecure, small enough to make exponentiation fast, and of a form that optimizes implementations’ speed (65537 = 2<sup>16</sup> + 1).</p>&#13;
<h1 id="letter-A"><span class="ChapterTitle">A</span></h1>&#13;
<h2 id="A5-0">A5/0</h2>&#13;
<p class="BodyFirst">One of the three encryption modes in early mobile telephony standards (GSM). A5/0 just means <em>no encryption</em>; therefore, the audio content from a mobile call would be received and transmitted in the clear between a mobile device and the nearest base station. It’s as secure as early TLS versions’ <em>null cipher</em>.</p>&#13;
<h2 id="A5-1">A5/1</h2>&#13;
<p class="BodyFirst">The default GSM cipher in Western countries (prior to 3G and 4G technologies) that encrypts encoded audio mobile communications. A stream cipher based on a curious mechanism involving three linear feedback shift registers irregularly clocked; so the update of a register depends on the values of certain bits in the two other registers. Sophisticated cryptanalytic attacks have broken A5/1. But in practice, the most effective attack is relatively simple: it’s a time-memory trade-off that exploits the short state of A5/1 (64 bits) and involves the precomputation of large rainbow tables. The A5/1 specification was <span epub:type="pagebreak" title="3" id="Page_3"/>initially confidential and unavailable to the public until it was reverse engineered in the late 1990s.</p>&#13;
<h2 id="A5-2">A5/2</h2>&#13;
<p class="BodyFirst">The export version of A5/1, a euphemism meaning its technical requirements include something like <em>must be easy to break by Western nations’ intelligence agencies</em>. Designed to be insecure, A5/2 didn’t turn out to be outrageously insecure: after being reverse engineered around the same time as A5/1, academic researchers quickly found attacks on A5/2. But these attacks were more efficient on paper than in practice.</p>&#13;
<h2 id="A5-3">A5/3</h2>&#13;
<p class="BodyFirst">At last, a real cipher in mobile phones. An upgrade to the do-it-yourself A5/1 that applies an algorithm already public and vetted, namely the block cipher KASUMI. KASUMI was used in 2G (along with A5/1), in 3G as A5/4 (along with SNOW 3G), and was no longer supported in 4G. </p>&#13;
<p class="BodyCustom">See <a href="#KASUMI"><em>KASUMI</em></a>.</p>&#13;
<h2 id="A5-4">A5/4</h2>&#13;
<p class="BodyFirst">A5/3 but with a key of 128 bits instead of 64 bits; A5/4 is secure, whereas A5/3 isn’t.</p>&#13;
<h2 id="Adaptive-attack">Adaptive attack</h2>&#13;
<p class="BodyFirst">An attack in which the attacker’s actions depend on what they observe during the attack and the protocol’s execution. For example, in an adaptive chosen-plaintext attack, the attacker sends plaintext messages that depend on the responses to their previous queries. In a nonadaptive attack, the list of plaintexts for which the attacker queries the ciphertexts must be predetermined.</p>&#13;
<h2 id="AEAD-authenticated-encryption-with-associated-data-">AEAD (authenticated encryption with associated data)</h2>&#13;
<p class="BodyFirst">A type of symmetric cipher that encrypts and authenticates data by producing a ciphertext as well as an authentication tag. The decryption step then only succeeds if the tag is valid, which proves that the ciphertext was created by someone who knows the key. To validate the tag, the receiving end generally computes it from the encrypted message and verifies that the computed value is identical to the one received.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="4" id="Page_4"/>DIFFERENT AEAD CONSTRUCTIONS</h2>&#13;
<p class="BoxBodyFirst">The AD in AEAD refers to associated data—also called <em>additional</em> or <em>auxiliary</em>—or data that isn’t encrypted but is covered by the authentication mechanism, because it’s taken as an input when computing the authentication tag.</p>&#13;
<p>AEAD can be realized in three ways:</p>&#13;
<ul>&#13;
<li>With an established cipher and established MAC, such as AES in CBC mode as a cipher and HMAC-SHA-256 as a MAC. This is the traditional approach that is usually the least efficient. It’s also the most error prone because of the different ways to combine a cipher and a MAC (so-called encrypt-and-MAC, encrypt-then-MAC, and MAC-then-encrypt.</li>&#13;
<li>With an established cipher and ad hoc MAC or mode, such as AES-GCM and ChaCha20-Poly1305, which are currently the most popular AEADs of this type. For example, TLS 1.3. AES-SIV also belongs in this category, although it’s a bit different (a MAC-and-encrypt rather than encrypt-then-MAC construction).</li>&#13;
<li>With a custom 2-in-1 construction, such as ACORN and AEGIS, both ciphers selected by the CAESAR competition. In these algorithms, the same internal state and logic encrypts and generates the authenti­cation tag.</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="AES-Advanced-Encryption-Standard">AES (Advanced Encryption Standard)</h2>&#13;
<p class="BodyFirst">The ubiquitous block cipher standardized by NIST in 2000. Designed by Belgian cryptographers Joan Daemen and Vincent Rijmen, and winner of the AES competition, its use is universal today under its various modes of operation, such as CBC, GCM, and SIV.</p>&#13;
<p class="BodyCustom">See <a href="#Rijndael"><em>Rijndael</em></a>.</p>&#13;
<h2 id="AES-CCM">AES-CCM</h2>&#13;
<p class="BodyFirst">AES in counter-with-CBC-MAC mode, which combines the CTR encryption mode with CBC-MAC authentication. AES-CCM is a NIST standard and is supported in TLS 1.3 and several other protocols, including Bluetooth Low Energy. But it’s much less popular than its sibling AES-GCM. The reason is that AES-CCM is generally slower and less convenient to use than AES-GCM. A research paper titled “A Critique of CCM” describes the limitations of the CCM mode.</p>&#13;
<p><span epub:type="pagebreak" title="5" id="Page_5"/>AES-CCM sometimes fits better than AES-GCM in embedded platforms because it only needs an AES algorithm and no additional logic (unlike GCM’s GMAC).</p>&#13;
<h2 id="AES-GCM">AES-GCM</h2>&#13;
<p class="BodyFirst">AES in Galois counter mode, the most common authenticated encryption primitive at the time of writing. Also the primitive that ended the reign of HMAC authenticators. In GCM mode, a message is encrypted in CTR mode and the Galois MAC (GMAC, aka GHASH) generates an authentication tag from the ciphertext and associated data blocks. The carry-less multiplication instruction PCLMULQDQ was introduced in Intel CPUs in the 2010s to speed up GMAC computations.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>AES-GCM’S ACHILLES’ HEEL</h2>&#13;
<p class="BoxBodyFirst">AES-GCM is secure except when called twice with the same nonce on distinct messages, which can leak plaintext data and reveal the authentication key GMAC uses. This unfortunate fragility hasn’t stopped AES-GCM from being used in countless protocols (including TLS, IPSec, and SSH) and from being standardized by IEEE, ISO, and NIST. AES-GCM’s cousin AES-GCM-SIV eliminates the nonce-reuse problem but isn’t yet widely supported and is a bit slower.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="AES-GCM-SIV">AES-GCM-SIV</h2>&#13;
<p class="BodyFirst">A variant of AES-GCM where the encryption nonce is determined from the tag computed by authenticating the plaintext (and any associated data). AES-GCM-SIV’s MAC, called <em>POLYVAL</em>, is slightly different from GCM’s GMAC: whereas AES-GCM is of the encrypt-then-MAC form, AES-GCM-SIV is a MAC-and-encrypt construction. The main benefit of AES-GCM-SIV compared to AES-GCM is that the former remains secure if a same nonce is reused—a property called <em>misuse resistance</em>.</p>&#13;
<h2 id="AES-NI">AES-NI</h2>&#13;
<p class="BodyFirst">Officially AES New Instructions but often called native instructions, which might be a better term. AES-NIs are CPU instructions that compute AES using hardware logic in the chip’s silicon as opposed to <span epub:type="pagebreak" title="6" id="Page_6"/>a combination of arithmetic operations using the chip’s ALU. When introduced by Intel in 2008, AES-NIs made AES software about 10 times faster, and as a by-product, immune to cache-timing attacks.</p>&#13;
<h2 id="AES-SIV">AES-SIV</h2>&#13;
<p class="BodyCustom">See <a href="#SIV-AES"><em>SIV-AES</em></a>.</p>&#13;
<h2 id="AIM-Advanced-INFOSEC-Machine">AIM (Advanced INFOSEC Machine)</h2>&#13;
<p class="BodyFirst">A chipset designed by Motorola in the late 1990s that includes separate FPGAs for red and black operations. Pompously advertised as <em>one of the most revolutionary advances in cryptography, ever</em>. The NSA uses it to protect classified and sensitive national security information. The off-the-shelf AIM didn’t include classified (Suite A) algorithms, but users could program the FPGAs to support algorithms, such as ACCORDION or BATON.</p>&#13;
<h2 id="AKA">AKA</h2>&#13;
<p class="BodyFirst">In 3GPP standards parlance, the authenticated key agreement operation between users of a cellular network and the user’s home network, which might be different from the serving network.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>AKA IN 3GPP STANDARDS</h2>&#13;
<p class="BoxBodyFirst">The AKA is very similar in 3G UMTS, 4G LTE, and 5G standards, and unlike many other key agreement protocols doesn’t use public key primitives; instead, it relies on a shared symmetric key and pseudorandom functions (except in 5G where public-key encryption is added).</p>&#13;
<p>The AKA looks like a straightforward protocol, taking a master key and a sequence number to derive session keys (encryption, authentication, and anonymity keys) while ensuring mutual authentication, or more precisely mutual knowledge of the shared key. But despite its cryptographic boringness, AKA aims to achieve other, nontrivial goals specific to its unique environment. These goals include confidentiality of the user identity (IMSI), unlinkability of the user, authentication of the serving network (by the user and home network), and strong unreliability guarantees and resilience to unsafe pseudo­random generators.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="AKS-Agrawal–Kayal–Saxena"><span epub:type="pagebreak" title="7" id="Page_7"/>AKS (Agrawal–Kayal–Saxena)</h2>&#13;
<p class="BodyFirst">The first deterministic primality test, as opposed to randomized ones. The 2002 research paper presenting the AKS algorithm, “PRIMES is in P,” was the first proof that the problem of primality testing is in the P complexity class, or the class of problems for which a nonrandomized polynomial-time algorithm exists.</p>&#13;
<p class="BodyCustom">See <a href="#PRIMES"><em>PRIMES</em></a>.</p>&#13;
<h2 id="Algebraic-cryptanalysis">Algebraic cryptanalysis</h2>&#13;
<p class="BodyFirst">A form of cryptanalysis where the target problem (typically key recovery, but also forgery, distinguishing, and so on) is modeled as a system of multivariate equations to which a solution is found by generic or ad hoc techniques. Algebraic cryptanalysis has been used to attack symmetric and asymmetric cryptosystems. An example target is stream ciphers based on feedback shift registers with low algebraic degree logic, giving rise to underlying equations exploitable by algebraic attacks.</p>&#13;
<p class="BodyCustom">See <a href="#Gr%C3%B6bner-basis"><em>Gröbner basis</em></a>.</p>&#13;
<h2 id="Alice">Alice</h2>&#13;
<p class="BodyFirst">Bob’s partner in crime, but who never met Bob in person. According to their official biography in John Gordon’s 1984 speech: “Alice and Bob have tried to defraud insurance companies, they’ve played poker for high stakes by mail, and they’ve exchanged secret messages over tapped telephones. (. . .) Alice and Bob have very powerful enemies. One of their enemies is the Tax Authority. Another is the Secret Police. This is a pity, since their favorite topics of discussion are tax frauds and overthrowing the government.”</p>&#13;
<p class="BodyCustom">See <a href="#Bob"><em>Bob</em></a>.</p>&#13;
<h2 id="All-or-nothing-transform-AONT">All-or-nothing transform (AONT)</h2>&#13;
<p class="BodyFirst">A reversible transformation where you need every bit of the output to determine any bit of the input. When an encryption scheme is an AONT, the decryption key is useless to determine the plaintext if you miss some bits of the ciphertext (unless the missing bits are so few that they can be brute-forced). The OAEP construction used for RSA encryption is an example of AONT. CBC or GCM encryption modes aren’t AONTs.</p>&#13;
<h2 id="Anonymous-signature"><span epub:type="pagebreak" title="8" id="Page_8"/>Anonymous signature</h2>&#13;
<p class="BodyFirst">A signature that doesn’t reveal the identity (public key) of the signer and therefore needs some interaction with the signer to verify it. It implies invisibility.</p>&#13;
<p class="BodyCustom">See <a href="#Invisible-signature"><em>Invisible signature</em></a>.</p>&#13;
<h2 id="Applied-Cryptography"><em>Applied Cryptography</em></h2>&#13;
<p class="BodyFirst">The 1996 book by Bruce Schneier that has been the main reference in the field for many years; it introduced many students and engineers to cryptography. Famous for its opening paragraph: “There are two kinds of cryptography in this world: cryptography that will stop your kid sister from reading your files, and cryptography that will stop major governments from reading your files. This book is about the latter.”</p>&#13;
<p>Inevitably outdated 25 years after its publication, <em>Applied Cryptography </em>is<em> </em>still worth keeping on your shelf as long as you don’t blindly follow all of its recommendations. It’s also much less outdated than Schneier’s two prior books, <em>E‑Mail Security </em>and <em>Protect Your Macintosh</em>.</p>&#13;
<h2 id="Applied-cryptography">Applied cryptography</h2>&#13;
<p class="BodyFirst">The part of cryptography that emphasizes direct applications. In contrast, theoretical cryptography is less about engineering and more about fundamental understanding and analysis. The term <em>applied </em>is deceiving; both applied and theoretical cryptography can (and ought to?) be equally relevant to real applications.</p>&#13;
<h2 id="ARC4">ARC4</h2>&#13;
<p class="BodyFirst">The original name of the RC4 stream cipher; also written as ARCFOUR. Before the reverse engineered RC4 was confirmed to be the actual RC4, it was prudently referred to as <em>alleged RC4</em>, which was shortened to ARC4.</p>&#13;
<h2 id="Argon2">Argon2</h2>&#13;
<p class="BodyFirst">A password hashing function developed during the Password Hashing Competition. Also, a de facto standard for processing passwords or any low-entropy secret to derive cryptographic keys or store a verifier in a way that prevents efficient cracking using GPUs, FPGAs, dedicated hardware, precomputed tables, or side-channel attacks.</p>&#13;
<p>Unlike PBKDF2, Argon2 can enforce the use of a certain amount of memory in addition to a configurable number of iterations. Unlike <span epub:type="pagebreak" title="9" id="Page_9"/>bcrypt, this amount of memory can be an arbitrary value rather than fixed. Unlike scrypt and the two others, Argon2 offers a user-friendly interface to easily pick time and memory parameters. It’s also a simple design that only uses the hash function BLAKE2 internally rather than a combination of all the cryptography ever designed.</p>&#13;
<p class="BodyCustom">See <a href="#bcrypt"><em>bcrypt</em></a>, <a href="#scrypt"><em>scrypt</em></a>, <a href="#PBKDF2-Password-Based-Key-Derivation-Function-2"><em>PBKDF2 (Password-Based Key Derivation Function 2)</em></a>.</p>&#13;
<h2 id="ARX-Add-Rotate-XOR">ARX (Add-Rotate-XOR)</h2>&#13;
<p class="BodyFirst">An abbreviation that denotes cryptographic algorithms only doing integer additions, word bit shifts or rotations, and XORs (as opposed to, for example, algorithms using S-boxes). It was coined by cryptography and security researcher Ralf-Philipp Weinmann in 2009. </p>&#13;
<h2 id="ASIACRYPT">ASIACRYPT</h2>&#13;
<p class="BodyFirst">Asia’s top academic cryptography conference, held every autumn in a different location in the Asia-Pacific region since 1990. The only IACR conference that includes <em>IACR</em> as a substring of its name. Researchers present peer-reviewed research papers with titles such as “Structure-Preserving and Re-Randomizable RCCA-Secure Public Key Encryption and Its Applications”<em> </em>and “Cryptanalysis of GSM Encryption in 2G/3G Networks Without Rainbow Tables.”</p>&#13;
<p class="BodyCustom">See <a href="#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems"><em>CHES</em></a>, <a href="#CRYPTO"><em>CRYPTO</em></a>, <a href="#Eurocrypt"><em>Eurocrypt</em></a>, <a href="#FSE-Fast-Software-Encryption"><em>FSE</em></a>, <a href="#PKC"><em>PKC</em></a>, <a href="#Real-World-Crypto-RWC"><em>Real World Crypto</em></a>, <a href="#TCC"><em>TCC</em></a>.</p>&#13;
<h2 id="Asymmetric-cryptography">Asymmetric cryptography</h2>&#13;
<p class="BodyCustom">See <a href="#Public-key-cryptography"><em>Public-key cryptography</em></a>.</p>&#13;
<h2 id="Attack">Attack</h2>&#13;
<p class="BodyFirst">In the context of cryptanalysis, the demonstration of a technique, described as an algorithm, that violates a security claim made by the designers of the primitive or protocol attacked.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>NOT ALL ATTACKS ARE ATTACKS</h2>&#13;
<p class="BoxBodyFirst">If Alice designs a cipher, she could claim that nobody can 1) recover the secret key with certainty if 2) they’re given a list of one billion pairs of plaintext or ciphertext. Here, point 1 is the security goal and point 2 is the attacker model. So if you determine how to recover the key with certainty with one million <span epub:type="pagebreak" title="10" id="Page_10"/>plaintext or ciphertext pairs, it qualifies as an attack. If you need 10 billion pairs, it doesn’t qualify as an attack. If the chance to recover the key is only 1/10, it doesn’t qualify either.</p>&#13;
<p>The existence of an attack doesn’t necessarily imply that the attacked primitive isn’t safe to use. For example, if an attack works in 2<sup>200</sup> operations and the security claim was 2<sup>256</sup>, you don’t have to worry because in reality 2<sup>200</sup> is as practically impossible as 2<sup>256</sup>.</p>&#13;
<p>Researchers often present attacks in the form of a research paper. When the attack is feasible, an actual implementation might be provided as evidence that it works.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Attribute-based-encryption-ABE">Attribute-based encryption (ABE)</h2>&#13;
<p class="BodyFirst">A generalization of identity-based encryption from one attribute (the identity) to more than one. It allows you to encrypt a message not to a given recipient, but to a set of attributes in such a way that only parties satisfying a valid combination of attributes can decrypt the message.</p>&#13;
<p>ABE sounds powerful but hasn’t found many real applications. Allegedly, the reason is due to its relatively complex construction (using elliptic-curve pairings) and the need for a trusted third party (holding the master key needed to generate private keys).</p>&#13;
<p class="BodyCustom">See <a href="#Identity-based-encryption"><em>Identity-based encryption</em></a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>ABE FOR ACCESS CONTROL</h2>&#13;
<p class="BoxBodyFirst">ABE is sometimes pitched as suitable for fine-grained access control. For example, you can imagine an organization deploying ABE to encrypt sensitive documents by using attributes such as department, clearance level, and project to cryptographically enforce multilevel security and role-based access. For instance, a document might be encrypted by using a public key with the attributes {department=ENGINEERING, clearance=SECRET, project=LABRADOR}.</p>&#13;
<p>ABE could then guarantee that if you satisfy only two of these attributes (say, your department is ENGINEERING and your clearance is SECRET but you work on the project HUSKY), you won’t be able to decrypt the document. More interestingly, ABE guarantees that you won’t be able to decrypt the document by colluding with someone on the project LABRADOR in the ENGINEERING department if they only have CONFIDENTIAL clearance.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Authenticated-cipher"><span epub:type="pagebreak" title="11" id="Page_11"/>Authenticated cipher</h2>&#13;
<p class="BodyCustom">See <a href="#AEAD-authenticated-encryption-with-associated-data-"><em>AEAD</em></a>.</p>&#13;
<h2 id="Axolotl">Axolotl</h2>&#13;
<p class="BodyFirst">The original name of the Signal application’s end-to-end messaging protocol.</p>&#13;
<p class="BodyCustom">See <a href="#Signal-protocol"><em>Signal protocol</em></a>.</p>&#13;
<h1 id="letter-B"><span class="ChapterTitle">B</span></h1>&#13;
<h2 id="Backdoor">Backdoor</h2>&#13;
<p class="BodyFirst">A covert feature to bypass an algorithm or protocol’s security. Trapdoors are known by users to exist; backdoors usually are not. A backdoor was once defined as <em>a feature or defect that allows surreptitious access to data</em>. A good backdoor must be undetectable, NOBUS (no-one-but-us, or exclusively exploitable by its architects), reusable, unmodifiable, and deniable.</p>&#13;
<p>For these reasons, backdoors in cryptographic algorithms are difficult to design and are more easily added in implementations, especially when the internal logic isn’t open and hard to deobfuscate. The NSA backdoor in Dual_EC_DRBG is a notable exception. Unfortunately, the most interesting research about backdoors isn’t presented at IACR conferences.</p>&#13;
<h2 id="Backtracking-resistance">Backtracking resistance</h2>&#13;
<p class="BodyFirst">Term notably used by NIST to refer to a notion similar to forward secrecy. The opposite of prediction resistance.</p>&#13;
<p class="BodyCustom">See <a href="#Forward-secrecy"><em>Forward secrecy</em></a>.</p>&#13;
<h2 id="Backward-secrecy">Backward secrecy</h2>&#13;
<p class="BodyFirst">The opposite of forward secrecy: backward secrecy is the property that if an attacker compromises some secret values, future messages remain protected. If an entire system’s state is compromised—­including long-term and short-term keys as well as any secret state <span epub:type="pagebreak" title="12" id="Page_12"/>or counter—backward secrecy is often impossible. An exception is pseudorandom generators, where uncertainty can be brought into the system via reseeding from reliable entropy sources, preventing an attacker from determining future output bits from a past snapshot of the system. In the context of secure messaging, some models assume that an attacker would compromise only certain sets of keys, but not necessarily the entire local secret state: in this case, some form of backward secrecy might be guaranteed.</p>&#13;
<p class="BodyCustom">See <a href="#Forward-secrecy"><em>Forward secrecy</em></a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>BACKWARD SECRECIES</h2>&#13;
<p class="BoxBodyFirst">Often defined in an ad hoc manner, the concept of backward secrecy also appeared under the terms <em>post-compromise security</em> (in the context of secure messaging), <em>break-in recovery</em> (Signal protocol), <em>future secrecy</em> (Signal protocol), <em>healing</em> (ZRTP), and <em>prediction resistance</em> (NIST).</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Base64">Base64</h2>&#13;
<p class="BodyFirst">Not encryption.</p>&#13;
<h2 id="BassOmatic">BassOmatic</h2>&#13;
<p class="BodyFirst">A cipher initially designed by Phil Zimmermann, the creator of PGP, to encrypt data in PGP. It was found to be insecure and replaced by IDEA in 1991. As Zimmermann commented in the source code, “BassOmatic gets its name from an old Dan Aykroyd <em>Saturday Night Live</em> skit involving a blender and a whole fish. The BassOmatic algorithm does to data what the original BassOmatic did to the fish.”</p>&#13;
<h2 id="BB84">BB84</h2>&#13;
<p class="BodyFirst">The first quantum key distribution (QKD) construction. It was described by Bennett and Brassard in 1984 and was based on ideas from the concept of quantum money, introduced a year earlier.</p>&#13;
<h2 id="bcrypt">bcrypt</h2>&#13;
<p class="BodyFirst">A hash algorithm: it doesn’t encrypt. Defined to address the obsolescence of the 1976 crypt utility in the 1999 paper “A Future-Adaptable <span epub:type="pagebreak" title="13" id="Page_13"/>Password Scheme.” In this paper, the authors made the following prediction: “Failing a major breakthrough in complexity theory, these algorithms should allow password-based systems to adapt to hardware improvements and remain secure 20 years into the future.”</p>&#13;
<p>You can argue that this prophecy was accurate, because you can tune bcrypt to be slow enough to defeat password cracking. On the other hand, bcrypt’s 4KB memory usage is now too low to prevent efficient cracking.</p>&#13;
<h2 id="Biclique-cryptanalysis">Biclique cryptanalysis</h2>&#13;
<p class="BodyFirst">An attack against cryptographic algorithms that works by searching for bicliques. In graph theory, a clique is a subset of nodes that are all connected to each other. A biclique is composed of two subsets of nodes; each node from the first subset is connected to all nodes from the second.</p>&#13;
<p>This concept was applied to refine differential attacks on AES and lead to attacks that, in theory, perform fewer operations than a brute-force search (2<sup>126</sup> instead of 2<sup>127</sup>). The bicliques used in this context are composed of a first set of bits from the internal state, a second set of bits from the ciphertext, and dependencies between these two sets conditioned by key bits. The idea of the attack is then to identify certain bits of the key as those for which the biclique conditions are satisfied (in terms of XOR differences).</p>&#13;
<h2 id="BIKE-Bit-Flipping-Key-Encapsulation">BIKE (Bit Flipping Key Encapsulation)</h2>&#13;
<p class="BodyFirst">Sounds like SIKE: also a KEM; also post-quantum, but based on a decoding problem rather than an isogeny problem.</p>&#13;
<p class="BodyCustom">See <a href="#SIKE-Supersingular-Isogeny-Key-Encapsulation"><em>SIKE (Supersingular Isogeny Key Encapsulation)</em></a>.</p>&#13;
<h2 id="BIP-Bitcoin-improvement-proposal">BIP (Bitcoin improvement proposal)</h2>&#13;
<p class="BodyFirst">A misleading name, because the most famous BIPs are no longer just proposals but de facto standards that apply to more cryptocurrencies than just Bitcoin. These BIPs include:</p>&#13;
<ul>&#13;
<li>BIP 32, which defines a tree-based mechanism to derive key pairs and addresses from a secret seed to create wallets of multiple accounts from a single secret value.</li>&#13;
<li><span epub:type="pagebreak" title="14" id="Page_14"/>BIP 44, which assigns semantics to BIP 32 tree levels and defines a syntax for paths within this tree (consisting of purpose, coin type, account, address type, and address index).</li>&#13;
<li>BIP 39, which defines a representation of a secret value as a high- entropy list of dictionary words, or mnemonic, which is then hashed to a seed that will be the root of a BIP 32 hierarchy of accounts.</li>&#13;
</ul>&#13;
<h2 id="Bit-Gold">Bit Gold</h2>&#13;
<p class="BodyFirst">The closest predecessor of Bitcoin.</p>&#13;
<h2 id="Bitcoin">Bitcoin</h2>&#13;
<p class="BodyFirst">An experiment that went out of control, for better or for worse.</p>&#13;
<h2 id="Black">Black</h2>&#13;
<p class="BodyFirst">NSA jargon referring to encrypted values. A black key is an encrypted key that uses, for example, a key wrapping mechanism so that it can be safely distributed on lower-security-level systems or networks. In the context of data-at-rest protection, black data is classified data that has been encrypted twice using appropriate encryption layers.</p>&#13;
<p class="BodyCustom">See <a href="#EKMS-Electronic-Key-Management-System"><em>EKMS (Electronic Key Management System)</em></a>.</p>&#13;
<h2 id="BLAKE">BLAKE</h2>&#13;
<p class="BodyFirst">A hash function submitted to the SHA-3 competition in 2008. It was one of five finalists but wasn’t selected (the winner was Keccak). BLAKE reuses the permutation of the ChaCha stream cipher with rotations done in the opposite directions. Some have suspected an advanced optimization, but in fact it originates from a typo in the original BLAKE specifications.</p>&#13;
<h2 id="BLAKE2">BLAKE2</h2>&#13;
<p class="BodyFirst">An evolution of BLAKE proposed shortly after the end of the SHA-3 competition in 2012. It was adopted in many software applications because it’s faster than SHA-2 and SHA-3. Several cryptocurrencies’ proof-of-work systems use BLAKE2.</p>&#13;
<h2 id="BLAKE3">BLAKE3</h2>&#13;
<p class="BodyFirst">A hash function that combines a reduced-round BLAKE2 and a Merkle tree construction, making it significantly faster than BLAKE2. BLAKE3 was announced at the Real World Crypto 2020 conference.</p>&#13;
<h2 id="Bleichenbacher-attack"><span epub:type="pagebreak" title="15" id="Page_15"/>Bleichenbacher attack</h2>&#13;
<p class="BodyFirst">The epitome of a padding oracle attack. Discovered in 1998 by Daniel Bleichenbacher, this is an adaptive chosen-ciphertext attack against the PKCS#1 v1.5 RSA encryption method. Ironically, Bleichenbacher’s attack exploits safeguards against other attacks (the mandatory padding bytes) to craft another attack, which after a few million chosen-ciphertext queries allows an attacker to recover a ciphertext’s plaintext.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>WHY BLEICHENBACHER IS UNPATCHABLE</h2>&#13;
<p class="BoxBodyFirst">Typically, when a software security bug and exploit is found and disclosed, a CVE might be issued, the bug is patched, a new version of the software application is released, and users sooner or later update to the new, corrected version. Of course, not all users will or can update immediately after the new release, but most of the time they eventually do.</p>&#13;
<p>Bleichenbacher’s attack is different because software can’t be patched to prevent it. The only effective mitigation is usually to use a different type of RSA encryption, namely PKCS#1 v2.1, aka OAEP, the evolution of the PKCS#1 standards series.</p>&#13;
<p>This is why, although Bleichenbacher published his attack in 1998, it was still exploited 20 years later on vulnerable devices as well as in the DROWN attack on legacy TLS versions.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Blind-signature">Blind signature</h2>&#13;
<p class="BodyFirst">A signature scheme where the signer (knowing the private key) creates a signature without knowing the number signed in a way that randomizes the value that the private key operation is applied to. This is clearer in the straightforward RSA blind signature construction: instead of using <em>md </em>mod <em>N</em>, the signer computes <em>s</em><sub>0</sub> = <em>m</em><sub>0</sub><sup><em>d</em></sup> where <em>m</em><sub>0</sub> = (<em>m </em>· <em>r</em><sup><em>e</em></sup>) mod <em>N </em>where <em>r </em>is some random value. You can then get the real signature of <em>m </em>by dividing <em>s</em><sub>0</sub> by <em>r</em>. Details are left as an exercise for you to complete.</p>&#13;
<p>This construction might look familiar because it’s the same trick the blinding defense uses against side-channel attacks to prevent attackers from controlling the data the private-key operation processes.</p>&#13;
<h2 id="Block-cipher"><span epub:type="pagebreak" title="16" id="Page_16"/>Block cipher</h2>&#13;
<p class="BodyFirst">A cipher that transforms a block of data to another block of the same length with a key as a parameter. It must be possible to decrypt the block. So the block cipher operation must be bijective (that is, one-to-one and reversible). That’s why block ciphers are also <em>keyed permutations</em> or <em>pseudorandom permutations</em>.</p>&#13;
<p>To encrypt more than a single block, which is usually a 64-bit or 128-bit chunk, you need to use a mode of operation (using the ECB mode is usually a bad idea, CBC is better, and CTR or SIV might be even better).</p>&#13;
<h2 id="Blockchain">Blockchain</h2>&#13;
<p class="BodyFirst">Both a curse and a blessing to cryptography. Comparable to when a subculture goes mainstream and its pioneers miss the old days, and sadly and bitterly contemplate the newly acquired wealth of those who might not deserve it the most.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>THANKS, BLOCKCHAIN?</h2>&#13;
<p class="BoxBodyFirst">If blockchain revolutionized anything, it’s probably the practice, funding, and deployment of cryptography. Thanks to blockchains, we acquired:</p>&#13;
<ul>&#13;
<li>A wealth of new, interesting, nontrivial problems to  solve—problems more exciting than designing an <em>n</em>th block cipher. For example, these problems relate to consensus protocols scalability, proof-of-stake security, transactions anonymity (via zk-SNARKS or bulletproofs), cross-blockchain operations, and so on.</li>&#13;
<li>Innovative solutions being created not to be published at peer-reviewed conference and be later forgotten, but actually technologies being deployed at scale, challenged by real threats and engineering constraints rather than only abstract models.</li>&#13;
<li>Large funding available with minimal bureaucracy and formalism, bypassing the traditional grant application systems and its flaws (slowness, misplaced incentives, and work overhead for researchers).</li>&#13;
<li>Passionate people, some without much formal education let alone a PhD, learning advanced cryptography concepts and creating new solutions to new problems, and implementing them without caring about academic rewards.</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Blockcipher"><span epub:type="pagebreak" title="17" id="Page_17"/>Blockcipher</h2>&#13;
<p class="BodyFirst">An alternative spelling of block cipher, introduced in research papers by Phillip Rogaway.</p>&#13;
<h2 id="Blowfish">Blowfish</h2>&#13;
<p class="BodyFirst">One of the most popular block ciphers in the 1990s. It owes its recognition to its memorable name and to its designer Bruce Schneier.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>BLOWFISH IN HOLLYWOOD</h2>&#13;
<p class="BoxBodyFirst">The Blowfish cipher once made it into episodes of the television series <em>24</em>. Here’s an excerpt from the show’s script:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">Mr. O’Brian, a short time ago one of our agents was in touch with Jack Bauer. She sent a name and address that we assume is his next destination. Unfortunately, it’s encrypted with Blowfish 148 and no one here knows how to crack that. Therefore, we need your help, please. (. . .)</p>&#13;
<p class="BoxExtractPara">Show me the file.</p>&#13;
<p class="BoxExtractPara">Where’s your information? 16- or 32-bit word length? 32.</p>&#13;
<p class="BoxExtractPara">Native or modified data points? Native.</p>&#13;
<p class="BoxExtractPara">The designer of this algorithm built a backdoor into his code. Decryption’s a piece of cake if you know the override codes.</p>&#13;
</blockquote>&#13;
<p class="BoxBodyContinued">Of course this dialogue makes little sense, and there’s no backdoor in Blowfish. Blowfish is actually a secure block cipher, despite the limitation of its 64-bit blocks, and is the core algorithm in the bcrypt password hashing scheme.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="BLS-Boneh-Lynn-Shacham-signature">BLS (Boneh-Lynn-Shacham) signature</h2>&#13;
<p class="BodyFirst">A signature scheme that leverages elliptic-curve pairings, allowing signatures to be shorter than ECDSA and Schnorr signatures. The reason is that each signature consists of a single group element. That is, for a similar security level as a 512-bit ECDSA signature, a BLS signature would be only 256 bits long.</p>&#13;
<p>BLS signatures have the useful property of supporting aggregation, whereby multiple public keys and signatures can be combined into a single public key and a single signature, and batch verification can be done efficiently.</p>&#13;
<p><span epub:type="pagebreak" title="18" id="Page_18"/>Combined with distributed key generation, you can use BLS signatures to build threshold signature schemes, which proved useful in cryptocurrency applications to distribute transaction signatures.</p>&#13;
<h2 id="Bob">Bob</h2>&#13;
<p class="BodyFirst">Subversive stockbroker and Alice’s co-conspirator.</p>&#13;
<p class="BodyCustom">See <a href="#Alice"><em>Alice</em></a>.</p>&#13;
<h2 id="Boolean-function">Boolean function</h2>&#13;
<p class="BodyFirst">A function whose arguments are binary values (that is, either 0 or 1), and that returns a single 0 or 1 bit. For example, <em>f</em>(<em>a</em>, <em>b</em>, <em>c</em>) = <em>a </em>+ <em>b </em>+ <em>ac </em>+ <em>bc </em>+ 1, where <em>a</em>, <em>b</em>, and <em>c</em> are binary values, is a Boolean function. Here, the plus sign behaves like XOR (because there are only 0s and 1s in Boolean functions), and <em>ab </em>means <em>a </em>times <em>b</em>, which is equivalent to a logical AND operation (giving 1 if and only if <em>a </em>= <em>b </em>= 1).</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>WHY CRYPTOGRAPHERS CARE ABOUT BOOLEAN FUNCTIONS</h2>&#13;
<p class="BoxBodyFirst">Boolean functions look dumb until you notice that you could describe any operation—for instance, a hash function—in terms of only Boolean functions. For example, each bit in the output of a hash function is a Boolean function of the input bits. Such functions only exist in the mathematical ether; they’re not explicit most of the time. It’s practically impossible to compute their polynomial form, let alone to implement and calculate them.</p>&#13;
<p>Nonetheless, there are countless research papers about Boolean functions and their security properties: the reason is that when you break a cryptographic hash or block cipher into pieces (meaning rounds and their subcomponents), you’ll encounter Boolean functions of a more manageable size—for example, the Boolean functions associated with S-boxes mapping 4-bit blocks to 4-bit blocks. Understanding Boolean functions and their properties, such as nonlinearity and algebraic immunity, has proved critical for designing secure ciphers and breaking weak ones.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Boomerang-attack">Boomerang attack</h2>&#13;
<p class="BodyFirst">A differential cryptanalysis technique in which you first <em>throw</em> a pair of plaintexts with a given difference into the cipher. You then obtain <span epub:type="pagebreak" title="19" id="Page_19"/>two ciphertexts and set another difference in these two ciphertexts to obtain two new ciphertexts. Finally, you <em>catch</em> the plaintexts obtained by decrypting them. The boomerang attack is essentially a trick to exploit differential characteristics that only cover part of the cipher.</p>&#13;
<h2 id="BQP-bounded-error-quantum-polynomial-time">BQP (bounded-error quantum polynomial time)</h2>&#13;
<p class="BodyFirst">The class of problems that quantum algorithms, and therefore a hypothetical quantum computer, can efficiently solve. BQP contains problems that classical computers can solve efficiently but also problems that today’s computers cannot. The latter are problems for which a superpolynomial quantum speedup exists.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>THE HIDDEN SUBGROUP PROBLEM</h2>&#13;
<p class="BoxBodyFirst">The most remarkable of the BQP problems, as far as cryptography is concerned, is called the <em>hidden subgroup problem</em> (<em>HSP</em>). In particular, cryptographers care about its version for commutative (or Abelian) finite groups. We could solve the following problems if HSP for Abelian groups is easy:</p>&#13;
<ul>&#13;
<li>Find <em>p </em>and <em>q </em>given <em>N </em>= <em>pq</em></li>&#13;
<li>Find <em>e </em>given <em>x</em>, <em>p</em>, and <em>x</em><sup><em>e</em></sup><em> </em>mod <em>p</em></li>&#13;
</ul>&#13;
<p class="BoxBodyContinued">You recognized these problems—factoring and discrete logarithm—whose hardness is necessary to the security of RSA and elliptic-curve cryptography.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Braid-group-cryptography">Braid group cryptography</h2>&#13;
<p class="BodyFirst">An attempt to build a new type of public-key cryptography using noncommutative groups of elements. Such elements can be viewed as braids with a fixed number of strands, and group operations are computationally efficient. As a side benefit, braid group cryptosystems were expected to be resistant to quantum algorithms. But none of the proposed key agreement schemes proved very cryptographically valuable due to their insufficient security.</p>&#13;
<h2 id="Brainpool-curves">Brainpool curves</h2>&#13;
<p class="BodyFirst">Elliptic curves designed by the German Federal information security authority (<em>Bundesamt für Sicherheit in der Informationstechnik</em>, or BSI). Brainpool curves have some suboptimal security properties, but unlike other standards, they provide a 512-bit curve (rather than a 521-bit one).</p>&#13;
<h2 id="Break-in-recovery"><span epub:type="pagebreak" title="20" id="Page_20"/>Break-in recovery</h2>&#13;
<p class="BodyFirst">A notion similar to backward secrecy and indistinguishable from future secrecy. The term was coined in the context of the Signal protocol.</p>&#13;
<p class="BodyCustom">See <a href="#Backward-secrecy"><em>Backward secrecy</em></a>.</p>&#13;
<h2 id="Broadcast-encryption">Broadcast encryption</h2>&#13;
<p class="BodyFirst">A type of encryption where the same ciphertext is broadcast to a set of receivers so only authorized ones can decrypt it, and receivers can be revoked to no longer decrypt it. Challenges of broadcast encryption are to be secure against collusion of receivers and to minimize ciphertext and keys’ lengths.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>APPLICATIONS OF BROADCAST ENCRYPTION</h2>&#13;
<p class="BoxBodyFirst">Although broadcast encryption was motivated by pay-TV content protection, it was never deployed: the reasons are mainly due to the prohibitive length of ciphertexts or keys and general unsuitability to receivers’ security model, where broadcast encryption only addresses a small part of the problems related to piracy.</p>&#13;
<p>But broadcast encryption has been used in the AACS content protection scheme used for Blu-ray discs. However, it turned out to be of limited effectiveness against piracy, because the content decryption key (which was protected by broadcast encryption) could be extracted from software players.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Brute-force-attack">Brute-force attack</h2>&#13;
<p class="BodyFirst">A type of attack that attempts to recover a secret by consecutively trying all the possible values of that secret. You can start a brute-force attack against most ciphers. But as long as the secret is long enough, the attack will never terminate (unless you’re impossibly lucky), because there are too many values to try.</p>&#13;
<h2 id="Bulletproof">Bulletproof</h2>&#13;
<p class="BodyFirst">A zero-knowledge proof proposed as an efficient range proof for cryptocurrencies. The major advantage of bulletproofs is that they don’t require a trusted setup. Specifically, they don’t need an initialization of <span epub:type="pagebreak" title="21" id="Page_21"/>the parameters, or <em>rules of the game</em>, which must be trusted for the protocol to be secure. Bulletproofs are notably used in Monero.</p>&#13;
<p class="BodyCustom">See <a href="#Range-proof"><em>Range proof</em></a>.</p>&#13;
<h2 id="Byzantine-fault-tolerance">Byzantine fault tolerance</h2>&#13;
<p class="BodyFirst">An umbrella term for a class of consensus protocols that don’t directly rely on mining and proof-of-something. pBFT (and variants thereof) and Tendermint are such protocols; they work by having a fixed number of hosts working together to reliably maintain a common state while distributing trust across hosts.</p>&#13;
<h1 id="letter-C"><span class="ChapterTitle">C</span></h1>&#13;
<h2 id="CAESAR">CAESAR</h2>&#13;
<p class="BodyFirst">The Competition for Authenticated Encryption: Security, Applicability, and Robustness, a non-NIST cryptographic competition that took place from 2014 to 2019. Partially funded by but not supervised by NIST, CAESAR identified new authenticated ciphers for several use cases, including <em>lightweight applications (resource constrained environments)</em>, <em>high-performance applications</em>, and <em>defense in depth</em>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>CAESAR’S DEFENSE IN DEPTH FOR AEAD</h2>&#13;
<p class="BoxBodyFirst">Of the three use cases defined in the CAESAR competition, defense in depth is probably the least obvious to readers. It was also the most interesting in terms of cryptographic engineering, because it was defined as addressing the following needs:</p>&#13;
<ul>&#13;
<li>Authenticity despite nonce repetition</li>&#13;
<li>Limited privacy damage from nonce repetition</li>&#13;
<li>Authenticity despite release of unverified plaintexts</li>&#13;
<li>Limited privacy damage from release of unverified plaintexts</li>&#13;
<li>Robustness in more scenarios, such as huge amounts of data</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Caesar’s-cipher"><span epub:type="pagebreak" title="22" id="Page_22"/>Caesar’s cipher</h2>&#13;
<p class="BodyFirst">An ancient cipher that encrypts a message by shifting each of its letters by three positions, so ABC becomes EFG, CAESAR becomes FDHVDU, and so on. Needless to say, Caesar’s cipher isn’t very secure.</p>&#13;
<h2 id="CAVP-Cryptographic-Algorithm-Validation-Program">CAVP (Cryptographic Algorithm Validation Program)</h2>&#13;
<p class="BodyFirst">NIST’s process to assess that an algorithm’s implementation conforms to the standard specification of that algorithm. Prerequisite of a cryptographic module’s validation through CMVP in the context of FIPS 140-2 certification. CAVP is essentially about checking test vectors, whereas CMVP covers the other FIPS 140-2 evaluation criteria.</p>&#13;
<p class="BodyCustom">See <a href="#CMVP-Cryptographic-Module-Validation-Program"><em>CMVP (Cryptographic Module Validation Program)</em></a>, <a href="#FIPS-140-2"><em>FIPS 140-2</em></a>.</p>&#13;
<h2 id="CBC-cipher-block-chaining">CBC (cipher block chaining)</h2>&#13;
<p class="BodyFirst">A mode of operation for block ciphers that has nothing to do with blockchains. CBC encrypts a series of blocks <em>P</em><sub>i</sub><em> </em>to ciphertext blocks <em>C</em><sub>i</sub><em> </em>by computing <em>C</em><sub>i</sub><em> </em>= Enc(<em>K</em>, <em>P</em><sub>i</sub><em> </em><span class="NSSymbol">⊕</span><em>C</em><sub>i</sub><sub>–1</sub>), for <em>i </em>= 1, . . . , <em>n</em>. The initial value of (IV) is <em>C</em><sub>0</sub>,<sub> </sub>which should be unpredictable to guarantee semantic security. CBC has the useful property that decryption is parallelizable (whereas encryption isn’t). Unfortunately, CBC is vulnerable to padding oracle attacks.</p>&#13;
<h2 id="CECPQ-combined-elliptic-curve-and-post-quantum">CECPQ (combined elliptic-curve and post-quantum)</h2>&#13;
<p class="BodyFirst">A hybrid key agreement scheme including an elliptic-curve and a post-quantum scheme. CECPQ was developed by Google as a way to hedge TLS connections against the risks of quantum computing.</p>&#13;
<p>The first version, CECPQ1, combined X25519 with the lattice-based scheme NewHope, and was deployed in 2016 for a few months in the Chrome Canary browser. Announced in 2019, CECPQ2 replaces NewHope with the NTRU-based scheme HRSS, and the variant CECPQ2b uses the isogeny-based scheme SIKE.</p>&#13;
<h2 id="Cellular-automata">Cellular automata</h2>&#13;
<p class="BodyFirst">Useless in cryptography. It’s a source of many bad papers.</p>&#13;
<h2 id="Ceremony">Ceremony</h2>&#13;
<p class="BodyFirst">A procedure during which important keys, secrets, or sensitive parameters are generated. A ceremony includes procedural and technical security controls to provide assurance about the keys’ secure <span epub:type="pagebreak" title="23" id="Page_23"/>generation and backup—and thus about the software, hardware, processes, and people involved. It’s more than picking an acceptable PRNG, which is actually the easiest part. For example, a ceremony involves participants with well-defined roles (such as auditors and operators), a predefined sequence of operations (known as a script or storybook), and the writing of detailed minutes.</p>&#13;
<p>Ceremonies are typically held to generate root keys of certificate authorities or master keys (seeds) of blockchain wallets in financial institutions. They are then called <em>key ceremonies</em>. Ceremonies can also be called <em>trusted setups</em> when they aim to generate parameters of a zero-knowledge proof system.</p>&#13;
<h2 id="Certificate">Certificate</h2>&#13;
<p class="BodyFirst">The source of many troubles, including encoding formats, parsing bugs, unrenewed expired certificates, broken chains, untrusted authorities, self signatures, revocation lists, and so on. But often it’s the least-bad solution we have.</p>&#13;
<h2 id="Certificate-authority-CA">Certificate authority (CA)</h2>&#13;
<p class="BodyFirst">A trusted third party in public-key infrastructures, or the type of component that cryptographers try to avoid but inevitably must live with. </p>&#13;
<p>A CA is the entity you must ultimately trust when verifying the validity of a certificate, because the CA can issue certificates as well as intermediate signing certificates. If the CA is compromised, it might grant certificates to malicious entities to perform phishing or man-in-the-middle attacks.</p>&#13;
<p>Even some blockchain platforms that claim to be fully decentralized and distributed ultimately rely on a CA.</p>&#13;
<h2 id="Certificate-transparency-CT">Certificate transparency (CT)</h2>&#13;
<p class="BodyFirst">A Google initiative that reduces the risk from rogue or compromised CAs by creating a public log of certificates being issued. Certificate transparency makes it easier for the domain owner to know whether certificates have been issued for their domain. CT is a kind of public ledger, but it’s not a blockchain and has been criticized by blockchain advocates.</p>&#13;
<h2 id="ChaCha20">ChaCha20</h2>&#13;
<p class="BodyFirst">A variant of the Salsa20 stream cipher that is currently one of the most used stream ciphers in the world. This is because it’s supported <span epub:type="pagebreak" title="24" id="Page_24"/>in recent TLS and SSH versions and is the default cipher in many protocols, such as WireGuard.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>CHACHA20: BORN ON A FORUM</h2>&#13;
<p class="BoxBodyFirst">ChaCha20 was first proposed on the eSTREAM project’s discussion forum in a post that began like this:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">I have an idea for improving Salsa20. Obviously, the result isn’t an eSTREAM candidate, but I’m curious what people think.</p>&#13;
</blockquote>&#13;
<p class="BoxBodyContinued">The short post, which didn’t attract much interest, described ChaCha20 as potentially having better diffusion and performance.</p>&#13;
<p>ChaCha20 did turn out to be slightly faster than Salsa20, thanks to a better use of vectorized SIMD instructions and to better withstand cryptanalysis than its parent algorithm.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems">CHES (Conference on Cryptographic Hardware and Embedded Systems)</h2>&#13;
<p class="BodyFirst">The most <em>real-world</em> conference of all IACR conferences before Real World Crypto existed. It’s held every year in a different location. Researchers present peer-reviewed research papers with titles such as “Electromagnetic Information Extortion from Electronic Devices Using Interceptor, Its Countermeasure”<em> </em>and “Make Some Noise. Unleashing the Power of Convolutional Neural Networks for Profiled Side-Channel Analysis.”</p>&#13;
<p class="BodyCustom">See <a href="#ASIACRYPT"><em>Asiacrypt</em></a>, <a href="#CRYPTO"><em>CRYPTO</em></a>, <a href="#Eurocrypt"><em>Eurocrypt</em></a>, <a href="#FSE-Fast-Software-Encryption"><em>FSE</em></a>, <a href="#PKC"><em>PKC</em></a>, <a href="#Real-World-Crypto-RWC"><em>Real World Crypto</em></a>, <a href="#TCC"><em>TCC</em></a>.</p>&#13;
<h2 id="CIA">CIA</h2>&#13;
<p class="BodyFirst">The three cardinal principles of information security: confidentiality, integrity, and availability. The cryptographer’s version of the principles replaces <em>availability</em> with <em>authenticity</em>.</p>&#13;
<h2 id="Ciphertext-stealing">Ciphertext stealing</h2>&#13;
<p class="BodyFirst">A technique to encrypt with a block cipher in CBC mode such that the ciphertext is of the same bit length as the plaintext. Instead of padding the last plaintext block with fixed values, as in PKCS#7 padding, it appends ciphertext bytes from the previous blocks to obtain a full block. It also strips off said bytes of the previous encrypted block to retain the original message size. This trick only works if the message <span epub:type="pagebreak" title="25" id="Page_25"/>is longer than one block. Standardized by NIST in three different versions (CS1, CS2, and CS3), ciphertext stealing is rarely used in practice, because most of the time a small overhead is acceptable.</p>&#13;
<h2 id="Clipper">Clipper</h2>&#13;
<p class="BodyFirst">A simple solution proposed for a complex problem: the Clipper chip aimed to enable encrypted communications for US citizens and businesses while allowing full interception by authorized parties (namely, government and law enforcement). Proposed in the early 1990s by the NSA, the Clipper chip was part of a key escrow architecture where each chip’s secret keys would also be shared with US Federal agencies. This has been called a backdoor, but strictly speaking isn’t really one because the door’s existence wasn’t a secret.</p>&#13;
<p>In addition to its questionable security architecture, the Clipper chip suffered from a poor technical execution and included a number of security flaws, which helped its opponents halt the project.</p>&#13;
<h2 id="CMVP-Cryptographic-Module-Validation-Program">CMVP (Cryptographic Module Validation Program)</h2>&#13;
<p class="BodyFirst">NIST’s process for validating cryptographic modules submitted to the FIPS 140-2 certification. To be evaluated within CMVP, a cryptographic component must implement at least one NIST-standard algorithm. </p>&#13;
<p class="BodyCustom">See <a href="#CAVP-Cryptographic-Algorithm-Validation-Program"><em>CAVP (Cryptographic Algorithm Validation Program)</em></a>, <a href="#FIPS-140-2"><em>FIPS 140-2</em></a>.</p>&#13;
<h2 id="Code-based-cryptography">Code-based cryptography</h2>&#13;
<p class="BodyFirst">Post-quantum schemes relying on hardness of decoding a linear code with insufficient information. Many code-based schemes are variants of the 1978 McEliece construction, whose public key describes a random linear code. The encryption process consists of encoding a message while adding some errors to the codeword. Decryption is possible due to a trapdoor that converts the codeword into another code for which decoding is doable.</p>&#13;
<p>The submission <em>Classic McEliece</em> to NIST’s post-quantum competition in 2017 is almost identical to McEliece’s 1978 scheme.</p>&#13;
<h2 id="Commitment">Commitment</h2>&#13;
<p class="BodyFirst">Also known as bit commitment, a protocol in which a prover temporarily hides a message that cannot be changed. The prover does this by publishing some value that doesn’t reveal the value committed (a feature called the <em>hiding property</em>) and must also prevent the prover from <span epub:type="pagebreak" title="26" id="Page_26"/>revealing a different value than the one committed (called the <em>binding property</em>). The term <em>bit commitment</em> initially referred to coin-flipping protocols in which you commit only one bit. But it’s now used for values of any size. The hash values that security people mysteriously post on Twitter so they can claim prior discovery of some 0-day vulnerability are basic commitments.</p>&#13;
<h2 id="Concurrent-zero-knowledge">Concurrent zero-knowledge</h2>&#13;
<p class="BodyFirst">Zero-knowledge proofs secure in concurrent settings, that is, when the attacker can observe and disrupt multiple independent executions of the proof protocol.</p>&#13;
<h2 id="Consensus-protocol">Consensus protocol</h2>&#13;
<p class="BodyFirst">An old concept from the field of distributed computing that became cool again due to its role in blockchain systems.</p>&#13;
<h2 id="Control-word">Control word</h2>&#13;
<p class="BodyFirst">A secret key used to encrypt audio and video content in pay-TV systems. This key is 48 bits long in legacy systems, 64 bits long in less old ones, and 128 bits long in the latest generation. Although 48 bits might seem ridiculously short, when the key is changed every 5 or 10 seconds, it can be long enough.</p>&#13;
<h2 id="COPACOBANA-Cost-Optimized-PArallel-COde-Breaker">COPACOBANA (Cost-Optimized PArallel COde Breaker)</h2>&#13;
<p class="BodyFirst">An academic proof of concept of an FPGA-based DES cracker. Created in approximately 2007, COPACOBANA is capable of breaking a 56-bit DES key within a week in a cost-effective way.</p>&#13;
<h2 id="Cothority-collective-authority">Cothority (collective authority)</h2>&#13;
<p class="BodyFirst">A framework for creating decentralized protocols where an operation involves multiple parties so none has greater authority than the others. You can use cothorities to perform operations, such as threshold signature, consensus, or distributed public randomness generation. Although it sounds very blockchain-y, few blockchains have used cothorities.</p>&#13;
<h2 id="Cryptanalysis">Cryptanalysis</h2>&#13;
<p class="BodyFirst">The practice of analyzing cryptographic algorithms to break them—that is, violate their security assumptions—or to understand why they cannot be broken.</p>&#13;
<h2 id="Cryptids"><span epub:type="pagebreak" title="27" id="Page_27"/>Cryptids</h2>&#13;
<p class="BodyFirst">Animals like bigfoots, unicorns, the Kraken, or the Mongolian death worm. As rare as good cryptography software.</p>&#13;
<h2 id="Crypto">Crypto</h2>&#13;
<p class="BodyFirst">Shorthand for cryptography and sometimes for cryptocurrency. Use in the latter sense tends to irritate orthodox cryptographers who rally under the banner “crypto is for cryptography.”</p>&#13;
<h2 id="CRYPTO">CRYPTO</h2>&#13;
<p class="BodyFirst">The top academic cryptography conference held every summer since 1981 in Santa Barbara, California. Researchers present peer-reviewed papers with titles such as “iO Without Multilinear Maps: New Paradigms via Low-Degree Weak Pseudorandom Generators and Security Amplification” and “Seedless Fruit Is the Sweetest: Random Number Generation, Revisited.”</p>&#13;
<p class="BodyCustom">See <a href="#ASIACRYPT"><em>Asiacrypt</em></a>, <a href="#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems"><em>CHES</em></a>, <a href="#Eurocrypt"><em>Eurocrypt</em></a>, <a href="#FSE-Fast-Software-Encryption"><em>FSE</em></a>, <a href="#PKC"><em>PKC</em></a>, <a href="#Real-World-Crypto-RWC"><em>Real World Crypto</em></a>, <a href="#TCC"><em>TCC</em></a>.</p>&#13;
<h2 id="Crypto-AG">Crypto AG</h2>&#13;
<p class="BodyFirst">The “Swiss” company known for literally being owned by the CIA and German intelligence between 1970 and 1994. It allowed the agencies to read the secret communications of several world governments.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>THE GREATEST BACKDOOR OF ALL TIME</h2>&#13;
<p class="BoxBodyFirst">Governments from Middle Eastern, African, and South American countries would buy encryption equipment from the neutral, supposedly trustworthy Swiss firm, worried that American vendors would spy on them. Unbeknownst to the governments, backdoors in the equipment allowed US intelligence to read all their communications. The NSA deputy director of operations once described the benefits of the operation as follows, allegedly in the late 1980s:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">The mere idea that we might lose any portion of the technical gain and, more importantly, the intelligence made possible by MINERVA is ­unthinkable . . .</p>&#13;
</blockquote>&#13;
<p class="BoxBodyContinued">(MINERVA was the codename for Crypto AG.)</p>&#13;
<p>Few technical details about the actual backdoors and their exploitation are publicly known. But we do know that, starting in the mid-1960s, Crypto AG’s encryption algorithms began relying on feedback shift registers (FSRs).</p>&#13;
<p><span epub:type="pagebreak" title="28" id="Page_28"/>Interestingly, the NSA used a backdoor technique that consists of choosing parameters in such a way that the output of the stream cipher created from the FSRs is partially predictable because of the existence of short cycles of patterns. In the context of linear FSRs, you can easily achieve this by picking characteristic polynomials with certain properties.</p>&#13;
<p>The story of Crypto AG is fascinating, from its foundation in 1952 by Swedish inventor Boris Hagelin to its early ties with the US government and its more recent personalizable encryption machines in the 2000s.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Crypto-period">Crypto period</h2>&#13;
<p class="BodyFirst">The lifetime of a key in some key management systems, such as the NSA’s EKMS. In pay-TV systems, the crypto period is the time during which the same control word (that is, the secret key) is used to encrypt audio and video content. Typical crypto periods are 5 and 10 seconds. These periods might seem short, but they’re not short enough to prevent some control-word sharing attacks, whereby the key from one legitimate subscriber is distributed to a large number of pirate boxes.</p>&#13;
<h2 id="Crypto-variable">Crypto variable</h2>&#13;
<p class="BodyFirst">The original name for cryptographic keys in the NSA. It was in use until the director of the NSA decided the agency should use the word <em>key</em> instead.</p>&#13;
<h2 id="Crypto-wars">Crypto wars</h2>&#13;
<p class="BodyFirst">A bellicose term referring to the open disagreements and debates between the US government (and governments of some other Western countries) on the one hand and activists, including researchers and privacy advocates, on the other. The governments wanted more control and surveillance capabilities, typically via proprietary algorithms, export control regulations, key escrow mechanisms, and so on; the latter parties pleading in favor of the right to develop and use any cryptographic mechanism as a way to support privacy rights.</p>&#13;
<h2 id="Cryptobiosis">Cryptobiosis</h2>&#13;
<p class="BodyFirst">Nothing to do with cryptography but fascinating nonetheless: a near-death state that certain living organisms can enter in response to adverse conditions. When danger subsides, the organisms can return to their original metabolic state. The tardigrade, sometimes used as an allegory for strong cryptography, can enter into cryptobiosis.</p>&#13;
<h2 id="Cryptocurrency"><span epub:type="pagebreak" title="29" id="Page_29"/>Cryptocurrency</h2>&#13;
<p class="BodyCustom">See <a href="#Crypto"><em>Crypto</em></a>.</p>&#13;
<h2 id="Crypto-Gram">Crypto-Gram</h2>&#13;
<p class="BodyFirst">The monthly cryptography digest by Bruce Schneier published since 1998.</p>&#13;
<h2 id="Cryptography">Cryptography</h2>&#13;
<p class="BodyCustom">See <a href="#Cryptology"><em>Cryptology</em></a>.</p>&#13;
<h2 id="Cryptologia"><em>Cryptologia</em></h2>&#13;
<p class="BodyFirst">Probably the oldest scholarly journal about cryptography; published since 1977.</p>&#13;
<h2 id="Cryptology">Cryptology</h2>&#13;
<p class="BodyCustom">See <a href="#Cryptography"><em>Cryptography</em></a>.</p>&#13;
<h2 id="Cryptonomicon"><em>Cryptonomicon</em></h2>&#13;
<p class="BodyFirst">A 1,000-page novel that references cryptography on about every other page. It was written by Neal Stephenson and was published in 1999. It’s not very Lovecraftian, despite what its title might suggest.</p>&#13;
<p>Unlike other books in which the crypto is mostly made up and laughably unrealistic, <em>Cryptonomicon</em> relies on historical facts and genuine cryptographic techniques. Readers might remember the cipher Solitaire (which Bruce Schneier created for the book) and the van Eck phreaking technique.</p>&#13;
<p class="BodyCustom">See <a href="#Solitaire"><em>Solitaire</em></a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>GETTING META</h2>&#13;
<p class="BoxBodyFirst">The <em>Cryptonomicon</em> is also a fictional book in the real book:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">They know enough, in other words, to understand that the Cryptonomicon is terribly important, and they have the wit to take the measures necessary to keep it safe. Some of them actually consult it from time to time, and use its wisdom to break Nipponese messages, or even solve whole cryptosystems.</p>&#13;
<p class="BoxExtractPara"><span epub:type="pagebreak" title="30" id="Page_30"/>(. . .)</p>&#13;
<p class="BoxExtractPara">the Cryptonomicon states that zeta functions are even today being used in cryptography, as sequence generators.</p>&#13;
</blockquote>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Cryptorchidism">Cryptorchidism</h2>&#13;
<p class="BodyFirst">A condition better kept confidential.</p>&#13;
<h2 id="Cryptovirology">Cryptovirology</h2>&#13;
<p class="BodyFirst">Popularized by the 2004 book <em>Malicious Cryptography: Exposing Cryptovirology</em>. The book describes cryptovirology as “the dark side of cryptography—that device developed to defeat Trojan horses, viruses, password theft, and other cyber-crime (. . .) the art of turning the very methods designed to protect your data into a means of subverting it.”</p>&#13;
<p class="BodyCustom">See <a href="#Kleptography"><em>Kleptography</em></a>.</p>&#13;
<h2 id="CRYPTREC">CRYPTREC</h2>&#13;
<p class="BodyFirst">The Japanese government’s Cryptography Research and Evaluation Commit­tees in charge of establishing official cryptography recommendations.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>CRYPTREC’S RECOMMENDED CIPHERS</h2>&#13;
<p class="BoxBodyFirst">As of 2020, CRYPTREC’s top tier is its <em>e-Government Recommended Ciphers</em> list, which includes the usual public-key schemes, AES and its usual modes, and the SHA-2 hash functions. In addition to AES, it recommends the block cipher Camellia, as well as the stream cipher KCipher-2.</p>&#13;
<p>The middle tier, or the <em>Candidate Recommended Ciphers</em> list, notably includes the five block ciphers CIPHERUNICORN, CLEFIA, Hierocrypt, MISTY1, and SC2000. It also includes the SHA-3 hash functions and XOFs, as well as the ChaCha20-Poly1305 authenticated cipher.</p>&#13;
<p>The lower tier, the <em>Monitored Ciphers List</em>, is a polite way of referring to algorithms you should avoid and includes the usual suspects: SHA-1 and 3DES (but not MD5), as well as RIPEMD160.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="CSIDH-Commutative-Supersingular-Isogeny-Diffie–Hellman">CSIDH (Commutative Supersingular Isogeny Diffie–Hellman)</h2>&#13;
<p class="BodyFirst">Pronounced <em>seaside</em>, the oldest isogeny-based scheme, revisited for efficiency. Also the only post-quantum scheme to have attracted some <span epub:type="pagebreak" title="31" id="Page_31"/>interest despite a well-known subexponential quantum attack. The proposed parameters “provide relatively little quantum security,” in the words of its cryptanalysts; however, its defenders point to its unique applications in the post-quantum arena, such as static key exchange. It’s not the same as SIDH.</p>&#13;
<p class="BodyCustom">See <a href="#Diffie%E2%80%93Hellman"><em>Diffie–Hellman</em></a>, <a href="#Post-quantum-cryptography"><em>Post-quantum cryptography</em></a>.</p>&#13;
<h2 id="CTF-capture-the-flag">CTF (capture the flag)</h2>&#13;
<p class="BodyFirst">A popular competition in the information security community. In the last 15 years, the crypto challenges presented in CTFs have evolved from Vigenère ciphers and visual puzzles to tasks involving state-of-the-art research. For example, participants in the 2020 edition of PlaidCTF had to break an isogeny-based cryptosystem (SIDH) and solve a multivariate system of equations.</p>&#13;
<h2 id="Cube-attack">Cube attack</h2>&#13;
<p class="BodyFirst">A type of higher-order differential cryptanalysis technique, described in 2008 to attack lightweight stream ciphers. The <em>cube</em> refers to the combination of bits over which to compute the higher-order differential, extending the notion of a 3D cube to arbitrary dimensions.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>WHEN CUBE ATTACKS WORK</h2>&#13;
<p class="BoxBodyFirst">In any cryptographic function, each output bit can be expressed as the result of evaluating a polynomial whose input terms are the input bits. If the function is cryptographically strong—and indistinguishable from a random function—this polynomial has exponentially more terms than the number of input bits and so is practically impossible to determine.</p>&#13;
<p>But if the function is cryptographically weak, that polynomial might be much simpler, with few terms, and only terms of low algebraic degree (that is, a sum of values that are either input bits or products of two or three input bits). In this case, attackers could use a variant of differential cryptanalysis to determine these terms. Eventually, the attacker could solve the equations to determine the value of secret key bits.</p>&#13;
<p>This is what cube attacks do. They were first applied to stream ciphers, which often rely on operations with low algebraic complexity, and thus might lead to cryptographic transforms of low algebraic degree.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Curve25519"><span epub:type="pagebreak" title="32" id="Page_32"/>Curve25519</h2>&#13;
<p class="BodyFirst">A reliable alternative to standardized elliptic curves, albeit somewhat clumsily named: <em>25519</em> doesn’t refer to the number 25519, but to 2<sup>255</sup> − 19, the number of elements in the finite field that Curve25519 is defined over. As a result, there are three types of cryptographers: the <em>twenty-five five nineteen</em> ones, the <em>two five five nineteen</em> ones, and the <em>two five five one nine</em> ones. Fortunately, the curve’s technical design is much better than its name thanks to its parameters optimized for speed and safe implementation, as well as its absence of unexplained constants, unlike in NIST curves.</p>&#13;
<p>You can use Curve25519 for Diffie–Hellman key agreement, signature, or encryption (via ECIES).</p>&#13;
<p class="BodyCustom">See <a href="#Ed25519"><em>Ed25519</em></a>, <a href="#X25519"><em>X25519</em></a>.</p>&#13;
<h2 id="Curve448">Curve448</h2>&#13;
<p class="BodyFirst">A lesser-known little sibling of Curve25519. It provides 224-bit security instead of 128-bit security due to its use of a finite field with 2<sup>448</sup> − 2<sup>224</sup> − 1 elements. Its signature and Diffie–Hellman primitives, Ed448 and X448, are supported in TLS 1.3.</p>&#13;
<p class="BodyCustom">See <a href="#Curve25519"><em>Curve25519</em></a>.</p>&#13;
<h2 id="Cypher">Cypher</h2>&#13;
<p class="BodyFirst">Alternative spelling of cipher used in pop culture. Its use is considered heresy in academic literature.</p>&#13;
<h1 id="letter-D"><span class="ChapterTitle">D</span></h1>&#13;
<h2 id="Daemon">Daemon</h2>&#13;
<p class="BodyFirst">A misspelling of the last name of Joan Daemen, who co-designed AES and SHA-3.</p>&#13;
<h2 id="Davies–Meyer">Davies–Meyer</h2>&#13;
<p class="BodyFirst">The most common technique to create a compression function from a block cipher (or keyed permutation). It’s used, for example, in MD5, <span epub:type="pagebreak" title="33" id="Page_33"/>SHA-1, and SHA-2. Instead of using the block cipher to encrypt as Enc(<em>K</em>, <em>M</em>), you use it to compress a message block <em>M </em>and a hash value <em>H </em>to obtain the new hash value Enc(<em>M</em>, <em>H</em>) <span class="NSSymbol">⊕</span><em>H</em>, where <em>M </em>acts as the cipher’s key. Alone, a compression function is a bit useless, but it’s easy to turn it into a proper hash function, using, for example, the Merkle–Damgård construction.</p>&#13;
<p>In practice, there’s no legitimate reason to build your own hash from a block cipher (as an exercise, figure out why it’s a bad idea to do so with AES in Davies–Meyer mode); yet the possible use of block ciphers to construct hash functions motivated cryptanalysts to investigate known-key and chosen-key attacks.</p>&#13;
<h2 id="Decentralized-private-computation">Decentralized private computation</h2>&#13;
<p class="BodyFirst">A combination of trusted execution and private blockchain token transfer.</p>&#13;
<h2 id="Déchiffrer">Déchiffrer</h2>&#13;
<p class="BodyFirst">French for <em>to decrypt</em> when you have the key.</p>&#13;
<h2 id="Décrypter">Décrypter</h2>&#13;
<p class="BodyFirst">French for <em>to decrypt</em> when you don’t have the key and thus must use cryptanalysis.</p>&#13;
<h2 id="Deniable-encryption">Deniable encryption</h2>&#13;
<p class="BodyFirst">Randomized public-key encryption where the encrypting party, if coerced to reveal the plaintext and randomness used, can choose different valid combinations of plaintext and randomness, thus preventing self-incrimination.</p>&#13;
<p>Deniable encryption can also loosely refer to systems where different keys can decrypt to different legitimate-looking plaintexts, again to dissimulate the real plaintext.</p>&#13;
<p>Although motivated by potential real-world problems, deniable encryption is usually not the solution to such problems.</p>&#13;
<h2 id="DES-Data-Encryption-Standard">DES (Data Encryption Standard)</h2>&#13;
<p class="BodyFirst">The first modern block cipher, standardized by NIST’s predecessor, the National Bureau of Standards. It’s broken by linear cryptanalysis more efficiently than brute force if you can find 2<sup>43</sup> plaintext/ciphertext pairs. If not, it’s now broken by design because of its too short keys.</p>&#13;
<h2 id="Dictionary"><span epub:type="pagebreak" title="34" id="Page_34"/>Dictionary</h2>&#13;
<p class="BodyFirst">A worthless book now that the internet exists.</p>&#13;
<h2 id="Dictionary-attack">Dictionary attack</h2>&#13;
<p class="BodyFirst">An attack that guesses passwords based on a list of words. Passwords have low entropy because they’re often composed of dictionary words and common proper nouns. An attacker can build a list of candidate passwords, ranked in order of popularity, and try them one after another, or in parallel, to find the password that hashes to the value they obtained from some password hash database.</p>&#13;
<h2 id="Differential-cryptanalysis">Differential cryptanalysis</h2>&#13;
<p class="BodyFirst">The class of cryptanalysis techniques that study the propagation of differences throughout internal computations to exploit some pattern or statistical bias in the output. Most of the attacks on symmetric cryptographic algorithms (block ciphers, hash functions, and so on) are some type of differential cryptanalysis.</p>&#13;
<p>The differences exploited might be taken between two input values or between more than two, as in higher-order cryptanalysis and its variants (integral cryptanalysis, cube attacks, and so on). A related technique, linear cryptanalysis, looks a bit different but is ultimately related to differential cryptanalysis. In addition, linear attacks often imply the possibility of pure differential attacks.</p>&#13;
<h2 id="Diffie–Hellman">Diffie–Hellman</h2>&#13;
<blockquote class="Epigraph">&#13;
<p class="Epigraph">Lots of people working in cryptography have no deep concern with real application issues. They are trying to discover things clever enough to write papers about.</p>&#13;
<p class="EpigraphSource">—Whitfield Diffie</p>&#13;
</blockquote>&#13;
<p class="BodyFirst">A fairly simple mathematical trick that is behind most key agreement protocols, and that indirectly powers many more cryptosystems.</p>&#13;
<p>You'll often find security proofs relying on the hardness of the Diffie–Hellman problem (given <em>g</em><sup><em>a</em></sup> and <em>g</em><sup><em>b</em></sup>, find <em>g</em><sup><em>ab</em></sup>) or variants thereof.</p>&#13;
<p>The <em>decisional</em> Diffie–Hellman problem (DDH) was called a “gold mine” by cryptographer Dan Boneh, and was leveraged to build encryption schemes (such as the Cramer–Shoup construction) as well as complex protocols such as threshold signature schemes.</p>&#13;
<p class="BodyCustom">See <a href="#New-Directions-in-Cryptography"><em>New Directions in Cryptography</em></a>.</p>&#13;
<h2 id="Disclosure"><span epub:type="pagebreak" title="35" id="Page_35"/>Disclosure</h2>&#13;
<p class="BodyFirst">More effective when the vulnerability is named with a clever acronym and accompanied by a nifty website, including a Q&amp;A and a logo. Researchers first took this approach to tell the world about Heartbleed; then they used it to describe subsequent attacks on SSL/TLS. This allowed them to better communicate the new vulnerability (and spend less time responding to emails from journalists). Notable examples include:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">BREACH</span>  Browser Reconnaissance and Exfiltration via Adaptive Compression of Hypertext</li>&#13;
<li><span class="RunInHead">CRIME</span>  Compression Ratio Info-leak Made Easy</li>&#13;
<li><span class="RunInHead">DROWN</span>  Decrypting RSA with Obsolete and Weakened eNcryption</li>&#13;
<li><span class="RunInHead">POODLE</span>  Padding Oracle On Downgraded Legacy Encryption</li>&#13;
<li><span class="RunInHead">ROBOT</span>  Return Of Bleichenbacher’s Oracle Threat</li>&#13;
</ol>&#13;
<h2 id="Discrete-logarithm-problem">Discrete logarithm problem</h2>&#13;
<p class="BodyFirst">The problem of finding <em>d </em>in <em>y </em>= <em>x</em><sup><em>d</em></sup> mod <em>p </em>for a prime <em>p</em>, or in <em>dG </em>= <em>P </em>in elliptic-curve groups of points. The discrete logarithm problem is now the most important computational problem in cryptography, before factoring, because Diffie–Hellman–like protocols have become more common than RSA and Paillier cryptosystems.</p>&#13;
<h2 id="Distinguisher">Distinguisher</h2>&#13;
<p class="BodyFirst">An algorithm used in attacks against a scheme’s indistinguishability. For example, if you find a statistical bias in the output of a pseudo­random generator, that bias would serve as a distinguisher, thereby breaking the PRNG.</p>&#13;
<p class="BodyCustom">See <a href="#Indistinguishability"><em>Indistinguishability</em></a>.</p>&#13;
<h2 id="Distributed-randomness">Distributed randomness</h2>&#13;
<p class="BodyFirst">Randomness generated by a group of parties that don’t necessarily trust each other; therefore, they don’t want any party to be capable of influencing the outcome. In this context, a simple protocol such as performing an XOR of each participant’s random contribution isn’t secure. The reason is that the last contributor can set their value to one that, <span epub:type="pagebreak" title="36" id="Page_36"/>when XORed with the combination of all previous values, produces the result they want to be returned. Publishing commitments in advance partially addresses the problem.</p>&#13;
<h2 id="Dolev–Yao-model">Dolev–Yao model</h2>&#13;
<p class="BodyFirst">The first formal model for defining cryptographic protocols. Also a symbolic framework for describing and analyzing their security. Cryptographers sometimes refer to the Dolev–Yao model when they mean the <em>active attacker adversarial model</em>—that is, the model wherein the attacker can eavesdrop, intercept, and modify data transmitted. But the Dolev–Yao model is more than that: it’s a general symbolic framework to describe and analyze protocols’ security.</p>&#13;
<h2 id="Double-ratchet">Double ratchet</h2>&#13;
<p class="BodyFirst">A subprotocol of the Signal messaging protocol. It determines each ­message’s unique keys in such a way that an attacker who knows the message keys at a given time can determine neither past nor future message keys, thereby providing forward secrecy and some form of backward secrecy.</p>&#13;
<p class="BodyCustom">See <a href="#Signal-protocol"><em>Signal protocol</em></a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>ONE RATCHET, TWO RATCHETS</h2>&#13;
<p class="BoxBodyFirst">The double ratchet is a highly stateful protocol. It’s called <em>double</em> because it combines two techniques:</p>&#13;
<ul>&#13;
<li>The <em>symmetric-key ratchet</em>, which maintains a hash chain from which message keys are derived.</li>&#13;
<li>The <em>Diffie–Hellman ratchet</em>, which performs Diffie–Hellman key exchanges with ephemeral key pairs to make future states unpredictable.</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Dragonfly">Dragonfly</h2>&#13;
<p class="BodyFirst">PAKE defined for the authentication standard EAP-pwd used in the Wi-Fi security suite WPA3. Attackers can bypass implementations of Dragonfly by exploiting the timing side channels in the hash-to-curve operations.</p>&#13;
<p class="BodyCustom">See <a href="#PAKE-password-authenticated-key-exchange"><em>PAKE (password-authenticated key agreement)</em>.</a></p>&#13;
<h2 id="DRBG-deterministic-random-bit-generator"><span epub:type="pagebreak" title="37" id="Page_37"/>DRBG (deterministic random bit generator)</h2>&#13;
<p class="BodyFirst">An oxymoronic-sounding term referring to a component that deterministically generates a long string of random-looking bits when given some actually random value (called a <em>seed</em>, a <em>key</em>, or sometimes just <em>entropy</em>). An operating system’s random generator usually includes an entropy extraction mechanism that generates some unpredictable bits from some analog source and pushes these bits to an entropy pool from which a DRBG takes its seed.</p>&#13;
<p>A DRBG is different from a PRNG; the terms PRBG and DRNG are rarely used.</p>&#13;
<p class="BodyCustom">See <a href="#Pseudorandom-number-generator-PRNG"><em>Pseudorandom generator (PRNG)</em></a>.</p>&#13;
<h2 id="DSA-Digital-Signature-Algorithm">DSA (Digital Signature Algorithm)</h2>&#13;
<p class="BodyFirst">The public-key signature scheme designed and patented by the NSA. It was standardized as part of the DSS (Digital Signature Standard) in 1991. This choice drew some criticism to which NIST responded as follows in the magazine <em>Federal Computer Week</em>:</p>&#13;
<p class="ExtractPara">NIST made the final choice. We obtained technical assistance from NSA, and we received technical inputs from others as well, but [NIST] made the final choice.</p>&#13;
<p>At the time, the criticisms of DSA were about its efficiency, incompleteness (it didn’t specify a hash function), risk of patent infringement, and security.</p>&#13;
<p class="BodyCustom">See <a href="#DSS-Digital-Signature-Standard"><em>DSS (Digital Signature Standard)</em></a>.</p>&#13;
<h2 id="DSS-Digital-Signature-Standard">DSS (Digital Signature Standard)</h2>&#13;
<p class="BodyFirst">The name of the NIST standard about digital signatures; not a single algorithm.</p>&#13;
<p>In 1982, NIST (then called the NBS) published a “Solicitation for Public Key Cryptographic Algorithms.” NIST later did the same for block ciphers and hash functions, resulting in the AES and SHA-3 standards. In 1987, NIST cancelled the DSS project upon request from the NSA. The standardization effort later resumed, leading to several standards established in 1991, including the NSA-designed DSA.</p>&#13;
<p>DSS is also the abbreviation of the sodium trimethylsilylpropane­sulfonate chemical compound, which is somehow related to cryptography.</p>&#13;
<h2 id="DVB-CSA"><span epub:type="pagebreak" title="38" id="Page_38"/>DVB-CSA</h2>&#13;
<p class="BodyFirst">The Common Scrambling Algorithm: an algorithm standardized by the Digital Video Broadcasting consortium to protect video content in pay-TV systems, typically by encrypting MPEG transport stream packets.</p>&#13;
<p class="BodyCustom">See <a href="#Control-word"><em>Control word</em></a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>VERSIONS OF DVB-CSA</h2>&#13;
<p class="BoxBodyFirst">The first version of the DVB-CSA standard, called <em>CSA1</em>, combines a stream cipher and a block cipher, and has a 48-bit key. CSA2 is similar but has a longer key of 64 bits. If these key sizes sound short to you, keep in mind that for most live content, the key usually changes every 5 or 10 seconds.</p>&#13;
<p>CSA3 is very different. Although its full design isn’t public, it’s known to combine AES with another (patented) block cipher running in some unusual operation mode. Additionally, it includes components designed to prevent software emulation. Per its design, CSA3 should run in dedicated hardware circuits only, like those found in the systems-on-chip of set-top boxes.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h1 id="letter-E"><span class="ChapterTitle">E</span></h1>&#13;
<h2 id="E0">E0</h2>&#13;
<p class="BodyFirst">A stream cipher used in Bluetooth. Broken in theory but not in practice. The more recent Bluetooth Low Energy standard uses AES-CCM instead.</p>&#13;
<h2 id="ECB-electronic-codebook">ECB (electronic codebook)</h2>&#13;
<p class="BodyFirst">The most obvious way to use a block cipher, where each block is processed independently of the others. ECB is the most robust mode against repeated IVs and nonces. But everybody knows ECB is insecure because you can see the penguin.</p>&#13;
<h2 id="ECC">ECC</h2>&#13;
<p class="BodyFirst">An acronym for either elliptic-curve cryptography or error-correcting code, depending on the context; confusion between the two can lead to unfortunate situations.</p>&#13;
<p class="BodyCustom">See <a href="#Elliptic-curve-cryptography"><em>Elliptic-curve cryptography</em></a>.</p>&#13;
<h2 id="ECDLP-Elliptic-curve-discrete-logarithm-problem"><span epub:type="pagebreak" title="39" id="Page_39"/>ECDLP (Elliptic-curve discrete logarithm problem)</h2>&#13;
<p class="BodyFirst">Arguably the most important computational problem as far as cryptographic security is concerned: given the points <em>P </em>and <em>xP</em>, find the number <em>x</em>, where multiplication happens in the group of an elliptic curve over a finite field.</p>&#13;
<p>Elliptic-curve schemes have replaced many instances of RSA or classical Diffie–Hellman, for example, in the TLS 1.3 standard.</p>&#13;
<h2 id="ECDSA-Elliptic-curve-DSA">ECDSA (Elliptic-curve DSA)</h2>&#13;
<p class="BodyFirst">The elliptic-curve counterpart of DSA, whose security requires the hardness of ECDLP, but is not totally equivalent to it. As far as we know, ECDLP’s hardness only implies ECDSA’s security (unforgeability) in the generic group model, which is an abstraction of ECDSA but not exactly ECDSA. </p>&#13;
<p class="BodyCustom">See <a href="#DSA-Digital-Signature-Algorithm"><em>DSA (Digital Signature Algorithm)</em></a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>ECDSA IN THE PLAYSTATION 3</h2>&#13;
<p class="BoxBodyFirst">Many people first learned about the ECDSA algorithm after attackers discovered that the PlayStation 3 used a weak implementation of it. The implementation’s nonce—an argument supposed to be unique for each signature, typically by being chosen at random—remained the same, allowing the attackers to easily retrieve the private key.</p>&#13;
<p>(Spoiler: the key was 46 DC EA D3 17 FE 45 D8 09 23 EB 97 E4 95 64 10 D4 CD B2 C2.)</p>&#13;
<p>Those who missed the PS3 hack later discovered ECDSA as the signature algorithm in Bitcoin and Ethereum, where ECDSA keys were sometimes also compromised because of repeated or biased nonces in flawed wallet software.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="ECIES-Elliptic-curve-IES">ECIES (Elliptic-curve IES)</h2>&#13;
<p class="BodyFirst">The elliptic-curve version of the IES public-key encryption scheme. Like IES, ECIES is a hybrid encryption scheme, therefore it needs a symmetric cipher to actually encrypt messages.</p>&#13;
<p class="BodyCustom">See <a href="#IES-Integrated-Encryption-Scheme"><em>IES (Integrated Encryption Scheme)</em></a>.</p>&#13;
<h2 id="Ed25519"><span epub:type="pagebreak" title="40" id="Page_40"/>Ed25519</h2>&#13;
<p class="BodyFirst">EdDSA signatures using Curve25519’s Edwards representation rather than the Montgomery format used by X25519, which causes developers a lot of headaches.</p>&#13;
<p class="BodyCustom">See <a href="#Curve25519"><em>Curve25519</em></a>, <a href="#EdDSA"><em>EdDSA</em></a>.</p>&#13;
<h2 id="EdDSA">EdDSA</h2>&#13;
<p class="BodyFirst">A deterministic elliptic-curve signature scheme based on Schnorr’s scheme. The main alternative to the ECDSA standard. In its purest form, it’s resilient to non-collision-resistant hash functions and is famously used by Ed25519.</p>&#13;
<h2 id="EKMS-Electronic-Key-Management-System">EKMS (Electronic Key Management System)</h2>&#13;
<p class="BodyFirst">A legacy key management system designed by NSA to secure communications for the US Army and other organizations.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>TOO MANY KEYS</h2>&#13;
<p class="BoxBodyFirst">If you thought key management for web applications was hard, wait until you have to do it in an environment with different classification levels, networks, device types, data management policies, and staff training.</p>&#13;
<p>The following (incomplete) list of EKMS key abbreviations illustrates the complexity of managing keys in its target environments:</p>&#13;
<ul>&#13;
<li>AEK: Algorithmic encryption key</li>&#13;
<li>KEK: Key encryption key</li>&#13;
<li>KPK: Key production key</li>&#13;
<li>OWK: Over the wire key</li>&#13;
<li>TEK: Traffic encryption key</li>&#13;
<li>TrKEK: Transmission key encryption key</li>&#13;
<li>TSK: Transmission security key</li>&#13;
</ul>&#13;
<p class="BoxBodyContinued">The system classifies keys depending on their role (operational, maintenance, or test). Operational keys, in turn, can have a variety of different attributes: they can be emergency contingency keys, joint theater keys, or allied keys, among others.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Electronic-codebook"><span epub:type="pagebreak" title="41" id="Page_41"/>Electronic codebook</h2>&#13;
<p class="BodyFirst">A cipher, in archaic NSA parlance. For example: “Electronic codebooks, such as the Advanced Encryption Standard, are both widely used and difficult to attack cryptanalytically.”</p>&#13;
<h2 id="ElGamal">ElGamal</h2>&#13;
<p class="BodyFirst">For many years, the only public-key encryption scheme used and taught in crypto classes other than RSA. Introduced in the 1985 article “A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms,” which modestly started with the following abstract:</p>&#13;
<p class="ExtractPara">A new signature scheme is proposed together with an implementation of the Diffie–Hellman key distribution scheme that achieves a public key cryptosystem. The security of both systems relies on the difficulty of computing discrete logarithms over finite fields.</p>&#13;
<p>ECDSA eventually overshadowed the signature scheme, and currently, ElGamal encryption is rarely used. Instead, cryptographers use ECIES except in applications in which the message must be directly public-key-encrypted (as in some e-voting systems).</p>&#13;
<p>The in-the-exponent variant of ElGamal encryption has two interesting properties: it is additively homomorphic, and decryption is impossible (unless you solve a discrete logarithm problem). Despite the latter suboptimal property, this version proved useful in threshold signature schemes.</p>&#13;
<h2 id="Elligator">Elligator</h2>&#13;
<p class="BodyFirst">A method of encoding elliptic-curve points as random-looking strings to make public keys indistinguishable from encrypted data.</p>&#13;
<h2 id="Elliptic-curve">Elliptic curve</h2>&#13;
<p class="BodyFirst">Not an ellipsis, not a curved line. A set of points on the plane whose (<em>x</em>, <em>y</em>) coordinates satisfy the curve’s equation, which usually has the form <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax </em>+ <em>b</em>, where <em>a </em>and <em>b </em>are fixed parameters. Crypto­graphic applications only work with points whose coordinates belong to some finite field; therefore, the curve has a finite set of points.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="42" id="Page_42"/>FROM MATH TO CRYPTO</h2>&#13;
<p class="BoxBodyFirst">Elliptic curves were, of course, discovered before cryptography, and mathematicians studied them much earlier. For example, elliptic curves played a role in the proof of Fermat’s Last Theorem.</p>&#13;
<p>Cryptography takes advantage of the fact that an elliptic curve’s points happen to form a group structure with respect to a geometrically defined group operation, denoted as point addition. For well-chosen curve types, the equivalent of the discrete logarithm problem becomes difficult in such groups, which is why these curves prove useful in public-key cryptography.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Elliptic-curve-cryptography">Elliptic-curve cryptography</h2>&#13;
<p class="BodyFirst">Public-key cryptography relying on elliptic curves and related hardness problems (the discrete logarithm, or a variant thereof). Elliptic-curve cryptography can do almost everything that legacy public-key cryptography can do, in a way that is often faster and uses shorter keys. That includes encryption, key agreement, and signature. In addition, you can use it for more exotic cryptographic schemes due to its support of pairings.</p>&#13;
<p class="BodyCustom">See <a href="#Pairing-based-cryptography"><em>Pairing-based cryptography</em></a>.</p>&#13;
<h2 id="Encipherment">Encipherment</h2>&#13;
<p class="BodyFirst">A synonym of encryption with emphasis on the act and operations carried out during the encryption process. <em>To encipher</em>, like the French verb <em>chiffrer</em>, comes from the Arabic <span class="Arabic">رفص</span> (<em>sifr</em>, the digit zero), whereas <em>to encrypt</em>, like the verb <em>crypter</em>, comes from the Greek <em>kryptos </em>(concealed, secret).</p>&#13;
<h2 id="End-to-end-encryption-E2EE">End-to-end encryption (E2EE)</h2>&#13;
<p class="BodyFirst">Encryption is said to be end-to-end when only the dedicated recipient(s) can decrypt the messages. It sounds straightforward but is actually an arduous engineering problem. </p>&#13;
<p>As usual in cryptography, the hard part of such a system is key management and distribution, not the actual encryption, which is why many E2EE systems need a central server. Many E2EE systems also rely on trust-but-verify mechanisms and are only end-to-end as long as participants perform some manual verification, such as checking a conversation’s fingerprint.</p>&#13;
<p><span epub:type="pagebreak" title="43" id="Page_43"/> In addition, E2EE systems sometimes ultimately rely on a central CA to enable trusted TLS connections (which you can think of as simply end-to-end encryption over the transport layer rather than the application layer).</p>&#13;
<h2 id="Enigma">Enigma</h2>&#13;
<p class="BodyFirst">The electromechanical encryption machine used by the Nazis during World War II. The Enigma was analyzed by Polish and British cryptanalysts, including Alan Turing, using techniques that researchers would later rediscover and call differential cryptanalysis, related-key attacks, and side-channel attacks.</p>&#13;
<h2 id="Entropy">Entropy</h2>&#13;
<p class="BodyFirst">A notion introduced around 1865 by Rudolf Clausius, arguably the founder of modern thermodynamics. But entropy wasn’t named until three years after his first formalization of the second law of thermodynamics (which states that entropy, at a microscopic level, cannot decrease in a closed system). Claude Shannon’s concept of information entropy came much later in his famous 1948 paper. Cryptography uses information entropy to assess a cryptosystem’s security by quantifying its amount of uncertainty.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>INFORMATION ENTROPY</h2>&#13;
<p class="BoxBodyFirst">Entropy is a property of a probability distribution, not of any particular value in that distribution. That is why asking about the entropy of some random-looking value makes no sense unless you know how this value was chosen and from which distribution.</p>&#13;
<p>In the context of information theory, Shannon’s entropy of some random variable <em>X </em>is defined as</p>&#13;
<figure class="graphic">&#13;
<img src="Images/g01001.jpg" alt="g01001" width="164" height="54"/>&#13;
</figure>&#13;
<p class="BoxBodyContinued">over a finite set of observables <em>n</em>, where <em>P</em><sub>n</sub><em> </em>is the probability of the event <em>n</em>.</p>&#13;
<p>In the case of a continuous random variable, we can extend the entropy definition to</p>&#13;
<figure class="graphic">&#13;
<img src="Images/g01002.jpg" alt="g01002" width="154" height="53"/>&#13;
</figure>&#13;
<p class="BoxBodyContinued"><span epub:type="pagebreak" title="44" id="Page_44"/>where <em>P</em>(<em>x</em>) is the variable’s density function, and <em>S</em> is the support set of the random variable.</p>&#13;
<p>When a symmetric cipher has an <em>n</em>-bit key, where all <em>n</em>-bit values are valid and equiprobable through key generation, a random key’s entropy is <em>n</em>. In ­public-key schemes, the entropy of a private key will rarely be equal to its encoding’s bit length, because not all values of that length might be valid keys.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="ePrint">ePrint</h2>&#13;
<p class="BodyFirst">Officially the Cryptology ePrint Archive, at <a href="https://eprint.iacr.org/" class="LinkURL">https://eprint.iacr.org/</a>. A website where cryptography researchers can post their papers online prior to formal, double-blind, peer-reviewed publication and be sure they’ll be noticed. Most cryptography researchers check the new papers published on ePrint at least once a week.</p>&#13;
<h2 id="Erathosthenes’-sieve">Erathosthenes’ sieve</h2>&#13;
<p class="BodyFirst">A method of enumerating all prime numbers up to some upper bound; a 2,000-year-old algorithm typically taught in high school. It was rediscovered during the Black Hat 2019 conference.</p>&#13;
<h2 id="eSTREAM">eSTREAM</h2>&#13;
<p class="BodyFirst">A cryptography competition, officially a <em>project</em>, organized by the EU-funded ECRYPT project between 2004 and 2008. Of the 34 submitted ciphers, eight made it to the final portfolio, which included two categories: software (those with 128-bit keys) and hardware (those with 80-bit keys). By far the most successful design from eSTREAM is Salsa20, a cipher that later evolved to ChaCha20, which became central to the BLAKE family of hash functions. Of the other portfolio ciphers, Trivium and Grain (or variants thereof) are used in niche applications, and F-FCSR was broken.</p>&#13;
<p class="BodyCustom">See <a href="#Grain"><em>Grain</em></a>, <a href="#Salsa20"><em>Salsa20</em></a>, <a href="#Trivium"><em>Trivium</em></a>.</p>&#13;
<h2 id="Ethereum">Ethereum</h2>&#13;
<p class="BodyFirst">An important blockchain platform for decentralized applications, such as tokens. Ethereum has led to some of the most interesting cryptography research and open problems, based on novel challenges faced by their unique decentralized deployment, adversarial model, and Turing-complete functionality. For example, consider the following, <span epub:type="pagebreak" title="45" id="Page_45"/>all of which are admittedly more exciting than yet another new block cipher: proof-of-stake security, smart contract formal verification, atomic swaps, and sharding.</p>&#13;
<h2 id="Eurocrypt">Eurocrypt</h2>&#13;
<p class="BodyFirst">Europe’s largest academic cryptography conference, held every spring in a different European location since 1987. Researchers present peer-reviewed research papers with titles such as “Indistinguishability Obfuscation Without Multilinear Maps: New Methods for Bootstrapping and Instantiation” and “A Quantum-Proof Non-Malleable Extractor with Application to Privacy Amplification Against Active Quantum Adversaries.”</p>&#13;
<p class="BodyCustom">See <a href="#ASIACRYPT"><em>Asiacrypt</em></a>, <a href="#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems"><em>CHES</em></a>, <a href="#CRYPTO"><em>CRYPTO</em></a>, <a href="#FSE-Fast-Software-Encryption"><em>FSE</em></a>, <a href="#PKC"><em>PKC</em></a>, <a href="#Real-World-Crypto-RWC"><em>Real World Crypto</em></a>, <a href="#TCC"><em>TCC</em></a>.</p>&#13;
<h2 id="Eve">Eve</h2>&#13;
<p class="BodyFirst">Alice and Bob’s nemesis.</p>&#13;
<p class="BodyCustom">See <a href="#Alice"><em>Alice</em></a>, <a href="#Bob"><em>Bob</em></a>.</p>&#13;
<h2 id="E-voting">E-voting</h2>&#13;
<p class="BodyFirst">A topic that cryptographers like to publish papers about but don’t like to see deployed in reality because it’s perceived as unacceptably risky. E-voting is nonetheless cryptographically fascinating. It involves nontrivial cryptography, such as homomorphic encryption schemes used to encrypt ballots and aggregate them in a privacy-preserving way, and noninteractive zero-knowledge proofs, which are used to prove a vote’s correctness.</p>&#13;
<h1 id="letter-F"><span class="ChapterTitle">F</span></h1>&#13;
<h2 id="Factoring-problem">Factoring problem</h2>&#13;
<p class="BodyFirst">Given <em>n </em>= <em>pq</em>, find the primes <em>p </em>and <em>q</em>. Easy to solve if you have a large enough quantum computer.</p>&#13;
<h2 id="Feedback-shift-register"><span epub:type="pagebreak" title="46" id="Page_46"/>Feedback shift register</h2>&#13;
<p class="BodyFirst">An array of values, usually bits or bytes, that updates by shifting the values over and then filling the empty slot with the result of some function of the previous state’s values. Historically, this cipher mechanism came after electromechanical machines and preceded modern ciphers. It’s still used in some hardware-oriented algorithms and in the mobile communication standard SNOW 3G.</p>&#13;
<p>There are two kinds of feedback shift registers. In linear ones (LFSRs), this update function is linear, which renders the output predictable but can also provide guarantees that the period of LFSR is maximal. In nonlinear ones (NFSRs), after a few cycles of updates, the output values are highly nonlinear functions of the initial state, but guarantees on the period are difficult to compute. Concretely, linear update functions only do additions, whereas nonlinear ones do additions and multiplications.</p>&#13;
<p>A good design strategy is to combine LFSRs and NFSRs. </p>&#13;
<p class="BodyCustom">See <a href="#Grain"><em>Grain</em></a>, <a href="#SNOW-3G"><em>SNOW 3G</em></a>, <a href="#Trivium"><em>Trivium</em></a>.</p>&#13;
<h2 id="Feistel-network">Feistel network</h2>&#13;
<p class="BodyFirst">A method of constructing a block cipher from a smaller block cipher or hash function. It works by splitting the message block in two halves, <em>L </em>and <em>R</em>,<em> </em>and updating it by repeatedly replacing (<em>L</em>, <em>R</em>) with (<em>R</em>, <em>L </em><span class="NSSymbol">⊕</span><em>f</em>(<em>R</em>)), where <em>f</em>() is the smaller function and can take a secret value as a parameter. Feistel network is sometimes called <em>Luby–Rackoff construction</em> after the researchers who formally analyzed its security. The XOR operation can be replaced by another group operation.</p>&#13;
<p class="BodyCustom">See <a href="#DES-Data-Encryption-Standard"><em>DES (Data Encryption Standard)</em></a>, <a href="#Lucifer"><em>Lucifer</em></a>.</p>&#13;
<h2 id="Fialka-Фиалка">Fialka (Фиалка)</h2>&#13;
<p class="BodyFirst">The Soviet counterpart to the Enigma machine created after World War II. Unlike Western encryption machines, Фиалка supported Cyrillic characters.</p>&#13;
<h2 id="Fiat–Shamir">Fiat–Shamir</h2>&#13;
<p class="BodyFirst">A technique for turning an interactive proof (a protocol between a prover and a verifier that involves multiple rounds) into a noninteractive one (a single message from the prover) using hash functions.</p>&#13;
<h2 id="FIPS-140-2"><span epub:type="pagebreak" title="47" id="Page_47"/>FIPS 140-2</h2>&#13;
<p class="BodyFirst">A set of security requirements for cryptographic modules (software or hardware), established by NIST in 2001. It’s been superseded by FIPS 140-3 since 2019.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>WHAT FIPS 140-2 REALLY MEANS</h2>&#13;
<p class="BoxBodyFirst">When a vendor says “We are FIPS 140-2 certified,” the statement can have one of two meanings: “We have applied for the certification,” or, ideally, “We have received the certification.”</p>&#13;
<p>The latter case can also have different meanings:</p>&#13;
<ul>&#13;
<li>Level 1: Correctness of the FIPS-approved algorithms.</li>&#13;
<li>Level 2: Level 1 plus some tamper evidence—for example, the ability to detect physical attacks after they occur by observing broken seals on the box.</li>&#13;
<li>Level 3: Level 2 plus some tamper detection—for example, the platform’s ability to detect physical attacks in real time and reset itself to factory mode if it believes it’s under attack. This level also includes some physical isolation and stronger authentication.</li>&#13;
<li>Level 4: Level 3 plus some stronger tamper detection with the guarantee that the module will detect most physical attack attempts and reset itself when under attack (for instance, by zeroizing secrets).</li>&#13;
</ul>&#13;
<p class="BoxBodyContinued">It’s worth noting that FIPS 140-2 doesn’t measure a system’s resilience to physical attacks so much as the system’s ability to detect them. This acknowledges that most systems are vulnerable to physical attacks given the right equipment.</p>&#13;
<p>Additionally, the fact that a system is FIPS 140-2 certified doesn’t mean that it’s perfectly secure. The reason is that 1) FIPS 140-2 is limited by its scope and by the definition of the security requirements of each of its levels, and 2) even in a certified product, the certification usually only applies the cryptographic module (and sometimes only parts of it). In other words, if some application calls a FIPS 140-2 Level 3 module to encrypt some message, and the application’s software has a flaw that leaks said plaintext, don’t blame the certification.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="FIPS-140-3">FIPS 140-3</h2>&#13;
<p class="BodyFirst">New version of FIPS 140-2 since 2019. It introduces requirements against noninvasive attacks and the concepts of <em>Normal Operation</em> and <em>Degraded Operation</em>, among others.</p>&#13;
<p class="BodyCustom">See <a href="#FIPS-140-2"><em>FIPS 140-2</em></a>.</p>&#13;
<h2 id="Forgery"><span epub:type="pagebreak" title="48" id="Page_48"/>Forgery</h2>&#13;
<p class="BodyFirst">An attack whose goal is not to recover some secret but to create a supposedly hard-to-generate value without the knowledge of some secret. Unforgeability is the corresponding security notion and is most commonly associated with signatures and MACs. More generally, unforgeability must apply to any scheme for which an attacker should have trouble creating a valid output. These include ciphertexts in authentication encryption and zero-knowledge proof protocol transcripts.</p>&#13;
<p>Sometimes forgeability is a desirable property (for example, to achieve deniability.</p>&#13;
<h2 id="Formal-verification">Formal verification</h2>&#13;
<p class="BodyFirst">A form of testing that relies on mathematical guarantees. Applied to security protocols, formal verification includes symbolic and computational verification techniques, which assess whether a protocol satisfies properties such as confidentiality and authentication. Another example is programming languages that can certify that an implementation is functionally correct with respect to a specification, or that it’s free of certain classes of side channels.</p>&#13;
<p>High-assurance applications often receive some sort of formal verification, such as the Common Criteria security evaluation framework’s EAL7 assurance level. Still, don’t be fooled into thinking formal verification means <em>proof that everything about a crypto implementation is secure</em>.</p>&#13;
<h2 id="Format-preserving-encryption">Format-preserving encryption</h2>&#13;
<p class="BodyFirst">A type of encryption that produces a ciphertext with the same format as the original message. For example, the format-preserving encryption of a 16-digit credit card number would produce another 16-digit number. Format-preserving encryption is often useful for encrypting database entries whose field type must have a specific format, such as social security numbers, IP addresses, and ZIP codes. Although the problem sounds simple, it requires sophisticated techniques, especially for the more general problem of creating ciphers from arbitrary domains of values.</p>&#13;
<h2 id="Forward-secrecy">Forward secrecy</h2>&#13;
<p class="BodyFirst">The notion that something remains secure if something else is compromised at a later time. What counts as <em>something</em>, <em>something else</em>, and <em>a later time</em> depends on the context. Forward secrecy is usually a <span epub:type="pagebreak" title="49" id="Page_49"/>relevant security notion for key agreement protocols, secure messaging protocols (and their ratchetting mechanisms), pseudorandom generators, pseudorandom functions, MACs, and other stateful objects.</p>&#13;
<p>It’s usually easier to achieve forward secrecy than backward secrecy, because it’s easier to erase the past than to make the future unpredictable (in cryptography, at least).</p>&#13;
<p class="BodyCustom">See <a href="#Backward-secrecy"><em>Backward secrecy</em></a>.</p>&#13;
<h2 id="FOX">FOX</h2>&#13;
<p class="BodyCustom">See <a href="#IDEA-NXT"><em>IDEA NXT</em></a>.</p>&#13;
<h2 id="FSE-Fast-Software-Encryption">FSE (Fast Software Encryption)</h2>&#13;
<p class="BodyFirst">A conference focused on the design and cryptanalysis of symmetric cryptography primitives, including slow and hardware-oriented hash functions. FSE is sometimes viewed as an applied cryptography conference, despite the fact that it rarely focuses on real-world algorithms, let alone real-world attacks.</p>&#13;
<p>Researchers present peer-reviewed papers with titles such as “Improving the MILP-Based Security Evaluation Algorithm Against Differential/Linear Cryptanalysis Using a Divide-and-Conquer Approach” and “Low AND Depth and Efficient Inverses: A Guide on S-boxes for Low-Latency Masking.”</p>&#13;
<p class="BodyCustom">See <a href="#ASIACRYPT"><em>Asiacrypt</em></a>, <a href="#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems"><em>CHES</em></a>, <a href="#CRYPTO"><em>CRYPTO</em></a>, <a href="#Eurocrypt"><em>Eurocrypt</em></a>, <a href="#PKC"><em>PKC</em></a>, <a href="#Real-World-Crypto-RWC"><em>Real World Crypto</em></a>, <a href="#TCC"><em>TCC</em></a>.</p>&#13;
<h2 id="Fully-homomorphic-encryption">Fully homomorphic encryption</h2>&#13;
<p class="BodyCustom">See <a href="#Homomorphic-encryption"><em>Homomorphic encryption</em></a>.</p>&#13;
<h2 id="Functional-encryption">Functional encryption</h2>&#13;
<p class="BodyFirst">A type of cryptographic scheme that looks like magic: when designed for some function <em>f</em>(), decrypting Enc(<em>M</em>) yields not <em>M </em>but <em>f</em>(<em>M</em>). But like many of the magic cryptographic schemes, it’s of limited use in practice, because it can efficiently support only simple functionalities.</p>&#13;
<p>To build functional encryption schemes, cryptographers can use the trick of leveraging indistinguishability obfuscation: in other words, the decryption process that finds <em>f</em>(<em>M</em>) would consist of an obfuscated program that first retrieves <em>M</em> and then computes <em>f</em>(<em>M</em>) without ever exposing <em>M</em>.</p>&#13;
<h2 id="Future-secrecy"><span epub:type="pagebreak" title="50" id="Page_50"/>Future secrecy</h2>&#13;
<p class="BodyFirst">A term coined in the context of the Signal protocol to refer to a notion similar to backward secrecy. Indistinguishable from break-in recovery.</p>&#13;
<p class="BodyCustom">See <a href="#Backward-secrecy"><em>Backward secrecy</em></a>.</p>&#13;
<h2 id="Fuzzy-extractor">Fuzzy extractor</h2>&#13;
<p class="BodyFirst">A scheme for extracting the value of some high-entropy secret from multiple noisy readings, each with different random errors, to derive a key. This might sound a lot like an error-correcting code, but it’s different: first, the value read is not a codeword (which has redundancy in it and thus is suboptimal entropy), but instead is a value of potentially maximal entropy; second, the value is not read once but multiple times; and third, the enrollment data used to decode the secret must not leak information about said secret. Therefore, you can store it without privacy leaks.</p>&#13;
<p>You might find fuzzy extractors used in biometric authentication applications, which have to extract a value that uniquely identifies an individual. These applications typically must extract this value from noisy measurements and without relying on a database of sensitive data, such as data about each individual. Conversely, in a traditional approach to authentication, you would compare a new measurement to a registered one to identify a person.</p>&#13;
<h1 id="letter-G"><span class="ChapterTitle">G</span></h1>&#13;
<h2 id="Generalized-birthday-problem">Generalized birthday problem</h2>&#13;
<p class="BodyFirst">The problem of finding values <em>X</em><sub>1</sub>, . . . , <em>X</em><sub>k</sub> such that Hash(<em>X</em><sub>1</sub>) <span class="NSSymbol">⊕</span> · · · <span class="NSSymbol">⊕</span> Hash(<em>X</em><sub>k</sub>) = 0. The special case of a classical collision is that of finding two distinct values, such that Hash(<em>X</em><sub>1</sub>) <span class="NSSymbol">⊕</span> Hash(<em>X</em><sub>2</sub>) = 0. The <em>birthday attack</em> finds such pairs in <em>O</em>(2<sup><em>n</em></sup><sup>/2</sup>) queries to the hash function, where <em>n </em>is the output bit size.</p>&#13;
<p>In the generalized birthday problem, it’s easy to see that the larger the value <em>k</em>, the easier the problem. More precisely, the cost of a collision becomes O(<em>k2</em><sup>n/(1+log<sub>2</sub></sup><sup><sup><em>k</em></sup>)</sup>) time and space, or of the order of 2<sup><em>n</em></sup><sup>/3</sup> for <em>k </em>= 4.</p>&#13;
<h2 id="GNFS-General-Number-Field-Sieve"><span epub:type="pagebreak" title="51" id="Page_51"/>GNFS (General Number Field Sieve)</h2>&#13;
<p class="BodyFirst">The best (nonquantum) algorithm for factoring large integers.</p>&#13;
<h2 id="GOST">GOST</h2>&#13;
<p class="BodyFirst">The USSR national standard block cipher designed in the 1970s and included in the GOST 28147-89 standard series. Whereas the American DES cipher, designed in the same era, uses keys that are only 64 bits long, GOST works with 256-bit keys and comes with customizable S-boxes. Constructed as a Feistel network like DES, GOST hasn’t been meaningfully broken, although research papers have described some attacks against it that perform fewer than 2<sup>256</sup> operations. Russian authorities officially deprecated GOST in 2019. Its successor is the block cipher Кузнечик (Kuznyechik).</p>&#13;
<h2 id="Grain">Grain</h2>&#13;
<p class="BodyFirst">A family of minimalistic hardware-oriented stream ciphers: Grain (80-bit key), Grain 128, and Grain 128a (128-bit key).</p>&#13;
<h2 id="Gröbner-basis">Gröbner basis</h2>&#13;
<p class="BodyFirst">A canonical representation of a system of multivariate equations. Computing a Gröbner basis for a multivariate system is one of the possible definitions of “solving” it, because it can be used, for example, to find its numeric solutions.</p>&#13;
<p>The general problem of computing Gröbner bases is NP-hard. The actual time and memory required to compute one for a specific system of equations, as found in multivariate cryptography or in algebraic cryptanalysis, is usually large and hard to estimate: but when it’s not, it produces spectacular cryptanalyses.</p>&#13;
<h2 id="Group-signature">Group signature</h2>&#13;
<p class="BodyFirst">A signature scheme involving a group of potential signers. Any group member can issue a signature on behalf of the group, and a verifier can learn the identity of the group members but not of the actual signer. There’s an exception: groups must work with a trusted entity, called the <em>group manager</em>, which can trace signatures back to their original signer. Ring signatures don’t have this traceability property or the need for a group manager.</p>&#13;
<p class="BodyCustom">See <a href="#Ring-signature"><em>Ring signature</em></a>.</p>&#13;
<h2 id="Grover’s-algorithm"><span epub:type="pagebreak" title="52" id="Page_52"/>Grover’s algorithm</h2>&#13;
<p class="BodyFirst">A quantum algorithm that in theory can break symmetric ciphers in <em>O</em>(2<sup><em>n</em></sup><sup>/2</sup>) instead of <em>O</em>(2<sup><em>n</em></sup>) complexity, where <em>n </em>is the key length.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>GROVER: READ THE FINE PRINT</h2>&#13;
<p class="BoxBodyFirst">You might think that, as a result of Grover’s algorithm, ciphers with a 128-bit key would have only 64-bit security. But in reality, breaking a cipher wouldn’t become quadratically more cost-efficient, because of various reasons, including the following:</p>&#13;
<ul>&#13;
<li>Running Grover’s algorithm to break, say, AES would require a quantum implementation of AES, which is much slower and more costly than any conventional implementation.</li>&#13;
<li>Grover’s algorithm doesn’t appear to scale the way classical brute force does, in the sense that it can’t distribute computations across multiple units or attack multiple instances simultaneously.</li>&#13;
<li>The <em>O</em>() asymptotic notation hides constant factors that might prove non-negligible in reality.</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h1 id="letter-H"><span class="ChapterTitle">H</span></h1>&#13;
<h2 id="Hardcore-predicate">Hardcore predicate</h2>&#13;
<p class="BodyFirst">A key concept in the theoretical definition of one-way functions and permutations: for some one-way function <em>f</em>(), a hardcore predicate is some bit of information about an input <em>x</em> that is easy to compute from <em>x </em>but hard from <em>f</em>(<em>x</em>). By definition, you should be able to find a hardcore predicate for any given one-way function and its permutations.</p>&#13;
<h2 id="Hash-function">Hash function</h2>&#13;
<p class="BodyFirst">The simplest cryptographic object, and at first glance, the dumbest operation ever. A hash function takes a single input of any type, <span epub:type="pagebreak" title="53" id="Page_53"/>format, or size, and returns a single output that is a fixed size and looks totally unrelated to its input. Yet equipped with such a trivial tool, you can construct secure symmetric ciphers, pseudorandom generators, key derivation functions, and even public-key signatures, as well as a variety of security protocols.</p>&#13;
<h2 id="Hash-based-cryptography">Hash-based cryptography</h2>&#13;
<p class="BodyFirst">The most secure but slowest form of post-quantum cryptography. You can use hash functions to create various cryptographic objects, such as stream ciphers or pseudorandom generators. But when you hear <em>hash-based cryptography</em>, it refers to public-key signatures built from only hash functions.</p>&#13;
<p>Simple hash-based signatures, as proposed by Lamport, Merkle, and Winternitz in the late 1970s, have severe shortcomings. For example, you can use them only a limited number of times or only on very short messages. Like many problems in computer science, researchers have addressed the problem of scaling hash-based signatures by throwing trees, trees, and even more trees at it. This has notably led to the SPHINCS and XMSS designs.</p>&#13;
<p class="BodyCustom">See <a href="#SPHINCS"><em>SPHINCS</em></a>, <a href="#XMSS-eXtended-Merkle-Signature-Scheme"><em>XMSS</em></a>.</p>&#13;
<h2 id="Heartbleed">Heartbleed</h2>&#13;
<p class="BodyFirst">The bug in OpenSSL that revived interest in the security of TLS and its implementation. Ultimately, Heartbleed led to a safer OpenSSL, as well as the TLS 1.3 protocol.</p>&#13;
<h2 id="Hedged-signature">Hedged signature</h2>&#13;
<p class="BodyFirst">A type of signature that reintroduces randomness as a defense against fault attacks. Fault attacks affect signature schemes, such as EdDSA and deterministic ECDSA, that don’t need a random or unique value to be secure. (By contrast, ECDSA requires a fresh secret random value per signature.) Such derandomized signature schemes protect against poor randomness but have been shown to be vulnerable to fault attacks that partially exploit their determinism. Hedged signatures aim to correct this without allowing lower-quality randomness to reduce the scheme’s security. Such hedged signatures include the XEdDSA variant, as well as the post-quantum schemes qTESLA and Picnic2.</p>&#13;
<h2 id="HFE-Hidden-Field-Equations"><span epub:type="pagebreak" title="54" id="Page_54"/>HFE (Hidden Field Equations)</h2>&#13;
<p class="BodyFirst">A family of multivariate public-key schemes, including encryption and signature schemes. As modestly stated in the 1996 paper that introduced it, “the security of HFE is not proved but <em>apparently</em> it seems to be related to the problem of solving a system of multivariate quadratic equations over a finite field.”</p>&#13;
<h2 id="HMAC-Hash-based-MAC">HMAC (Hash-based MAC)</h2>&#13;
<p class="BodyFirst">For many developers, a synonym of <em>MAC</em>. Strictly speaking, however, an HMAC isn’t a MAC but a way to construct a MAC from a hash function.</p>&#13;
<p>For example, you can construct a MAC atop SHA-256, which is called <em>HMAC-SHA-256</em>. Keep in mind that HMACs are not the only—and not necessarily the best—ways of constructing MACs.</p>&#13;
<h2 id="Homomorphic-encryption">Homomorphic encryption</h2>&#13;
<p class="BodyFirst">An encryption that satisfies Dec(Enc(<em>M</em><sub>1</sub>) <span class="NSSymbol">⦾</span><span class="ColorText" style="color:#202122"/>Enc(<em>M</em><sub>2</sub>)) = <em>M</em><sub>1</sub><span class="NSSymbol">⦿</span><em>M</em><sub>2</sub> for some operators <span class="NSSymbol">⦾</span> and <span class="NSSymbol">⦿</span> that might be identical or distinct, and are usually some type of addition or multiplication. For example, encrypting a message with textbook RSA by doing <em>M</em><sup><em>d </em></sup>mod <em>n </em>for some message <em>M </em>is homomorphic with respect to multiplication: the ­product of two ­ciphertexts is the ciphertext of the product of the plaintexts.</p>&#13;
<p>Homomorphism can be a security issue and a feature, depending on the context. For example, certain e-voting systems leverage the homomorphic property of Paillier’s cryptosystem to aggregate ballots without decrypting them individually.</p>&#13;
<p>Fully homomorphic encryption is a more general and powerful property but is also harder to realize: a fully homomorphic encryption can be homomorphic with respect to any operation performed on the ciphertext instead of just a single group operation.</p>&#13;
<h2 id="HPC-Hasty-Pudding-Cipher">HPC (Hasty Pudding Cipher)</h2>&#13;
<p class="BodyFirst">A mostly forgotten block cipher submitted in 1998 to the AES competition. Its designer called it “the first Omni-Cipher: It can encrypt any blocksize with any keysize.”</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="55" id="Page_55"/>SPECIAL FEATURES OF THE HASTY PUDDING CIPHER</h2>&#13;
<p class="BoxBodyFirst">Unconventional yet innovative, HPC had several unique features as it was:</p>&#13;
<ul>&#13;
<li>The first tweakable block cipher (the tweak was then called the <em>spice</em> or the <em>secondary key</em>)</li>&#13;
<li>Optimized for 64-bit architectures and the fastest of all AES candidates on these</li>&#13;
<li>Able to support any key and block size</li>&#13;
<li>Composed of five subciphers: HPC-Tiny, -Short, -Medium, -Long, and -Extended</li>&#13;
</ul>&#13;
<p>The so-called <em>spice</em> anticipated some of the future needs for a tweak. As the specification comments:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">HPC’s spice is an important protection for short-block encryption: The spice can be different for every bit field, preventing dictionary attacks.</p>&#13;
</blockquote>&#13;
<p class="BoxBodyContinued">In addition, HPC’s designer foresaw that one of the main applications of encryption would be online videos:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">The most important future application for encryption will be for video communications, on stock hardware, which will be 64-bit machines. The Hasty Pudding Cipher is the fastest cipher for bulk encryption on 64-bit machines. (. . .) Performance in video applications is so important that HPC should be the primary AES choice.</p>&#13;
</blockquote>&#13;
<p class="BoxBodyContinued">Although it remains unbroken—only equivalent keys were found—HPC wasn’t selected as the AES and didn’t even make it to the second round. Its unorthodox design and lack of formal security arguments probably didn’t play in its favor.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="HSM-hardware-security-module">HSM (hardware security module)</h2>&#13;
<p class="BodyFirst">Hardware equipment dedicated to running cryptographic operations and other security tasks. HSMs can come in different form factors, such as rack servers or USB dongles. HSMs don’t necessarily run cryptographic operations using dedicated hardware (as in a dedicated silicon circuit). Actually, most of the time, they run all cryptography in software, executed by some general-purpose processor. The S in HSM <span epub:type="pagebreak" title="56" id="Page_56"/>refers to the functionality it implements; it doesn’t necessarily mean the HSM is more secure than a normal computer.</p>&#13;
<h2 id="HTTP-3">HTTP/3</h2>&#13;
<p class="BodyCustom">See <a href="#QUIC-Quick-UDP-Internet-Connections"><em>QUIC (Quick UDP Internet Connections)</em></a>.</p>&#13;
<h2 id="Hyperelliptic-curve-cryptography">Hyperelliptic-curve cryptography</h2>&#13;
<p class="BodyFirst">Like elliptic-curve cryptography but using a higher-dimensional object: the Jacobian of a hyperelliptic curve. We can’t explain what a Jacobian is in terms of anything else that is familiar to most readers, to paraphrase Richard Feynman.</p>&#13;
<p>The main advantage of hyperelliptic curves is that, owing to the additional dimensions, the same finite field generates larger groups than it would with an elliptic curve. This strength is also a weakness: when the number of dimensions becomes too high (usually more than three), discrete logarithms become easier.</p>&#13;
<h1 id="letter-I"><span class="ChapterTitle narrow">I</span></h1>&#13;
<h2 id="IACR-International-Association-for-Cryptologic-Research">IACR (International Association for Cryptologic Research)</h2>&#13;
<p class="BodyFirst">Cryptographers’ union, a nonprofit that organizes the largest academic cryptography conferences and manages the reference preprint platform ePrint.</p>&#13;
<h2 id="IDEA-International-Data-Encryption-Algorithm">IDEA (International Data Encryption Algorithm)</h2>&#13;
<p class="BodyFirst">A 64-bit block cipher from the early 1990s. One of the rare block ciphers that uses the Lai–Massey construction, not a Feistel or substitution–permutation network.</p>&#13;
<p>Despite a rather heuristic design approach, IDEA resisted cryptanalysis for years. The first attack against it that proved potentially faster than brute force didn’t appear until 2012. (This was a biclique attack with 2<sup>126</sup> operations.)</p>&#13;
<p>IDEA is one of the few ciphers that uses integer multiplication operations, which has some security benefits but makes protecting against side-channel attacks difficult.</p>&#13;
<h2 id="IDEA-NXT"><span epub:type="pagebreak" title="57" id="Page_57"/>IDEA NXT</h2>&#13;
<p class="BodyFirst">A block cipher with little similarity to IDEA except for their shared Lai–Massey construction. Also like IDEA, it was designed for the Mediacrypt AG company and patented. Initially named and published as FOX, IDEA NXT proved very useful in antipiracy initiatives, not only because of its cryptographic merits.</p>&#13;
<h2 id="Identity-based-encryption">Identity-based encryption</h2>&#13;
<p class="BodyFirst">A means of sending an encrypted message without knowing someone’s public key. For instance, when Alice wants to send an encrypted message to Bob but doesn’t know his public key, identity-based encryption (IBE) allows her to compute it using the name <em>Bob</em> and some master public key. The only caveat is that IBE requires a trusted third party, called the <em>key server</em>, which knows some master private key and uses it to generate users’ private keys. Bob therefore needs to authenticate to the key server, proving that he’s the real Bob, to receive his private key.</p>&#13;
<h2 id="IES-Integrated-Encryption-Scheme">IES (Integrated Encryption Scheme)</h2>&#13;
<p class="BodyFirst">A public-key encryption scheme that doesn’t involve a public-key encryption primitive. Instead, the sender chooses a random key pair, computes a Diffie–Hellman shared secret between the fresh private key and the recipient’s public key, derives a symmetric key from it, and encrypts the message with some authenticated cipher. Neither party performs a public-key operation to encrypt the data.</p>&#13;
<h2 id="Impatient-saboteur">Impatient saboteur</h2>&#13;
<p class="BodyFirst">In the Dolev–Yao model, an archetypal attacker who can transmit data but not receive it. Or in Dolev and Yao’s own words, “one who only initiates conversations (and does not rely on being spoken to.)”</p>&#13;
<h2 id="Impossibility">Impossibility</h2>&#13;
<p class="BodyFirst">Cryptographer Moti Yung once said, “When a software engineer says [a security engineering problem] is impossible, that really just means it’s cryptographically interesting.”</p>&#13;
<h2 id="Impossible-differential-attack">Impossible differential attack</h2>&#13;
<p class="BodyFirst">A differential attack that exploits abnormally unlikely events rather than abnormally likely ones. Differential cryptanalysis generally exploits patterns of unusually high probability that occur in the <span epub:type="pagebreak" title="58" id="Page_58"/>differences between outputs and inputs with a specific difference. Impossible differential attacks exploit the opposite type of pattern, namely those that have zero chance of being observed under certain conditions. If cryptanalysts notice these patterns, they can deduce that the condition doesn’t hold. This information could help recover a cipher’s secret key or subkey.</p>&#13;
<h2 id="IND-CCA">IND-CCA</h2>&#13;
<p class="BodyFirst">Indistinguishability of ciphertexts under chosen-ciphertext attacks. The strongest security notion for encryption schemes (both public-key and symmetric-key schemes). The chosen-ciphertext might intuitively make little sense in practice. The reason is that you’ll rarely find systems where attackers can decrypt any ciphertexts they want, but encryption that can do more can do less. In addition, there are cases in which you do have a decryption oracle, such as some DRM systems.</p>&#13;
<h2 id="IND-CPA">IND-CPA</h2>&#13;
<p class="BodyFirst">Indistinguishability of ciphertexts under chosen-plaintext attacks. Also known as semantic security. It’s the idea that a ciphertext shouldn’t reveal anything about a plaintext other than its approximate length, even to an active attacker capable of retrieving the ciphertext corresponding to the plaintexts of their choice.</p>&#13;
<p>IND-CPA is the standard security notion for symmetric encryption. For example, block ciphers in CTR or in CBC mode are secure if the underlying block cipher is secure, and if CTR nonces are unique or CBC initial values are unpredictable. That’s a lot of ifs, which in practice can lead to security flaws in otherwise IND-CPA schemes.</p>&#13;
<h2 id="Indelibility">Indelibility</h2>&#13;
<p class="BodyFirst">Property belonging to a transaction, or series thereof, that is timestamped implicitly or explicitly and cannot be backdated or otherwise altered. Cryptographic ledger mechanisms, such as blockchains, can often address this problem.</p>&#13;
<h2 id="Indifferentiability">Indifferentiability</h2>&#13;
<p class="BodyFirst">Property of a construction, such as of a hash function, that is guaranteed to lead to a secure primitive if the building blocks have no security flaw. In the context of hash functions, we talk of <em>indifferentiability <span epub:type="pagebreak" title="59" id="Page_59"/>from a random oracle</em>, meaning that if the underlying compression function or permutation is ideal, the hash function has as many structural properties as a random oracle: that is, none.</p>&#13;
<h2 id="Indistinguishability">Indistinguishability</h2>&#13;
<p class="BodyFirst">The property in which something that isn’t really random appears the same as something that is actually random. If the two are indistinguishable, you cannot extract information from the not-really-random thing. In the case of encryption, the not-really-random thing is the ciphertext, and the information you’re unable to extract is about the plaintext. Indistinguishability applies to other cryptographic functionalities as well.</p>&#13;
<h2 id="Indistinguishability-obfuscation-iO">Indistinguishability obfuscation (iO)</h2>&#13;
<p class="BodyFirst">The mathematization of the intuitive concept of software obfuscation. In cryptography, as in software security, the obfuscation process takes as input a program and produces a second program that in some sense hides how the first program works: its internal variables, secret arguments, and so on. Unlike in software security, cryptography sees a program as one of the possible abstract representations, most commonly a Boolean circuit with AND, OR, and NOT gates.</p>&#13;
<p>iO can be seen as a raw encoding of the input–output relations that hides its implementation details, such as subprocedures or intermediate variables. The notion of indistinguishability is just a formal way to express the idea that, given obfuscations of two distinct yet equivalent programs, an attacker shouldn’t be able to identify which of the programs is which.</p>&#13;
<p>Although iO sounds like the solution to many problems, in practice it’s not because of its high complexity and inefficiency.</p>&#13;
<h2 id="Information-theoretic-security">Information-theoretic security</h2>&#13;
<p class="BodyFirst">Security that even infinite computational power cannot compromise. For example, imagine that you encrypt some 128-bit secret key <em>K</em><sub>0</sub> with AES by using another secret key <em>K </em>as the AES key. Let’s assume that the attacker has no way to verify whether or not they got the valid <em>K</em><sub>0</sub>. In this case, even if the attacker could try all possible values of <em>K</em>, they would have no way of identifying the correct value of <em>K</em>, because they’d have no way of identifying the <em>K</em><sub>0</sub> that they’re after.</p>&#13;
<h2 id="INT-CTXT"><span epub:type="pagebreak" title="60" id="Page_60"/>INT-CTXT</h2>&#13;
<p class="BodyFirst">Integrity of ciphertexts. The security notion, applicable to authenticated encryption schemes, that it should be practically impossible for an attacker to create a valid ciphertext, even if they know many valid ciphertexts for messages of their choice.</p>&#13;
<p>A related theorem: if an authenticated cipher is IND-CPA and INT-CTXT, it’s also IND-CCA. I leave it to you to Google the proof for this result.</p>&#13;
<h2 id="Invisible-signature">Invisible signature</h2>&#13;
<p class="BodyFirst">A public-key signature that cannot be identified as valid or invalid unless the signer has agreed to reveal that information. An invisible signature might appear to make the signature anonymous (that is, because the signature doesn’t reveal the signer’s identity or public key), but this isn’t necessarily the case. Consider this counterexample: if you additionally sign the signature with a noninvisible signature scheme, the scheme remains invisible but is clearly not anonymous.</p>&#13;
<p class="BodyCustom">See <a href="#Anonymous-signature"><em>Anonymous signature</em></a>, <a href="#Undeniable-signature"><em>Undeniable signature</em></a>.</p>&#13;
<h2 id="IOTA">IOTA</h2>&#13;
<p class="BodyFirst">By its own definition, a blockchain with no blocks and no chain. Probably the most mocked blockchain platform, because it has made some unfortunate cryptographic choices, such as designing a new hash function.</p>&#13;
<p>Cryptography enthusiasts and IOTA supporters have posted hundreds of inflammatory tweets about IOTA’s questionable design choices. Here is a very brief summary of the debate: the crypto enthusiasts yelled, “IOTA is broken because its signature scheme is broken.” In response, IOTA fans responded, “IOTA isn’t broken because it can’t be exploited.” There is some truth to both sides.</p>&#13;
<h2 id="IPES-Improved-Proposed-Encryption-Standard">IPES (Improved Proposed Encryption Standard)</h2>&#13;
<p class="BodyFirst">An alternative name for the IDEA block cipher.</p>&#13;
<p class="BodyCustom">See <a href="#IDEA-International-Data-Encryption-Algorithm"><em>IDEA</em></a>.</p>&#13;
<h2 id="IPSec">IPSec</h2>&#13;
<p class="BodyFirst">One of the major open secure channel protocols along with TLS and SSH. Despite its widespread use, it remains much less known in the cryptography community and among engineers. Indeed, you don’t <span epub:type="pagebreak" title="61" id="Page_61"/>need to understand IPSec if you’re developing mobile or web applications. Also, its design and subprotocols look cryptographically boring. A product of DARPA- and NSA-sponsored efforts that began in the 1970s, IPSec nonetheless remains the standard for network layer security. In addition, its design and implementations have proven more robust than early SSL and TLS versions except for the weak IKEv1 subprotocol.</p>&#13;
<h2 id="ISO-standard">ISO standard</h2>&#13;
<p class="BodyFirst">Buy this definition for $180. Please note that a paper format is currently unavailable.</p>&#13;
<h2 id="Isogeny-based-cryptography">Isogeny-based cryptography</h2>&#13;
<p class="BodyFirst">The youngest class of post-quantum cryptography methods; initiated in the early 2000s. An isogeny is a function that maps points of an elliptic curve to points of another elliptic curve and that satisfies specific mathematical properties. You can then draw a graph whose nodes are elliptic curves and whose edges are isogenies between them, and walk through this graph in a pseudorandom way. After throwing a lot of cool math at the study of these objects—graph theory, quaternion algebras, and so on—you end up with hard computational problems that you can use for crypto applications.</p>&#13;
<h1 id="letter-J"><span class="ChapterTitle narrow">J</span></h1>&#13;
<h2 id="Journal-of-Cryptology-JoC"><em>Journal of Cryptology</em> (JoC)</h2>&#13;
<p class="BodyFirst">Cryptography’s <em>Nature </em>minus the publication fees.</p>&#13;
<h1 id="letter-K"><span class="ChapterTitle">K</span></h1>&#13;
<h2 id="KASUMI">KASUMI</h2>&#13;
<p class="BodyFirst">A variant of the 1995 block cipher MISTY1; used in 3G telecommunications standards as the A5/3 cipher. KASUMI is broken, because <span epub:type="pagebreak" title="62" id="Page_62"/>a practical key-recovery attack exists. KASUMI is also not broken, because said attack requires chosen-ciphertext queries in the related-key model, which isn’t realistic.</p>&#13;
<h2 id="Keccak">Keccak</h2>&#13;
<p class="BodyFirst">The hash function family standardized as SHA-3; it is built from a single permutation according to the sponge function framework. Keccak’s permutation performs a clever combination of XORs and logical ANDs. It’s also optimized for efficiency and easily scales to different widths.</p>&#13;
<p>The original Keccak design and its sponge mode have led to several other algorithms.</p>&#13;
<p class="BodyCustom">See <a href="#Permutation-based-cryptography"><em>Permutation-based cryptography</em></a>.</p>&#13;
<h2 id="KeeLoq">KeeLoq</h2>&#13;
<p class="BodyFirst">The most expensive broken cipher ever. One of the rare block ciphers to rely on a feedback shift register.</p>&#13;
<h2 id="KEM-key-encapsulation-mechanism">KEM (key encapsulation mechanism)</h2>&#13;
<p class="BodyFirst">A public-key encryption scheme designed to encrypt and decrypt short, fixed-size chunks of data; commonly used to encapsulate a symmetric key. You can think of a KEM as a key agreement in which one party gets to choose the key; a KEM’s encryption function picks a random symmetric key and encrypts it, whereas the KEM’s decryption function decrypts it to recover the symmetric key. It can then continue to decrypt any data encrypted using that key with some symmetric primitives.</p>&#13;
<h2 id="Kerberos">Kerberos</h2>&#13;
<p class="BodyFirst">The ancestor of single sign-on systems, designed in the late 1980s to provide secure authentication and authorization to MIT’s distributed computing platform Athena. Admittedly an elder technology, Kerberos is one of the security protocols that relatively few people know despite its major impact and the fact that it’s still used in many places, such as in the Radius authentication protocol. Indeed, in spite of its old age, Kerberos remains a decently secure protocol. It implements often forgotten concepts, such as not trusting any party until &#13;
<span epub:type="pagebreak" title="63" id="Page_63"/>they’re authenticated and not exposing passwords in clear. It has some limitations; for instance, Kerberos must rely on a trusted third party. But then again, how many security protocols ultimately don’t? Sometimes known as a protocol that uses only symmetric cryptography, Kerberos can also support public-key crypto, as well as various authentication forms, such as one-time passwords, hardware tokens, and biometrics.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>HADES’ DOG</h2>&#13;
<p class="BoxBodyFirst">The origin of the Kerberos protocol’s name is best explained by the goddess Athena in her conversation with Euripides (as reproduced on MIT’s Kerberos site):</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">Euripides: (. . .) You know, I think we have a solid basis on which to implement the Charon Authentication System.</p>&#13;
<p class="BoxExtractPara">Athena: Perhaps. Anyway, I don’t like the name <em>Charon</em>.</p>&#13;
<p class="BoxExtractPara">Euripides: You don’t? Since when?</p>&#13;
<p class="BoxExtractPara">Athena: I’ve never liked it, because the name doesn’t make sense. I was talking to my Uncle Hades about it the other day, and he suggested another name, the name of his three-headed watchdog.</p>&#13;
<p class="BoxExtractPara">Euripides: Oh, you mean <em>Cerberus</em>.</p>&#13;
<p class="BoxExtractPara">Athena: Bite your tongue Rip! <em>Cerberus</em> indeed . . . </p>&#13;
<p class="BoxExtractPara">Euripides: Er, isn’t that the name?</p>&#13;
<p class="BoxExtractPara">Athena: Yeah, if you happen to be a Roman! I’m a Greek goddess, he’s a Greek watchdog, and his name is <em>Kerberos</em>, <em>Kerberos</em> with a K.</p>&#13;
<p class="BoxExtractPara">Euripides: Okay, okay, don’t throw thunderbolts. I’ll buy the name. Actually, it has a nice ring to it. Adios Charon and hello to Kerberos.</p>&#13;
</blockquote>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Kerckhoffs’-principles">Kerckhoffs’ principles</h2>&#13;
<p class="BodyFirst">The six principles, or <em>desiderata</em>, of security established by the 19th-century Dutch cryptographer Auguste Kerckhoffs in his article “La cryptographie militaire”<em> </em>(in French).</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="64" id="Page_64"/>LES SIX PRINCIPES DE KERCKhOFFS</h2>&#13;
<p class="BoxBodyFirst">Of the six principles in Kerckhoffs’ paper, only the second is commonly known as <em>Kerckhoffs’ </em><em>principle</em>. But all six deserve our attention. Let’s examine them here:</p>&#13;
<ol class="decimal">&#13;
<li value="1"><em>The system must be practically, if not mathematically, indecipherable</em>. Today’s equivalent would also include systems that are virtually indecipherable by mathematical means, as when security proofs guarantee practical security under some hardness assumptions.</li>&#13;
<li value="2"><em>It must not be required to be secret, and it must be able to fall into the hands of the enemy without inconvenience</em>. All serious cryptographers should follow this . . . except when they shouldn’t. Indeed, in rare exceptions, making the algorithm secret (via custom design, secret S-boxes, secret tweak input, and/or secret personalization values) contributes significantly to the security of a system.</li>&#13;
<li value="3"><em>Its key must be communicable and retainable without the help of written notes, and changeable or modifiable at the will of the correspondents</em>. Key distribution, revocation, and rotation remain among the most challenging problems in cryptography, and the source of many perils.</li>&#13;
<li value="4"><em>It must be applicable to telegraphic correspondence</em>. Sorry, Kerckhoffs; the problem of email encryption is still practically unsolved.</li>&#13;
<li value="5"><em>Apparatus and documents must be portable, and its usage and function must not require the concourse of several people</em>. This goal is the opposite of that of protocols, such as distributed key generation and threshold encryption.</li>&#13;
<li value="6"><em>Finally, it is necessary, given the circumstances that command its application, that the system be easy to use, requiring neither mental strain nor the knowledge of a long series of rules to observe</em>. Simplicity has rarely been a major concern in cryptographic designs, although it ought to be.</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Key-derivation-function-KDF">Key derivation function (KDF)</h2>&#13;
<p class="BodyFirst">A function that hashes stuff to obtain a key. A simple hash function doesn’t always do the trick, because the <em>stuff</em> to be hashed typically includes a combination of secret and nonsecret values. A KDF’s interface helps process these values securely to avoid collisions between different sets of stuff. There is another reason hash functions aren’t <span epub:type="pagebreak" title="65" id="Page_65"/>sufficient: a KDF must often generate keys of arbitrary size, whereas most hash functions generate values of a fixed size.</p>&#13;
<p>A special case arises whenever the key can’t be just any string of bits (as in the case of a symmetric key) but a public/private key pair. In those situations, rather than generating the key pair as part of the KDF, you would generally use a second algorithm to deterministically create a key pair from a seed.</p>&#13;
<p>Last but not least, when the stuff’s secret is a password, passphrase, or other low-entropy value, you need a special kind of KDF, called a <em>password hash function</em>. These have some additional security requirements.</p>&#13;
<p class="BodyCustom">See <a href="#Password-hash-function"><em>Password hash function</em></a>.</p>&#13;
<h2 id="Key-escrow">Key escrow</h2>&#13;
<p class="BodyFirst">The idea of entrusting an organization or entity with the custody of secret keys and therefore the rights associated with them, for example, to decrypt communications.</p>&#13;
<p>As told by the European Council in a meeting in May 1998:</p>&#13;
<p class="ExtractPara">The Council Resolution of 17 January 1995 recognised that lawfully authorised interception of communications is an important tool for the investigation of serious crime. The Council notes that law enforcement agencies may require lawful access to encryption keys, without the knowledge of the user of the cryptographic service, in order to maintain this capability. To this end, the Council recognises that one possible approach amongst others, which might meet law enforcement interests, might be the promotion of confidentiality services which involve the depositing of an encryption key or other information with a third party. Such services are often known as “key escrow” or “key recovery” services. Law enforcement agencies may also require lawful access to encryption keys where it is necessary to decrypt material which has been seized as part of a criminal investigation.</p>&#13;
<p>In principle, key escrow sounds easy and a fair solution to real problems. But in practice, key escrow raises a lot of procedural, technological, and political problems, and its benefits might not be worth the additional cost and risks, depending on your metric.</p>&#13;
<p class="BodyCustom">See <a href="#Key-management"><em>Key management</em></a>.</p>&#13;
<h2 id="Key-management"><span epub:type="pagebreak" title="66" id="Page_66"/>Key management</h2>&#13;
<p class="BodyFirst">The single hardest problem in cryptography. Key management won’t be solved by quantum computers or with an NP oracle.</p>&#13;
<h2 id="Key-wrapping">Key wrapping</h2>&#13;
<p class="BodyFirst">To symmetric cryptography, what KEMs are to public-key cryptography.</p>&#13;
<h2 id="Kleptography">Kleptography</h2>&#13;
<p class="BodyFirst">A term coined to refer to cryptography used in malware and other unholy applications, particularly when their aim is to steal information in a covert way; for example, via subliminal channels or obfuscation.</p>&#13;
<p class="BodyCustom">See <a href="#Cryptovirology"><em>Cryptovirology</em></a>.</p>&#13;
<h2 id="Known-key-attack">Known-key attack</h2>&#13;
<p class="BodyFirst">An adversarial model that assumes the attacker already knows the secret key of some symmetric cipher. Therefore, the attack’s goal isn’t to recover a key but to identify structural properties that the attacker might exploit when the cipher is used in a hash function or some other construction where its key might not be secret.</p>&#13;
<h2 id="Kupyna-Купина">Kupyna (Купина)</h2>&#13;
<p class="BodyFirst">The Ukrainian national hash function standard; established in 2014 and named after the plant <em>Polygonatum multiflorum</em>. Kupyna is based on a fairly unusual compression function construction: given a message block <em>M </em>and an initial hash value <em>H</em>, the next hash value is computed as <em>H </em><span class="NSSymbol">⊕</span> Perm<sub>1</sub>(<em>M</em>) <span class="NSSymbol">⊕</span> Perm<sub>2</sub>(<em>M </em><span class="NSSymbol">⊕</span><em>H</em>), where Perm<sub>1</sub> and Perm<sub>2</sub> are permutations similar to AES with no key and a wider state.</p>&#13;
<h1 id="letter-L"><span class="ChapterTitle">L</span></h1>&#13;
<h2 id="Laconic-zero-knowledge-proof">Laconic zero-knowledge proof</h2>&#13;
<p class="BodyFirst">An interactive proof protocol where the prover sends very few bits to the verifier.</p>&#13;
<h2 id="Lai–Massey"><span epub:type="pagebreak" title="67" id="Page_67"/>Lai–Massey</h2>&#13;
<p class="BodyFirst">A secure way to build a block cipher, although much less common than the Feistel substitution-permutation networks. The Lai–Massey construction is notably used by IDEA and FOX.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>A LAI–MASSEY ROUND</h2>&#13;
<p class="BoxBodyFirst">Given a function <em>f</em>() whose input and output is of a length twice as short as the block size, a Lai–Massey round applies to an internal state split in two halves, <em>L </em>and <em>R</em>. Each round updates these halves as follows:</p>&#13;
<p>First, compute <em>X</em><em> </em>= <em>f</em>(<em>L</em><em> </em>− <em>R</em>). Then set <em>L</em><em> </em>= <span class="NSSymbol">σ</span>(<em>L</em><em> </em>+ <em>X</em>) and <em>R</em><em> </em>= <em>R</em><em> </em>+ <em>X</em>.</p>&#13;
<p>Here, <em><span class="NSSymbol">σ</span></em>() is an orthomorphism, that is, a permutation so that the mapping <em>Y </em><span class="NSSymbol">↦</span><em> <span class="NSSymbol">σ</span></em>(<em>Y</em>) − <em>Y </em>is also a permutation. For example, FOX’s orthomorphism sees <em>L</em> as two halves <em>L</em><em> </em>= <em>L</em><sub>L</sub><em>||</em><em>L</em><sub>R</sub><em> </em>and returns <em>L</em><sub>R</sub>||(<em>L</em><sub>L</sub><em> </em><em><span class="NSSymbol"/></em><span class="NSSymbol">⊕</span><em> </em><em>L</em><sub>R</sub>).</p>&#13;
<p>Without <span class="NSSymbol">σ</span>(), the difference <em>L</em><em> </em>− <em>R</em><em> </em>remains the same through the round operation, slightly reducing the scheme’s security (I’ll leave the proof for this as a simple exercise for you to complete). </p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Lamport-signature">Lamport signature</h2>&#13;
<p class="BodyFirst">The first hash-based signature scheme, and in its original form, the simplest signature scheme ever: to sign a one-bit message, you’d first generate a private key composed of two random values <em>K</em><sub>0</sub> and <em>K</em><sub>1</sub>. Then you’d share the public key (Hash(<em>K</em><sub>0</sub>), Hash(<em>K</em><sub>1</sub>)). To sign the message <em>0</em>, you’d attach <em>K</em><sub>0</sub> as a signature, and you’d attach <em>K</em><sub>1</sub> otherwise.</p>&#13;
<p>This works, but it’s not very useful, because 1) a key pair can sign only one message, and 2) the key size is proportional to that of the message.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>THE FIRST PUBLIC-KEY SIGNATURE SCHEME?</h2>&#13;
<p class="BoxBodyFirst">Although published in 1979—after the Diffie–Hellman and RSA papers—Lamport’s scheme might have been the signature scheme to use public-key cryptography. In Lamport’s own words:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">At a coffee house in Berkeley around 1975, Whitfield Diffie described a problem to me that he had been trying to solve: constructing a digital signature for a document. I immediately proposed a solution. Though not very practical—it required perhaps 64 bits of published key to sign a single bit—it was the first digital signature algorithm.</p>&#13;
</blockquote>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Lattice-based-cryptography"><span epub:type="pagebreak" title="68" id="Page_68"/>Lattice-based cryptography</h2>&#13;
<p class="BodyFirst">The most promising class of post-quantum cryptography schemes, as far as real applications are concerned. Lattice-based cryptography usually relies on some version of the learning with errors (LWE) problem and in particular its relation to lattice problems. It can provide encryption/KEM and signature schemes. It’s generally considered the most promising type of post-quantum scheme due to its combination of acceptable security assurance, performance, and diversity of constructions.</p>&#13;
<p>Lattice-based schemes represent 39 percent of round one submissions to NIST’s post-quantum competition, 46 percent of submissions selected in round two, and 71 percent of the finalists. </p>&#13;
<p class="BodyCustom">See <a href="#Learning-with-errors-LWE"><em>Learning with errors (LWE)</em></a>.</p>&#13;
<h2 id="Le-Chiffre">Le Chiffre</h2>&#13;
<p class="BodyFirst">A character in an Ian Fleming spy book. Anyone whose name means <em>The Cipher</em> can only be a villain:</p>&#13;
<p class="ExtractPara">Mostly expensive, but discreet. Large sexual appetites. Flagellant. Expert driver of fast cars. Adept with small arms and other forms of personal combat, including knives. Carries three Eversharp razor blades, in hatband, heel of left shoe, and cigarette case. Knowledge of accountancy and mathematics. Fine gambler.</p>&#13;
<h2 id="Leakage-resilient-cryptography">Leakage-resilient cryptography</h2>&#13;
<p class="BodyFirst">An attempt to model side-channel information leaks using abstract models of computation and memory leakage. Such models include the Bounded Retrieval Model, Continual Memory Leakage, Auxiliary Memory Leakage, and Only Computation Leaks, among others. Building secure schemes within these models has proved an interesting exercise, yet of questionable practical interest, because the models largely fail to capture the complex reality of side channels and physical attacks.</p>&#13;
<h2 id="Learning-with-errors-LWE">Learning with errors (LWE)</h2>&#13;
<p class="BodyFirst">The problem of solving a system of linear equations when the equations have errors in them. LWE generalizes the <em>learning parity with noise</em> (<em>LPN</em>) problem so it has arbitrary dimensions and numbers greater than 0 and 1.</p>&#13;
<p><span epub:type="pagebreak" title="69" id="Page_69"/>Lattice-based cryptography schemes often rely on the hardness of some LWE problem. The reason is that, on average, LWE is as hard as the hardest instances of a lattice problem, such as GapSVP. The resulting cryptographic constructions should be, in turn, at least as hard to break as LWE.</p>&#13;
<h2 id="Length-extension-attack">Length extension attack</h2>&#13;
<p class="BodyFirst">The property of certain hash functions that given Hash(<em>X</em>), and without knowing <em>X</em>, it’s trivial to find the value of Hash(<em>X </em>||pad|| <em>Y</em>) for any <em>Y</em>, where pad is padding bits followed by the encoding of <em>X</em>’s length. Hash functions vulnerable to length extension include all those built with the Merkle–Damgård construction, such as SHA-256 and RIPEMD-160. More recent hash functions, such as SHA-3 or BLAKE3, aren’t vulnerable to length extension.</p>&#13;
<h2 id="Length-preserving-encryption">Length-preserving encryption</h2>&#13;
<p class="BodyFirst">Encryption that creates ciphertexts of exactly the same bit size as their corresponding plaintext; for example, encrypting any 16-byte plaintext into a 16-byte ciphertext, any 1-byte plaintext into a 1-byte ciphertext, any 2-bit plaintext into a 2-bit ciphertext, and so on. In applications where the payload length is fixed, length-preserving encryption is necessary to encrypt payload data.</p>&#13;
<p>Length-preserving encryption shouldn’t be confused with <em>format-preserving encryption</em>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>PRESERVING PLAINTEXT LENGTH</h2>&#13;
<p class="BoxBodyFirst">Length-preserving encryption might sound simple, but it’s not. First, public-key encryption schemes cannot directly offer length-preserving encryption, because ciphertext expansion is intrinsic to how they work. For example, RSA encryption requires additional padding and randomness to achieve secure encryption (IND-CPA).</p>&#13;
<p>When it comes to symmetric encryption, the only way to achieve IND-CPA-secure length-preserving encryption is if the nonce or IV is not seen as a part of the ciphertext.</p>&#13;
<p>Stream ciphers are trivially length-preserving, because they XOR pseudorandom bits with the plaintext and thus preserve its length through encryption. Likewise, the CTR-mode creates ciphertexts of identical length as their plaintext.</p>&#13;
<p><span epub:type="pagebreak" title="70" id="Page_70"/>What about a block cipher mode like CBC? If you use the standard PKCS#7 padding scheme, the ciphertext will inevitably be longer than the plaintext. But there’s a technique called <em>ciphertext stealing</em> that shuffles the bytes in the last blocks to obtain a ciphertext of the same length as its plaintext.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="LFSR-linear-feedback-shift-register">LFSR (linear feedback shift register)</h2>&#13;
<p class="BodyCustom">See <a href="#Feedback-shift-register"><em>Feedback shift register</em></a>.</p>&#13;
<h2 id="Lightweight-cryptography">Lightweight cryptography</h2>&#13;
<p class="BodyFirst">Cryptography optimized for IoT devices and other platforms that have memory and logic constraints. But these constrained platforms usually have unique limitations and therefore require unique designs. Consequently, academic research about lightweight cryptography has been of disappointing practical relevance, sometimes because embedded platforms often include an AES logic.</p>&#13;
<h2 id="Linear-cryptanalysis">Linear cryptanalysis</h2>&#13;
<p class="BodyFirst">A cryptanalysis technique for symmetric ciphers that exploits patterns described in terms of linear equations, or equations consisting only of XORs between bits.</p>&#13;
<p>Linear cryptanalysis might look totally different from differential cryptanalysis, but it’s actually closely related to it. The most successful linear attack is arguably the one on DES.</p>&#13;
<h2 id="Linkability">Linkability</h2>&#13;
<p class="BodyFirst">A property of a signature scheme that allows an attacker to determine whether two signatures were issued by the same signer. Of course, standard signatures, such as ECDSA signatures, are linkable by design, which is fine. But nonlinkability is a requirement for ring signatures.</p>&#13;
<h2 id="LM-hash">LM hash</h2>&#13;
<p class="BodyFirst">Short for LAN Manager hash, the function that hashes users’ passwords in earlier Microsoft Windows versions. LM hash is the predecessor of NT hash, which is a stronger hash.</p>&#13;
<p class="BodyCustom">See <a href="#NT-hash"><em>NT hash</em></a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="71" id="Page_71"/>THE IMPERFECTION OF LM HASH</h2>&#13;
<p class="BoxBodyFirst">In hindsight, LM hash is laughably weak: it’s barely a hash because you can recover the original passwords very easily.</p>&#13;
<p>To hash a password with LM hash, follow these steps:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Convert lowercase letters to uppercase letters. This makes collisions frequent, which is bad, while also making the recovery of the initial password informationally impossible, a fact probably not intended as a security feature.</li>&#13;
<li value="2">If the password is longer than 14 characters, truncate it to its first 14 characters (another way to create trivial collisions); otherwise, pad it with null bytes to get a 14-byte string.</li>&#13;
<li value="3">Encrypt the string <em>KGS!@#$%</em> using two DES instances, one with the first seven bytes of the padded password and another with the last seven bytes (remember that DES’s key is 56 bits long).</li>&#13;
<li value="4">The hash is the concatenation of two ciphertexts!</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Luby–Rackoff">Luby–Rackoff</h2>&#13;
<p class="BodyCustom">See <a href="#Feistel-network"><em>Feistel network</em></a>.</p>&#13;
<h2 id="Lucifer">Lucifer</h2>&#13;
<p class="BodyFirst">The block cipher designed by Horst Feistel at IBM that led to the DES standard. It wasn’t originally a Feistel network, but a substitution-permutation network like AES, with blocks of 32, 48, or 128 bits. Lucifer was initially implemented in APL (A Programming Language) and codenamed <em>Demonstration</em>. But the APL workspace restricted projects’ name length, so <em>Demonstration</em> became <em>Demon</em> and later <em>Lucifer</em>.</p>&#13;
<h1 id="letter-M"><span class="ChapterTitle"> M</span></h1>&#13;
<h2 id="MAC-message-authentication-code">MAC (message authentication code)</h2>&#13;
<p class="BodyFirst">Not a signature, but very close: like a public-key signature a MAC should be unforgeable without the key, but unlike a public-key signature a MAC doesn’t provide nonrepudiation. </p>&#13;
<p><span epub:type="pagebreak" title="72" id="Page_72"/>In theory, a MAC can be unforgeable yet leak information about the message, but in practice most MACs don’t.</p>&#13;
<h2 id="MAGENTA">MAGENTA</h2>&#13;
<p class="BodyFirst">An unfortunate candidate at the AES competition, broken literally minutes after it was presented at the first AES conference. A conference participant commented: “It got so bad that a few of the participants started doing real-time cryptanalysis and suggesting attacks that would break the algorithm right there and then. I marvelled that the German guy managed to keep his composure. The whole spectacle was rather shameful.”</p>&#13;
<h2 id="Malleability">Malleability</h2>&#13;
<p class="BodyFirst">An underappreciated security notion: an encryption scheme is nonmalleable if an attacker cannot turn a ciphertext Enc(<em>K</em>, <em>M</em>) into another valid ciphertext Enc(<em>K</em>, <em>f</em>(<em>M</em>)) for some specified function <em>f</em>(). A nonmalleable scheme is therefore more secure than a malleable one. In the chosen-ciphertext model, nonmalleability is equivalent to indistinguishability (the strongest security notion).</p>&#13;
<h2 id="Manger-attack">Manger attack</h2>&#13;
<p class="BodyFirst">A padding oracle attack on RSA encryption in OAEP mode. The Manger attack is less well known than the Bleichenbacher attack on older RSA encryption, because it’s generally harder to exploit. Indeed, as Manger’s original paper noted, the PKCS standard already described a partial mitigation against his attack when saying that “it is important that the error messages output in steps 4 [integer-to-octets conversion] and 5 [OAEP decoding] be the same.” But as with Bleichenbacher’s attack, Manger’s attack also works if the attacker exploits timing leaks instead of error messages.</p>&#13;
<h2 id="Man-in-the-middle">Man-in-the-middle</h2>&#13;
<p class="BodyFirst">A class of attacks where the attacker surreptitiously captures and modifies traffic from two or more correspondents. The FREAK (Factoring RSA Export Keys) attack on TLS implementations is an example of a man-in-the-middle attack in which the attacker modifies session initiation data to force the use of a weak cipher suite.</p>&#13;
<p class="BodyCustom">See <a href="#Meet-in-the-middle"><em>Meet-in-the-middle</em></a>.</p>&#13;
<h2 id="MASH-Modular-Arithmetic-Secure-Hash"><span epub:type="pagebreak" title="73" id="Page_73"/>MASH (Modular Arithmetic Secure Hash)</h2>&#13;
<p class="BodyFirst">An early attempt at a hash function relying on the same operations as RSA. </p>&#13;
<p class="BodyCustom">See <a href="#VSH-Very-Smooth-Hash"><em>VSH (Very Smooth Hash)</em></a>.</p>&#13;
<h2 id="McEliece-encryption-scheme">McEliece encryption scheme</h2>&#13;
<p class="BodyCustom">See <a href="#Code-based-cryptography"><em>Code-based cryptography</em></a>.</p>&#13;
<h2 id="MD4">MD4</h2>&#13;
<p class="BodyFirst">Hash function even weaker than MD5.</p>&#13;
<h2 id="MD5">MD5</h2>&#13;
<p class="BodyFirst">Previously a synonym of <em>checksum</em> and <em>hash function</em>, now a sign of poor cryptography design because it isn’t collision resistant. But MD5 is still secure against preimage attacks.</p>&#13;
<h2 id="MDC-Message-Digest-Cipher">MDC (Message Digest Cipher)</h2>&#13;
<p class="BodyFirst">Old-fashioned name for hash functions.</p>&#13;
<h2 id="MDC-2-Modification-Detection-Code-2">MDC-2 (Modification Detection Code 2)</h2>&#13;
<p class="BodyFirst">A construction that turns an <em>n</em>-bit block cipher into a hash function with 2<em>n</em>-bit output. The resulting hash is less secure than an ideal 2<em>n</em>-bit hash but more secure than an <em>n</em>-bit hash. MDC-2 was mainly used with DES as <em>MDC-2DES</em> except when IBM’s patent was a concern.</p>&#13;
<h2 id="Meet-in-the-middle">Meet-in-the-middle</h2>&#13;
<p class="BodyFirst">A folklore cryptanalysis technique mainly known for its application in attacking symmetric primitives. A meet-in-the-middle is applicable when consecutive encryption layers (also called <em>rounds</em> or <em>cipher instances</em>) work with independent keys. For example, when encrypting a message <em>M </em>as <em>C </em>= Enc<sup>2</sup>(<em>K</em><sub>2</sub>, Enc<sup>1</sup>(<em>K</em><sub>1</sub>, <em>M</em>)) with two <em>n</em>-bit keys <em>K</em><sub>1</sub> and <em>K</em><sub>2 </sub>and two distinct ciphers Enc<sup>1</sup> and Enc<sup>2</sup>, you might expect a security of 2<em>n </em>bits (as if it were equivalent to encrypting with a 2<em>n</em>-bit key). But the actual security is closer to <em>n </em>bits: the reason is that, given a pair (<em>C</em>, <em>M</em>) <span epub:type="pagebreak" title="74" id="Page_74"/>you can compute <em>X </em>= Dec<sup>2</sup>(<em>K</em>, <em>C</em>) for all the 2<sup><em>n</em></sup> values of <em>K</em>, and then compute <em>Y</em> = Enc<sup>1</sup>(<em>K'</em>, <em>M</em>) for all 2<sup><em>n</em></sup> values of <em>K'</em>. The pair (<em>K'</em>, <em>K</em>) for which <em>X </em>= <em>Y </em>is then likely to be (<em>K</em><sub>1</sub>, <em>K</em><sub>2</sub>).</p>&#13;
<p>You can view this trick as one instance of a more general optimization technique found in many cryptanalytic attacks. Those attacks include the baby-step giant-step algorithm (to compute discrete logarithms), the GHS isogeny-based attack on ECDLP, or attacks on isogeny-based schemes.</p>&#13;
<p class="BodyCustom">See <a href="#Man-in-the-middle"><em>Man-in-the-middle</em></a>.</p>&#13;
<h2 id="Merkle-puzzle">Merkle puzzle</h2>&#13;
<p class="BodyFirst">The closest thing to public-key cryptography before (secure) public-key cryptography was invented.</p>&#13;
<h2 id="Merkle-tree">Merkle tree</h2>&#13;
<p class="BodyFirst">A solution to many problems in cryptography and computing. Essentially, a hash tree. It can, for example, be used to demonstrate the knowledge of some large set of data in a compact and efficient way: you can prove that a piece of data is in the tree by showing the list of nodes required to compute the root node from the said data’s node (usually a leaf). This list of values has been called the <em>authentication path</em>, <em>inclusion proof</em>, and <em>Merkle proof</em>.</p>&#13;
<p>Merkle trees are the main components of hash-based signatures.</p>&#13;
<h2 id="Merkle–Damgård-construction">Merkle–Damgård construction</h2>&#13;
<p class="BodyFirst">A straightforward technique for hashing messages of any length when using a hash function that hashes only short messages. It does this in such a way that, if the short-length hash is secure, the resulting hash of any length is secure as well. This is one of the earliest security proofs in symmetric cryptography. But this proof is only about collision resistance and preimage resistance, not about security in the most absolute sense. For example, Merkle–Damgård hash functions, such as SHA-256, are vulnerable to length extension attacks.</p>&#13;
<h2 id="Mersenne-twister">Mersenne twister</h2>&#13;
<p class="BodyFirst">Not a cryptographic pseudorandom generator.</p>&#13;
<h2 id="Message-franking"><span epub:type="pagebreak" title="75" id="Page_75"/>Message franking</h2>&#13;
<p class="BodyFirst">A protocol to allow the reporting of abusive messages in an end-to-end encryption conversation while maintaining an acceptable level of security. Motivated by Facebook’s problem of deploying end-to-end encryption in Messenger, yet with the possibility of users to report messages to Facebook in a way that their sender can’t cryptographically deny their sending. Therefore, it requires quite the opposite of plausible deniability. </p>&#13;
<h2 id="Miller–Rabin">Miller–Rabin</h2>&#13;
<p class="BodyFirst">The most common probabilistic primality test. Under certain conditions, you can fool the test into declaring that a composite number is prime.</p>&#13;
<p class="BodyCustom">See <a href="#PRIMES"><em>PRIMES</em></a>.</p>&#13;
<h2 id="MINERVA">MINERVA</h2>&#13;
<p class="BodyCustom">See <a href="#Crypto-AG"><em>Crypto AG</em></a>.</p>&#13;
<h2 id="Mining">Mining</h2>&#13;
<p class="BodyFirst">Hashing for money.</p>&#13;
<h2 id="Misuse-resistance">Misuse resistance</h2>&#13;
<p class="BodyFirst">Defense-in-depth applied to cryptography. Misuse resistance counters the fact that some ciphers, such as AES-GCM, are secure only if you never call them twice with the same nonce. (A nonce is the auxiliary input that ensures that you’ll get a different ciphertext if you encrypt the same plaintext twice with the same key.) Misuse-resistant ciphers attempt to eliminate this problem. Their only limitation is that if you encrypt the same message with the same key and nonce twice, the output will be the same. (As an exercise, find why this limitation can’t be avoided.) The only security flaw is that an attacker will learn when you’ve encrypted the same message twice. SIV-AES is an example of such a cipher.</p>&#13;
<p>Misuse resistance can extend to cases other than symmetric encryption. It also applies to APIs to prevent disasters when the caller forgets to read the documentation (if it exists).</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="76" id="Page_76"/>THEOREM: REPEATING NONCE IS INSECURE</h2>&#13;
<p class="BoxBodyFirst">In the case of AES-GCM, reusing a nonce allows an attacker to learn the XOR difference between the two plaintext messages, even if they don’t know either of the messages. Proof: AES-GCM encrypts a message by using the CTR (counter) mode, which, given a key and a nonce, generates a pseudo­random sequence, called the <em>keystream</em>, XORed to the message. So if you generate the keystream <em>S </em>and create the ciphertext <em>C</em><sub>1</sub> = <em>M</em><sub>1</sub><span class="NSSymbol">⊕</span><em> S </em>from the message <em>M</em><sub>1</sub> by reusing the same key and nonce, you’ll also use the same <em>S </em>to encrypt a ­second message <em>M</em><sub>2</sub> to <em>C</em><sub>2</sub> = <em>M</em><sub>2</sub><span class="NSSymbol">⊕</span><em> S</em>. In that case, an attacker can compute <em>C</em><sub>1</sub><span class="NSSymbol">⊕</span><em> C</em><sub>2</sub> = <em>M</em><sub>1</sub><span class="NSSymbol">⊕</span><em> M</em><sub>2</sub>. This is bad. QED.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Mixnet">Mixnet</h2>&#13;
<p class="BodyFirst">A multi-party protocol that provides anonymity by shuffling a sequence of ciphertexts <em>C</em><sub>1</sub>, <em>. . . </em>, <em>C</em><sub>n</sub><em> </em>into another sequence <em>C'</em><sub>1</sub>, <em>. . . </em>, <em>C'</em><sub>n</sub>, so that for each <em>C</em><sub>i</sub><em> </em>there exists a <em>C'</em><sub>j</sub><em> </em>whose value is distinct but decrypts to the same plaintext. The protocol might also include a zero-knowledge proof that shows that the criterion is satisfied without leaking any information about the permutation or plaintexts.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>MIXNETS IN PRACTICE</h2>&#13;
<p class="BoxBodyFirst">Most often, mixnets are used to route data in anonymous communication networks. Here, an observer shouldn’t be able to associate a post-mix value <em>C'</em><sub>i</sub><em> </em>to its pre-mix counterpart <em>C</em><sub>j</sub>. After one or more rounds of mixing, this prevents an attacker from associating a message’s source with its final recipient.</p>&#13;
<p>Mixnets were also used in e-voting schemes to provide voter anonymity, as well as in cryptocurrencies to hide sender/recipient relations, typically by shuffling UTXOs.</p>&#13;
<p>A number of gotchas can defeat mixnets’ security. For example, in the case of anonymous routing, the mixing router must transmit the mixed values in an order not correlated with that of received values; otherwise, anonymity can be easily compromised. Messages should also all be of the same size; otherwise, the permutation is straightforward to identify.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="MQV-Menezes–Qu–Vanstone"><span epub:type="pagebreak" title="77" id="Page_77"/>MQV (Menezes–Qu–Vanstone)</h2>&#13;
<p class="BodyFirst">Diffie–Hellman on steroids. Invented in 1995, yet rarely used, in part because of patents covering it. It’s the sister of HMQV and ECMQV (once in NSA’s Suite B). Today, MQV is perhaps best known for its use in the password-based key agreement protocol OPAQUE.</p>&#13;
<h2 id="Multicollision">Multicollision</h2>&#13;
<p class="BodyFirst">For hash functions, a collision between more than two messages. It takes less time to find multicollisions on iterated hash functions (such as SHA-256) than for a hash function accessed as a black box. If intermediate chaining values of the iterated hash are <em>n</em>-bit, then a <em>k</em>-collision can be found in <span class="NSSymbol">⌈</span>log<sub>2</sub><em>k</em><span class="NSSymbol">⌉ </span>· 2<sup><em>n</em></sup><sup>/2</sup> against <em>k</em>!<sup>1/</sup><sup><em>k</em></sup><em> </em>· 2<sup><em>n</em></sup><sup>(</sup><sup><em>k</em></sup><sup> – 1)</sup><sup><em>k</em></sup><em> </em>for an ideal, black-box hash.</p>&#13;
<h2 id="Multi-party-computation-MPC">Multi-party computation (MPC)</h2>&#13;
<p class="BodyFirst">A class of cryptographic techniques for computing a function’s output without knowing the inputs’ original values. MPC is a rich field of research, yet with few major application until cryptocurrency wallets, which also use the MPC-like threshold signatures. Many more real-world MPC applications are expected.</p>&#13;
<h2 id="Multivariate-cryptography">Multivariate cryptography</h2>&#13;
<p class="BodyFirst">A class of post-quantum schemes based on the hardness of solving systems of nonlinear equations in multiple variables. The hardness of such problems is related to that of Multivariate Quadratics (MQ), the problem of solving a random system of degree-2 equations, known to be NP-complete.</p>&#13;
<p>Most multivariate schemes are signature schemes that produce short signatures (good) but require long public keys (not so good).</p>&#13;
<h1 id="letter-N"><span class="ChapterTitle">N</span></h1>&#13;
<h2 id="NBS-National-Bureau-of-Standards">NBS (National Bureau of Standards)</h2>&#13;
<p class="BodyFirst">Previous name for NIST.</p>&#13;
<p class="BodyCustom">See <a href="#NIST-National-Institute-of-Standards-and-Technology"><em>NIST (National Institute of Standards and Technology)</em></a>.</p>&#13;
<h2 id="NESSIE-New-European-Schemes-for-Signatures,-Integrity,-and-Encryption"><span epub:type="pagebreak" title="78" id="Page_78"/>NESSIE (New European Schemes for Signatures, Integrity, and Encryption)</h2>&#13;
<p class="BodyFirst">A project that ran from 2000 to 2003 and was headed by seven European institutions. It selected 17 recommended algorithms among 42 submissions.</p>&#13;
<p>NESSIE’s selected algorithms didn’t become formal standards, only informal recommendations, which in hindsight drew little interest: does anyone remember ACE Encrypt, SHACAL-2, or SFLASH?</p>&#13;
<h2 id="New-Directions-in-Cryptography">“New Directions in Cryptography”</h2>&#13;
<p class="BodyFirst">Invited research paper published in IEEE Transactions on Information Theory in November 1976, by Whitfield Diffie and Martin Hellman. Today, the Diffie–Hellman operation is used in almost every software or hardware system that performs cryptographic operations.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>THE DIFFIE–HELLMAN REVOLUTION</h2>&#13;
<p class="BoxBodyFirst">Diffie and Hellman can non-ironically be called visionaries after writing the following introduction:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">We stand today on the brink of a revolution in cryptography. The development of cheap digital hardware has freed it from the design limitations of mechanical computing and brought the cost of high grade cryptographic devices down to where they can be used in such commercial applications as remote cash dispensers and computer terminals. In turn, such applications create a need for new types of cryptographic systems which minimize the necessity of secure key distribution channels and supply the equivalent of a written signature. At the same time, theoretical developments in information theory and computer science show promise of providing provably secure cryptosystems, changing this ancient art into a science.</p>&#13;
</blockquote>&#13;
<p>The paper goes on to introduce the concept of public-key cryptography, and a new <em>public-key distribution system</em>, now referred to as the Diffie–Hellman key agreement. The original specification is worth copying verbatim:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">Each user generates an independent random number <em>X</em><sub>i</sub> chosen uniformly from the set of integers {1, 2,<em> · · · </em>,  <em>q </em>− 1}. Each keeps <em>X</em><sub>i</sub><em> </em>secret, but places</p>&#13;
</blockquote>&#13;
<figure class="graphic auto">&#13;
<img src="Images/g01003.jpg" alt="g01003" width="119" height="31"/>&#13;
</figure>&#13;
<blockquote>&#13;
<p class="BoxExtractPara"><span epub:type="pagebreak" title="79" id="Page_79"/>in a public file with his name and address. When users <em>i </em>and <em>j </em>wish to communicate privately, they use</p>&#13;
</blockquote>&#13;
<figure class="graphic auto">&#13;
<img src="Images/g01004.jpg" alt="g01004" width="135" height="32"/>&#13;
</figure>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">as their key. User <em>i </em>obtains <em>K</em><sub>ij</sub><em> </em>by obtaining <em>Y</em><sub>j</sub><em> </em>from the public file and letting </p>&#13;
</blockquote>&#13;
<figure class="graphic">&#13;
<img src="Images/g01005.jpg" alt="g01005" width="398" height="51"/>&#13;
</figure>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">User <em>j</em><em> </em>obtains <em>K</em><sub>ij</sub><em> </em>in a similar fashion</p>&#13;
</blockquote>&#13;
<figure class="graphic auto">&#13;
<img src="Images/g01006.jpg" alt="g01006" width="122" height="32"/>&#13;
</figure>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">Another user must compute <em>K</em><sub>ij</sub> from <em>Y</em><sub>i</sub> and <em>Y</em><sub>j</sub>, for example, by computing</p>&#13;
</blockquote>&#13;
<figure class="graphic auto">&#13;
<img src="Images/g01007.jpg" alt="g01007" width="160" height="28"/>&#13;
</figure>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">We thus see that if logs mod <em>q </em>are easily computed, the system can be broken. While we do not currently have a proof of the converse (i.e., that the system is secure if logs mod <em>q </em>are difficult to compute), neither do we see any way to compute <em>K</em><sub>ij</sub><em> </em>from <em>Y</em><sub>i</sub><em> </em>and <em>Y</em><sub>j</sub><em> </em>without first obtaining either <em>X</em><sub>i</sub><em> </em>or <em>X</em><sub>j</sub>.</p>&#13;
</blockquote>&#13;
<p>After discussing signatures (as <em>one-way authentication</em>) and computational complexity, the paper concludes,</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">We hope this will inspire others to work in this fascinating area in which participation has been discouraged in the recent past by a nearly total government monopoly.</p>&#13;
</blockquote>&#13;
<p>It certainly did.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="NFSR-nonlinear-feedback-shift-register">NFSR (nonlinear feedback shift register)</h2>&#13;
<p class="BodyCustom">See <a href="#Feedback-shift-register"><em>Feedback shift register</em></a>.</p>&#13;
<h2 id="NIST-National-Institute-of-Standards-and-Technology">NIST (National Institute of Standards and Technology)</h2>&#13;
<p class="BodyFirst">The agency responsible for US Federal standards in various technical fields, including cryptography. NIST cryptography standards and <span epub:type="pagebreak" title="80" id="Page_80"/>recommendations have included algorithms (such as DSS, AES, SHA-2, SHA-3, and so on), block cipher operation modes, SHA-3 variants (such as cSHAKE, KMAC, and TupleHash), key management, random generation, and statistical tests.</p>&#13;
<p>The design of NIST-standardized algorithms, such as AES and SHA-3, was crowdsourced to cryptographers from all around the world through a public, transparent process. This approach is believed to be more reliable than delegating cryptographic algorithms design to NSA.</p>&#13;
<h2 id="NIZK-non-interactive-zero-knowledge">NIZK (non-interactive zero-knowledge)</h2>&#13;
<p class="BodyFirst">A NIZK proof is a zero-knowledge proof that comes as a single message, as opposed to an interactive protocol involving multiple messages between a prover and a verifier. NIZK proofs often use the Fiat–Shamir heuristic to turn an interactive protocol into a noninteractive one.</p>&#13;
<h2 id="Noekeon">Noekeon</h2>&#13;
<p class="BodyFirst">A block cipher with a rare property: the encryption algorithm is the same as the decryption algorithm. This is convenient in environments with limited code, silicon, or developer time.</p>&#13;
<h2 id="Noise">Noise</h2>&#13;
<p class="BodyFirst">A framework for designing protocols using the Diffie–Hellman protocol. A Noise protocol can sometimes (but not always) replace TLS to implement transport security. This offers multiple potential benefits, including greater simplicity, identity hiding, and lower bandwidth usage.</p>&#13;
<h2 id="Nonce">Nonce</h2>&#13;
<p class="BodyFirst">In the context of cryptography, a <em>number used only once</em>. An additional input to some cryptographic operation whose value should always be unique. This ensures that the operation will always produce different outputs, even if all inputs are identical. In practice, guaranteeing nonce uniqueness isn’t always straightforward, and nonces are typically generated at random. Authenticated ciphers will usually use a nonce to ensure that if you encrypt the same message twice, the output ciphertext will look different, thereby preventing an attacker from noticing that the same message was encrypted again.</p>&#13;
<h2 id="Non-committing-encryption"><span epub:type="pagebreak" title="81" id="Page_81"/>Non-committing encryption</h2>&#13;
<p class="BodyFirst">Sounds like deniable encryption, but not necessarily deniable. Using non-committing encryption, a fake ciphertext can be created in such a way that it looks like a real one. It can be shown to have been created from any plaintext by revealing a key pair and random bits that connect the ciphertext to the plaintext.</p>&#13;
<h2 id="Non-outsourceability">Non-outsourceability</h2>&#13;
<p class="BodyFirst">A property of a proof-of-work scheme whose work cannot be outsourced without revealing the private key of the prover. So it prevents pooled mining, where third parties perform a share of the work and are supposed to get a share of the mining reward. Such a proof must be efficiently verifiable without the private key.</p>&#13;
<h2 id="Non-slanderability">Non-slanderability</h2>&#13;
<p class="BodyFirst">In the context of ring signatures, a security property that prevents an attacker from forging a valid signature that can be linked to a specific member of the group of authorized signers. Although expressed in slightly different terms, non-slanderability is equivalent to unforgeability.</p>&#13;
<h2 id="NSA-National-Security-Agency">NSA (National Security Agency)</h2>&#13;
<p class="BodyFirst">Cryptographers’ favorite three-letter agency. The NSA employs many cryptographers but never publishes in peer-reviewed conferences. However, it’s active in cryptography research, having designed established public standards (such as DSA, SHA-2, and the unfortunate Dual_EC_DRBG), unclassified candidate standards (the block ciphers SIMON and SPECK), declassified systems (the Fortezza crypto card, including the Skipjack block cipher), and many classified algorithms. The NSA’s cryptanalysis capabilities remain largely undocumented.</p>&#13;
<p class="BodyCustom">See <a href="#Suite-A"><em>Suite A</em></a>.</p>&#13;
<h2 id="NT-hash">NT hash</h2>&#13;
<p class="BodyFirst">Colloquially known as NTLM hash, the password hash function used in MS Windows’ NT LAN Manager (NTLM) protocol suite, and an upgrade from the legacy LAN Manager protocol. NT hash is just an <span epub:type="pagebreak" title="82" id="Page_82"/>MD4 hash of the encoded user password. It’s better than LM hash but is also easily cracked.</p>&#13;
<p class="BodyCustom">See <a href="#LM-hash"><em>LM hash</em></a>.</p>&#13;
<h2 id="NTRU-Nth-degree-Truncated-polynomial-Ring-Units">NTRU (<em>N</em>th degree Truncated polynomial Ring Units)</h2>&#13;
<p class="BodyFirst">One of the first lattice-based cryptosystems, designed in 1996. Under­studied for many years, perhaps because it was patented and commercialized.</p>&#13;
<p>Renewed interest in NTRU culminated in the 2016 design of NTRU Prime, an NTRU variant succinctly defined by its authors as “an efficient implementation of high-security prime-degree large-Galois-group inert-modulus ideal-lattice-based cryptography,” where “<em>Prime degree</em> etc. are three features that (. . .) take various mathematical tools away from the attacker.” NTRU Prime was submitted to NIST’s post-quantum competition.</p>&#13;
<h2 id="Null-cipher">Null cipher</h2>&#13;
<p class="BodyFirst">A term that means <em>no encryption</em> when encountered as a cipher suite. For example, early TLS versions supported the null cipher. The null cipher needs no key, and I suppose you could consider it the fastest cipher.</p>&#13;
<h1 id="letter-O"><span class="ChapterTitle">O</span></h1>&#13;
<h2 id="OAEP-Optimal-Asymmetric-Encryption-Padding">OAEP (Optimal Asymmetric Encryption Padding)</h2>&#13;
<p class="BodyFirst">Method for securely padding a message before public-key encryption with RSA or Rabin’s schemes. Computing <em>m</em><sup><em>e</em></sup><em> </em>mod <em>n </em>is indeed not a very safe way to use the RSA operation to encrypt a message <em>m</em>. Instead, OAEP can convert the message into a randomized string that breaks plain RSA’s malleability and homomorphicity. RSA-OAEP is now the recommended way to encrypt with RSA, following the PKCS#1 v2.2 standard.</p>&#13;
<p class="BodyCustom">See <a href="#All-or-nothing-transform-AONT"><em>All-or-nothing transform (AONT)</em></a>, <a href="#Manger-attack"><em>Manger attack</em></a>.</p>&#13;
<h2 id="Oblivious-key-management-system-OKMS">Oblivious key management system (OKMS)</h2>&#13;
<p class="BodyFirst">Service that holds master keys and interacts with clients to derive keys without knowing said keys due to (partially) oblivious PRFs used for key derivation.</p>&#13;
<h2 id="Oblivious-PRF-OPRF"><span epub:type="pagebreak" title="83" id="Page_83"/>Oblivious PRF (OPRF)</h2>&#13;
<p class="BodyFirst">A two-party protocol where a server knows the key <em>K </em>and a client computes PRF(<em>K</em>, <em>X</em>) for some <em>X </em>without learning <em>K </em>by interacting with the server, which must learn nothing about <em>X </em>or PRF(<em>K</em>, <em>X</em>).</p>&#13;
<p>Partially oblivious PRFs (pOPRFs) are a variant wherein the server can supply an additional nonsecret input.</p>&#13;
<h2 id="Oblivious-RAM-ORAM">Oblivious RAM (ORAM)</h2>&#13;
<p class="BodyFirst">An abstract model of secure memory, designed so an attacker learns nothing when they observe the content and access patterns of the memory a program uses. In particular, they shouldn’t learn what piece of data is being accessed or (to some extent) whether the access is a read or a modification of the stored data. In theory, an ORAM deals with actual RAM—as in memory a program uses—but in practice is more about ROM, a filesystem, or a database.</p>&#13;
<h2 id="Oblivious-transfer">Oblivious transfer</h2>&#13;
<p class="BodyFirst">A protocol to transfer data between two parties, where the receiver chooses which piece of data they want to receive among a multitude of pieces, but the sender doesn’t know which piece it is.</p>&#13;
<p>Imagine you want to buy and download an ebook from the No Starch Press online store but don’t want the publisher, Bill, to know which book you purchased. Normally, your ebook purchase request would ultimately lead to a query to No Starch’s database, a file transfer from some storage media to No Starch’s ebook service, and then to your device. The publisher could therefore find out which book you bought by monitoring the disk activity, database queries, file transfers, and so on.</p>&#13;
<p>Oblivious transfer prevents anyone from finding out which file was accessed, even if they monitored the precise data read from the storage medium. In addition, oblivious transfer guarantees to No Starch Press that you’re retrieving only one book, and that you’re not collecting information about others (the main feature that makes oblivious transfer different than private information retrieval).</p>&#13;
<h2 id="Obscurity">Obscurity</h2>&#13;
<p class="BodyFirst">A heresy for cryptographers. But in reality, when cryptography is just a part of a broader security system, you sometimes need to obscure its logic to meet your security goals.</p>&#13;
<h2 id="OCB-offset-codebook-mode"><span epub:type="pagebreak" title="84" id="Page_84"/>OCB (offset codebook mode)</h2>&#13;
<p class="BodyFirst">One of the simplest and most efficient authenticated encryption modes for block ciphers and a demonstration of cryptography’s fragility. Attackers managed to break OCB2, the second version of OCB, in spite of security proofs and standardization. OCB1 and OCB3, although very similar, seem to be secure.</p>&#13;
<h2 id="One-time-pad">One-time pad</h2>&#13;
<p class="BodyFirst">Often described as the paragon of encryption, or the perfect cipher, because it’s mathematically proven to be absolutely secure. But the one-time pad used on its own is actually a weak cipher: it’s trivially malleable, unauthenticated, and not misuse resistant.</p>&#13;
<h2 id="One-way-function">One-way function</h2>&#13;
<p class="BodyFirst">The cornerstone of modern cryptography. Easy to compute but hard to invert: a function <em>f</em>() is one-way if, given <em>f</em>(<em>x</em>) for a random unknown input <em>x</em>, finding a value <em>y </em>so that <em>f</em>(<em>y</em>) = <em>f</em>(<em>x</em>) is computationally hard. (The formal definition is more rigorous than this.)</p>&#13;
<p>You can construct most cryptographic primitives if all you have is a one-way function; in practice, many functions in cryptography, such as hash functions, appear to be one-way. But in theory, we have no proof that one-way functions actually exist. In fact, the existence of one-way functions implies P ≠ NP (the proof is left as an exercise for you to complete).</p>&#13;
<h2 id="Onion-AE">Onion-AE</h2>&#13;
<p class="BodyFirst">The notion of strong authenticated encryption in the context of Tor’s onion routing. In onion-AE encryption, the authenticity of a message must only be checked at the last (exit) node, yet covers the entire route of the message, from its initial sender.</p>&#13;
<h2 id="OPAQUE">OPAQUE</h2>&#13;
<p class="BodyFirst">Pronounced <em>O-PAKE</em>. The O represents oblivious PRF, the most interesting part of the OPAQUE password-authenticated key agreement (PAKE). It allows the client to compute the hash of a combination of two values when it knows only one of the two (its password).</p>&#13;
<p>There are some caveats: although authentication is about proving knowledge of a password, the client also needs a traditional public-key <span epub:type="pagebreak" title="85" id="Page_85"/>pair and must therefore protect its private key. Also, to get a full PAKE with secure shared key agreement, it must be combined with another protocol, such as HMQV.</p>&#13;
<p class="BodyCustom">See <a href="#Oblivious-PRF-OPRF"><em>Oblivious PRF (OPRF)</em></a>.</p>&#13;
<h2 id="OpenSSL">OpenSSL</h2>&#13;
<p class="BodyFirst">One of the most important pieces of cryptographic software. Foremost a command line utility that supports a multitude of cryptographic operations (key generation, signature, encryption, certificate creation, encoding/decoding of various formats, and so on) for a multitude of algorithms (block ciphers, hash functions, elliptic curves, and so on, as well as legacy algorithms) and their parameters, and that runs on numerous CPU types and operating systems.</p>&#13;
<p>If that isn’t enough, OpenSSL also provides two libraries: a cryptographic library (libcrypto) and an implementation of the SSL and TLS protocols (libssl), which uses libcrypto.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>OPENSSL’S KITCHEN</h2>&#13;
<p class="BoxBodyFirst">OpenSSL is like a 24/7 restaurant that offers burgers and pizza, as well as Japanese sushi, French coq au vin, Mexican tacos, and Swiss fondue. It’s extremely difficult to serve all dishes with the same level of quality.</p>&#13;
<p>It also means that the kitchen must be a real mess. As cryptography professor Matthew Green once said,</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">OpenSSL is the space shuttle of crypto libraries. It will get you to space, provided you have a team of people to push the ten thousand buttons required to do so.</p>&#13;
</blockquote>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Oracle">Oracle</h2>&#13;
<p class="BodyFirst">Rather like a crystal ball, an abstract entity that will respond to your requests, which cryptographers call oracle queries.</p>&#13;
<p>The idea of cryptographic oracles comes from the <em>oracles</em> of complexity theory, where, for example, you attempt to solve problem 1 using an oracle that magically gives you solutions to problem 2, given the description of an instance of problem 2. Given a factoring oracle, for instance, you can break RSA.</p>&#13;
<p><span epub:type="pagebreak" title="86" id="Page_86"/>Oracles are an abstraction used in research papers as a device to simplify security arguments, proofs, or cryptanalytic attacks. You might encounter encryption oracles, decryption oracles, factorization oracles, and many more. Random oracles are the most common because of their unique role in proofs of security.</p>&#13;
<p class="BodyCustom">See <a href="#Random-oracle"><em>Random oracle</em></a>.</p>&#13;
<h2 id="OTR-Off-the-Record">OTR (Off-the-Record)</h2>&#13;
<p class="BodyFirst">The end-to-end encryption protocol initially designed for synchronous communications. Capable of running atop messaging protocols, such as XMPP or IRC. A unique aspect of OTR is its deniability property, whereby peers can deny having sent a message by leaking the MAC key used to sign it. OTR is the basis for what became known as the Signal protocol.</p>&#13;
<h1 id="letter-P"><span class="ChapterTitle">P</span></h1>&#13;
<h2 id="Padding-oracle-attack">Padding oracle attack</h2>&#13;
<p class="BodyFirst">A class of side-channel attacks that exploit information about whether the padding of some encrypted message is valid. An attacker could learn that information by measuring the decryption execution time, which sometimes depends on the padding’s correctness. The most common padding oracle attacks are those applied to the CBC block cipher mode, the Bleichenbacher attack on PKCS#1 v1.5, and Manger attack on OAEP (PKCS#1 v2) encryption. The idea of padding oracles can be generalized to format oracles, which reveal the existence of some known pattern in the decrypted message (for example, a specific encoding or character set).</p>&#13;
<p>Developers have sometimes deployed countermeasures to padding oracle attacks accidentally—namely, when certain implementations don’t check the padding correctly (but this creates other problems).</p>&#13;
<p class="BodyCustom">See <a href="#Bleichenbacher-attack"><em>Bleichenbacher attack</em></a>, <a href="#CBC-cipher-block-chaining"><em>CBC (cipher block chaining)</em></a>, <a href="#Manger-attack"><em>Manger attack</em></a>.</p>&#13;
<h2 id="Paillier-cryptosystem"><span epub:type="pagebreak" title="87" id="Page_87"/>Paillier cryptosystem</h2>&#13;
<p class="BodyFirst">A public-key encryption scheme that is a bit more mathematically interesting than RSA, ElGamal, and IES. Paillier’s encryption has the rare property of additive homomorphism, meaning that Dec(Enc(<em>M</em><sub>1</sub>) × Enc(<em>M</em><sub>2</sub>)) = <em>M</em><sub>1</sub> + <em>M</em><sub>2</sub>. Its security is based on the hardness of the factoring problem as well as that of a related problem—the decisional composite residuosity problem, introduced with Paillier’s cryptosystem, which is about deciding whether there exists <em>x </em>such that <em>y </em>= <em>x</em><sup><em>d</em></sup><em> </em>mod <em>n</em><sup>2</sup> given <em>n </em>and <em>y</em>.</p>&#13;
<h2 id="Pairing">Pairing</h2>&#13;
<p class="BodyFirst">In public-key cryptography, nothing to do with the Bluetooth pairing operation. A pairing is a map <em>e</em>() of two group elements to an element from another group, with the following property, for any <em>R</em>, <em>S</em>, <em>T</em>:</p>&#13;
<p class="Equation"><em>e</em>(<em>R </em>+ <em>S</em>, <em>T</em>) = <em>e</em>(<em>R</em>, <em>T</em>)<em>e</em>(<em>S</em>, <em>T</em>)</p>&#13;
<p class="BodyContinued">This is called bilinearity and is what makes pairings useful in cryptography. These properties hold as well for a bilinear pairing:</p>&#13;
<p class="Equation"><em>e</em>(<em>S</em>, −<em>T</em>) = <em>e</em>(−<em>S</em>, <em>T</em>) = <em>e</em>(<em>S</em>, <em>T</em>)<sup>−1</sup></p>&#13;
<p class="Equation"><em>e</em>(<em>aS</em>, <em>bT</em>) = <em>e</em>(<em>S</em>, <em>T</em>)<sup><em>ab</em></sup><em/></p>&#13;
<p>The bilinear counterpart of the Diffie–Hellman problem for pairings is the following: given <em>P</em>, <em>aP</em>, <em>bP</em>, <em>cP</em>, find <em>e</em>(<em>P</em>, <em>P</em>)<sup><em>abc</em></sup>. For well-chosen types of pairing and elliptic curves, this problem is believed to be about as hard as its classical version.</p>&#13;
<h2 id="Pairing-based-cryptography">Pairing-based cryptography</h2>&#13;
<p class="BodyFirst">Cryptography that uses pairings, duh. Pairings on elliptic curves allow the creation of bilinear maps, which allow you to construct—under some hardness assumptions—secure functionalities that classical, discrete, logarithm-based elliptic-curve cryptography cannot. These functionalities include one-round three-party key agreement, identity-based encryption, attribute-based encryption, short signatures, and verifiable random functions.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="88" id="Page_88"/>TRIPARTITE KEY AGREEMENT</h2>&#13;
<p class="BoxBodyFirst">Cryptographers began using pairings in cryptography to achieve three-party key agreement in just one round of communication. With pairings, this works as follows, given a common base point <em>P</em>:</p>&#13;
<ul>&#13;
<li>Alice generates an integer <em>a </em>and broadcasts <em>aP</em><em/>.</li>&#13;
<li>Bob generates an integer <em>b </em>and broadcasts <em>bP</em><em/>.</li>&#13;
<li>Chris generates an integer <em>c </em>and broadcasts <em>cP</em>.</li>&#13;
</ul>&#13;
<p class="BoxBodyContinued">Then Alice computes the shared secret as <em>e</em>(<em>bP</em>, <em>cP</em>)<sup><em>a</em></sup> = <em>e</em>(<em>P</em>, <em>P</em>)<sup><em>abc</em></sup>. Bob and Chris run a similar operation to obtain the same value.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="PAKE-password-authenticated-key-exchange">PAKE (password-authenticated key exchange)</h2>&#13;
<p class="BodyFirst">An authenticated key agreement (or exchange) protocol where the client’s authentication relies on the knowledge of a password. In most PAKEs, the server doesn’t know the password but only some data derived from it. PAKEs where both parties know the password are called balanced PAKEs.</p>&#13;
<p>PAKEs try to prevent the straightforward password-guessing attacks possible in send-the-password-or-its-hash methods of key exchange. But this small benefit comes at a high cost: PAKEs add complexity and deployment cost, which is why they’re rarely used. As Matthew Green wrote, “Many people don’t want to run a <em>key exchange</em> protocol in the first place! They just want to verify that a user knows a password.”</p>&#13;
<h2 id="Paradigm">Paradigm</h2>&#13;
<p class="BodyFirst">An overused word in cryptography, especially when preceded by <em>new</em>.</p>&#13;
<h2 id="Password-hash-function">Password hash function</h2>&#13;
<p class="BodyFirst">A hash function whose goal is to be slow rather than fast.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>WHY FAST PASSWORD HASHES ARE INSECURE</h2>&#13;
<p class="BoxBodyFirst">If <em>M </em>is an arbitrary string of bits, then given a hash value <em>H </em>= Hash(<em>M</em>), you’ll never find <em>M</em>. The reason is that 1) finding any preimage of <em>H </em>will be computationally infeasible if <em>H </em>is long enough, and 2) even with infinite computing power, you’d have no way of singling out <em>M </em>among all the values that map to <em>H</em>, which is impossible, according to the pigeon-hole principle.</p>&#13;
<p><span epub:type="pagebreak" title="89" id="Page_89"/>But if you know that <em>M </em>is a password chosen by a human, retrieving it becomes much easier. You might be able to find a password <em>M </em>that hashes to <em>H </em>and be reasonably sure that it was the password hashed in the first place, because there are way fewer rememberable passwords than possible values of <em>H</em>. In other words, as an unknown input value, a typical password has much lower entropy than an arbitrary string.</p>&#13;
<p>The more you know about the person who chose the password, the easier this is, and the lower the password’s entropy. For example, if you know the person is a 65-year-old woman living in Tennessee, you’ll probably try a specific set of passwords; you’d try a different set if the person is a 20-year-old Swiss guy. The consequence of this is that passwords are fairly easy to find given their hash values: you just repeatedly hash possible passwords and compare the results with the given hash.</p>&#13;
<p>The mitigation we use is very dumb, but it works: instead of using a secure and efficient hash function, we use a function that is secure but inefficient—slow to compute and sometimes also uses large amounts of memory (which makes password cracking even more difficult when using GPUs or dedicated hardware).</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="PBKDF2-Password-Based-Key-Derivation-Function-2">PBKDF2 (Password-Based Key Derivation Function 2)</h2>&#13;
<p class="BodyFirst">Password-based key derivation function, second version of the standard. PBKDF2 is the poor man’s password hash. It’s good enough in most cases when tuned with enough iterations, but it’s not as cool as Argon2.</p>&#13;
<h2 id="PCT-Private-Communications-Technology">PCT (Private Communications Technology)</h2>&#13;
<p class="BodyFirst">Microsoft’s secure communication protocol. PCT competed with SSL v3 in the mid-1990s. PCT intended to address SSL v2’s flaws yet be somewhat compatible with it. But only Microsoft has used it, and it was ultimately replaced by SSL v3 or TLS everywhere.</p>&#13;
<h2 id="PEP-Plaintext-equivalence-proof">PEP (Plaintext equivalence proof)</h2>&#13;
<p class="BodyFirst">A protocol that checks whether two ciphertexts are encryptions of the same value. Participants cannot cheat.</p>&#13;
<h2 id="Perfect-forward-secrecy">Perfect forward secrecy</h2>&#13;
<p class="BodyCustom">See <a href="#Forward-secrecy"><em>Forward secrecy</em></a>.</p>&#13;
<h2 id="Permutation-based-cryptography"><span epub:type="pagebreak" title="90" id="Page_90"/>Permutation-based cryptography</h2>&#13;
<p class="BodyFirst">Cryptographic schemes that leverage a single permutation to provide other functionalities. It’s based on research related to the Keccak hash function.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>A Bestiary OF PERMUTATION-BASED CRYpTO</h2>&#13;
<p class="BoxBodyFirst">Permutation-based cryptography from the Keccak extended family includes many constructions, modes, and primitives, which we’ve tried to inventory in the following subdictionary:</p>&#13;
<ul>&#13;
<li>SHAKE, a XOF (part of the FIPS 202 standard)</li>&#13;
<li>cSHAKE, variant of SHAKE (part of NIST SP 800-185)</li>&#13;
<li>KMAC, a variable-length MAC (part of NIST SP 800-185)</li>&#13;
<li>ParallelHash, a parallelizable XOF (part of NIST SP 800-185)</li>&#13;
<li>TupleHash, a XOF designed to hash tuples of data (part of NIST SP 800-185)</li>&#13;
<li>Duplex, an extension of the sponge construction</li>&#13;
<li>MonkeyDuplex, a variant of Duplex to build authentication encryption schemes</li>&#13;
<li>DonkeySponge, a variant of Duplex to build MACs</li>&#13;
<li>Keccup, a reduced-round version of Keccak</li>&#13;
<li>Ketje (and its versions Ketje Jr, Ketje Sr, Ketje Minor, and Ketje Major), a lightweight authenticated cipher</li>&#13;
<li>Keyak (and its versions River, Lake, Sea, Ocean, and Lunar Keyak), an authenticated cipher</li>&#13;
<li>KangarooTwelve, a fast parallel XOF</li>&#13;
<li>Dec (doubly extendable cryptographic) functions</li>&#13;
<li>Deck (doubly extendable cryptographic keyed) functions</li>&#13;
<li>Kravatte, a deck function, coming with KravatteModes, modes on top of it</li>&#13;
<li>Farfalle, a construction to build a deck function</li>&#13;
<li>Cyclist, the mode of operation of Xoodyak</li>&#13;
<li>Motorist, the mode of operation of Keyak</li>&#13;
<li>Xoofff, a deck function, coming with XoofffModes, modes on top of it</li>&#13;
<li>Xoofffie, a variant of Xoofff</li>&#13;
<li>Xoodoo, a family of permutations</li>&#13;
<li>Xoodyak, a lightweight scheme (performing authenticated encryption, MAC, hashing, and so on)</li>&#13;
<li><span epub:type="pagebreak" title="91" id="Page_91"/>Mixifer, a 256-bit permutation</li>&#13;
<li>Mr. Monster Burrito, a variable-length block cipher</li>&#13;
</ul>&#13;
<p class="BoxBodyContinued">Most likely, this is an incomplete list of the Keccak bestiary, but gives you an idea of the creativity and innovation of the Keccak designers.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="PES-Proposed-Encryption-Standard">PES (Proposed Encryption Standard)</h2>&#13;
<p class="BodyFirst">A block cipher presented at Eurocrypt 1990. It didn’t become a standard.</p>&#13;
<p class="BodyCustom">See <a href="#IDEA-International-Data-Encryption-Algorithm"><em>IDEA</em></a>, <a href="#IPES-Improved-Proposed-Encryption-Standard"><em>IPES</em></a>.</p>&#13;
<h2 id="PET-Plaintext-equivalence-test">PET (Plaintext equivalence test)</h2>&#13;
<p class="BodyFirst">A protocol that checks whether two ciphertexts are encryptions of the same value. But participants can cheat.</p>&#13;
<h2 id="PFS">PFS</h2>&#13;
<p class="BodyFirst">A secret advanced cryptography think tank.</p>&#13;
<p class="BodyCustom">See <a href="#Forward-secrecy"><em>Forward secrecy</em></a>.</p>&#13;
<h2 id="PGP-Pretty-Good-Privacy">PGP (Pretty Good Privacy)</h2>&#13;
<p class="BodyFirst">The first major, public cryptography software, developed in the early 1990s. PGP later became an enterprise encryption product. Currently, pgp.com redirects to broadcom.com, because Symantec acquired the PGP company and Broadcom later acquired Symantec. The OpenPGP message format and the GnuPG (GPG) software are the open source legacies of PGP. In 2020, PGP remains the de facto standard for email encryption and is used by major enterprise and open source email encryption software.</p>&#13;
<p>PGP is often called broken, mostly because the 1990s design didn’t anticipate security requirements of the 2010s. Also, its software implementations turned out to have security flaws—as pretty much all software does.</p>&#13;
<h2 id="Photuris">Photuris</h2>&#13;
<p class="BodyFirst">The Latin name for a genus of fireflies. Also, a session-key management protocol for IPSec that is, according to <em>informed speculation</em>, similar to NSA’s FIREFLY protocol (allegedly part of Suite A and used in EKMS).</p>&#13;
<p class="BodyCustom">See <a href="#Suite-A"><em>Suite A</em></a>.</p>&#13;
<h2 id="Picnic"><span epub:type="pagebreak" title="92" id="Page_92"/>Picnic</h2>&#13;
<p class="BodyFirst">A post-quantum signature scheme that doesn’t fit in any of the established categories of post-quantum schemes. A Picnic signature proves the signer’s knowledge of the key to a block cipher, given a plaintext-ciphertext pair as a public key.</p>&#13;
<p>Picnic achieves this by using a noninteractive proof of knowledge and a block cipher (lowMC) that lends itself to such proofs.</p>&#13;
<h2 id="PKC">PKC</h2>&#13;
<p class="BodyFirst">Officially, “The International Conference on Practice and Theory in Public Key Cryptography.” The PKC conference is to public-key cryptography what FSE is to symmetric cryptography, but it covers more diverse and mathematical topics.</p>&#13;
<p>Researchers present peer-reviewed research papers with titles such as “Safety in Numbers: On the Need for Robust Diffie–Hellman Parameter Validation”<em> </em>and “Committed MPC—Maliciously Secure Multiparty Computation from Homomorphic Commitments.”</p>&#13;
<p class="BodyCustom">See <a href="#ASIACRYPT"><em>Asiacrypt</em></a>, <a href="#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems"><em>CHES</em></a>, <a href="#CRYPTO"><em>CRYPTO</em></a>, <a href="#Eurocrypt"><em>Eurocrypt</em></a>, <a href="#FSE-Fast-Software-Encryption"><em>FSE</em></a>, <a href="#Real-World-Crypto-RWC"><em>Real World Crypto</em></a>, <a href="#TCC"><em>TCC</em></a>.</p>&#13;
<h2 id="PKCS-Public-Key-Cryptography-Standards">PKCS (Public Key Cryptography Standards)</h2>&#13;
<p class="BodyFirst">A series of cryptographic standards issued by the RSA Security firm in the 1990s. Of the 15 PKCS standards, the best known are probably the following:</p>&#13;
<ul>&#13;
<li>PKCS#1, also RFC 8017, is about RSA-based encryption and signature. An earlier version (1.5) defined an RSA encryption scheme vulnerable to Bleichenbacher’s padding oracle attack. Later versions, starting with 2.0, defined instead OAEP-based RSA encryption, which is less vulnerable to padding oracle attacks.</li>&#13;
<li>PKCS#7, also RFC 2315, is best known for its definition of the block cipher padding scheme but is mainly about data formatting and encoding.</li>&#13;
<li>PKCS#11 is a standard API to interact with a cryptographic module, such as that of an HSM.</li>&#13;
</ul>&#13;
<h2 id="Poly1305"><span epub:type="pagebreak" title="93" id="Page_93"/>Poly1305</h2>&#13;
<p class="BodyFirst">A one-time MAC best known as the authenticator component in the <em>ChaChaPoly</em> authenticated cipher, as well as ChaCha20-Poly1305. It’s supported in TLS, OpenSSH, and many other applications.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>FROM POLY1305 TO CHACHA20-POLY1305</h2>&#13;
<p class="BoxBodyFirst">In this context, <em>poly</em> refers to polynomial evaluation. To compute the MAC of a message, Poly1305 evaluates a polynomial</p>&#13;
<p class="BoxEquation">poly = <em>c</em><sub>1</sub><em>r </em>+ <em>c</em><sub>2</sub><em>r</em><sup>2</sup> + <em>· · · </em>+ <em>c</em><sub>n</sub><em>r</em><sup><em>n</em></sup> mod <em>p</em></p>&#13;
<p>where the <em>c</em><sub>i</sub> coefficients are blocks of the message to be authenticated and <em>r </em>is a 16-byte secret key. The value poly is therefore a number less than <em>p </em>= 2<sup>130</sup> – 5, or <code>(1 &lt;&lt; 130) </code><code>−</code><code> 5</code> in pseudocode (don’t write this in a C program; it won’t work). The final value of the MAC is (poly + <em>s</em>) mod 2<sup>128</sup>, where <em>s </em>is another 16-byte secret key.</p>&#13;
<p>In its initial form, Poly1305 took as input a 32-byte key <em>k </em>and a per-message nonce <em>n</em>. It then computed <em>s </em>by AES-encrypting <em>n </em>with the first 16 bytes of <em>k </em>as a key and using the last 16 bytes of <em>k</em> as <em>r</em>. <em>ChaChaPoly</em> computes <em>r </em>and <em>s </em>by instead hashing the key and nonce supplied to the authenticated cipher to a 32-byte string. AES is thus not used.</p>&#13;
<p>On paper, Poly1305 is simple, but its nonstandard arithmetic modulo 2<sup>130</sup> − 5 and key generation mechanism have sometimes proved confusing to implementers.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Polynomial-complexity">Polynomial complexity</h2>&#13;
<p class="BodyFirst">Practical complexity, most of the time.</p>&#13;
<h2 id="Post-compromise-security">Post-compromise security</h2>&#13;
<p class="BodyFirst">A term used mostly in the context of secure messaging to denote a notion similar to backward secrecy.</p>&#13;
<p class="BodyCustom">See <a href="#Backward-secrecy"><em>Backward secrecy</em></a>.</p>&#13;
<h2 id="Post-quantum-cryptography">Post-quantum cryptography</h2>&#13;
<p class="BodyFirst">Cryptography schemes designed to remain unbreakable by quantum algorithms. Therefore, they can resist the hypothetical quantum computers of the future. Also termed quantum-safe and quantum-resilient.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="94" id="Page_94"/>DIGGING INTO POST-QUANTUM CRYPTO</h2>&#13;
<p class="BoxBodyFirst">Post-quantum cryptography mainly targets public-key schemes (signature, encryption, key agreement) rather than symmetric schemes, because the latter are mostly immune to quantum attacks. For example, symmetric ciphers can thwart the asymptotically quadratic speedup of Grover’s algorithm by simply doubling the key length, and superpolynomial speedups only occur in peculiar circumstances.</p>&#13;
<p>To be post-quantum, an algorithm mustn’t rely on the factoring or discrete logarithm problems, both of which break when subjected to Shor’s quantum algorithm. Instead, they can rely on NP-hard problems. Most of the proposed post-quantum algorithms fall into one of the following categories, depending on the hard computational problems on which they build their security:</p>&#13;
<ul>&#13;
<li>Code-based, relying on error-correcting codes’ decoding problems</li>&#13;
<li>Multivariate systems of equations</li>&#13;
<li>Lattice-based, with problems such as learning with errors (LWE)</li>&#13;
<li>Hash-based, or hash tree constructions using cryptographic hash functions</li>&#13;
<li>Isogenies of elliptic curves</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Post-quantum-RSA">Post-quantum RSA</h2>&#13;
<p class="BodyFirst">RSA so big that it’s practically immune to quantum attacks as well as to any practical application. A public key of post-quantum RSA is of the order of one terabyte. Post-quantum RSA has been submitted to NIST’s post-quantum cryptography standardization project.</p>&#13;
<h2 id="Prediction-resistance">Prediction resistance</h2>&#13;
<p class="BodyFirst">A term notably used by NIST to refer to a notion similar to backward secrecy. Prediction resistance is the opposite of backtracking resistance.</p>&#13;
<p>See <em>Backward secrecy</em>.</p>&#13;
<h2 id="Preimage">Preimage</h2>&#13;
<p class="BodyFirst">The hash function problem of finding some <em>M </em>so that Hash(<em>M</em>) = <em>H </em>given the value <em>H</em>. If <em>H </em>was chosen by picking some <em>M</em><sub>0</sub> at random (among a large enough finite set of possible messages) and computing <em>H</em> = Hash(<em>M</em><sub>0</sub>), then even with unlimited computational power, an <span epub:type="pagebreak" title="95" id="Page_95"/>attacker can never identify <em>M</em><sub>0</sub> with certainty unless <em>M</em><sub>0</sub> is the only value that hashes to <em>H</em>.</p>&#13;
<p>But in practice, the message sets we deal with are much larger than the hash size; thus, any <em>H </em>will have many preimages. Also, nobody actually has unlimited computational power. Finding any preimage would cost 2<sup><em>n</em></sup>, which is practically impossible, even if the hash values are as short as <em>n </em>= 128 bits.</p>&#13;
<h2 id="PRESENT">PRESENT</h2>&#13;
<p class="BodyFirst">Anagram of Serpent. A block cipher that works a lot like Serpent (­surprise) but smaller. Marketed as an <em>ultra lightweight cipher</em>, PRESENT has 64-bit blocks like DES and supports 80-bit and 128-bit keys. According to some very academic understanding of <em>broken</em>, PRESENT is broken by biclique cryptanalysis, with respectively 2<sup>79.76</sup> and 2<sup>127.91</sup> complexities. But PRESENT remains safe to use, and it was standardized by ISO. A variant of PRESENT, named <em>GIFT</em>, is described as <em>a small PRESENT</em>.</p>&#13;
<h2 id="PRIMES">PRIMES</h2>&#13;
<p class="BodyFirst">The decisional problem of determining whether a given integer is a prime number.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>PRIMES Is IN P</h2>&#13;
<p class="BoxBodyFirst">Known to be in the P complexity class since the 2002 AKS test, the PRIMES problem is also in NP, the class of problems for which a valid solution can be verified to be correct in polynomial time. The result that PRIMES is in NP is actually less obvious than it might sound, because it requires the demonstration of the existence of proofs of primality whose size is a polynomial function of the prime’s length.</p>&#13;
<p>Computer scientist Vaughan Pratt first demonstrated this result in 1975, at MIT. He later commented the following in an email:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">That the primes are in NP (and hence in delta-P, the intersection of NP and co-NP) was known informally since the 1960s (i.e., well before the concept of NP itself) to the very small set of people (which Rich Schroeppel and Bob Floyd told me they belong to) who’d noticed that the Lucas–Lehmer test was not just a heuristic like many other tests for primality (which was how the LL test was invariably described back then) but actually was applicable in some sense to *every* prime. In the absence of the concept of NP, the obstacle to finding a suitable sense of this fact was the difficulty of finding <span epub:type="pagebreak" title="96" id="Page_96"/>a suitable primitive root and factorizing <em>n</em>-1. The NP concept creates a meaningful setting in which it makes sense to simply guess a good primitive root and the factors of <em>n</em>-1 and then verify the guess afterwards. I’d been aware of this test since the 60s, but it was not until Karp’s NP concept had appeared that I noticed that the test put the primes in NP by being applicable to every prime. I didn’t think to write this up however, or even bother to mention it to anyone, since it seemed so obvious, until I mentioned it in some other context to Albert Meyer. When he said that this couldn’t be true or he’d have heard about it, I wrote it up to show him, and the writeup ended up a couple of years later in print (SiComp 4:3, 214-220, 1975). The point of the <em>every</em> in <em>every prime has a succinct certificate</em> was to emphasize that the Lucas-Lehmer test was more than just a heuristic that worked only for some primes. Some minor additional analysis turned out to be necessary to make the argument stick.</p>&#13;
</blockquote>&#13;
<p>A year after Pratt’s publication, Gary Miller proved that PRIMES is in P if the Extended Riemann Hypothesis holds. (The hypothesis is believed to be true but remains unproven.) In 1977, Robert Solovay and Volker Strassen showed a randomized primality testing algorithm to demonstrate that PRIMES is in BPP (the class of algorithms solvable in polynomial time by randomized algorithms).</p>&#13;
<p>But the most common primality testing algorithm is the Miller–Rabin algorithm, a modification of Miller’s initial algorithm by Michael Rabin. It’s the ­algorithm used in most libraries when performing key generation for public-key schemes, such as RSA, that rely on prime numbers. If you run the Miller–Rabin multiple times, you can make its probability of error arbitrarily small, because it will declare a composite number as composite with probability at least 1 − (1/4)<sub>n</sub><em> </em>when repeated <em>n </em>times. Too few iterations risk mistaking composite numbers for primes. An attacker could even craft composite numbers that have an unusually high chance of being declared primes by the Miller–Rabin test, as observed in the 2018 paper “Prime and Prejudice: Primality Testing Under Adversarial Conditions.”</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Privacy-preserving">Privacy-preserving</h2>&#13;
<p class="BodyFirst">A broad qualifier encompassing techniques and technologies that attempt to minimize the exposure of privacy-sensitive data, such as personally identifiable information, geolocation, social graph, online activity, and so on.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="97" id="Page_97"/>EXAMPLES OF PRIVACY-PRESERVING TECHNOLOGIES</h2>&#13;
<p class="BoxBodyFirst">The following are examples of privacy-preserving technologies, not all of which make heavy use of cryptography:</p>&#13;
<ul>&#13;
<li>Data analytics that processes data in a sanitized form to restrict the amount of information to what the application needs (for example, translating a person’s exact age into an age range).</li>&#13;
<li>Differential privacy techniques, for example, where data is made slightly inaccurate on purpose to hide its exact value, yet provides enough information to be useful.</li>&#13;
<li>The Signal application’s private contact discovery technique, leveraging the Intel SGX technology to prevent users’ contact lists to be directly exposed to the Signal servers, yet allowing users to find out who of their contacts are using the application.</li>&#13;
<li>Homomorphic encryption and searchable encryption, which can perform operations on encrypted data, thus keeping it confidential.</li>&#13;
<li>Tor’s onion routing, which prevents any host from knowing the source and destination of a message.</li>&#13;
<li>Contact tracing protocols considered to identify COVID-19–infected persons while preventing the tracking of users’ activity, social graph, and geolocation.</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Private-information-retrieval-PIR">Private information retrieval (PIR)</h2>&#13;
<p class="BodyFirst">Similar to oblivious transfer except the amount of information to be retrieved isn’t limited. Both PIR and oblivious transfer attempt to conceal the client’s activity to the database host, but PIR assumes <em>self-service</em>, whereas oblivious transfer restricts the client’s access to one-in-many access.</p>&#13;
<p class="BodyCustom">See <a href="#Oblivious-transfer"><em>Oblivious transfer</em></a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>PROOFS OF . . .</h2>&#13;
<p class="BoxBodyFirst">The validation of blockchain transactions requires spending or owning some resource. This prevents arbitrary and efficient forking into alternative histories, which would enable double spending and other attacks.</p>&#13;
<p><span epub:type="pagebreak" title="98" id="Page_98"/>This design choice has led to a renewed interest in proofs of work, which we can trace back to at least anti-spam defense in the early 1990s and to the creation of other proofs where work is something other than just CPU usage. These proofs of resource often appear motivated by blockchain applications but usually aren’t specific to blockchain use cases (unlike the proof of burn).</p>&#13;
<p>For an inventory of some of the proposed methods—besides the main and most general notions of proof of work and proof of stake—see <em>Proof of burn</em>, <em>Proof of catalytic space</em>, <em>Proof of human work</em>, <em>Proof of reserve</em>, <em>Proof of sequential work</em>, <em>Proof of space</em>, <em>Proof of spacetime</em>, <em>Proof of storage</em>, <em>Proof of useful work</em>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Proof-of-burn">Proof of burn</h2>&#13;
<p class="BodyFirst">Perhaps the most straightforward type of resource usage proof proposed for a consensus protocol. Proof of burn consists of nullifying the value of tokens or other digital assets associated with the protocol, for example, by sending them to some unspendable address, the blockchain equivalent of <code>/dev/null</code>. This differs from proofs of stake, where the value owned isn’t destroyed.</p>&#13;
<h2 id="Proof-of-catalytic-space">Proof of catalytic space</h2>&#13;
<p class="BodyFirst">A variant of proofs of space wherein the space isn’t completely wasted but can be used to store data unrelated to the proof. This leverages the concept of catalytic space computation, where a program can use some memory region even if it’s already used to store data, and return said region in its original state after completing its task.</p>&#13;
<h2 id="Proof-of-human-work">Proof of human work</h2>&#13;
<p class="BodyFirst">Proof of work whose work isn’t a computationally intensive task but one that is relatively easy for humans, yet hard for computers and AI programs. An idea proposed it to rely on CAPTCHAs generated using obfuscated programs to prevent the machine generating CAPTCHAs to solve them.</p>&#13;
<h2 id="Proof-of-replication">Proof of replication</h2>&#13;
<p class="BodyFirst">An extension of proof of storage to prove that multiple replicas of a piece of data are being stored instead of a single real copy and pointers to it. One technique used to realize proof of replication involves depth-robust graphs, a notion from graph theory rediscovered in the context of memory-hard password hashing.</p>&#13;
<h2 id="Proof-of-reserve"><span epub:type="pagebreak" title="99" id="Page_99"/>Proof of reserve</h2>&#13;
<p class="BodyFirst">Not a proof of resource associated to consensus protocols, but a proof that one account or organization owns a certain amount of coins. A proof of reserve can be publicly verifiable, for example, by issuing a special transaction from an address that controls the funds to be verified. It can also be private and/or notarized on a private ledger, for example, by signing a timestamped message provided by auditors.</p>&#13;
<p>A proof of reserve can be considered a proof of stake without the lottery mechanism and without being tied to any decentralized protocol.</p>&#13;
<h2 id="Proof-of-security">Proof of security</h2>&#13;
<p class="BodyCustom">See <a href="#Security-proof"><em>Security proof</em></a>.</p>&#13;
<h2 id="Proof-of-sequential-work">Proof of sequential work</h2>&#13;
<p class="BodyFirst">Proof of work for which parallelism is useless, because operations must be carried out sequentially. As with parallelizable proofs of work, a solution to the puzzle must be verifiable efficiently.</p>&#13;
<p>Like verifiable delay functions (VDFs), proofs of sequential work can be used to add an incompressible delay in decentralized applications. They also face the same technical challenges of associating an actual time latency to a series of operations. Unlike with VDFs, a proof of sequential work doesn’t admit a unique precomputable solution, which restricts its number of applications.</p>&#13;
<p class="BodyCustom">See <a href="#Time-lock-puzzle"><em>Time-lock puzzle</em></a>, <a href="#Verifiable-delay-function-VDF"><em>Verifiable delay function (VDF)</em></a>.</p>&#13;
<h2 id="Proof-of-space">Proof of space</h2>&#13;
<p class="BodyFirst">A demonstration that a prover has certain amount of memory at their disposal. For example, a prover might have to allocate one terabyte to convince a verifier, and the verifier won’t accept any proof from a prover that allocated less than a terabyte. Wasting memory with proofs of space is arguably more ecological than wasting CPU time with proofs of work.</p>&#13;
<h2 id="Proof-of-spacetime">Proof of spacetime</h2>&#13;
<p class="BodyFirst">An extension of proof of storage to efficiently demonstrate that a piece of data (or multiple replicas thereof) has been stored throughout a given period of time. Proofs of spacetime can be realized by combining proofs of replication. Used by the Filecoin project, proofs of spacetime ensure that hosts rewarded to store data aren’t cheating.</p>&#13;
<h2 id="Proof-of-stake"><span epub:type="pagebreak" title="100" id="Page_100"/>Proof of stake</h2>&#13;
<p class="BodyFirst">An environment-friendly counterpart of proofs of work where miners holding a greater amount of tokens have a greater chance to validate transactions; they receive the reward by a kind of lottery system. The richest thus get richer faster by doing nothing other than <em>staking</em>, by running a node and keeping it online.</p>&#13;
<p>Proof of stake blockchains usually require a certain table stake amount to participate on the network.</p>&#13;
<h2 id="Proof-of-storage">Proof of storage</h2>&#13;
<p class="BodyFirst">Proof that some piece of data is being stored (or at least known, or possible to be generated). Concepts such as provable data possession and proof of retrieveability are examples of proofs of storage. The most straightforward proof system is one where the verifier sends some challenge <em>c</em> and the prover returns Hash(<em>c</em>||<em>M</em>) where <em>M </em>is the data whose storage is to be verified.</p>&#13;
<h2 id="Proof-of-useful-work">Proof of useful work</h2>&#13;
<p class="BodyFirst">When the proof of work is not completely wasteful, but compute time is used to contribute to solving some computational problem.</p>&#13;
<h2 id="Proof-of-work">Proof of work</h2>&#13;
<p class="BodyFirst">Cryptography’s contribution to environmental problems.</p>&#13;
<h2 id="Provable-security">Provable security</h2>&#13;
<p class="BodyFirst">For some cryptographers, the only acceptable security—as opposed to unscientific, unacceptably risky heuristic security.</p>&#13;
<p>This simplistic goal is now less common, and provable security is now considered more of an additional insurance than as something required by all means necessary.</p>&#13;
<p>For example, an algorithm such as AES is not <em>provably secure</em>, and public-key schemes, such as RSA or ECDSA, are only proven secure insofar as their underlying computational problems are hard.</p>&#13;
<h2 id="Provably-secure">Provably secure</h2>&#13;
<p class="BodyFirst">“If it’s provably secure, it’s probably not,” to quote cryptographer Lars Knudsen (then in the context of block ciphers). This folklore adage might come from the block cipher COCONUT98, which was proven to be secure against a class of differential cryptanalysis techniques but <span epub:type="pagebreak" title="101" id="Page_101"/>ended up being broken by a yet unknown type of differential attack (boomerang).</p>&#13;
<h2 id="Proxy-re-encryption">Proxy re-encryption</h2>&#13;
<p class="BodyFirst">A public-key encryption scheme where a ciphertext for Alice (created using her public key) can be turned into a ciphertext for Bob without exposing the plaintext—in other words, without decrypting and re-encrypting. For example, proxy re-encryption can be realized (in theory) thanks to indistinguishability obfuscation by creating an obfuscated program that decrypts and re-encrypts a ciphertext without exposing the plaintext.</p>&#13;
<h2 id="Pseudo-random">Pseudo-random</h2>&#13;
<p class="BodyFirst">Hyphenated spelling of <em>pseudorandom</em>. But in English, compounds created by the addition of a prefix are usually not hyphenated (for example, pseudoscience, cryptocommunist, and antisocial). Among research papers on the IACR ePrint archive, the use of <em>pseudorandom</em> is about twice as frequent as <em>pseudo-random</em>.</p>&#13;
<h2 id="Pseudorandom-function-PRF">Pseudorandom function (PRF)</h2>&#13;
<p class="BodyFirst">Not actually a single function but a family of many functions; each is indexed by its secret key. The security goal of a PRF is to be indistinguishable from a truly random function if you don’t know the key and only see input–output pairs, even when choosing input values.</p>&#13;
<p>You can use PRFs as secure MACs, but a secure MAC isn’t necessarily a secure PRF.</p>&#13;
<h2 id="Pseudorandom-number-generator-PRNG">Pseudorandom number generator (PRNG)</h2>&#13;
<p class="BodyFirst">A system generating random-looking data with the security guarantee that an attacker that knows any subset of the output bits cannot determine any other output bits. The theoretical definition of a PRNG differs from its colloquial usage. </p>&#13;
<p>In theory, a PRNG is a (deterministic) algorithm that takes as input a value (seed) of fixed size and returns a longer output value. In practice, a PRNG often refers to all the components involved in the generation of pseudorandom bits, for example, in the context of an operating system’s PRNG. Such a PRNG usually includes the following components:</p>&#13;
<ul>&#13;
<li>Entropy collectors from analog sources, such as user activity, temperature measurements, and on-chip sensors—sometimes referred <span epub:type="pagebreak" title="102" id="Page_102"/>to as true random generators, although their (digital) output is rarely guaranteed to be cryptographically safe, or even uniformly distributed.</li>&#13;
<li>A mechanism to store an internal state, such as <em>entropy pools</em>, including the logic to update it and perform <em>reseeding</em> operations from entropy collectors.</li>&#13;
<li>A deterministic random bit generator (DRBG), which produces an arbitrarily long output from a seed derived from the internal state.</li>&#13;
</ul>&#13;
<h2 id="Pseudorandom-permutation-PRP">Pseudorandom permutation (PRP)</h2>&#13;
<p class="BodyFirst">To a permutation what a PRF is to a hash function. A block cipher is a PRP.</p>&#13;
<h2 id="Public-key-cryptography">Public-key cryptography</h2>&#13;
<p class="BodyFirst">All cryptography, excluding symmetric cryptography.</p>&#13;
<h2 id="PUF-physically-unclonable-function">PUF (physically unclonable function)</h2>&#13;
<p class="BodyFirst">A physical component on semiconductor devices that leverages minute differences between each different platform to generate unpredictable values, such as identifiers. Although sometimes advertised as semi-magical technology, many PUFs have been shown to be cryptographically weaker than claimed.</p>&#13;
<h2 id="Puncturable-encryption">Puncturable encryption</h2>&#13;
<p class="BodyFirst">Public-key encryption augmented with a <em>puncture</em> operation. This operation creates a new private key to replace the current one to forever revoke the decryption capability for certain ciphertexts that the previous key could decrypt. One motivation for this is to be able to provide forward secrecy for certain messages, even though they were encrypted with the same public key.</p>&#13;
<p>You can create puncturable symmetric encryption from puncturable PRFs.</p>&#13;
<h2 id="Puncturable-pseudorandom-function-PPRF">Puncturable pseudorandom function (PPRF)</h2>&#13;
<p class="BodyFirst">Similar to puncturable encryption. PRFs whose keys can be updated to revoke the capability to process certain values.</p>&#13;
<h1 id="letter-Q"><span class="ChapterTitle"><span epub:type="pagebreak" title="103" id="Page_103"/>Q</span></h1>&#13;
<h2 id="Quantum-computer">Quantum computer</h2>&#13;
<p class="BodyFirst">According to some experts, has a 1/7 chance of breaking RSA-2048 by 2026 and a 1/2 chance by 2031. In truth, nobody knows if you’ll see a quantum computer breaking RSA-2048 in your lifetime.</p>&#13;
<h2 id="Quantum-cryptography">Quantum cryptography</h2>&#13;
<p class="BodyFirst">Cryptographic operations that rely on quantum phenomena and don’t necessarily need a quantum computer, such as quantum key distribution. Quantum cryptography happens to be post-quantum but doesn’t belong to the field of post-quantum cryptography.</p>&#13;
<h2 id="Quantum-encryption">Quantum encryption</h2>&#13;
<p class="BodyFirst">Encryption of quantum states as opposed to strings of classical bits. The most basic form of this is the quantum one-time pad, which you can think of as a combination of quantum teleportation (to transmit the encrypted state) and a classical one-time pad (the bits required to read the decrypted state).</p>&#13;
<p>The quantum one-time pad looks less efficient than its classical counterpart, requiring two classical bits of key for each bit of information encrypted. But it’s also more powerful, because it can be leveraged to build secure homomorphic and multi-party computation schemes.</p>&#13;
<h2 id="Quantum-key-distribution">Quantum key distribution</h2>&#13;
<p class="BodyFirst">Sometimes confused with post-quantum cryptography, but different and of lower practical value. The best known is the <em>BB84</em> key agreement protocol</p>&#13;
<p class="BodyCustom">See <a href="#BB84"><em>BB84</em></a>.</p>&#13;
<h2 id="Quantum-signature">Quantum signature</h2>&#13;
<p class="BodyFirst">An impossible scheme, because the classical notion of a signature doesn’t apply to quantum states. Intuitively, you should see why: any party that can learn information about a quantum state can also modify it. In particular, it’s impossible to attach a signature to a quantum state, as you would do with a classical message. More generally, <span epub:type="pagebreak" title="104" id="Page_104"/>quantum states cannot be authenticated unless they’re also encrypted, so that only the intended recipient can decrypt them. But although quantum signing isn’t possible, quantum signcryption is.</p>&#13;
<h2 id="QUIC-Quick-UDP-Internet-Connections">QUIC (Quick UDP Internet Connections)</h2>&#13;
<p class="BodyFirst">A transport security protocol designed to make HTTPS connections more reliable under poor conditions (packet loss, IP roaming, and so on), notably by running over UDP rather than TCP. Using UDP saves it from the latency cost of the TCP handshake. It also includes some mechanism to mitigate the problem of UDP’s unreliability. HTTP-over-QUIC has been officially standardized by IETF and has been named HTTP/3.</p>&#13;
<h1 id="letter-R"><span class="ChapterTitle">R</span></h1>&#13;
<h2 id="Rabin-cryptosystem">Rabin cryptosystem</h2>&#13;
<p class="BodyFirst">RSA with 2 as a public exponent, kinda. Because computing modular square roots is proven to be equivalent to factoring, breaking Rabin encryption is as hard as factoring its modulus <em>n = pq</em>. The equivalence between breaking RSA and factoring is harder to demonstrate.</p>&#13;
<h2 id="Rainbow-tables">Rainbow tables</h2>&#13;
<p class="BodyFirst">Time-memory trade-off technique mostly applied to password cracking, such as Windows NTLM passwords. Rainbow tables are a specific, optimized type of look-up tables precomputed once, in the <em>offline</em> stage, to significantly speed up the cracking of passwords (<em>online</em> stage).</p>&#13;
<p>Rainbow tables are also successfully applied to crack pay-TV control words within short cryptoperiods (such as 10 seconds). They’re designed and often also made in Switzerland.</p>&#13;
<h2 id="Random-bits">Random bits</h2>&#13;
<p class="BodyFirst">Bits that have been generated at random. We often talk of random bits when strictly speaking they’ve only been pseudorandomly generated.</p>&#13;
<h2 id="Random-oracle">Random oracle</h2>&#13;
<p class="BodyFirst">An abstract concept used to prove that a protocol is secure in theory: you can imagine a random oracle as a function <em>f</em>() that, every time you <span epub:type="pagebreak" title="105" id="Page_105"/>send it an input <em>x</em>, it picks a random value <em>y</em> and returns it as the output while registering <em>f</em>(<em>x</em>) = <em>y</em>. This sounds similar to how a hash function ought to behave, yet a random oracle relies on a slightly different assumption than that of a secure hash function. Assuming that a hash function is a random oracle makes it easier to write security proofs. But such proofs are perceived as less reliable because, unlike secure hash functions, random oracles can’t exist in practice, but in practice that’s not a concern.</p>&#13;
<h2 id="Randomness">Randomness</h2>&#13;
<p class="BodyFirst">The most important thing in cryptography. Without randomness, you couldn’t generate random secret values so there would be no secret keys and therefore no encryption. Even if you already have keys, you need randomness to achieve the highest public-key encryption security level (called <em>semantic security, or IND-CPA</em>).</p>&#13;
<h2 id="Range-proof">Range proof</h2>&#13;
<p class="BodyFirst">Proof that a number lies in a certain interval without having to reveal the number (the zero-knowledge part). Some cryptocurrencies use range proofs to hide the amounts transferred, and to ensure the correctness of a protocol’s execution, for example.</p>&#13;
<h2 id="RC4">RC4</h2>&#13;
<p class="BodyFirst">Rivest’s Cipher 4, designed in 1987. A stream cipher with a tumultuous history: initially, it was a proprietary algorithm from the firm RSA Security and was then reverse engineered and published in 1994. It withstood cryptanalysis surprisingly well despite its extreme simplicity and lack of academic peer-review seal of approval—until it didn’t, and was found to be insecure (because of statistical biases in the first bytes it generates). Still, it was less insecure than most proprietary algorithms from that era. RC4 was the basis of WEP, the first Wi-Fi encryption scheme, which was broken in part because of RC4’s properties but in larger part because of WEP’s flawed design. RC4 was also used in TLS, where its statistical biases could be exploited to decrypt data that is encrypted under many different keys. Because of its small size, RC4 is also used in malware to obfuscate code or encrypt data sent to the malware’s server.</p>&#13;
<h2 id="RC5">RC5</h2>&#13;
<p class="BodyFirst">A cipher whose only commonality with RC4 is its designer Ronald Rivest; unlike RC4, RC5 is not a stream cipher but a block cipher. RC5 &#13;
<span epub:type="pagebreak" title="106" id="Page_106"/>is one of the few ciphers to use data-dependent rotations, an idea that at first sounds like it makes the cipher more complicated. But it also turned out to facilitate cryptanalysis, because an attacker could then control the rotation values.</p>&#13;
<h2 id="RC6">RC6</h2>&#13;
<p class="BodyFirst">Similar to RC5. Also a block cipher that uses data-dependent rotations and was patented by RSA Security. Designed by Ronald Rivest (along with other people) as well, RC6 was one of the candidates in the AES competition. It wasn’t chosen by NIST to be the AES but was later used in a software implant allegedly designed by the NSA.</p>&#13;
<h2 id="Real-world">Real world</h2>&#13;
<p class="BodyFirst">Academic cryptography’s term to refer to reality, as opposed to the <em>ideal world</em> of the security models needed to rigorously analyze the security of cryptographic schemes. If attackers in the real world are less powerful than in the ideal world, then security proofs on paper guarantee real security.</p>&#13;
<p>The term is often the source of pleonasms, for example: <em>previous works don’t clarify how the code should be instantiated concretely in the real world</em>, <em>real-world applications</em>, and <em>practical real-world protocols</em>.</p>&#13;
<h2 id="Real-World-Crypto-RWC">Real World Crypto (RWC)</h2>&#13;
<p class="BodyFirst">A cryptography conference focused on current real applications of cryptography, as opposed to research conferences less concerned with direct applications. Attended by participants from academia and industry, it’s the largest cryptography conference in terms of participants. RWC is held alternately on the US West Coast, East Coast, in Europe, and in the Asia-Pacific region. Speakers present contributed talks (which aren’t necessarily from formal research papers) with titles such as “Privacy-Preserving Telemetry in Firefox” and “Weaknesses in the Moscow Internet Voting System.”</p>&#13;
<p class="BodyCustom">See <a href="#ASIACRYPT"><em>Asiacrypt</em>,</a> <a href="#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems"><em>CHES</em></a>, <a href="#CRYPTO"><em>CRYPTO</em></a>, <a href="#Eurocrypt"><em>Eurocrypt</em></a>, <a href="#FSE-Fast-Software-Encryption"><em>FSE</em></a>, <a href="#PKC"><em>PKC</em></a>, <a href="#TCC"><em>TCC</em></a>.</p>&#13;
<h2 id="Rectangle-attack">Rectangle attack</h2>&#13;
<p class="BodyFirst">An improvement of the boomerang attack, created to attack the block cipher Serpent.</p>&#13;
<p class="BodyCustom">See <a href="#Boomerang-attack"><em>Boomerang attack</em>.</a></p>&#13;
<h2 id="Related-key-attack"><span epub:type="pagebreak" title="107" id="Page_107"/>Related-key attack</h2>&#13;
<p class="BodyFirst">An attack that makes encryption or decryption queries for instances of the cipher whose key is a modified version of the original key, so the modification (as a function) is chosen by the attacker. For example, a related-key attack on a block cipher might make encryption queries Enc(<em>K </em><span class="NSSymbol">⊕</span><em>M</em>, <em>P</em>) where <em>M </em>is a fixed value defined by the attacker without knowing the key.</p>&#13;
<p>You can only use this attack model against symmetric primitives, because it would be too powerful and effective against public-key schemes. Related-key attacks aren’t a very realistic threat when the key is secret.</p>&#13;
<h2 id="Research-papers">Research papers</h2>&#13;
<p class="BodyFirst">What academic researchers must write to keep their jobs. The IACR’s ePrint server received 69 research papers in 2000, 661 in 2010, and 1,499 in 2019. No one has time to read all these articles, which is why it’s crucial for researchers to write succinct, informative abstracts, as well as clear and appealing titles.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>FUN WITH PAPER TITLES</h2>&#13;
<p class="BoxBodyFirst">Conventional paper titles are boring; they usually follow the structure “New X for Solving Problem Y Using Technique Z.” But researchers sometimes get creative with titles, such as the following:</p>&#13;
<ol class="none">&#13;
<li>“Proof of Work Proves Not to Work”</li>&#13;
<li>“Dumb Crypto in Smart Grids”</li>&#13;
<li>“FourQ: Four-Dimensional Decompositions on a Q-curve over the Mersenne Prime”</li>&#13;
<li>“Mining Your Ps and Qs: Detection of Widespread Weak Keys in Network Devices”</li>&#13;
<li>“Prime and Prejudice: Primality Testing Under Adversarial Conditions” </li>&#13;
<li>“The Hunting of the SNARK”</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Revocation"><span epub:type="pagebreak" title="108" id="Page_108"/>Revocation</h2>&#13;
<p class="BodyFirst">Problem solved in theory but rarely in practice.</p>&#13;
<h2 id="Rijndael">Rijndael</h2>&#13;
<p class="BodyFirst">The block cipher that became known as AES after winning the AES competition in 2000. The Rijndael name is a portmanteau of the last names of its designers, Belgian cryptographers Joan Daemen and Vincent Rijmen. The Google query <em>how do you say rijndael</em> returns about 100,000 results.</p>&#13;
<p class="BodyCustom">See <a href="#AES-Advanced-Encryption-Standard"><em>AES</em></a>.</p>&#13;
&#13;
<h2 id="Ring-signature">Ring signature</h2>&#13;
<p class="BodyFirst">First described in the paper “How to Leak a Secret” by Rivest, Shamir, and Tauman. Ring signatures involve a group of signers such that any signer can create a signature that is signer-ambiguous with respect to the subset of signers of their choice. In other words, verifiers have no way of identifying the signer; they can only know the group of potential signers that they’re in. Unlike with group signatures, there is no way to deanonymize the signer.</p>&#13;
<p class="BodyCustom">See <a href="#Group-signature"><em>Group signature</em></a>.</p>&#13;
&#13;
<h2 id="RIPEMD-160">RIPEMD-160</h2>&#13;
<p class="BodyFirst">A hash function designed in 1992. RIPEMD-160 got a second life due to its use in Bitcoin and many other cryptocurrencies.</p>&#13;
<h2 id="Rivest–Shamir–Adleman">Rivest–Shamir–Adleman</h2>&#13;
<p class="BodyFirst">The authors of the 1978 paper “A Method for Obtaining Digital Signatures and Public-Key Cryptosystems” that described the RSA cryptosystem. RSA’s then unique property was that the key used for encryption is different from the one used for decryption. RSA has evolved into standardized schemes to encrypt and sign securely (such as the OAEP and PSS standards, respectively). But its market share has declined while elliptic-curve cryptography has gained greater adoption. But RSA’s support for <em>native</em>, non-hybrid encryption, as well as fast signature verification, sometimes makes it the best option when these properties are necessary.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="109" id="Page_109"/>INNOVATIONS OF RSA</h2>&#13;
<p class="BoxBodyFirst">Ronald Rivest, Adi Shamir, and Leonard Adleman noted the following direct consequences of their new cryptosystem in their 1978 paper:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Couriers or other secure means are not needed to transmit keys, since a message can be enciphered using an encryption key publicly revealed by the intended recipient. Only he can decipher the message, since only he knows the corresponding decryption key.</li>&#13;
<li value="2">A message can be <em>signed</em> using a privately held decryption key. Anyone can verify this signature using the corresponding publicly revealed encryption key. Signatures cannot be forged, and a signer cannot later deny the validity of his signature. This has obvious applications in <em>electronic mail</em> and <em>electronic funds transfer</em> systems.</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="ROBOT-Return-Of-Bleichenbacher’s-Oracle-Threat">ROBOT (Return Of Bleichenbacher’s Oracle Threat)</h2>&#13;
<p class="BodyFirst">Bleichenbacher’s attack, 20 years later.</p>&#13;
<p class="BodyCustom">See <a href="#Bleichenbacher-attack"><em>Bleichenbacher attack</em>.</a></p>&#13;
<h2 id="ROS">ROS</h2>&#13;
<p class="BodyFirst">Random inhomogeneities in an Overdetermined Solvable system of linear equations: the hardest of all crypto abbreviations to memorize.</p>&#13;
<h2 id="RSA">RSA</h2>&#13;
<p class="BodyFirst">The biggest conference in the information security industry.</p>&#13;
<h2 id="Rubber-hose-cryptanalysis">Rubber-hose cryptanalysis</h2>&#13;
<p class="BodyFirst">Term popularized by XKCD’s comic 538. A reminder that mathematical cryptographic adversarial models often fail to capture more mundane risks from procedural or human flaws.</p>&#13;
<h2 id="Rumba20">Rumba20</h2>&#13;
<p class="BodyFirst">The only hash function from the Salsa20 family. Rumba20 was created in the context of new results regarding the generalized birthday problem.</p>&#13;
<h1 id="letter-S"><span class="ChapterTitle"><span epub:type="pagebreak" title="110" id="Page_110"/>S</span></h1>&#13;
<h2 id="SAEP-Simplified-OAEP">SAEP (Simplified OAEP)</h2>&#13;
<p class="BodyFirst">A variant of OAEP that is slightly simpler and achieves the same level of chosen-ciphertext security.</p>&#13;
<p class="BodyCustom">See <a href="#OAEP-Optimal-Asymmetric-Encryption-Padding"><em>OAEP (Optimal Asymmetric Encryption Padding)</em>.</a></p>&#13;
<h2 id="Salsa20">Salsa20</h2>&#13;
<p class="BodyFirst">Undoubtedly one of the most influential cryptographic algorithms. It led to the stream cipher ChaCha20 (used in TLS, SSH, and many other places). This in turn was reused in the BLAKE2 hash function, a component of the Argon2 password hash and protocols such as WireGuard. More generally, Salsa20 popularized simple, easy to implement add-rotate-xor (ARX) constructions. A few years earlier, NIST had standardized a more complicated cipher whose understanding required the knowledge of concepts such as polynomials, matrix inversion, and finite fields.</p>&#13;
<p>The 20 in Salsa20 is for its number of rounds, a conservative value initially chosen by its designer and later relaxed in some applications, decreasing to 12 or even 8.</p>&#13;
<h2 id="Sandwich-attack">Sandwich attack</h2>&#13;
<p class="BodyFirst">A refinement of the boomerang attack often used to cryptanalyze block ciphers. A sandwich attack relies on a distinguisher divided into three parts: “A thick slice (bread) at the top, a thin slice (meat) in the middle, and a thick slice (bread) at the bottom.” It was invented to find the first practical attack on the block cipher KASUMI.</p>&#13;
<p class="BodyCustom">See <a href="#Boomerang-attack"><em>Boomerang attack</em>.</a></p>&#13;
<h2 id="S-box">S-box</h2>&#13;
<p class="BodyFirst">A look-up table used in block ciphers to implement a nonlinear transformation with measurable security properties (such as nonlinearity or branch number), although S-boxes are not necessarily implemented as look-up tables. In the context of differential cryptanalysis, an active S-box is one for which the values from the two (different) inputs yield a different input value to the S-box, and thus a different output.</p>&#13;
<p><span epub:type="pagebreak" title="111" id="Page_111"/>S-boxes are usually 4-bit (16 values, as in Serpent) or 8-bit (256 values, as in Rijndael/AES).</p>&#13;
<h2 id="Scalar">Scalar</h2>&#13;
<p class="BodyFirst">A number, as opposed to a vector or group element, for example. When you hear <em>scalar multiplication</em> in cryptography, it often just means multiplication of a point on an elliptic curve by a number, according to the addition law defined on said curve.</p>&#13;
<h2 id="sci.crypt">sci.crypt</h2>&#13;
<p class="BodyFirst">Along with sci.crypt.research, Usenet newsgroup where people discussed cryptography before Twitter and Slack. It’s notorious for its can-you-break-my-cipher-here’s-a-ciphertext posts.</p>&#13;
<h2 id="Scrambler">Scrambler</h2>&#13;
<p class="BodyFirst">Former term for ciphers used in telecommunications and audio/video content processing. The first of these algorithms were cryptographically weak, because they didn’t really encrypt the signal but effectively just made it unintelligible. The later algorithms evolved into actual cryptography.</p>&#13;
<p class="BodyCustom">See <a href="#DVB-CSA"><em>DVB-CSA</em>.</a></p>&#13;
<h2 id="scrypt">scrypt</h2>&#13;
<p class="BodyFirst">A password hash function with configurable time memory usage, pronounced <em>ess-crypt</em>. scrypt pioneered memory-hard password hashing and inspired subsequent designs as well as the Password Hashing Competition.</p>&#13;
<p>scrypt has a modular, if not outright minimalistic, design. It includes, as subcomponents, the PBKDF2 construction based on HMAC-SHA-256 as well as the Salsa20/8 stream cipher.</p>&#13;
<h2 id="Searchable-encryption">Searchable encryption</h2>&#13;
<p class="BodyFirst">Encryption of database records that allows a search on encrypted data. For example, it permits a search that given an encrypted keyword retrieves the encrypted items that, when decrypted, include the keyword.</p>&#13;
<p>Searchable encryption schemes that are possibly practical and useful leak some information about the encrypted data. In contrast, <span epub:type="pagebreak" title="112" id="Page_112"/>those with the highest security guarantees are severely limited functionality- and performance-wise (for example, those using functional encryption, homomorphic encryption, and oblivious RAMs).</p>&#13;
<h2 id="secp256k1">secp256k1</h2>&#13;
<p class="BodyFirst">The elliptic curve used by Bitcoin, Ethereum, and many other cryptocurrencies for their ECDSA signatures of transactions. The <em>k</em> indicates a Koblitz curve. Unlike other standard curves, and in particular unlike the ubiquitous secp256r1 (also known as the NIST p-256), secp256k1 doesn’t rely on pseudorandom parameters and is in principle less likely to have been manipulated. The actual reasons why Satoshi Nakamoto, or whoever, chose to use secp256k1 remain unclear.</p>&#13;
<h2 id="Secret-sharing">Secret sharing</h2>&#13;
<p class="BodyCustom">See <a href="#Threshold-secret-sharing"><em>Threshold secret sharing</em>.</a></p>&#13;
<h2 id="Security">Security</h2>&#13;
<p class="BodyFirst">An important aspect of cryptographic schemes. Security of a cryptographic scheme on paper doesn’t imply security in reality (to some extent, the reverse is also true). Even the existence of a formal proof that a cryptographic scheme is secure doesn’t necessarily mean it’s secure in all real-life conditions, because the definition of “secure in practice” is often undefinable in mathematical terms.</p>&#13;
<h2 id="Security-proof">Security proof</h2>&#13;
<p class="BodyFirst">The demonstration that finding an algorithm to break some new crypto scheme is at least as hard as finding an algorithm to break some other crypto scheme or notoriously hard math problem, or a reduction of one problem to another. Security proofs only prove an algorithm’s security insofar as their assumptions about attackers’ capabilities are accurate. Also, the scheme on which it’s based must really be practically unbreakable. Other caveats include the fact that the reduction might be too loose to be meaningful, and that, in reality, breaking cryptography isn’t always about attacking an algorithm.</p>&#13;
<h2 id="Semantic-security">Semantic security</h2>&#13;
<p class="BodyCustom">See <a href="#IND-CPA"><em>IND-CPA</em>.</a></p>&#13;
<h2 id="Serious-Cryptography"><span epub:type="pagebreak" title="113" id="Page_113"/><em>Serious Cryptography</em></h2>&#13;
<p class="BodyFirst">Yet another book about cryptography.</p>&#13;
<h2 id="Serpent">Serpent</h2>&#13;
<p class="BodyFirst">In hindsight, would have been a good choice as the AES standard: its design is easy to understand, because it contains no finite fields, polynomials, matrix multiplication, or other such math; its implementation logic doesn’t stray too far from the specification; and it poses no risk of cache-timing attacks. But its security margin (in other words, number of rounds) involved perhaps too much crypto compared to Rijndael.</p>&#13;
<p class="BodyCustom">See <a href="#PRESENT"><em>PRESENT</em>.</a></p>&#13;
<h2 id="SHA-0">SHA-0</h2>&#13;
<p class="BodyFirst">First draft of SHA-1.</p>&#13;
<h2 id="SHA-1">SHA-1</h2>&#13;
<p class="BodyFirst">A secure hash function if the only security you need is preimage resistance. It took approximately 12 years to progress from the collision attack described in a 2005 paper to a demonstrable collision in 2017.</p>&#13;
<h2 id="SHA-2">SHA-2</h2>&#13;
<p class="BodyFirst">Not one but four hash functions:</p>&#13;
<ul>&#13;
<li>SHA-256 looks like SHA-1 but with more rounds and more complex internals.</li>&#13;
<li>SHA-224 is SHA-256 with 224-bit output instead of 256-bit output.</li>&#13;
<li>SHA-512 looks like SHA-256 with 64-bit words instead of 32-bit words.</li>&#13;
<li>SHA-384 is SHA-512 with 384-bit output instead of 512-bit output.</li>&#13;
</ul>&#13;
<p class="BodyContinued">Unlike SHA-1, SHA-2 algorithms aren’t broken and are unlikely to ever be.</p>&#13;
<h2 id="SHA-3">SHA-3</h2>&#13;
<p class="BodyFirst">When someone tells you they use SHA-3, you should ask which version of SHA-3 they use: it could be SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, or SHAKE256. If it’s one of the latter two, you might want to know what output length they use, because these aren’t simple hash functions but XOF (extendable-output functions).</p>&#13;
<p class="BodyCustom">See <a href="#Keccak"><em>Keccak</em>.</a></p>&#13;
<h2 id="SHA-3-competition"><span epub:type="pagebreak" title="114" id="Page_114"/>SHA-3 competition</h2>&#13;
<p class="BodyFirst">Officially the <em>NIST hash function competition</em>. The 2008 to 2012 selection process for SHA-3 eventually settled on Keccak after a final round that included BLAKE, Grøstl, JH, and Skein. Of 64 submissions received by NIST, 51 were accepted as valid.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>SHA-3 PANDEMONIUM</h2>&#13;
<p class="BoxBodyFirst">The first few months of the SHA-3 competition were a rampage. Most submissions by amateurs were broken, sometimes within minutes of reading their specification.</p>&#13;
<p>Noteworthy submissions included:</p>&#13;
<ul>&#13;
<li>MD6: Tree-based hash having nothing to do with MD5 but its designer</li>&#13;
<li>CubeHash: Minimalist ChaCha-like permutation-based</li>&#13;
<li>ECOH, FSB, SWIFFTX: Attempts of provably secure hashes using a reduction to a hard computational problem</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="SHACAL">SHACAL</h2>&#13;
<p class="BodyFirst">A block cipher extracted from the compression function used in SHA-1. More precisely, SHACAL is the keyed permutation in SHA-1’s instance of a Davies–Meyer construction. Likewise, SHACAL-2 is SHA-256’s block cipher; it was submitted to the NESSIE project and was selected.</p>&#13;
<p><em>SHACAL</em> is pronounced like the French <em>chacal</em>, meaning jackal.</p>&#13;
<h2 id="Shamir’s-secret-database">Shamir’s secret database</h2>&#13;
<p class="BodyFirst">A list of all prime numbers—and therefore all RSA private keys—that Adi Shamir is rumored to have created to instantaneously break RSA. To the best of our knowledge, this rumor has never been confirmed or denied.</p>&#13;
<h2 id="Shor’s-algorithm">Shor’s algorithm</h2>&#13;
<p class="BodyFirst">A quantum algorithm that solves factoring and discrete logarithms with practical complexity. Shor’s algorithm is the reason the field of post-quantum cryptography exists.</p>&#13;
<h2 id="SHS-Secure-Hash-Standard"><span epub:type="pagebreak" title="115" id="Page_115"/>SHS (Secure Hash Standard)</h2>&#13;
<p class="BodyFirst">The FIPS 180-4 document that specifies the SHA-1 and SHA-2 algorithms, “for computing a condensed representation of electronic data (message).”</p>&#13;
<p>SHA-3 is specified in a separate document titled “SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions”<em> </em>(FIPS 202).</p>&#13;
<h2 id="Side-channel">Side channel</h2>&#13;
<p class="BodyFirst">Any way to obtain information about a cryptographic operation other than the specified output values.</p>&#13;
<h2 id="Side-channel-attack">Side-channel attack</h2>&#13;
<p class="BodyFirst">An attack that leverages some side-channel information, either passively or actively, locally or remotely, based on physical or logical properties. A side-channel attack doesn’t necessarily require physical access to the module attacked.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>KINDS OF SIDE CHANNELS</h2>&#13;
<p class="BoxBodyFirst">Here is an incomplete list of classes of side-channel attacks:</p>&#13;
<ul>&#13;
<li>Timing attacks when the execution time depends on sensitive data</li>&#13;
<li>Fault attacks, such as CPU overclocking, power glitching, and laser fault injection</li>&#13;
<li>Simple measurement of differential analysis of physical phenomena: acoustic waves, electromagnetic emanations, and heat</li>&#13;
<li>Operating system leaks, via procfs, dmesg entries, race conditions, and various ASLR leaks</li>&#13;
<li>Traffic analysis over encrypted communications</li>&#13;
<li>Micro-architectural attacks, such as cache attacks</li>&#13;
<li>Shoulder surfing and observation of users’ movements</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Sigaba">Sigaba</h2>&#13;
<p class="BodyFirst">The American Enigma, designed in the 1930s. It was never officially broken.</p>&#13;
<h2 id="Signal-protocol"><span epub:type="pagebreak" title="116" id="Page_116"/>Signal protocol</h2>&#13;
<p class="BodyFirst">The combination of the X3DH session initialization protocol and the double ratchet state update and key update protocol, as used by the Signal application. A similar protocol was integrated in WhatsApp and Facebook Messenger, reusing libraries developed for Signal. The cryptographic research and engineering behind the Signal protocol had a major impact on secure messaging applications.</p>&#13;
<p class="BodyCustom">See <a href="#Double-ratchet"><em>Double ratchet</em></a>, <a href="#X3DH"><em>X3DH</em></a>.</p>&#13;
<h2 id="Signature">Signature</h2>&#13;
<p class="BodyFirst">Public-key signature, or digital signature, but different from electronic signature, e-signature, or electromagnetic signature. It’s sometimes sacrilegiously defined as <em>encrypting with the private key</em>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>What is THE SECURITY GOAL OF A SIGNATURE?</h2>&#13;
<p class="BoxBodyFirst">A brilliant CS master’s student once successfully defended his master’s thesis project (on post-quantum cryptography). In the Q&amp;A part of his defense, after questions about his work, his cryptography professor asked him, “What’s the security goal of a signature?”</p>&#13;
<p>The student was confused by this deceptively simple question.</p>&#13;
<p>Signatures should be unforgeable under adaptive chosen-message attacks. An attacker who can query a valid signer for a signature of any message of their choice shouldn’t be able to compute a signature for any other message.</p>&#13;
<p>The student thus unconvincingly answered, “Existential unforgeability under adaptive chosen-message attacks.”</p>&#13;
<p>The professor said that no, this wasn’t the unique goal of public-key signatures because, after all, MACs attempt to achieve a similar goal.</p>&#13;
<p>The professor had expected the answer <em>nonrepudiation</em>, or the property that a signer cannot claim that someone else issued the signature on their behalf, because nobody else knows the private signing key. The same isn’t true for MACs. This notion is intuitively the opposite of deniability, although in MACs can effectively provide nonrepudiation if a signature was demonstrably transmitted by some entity or computer.</p>&#13;
<p>A more flexible form of nonrepudiation is provided by undeniable signatures, which are defined in this book, along with many other signature variants (blind, group, ring, threshold, and so on).</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Signcryption"><span epub:type="pagebreak" title="117" id="Page_117"/>Signcryption</h2>&#13;
<p class="BodyFirst">To public-key cryptography what authenticated encryption is to symmetric cryptography. In other words, signcryption is signature and encryption within a single primitive.</p>&#13;
<h2 id="SIKE-Supersingular-Isogeny-Key-Encapsulation">SIKE (Supersingular Isogeny Key Encapsulation)</h2>&#13;
<p class="BodyFirst">Sounds like BIKE. SIKE is also a post-quantum KEM but is based on an isogeny problem rather than a decoding problem.</p>&#13;
<p>SIKE is based on SIDH (Supersingular Isogeny Diffie–Hellman), the main isogeny-based key agreement scheme, and is a candidate in NIST’s post-quantum project.</p>&#13;
<p class="BodyCustom">See <a href="#BIKE-Bit-Flipping-Key-Encapsulation"><em>BIKE (Bit Flipping Key Encapsulation)</em></a>, <a href="#Isogeny-based-cryptography"><em>Isogeny-based cryptography</em></a>.</p>&#13;
<h2 id="SIMECK">SIMECK</h2>&#13;
<p class="BodyFirst">SIMON + SPECK = SIMECK. It’s a block cipher that borrows from the SIMON and SPECK NSA-designed ciphers to create an algorithm suitable for software- and hardware-constrained implementations. SIMECK is not from the NSA.</p>&#13;
<h2 id="SIMON">SIMON</h2>&#13;
<p class="BodyFirst">Along with its brother SPECK, block ciphers designed to qualify as lightweight, optimized for hardware and software, respectively. SIMON would likely be used in many projects if it wasn’t designed by the NSA. Indeed, arguing that Caesar’s wife must be above suspicion, many cryptographers objected to the use of SIMON and SPECK after Snowden publicly questioned the NSA’s trustworthiness.</p>&#13;
<h2 id="SipHash">SipHash</h2>&#13;
<p class="BodyFirst">Not a hash but a pseudorandom function. SipHash is used as a secure MAC and is optimized for short input values. It was designed to prevent hash-flooding attacks against hash tables.</p>&#13;
<h2 id="SIV-AES">SIV-AES</h2>&#13;
<p class="BodyFirst">AES in SIV mode. For some reason, it’s not called AES-SIV. Instead, it goes by the official name of <em>Synthetic Initialization Vector </em>(<em>SIV</em>)<em> Authenticated Encryption Using the Advanced Encryption Standard </em>(<em>AES</em>)<em/>. Not to be confused with AES-GCM-SIV.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="118" id="Page_118"/>USES OF SIV-AES</h2>&#13;
<p class="BoxBodyFirst">As with AES-GCM-SIV, SIV-AES avoids the hazard of exposing plaintext data if the same nonce is used more than once. SIV-AES also uses the trick of deriving the encryption nonce from the message, thus leading to different nonces for different messages.</p>&#13;
<p>Unlike AES-GCM-SIV, the MAC used in SIV-AES isn’t based on binary polynomial multiplication. Instead, it uses the AES-based CMAC, a variant of CBC-MAC. (Perhaps you remember AES-CCM?) This contributes to making SIV-AES simpler than AES-GCM-SIV but also slightly less fast.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Skipjack">Skipjack</h2>&#13;
<p class="BodyFirst">A block cipher designed by the NSA in the late 1980s. It’s famous for its role in the Clipper fiasco and is currently often used as a toy cipher in cryptanalysis classes. Skipjack hasn’t been fully broken or shown to include a backdoor.</p>&#13;
<p class="BodyCustom">See <a href="#Clipper"><em>Clipper</em>.</a></p>&#13;
<h2 id="Slide-attack">Slide attack</h2>&#13;
<p class="BodyFirst">An attack introduced in a 1999 paper that began as follows: “It is a general belief among the designers of block-ciphers that even a relatively weak cipher may become very strong if its number of rounds is made very large.”</p>&#13;
<p>The paper then goes on to describe a type of attack on block ciphers that works regardless of the number of rounds used.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>MORE CRYPTO, SAME INSECURITY?</h2>&#13;
<p class="BoxBodyFirst">Slide attacks work as follows:</p>&#13;
<p>Assume that the encryption function <em>E(</em>) works by iterating a round function <em>R</em>(), such that <em>E</em>(<em>X</em>) = <em>R</em>(<em>R</em>(. . .<em> R</em>(<em>X</em>) . . . )). The attack first looks for one or more <em>slid pairs</em>, which are pairs of plaintext blocks <em>X </em>and <em>Y </em>such that <em>R</em>(<em>X</em>) = <em>Y</em>, and therefore <em>E</em>(<em>X</em>) = <em>R</em><sup>−1</sup>(<em>E</em>(<em>Y</em>)). You can use several tricks to identify these pairs.</p>&#13;
<p>Once you have such pairs, breaking the cipher is equivalent to just breaking one round, which is usually easy.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="SM"><span epub:type="pagebreak" title="119" id="Page_119"/>SM</h2>&#13;
<p class="BodyFirst">A suite of Chinese national cryptographic standards, including publicly available algorithms that certain products in China are required to use. The SM suite includes elliptic-curve public-key cryptography (SM2), a hash function (SM3), a block cipher (SM4), and, interestingly, identity-based cryptography (SM9).</p>&#13;
<h2 id="Smart-contract">Smart contract</h2>&#13;
<p class="BodyFirst">Programs running on blockchain platforms. Bugs in smart contracts tend to have catastrophic consequences.</p>&#13;
<h2 id="Snake-oil">Snake-oil</h2>&#13;
<p class="BodyFirst">Bruce Schneier’s snake-oil warning signs from 1999 are still applicable today:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Pseudo-mathematical gobbledygook</li>&#13;
<li value="2">New mathematics</li>&#13;
<li value="3">Proprietary cryptography</li>&#13;
<li value="4">Extreme cluelessness</li>&#13;
<li value="5">Ridiculous key lengths</li>&#13;
<li value="6">One-time pads</li>&#13;
<li value="7">Unsubstantiated claims</li>&#13;
<li value="8">Security proofs</li>&#13;
<li value="9">Cracking contests</li>&#13;
</ol>&#13;
<h2 id="SNARK-succinct-non-interactive-argument-of-knowledge">SNARK (succinct non-interactive argument of knowledge)</h2>&#13;
<p class="BodyFirst">A powerful and efficient type of proof of knowledge. Introduced in the 2011 article “From Extractable Collision Resistance to Succinct Non-Interactive Arguments of Knowledge, and Back Again.” It’s a variant of a SNARG (succinct non-interactive argument), because a SNARK is a <em>SNARG of knowledge</em>. SNARKs can, for example, be used for (noninteractive) delegation of computation, where a worker uses a SNARK to prove that they performed the correct computation.</p>&#13;
<p>When a SNARK is zero-knowledge, we talk of zk-SNARK, which was famously used in the Zcash blockchain protocol to anonymize transactions via a proof that tokens have been transferred from a sender to a recipient without disclosing either’s identity or the amount transferred.</p>&#13;
<p><span epub:type="pagebreak" title="120" id="Page_120"/>Post-quantum SNARKs exist but are less efficient than pre-­quantum ones.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>DISSECTING SNARKS</h2>&#13;
<p class="BoxBodyFirst">The following explains SNARK word by word, starting from the end:</p>&#13;
<p>An <em>argument of knowledge</em> is essentially a proof of knowledge that is practically secure, whereas <em>proof of knowledge</em> is, strictly speaking, reserved for proofs that remain secure against computationally unbounded adversaries. In the context of cryptographic applications, the <em>knowledge</em> proved can be that of a secret value or of the relation between values that must be kept secret.</p>&#13;
<p><em>Non-interactive</em> just means that the SNARK comes as a single message from a prover to a verifier rather than as a protocol involving multiple messages.</p>&#13;
<p><em>Succinct</em> means that the message is of a relatively small size, even if the argument covers large amounts of data, and that it’s efficiently verifiable.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="SNIP-secret-shared-non-interactive-proof">SNIP (secret-shared non-interactive proof)</h2>&#13;
<p class="BodyFirst">A zero-knowledge protocol with one prover and several verifiers that each holds a share of a proof of correctness. Each verifier holds a share of the secret value; the prover sends distinct proof strings to each verifier, allowing the verifiers to collaborate to check the validity of the secret according to some predefined predicate without leaking any information on said secret. SNIPs were introduced as a tool to build privacy-preserving aggregate statistics schemes.</p>&#13;
<h2 id="SNOW-3G">SNOW 3G</h2>&#13;
<p class="BodyFirst">A stream cipher used in 3G, 4G, and 5G communications to encrypt voice communications. Like its early predecessor A5/1, SNOW 3G works by updating a state composed of feedback shift registers, which makes it simple to implement and efficient. Unlike A5/1, SNOW 3G is secure. A new version of SNOW 3G for 5G networks called <em>SNOW-V</em> was proposed in 2020 to be faster in software, because 5G relies a lot more on software and virtualized environments than previous standards.</p>&#13;
<p class="BodyCustom">See <a href="#Feedback-shift-register"><em>Feedback shift register</em></a>.</p>&#13;
&#13;
<h2 id="Solitaire">Solitaire</h2>&#13;
<p class="BodyFirst"><span epub:type="pagebreak" title="121" id="Page_121"/>A stream cipher created by Bruce Schneier for the novel <em>Cryptonomicon</em>. The novel’s characters use it without accessing a computer. As Schneier describes:</p>&#13;
<p class="ExtractPara">Solitaire gets its security from the inherent randomness in a shuffled deck of cards. By manipulating this deck, a communicant can create a string of <em>random</em> letters that he then combines with his message. Of course Solitaire can be simulated on a computer, but it is designed to be implemented by hand.</p>&#13;
<p>Solitaire is broken by today’s academic standards (it has a statistical bias), but it’s quite secure for a pen-and-paper cipher, and practically safe when used correctly.</p>&#13;
<p class="BodyCustom">See <a href="#Cryptonomicon"><em>Cryptonomicon</em>.</a></p>&#13;
<h2 id="SPECK">SPECK</h2>&#13;
<p class="BodyFirst">An NSA lightweight cipher. </p>&#13;
<p class="BodyCustom">See <a href="#SIMON"><em>SIMON</em>.</a></p>&#13;
<h2 id="SPEKE-Simple-Password-Exponential-Key-Exchange">SPEKE (Simple Password Exponential Key Exchange)</h2>&#13;
<p class="BodyFirst">PAKE invented long before PAKEs were cool (in 1996).</p>&#13;
<h2 id="SPHINCS">SPHINCS</h2>&#13;
<p class="BodyFirst">A hash-based signature scheme that, unlike XMSS, is stateless. But it’s even more complicated than XMSS. Gravity-SPHINCS and SPHINCS+ are SPHINCS variants that were submitted to NIST’s post-quantum competition. Not to be confused with the SPHINX mixnet.</p>&#13;
<p class="BodyCustom">See <a href="#XMSS-eXtended-Merkle-Signature-Scheme"><em>XMSS</em></a>.</p>&#13;
<h2 id="Sponge-function">Sponge function</h2>&#13;
<p class="BodyFirst">The simplest way to design a hash function. A sponge function uses only a permutation algorithm—as opposed to a keyed permutation—or a block cipher. Pioneered by Keccak, now SHA-3, it leads to a multitude of permutation-based schemes.</p>&#13;
<p class="BodyCustom">See <a href="#Keccak"><em>Keccak</em></a>, <a href="#Permutation-based-cryptography"><em>Permutation-based cryptography</em></a>.</p>&#13;
<h2 id="SRP-Secure-Remote-Password"><span epub:type="pagebreak" title="122" id="Page_122"/>SRP (Secure Remote Password)</h2>&#13;
<p class="BodyFirst">PAKE relying on the Diffie–Hellman problem. SRP can be combined with TLS and is notably used in iCloud Keychain. But overall, it’s found in very few applications, most likely because of vulnerabilities in earlier versions of SRP, and because the minor security benefit is often not worth SRP’s extra complexity compared to a straightforward password authentication.</p>&#13;
<h2 id="SSH-Secure-Shell">SSH (Secure Shell)</h2>&#13;
<p class="BodyFirst">A secure channel over TCP. SSH relies on neither PKI nor X.509 certificates. Instead, it has a trust-on-first-use (TOFU) trust model. Fewer security issues have been found in SSH than in TLS.</p>&#13;
<h2 id="SSL-Secure-Socket-Layer">SSL (Secure Socket Layer)</h2>&#13;
<p class="BodyFirst">Not TLS. SSL is the predecessor of that ubiquitous transport security protocol; it was designed in the 1990s by Netscape and had three versions, the first of which was never released because it was too insecure. SSL v2 shipped with Netscape Navigator 1.1 in March 1995, and SSL v3 was released shortly after to notably mitigate a man-in-the-middle attack (working by downgrading to a weak cipher suite). Nonetheless, many systems continued to support SSL v2, sometimes for backward compatibility. Twenty years later, the DROWN attack exploited such legacy support of SSL v2 to attack recent TLS versions.</p>&#13;
<p class="BodyCustom">See <a href="#TLS-Transport-Layer-Security"><em>TLS</em></a>.</p>&#13;
<h2 id="STARK-scalable-transparent-arguments-of-knowledge">STARK (scalable transparent arguments of knowledge)</h2>&#13;
<p class="BodyFirst">Variants of SNARKs. STARKs were motivated by applications requiring efficient and scalable zero-knowledge proofs with fewer constraints than with SNARKs. Here are the main differences between STARKs and SNARKs:</p>&#13;
<ul>&#13;
<li>STARKs don’t require a <em>trusted setup</em>—a process that must be performed by trusted parties so that subsequent proofs are secure.</li>&#13;
<li>STARKs can be safe against quantum algorithms, whereas known SNARK constructions usually aren’t (or with some constraints).</li>&#13;
<li>STARKs are a bit faster to create and a bit slower to verify. </li>&#13;
</ul>&#13;
<p class="BodyCustom">See <a href="#SNARK-succinct-non-interactive-argument-of-knowledge"><em>SNARK (succinct non-interactive argument of knowledge)</em></a>.</p>&#13;
<h2 id="Steganography"><span epub:type="pagebreak" title="123" id="Page_123"/>Steganography</h2>&#13;
<p class="BodyFirst">Covert communication techniques that belong more to the field of signal processing than to cryptography.</p>&#13;
<h2 id="Stream-cipher">Stream cipher</h2>&#13;
<p class="BodyFirst">A type of cipher you can think of as a one-time pad cryptographically generated from a key and a (unique) nonce. The block cipher DES was designed in the 1970s with hardware implementations in mind; later the stream cipher RC4 was designed to be software friendly due to its byte-oriented mechanism. Yet in the 1990s stream ciphers were often thought of as <em>hardware ciphers</em> and were frequently based on feedback shift registers with minimal surrounding logic, like Grain or SNOW 3G. On the other hand, block ciphers are considered software ciphers, as the AES competition requirements made clear in 2000. Indeed, you’ll find stream ciphers used in niche, constrained applications, even before the term <em>lightweight cryptography</em> existed, when block ciphers were too costly.</p>&#13;
<p>Today, stream ciphers are no longer a niche market, and many of the encryption modes used in modern applications are technically stream ciphers because they run in CTR mode.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>STREAM CIPHER MODES</h2>&#13;
<p class="BoxBodyFirst">Historically, stream ciphers could have two modes:</p>&#13;
<ul>&#13;
<li>Synchronous, also known as autonomous or key auto key (KAK). The more well-known mode whereby a pseudorandom keystream is generated and XORed to the message.</li>&#13;
<li>Self-synchronizing, also known as autoclave or ciphertext auto key (CTAK), where the output depends on the message encryption.</li>&#13;
</ul>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Substitution-permutation-network-SPN">Substitution-permutation network (SPN)</h2>&#13;
<p class="BodyFirst">Construction of permutations, as used in block ciphers and hash functions, in which a round includes two layers:</p>&#13;
<ul>&#13;
<li>Substitution, typically via S-boxes, to transform chunks of blocks into other chunks in a nonlinear manner (that is, with a complex input–output relation). This strong but very local transformation is sometimes said to bring <em>confusion</em>.</li>&#13;
<li><span epub:type="pagebreak" title="124" id="Page_124"/>Permutation, typically via shuffling of bits or a matrix operation to make sure that each output bit will eventually depend on all input bits. This is weak, but block-wise transformation is said to provide <em>diffusion</em>.</li>&#13;
</ul>&#13;
<p>In an SPN, these two layers are complementary, and this separation of duties often simplifies the analysis of the cipher and the calculation of bounds on the success rate of certain attack techniques. AES, Serpent, and PRESENT are examples of SPNs.</p>&#13;
<h2 id="Suck">Suck</h2>&#13;
<p class="BodyFirst">As defined by cryptographer Matthew Green: “In cryptography <em>suck </em>is a purely technical term meaning <em>slow</em>, <em>complex</em>, and <em>probably insecure</em>.”</p>&#13;
<h2 id="Sugar-beet-auctions">Sugar beet auctions</h2>&#13;
<p class="BodyFirst">For many years, the only known real-world application of multi-party computation (MPC). Sugar beet auctions occurred in Denmark in 2008 with the support of Aarhus University researchers. They were described in detail in the paper “Secure Multiparty Computation Goes Live” and cited in numerous other papers as evidence that MPC isn’t useless. Thanks to blockchain protocols, there are now many more MPC applications.</p>&#13;
<h2 id="Suite-A">Suite A</h2>&#13;
<p class="BodyFirst">The NSA’s suite of classified cryptographic algorithms and techniques. Suite A is used, for example, in military secure communication devices. It’s not available to the public.</p>&#13;
<p class="BodyCustom">See <a href="#NSA-National-Security-Agency"><em>NSA (National Security Agency)</em></a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>A PEEK INTO SUITE A</h2>&#13;
<p class="BoxBodyFirst">Suite A seems to include a number of interesting ciphers, such as the following:</p>&#13;
<ul>&#13;
<li>BATON, a block cipher developed by the NSA around 1995. It has a 128-bit-long block and a key of 320 bits, 160 of which are checksum bits (which means that BATON’s key only has 160 secret bits). BATON is supported by the PKCS#11 cryptography interface standard; thus BATON’s parameters and supported modes are publicly documented. These modes include an undocumented <em>SHUFFLE</em> mode as well as a key wrapping mode. BATON is one of the fastest NSA ciphers.</li>&#13;
<li><span epub:type="pagebreak" title="125" id="Page_125"/>SAVILLE, a stream cipher developed by the NSA jointly with the British GCHQ in the late 1960s. It was used notably in encryption devices during the Vietnam War. SAVILLE is based on a nonlinear feedback shift register and uses a 128-bit key whose last eight bits are a checksum of the first 120 bits. SAVILLE has the interesting property of being able to run in synchronous or self-synchronizing mode.</li>&#13;
</ul>&#13;
<p class="BoxBodyContinued">Suite A also includes algorithms such as ACCORDION, CRAYON, JUNIPER, and PHALANX.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="SUPERCOP">SUPERCOP</h2>&#13;
<p class="BodyFirst">System for Unified Performance Evaluation Related to Cryptographic Operations and Primitives. It’s a successor of BATMAN and eBASH.</p>&#13;
<p>SUPERCOP estimates the optimal speed of an algorithm by trying out many different implementations of it. It also compiles each implementation with many different compiler options and then runs the compiled program multiple times to reliably measure its execution time. As of May 2020, SUPERCOP has benchmarked more than 1,000 different algorithms and more than 2,800 implementations of them, as well as multiple compilers and compiler options.</p>&#13;
<p>In terms of CPU usage, running SUPERCOP is to cryptography implementers what Bitcoin mining is to cryptocurrency people.</p>&#13;
<h2 id="Superpolynomial-complexity">Superpolynomial complexity</h2>&#13;
<p class="BodyFirst">Practically impossible complexity, according to Cobham’s thesis (and empirical observation).</p>&#13;
<h2 id="SVP-shortest-vector-problem">SVP (shortest vector problem)</h2>&#13;
<p class="BodyFirst">The main computational problem in lattice-based cryptography. SVP involves finding a combination of multidimensional vectors whose length (with respect to a given norm) is the smallest.</p>&#13;
<p>Many lattice-based cryptosystems indirectly leverage the worst-case hardness of an SVP-like problem, such as GapSVP, due to results relating the learning with errors (LWE) problem to SVP problems.</p>&#13;
<h2 id="Symmetric-key-cryptography">Symmetric-key cryptography</h2>&#13;
<p class="BodyFirst">The oldest form of post-quantum cryptography.</p>&#13;
<h1 id="letter-T"><span class="ChapterTitle"><span epub:type="pagebreak" title="126" id="Page_126"/>T</span></h1>&#13;
<h2 id="TCC">TCC</h2>&#13;
<p class="BodyFirst">The Theory of Cryptography Conference “focuses on paradigms, approaches, and techniques used to conceptualize, define, and provide solutions to natural cryptographic problems.”</p>&#13;
<p>TCC indeed covers both theoretical cryptography—an intellectually interesting topic but of low practical relevance, for example, when concerned with concepts such as quantum random oracles—and the theoretical aspects of applied cryptography, where fundamental results can be of high practical interest.</p>&#13;
<p>Researchers present peer-reviewed research papers with titles such as “Obfuscated Fuzzy Hamming Distance and Conjunctions from Subset Product Problems” and “Fully Homomorphic NIZK and NIWI Proofs.”</p>&#13;
<p class="BodyCustom">See <a href="#ASIACRYPT"><em>Asiacrypt</em></a>, <a href="#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems"><em>CHES</em></a>, <a href="#CRYPTO"><em>CRYPTO</em></a>, <a href="#Eurocrypt"><em>Eurocrypt</em></a>, <a href="#FSE-Fast-Software-Encryption"><em>FSE</em></a>, <a href="#PKC"><em>PKC</em></a>, <a href="#Real-World-Crypto-RWC"><em>Real World Crypto</em></a>.</p>&#13;
<h2 id="Test-vectors">Test vectors</h2>&#13;
<p class="BodyFirst">Alas, often the only tests found in cryptosystems’ implementations.</p>&#13;
<h2 id="Threefish">Threefish</h2>&#13;
<p class="BodyFirst">The third member of the Blowfish family but very different from Blowfish and Twofish. It has no Feistel network, no MDS matrices, no S-box, but just an ARX construction allegedly inspired by ChaCha and that later inspired SipHash.</p>&#13;
<h2 id="Threshold-encryption">Threshold encryption</h2>&#13;
<p class="BodyFirst">Strictly speaking, doesn’t exist. But threshold decryption does exist. It’s where the decryption key is threshold-shared among <em>N </em>parties, <em>t </em>≤ <em>N </em>of which must collaborate to decrypt a ciphertext.</p>&#13;
<h2 id="Threshold-secret-sharing">Threshold secret-sharing</h2>&#13;
<p class="BodyFirst">Or just secret sharing. A mechanism whereby a secret is split into <em>N </em>shares so that <em>t</em> ≤ <em>N </em>are required to recover the secret, and fewer than <em>t </em>don’t reveal information about the secret. Shamir’s method, based on polynomial interpolation, is the standard way to realize secret sharing.</p>&#13;
<p><span epub:type="pagebreak" title="127" id="Page_127"/>Verifiable secret-sharing (VSS) is a variant wherein parties can cryptographically verify that the correct secret has been recovered and that each party provided their correct share.</p>&#13;
<h2 id="Threshold-signature">Threshold signature</h2>&#13;
<p class="BodyFirst">A signature scheme where signing capabilities (that is, keys) are distributed across <em>N </em>potential signers and where a signature requires at least <em>t</em> ≤ <em>N </em>signatures from distinct signers. It’s notably used for custody of cryptocurrency in cold storage systems of certain exchanges.</p>&#13;
<h2 id="Time-AI™">Time AI™</h2>&#13;
<p class="BodyFirst">The Fyre Festival of cryptography.</p>&#13;
<h2 id="Time-lock-encryption">Time-lock encryption</h2>&#13;
<p class="BodyFirst">A cryptographic time capsule. Time-lock encryption attempts to make decryption impossible—even with the decryption key—until a certain date, when the algorithm authorizes noninteractive decryption. Like many cryptographic functionalities, you can achieve it using a trusted execution environment under fairly realistic assumptions. It’s also possible to create time-locked ciphertexts by leveraging so-called computational reference clocks, like those obtained from blockchains.</p>&#13;
<h2 id="Time-lock-puzzle">Time-lock puzzle</h2>&#13;
<p class="BodyFirst">The first instance of <em>timed-release crypto</em>. It was defined in 1996 as a way to “send information into the future” by creating a problem whose solution is known by its creator but the recovery of which otherwise requires a large amount of computation. It later inspired time-lock encryption.</p>&#13;
<p class="BodyCustom">See <a href="#Proof-of-sequential-work"><em>Proof of sequential work</em></a>, <a href="#Verifiable-delay-function-VDF"><em>Verifiable delay function (VDF)</em></a>.</p>&#13;
&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>THE FAILURE OF THE TIME-LOCK PUZZLE</h2>&#13;
<p class="BoxBodyFirst">In 1999, authors of the time-lock puzzle paper proposed an actual challenge, and they made the following prediction:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">We estimate that the puzzle will require 35 years of continuous computation to solve, with the computer being replaced every year by the next fastest model available.</p>&#13;
</blockquote>&#13;
<p class="BoxBodyContinued"><span epub:type="pagebreak" title="128" id="Page_128"/>In 2019, this challenge was shown to be quite a bit easier to solve, using either a desktop CPU or FPGA (in which case it took only two months of computation).</p>&#13;
<p>Although it was an interesting thought experiment of negligible practical interest, at least regarding the time-travel aspects, the initial paper suggested periods of months or years of computation.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Timing-attack">Timing attack</h2>&#13;
<p class="BodyFirst">An attack that takes advantage of timing differences to discover a secret and more generally compromise a cryptosystem’s security. Sometimes, the running time of the algorithm depends on the value of secret inputs, which might trigger things, such as if–then patterns or some other ­variable-time operation. For example, some processors’ arithmetic units will execute a multiplication instruction in fewer cycles if one of the inputs is zero. The textbook example of a timing attack targets square-and-multiply exponentiation (or double-and-add multiplication) where the private exponent (or scalar) is scanned bit per bit.</p>&#13;
<p>Attackers can also exploit timing leaks to identify the outcome of a cryptographic operation (such as padding validation) or the type of error that occurs when no detailed error code is returned (as with mitigations against Manger’s attack).</p>&#13;
<h2 id="TLS-Transport-Layer-Security">TLS (Transport Layer Security)</h2>&#13;
<p class="BodyFirst">A protocol to establish a secure channel over TCP (and over UDP with DTLS). TLS used PKI, X.509 certificates, and too many cipher suites until TLS 1.3.</p>&#13;
<p class="BodyCustom">See <a href="#SSL-Secure-Socket-Layer"><em>SSL</em></a>, <a href="#Heartbleed"><em>Heartbleed</em></a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>INDUSTRY CONCERNS</h2>&#13;
<p class="BoxBodyFirst">In September 2016, during the development of TLS 1.3, a representative of a financial services organization sent an email to the IETF working group in charge of TLS with the subject line <em>Industry Concerns about TLS 1.3</em>.</p>&#13;
<p>The message requested that TLS 1.3 consider integrating features allowing <em>supervised employee communications</em> (as mandated by some regulatory frameworks), or the capability to intercept encrypted communications under certain circumstances.</p>&#13;
<p><span epub:type="pagebreak" title="129" id="Page_129"/>The chair of the working group, Kenny Paterson, responded:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">Hi Andrew,</p>&#13;
<p class="BoxExtractPara">My view concerning your request: no.</p>&#13;
<p class="BoxExtractPara">Rationale: We’re trying to build a more secure internet. Meta-level comment:</p>&#13;
<p class="BoxExtractPara">You’re a bit late to the party. We’re metaphorically speaking at the stage of emptying the ash trays and hunting for the not quite empty beer cans.</p>&#13;
<p class="BoxExtractPara">More exactly, we are at draft 15 and RSA key transport disappeared from the spec about a dozen drafts ago. I know the banking industry is usually a bit slow off the mark, but this takes the biscuit.</p>&#13;
<p class="BoxExtractPara">Cheers, Kenny</p>&#13;
</blockquote>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="Tor">Tor</h2>&#13;
<p class="BodyFirst">Of all cryptographic applications, Tor has one of the highest ratios between real-world impact and academic contribution and interest. The Tor anonymity network, also known as the <em>onion router</em>, provides untraceability guarantees if used correctly. Those for whom these are vital (criminals and law enforcement, as well as some journalists and political activists) use Tor to increase their life expectancy. You can also use Tor to bypass network restrictions (such as government censorship) and mitigate tracking and surveillance, which is why using it might get you in trouble in certain places.</p>&#13;
<h2 id="Traitor-tracing">Traitor tracing</h2>&#13;
<p class="BodyFirst">Encryption schemes where different parties have a different decryption key to decrypt the same ciphertext. Traitor tracing aims, for example, to identify the source of a content leak and revoke access. But in practice, pirates can use a simple workaround: redistribute the content rather than the key. And anyway, large pay-TV deployments haven’t really used purely cryptographic traitor tracing schemes.</p>&#13;
<h2 id="Transfinite-cryptography">Transfinite cryptography</h2>&#13;
<p class="BodyFirst">Cryptography over transfinite numbers, that is, infinite numbers like <span class="NSSymbol">ℵ</span><sub>0</sub> (the cardinal of countable sets, such as that of integers <span class="NSSymbol">ℕ</span>), <span class="InlineGraphic"><img src="Images/i01002.jpg" width="99" height="25"/></span><span epub:type="pagebreak" title="130" id="Page_130"/>(cardinality of the continuum, that is, of the set of real numbers <span class="NSSymbol">ℝ</span>), or <span class="NSSymbol">ℵ</span><sub>1 </sub>(the cardinality of Ω, the set of all countable ordinal numbers—itself an uncountable set).</p>&#13;
<p>Transfinite cryptography describes a computational model for working with such infinite numbers, as well as analogues of stream ciphers, block ciphers, and hash functions, and public-key signatures using said hash functions (via Lamport’s construction).</p>&#13;
<p>An example of a definition is that of <span class="NSSymbol">ℵ</span><sub>0</sub>-one-way functions, which are functions computable in <span class="NSSymbol">ℵ</span><sub>0</sub> operations and <em>practically</em> <em>impossible</em> to invert with <em>only</em><span class="NSSymbol">ℵ</span><sub>0</sub> operations. If such a function takes strings of length <span class="NSSymbol">ℵ</span><sub>0</sub> as input, there are therefore <span class="InlineGraphic"><img src="Images/i01003.jpg" width="25" height="24"/></span> possible inputs, an uncountable number, preventing brute force even with infinite computational capabilities. Such a hash function isn’t known to exist and intuitively sounds impossible to define.</p>&#13;
<p>Needless to say, transfinite cryptography can only be implemented in a Platonic universe of mathematical objects, not on your computer or on a future quantum computer.</p>&#13;
<h2 id="Trapdoor">Trapdoor</h2>&#13;
<p class="BodyFirst">Not a backdoor. A trapdoor for some cryptographic function is a value, known to exist, that allows you to perform some operation that would otherwise be computationally hard. The best-known example is the RSA trapdoor permutation, which you can only invert using the RSA private key. A lesser-known example is that of trapdoor hash functions, such as VSH, for which collisions can only be found using the trapdoor.</p>&#13;
<h2 id="Triple-DES">Triple DES</h2>&#13;
<p class="BodyFirst">Known as TDEA in NIST’s official parlance. A cipher that consists not in three instances of DES but in one DES encryption, one DES decryption, and a second DES encryption. This is designed to emulate DES, because the Triple DES engine sets the same key for the first two instances, which then cancel themselves out. A Triple DES key can be up to 3 × 64 = 192 bits long. But Triple DES can’t boast 192-bit security, because 1) each 64-bit DES key only has 56 bits of information, thus bounding Triple DES’ security to 168 bits, and 2) meet-in-the-middle attacks can break Triple DES in approximately 2<sup>56 × 2</sup> = 2<sup>112</sup> operations. <span epub:type="pagebreak" title="131" id="Page_131"/>Like DES, Triple DES’ security is also limited by its 64-bit block size. So, even though Triple DES still found in legacy applications isn’t practically breakable, you’ve no reason to use it today. It fits best in crypto museums rather than modern applications. NIST retired Triple DES in 2018.</p>&#13;
<h2 id="Trivium">Trivium</h2>&#13;
<p class="BodyFirst">A minimalistic hardware-oriented stream cipher that uses an 80-bit key. For several years, its circular representation was used on the banner of the DEFCON conference website.</p>&#13;
<h2 id="True-random-number-generator-TRNG">True random number generator (TRNG)</h2>&#13;
<p class="BodyCustom">See <a href="#Pseudorandom-number-generator-PRNG"><em>Pseudorandom generator (PRNG)</em></a>.</p>&#13;
<h2 id="Trusted-third-party">Trusted third party</h2>&#13;
<p class="BodyFirst">The solution to most cryptography problems. Sometimes a trusted third party is inevitable, and the cryptographers’ job is to design protocols that minimize the level of trust required or that make any breach of trust detectable and recoverable.</p>&#13;
<h2 id="Tweakable-block-cipher">Tweakable block cipher</h2>&#13;
<p class="BodyFirst">A block cipher that takes an additional parameter, called the <em>tweak</em>, to ensure it produces different outputs with different tweaks. Unlike a key, a tweak isn’t necessarily secret and usually changes more often than the key. Changing the value of a tweak should incur only a negligible performance penalty, unlike a key change, which usually involves a costly key schedule operation. Tweakable block ciphers have been used for disk encryption, for example, and for exotic proprietary constructions that need additional inputs.</p>&#13;
<h2 id="Twitter">Twitter</h2>&#13;
<p class="BodyFirst">The location of the best and worst discussions about cryptography.</p>&#13;
<h2 id="Twofish">Twofish</h2>&#13;
<p class="BodyFirst">AES candidate and finalist. Twofish is the little brother of Blowfish and has 128-bit-long blocks instead of 64-bit-long ones.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="132" id="Page_132"/>MORE ON TWOFISH</h2>&#13;
<p class="BoxBodyFirst">Quoting from the Twofish paper, Twofish’s claims to fame included performance:</p>&#13;
<ul>&#13;
<li>Encrypt data at 285 clock cycles per block on a Pentium Pro, after a 12,700 clock-cycle key setup</li>&#13;
<li>Encrypt data at 860 clock cycles per block on a Pentium Pro, after a 1,250 clock-cycle key setup</li>&#13;
</ul>&#13;
<p class="BoxBodyContinued">as well as cryptanalysis work:</p>&#13;
<blockquote>&#13;
<p class="BoxExtractPara">And finally, we cryptanalyzed Twofish. We cryptanalyzed and cryptanalyzed and cryptanalyzed, right up to the morning of the submission deadline. We’re still cryptanalyzing; there’s no stopping.</p>&#13;
</blockquote>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h1 id="letter-U"><span class="ChapterTitle">U</span></h1>&#13;
<h2 id="Undeniable-signature">Undeniable signature</h2>&#13;
<p class="BodyFirst">A signature that cannot be verified without the signer’s cooperation, whether or not the signature is valid. Verifiers shouldn’t be able to determine if a signature is valid without interacting with the signer, and the signer shouldn’t be able to convince a prover that a valid signature is invalid, or vice versa.</p>&#13;
<p class="BodyCustom">See <a href="#Invisible-signature"><em>Invisible signature</em></a>.</p>&#13;
<h2 id="Universal-composability">Universal composability</h2>&#13;
<p class="BodyFirst">A theoretical framework for analyzing the security of combining cryptographic components, seeing as combining two secure protocols doesn’t automatically result in a secure protocol. It’s rarely applied to real use cases.</p>&#13;
<h2 id="Universal-hash-function">Universal hash function</h2>&#13;
<p class="BodyFirst">A hash function used in cryptography that isn’t the same as a cryptographic hash function. Unlike a general-purpose cryptographic hash, a universal hash function is parameterized by a secret key. Therefore, it’s actually a family of functions, like a pseudorandom function.</p>&#13;
<p><span epub:type="pagebreak" title="133" id="Page_133"/>But unlike a pseudorandom function, a universal hash function isn’t pseudorandom in the cryptographic sense, only in the statistical sense: there exist no two input values <em>M</em><sub>1</sub> and <em>M</em><sub>2</sub> such that Hash(<em>M</em><sub>1</sub>) = Hash(<em>M</em><sub>2</sub>) with abnormally high probability.</p>&#13;
<p>This property shouldn’t be mistaken for collision resistance, however. Collisions are usually easy to find for universal hash functions.</p>&#13;
<h2 id="Updatable-encryption">Updatable encryption</h2>&#13;
<p class="BodyFirst">An encryption scheme that can directly turn one ciphertext into another ciphertext, which can only be decrypted with a new, different key. A goal of updatable encryption is to perform key rotation on an untrusted system, as an alternative to the naive decrypt-encrypt approach.</p>&#13;
<h1 id="letter-V"><span class="ChapterTitle">V</span></h1>&#13;
<h2 id="Verifiable-delay-function-VDF">Verifiable delay function (VDF)</h2>&#13;
<p class="BodyFirst">A function whose computation cannot be sped up by extra parallelism or storage; therefore, it must be computed sequentially, like a proof of sequential work. But unlike the latter, VDFs admit only one solution.</p>&#13;
<p class="BodyCustom">See <a href="#Proof-of-sequential-work"><em>Proof of sequential work</em></a>, <a href="#Time-lock-puzzle"><em>Time-lock puzzle</em></a>.</p>&#13;
<h2 id="Verifiable-random-function-VRF">Verifiable random function (VRF)</h2>&#13;
<p class="BodyFirst">The public-key counterpart of a pseudorandom function, where the public key can be used to verify that the output has been computed correctly by verifying the proof of correctness generated along with the function’s output.</p>&#13;
<p>VRFs sound similar to public-key signatures but differ in two main aspects: a VRF’s result is always deterministic (whereas a message can admit many valid ECDSA signatures, for example), and a VRF can generate a result and a proof (where the proof might be randomized).</p>&#13;
<p>VRFs have been used to build (theoretical versions of) lottery systems and transaction escrow schemes, and are used in several blockchain platforms.</p>&#13;
<h2 id="Verifiable-unpredictable-function-VUF"><span epub:type="pagebreak" title="134" id="Page_134"/>Verifiable unpredictable function (VUF)</h2>&#13;
<p class="BodyFirst">A function that somehow occupies a niche between signatures and VRFs: a VUF is like a VRF but isn’t necessarily pseudorandom, only unpredictable. But unlike a signature, there must be only one valid output for a given message. A VUF scheme can thus be regarded as a unique signature.</p>&#13;
<p class="BodyCustom">See <a href="#Verifiable-random-function-VRF"><em>Verifiable random function (VRF)</em></a>.</p>&#13;
<h2 id="Vigenere-cipher">Vigenère cipher</h2>&#13;
<p class="BodyFirst">A cipher more secure than Caesar’s.</p>&#13;
<h2 id="VSH-Very-Smooth-Hash">VSH (Very Smooth Hash)</h2>&#13;
<p class="BodyFirst">A hash function with provable collision resistance, based on the hardness of factoring integers. But VSH (second) preimage resistance doesn’t have as strong security guarantees.</p>&#13;
<h1 id="letter-W"><span class="ChapterTitle">W</span></h1>&#13;
<h2 id="Wallet">Wallet</h2>&#13;
<p class="BodyFirst">In cryptocurrencies, a set of accounts managed by a single individual or organization. Each account consists of a private key used for signing and an address somehow derived from the public key. Typically, these accounts are organized hierarchically, from one or more seeds, using BIP32 or a similar hierarchical derivation. This is convenient, because you can then manage a practically infinite number of accounts by storing only a single secret.</p>&#13;
<p>By extension, a wallet refers to any application or device that implements account management functionalities. Hardware wallets offer the best feeling of security, and sometimes they really are more secure. That said, they don’t protect any better than software wallets against the most common risk: the lack of reliable backups.</p>&#13;
<h2 id="Watermarking">Watermarking</h2>&#13;
<p class="BodyFirst">The practice of embedding a value in some analog information (such as an image, video, or sound), usually during digital encoding, in such <span epub:type="pagebreak" title="135" id="Page_135"/>a way that the value can’t be extracted or removed. In its most robust forms, it also survives noise, transcoding, and digital-analog-digital conversion.</p>&#13;
<h2 id="White-box-cryptography">White-box cryptography</h2>&#13;
<p class="BodyFirst">Obfuscation at the algorithm level. Put otherwise, a means of implementing, say, AES in such a way that the implementation for a given key doesn’t reveal the key. This sounds like magic, and like real magic, it doesn’t actually exist, although advanced techniques give the illusion that it does. Most white-box techniques have indeed been broken, at least on paper. But in practice, they contribute to making reverse engineering harder, due to being supplemented by software-level defenses (such as software obfuscation, anti-tampering, anti-debugging, device binding, and so on).</p>&#13;
<p>Fundamentally, white-box cryptography is about transforming a symmetric cipher into an asymmetric one. If that were feasible, it would mean that we could create public-key encryption from a symmetric primitive, which would be surprising (despite the fact that we can construct public-key signatures from hash functions.)</p>&#13;
<h2 id="Winternitz-signature">Winternitz signature</h2>&#13;
<p class="BodyFirst">An extension of Lamport hash-based signatures that can hash values greater than one. For example, to hash 4-bit messages, or integers between 0 and 15, you would publish Hash<sup>16</sup>(<em>K</em>) as a public key, and then sign a message <em>M </em><span class="NSSymbol">∈</span> [0, 15] by computing Hash<sup><em>M</em></sup>(<em>K</em>), where <em>M </em>is the number of hash iterations.</p>&#13;
<p>This works better than Lamport’s binary scheme, but it still doesn’t scale—just imagine the work involved in signing a 64-bit value.</p>&#13;
<h2 id="WireGuard">WireGuard</h2>&#13;
<p class="BodyFirst">A network-layer protocol for peer-to-peer secure channels that grew out of a kernel rootkit project. WireGuard was designed for SSH-like usage and VPN functionality. As per its creator’s words, WireGuard is “cryptographically opinionated,” which means it consists of a single suite of algorithms, as well as minimal cryptographic bureaucracy. Notably, it excludes certificates and thus ASN.1 or X.509 parsing. Unlike many projects, WireGuard has focused its efforts on cryptography and implementation quality with a much smaller code base than its alternatives.</p>&#13;
<p><span epub:type="pagebreak" title="136" id="Page_136"/>Initially regarded with suspicion by the cryptographic intelligent­sia, WireGuard’s success and security track record now speak for themselves.</p>&#13;
<h1 id="letter-X"><span class="ChapterTitle">X</span></h1>&#13;
<h2 id="X25519">X25519</h2>&#13;
<p class="BodyFirst">Diffie–Hellman with Curve25519.</p>&#13;
<p class="BodyCustom">See <a href="#Curve25519"><em>Curve25519</em></a>.</p>&#13;
<h2 id="X3DH">X3DH</h2>&#13;
<p class="BodyFirst">Extended triple Diffie–Hellman, a variant of Diffie–Hellman popularized by its use in the Signal protocol. X3DH combines multiple key pairs to compute one shared secret instead of using just one key pair per participant, as in basic Diffie–Hellman.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>HOW X3DH WORKS</h2>&#13;
<p class="BoxBodyFirst">In its simplest setting, an X3DH operation between Alice and Bob works like this.</p>&#13;
<p>First, it combines their long-term identity keys IK<sub>A</sub><em> </em>and IK<sub>B</sub> and their ephemeral, one-time keys EK<sub>A</sub><em> </em>and EK<sub>B</sub> by computing the shared secret SK as follows, where DH() is a Diffie–Hellman operation:</p>&#13;
<ol class="none">&#13;
<li>DH<sub>1</sub> = DH(IK<sub>A</sub>, EK<sub>B</sub>) </li>&#13;
<li>DH<sub>2</sub> = DH(EK<sub>A</sub>, IK<sub>B</sub>) </li>&#13;
<li>DH<sub>3</sub> = DH(EK<sub>A</sub>, EK<sub>B</sub>)</li>&#13;
<li>SK = KDF(DH<sub>1</sub>, DH<sub>2</sub>, DH<sub>3</sub>)</li>&#13;
</ol>&#13;
<p>Here, KDF() is a key derivation function. Alice computes these operations using her private keys and Bob’s public keys, whereas Bob does the opposite.</p>&#13;
<p>In practice, if Alice initiates the protocol, she’ll pick a random ephemeral key and fetch a precomputed ephemeral key for Bob from the message server, where such keys are called pre-keys. X3DH was designed for use in asynchronous communications; it attempts to fulfill several security requirements in a way that minimizes computations and trust assumptions.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="XMSS-eXtended-Merkle-Signature-Scheme"><span epub:type="pagebreak" title="137" id="Page_137"/>XMSS (eXtended Merkle Signature Scheme)</h2>&#13;
<p class="BodyFirst">A public-key signature scheme that uses only a hash function and a tree structure. XMSS’s statefulness—or obligation to keep track of a counter over signature operations—has been called <em>a huge foot-cannon</em>. Even so, XMSS has become an IETF standard and was experimentally integrated in OpenSSH.</p>&#13;
<p class="BodyCustom">See <a href="#SPHINCS"><em>SPHINCS</em></a>.</p>&#13;
<h2 id="XOF-extendable-output-function">XOF (extendable output function)</h2>&#13;
<p class="BodyFirst">A hash function whose output can be of variable size. The function can also extend the length of the output if needed. By contrast, in nonextendable, variable-size output functions, output values of different sizes are completely distinct, and the shorter ones aren’t prefixes of the longer.</p>&#13;
<h2 id="XOR">XOR</h2>&#13;
<p class="BodyFirst">The exclusive OR logical operation, written as <span class="NSSymbol">⊕</span>. XOR obeys the following rules: true XOR false equals true; true XOR true equals false; and false XOR false equal false. When viewed as a binary operator, the rules produce the following results: 1 <span class="NSSymbol">⊕</span> 1 = 0 <span class="NSSymbol">⊕</span> 0 = 0, 0 <span class="NSSymbol">⊕</span> 1 = 1 <span class="NSSymbol">⊕</span> 0 = 1. Extended to bit strings, you’d get 0111 <span class="NSSymbol">⊕</span> 1101 = 1010, and so on.</p>&#13;
<h2 id="XOR-encryption">XOR encryption</h2>&#13;
<p class="BodyFirst">A straightforward form of encryption, sometimes used in malware as an obfuscation layer. It’s similar to a one-time pad except that the XORed value isn’t always secret or used only once.</p>&#13;
<h1 id="letter-Z"><span class="ChapterTitle">Z</span></h1>&#13;
<h2 id="Zerocash">Zerocash</h2>&#13;
<p class="BodyFirst">Came after Zerocoin but before Zcash.</p>&#13;
<h2 id="ZKP-zero-knowledge-proof">ZKP (zero-knowledge proof)</h2>&#13;
<p class="BodyFirst">A protocol where a prover convinces a verifier that they know some mathematical statement (such as the solution to a hard problem) without revealing said statement.</p>&#13;
<p><span epub:type="pagebreak" title="138" id="Page_138"/>Now a mainstream concept among crypto enthusiasts, ZKPs were once an obscure field at the intersection of cryptography and theoretical computer science.</p>&#13;
<p>Zero-knowledge is a broad and rich discipline, arguably still in its infancy as far as applications are concerned. There have been a few ZKPs advancing from conference proceedings to the real world: these applications include e-voting and blockchain applications, wherein noninteractive ZKPs help protect the privacy of transactions. ZKPs are also a component of threshold signing schemes as used for certain cold storage systems.</p>&#13;
<p>Cryptographic zero-knowledge shouldn’t be confused with the security engineering concept of zero-knowledge architecture or with the marketing term zero-knowledge referring to client-side encryption.</p>&#13;
<p class="BodyCustom">See <a href="#NIZK-non-interactive-zero-knowledge"><em>NIZK (non-interactive zero-knowledge)</em></a>.</p>&#13;
&#13;
<h2 id="ZRTP">ZRTP</h2>&#13;
<p class="BodyFirst">A key agreement procedure for RTP connections and used in voice-over-IP connections between two peers. Initially present in the Signal application to enable end-to-end encrypted calls, ZRTP was later discarded in favor of keys derived from the text messaging session state, which turned out to be simpler and more secure. The Z in ZRTP represents Phil Zimmermann.</p>&#13;
<header><h1 class="FrontmatterTitle pagebreak" id="fm-501409c01-0001"><span epub:type="pagebreak" title="139" id="Page_139"/>Index of Terms</h1></header>&#13;
<p class="index1"><a href="#2013">2013</a></p>&#13;
<p class="index1"><a href="#65537">65537</a></p>&#13;
<p class="index1"><a href="#A5-0">A5/0</a></p>&#13;
<p class="index1"><a href="#A5-1">A5/1</a></p>&#13;
<p class="index1"><a href="#A5-2">A5/2</a></p>&#13;
<p class="index1"><a href="#A5-3">A5/3</a></p>&#13;
<p class="index1"><a href="#A5-4">A5/4</a></p>&#13;
<p class="index1"><a href="#Adaptive-attack">Adaptive attack</a></p>&#13;
<p class="index1"><a href="#AEAD-authenticated-encryption-with-associated-data-">AEAD (authenticated encryption with associated data) </a></p>&#13;
<p class="index1"><a href="#AES-Advanced-Encryption-Standard">AES (Advanced Encryption Standard)</a></p>&#13;
<p class="index1"><a href="#AES-CCM">AES-CCM</a></p>&#13;
<p class="index1"><a href="#AES-GCM">AES-GCM</a></p>&#13;
<p class="index1"><a href="#AES-GCM-SIV">AES-GCM-SIV</a></p>&#13;
<p class="index1"><a href="#AES-NI">AES-NI</a></p>&#13;
<p class="index1"><a href="#AES-SIV">AES-SIV</a></p>&#13;
<p class="index1"><a href="#AIM-Advanced-INFOSEC-Machine">AIM (Advanced INFOSEC Machine)</a></p>&#13;
<p class="index1"><a href="#AKA">AKA</a></p>&#13;
<p class="index1"><a href="#AKS-Agrawal%E2%80%93Kayal%E2%80%93Saxena">AKS (Agrawal–Kayal–Saxena)</a></p>&#13;
<p class="index1"><a href="#Algebraic-cryptanalysis">Algebraic cryptanalysis</a></p>&#13;
<p class="index1"><a href="#Alice">Alice</a></p>&#13;
<p class="index1"><a href="#All-or-nothing-transform-AONT">All-or-nothing transform (AONT)</a></p>&#13;
<p class="index1"><a href="#Anonymous-signature">Anonymous signature</a></p>&#13;
<p class="index1"><a href="#Applied-Cryptography">Applied Cryptography</a></p>&#13;
<p class="index1"><a href="#Applied-cryptography">Applied cryptography</a></p>&#13;
<p class="index1"><a href="#ARC4">ARC4</a></p>&#13;
<p class="index1"><a href="#Argon2">Argon2</a></p>&#13;
<p class="index1"><a href="#ARX-Add-Rotate-XOR">ARX (Add-Rotate-XOR)</a></p>&#13;
<p class="index1"><a href="#ASIACRYPT">ASIACRYPT</a></p>&#13;
<p class="index1"><a href="#Asymmetric-cryptography">Asymmetric cryptography</a></p>&#13;
<p class="index1"><a href="#Attack">Attack</a></p>&#13;
<p class="index1"><a href="#Attribute-based-encryption-ABE">Attribute-based encryption (ABE)</a></p>&#13;
<p class="index1"><a href="#Authenticated-cipher">Authenticated cipher</a></p>&#13;
<p class="index1"><a href="#Axolotl">Axolotl</a></p>&#13;
<p class="index1"><a href="#Backdoor">Backdoor</a></p>&#13;
<p class="index1"><a href="#Backtracking-resistance">Backtracking resistance</a></p>&#13;
<p class="index1"><a href="#Backward-secrecy">Backward secrecy</a></p>&#13;
<p class="index1"><a href="#Base64">Base64</a></p>&#13;
<p class="index1"><a href="#BassOmatic">BassOmatic</a></p>&#13;
<p class="index1"><a href="#BB84">BB84</a></p>&#13;
<p class="index1"><a href="#bcrypt">bcrypt</a></p>&#13;
<p class="index1"><a href="#Biclique-cryptanalysis">Biclique cryptanalysis</a></p>&#13;
<p class="index1"><a href="#BIKE-Bit-Flipping-Key-Encapsulation">BIKE (Bit Flipping Key Encapsulation)</a></p>&#13;
<p class="index1"><a href="#BIP-Bitcoin-improvement-proposal">BIP (Bitcoin improvement proposal)</a></p>&#13;
<p class="index1"><a href="#Bit-Gold">Bit Gold</a></p>&#13;
<p class="index1"><a href="#Bitcoin">Bitcoin</a></p>&#13;
<p class="index1"><a href="#Black">Black</a></p>&#13;
<p class="index1"><a href="#BLAKE">BLAKE</a></p>&#13;
<p class="index1"><a href="#BLAKE2">BLAKE2</a></p>&#13;
<p class="index1"><a href="#BLAKE3">BLAKE3</a></p>&#13;
<p class="index1"><a href="#Bleichenbacher-attack">Bleichenbacher attack</a></p>&#13;
<p class="index1"><a href="#Blind-signature">Blind signature</a></p>&#13;
<p class="index1"><a href="#Block-cipher">Block cipher</a></p>&#13;
<p class="index1"><a href="#Blockchain">Blockchain</a></p>&#13;
<p class="index1"><a href="#Blockcipher">Blockcipher</a></p>&#13;
<p class="index1"><a href="#Blowfish">Blowfish</a></p>&#13;
<p class="index1"><a href="#BLS-Boneh-Lynn-Shacham-signature">BLS (Boneh-Lynn-Shacham) signature</a></p>&#13;
<p class="index1"><a href="#Bob">Bob</a></p>&#13;
<p class="index1"><a href="#Boolean-function">Boolean function</a></p>&#13;
<p class="index1"><a href="#Boomerang-attack">Boomerang attack</a></p>&#13;
<p class="index1"><a href="#BQP-bounded-error-quantum-polynomial-time">BQP (bounded-error quantum polynomial time)</a></p>&#13;
<p class="index1"><a href="#Braid-group-cryptography">Braid group cryptography</a></p>&#13;
<p class="index1"><a href="#Brainpool-curves">Brainpool curves</a></p>&#13;
<p class="index1"><a href="Images/#Break-in-recovery"><span epub:type="pagebreak" title="140" id="Page_140"/>Break-in recovery</a></p>&#13;
<p class="index1"><a href="#Broadcast-encryption">Broadcast encryption</a></p>&#13;
<p class="index1"><a href="#Brute-force-attack">Brute-force attack</a></p>&#13;
<p class="index1"><a href="#Bulletproof">Bulletproof</a></p>&#13;
<p class="index1"><a href="#Byzantine-fault-tolerance">Byzantine fault tolerance</a></p>&#13;
<p class="index1"><a href="#CAESAR">CAESAR</a></p>&#13;
<p class="index1"><a href="#Caesar%E2%80%99s-cipher">Caesar’s cipher</a></p>&#13;
<p class="index1"><a href="#CAVP-Cryptographic-Algorithm-Validation-Program">CAVP (Cryptographic Algorithm Validation Program)</a></p>&#13;
<p class="index1"><a href="#CBC-cipher-block-chaining">CBC (cipher block chaining)</a></p>&#13;
<p class="index1"><a href="#CECPQ-combined-elliptic-curve-and-post-quantum">CECPQ (combined elliptic-curve and post-quantum)</a></p>&#13;
<p class="index1"><a href="#Cellular-automata">Cellular automata</a></p>&#13;
<p class="index1"><a href="#Ceremony">Ceremony</a></p>&#13;
<p class="index1"><a href="#Certificate">Certificate</a></p>&#13;
<p class="index1"><a href="#Certificate-authority-CA">Certificate authority (CA)</a></p>&#13;
<p class="index1"><a href="#Certificate-transparency-CT">Certificate transparency (CT)</a></p>&#13;
<p class="index1"><a href="#ChaCha20">ChaCha20</a></p>&#13;
<p class="index1"><a href="#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems">CHES (Conference on Cryptographic Hardware and Embedded Systems)</a></p>&#13;
<p class="index1"><a href="#CIA">CIA</a></p>&#13;
<p class="index1"><a href="#Ciphertext-stealing">Ciphertext stealing</a></p>&#13;
<p class="index1"><a href="#Clipper">Clipper</a></p>&#13;
<p class="index1"><a href="#CMVP-Cryptographic-Module-Validation-Program">CMVP (Cryptographic Module Validation Program)</a></p>&#13;
<p class="index1"><a href="#Code-based-cryptography">Code-based cryptography</a></p>&#13;
<p class="index1"><a href="#Commitment">Commitment</a></p>&#13;
<p class="index1"><a href="#Concurrent-zero-knowledge">Concurrent zero-knowledge</a></p>&#13;
<p class="index1"><a href="#Consensus-protocol">Consensus protocol</a></p>&#13;
<p class="index1"><a href="#Control-word">Control word</a></p>&#13;
<p class="index1"><a href="#COPACOBANA-Cost-Optimized-PArallel-COde-Breaker">COPACOBANA (Cost-Optimized PArallel COde Breaker)</a></p>&#13;
<p class="index1"><a href="#Cothority-collective-authority">Cothority (collective authority)</a></p>&#13;
<p class="index1"><a href="#Cryptanalysis">Cryptanalysis</a></p>&#13;
<p class="index1"><a href="#Cryptids">Cryptids</a></p>&#13;
<p class="index1"><a href="#Crypto">Crypto</a></p>&#13;
<p class="index1"><a href="#CRYPTO">CRYPTO</a></p>&#13;
<p class="index1"><a href="#Crypto-AG">Crypto AG</a></p>&#13;
<p class="index1"><a href="#Crypto-period">Crypto period</a></p>&#13;
<p class="index1"><a href="#Crypto-variable">Crypto variable</a></p>&#13;
<p class="index1"><a href="#Crypto-wars">Crypto wars</a></p>&#13;
<p class="index1"><a href="#Cryptobiosis">Cryptobiosis</a></p>&#13;
<p class="index1"><a href="#Cryptocurrency">Cryptocurrency</a></p>&#13;
<p class="index1"><a href="#Crypto-Gram">Crypto-Gram</a></p>&#13;
<p class="index1"><a href="#Cryptography">Cryptography</a></p>&#13;
<p class="index1"><a href="#Cryptologia"><em>Cryptologia</em></a></p>&#13;
<p class="index1"><a href="#Cryptology">Cryptology</a></p>&#13;
<p class="index1"><a href="#Cryptonomicon"><em>Cryptonomicon</em></a></p>&#13;
<p class="index1"><a href="#Cryptorchidism">Cryptorchidism</a></p>&#13;
<p class="index1"><a href="#Cryptovirology">Cryptovirology</a></p>&#13;
<p class="index1"><a href="#CRYPTREC">CRYPTREC</a></p>&#13;
<p class="index1"><a href="#CSIDH-Commutative-Supersingular-Isogeny-Diffie%E2%80%93Hellman">CSIDH (Commutative Supersingular Isogeny Diffie–Hellman)</a></p>&#13;
<p class="index1"><a href="#CTF-capture-the-flag">CTF (capture the flag)</a></p>&#13;
<p class="index1"><a href="#Cube-attack">Cube attack</a></p>&#13;
<p class="index1"><a href="#Curve25519">Curve25519</a></p>&#13;
<p class="index1"><a href="#Curve448">Curve448</a></p>&#13;
<p class="index1"><a href="#Cypher">Cypher</a></p>&#13;
<p class="index1"><a href="#Daemon">Daemon</a></p>&#13;
<p class="index1"><a href="#Davies%E2%80%93Meyer">Davies–Meyer</a></p>&#13;
<p class="index1"><a href="#Decentralized-private-computation">Decentralized private computation</a></p>&#13;
<p class="index1"><a href="#D%C3%A9chiffrer">Déchiffrer</a></p>&#13;
<p class="index1"><a href="#D%C3%A9crypter">Décrypter</a></p>&#13;
<p class="index1"><a href="#Deniable-encryption">Deniable encryption</a></p>&#13;
<p class="index1"><a href="#DES-Data-Encryption-Standard">DES (Data Encryption Standard)</a></p>&#13;
<p class="index1"><a href="#Dictionary">Dictionary</a></p>&#13;
<p class="index1"><a href="#Dictionary-attack">Dictionary attack</a></p>&#13;
<p class="index1"><a href="#Differential-cryptanalysis">Differential cryptanalysis</a></p>&#13;
<p class="index1"><a href="#Diffie%E2%80%93Hellman">Diffie–Hellman</a></p>&#13;
<p class="index1"><a href="#Disclosure">Disclosure</a></p>&#13;
<p class="index1"><a href="#Discrete-logarithm-problem">Discrete logarithm problem</a></p>&#13;
<p class="index1"><a href="#Distinguisher">Distinguisher</a></p>&#13;
<p class="index1"><a href="#Distributed-randomness">Distributed randomness</a></p>&#13;
<p class="index1"><a href="#Dolev%E2%80%93Yao-model">Dolev–Yao model</a></p>&#13;
<p class="index1"><a href="#Double-ratchet">Double ratchet</a></p>&#13;
<p class="index1"><a href="#Dragonfly">Dragonfly</a></p>&#13;
<p class="index1"><a href="#DRBG-deterministic-random-bit-generator">DRBG (deterministic random bit generator)</a></p>&#13;
<p class="index1"><a href="#DSA-Digital-Signature-Algorithm">DSA (Digital Signature Algorithm)</a></p>&#13;
<p class="index1"><a href="#DSS-Digital-Signature-Standard">DSS (Digital Signature Standard)</a></p>&#13;
<p class="index1"><a href="#DVB-CSA">DVB-CSA</a></p>&#13;
<p class="index1"><a href="#E0">E0</a></p>&#13;
<p class="index1"><a href="#ECB-electronic-codebook">ECB (electronic codebook)</a></p>&#13;
<p class="index1"><a href="#ECC">ECC</a></p>&#13;
<p class="index1"><a href="#ECDLP-Elliptic-curve-discrete-logarithm-problem">ECDLP (Elliptic-curve discrete logarithm problem)</a></p>&#13;
<p class="index1"><a href="#ECDSA-Elliptic-curve-DSA">ECDSA (Elliptic-curve DSA)</a></p>&#13;
<p class="index1"><a href="#ECIES-Elliptic-curve-IES">ECIES (Elliptic-curve IES)</a></p>&#13;
<p class="index1"><a href="#Ed25519">Ed25519</a></p>&#13;
<p class="index1"><a href="#EdDSA">EdDSA</a></p>&#13;
<p class="index1"><a href="#EKMS-Electronic-Key-Management-System"><span epub:type="pagebreak" title="141" id="Page_141"/>EKMS (Electronic Key Management System)</a></p>&#13;
<p class="index1"><a href="#Electronic-codebook">Electronic codebook</a></p>&#13;
<p class="index1"><a href="#ElGamal">ElGamal</a></p>&#13;
<p class="index1"><a href="#Elligator">Elligator</a></p>&#13;
<p class="index1"><a href="#Elliptic-curve">Elliptic curve</a></p>&#13;
<p class="index1"><a href="#Elliptic-curve-cryptography">Elliptic-curve cryptography</a></p>&#13;
<p class="index1"><a href="#Encipherment">Encipherment</a></p>&#13;
<p class="index1"><a href="#End-to-end-encryption-E2EE">End-to-end encryption (E2EE)</a></p>&#13;
<p class="index1"><a href="#Enigma">Enigma</a></p>&#13;
<p class="index1"><a href="#Entropy">Entropy</a></p>&#13;
<p class="index1"><a href="#ePrint">ePrint</a></p>&#13;
<p class="index1"><a href="#Erathosthenes%E2%80%99-sieve">Erathosthenes’ sieve</a></p>&#13;
<p class="index1"><a href="#eSTREAM">eSTREAM</a></p>&#13;
<p class="index1"><a href="#Ethereum">Ethereum</a></p>&#13;
<p class="index1"><a href="#Eurocrypt">Eurocrypt</a></p>&#13;
<p class="index1"><a href="#Eve">Eve</a></p>&#13;
<p class="index1"><a href="#E-voting">E-voting</a></p>&#13;
<p class="index1"><a href="#Factoring-problem">Factoring problem</a></p>&#13;
<p class="index1"><a href="#Feedback-shift-register">Feedback shift register</a></p>&#13;
<p class="index1"><a href="#Feistel-network">Feistel network</a></p>&#13;
<p class="index1"><a href="#Fialka-%D0%A4%D0%B8%D0%B0%D0%BB%D0%BA%D0%B0">Fialka (Фиалка)</a></p>&#13;
<p class="index1"><a href="#Fiat%E2%80%93Shamir">Fiat–Shamir</a></p>&#13;
<p class="index1"><a href="#FIPS-140-2">FIPS 140-2</a></p>&#13;
<p class="index1"><a href="#FIPS-140-3">FIPS 140-3</a></p>&#13;
<p class="index1"><a href="#Forgery">Forgery</a></p>&#13;
<p class="index1"><a href="#Formal-verification">Formal verification</a></p>&#13;
<p class="index1"><a href="#Format-preserving-encryption">Format-preserving encryption</a></p>&#13;
<p class="index1"><a href="#Forward-secrecy">Forward secrecy</a></p>&#13;
<p class="index1"><a href="#FOX">FOX</a></p>&#13;
<p class="index1"><a href="#FSE-Fast-Software-Encryption">FSE (Fast Software Encryption)</a></p>&#13;
<p class="index1"><a href="#Fully-homomorphic-encryption">Fully homomorphic encryption</a></p>&#13;
<p class="index1"><a href="#Functional-encryption">Functional encryption</a></p>&#13;
<p class="index1"><a href="#Future-secrecy">Future secrecy</a></p>&#13;
<p class="index1"><a href="#Fuzzy-extractor">Fuzzy extractor</a></p>&#13;
<p class="index1"><a href="#Generalized-birthday-problem">Generalized birthday problem</a></p>&#13;
<p class="index1"><a href="#GNFS-General-Number-Field-Sieve">GNFS (General Number Field Sieve)</a></p>&#13;
<p class="index1"><a href="#GOST">GOST</a></p>&#13;
<p class="index1"><a href="#Grain">Grain</a></p>&#13;
<p class="index1"><a href="#Gr%C3%B6bner-basis">Gröbner basis</a></p>&#13;
<p class="index1"><a href="#Group-signature">Group signature</a></p>&#13;
<p class="index1"><a href="#Grover%E2%80%99s-algorithm">Grover’s algorithm</a></p>&#13;
<p class="index1"><a href="#Hardcore-predicate">Hardcore predicate</a></p>&#13;
<p class="index1"><a href="#Hash-function">Hash function</a></p>&#13;
<p class="index1"><a href="#Hash-based-cryptography">Hash-based cryptography</a></p>&#13;
<p class="index1"><a href="#Heartbleed">Heartbleed</a></p>&#13;
<p class="index1"><a href="#Hedged-signature">Hedged signature</a></p>&#13;
<p class="index1"><a href="#HFE-Hidden-Field-Equations">HFE (Hidden Field Equations)</a></p>&#13;
<p class="index1"><a href="#HMAC-Hash-based-MAC">HMAC (Hash-based MAC)</a></p>&#13;
<p class="index1"><a href="#Homomorphic-encryption">Homomorphic encryption</a></p>&#13;
<p class="index1"><a href="#HPC-Hasty-Pudding-Cipher">HPC (Hasty Pudding Cipher)</a></p>&#13;
<p class="index1"><a href="#HSM-hardware-security-module">HSM (hardware security module)</a></p>&#13;
<p class="index1"><a href="#HTTP-3">HTTP/3</a></p>&#13;
<p class="index1"><a href="#Hyperelliptic-curve-cryptography">Hyperelliptic-curve cryptography</a></p>&#13;
<p class="index1"><a href="#IACR-International-Association-for-Cryptologic-Research">IACR (International Association for Cryptologic Research)</a></p>&#13;
<p class="index1"><a href="#IDEA-International-Data-Encryption-Algorithm">IDEA (International Data Encryption Algorithm)</a></p>&#13;
<p class="index1"><a href="#IDEA-NXT">IDEA NXT</a></p>&#13;
<p class="index1"><a href="#Identity-based-encryption">Identity-based encryption</a></p>&#13;
<p class="index1"><a href="#IES-Integrated-Encryption-Scheme">IES (Integrated Encryption Scheme)</a></p>&#13;
<p class="index1"><a href="#Impatient-saboteur">Impatient saboteur</a></p>&#13;
<p class="index1"><a href="#Impossibility">Impossibility</a></p>&#13;
<p class="index1"><a href="#Impossible-differential-attack">Impossible differential attack</a></p>&#13;
<p class="index1"><a href="#IND-CCA">IND-CCA</a></p>&#13;
<p class="index1"><a href="#IND-CPA">IND-CPA</a></p>&#13;
<p class="index1"><a href="#Indelibility">Indelibility</a></p>&#13;
<p class="index1"><a href="#Indifferentiability">Indifferentiability</a></p>&#13;
<p class="index1"><a href="#Indistinguishability">Indistinguishability</a></p>&#13;
<p class="index1"><a href="#Indistinguishability-obfuscation-iO">Indistinguishability obfuscation (iO)</a></p>&#13;
<p class="index1"><a href="#Information-theoretic-security">Information-theoretic security</a></p>&#13;
<p class="index1"><a href="#INT-CTXT">INT-CTXT</a></p>&#13;
<p class="index1"><a href="#Invisible-signature">Invisible signature</a></p>&#13;
<p class="index1"><a href="#IOTA">IOTA</a></p>&#13;
<p class="index1"><a href="#IPES-Improved-Proposed-Encryption-Standard">IPES (Improved Proposed Encryption Standard)</a></p>&#13;
<p class="index1"><a href="#IPSec">IPSec</a></p>&#13;
<p class="index1"><a href="#ISO-standard">ISO standard</a></p>&#13;
<p class="index1"><a href="#Isogeny-based-cryptography">Isogeny-based cryptography</a></p>&#13;
<p class="index1"><a href="#Journal-of-Cryptology-JoC"><em>Journal of Cryptology</em> (JoC)</a></p>&#13;
<p class="index1"><a href="#KASUMI">KASUMI</a></p>&#13;
<p class="index1"><a href="#Keccak">Keccak</a></p>&#13;
<p class="index1"><a href="#KeeLoq">KeeLoq</a></p>&#13;
<p class="index1"><a href="#KEM-key-encapsulation-mechanism">KEM (key encapsulation mechanism)</a></p>&#13;
<p class="index1"><a href="#Kerberos">Kerberos</a></p>&#13;
<p class="index1"><a href="#Kerckhoffs%E2%80%99-principles">Kerckhoffs’ principles</a></p>&#13;
<p class="index1"><a href="#Key-derivation-function-KDF">Key derivation function (KDF)</a></p>&#13;
<p class="index1"><a href="#Key-escrow">Key escrow</a></p>&#13;
<p class="index1"><a href="#Key-management"><span epub:type="pagebreak" title="142" id="Page_142"/>Key management</a></p>&#13;
<p class="index1"><a href="#Key-wrapping">Key wrapping</a></p>&#13;
<p class="index1"><a href="#Kleptography">Kleptography</a></p>&#13;
<p class="index1"><a href="#Known-key-attack">Known-key attack</a></p>&#13;
<p class="index1"><a href="#Kupyna-%D0%9A%D1%83%D0%BF%D0%B8%D0%BD%D0%B0">Kupyna (Купина)</a></p>&#13;
<p class="index1"><a href="#Laconic-zero-knowledge-proof">Laconic zero-knowledge proof</a></p>&#13;
<p class="index1"><a href="#Lai%E2%80%93Massey">Lai–Massey</a></p>&#13;
<p class="index1"><a href="#Lamport-signature">Lamport signature</a></p>&#13;
<p class="index1"><a href="#Lattice-based-cryptography">Lattice-based cryptography</a></p>&#13;
<p class="index1"><a href="#Le-Chiffre">Le Chiffre</a></p>&#13;
<p class="index1"><a href="#Leakage-resilient-cryptography">Leakage-resilient cryptography</a></p>&#13;
<p class="index1"><a href="#Learning-with-errors-LWE">Learning with errors (LWE)</a></p>&#13;
<p class="index1"><a href="#Length-extension-attack">Length extension attack</a></p>&#13;
<p class="index1"><a href="#Length-preserving-encryption">Length-preserving encryption</a></p>&#13;
<p class="index1"><a href="#LFSR-linear-feedback-shift-register">LFSR (linear feedback shift register)</a></p>&#13;
<p class="index1"><a href="#Lightweight-cryptography">Lightweight cryptography</a></p>&#13;
<p class="index1"><a href="#Linear-cryptanalysis">Linear cryptanalysis</a></p>&#13;
<p class="index1"><a href="#Linkability">Linkability</a></p>&#13;
<p class="index1"><a href="#LM-hash">LM hash</a></p>&#13;
<p class="index1"><a href="#Luby%E2%80%93Rackoff">Luby–Rackoff</a></p>&#13;
<p class="index1"><a href="#Lucifer">Lucifer</a></p>&#13;
<p class="index1"><a href="#MAC-message-authentication-code">MAC (message authentication code)</a></p>&#13;
<p class="index1"><a href="#MAGENTA">MAGENTA</a></p>&#13;
<p class="index1"><a href="#Malleability">Malleability</a></p>&#13;
<p class="index1"><a href="#Manger-attack">Manger attack</a></p>&#13;
<p class="index1"><a href="#Man-in-the-middle">Man-in-the-middle</a></p>&#13;
<p class="index1"><a href="#MASH-Modular-Arithmetic-Secure-Hash">MASH (Modular Arithmetic Secure Hash)</a></p>&#13;
<p class="index1"><a href="#McEliece-encryption-scheme">McEliece encryption scheme</a></p>&#13;
<p class="index1"><a href="#MD4">MD4</a></p>&#13;
<p class="index1"><a href="#MD5">MD5</a></p>&#13;
<p class="index1"><a href="#MDC-Message-Digest-Cipher">MDC (Message Digest Cipher)</a></p>&#13;
<p class="index1"><a href="#MDC-2-Modification-Detection-Code-2">MDC-2 (Modification Detection Code 2)</a></p>&#13;
<p class="index1"><a href="#Meet-in-the-middle">Meet-in-the-middle</a></p>&#13;
<p class="index1"><a href="#Merkle-puzzle">Merkle puzzle</a></p>&#13;
<p class="index1"><a href="#Merkle-tree">Merkle tree</a></p>&#13;
<p class="index1"><a href="#Merkle%E2%80%93Damg%C3%A5rd-construction">Merkle–Damgård construction</a></p>&#13;
<p class="index1"><a href="#Mersenne-twister">Mersenne twister</a></p>&#13;
<p class="index1"><a href="#Message-franking">Message franking</a></p>&#13;
<p class="index1"><a href="#Miller%E2%80%93Rabin">Miller–Rabin</a></p>&#13;
<p class="index1"><a href="#MINERVA">MINERVA</a></p>&#13;
<p class="index1"><a href="#Mining">Mining</a></p>&#13;
<p class="index1"><a href="#Misuse-resistance">Misuse resistance</a></p>&#13;
<p class="index1"><a href="#Mixnet">Mixnet</a></p>&#13;
<p class="index1"><a href="#MQV-Menezes%E2%80%93Qu%E2%80%93Vanstone">MQV (Menezes–Qu–Vanstone)</a></p>&#13;
<p class="index1"><a href="#Multicollision">Multicollision</a></p>&#13;
<p class="index1"><a href="#Multi-party-computation-MPC">Multi-party computation (MPC)</a></p>&#13;
<p class="index1"><a href="#Multivariate-cryptography">Multivariate cryptography</a></p>&#13;
<p class="index1"><a href="#NBS-National-Bureau-of-Standards">NBS (National Bureau of Standards)</a></p>&#13;
<p class="index1"><a href="#NESSIE-New-European-Schemes-for-Signatures,-Integrity,-and-Encryption">NESSIE (New European Schemes for Signatures, Integrity, and Encryption)</a></p>&#13;
<p class="index1"><a href="#New-Directions-in-Cryptography">“New Directions in Cryptography”</a></p>&#13;
<p class="index1"><a href="#NFSR-nonlinear-feedback-shift-register">NFSR (nonlinear feedback shift register)</a></p>&#13;
<p class="index1"><a href="#NIST-National-Institute-of-Standards-and-Technology">NIST (National Institute of Standards and Technology)</a></p>&#13;
<p class="index1"><a href="#NIZK-non-interactive-zero-knowledge">NIZK (non-interactive zero-knowledge)</a></p>&#13;
<p class="index1"><a href="#Noekeon">Noekeon</a></p>&#13;
<p class="index1"><a href="#Noise">Noise</a></p>&#13;
<p class="index1"><a href="#Nonce">Nonce</a></p>&#13;
<p class="index1"><a href="#Non-committing-encryption">Non-committing encryption</a></p>&#13;
<p class="index1"><a href="#Non-outsourceability">Non-outsourceability</a></p>&#13;
<p class="index1"><a href="#Non-slanderability">Non-slanderability</a></p>&#13;
<p class="index1"><a href="#NSA-National-Security-Agency">NSA (National Security Agency)</a></p>&#13;
<p class="index1"><a href="#NT-hash">NT hash</a></p>&#13;
<p class="index1"><a href="#NTRU-Nth-degree-Truncated-polynomial-Ring-Units">NTRU (<em>N</em>th degree Truncated polynomial Ring Units)</a></p>&#13;
<p class="index1"><a href="#Null-cipher">Null cipher</a></p>&#13;
<p class="index1"><a href="#OAEP-Optimal-Asymmetric-Encryption-Padding">OAEP (Optimal Asymmetric Encryption Padding)</a></p>&#13;
<p class="index1"><a href="#Oblivious-key-management-system-OKMS">Oblivious key management system (OKMS)</a></p>&#13;
<p class="index1"><a href="#Oblivious-PRF-OPRF">Oblivious PRF (OPRF)</a></p>&#13;
<p class="index1"><a href="#Oblivious-RAM-ORAM">Oblivious RAM (ORAM)</a></p>&#13;
<p class="index1"><a href="#Oblivious-transfer">Oblivious transfer</a></p>&#13;
<p class="index1"><a href="#Obscurity">Obscurity</a></p>&#13;
<p class="index1"><a href="#OCB-offset-codebook-mode">OCB (offset codebook mode)</a></p>&#13;
<p class="index1"><a href="#One-time-pad">One-time pad</a></p>&#13;
<p class="index1"><a href="#One-way-function">One-way function</a></p>&#13;
<p class="index1"><a href="#Onion-AE">Onion-AE</a></p>&#13;
<p class="index1"><a href="#OPAQUE">OPAQUE</a></p>&#13;
<p class="index1"><a href="#OpenSSL">OpenSSL</a></p>&#13;
<p class="index1"><a href="#Oracle">Oracle</a></p>&#13;
<p class="index1"><a href="#OTR-Off-the-Record">OTR (Off-the-Record)</a></p>&#13;
<p class="index1"><a href="#Padding-oracle-attack">Padding oracle attack</a></p>&#13;
<p class="index1"><a href="#Paillier-cryptosystem">Paillier cryptosystem</a></p>&#13;
<p class="index1"><a href="#Pairing"><span epub:type="pagebreak" title="143" id="Page_143"/>Pairing</a></p>&#13;
<p class="index1"><a href="#Pairing-based-cryptography">Pairing-based cryptography</a></p>&#13;
<p class="index1"><a href="#PAKE-password-authenticated-key-exchange">PAKE (password-authenticated key exchange)</a></p>&#13;
<p class="index1"><a href="#Paradigm">Paradigm</a></p>&#13;
<p class="index1"><a href="#Password-hash-function">Password hash function</a></p>&#13;
<p class="index1"><a href="#PBKDF2-Password-Based-Key-Derivation-Function-2">PBKDF2 (Password-Based Key Derivation Function 2)</a></p>&#13;
<p class="index1"><a href="#PCT-Private-Communications-Technology">PCT (Private Communications Technology)</a></p>&#13;
<p class="index1"><a href="#PEP-Plaintext-equivalence-proof">PEP (Plaintext equivalence proof)</a></p>&#13;
<p class="index1"><a href="#Perfect-forward-secrecy">Perfect forward secrecy</a></p>&#13;
<p class="index1"><a href="#Permutation-based-cryptography">Permutation-based cryptography</a></p>&#13;
<p class="index1"><a href="#PES-Proposed-Encryption-Standard">PES (Proposed Encryption Standard)</a></p>&#13;
<p class="index1"><a href="#PET-Plaintext-equivalence-test">PET (Plaintext equivalence test)</a></p>&#13;
<p class="index1"><a href="#PFS">PFS</a></p>&#13;
<p class="index1"><a href="#PGP-Pretty-Good-Privacy">PGP (Pretty Good Privacy)</a></p>&#13;
<p class="index1"><a href="#Photuris">Photuris</a></p>&#13;
<p class="index1"><a href="#Picnic">Picnic</a></p>&#13;
<p class="index1"><a href="#PKC">PKC</a></p>&#13;
<p class="index1"><a href="#PKCS-Public-Key-Cryptography-Standards">PKCS (Public Key Cryptography Standards)</a></p>&#13;
<p class="index1"><a href="#Poly1305">Poly1305</a></p>&#13;
<p class="index1"><a href="#Polynomial-complexity">Polynomial complexity</a></p>&#13;
<p class="index1"><a href="#Post-compromise-security">Post-compromise security</a></p>&#13;
<p class="index1"><a href="#Post-quantum-cryptography">Post-quantum cryptography</a></p>&#13;
<p class="index1"><a href="#Post-quantum-RSA">Post-quantum RSA</a></p>&#13;
<p class="index1"><a href="#Prediction-resistance">Prediction resistance</a></p>&#13;
<p class="index1"><a href="#Preimage">Preimage</a></p>&#13;
<p class="index1"><a href="#PRESENT">PRESENT</a></p>&#13;
<p class="index1"><a href="#PRIMES">PRIMES</a></p>&#13;
<p class="index1"><a href="#Privacy-preserving">Privacy-preserving</a></p>&#13;
<p class="index1"><a href="#Private-information-retrieval-PIR">Private information retrieval (PIR)</a></p>&#13;
<p class="index1"><a href="#Proof-of-burn">Proof of burn</a></p>&#13;
<p class="index1"><a href="#Proof-of-catalytic-space">Proof of catalytic space</a></p>&#13;
<p class="index1"><a href="#Proof-of-human-work">Proof of human work</a></p>&#13;
<p class="index1"><a href="#Proof-of-replication">Proof of replication</a></p>&#13;
<p class="index1"><a href="#Proof-of-reserve">Proof of reserve</a></p>&#13;
<p class="index1"><a href="#Proof-of-security">Proof of security</a></p>&#13;
<p class="index1"><a href="#Proof-of-sequential-work">Proof of sequential work</a></p>&#13;
<p class="index1"><a href="#Proof-of-space">Proof of space</a></p>&#13;
<p class="index1"><a href="#Proof-of-spacetime">Proof of spacetime</a></p>&#13;
<p class="index1"><a href="#Proof-of-stake">Proof of stake</a></p>&#13;
<p class="index1"><a href="#Proof-of-storage">Proof of storage</a></p>&#13;
<p class="index1"><a href="#Proof-of-useful-work">Proof of useful work</a></p>&#13;
<p class="index1"><a href="#Proof-of-work">Proof of work</a></p>&#13;
<p class="index1"><a href="#Provable-security">Provable security</a></p>&#13;
<p class="index1"><a href="#Provably-secure">Provably secure</a></p>&#13;
<p class="index1"><a href="#Proxy-re-encryption">Proxy re-encryption</a></p>&#13;
<p class="index1"><a href="#Pseudo-random">Pseudo-random</a></p>&#13;
<p class="index1"><a href="#Pseudorandom-function-PRF">Pseudorandom function (PRF)</a></p>&#13;
<p class="index1"><a href="#Pseudorandom-number-generator-PRNG">Pseudorandom number generator (PRNG)</a></p>&#13;
<p class="index1"><a href="#Pseudorandom-permutation-PRP">Pseudorandom permutation (PRP)</a></p>&#13;
<p class="index1"><a href="#Public-key-cryptography">Public-key cryptography</a></p>&#13;
<p class="index1"><a href="#PUF-physically-unclonable-function">PUF (physically unclonable function)</a></p>&#13;
<p class="index1"><a href="#Puncturable-encryption">Puncturable encryption</a></p>&#13;
<p class="index1"><a href="#Puncturable-pseudorandom-function-PPRF">Puncturable pseudorandom function (PPRF)</a></p>&#13;
<p class="index1"><a href="#Quantum-computer">Quantum computer</a></p>&#13;
<p class="index1"><a href="#Quantum-cryptography">Quantum cryptography</a></p>&#13;
<p class="index1"><a href="#Quantum-encryption">Quantum encryption</a></p>&#13;
<p class="index1"><a href="#Quantum-key-distribution">Quantum key distribution</a></p>&#13;
<p class="index1"><a href="#Quantum-signature">Quantum signature</a></p>&#13;
<p class="index1"><a href="#QUIC-Quick-UDP-Internet-Connections">QUIC (Quick UDP Internet Connections)</a></p>&#13;
<p class="index1"><a href="#Rabin-cryptosystem">Rabin cryptosystem</a></p>&#13;
<p class="index1"><a href="#Rainbow-tables">Rainbow tables</a></p>&#13;
<p class="index1"><a href="#Random-bits">Random bits</a></p>&#13;
<p class="index1"><a href="#Random-oracle">Random oracle</a></p>&#13;
<p class="index1"><a href="#Randomness">Randomness</a></p>&#13;
<p class="index1"><a href="#Range-proof">Range proof</a></p>&#13;
<p class="index1"><a href="#RC4">RC4</a></p>&#13;
<p class="index1"><a href="#RC5">RC5</a></p>&#13;
<p class="index1"><a href="#RC6">RC6</a></p>&#13;
<p class="index1"><a href="#Real-world">Real world</a></p>&#13;
<p class="index1"><a href="#Real-World-Crypto-RWC">Real World Crypto (RWC)</a></p>&#13;
<p class="index1"><a href="#Rectangle-attack">Rectangle attack</a></p>&#13;
<p class="index1"><a href="#Related-key-attack">Related-key attack</a></p>&#13;
<p class="index1"><a href="#Research-papers">Research papers</a></p>&#13;
<p class="index1"><a href="#Revocation">Revocation</a></p>&#13;
<p class="index1"><a href="#Rijndael">Rijndael</a></p>&#13;
<p class="index1"><a href="#Ring-signature">Ring signature</a></p>&#13;
<p class="index1"><a href="#RIPEMD-160">RIPEMD-160</a></p>&#13;
<p class="index1"><a href="#Rivest%E2%80%93Shamir%E2%80%93Adleman">Rivest–Shamir–Adleman</a></p>&#13;
<p class="index1"><a href="#ROBOT-Return-Of-Bleichenbacher%E2%80%99s-Oracle-Threat">ROBOT (Return Of Bleichenbacher’s Oracle Threat)</a></p>&#13;
<p class="index1"><a href="#ROS">ROS</a></p>&#13;
<p class="index1"><a href="#RSA">RSA</a></p>&#13;
<p class="index1"><a href="#Rubber-hose-cryptanalysis"><span epub:type="pagebreak" title="144" id="Page_144"/>Rubber-hose cryptanalysis</a></p>&#13;
<p class="index1"><a href="#Rumba20">Rumba20</a></p>&#13;
<p class="index1"><a href="#SAEP-Simplified-OAEP">SAEP (Simplified OAEP)</a></p>&#13;
<p class="index1"><a href="#Salsa20">Salsa20</a></p>&#13;
<p class="index1"><a href="#Sandwich-attack">Sandwich attack</a></p>&#13;
<p class="index1"><a href="#S-box">S-box</a></p>&#13;
<p class="index1"><a href="#Scalar">Scalar</a></p>&#13;
<p class="index1"><a href="#sci.crypt">sci.crypt</a></p>&#13;
<p class="index1"><a href="#Scrambler">Scrambler</a></p>&#13;
<p class="index1"><a href="#scrypt">scrypt</a></p>&#13;
<p class="index1"><a href="#Searchable-encryption">Searchable encryption</a></p>&#13;
<p class="index1"><a href="#secp256k1">secp256k1</a></p>&#13;
<p class="index1"><a href="#Secret-sharing">Secret sharing</a></p>&#13;
<p class="index1"><a href="#Security">Security</a></p>&#13;
<p class="index1"><a href="#Security-proof">Security proof</a></p>&#13;
<p class="index1"><a href="#Semantic-security">Semantic security</a></p>&#13;
<p class="index1"><a href="#Serious-Cryptography"><em>Serious Cryptography</em></a></p>&#13;
<p class="index1"><a href="#Serpent">Serpent</a></p>&#13;
<p class="index1"><a href="#SHA-0">SHA-0</a></p>&#13;
<p class="index1"><a href="#SHA-1">SHA-1</a></p>&#13;
<p class="index1"><a href="#SHA-2">SHA-2</a></p>&#13;
<p class="index1"><a href="#SHA-3">SHA-3</a></p>&#13;
<p class="index1"><a href="#SHA-3-competition">SHA-3 competition</a></p>&#13;
<p class="index1"><a href="#SHACAL">SHACAL</a></p>&#13;
<p class="index1"><a href="#Shamir%E2%80%99s-secret-database">Shamir’s secret database</a></p>&#13;
<p class="index1"><a href="#Shor%E2%80%99s-algorithm">Shor’s algorithm</a></p>&#13;
<p class="index1"><a href="#SHS-Secure-Hash-Standard">SHS (Secure Hash Standard)</a></p>&#13;
<p class="index1"><a href="#Side-channel">Side channel</a></p>&#13;
<p class="index1"><a href="#Side-channel-attack">Side-channel attack</a></p>&#13;
<p class="index1"><a href="#Sigaba">Sigaba</a></p>&#13;
<p class="index1"><a href="#Signal-protocol">Signal protocol</a></p>&#13;
<p class="index1"><a href="#Signature">Signature</a></p>&#13;
<p class="index1"><a href="#Signcryption">Signcryption</a></p>&#13;
<p class="index1"><a href="#SIKE-Supersingular-Isogeny-Key-Encapsulation">SIKE (Supersingular Isogeny Key Encapsulation)</a></p>&#13;
<p class="index1"><a href="#SIMECK">SIMECK</a></p>&#13;
<p class="index1"><a href="#SIMON">SIMON</a></p>&#13;
<p class="index1"><a href="#SipHash">SipHash</a></p>&#13;
<p class="index1"><a href="#SIV-AES">SIV-AES</a></p>&#13;
<p class="index1"><a href="#Skipjack">Skipjack</a></p>&#13;
<p class="index1"><a href="#Slide-attack">Slide attack</a></p>&#13;
<p class="index1"><a href="#SM">SM</a></p>&#13;
<p class="index1"><a href="#Smart-contract">Smart contract</a></p>&#13;
<p class="index1"><a href="#Snake-oil">Snake-oil</a></p>&#13;
<p class="index1"><a href="#SNARK-succinct-non-interactive-argument-of-knowledge">SNARK (succinct non-interactive argument of knowledge)</a></p>&#13;
<p class="index1"><a href="#SNIP-secret-shared-non-interactive-proof">SNIP (secret-shared non-interactive proof)</a></p>&#13;
<p class="index1"><a href="#SNOW-3G">SNOW 3G</a></p>&#13;
<p class="index1"><a href="#Solitaire">Solitaire</a></p>&#13;
<p class="index1"><a href="#SPECK">SPECK</a></p>&#13;
<p class="index1"><a href="#SPEKE-Simple-Password-Exponential-Key-Exchange">SPEKE (Simple Password Exponential Key Exchange)</a></p>&#13;
<p class="index1"><a href="#SPHINCS">SPHINCS</a></p>&#13;
<p class="index1"><a href="#Sponge-function">Sponge function</a></p>&#13;
<p class="index1"><a href="#SRP-Secure-Remote-Password">SRP (Secure Remote Password)</a></p>&#13;
<p class="index1"><a href="#SSH-Secure-Shell">SSH (Secure Shell)</a></p>&#13;
<p class="index1"><a href="#SSL-Secure-Socket-Layer">SSL (Secure Socket Layer)</a></p>&#13;
<p class="index1"><a href="#STARK-scalable-transparent-arguments-of-knowledge">STARK (scalable transparent arguments of knowledge)</a></p>&#13;
<p class="index1"><a href="#Steganography">Steganography</a></p>&#13;
<p class="index1"><a href="#Stream-cipher">Stream cipher</a></p>&#13;
<p class="index1"><a href="#Substitution-permutation-network-SPN">Substitution-permutation network (SPN)</a></p>&#13;
<p class="index1"><a href="#Suck">Suck</a></p>&#13;
<p class="index1"><a href="#Sugar-beet-auctions">Sugar beet auctions</a></p>&#13;
<p class="index1"><a href="#Suite-A">Suite A</a></p>&#13;
<p class="index1"><a href="#SUPERCOP">SUPERCOP</a></p>&#13;
<p class="index1"><a href="#Superpolynomial-complexity">Superpolynomial complexity</a></p>&#13;
<p class="index1"><a href="#SVP-shortest-vector-problem">SVP (shortest vector problem)</a></p>&#13;
<p class="index1"><a href="#Symmetric-key-cryptography">Symmetric-key cryptography</a></p>&#13;
<p class="index1"><a href="#TCC">TCC</a></p>&#13;
<p class="index1"><a href="#Test-vectors">Test vectors</a></p>&#13;
<p class="index1"><a href="#Threefish">Threefish</a></p>&#13;
<p class="index1"><a href="#Threshold-encryption">Threshold encryption</a></p>&#13;
<p class="index1"><a href="#Threshold-secret-sharing">Threshold secret-sharing</a></p>&#13;
<p class="index1"><a href="#Threshold-signature">Threshold signature</a></p>&#13;
<p class="index1"><a href="#Time-AI%E2%84%A2">Time AI</a></p>&#13;
<p class="index1"><a href="#Time-lock-encryption">Time-lock encryption</a></p>&#13;
<p class="index1"><a href="#Time-lock-puzzle">Time-lock puzzle</a></p>&#13;
<p class="index1"><a href="#Timing-attack">Timing attack</a></p>&#13;
<p class="index1"><a href="#TLS-Transport-Layer-Security">TLS (Transport Layer Security)</a></p>&#13;
<p class="index1"><a href="#Tor">Tor</a></p>&#13;
<p class="index1"><a href="#Traitor-tracing">Traitor tracing</a></p>&#13;
<p class="index1"><a href="#Transfinite-cryptography">Transfinite cryptography</a></p>&#13;
<p class="index1"><a href="#Trapdoor">Trapdoor</a></p>&#13;
<p class="index1"><a href="#Triple-DES">Triple DES</a></p>&#13;
<p class="index1"><a href="#Trivium">Trivium</a></p>&#13;
<p class="index1"><a href="#True-random-number-generator-TRNG">True random number generator (TRNG)</a></p>&#13;
<p class="index1"><a href="#Trusted-third-party">Trusted third party</a></p>&#13;
<p class="index1"><a href="#Tweakable-block-cipher">Tweakable block cipher</a></p>&#13;
<p class="index1"><a href="#Twitter"><span epub:type="pagebreak" title="145" id="Page_145"/>Twitter</a></p>&#13;
<p class="index1"><a href="#Twofish">Twofish</a></p>&#13;
<p class="index1"><a href="#Undeniable-signature">Undeniable signature</a></p>&#13;
<p class="index1"><a href="#Universal-composability">Universal composability</a></p>&#13;
<p class="index1"><a href="#Universal-hash-function">Universal hash function</a></p>&#13;
<p class="index1"><a href="#Updatable-encryption">Updatable encryption</a></p>&#13;
<p class="index1"><a href="#Verifiable-delay-function-VDF">Verifiable delay function (VDF)</a></p>&#13;
<p class="index1"><a href="#Verifiable-random-function-VRF">Verifiable random function (VRF)</a></p>&#13;
<p class="index1"><a href="#Verifiable-unpredictable-function-VUF">Verifiable unpredictable function (VUF)</a></p>&#13;
<p class="index1"><a href="#Vigenere-cipher">Vigenère cipher</a></p>&#13;
<p class="index1"><a href="#VSH-Very-Smooth-Hash">VSH (Very Smooth Hash)</a></p>&#13;
<p class="index1"><a href="#Wallet">Wallet</a></p>&#13;
<p class="index1"><a href="#Watermarking">Watermarking</a></p>&#13;
<p class="index1"><a href="#White-box-cryptography">White-box cryptography</a></p>&#13;
<p class="index1"><a href="#Winternitz-signature">Winternitz signature</a></p>&#13;
<p class="index1"><a href="#WireGuard">WireGuard</a></p>&#13;
<p class="index1"><a href="#X25519">X25519</a></p>&#13;
<p class="index1"><a href="#X3DH">X3DH</a></p>&#13;
<p class="index1"><a href="#XMSS-eXtended-Merkle-Signature-Scheme">XMSS (eXtended Merkle Signature Scheme)</a></p>&#13;
<p class="index1"><a href="#XOF-extendable-output-function">XOF (extendable output function)</a></p>&#13;
<p class="index1"><a href="#XOR">XOR</a></p>&#13;
<p class="index1"><a href="#XOR-encryption">XOR encryption</a></p>&#13;
<p class="index1"><a href="#Zerocash">Zerocash</a></p>&#13;
<p class="index1"><a href="#ZKP-zero-knowledge-proof">ZKP (zero-knowledge proof)</a></p>&#13;
<p class="index1"><a href="#ZRTP">ZRTP</a></p>&#13;
</section>&#13;
</div></body></html>