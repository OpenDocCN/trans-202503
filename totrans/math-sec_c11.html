<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 11: Distributing Security Resources to Guard a Space</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:1ff3c234-c763-4a12-a0c7-4ddf7c732e40" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_209" title="209"/>11</span><br/>
<span class="ChapterTitle">Distributing Security Resources to Guard a Space</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">The remainder of the book will focus on a single, extremely practical application. Known as the art gallery problem, this classic application has plenty of research for us to leverage and deals with efficiently distributing security resources to guard a space. Efficiency is an imperative for today’s security teams: there are always more assets to protect than there are resources to protect them. In its grandest form, the art gallery problem ties together the two main disciplines we’ve been studying: graph theory and computational geometry. It’s fitting, then, that this part of the book will also represent the most complete Python application yet, going beyond a conceptual design and into the realm of a full-fledged software project. We’ll cover the design, development, and delivery options for a modern Python project, including graphics, distributed computation, and licensing your application to users.</p>
<p><span epub:type="pagebreak" id="Page_210" title="210"/>The goal for this part of the book is to develop a <em>minimum viable product (MVP)</em>, which can be considered a step up from a proof of concept. As you’ve seen, a proof of concept proves that an idea is worth pursuing and defines the framework for future development. It’s usually constrained to only the functions necessary to get an idea off the ground—no bells or whistles included. An MVP design, on the other hand, is concerned with the smallest number of features you could produce to bring an idea to market and “be competitive.” Typically this means adding features like a GUI as well as user-friendly elements, such as save and restore functions. </p>
<p>There’s no exact set of features that make an application viable, because they’re ultimately dictated by the expectations of the users in that particular market. For example, in the security market, users have come to expect features like single sign-on (SSO), data encryption, push notifications, and so on. Does this mean you need to develop all of these features before you can bring a security tool to the market? Absolutely not! Think minimally and ask yourself, “What features do all the applications similar to mine share?” When you’re developing a product for users, it’s tempting to try to anticipate all their needs up front, but this mentality is impractical and expensive: you’ll often end up solving problems that no one would have encountered (edge-case code) or developing features that only confuse new users. If you instead release a product that contains a minimal set of clearly labeled features, you can get feedback on the actual problems users see and conveniences they’re missing. Iterative improvement plans allow you to focus development time on features that will actually be useful. </p>
<p>Now let’s jump into the art gallery problem, which asks, “What is the minimum number of guards that need to be placed in a gallery (represented by an <em>n</em>-vertex simple polygon) such that all points of the interior are visible?” This is a resource planning problem similar to the fire station placement problem from <span class="xref" itemid="xref_target_Chapter 9"><a href="c09.xhtml">Chapter 9</a></span>. A good plan for the placement of security personnel, checkpoints, and monitoring devices can reduce the number of incidents a security team will need to respond to from the start. It can also improve the response time when an incident does occur, thus reducing the overall risk. Unfortunately, there are often differing levels of understanding among human planners on a security team, which can lead to poorly planned (or poorly implemented) security controls. That’s why I’m always searching for ways to automate portions of my team’s planning. </p>
<p>It was during one of these searches that I discovered the art gallery problem, which addressed the very problem I was researching: the efficient deployment of security resources for buildings with what we’ll call “untraditional” layouts. As you’ll see, not all building designs lend themselves equally well to being guarded, so before we get into the details of the problem, we’ll cover the use cases for the application we plan to develop. Then we’ll be ready to start developing the core of the application logic. We’ll cover the existing research and show the theory in its simplest form. We’ll then move on to defining the two data representations we’re going to use in solving the problem and discuss the data structures. Finally, we’ll go beyond the base model to allow for more realistic deployments by adding advanced concepts like field of view and budget constraints.</p>
<h2 id="h1-502567c11-0001"><span epub:type="pagebreak" id="Page_211" title="211"/>Determining the Minimum Number of Guards</h2>
<p class="BodyFirst">We’ll use the original problem statement as our first use case: a user wants to know the minimum number of guards to protect an unconventional floor plan. We want all the guards together to be able to observe the whole gallery (all points of the interior, or the walls, in the original problem statement). For this use case, our application will need functions that can encode floor plans in a data format the computer can analyze as well as an algorithm that can do the actual guard placement. We’ll go through that in the rest of this chapter, once we’ve covered a few more use cases. </p>
<p>The next use case deals with informing the architectural design of secure facilities and can be summarized like so: a user wants to analyze the security coverage and layout of a building. Prior to building a secure facility, the CAD drafts of a few potential floor plans are run through a <em>building information modeling (BIM)</em> program. The hypothetical building designs are rated on the difficulty to secure, access to emergency exits, accessibility features (like ramps and elevators), and more. For this use case, the application will need to define the effective coverage for different types of security equipment, including human guards’ cameras and other electronic sensors. </p>
<p>Of course, this analysis can also inform an attacker of flaws in a security layout. Every heist movie has a scene where the protagonists lay out the blueprint for their target and start to mark where the impossibly large number of security controls are, until they spot a flaw. Sensor blind spots are a favorite trope for these films, but the truth is that blind spots are a real-world consideration. By observing the guards and sensors in use, you can make a fairly accurate coverage map. Finding blind spots is often a simple matter of searching for the model’s technical specifications document. Information such as field of view, often given in degrees, as well as effective range, given in feet or meters, tells you not only where the device can detect but also where it can’t! To support this use case, the application we’re developing will create a visual layout of how the gallery is divided among the security resources. A user will be able to inspect the layout to see any gaps in the coverage. We’ll also develop a solver that will suggest additional vertices where guards can be placed to achieve customizable coverage goals, and we’ll add the concepts of distance, field of view, and effective range so we can differentiate between a guard, camera, motion sensor, and so forth.</p>
<p>Many buildings, particularly galleries and museums, are multistory buildings, so we can assume a professional using our software would want it to work on all the floor plans. Because the project needs to contain multiple assets, such as the shape data and the floor plan itself, it’s also safe to assume a user will want a way to back up their work or resume working across multiple sessions. We’ll wrap these all together in the final use case: a user wants to plan security for multiple floors of the same building across multiple work sessions. The program we develop will do this by creating a set of custom objects that can be serialized, encoded, and stored in a compressed file between sessions. We’re going to treat each floor of a multilevel building as separate 2D floor plans that can be grouped into a <span epub:type="pagebreak" id="Page_212" title="212"/>single multifloor project. Each floor will contain an image representing the background used to trace the gallery shape as well as all of the geometric information added by the user.</p>
<p>Studying blueprints and CAD designs of buildings is an excellent habit to form, especially for physical penetration testers. Simply by knowing the layout of a facility and walking confidently, I’ve passed myself off as belonging in a building. After all, who would know that “utility closet #2” is on the basement level, west end, if not someone who had been there before? Pair that knowledge of the layout with a clipboard, toolbox, or other official-looking props, and it’s often just as good as a building pass.</p>
<p>Now that we have our use cases, we can start diving into the nuts and bolts. Let’s start by reviewing the original problem and some research performed in the past. We’ll then cover the solution steps in depth and discuss additional constraints you can add to customize the results to specific needs.</p>
<h2 id="h1-502567c11-0002">Art Gallery Problem Theory</h2>
<p class="BodyFirst">The first well-known theorem on the art gallery problem was written in 1973 by computer scientist and professor Václav Chvátal. This question was posed to him by a former University of Washington mathematics professor, Victor Klee:</p>
<blockquote class="blockquote">
<p class="Blockquote">Given the floor plan of a weirdly shaped art gallery having <em>n</em> straight sides, how many guards will we need to post, in the worst case, so that every bit of wall is visible to a guard?</p>
</blockquote>
<p>The <em>Chvátal AGP theorem</em> gives an upper bound that states, “At most <em>n</em> / 3 guards is always sufficient, and sometimes required, to cover a polygon with <em>n</em> vertices.”<sup class="endnote"><a href="b01.xhtml#c11-endnote-001" id="c11-noteref-001">1</a></sup> Chvátal assumed in his proof that guards would be placed on the vertices, but <em>Chvátal’s upper bound</em> remains true even if the restriction of guards at corners is loosened to “guards anywhere within the interior of the polygon.” The 3 constant comes from decomposing the shape of the gallery into triangles, based on the reasoning that you would only ever need one guard per triangular section. </p>
<p>Chvátal’s work was later simplified by mathematics professor Steve Fisk, who reduced the problem to a three-color problem, defining it as follows: “Under what conditions can the regions of a planar map be colored in three colors so that no two regions with a common boundary have the same color?” The three-color problem can be represented easily as a graph, where each vertex of the gallery’s shape constitutes a node and each edge marks a shared wall segment between two vertices. You can then treat the problem as a <em>vertex-coloring problem</em>, where two nodes of the same color can’t be directly connected by an edge. The graph version of the coloring problem is a popular method to analyze connectivity, so NetworkX includes a function to solve it for us, known as <em>greedy coloring</em>, that we’ll leverage in our solution. <a href="#figure11-1" id="figureanchor11-1">Figure 11-1</a> shows the simplest case of the greedy coloring algorithm.</p>
<span epub:type="pagebreak" id="Page_213" title="213"/><figure>
<img alt="" class="" src="image_fi/502567c11/f11001.png"/>
<figcaption><p><a id="figure11-1">Figure 11-1</a>: Solving the simplest art gallery problem</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-1">Figure 11-1</a> is in the 4th cell of the <em>AGP_basics.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The leftmost image in <a href="#figure11-1">Figure 11-1</a> shows a triangle polygon. The upper bound of <em>n</em> / 3 = 3 / 3 = 1 means we should need only one guard to observe the entire interior. The middle image shows the result of converting the triangle into a graph representation. Finally, the rightmost image shows the result of the greedy coloring algorithm. As expected, each node gets colored a different color, meaning placing one guard at any one of those points would enable them to observe all the walls. This is the core of the process. To expand the algorithm, we just need to solve a series of interconnected triangles, as you’ll see in the next section on the geometric and graph representations.</p>
<p>In a 2008 thesis paper, Mikael Pålsson and Joachim Ståhl examine the three-color algorithm and propose a set of alternate “rectangular” algorithms (ones that operate on orthogonal polygons only) specifically designed with camera placement in mind.<sup class="endnote"><a href="b01.xhtml#c11-endnote-002" id="c11-noteref-002">2</a></sup> Pålsson and Ståhl were able to address several practical pitfalls of Chvátal’s theorem. First, by restricting themselves to orthogonal polygons, they reduce the upper bound to <em>n</em> / 4. Second, their camera placement version of the problem addresses concerns like limited field of view, effective range, and obstacles, which apply equally well to human guards as well as cameras. These additional goals make the placement selection more realistic than the standard formulation. We’ll discuss field of view and effective range more in a bit. We’ll also add the ability to weight areas to prioritize the required coverage. Other constraints, such as making sure that each camera is visible to another camera (common in high-security areas), won’t be covered but are definitely worth your time to research. </p>
<p>Because it uses orthogonal polygons, Pålsson and Ståhl’s approach is less practical for general use in planning security layouts. Anywhere there’s a diagonal or curved wall will require multiple small rectangles to approximate the shape. One of my favorite examples of unconventional <span epub:type="pagebreak" id="Page_214" title="214"/>architecture is the Guggenheim Museum in New York, shown in <a href="#figure11-2" id="figureanchor11-2">Figure 11-2</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502567c11/f11002.png"/>
<figcaption><p><a id="figure11-2">Figure 11-2</a>: The Guggenheim, designed by Frank Lloyd Wright (© 2023 Frank Lloyd Wright Foundation. All Rights Reserved. Licensed by Artists Rights Society.)</p></figcaption>
</figure>
<p>On the left you can see a top-down view of the lower level, the lecture auditorium. The grid laid over the floor plan represents 8 square feet. As you can see, near the rounded walls and near the diagonal walls, the squares are cut off in places. These are the areas where a purely orthogonal approach would struggle. On the right you can see a cross section of the museum showing the circular structure that continues throughout the majority of the building. It makes for beautiful architecture, but it also makes the museum difficult to map with orthogonal polygons.</p>
<p>To counter the shortcomings of the orthogonal approach, we’re going to allow users to draw one or more complex polygons directly on top of an image of the building’s floor plan. We’ll treat each individual polygon as a distinct area that needs to be guarded, similar to the original problem definition. Each polygon will be subdivided using a modified triangular tessellation called a constrained Delaunay triangulation. We’ll then convert the tessellated geometry into an unweighted graph, which we can solve using the greedy coloring algorithm from NetworkX. This process allows users to input unconventional floor plans like that of the Guggenheim and solve them for a wide variety of potential scenarios, while still respecting the real-world limitations of the resources involved.</p>
<h2 id="h1-502567c11-0003">Geometric and Graph Representations of the Gallery</h2>
<p class="BodyFirst">Now let’s consider how we’d represent the gallery space as a <code>Polygon</code> object, just as we represented the park in <span class="xref" itemid="xref_target_Chapter 7"><a href="c07.xhtml">Chapter 7</a></span>. <a href="#figure11-3" id="figureanchor11-3">Figure 11-3</a> shows the example gallery.</p>
<span epub:type="pagebreak" id="Page_215" title="215"/><figure>
<img alt="" class="" src="image_fi/502567c11/f11003.png"/>
<figcaption><p><a id="figure11-3">Figure 11-3</a>: Representing the gallery with a polygon and graph</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-3">Figure 11-3</a> is in the 7th cell of the <em>AGP_basics.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>On the left you see the polygon; the gray area represents the interior of the gallery. On the right you see the translation of the shape into a simple NetworkX graph. There are a number of ways you could convert the information in a <code>Polygon</code> into a graph, but often the simplest option is to iterate over the vertices of the <code>Polygon</code>’s exterior, as in <a href="#listing11-1" id="listinganchor11-1">Listing 11-1</a>.</p>
<pre><code>from shapely.geometry import Polygon, Point
import networkx as nx
import triangle as tr
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> gallery_poly = Polygon([
    (0, 0), (0, 2), (0.55, 1.55), (1.4, 0.33),
    (1, 0.33), (0.45, 1.22), (0.25, 1.29)
    ])
gallery_coords = gallery_poly.exterior.coords[:-1]
G = nx.Graph()
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> G.add_node( 0, coords=gallery_coords[0])
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> pos = [list(gallery_coords[0])]
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> for i in range(1, len(gallery_coords)):
    p = gallery_coords[i] 
    pos.append(p)
  <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> G.add_edge(i-1, i)
  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> G.nodes[i]["coords"] = p
    if i == len(gallery_coords)-1:
      <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> G.add_edge(i, 0)</code></pre>
<p class="CodeListingCaption"><a id="listing11-1">Listing 11-1</a>: Creating the gallery representations</p>
<p>In <a href="#listing11-1">Listing 11-1</a>, we first define the gallery <code>Polygon</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span> by passing in the list of vertices as before. Then we add the first node, which represents the vertices at index 0 in the coordinates list <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Each node in the graph is keyed by its index in the vertex list to help keep the two representations logically tied together. The first point serves as an anchor for the shape and makes it easier to create the edges—we’ll do this momentarily. Before we do so, <span epub:type="pagebreak" id="Page_216" title="216"/>however, we have to add the coordinates to a position list called <code>pos</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span>, which will make it easier to display the graph so that it matches the shape of the polygon. Next, we loop over the remaining vertices <span aria-label="annotation4" class="CodeAnnotation">❹</span> to finish filling in the graph. For each remaining vertex, we add an edge between the previously defined node at <code>i-1</code> and the current node at <code>i</code> <span aria-label="annotation5" class="CodeAnnotation">❺</span>. Adding the edge creates the node <em>V</em><sub>(</sub><sub><em>i</em></sub><sub>)</sub> and adds the edge <em>E</em><sub>(</sub><sub><em>i</em></sub><sub> – 1,</sub><sub><em>i</em></sub><sub>)</sub> in one line. Storing the coordinate information for the vertex as node metadata can serve as a more flexible alternative to the <code>pos</code> list. We’ll do so by passing the coordinates in the <code>coords</code> parameter <span aria-label="annotation6" class="CodeAnnotation">❻</span>. Finally, if <code>i</code> is equal to the last index, it’s time to create the final closing edge between the last node defined and the anchor node at index 0 <span aria-label="annotation7" class="CodeAnnotation">❼</span>.</p>
<p>Now that we have a way to generate the two representations of the gallery, let’s go over the process of solving the art gallery problem in detail.</p>
<h2 id="h1-502567c11-0004">Securing the Gallery</h2>
<p class="BodyFirst">We’ve already covered the start of the art gallery problem (AGP) algorithm, which creates the two base data structures we’ll be working with. The next step in the process is to tessellate the geometric shape into triangles and add the resulting edges to the graph representations. Remember, any changes that you make to one representation need to be done to the other as well, to maintain their logical equivalence. Rather than using the Shapely <code>triangulate</code> function as we did in <span class="xref" itemid="xref_target_Chapter 7"><a href="c07.xhtml">Chapter 7</a></span>, we’re going to use a purpose-built wrapper library called Triangle. The underlying application is a C-based program, also called Triangle, which was created by Professor Jonathan Shewchuk.<sup class="endnote"><a href="b01.xhtml#c11-endnote-003" id="c11-noteref-003">3</a></sup> There are several reasons for choosing Triangle over Shapely. First, the Shapely version performs what’s known as a Delaunay triangulation, which in its pure form doesn’t respect edges; on the other hand, the Triangle library performs a <em>constrained </em>Delaunay triangulation, which can respect boundaries. <a href="#listing11-2" id="listinganchor11-2">Listing 11-2</a> shows the code to tessellate the gallery polygon.</p>
<pre><code>tri_dict = {
    "vertices": gallery_poly.exterior.coords[:-1],
    "segments": list(G.edges())
}
triangulated = triangulate(tri_dict, "pe")</code></pre>
<p class="CodeListingCaption"><a id="listing11-2">Listing 11-2</a>: Performing the triangular tessellation with the Triangle library</p>
<p>The <code>triangulate</code> function expects a dictionary with two required keys. The <code>vertices</code> key holds the coordinates for the exterior of the shape. The <code>segments</code> key holds the edges that should be enforced while performing the tessellation. We pass the dictionary as the first argument to the <code>triangulate</code> function. The second optional argument is a string containing the settings to pass to the underlying application. There are a large number of configuration flags, and you can pass multiple arguments in the string. The <code>p</code> flag tells the library to treat the shape as a <em>planar straight-line graph</em>. The <code>e</code> flag tells the library to return the edge list as part of the result. Having the list <span epub:type="pagebreak" id="Page_217" title="217"/>included saves us a step when updating the graph representation, as we can simply compare the edges in the result to the edges in the graph and add any that are missing. </p>
<p>The <code>triangulate</code> function returns a dictionary. It includes a list called <code>vertices</code> that sets the ID for each vertex based on its position in this list. We’ll need this when decoding the rest of the outputs. The other two keys we’re interested in at the moment are the <code>triangles</code> key, which contains a list of triplets representing the three points making up each triangle, and the <code>edges</code> key, which contains a list of all the edges resulting from the triangulation. Both the <code>triangles</code> and <code>edges</code> use the node ID to denote vertices, so an entry in the triangle table like <code>[6, 1, 0]</code> means the sixth, first, and zeroth vertices form a triangle. If you look at the graph representation on the right side of <a href="#figure11-3">Figure 11-3</a> again, you’ll see that adding an edge from node 6 to node 1 (<em>E</em><sub>(6,1)</sub>) does indeed form a triangle with node 0. The <code>edges</code> list contains all of the original edges plus all the additional edges needed to form the triangles (like the edge <em>E</em><sub>(6,1)</sub> just mentioned). You can use either the <code>edges</code> list or the <code>triangles</code> list to update the graph representation. The Jupyter notebook has an example of using the <code>triangles</code> list, but I chose the <code>edges</code> list for the code in <a href="#listing11-3" id="listinganchor11-3">Listing 11-3</a> because it’s more succinct.</p>
<pre><code>G2 = G.copy()
for e in triangulated["edges"]:
    if list(e) not in list(G2.edges()):
        G2.add_edge(e[0], e[1])</code></pre>
<p class="CodeListingCaption"><a id="listing11-3">Listing 11-3</a>: Updating the gallery representations</p>
<p>First, we create a copy of the original graph <em>G</em> to work on. We loop over the <code>edges</code> list in the triangulated result. For each edge, we check if it’s already in the edge list for <em>G</em><sub>2</sub>. If it’s not, we add it. The result is a triangulated representation of the gallery in both a geometric and graph representation, as in <a href="#figure11-4" id="figureanchor11-4">Figure 11-4</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502567c11/f11004.png"/>
<figcaption><p><a id="figure11-4">Figure 11-4</a>: The result of triangulating the example gallery</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-4">Figure 11-4</a> is in the 9th cell of the <em>AGP_basics.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" id="Page_218" title="218"/>You can see that the division line segments added to the graph on the left-hand plot match the new edges added to the graph on the right-hand plot. The set of vertices and segments resulting from the tessellations is technically referred to as a <em>mesh</em>. </p>
<p>We’re now ready to color the graph using the <code>greedy_color</code> function, which you’ll need to import from the <code>networkx.algorithms.coloring</code> library like so:</p>
<pre><code>from networkx.algorithms.coloring import greedy_color
gallery_coloring = greedy_color(G2)</code></pre>
<p>The response from the function is a dictionary keyed off the node identifier. The value represents a numeric index for the color group the node belongs to. <a href="#figure11-5" id="figureanchor11-5">Figure 11-5</a> shows the solution for the example gallery.</p>
<figure>
<img alt="" class="" src="image_fi/502567c11/f11005.png"/>
<figcaption><p><a id="figure11-5">Figure 11-5</a>: Result of greedy coloring the example gallery</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-5">Figure 11-5</a> is in the 12th cell of the <em>AGP_basics.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>On the left you can see the solution found by the coloring algorithm. For the right side of the plot, I’ve removed the triangulation edges because we no longer need them once the coloring is done. I’ve also represented the color groups using different shapes—squares, diamonds, and circles—to make them easier to distinguish. You can think of each group as a potential deployment plan for guards. As you can see, not all deployments have the same number of guard positions, though. The circle group has three nodes in it while the others only have two; this means positioning guards at the locations marked by the circle nodes would require you to deploy an additional guard to cover all the walls. </p>
<p>You can compare the deployments that are tied for the lowest number of nodes to see what practical advantages and disadvantages each offers. For example, the square and diamond groups both require only two guards, but the diamond deployment places the guards closer to each other than the square deployment. While this may seem like small difference, in the real world having two guards in closer proximity allows them to support each other more efficiently; therefore, assuming these deployments were my only options, I would choose the diamond deployment.</p>
<p><span epub:type="pagebreak" id="Page_219" title="219"/>Now that you’ve seen the basic solution concept applied to the example gallery, it’s time to start refining the process and making the solution more practical for real-world use. The rest of this chapter focuses on refining the theoretical approach you’ve just seen to address some of the practical concerns mentioned earlier. </p>
<h3 id="h2-502567c11-0001">Mapping Guard Coverage</h3>
<p class="BodyFirst">So far, we’ve ignored the scale of the gallery. The original problem assumes guards have perfect, infinite vision that isn’t affected by lighting, distance, or crowds. But in a real-world scenario, the deployment needs to account for these factors with some type of maximum coverage threshold per guard location. If we say the scale for the example gallery is 1:300 m (meaning one unit on the graph is equal to 300 meters), the length of the edge <em>E</em><sub>(0,1)</sub> is 600 m <em>E</em><sub>(0,1)</sub> = 2 × 300 m = 600 m (this is about 1,968.5 feet). The area of the gallery, then, is about 241 m<sup>2</sup> (2,594 square feet). </p>
<p>Using only two guards for a floor plan of that size is likely to leave gaps in the coverage. Add in the other environmental factors that affect visibility,<sup class="endnote"><a href="b01.xhtml#c11-endnote-004" id="c11-noteref-004">4</a></sup> such as elevation (created by a slope in the floors) and lighting (often dimmed in portions of a gallery for dramatic effect), and it’s clear two guards would be woefully inadequate to secure the gallery. Therefore, we need to improve on the simplifications made in the theoretical model. We’ll do so by acknowledging that guards are really only able to guard so much area at a time. This is my second major reason for choosing the Triangle library: it supports the idea of a <em>maximum area threshold</em>, whereas the Shapely version of the function doesn’t. The maximum area threshold sets the largest area of any triangle created during the tessellation. </p>
<p>If you consider each triangle as a zone that needs to be guarded, you can assign them to guard positions to create an area of responsibility (AOR) map that shows which positions are responsible for which zones as well as the overall coverage distribution (we saw an AOR map in <span class="xref" itemid="xref_target_Chapter 9"><a href="c09.xhtml">Chapter 9</a></span> with the fire station example). The smaller the area for each zone triangle, the closer together the triangles will be clustered, and therefore more triangles will be needed to tessellate the whole gallery. More triangles mean more points in the tessellation, which translates to more guard positions. It also means more color (or shape) groups are needed to represent them.</p>
<p>To simplify the math, let’s say each zone triangle should be a maximum area of 30 m<sup>2</sup> (close to 323 square feet), which scales down to an area of 0.1 unit per triangle. We can tell Triangle to tessellate the gallery into triangles with a maximum area of 30 m<sup>2</sup> by adding the <code>a</code> flag to the arguments string followed by the scaled maximum area 0.1:</p>
<pre><code>triangulated = tr.triangulate(tri_dict, "pe<b>a0.1</b>")</code></pre>
<p>To do the tessellation, the <code>triangulate</code> function will add the points necessary (often called <em>Steiner points</em>) for the geometry to split triangles larger than the maximum area until they’re all below the threshold. <a href="#figure11-6" id="figureanchor11-6">Figure 11-6</a> shows the result of the tessellation. </p>
<span epub:type="pagebreak" id="Page_220" title="220"/><figure>
<img alt="" class="" src="image_fi/502567c11/f11006.png"/>
<figcaption><p><a id="figure11-6">Figure 11-6</a>: Maximum zone area 30 m<sup>2</sup> solutions</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-6">Figure 11-6</a> is in the 16th cell of the <em>AGP_basics.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>On the left you can see the graph representation of the mesh. On the right you can see the different potential guard deployments. Since each node is a member of multiple triangles, the guard at that position will be responsible for all the triangular slices the node is a member of. Additionally, if there are any triangles that aren’t directly connected to one of the guard positions (as is the case with triangle <code>[3, 4, 10]</code> in the lower right of the gallery), we assign that triangle to the closest guard position to generate the AOR map. Solving the graph coloring required the algorithm to add a fourth group, represented by the star nodes. Remember, you can think of the additional groups as more potential deployment options and the additional points within a deployment as more guards being added to that deployment. In this example, the circle deployment and the star deployments both have three positions to cover, while the square and diamond deployments both require four. By the same logic as before, I’d pick the circle deployment because it places the guard positions closer together, whereas the star deployment leaves one position relatively isolated. <a href="#figure11-7" id="figureanchor11-7">Figure 11-7</a> shows the AOR map generated from the circle deployment.</p>
<figure>
<img alt="" class="" src="image_fi/502567c11/f11007.png"/>
<figcaption><p><a id="figure11-7">Figure 11-7</a>: Creating an AOR map from a selected deployment</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_221" title="221"/><h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-7">Figure 11-7</a> is in the 19th cell of the <em>AGP_basics.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The left side of the figure shows the default assignment of triangles to guards. The black triangle is the uncovered triangle mentioned previously. On the right side of the figure, you can see the result of assigning the triangle to be covered by the closest guard position. This does create a slight imbalance in the deployment. The light gray AOR contains five triangles (and therefore more square footage), while the other two AORs have only four. </p>
<p><a href="#listing11-4" id="listinganchor11-4">Listing 11-4</a> shows the function for assigning triangles to guards based on the deployment group:</p>
<pre><code>def assign_triangles(g, triangulated, group_id):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> guard_nodes = [n for n in g.nodes() if g.nodes[n]["group"] == group_id]
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> triangles = {k:[] for k in guard_nodes}
    for i in range(len(triangulated["triangles"])):
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> t = triangulated["triangles"][i]
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> t_poly = Polygon([g.nodes[p]["coords"] for p in t])

        # If triangle touches a guard directly at any point:
      <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> if t[0] in guard_nodes:
            triangles[t[0]].append(t_poly)
        elif t[1] in guard_nodes:
            triangles[t[1]].append(t_poly)
        elif t[2] in guard_nodes:
            triangles[t[2]].append(t_poly)
        else:
          <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> dists = {
                k: t_poly.distance(
                     Point(g.nodes[k]["coords"])
                   ) for k in guard_nodes}
          <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> close = min(dists, key=dists.get)
          <span aria-label="annotation8" class="CodeAnnotationCode">❽</span> triangles[close].append(t_poly)
  <span aria-label="annotation9" class="CodeAnnotationCode">❾</span> return triangles</code></pre>
<p class="CodeListingCaption"><a id="listing11-4">Listing 11-4</a>: Assigning triangles to guard nodes</p>
<p>The <code>assign_triangles</code> function takes in a copy of the triangulated graph, <code>g</code>; the result of the <code>triangulate</code> function, <code>triangulated</code>; and finally, the ID for the deployment of interest, <code>group_id</code>. We begin by collecting the nodes that represent the guard positions into a list called <code>guard_nodes</code> based on the provided group ID <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We then create a dictionary to hold the output of the function until the <code>return</code> statement. The keys will be the node identifiers and the values will be an empty list that will eventually contain all triangles (as <code>Polygon</code> objects) that are assigned to that node <span aria-label="annotation2" class="CodeAnnotation">❷</span>. </p>
<p>To begin filling the <code>triangles</code> lists, we loop over all the triangles in <code>triangulated</code>. Each of these triangles represents the collection of graph nodes that form the triangle <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We turn the nodes into a <code>Polygon</code> by looking up the coordinates for the triangle using the provided graph <code>g</code> <span aria-label="annotation4" class="CodeAnnotation">❹</span>. The next step is to check if the triangle nodes already contain one of the guard positions. If they do, then one of the three points will be in the <code>guard_nodes</code> <span epub:type="pagebreak" id="Page_222" title="222"/>list <span aria-label="annotation5" class="CodeAnnotation">❺</span>. If the triangle isn’t directly connected to a guard, we determine which guard it’s closest to. </p>
<p>Next, we create a dictionary called <code>dists</code> that is keyed off of the guard node’s ID. The value for each key will be the result of the Shapely function <code>t_poly.distance</code>, which measures the minimum distance between the triangle polygon and a <code>Point</code> object representing the guard station <span aria-label="annotation6" class="CodeAnnotation">❻</span>. We then find the minimum entry in the <code>dists</code> dictionary using the <code>min</code> function. Passing in the dictionary key list in the <code>key</code> parameter tells the function to return the key that has the lowest value instead of the value itself <span aria-label="annotation7" class="CodeAnnotation">❼</span>. We use this key to assign the polygon to the proper list in <code>triangles</code> <span aria-label="annotation8" class="CodeAnnotation">❽</span>. Finally, we return the <code>triangles</code> dictionary to conclude the function <span aria-label="annotation9" class="CodeAnnotation">❾</span>. </p>
<p>We can determine the exact area of each AOR by summing the area of all the triangles associated with it, as in <a href="#listing11-5" id="listinganchor11-5">Listing 11-5</a>.</p>
<pre><code>for k in triangles.keys():
    area = sum([(t.area * 300) for t in triangles[k]])
    print("Position %d covers %.2fm2" % (k, area))</code></pre>
<p class="CodeListingCaption"><a id="listing11-5">Listing 11-5</a>: Summing AOR areas</p>
<p>For each key in the resulting <code>triangles</code> dictionary, we do a <code>sum</code> operation on the list of triangle areas associated with it. Notice we adjust the scale by multiplying each area by the scaling factor (in this case <code>300</code>). The result of the code for the example should be:</p>
<pre><code>Position 2 covers 60.41m2
Position 11 covers 98.68m2
Position 12 covers 82.34m2</code></pre>
<p>One important note about the triangle assignment function: it’s really only a heuristic. Depending on the shape of the gallery and the location of the different edges and vertices, it’s possible to assign a triangle to a guard that is “closer” (as measured by minimum straight-line distance, or as the crow flies) to one guard position but logically should be assigned to another guard. You can improve the function by taking into account whether the straight-line distance measured by Shapely intersects the body of the gallery; if it does, this indicates that the measurement traveled through walls and is therefore shorter than it would be in reality (unless your guards can phase through solid objects like concrete walls). You could then change the function so that it assigns the triangles to the guard position with the shortest distance that doesn’t intersect with any walls. </p>
<p>Another option is to change the deployment to add another guard position that covers the uncovered triangle. Looking closely at the graph representation on the right side of <a href="#figure11-6">Figure 11-6</a>, you can see the star at node position 3 also could have been a circle. Sometimes there will be multiple possible solutions, and the coloring algorithm has to settle on the one it feels is optimal (which means it attempts to evenly distribute color groups as much as possible). Rather than just assigning the uncovered triangle to a guard position, you might opt to change the star node to another circle node; this maintains the validity of the solution but leaves every triangle <span epub:type="pagebreak" id="Page_223" title="223"/>covered by the deployment. On the other hand, it also means adding another guard to the deployment, making it less optimal in that sense. A future improvement for your application may involve letting users select the assignment strategy during the AOR map creation based on their specific use.</p>
<h3 id="h2-502567c11-0002">Defining Obstructed Areas</h3>
<p class="BodyFirst">Now that we’ve covered the algorithm, how it deals with scaling, and basic AOR coverage maps, it’s time to deal with complex polygons. As you might recall from <span class="xref" itemid="xref_target_Chapter 7"><a href="c07.xhtml">Chapter 7</a></span>, these are polygons that have holes representing areas of the floor plan that can’t be accessed or that obstruct visibility (a giant column of granite, for example). </p>
<p>Luckily, dealing with holes inside the Triangle library is fairly easy. For each hole we want to define, we pass the <code>triangulate</code> function a point inside the hole (any point will do). The algorithm then removes triangles until it hits a vertex defined in the <code>segments</code> portion of the dictionary. Be aware that it’s possible to accidentally remove all the triangles if you improperly enclose the hole in segments. If this happens, you won’t receive anything back in the <code>triangles</code> key, so you might want to update your implementation to handle this condition with some form of validity check. </p>
<p>To get the point for a hole, you can use the Shapely <code>representative_point</code> function, which returns a <code>Point</code> object guaranteed to be inside the boundaries of the shape the function was called on. The great thing about using the representative point is that, because Shapely doesn’t care whether the point is centered in the shape, it can compute it quickly. As long as the point falls within the given shape it is considered representative, which works great for Triangle since it needs to know only where to begin removing triangles from. </p>
<p><a href="#listing11-6" id="listinganchor11-6">Listing 11-6</a> shows the code to create the tessellation for the complex polygon.</p>
<pre><code>ext_3 = [(0.0, 0.0), (0.0, 3.0), (3.0, 3.0), (3.0, 0.0)]
int_3 = [(1.0, 1.0), (1.0, 2.0), (2.0, 2.0), (2.0, 1.0)]
verts = ext_3 + int_3
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> hole_p = Polygon(int_3).representative_point()
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> hp1 = [list(v)[0] for v in list(hole_p.xy)]
segs = [(0,1), (1,2), (2,3), (3,0), (4,5), (5,6), (6,7), (7,4)]
sq_tri_dict = {
    "vertices": verts,
    "segments": segs,
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> "holes":[hp1]
}
triangulated = tr.triangulate(sq_tri_dict, "pe")</code></pre>
<p class="CodeListingCaption"><a id="listing11-6">Listing 11-6</a>: Tessellating the complex polygon </p>
<p>We start by defining the exterior coordinates for the gallery polygon into a list named <code>ext_3</code>. In this case the points form a large square-shaped gallery. Next, we define the coordinates for the hole vertices in a list named <code>int_3</code>. These points form a smaller square hole placed directly in the center of the larger square exterior. We then create the list of vertices in a variable named <code>verts</code>, which is a concatenated list of all exterior and interior <span epub:type="pagebreak" id="Page_224" title="224"/>coordinates in the shape. We can calculate the representative point for the hole by casting the <code>int_3</code> list as its own polygon and calling the <code>representative_point</code> function mentioned previously. </p>
<p>The <code>hole_p</code> variable now holds a <code>Point</code> whose <code>x</code> and <code>y</code> values can be used to identify the hole region to the Triangle library <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Because Triangle doesn’t work directly with <code>Point</code> objects, we must extract the coordinate information into a list <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Next, we create the <code>segs</code> list, which contains the list of edges that must be respected by the tessellation algorithm. Rather than using coordinates, the edges use the indices of the two vertices as the start and end of each segment. In more complex floor plans, it can be easier to take the segment list directly from the edges in the graph representation. Just be sure that all the edges and nodes are entered correctly, or you’ll get some unexpected results. </p>
<p>Finally, we can construct the parameter dictionary for calling the <code>triangulate</code> function. The only change from the previous parameter dictionary is the addition of the <code>holes</code> key <span aria-label="annotation3" class="CodeAnnotation">❸</span>, which holds a list of coordinates that represent a point inside a hole to be removed. When dealing with multiple holes, you need to calculate a representative point for each and add it to the holes list in the dictionary. </p>
<p><a href="#figure11-8" id="figureanchor11-8">Figure 11-8</a> shows the steps performed on the example complex polygon gallery.</p>
<figure>
<img alt="" class="" src="image_fi/502567c11/f11008.png"/>
<figcaption><p><a id="figure11-8">Figure 11-8</a>: Applying the AGP algorithm to a complex polygon</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-8">Figure 11-8</a> is in the 25th cell of the <em>AGP_basics.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>From left to right you can see the entire solution process applied to the gallery. The white square in the leftmost plot represents the hole in the middle of the gallery; the darker gray area represents the usable floor plan. In the second plot, you can see the result of converting the geometry into a graph. Notice that the hole section is entirely surrounded by edges. These edges are boundaries passed into the Triangle’s <code>triangulate</code> function in the <code>segments</code> key (along with the exterior edges, as before). The third image shows the result of tessellating the shape with respect to the hole. The <code>triangulate</code> function begins by creating the tessellation without respecting the holes and then starts removing triangles, beginning with any triangle <span epub:type="pagebreak" id="Page_225" title="225"/>that contains a point in the holes list; it continues removing adjacent triangles until it reaches one of the edges in the segments list. I didn’t apply an area constraint, so the result is a triangulation with the fewest number of triangles.</p>
<p>The fourth plot shows the updated graph, which is ready for color solving to be applied. As you can see, none of the edges in the second or third plots cross into the hole space; this indicates Triangle has respected our request to ignore that portion of the space when generating the mesh. The final plot on the right shows the result of assigning the deployment groups based on the coloring solution. There are four potential deployments, all of which consist of two guard stations. If the hole weren’t present, you would theoretically need only one guard for the whole gallery.</p>
<h3 id="h2-502567c11-0003">Prioritizing Guard Coverage Areas</h3>
<p class="BodyFirst">Next, we’ll refine our model to address another implicit assumption we’ve made: that all areas of the gallery are equally important and therefore the guard deployments should be evenly distributed. For example, a bank may weigh the monitoring of private offices lower than that of the lobby and therefore require different resources to protect the different spaces. To address this, we’ll refine our initial mesh to respect the importance (or weight) of each region of the floor plan. The underlying Triangle program supports multiple maximum areas (read in from custom data files), which allows us to get creative with how we define different AORs. To pull the example into our world of art gallery security, perhaps you believe the gallery floor needs fewer guards than the lecture hall, where people tend to gather in larger groups. You can see the result of assigning regions applied to the example square gallery in <a href="#figure11-9" id="figureanchor11-9">Figure 11-9</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502567c11/f11009.png"/>
<figcaption><p><a id="figure11-9">Figure 11-9</a>: The gallery when region assignment is added</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-9">Figure 11-9</a> is in the 28th cell of the <em>AGP_basics.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" id="Page_226" title="226"/> On the left of the figure you can see the four numbered regions I defined for the square gallery example. The center of each region is marked by a star as well as its region number. These regions are segment-bounded portions of the overall gallery polygon, so they can be defined using any point within the segment bounds (similar to the way holes are defined). In this case, I added four theoretical segments (the diagonal separators) to the list of segment bounds already defined to enclose the regions. They’re theoretical because, unlike the other segments that represent walls and other physical structures, the region segments represent logical borders between areas, not physical ones. Bear in mind that Triangle doesn’t know the difference, so it’s up to us to track which segments belong to which class. We can do so by taking advantage of edge attributes stored in the graph representation. </p>
<p>To let Triangle know that we have regions of interest, we also need to update the input dictionary we pass to the wrapper to include the <code>regions</code> key, as shown in <a href="#listing11-7" id="listinganchor11-7">Listing 11-7</a>. </p>
<pre><code>sq_tri_dict = {
    <var>--snip--</var>
    "regions":[
        [1.5, 2.5, <b>0.</b> , 0. ],
        [0.5, 1.5, 1. , 0. ],
        [1.5, 0.5, 2. , 0. ],
        [2.5, 1.5, 3. , 0. ]]
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-7">Listing 11-7</a>: Adding the region definitions for tessellation</p>
<p>The value for the <code>regions</code> key is a nested list. Each entry contains x- and y-coordinates representing a point within the associated region. During the initial tessellation, triangles within the bounding segments found around each region’s representative point are assigned the value in the third position. The fourth position in the list, and all subsequent ones, can contain a numeric region attribute (such as a modified visibility value to mark regions with softer lighting). The values of any region attributes you include will be inherited by the triangles within the region.</p>
<p>Once the regions are defined, we can perform the initial tessellation. We’ll tell Triangle to include the region information in the result by adding the <code>A</code> flag to the <code>triangulate</code> function call: </p>
<pre><code>triangulated = tr.triangulate(sq_tri_dict, "pe<b>A</b>")</code></pre>
<p>The resulting mesh is shown on the right side of <a href="#figure11-9">Figure 11-9</a>. The dots with the numbers inside each triangle show which region identifier has been assigned to it. So far, the process is identical to the previous one, so the mesh remains unchanged. </p>
<p>The next step is to save the result in a special group of files; these are essentially the same data in the dictionary written out to flat text files. We need to do this so that we can have Triangle reload the files during the refinement stage. Unfortunately, the wrapper library doesn’t include any functions to save, so I had to write my own based off the file specification <span epub:type="pagebreak" id="Page_227" title="227"/>in the underlying program’s documentation. The project code has all the functions necessary to create the expected files, but they’re long and fairly boring, so I’ll skip detailing them here. All you need to do is import the <code>DataSaver</code> class I’ve included with the chapter code, as shown in <a href="#listing11-8" id="listinganchor11-8">Listing 11-8</a>. </p>
<pre><code>from filemanager import DataSaver
saver = DataSaver(triangulated, "square", 1, "/myproject/")
saver.set_region_areas([-1,0.1,-1,0.05])
saver.save_project()</code></pre>
<p class="CodeListingCaption"><a id="listing11-8">Listing 11-8</a>: Saving the tessellation result to Triangle project files</p>
<p>We start by defining the <code>DataSaver</code> instance, passing it the <code>triangulated</code> dictionary in the first parameter and the project name in the second. You can also optionally pass in a version number and directory. If you don’t pass these in, the version number will automatically be set to 1 and the directory will be the current working directory of the script. The <code>set_region_areas</code> function stores the list of maximum areas, and the index in the list is the same as the region index. If you pass in a list that is shorter than the number of regions, the remaining regions are treated as though they had no area constraint. </p>
<p>We need to set the region areas before we save the project using <code>save_project</code> so that the saver knows how to mark each triangle during the file creation. Once <code>save_file</code> function has completed, you’ll have a list of files in the directory you specified (or the current working directory, as I mentioned). Each file is named like so: <em>&lt;project name&gt;_&lt;version number&gt;.&lt;part&gt;</em> where <em>&lt;part&gt;</em> is one of the file types expected by Triangle (with a <em>.node</em>, <em>.ele</em>, <em>.area</em>, or <em>.poly</em> file extension). Therefore, the code in <a href="#listing11-8">Listing 11-8</a> will create a file named <em>/myproject/square_1.area</em> (among others). The <em>.area</em> file is of particular interest because it contains the maximum area for each triangle, which we just set by virtue of its region association.</p>
<p>Next we need to refine the mesh by reloading the saved data and performing another tessellation:</p>
<pre><code>reload = tr.load("/myproject/", "square_1")
refined = tr.triangulate(reload, "ra")</code></pre>
<p>We call the <code>load</code> function from the wrapper library and pass in the directory where the project files were stored, as well as the project name, including the version. These inputs find and load the data from the associated files created in <a href="#listing11-5">Listing 11-5</a>. Finally, we create the refined mesh by calling the <code>triangulate</code> function once again, this time on the loaded data. The option string <code>ra</code> tells Triangle to refine a previously generated mesh (the <code>r</code> flag) and to refine the mesh using constrained triangle areas (the <code>a</code> flag). Because Triangle is refining a mesh, and we’ve asked it to constrain the area, it will attempt to locate the project’s <em>.area</em> file and use that information while creating the refined mesh.</p>
<p>During the refinement step, each triangle in the original tessellation is compared against the area defined in the <em>.area</em> file. If the area is larger than the maximum defined, the algorithm splits the triangle into smaller ones. You can see the result of the region areas being applied to the tessellation of the square gallery in <a href="#figure11-10" id="figureanchor11-10">Figure 11-10</a>.</p>
<span epub:type="pagebreak" id="Page_228" title="228"/><figure>
<img alt="" class="" src="image_fi/502567c11/f11010.png"/>
<figcaption><p><a id="figure11-10">Figure 11-10</a>: Creating a multiregion tessellation</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-10">Figure 11-10</a> is in the 31st cell of the <em>AGP_basics.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p> On the left, you can see the region assignment. The areas passed in to the <code>DataSaver</code> class were <code>[-1,0.1,-1,0.3]</code>, which can be interpreted as: region 0 has no maximum area constraint (marked by any negative value); region 1 has a maximum area constraint of 0.1; region 2 also has no constraint applied; and finally region 3 has a maximum area constraint of 0.3. On the right side, region 1 has been broken up into many small triangles, while region 3 has been divided up into slightly larger triangles. The result is more guard positions in region 1 than region 3, and increased coverage in both compared to the other two zones with no constraints applied.</p>
<p>We can save the refined mesh using another instance of the <code>DataSaver</code> class:</p>
<pre><code>saver = DataSaver(refined, "square", 2)
wsaver.save_project()</code></pre>
<p>We pass in the <code>refined</code> mesh result, project name, and version once again. It’s standard practice to increment the version for each subsequent mesh you refine, so this refined mesh would be the second version of the square project. We don’t need to define the region areas this time unless we want to perform any further refinements.</p>
<p>Of course, it’d be nice if you could just add as many guards as you wanted to the deployment. Unfortunately, we rarely have the budget for more than some number of guards per shift or for some fixed number of sensor devices we can deploy per floor. We can tell Triangle the maximum number of Steiner points it can add to achieve the tessellation with the <code>S</code> flag. For example, let’s say we can only afford to deploy three extra guards to the square gallery. <a href="#figure11-11" id="figureanchor11-11">Figure 11-11</a> shows the result of adding this constraint during the refinement step.</p>
<span epub:type="pagebreak" id="Page_229" title="229"/><figure>
<img alt="" class="" src="image_fi/502567c11/f11011.png"/>
<figcaption><p><a id="figure11-11">Figure 11-11</a>: Refined mesh with three guards</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-11">Figure 11-11</a> is in the 34th cell of the <em>AGP_basics.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>On the left, you can see the mesh we generated previously, with no restriction on the addition of guard points. On the right, you can see the mesh generated from the refinement where I restricted the output to three additional guard positions. Bear in mind that I didn’t change the maximum area constraint I defined earlier, which clearly the mesh on the right doesn’t achieve. Once Triangle runs out of Steiner points it can add, it can’t divide the larger triangles anymore and so it stops. If you’re asked to divide the gallery into small zones and then cover those zones with only three additional guards, you can use this result to show that it’s a mathematical impossibility to accomplish both goals. Hopefully this result gets you the budget increase you need for those additional guards!</p>
<h3 id="h2-502567c11-0004">Mapping Security Camera Field of View</h3>
<p class="BodyFirst">The next feature to address is adding the field of view and effective range parameters. When discussing human guards, the field of view and effective range are very different from person to person so assigning these parameters is a bit fuzzy. Intuition and educated estimates are your best friend in these cases. However, when you think of guard positions as electronic devices, such as cameras or motion detectors, the data is easier to locate. For example, I searched Google for “security camera data sheet” and selected the first model I saw: Ocuity model number HMNC100 from NetGear. After reviewing the technical data for the model (available from the manufacturer’s website), I found that the listed field of view was 107 degrees and the effective range was 7 m in total darkness (thanks to built-in infrared lighting). The distance during normal operational lighting is often not listed because the answer depends on how much detail you need to be able to distinguish, the focal length of the camera (which may or may not be listed in the user documents), and the number of pixels used to encode the information (often given as a megapixel rating, where 1MP is equal to <span epub:type="pagebreak" id="Page_230" title="230"/>one million pixels). To get a good number for effective distance, the best method is often to just test the camera under the conditions of interest.</p>
<p>We’ll assume the normal effective range <em>r(d)</em> is 20 times greater than the night range, <em>r</em>(<em>n</em>) = 7 m (<em>r</em>(<em>n</em>) × 20 = 140 m or about 460 feet). Since we’re approximating things, I’m also going to change the field of view Δ from 107 to 104 because 107 is prime and therefore can’t be divided up into equal segments; this makes computing the points representing the edges of the field of view harder. On the other hand, 104 can be divided by several factors, including 2, which is also helpful for keeping the math simple. I’ll define the starting angle ϴ<sub>(0)</sub> for each of the four internal guard nodes <code>[4, 5, 6, 7]</code> as <code>[180, 134, 45, 351]</code>, respectively. We can define the positive peripheral angle as <span class="GraphicInline eq"><img alt="m11001" src="image_fi/502567c11/m11001.png"/></span> and the negative peripheral angle as <span class="GraphicInline eq"><img alt="m11002" src="image_fi/502567c11/m11002.png"/></span>.</p>
<p>Finally, we can create some number of intermediary angles between the two peripheral angles by dividing the field of view into eight segments of 13 degrees each:</p>
<p class="MathEquation"><span class="math" title="%delta = %DELTA/8 = 13"> <span class="mo">δ</span> <span class="mo"> =</span>  <span class="mo">Δ</span> <span class="mo">/</span> <span class="mn">8</span> <span class="mo"> = </span> <span class="mn">13</span></span></p>
<p>We can then use the <code>cos</code> and <code>sin</code> functions for each of the angles:</p>
<p class="MathEquation"><span class="math" title="A := [%theta sub(p) - i%delta] forall i in  setZ sub{ 0-8 }"><span class="mi">A</span> <span class="mi">:</span>  <span class="mo">= </span> <span class="mo">[</span> <span class="mi">θ</span><span class="msub"><span class="mo">(</span> <span class="mi">p</span> <span class="mo">)</span></span>  <span class="mo">− </span> <span class="mi">i</span> <span class="mo">δ</span><span class="mo">]</span> <span class="mo">∀</span> <span class="mi">i</span> <span class="mo">∈</span>  <span class="mi">ℤ</span><span class="msub"><span class="mn">0</span>  <span class="mo">− </span> <span class="mn">8</span></span></span></p>
<p><a href="#figure11-12" id="figureanchor11-12">Figure 11-12</a> shows the approximated coverage if you positioned one of these cameras at each of the four internal guard positions from the square example in <a href="#figure11-8">Figure 11-8</a>, using the starting angles just mentioned. </p>
<figure>
<img alt="" class="" src="image_fi/502567c11/f11012.png"/>
<figcaption><p><a id="figure11-12">Figure 11-12</a>: Defining the field of view polygons</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_231" title="231"/><h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure11-12">Figure 11-12</a> is in the 26th cell of the <em>AGP_basics.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><a href="#figure11-12">Figure 11-12</a> shows the approximate field of view coverage resulting from placing one of those cameras at each of the corners of the internal hole. As you can see, there are clearly large areas the cameras aren’t able to adequately cover. Furthermore, you can see someone could theoretically approach each camera position without ever entering the field of vision of any camera. These are examples of the blind spots mentioned earlier in the chapter. As a defender, you’d want to add more coverage to prevent these gaps. As an attacker, you could consider all of the uncovered assets as potentially good targets.</p>
<p>One last note about field of view mapping. I’ve assumed that the cameras are pointed and then left stationary. Several high-end cameras include a device called a gimbal that allows a remote operator to move the camera as needed. Some mid-level cameras also include the ability to automatically sweep back and forth across an area. These types of cameras are becoming less popular these days, but they’re still good to be aware of; not all field of view maps are going to be static. Be sure to look out for features like these when you’re analyzing the data sheets for devices; you may need to update your implementation to produce the full range of vision for these cases.</p>
<h2 id="h1-502567c11-0005">Summary</h2>
<p class="BodyFirst">You now have all the code necessary to solve the core of the art gallery problem, including methods for handling real-world constraints, such as limited budgets and effective range for sensors. We’ve discussed the power of the Triangle library and combined it with Shapely and NetworkX to model the problem with both a geometric and graph representation. Perhaps most important of all, you should now be comfortable explaining the AGP theory and discussing the practical constraints applied within the application. There’s a large body of research you can tap into to continue developing your understanding of the problem. I didn’t even touch on how the greedy color algorithm functions under the hood, for example.<sup class="endnote"><a href="b01.xhtml#c11-endnote-005" id="c11-noteref-005">5</a></sup> Node coloring in general is a great graph theory topic with many applications outside the AGP, but for our purposes, studying node-coloring algorithms can help you understand the solutions your application outputs (and how you can potentially modify them) more completely. For a more in-depth description of the geometric implications of different gallery layouts, check out the paper “Note on an Art Gallery Problem.”<sup class="endnote"><a href="b01.xhtml#c11-endnote-006" id="c11-noteref-006">6</a></sup> </p>
<p>To continue developing the core of the system, you can identify additional use cases that may be of interest to the users you want to serve. For example, you might want a use case to cover users who want to compare before and after deployment plans. Once you collect the use cases, you can develop the additional functions needed to support them. Additionally, you can continue to refine the functions included here. The triangle assignment function is one excellent area to improve upon using one of the <span epub:type="pagebreak" id="Page_232" title="232"/>options we discussed previously. Remember, you don’t necessarily need to develop all of these features before taking your application to the market. Developing an MVP is all about picking the key features that make your application useful to users. Oftentimes, figuring out these key features is a matter of analyzing competitive software offerings and answering the questions, “What features do all these applications offer?” and “What features does my application offer that the others do not?” </p>
<p>Once you can answer those two questions, you’re ready to move on to the next chapters, where we’ll go from the core algorithm developed in this chapter to a full-fledged Python application. We’ll finish out the project by mapping out the user interaction, adding graphics, selecting a modern processing architecture, and deciding whether to add application licensing.</p>
</section>
</body>
</html>