["```\nconst distances = (graph) => {\n❶ const n = graph.length;\n\n❷ const distance = [];\n❸ for (let i = 0; i < n; i++) {\n    distance[i] = Array(n).fill(+Infinity);\n  }\n\n❹ graph.forEach((r, i) => {\n  ❺ distance[i][i] = 0;\n  ❻ r.forEach((c, j) => {\n      if (c > 0) {\n        distance[i][j] = graph[i][j];\n      }\n    });\n  });\n\n❼ for (let k = 0; k < n; k++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n      ❽ if (distance[i][j] > distance[i][k] + distance[k][j]) {\n          distance[i][j] = distance[i][k] + distance[k][j];\n        }\n      }\n    }\n  }\n\n ❾ return distance;\n};\n```", "```\nconst distances = (graph, from) => {\n  const n = graph.length;\n\n❶ const previous = Array(n).fill(null);\n❷ const distance = Array(n).fill(+Infinity);\n❸ distance[from] = 0;\n\n❹ const edges = [];\n  for (let i = 0; i < n; i++) {\n for (let j = 0; j < n; j++) {\n      if (graph[i][j]) {\n        edges.push({from: i, to: j, dist: graph[i][j]});\n      }\n    }\n  }\n\n❺ for (let i = 0; i < n - 1; i++) {\n  ❻ edges.forEach((v) => {\n      const w = v.dist;\n    ❼ if (distance[v.from] + w < distance[v.to]) {\n      ❽ distance[v.to] = distance[v.from] + w;\n      ❾ previous[v.to] = v.from;\n      }\n    });\n  }\n\n  ❿ return [distance, previous];\n};\n```", "```\nconst distance = (graph, from) => {\n  const n = graph.length;\n\n❶ const points = [];\n  for (let i = 0; i < n; i++) {\n  ❷ points[i] = {\n      i,\n      done: false,\n      dist: i === from ? 0 : +Infinity,\n      prev: null,\n      index: -1\n    };\n  }\n\n❸ const heap = [from];\n  for (let i = 0; i < n; i++) {\n    if (i !== from) {\n      heap.push(i);\n    }\n  }\n❹ heap.forEach((v, i) => (points[v].index = i));\n\n  // heap functions, omitted for now\n\n❺ while (heap.length) {\n    const closest = heap[0];\n    points[closest].done = true;\n    const dist = points[closest].dist;\n\n ❻ swap(0, heap.length – 1);\n    heap.pop();\n    sinkDown(0);\n\n  ❼ graph[closest].forEach((v, next) => {\n      if (v > 0 && !points[next].done) {\n        const newDist = dist + graph[closest][next];\n      ❽ if (newDist < points[next].dist) {\n          points[next].dist = newDist;\n          points[next].prev = closest;\n          bubbleUp(points[next].index);\n        }\n      }\n    });\n  }\n\n❾ return points;\n};\n```", "```\n❶ const swap = (i, j) => {\n    [heap[i], heap[j]] = [heap[j], heap[i]];\n    points[heap[i]].index = i;\n    points[heap[j]].index = j;\n  };\n\n❷ const sinkDown = (i) => {\n    const l = 2 * i + 1;\n    const r = l + 1;\n    let g = i;\n  ❸ if (l < heap.length && points[heap[l]].dist < points[heap[g]].dist) {\n      g = l;\n }\n    if (r < heap.length && points[heap[r]].dist < points[heap[g]].dist) {\n      g = r;\n    }\n    if (g !== i) {\n      swap(g, i);\n      sinkDown(g);\n    }\n  };\n\n❹ const bubbleUp = (i) => {\n    if (i > 0) {\n      const p = Math.floor((i - 1) / 2);\n    ❺ if (points[heap[i]].dist < points[heap[p]].dist) {\n        swap(p, i);\n        bubbleUp(p);\n      }\n    }\n  };\n```", "```\nconst topologicalSort = (graph) => {\n  const n = graph.length;\n❶ const queue = [];\n❷ const sorted = [];\n\n❸ const incoming = Array(n).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (graph[i][j]) {\n        incoming[j]++;\n      }\n    }\n  }\n\n❹ incoming.forEach((v, i) => {\n    if (v === 0) {\n      queue.push(i);\n    }\n  });\n\n❺ while (queue.length > 0) {\n  ❻ const i = queue.shift();\n  ❼ sorted.push(i);\n\n  ❽ graph[i].forEach((v, j) => {\n      if (v) {\n        incoming[j]--;\n      ❾ if (incoming[j] === 0) {\n          queue.push(j);\n        }\n      }\n    });\n  }\n\n ❿ return sorted.length === n ? sorted : null;\n};\n```", "```\nconst topologicalSort = (graph) => {\n   const n = graph.length;\n❶ const marks = Array(n).fill(0); // 1:temp, 2:final\n❷ const sorted = [];\n\n❸ const visit = (p) => {\n  ❹ if (marks[p] === 1) {\n      throw new Error(\"Not a DAG\");\n  ❺} else if (marks[p] === 0) {\n      marks[p] = 1;\n    ❻ graph[p].forEach((v, q) => {\n ❼ if (v && marks[q] !== 2) {\n          visit(q);\n        }\n      });\n\n    ❽ marks[p] = 2;\n    ❾ sorted.unshift(p);\n    }\n  };\n\n  try {\n  ❿ marks.forEach((v, i) => {\n      visit(i);\n    });\n    return sorted;\n  } catch (e) {\n    return null;\n  }\n};\n```", "```\nconst hasCycle = (graph) => {\n  const n = graph.length;\n❶ const marks = Array(n).fill(0); // 1:temp, 2:final\n\n  const visit = (p) => {\n    if (marks[p] === 1) {\n      throw new Error(\"cycle found\");\n    } else if (marks[p] === 0) {\n      marks[p] = 1;\n      graph[p].forEach((v, q) => {\n        if (v && marks[q] !== 2) {\n          visit(q);\n        }\n      });\n\n    ❷ marks[p] = 2;\n    }\n  };\n\n  try {\n    marks.forEach((v, i) => {\n      visit(i);\n    });\n  ❸ return false; // no cycles found\n  } catch (e) {\n    return true;\n  }\n};\n```", "```\nconst isConnected = (graph) => {\n  const n = graph.length;\n\n❶ const groups = Array(n)\n    .fill(0)\n    .map(() => ({ptr: null}));\n❷ let count = n;\n\n❸ const findParent = (x) => (x.ptr !== null ? findParent(x.ptr) : x);\n\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n    ❹ if (graph[i][j]) {\n      ❺ const pf = findParent(groups[i]);\n        const pt = findParent(groups[j]);\n      ❻ if (pf !== pt) {\n          pf.ptr = pt.ptr = {ptr: null};\n ❼ count--;\n        }\n      }\n    }\n  }\n\n❽ return count === 1;\n};\n```", "```\nconst isConnected = (graph) => {\n  const n = graph.length;\n❶ const visited = Array(n).fill(false);\n\n❷ const visit = (x) => {\n\n  ❸ graph[x].forEach((v, i) => {\n    ❹ if (v > 0 && !visited[i]) {\n      ❺ visited[i] = true;\n      ❻ visit(i);\n      }\n    });\n  };\n\n❼ visited[0] = true;\n❽ visit(0);\n\n❾ return visited.every((x) => x);\n};\n```", "```\n const bubbleUp = (i) => {\n  ❶ while (i > 0) {\n      const p = Math.floor((i - 1) / 2);\n    ❷ if (heap[i].dist > heap[p].dist) {\n        return;\n      }\n    ❸ [heap[p], heap[i]] = [heap[i], heap[p]];\n    ❹ i = p;\n }\n  };\n\n  const sinkDown = (i) => {\n  ❺ for (;;) {\n      const l = 2 * i + 1;\n      const r = l + 1;\n      let m = i;\n      if (l < heap.length && heap[l].dist < heap[m].dist) {\n        m = l;\n      }\n      if (r < heap.length && heap[r].dist < heap[m].dist) {\n        m = r;\n      }\n      if (m === i) {\n      ❻ return;\n      }\n    ❼ [heap[m], heap[i]] = [heap[i], heap[m]];\n    ❽ i = m;\n    }\n  };\n```", "```\nconst spanning = (graph) => {\n  const n = graph.length;\n\n❶ const newGraph = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n❷ const heap = Array(n)\n    .fill(0)\n    .map((v, i) => ({from: i, to: i, dist: +Infinity}));\n\n  //  bubbleUp and sinkDown, excluded\n\n❸ while (heap.length) {\n  ❹ const from = heap[0].from;\n  ❺ const to = heap[0].to;\n\n  ❻ newGraph[from][to] = graph[from][to];\n    newGraph[to][from] = graph[to][from];\n\n  ❼ heap[0] = heap[heap.length – 1];\n    heap.pop(); // or the more unconventional heap.length--;\n    sinkDown(0);\n\n ❽ for (let i = 0; i < heap.length; i++) {\n    ❾ const v = heap[i];\n      const dist = graph[v.from][from];\n    ❿ if (dist > 0 && dist < v.dist) {\n        v.to = from;\n        v.dist = dist;\n        bubbleUp(i);\n      }\n    }\n  }\n\n  return newGraph;\n};\n```", "```\nconst spanning = (graph) => {\n  const n = graph.length;\n\n❶ const newGraph = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n❷ const edges = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (graph[i][j]) {\n        edges.push({from: i, to: j, dist: graph[i][j]});\n      }\n    }\n  }\n❸ edges.sort((a, b) => a.dist – b.dist);\n\n❹ const groups = Array(n)\n    .fill(0)\n    .map(() => ({ptr: null}));\n\n❺ const findParent = (x) => {\n    while (x.ptr) {\n      x = x.ptr;\n    }\n    return x;\n  };\n\n❻ edges.forEach((v) => {\n  ❼ const pf = findParent(groups[v.from]);\n    const pt = findParent(groups[v.to]);\n  ❽ if (pf !== pt) {\n    ❾ pf.ptr = pt.ptr = {ptr: null};\n      newGraph[v.from][v.to] = newGraph[v.to][v.from] = graph[v.to][v.from];\n    }\n  });\n\n ❿ return newGraph;\n};\n```"]