- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SCANNERS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">扫描器</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Nearly every EDR solution includes a component that accepts data and tries to
    determine whether the content is malicious. Endpoint agents use it to assess many
    different data types, such as files and memory streams, based on a set of rules
    that the vendor defines and updates. This component, which we’ll refer to as the
    *scanner* for simplicity’s sake, is one of the oldest and best-studied areas in
    security from both the defensive and offensive angles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的EDR解决方案都包括一个组件，接受数据并尝试确定内容是否具有恶意性。终端代理使用它来评估许多不同的数据类型，如文件和内存流，这些评估基于供应商定义和更新的一组规则。为了简单起见，我们将这个组件称为*扫描器*，它是安全领域中最古老、研究最深入的领域之一，无论是从防御角度还是进攻角度来看。
- en: Because covering all aspects of their implementation, processing logic, and
    signatures would be like trying to boil the ocean, this chapter focuses on the
    rules employed by file-based scanners. Scanner rules differentiate one product’s
    scanner from another (barring major performance differences or other technical
    capabilities). And on the offensive side, it’s the scanner rules rather than the
    implementation of the scanner itself that adversaries must evade.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涵盖它们的实现、处理逻辑和签名几乎像是要“煮海洋”，本章专注于基于文件的扫描器所使用的规则。扫描器规则使得不同产品的扫描器有所区别（不考虑性能差异或其他技术能力）。在进攻方面，正是扫描器规则，而不是扫描器本身的实现，敌对者必须规避的目标。
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Brief History of Antivirus Scanning</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">反病毒扫描的简史</samp>
- en: We don’t know who invented the antivirus scanning engine. German security researcher
    Bernd Fix developed some of the first antivirus software, in 1987, to neutralize
    the Vienna virus, but it wasn’t until 1991 that the world saw an antivirus scanning
    engine that resembles the ones in use today; FRISK Software’s F-PROT antivirus
    would scan a binary to detect any reordering of its sections, a pattern that malware
    developers of the time commonly employed to jump execution to the end of the file,
    where they had placed malicious code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道是谁发明了病毒扫描引擎。德国安全研究员伯恩德·菲克斯（Bernd Fix）在1987年开发了第一款病毒软件，用于中和维也纳病毒，但直到1991年，世界才看到了类似今天常用的病毒扫描引擎；FRISK软件的F-PROT病毒扫描器会扫描一个二进制文件，检测其各部分的重排序，这是当时恶意软件开发者常用的一个模式，用来将执行跳转到文件末尾，那时他们将恶意代码放置在文件的末尾。
- en: As viruses became more prevalent, dedicated antivirus agents became a requirement
    for many companies. To meet this demand, vendors such as Symantec, McAfee, Kaspersky,
    and F-Secure brought their scanners to market in the 1990s. Regulatory bodies
    began enforcing the use of antivirus to protect systems, further promoting their
    adoption. By the 2010s, it was nearly impossible to find an enterprise environment
    without antivirus software deployed on most of its endpoints.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着病毒的传播越来越广泛，专用的反病毒代理成为许多公司所必须的。为了满足这一需求，像赛门铁克（Symantec）、麦卡菲（McAfee）、卡巴斯基（Kaspersky）和F-Secure等供应商在1990年代推出了他们的扫描器。监管机构开始强制要求使用反病毒软件来保护系统，进一步推动了它们的普及。到2010年代，几乎不可能找到一个没有在大多数终端部署反病毒软件的企业环境。
- en: This broad adoption lulled many directors of information-security programs into
    a false sense of security. While these antimalware scanners had some success in
    detecting commodity threats, they missed more advanced threat groups, which were
    achieving their objectives without detection.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这种广泛的采用使得许多信息安全项目的主管产生了错误的安全感。尽管这些反恶意软件扫描器在检测常见威胁方面取得了一些成功，但它们未能捕捉到更先进的威胁团体，而这些团体能够在不被发现的情况下实现它们的目标。
- en: In May 2013, Will Schroeder, Chris Truncer, and Mike Wright released their tool,
    Veil, which opened many people’s eyes to this overreliance on antivirus scanners.
    Veil’s entire purpose was to create payloads that bypassed antivirus by employing
    techniques that broke legacy detection rulesets. These techniques included string-
    and variable-name obfuscation, less common code-injection methods, and payload
    encryption. During offensive security engagements, they proved that their tool
    could effectively evade detection, causing many companies to reevaluate the value
    of the antivirus scanners they paid for. Simultaneously, antivirus vendors began
    rethinking how to approach the problem of detection.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年5月，Will Schroeder、Chris Truncer 和 Mike Wright 发布了他们的工具Veil，这让很多人意识到过度依赖杀毒扫描程序的问题。Veil的整个目的就是通过采用打破传统检测规则集的技术来创建绕过杀毒软件的有效载荷。这些技术包括字符串和变量名称混淆、更不常见的代码注入方法以及有效载荷加密。在攻防安全工作中，他们证明了自己的工具能够有效避开检测，导致许多公司重新评估他们支付费用购买的杀毒扫描程序的价值。与此同时，杀毒软件供应商也开始重新思考如何应对检测问题。
- en: While it’s hard to quantify the impact of Veil and other tools aimed at tackling
    the same problem, these tools undoubtedly moved the needle, leading to the creation
    of more robust endpoint detection solutions. These newer solutions still make
    use of scanners, which contribute to the overall detection strategies, but they
    have grown to include other sensors that can provide coverage when the scanners’
    rulesets fail to detect malware.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管很难量化Veil和其他旨在解决相同问题的工具的影响，但这些工具无疑推动了技术进步，促使了更强大的端点检测解决方案的出现。这些新的解决方案仍然使用扫描程序，作为整体检测策略的一部分，但它们已经发展到包括其他传感器，当扫描程序的规则集未能检测到恶意软件时，这些传感器能够提供覆盖。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Scanning Models</samp>
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">扫描模型</samp>
- en: Scanners are software applications that the system should invoke when appropriate.
    Developers must choose between two models to determine when their scanner will
    run. This decision is more complex and important than it may seem at face value.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描程序是系统在适当时应该调用的软件应用程序。开发人员必须在两种模型之间做出选择，以确定扫描程序何时运行。这个决策比看起来的更复杂且重要。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">On Demand</samp>
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按需扫描</samp>
- en: The first model, *on-demand scanning*, instructs a scanner to run at some set
    time or when explicitly requested to do so. This type of scanning typically interacts
    with a large number of targets (for example, files and folders) on each execution.
    The Quick Scan feature in Microsoft Defender, shown in [Figure 9-1](#fig9-1),
    may be the most familiar example of this model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模型，*按需扫描*，指示扫描程序在某个设定时间或在明确要求时运行。这种类型的扫描通常会在每次执行时与大量目标（例如文件和文件夹）进行交互。Microsoft
    Defender中的快速扫描功能，如[图 9-1](#fig9-1)所示，可能是这种模型最为熟悉的例子。
- en: '![](../images/Figure9-1.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: Defender’s Quick
    Scan feature in action</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-1：Microsoft Defender的快速扫描功能示意图</samp>
- en: When implementing this model, developers must consider the potential performance
    impacts on the system caused by the scanner processing thousands of files at once.
    On resource-constrained systems, it might be best to run this type of scan during
    off-hours (for example, 2 AM every Tuesday) than to run a full scan during working
    hours.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施此模型时，开发人员必须考虑扫描程序在一次处理数千个文件时可能对系统性能造成的影响。在资源受限的系统上，最好是在非工作时间（例如，每周二凌晨 2 点）运行此类扫描，而不是在工作时间运行完整扫描。
- en: The other major downside of this model involves the period of time between each
    scan. Hypothetically, an attacker could drop malware on the system after the first
    scan, execute it, and remove it before the next scan, to evade detection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型的另一个主要缺点是每次扫描之间的时间间隔。假设攻击者可以在第一次扫描之后将恶意软件投放到系统中，执行它，并在下一次扫描之前将其删除，从而避开检测。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">On Access</samp>
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按访问扫描</samp>
- en: During *on-access scanning*, often referred to as *real-time protection*, the
    scanner assesses an individual target while some code is interacting with it or
    when a suspicious activity occurs and warrants investigation. You’ll most often
    find this model paired with another component that can receive notifications when
    something interacts with the target object, such as a filesystem minifilter driver.
    For example, the scanner might investigate a file when it is downloaded, opened,
    or deleted. Microsoft Defender implements this model on all Windows systems, as
    shown in [Figure 9-2](#fig9-2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在*按需扫描*过程中，通常称为*实时保护*，扫描器会在某些代码与目标交互或发生可疑活动并需要调查时评估单个目标。你通常会发现这种模型与另一个组件配合使用，当某些东西与目标对象交互时，它能够接收通知，例如文件系统迷你过滤器驱动程序。例如，当文件被下载、打开或删除时，扫描器可能会对其进行检查。微软
    Defender 在所有 Windows 系统上实现了这一模型，如[图 9-2](#fig9-2)所示。
- en: '![](../images/Figure9-2.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: Defender’s real-time
    protection feature enabled by default</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-2：Defender 的实时保护功能默认启用</samp>
- en: The on-access scanning approach generally causes more of a headache for adversaries
    because it removes the ability to abuse the periods of time between on-demand
    scans. Instead, attackers are left trying to evade the ruleset used by the scanner.
    Let’s now consider how these rulesets work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*按需扫描*方法通常会给对手带来更多困扰，因为它消除了滥用按需扫描之间的时间间隔的可能性。相反，攻击者只能试图规避扫描器使用的规则集。现在让我们来考虑这些规则集是如何工作的。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Rulesets</samp>
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规则集</samp>
- en: At the heart of every scanner is a set of rules that the engine uses to assess
    the content to be scanned. These rules more closely resemble dictionary entries
    than firewall rules; each rule contains a definition in the form of a list of
    attributes that, if identified, signals that the content should be treated as
    malicious. If the scanner detects a match for a rule, it will take some predetermined
    action, such as quarantining the file, killing the process, or alerting the user.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个扫描器的核心都是一组规则，扫描引擎使用这些规则来评估待扫描的内容。这些规则更像是字典条目，而不是防火墙规则；每个规则都包含一个定义，形式为一系列属性列表，如果这些属性被识别，就表示该内容应被视为恶意。如果扫描器检测到规则匹配，它将采取一些预定的措施，如将文件隔离、终止进程或提醒用户。
- en: When designing scanner rules, developers hope to capture a unique attribute
    of a piece of malware. These features can be specific, like the names or cryptographic
    hashes of files, or they can be broader, such as DLLs or functions that the malware
    imports or a series of opcodes that serve some critical function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计扫描器规则时，开发人员希望捕捉到恶意软件的独特属性。这些特征可以是具体的，如文件的名称或加密哈希值，或者可以更广泛，如恶意软件导入的 DLL 或函数，或者执行某些关键功能的一系列操作码。
- en: Developers might base these rules on known malware samples detected outside
    the scanner. Sometimes other groups even share information about the sample with
    a vendor. The rules can also target malware families or techniques more generally,
    such as a known group of APIs used by ransomware, or strings like <samp class="SANS_TheSansMonoCd_W5Regular_11">bcdedit.exe</samp>,
    which might indicate that malware is trying to modify the system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可能会基于在扫描器外部检测到的已知恶意软件样本来制定这些规则。有时其他团队甚至会将关于样本的信息共享给厂商。这些规则也可以针对恶意软件家族或技术进行更广泛的检测，例如勒索软件使用的已知
    API 组，或像<samp class="SANS_TheSansMonoCd_W5Regular_11">bcdedit.exe</samp>这样的字符串，可能表明恶意软件正试图修改系统。
- en: Vendors can implement both types of rules in whatever ratio makes sense for
    their product. Generally, vendors that heavily rely on rules specific to known
    malware samples will generate fewer false positives, while those that make use
    of less-specific indicators will encounter fewer false negatives. Because rulesets
    are made up of hundreds or thousands of rules, vendors can balance the ratio of
    specific to less-specific detections to meet the false-positive and false-negative
    tolerances of their customers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 厂商可以根据其产品的需求，在两种类型的规则之间以适当的比例进行实现。通常，依赖于特定已知恶意软件样本规则的厂商会产生较少的误报，而那些使用较少特定指示符的厂商则会遇到较少的漏报。由于规则集由数百或数千条规则组成，厂商可以平衡特定规则和较少特定规则之间的比例，以满足客户对误报和漏报的容忍度。
- en: Vendors each develop and implement their own rulesets, but products tend to
    have a lot of overlap. This is beneficial to consumers, as the overlap ensures
    that no single scanner dominates the marketplace based on its ability to detect
    the “threat du jour.” To illustrate this, take a look at the results of a query
    in VirusTotal (an online service used to investigate suspicious files, IPs, domain
    names, and URLs). [Figure 9-3](#fig9-3) shows a phishing lure associated with
    FIN7, a financially motivated threat group, detected by 33 security vendors, demonstrating
    the overlap of these rulesets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 各供应商各自开发和实施自己的规则集，但产品之间存在大量重叠。这对消费者有利，因为重叠确保没有单一的扫描器基于其检测“每日威胁”的能力主导市场。为了说明这一点，请查看VirusTotal中的查询结果（这是一个在线服务，用于调查可疑文件、IP、域名和URL）。[图
    9-3](#fig9-3)显示了与财务动机威胁组织FIN7相关的网络钓鱼诱饵，由33个安全供应商检测到，展示了这些规则集的重叠。
- en: There have been many attempts to standardize scanner rule formats to facilitate
    the sharing of rules between vendors and the security community. At the time of
    this writing, the YARA rule format is the most widely adopted, and you’ll see
    it used in open source, community-driven detection efforts as well as by EDR vendors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多尝试标准化扫描规则格式以促进规则在供应商和安全社区之间共享的努力。截至目前，YARA规则格式是最广泛采用的，在开源、社区驱动的检测工作以及EDR供应商中都可以看到其使用。
- en: '![](../images/Figure9-3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: VirusTotal scan
    results for a file associated with FIN7</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-3：与FIN7相关的文件的VirusTotal扫描结果</samp>
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Case Study: YARA</samp>'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">案例研究：YARA</samp>
- en: Originally developed by Victor Alvarez of VirusTotal, the YARA format helps
    researchers identify malware samples by using textual and binary patterns to detect
    malicious files. The project provides both a stand-alone executable scanner and
    a C programming language API that developers can integrate into external projects.
    This section explores YARA, as it provides a great example of what a scanner and
    its rulesets look like, has fantastic documentation, and is widely used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: YARA最初由VirusTotal的Victor Alvarez开发，帮助研究人员通过文本和二进制模式检测恶意软件样本。该项目提供了一个独立的可执行扫描程序和一个可以集成到外部项目中的C编程语言API。本节探讨了YARA，因为它提供了一个很好的示例，展示了扫描器及其规则集的样子，有着出色的文档，广泛应用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding YARA
    Rules</samp>
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理解YARA规则</samp>
- en: 'YARA rules use a simple format: they begin with metadata about the rule, followed
    by a set of strings describing the conditions to be checked and a Boolean expression
    that describes the rule logic. Consider the example in [Listing 9-1](#list9-1).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: YARA规则采用简单的格式：它们以规则的元数据开始，接着是一组描述要检查的条件的字符串，以及描述规则逻辑的布尔表达式。可以参考[Listing 9-1](#list9-1)中的例子。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: A YARA rule for detecting the public version of SafetyKatz'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-1：用于检测公共版本SafetyKatz的YARA规则
- en: This simple rule, called *SafetyKatz_PE*, follows a format commonly used to
    detect off-the-shelf .NET tooling. It begins with some metadata containing a brief
    description of the rule, a reference to the tool it aims to detect, and, optionally,
    the date on which it was created ❶. This metadata has no bearing on the scanner’s
    behavior, but it does provide some useful context about the rule’s origins and
    behavior.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的规则称为*SafetyKatz_PE*，遵循常用于检测现成.NET工具的格式。它以一些元数据开头，包含了对规则进行简要描述、旨在检测的工具的引用，以及可选的创建日期
    ❶。这些元数据对扫描器的行为没有影响，但提供了有关规则来源和行为的一些有用上下文信息。
- en: 'Next is the strings section ❷. While optional, it houses useful strings found
    inside the malware that the rule’s logic can reference. Each string has an identifier,
    beginning with a <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>, and a
    function, like in a variable declaration. YARA supports three different types
    of strings: plaintext, hexadecimal, and regular expressions.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是字符串部分 ❷。虽然可选，但它包含了恶意软件中发现的有用字符串，规则的逻辑可以引用这些字符串。每个字符串都有一个标识符，以 <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>
    开头，并且一个类似于变量声明的功能。YARA支持三种不同类型的字符串：明文、十六进制和正则表达式。
- en: Plaintext strings are the most straightforward, as they have the least variation,
    and YARA’s support of modifiers makes them especially powerful. These modifiers
    appear after the contents of the string. In [Listing 9-1](#list9-1), the string
    is paired with the modifiers <samp class="SANS_TheSansMonoCd_W5Regular_11">ascii
    nocase wide</samp>, which means that the string should be checked without sensitivity
    to case in both ASCII and wide formats (the *wide* format uses two bytes per character).
    Additional modifiers, including <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">base64</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">base64wide</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">fullword</samp>, exist to provide
    even more flexibility when defining a string to be processed. Our example rule
    uses only one plaintext string, the GUID for TypeLib, an artifact created by default
    in Visual Studio when a new project is begun.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 明文字符串是最简单的，因为它们变化最小，并且 YARA 对修饰符的支持使它们尤其强大。这些修饰符出现在字符串的内容之后。在 [Listing 9-1](#list9-1)
    中，字符串与修饰符 <samp class="SANS_TheSansMonoCd_W5Regular_11">ascii nocase wide</samp>
    配对，意思是该字符串应该在不区分大小写的情况下，以 ASCII 和宽格式（*wide* 格式每个字符使用两个字节）进行检查。其他修饰符，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">base64</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">base64wide</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">fullword</samp>，提供了更多的灵活性，用于定义待处理的字符串。我们的示例规则仅使用一个明文字符串，即
    TypeLib 的 GUID，这是在 Visual Studio 中创建新项目时默认生成的一个工件。
- en: Hexadecimal strings are useful when you’re searching for non-printable characters,
    such as a series of opcodes. They’re defined as space-delimited bytes enclosed
    in curly brackets (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">$foo</samp>
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE EF}</samp>). Like plaintext
    strings, hexadecimal strings support modifiers that extend their functionality.
    These include wildcards, jumps, and alternatives. *Wildcards* are really just
    placeholders that say “match anything here” and are denoted with a question mark.
    For example, the string <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE ??}</samp>
    would match anything from <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE 00}</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE FF}</samp> appearing in a
    file. Wildcards are also *nibble-wise*, meaning that the rule author can use a
    wildcard for either nibble of the byte, leaving the other one defined, which allows
    the author to scope their search even further. For example, the string <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE
    E?}</samp> would match anything from <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE
    E0}</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE EF}</samp>.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制字符串在搜索不可打印字符时非常有用，例如一系列的操作码。它们定义为用空格分隔的字节，并用大括号括起来（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">$foo</samp>
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE EF}</samp>）。与明文字符串一样，十六进制字符串支持扩展其功能的修饰符。这些修饰符包括通配符、跳跃和替代项。*通配符*实际上只是占位符，表示“这里匹配任何内容”，并用问号表示。例如，字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE ??}</samp> 将匹配文件中出现的任何内容，从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">{BE 00}</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE
    FF}</samp>。通配符也是*按半字节*匹配的，这意味着规则作者可以为字节的任意半字节使用通配符，而保留另一个字节的定义，从而使搜索范围进一步缩小。例如，字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE E?}</samp> 将匹配从 <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE
    E0}</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE EF}</samp> 之间的任何内容。
- en: 'In some situations, the content of a string can vary, and the rule author might
    not know the length of these variable chunks. In that case, they can use a jump.
    *Jumps* are formatted as two numbers delimited with a hyphen and enclosed in square
    brackets. They effectively mean “the values starting here and ranging from X to
    Y bytes in length are variable.” For example, the hexadecimal string <samp class="SANS_TheSansMonoCd_W5Regular_11">$foo</samp>
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE [1-3] EF}</samp> would match
    any of the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，字符串的内容可能会有所不同，规则的作者可能不知道这些可变部分的长度。在这种情况下，他们可以使用跳跃。*跳跃*的格式是用连字符分隔的两个数字，并用方括号括起来。它们的意思是“从这里开始，长度在
    X 到 Y 字节之间的值是可变的”。例如，十六进制字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">$foo</samp>
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE [1-3] EF}</samp> 将匹配以下任意内容：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EE</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EE</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">00
    B1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">00
    B1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EF
    00 BE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EF
    00 BE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
- en: 'Another modifier supported by hexadecimal strings is *alternatives*. Rule authors
    use these when working with a portion of a hex string that has multiple possible
    values. The authors delimit these values with pipes and store them in parentheses.
    There is no limit to the number or size of alternatives in a string. Additionally,
    alternatives can include wildcards to expand their utility. The string <samp class="SANS_TheSansMonoCd_W5Regular_11">$foo</samp>
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE (EE | EF BE | ?? 00) EF}</samp>
    would match any of the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制字符串支持的另一种修饰符是*选择项*。规则作者在处理具有多个可能值的十六进制字符串部分时使用这些修饰符。作者用管道符号分隔这些值，并将其存储在括号中。字符串中的选择项数量和大小没有限制。此外，选择项可以包括通配符，以扩展其用途。字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">$foo</samp> = <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE
    (EE | EF BE | ?? 00) EF}</samp> 将匹配以下任意一种情况：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EE</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EE</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EF
    BE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EF
    BE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EE
    00</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EE
    00</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">A1
    00</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">A1
    00</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp>
- en: The final and only mandatory section of a YARA rule is called the condition.
    *Conditions* are Boolean expressions that support Boolean operators (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AND</samp>), relational operators
    (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>=), and the
    arithmetic and bitwise operators (for example, *+* and <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>)
    for numerical expressions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: YARA 规则的最后一个也是唯一一个必需的部分被称为条件。*条件*是支持布尔运算符（例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">AND</samp>）、关系运算符（例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>=）以及用于数值表达式的算术和按位运算符（例如
    *+* 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>）的布尔表达式。
- en: 'Conditions can work with strings defined in the rule while scanning the file.
    For example, the SafetyKatz rule makes sure that the TypeLib GUID is present in
    the file. But conditions can also work without the use of strings. The first two
    conditions in the SafetyKatz rule check for the two-byte value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x4D5A</samp>
    (the MZ header of a Windows executable) at the start of the file and the four-byte
    value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00004550</samp> (the PE
    signature) at offset <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3C</samp>.
    Conditions can also operate using special reserved variables. For example, here
    is a condition that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">filesize</samp>
    special variable: <samp class="SANS_TheSansMonoCd_W5Regular_11">filesize</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">30KB</samp>.
    It will return true if the total file size is less than 30KB.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 条件可以在扫描文件时与规则中定义的字符串一起工作。例如，SafetyKatz 规则确保文件中存在 TypeLib GUID。但是，条件也可以在不使用字符串的情况下工作。SafetyKatz
    规则中的前两个条件检查文件开始处的两个字节值 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x4D5A</samp>（Windows
    可执行文件的 MZ 头）和偏移位置 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3C</samp> 处的四字节值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00004550</samp>（PE 签名）。条件也可以使用特殊的保留变量。例如，以下条件使用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">filesize</samp> 特殊变量：<samp class="SANS_TheSansMonoCd_W5Regular_11">filesize</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">30KB</samp>。当文件总大小小于
    30KB 时，它会返回 true。
- en: Conditions can support more complex logic with additional operators. One example
    is the <samp class="SANS_TheSansMonoCd_W5Regular_11">of</samp> operator. Consider
    the example shown in [Listing 9-2](#list9-2).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 条件可以支持更复杂的逻辑，加入更多的操作符。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">of</samp>
    操作符。请参考 [列表 9-2](#list9-2) 中的示例。
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: Using YARA’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">of</samp>
    operator'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-2：使用 YARA 的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">of</samp>
    操作符
- en: This rule returns true if either the <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello"</samp>
    string or the <samp class="SANS_TheSansMonoCd_W5Regular_11">"world"</samp> string
    is found in the file being scanned. Other operators exist, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">all
    of</samp>, for when all strings must be present; <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">of</samp>, for when some subset
    of the strings must be present; and the <samp class="SANS_TheSansMonoCd_W5Regular_11">for…of</samp>
    iterator, to express that only some occurrences of the string should satisfy the
    rule’s conditions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果扫描的文件中找到 <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello"</samp> 字符串或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"world"</samp> 字符串，则此规则返回 true。还有其他操作符，例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">all of</samp>，表示必须包含所有字符串；<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">of</samp>，表示必须包含字符串的某些子集；以及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for…of</samp> 迭代器，用于表示仅某些字符串的出现应满足规则的条件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reverse Engineering
    Rules</samp>
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">逆向工程规则</samp>
- en: In production environments, you’ll commonly find hundreds or even thousands
    of rules analyzing files correlating to malware signatures. There are over 200,000
    signatures in Defender alone, as shown in [Listing 9-3](#list9-3).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，您通常会发现数百甚至数千条规则分析与恶意软件签名相关的文件。仅 Defender 中就有超过 200,000 个签名，如 [列表 9-3](#list9-3)
    所示。
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-3: Enumerating signatures in Defender'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-3：在 Defender 中列举签名
- en: The first command extracts the *threat names*, a way of identifying specific
    or closely related pieces of malware (for example, *VirTool:MSIL/BytzChk.C!MTB*),
    from Defender’s signature catalog. The second command then parses each threat
    name for its top-level category (for example, *VirTool*) and returns a count of
    all signatures belonging to the top levels.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令提取 *威胁名称*，即识别特定或紧密相关的恶意软件（例如，*VirTool:MSIL/BytzChk.C!MTB*）的方法，来自 Defender
    的签名目录。第二个命令随后解析每个威胁名称的顶层类别（例如，*VirTool*），并返回属于这些顶层类别的所有签名的数量。
- en: To the user, however, most of these rules are opaque. Often, the only way to
    figure out what causes one sample to be flagged as malicious and another to be
    deemed benign is manual testing. The DefenderCheck tool helps automate this process.
    [Figure 9-4](#fig9-4) shows a contrived example of how this tool works under the
    hood.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对用户而言，大多数这些规则都是不透明的。通常，唯一能弄清楚为什么一个样本被标记为恶意而另一个被认为是良性的方式就是手动测试。DefenderCheck工具有助于自动化这个过程。[图9-4](#fig9-4)展示了这个工具在幕后工作的一个构造示例。
- en: '![](../images/Figure9-4.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: DefenderCheck’s
    binary search</samp>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-4：DefenderCheck的二分查找</samp>
- en: DefenderCheck splits a file in half, then scans each half to determine which
    one holds the content that the scanner deemed malicious. It recursively repeats
    this process on every malicious half until it has identified the specific byte
    at the center of the rule, forming a simple binary search tree.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: DefenderCheck将文件分成两半，然后扫描每一半以确定哪一部分包含扫描器认为是恶意的内容。它会递归地重复这个过程，直到找出规则中心的具体字节，形成一个简单的二分查找树。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Scanner Signatures</samp>
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避扫描器签名</samp>
- en: When trying to evade detection by a file-based scanner such as YARA, attackers
    typically attempt to generate false negatives. In short, if they can figure out
    what rules the scanner is employing to detect some relevant file (or at least
    make a satisfactory guess at this), they can potentially modify that attribute
    to evade the rule. The more brittle the rule, the easier it is to evade. In [Listing
    9-4](#list9-4), we use dnSpy, a tool for decompiling and modifying .NET assemblies,
    to change the GUID in the compiled SafetyKatz assembly so that it evades the brittle
    YARA rule shown earlier in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图规避像YARA这样的基于文件的扫描器时，攻击者通常会尝试制造假阴性。简而言之，如果他们能弄清楚扫描器用来检测某个相关文件的规则（或者至少做出一个满意的猜测），他们就可以修改该属性来规避规则。规则越脆弱，越容易被规避。在[清单9-4](#list9-4)中，我们使用dnSpy，一个用于反编译和修改.NET程序集的工具，修改编译后的SafetyKatz程序集中的GUID，以便规避本章早些时候展示的脆弱YARA规则。
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-4: Modifying the GUID in the assembly using dnSpy'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-4：使用dnSpy修改程序集中的GUID
- en: If a detection is built solely around the presence of SafetyKatz’s default assembly
    GUID, the change made to the GUID here ❶ would evade the rule entirely.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检测规则仅仅是基于SafetyKatz默认程序集GUID的存在，那么这里对GUID所做的修改❶将完全规避该规则。
- en: This simple evasion highlights the importance of building detections based on
    a sample’s immutable attributes (or at least those that are more difficult to
    modify) to compensate for the more brittle rules. This is not to discount the
    value of these brittle rules, which could detect off-the-shelf Mimikatz, a tool
    very rarely used for legitimate purposes. However, adding a more robust companion
    (one whose false-positive rate is higher and false-negative rate is lower) fortifies
    the scanner’s ability to detect samples that have been modified to evade the existing
    rules. [Listing 9-5](#list9-5) shows an example of this using SafetyKatz.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的规避手段突显了基于样本不可变属性（或者至少是那些更难修改的属性）构建检测规则的重要性，以弥补更脆弱规则的不足。这并不是要否定这些脆弱规则的价值，因为它们可以检测到现成的Mimikatz，一个极少用于合法目的的工具。然而，增加一个更稳健的伴随规则（其假阳性率较高，假阴性率较低）可以增强扫描器检测已被修改以规避现有规则的样本的能力。[清单9-5](#list9-5)展示了一个使用SafetyKatz的示例。
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 9-5: YARA rule to detect SafetyKatz based on internal function names
    and Base64 substrings'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-5：基于内部函数名称和Base64子字符串的YARA规则，用于检测SafetyKatz
- en: You could pass this rule to YARA via the command line to scan the base version
    of SafetyKatz, as is shown in [Listing 9-6](#list9-6).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过命令行将此规则传递给YARA，扫描SafetyKatz的基础版本，如[清单9-6](#list9-6)所示。
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 9-6: Detecting SafetyKatz using the new YARA rule'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-6：使用新的YARA规则检测SafetyKatz
- en: In the YARA output, we can see that the scanner detected both the suspicious
    functions ❶ and Base64 substring ❷.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在YARA输出中，我们可以看到扫描器检测到可疑的函数❶和Base64子字符串❷。
- en: But even this rule isn’t a silver bullet against evasion. An attacker could
    further modify the attributes from which we’ve built the detection, such as by
    moving from P/Invoke, the native way of calling unmanaged code from .NET, to D/Invoke,
    an alternative to P/Invoke that performs the same function, avoiding the suspicious
    P/Invokes that an EDR may be monitoring for. They could also use syscall delegates
    or modify the embedded copy of Mimikatz such that the first 32 bytes of its encoded
    representation differ from that in the rule.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使这一规则也不是对规避的万全之策。攻击者可能进一步修改我们构建检测的属性，例如通过从P/Invoke（.NET中调用非托管代码的本地方式）切换到D/Invoke，D/Invoke是P/Invoke的一种替代方式，执行相同的功能，避免EDR可能正在监控的可疑P/Invoke调用。他们还可以使用系统调用委托，或者修改Mimikatz的嵌入式副本，使其编码表示的前32个字节与规则中的不同。
- en: There is one other way to avoid detection by scanners. In modern red teaming,
    most adversaries avoid touching disk (writing files to the filesystem). If they
    can operate entirely in memory, file-based scanners no longer pose a concern.
    For example, consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">/ticket:base64</samp>
    command line option in Rubeus, a tool for interacting with Kerberos. By using
    this flag, attackers can prevent a Kerberos ticket from being written to the target’s
    filesystem and instead have it returned through console output.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种避免被扫描器检测到的方法。在现代红队演练中，大多数对手避免写入磁盘（写文件到文件系统）。如果他们能够完全在内存中操作，基于文件的扫描器就不再构成问题。例如，考虑Rubeus中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/ticket:base64</samp>命令行选项，Rubeus是一个用于与Kerberos交互的工具。通过使用这个标志，攻击者可以防止Kerberos票据被写入目标的文件系统，而是通过控制台输出返回。
- en: In some situations, attackers can’t avoid writing files to disk, such as in
    the case of SafetyKatz’s use of <samp class="SANS_TheSansMonoCd_W5Regular_11">dbghelp!MiniDumpWriteDump()</samp>,
    which requires the memory dump to be written to a file. In these situations, it’s
    important for attackers to limit the exposure of their files. This most commonly
    means immediately retrieving a copy of the files and removing them from the target,
    obscuring filenames and paths, or protecting the content of the file in some way.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，攻击者无法避免将文件写入磁盘，例如在SafetyKatz使用<samp class="SANS_TheSansMonoCd_W5Regular_11">dbghelp!MiniDumpWriteDump()</samp>时，该函数要求将内存转储写入文件。在这些情况下，攻击者必须限制文件的暴露。这通常意味着立即获取文件的副本并将其从目标中删除，模糊文件名和路径，或以某种方式保护文件内容。
- en: While potentially less sophisticated than other sensors, scanners play an important
    part in detecting malicious content on the host. This chapter covers only file-based
    scanners, but commercial projects frequently employ other types, including network-based
    and memory scanners. At an enterprise scale, scanners can also offer interesting
    metrics, such as whether a file is globally unique. They present a particular
    challenge for adversaries and serve as a great representation of evasion in general.
    You can think of them as black boxes through which adversary tooling passes; the
    adversary’s job is to modify the attributes within their control, namely the elements
    of their malware, to make it to the other end.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然扫描器可能不如其他传感器复杂，但它们在检测宿主上的恶意内容方面发挥着重要作用。本章仅涵盖基于文件的扫描器，但商业项目通常会使用其他类型的扫描器，包括基于网络的和内存扫描器。在企业规模上，扫描器还可以提供有趣的指标，例如文件是否在全球范围内唯一。它们对对手构成特别的挑战，并且在规避方面具有重要代表性。你可以把它们看作是对手工具通过的黑箱；对手的任务是修改其控制范围内的属性，即恶意软件的元素，使其能够顺利通过。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: Scanners, especially those related to antivirus engines, are one of the first
    defensive technologies many of us encounter. Though they fell out of favor due
    to the brittleness of their rulesets, they have recently regained popularity as
    a supplemental feature, employing (at times) more robust rules than other sensors
    such as minifilters and image-load callback routines. Still, evading scanners
    is an exercise in obfuscation rather than avoidance. By changing indicators, even
    simple things like static strings, an adversary can usually fly under the radar
    of most modern scanning engines.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描器，特别是与杀毒引擎相关的扫描器，是我们许多人最先接触到的防御技术之一。虽然由于规则集的脆弱性，它们曾一度失宠，但最近它们作为辅助功能重新流行，采用（有时）比其他传感器如微滤器和映像加载回调例程更强健的规则。然而，规避扫描器更多的是一种模糊化的练习，而非避免。通过更改指标，即使是简单的东西，如静态字符串，对手通常也能避开大多数现代扫描引擎的雷达。
