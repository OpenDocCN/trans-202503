<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_77"/><strong><span class="big">3</span><br/>MEMOIZATION AND DYNAMIC PROGRAMMING</strong></h2>
<div class="image1"><img alt="Image" src="../images/common1.jpg"/></div>
<p class="noindenta">In this chapter, we’ll study three problems that appear to be solvable using recursion. As you’ll see, while in theory we can use recursion, in practice it leads to an explosion of work that renders the problems unsolvable. Not to worry: you’ll learn two powerful, related techniques, called memoization and dynamic programming, that will lead to shocking performance increases, morphing runtimes from hours or days to seconds. In the next chapter, we’ll level up and solve two even more challenging problems using these techniques. Once you get the hang of this stuff, you’ll be able to solve hundreds of other programming problems as well. If you’re going to read one chapter in this book, read this one.</p>
<h3 class="h3" id="lev22"><span epub:type="pagebreak" id="page_78"/>Problem 1: Burger Fervor</h3>
<p class="noindent">This is UVa problem <code>10465</code>.</p>
<h4 class="h4" id="sec35"><em>The Problem</em></h4>
<p class="noindent">A man named Homer Simpson likes to eat and drink. He has <em>t</em> minutes that he’ll spend eating burgers and drinking beer. There are two kinds of burgers. One of them takes <em>m</em> minutes to eat, and the other takes <em>n</em> minutes to eat.</p>
<p class="indent">Homer likes burgers more than beer, so he’d like to spend the entire <em>t</em> minutes eating burgers. However, doing so isn’t always possible. For example, if <em>m</em> = 4, <em>n</em> = 9, and <em>t</em> = 15, then no combination of the 4-minute and 9-minute burgers can take him exactly 15 minutes to eat. In such a case, he’ll spend as much time as possible eating burgers and then fill the rest of the time drinking beer. Our task is to determine the number of burgers that Homer can eat.</p>
<h5 class="h5">Input</h5>
<p class="noindent">We read test cases until there is no more input. Each test case is represented by a line of three integers: <em>m</em>, the number of minutes it takes to eat the first kind of burger; <em>n</em>, the number of minutes it takes to eat the second kind of burger; and <em>t</em>, the number of minutes that Homer will spend eating burgers and drinking beer. Each <em>m</em>, <em>n</em>, and <em>t</em> value is less than 10,000.</p>
<h5 class="h5">Output</h5>
<p class="noindent">For each test case:</p>
<ul>
<li class="noindent">If Homer can spend exactly <em>t</em> minutes eating burgers, then output the maximum number of burgers that he can eat.</li>
<li class="noindent">Otherwise, output the maximum number of burgers that Homer can eat when maximizing his time eating burgers, a space, and the number of remaining minutes (during which he’ll drink beer).</li>
</ul>
<p class="indent">The time limit for solving the test cases is three seconds.</p>
<h4 class="h4" id="sec36"><em>Forming a Plan</em></h4>
<p class="noindent">Let’s start by thinking about a few different test cases. Here’s the first one:</p>
<pre>4 9 22</pre>
<p class="indent">Here, the first kind of burger takes 4 minutes to eat (<em>m</em> = 4), the second kind of burger takes 9 minutes to eat (<em>n</em> = 9), and Homer has 22 minutes to spend (<em>t</em> = 22). This is an example in which Homer can fill the entire time by eating burgers. The maximum number of burgers that Homer can eat here is three, so <code>3</code> is the correct output for this test case.</p>
<p class="indent">The three burgers that Homer should eat are one 4-minute burger and two 9-minute burgers. This takes him 1 × 4 + 2 × 9 = 22 minutes, as required. <span epub:type="pagebreak" id="page_79"/>Notice, though, that we are <em>not</em> being asked to indicate the number of each kind of burger he should eat. All we’re asked to do is output the total number of burgers. When I provide the number of each kind of burger below, I do so only to offer evidence that the proposed output makes sense.</p>
<p class="indent">Here’s another test case:</p>
<pre>4 9 54</pre>
<p class="indent">Again, Homer can fill the entire time with burgers. The correct output here is <code>11</code>, obtained by eating nine 4-minute burgers and two 9-minute burgers. Unlike the <code>4 9 22</code> test case, here Homer has multiple ways to spend exactly 54 minutes eating burgers. For example, he could eat six 9-minute burgers—that fills up the 54 minutes, too—but, remember, if we can fill the entire <code>t</code> minutes, then we want to output the <em>maximum</em> number of burgers.</p>
<p class="indent">As noted in the problem description, it’s not always possible for Homer to completely fill the <em>t</em> minutes by eating burgers. Let’s study the example that I gave there as our next test case:</p>
<pre>4 9 15</pre>
<p class="indent">How many burgers should Homer eat here? He can eat a maximum of three burgers by eating three 4-minute burgers. By doing so, Homer would spend 12 minutes eating burgers, and he would have to spend the remaining 15 – 12 = 3 minutes drinking beer. So, he eats three burgers and has three minutes’ beer-drinking time, making the output <code>3 3</code>. Have we solved this test case?</p>
<p class="indent">We have not! Carefully reread the problem description and zone in on this: “output the maximum number of burgers that Homer can eat when maximizing his time eating burgers.” That is, when Homer cannot fill the entire time by eating burgers, we want to maximize the <em>time</em> that he spends eating burgers and then the maximum number of burgers he can eat in that time. The correct output for <code>4 9 15</code> is in fact <code>2 2</code>: the first <code>2</code> means that he eats two burgers (one 4-minute burger and one 9-minute burger, for a total of 13 minutes) and the second <code>2</code> means that he has to spend 2 minutes (15 – 13) drinking beer.</p>
<p class="indent">In the <code>4 9 22</code> and <code>4 9 54</code> test cases, we’re asked to solve the problem for 22 and 54 minutes, respectively. We found that there is indeed a way to spend the entire time eating burgers, so we can report the maximum number of burgers as our solution. However, in the <code>4 9 15</code> case, we found that there is no way to completely fill the 15 minutes by eating burgers. Thinking ahead to our code, how are we going to handle this? How will we be able to conclude that the answer is <code>2 2</code>?</p>
<p class="indent">One idea is that we can next try to fill exactly 14 minutes with the 4-minute and 9-minute burgers. If we succeed, then we have our answer: we report the maximum number of burgers that Homer can eat in exactly 14 minutes, followed by 1, the number of minutes Homer spends drinking beer. This would maximize the amount of time that Homer can spend eating burgers. We already know that eating burgers for exactly 15 minutes is impossible, so 14 minutes is the next best option.</p>
<p class="indent"><span epub:type="pagebreak" id="page_80"/>Let’s see if 14 minutes works. Can we fill exactly 14 minutes with the 4-minute and 9-minute burgers? No! Like the 15-minute case, this will be impossible.</p>
<p class="indent">We can, though, fill exactly 13 minutes by eating two burgers: one 4-minute burger and one 9-minute burger. That leaves Homer two minutes for drinking beer. This justifies <code>2 2</code> as the correct output.</p>
<p class="indent">In summary, our plan is to determine whether Homer can eat burgers for exactly <em>t</em> minutes. If he can, then we’re done: we report the maximum number of burgers he can eat. If he can’t, then we next determine whether Homer can eat burgers for exactly <em>t</em> – 1 minutes. If he can, then we’re done, and we report the maximum number of burgers he can eat and the number of minutes spent drinking beer. If he can’t, then we will move on to trying <em>t</em> – 2 minutes, then <em>t</em> – 3 minutes, and so on, stopping when the time can be completely filled by eating burgers.</p>
<h4 class="h4" id="sec37"><em>Characterizing Optimal Solutions</em></h4>
<p class="noindent">Consider the <code>4 9 22</code> test case. Whatever combination of burgers and beer we propose as the solution better take exactly 22 minutes, and it better actually be doable using the 4-minute and 9-minute burgers. Such a solution, which adheres to the rules of a problem, is called a <em>feasible</em> solution. A solution attempt that does not follow the rules is called an <em>infeasible</em> solution. For example, having Homer spend 4 minutes eating burgers and 18 minutes drinking beer is feasible. Having Homer spend 8 minutes eating burgers and 18 minutes drinking beer is infeasible, because 8 + 18 is not 22. Having Homer spend 5 minutes eating burgers and 17 minutes drinking beer is also infeasible, because there’s no way we can use the 4-minute and 9-minute burgers to get a total of 5 minutes of burger time.</p>
<p class="indent">Burger Fervor is an <em>optimization problem</em>. An optimization problem involves choosing the best—that is, <em>optimal</em>—solution out of all feasible solutions. There may be many feasible solutions of varying quality. Some will be really poor, such as drinking beer for 22 minutes. Others will be close to but not quite optimal—maybe they’re off by one or two. And, of course, some of them will be optimal. Our goal is to identify an optimal solution among all possible solutions.</p>
<p class="indent">Suppose we’re solving a case where the first kind of burger takes <em>m</em> minutes to eat, the second kind of burger takes <em>n</em> minutes to eat, and we want to try to spend <em>exactly t</em> minutes eating burgers.</p>
<p class="indent">If <em>t</em> = 0, then the correct output is <code>0</code>, because we can fill the entire 0 minutes by eating zero burgers. As we continue, we’ll therefore focus on what to do when <em>t</em> is greater than 0.</p>
<p class="indent">Let’s think about what an optimal solution for <em>t</em> minutes must look like. Of course, we can’t possibly know anything specific, such as “Homer eats a 4-minute burger, then a 9-minute burger, then another 9-minute burger, then . . . ” We haven’t done anything yet to solve the problem, so obtaining this level of detail is wishful thinking.</p>
<p class="indent">There is, however, something we can say that’s not wishful thinking. It’s at once so inane that you’d be forgiven for wondering why I am stating it at <span epub:type="pagebreak" id="page_81"/>all and so powerful that at its core lies a solution strategy for a bewildering number of optimization problems.</p>
<p class="indent">Here it is: Suppose that Homer can fill exactly <em>t</em> minutes by eating burgers. (If this supposition ends up being wrong, then we’ll try it again with <em>t</em> – 1 minutes, then <em>t</em> – 2 minutes, and so on.) The final burger that he eats, the one that finishes off his <em>t</em> minutes, must be an <em>m</em>-minute burger or an <em>n</em>-minute burger.</p>
<p class="indent">How could that final burger be anything else? Homer can only eat <em>m</em>-minute and <em>n</em>-minute burgers, so there are only two choices for the last burger that he eats and so two choices for what the end of the optimal solution must look like.</p>
<p class="indent">If we know that the final burger that Homer eats in an optimal solution is an <em>m</em>-minute burger, we know he has <em>t</em> – <em>m</em> minutes left to spend. There must be a way to fill those <em>t</em> – <em>m</em> minutes with burgers, without drinking any beer: remember that we are assuming that Homer can spend the entire <em>t</em> minutes by eating burgers. If we could spend those <em>t</em> – <em>m</em> minutes optimally, with Homer eating the maximum number of burgers, then we’d have an optimal solution to the original problem of <em>t</em> minutes. We’d take the number of burgers that he can eat in <em>t</em> – <em>m</em> minutes and add one <em>m</em>-minute burger to fill the remaining <em>m</em> minutes.</p>
<p class="indent">Now, what if we knew that the final burger that Homer eats in an optimal solution is an <em>n</em>-minute burger? Then he has <em>t</em> – <em>n</em> minutes left to spend. Again, by virtue of the entire <em>t</em> minutes being spent eating burgers, we know that it must be possible for Homer to eat burgers for the first <em>t</em> – <em>n</em> of those minutes. If we could spend those <em>t</em> – <em>n</em> minutes optimally, then we’d have an optimal solution to the original problem of <em>t</em> minutes. We’d take the number of burgers that he can eat in <em>t</em> – <em>n</em> minutes and add one <em>n</em>-minute burger to fill the remaining <em>n</em> minutes.</p>
<p class="indent">Now we seem to be squarely in farce territory. We just assumed that we knew what the final burger was! However, there’s no way we could know this. We do know that the final burger is an <em>m</em>-minute burger <em>or</em> an <em>n</em>-minute burger. We definitely don’t know which it is.</p>
<p class="indent">The wonderful truth is that we don’t need to know. We can assume the final burger is an <em>m</em>-minute burger and solve the problem optimally given that choice. We then make the other choice—assume that the final burger is an <em>n</em>-minute burger—and solve the problem optimally given that choice. In the first case, we have a subproblem of <em>t</em> – <em>m</em> minutes to solve optimally; in the second case, we have a subproblem of <em>t</em> – <em>n</em> minutes to solve optimally. Whenever we have characterized a solution to a problem in terms of solutions to subproblems, we would do well to try a recursive approach as we did in <a href="ch02.xhtml">Chapter 2</a>.</p>
<h4 class="h4" id="sec38"><em>Solution 1: Recursion</em></h4>
<p class="noindent">Let’s attempt a recursive solution. We’ll begin by writing a helper function to solve for exactly <em>t</em> minutes. Once we’re done, we’ll rely on it to write a function that solves for exactly <em>t</em> minutes, <em>t</em> – 1 minutes, <em>t</em> – 2 minutes, and so on, until we can completely fill some number of minutes with burgers.</p>
<span epub:type="pagebreak" id="page_82"/>
<h5 class="h5">The Helper Function: Solving for the Number of Minutes</h5>
<p class="noindent">To solve each problem and subproblem instance, we need three things: <em>m</em> and <em>n</em> from the test case and the <em>t</em> value for the current instance. We’ll therefore write the body of the following function:</p>
<pre>int solve_t(int m, int n, int t)</pre>
<p class="indent">If Homer can spend exactly <code>t</code> minutes eating burgers, then we’ll return the maximum number of burgers he can eat. If he can’t spend exactly <code>t</code> minutes eating burgers—meaning he must spend at least one minute drinking beer—then we’ll return <code>-1</code>. A return value of <code>0</code> or more means that we’ve solved the problem using burgers alone; a return value of <code>-1</code> means that the problem cannot be solved using burgers alone.</p>
<p class="indent">If we call <code>solve_t(4, 9, 22)</code>, we expect to get <code>3</code> as the return value: three is the maximum number of burgers that Homer can eat in exactly 22 minutes. If we call <code>solve_t(4, 9, 15)</code>, we expect to get <code>-1</code> as the return value: there’s no combination of 4-minute and 9-minute burgers that gives us exactly 15 minutes.</p>
<p class="indent">We’ve already settled on what to do when <em>t</em> = 0: in this case, we have 0 minutes to spend, and we do so by having Homer eat zero burgers:</p>
<pre>if (t == 0)
  return 0;</pre>
<p class="indent">That’s the base case of our recursion. To implement the rest of this function, we need the analysis from the last section. Remember that, to solve the problem for exactly <em>t</em> minutes, we think about the final burger that Homer eats. Maybe it’s an <em>m</em>-minute burger. To check that possibility, we solve the subproblem for exactly <em>t</em> – <em>m</em> minutes. Of course, the final burger can only be an <em>m</em>-minute burger if we’ve got at least <em>m</em> minutes to spend. This logic can be coded as follows:</p>
<pre>int first;
if (t &gt;= m)
  first = solve_t(m, n, t - m);
else
  first = -1;</pre>
<p class="indent">We use <code>first</code> to store the optimal solution to the <code>t - m</code> subproblem, with <code>-1</code> indicating “no solution.” If <code>t &gt;= m</code>, then there’s a chance that an <em>m</em>-minute burger is the final one, so we make a recursive call to compute the optimal number of burgers that Homer can eat in exactly <code>t - m</code> minutes. That recursive call will return a number greater than <code>-1</code> if it can be solved exactly or <code>-1</code> if it can’t. If <code>t &lt; m</code>, then there’s no recursive call to make: we set <code>first = -1</code> to signify that an <em>m</em>-minute burger isn’t the final burger and that it can’t participate in an optimal solution for exactly <code>t</code> minutes.</p>
<p class="indent">Now, what about when an <em>n</em>-minute burger is the final burger? The code for this case is analogous to the <em>m</em>-minute burger case, this time storing the result in the variable <code>second</code> instead of <code>first</code>:</p>
<span epub:type="pagebreak" id="page_83"/>
<pre>int second;
if (t &gt;= n)
  second = solve_t(m, n, t - n);
else
  second = -1;</pre>
<p class="indent">Let’s summarize our current progress:</p>
<ul>
<li class="noindent">The variable <code>first</code> is the solution to the <code>t - m</code> subproblem. If it’s <code>-1</code>, then we can’t completely fill <code>t - m</code> minutes with burgers. If it’s anything else, then it gives the optimal number of burgers that Homer can eat in exactly <code>t - m</code> minutes.</li>
<li class="noindent">The variable <code>second</code> is the solution to the <code>t - n</code> subproblem. If it’s <code>-1</code>, then we can’t completely fill <code>t - n</code> minutes with burgers. If it’s anything else, then it gives the optimal number of burgers that Homer can eat in exactly <code>t - n</code> minutes.</li>
</ul>
<p class="indent">There’s a chance that both <code>first</code> and <code>second</code> have values of <code>-1</code>. A value of <code>-1</code> for <code>first</code> means that an <em>m</em>-minute burger can’t be the final burger. A value of <code>-1</code> for <code>second</code> means that an <em>n</em>-minute burger can’t be the final burger. If the final burger can’t be an <em>m</em>-minute burger and can’t be an <em>n</em>-minute burger, then we’re out of options and have to conclude that there’s no way to solve the problem for exactly <code>t</code> minutes:</p>
<pre>if (first == -1 &amp;&amp; second == -1)
  return -1;</pre>
<p class="indent">Otherwise, if <code>first</code> or <code>second</code> or both are greater than <code>-1</code>, then we can build at least one solution for exactly <code>t</code> minutes. In this case, we start with the maximum of <code>first</code> and <code>second</code> to choose the better subproblem solution. If we add one to that maximum, thereby incorporating the final burger, then we obtain the maximum for the original problem of exactly <code>t</code> minutes:</p>
<pre>return max(first, second) + 1;</pre>
<p class="indent">The full function is given in <a href="ch03.xhtml#ch03ex01">Listing 3-1</a>.</p>
<pre>int max(int v1, int v2) {
  if (v1 &gt; v2)
    return v1;
  else
    return v2;
}

int solve_t(int m, int n, int t) {
  int first, second;
  if (t == 0)
    return 0;
  if (t &gt;= m)
  <span epub:type="pagebreak" id="page_84"/><span class="ent">❶</span> first = solve_t(m, n, t - m);
   else
     first = -1;
   if (t &gt;= n)
  <span class="ent">➋</span> second = solve_t(m, n, t - n);
   else
    second = -1;
  if (first == -1 &amp;&amp; second == -1)
  <span class="ent">➌</span> return -1;
   else
  <span class="ent">➍</span> return max(first, second) + 1;
}</pre>
<p class="excap" id="ch03ex01"><em>Listing 3-1: Solving for exactly t minutes</em></p>
<p class="indent">It’s worth spending a few minutes getting a feel for what the function does—even if you’re already convinced of its correctness.</p>
<p class="indent">Let’s begin with <code>solve_t(4, 9, 22)</code>. The recursive call for <code>first</code> <span class="ent">❶</span> solves the subproblem for 18 minutes (22 – 4). That recursive call returns <code>2</code>, because two is the maximum number of burgers that Homer can eat in exactly 18 minutes. The recursive call for <code>second</code> <span class="ent">➋</span> solves the subproblem for 13 minutes (22 – 9). That recursive call returns <code>2</code> as well, because two is the maximum number of burgers that Homer can eat in exactly 13 minutes. That is, both <code>first</code> and <code>second</code> are <code>2</code> in this case; tacking on the final four-minute or nine-minute burger gives a solution of <code>3</code> <span class="ent">➍</span> for the original problem of exactly 22 minutes.</p>
<p class="indent">Let’s now try <code>solve_t(4, 9, 20)</code>. The recursive call for <code>first</code> <span class="ent">❶</span> solves the subproblem for 16 minutes (20 – 4) and yields <code>4</code> as a result, but what about the recursive call for <code>second</code> 	<span class="ent">➋</span>? Well, that one is asked to solve the subproblem for 11 minutes (20 – 9), but there is no way to spend exactly 11 minutes by eating 4-minute and 9-minute burgers! Thus this second recursive call returns <code>-1</code>. The maximum of <code>first</code> and <code>second</code> is therefore <code>4</code> (the value of <code>first</code>), and so we return <code>5</code> <span class="ent">➍</span>.</p>
<p class="indent">So far we’ve seen an example where the two recursive calls both give subproblem solutions with the same number of burgers and an example where only one recursive call gives a subproblem solution. Now let’s look at a case where each recursive call returns a subproblem solution, but where one is better than the other! Consider <code>solve_t(4, 9, 36)</code>. The recursive call for <code>first</code> <span class="ent">❶</span> yields <code>8</code>, the maximum number of burgers that Homer can eat in exactly 32 minutes (36 – 4). The recursive call for <code>second</code> <span class="ent">➋</span> yields <code>3</code>, the maximum number of burgers that Homer can eat in exactly 27 minutes (36 – 9). The maximum of <code>8</code> and <code>3</code> is <code>8</code>, and so we return <code>9</code> as the overall solution <span class="ent">➍</span>.</p>
<p class="indent">Finally, try <code>solve_t(4, 9, 15)</code>. The recursive call for <code>first</code> <span class="ent">❶</span> is asked to solve for exactly 11 minutes (15 – 4) and, since this is impossible with these kinds of burger, returns <code>-1</code>. The result for the <code>second</code> recursive call <span class="ent">➋</span> is similar: solving for exactly 6 minutes (15 – 9) is impossible, so it also returns <code>-1</code>. There is therefore no way to solve for exactly 15 minutes, so we return <code>-1</code> <span class="ent">➌</span>.</p>
<span epub:type="pagebreak" id="page_85"/>
<h5 class="h5">The solve and main Functions</h5>
<p class="noindent">Recall from “Forming a Plan” on <a href="#sec36">page 78</a> that if we can fill exactly <em>t</em> minutes by eating burgers, then we output the maximum number of burgers. Otherwise, Homer has to spend at least one minute drinking beer. To figure out the number of minutes that he must spend drinking beer, we try to solve for exactly <em>t</em> – 1 minutes, <em>t</em> – 2 minutes, and so on, until we find a number of minutes that can be filled by eating burgers. Happily, with our <code>solve_t</code> function, we can set the <code>t</code> parameter to whatever we want. We can start at the given value of <code>t</code> and then, as needed, make calls on <code>t - 1</code>, <code>t - 2</code>, and so on. We effect this plan in <a href="ch03.xhtml#ch03ex02">Listing 3-2</a>.</p>
<pre>void solve(int m, int n, int t) {
  int result, i;
<span class="ent">❶</span> result = solve_t(m, n, t);
   if (result &gt;= 0)
  <span class="ent">➋</span> printf("%d\n", result);
   else {
     i = t - 1;
  <span class="ent">➌</span> result = solve_t(m, n, i);
     while (result == -1) {
       i--;
     <span class="ent">➍</span> result = solve_t(m, n, i);
     }
  <span class="ent">➎</span> printf("%d %d\n", result, t - i);
  }
}</pre>
<p class="excap" id="ch03ex02"><em>Listing 3-2: Solution 1</em></p>
<p class="indent">First, we solve the problem for exactly <code>t</code> minutes <span class="ent">❶</span>. If our result is at least zero, then we output the maximum number of burgers <span class="ent">➋</span> and stop.</p>
<p class="indent">If it wasn’t possible for Homer to eat burgers for the entire <code>t</code> minutes, we set <code>i</code> to <code>t - 1</code>, since <code>t - 1</code> is the next-best number of minutes that we should try. We then solve the problem for this new value of <code>i</code> <span class="ent">➌</span>. If we don’t get a value of <code>-1</code>, we’re successful and the <code>while</code> loop is skipped. If we’re not successful, the <code>while</code> loop executes until we successfully solve a subproblem. Inside the <code>while</code> loop, we decrement the value of <code>i</code> and solve that smaller subproblem <span class="ent">➍</span>. The <code>while</code> loop will eventually terminate; for example, we can certainly fill zero minutes with burgers. Once we escape the <code>while</code> loop, we’ve found the largest number of minutes, <code>i</code>, that can be filled by burgers. At that point, <code>result</code> will hold the maximum number of burgers, and <code>t - i</code> is the number of minutes that remain, so we output both values <span class="ent">➎</span>.</p>
<p class="indent">That’s that. We use recursion in <code>solve_t</code> to solve for <code>t</code> exactly. We tested <code>solve_t</code> on different kinds of test cases, and everything looked good. Not being able to solve for exactly <code>t</code> poses no problem: we use a loop inside of <code>solve</code> to try the minutes one by one, from largest to smallest. All we need now is a <code>main</code> function to read the input and call <code>solve</code>; <a href="ch03.xhtml#ch03ex03">Listing 3-3</a> provides the code.</p>
<span epub:type="pagebreak" id="page_86"/>
<pre>int main(void) {
  int m, n, t;
  while (scanf("%d%d%d", &amp;m, &amp;n, &amp;t) != -1)
    solve(m, n, t);
  return 0;
}</pre>
<p class="excap" id="ch03ex03"><em>Listing 3-3: The main function</em></p>
<p class="indent">Ah, a harmonious moment. We’re now ready to submit Solution 1 to the judge. Please do that now. I’ll wait . . . and wait . . . and wait.</p>
<h4 class="h4" id="sec39"><em>Solution 2: Memoization</em></h4>
<p class="noindent">Solution 1 fails, not because it’s incorrect, but because it’s too slow. If you submit Solution 1 to the judge, you’ll receive a “Time-Limit Exceeded” error. Remember the “Time-Limit Exceeded” error we received in Solution 1 of the Unique Snowflakes problem in <a href="ch01.xhtml">Chapter 1</a>? There, the inefficiency was emblematic of doing unnecessary work. Here, as we’ll soon see, the inefficiency does not lie in doing unnecessary work, but in doing necessary work over and over and over.</p>
<p class="indent">The problem description says that <em>t</em> can be any number of minutes less than 10,000. Surely, then, the following test case should pose no problem at all:</p>
<pre>4 2 88</pre>
<p class="indent">The <em>m</em> and <em>n</em> values, <code>4</code> and <code>2</code>, are very small. Relative to 10,000, the <em>t</em> value of <code>88</code> is very small as well. You may be surprised and disappointed that our code on this test case may not run within the three-second problem time limit. On my laptop, it takes about 10 seconds. That’s 10 seconds on a puny <code>88</code> test case. While we’re at it, let’s try this slightly bigger test case:</p>
<pre>4 2 90</pre>
<p class="indent">All we did was increase <code>t</code> from <code>88</code> to <code>90</code>, but this small increase has a disproportionate effect on runtime: on my laptop, this test case takes about 18 seconds—almost double what the <code>88</code> test case takes! Testing with a <code>t</code> value of 92 just about doubles the runtime again, and so on and so on. No matter how fast the computer, you’re unlikely to ever make it to a <code>t</code> value of even 100. By extrapolating from this trend, we can see that it’s unfathomable how much time it would take to run our code on a test case where <code>t</code> is in the thousands. This kind of algorithm, in which a fixed increment in problem size leads to a doubling of runtime, is called an <em>exponential-time algorithm</em>.</p>
<p class="indent">We have established that our code is slow—but why? Where is the inefficiency?</p>
<span epub:type="pagebreak" id="page_87"/>
<h5 class="h5">Counting the Function Calls</h5>
<p class="noindent">I’m going to take Solution 1 and add some code that counts the number of times that <code>solve_t</code> is called; see <a href="ch03.xhtml#ch03ex04">Listing 3-4</a> for the new <code>solve_t</code> and <code>solve</code> functions. We now have a global variable <code>total_calls</code> that is initialized to <code>0</code> on entry to <code>solve</code> and is increased by <code>1</code> on every call of <code>solve_t</code>. That variable is of type <code>long long</code>; <code>long</code> or <code>int</code> simply isn’t big enough to capture the explosion of function calls.</p>
<pre>unsigned long long total_calls;

int solve_t(int m, int n, int t) {
  int first, second;
<span class="ent">❶</span> total_calls++;
   if (t == 0)
     return 0;
   if (t &gt;= m)
     first = solve_t(m, n, t - m);
   else
     first = -1;
   if (t &gt;= n)
     second = solve_t(m, n, t - n);
   else
     second = -1;
   if (first == -1 &amp;&amp; second == -1)
     return -1;
   else
     return max(first, second) + 1;
}

 void solve(int m, int n, int t) {
   int result, i;
<span class="ent">➋</span> total_calls = 0;
   result = solve_t(m, n, t);
   if (result &gt;= 0)
     printf("%d\n", result);
   else {
     i = t - 1;
     result = solve_t(m, n, i);
     while (result == -1) {
       i--;
       result = solve_t(m, n, i);
      }
      printf("%d %d\n", result, t - i);
   }
<span class="ent">➌</span> printf("Total calls to solve_t: %llu\n", total_calls);
 }</pre>
<p class="excap" id="ch03ex04"><em>Listing 3-4: Solution 1, instrumented</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_88"/>At the start of <code>solve_t</code>, we increase <code>total_calls</code> by <code>1</code> <span class="ent">❶</span> to count this function call. In <code>solve</code>, we initialize <code>total_calls</code> to <code>0</code> <span class="ent">➋</span> so that the count of calls is reset before each test case is processed. For each test case, the code prints the number of times that <code>solve_t</code> was called <span class="ent">➌</span>.</p>
<p class="indent">If we give it a go with this input:</p>
<pre>4 2 88
4 2 90</pre>
<p class="noindent">we get this as output:</p>
<pre>44
Total calls to solve_t: 2971215072
45
Total calls to solve_t: 4807526975</pre>
<p class="indent">We’ve made billions of calls!</p>
<p class="indent">Consider a given <em>m</em>, <em>n</em>, <em>t</em> test case. Our <code>solve_t</code> function has three parameters, but only the third parameter <em>t</em> ever changes. There are, therefore, only <em>t</em> + 1 different ways that <code>solve_t</code> can be called. For example, if <em>t</em> in a test case is <code>88</code>, then the only calls that can be made to <code>solve_t</code> are those with <em>t</em> values of <code>88</code>, <code>87</code>, <code>86</code>, and so on. Once we know the answer for some <em>t</em> value, such as <code>86</code>, there’s no reason to ever compute that answer again.</p>
<p class="indent">Of those billions of calls, only about 88 or 90 of them can be distinct. We conclude that the same subproblems are being solved a staggering number of times.</p>
<h5 class="h5">Remembering Our Answers</h5>
<p class="noindent">Here’s some intuition for the staggering number of calls we make. If we call <code>solve_t(4, 2, 88)</code>, it makes two recursive calls: one to <code>solve_t(4, 2, 86)</code> and the other to <code>solve_t(4, 2, 84)</code>. So far, so good. Now consider what will happen for the <code>solve_t(4, 2, 86)</code> call. It will make two recursive calls of its own, the first of which is <code>solve_t(4, 2, 84)</code>—exactly one of the recursive calls made by <code>solve_t(4, 2, 88)</code>! That <code>solve_t(4, 2, 84)</code> work will therefore be performed twice. Once would have been enough!</p>
<p class="indent">However, the imprudent duplication is only just beginning. Consider the two <code>solve_t(4, 2, 84)</code> calls. By reasoning as in the previous paragraph, we see that each call eventually leads to two calls of <code>solve_t(4, 2, 80)</code>, for a total of four. Again, once would have been enough!</p>
<p class="indent">Well, it would have been enough if we had somehow remembered the answer from the first time we computed it. If we remember the answer to a call of <code>solve_t</code> the first time we compute it, we can just look it up later when we need that answer again.</p>
<p class="indent"><em>Remember, don’t refigure</em>. That’s the maxim of the <em>memoization</em> technique. Memoization comes from the word <em>memoize</em>, which means to store as if on a memo. It is a clunky word, sure, but one that’s in widespread use.</p>
<p class="indent">Using memoization involves three steps:</p>
<span epub:type="pagebreak" id="page_89"/>
<ol>
<li class="noindent">Declare an array large enough to hold the solutions to all possible subproblems. In Burger Fervor, <code>t</code> is less than 10,000, so an array of 10,000 elements suffices. This array is typically given the name <code>memo</code>.</li>
<li class="noindent">Initialize the elements of <code>memo</code> to a value reserved to mean “unknown value.”</li>
<li class="noindent">At the start of the recursive function, add code to check whether the subproblem solution has already been solved. This involves checking the corresponding index of <code>memo</code>: if the “unknown value” is there, then we have to solve this subproblem now; otherwise, the answer is already stored in <code>memo</code> and we simply return it, without doing any further recursion. Whenever we solve a new subproblem, we store its solution in <code>memo</code>.</li>
</ol>
<p class="indent">Let’s augment Solution 1 with memoization.</p>
<h5 class="h5">Implementing Memoization</h5>
<p class="noindent">The appropriate place to declare and initialize the <code>memo</code> array is in <code>solve</code>, since that’s the function that first gets triggered for each test case. We’ll use a value of <code>-2</code> to represent an unknown value; we can’t use positive numbers because those would be confused with numbers of burgers, and we can’t use <code>-1</code> because we’re already using <code>-1</code> to mean “no solution possible.” The updated <code>solve</code> function is given in <a href="ch03.xhtml#ch03ex05">Listing 3-5</a>.</p>
<pre> #define SIZE 10000

 void solve(int m, int n, int t) {
   int result, i;
<span class="ent">❶</span> int memo[SIZE];
   for (i = 0; i &lt;= t; i++)
     memo[i] = -2;
   result = solve_t(m, n, t, memo);
   if (result &gt;= 0)
     printf("%d\n", result);
   else {
     i = t - 1;
     result = solve_t(m, n, i, memo);
     while (result == -1) {
       i--;
       result = solve_t(m, n, i, memo);
     }
     printf("%d %d\n", result, t - i);
   }
 }</pre>
<p class="excap" id="ch03ex05"><em>Listing 3-5: Solution 2, with memoization implemented</em></p>
<p class="indent">We declare the <code>memo</code> array using the maximum possible size for any test case <span class="ent">❶</span>. Then we loop from <code>0</code> to <code>t</code> and set each element in the range to <code>-2</code>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_90"/>There’s also a small but important change in our calls to <code>solve_t</code>. Now we’re passing in <code>memo</code> along with the other arguments; in this way, <code>solve_t</code> can check <code>memo</code> to determine whether the current subproblem has already been solved and update <code>memo</code> if it has not.</p>
<p class="indent">The updated <code>solve_t</code> code is given in <a href="ch03.xhtml#ch03ex06">Listing 3-6</a>.</p>
<pre> int solve_t(int m, int n, int t, int memo[]) {
   int first, second;
<span class="ent">❶</span> if (memo[t] != -2)
     return memo[t];
   if (t == 0) {
     memo[t] = 0;
     return memo[t];
   }
   if (t &gt;= m)
     first = solve_t(m, n, t - m, memo);
   else
     first = -1;
   if (t &gt;= n)
     second = solve_t(m, n, t - n, memo);
   else
     second = -1;
   if (first == -1 &amp;&amp; second == -1) {
     memo[t] = -1;
     return memo[t];
   } else {
     memo[t] = max(first, second) + 1;
     return memo[t];
   }
 }</pre>
<p class="excap" id="ch03ex06"><em>Listing 3-6: Solving for exactly t minutes, with memoization implemented</em></p>
<p class="indent">The game plan is the same as it was in Solution 1, <a href="ch03.xhtml#ch03ex01">Listing 3-1</a>: if <code>t</code> is <code>0</code>, solve the base case; otherwise, solve for <code>t - m</code> minutes and <code>t - n</code> minutes and use the better one.</p>
<p class="indent">To this structure we fasten memoization. The huge reduction in time is realized when we check if a solution for <code>t</code> is already in the <code>memo</code> array <span class="ent">❶</span>, returning that stored result if it is. There is no fussing over whether the final burger takes <em>m</em> or <em>n</em> minutes. There is no further recursion. All we have is an immediate return from the function.</p>
<p class="indent">If we don’t find a solution in <code>memo</code>, then we have work to do. The work is the same as before—except that, whenever we’re about to return the solution, we first store it in the memo. Before each of our <code>return</code> statements, we store the value we’re about to return in <code>memo</code> so that our program maintains a memory of it.</p>
<span epub:type="pagebreak" id="page_91"/>
<h5 class="h5">Testing Our Memoization</h5>
<p class="noindent">I demonstrated that Solution 1 was doomed by showing you two things: that small test cases took far too long to run and that the slowness was caused by making an exorbitant number of function calls. How does Solution 2 fare in terms of these metrics?</p>
<p class="indent">Try Solution 2 with the input that bested Solution 1:</p>
<pre>4 2 88
4 2 90</pre>
<p class="indent">On my laptop, the time taken is imperceptibly small.</p>
<p class="indent">How many function calls are made? I encourage you to instrument Solution 2 in the way that we did for Solution 1 (<a href="ch03.xhtml#ch03ex04">Listing 3-4</a>). If you do that and run it with the above input, you should get this output:</p>
<pre>44
Total calls to solve_t: 88
45
Total calls to solve_t: 90</pre>
<p class="indent">88 calls when <code>t</code> is <code>88</code>. 90 calls when <code>t</code> is <code>90</code>. The difference between Solution 2 and Solution 1 is like night and a few billion days. We’ve gone from an exponential-time algorithm to a linear-time algorithm. Specifically, we now have an <em>O</em>(<em>t</em>) algorithm, where <em>t</em> is the number of Homer’s minutes.</p>
<p class="indent">It’s judge time. If you submit Solution 2, you’ll see that we pass all of the test cases.</p>
<p class="indent">This is certainly a milestone, but it is not the last word on Homer and his burgers. We’ll be able to use something called dynamic programming to eliminate the recursion from our code.</p>
<h4 class="h4" id="sec40"><em>Solution 3: Dynamic Programming</em></h4>
<p class="noindent">We’ll bridge our way from memoization to dynamic programming by making explicit the purpose of recursion in Solution 2. Consider the <code>solve_t</code> code in <a href="ch03.xhtml#ch03ex07">Listing 3-7</a>; it’s the same as the code in <a href="ch03.xhtml#ch03ex06">Listing 3-6</a> except that I’m now highlighting just the two recursive calls.</p>
<pre>int solve_t(int m, int n, int t, int memo[]) {
  int first, second;
  if (memo[t] != -2)
    return memo[t];
  if (t == 0) {
    memo[t] = 0;
    return memo[t];
  }
  if (t &gt;= m)
 <span class="ent">❶</span> first = solve_t(m, n, t - m, memo);
  else
    first = -1;
 <span epub:type="pagebreak" id="page_92"/> if (t &gt;= n)
 <span class="ent">➋</span> second = solve_t(m, n, t - n, memo);
  else
    second = -1;
  if (first == -1 &amp;&amp; second == -1) {
    memo[t] = -1;
    return memo[t];
  } else {
    memo[t] = max(first, second) + 1;
    return memo[t];
  }
}</pre>
<p class="excap" id="ch03ex07"><em>Listing 3-7: Solving for exactly t minutes, focusing on recursive calls</em></p>
<p class="indent">At the first recursive call <span class="ent">❶</span>, one of two very different things will happen. The first is that the recursive call finds its subproblem solution in the memo and returns immediately. The second is that the recursive call does not find the subproblem solution in the memo, in which case it carries out its own recursive calls. All of this is true of the second recursive call <span class="ent">➋</span> as well.</p>
<p class="indent">When we make a recursive call and it finds its subproblem solution in the memo, we have to wonder why we made the recursive call at all. The only thing that the recursive call will do is check the memo and return; we could have done that ourselves. If the subproblem solution is not in the memo, however, then the recursion is really necessary.</p>
<p class="indent">Suppose that we could orchestrate things so that the <code>memo</code> array always holds the next subproblem solution that we need to look up. We want to know the optimal solution when <code>t</code> is <code>5</code>? It’s in <code>memo</code>. What about when <code>t</code> is <code>18</code>? That’s in <code>memo</code>, too. By virtue of always having the subproblem solutions in the memo, we’ll never require a recursive call; we can just look up the solution right away.</p>
<p class="indent">Here we have the difference between memoization and dynamic programming. A function that uses memoization makes a recursive call to solve a subproblem. Maybe the subproblem was already solved, maybe it wasn’t— regardless, it will be solved when the recursive call returns. A function that uses <em>dynamic programming</em> organizes the work so that a subproblem is already solved by the time we need it. We then have no reason to use recursion: we just look up the solution.</p>
<p class="indent">Memoization uses recursion to ensure that a subproblem is solved; dynamic programming ensures that the subproblem is already solved and therefore has no use for recursion.</p>
<p class="indent">Our dynamic-programming solution dispenses with the <code>solve_t</code> function and systematically solves for all values of <code>t</code> in <code>solve</code>. <a href="ch03.xhtml#ch03ex08">Listing 3-8</a> gives the code.</p>
<pre> void solve(int m, int n, int t) {
   int result, i, first, second;
   int dp[SIZE];
<span class="ent">❶</span> dp[0] = 0;
  <span epub:type="pagebreak" id="page_93"/>for (i = 1; i &lt;= t; i++) {
<span class="ent">➋</span> if (i &gt;= m)
   <span class="ent">➌</span> first = dp[i - m];
   else
     first = -1;
<span class="ent">➍</span> if (i &gt;= n)
     second = dp[i - n];
   else
     second = -1;
   if (first == -1 &amp;&amp; second == -1)
  <span class="ent">➎</span> dp[i] = -1;
   else
  <span class="ent">➏</span> dp[i] = max(first, second) + 1;
  }
 
<span class="ent">❼</span> result = dp[t];
   if (result &gt;= 0)
     printf("%d\n", result);
   else {
     i = t - 1;
     result = dp[i];
     while (result == -1) {
       i--;
    <span class="ent">❽</span> result = dp[i];
    }
    printf("%d %d\n", result, t - i);
  }
}</pre>
<p class="excap" id="ch03ex08"><em>Listing 3-8: Solution 3, with dynamic programming</em></p>
<p class="indent">The canonical name for a dynamic-programming array is <code>dp</code>. We could have called it <code>memo</code>, since it serves the same purpose as a memo table, but we call it <code>dp</code> to follow convention. Once we declare the array, we solve the base case, explicitly storing the fact that the optimal solution for zero minutes is to eat zero burgers <span class="ent">❶</span>. Then we have the loop that controls the order in which the subproblems are solved. Here, we solve the subproblems from smallest number of minutes (<code>1</code>) to largest number of minutes (<code>t</code>). The variable <code>i</code> determines which subproblem is being solved. Inside our loop, we have the familiar check of whether it makes sense to test the <em>m</em>-minute burger as the final burger <span class="ent">➋</span>. If so, we look up the solution to the <code>i - m</code> subproblem in the <code>dp</code> array <span class="ent">➌</span>.</p>
<p class="indent">Notice how we just look up the value from the array <span class="ent">➌</span>, without using any recursion. We can do that because we know, by virtue of the fact that <code>i - m</code> is less than <code>i</code>, that we’ve already solved subproblem <code>i - m</code>. This is precisely why we solve subproblems in order, from smallest to largest: larger subproblems will require solutions to smaller subproblems, so we must ensure that those smaller subproblems have already been solved.</p>
<p class="indent"><span epub:type="pagebreak" id="page_94"/>The next <code>if</code> statement <span class="ent">➍</span> is analogous to the previous one <span class="ent">➋</span> and handles the case when the final burger is an <em>n</em>-minute burger. As before, we look up the solution to a subproblem using the <code>dp</code> array. We know for sure that the <code>i - n</code> subproblem has already been solved, because the <code>i - n</code> iteration took place before this <code>i</code> iteration.</p>
<p class="indent">We now have the solutions to both of the required subproblems. All that’s left to do is store the optimal solution for <code>i</code> in <code>dp[i]</code> <span class="ent">➎</span> <span class="ent">➏</span>.</p>
<p class="indent">Once we’ve built up the <code>dp</code> array, solving subproblems <code>0</code> to <code>t</code>, we can look up subproblem solutions at will. We thus simply look up the solution to subproblem <code>t</code> <span class="ent">❼</span>, printing it if there’s a solution and looking up solutions to progressively smaller subproblems if there’s not <span class="ent">❽</span>.</p>
<p class="indent">Like our memoized solution, this is a linear-time solution. In general, the dynamic-programming and memoized solutions of a problem will have the same efficiency, but, that efficiency may be easier to identify in dynamic-programming solutions because they use a loop rather than recursion.</p>
<p class="indent">Let’s see one example <code>dp</code> array before moving on. For the test case that follows:</p>
<pre>4 9 15</pre>
<p class="noindent">the final contents of the <code>dp</code> array are:</p>
<div class="image"><img alt="Image" src="../images/unch03fig02.jpg"/></div>
<p class="indenta">We can trace the code in <a href="ch03.xhtml#ch03ex08">Listing 3-8</a> to confirm each of these subproblem solutions. For example, <code>dp[0]</code>, the maximum number of burgers that Homer can eat in zero minutes, is <code>0</code> <span class="ent">❶</span>. <code>dp[1]</code> is <code>-1</code> because both checks <span class="ent">➋</span> <span class="ent">➍</span> fail, meaning we store <code>-1</code> <span class="ent">➎</span>.</p>
<p class="indent">As a final example, we’re going to reverse-engineer how <code>dp[12]</code> got its value of <code>3</code>. Since 12 is greater than 4, the first check passes <span class="ent">➋</span>. We then set <code>first</code> to <code>dp[8]</code> <span class="ent">➌</span>, which has a value of <code>2</code>. Similarly, 12 is greater than 9, so the second check passes <span class="ent">➍</span>, and we set <code>second</code> to <code>dp[3]</code>, which has a value of <code>-1</code>. The maximum of <code>first</code> and <code>second</code> is therefore <code>2</code>, so we set <code>dp[12]</code> to <code>3</code>, one more than that maximum <span class="ent">➏</span>.</p>
<p class="indent">Please feel free to submit our dynamic programming solution to the judge. It should pass all test cases just like our memoization solution did. Is one of these solutions better than the other? And when should we be using memoization and dynamic programming, anyway? Read on to find out.</p>
<h3 class="h3" id="lev23">Memoization and Dynamic Programming</h3>
<p class="noindent">We solved Burger Fervor in four steps. First, we characterized what an optimal solution must look like; second, we wrote a recursive solution; third, we added memoization; and fourth, we eliminated the recursion by explicitly solving subproblems from smallest to largest. These four steps offer a general plan for tackling many other optimization problems.</p>
<span epub:type="pagebreak" id="page_95"/>
<h4 class="h4" id="sec41"><em>Step 1: Structure of Optimal Solutions</em></h4>
<p class="noindent">The first step is to show how to decompose an optimal solution to a problem into optimal solutions for smaller subproblems. In Burger Fervor, we did this by reasoning about the final burger that Homer eats. Is it an <em>m</em>-minute burger? That leaves the subproblem of filling <em>t</em> – <em>m</em> minutes. What if it is an <em>n</em>-minute burger? That leaves the problem of filling <em>t</em> – <em>n</em> minutes. We don’t know which it is, of course, but we can simply solve these two subproblems to find out.</p>
<p class="indent">It’s critical that our subproblems really are <em>smaller</em> than the original problem. If they are not, then we will fail to eventually reach a base case. The problems in <a href="ch05.xhtml">Chapter 5</a> serve as examples of what we need to do when subproblems cannot be easily ordered by size.</p>
<p class="indent">We also require that an optimal solution to a problem contains within it not just some solutions to the smaller subproblems but <em>optimal</em> solutions to those subproblems. Let’s make this point explicit here.</p>
<p class="indent">In Burger Fervor, when supposing that the final burger in an optimal solution is an <em>m</em>-minute burger, we argued that a solution to the <em>t</em> – <em>m</em> subproblem was part of the solution to the overall <em>t</em> problem. Moreover, an optimal solution for <em>t</em> must include the optimal solution for <em>t</em> – <em>m</em>: if it didn’t, then the solution for <em>t</em> wouldn’t be optimal after all, since we could improve it by using the better solution for <em>t</em> – <em>m</em>! A similar argument can be used to show that, if the last burger in an optimal solution is an <em>n</em>-minute burger, then the remaining <em>t</em> – <em>n</em> minutes should be filled with an optimal solution for <em>t</em> – <em>n</em>.</p>
<p class="indent">Let me unpack this a little through an example. Suppose that <em>m</em> = 4, <em>n</em> = 9, and <em>t</em> = 54. The value of an optimal solution is 11. There is an optimal solution <em>S</em> where the final burger is a 9-minute burger. My claim is that <em>S</em> must consist of this 9-minute burger along with an optimal solution for 45 minutes. The optimal solution for 45 minutes is 10 burgers. If <em>S</em> used some suboptimal solution for the first 45 minutes, then <em>S</em> wouldn’t be an example of an optimal 11-burger solution. For example, if <em>S</em> used a suboptimal five-burger solution for the first 45 minutes, then it would use a total of only six burgers for the full 54 minutes!</p>
<p class="indent">If an optimal solution to a problem is composed of optimal solutions to subproblems, we say that the problem has <em>optimal substructure</em>. If a problem has optimal substructure, the techniques from this chapter are likely to apply.</p>
<p class="indent">I’ve read and heard people claim that solving optimization problems using memoization or dynamic programming is formulaic, that once you’ve seen one such problem, you’ve seen them all, and you can just turn the crank when a new problem arises. I don’t think so. That perspective belies the challenges of both characterizing the structure of optimal solutions and identifying that this will be fruitful in the first place.</p>
<p class="indent">For example, when discussing the structure of an optimal solution for Burger Fervor, I made a big deal about focusing on <em>exactly t</em> minutes. As a result, in our code we couldn’t necessarily look up the answer in one shot—we needed to check for a solution to exactly <em>t</em> minutes, then exactly <em>t</em> – 1 minutes, then exactly <em>t</em> – 2 minutes, and so on, until we found a solution. But <span epub:type="pagebreak" id="page_96"/>couldn’t we have found a way to characterize the optimal solution so that we didn’t need to search like that? Well, we could have, but that would have led to an overall trickier solution for this problem. (We’ll see this alternate kind of approach as an effective way to solve Problem 3 later in this chapter.)</p>
<p class="indent">My point here is simply that discovering what an optimal solution looks like can be surprisingly tricky. The sheer breadth of problems that can be solved using memoization and dynamic programming means that practicing with and generalizing from as many problems as possible is the only way forward.</p>
<h4 class="h4" id="sec42"><em>Step 2: Recursive Solution</em></h4>
<p class="noindent">Step 1 not only suggests to us that memoization and dynamic programming will lead to a solution, but also leaves in its wake a recursive approach for solving the problem. To solve the original problem, try each of the possibilities for an optimal solution, solving subproblems optimally using recursion. In Burger Fervor, we argued that an optimal solution for exactly <em>t</em> minutes might consist of an <em>m</em>-minute burger and an optimal solution for exactly <em>t</em> – <em>m</em> minutes or an <em>n</em>-minute burger and an optimal solution for exactly <em>t</em> – <em>n</em> minutes. Solving the <em>t</em> – <em>m</em> and <em>t</em> – <em>n</em> subproblems is therefore required and, as these are smaller subproblems than <em>t</em>, we used recursion to solve them. In general, the number of recursive calls depends on the number of available candidates competing to be the optimal solution.</p>
<h4 class="h4" id="sec43"><em>Step 3: Memoization</em></h4>
<p class="noindent">If we succeed with Step 2, then we have a correct solution to the problem. As we saw with Burger Fervor, though, such a solution may require an absolutely unreasonable amount of time to execute. The culprit is that the same subproblems are being solved over and over, as a result of a phenomenon known as <em>overlapping subproblems</em>. Really, if we didn’t have overlapping subproblems, then we could stop right here: recursion would be fine on its own. Think back to <a href="ch02.xhtml">Chapter 2</a> and the two problems we solved there. We solved those successfully with recursion alone, and that worked because each subproblem was solved only once. In Halloween Haul, for example, we calculated the total amount of candy in a tree. The two subproblems were finding the total amounts of candy in the left and right subtrees. Those problems are independent: there’s no way that solving the subproblem for the left subtree could somehow require information about the right subtree, or vice versa.</p>
<p class="indent">If there’s no subproblem overlap, we can just use recursion. When there is subproblem overlap, however, it’s time for memoization. As we learned when solving Burger Fervor, memoization means that we store the solution to a subproblem the first time we solve it. Then, whenever that subproblem solution is needed in the future, we simply look it up rather than recalculate it. Yes, the subproblems still overlap, but now they are solved only once, just like in <a href="ch02.xhtml">Chapter 2</a>.</p>
<span epub:type="pagebreak" id="page_97"/>
<h4 class="h4" id="sec44"><em>Step 4: Dynamic Programming</em></h4>
<p class="noindent">Very likely, the solution resulting from Step 3 will be fast enough. Such a solution still uses recursion, but without the risk of duplicating work. As I’ll explain in the next paragraph, sometimes we want to eliminate the recursion. We can do so as long as we systematically solve smaller subproblems before larger subproblems. This is dynamic programming: the use of a loop in lieu of recursion, explicitly solving all subproblems in order from smallest to largest.</p>
<p class="indent">So what’s better: memoization or dynamic programming? For many problems, they are roughly equivalent and, in those cases, you should use what you find more comfortable. My personal choice is memoization. We’ll see an example (Problem 3 later in this chapter) where the <code>memo</code> and <code>dp</code> tables have multiple dimensions. In such problems, I often have trouble getting all of the base cases and bounds for the <code>dp</code> table correct.</p>
<p class="indent">Memoization solves subproblems on an as-needed basis. For example, consider the Burger Fervor test case where we have a kind of burger that takes 2 minutes to eat, a kind of burger that takes 4 minutes to eat, and 90 minutes of time. A memoized solution will never solve for odd numbers of minutes, such as 89 or 87 or 85, because those subproblems do not result from subtracting multiples of 2 and 4 from 90. Dynamic programming, by contrast, solves all subproblems on its way up to 90. The difference here seems to favor memoized solutions; indeed, if huge swaths of the subproblem space are never used, then memoization may be faster than dynamic programming. This has to be balanced against the overhead inherent in recursive code, though, with all of the calling and returning from functions. If you’re so inclined, it wouldn’t hurt to code up both solutions to a problem and see which is faster!</p>
<p class="indent">You’ll commonly see people refer to memoized solutions as <em>top-down</em> solutions and dynamic-programming solutions as <em>bottom-up</em> solutions. It’s called “top-down” because, to solve large subproblems, we recurse down to small subproblems. In “bottom-up” solutions, we start from the bottom—the smallest subproblems—and work our way to the top.</p>
<p class="indent">Memoization and dynamic programming are captivating to me. They can solve so many types of problems; I don’t know another algorithm design technique that even comes close. Many of the tools that we learn in this book, such as hash tables in <a href="ch01.xhtml">Chapter 1</a>, offer valuable speedups. The truth is that, even without those tools, we could solve many problem instances— not in time to have such solutions accepted by the judge, but perhaps still in time to be practically useful. However, memoization and dynamic programming are different. They vivify recursive ideas, turning algorithms that are astonishingly slow into those that are astonishingly fast. I hope I can pull you into the fold with this chapter and the next and that you won’t stop when these chapters do.</p>
<span epub:type="pagebreak" id="page_98"/>
<h3 class="h3" id="lev24">Problem 2: Moneygrubbers</h3>
<p class="noindent">In Burger Fervor, we were able to solve each problem by considering only two subproblems. Here, we’ll see an example where each problem may require solving many more subproblems.</p>
<p class="indent">This is UVa problem <code>10980</code>.</p>
<h4 class="h4" id="sec45"><em>The Problem</em></h4>
<p class="noindent">You want to buy apples, so you go to an apple store. The store has a price for buying one apple—for example, $1.75. The store also has <em>m</em> pricing schemes, where each pricing scheme gives a number <em>n</em> and a price <em>p</em> for buying <em>n</em> apples. For example, one pricing scheme might state that three apples cost a total of $4.00; another might state that two apples cost a total of $2.50. You want to buy <em>at least k</em> apples and do so as cheaply as possible.</p>
<h5 class="h5">Input</h5>
<p class="noindent">We read test cases until there’s no more input. Each test case consists of the following lines:</p>
<ul>
<li class="noindent">A line containing the price for buying one apple, followed by the number <em>m</em> of pricing schemes for this test case. <em>m</em> is at most 20.</li>
<li class="noindent"><em>m</em> lines, each of which gives a number <em>n</em> and total price <em>p</em> for buying <em>n</em> apples. <em>n</em> is between 1 and 100.</li>
<li class="noindent">A line containing integers, where each integer <em>k</em> is between 0 and 100 and gives the desired number of apples to buy.</li>
</ul>
<p class="indent">Each price in the input is a floating-point number with exactly two decimal digits.</p>
<p class="indent">In the problem description, I gave an example price of one apple as $1.75. I also gave two example pricing schemes: three apples for $4.00 and two apples for $2.50. Using that data, suppose we wanted to determine the minimum price for buying at least one apple and at least four apples, respectively. Here’s the input for this test case:</p>
<pre>1.75 2
3 4.00
2 2.50
1 4</pre>
<h5 class="h5">Output</h5>
<p class="noindent">For each test case, output the following:</p>
<ul>
<li class="noindent">A line containing <code>Case</code> <span class="codeitalic">c</span>:, where <span class="codeitalic">c</span> is the number of the test case starting at 1.</li>
<li class="noindent">For each integer <em>k</em>, a line containing <code>Buy</code> <em>k</em> <code>for $<em>d</em></code>, where <span class="codeitalic">d</span> is the cheapest cost for which we can buy at least <span class="codeitalic">k</span> apples.</li>
</ul>
<p class="indent"><span epub:type="pagebreak" id="page_99"/>Here’s the output for the above sample input:</p>
<pre>Case 1:
Buy 1 for $1.75
Buy 4 for $5.00</pre>
<p class="indent">The time limit for solving the test cases is three seconds.</p>
<h4 class="h4" id="sec46"><em>Characterizing Optimal Solutions</em></h4>
<p class="noindent">The problem description specifies that we want to buy <em>at least k</em> apples as cheaply as possible. This means that buying exactly <em>k</em> apples is only one option; we can buy more than <em>k</em> apples if it’s cheaper that way. We’re going to start by trying to solve for exactly <em>k</em> apples, much as we solved for exactly <em>t</em> minutes in Burger Fervor. Back then, we found a way when necessary to move from exactly <em>t</em> minutes to smaller numbers of minutes. The hope is that we can do something similar here, starting with <em>k</em> apples and finding the cheapest cost for <em>k</em>, <em>k</em> + 1, <em>k</em> + 2, and so on. If it ain’t broke . . .</p>
<p class="indent">Before just recalling the title of this chapter and diving headlong into memoization and dynamic programming, let’s make sure that we really do need those tools.</p>
<p class="indent">What’s better: buying three apples for a total of $4.00 (Scheme 1) or two apples for a total of $2.50 (Scheme 2)? We can try to answer this by calculating the cost per apple for each of these pricing schemes. In Scheme 1, we have $4.00/3 = $1.33 per apple, and in Scheme 2 we have $2.50/2 = $1.25 per apple. It looks like Scheme 2 is better than Scheme 1. Let’s also suppose that we can buy one apple for $1.75, which looks even worse than the two schemes. We therefore have the cost per apple, from cheapest to most expensive, as follows: $1.25, $1.33, $1.75.</p>
<p class="indent">Now, suppose that we want to buy <em>exactly k</em> apples. How’s this for an algorithm: at each step, use the cheapest cost per apple, until we’ve bought <em>k</em> apples?</p>
<p class="indent">If we wanted to buy exactly four apples for the above case, then we’d start with Scheme 2, because it lets us buy apples with the best price per apple. Using Scheme 2 once costs us $2.50 for two apples, and it leaves us with two apples to buy. We can then use Scheme 2 again, buying two more apples (for a total now of four apples) for another $2.50. We’d have spent $5.00 for the four apples and, indeed, we cannot do better.</p>
<p class="indent">Note that just because an algorithm is intuitive or works on one test case does not mean that it is correct in general. This algorithm of using the best-available price per apple is flawed, and there are test cases that prove it. Try to find such a test case before continuing!</p>
<p class="indent">Here’s one: suppose that we want to buy exactly three apples, not four. We’d start with Scheme 2 again, giving us two apples for a total of $2.50. Now we have only one apple to buy—and the only choice is to pay $1.75 for the one apple. The total cost is $4.25—but there is a better way. Namely, we should simply have used Scheme 1 once, costing us $4.00: yes, it has a higher <span epub:type="pagebreak" id="page_100"/>cost per apple than Scheme 2, but it makes up for that by freeing us from paying for one apple that has a still higher cost per apple.</p>
<p class="indent">It’s tempting to start affixing extra rules to our algorithm to try to fix it; for example, “if there’s a pricing scheme for exactly the number of apples that we need, then use it.” Suppose, however, we want to buy exactly three apples. We can easily break this augmented algorithm by adding a scheme in which the store sells three apples for $100.00.</p>
<p class="indent">When using memoization and dynamic programming, we try all the available options for an optimal solution and then pick the best one. In Burger Fervor, should Homer end with an <em>m</em>-minute burger or an <em>n</em>-minute burger? We don’t know, so we try both. By contrast, a <em>greedy algorithm</em> is an algorithm that tries just one option: the one that looks like the best choice at the time.</p>
<p class="indent">Using the best price per apple, as we did above, is an example of a greedy algorithm, because at each step it chooses what to do without considering other options. Sometimes greedy algorithms work. Moreover, since they often run faster than dynamic-programming algorithms and are easier to implement , a working greedy algorithm may be better than a working dynamic-programming algorithm. For this problem, it appears that greedy algorithms—whether the one above or others that might come to mind—are not sufficiently powerful.</p>
<p class="indent">In Burger Fervor, we reasoned that, if it’s possible to spend <em>t</em> minutes eating burgers, then the final burger in an optimal solution must be an <em>m</em>-minute burger or an <em>n</em>-minute burger. For the present problem, we want to say something analogous: that an optimal solution for buying <em>k</em> apples must end in one of a small number of ways. Here’s a claim: if the available pricing schemes are Scheme 1, Scheme 2, . . . , Scheme <em>m</em>, then the final thing we do must be to use one of these <em>m</em> pricing schemes. There can’t be anything else that we could do, right?</p>
<p class="indent">Well, this is not quite true. The final thing that we do in an optimal solution might be buying one apple. We always have that as an option. Rather than solve two subproblems as in Burger Fervor, we solve <em>m</em> + 1 subproblems: one for each of the <em>m</em> pricing schemes and one for buying one apple.</p>
<p class="indent">Suppose that an optimal solution for buying <em>k</em> apples ends with us paying <em>p</em> dollars for <em>n</em> apples. We then need to optimally buy <em>k</em> – <em>n</em> apples and add that cost to <em>p</em>. We need to establish that the overall optimal solution for <em>k</em> apples contains within it an optimal solution for <em>k</em> – <em>n</em> apples. This is the optimal substructure requirement of memoization and dynamic programming. As with Burger Fervor, optimal substructure does hold. If a solution for <em>k</em> didn’t use an optimal solution for <em>k</em> – <em>n</em>, then that solution for <em>k</em> cannot be optimal after all: it’s not as good as what we’d get if we built it on the optimal solution for <em>k</em> – <em>n</em>.</p>
<p class="indent">Of course, we don’t know what to do at the end of the solution to make it optimal. Do we use Scheme 1, use Scheme 2, use Scheme 3, or just buy one apple? Who knows? As in any memoization or dynamic-programming algorithm, we simply try them all and choose the best one.</p>
<p class="indent"><span epub:type="pagebreak" id="page_101"/>Before we look at a recursive solution, note that, for any number <em>k</em>, we can always find a way to buy exactly <em>k</em> apples. Whether one apple, two apples, five apples, whatever, we can buy that many. The reason is that we always have the option of buying one apple, and we can do that as many times as we like. Compare this to Burger Fervor, where there were values of <em>t</em> such that <em>t</em> minutes could not be filled by the available burgers. As a consequence of this difference, here we won’t have to worry about the case where a recursive call on a smaller subproblem fails to find a solution.</p>
<h4 class="h4" id="sec47"><em>Solution 1: Recursion</em></h4>
<p class="noindent">Like in Burger Fervor, the first thing to do is write a helper function to solve for a specific number of apples.</p>
<h5 class="h5">The Helper Function: Solving for the Number of Apples</h5>
<p class="noindent">Let’s write the function <code>solve_k</code>, whose job will be analogous to the <code>solve_t</code> functions that we wrote for Burger Fervor. The function signature is as follows:</p>
<pre>double solve_k(int num[], double price[], int num_schemes,
               double unit_price, int num_apples)</pre>
<p class="indent">Each of these parameters except for the last comes directly from the current test case. Here’s what each parameter is for:</p>
<p class="block"><span class="codestrong">num</span>   An array of numbers of apples, with one element per pricing scheme. For example, if we have two pricing schemes, the first for three apples and the second for two apples, then this array would be <code>[3, 2]</code>.</p>
<p class="block"><span class="codestrong">price</span>   An array of prices, one element per pricing scheme. For example, if we have two pricing schemes, the first with cost <code>4.00</code> and the second with cost <code>2.50</code>, then this array would be <code>[4.00, 2.50]</code>. Notice that <code>num</code> and <code>price</code> together give us all of the information about the pricing schemes.</p>
<p class="block"><span class="codestrong">num_schemes</span>   The number of pricing schemes. It’s the <code>m</code> value from the test case.</p>
<p class="block"><span class="codestrong">unit_price</span>   The price for one apple.</p>
<p class="block"><span class="codestrong">num_apples</span>   The number of apples that we want to buy.</p>
<p class="noindenta">The <code>solve_k</code> function returns the minimum cost for buying exactly <code>num_apples</code> apples.</p>
<p class="indent">The code for <code>solve_k</code> is given in <a href="ch03.xhtml#ch03ex09">Listing 3-9</a>. In addition to studying this code on its own, I strongly encourage you to compare it to the <code>solve_t</code> function from Burger Fervor (<a href="ch03.xhtml#ch03ex01">Listing 3-1</a>). What differences do you notice? Why are these differences present? Memoization and dynamic-programming solutions share a common code structure. If we can nail that structure, then we can focus on what’s different in and specific to each problem.</p>
<span epub:type="pagebreak" id="page_102"/>
<pre><span class="ent">❶</span> double min(double v1, double v2) {
     if (v1 &lt; v2)
       return v1;
     else
       return v2;
  }

  double solve_k(int num[], double price[], int num_schemes,
                 double unit_price, int num_apples) {
    double best, result;
    int i;
 <span class="ent">➋</span> if (num_apples == 0)
   <span class="ent">➌</span> return 0;
    else {
   <span class="ent">➍</span> result = solve_k(num, price, num_schemes, unit_price,
                       num_apples - 1);
   <span class="ent">➎</span> best = result + unit_price;
      for (i = 0; i &lt; num_schemes; i++)
     <span class="ent">➏</span> if (num_apples - num[i] &gt;= 0) {
       <span class="ent">❼</span> result = solve_k(num, price, num_schemes, unit_price,
                           num_apples - num[i]);
       <span class="ent">❽</span> best = min(best, result + price[i]);
       }
          return best;
    }
}</pre>
<p class="excap" id="ch03ex09"><em>Listing 3-9: Solving for exactly <span class="codeitalic1">num_apples</span> apples</em></p>
<p class="indent">We start with a little <code>min</code> function <span class="ent">❶</span>: we’ll need that for comparing solutions and picking the smaller one. In Burger Fervor, we used a similar <code>max</code> function, because we wanted the maximum number of burgers. Here, we want the minimum cost. Some optimization problems are <em>maximization problems</em> (Burger Fervor) and others are <em>minimization problems</em> (Moneygrubbers)— carefully read problem statements to make sure you’re optimizing in the right direction!</p>
<p class="indent">What do we do if asked to solve for <code>0</code> apples <span class="ent">➋</span>? We return <code>0</code> <span class="ent">➌</span>, because the minimum cost to buy zero apples is exactly $0.00. That’s a base case, just like filling zero minutes in Burger Fervor. As with recursion in general, at least one base case is required for any optimization problem.</p>
<p class="indent">If we’re not in the base case, then <code>num_apples</code> will be a positive integer, and we need to find the optimal way to buy exactly that many apples. The variable <code>best</code> is used to track the best (minimum-cost) option that has been found so far.</p>
<p class="indent">One option is to optimally solve for <code>num_apples - 1</code> apples <span class="ent">➍</span> and add the cost of the final apple <span class="ent">➎</span>.</p>
<p class="indent">We now hit the big structural difference between this problem and Burger Fervor: a loop inside of the recursive function. In Burger Fervor, we <span epub:type="pagebreak" id="page_103"/>didn’t need a loop, because we only had two subproblems to try. We just tried the first one and then tried the second one. Here, though, we have one subproblem per pricing scheme, and we have to go through all of them. We check whether the current pricing scheme can be used at all <span class="ent">➏</span>: if its number of apples is no larger than the number that we need, then we can try it. We make a recursive call to solve the subproblem resulting from removing the number of apples in this pricing scheme <span class="ent">❼</span>. (It’s similar to the earlier recursive call where we subtracted one for the single apple <span class="ent">➍</span>.) If that subproblem solution plus the price of the current scheme is our best option so far, then we update <code>best</code> accordingly <span class="ent">❽</span>.</p>
<h5 class="h5">The solve Function</h5>
<p class="noindent">We’ve optimally solved for exactly <em>k</em> apples, but there’s this detail from the problem statement that we haven’t addressed yet: “You want to buy <em>at least k</em> apples and to do so as cheaply as possible.” Why does the difference between exactly <em>k</em> apples and at least <em>k</em> apples matter in the first place? Can you find a test case where it’s cheaper to buy more than <em>k</em> apples than it is to buy <em>k</em> apples?</p>
<p class="indent">Here’s one for you. We’ll say that one apple costs $1.75. We have two pricing schemes: Scheme 1 is that we can buy four apples for $3.00, and Scheme 2 is that we can buy two apples for $2.00. Now, we want to buy at least three apples. This test case in the form of problem input is as follows:</p>
<pre>1.75 2
4 3.00
2 2.00
3</pre>
<p class="indent">The cheapest way to buy exactly three apples is to spend $3.75: one apple for $1.75 and two apples using Scheme 2 for $2.00. However, we can spend less money by in fact buying four apples, not three. The cheapest way to buy four apples is to use Scheme 1 once, which costs us only $3.00. That is, the correct output for this test case is:</p>
<pre>Case 1:
Buy 3 for $3.00</pre>
<p class="indent">(This output is a bit confusing, because we’re actually buying four apples, not three, but it is correct to output <code>Buy 3</code> here. We always output the number of apples that we’re asked to buy, whether or not we buy more than that to save money.)</p>
<p class="indent">What we need is a <code>solve</code> function like the one we had for Burger Fervor in <a href="ch03.xhtml#ch03ex02">Listing 3-2</a>. There, we tried smaller and smaller values until we found a solution. Here, we’ll try larger and larger values, keeping track of the minimum solution as we go. Here’s a first crack at the code:</p>
<pre>double solve(int num[], double price[], int num_schemes,
             double unit_price, int num_apples) {
  double best;
  <span epub:type="pagebreak" id="page_104"/>int i;
<span class="ent">❶</span> best = solve_k(num, price, num_schemes,
                  unit_price, num_apples);
<span class="ent">➋</span> for (i = num_apples + 1; i &lt; ???; i++)
     best = min(best, solve_k(num, price, num_schemes,
                              unit_price, i));
   return best;
}</pre>
<p class="indent">We initialize <code>best</code> to the optimal solution for buying exactly <code>num_apples</code> apples <span class="ent">❶</span>. Then, we use a <code>for</code> loop to try larger and larger numbers of apples <span class="ent">➋</span>. The <code>for</code> loop stops when . . . uh-oh. How do we know when it’s safe to stop? Maybe we’re being asked to buy 3 apples, but the cheapest thing to do is to buy 4 or 5 or 10 or even 20. We didn’t have this problem in Burger Fervor, because there we were making our way downward, toward zero, rather than upward.</p>
<p class="indent">We can find a game-saving observation from the problem input specification: it says that the number of apples in a given pricing scheme is at most 100. How does this help?</p>
<p class="indent">Suppose we’re being asked to buy at least 50 apples. Might it be best to buy exactly 60 apples? Sure! Maybe the final pricing scheme in an optimal solution for 60 apples is for 20 apples. Then we could combine those 20 apples with an optimal solution for 40 apples to get a total of 60 apples.</p>
<p class="indent">Suppose again that we’re buying 50 apples. Could it make sense for us to buy exactly 180 apples? Well, think about an optimal solution for buying exactly 180 apples. The final pricing scheme that we use gives us at most 100 apples. Before using that final pricing scheme, we’d have bought at least 80 apples and had done so more cheaply than we did for 180 apples. Crucially, 80 is still greater than 50! Therefore, buying 80 apples is cheaper than buying 180 apples. Buying 180 apples cannot be the optimal thing to do if we want at least 50 apples.</p>
<p class="indent">In fact, for 50 apples, the maximum number of apples we should even consider buying is 149. If we buy 150 or more apples, then removing the final pricing scheme gives us a cheaper way to buy 50 or more apples.</p>
<p class="indent">The problem input specification not only limits the number of apples per pricing scheme to 100, it also limits the number of apples to buy to 100. In the case in which we are asked to buy 100 apples, then, the maximum number of apples we should consider buying is 100 + 99 = 199. Incorporating this observation leads to the <code>solve</code> function in <a href="ch03.xhtml#ch03ex010">Listing 3-10</a>.</p>
<pre>#define SIZE 200

double solve(int num[], double price[], int num_schemes,
             double unit_price, int num_apples) {
  double best;
  int i;
  best = solve_k(num, price, num_schemes, unit_price, num_apples);
  for (i = num_apples + 1; i &lt; SIZE; i++)
    <span epub:type="pagebreak" id="page_105"/>best = min(best, solve_k(num, price, num_schemes,
                             unit_price, i));
  return best;
}</pre>
<p class="excap" id="ch03ex010"><em>Listing 3-10: Solution 1</em></p>
<p class="indent">Now all we need is a <code>main</code> function and we can start submitting stuff to the judge.</p>
<h4 class="h4" id="sec48"><em>The main Function</em></h4>
<p class="noindent">Let’s get a <code>main</code> function written. See <a href="ch03.xhtml#ch03ex11">Listing 3-11</a>. It’s not completely self-contained, but all we’ll need is one helper function, <code>get_number</code>, that I’ll describe shortly.</p>
<pre>#define MAX_SCHEMES 20

int main(void) {
  int test_case, num_schemes, num_apples, more, i;
  double unit_price, result;
  int num[MAX_SCHEMES];
  double price[MAX_SCHEMES];
  test_case = 0;
<span class="ent">❶</span> while (scanf("%lf%d ", &amp;unit_price, &amp;num_schemes) != -1) {
     test_case++;
     for (i = 0; i &lt; num_schemes; i++)
    <span class="ent">➋</span> scanf("%d%lf ", &amp;num[i], &amp;price[i]);
     printf("Case %d:\n", test_case);
     more = get_number(&amp;num_apples);
 <span class="ent">➌</span> while (more) {
      result = solve(num, price, num_schemes, unit_price, num_apples);
      printf("Buy %d for $%.2f\n", num_apples, result);
      more = get_number(&amp;num_apples);
    }
 <span class="ent">➍</span> result = solve(num, price, num_schemes, unit_price, num_apples);
    printf("Buy %d for $%.2f\n", num_apples, result);
  }
  return 0;
}</pre>
<p class="excap" id="ch03ex11"><em>Listing 3-11: The main function</em></p>
<p class="indent">We begin by using <code>scanf</code> to try to read the first line of the next test case from the input <span class="ent">❶</span>. The next <code>scanf</code> call <span class="ent">➋</span> is in a nested loop, and it reads the number of apples and price for each pricing scheme.</p>
<p class="indent">Notice that each of the <code>scanf</code> format strings ends with a space, which ensures that we’re always positioned at the start of each line. This becomes important once we get to the line containing the numbers of apples that we <span epub:type="pagebreak" id="page_106"/>are asked to buy, because we’re going to use a helper function that assumes we’re at the start of the line.</p>
<p class="indent">Why do we need a helper function? Well, we can’t just airily keep calling <code>scanf</code> to read those numbers of apples, because we have to be able to stop at a newline. That’s why we use my <code>get_number</code> helper function instead, described further below. It returns <code>1</code> if there are more numbers to read and <code>0</code> if this is the last number on the line. We call this function to read each number in the loop <span class="ent">➌</span> that solves the test cases. We also need some code below the loop <span class="ent">➍</span>: when the loop terminates because it has read the final number on the line, we still need to solve that final test case.</p>
<p class="indent">The code for <code>get_number</code> is given in <a href="ch03.xhtml#ch03ex012">Listing 3-12</a>.</p>
<pre>int get_number(int *num) {
  int ch;
  int ret = 0;
  ch = getchar();
<span class="ent">❶</span> while (ch != ' ' &amp;&amp; ch != '\n') {
     ret = ret * 10 + ch - '0';
     ch = getchar();
  }
<span class="ent">➋</span> *num = ret;
<span class="ent">➌</span> return ch == ' ';
}</pre>
<p class="excap" id="ch03ex012"><em>Listing 3-12: The function to get an integer</em></p>
<p class="indent">This function reads an integer value using an approach reminiscent of <a href="ch02.xhtml#ch02ex017">Listing 2-17</a>. The loop continues as long as we haven’t yet hit a space or new-line character <span class="ent">❶</span>. When the loop terminates, we store what was read in the pointer parameter passed to this function call <span class="ent">➋</span>. We use that pointer parameter, rather than return the value, because the return value has another role: to indicate whether or not this is the last number on the line <span class="ent">➌</span>. That is, if <code>get_number</code> returns <code>1</code> (because it found a space after the number that it read), it means that there are more numbers on this line; if it returns <code>0</code>, then this is the final number on this line.</p>
<p class="indent">We’ve got a complete solution now, but its performance is glacial. Even test cases that look small will take ages, because we’re going all the way up to 299 apples no matter what.</p>
<p class="indent">Oh well. Let’s memoize the heck out of this thing.</p>
<h4 class="h4" id="sec49"><em>Solution 2: Memoization</em></h4>
<p class="noindent">We introduced the <code>memo</code> array in <code>solve</code> (<a href="ch03.xhtml#ch03ex05">Listing 3-5</a>) when memoizing Burger Fervor. That was because each call of <code>solve</code> was for an independent test case. However, in Moneygrubbers, we have that line where each integer specifies a number of apples to buy, and we have to solve each one. It would be wasteful to throw away the <code>memo</code> array before we’ve completely finished with the test case!</p>
<p class="indent"><span epub:type="pagebreak" id="page_107"/>We’re therefore going to declare and initialize <code>memo</code> in <code>main</code>. The updated <code>main</code> function is in <a href="ch03.xhtml#ch03ex013">Listing 3-13</a>.</p>
<pre>int main(void) {
  int test_case, num_schemes, num_apples, more, i;
  double unit_price, result;
  int num[MAX_SCHEMES];
  double price[MAX_SCHEMES];
<span class="ent">❶</span> double memo[SIZE];
   test_case = 0;
   while (scanf("%lf%d ", &amp;unit_price, &amp;num_schemes) != -1) {
     test_case++;
     for (i = 0; i &lt; num_schemes; i++)
       scanf("%d%lf ", &amp;num[i], &amp;price[i]);
     printf("Case %d:\n", test_case);
  <span class="ent">➋</span> for (i = 0; i &lt; SIZE; i++)
    <span class="ent">➌</span> memo[i] = -1;
      more = get_number(&amp;num_apples);
      while (more) {
        result = solve(num, price, num_schemes, unit_price, num_apples, memo);
        printf("Buy %d for $%.2f\n", num_apples, result);
        more = get_number(&amp;num_apples);
    }
    result = solve(num, price, num_schemes, unit_price, num_apples, memo);
    printf("Buy %d for $%.2f\n", num_apples, result);
  }
  return 0;
}</pre>
<p class="excap" id="ch03ex013"><em>Listing 3-13: The main function, with memoization implemented</em></p>
<p class="indent">We declare the <code>memo</code> array <span class="ent">❶</span>, and we set each element of <code>memo</code> to <code>-1</code> (“unknown” value) <span class="ent">➋</span> <span class="ent">➌</span>. Notice that the initialization of <code>memo</code> occurs just once per test case. The only other change is that we add <code>memo</code> as a new parameter to the <code>solve</code> calls.</p>
<p class="indent">The new code for <code>solve</code> is given in <a href="ch03.xhtml#ch03ex014">Listing 3-14</a>.</p>
<pre>double solve(int num[], double price[], int num_schemes,
             double unit_price, int num_apples, double memo[]) {
  double best;
  int i;
  best = solve_k(num, price, num_schemes, unit_price, num_apples, memo);
  for (i = num_apples + 1; i &lt; SIZE; i++)
    best = min(best, solve_k(num, price, num_schemes, unit_price, i, memo));
  return best;
}</pre>
<p class="excap" id="ch03ex014"><em>Listing 3-14: Solution 2, with memoization implemented</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_108"/>In addition to adding <code>memo</code> as a new parameter at the end of the parameter list, we pass <code>memo</code> to the <code>solve_k</code> calls. That’s it.</p>
<p class="indent">Finally, let’s take a look at the changes required to memoize <code>solve_k</code>. We will store in <code>memo[num_apples]</code> the minimum cost of buying exactly <code>num_apples</code> apples. See <a href="ch03.xhtml#ch03ex015">Listing 3-15</a>.</p>
<pre> double solve_k(int num[], double price[], int num_schemes,
                double unit_price, int num_apples, double memo[]) {
  double best, result;
  int i;
<span class="ent">❶</span> if (memo[num_apples] != -1)
     return memo[num_apples];
   if (num_apples == 0) {
     memo[num_apples] = 0;
     return memo[num_apples];
   } else {
     result = solve_k(num, price, num_schemes, unit_price,
                      num_apples - 1, memo);
     best = result + unit_price;
     for (i = 0; i &lt; num_schemes; i++)
       if (num_apples - num[i] &gt;= 0) {
         result = solve_k(num, price, num_schemes, unit_price,
                          num_apples - num[i], memo);
         best = min(best, result + price[i]);
       }
         memo[num_apples] = best;
         return memo[num_apples];
    }
}</pre>
<p class="excap" id="ch03ex015"><em>Listing 3-15: Solving for exactly <span class="codeitalic1">num_apples</span> apples, with memoization implemented</em></p>
<p class="indent">Remember that the first thing we do when solving with memoization is check whether the solution is already known <span class="ent">❶</span>. If any value besides <code>-1</code> is stored for the <code>num_apples</code> subproblem, we return it. Otherwise, as with any memoized function, we store a new subproblem solution in <code>memo</code> before returning it.</p>
<p class="indent">We’ve now reached a natural stopping point for this problem: this memoized solution can be submitted to the judge and should pass all test cases. If you’d like more practice with dynamic programming, though, here’s a perfect opportunity for you to convert this memoized solution into a dynamic-programming solution! Otherwise, we’ll put this problem on ice.</p>
<h3 class="h3" id="lev25">Problem 3: Hockey Rivalry</h3>
<p class="noindent">Our first two problems used a one-dimensional <code>memo</code> or <code>dp</code> array. Let’s look at a problem whose solution dictates using a two-dimensional array.</p>
<p class="indent"><span epub:type="pagebreak" id="page_109"/>I live in Canada, so I suppose we weren’t getting through this book without some hockey. Hockey is a team sport like soccer . . . but with goals.</p>
<p class="indent">This is DMOJ problem <code>cco18p1</code>.</p>
<h4 class="h4" id="sec50"><em>The Problem</em></h4>
<p class="noindent">The Geese played <em>n</em> games, each of which had one of two outcomes: a win for the Geese (<code>W</code>) or a loss for the Geese (<code>L</code>). (There are no tie games.) For each of their games, we know whether they won or lost and we know the number of goals that they scored. For example, we might know that their first game was a win (<code>W</code>) and that they scored four goals in that game. (Their opponent, whoever it was, must therefore have lost and scored fewer than four goals.) The Hawks also played <em>n</em> games and, the same as the Geese, each game was a win or loss for the Hawks. Again, for each of their games, we know whether they won or lost and we know the number of goals that they scored.</p>
<p class="indent">Some of the games that these teams played may have been against each other, but there are other teams, too, and some of the games may have been against these other teams.</p>
<p class="indent">We have no information about who played whom. We might know that the Geese won a certain game and that they scored four goals in that game, but we don’t know who their opponent was—their opponent could have been the Hawks, but it also could have been some other team.</p>
<p class="indent">A <em>rivalry game</em> is a game where the Geese played the Hawks.</p>
<p class="indent">Our task is to determine the maximum number of goals that could have been scored in rivalry games.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, the information for which is spread over five lines as follows:</p>
<ul>
<li class="noindent">The first line contains <em>n</em>, the number of games that each team played. <em>n</em> is between 1 and 1,000.</li>
<li class="noindent">The second line contains a string of length <em>n</em>, where each character is a <code>W</code> (win) or <code>L</code> (loss). This line tells us the outcome of each game played by the Geese. For example, <code>WLL</code> means that the Geese won their first game, lost their second game, and lost their third game.</li>
<li class="noindent">The third line contains <em>n</em> integers, giving the number of goals scored in each game by the Geese. For example, <code>4 1 2</code> means that the Geese scored four goals in their first game, one goal in their second game, and two goals in their third game.</li>
<li class="noindent">The fourth line is like the second, but it tells us the outcome of each game for the Hawks.</li>
<li class="noindent">The fifth line is like the third, but it tells us the number of goals scored in each game by the Hawks.</li>
</ul>
<span epub:type="pagebreak" id="page_110"/>
<h5 class="h5">Output</h5>
<p class="noindent">The output is a single integer: the maximum number of goals scored in possible rivalry games.</p>
<p class="indent">The time limit for solving the test case is 0.6 seconds.</p>
<h4 class="h4" id="sec51"><em>About Rivalries</em></h4>
<p class="noindent">Before jumping to the structure of optimal solutions, let’s be sure that we understand exactly what’s being asked by working through some test cases.</p>
<p class="indent">We’ll start with this one:</p>
<pre>3
WWW
2 5 1
WWW
5 7 8</pre>
<p class="indent">There can’t be <em>any</em> rivalry games at all here. A rivalry game, like any game, requires that one team win and the other lose—but the Geese won all their games and the Hawks won all their games, so the Geese and Hawks could not have played each other. Since there are no rivalry games possible, there are no goals scored in rivalry games. The correct output is <code>0</code>.</p>
<p class="indent">Let’s now have the Hawks lose all their games:</p>
<pre>3
WWW
2 5 1
LLL
5 7 8</pre>
<p class="indent">Are there any rivalry games now? The answer is still no! The Geese won their first game by scoring two goals. For that game to be a rivalry game, it must be with a game where the Hawks lost and where the Hawks scored fewer than two goals. Since the fewest goals scored by the Hawks was five, though, none of those games can be a rivalry game with the Geese’s first game. Similarly, the Geese won their second game by scoring five goals, but there is no loss for the Hawks where they scored four goals or fewer. That is, there is no rivalry involving the Geese’s second game. The same kind of analysis shows that the Geese’s third game also cannot be part of a rivalry. Again, <code>0</code> is the correct output.</p>
<p class="indent">Let’s move past these zero cases. Here’s one:</p>
<pre>3
WWW
2 5 1
LLL
4 7 8</pre>
<p class="indent"><span epub:type="pagebreak" id="page_111"/>We’ve changed the first Hawks game so that they scored four goals instead of five, and this is enough to produce a possible rivalry game! Specifically, the second game played by the Geese, where the Geese won and scored five goals, could be a rivalry game with the first game by the Hawks, where the Hawks lost and scored four goals. That game had nine goals scored in it. As there are no other rivalry games that we can include, there are no other goals that we can add to our total. The correct output here is <code>9</code>.</p>
<p class="indent">Now consider this one:</p>
<pre>2
WW
6 2
LL
8 1</pre>
<p class="indent">Look at the final game that each team played: the Geese won and scored two goals, and the Hawks lost and scored one goal. That could be a rivalry game, with a total of three goals. The first game played by each team cannot be a rivalry game (the Geese won with six goals, and the Hawks could not have lost the same game with eight goals), so we can’t add any more goals. Is <code>3</code> the correct output?</p>
<p class="indent">It is not! We chose poorly, matching those final games. What we should have done is match the first game played by the Geese with the second game played by the Hawks. That could be a rivalry game, and it has seven goals. This time we’ve got it: the correct output is <code>7</code>.</p>
<p class="indent">Let’s look at one more example. Try to figure out the maximum total before reading my answer:</p>
<pre>4
WLWW
3 4 1 8
WLLL
5 1 2 3</pre>
<p class="indent">The correct output is <code>20</code>, witnessed by having two rivalry games: the second Geese game with the first Hawks game (9 goals there) and the fourth Geese game with the fourth Hawks game (11 goals there).</p>
<p class="indent">Did you predict instead that the correct output would be <code>25</code>? If so, we’re not allowed to add a rivalry of the first Geese game with the third Hawks game. Call that pair <em>x</em>. Each team’s games are played in order, so if we used <em>x</em> as a rivalry game, then we wouldn’t be allowed to also pair the second Geese game (played after <em>x</em>) with the first Hawks game (played before <em>x</em>).</p>
<h4 class="h4" id="sec52"><em>Characterizing Optimal Solutions</em></h4>
<p class="noindent">Consider an optimal solution to this problem: a solution that maximizes the number of goals scored in rivalry games. What might this optimal solution look like? Assume that the games for each team are numbered from 1 to <em>n</em>.</p>
<span epub:type="pagebreak" id="page_112"/>
<p class="noindent"><strong>Option 1</strong></p>
<p class="block95">One option is that the optimal solution uses the final game <em>n</em> played by the Geese and the final game <em>n</em> played by the Hawks as a rivalry game. That game has a certain number of goals scored in it: call that <em>g</em>. We can then strip out both of these games and optimally solve the smaller subproblem on the Geese’s first <em>n</em>–1 games and the Hawks’ first <em>n</em>–1 games. That subproblem solution, plus <em>g</em>, is the optimal solution overall. Note, though, that this option is only available if the two <em>n</em> games can really be a rivalry game. For example, if both teams have a <code>W</code> for that game, then this cannot be a rivalry game and Option 1 cannot apply.</p>
<p class="blocki">Remember this test case from the prior section?</p>
<pre>4
WLWW
3 4 1 8
WLLL
5 1 2 3</pre>
<p class="blocki">That’s an example of Option 1: we match the two rightmost scores, <code>8</code> and <code>3</code>, and then optimally solve the subproblem for the remaining games.</p>
<p class="noindent"><strong>Option 2</strong></p>
<p class="block95">Another option is that the optimal solution has nothing to do with these final games at all. In that case, we strip out game <em>n</em> played by the Geese and game <em>n</em> played by the Hawks, and we optimally solve the subproblem on the Geese’s first <em>n</em> – 1 games and the Hawks’ first <em>n</em> – 1 games.</p>
<p class="blocki">Here’s a test case from the prior section that is an example of Option 2:</p>
<pre>3
WWW
2 5 1
LLL
4 7 8</pre>
<p class="blocki">The <code>1</code> and <code>8</code> at the right are not part of an optimal solution. The optimal solution for the other games is the optimal solution overall.</p>
<p class="indenta">So far we’ve covered the case where both game <em>n</em> scores are used and the case where neither game <em>n</em> score is used. Are we done?</p>
<p class="indent">To see that we are not done, consider this test case from the previous section:</p>
<pre>2
WW
6 2
LL
8 1</pre>
<p class="indent"><span epub:type="pagebreak" id="page_113"/>Option 1, matching the <code>2</code> and <code>1</code>, leads to a maximum of three goals in rivalry games. Option 2, throwing away both the <code>2</code> and <code>1</code>, leads to a maximum of zero goals in rivalry games. However, the maximum overall here is seven. Our coverage of types of optimal solutions, using only Option 1 and Option 2, is therefore spotty.</p>
<p class="indentb">What we need to be able to do here is drop a game from the Geese but not from the Hawks. Specifically, we’d like to drop the Geese’s second game and then solve the subproblem consisting of the Geese’s first game and <em>both</em> of the Hawks’ games. For symmetry, we should also be able to drop the second Hawks game and solve the resulting subproblem on the first Hawks game and both Geese games. Let’s get these two additional options in there.</p>
<p class="noindent"><strong>Option 3</strong></p>
<p class="block95">Our third option is that the optimal solution has nothing to do with the Geese’s game <em>n</em>. In that case, we strip out game <em>n</em> played by the Geese, and we optimally solve the subproblem on the Geese’s first <em>n</em> – 1 games and the Hawks’ first <em>n</em> games.</p>
<p class="noindent"><strong>Option 4</strong></p>
<p class="block95">Our fourth and final option is that the optimal solution has nothing to do with the Hawks’ game <em>n</em>. In that case, we strip out game <em>n</em> played by the Hawks, and we optimally solve the subproblem on the Geese’s first <em>n</em> games and the Hawks’ first <em>n</em> – 1 games.</p>
<p class="indenta">Options 3 and 4 induce a change in the structure of a solution to this problem—whether that solution uses recursion, memoization, or dynamic programming. In the previous problems of this chapter, our subproblems were characterized by only one varying parameter: <em>t</em> for Burger Fervor and <em>k</em> for Moneygrubbers. Without Options 3 and 4, we’d have gotten away with a single parameter, <em>n</em>, for the Hockey Rivalry problem, too. That <em>n</em> parameter would have reflected the fact that we were solving a subproblem for the first <em>n</em> games played by the Geese and the first <em>n</em> games played by the Hawks. With Options 3 and 4 in the mix, however, these <em>n</em> values are no longer yoked: one can change when the other does not. For example, if we’re solving a subproblem concerning the first five games played by the Geese, this does not mean that we’re stuck looking at the first five games played by the Hawks. Symmetrically, a subproblem concerning the first five games played by the Hawks doesn’t tell us anything about the number of games played by the Geese.</p>
<p class="indent">We therefore need two parameters for our subproblems: <em>i</em>, the number of games played by the Geese, and <em>j</em>, the number of games played by the Hawks.</p>
<p class="indent">For a given optimization problem, the number of subproblem parameters could be one, two, three, or more. When confronting a new problem, I suggest beginning with one subproblem parameter. Then, think about the possible options for an optimal solution. Perhaps each option can be solved by solving one-parameter subproblems, in which case additional parameters are not required. However, sometimes it will be that one or more options <span epub:type="pagebreak" id="page_114"/>require the solution to a subproblem that cannot be pinned down by one parameter. In these cases, a second parameter can often help.</p>
<p class="indent">The benefit of adding additional subproblem parameters is the larger subproblem space in which to couch our optimal solutions. The cost is the responsibility of solving more subproblems. Keeping the number of parameters small—one, two, or perhaps three—is key for designing fast solutions to optimization problems.</p>
<p class="indent">Before we move on, I want to highlight an important difference between the way that we solved Burger Fervor and Moneygrubbers and the way that we’re solving Hockey Rivalry. In the two earlier problems, we focused on solving for exactly <em>t</em> minutes or exactly <em>k</em> apples. Here, by contrast, we’re not forcing our subproblems to use any specific game. For example, a subproblem involving the first <em>i</em> games played by the Geese isn’t forced to use Geese game <em>i</em>. The difference arose as a byproduct of our analysis of the structure of optimal solutions. Each time we use dynamic programming, we need to choose whether to use “exactly.” If we had chosen to use “exactly” for Hockey Rivalry, then we would have ended up with comparably slower and more complicated code. I’ve included that code in the online resources for this book—check it out once you’re done here!</p>
<p class="indent">If you’re struggling to relate a problem to smaller subproblems, or struggling to solve subproblems efficiently, it’s worth adding or removing “exactly” and trying again. We’ll continue to practice identifying subproblems in the next chapter.</p>
<h4 class="h4" id="sec53"><em>Solution 1: Recursion</em></h4>
<p class="noindent">It’s now time for our recursive solution. Here’s the signature for the <code>solve</code> function that we’ll write this time:</p>
<pre>int solve(char outcome1[], char outcome2[], int goals1[],
          int goals2[], int i, int j)</pre>
<p class="indent">The first four parameters come directly from the current test case, while the fifth and sixth are the subproblem parameters. Here are brief descriptions of the parameters:</p>
<p class="block"><span class="codestrong">outcome1</span>   The array of <code>W</code> and <code>L</code> characters for the Geese</p>
<p class="block"><span class="codestrong">outcome2</span>   The array of <code>W</code> and <code>L</code> characters for the Hawks</p>
<p class="block"><span class="codestrong">goals1</span>   The array of goals scored for the Geese</p>
<p class="block"><span class="codestrong">goals2</span>   The array of goals scored for the Hawks</p>
<p class="block5"><span class="codestrong">i</span>   The number of Geese games that we’re considering in this subproblem</p>
<p class="block"><span class="codestrong">j</span>   The number of Hawks games that we’re considering in this subproblem</p>
<span epub:type="pagebreak" id="page_115"/>
<p class="noindent">The last two parameters—the ones specific to the current subproblem—are the only parameters that change on recursive calls.</p>
<p class="indent">If we started each of the arrays at index <code>0</code>, as is standard for C arrays, then we’d have to keep in our minds that information for some game <code>k</code> was not at index <code>k</code> but at index <code>k - 1</code>. For example, information about game four would be at index <code>3</code>. To avoid this, we’ll store information about games starting at index <code>1</code>, so information about game four will be at index <code>4</code>. This leaves us with one less mistake to make! In addition, it frees up the value <code>0</code> to characterize zero games played.</p>
<p class="indent">The code for the recursive solution is given in <a href="ch03.xhtml#ch03ex016">Listing 3-16</a>.</p>
<pre><span class="ent">❶</span> int max(int v1, int v2) {
     if (v1 &gt; v2)
       return v1;
     else
       return v2;
  }

  int solve(char outcome1[], char outcome2[], int goals1[],
            int goals2[], int i, int j) {
 <span class="ent">➋</span> int first, second, third, fourth;
 <span class="ent">➌</span> if (i == 0 || j == 0)
      return 0;
 <span class="ent">➍</span> if ((outcome1[i] == 'W' &amp;&amp; outcome2[j] == 'L' &amp;&amp;
        goals1[i] &gt; goals2[j]) ||
       (outcome1[i] == 'L' &amp;&amp; outcome2[j] == 'W' &amp;&amp;
        goals1[i] &lt; goals2[j]))
  <span class="ent">➎</span> first = solve(outcome1, outcome2, goals1, goals2, i - 1, j - 1) +
             goals1[i] + goals2[j];
   else
     first = 0;
<span class="ent">➏</span> second = solve(outcome1, outcome2, goals1, goals2, i - 1, j - 1);
<span class="ent">❼</span> third = solve(outcome1, outcome2, goals1, goals2, i - 1, j);
<span class="ent">❽</span> fourth = solve(outcome1, outcome2, goals1, goals2, i, j - 1);
<span class="ent">❾</span> return max(first, max(second, max(third, fourth)));
}</pre>
<p class="excap" id="ch03ex016"><em>Listing 3-16: Solution 1</em></p>
<p class="indent">This is a maximization problem: we want to maximize the number of goals scored in rivalry games. We start with a <code>max</code> function <span class="ent">❶</span>—we’ll use that when we need to determine which of the options is best. We then declare four integer variables, one for each of the four options <span class="ent">➋</span>.</p>
<p class="indent">Let’s begin with base cases: What do we return if both <code>i</code> and <code>j</code> are <code>0</code>? This subproblem is for the first zero Geese games and zero Hawks games. Since there are no games, there are certainly no rivalry games, and since there are no rivalry games, there are no goals scored in rivalry games. We should therefore return <code>0</code> here.</p>
<p class="indent"><span epub:type="pagebreak" id="page_116"/>That isn’t the only base case, though. For example, consider the subproblem where the Geese play zero games (<code>i = 0</code>) and the Hawks play three games (<code>j = 3</code>). As with the case in the prior paragraph, there can’t be any rivalry games here, because the Geese don’t have any games! A similar situation arises when the Hawks play zero games: even if the Geese play some games, none of them can be against the Hawks.</p>
<p class="indent">That captures all of the base cases. That is to say, if <code>i</code> has value <code>0</code> <em>or</em> <code>j</code> has value <code>0</code>, then we have zero goals scored in rivalry games <span class="ent">➌</span>.</p>
<p class="indentb">With the base cases out of the way, we must now try the four possible options for an optimal solution and choose the best one.</p>
<p class="noindent"><strong>Option 1</strong></p>
<p class="block95">Recall that this option is valid only when the final Geese game and final Hawks game can be a rivalry game. There are two ways for this game to be a rivalry game:</p>
<ol>
<li class="noindentdd">The Geese win, the Hawks lose, and the Geese score more goals than the Hawks.</li>
<li class="noindentdd">The Geese lose, the Hawks win, and the Geese score fewer goals than the Hawks.</li>
</ol>
<p class="block95">We encode these two possibilities <span class="ent">➍</span>. If the game can be a rivalry game, we compute the optimal solution for this option <span class="ent">➎</span>: it consists of the optimal solution for the first <code>i - 1</code> Geese games and <code>j - 1</code> Hawks games plus the total goals scored in the rivalry game.</p>
<p class="noindent"><strong>Option 2</strong></p>
<p class="block95">For this one, we solve the subproblem for the first <code>i - 1</code> Geese games and <code>j - 1</code> Hawks games <span class="ent">➏</span>.</p>
<p class="noindent"><strong>Option 3</strong></p>
<p class="block95">Here, we solve the subproblem for the first <code>i - 1</code> Geese games and <code>j</code> Hawks games <span class="ent">❼</span>. Notice that <code>i</code> changes but <code>j</code> does not. This is exactly why we need two subproblem parameters here, not one.</p>
<p class="noindent"><strong>Option 4</strong></p>
<p class="block95">We solve the subproblem for the first <code>i</code> Geese games and <code>j - 1</code> Hawks games <span class="ent">❽</span>. Again, one subproblem parameter changes but the other does not; it’s a good thing there’s no need for us to keep them at the same value!</p>
<p class="indenta">There we go: <code>first</code>, <code>second</code>, <code>third</code>, and <code>fourth</code>—those are the only four possibilities for our optimal solution. We want the maximum of these, and that is what we compute and return <span class="ent">❾</span>. The innermost <code>max</code> call calculates the maximum of <code>third</code> and <code>fourth</code>. Working outward, the next <code>max</code> call calculates the maximum of that winner and <code>second</code>. Finally, the outermost call calculates the maximum of that winner and <code>first</code>.</p>
<p class="indent">We’re just about there. All we need now is a <code>main</code> function that reads the five lines of input and calls <code>solve</code>. The code is given in <a href="ch03.xhtml#ch03ex017">Listing 3-17</a>.</p>
<pre> #define SIZE 1000

 int main(void) {
   int i, n, result;
<span class="ent">❶</span> char outcome1[SIZE + 1], outcome2[SIZE + 1];
<span class="ent">➋</span> int goals1[SIZE + 1], goals2[SIZE + 1];
<span class="ent">➌</span> scanf("%d ", &amp;n);
   for (i = 1; i &lt;= n; i++)
     scanf("%c", &amp;outcome1[i]);
   for (i = 1; i &lt;= n; i++)
     scanf("%d ", &amp;goals1[i]);
   for (i = 1; i &lt;= n; i++)
     scanf("%c", &amp;outcome2[i]);
   for (i = 1; i &lt;= n; i++)
     scanf("%d", &amp;goals2[i]);
    result = solve(outcome1, outcome2, goals1, goals2, n, n);
    printf("%d\n", result);
    return 0;
}</pre>
<span epub:type="pagebreak" id="page_117"/>
<p class="excap" id="ch03ex017"><em>Listing 3-17: The main function</em></p>
<p class="indent">We declare the outcome (<code>W</code> and <code>L</code>) <span class="ent">❶</span> and goals-scored arrays <span class="ent">➋</span>. The <code>+ 1</code> there is because of our choice to begin indexing at <code>1</code>. If we had used just <code>SIZE</code>, then valid indices would go from zero to 999, when what we need is to include index 1,000.</p>
<p class="indent">We then read the integer on the first line <span class="ent">➌</span>, which gives the number of games played by the Geese and Hawks. There’s a space right after the <code>%d</code> and before the closing quote. That space causes <code>scanf</code> to read whitespace following the integer. Crucially, this reads the newline character at the end of the line, which otherwise would be included when we use <code>scanf</code> to read individual characters . . . which we do next!</p>
<p class="indent">We read the <code>W</code> and <code>L</code> information for the Geese and then read the goals-scored information for the Geese. We then do the same for the Hawks. Finally, we call <code>solve</code>. We want to solve the problem considering all <em>n</em> Geese games and all <em>n</em> Hawks games, which explains why the last two arguments are <code>n</code>. We know exactly how to call <code>solve</code> to get our answer in one shot; unlike for our solutions to Burger Fervor and Moneygrubbers, we don’t need to search for it.</p>
<p class="indent">Any chance you’ll submit this solution to the judge? The “Time-Limit Exceeded” error should come as no surprise.</p>
<h4 class="h4" id="sec54"><em>Solution 2: Memoization</em></h4>
<p class="noindent">In Burger Fervor and Moneygrubbers, we used a one-dimensional array for the memo. That’s because our subproblems had but one parameter: the number of minutes and number of apples, respectively. In contrast, the subproblems in Hockey Rivalry have two parameters, not one. We’ll correspondingly need a memo array with two dimensions, not one. Element <code>memo[i][j]</code> is used to hold the solution to the subproblem on the first <code>i</code> Geese games and the first <code>j</code> Hawks games. Other than switching from one to two <span epub:type="pagebreak" id="page_118"/>dimensions in the memo, the technique remains as before: return the solution if it’s already stored; calculate and store it if it’s not.</p>
<p class="indent">The updated <code>main</code> function is given in <a href="ch03.xhtml#ch03ex018">Listing 3-18</a>.</p>
<pre>int main(void) {
  int i, j, n, result;
  char outcome1[SIZE + 1], outcome2[SIZE + 1];
  int goals1[SIZE + 1], goals2[SIZE + 1];
  static int memo[SIZE + 1][SIZE + 1];
  scanf("%d ", &amp;n);
  for (i = 1; i &lt;= n; i++)
    scanf("%c", &amp;outcome1[i]);
  for (i = 1; i &lt;= n; i++)
    scanf("%d ", &amp;goals1[i]);
  for (i = 1; i &lt;= n; i++)
    scanf("%c", &amp;outcome2[i]);
  for (i = 1; i &lt;= n; i++)
    scanf("%d", &amp;goals2[i]);
  for (i = 0; i &lt;= SIZE; i++)
    for (j = 0; j &lt;= SIZE; j++)
      memo[i][j] = -1;
  result = solve(outcome1, outcome2, goals1, goals2, n, n, memo);
  printf("%d\n", result);
  return 0;
}</pre>
<p class="excap" id="ch03ex018"><em>Listing 3-18: The main function, with memoization implemented</em></p>
<p class="indent">Notice that the <code>memo</code> array is huge—over 1,000 elements in each dimension and therefore over 1 million elements in all—so we make the array static as in <a href="ch01.xhtml#ch01ex08">Listing 1-8</a>.</p>
<p class="indent">The memoized <code>solve</code> function is given in <a href="ch03.xhtml#ch03ex019">Listing 3-19</a>.</p>
<pre>int solve(char outcome1[], char outcome2[], int goals1[],
          int goals2[], int i, int j, int memo[SIZE + 1][SIZE + 1]) {
  int first, second, third, fourth;
  if (memo[i][j] != -1)
    return memo[i][j];
  if (i == 0 || j == 0) {
    memo[i][j] = 0;
    return memo[i][j];
  }
  if ((outcome1[i] == 'W' &amp;&amp; outcome2[j] == 'L' &amp;&amp;
       goals1[i] &gt; goals2[j]) ||
      (outcome1[i] == 'L' &amp;&amp; outcome2[j] == 'W' &amp;&amp;
       goals1[i] &lt; goals2[j]))
    first = solve(outcome1, outcome2, goals1, goals2, i - 1, j - 1, memo) +
            goals1[i] + goals2[j];
  else
    first = 0;
  second = solve(outcome1, outcome2, goals1, goals2, i - 1, j - 1, memo);
  third = solve(outcome1, outcome2, goals1, goals2, i - 1, j, memo);
  fourth = solve(outcome1, outcome2, goals1, goals2, i, j - 1, memo);
  memo[i][j] = max(first, max(second, max(third, fourth)));
  return memo[i][j];
}</pre>
<span epub:type="pagebreak" id="page_119"/>
<p class="excap" id="ch03ex019"><em>Listing 3-19: Solution 2, with memoization implemented</em></p>
<p class="indent">This solution passes all test cases and does so quickly. If we just wanted to solve this problem, we would stop right now, but here we have the opportunity to plumb further and learn more about dynamic programming as we do so.</p>
<h4 class="h4" id="sec55"><em>Solution 3: Dynamic Programming</em></h4>
<p class="noindent">We just saw that to memoize this problem we needed a two-dimensional <code>memo</code> array, not a one-dimensional array. To develop a dynamic-programming solution, we’ll correspondingly need a two-dimensional <code>dp</code> array. We declared the <code>memo</code> array as follows in <a href="ch03.xhtml#ch03ex018">Listing 3-18</a>:</p>
<pre>static int memo[SIZE + 1][SIZE + 1];</pre>
<p class="noindent">and we’ll do likewise for the <code>dp</code> array:</p>
<pre>static int dp[SIZE + 1][SIZE + 1];</pre>
<p class="indent">As in the <code>memo</code> array, element <code>dp[i][j]</code> will hold the subproblem solution for the first <code>i</code> Geese games and first <code>j</code> Hawks games. Our task, then, is to solve each of these subproblems and return <code>dp[n][n]</code> once we’re done.</p>
<p class="indent">In memoized solutions to optimization problems, it’s not our responsibility to determine an order in which to solve the subproblems. We make our recursive calls, and those calls return to us the solutions for their corresponding subproblems. In dynamic-programming solutions, however, it <em>is</em> our responsibility to determine an order in which to solve the subproblems. We can’t just solve them in any order we want, because then a subproblem solution might not be available when we need it.</p>
<p class="indent">For example, suppose we wanted to fill in <code>dp[3][5]</code>—that’s the cell for the first three Geese games and the first five Hawks games. Take another look back at the four options for an optimal solution.</p>
<ul>
<li class="noindent">Option 1 requires us to look up <code>dp[2][4]</code>.</li>
<li class="noindent">Option 2 also requires us to look up <code>dp[2][4]</code>.</li>
<li class="noindent">Option 3 requires us to look up <code>dp[2][5]</code>.</li>
<li class="noindent">Option 4 requires us to look up <code>dp[3][4]</code>.</li>
</ul>
<p class="indent">We must arrange it so that these elements of <code>dp</code> are already stored by the time we want to store <code>dp[3][5]</code>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_120"/>For subproblems with only one parameter, you generally solve those subproblems from smallest index to largest index. For subproblems with more than one parameter, things are not so simple, as there are many more orders in which the array can be filled. Only some of these orders maintain the property that a subproblem solution is available by the time we need it.</p>
<p class="indent">For the Hockey Rivalry problem, we can solve <code>dp[i][j]</code> if we’ve already stored <code>dp[i - 1][j - 1]</code> (Option 1 and Option 2), <code>dp[i - 1][j]</code> (Option 3), and <code>dp[i][j - 1]</code> (Option 4). One order we can use is to solve all of the <code>dp[i - 1]</code> subproblems before solving any of the <code>dp[i]</code> subproblems. For example, this would result in <code>dp[2][4]</code> being solved before <code>dp[3][5]</code>, which is exactly what we need to satisfy Options 1 and 2. It would also result in <code>dp[2][5]</code> being solved before <code>dp[3][5]</code>, which is what we need for Option 3. That is, solving row <code>i - 1</code> before row <code>i</code> satisfies Options 1 to 3.</p>
<p class="indent">To satisfy Option 4, we can solve the <code>dp[i]</code> subproblems from smallest <code>j</code> index to largest <code>j</code> index. That, for example, would solve <code>dp[3][4]</code> before <code>dp[3][5]</code>.</p>
<p class="indent">In summary, we solve all of the subproblems in row <code>0</code> from left to right, then all of the subproblems in row <code>1</code> from left to right, and so on, until we have solved all subproblems in row <code>n</code>.</p>
<p class="indent">The <code>solve</code> function is given in <a href="ch03.xhtml#ch03ex020">Listing 3-20</a>.</p>
<pre>int solve(char outcome1[], char outcome2[], int goals1[],
          int goals2[], int n) {
  int i, j;
  int first, second, third, fourth;
  static int dp[SIZE + 1][SIZE + 1];
  for (i = 0; i &lt;= n; i++)
    dp[0][i] = 0;
  for (i = 0; i &lt;= n; i++)
    dp[i][0] = 0;
 <span class="ent">❶</span> for (i = 1; i &lt;= n; i++)
   <span class="ent">➋</span> for (j = 1; j &lt;= n; j++) {
        if ((outcome1[i] == 'W' &amp;&amp; outcome2[j] == 'L' &amp;&amp;
             goals1[i] &gt; goals2[j]) ||
            (outcome1[i] == 'L' &amp;&amp; outcome2[j] == 'W' &amp;&amp;
             goals1[i] &lt; goals2[j]))
         first = dp[i - 1][j - 1] + goals1[i] + goals2[j];
       else
         first = 0;
       second = dp[i - 1][j - 1];
       third = dp[i - 1][j];
       fourth = dp[i][j - 1];
       dp[i][j] = max(first, max(second, max(third, fourth)));
     }
<span class="ent">➌</span> return dp[n][n];
}</pre>
<p class="excap" id="ch03ex020"><em>Listing 3-20: Solution 3, with dynamic programming</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_121"/>We begin by initializing the base case subproblems, which are those in which at least one of the indices is <code>0</code>. Then, we hit the double <code>for</code> loop <span class="ent">❶</span> <span class="ent">➋</span>, which controls the order in which the non-base-case subproblems are solved. We first range over the rows <span class="ent">❶</span> and then the elements in each row <span class="ent">➋</span>, which, as we have argued, is a valid order for solving the subproblems. Once we have filled in the table, we return the solution for the original problem <span class="ent">➌</span>.</p>
<p class="indent">We’re solving <em>n</em><sup>2</sup> subproblems here, each of which takes us a constant number of steps. Therefore, we’ve achieved an <em>O</em>(<em>n</em><sup>2</sup>) solution.</p>
<p class="indent">We can visualize the array produced by a two-dimensional dynamic-programming algorithm as a table. This is helpful for getting a feel for how the elements of the array are filled in. Let’s look at the final array for the following test case:</p>
<pre>4
WLWW
3 4 1 8
WLLL
5 1 2 3</pre>
<p class="indent">Here’s the resulting array:</p>
<div class="image1"><img alt="Image" src="../images/unch03fig01.jpg"/></div>
<p class="indent">Consider, for example, the computation for the element in row <code>4</code>, column <code>2</code> or, in terms of the <code>dp</code> table, <code>dp[4][2]</code>. This is the subproblem for the first four Geese games and first two Hawks games. Looking at the Geese’s game four and the Hawks’ game two, we see that the Geese won with eight goals and the Hawks lost with one goal, so this game could be a rivalry game. Option 1 is therefore a possible option. Nine goals were scored in this game. To that nine, we add the value at row <code>3</code>, column <code>1</code>, which is nine again. This gives us a total of 18. That’s our maximum so far—now we have to try Options 2 to 4 to see whether they are better. If you do that, you should observe that they all happen to have the value nine. We therefore store 18, the maximum of all available options, in <code>dp[4][2]</code>.</p>
<p class="indent">The only quantity of real interest here, of course, is that in the topmost, rightmost cell, corresponding to the subproblem allowing the full <code>n</code> games for the Geese and <code>n</code> games for the Hawks. That value, 20, is what we return as the optimal solution. The other quantities in the table are only useful insofar as they help us make progress toward calculating that 20.</p>
<p class="indent"><span epub:type="pagebreak" id="page_122"/>In terms of the <code>main</code> function, we make one small change to the code of <a href="ch03.xhtml#ch03ex017">Listing 3-17</a>: the only thing to do is remove the second <code>n</code> passed to <code>solve</code>, resulting in:</p>
<pre>result = solve(outcome1, outcome2, goals1, goals2, n);</pre>
<h4 class="h4" id="sec56"><em>A Space Optimization</em></h4>
<p class="noindent">I mentioned in “Step 4: Dynamic Programming” on <a href="#sec44">page 97</a> that memoization and dynamic programming are roughly equivalent. <em>Roughly</em>, because sometimes there are benefits to be had by choosing one or the other. The Hockey Rivalry problem furnishes an example of a typical optimization that we can perform when using dynamic programming but not when using memoization. The optimization is not one of speed but of space.</p>
<p class="indent">Here’s the key question: When solving a subproblem in row <code>i</code> of the <code>dp</code> array, which rows do we access? Look back at the four options. The only rows used are <code>i - 1</code> (the previous row) and <code>i</code> (the current row). There’s no <code>i - 2</code> or <code>i - 3</code> or anything else in there. As such, keeping the entire two-dimensional array in memory is wasteful. Suppose we’re solving subproblems in row 500. All we need is access to row 500 and row 499. We might as well not have row 498 or 497 or 496 or any other row in memory, because we’ll never look at these again.</p>
<p class="indent">Rather than a two-dimensional table, we can pull through with only two one-dimensional arrays: one for the previous row and one for the current row we are solving.</p>
<p class="indent"><a href="ch03.xhtml#ch03ex021">Listing 3-21</a> implements this optimization.</p>
<pre>int solve(char outcome1[], char outcome2[], int goals1[],
          int goals2[], int n) {
   int i, j, k;
   int first, second, third, fourth;
   static int previous[SIZE + 1], current[SIZE + 1];
<span class="ent">❶</span> for (i = 0; i &lt;= n; i++)
  <span class="ent">➋</span> previous[i] = 0;
  for (i = 1; i &lt;= n; i++) {
    for (j = 1; j &lt;= n; j++) {
      if ((outcome1[i] == 'W' &amp;&amp; outcome2[j] == 'L' &amp;&amp;
           goals1[i] &gt; goals2[j]) ||
          (outcome1[i] == 'L' &amp;&amp; outcome2[j] == 'W' &amp;&amp;
           goals1[i] &lt; goals2[j]))
         first = previous[j - 1] + goals1[i] + goals2[j];
      else
        first = 0;
      second = previous[j - 1];
      third = previous[j];
      fourth = current[j - 1];
      current[j] = max(first, max(second, max(third, fourth)));
   }
<span class="ent">➌</span> for (k = 0; k &lt;= SIZE; k++)
  <span class="ent">➍</span> previous[k] = current[k];
  }
  return current[n];
}</pre>
<span epub:type="pagebreak" id="page_123"/>
<p class="excap" id="ch03ex021"><em>Listing 3-21: Solution 3, with space optimization implemented</em></p>
<p class="indent">We initialize <code>previous</code> to all zeros <span class="ent">❶</span> <span class="ent">➋</span>, thereby solving all subproblems in row <code>0</code>. In the rest of the code, whenever we previously referred to row <code>i - 1</code>, we now use <code>previous</code>. In addition, whenever we previously referred to row <code>i</code>, we now use <code>current</code>. Once a new row has been fully solved and stored in <code>current</code>, we copy <code>current</code> into <code>previous</code> <span class="ent">➌</span> <span class="ent">➍</span> so that <code>current</code> can be used to solve the next row.</p>
<h3 class="h3" id="lev26">Summary</h3>
<p class="noindent">I’ve presented what I think of as the core of memoization and dynamic programming: explicating the structure of an optimal solution, developing a recursive algorithm, speeding it up through memoization, and optionally replacing the recursion by filling a table.</p>
<p class="indent">There’s more to learn, though. What if I showed you how to crack some nasty dynamic-programming problems merely through a change in perspective? What if I told you that we can work with three or more dimensions to solve the toughest dynamic-programming problems?</p>
<p class="indent">In the next chapter, you’ll learn all that and more. See you there!</p>
<h3 class="h3" id="lev27">Notes</h3>
<p class="noindent">Hockey Rivalry is originally from the 2018 Canadian Computing Olympiad.</p>
<p class="indent">Sometimes, you need to know not only the value of an optimal solution, but the decisions that you should make to achieve that solution. Check out “Burger Fervor: Reconstructing a Solution” in <a href="app02.xhtml">Appendix B</a> for an example of how to do this.</p>
<p class="indent">Many algorithm textbooks delve deeper into the theory and application of memoization and dynamic programming. My favorite treatment is <em>Algorithm Design</em> by Jon Kleinberg and Éva Tardos (2006).<span epub:type="pagebreak" id="page_124"/></p>
</body></html>