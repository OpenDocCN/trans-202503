["```\n1\n7\n7\n1\n1\n4\n6\n```", "```\ntypedef struct position {\n  int row, col;\n} position;\n```", "```\n#define MAX_ROWS 99\n#define MAX_COLS 99\n\ntypedef int board[MAX_ROWS + 1][MAX_COLS + 1];\n```", "```\ntypedef position positions[MAX_ROWS * MAX_COLS];\n```", "```\nint find_distance(int knight_row, int knight_col,\n                  int dest_row, int dest_col,\n                  int num_rows, int num_cols)\n```", "```\nint find_distance(int knight_row, int knight_col,\n                  int dest_row, int dest_col,\n                  int num_rows, int num_cols) {\n  positions cur_positions, new_positions;\n  int num_cur_positions, num_new_positions;\n  int i, j, from_row, from_col;\n  board min_moves;\n  for (i = 1; i <= num_rows; i++)\n    for (j = 1; j <= num_cols; j++)\n      min_moves[i][j] = -1;\n➊ min_moves[knight_row][knight_col] = 0;\n➋ cur_positions[0] = (position){knight_row, knight_col};\n   num_cur_positions = 1;\n\n➌ while (num_cur_positions > 0) {\n     num_new_positions = 0;\n     for (i = 0; i < num_cur_positions; i++) {\n       from_row = cur_positions[i].row;\n       from_col = cur_positions[i].col;\n     ➍ if (from_row == dest_row && from_col == dest_col)\n          return min_moves[dest_row][dest_col];\n\n     ➎ add_position(from_row, from_col, from_row + 1, from_col + 2,\n                     num_rows, num_cols, new_positions,\n                     &num_new_positions, min_moves);\n        add_position(from_row, from_col, from_row + 1, from_col - 2,\n                     num_rows, num_cols, new_positions,\n                     &num_new_positions, min_moves);\n        add_position(from_row, from_col, from_row - 1, from_col + 2,\n                     num_rows, num_cols, new_positions,\n                     &num_new_positions, min_moves); add_position(from_row, from_col, from_row - 1, from_col - 2,\n                     num_rows, num_cols, new_positions,\n                     &num_new_positions, min_moves);\n        add_position(from_row, from_col, from_row + 2, from_col + 1,\n                     num_rows, num_cols, new_positions,\n                     &num_new_positions, min_moves);\n        add_position(from_row, from_col, from_row + 2, from_col - 1,\n                     num_rows, num_cols, new_positions,\n                     &num_new_positions, min_moves);\n        add_position(from_row, from_col, from_row - 2, from_col + 1,\n                     num_rows, num_cols, new_positions,\n                     &num_new_positions, min_moves);\n        add_position(from_row, from_col, from_row - 2, from_col - 1,\n                     num_rows, num_cols, new_positions,\n                     &num_new_positions, min_moves);\n    }\n\n  ➏ num_cur_positions = num_new_positions;\n     for (i = 0; i < num_cur_positions; i++)\n       cur_positions[i] = new_positions[i];\n  }\n  return -1;\n}\n```", "```\nvoid add_position(int from_row, int from_col,\n                  int to_row, int to_col,\n                  int num_rows, int num_cols,\n                  positions new_positions, int *num_new_positions,\n                  board min_moves) {\n  struct position new_position;\n  if (to_row >= 1 && to_col >= 1 &&\n      to_row <= num_rows && to_col <= num_cols &&\n      min_moves[to_row][to_col] == -1) {\n  ➊ min_moves[to_row][to_col] = 1 + min_moves[from_row][from_col];\n     new_position = (position){to_row, to_col};\n     new_positions[*num_new_positions] = new_position;\n     (*num_new_positions)++;\n  }\n}\n```", "```\n// bugged!\nvoid solve(int pawn_row, int pawn_col,\n           int knight_row, int knight_col,\n           int num_rows, int num_cols) {\n   int cur_pawn_row, num_moves, knight_takes;\n\n➊ cur_pawn_row = pawn_row;\n   num_moves = 0;\n   while (cur_pawn_row < num_rows) {\n     knight_takes = find_distance(knight_row, knight_col,\n                                  cur_pawn_row, pawn_col,\n                                  num_rows, num_cols);\n  ➋ if (knight_takes == num_moves) {\n       printf(\"Win in %d knight move(s).\\n\", num_moves);\n       return;\n    }\n    cur_pawn_row++;\n    num_moves++;\n  }\n\n➌ cur_pawn_row = pawn_row;\n   num_moves = 0;\n   while (cur_pawn_row < num_rows) {\n     knight_takes = find_distance(knight_row, knight_col,\n                                  cur_pawn_row + 1, pawn_col,\n                                  num_rows, num_cols);\n     if (knight_takes == num_moves) {\n       printf(\"Stalemate in %d knight move(s).\\n\", num_moves);\n       return;\n    }\n    cur_pawn_row++;\n    num_moves++;\n }\n\n➍ printf(\"Loss in %d knight move(s).\\n\", num_rows - pawn_row - 1);\n}\n```", "```\nint main(void) {\n  int num_cases, i;\n  int num_rows, num_cols, pawn_row, pawn_col, knight_row, knight_col;\n  scanf(\"%d\", &num_cases);\n  for (i = 0; i < num_cases; i++) {\n    scanf(\"%d%d\", &num_rows, &num_cols);\n    scanf(\"%d%d\", &pawn_row, &pawn_col);\n    scanf(\"%d%d\", &knight_row, &knight_col);\n    solve(pawn_row, pawn_col, knight_row, knight_col, num_rows, num_cols);\n  }\n  return 0;\n}\n```", "```\n1\n5\n3\n1\n1\n3\n1\n```", "```\nLoss in 3 knight move(s).\n```", "```\nif (knight_takes == num_moves) {\n```", "```\nif (knight_takes >= 0 && num_moves >= knight_takes &&\n    (num_moves - knight_takes) % 2 == 0) {\n```", "```\nvoid solve(int pawn_row, int pawn_col,\n           int knight_row, int knight_col,\n           int num_rows, int num_cols) {\n  int cur_pawn_row, num_moves, knight_takes;\n\n  cur_pawn_row = pawn_row;\n  num_moves = 0;\n  while (cur_pawn_row < num_rows) {\n    knight_takes = find_distance(knight_row, knight_col,\n                                 cur_pawn_row, pawn_col,\n                                 num_rows, num_cols);\n  ➊ if (knight_takes >= 0 && num_moves >= knight_takes &&\n        (num_moves - knight_takes) % 2 == 0) {\n      printf(\"Win in %d knight move(s).\\n\", num_moves);\n      return;\n    }\n    cur_pawn_row++;\n    num_moves++;\n  }\n\n  cur_pawn_row = pawn_row;\n  num_moves = 0;\n  while (cur_pawn_row < num_rows) {\n    knight_takes = find_distance(knight_row, knight_col,\n                                 cur_pawn_row + 1, pawn_col,\n                                 num_rows, num_cols);\n  ➋ if (knight_takes >= 0 && num_moves >= knight_takes &&\n        (num_moves - knight_takes) % 2 == 0) {\n      printf(\"Stalemate in %d knight move(s).\\n\", num_moves);\n return;\n    }\n    cur_pawn_row++;\n    num_moves++;\n  }\n\n  printf(\"Loss in %d knight move(s).\\n\", num_rows - pawn_row - 1);\n}\n```", "```\n10 4 1\n8 9\n```", "```\n#define SIZE 1000000\n\ntypedef int board[SIZE * 2];\ntypedef int positions[SIZE * 2];\n```", "```\nvoid find_distances(int target_height, int jump_distance,\n                    int itching[], board min_moves) {\n  static positions cur_positions, new_positions;\n  int num_cur_positions, num_new_positions;\n  int i, j, from_height;\n  for (i = 0; i < target_height * 2; i++)\n ➊ min_moves[i] = -1;\n  min_moves[0] = 0;\n  cur_positions[0] = 0;\n  num_cur_positions = 1;\n\n  while (num_cur_positions > 0) {\n    num_new_positions = 0;\n    for (i = 0; i < num_cur_positions; i++) {\n      from_height = cur_positions[i];\n\n   ➋ add_position(from_height, from_height + jump_distance,\n                   target_height * 2 - 1,\n                   new_positions, &num_new_positions,\n                   itching, min_moves);\n   ➌ for (j = 0; j < from_height; j++)\n        add_position(from_height, j,\n                     target_height * 2 - 1,\n                     new_positions, &num_new_positions,\n                     itching, min_moves);\n    }\n\n    num_cur_positions = num_new_positions;\n    for (i = 0; i < num_cur_positions; i++)\n      cur_positions[i] = new_positions[i];\n }\n}\n```", "```\nvoid add_position(int from_height, int to_height, int max_height,\n                  positions new_positions, int *num_new_positions,\n                  int itching[], board min_moves) {\n  if (to_height <= max_height && itching[to_height] == 0 &&\n      min_moves[to_height] == -1) {\n    min_moves[to_height] = 1 + min_moves[from_height];\n    new_positions[*num_new_positions] = to_height;\n    (*num_new_positions)++;\n  }\n}\n```", "```\nvoid solve(int target_height, board min_moves) {\n➊ int best = -1;\n   int i;\n   for (i = target_height; i < target_height * 2; i++)\n  ➋ if (min_moves[i] != -1 && (best == -1 || min_moves[i] < best))\n      best = min_moves[i];\n   printf(\"%d\\n\", best);\n}\n```", "```\nint main(void) {\n  int target_height, jump_distance, num_itching_sections;\n  static int itching[SIZE * 2] = {0};\n  static board min_moves;\n  int i, j, itch_start, itch_end;\n  scanf(\"%d%d%d\", &target_height, &jump_distance, &num_itching_sections);\n  for (i = 0; i < num_itching_sections; i++) {\n    scanf(\"%d%d\", &itch_start, &itch_end);\n ➊ for (j = itch_start; j <= itch_end; j++)\n   ➋ itching[j] = 1;  \n  }\n  find_distances(target_height, jump_distance, itching, min_moves);\n  solve(target_height, min_moves);\n\n  return 0;\n}\n```", "```\n30000 5 0\n```", "```\n60000 5 0\n```", "```\n120000 5 0\n```", "```\ntypedef struct position {\n  int height, state;\n} position;\n\ntypedef int board[SIZE * 2][2];\ntypedef position positions[SIZE * 4];\n```", "```\nvoid add_position_up(int from_height, int to_height, int max_height,\n                     positions pos, int *num_pos,\n                     int itching[], board min_moves) {\n➊ int distance = 1 + min_moves[from_height][0];\n   if (to_height <= max_height && itching[to_height] == 0 &&\n   ➋ (min_moves[to_height][0] == -1 ||\n       min_moves[to_height][0] > distance)) {\n   min_moves[to_height][0] = distance;\n   pos[*num_pos] = (position){to_height, 0};\n   (*num_pos)++;\n  }\n}\n```", "```\nvoid add_position_down(int from_height, int to_height,\n                       positions pos, int *num_pos,\n                       board min_moves) {\n➊ int distance = min_moves[from_height][1];\n   if (to_height >= 0 &&\n       (min_moves[to_height][1] == -1 ||\n        min_moves[to_height][1] > distance)) {\n     min_moves[to_height][1] = distance;\n     pos[*num_pos] = (position){to_height, 1};\n     (*num_pos)++;\n  }\n}\n```", "```\nvoid add_position_01(int from_height,\n                     positions pos, int *num_pos,\n                     board min_moves) {\n  int distance = 1 + min_moves[from_height][0];\n  if (min_moves[from_height][1] == -1 ||\n      min_moves[from_height][1] > distance) {\n    min_moves[from_height][1] = distance;\n    pos[*num_pos] = (position){from_height, 1};\n    (*num_pos)++;\n  }\n}\n```", "```\nvoid add_position_10(int from_height,\n                     positions pos, int *num_pos,\n                     int itching[], board min_moves) {\n  int distance = min_moves[from_height][1];\n  if (itching[from_height] == 0 &&\n      (min_moves[from_height][0] == -1 ||\n       min_moves[from_height][0] > distance)) {\n    min_moves[from_height][0] = distance;\n    pos[*num_pos] = (position){from_height, 0};\n    (*num_pos)++;\n  }\n}\n```", "```\nvoid find_distances(int target_height, int jump_distance,\n                    int itching[], board min_moves) {\n  static positions cur_positions, new_positions;\n  int num_cur_positions, num_new_positions;\n  int i, j, from_height, from_state;\n  for (i = 0; i < target_height * 2; i++)\n    for (j = 0; j < 2; j++)\n      min_moves[i][j] = -1;\n  min_moves[0][0] = 0;\n  cur_positions[0] = (position){0, 0};\n  num_cur_positions = 1;\n\n  while (num_cur_positions > 0) {\n    num_new_positions = 0;\n    for (i = 0; i < num_cur_positions; i++) {\n      from_height = cur_positions[i].height;\n      from_state = cur_positions[i].state;\n\n    ➊ if (from_state == 0) {\n         add_position_up(from_height, from_height + jump_distance,\n                         target_height * 2 - 1,\n                         new_positions, &num_new_positions,\n                         itching, min_moves);\n         add_position_01(from_height, new_positions, &num_new_positions,\n                         min_moves);\n       } else {\n         add_position_down(from_height, from_height - 1,\n                           cur_positions, &num_cur_positions, min_moves);\n         add_position_10(from_height,\n                         cur_positions, &num_cur_positions,\n                         itching, min_moves);\n       }\n     }\n\n     num_cur_positions = num_new_positions;\n     for (i = 0; i < num_cur_positions; i++)\n       cur_positions[i] = new_positions[i];\n  }\n}\n```", "```\n/* based on https://stackoverflow.com/questions/16870485 */\nchar *read_word(int size) {\n  char *str;\n  int ch;\n  int len = 0;\n  str = malloc(size);\n  if (str == NULL) {\n    fprintf(stderr, \"malloc error\\n\");\n    exit(1);\n  }  \n➊ while ((ch = getchar()) != EOF && (ch != ' ') && (ch != '\\n')) {\n     str[len++] = ch;\n     if (len == size) {\n       size = size * 2;\n     ➋ str = realloc(str, size);\n        if (str == NULL) {\n          fprintf(stderr, \"realloc error\\n\");\n          exit(1);\n      }\n    }\n }\n➌ str[len] = '\\0';\n   return str;\n}\n```", "```\n3 5\nSpanish Bengali Italian\nEnglish Spanish 500\nSpanish Bengali 1800\nEnglish Italian 1000\nSpanish Italian 250\nBengali Italian 9000\n```", "```\n#define MAX_LANGS 101\n#define WORD_LENGTH 16\n\ntypedef struct edge {\n  int to_lang, cost;\n  struct edge *next;\n} edge;\n\ntypedef int board[MAX_LANGS];\ntypedef int positions[MAX_LANGS];\n```", "```\nint main(void) {\n  static edge *adj_list[MAX_LANGS] = {NULL};\n  static char *lang_names[MAX_LANGS];\n  int i, num_targets, num_translators, cost, from_index, to_index;\n  char *from_lang, *to_lang;\n  edge *e;\n  static board min_costs;\n  scanf(\"%d%d \", &num_targets, &num_translators);\n➊ lang_names[0] = \"English\";\n\n  for (i = 1; i <= num_targets; i++)\n  ➋ lang_names[i] = read_word(WORD_LENGTH);\n\n  for (i = 0; i < num_translators; i++) {\n    from_lang = read_word(WORD_LENGTH);\n    to_lang = read_word(WORD_LENGTH);\n    scanf(\"%d \", &cost);\n    from_index = find_lang(lang_names, from_lang);\n    to_index = find_lang(lang_names, to_lang);\n    e = malloc(sizeof(edge));\n    if (e == NULL) {\n      fprintf(stderr, \"malloc error\\n\");\n      exit(1);\n    }\n    e->to_lang = to_index;\n    e->cost = cost;\n    e->next = adj_list[from_index];\n  ➌ adj_list[from_index] = e;\n    e = malloc(sizeof(edge));\n    if (e == NULL) {\n      fprintf(stderr, \"malloc error\\n\");\n      exit(1);\n    }\n e->to_lang = from_index;\n    e->cost = cost;\n    e->next = adj_list[to_index];\n ➍ adj_list[to_index] = e;\n  }\n  find_distances(adj_list, num_targets + 1, min_costs);\n  solve(num_targets + 1, min_costs);\n  return 0;\n}\n```", "```\nint find_lang(char *langs[], char *lang) {\n  int i = 0;\n    while (strcmp(langs[i], lang) != 0)\n      i++;\n  return i;\n}\n```", "```\nvoid add_position(int from_lang, int to_lang,\n                  positions new_positions, int *num_new_positions,\n                  board min_moves) {\n  if (min_moves[to_lang] == -1) {\n    min_moves[to_lang] = 1 + min_moves[from_lang];\n    new_positions[*num_new_positions] = to_lang;\n\n    (*num_new_positions)++;\n  }\n}\n```", "```\n void find_distances(edge *adj_list[], int num_langs, board min_costs) {\n➊ static board min_moves;\n   static positions cur_positions, new_positions;\n   int num_cur_positions, num_new_positions;\n   int i, from_lang, added_lang, best;\n   edge *e;\n   for (i = 0; i < num_langs; i++) {\n     min_moves[i] = -1;\n     min_costs[i] = -1;\n   }\n   min_moves[0] = 0;\n   cur_positions[0] = 0;\n   num_cur_positions = 1;\n\n   while (num_cur_positions > 0) {\n     num_new_positions = 0;\n     for (i = 0; i < num_cur_positions; i++) {\n       from_lang = cur_positions[i];\n    ➋ e = adj_list[from_lang];\n\n       while (e) {\n         add_position(from_lang, e->to_lang,\n                      new_positions, &num_new_positions, min_moves);\n         e = e->next;\n      }\n    }\n\n  ➌ for (i = 0; i < num_new_positions; i++) {\n      added_lang = new_positions[i];\n      e = adj_list[added_lang];\n      best = -1;\n      while (e) {\n      ➍ if (min_moves[e->to_lang] + 1 == min_moves[added_lang] &&\n            (best == -1 || e->cost < best))\n          best = e->cost;\n        e = e->next;\n      }\n      min_costs[added_lang] = best;\n    }\n\n    num_cur_positions = num_new_positions;\n for (i = 0; i < num_cur_positions; i++)\n      cur_positions[i] = new_positions[i];\n  }\n}\n```", "```\nvoid solve(int num_langs, board min_costs) {\n  int i, total = 0;\n  for (i = 1; i < num_langs; i++)\n  ➊ if (min_costs[i] == -1) {\n       printf(\"Impossible\\n\");\n       return;\n     } else {\n       total = total + min_costs[i];\n  }\n➋ printf(\"%d\\n\", total);\n}\n```"]