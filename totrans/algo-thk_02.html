<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_37"/><span class="big">2</span><br/>TREES AND RECURSION</h2>
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>
<p class="noindent">In this chapter, we’ll look at two problems that will require processing and answering questions about hierarchical data. The first problem is about collecting candy from a neighborhood. The second concerns queries on family trees. Because loops are a natural means to process collections of data, we’ll try them first. We’ll soon see, though, that these problems push against what we can easily express with loops, and this will motivate a shift in the way we think about and solve such problems. You’ll leave this chapter knowing about recursion, a problem-solving technique that applies whenever the solution to a problem involves solutions to simpler, smaller problems.</p>
<h3 class="h3" id="lev17">Problem 1: Halloween Haul</h3>
<p class="noindent">This is DMOJ problem <span class="literal">dwite12c1p4</span>.<span epub:type="pagebreak" id="page_38"/></p>
<h4 class="h4" id="sec20"><em>The Problem</em></h4>
<p class="noindent">It’s Halloween, a holiday that often involves getting dressed up, candy from neighbors, and a stomachache. In this problem, you want to collect all the candy from a particular neighborhood as efficiently as possible. The neighborhood has a rigid, though strange, shape. <a href="ch02.xhtml#ch02fig01">Figure 2-1</a> shows a sample neighborhood.</p>
<div class="image"><img alt="Image" id="ch02fig01" src="../images/ch02fig01.jpg"/></div>
<p class="figcap"><em>Figure 2-1: A sample neighborhood</em></p>
<p class="indent">The circles with numbers in them are houses. Each number gives the amount of candy you’ll get by visiting that house. Candy values are at most two digits. The circle at the top is your starting location. The circles without numbers are intersections between streets, where you choose which way to walk next. The lines that connect circles are the streets. Moving from one circle to another corresponds to walking one street.</p>
<p class="indent">Let’s think about how you could move through this neighborhood. Begin at the top circle. If you walk down the street on the right, you get to an intersection. If you then walk down the street on the right from that circle, you end up at a house and collect 41 pieces of candy. You could then walk back up the two streets to the top to return to your starting location. You’ll have thus walked a total of four streets and collected 41 pieces of candy.</p>
<p class="indent">However, your goal is to collect <em>all</em> of the candy and to do so by walking the minimum number of streets. You’re allowed to end your walk as soon as you’ve collected all of the candy; there’s no requirement to get back to the top circle.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input consists of exactly five lines, where each line is a string of at most 255 characters that describes a neighborhood.<span epub:type="pagebreak" id="page_39"/></p>
<p class="indent">How can a string encode a diagram? This isn’t like the Unique Snow-flakes problem from <a href="ch01.xhtml">Chapter 1</a>, where each snowflake was just six integers. Here we have circles, lines connecting circles, and candy values in some of those circles.</p>
<p class="indent">As with the Unique Snowflakes problem, we can simplify things by initially ignoring some of the complexities of the full problem. For that reason, I’ll defer the way that the input is provided until later. Here’s a teaser, though: there’s a quite clever and compact way to represent these diagrams as strings. Stay tuned.</p>
<h5 class="h5">Output</h5>
<p class="noindent">Our output will be five lines of text, with each line corresponding to one of the five input lines. Each line of output contains two integers separated by a space: the minimum number of streets walked to obtain all of the candy and the total amount of candy obtained.</p>
<p class="indent">The time limit for solving the test case is two seconds.</p>
<h4 class="h4" id="sec21"><em>Binary Trees</em></h4>
<p class="noindent">In <a href="ch02.xhtml#ch02fig02">Figure 2-2</a>, I’ve augmented the neighborhood from <a href="ch02.xhtml#ch02fig01">Figure 2-1</a> to include letters in the nonhouse circles. These letters have nothing to do with the problem and won’t affect our code, but they allow us to uniquely refer to each circle.</p>
<div class="image"><img alt="Image" id="ch02fig02" src="../images/ch02fig02.jpg"/></div>
<p class="figcap"><em>Figure 2-2: A sample neighborhood with letter labels</em></p>
<p class="indent">The particular shape of the neighborhoods in our Halloween Haul problem is known as a <em>binary tree</em>. Both <em>binary</em> and <em>tree</em> are important words here. Let’s unpack their definitions, starting with tree.<span epub:type="pagebreak" id="page_40"/></p>
<h5 class="h5">Defining Tree</h5>
<p class="noindent">A <em>tree</em> is a structure that consists of <em>nodes</em> (the circles) and <em>edges</em> between nodes (the lines representing streets). The node at the top—the H circle—is referred to as the <em>root</em>. You’ll often see the term <em>vertex</em> used synonymously with node; in this book, I’ll stick to “node.”</p>
<p class="indent">The nodes in the tree have a parent-child relationship. For example, we say that H is the <em>parent</em> of F and G, because there is an edge from H to F and an edge from H to G. We also say that F and G are <em>children</em> of H. More specifically, F is the <em>left child</em> of H, and G is the <em>right child</em> of H. Any node that has no children is referred to as a <em>leaf</em>. In the current problem, the nodes with candy values (the houses) are leaves.</p>
<p class="indent">Much of the terminology that computer scientists use when discussing trees is familiar from the notion of family trees. For example, F and G are <em>siblings</em>, because they have the same parent. E is an example of a <em>descendant</em> of H, because E is reachable by moving down the tree from H.</p>
<p class="indent">The <em>height</em> of a tree is determined by the largest number of edges that we can traverse on a downward path from the root to a leaf. What is the height of our sample tree? Well, here’s one downward path we could traverse: H to G to 7. That path has two edges (H to G and G to 7), giving us a height of at least two. However, we can find a much longer downward path! Here’s one such longest downward path: H to F to E to D to C to B to 4. That path has six edges on it. Convince yourself that there is no longer downward path here. The height of this tree is six.</p>
<p class="indent">Trees have a very regular, repeatable structure, which helps us process them. For example, if we remove the root H, along with the edges from H to F and from H to G, we end up with two <em>subtrees</em> (<a href="ch02.xhtml#ch02fig03">Figure 2-3</a>).</p>
<div class="image"><img alt="Image" id="ch02fig03" src="../images/ch02fig03.jpg"/></div>
<p class="figcap"><em>Figure 2-3: A tree split in two</em></p>
<p class="indent">Notice that each of the two subtrees is a legitimate tree on its own: it has a root, nodes and edges, and the proper structure. We could further split these trees into even smaller pieces, and each of those pieces would be <span epub:type="pagebreak" id="page_41"/>a tree. A tree can be thought of as consisting of smaller trees, each of which consists of even smaller trees, and so on.</p>
<h5 class="h5">Defining Binary</h5>
<p class="noindent">In the context of trees, <em>binary</em> simply means that each node in our trees has at most two children. A given node in a binary tree can have zero children, or one child, or two children, but no more. The binary trees in our current problem are in fact a little more constrained than that: each node is required to have exactly zero or two children—you’ll never see a node with exactly one child. Such a binary tree, where every nonleaf node has exactly two children, is referred to as a <em>full</em> binary tree.</p>
<h4 class="h4" id="sec22"><em>Solving the Sample Instance</em></h4>
<p class="noindent">Let’s go ahead and solve the Halloween Haul problem on our sample tree (<a href="ch02.xhtml#ch02fig02">Figure 2-2</a>). We’re required to return both the minimum number of streets we have to walk to get all of the candy and the total amount of candy. We’ll start with the latter, because it’s the easier of the two to calculate.</p>
<p class="indent">We can calculate the total amount of candy by hand: just add up all of the candy values in the house nodes. If we do that, we get 7 + 41 + 72 + 3 + 6 + 2 + 15 + 4 + 9 = 159.</p>
<p class="indent">Now, let’s figure out the minimum number of streets that you must walk to collect all of the candy. Does it even matter how we traverse the tree? After all, you have to visit every house—maybe your quickest route is simply to avoid visiting the same house multiple times.</p>
<p class="indent">Let’s traverse the tree by visiting left children before right children. By using this strategy, here is the order in which you visit the nodes: H, F, A, 72, A, 3, A, F, E, 6, E, D, C, B, 4, B, 9, B, C, 15, C, D, 2, D, E, F, H, G, 7, G, 41. Note how your final stop is the 41 house and not H: you’re not required to return to your starting location once you’re finished collecting the candy. There are 30 edges in that path. (There are 31 nodes in the path, and the number of edges in a path is always the number of nodes minus one.) Is walking 30 streets the best you can do?</p>
<p class="indent">In fact, you can do better: the most efficient route involves walking only 26 streets. Spend some time now trying to find this more optimized traversal. As in the 30-street traversal, you’ll have to visit the nonhouse nodes multiple times and you want to visit each house exactly once, but you can save four street-walks by being strategic about the <em>final</em> house that you visit.</p>
<h4 class="h4" id="sec23"><em>Representing Binary Trees</em></h4>
<p class="noindent">To create a solution in code, we’ll need to find a way to represent neighborhood trees. As you’ll see, it’s convenient to convert the strings from the input that represent trees to explicit tree structures that represent relationships between nodes. In this section, I’ll provide those tree structures. We won’t yet be able to read the strings and convert them to trees, but we’ll be <span epub:type="pagebreak" id="page_42"/>able to hardcode trees. That gives us the foothold we need to start solving the problem.</p>
<h5 class="h5">Defining Nodes</h5>
<p class="noindent">When solving the Unique Snowflakes problem in the last chapter, we used a linked list to store a chain of snowflakes. Each snowflake node contained the snowflake itself, and it also contained a pointer to the next snowflake in the chain:</p>
<pre>typedef struct snowflake_node {
  int snowflake[6];
  struct snowflake_node *next;
} snowflake_node;</pre>
<p class="indent">We can use a similar struct to represent a binary tree. In our neighborhood trees, the houses have candy values and the other nodes do not. Even though we have these two kinds of nodes, we’ll be okay with just one node structure. We’ll just make sure that house nodes have correct candy values; we won’t even initialize the <span class="literal">candy</span> values of nonhouse nodes, because we won’t look at those values anyway.</p>
<p class="indent">That gives us this starting point:</p>
<pre>typedef struct node {
  int candy;
  // ... what else should we add?
} node;</pre>
<p class="indent">In a linked list, each node points to the next node in the chain (or is <span class="literal">NULL</span> if there is no next node). From one node, we can move to exactly one other node. In contrast, in a tree, a single <span class="literal">next</span> pointer per node will not suffice, because a nonleaf node will have both a left child and a right child. We need two pointers per node, as in <a href="ch02.xhtml#ch02ex01">Listing 2-1</a>.</p>
<pre>typedef struct node {
  int candy;
  struct node *left, *right;
} node;</pre>
<p class="excap" id="ch02ex01"><em>Listing 2-1: The</em> <span class="codeitalic1">node</span> <em>struct</em></p>
<p class="indent">It’s apparent that the <span class="literal">parent</span> is not included here. Should we throw in a <span class="literal">*parent</span> as well, letting us access the parent of a node in addition to its children? This would be useful for some problems, but it is not required for Halloween Haul. We will need a way to move up the tree (from child to parent), but we can do so implicitly, without explicitly following parent pointers. You’ll see more about this later.<span epub:type="pagebreak" id="page_43"/></p>
<h5 class="h5" id="ch02lev1">Building a Tree</h5>
<p class="noindent">With this <span class="literal">node</span> type in hand, we can now build sample trees. We work bottom-up, uniting subtrees until we reach the root. Let’s demonstrate the start of this process on our sample tree.</p>
<p class="indent">We’ll start with the 4 and 9 nodes at the bottom of our sample tree. Then we can combine those under a new parent to create the subtree whose root is B.</p>
<p class="indent">Here’s the 4 node:</p>
<pre>  node *four = malloc(sizeof(node));
  four-&gt;candy = 4;
  four-&gt;left = NULL;
  four-&gt;right = NULL;</pre>
<p class="indent">This is a house node, so we remember to give it a candy value. It’s also important to set its left and right children to <span class="literal">NULL</span>. If we don’t do that, they’ll remain uninitialized, pointing to unspecified memory, and that’ll mean trouble if we try to access it.</p>
<p class="indent">Now consider the 9 node. This is another house, so the code is structurally identical:</p>
<pre>  node *nine = malloc(sizeof(node));
  nine-&gt;candy = 9;
  nine-&gt;left = NULL;
  nine-&gt;right = NULL;</pre>
<p class="indent">We now have two nodes. They’re not yet part of a tree. They’re hanging out by themselves. We can unite them under a common parent, like this:</p>
<pre>  node *B = malloc(sizeof(node));
  B-&gt;left = four;
  B-&gt;right = nine;</pre>
<p class="indent">This <span class="literal">B</span> node is given a <span class="literal">left</span> pointer to the 4 house and a <span class="literal">right</span> pointer to the 9 house. It’s <span class="literal">candy</span> member is not initialized, which is fine because non-house nodes have no sensible <span class="literal">candy</span> value anyway.</p>
<p class="indent"><a href="ch02.xhtml#ch02fig04">Figure 2-4</a> depicts what we’ve generated so far.</p>
<div class="image"><img alt="Image" id="ch02fig04" src="../images/ch02fig04.jpg"/></div>
<p class="figcap"><em>Figure 2-4: The first three nodes in our hardcoded tree</em><span epub:type="pagebreak" id="page_44"/></p>
<p class="indent">Before powering ahead and producing the C subtree, let’s do a little cleanup. Creating a house node involves four things: allocating the node, setting the candy value, setting the left child to <span class="literal">NULL</span>, and setting the right child to <span class="literal">NULL</span>. Similarly, creating a nonhouse node involves doing three things: allocating the node, setting the left child to some existing subtree, and setting the right child to some other existing subtree. We can capture these steps in helper functions rather than typing them out each time, as shown in <a href="ch02.xhtml#ch02ex02">Listing 2-2</a>.</p>
<pre>node *new_house(int candy) {
  node *house = malloc(sizeof(node));
  if (house == NULL) {
    fprintf(stderr, "malloc error\n");
    exit(1);
  }
  house-&gt;candy = candy;
  house-&gt;left = NULL;
  house-&gt;right = NULL;
  return house;
}

node *new_nonhouse(node *left, node *right) {
  node *nonhouse = malloc(sizeof(node));
  if (nonhouse == NULL) {
    fprintf(stderr, "malloc error\n");
    exit(1);
  }
  nonhouse-&gt;left = left;
  nonhouse-&gt;right = right;
  return nonhouse;
}</pre>
<p class="excap" id="ch02ex02"><em>Listing 2-2: Helper functions for creating nodes</em></p>
<p class="indent">Let’s rewrite our earlier <span class="literal">four</span>, <span class="literal">nine</span>, <span class="literal">B</span> code to use these helper functions, and add the 15 and C nodes while we’re at it:</p>
<pre>  node *four = new_house(4);
  node *nine = new_house(9);
  node *B = new_nonhouse(four, nine);
  node *fifteen = new_house(15);
  node *C = new_nonhouse(B, fifteen);</pre>
<p class="indent"><a href="ch02.xhtml#ch02fig05">Figure 2-5</a> depicts our five-node tree.<span epub:type="pagebreak" id="page_45"/></p>
<div class="image"><img alt="Image" id="ch02fig05" src="../images/ch02fig05.jpg"/></div>
<p class="figcap"><em>Figure 2-5: The first five nodes in our hardcoded tree</em></p>
<p class="indent">Notice that node <span class="literal">C</span> has a left child that is a nonhouse node (<span class="literal">B</span> in our code) and a right child that is a house node (<span class="literal">fifteen</span> in our code). Our <span class="literal">new_nonhouse</span> function allows this asymmetry (one nonhouse child and one house child): each is just a node. We can mix and match nonhouse nodes and house nodes at will.</p>
<p class="indent">At this point, we have a five-node subtree rooted at node <span class="literal">C</span>. We should be able to use that <span class="literal">C</span> node to access the candy values stored in the tree. (We could also use <span class="literal">B</span>, <span class="literal">four</span>, <span class="literal">nine</span>, and <span class="literal">fifteen</span> to access parts of the tree, because building a tree piecewise leaves a residue of node variables in our wake, but later we’ll build a function for converting a string to a tree that will furnish us with only the tree’s root, so let’s not cheat by using those variables here.)</p>
<p class="indent">Here’s a quick exercise: What does this print?</p>
<pre>  printf("%d\n", C-&gt;right-&gt;candy);</pre>
<p class="indent">If you said <span class="literal">15</span>, you’d be correct! We access <span class="literal">C</span>’s right child, which is the <span class="literal">fifteen</span> house node, and then we access <span class="literal">fifteen</span>’s candy value.</p>
<p class="indent">How about this?</p>
<pre>printf("%d\n", C-&gt;left-&gt;right-&gt;candy);</pre>
<p class="indent">That should output <span class="literal">9</span>: a left and then a right takes us from <span class="literal">C</span> to <span class="literal">nine</span>. Now try this:</p>
<pre>printf("%d\n", C-&gt;left-&gt;left);</pre>
<p class="indent">Yikes! On my laptop, I’m getting the value <span class="literal">10752944</span>. Why? The reason is that we’re printing a pointer value, not a candy value. We will have to be careful here.</p>
<p class="indent">Finally, what would this print?</p>
<pre>printf("%d\n", C-&gt;candy);</pre>
<p class="indent">This gives us a useless number. Here we’re printing the <span class="literal">candy</span> member for a nonhouse node, but only houses have meaningful values of <span class="literal">candy</span>.</p>
<p class="indent">We’re now ready to start tackling this problem. Finish up the code to build the sample tree and we’ll be on our way.<span epub:type="pagebreak" id="page_46"/></p>
<h4 class="h4" id="sec24"><em>Collecting All the Candy</em></h4>
<p class="noindent">We have two main tasks: calculating the minimum number of streets required to collect all of the candy and calculating the total amount of candy in the tree. We’ll write a helper function for each task, starting with calculating the total amount of candy, the easier of the two tasks. The helper function will have the following signature:</p>
<pre>int tree_candy(node *tree)</pre>
<p class="noindent">The function takes a pointer to a node that is the root of the tree and returns an integer that will be the total amount of candy in the tree.</p>
<p class="indent">If we were dealing with linked lists, we could use a loop like we did when solving the Unique Snowflakes problem. The body of the loop would process the current node and then use the <span class="literal">next</span> member of the node to advance to the next node. At each step, there’s only one place to go: further down the linked list. However, the structure of binary trees is more complex. Each nonleaf node has a left and a right subtree. Each must be traversed; otherwise, we’ll miss processing part of the tree!</p>
<p class="indent">To show a tree traversal in action, we will return to our sample tree (<a href="ch02.xhtml#ch02fig02">Figure 2-2</a>): Beginning at node H, where should we go first? We could move right to G and then move right again to 41, collecting 41 pieces of candy there. Then what? We’re at a dead end, and there’s a lot more candy to collect. Remember that each nonleaf node stores pointers only to its left and right children, not to its parent. Once at 41, we have no way to get back up to G.</p>
<p class="indent">Starting again, we need to move from H to G and to record that we must later process the F subtree—otherwise, we’ll have no way to return to the F subtree.</p>
<p class="indent">Once at G, we similarly need to move to 41 and to record that we must later process the 7 subtree. When we’re at 41, we see that there are no subtrees to process, and we have recorded two subtrees (F and 7) that we still need to process.</p>
<p class="indent">Perhaps next we choose to process the 7 subtree, giving us a total candy value of 41 + 7 = 48. After that, we’ll process the F subtree. Making any one decision about where to go from F leaves a whole subtree unprocessed, so we also need to record that.</p>
<p class="indent">That is, if we use a loop, for each nonleaf node we must do two things: choose one of its subtrees to process first and record that the other subtree is pending to be processed. Choosing one of the subtrees amounts to following the <span class="literal">left</span> or <span class="literal">right</span> pointer—there is no problem there. Recording information so that we can visit the other subtree later, however, will be trickier. We’ll need a new tool.</p>
<h5 class="h5">Storing Pending Subtrees on a Stack</h5>
<p class="noindent">At any moment, we can have multiple subtrees pending for us to visit later. We need to be able to add another subtree to that collection and to remove and return subtrees when we’re ready to process them.<span epub:type="pagebreak" id="page_47"/></p>
<p class="indent">We can use an array to manage this bookkeeping. We’ll define a large array that can hold as many references to pending subtrees as needed. To tell us how many subtrees are pending, we’ll keep a <span class="literal">highest_used</span> variable that will track the highest index being used in the array. For example, if <span class="literal">highest_used</span> is <span class="literal">2</span>, it means that indices <span class="literal">0</span>, <span class="literal">1</span>, and <span class="literal">2</span> hold references to pending subtrees and that the rest of the array is currently unused. If <span class="literal">highest_used</span> is <span class="literal">0</span>, it means that only index <span class="literal">0</span> is being used. To signify that no part of the array is being used, we set <span class="literal">highest_used</span> to <span class="literal">-1</span>.</p>
<p class="indent">The easiest spot to add to the array is at index <span class="literal">highest_used + 1</span>. If we tried to add an element anywhere else, we’d first have to move existing elements to the right; otherwise, we’d overwrite one of the existing elements! Similarly, the easiest element to remove from the array is <span class="literal">highest_used</span>. Using any other index would necessitate moving elements to the left to fill the vacancy left by the removed element.</p>
<p class="indent">Using this scheme, suppose we first add a reference to subtree F and then add a reference to subtree 7. This places the F subtree at index <span class="literal">0</span> and the 7 subtree at index <span class="literal">1</span>. The value of <span class="literal">highest_used</span> is currently <span class="literal">1</span>. Now, when we remove an element from this array, which subtree do you think gets removed: the F subtree or the 7 subtree?</p>
<p class="indent">The 7 subtree gets removed! In general, the element that was most recently added is the one that is removed.</p>
<p class="indent">Computer scientists refer to this as <em>last-in, first-out (LIFO)</em> access. Collections of data that provide LIFO access are referred to as <em>stacks</em>. Adding an element to a stack is known as a <em>push</em>, and removing an element from a stack is known as a <em>pop</em>. The <em>top</em> of the stack refers to the element that would next be popped from the stack; that is, the top of the stack is the most recently pushed item.</p>
<p class="indent">There are real-life stacks all over the place. Say you have some plates that have just been washed, and you put them away on a shelf in a cupboard, one after the other. The last one that you add (push) to the shelf will be at the top of the stack, and it will be the first plate that you remove (pop) when retrieving a plate from the cupboard. This is LIFO.</p>
<p class="indent">A stack also powers the undo functionality in your word processor. Suppose you type a word, then a second word, then a third word. Now you hit undo. The third word goes away, since it was the last one that you entered.</p>
<h5 class="h5">Implementing a Stack</h5>
<p class="noindent">Let’s implement the stack. To begin, we package both the array and <span class="literal">highest_used</span> into a struct. This keeps the stack’s variables together and also allows us to create as many stacks as we wish. (In Halloween Haul, we need only one stack, but you might use this code in other settings where multiple stacks are required.) Here’s our definition:</p>
<pre>#define SIZE 255

typedef struct stack {
  node * values[SIZE];
  int highest_used;
} stack;</pre>
<p class="indent"><span epub:type="pagebreak" id="page_48"/>Recall that each input line is at most 255 characters. Each character will represent at most one node. Each tree that we deal with will thus have at most 255 nodes, and this is why our <span class="literal">values</span> array has space for 255 elements. Also, notice that each element in <span class="literal">values</span> is of type <span class="literal">node *</span>, a pointer to <span class="literal">node</span>. We could have stored nodes in there directly, rather than pointers to nodes, but that would be less memory efficient because the nodes from the tree would be duplicated when added to the stack.</p>
<p class="indent">We’ll create a function for each operation on a stack. First, we need a <span class="literal">new_stack</span> function that creates a new stack. Next, we need <span class="literal">push_stack</span> and <span class="literal">pop_stack</span> functions to add to and remove from the stack, respectively. Finally, we’ll have an <span class="literal">is_empty_stack</span> function that tells us whether the stack is empty.</p>
<p class="indent">The <span class="literal">new_stack</span> function is provided in <a href="ch02.xhtml#ch02ex03">Listing 2-3</a>.</p>
<pre>stack *new_stack(void) {
<span class="ent">❶</span> stack *s = malloc(sizeof(stack));
   if (s == NULL) {
     fprintf(stderr, "malloc error\n");
     exit(1);
  }
<span class="ent">➋</span> s-&gt;highest_used = -1;
   return s;
}</pre>
<p class="excap" id="ch02ex03"><em>Listing 2-3: Creating a stack</em></p>
<p class="indent">First, we allocate memory for the stack <span class="ent">➊</span>. Then, we set <span class="literal">highest_used</span> to <span class="literal">-1</span> <span class="ent">➋</span>; recall that <span class="literal">-1</span> here means an empty stack. Notice that we don’t do anything to initialize the elements of <span class="literal">s-&gt;values</span> here: our stack is empty, so its values are irrelevant.</p>
<p class="indent">I’ve put <span class="literal">stack_push</span> and <span class="literal">stack_pop</span> together in <a href="ch02.xhtml#ch02ex04">Listing 2-4</a> to highlight the symmetry of their implementation.</p>
<pre>void push_stack(stack *s, node *value) {
<span class="ent">❶</span> s-&gt;highest_used++;
<span class="ent">➋</span> s-&gt;values[s-&gt;highest_used] = value;
}

node * pop_stack(stack *s) {
<span class="ent">➌</span> node * ret = s-&gt;values[s-&gt;highest_used];
<span class="ent">➍</span> s-&gt;highest_used--;
<span class="ent">➎</span> return ret;
}</pre>
<p class="excap" id="ch02ex04"><em>Listing 2-4: Push and pop on a stack</em><span epub:type="pagebreak" id="page_49"/></p>
<p class="indent">In <span class="literal">push_stack</span>, we first make room for a new element <span class="ent">➊</span>, and then place <span class="literal">value</span> in that free location <span class="ent">➋</span>.</p>
<p class="indent">Our <span class="literal">pop_stack</span> function is responsible for removing the element at index <span class="literal">highest_used</span>. If it did just that, however, then the function wouldn’t be all that useful: we’d be able to call it and it would pop the element for us, but it wouldn’t tell us what was popped! To remedy that, we store in <span class="literal">ret</span> the element from the stack that we are about to remove <span class="ent">➌</span>. We then remove the element from the stack by decreasing <span class="literal">highest_used</span> by one <span class="ent">➍</span>. Finally, we return the element that was removed <span class="ent">➎</span>.</p>
<p class="indent">I have not included error checking in <span class="literal">push_stack</span> or <span class="literal">pop_stack</span>. Notice that <span class="literal">push_stack</span> would fail if you tried to push more than the maximum number of elements—but we’re safe, because we’ve made the stack as big as any input we’ll be provided. Likewise, <span class="literal">pop_stack</span> would fail if you tried to pop from an empty stack—but we’ll be careful to check that the stack is nonempty before we pop. Of course, general-purpose stacks should be made more robust!</p>
<p class="indent">We’ll determine whether a stack is empty using <span class="literal">is_empty_stack</span> (shown in <a href="ch02.xhtml#ch02ex05">Listing 2-5</a>), which uses <span class="literal">==</span> to check whether <span class="literal">highest_used</span> is <span class="literal">-1</span>.</p>
<pre>int is_empty_stack(stack *s) {
  return s-&gt;highest_used == -1;
}</pre>
<p class="excap" id="ch02ex05"><em>Listing 2-5: Determining whether a stack is empty</em></p>
<p class="indent">Before we calculate the total amount of candy in a tree, let’s exercise our stack code with a small, standalone example, as given in <a href="ch02.xhtml#ch02ex06">Listing 2-6</a>. I encourage you to take a few minutes to trace the example on your own. Predict what will happen! Then, run the code and check whether the output matches what you expected.</p>
<pre>int main(void) {
  stack *s;
  s = new_stack();
  node *n, *n1, *n2, *n3;
  n1 = new_house(20);
  n2 = new_house(30);
  n3 = new_house(10);
  push_stack(s, n1);
  push_stack(s, n2);
  push_stack(s, n3);
  while (!is_empty_stack(s)) {
    n = pop_stack(s);
    printf("%d\n", n-&gt;candy);
  }
  return 0;
}</pre>
<p class="excap" id="ch02ex06"><em>Listing 2-6: An example of using a stack</em><span epub:type="pagebreak" id="page_50"/></p>
<p class="indent">Let’s figure out what this example does. First we create a new stack called <span class="literal">s</span>. We then create three house nodes: <span class="literal">n1</span> has 20 pieces of candy, <span class="literal">n2</span> has 30 pieces of candy, and <span class="literal">n3</span> has 10 pieces of candy.</p>
<p class="indent">We push these (single-node) subtrees onto the stack: first <span class="literal">n1</span> is pushed, then <span class="literal">n2</span>, then <span class="literal">n3</span>. As long as the stack is nonempty, we pop an element from the stack and print its candy value. The elements come off the stack in the opposite order in which they were pushed, so we get 10, 30, 20 as the result of the <span class="literal">printf</span> calls.</p>
<h5 class="h5">A Stack Solution</h5>
<p class="noindent">We now have a means of keeping track of pending subtrees: whenever we make a choice of which subtree to process, we put the other one on the stack. What’s important for calculating the total amount of candy is that the stack gives us a way to push a subtree (to help us remember that subtree) and pop a subtree (to help us process a subtree when we’re ready to do so).</p>
<p class="indent">We could also have used a <em>queue</em>, a data structure to give us elements in <em>first-in, first-out (FIFO)</em> order, which would change the order in which subtrees are visited and the order in which we add candy to our total, but it would give us the same end result. I chose a stack because it’s easier to implement than a queue.</p>
<p class="indent">We’re now ready to implement <span class="literal">tree_candy</span> using a stack. We need to handle two cases: the first is what we do when looking at a nonhouse node, and the second is what we do when looking at a house node.</p>
<p class="indent">To know whether our current node is a nonhouse node, we can check its <span class="literal">left</span> and <span class="literal">right</span> pointers. For a nonhouse, both will be non-null, because they point to subtrees. If we confirm we’re looking at a nonhouse node, we store the pointer to the left subtree in the stack, and we proceed down the right subtree. The code for the nonhouse-node case goes like this:</p>
<pre>if (tree-&gt;left &amp;&amp; tree-&gt;right) {
  push_stack(s, tree-&gt;left);
  tree = tree-&gt;right;
}</pre>
<p class="indent">Otherwise, if <span class="literal">left</span> and <span class="literal">right</span> are <span class="literal">NULL</span>, then we’re looking at a house node. House nodes have candy, so the first thing we should do is add that house’s candy value to our total amount of candy:</p>
<pre>total = total + tree-&gt;candy;</pre>
<p class="indent">It’s a house, so there’s no further down in the tree we can go. If the stack is empty, we’re done: an empty stack means that there are no more pending trees to process. If the stack is not empty, then we need to pop a subtree from the stack and process that subtree. Here’s the code for processing a house:</p>
<pre>total = total + tree-&gt;candy;
if (is_empty_stack(s))
  tree = NULL;
else
  tree = pop_stack(s);</pre>
<p class="indent"><span epub:type="pagebreak" id="page_51"/>The complete code for <span class="literal">tree_candy</span>, using a stack, is given in <a href="ch02.xhtml#ch02ex07">Listing 2-7</a>.</p>
<pre>int tree_candy(node *tree) {
  int total = 0;
  stack *s = new_stack();
  while (tree != NULL) {
    if (tree-&gt;left &amp;&amp; tree-&gt;right) {
      push_stack(s, tree-&gt;left);
      tree = tree-&gt;right;
    } else {
      total = total + tree-&gt;candy;
      if (is_empty_stack(s))
        tree = NULL;
      else
        tree = pop_stack(s);
    }
  }
  return total;
}</pre>
<p class="excap" id="ch02ex07"><em>Listing 2-7: Calculating the total amount of candy using a stack</em></p>
<p class="indent">Let <em>n</em> be the number of nodes in a tree. Each time through the <span class="literal">while</span> loop, <span class="literal">tree</span> is a different node. We therefore visit each node just once. Each node is also pushed to and popped from the stack at most once. In all, each node is involved in a constant number of steps, so we have a linear-time, or <em>O</em>(<em>n</em>), algorithm here.</p>
<h4 class="h4" id="sec25"><em>A Completely Different Solution</em></h4>
<p class="noindent">Our <span class="literal">tree_candy</span> function works, but it isn’t the simplest solution. We had to write an implementation of a stack. We had to keep track of pending trees. We had to backtrack to a pending tree whenever we hit a dead end. For two reasons, using a stack in the way we have done may not be the ideal solution strategy when writing functions on trees:</p>
<ol>
<li class="noindent">Whenever we have to go one way but return later to go the other way, we’re stuck using this kind of stack code. Tree-processing is rife with problems that require this pattern.</li>
<li class="noindent">The complexity of stack-based code scales with the complexity of the problem. Adding up all of the candy in a tree isn’t so bad, but other related problems that we solve later in this chapter are more challenging. Those problems require not only a stack of pending trees but control flow information for tracking the processing that we need to perform on each tree.</li>
</ol>
<p class="indent"><span epub:type="pagebreak" id="page_52"/>We’ll rewrite our code so it’s able to work at a higher level of abstraction, eliminating stacks completely from both our code and our thought processes.</p>
<h5 class="h5">Recursive Definitions</h5>
<p class="noindent">Our stack-based <span class="literal">tree_candy</span> function is concerned with the <em>particular steps</em> needed to solve the problem: push this on the stack, move that way in the tree, pop from the stack when we hit a dead end, stop when we’ve processed the entire tree. I will now give you another solution that focuses on the <em>structure</em> of the problem. This method solves the main problem in terms of solutions to smaller subproblems. The solution comprises two rules:</p>
<p class="block"><strong>Rule 1</strong>   If the root of the tree is a house node, then the total amount of candy in the tree equals the amount of candy at that house.</p>
<p class="block"><strong>Rule 2</strong>   If the root of the tree is a nonhouse node, then the total amount of candy in the tree equals the total amount of candy in the left subtree plus the total amount of candy in the right subtree.</p>
<p class="indenta">This is called a <em>recursive</em> definition. A definition is recursive if it offers a solution to a problem by referring to solutions to subproblems. Rule 2 is where we see this in action. We care about solving the original problem of calculating the total amount of candy in the tree. That total can be calculated, according to Rule 2, by adding up the solutions to two smaller problems: the total amount of candy in the left subtree and the total amount of candy in the right subtree.</p>
<p class="indent">It’s at about this time that students in my classes start blanching all over the place. How is this description going to solve anything? Even if it does, how can this kind of thing be written in code? The problem is aggravated by books and tutorials that imbue recursive definitions with a mystical quality that is to be trusted but not understood. However, there is no leap of faith or temerity required.</p>
<p class="indent">Let’s work through a small example to get a feel for why this recursive definition is correct.</p>
<p class="indent">Consider this tree consisting of a single house with four pieces of candy:</p>
<div class="image1"><img alt="Image" src="../images/unch02fig01.jpg"/></div>
<p class="indent">Rule 1 immediately tells us that the answer for this tree is four. Whenever we see this tree later, just remember that the answer is four.</p>
<p class="indent">Now, consider this tree consisting of a single house with nine pieces of candy:</p>
<div class="image1"><img alt="Image" src="../images/unch02fig02.jpg"/></div>
<p class="indent">Again, Rule 1 applies, telling us that the answer is nine: when we see this tree later, we’ll just respond that the answer is nine.<span epub:type="pagebreak" id="page_53"/></p>
<p class="indent">Now, let’s solve the problem for a bigger tree:</p>
<div class="image1"><img alt="Image" src="../images/unch02fig03.jpg"/></div>
<p class="indent">This time, Rule 1 does not apply: the root of the tree is a nonhouse node, not a house node. However, we are rescued by Rule 2, which tells us that the total amount of candy here is the total amount of candy in the left subtree plus the total amount of candy in the right subtree. We already know that the total amount of candy in the left subtree is four: it is a tree that we have seen before. Similarly, we know that the total amount of candy in the right subtree is nine: we have seen that tree before, too. By Rule 2, therefore, the entire tree has 4 + 9 = 13 pieces of candy. Remember this for when we see this tree again!</p>
<p class="indent">Let’s go a little further. Here’s another one-house tree, this one with 15 pieces of candy:</p>
<div class="image1"><img alt="Image" src="../images/unch02fig04.jpg"/></div>
<p class="block">Rule 1 tells us this tree has a total of 15 pieces of candy. Remember that! Now consider a five-node tree:</p>
<div class="image1"><img alt="Image" src="../images/unch02fig05.jpg"/></div>
<p class="indent">Rule 2 applies here, because the root is a nonhouse node. We need the total amount of candy in the left subtree and the total amount of candy in the right subtree. We already know the total amount of candy in the left subtree, as we remember our earlier answer of 13. There’s no point going into that left subtree and recalculating anything: we already know the answer. Similarly, we already know the total amount of candy in the right subtree, as it was 15. By Rule 2, then, we have a total of 13 + 15 = 28 pieces of candy in the tree.</p>
<p class="indent">You can keep using this logic to find the total amount of candy in bigger and bigger trees. As we did in the example here, solve smaller subtrees before larger subtrees. In doing so, Rule 1 or Rule 2 will always apply, and answers for smaller subtrees will be known when they are needed.</p>
<p class="indent">Let’s encode Rule 1 and Rule 2 as a C function; see <a href="ch02.xhtml#ch02ex08">Listing 2-8</a>.<span epub:type="pagebreak" id="page_54"/></p>
<pre>int tree_candy(node *tree) {
<span class="ent">❶</span> if (!tree-&gt;left &amp;&amp; !tree-&gt;right)
     return tree-&gt;candy;
<span class="ent">➋</span> return tree_candy(tree-&gt;left) + tree_candy(tree-&gt;right);
}</pre>
<p class="excap" id="ch02ex08"><em>Listing 2-8: Calculating the total amount of candy using recursion</em></p>
<p class="indent">Notice how Rule 1 and Rule 2 are directly represented here. We have an <span class="literal">if</span> statement whose condition is true when the left and right subtrees are <span class="literal">NULL</span> <span class="ent">➊</span>. No subtrees means that <span class="literal">tree</span> is a house node. We should therefore apply Rule 1, which is exactly what we do. Specifically, we return the amount of candy in the house node <span class="literal">tree</span>. If Rule 1 does not apply, we know that <span class="literal">tree</span> is a nonhouse node, and we can implement Rule 2 and return the candy in the left subtree plus the candy in the right subtree <span class="ent">➋</span> . . . but here we pause.</p>
<p class="indent">How does Rule 2 work here? The total amount of candy in the left subtree is obtained by calling <span class="literal">tree_candy</span> on the left subtree. This is the same as for the right subtree: to obtain the total amount of candy in the right subtree, we’re calling <span class="literal">tree_candy</span> on the right subtree. But we’re already in <span class="literal">tree_candy</span>!</p>
<p class="indent">Calling a function from inside itself is known as a <em>recursive call</em>. A function that makes a recursive call is said to be using <em>recursion</em>. One of the biggest mistakes you can make at this point is to try to trace what’s going on in the computer when this recursion happens. I’m going to refrain from giving the low-level details on how the computer organizes these recursive calls. (Suffice it to say that it uses a stack to keep track of pending function calls. It’s very similar to how we earlier used a stack in our code to solve <span class="literal">tree_candy</span>! For that reason, our recursive code, much like our stack-based code, is an <em>O</em>(<em>n</em>) solution.)</p>
<p class="indent">Over and over, I’ve seen the quagmire that can result from trying to manually trace recursive calls. It’s the wrong level of abstraction. Let the computer execute it in the same way that, without a second thought, you let it execute your loops or function calls.</p>
<p class="indent">Here’s how I suggest thinking through what the recursive code is doing:</p>
<ul>
<li class="noindents">If the root of the tree is a house, return its amount of candy.</li>
<li class="noindents">Otherwise, the root of the tree is a nonhouse. Return the total amount of candy in the left subtree plus the total amount of candy in the right subtree.</li>
</ul>
<p class="indent">It’s easy to err when writing recursive code. One common mistake is to inadvertently throw information away when in fact it should be returned. The following flawed implementation exhibits this error:</p>
<pre>// bugged!
int tree_candy(node *tree) {
  if (!tree-&gt;left &amp;&amp; !tree-&gt;right)
    return tree-&gt;candy;
<span class="ent">❶</span> tree_candy(tree-&gt;left) + tree_candy(tree-&gt;right);
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_55"/>Our bug is that we return nothing from the recursive calls <span class="ent">➊</span>, as there is no <span class="literal">return</span> keyword. We’re supposed to return the sum, not throw it away.</p>
<p class="indent">Another common mistake is to make a recursive call on something that’s not a smaller subproblem of the current problem. Here’s an example:</p>
<pre>// bugged!
int tree_candy(node *tree) {
  if (!tree-&gt;left &amp;&amp; !tree-&gt;right)
    return tree-&gt;candy;
<span class="ent">❶</span> return tree_candy(tree);
}</pre>
<p class="indent">Look at the second <span class="literal">return</span> statement <span class="ent">➊</span>. If I told you that the total amount of candy in a tree is obtained by calculating the total amount of candy in the tree, I think you’d be quite vexed—but that’s exactly the rule that it embodies. This function will not work on a tree whose root is a nonhouse node: it will continue to use up memory with pending function calls until the program crashes.</p>
<h5 class="h5">Practicing Recursion</h5>
<p class="noindent">Before proceeding with solving the Halloween Haul problem, let’s practice with recursion by writing two more functions in the spirit of <span class="literal">tree_candy</span>.</p>
<p class="indent">First, given a pointer to the root of a full binary tree, let’s return the number of nodes in the tree. If the node is a leaf, then there is only one node in the tree, so <span class="literal">1</span> is the correct return value. Otherwise, we’re looking at a nonleaf, and the number of nodes in the tree is one (this node) plus the number of nodes in the left subtree plus the number of nodes in the right subtree. That is, the two rules are as follows:</p>
<p class="block"><strong>Rule 1</strong>   If the root of the tree is a leaf node, then the number of nodes in the tree equals <span class="literal">1</span>.</p>
<p class="block"><strong>Rule 2</strong>   If the root of the tree is a nonleaf node, then the number of nodes in the tree equals <span class="literal">1</span> plus the number of nodes in the left subtree plus the number of nodes in the right subtree.</p>
<p class="indent">A rule like Rule 1 is known as a <em>base case</em>, because it can be solved directly, without using recursion. A rule like Rule 2 is known as a <em>recursive case</em>, because its solution requires that smaller subproblems be recursively solved. Every recursive function requires at least one base case and at least one recursive case: the base case tells us what to do when the problem is easy, and the recursive case tells us what to do when the problem is not.</p>
<p class="indent">Converting these rules to code yields the function in <a href="ch02.xhtml#ch02ex09">Listing 2-9</a>.</p>
<pre>int tree_nodes(node *tree) {
  if (!tree-&gt;left &amp;&amp; !tree-&gt;right)
    return 1;
  return 1 + tree_nodes(tree-&gt;left) + tree_nodes(tree-&gt;right);
}</pre>
<p class="excap" id="ch02ex09"><span epub:type="pagebreak" id="page_56"/><em>Listing 2-9: Calculating the number of nodes</em></p>
<p class="indent">Second, let’s write a function to return the number of leaves in a tree. If the node is a leaf, we return <span class="literal">1</span>. If the node is a nonleaf, then that node is <em>not</em> a leaf, so it doesn’t count; what does count is the number of leaves in the left subtree and the number of leaves in the right subtree. The code is given in <a href="ch02.xhtml#ch02ex010">Listing 2-10</a>.</p>
<pre>int tree_leaves(node *tree) {
  if (!tree-&gt;left &amp;&amp; !tree-&gt;right)
    return 1;
  return tree_leaves(tree-&gt;left) + tree_leaves(tree-&gt;right);
}</pre>
<p class="excap" id="ch02ex010"><em>Listing 2-10: Calculating the number of leaves</em></p>
<p class="indent">The only difference between this code and that in <a href="ch02.xhtml#ch02ex09">Listing 2-9</a> is the lack of the <span class="literal">1 +</span> in the last line. Recursive functions are often very similar to each other but can compute very different things!</p>
<h4 class="h4" id="sec26"><em>Walking the Minimum Number of Streets</em></h4>
<p class="noindent">I’ve gone on and on and on, so you might want to revisit the problem description to reorient yourself. We know how to produce the total amount of candy now, but that’s only one of the two required outputs. We also need to output the minimum number of streets that must be walked to obtain all of the candy. No candy for guessing that we’ll nail this using recursion!</p>
<h5 class="h5">Calculating the Number of Streets</h5>
<p class="noindent">Earlier, I provided a 30-street walk for the tree in <a href="ch02.xhtml#ch02fig02">Figure 2-2</a>. I also asked you to find an even better—and in fact optimal—26-street walk. This optimal walk saves four streets by taking advantage of the fact that we can end the walk as soon as the final piece of candy has been collected. There’s no requirement in the problem description to walk back to the root of the tree.</p>
<p class="indent">What if we <em>did</em> return to the root of the tree as part of the walk? It’s true that we’d get the wrong answer, because we’d walk more streets than required. It’s also true, though, that returning to the root greatly simplifies the problem. We don’t have to be concerned with the thorny issue of how to cleverly do the walk to minimize the number of streets. (After all, we’ll end up back at the root, so we don’t have to orchestrate things so that the final house we visit is a good choice.) Perhaps we’ll be able to overshoot the minimum (by returning to the root) and then subtract off the extra streets that we walked? That’s our gambit!</p>
<p class="indent">Let’s follow the same plan as for <span class="literal">tree_candy</span> and define a base case and a recursive case.<span epub:type="pagebreak" id="page_57"/></p>
<p class="indent">What do we do if the root of the tree is a house—how many streets do we walk starting from that house and getting back to that house? The answer is zero! No streets are required.</p>
<p class="indent">What do you do if the root is a nonhouse? Return to <a href="ch02.xhtml#ch02fig03">Figure 2-3</a>, where I split the tree in two. Suppose we knew the number of streets required to walk the F subtree and the number of streets required to walk the G subtree. We can calculate those recursively. Then, add H and its two edges back in. How many more streets must we walk now? We have to walk one street from H to F and then walk one street from F back to H after we finish with the F subtree. We have to do similarly for G: walking from H to G and then from G back to H after we finish with the G subtree. That’s four additional streets, beyond those that we get from the recursion.</p>
<p class="indent">Here are our two rules:</p>
<p class="block"><strong>Rule 1</strong>   If the root of the tree is a house node, then the number of streets we walk is zero.</p>
<p class="block"><strong>Rule 2</strong>   If the root of the tree is a nonhouse node, then the number of streets we walk is the number of streets we walk for the left subtree plus the number of streets we walk for the right subtree plus <span class="literal">4</span>.</p>
<p class="indent">At this stage, you should be getting a little more comfortable converting such rules into code. <a href="ch02.xhtml#ch02ex011">Listing 2-11</a> supplies an implementation.</p>
<pre>int tree_streets(node *tree) {
  if (!tree-&gt;left &amp;&amp; !tree-&gt;right)
    return 0;
  return tree_streets(tree-&gt;left) + tree_streets(tree-&gt;right) + 4;
}</pre>
<p class="excap" id="ch02ex011"><em>Listing 2-11: Calculating the number of streets getting back to the root</em></p>
<p class="indent">If you perform a walk in <a href="ch02.xhtml#ch02fig02">Figure 2-2</a> starting at H, collecting all the candy, and ending at H, you will walk 32 streets. No matter how you walk the tree, as long as you visit each house once and don’t unnecessarily rewalk streets, you’ll get 32. The minimum number of streets we can walk, with no requirement to return to the root, is 26. Since 32 – 26 = 6, by ending at the root we overshoot the correct answer by six.</p>
<p class="indent">Because there’s no requirement to return to the root, it makes sense to arrange our walk so that the last house that we visit is as far away as possible from the root. For example, ending at the house with 7 pieces of candy is a bad move, because we’re only two streets from H anyway—but look at those gloriously distant 4 and 9 houses way at the bottom. It would be wonderful to end our walk at one of those houses. If we end our walk at 9, for example, then we’d save six streets: 9 to B, B to C, C to D, D to E, E to F, and F to H.</p>
<p class="indent">The plan, then, is to end our walk at a house that is located the maximum number of streets away from the root. If that house is six streets from the root, it means that there is a path of six edges from the root to some leaf. This is exactly the definition of the height of a tree! If we can calculate the height of a tree—recursively, I’ll bet—then we can subtract the height from <span epub:type="pagebreak" id="page_58"/>what <span class="literal">tree_streets</span> gives us. That leaves us off at a house furthest from the root, thereby saving us the maximum number of streets.</p>
<p class="indent">As a quick aside, there’s actually no reason to know which house is the furthest, or even to know how to perform a walk to make that house be last. All we have to do is convince ourselves that we <em>can</em> construct a walk to make that house be last. I’ll give a quick argument using <a href="ch02.xhtml#ch02fig02">Figure 2-2</a> that I hope convinces you. Starting at H, compare the heights of the F and G subtrees, and completely walk whichever has smaller height—G, in this case. Then, repeat this process using F’s subtrees. Compare the heights of the A and E subtrees, and completely walk the A subtree (because it’s height is smaller than that of E). Keep doing this until all subtrees have been walked; the final house that you visit will be a house furthest from H.</p>
<h5 class="h5">Calculating Tree Height</h5>
<p class="noindent">Let’s now move on to <span class="literal">tree_height</span> and another manifestation of our Rule 1– Rule 2 recursive approach.</p>
<p class="indent">The height of a tree consisting of a single house is zero, because there are no edges at all that we can traverse.</p>
<p class="indent">For a tree whose root is a nonhouse, consult <a href="ch02.xhtml#ch02fig03">Figure 2-3</a> again. The F subtree has a height of five, and the G subtree has a height of one. We can solve these subproblems recursively. The height of the original tree, with H in there, is one more than the maximum of five and one, because an edge from H increases the number of edges to each leaf by one.</p>
<p class="indent">That analysis gives us these two rules:</p>
<p class="block"><strong>Rule 1</strong>   If the root of the tree is a house node, then the tree’s height is zero.</p>
<p class="block"><strong>Rule 2</strong>   If the root of the tree is a nonhouse node, then the tree’s height is one more than the maximum of the left subtree’s height and the right subtree’s height.</p>
<p class="indent">See <a href="ch02.xhtml#ch02ex012">Listing 2-12</a> for the code. We have a little <span class="literal">max</span> helper function to tell us the maximum of two numbers; otherwise, <span class="literal">tree_height</span> holds no surprises.</p>
<pre>int max(int v1, int v2) {
  if (v1 &gt; v2)
    return v1;
  else
    return v2;
}

int tree_height(node *tree) {
  if (!tree-&gt;left &amp;&amp; !tree-&gt;right)
    return 0;
  return 1 + max(tree_height(tree-&gt;left), tree_height(tree-&gt;right));
}</pre>
<p class="excap" id="ch02ex012"><em>Listing 2-12: Calculating the height of the tree</em><span epub:type="pagebreak" id="page_59"/></p>
<p class="indent">We now have <span class="literal">tree_candy</span> to calculate the total amount of candy and <span class="literal">tree_streets</span> and <span class="literal">tree_height</span> to calculate the minimum number of streets. Putting those three together gives us a function that solves the problem given a tree; see <a href="ch02.xhtml#ch02ex013">Listing 2-13</a>.</p>
<pre>void tree_solve(node *tree) {
  int candy = tree_candy(tree);
  int height = tree_height(tree);
  int num_streets = tree_streets(tree) - height;
  printf("%d %d\n", num_streets, candy);
}</pre>
<p class="excap" id="ch02ex013"><em>Listing 2-13: Solving the problem, given a tree</em></p>
<p class="indent">Try calling this function on the trees you built in “Building a Tree” on <a href="ch02.xhtml#ch02lev1">page 43</a>.</p>
<h4 class="h4" id="sec27"><em>Reading the Input</em></h4>
<p class="noindent">We are now ever so close, but we’re not quite there. Yes, we can solve the problem if we have a tree in hand, but recall that the input to the problem is lines of text, not trees. We’ll have to convert each of those lines to a tree before we can unleash <span class="literal">tree_solve</span> on it. At last, we’re finally ready to unveil the way in which trees are represented as text.</p>
<h5 class="h5">Representing a Tree as a String</h5>
<p class="noindent">I’ll show you the correspondence between a line of text and its tree by progressing through several examples.</p>
<p class="indent">First, a tree of a single house node is represented simply as the text of the candy value. For example, this tree (whose node’s candy value is four):</p>
<div class="image1"><img alt="Image" src="../images/unch02fig06.jpg"/></div>
<p class="noindent">is represented as follows:</p>
<pre>4</pre>
<p class="indent">A tree whose root is a nonhouse node is represented (recursively!) by the following, in order: an opening parenthesis, a first smaller tree, a space, a second smaller tree, and a closing parenthesis. The first smaller tree in there is the left subtree, and the second smaller tree is the right subtree. For example, this three-node tree</p>
<div class="image1"><img alt="Image" src="../images/unch02fig07.jpg"/></div>
<p class="noindent"><span epub:type="pagebreak" id="page_60"/>is represented like this:</p>
<pre>(4 9)</pre>
<p class="indent">Similarly, here is a five-node tree:</p>
<div class="image1"><img alt="Image" src="../images/unch02fig08.jpg"/></div>
<p class="noindent">This five-node tree is represented like this:</p>
<pre>((4 9) 15)</pre>
<p class="noindent">Here, the left subtree is <span class="literal">(4 9)</span> and the right subtree is <span class="literal">15</span>.</p>
<p class="indent">Written as rules, we have the following:</p>
<p class="block"><strong>Rule 1</strong>   If the text is the digits of integer <span class="literal">c</span>, then the tree is a single house node with <span class="literal">c</span> candy.</p>
<p class="block"><strong>Rule 2</strong>   If the text starts with an opening parenthesis, then the root of the tree is a nonhouse node. After the opening parenthesis, the text contains the tree’s left subtree, a space, the tree’s right subtree, and a closing parenthesis.</p>
<h5 class="h5">Reading in a Nonhouse Node</h5>
<p class="noindent">Our goal is to write function <span class="literal">read_tree</span> with this signature:</p>
<pre>node *read_tree(char *line)</pre>
<p class="indent">It takes a string, and it returns the corresponding tree.</p>
<p class="indent">Let’s start by implementing Rule 2, since Rule 1 involves some subtle work to convert characters to integers.</p>
<p class="indent">Rule 2, the recursive rule, requires us to make two calls to <span class="literal">read_tree</span>: one to read the left subtree and one to read the right subtree. Let’s see how far we get:</p>
<pre> node *tree;
 tree = malloc(sizeof(node));
 if (line[0] == '(') {
<span class="ent">❶</span> tree-&gt;left = read_tree(&amp;line[1]);
<span class="ent">➋</span> tree-&gt;right = read_tree(<span class="codeitalic1">???</span>);
   return tree;
}</pre>
<p class="indent">After allocating memory for the root of our tree, we make a recursive call to read the left subtree <span class="ent">➊</span>. We pass a pointer to index <span class="literal">1</span> of <span class="literal">line</span> so that <span epub:type="pagebreak" id="page_61"/>the recursive call receives the string not including the opening parenthesis at index <span class="literal">0</span>. However, in the next line, we’re in trouble <span class="ent">➋</span>. Where do we start reading the right subtree? Equivalently, how many characters are in the left subtree? We don’t know! We could write a separate function to figure out where the left subtree ends. For example, we could count the number of opening and closing parentheses until they’re equal, except that this seems wasteful: If <span class="literal">read_tree</span> successfully read the left subtree, surely that recursive call knew where that subtree ended? If only there were a way to communicate that information back to the original <span class="literal">read_tree</span> call, it could use that to determine what part of the string to pass to the second recursive call.</p>
<p class="indent">Adding a parameter to a recursive function is a general and powerful way to solve this kind of problem. Whenever a recursive call has information not conveyed through what it returns, or it needs information that is not passed, consider adding a parameter. If that parameter is a pointer, it can be used to both pass additional information to recursive calls and receive information back.</p>
<p class="indent">For our purposes, we want to be able to tell a recursive call where its string starts. Also, we want the recursive call to be able to tell us, when it’s finished, where we should continue processing the string. To do this, we’ll add an integer pointer parameter <span class="literal">pos</span>. However, we don’t want to add that parameter to <span class="literal">read_tree</span>, because the caller of <span class="literal">read_tree</span> has no business or interest knowing about this extra parameter. The caller of <span class="literal">read_tree</span> should be able to just pass a string, not caring about this <span class="literal">pos</span> parameter that is internal to our implementation.</p>
<p class="indent">We’ll keep the signature of <span class="literal">read_tree</span> as before, with only the <span class="literal">line</span> parameter. Then <span class="literal">read_tree</span> will call <span class="literal">read_tree_helper</span>, and it’s <span class="literal">read_tree_helper</span> that has this <span class="literal">pos</span> parameter and induces the recursion.</p>
<p class="indent"><a href="ch02.xhtml#ch02ex014">Listing 2-14</a> gives the <span class="literal">read_tree</span> code. It passes a pointer to <span class="literal">0</span> to <span class="literal">read_tree_helper</span>, because index <span class="literal">0</span> (the start of the string) is where we want to start processing.</p>
<pre>node *read_tree(char *line) {
  int pos = 0;
  return read_tree_helper(line, &amp;pos);
}</pre>
<p class="excap" id="ch02ex014"><em>Listing 2-14: Calling our helper, with a pointer to</em> <span class="codeitalic1">int</span></p>
<p class="indent">We’re now ready to try again with our implementation of Rule 2:</p>
<pre> node *tree;
 tree = malloc(sizeof(node));
 if (line[*pos] == '(') {
<span class="ent">❶</span> (*pos)++;
   tree-&gt;left = read_tree_helper(line, pos);
<span class="ent">➋</span> (*pos)++;
   tree-&gt;right = read_tree_helper(line, pos);
<span class="ent">➌</span> (*pos)++;
   return tree;
 }</pre>
<p class="indent"><span epub:type="pagebreak" id="page_62"/>The function will be called with <span class="literal">pos</span> referring to the first character of a tree, so we first advance <span class="literal">pos</span> by one character to skip over the opening parenthesis <span class="ent">➊</span>. Now <span class="literal">pos</span> is perfectly positioned at the start of the left subtree. We then make the recursive call to read the left subtree. That recursive call will update <span class="literal">pos</span> to the index of the character following the left subtree. Because a space follows the left subtree, we skip over that space <span class="ent">➋</span>. Now we’re positioned at the start of the right subtree; we recursively grab that right subtree and then skip over the closing parenthesis <span class="ent">➌</span>, the one that closes the opening parenthesis that we skipped over initially <span class="ent">➊</span>. Skipping the closing parenthesis is important, because this function is responsible for processing the entire subtree, including its closing parenthesis. If we left out this final skip, whoever called the function may be left staring at a closing parenthesis when they expected a space. After skipping that closing parenthesis, the only thing left to do is return our tree.</p>
<h5 class="h5">Reading in a House Node</h5>
<p class="noindent">With Rule 2 out of the way, let’s tackle Rule 1. Before we can make much progress, we’ll need to be able to convert part of a string to an integer. Let’s write a small, separate program to make sure that we can do this. It will take a string that we assume represents a house node and print its candy value. Surprisingly, if we’re not careful, we may get baffling results. Be advised: we are not careful in <a href="ch02.xhtml#ch02ex015">Listing 2-15</a>.</p>
<pre>#define SIZE 255

// bugged!
int main(void) {
  char line[SIZE + 1];
  int candy;
  gets(line);
  candy = line[0];
  printf("%d\n", candy);
  return 0;
}</pre>
<p class="excap" id="ch02ex015"><em>Listing 2-15: Reading a candy value (bugged!)</em></p>
<p class="indent">Run that program and enter the number <span class="literal">4</span>.</p>
<p class="indent">You’ll likely see <span class="literal">52</span> as the output. Run it again and enter the number <span class="literal">9</span>. You’re likely to see <span class="literal">57</span>. Now run it with <span class="literal">0</span>. You’ll likely see <span class="literal">48</span>. Finally, run it with each value from <span class="literal">0</span> to <span class="literal">9</span>. You should see that each output is offset by the output that <span class="literal">0</span> produced. If <span class="literal">0</span> outputs 48, then <span class="literal">1</span> will output 49, <span class="literal">2</span> will output 50, <span class="literal">3</span> will output 51, and so on.</p>
<p class="indent">What we’re seeing here is the character code for each digit. The crucial point is that the codes for integers are consecutive. We can therefore <span epub:type="pagebreak" id="page_63"/>subtract the character code for zero to put our integers in the proper range. With this fix, we get the code in <a href="ch02.xhtml#ch02ex016">Listing 2-16</a>. Try it!</p>
<pre>#define SIZE 255

int main(void) {
  char line[SIZE + 1];
  int candy;
  gets(line);
  candy = line[0] - '0';
  printf("%d\n", candy);
  return 0;
}</pre>
<p class="excap" id="ch02ex016"><em>Listing 2-16: Reading a candy value</em></p>
<p class="indent">This little program works for single-digit integers. The description of Halloween Haul, though, requires that we also accommodate candy integers that are two digits. Suppose we read digit <span class="literal">2</span> and then digit <span class="literal">8</span>. We want to combine these and end up with the integer <span class="literal">28</span>. What we can do is multiply the first digit by 10 (that gives us 20 here) and then add the 8 (for a total of 28). <a href="ch02.xhtml#ch02ex017">Listing 2-17</a> is another little test program to enable us to check that we’ve got this right. Here we assume that a string of two digits will be typed.</p>
<pre>#define SIZE 255

int main(void) {
  char line[SIZE + 1];
  int digit1, digit2, candy;
  gets(line);
  digit1 = line[0] - '0';
  digit2 = line[1] - '0';
  candy = 10 * digit1 + digit2;
  printf("%d\n", candy);
  return 0;
}</pre>
<p class="excap" id="ch02ex017"><em>Listing 2-17: Reading a candy value with two digits</em></p>
<p class="indent">That’s all we need for Rule 1, and we can write this:</p>
<pre>   <span class="codeitalic1">--snip--</span>
   tree-&gt;left = NULL;
   tree-&gt;right = NULL;
<span class="ent">❶</span> tree-&gt;candy = line[*pos] - '0';
<span class="ent">➋</span> (*pos)++;
   if (line[*pos] != ')' &amp;&amp; line[*pos] != ' ' &amp;&amp;
     line[*pos] != '\0') {
  <span class="ent">➌</span> tree-&gt;candy = tree-&gt;candy * 10 + line[*pos] - '0';
<span class="ent">➍</span> (*pos)++;
}
return tree;</pre>
<p class="indent"><span epub:type="pagebreak" id="page_64"/>We begin by setting the left and right subtrees to <span class="literal">NULL</span>; we’re creating a house node, after all. We then take a character and convert it to a digit <span class="ent">❶</span> and then skip over that digit <span class="ent">➋</span>. Now, if this candy value is only one digit, then we have correctly stored its value. If it is two digits, then we need to multiply the first digit by 10 and add the second digit. We therefore determine whether the candy value is one or two digits. If we’re not looking at a closing parenthesis, or a space, or the null terminator at the end of the string, then we must be looking at a second digit. If a second digit is present, we incorporate it into our candy value <span class="ent">➌</span> and move past the digit <span class="ent">➍</span>.</p>
<p class="indent"><a href="ch02.xhtml#ch02ex018">Listing 2-18</a> puts together our code for Rules 2 and 1.</p>
<pre>node *read_tree_helper(char *line, int *pos) {
  node *tree;
  tree = malloc(sizeof(node));
  if (tree == NULL) {
    fprintf(stderr, "malloc error\n");
    exit(1);
  }
  if (line[*pos] == '(') {
    (*pos)++;
    tree-&gt;left = read_tree_helper(line, pos);
    (*pos)++;
    tree-&gt;right = read_tree_helper(line, pos);
    (*pos)++;
    return tree;
  } else {
    tree-&gt;left = NULL;
    tree-&gt;right = NULL;
    tree-&gt;candy = line[*pos] - '0';
    (*pos)++;
    if (line[*pos] != ')' &amp;&amp; line[*pos] != ' ' &amp;&amp;
        line[*pos] != '\0') {
      tree-&gt;candy = tree-&gt;candy * 10 + line[*pos] - '0';
      (*pos)++;
    }
    return tree;
  }
}</pre>
<p class="excap" id="ch02ex018"><em>Listing 2-18: Converting a string to a tree</em></p>
<p class="indent">All that’s left is to construct a tidy <span class="literal">main</span> function to read each test case and solve it! <a href="ch02.xhtml#ch02ex019">Listing 2-19</a> is all it takes.<span epub:type="pagebreak" id="page_65"/></p>
<pre>#define SIZE 255
#define TEST_CASES 5

int main(void) {
  int i;
  char line[SIZE + 1];
  node *tree;
  for (i = 0; i &lt; TEST_CASES; i++) {
    gets(line);
    tree = read_tree(line);
    tree_solve(tree);
  }
  return 0;
}</pre>
<p class="excap" id="ch02ex019"><em>Listing 2-19: The</em> <span class="codeitalic1">main</span> <em>function</em></p>
<p class="indent">We’ve successfully used recursion to solve this problem, as you should be able to verify by submitting our solution to the judge.</p>
<h3 class="h3" id="lev18">Why Use Recursion?</h3>
<p class="noindent">It’s not always easy to know whether recursion will offer a clean solution to a problem. Here’s the telltale sign: whenever a problem can be solved by combining solutions to smaller subproblems, you should try recursion. In all of our recursive code in this chapter, we have solved exactly two subproblems in order to solve the larger problem. These two-subproblem problems are very common, but a problem may require solving three or four or more subproblems.</p>
<p class="indent">How do you know that breaking a problem into subproblems can help you solve the original problem, and how do you know what those subproblems are in the first place? We’ll revisit these questions in <a href="ch03.xhtml">Chapter 3</a>, when we build on what we’ve learned here to study memoization and dynamic programming. In the meantime, think about whether you could easily solve a given problem if someone told you the solutions to smaller subproblems. For example, think back to calculating the total amount of candy in the tree. This is not an easy problem. What if someone told you the total amount of candy in the left subtree and the total amount of candy in the right subtree? That would make the problem easier. A problem made easier by virtue of knowing its subproblem solutions is a strong clue that recursion applies.</p>
<p class="indent">Let’s move on to another problem where recursion is useful. As you read the problem description, try to identify where and why recursion will come into play.<span epub:type="pagebreak" id="page_66"/></p>
<h3 class="h3" id="lev19">Problem 2: Descendant Distance</h3>
<p class="noindent">We’ll now move away from binary trees to general trees in which nodes can have many children.</p>
<p class="indent">This is DMOJ problem <span class="literal">ecna05b</span>.</p>
<h4 class="h4" id="sec28"><em>The Problem</em></h4>
<p class="noindent">In this problem, we are given a family tree and a specified distance <em>d</em>. The score for each node in the tree is the number of descendants it has at distance <em>d</em>. Our task is to output the nodes with high scores; I’ll explain exactly how many nodes that is in the Output section. To see what I mean by descendants at a specified distance, look at the family tree in <a href="ch02.xhtml#ch02fig06">Figure 2-6</a>.</p>
<div class="image"><img alt="Image" id="ch02fig06" src="../images/ch02fig06.jpg"/></div>
<p class="figcap"><em>Figure 2-6: A sample family tree</em></p>
<p class="indent">Consider the Amber node. Amber has four children, so she has four descendants at a distance of one. Amber also has five grandchildren: five nodes at a distance of two. Generalizing, we can say that, for any node, the number of descendants at distance <em>d</em> is the number of nodes that are exactly <em>d</em> edges down the tree from that node.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The first line of input gives the number of test cases that will follow. Each test case consists of the following lines:<span epub:type="pagebreak" id="page_67"/></p>
<ul>
<li class="noindents">A line containing two integers, <em>n</em> and <em>d</em>, where <em>n</em> tells us how many more lines there are for this test case and <em>d</em> specifies the descendant distance of interest.</li>
<li class="noindents"> <em>n</em> lines used to build the tree. Each of these lines consists of the name of a node, an integer <em>m</em>, and <em>m</em> node names giving the children of this node. Each name is at most 10 characters long. These lines can come in any order—there’s no requirement that parent lines come before their descendant lines.</li>
</ul>
<p class="indent">There are at most 1,000 nodes in any test case.</p>
<p class="indent">Here is a possible input to generate the sample tree in <a href="ch02.xhtml#ch02fig06">Figure 2-6</a>, asking for the nodes with the most descendants at a distance of two:</p>
<pre>1
7 2
Lucas 1 Enzo
Zara 1 Amber
Sana 2 Gabriel Lucas
Enzo 2 Min Becky
Kevin 2 Jad Cassie
Amber 4 Vlad Sana Ashley Kevin
Vlad 1 Omar</pre>
<h5 class="h5">Output</h5>
<p class="noindent">The output for each test case has two parts.</p>
<p class="indent">First, output the following line:</p>
<pre>Tree <span class="codeitalic1">i</span>:</pre>
<p class="noindent">where <span class="codeitalic">i</span> is <span class="literal">1</span> for the first test case, <span class="literal">2</span> for the second test case, and so on.</p>
<p class="indent">Then, output information for the nodes with high scores (where the score for a node is the number of descendants it has at distance <em>d</em>), sorted from most to least. Output the names that are tied for the number of descendants at distance <em>d</em> in alphabetical order.</p>
<p class="indent">Use the following rules to determine how many names to output:</p>
<ul>
<li class="noindents">If there are three or fewer names with descendants at distance <em>d</em>, output them all.</li>
<li class="noindents">If there are more than three names with descendants at distance <em>d</em>, start by outputting those with the top three scores, starting from the highest score. Then, output each other name whose score is the same as the third score from the top. For example, if we have names with eight, eight, two, two, two, one, and one descendants at distance <em>d</em>, we would output information for five names: those with eight, eight, two, two, and two descendants at distance <em>d</em>.</li>
</ul>
<p class="indent"><span epub:type="pagebreak" id="page_68"/>For each name that we’re required to output, we output a line consisting of the name, followed by a space, followed by its number of descendants at distance <em>d</em>.</p>
<p class="indent">Output for each test case is separated from the next by a blank line.</p>
<p class="indent">Here is the output for the above sample input:</p>
<pre>Tree 1:
Amber 5
Zara 4
Lucas 2</pre>
<p class="indent">The time limit for solving the test cases is 0.6 seconds.</p>
<h4 class="h4" id="sec29"><em>Reading the Input</em></h4>
<p class="noindent">One interesting difference between this problem and the Halloween Haul problem is that we’re no longer dealing with binary trees. Here, a node can have any number of children. We’ll have to change our node structure, since <span class="literal">left</span> and <span class="literal">right</span> pointers are not going to work for us anymore. Instead, we’ll use an array <span class="literal">children</span> of children and an integer <span class="literal">num_children</span> to record the number of children stored in the array. We’ll also have a <span class="literal">name</span> member to store the node’s name (Zara, Amber, and so on) and a <span class="literal">score</span> member for when we calculate the number of descendants at distance <em>d</em>. Our <span class="literal">node</span> struct is given in <a href="ch02.xhtml#ch02ex020">Listing 2-20</a>.</p>
<pre>typedef struct node {
  int num_children;
  struct node **children;
  char *name;
  int score;
} node;</pre>
<p class="excap" id="ch02ex020"><em>Listing 2-20: The</em> <span class="codeitalic1">node</span> <em>struct</em></p>
<p class="indent">In Halloween Haul, the trees started as recursively defined expressions, from which we could recursively read off the left and right subtrees. This is not the case here: nodes can come in any order. For example, we might see</p>
<pre>Zara 1 Amber
Amber 4 Vlad Sana Ashley Kevin</pre>
<p class="noindent">where we learn about Zara’s child, Amber, before we learn about Amber’s children. However, we could equally well see</p>
<pre>Amber 4 Vlad Sana Ashley Kevin
Zara 1 Amber</pre>
<p class="noindent">where we learn about Amber’s children before Zara’s!</p>
<p class="indent">We know that the nodes and parent-child relationships we read from the file will, by the time we’re done, form a single tree. Nonetheless, there’s no <span epub:type="pagebreak" id="page_69"/>guarantee that we have a single tree as we process the lines. For example, we might read the lines</p>
<pre>Lucas 1 Enzo
Zara 1 Amber</pre>
<p class="indent">This tells us that Enzo is a child of Lucas and that Amber is a child of Zara, but so far that’s all we know. We have two disconnected subtrees here, and it will take future lines to connect these subtrees.</p>
<p class="indent">For these reasons, maintaining a single, connected tree as we read the lines is hopeless. Instead, we’ll maintain an array of pointers to nodes. Every time we see a name we haven’t seen before, we create a new node and add a pointer to that node to the array. It will therefore prove valuable to have a helper function that searches the array and tells us whether we have seen a name before.</p>
<h5 class="h5">Finding a Node</h5>
<p class="noindent"><a href="ch02.xhtml#ch02ex021">Listing 2-21</a> implements a <span class="literal">find_node</span> function. The <span class="literal">nodes</span> parameter is an array of pointers to nodes, <span class="literal">num_nodes</span> gives the number of pointers in the array, and <span class="literal">name</span> is the name that we’re searching for.</p>
<pre>node *find_node(node *nodes[], int num_nodes, char *name) {
  int i;
  for (i = 0; i &lt; num_nodes; i++)
    if (strcmp(nodes[i]-&gt;name, name) == 0)
      return nodes[i];
  return NULL;
}</pre>
<p class="excap" id="ch02ex021"><em>Listing 2-21: Finding a node</em></p>
<p class="indent">A <em>linear search</em> is an element-by-element search of an array. Inside our function, we use a linear search to search through <span class="literal">nodes</span>, and . . . but wait! Aren’t we searching through an array? This is tailor-made hash table territory right here (see <a href="ch01.xhtml">Chapter 1</a>). I encourage you to swap in a hash table on your own and compare the performance. To keep things simple, and because there are at most only 1,000 nodes, we’ll proceed with this (slow) linear search.</p>
<p class="indent">We do a string comparison between each name in the array and the desired name. If <span class="literal">strcmp</span> returns <span class="literal">0</span>, it means that the strings are equal, so we return the pointer to the corresponding node. If we reach the end of the array without finding the name, we return <span class="literal">NULL</span> to signal that the name was not found.</p>
<h5 class="h5">Creating a Node</h5>
<p class="noindent">When a name is not found in the array, we’ll have to create a node with that name. This will involve a call to <span class="literal">malloc</span>, and we’ll see that <span class="literal">malloc</span> will be required elsewhere in the program as well. So, I’ve written a helper function, <span epub:type="pagebreak" id="page_70"/><span class="literal">malloc_safe</span>, that we can call whenever we need it. See <a href="ch02.xhtml#ch02ex022">Listing 2-22</a>: it’s just a regular <span class="literal">malloc</span>, but with error checking added:</p>
<pre>void *malloc_safe(int size) {
  char *mem = malloc(size);
  if (mem == NULL) {
    fprintf(stderr, "malloc error\n");
    exit(1);
  }
  return mem;
}</pre>
<p class="excap" id="ch02ex022"><em>Listing 2-22: The</em> <span class="codeitalic1">malloc_safe</span> <em>function</em></p>
<p class="indent">The <span class="literal">new_node</span> helper function in <a href="ch02.xhtml#ch02ex023">Listing 2-23</a> uses <span class="literal">malloc_safe</span> to create a new node.</p>
<pre>node *new_node(char *name) {
  node *n = malloc_safe(sizeof(node));
  n-&gt;name = name;
  n-&gt;num_children = 0;
  return n;
}</pre>
<p class="excap" id="ch02ex023"><em>Listing 2-23: Creating a node</em></p>
<p class="indent">We allocate the new node and then set the node’s <span class="literal">name</span> member. Then, we set the node’s number of children to <span class="literal">0</span>. The reason we use zero here is because we may not know how many children the node has. For example, suppose that the first line that we read for the tree is</p>
<pre>Lucas 1 Enzo</pre>
<p class="indent">We know that Lucas has one child, but we have no idea how many children Enzo has. The caller of <span class="literal">new_node</span> can set the number of children to a new value once that information is available. That happens immediately for Lucas here, but not for Enzo.</p>
<h5 class="h5">Building a Family Tree</h5>
<p class="noindent">Now we’re ready to read and build the tree. <a href="ch02.xhtml#ch02ex024">Listing 2-24</a> gives the function. Here <span class="literal">nodes</span> is an array of pointers to nodes, with space allocated by the caller of this function; <span class="literal">num_lines</span> indicates the number of lines to read.</p>
<pre>#define MAX_NAME 10

int read_tree(node *nodes[], int num_lines) {
  node *parent_node, *child_node;
  char *parent_name, *child_name;
  int i, j, num_children;
  int num_nodes = 0;
<span class="ent">❶</span> for (i = 0; i &lt; num_lines; i++) {
   parent_name = malloc_safe(MAX_NAME + 1);
   scanf("%s", parent_name);
   scanf("%d", &amp;num_children);
<span class="ent">➋</span> parent_node = find_node(nodes, num_nodes, parent_name);
   if (parent_node == NULL) {
     parent_node = new_node(parent_name);
     nodes[num_nodes] = parent_node;
     num_nodes++;
   }
   else
   <span class="ent">➌</span> free(parent_name);

<span class="ent">➍</span> parent_node-&gt;children = malloc_safe(sizeof(node) * num_children);
<span class="ent">➎</span> parent_node-&gt;num_children = num_children;
   for (j = 0; j &lt; num_children; j++) {
     child_name = malloc_safe(MAX_NAME + 1);
     scanf("%s", child_name);
     child_node = find_node(nodes, num_nodes, child_name);
     if (child_node == NULL) {
       child_node = new_node(child_name);
       nodes[num_nodes] = child_node;
       num_nodes++;
     }
     else
       free(child_name);
   <span class="ent">➏</span> parent_node-&gt;children[j] = child_node;
    }
  }
  return num_nodes;
}</pre>
<p class="excap" id="ch02ex024"><span epub:type="pagebreak" id="page_71"/><em>Listing 2-24: Converting lines into a tree</em></p>
<p class="indent">The outer <span class="literal">for</span> loop <span class="ent">➊</span> iterates once for each of the <span class="literal">num_lines</span> lines of input. Each line has the name of a parent and one or more names for children; we deal with the parent first. We allocate memory, read the parent’s name, and read the parent’s number of children. Then, we use our <span class="literal">find_node</span> helper function to determine whether we have seen this node before <span class="ent">➋</span>. If we have not, we use our <span class="literal">new_node</span> helper function to create a new node, store a pointer to the new node in the <span class="literal">nodes</span> array, and increment the number of nodes. If the node is already in the <span class="literal">nodes</span> array, we free the memory for the parent name since it will not be used <span class="ent">➌</span>.</p>
<p class="indent">We next allocate memory for the parent’s child pointers <span class="ent">➍</span>, and we store the number of children <span class="ent">➎</span>. We then process the child nodes; each child is processed similarly to the parent node. Once the child node exists and has its members set, we store a pointer to it in the parent’s <span class="literal">children</span> array <span class="ent">➏</span>. Notice that there is no child code that allocates any memory or sets the number of children, like we had for the parent. If we have seen a child name before, <span epub:type="pagebreak" id="page_72"/>then its children were already set when this name was encountered the first time. If this is the first time we’re seeing the name, then we’ll set its children when we later learn about its children; if this child is a leaf, its number of children will remain at its initialized value of <span class="literal">0</span>.</p>
<p class="indent">We end by returning the number of nodes in the tree. We’ll need this when we want to process each node.</p>
<h4 class="h4" id="sec30"><em>Number of Descendants from One Node</em></h4>
<p class="noindent">We need to calculate the number of descendants at distance <em>d</em> for each node, so we can find the nodes with the most such descendants. A more modest goal, and the goal for this section, is to calculate the number of descendants at distance <em>d</em> from a single node. We’ll write the function with this signature:</p>
<pre>int score_one(node *n, int d)</pre>
<p class="noindent">where <span class="literal">n</span> is the node whose number of descendants at distance <span class="literal">d</span> we’d like to calculate.</p>
<p class="indent">If <span class="literal">d</span> is <span class="literal">1</span>, then we want to know the number of children of <span class="literal">n</span>. That we can do: we have stored a <span class="literal">num_children</span> member with each node. All we have to do is return that:</p>
<pre>if (d == 1)
  return n-&gt;num_children;</pre>
<p class="indent">If <span class="literal">d</span> is greater than <span class="literal">1</span>, then what? It may be worth thinking about this first in the more familiar context of binary trees. Here’s the binary tree from Halloween Haul (<a href="ch02.xhtml#ch02fig02">Figure 2-2</a>) again:</p>
<div class="image"><img alt="Image" src="../images/unch02fig09.jpg"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_73"/>Suppose we had a node of a binary tree and we wanted to know its number of descendants at some specified distance. If we knew how many descendants at that distance were in the left subtree and how many were in the right subtree, would that help?</p>
<p class="indent">Not quite. Suppose, for example, that we wanted to know the number of descendants of H at a distance of two. We calculate the number of descendants of F at a distance of two and the number of descendants of G at a distance of two. That doesn’t help, because each of those descendants is at a distance of three from H! We don’t care about nodes at a distance of three.</p>
<p class="indent">How do we fix this? We calculate the number of descendants of F at a distance of one and G at a distance of one! Each of those nodes is at a distance of two from H.</p>
<p class="indent">To calculate the number of descendants at any distance <em>d</em>, then, we calculate the number of descendants at distance <em>d</em> – 1 in the left subtree and number of descendants at distance <em>d</em> – 1 in the right subtree.</p>
<p class="indent">In the context of family trees, where a node can have more than two children, we generalize this slightly: the number of descendants at distance <em>d</em> is the sum of the number of descendants at distance <em>d</em> – 1 in each subtree. And how are we going to find the number of descendants at distance <em>d</em> – 1 in each subtree? It’s recursion time!</p>
<p class="indent">Here are some rules for us to use. Given a node <em>n</em>:</p>
<p class="block"><strong>Rule 1</strong>   If <em>d</em> equals one, then the number of descendants at distance <em>d</em> equals the number of children of <em>n</em>.</p>
<p class="block"><strong>Rule 2</strong>   If <em>d</em> is greater than one, then the number of descendants at distance <em>d</em> equals the sum of the number of descendants at distance <em>d</em> – 1 in each subtree of <em>n</em>.</p>
<p class="indent">The corresponding code is given in <a href="ch02.xhtml#ch02ex025">Listing 2-25</a>.</p>
<pre>int score_one(node *n, int d) {
  int total, i;
  if (d == 1)
    return n-&gt;num_children;
  total = 0;
  for (i = 0; i &lt; n-&gt;num_children; i++)
    total = total + score_one(n-&gt;children[i], d - 1);
  return total;
}</pre>
<p class="excap" id="ch02ex025"><em>Listing 2-25: The number of descendants from one node</em></p>
<h4 class="h4" id="sec31"><em>Number of Descendants from All Nodes</em></h4>
<p class="noindent">To calculate the number of descendants at distance <em>d</em> for all nodes, we simply put <span class="literal">score_one</span> in a loop (<a href="ch02.xhtml#ch02ex026">Listing 2-26</a>).</p>
<pre>void score_all(node **nodes, int num_nodes, int d) {
  int i;
  for (i = 0; i &lt; num_nodes; i++)
    nodes[i]-&gt;score = score_one(nodes[i], d);
}</pre>
<p class="excap" id="ch02ex026"><span epub:type="pagebreak" id="page_74"/><em>Listing 2-26: The number of descendants from all nodes</em></p>
<p class="indent">Here is where we use the <span class="literal">score</span> member in each <span class="literal">node</span> struct: after this function runs, <span class="literal">score</span> holds the number of descendants of interest for each node. Now we just have to figure out which nodes have the highest scores!</p>
<h4 class="h4" id="sec32"><em>Sorting Nodes</em></h4>
<p class="noindent">In our ill-fated attempt to sort snowflakes (see “Diagnosing the Problem” on <a href="ch01.xhtml#ch01lev1">page 9</a>), we came across the C <span class="literal">qsort</span> function. We can bring <span class="literal">qsort</span> to bear here to sort our nodes. We’re required to sort by number of descendants at distance <em>d</em>, from highest to lowest. If nodes are tied for the number of descendants at distance <em>d</em>, then we sort those alphabetically.</p>
<p class="indent">To use <span class="literal">qsort</span>, we’re tasked with writing a comparison function that takes pointers to two elements and returns a negative integer if the first element is less than the second, <span class="literal">0</span> if they are equal, and a positive integer if the first is greater than the second. Our comparison function is given in <a href="ch02.xhtml#ch02ex027">Listing 2-27</a>.</p>
<pre>int compare(const void *v1, const void *v2) {
  const node *n1 = *(const node **)v1;
  const node *n2 = *(const node **)v2;
  if (n1-&gt;score &gt; n2-&gt;score)
    return -1;
  if (n1-&gt;score &lt; n2-&gt;score)
    return 1;
  return strcmp(n1-&gt;name, n2-&gt;name);
}</pre>
<p class="excap" id="ch02ex027"><em>Listing 2-27: A comparison function for sorting</em></p>
<p class="indent">Any <span class="literal">qsort</span> comparison function, like this one, has the same signature: it takes two void pointers. These pointers are <span class="literal">const</span> to signify that we should not make any changes to the elements that they point to.</p>
<p class="indent">Void pointers must be cast before we can perform comparisons or otherwise access the underlying elements. Remember that <span class="literal">qsort</span> calls <span class="literal">compare</span> with pointers to two elements from our array, but, because our array is an array of pointers, what gets passed to <span class="literal">compare</span> is two pointers to pointers to elements. Therefore, we first cast the void pointers to type <span class="literal">const node**</span>, and then we apply <span class="literal">*</span> to give us values for <span class="literal">n1</span> and <span class="literal">n2</span> that are of type <span class="literal">const node*</span>. Now we can use <span class="literal">n1</span> and <span class="literal">n2</span> as pointers to nodes.</p>
<p class="indent">We begin by comparing the scores that are stored in each node. These scores will have already been calculated as the number of descendants at the distance <em>d</em>. If <span class="literal">n1</span> has more such descendants than <span class="literal">n2</span>, we return <span class="literal">-1</span> to indicate that <span class="literal">n1</span> should sort before <span class="literal">n2</span>. Similarly, if <span class="literal">n1</span> has fewer descendants at distance <em>d</em> than <span class="literal">n2</span>, we return <span class="literal">1</span> to indicate that <span class="literal">n1</span> should sort after <span class="literal">n2</span>.<span epub:type="pagebreak" id="page_75"/></p>
<p class="indent">The only way to get to the final line, then, is if <span class="literal">n1</span> and <span class="literal">n2</span> have the same number of descendants at distance <em>d</em>. It’s here where we want to break the tie by sorting on the nodes’ names. We do this using <span class="literal">strcmp</span>, which returns a negative number, zero, or positive number if the first string is alphabetically less than, equal to, or greater than the second string, respectively.</p>
<h4 class="h4" id="sec33"><em>Outputting the Information</em></h4>
<p class="noindent">After we sort the nodes, the names to output are those at the beginning of the <span class="literal">nodes</span> array. <a href="ch02.xhtml#ch02ex028">Listing 2-28</a> gives the function that produces this output:</p>
<pre>void output_info(node *nodes[], int num_nodes) {
  int i = 0;
<span class="ent">❶</span> while (i &lt; 3 &amp;&amp; i &lt; num_nodes &amp;&amp; nodes[i]-&gt;score &gt; 0) {
     printf("%s %d\n", nodes[i]-&gt;name, nodes[i]-&gt;score);
     i++;
  <span class="ent">➋</span> while (i &lt; num_nodes &amp;&amp; nodes[i]-&gt;score == nodes[i - 1]-&gt;score) {
       printf("%s %d\n", nodes[i]-&gt;name, nodes[i]-&gt;score);
       i++;
    }
  }
}</pre>
<p class="excap" id="ch02ex028"><em>Listing 2-28: Outputting the nodes</em></p>
<p class="indent">The variable <span class="literal">i</span> counts the number of nodes that we have outputted. The outer <span class="literal">while</span> loop <span class="ent">➊</span> is controlled by three conditions that together determine whether we are allowed to output more nodes. If all three conditions are true, we know that more output is required, so we enter the body of that <span class="literal">while</span> loop. We then print information for the current node and increase <span class="literal">i</span> so that we look at the next node. Now, as long as this new node is tied with the previous node, we want to keep outputting nodes, with no heed to the “maximum of three nodes” rule. The conditions on the inner <span class="literal">while</span> loop <span class="ent">➋</span> encode this logic: if there are more nodes and the current node’s score is tied with the previous node, then we enter the body of the inner <span class="literal">while</span> loop and print information for the relevant node.</p>
<h4 class="h4" id="sec34"><em>The main Function</em></h4>
<p class="noindent">All that remains is to glue our functions together and add the logic to process the test cases. We do this in <a href="ch02.xhtml#ch02ex029">Listing 2-29</a>.</p>
<pre> #define MAX_NODES 1000

 int main(void) {
   int num_cases, case_num;
   int n, d, num_nodes;
<span class="ent">❶</span> node **nodes = malloc_safe(sizeof(node) * MAX_NODES);
   scanf("%d", &amp;num_cases);
   for (case_num = 1; case_num &lt;= num_cases; case_num++) {
   <span class="ent">➋</span> printf("Tree %d:\n", case_num);
      scanf("%d %d", &amp;n, &amp;d);
      num_nodes = read_tree(nodes, n);
      score_all(nodes, num_nodes, d);
      qsort(nodes, num_nodes, sizeof(node*), compare);
      output_info(nodes, num_nodes);
   <span class="ent">➌</span> if (case_num &lt; num_cases)
        printf("\n");
   }
   return 0;
 }</pre>
<p class="excap" id="ch02ex029"><span epub:type="pagebreak" id="page_76"/><em>Listing 2-29: The</em> <span class="codeitalic1">main</span> <em>function</em></p>
<p class="indent">We begin by allocating pointers for the maximum number of nodes that can make up a test case <span class="ent">➊</span>. We then read the number of test cases and loop once for each test case. Recall that each test case requires two pieces of output: information about the test case number and information about the relevant nodes. The first is handled by a single call of <span class="literal">printf</span> <span class="ent">➋</span>. For the second, we start leaning on our earlier functions: we read the tree, solve the problem for each node, sort the nodes, and then output the required information.</p>
<p class="indent">There’s a check at the bottom of the code to tell whether or not we’re in the final test case <span class="ent">➌</span>; this is so we can output a blank line between tests.</p>
<h3 class="h3" id="lev20">Summary</h3>
<p class="noindent">Recursive solutions are virtuous, simple, clean, easy to devise, easy to understand, and easy to prove correct . . .</p>
<p class="indent">Well, at least, that’s the sense you’d get if you read enough about recursion and talked to enough recursion enthusiasts. It’s clear what the experts think. Through my students, however, I’ve observed a disconnect between the way that recursion is touted and the way it is learned. It takes time and practice to appreciate the expert perspective. Don’t worry if you find recursive solutions tough to devise and trust. Keep at it! Many teachers and writers have their own approaches and examples for introducing recursion. More than for any other topic in the book, I encourage you to seek out additional material on recursion to complement what I have offered here.</p>
<p class="indent">In the next chapter, we’ll keep going with recursion, optimizing it for a different class of problems.</p>
<h3 class="h3" id="lev21">Notes</h3>
<p class="noindent">Halloween Haul is originally from the 2012 DWITE Programming Competition, Round 1. Descendant Distance is originally from the 2005 East Central North America Regional Programming Contest. For a book-length treatment of recursion, check out <em>Thinking Recursively with Java</em> by Eric Roberts (2005).</p>
</body></html>