- en: '**9**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IOS-TARGETED WEB APPS**'
  prefs: []
  type: TYPE_NORMAL
- en: Since the introduction of third-party developer APIs for iOS, the Web has been
    an important component of iOS applications. Originally, the APIs were entirely
    web-based. While this potentially made life easier for people with no Objective-C
    or Cocoa experience, it severely limited what non-Apple applications could do
    and relegated them to a second-class status. They had no access to native capabilities
    of the phone, such as geolocation, and were available only within the browser
    instead of on the home screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'While things have changed drastically since that time, the need to integrate
    with web applications from iOS has not. In this chapter, you’ll take a closer
    look at the connections between native iOS applications and web applications:
    how web applications are interacted with, what native iOS APIs can be exposed
    to web apps, and the risks of various approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using (and Abusing) UIWebViews**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developers use web views to render and interact with web content in iOS applications
    because they are simple to implement and provide browser-like functionality. Most
    web views are instances of the `UIWebView` class, which uses the WebKit rendering
    engine^([1](footnote.html#fn77)) to display web content. Web views are often used
    either to abstract portions of the application so they can be shared between different
    mobile app platforms or simply to offload more logic to the web application, often
    because of more in-house expertise in web application programming than iOS. They’re
    also frequently used as a way to view links to third-party web content without
    having to leave the application and spawn Safari. For example, when you click
    an article in a Facebook feed, the content is rendered in the Facebook app.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with iOS 8, the `WKWebView` framework was introduced. This framework
    gives developers some additional flexibility as well as access to Apple’s high-performance
    Nitro JavaScript engine, which increases the performance of apps that use web
    views significantly. Since you’ll be seeing `UIWebView` for some time to come,
    you’ll examine both APIs in this chapter, beginning with `UIWebView`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with UIWebViews***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Web views shift some portion of the application logic to a remote web API or
    application. As such, developers have less control over the behavior of web views
    than a fully native iOS application would allow, but there are a few controls
    you can put in place to bend web views to your will.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing the `shouldStartLoadWithRequest` method of the protocol `UIWebViewDelegate`,^([2](footnote.html#fn78))
    you can make decisions about all the URLs opened via web views before actually
    allowing them to be opened. For example, to limit the attack surface, you can
    limit all requests so that they go only to HTTPS URLs or only to particular domains.
    If you want to ensure that your application will never load non-HTTPS URLs, you
    can do something like the example shown in [Listing 9-1](ch09.html#ch9ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: Rejecting non-HTTPS URLs and unknown hostnames*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses two different attributes of the `NSURL` associated with the
    `NSURLRequest` being loaded. At ➊, the `scheme` property of the URL is checked
    to see whether it matches the specified scheme, `https`. At ➋, the `host` property
    is compared to a single whitelisted domain: *happy.fluffy.bunnies.com*. These
    two restrictions limit the application’s web views access to only your domain—rather
    than anything that might be attacker-controlled—and ensure that requests are always
    transmitted over HTTPS, keeping their contents safe from network attackers.'
  prefs: []
  type: TYPE_NORMAL
- en: Web views may seem like the way to go because you can reuse codebases across
    platforms and still have some level of control over the local system. However,
    web views do have some serious security implications. One limitation is the inability
    to upgrade the WebKit binary shipped with `UIWebView`. WebKit is prepackaged with
    new versions of iOS and does not get updated out-of-band from the main OS. This
    means that any WebKit vulnerabilities that are discovered remain exploitable until
    a new version of iOS is released.
  prefs: []
  type: TYPE_NORMAL
- en: Another major part of using web views securely involves handling your cached
    data properly, which I’ll discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Executing JavaScript in UIWebViews***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The web view JavaScript engine is known as JavaScriptCore, also marketed as
    Nitro by Apple. While the new `WKWebView` class improves JavaScript support (see
    “[Enter WKWebView](ch09.html#ch09lev1sec03)” on [page 158](ch09.html#page_158)),
    the implementation of JavaScript-Core as used in `UIWebView` has a couple of shortcomings
    when compared with JavaScript engines in modern browsers. The main limitation
    is the lack of just-in-time (JIT) compilation.
  prefs: []
  type: TYPE_NORMAL
- en: '`UIWebView` JavaScript execution also limits total allocations to 10MB and
    runtime to 10 seconds, at which point execution will be immediately and unequivocally
    halted. Despite these shortcomings, applications can execute a limited amount
    of JavaScript by passing the script to `stringByEvaluatingJavaScriptFromString`,
    as illustrated in [Listing 9-2](ch09.html#ch9ex2).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-2: Injecting JavaScript into the web view*'
  prefs: []
  type: TYPE_NORMAL
- en: The `stringByEvaluatingJavaScriptFromString` method takes a single argument,
    which is a blob of JavaScript, to insert into the view. Here, the element `elem`
    is created, a simple function to spawn an alert box is defined, and the function
    is inserted into the web view. Now, the newly defined function can be called with
    subsequent calls to `stringByEvaluatingJavaScriptFromString`.
  prefs: []
  type: TYPE_NORMAL
- en: Do note, however, that allowing dynamic JavaScript execution within your apps
    exposes your users to the JavaScript injection attacks. As such, this functionality
    should be used judiciously, and developers should never reflect untrusted input
    into dynamically generated scripts.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn more about JavaScriptCore in the next section, where I discuss
    ways to get around the `UIWebView` shortcomings I’ve described so far.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rewards and Risks of JavaScript-Cocoa Bridges**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To overcome the limitations of `UIWebView`, various workarounds have been used
    to expose more native functionality to web-based applications. For example, the
    Cordova development framework uses a clever (or dangerous) web view implementation
    to access Cocoa APIs that allow the use of the camera, accelerometer, geolocation
    capabilities, address book, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll introduce you to some popular JavaScript-Cocoa bridges,
    provide examples of how you’d see them used in the wild, and discuss some security
    risks they pose.
  prefs: []
  type: TYPE_NORMAL
- en: '***Interfacing Apps with JavaScriptCore***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prior to iOS 7, `[UIWebView stringByEvaluatingJavaScriptFromString:]` was the
    only way to invoke JavaScript from inside an application. However, iOS 7 shipped
    with the JavaScriptCore framework, which has full support for bridging communications
    between native Objective-C and a JavaScript runtime. The bridge is created via
    the new `JSContext` global object, which provides access to a JavaScript virtual
    machine for evaluating code. The Objective-C runtime can also obtain strong references
    to JavaScript values via `JSValue` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use JavaScriptCore to interface with the JavaScript runtime in two
    fundamental ways: by using inline blocks or by directly exposing Objective-C objects
    with the `JSExport` protocol. I’ll briefly cover how both methods work and then
    discuss security concerns introduced by this new attack surface.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directly Exposing Objective-C Blocks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One use of Objective-C blocks is to provide a simple mechanism to expose Objective-C
    code to JavaScript. When you expose an Objective-C block to JavaScript, the framework
    automatically wraps it with a callable JavaScript function, which allows you to
    then call the Objective-C code directly from JavaScript. Let’s look at an example—albeit
    a contrived one—in [Listing 9-3](ch09.html#ch9ex3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-3: Exposing an Objective-C block to JavaScript*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, a block (you can see it defined by the `^` operator at ➊) is exposed that
    accepts a password and a salt from JavaScript and uses the Common-Crypto framework
    to create a hash. This block can then be accessed directly from JavaScript to
    create the user’s password hash, as shown in [Listing 9-4](ch09.html#ch9ex4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-4: JavaScript call to exposed Objective-C block*'
  prefs: []
  type: TYPE_NORMAL
- en: This technique lets you utilize the Cocoa Touch APIs and avoid re-implementing
    difficult and easily botched operations such as encryption or hashing.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks are the simplest way to expose Objective-C code to JavaScript, but they
    have a few drawbacks. For instance, all the bridged objects are immutable, so
    changing the value of an Objective-C variable won’t affect the JavaScript variable
    that it is mapped to. However, if you do need to share objects between both execution
    contexts, you can also expose custom classes using the `JSExport` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Connecting Objective-C and JavaScript with JSExport**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `JSExport` protocol allows applications to expose entire Objective-C classes
    and instances to JavaScript and operate on them as if they were JavaScript objects.
    Additionally, the references to their Objective-C counterparts are strong, meaning
    modifications to an object in one environment are reflected in the other. Defining
    variables and methods within a protocol that inherits `JSExport` signals to JavaScriptCore
    that those elements can be accessed from JavaScript, as illustrated in [Listing
    9-5](ch09.html#ch9ex5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-5: Exposing variables and methods using a whitelist approach*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to that `JSExport` protocol declaration, JavaScript has access to the
    variables `name` and `address` and the function `updateUser`. Apple has made exposing
    such objects to JavaScriptCore extremely easy, which means it can also be extremely
    easy for developers to inadvertently expose all kinds of unintended functionality.
    Luckily, this bridge follows an entirely opt-in model: only members you actually
    define in the protocol itself are exposed. Unless explicitly whitelisted in the
    protocol definition, any additional declarations made in the class interface are
    hidden, as in [Listing 9-6](ch09.html#ch9ex6).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-6: Elements declared outside the protocol definition are inacessible
    in JavaScript*'
  prefs: []
  type: TYPE_NORMAL
- en: The `User` interface inherits from `UserExports` at ➊, so it also inherits from
    `JSExport`. But the `password` property and the `resetPassword` method aren’t
    declared inside `UserExports`, so they won’t be exposed to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that JavaScriptCore knows about your `UserExports` protocol, it can create
    an appropriate wrapper object when you add an instance of it to a `JSContext`,
    as in the next listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, a `JSContext` is set up at ➊, an instance of a `User` class is set up
    at ➋, and some values are assigned to three of the new user’s properties. One
    of those properties, `hiddenName`, was defined only in the `@implementation` instead
    of the protocol—the same thing that happened in [Listing 9-6](ch09.html#ch9ex6)
    with the `password` property. At ➌, the newly created user is bridged to the `JSContext`.
    When the code subsequently tries to access the values of the user object from
    JavaScript, the `value` property is successfully accessed at ➍, while the attempt
    to access `hiddenName` fails ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use discretion when exporting objects to JavaScriptCore. An attacker who exploits
    a script injection flaw will be able to run any exported functions, essentially
    turning the script injection into native remote code execution on users’ devices.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'One additional interesting point is that JavaScriptCore disallows calling exported
    class constructors. (This is a bug in iOS that, as of iOS 8, has yet to be resolved.)
    So even if you add `[User class]` to your context, you won’t be able to create
    new objects using `new`. As I discovered through some testing, however, it’s possible
    to work around that limitation. You can essentially implement an exported Objective-C
    block that accepts a class name and then creates and returns an instance of an
    arbitrary class to JavaScript, as I’ve done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This technique bypasses the need to explicitly export any classes and allows
    you to instantiate an object of any type and expose it to JavaScript-Core. However,
    no members have been whitelisted to be exported, so there are no strong references
    to any methods or variables of the class object. Clearly, there’s plenty of room
    for more security research into bypassing the restrictions implemented by JavaScriptCore
    because the Objective-C runtime is such a dynamic and powerful beast.
  prefs: []
  type: TYPE_NORMAL
- en: One common complaint about the JavaScriptCore framework is that there is no
    documented way to access the `JSContext` of a `UIWebView`. I’ll discuss some potential
    ways around this next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Manipulating JavaScript in Web Views**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Why expose this `JSContext` functionality without a way to access it within
    a web view? It’s not clear what Apple’s intentions were, but the developers did
    only half the job of documenting the JavaScriptCore APIs. As of yet, there’s no
    official Apple way to manipulate a `UIWebView`’s `JSContext`, but several people
    have discovered methods to do so. Most of them involve using the `valueForKeyPath`
    method, as in [Listing 9-7](ch09.html#ch9ex7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-7: Manipulating a DOM via Objective-C*'
  prefs: []
  type: TYPE_NORMAL
- en: Since this isn’t an officially Apple-sanctioned approach, there’s no guarantee
    that this kind of code will make it into the App Store, but it’s worth being aware
    of the ways developers may try to communicate between JavaScript and Objective-C
    and the pitfalls it poses.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the `JSContext` isn’t the only way to connect JavaScript to Objective-C.
    I describe Cordova, another popular bridge, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Executing JavaScript with Cordova***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Cordova (known as PhoneGap before Adobe acquired the development firm Nitobi)
    is an SDK that provides native mobile APIs to a web view’s JavaScript execution
    environment in a platform-agnostic manner. This allows mobile applications to
    be developed like standard web applications using HTML, CSS, and JavaScript. Those
    applications then work across all platforms Cordova supports. This can significantly
    reduce lead time and do away with the need for development firms to hire platform-specific
    engineers, but Cordova’s implementation increases the application attack surface
    significantly.
  prefs: []
  type: TYPE_NORMAL
- en: '**How Cordova Works**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Cordova bridges JavaScript and Objective-C by implementing an `NSURLProtocol`
    to handle any JavaScript-initiated `XmlHttpRequest` to *file://!gap_exec*. If
    the native Cordova library detects a call to this URI, it attempts to pull class,
    method, argument, and callback information out of the request headers, as evidenced
    in [Listing 9-8](ch09.html#ch9ex8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-8: Detecting native library calls in* CDVURLProtocol.m^([3](footnote.html#fn79))'
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, the request URL is checked for a path component of */!gap_exec*, and at
    ➋, the value of the `cmds` HTTP header is extracted. Cordova then passes these
    commands to the command queue ➌, where they will be executed if possible. When
    these commands are queued, Cordova looks up the information in a map of available
    Cordova plug-ins, which essentially just expose various portions of the native
    functionality and can be extended arbitrarily. If a particular plug-in is enabled
    and the class in the request can be instantiated, then the method is called with
    the supplied arguments using the all-powerful `objc_msgSend`.
  prefs: []
  type: TYPE_NORMAL
- en: When the call completes, the native code calls back to the JavaScript runtime
    via `[UIWebView stringByEvaluatingJavaScriptFromString]`, calling the `cordova.require('cordova/exec').nativeCallback`
    method defined in *cordova.js*, and provides the original callback ID as well
    as the return value of the native code execution.
  prefs: []
  type: TYPE_NORMAL
- en: This exports an unprecedented amount of native object control to the JavaScript
    runtime, allowing applications to read and write files, read and write Keychain
    storage, upload local files to a remote server via FTP, and so on. But with this
    increased functionality comes potential pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: '**Risks of Using Cordova**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If your app contains any script injection vulnerabilities and if your users
    can influence application navigation, an attacker could obtain remote code execution.
    They would just have to inject callback functions combined with a call to initiate
    communication with native code. For instance, an attacker might inject a call
    to access Keychain items, grab a copy of all the user’s contacts, or read out
    a file and feed it into a JavaScript function of their choosing, as demonstrated
    in [Listing 9-9](ch09.html#ch9ex9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-9: Using Cordova to make Objective-C calls to read the contents
    of a file*'
  prefs: []
  type: TYPE_NORMAL
- en: This attacker-supplied JavaScript reads the device’s *com.apple.MobileSMS.plist*,
    which, in iOS 8, is accessible to all applications on the device.^([4](footnote.html#fn80))
    This gives the attacker the ability to examine the user’s contacts, as well as
    determine the owner of the device in question.
  prefs: []
  type: TYPE_NORMAL
- en: One reasonable bit of built-in security that can significantly reduce the risks
    of script injection is *domain whitelisting*.^([5](footnote.html#fn81)) Cordova’s
    default security policy blocks all network access and allows interaction only
    with domains that are whitelisted under the `<access>` element in the app configuration.
    The whitelist does allow access to all domains via a wildcard ([*]) entry, but
    don’t be lazy—ensure that only the domains your app needs to talk to in order
    to function properly are in the whitelist. You can configure this through Xcode
    by adding values to the `ExternalHosts` key in `Cordova.plist`, as shown in [Figure
    9-1](ch09.html#ch9fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f09-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: Whitelisting domains in Cordova using the* `ExternalHosts` *key*'
  prefs: []
  type: TYPE_NORMAL
- en: Besides exposing native code objects to the web view, there are many other drawbacks
    to implementing mobile applications using a web platform wrapper such as Cordova.
    Mainly, each mobile platform has its own security model predicated on specific
    assumptions, APIs, and functionality to protect users and secure local storage.
    One platform’s security model just won’t make sense on other platforms. Providing
    a one-size-fits-all implementation is, necessarily, going to exclude some of these
    platform-specific security benefits for the sake of usability.
  prefs: []
  type: TYPE_NORMAL
- en: For example, iOS provides secure storage through the Data Protection APIs (as
    I describe in [Chapter 13](ch13.html#ch13)), which require specific arguments
    that don’t lend themselves to a cross-platform implementation. As such, these
    APIs are not supported by Cordova, preventing fine-grained control over when file
    data is encrypted at rest. To solve this problem, you can enable entitlement-level
    data protection (refer to “[The DataProtectionClass Entitlement](ch13.html#ch13lev2sec08)”
    on [page 223](ch13.html#page_223)), which will apply a default protection level
    ubiquitously for all data written to disk by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Another common issue is the lack of a similar secure storage element across
    platforms. This removes direct Keychain access on iOS, although Adobe ultimately
    developed an open source plug-in^([6](footnote.html#fn82)) to address the problem.
  prefs: []
  type: TYPE_NORMAL
- en: That ends the tour of `UIWebView` and JavaScript bridges, but new applications
    (for iOS 8 and newer) will increasingly be using the `WKWebView` API. I’ll cover
    how to wrangle `WKWebView` in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter WKWebView**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned previously, a newer interface to WebKit was introduced with iOS
    8 to supplant `UIWebView`. `WKWebView` addresses several of the shortcomings of
    `UIWebView`, including access to the Nitro JavaScript engine, which greatly increases
    performance on JavaScript-heavy tasks. Let’s look at how apps would create `WKWebView`s
    and how `WKWebView`s can improve your app’s security.
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with WKWebViews***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `WKWebView` is instantiated in essentially the same way as a `UIWebView`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This just allocates a new `WKWebView` instance and then initializes it with
    the `initWithFrame` method.
  prefs: []
  type: TYPE_NORMAL
- en: To customize behavior, `WKWebView`s can also be instantiated with user-supplied
    JavaScript, as in [Listing 9-10](ch09.html#ch9ex10). This allows you to load a
    third-party website but with your own custom JavaScript that executes upon page
    load.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-10: Instantiating a* `WKWebView` *with custom JavaScript*'
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, a simple `NSString` that consists of a single JavaScript command is created.
    At ➋, a configuration object is created that will hold the configuration parameters
    for the web view that will be created later. At ➌, a `WKUserScript` object is
    created and initialized with the `src` that contains the JavaScript you want to
    execute. Then a `WKUserContentController` is made at ➍, which is set in the configuration
    object at ➎. Finally, the script is added to the controller with the `addUserScript`
    method at ➏, and the web view is instantiated at ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As with other methods of injecting JavaScript, be careful not to interpolate
    content provided by third parties without strict sanitization.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Security Benefits of WKWebViews***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using `WKWebView`s has a couple security advantages. First, you can set preferences
    that disable loading JavaScript with the method `setJavaScriptEnabled` if the
    pages you plan to load don’t require it; if the remote site has malicious script,
    this will prevent that script from executing. You can also leave JavaScript enabled
    but disable the opening of new windows from JavaScript using the `setJavaScriptCanOpenWindowsAutomatically`
    method—this will prevent most pop-ups from opening, which can be quite irritating
    in web views.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, and perhaps most importantly, you can actually detect whether the contents
    of the web view were loaded over HTTPS, giving you the ability to ensure that
    no parts of the page were loaded over insecure channels. For `UIWebView`s, there
    is no indication to the user or developer when the web view loads mixed content—the
    `hasOnlySecureContent` method of `WKWebView` resolves this problem. [Listing 9-11](ch09.html#ch9ex11)
    shows a way to implement a somewhat hardened `WKWebView`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-11: A nice, safe* `WKWebView`'
  prefs: []
  type: TYPE_NORMAL
- en: This code uses a couple of extra security mechanisms that `WKWebView` provides.
    At ➊, a `WKPreferences` instance is instantiated, and the `setJavaScriptEnabled`
    and `setJavaScriptCanOpenWindowsAutomatically` properties are set on it. (These
    are redundant, of course, but you can pick whichever property best suits your
    needs.) Then, a `WKWebViewConfiguration` object is instantiated at ➋ and the `WKPreferences`
    already created are passed in. At ➌, a URL to load is defined; in this case, it’s
    simply an example page that includes mixed content. At ➍, the `WKWebView` itself
    is made, using the configuration created previously. The code then requests that
    the web view load a given URL at ➎. Finally, the `didFinishNavigation` delegate
    is implemented at ➏, which in turn calls `hasOnlySecureContent` on the web view.
    If the content is mixed, the user is alerted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While modern versions of iOS have made great strides in allowing developers
    control over the interactions between native code and web content, there is a
    legacy of hacks to bridge the two, with their own idiosyncrasies. At this point,
    you should be aware of the main bridging mechanisms, as well as where to look
    for potentially malicious externally supplied data.
  prefs: []
  type: TYPE_NORMAL
- en: I also briefly covered some of the caching that takes place when working with
    web content. In [Chapter 10](ch10.html#ch10), you’ll dig in to the many ways that
    data can leak to the local filesystem and be recovered by attackers.
  prefs: []
  type: TYPE_NORMAL
