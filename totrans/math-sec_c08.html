<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 8: Tracking People in Physical Space with Digital Information</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:1ff3c234-c763-4a12-a0c7-4ddf7c732e40" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_141" title="141"/>8</span><br/>
<span class="ChapterTitle">Tracking People in Physical Space with Digital Information</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">Let’s continue our discussion of computational geometry with a somewhat controversial topic: tracking people in physical space using digital information. It’s no secret that law enforcement agencies across the globe rely heavily on cell phone tracking to locate and apprehend suspects. You might think this requires them to get a warrant and then subpoena the GPS records from a wireless provider, but this isn’t always the case, nor is it strictly necessary. Using publicly available information and basic geometry, you can (somewhat) accurately place a phone in a given area, even if it doesn’t have GPS. As long as it’s connected to a cellular or wireless network, you have a good shot at locating it. </p>
<p>The triangulation process relies on knowing a few things: first, the location—that is, physical latitude and longitude—and configuration for a large number of wireless network hubs, like cell phone towers; second, the approximate broadcast range of these devices; and finally, the signal strength at the cell phone for a set of networks the device can communicate <span epub:type="pagebreak" id="Page_142" title="142"/>with. This may seem like a tall order, but the first two have already been handled for us by the nice folks at Unwired Labs with their service OpenCellID. The third topic we’ll discuss in the next section.</p>
<p>Once you have a basic understanding of the data, we’ll cover some of the ethical implications surrounding this project. After that, we’ll look at the OpenCellID API in more detail and discuss how to find the location of individual towers and use the API’s Geolocation solver to get an address and an accuracy estimate.</p>
<h2 id="h1-502567c08-0001">Gathering Cellular Network Data</h2>
<p class="BodyFirst">There are several options for getting network information from a phone, ranging from sophisticated hardware attacks to very simple ones that use built-in utilities. Hardware attacks are beyond the scope of this book, but check out the books <em>Android Security Internals</em><sup class="endnote"><a href="b01.xhtml#c08-endnote-001" id="c08-noteref-001">1</a></sup> and <em>The Android Hacker’s Handbook</em><sup class="endnote"><a href="b01.xhtml#c08-endnote-002" id="c08-noteref-002">2</a></sup> for an introduction to this topic for Android phones, as well as <em>iOS Hacker’s Handbook</em><sup class="endnote"><a href="b01.xhtml#c08-endnote-003" id="c08-noteref-003">3</a></sup> for Apple devices. </p>
<p>The network interface data we need seems so simple and innocuous that it’s often made available to almost every application running on a cell phone, tablet, laptop, or other wireless-enabled devices. If you’re like me, you’re probably very picky about which applications can access your location data directly, but just about every app has a built-in reason to require network access: updates. Unfortunately, this means these applications can see which networks are visible and how strong their signal is. Thanks to the OpenCellID API, this information is almost as good as having a GPS signal, so if you had an exploit for any one of these apps, you could potentially use that to retrieve the information.</p>
<p>As an experiment, you can try to manually scan the cellular networks in your area. Most phones have an option to manually select the cell network you want to connect with. To find it, search your phone’s make and model along with “manual cell network selection.” There’s also a plethora of apps available to perform this task, although I prefer to use the phone’s built-in capabilities before downloading any. Suffice to say, from this point forward I’ll assume you have access to the device’s network data through some legal means. I’ve also provided the sample data I used when developing the examples so that you can follow along without access to any device.</p>
<p>We’ll be working with the OpenCellID API throughout this project, so let’s take a moment to discuss what it is and why we’ll be using it. The OpenCellID API is an online service that stores information about cellular network base stations, such as location and network type. <em>Base stations</em> are what people usually mean when they refer to a cell network’s towers. Technically, the part of the tower we’re used to seeing just holds the physical antennas; the real brains of the operation are housed near the base of the antennas. These boxes contains the hardware and application logic necessary to route traffic from devices onto the cell provider’s network infrastructure and its final destination. For the rest of the chapter, I’ll use the terms <em>base station</em> and <em>tower</em> interchangeably. </p>
<p><span epub:type="pagebreak" id="Page_143" title="143"/>After creating a free account and getting an API access token, you’ll have access to the data through an online REST API. Having publicly accessible data about cell networks is useful in a number of security applications, aside from tracking physical locations. If you’re traveling within any metropolitan area, your phone is being bounced from tower to tower. This usually happens seamlessly in the background and can occur for a couple of different reasons. Cell networks are constantly balancing traffic by asking devices to connect to other towers. When a base station detects that it’s becoming bogged down with traffic, it may tell new devices to find a different tower to handle their traffic. Your phone is also programmed to try to connect to the base station with the strongest signal first and then try others in descending order as necessary. Having your device bouncing across all these towers creates the potential for an adversary to introduce a rogue base station (one they control the application logic for) with a strong enough signal to trick nearby devices into connecting to it. As your phone is bouncing around, having access to a publicly curated list of known cell towers can help to ensure your device connects only to legitimate cell networks. The online portal for OpenCellID (<a class="LinkURL" href="https://opencellid.org">https://opencellid.org</a>) can also be used to explore the data available in a geographic region. </p>
<p><a href="#figure8-1" id="figureanchor8-1">Figure 8-1</a> shows the OpenCellID map for the Pike Place Market area of Seattle, retrieved from its online portal.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502567c08/f08001.png"/>
<figcaption><p><a id="figure8-1">Figure 8-1</a>: Network data for the Pike Place Market area</p></figcaption>
</figure>
<p>This image was captured from the OpenCellID main site. The gray circles are clusters of radios that OpenCellID has information for. The number in the center of the circle shows how may radios are in that cluster. You can also see a few pins with letter labels. These are single network instances where the letter denotes the type of radio that’s being used to communicate. The key in the lower right of the map shows the four major network types available: GSM, CDMA, UMTS, and LTE. The Jupyter notebook that accompanies this section has more details on each type of network. </p>
<p>These four network types make up the core radio towers we’ll use to locate equipment based on their proximity to a set of fixed radio locations. There is another network type that isn’t shown on the map, Wi-Fi routers, which you can also use to get more precise results in some cases. The problem is, when compared to cellular network towers, Wi-Fi routers are <span epub:type="pagebreak" id="Page_144" title="144"/>ephemeral. They may be turned off, or worse (for our purpose), relocated without the OpenCellID database being updated, which would throw our analysis into a tailspin. We’ll stick to cellular towers in the example data, but you should definitely explore the Wi-Fi option on your own. There are online services such as WiGLE (<a class="LinkURL" href="https://www.wigle.net">https://www.wigle.net</a>) that are similar to OpenCellID but for Wi-Fi networks.</p>
<p>Each tower is uniquely identified by a country code and network ID. The data contains estimates on the effective range for the type of network, such as 1 kilometer for most CDMA antennas; it also contains the approximate latitude and longitude of the antenna, other bits to track when it was last verified, and more. By taking several visible network towers and seeing where they overlap service, we should be able to determine the small portion of earth where the device could be located. To do so, we’ll create polygons representing the service areas for each base station based on the network type. We’ll then overlay the polygons in relation to one another and find the area that all the networks have in common using the Shapely library’s <code>intersection</code> and <code>difference</code> functions. </p>
<p>Before we dive into the nuts and bolts of the data, there are some privacy concerns we should consider. The decisions we make as security researchers can negatively impact the privacy and security of large portions of society in unintended ways. In the next section, we’ll cover some considerations to keep in mind before you undertake any project related to device tracking. </p>
<h2 id="h1-502567c08-0002">Ethics of Tracking Devices and People</h2>
<p class="BodyFirst">In some ways, criminals have it easy. A criminal doesn’t have to consider the ethical or moral implications of their actions. Whether they’re exposing their target to additional risk is usually not high on their list of concerns. White hats, on the other hand, have ethical, and oftentimes legal, barriers to consider when obtaining or using location information. In the past, I’ve received records similar to the data for this project from company-owned devices via remote administration tools after an employee’s laptop or cell phone went missing. However, even this seemingly benevolent use is an ethical gray area. Here in the US there isn’t a clear line on an employee’s right to privacy.<sup class="endnote"><a href="b01.xhtml#c08-endnote-004" id="c08-noteref-004">4</a></sup> It’s easy to say, “If a company owns a system they have the right to track and monitor it,” but what about people who carry their work systems with them during off-hours (something I regularly do myself)? Several companies even require their managers to keep work phones on them during their downtime—even on vacation. There’s nothing technical to block these companies from tracking their employees during their private time, and the laws are murky and vague, so it becomes purely a question of ethics. When dealing with corporate entities, being forced to trust their ethical behavior scares a lot of people! </p>
<p>Understanding how this technology works, and how to apply it ethically to improve security without hurting privacy, falls to us as researchers and analysts. After reading this chapter, take some time to look up the relevant laws for your area and, perhaps even more importantly, think about what you believe are appropriate and inappropriate uses for this technology.<sup class="endnote"><a href="b01.xhtml#c08-endnote-005" id="c08-noteref-005">5</a></sup></p>
<p><span epub:type="pagebreak" id="Page_145" title="145"/>For our project, I collected the data on myself using an Android tablet. As the data subject, I was aware of the data collection and gave myself, as the author, permission to use the data in the limited scope of writing this material. The key point here is that the data subject (me) was informed and gave consent. Getting informed consent to perform your analysis can prevent a lot of ethical risk before you even begin. If you apply this type of tracking technology outside the scope of informed consent (such as law enforcement or military applications), you must decide for yourself what ethical doctrine applies.</p>
<p>Now that we’ve discussed the ethics of device tracking in general, and more specifically concerning the various potential applications of our project, we can get into the meat of the problem. In the next section we’ll take a deeper dive into the OpenCellID API, covering the basics of calling the API, the structure of the data returned, and how we can process this information into relevant shape objects.</p>
<h2 id="h1-502567c08-0003">The OpenCellID API Structure</h2>
<p class="BodyFirst">Technically speaking, OpenCellID is a RESTful API that uses client secret keys to identify users. To access the OpenCellID data, you’ll need to sign up for one of these API keys. It’s free and easy: you simply provide an email and a use case (like “Research”), and you’ll get back an alphanumeric key. Your account comes with a limit of 5,000 requests a day, but this should be more than enough for most applications. If you’re smart about caching responses, you should be able to spread those out even more. </p>
<p>There are two common workflows supported by the API. <em>Geolocation</em> is the process of turning latitude and longitude information into a location on earth, like “123 Main Street, Seattle, WA.” Geolocation comes up a lot both inside and outside of security, so it’s a good idea to become familiar with the process. <em>Geocoding</em> works in the opposite direction: you take an address and return the latitude and longitude of that point. We’ll mostly be working with the Geolocation portion of the API, but it’s worth noting OpenCellID also has API calls to help with map displays and calls for monitoring your usage. As you develop your own application, you’ll want to take advantage of those additional features.</p>
<p><a href="#listing8-1" id="listinganchor8-1">Listing 8-1</a> shows the structure of a simple request to the API.</p>
<pre><code>payload = {
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> "token": "alphanumeric_code",
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> "radio": "cdma",
    "mnc": 120,
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> "mcc": 310,
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> "cells": [{
      <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> "lac": 23319,
        "cid": 192337670
    }],
  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> "address": 1
}</code></pre>
<p class="CodeListingCaption"><a id="listing8-1">Listing 8-1</a>: The structure of the API payload</p>
<p><span epub:type="pagebreak" id="Page_146" title="146"/>Every request needs to contain the alphanumeric <code>token</code> that you received when you signed up <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The <code>radio</code> field <span aria-label="annotation2" class="CodeAnnotation">❷</span> identifies the primary network type of the device we’re looking into. Setting this field doesn’t restrict the types of radios that you can pass in the <code>cells</code> field <span aria-label="annotation4" class="CodeAnnotation">❹</span>, however, which represents the base stations that are visible to the device. We’ll revisit the <code>cells</code> field more in a moment, but first, let’s discuss how networks are identified and grouped. </p>
<p>Each country is assigned a three-digit <em>mobile country code (MCC)</em>. Most countries actually have several MCCs assigned to break up the geography into smaller chunks that make it easier to manage the traffic for any one region. To uniquely identify a mobile subscriber’s network, the MCC is combined with a <em>mobile network code (MNC)</em> into the <em>home network identity (HNI)</em>, which concatenates both pieces of information into one string. </p>
<p>In <a href="#listing8-1">Listing 8-1</a>, the device has an MCC of 310 <span aria-label="annotation3" class="CodeAnnotation">❸</span> (which is the first of seven MCCs assigned to North America, numbered 310–316) and an MNC of 120, so the HNI is 310120. Using the HNI, OpenCellID can determine what service provider and network segment a device belongs to when it sends a query to the API. You can pull this information off the device you’re testing or pass some default network MCC and MNC, which is what we do in the code for this project. If you look up the HNI from <a href="#listing8-1">Listing 8-1</a>, you’ll see it belongs to the Sprint Spectrum network (<a class="LinkURL" href="https://imsiadmin.com/assignments/hni">https://imsiadmin.com/assignments/hni</a>) in North America.</p>
<p> Now, returning to the <code>cells</code> field, we see a list of nested JSON objects. We can send between one and seven radio identifiers to OpenCellID to help pinpoint location more accurately. You can even contact Unwired’s development team to increase that number if you need to (but that’s unlikely).</p>
<p>The next section of the data contains the radios we’d like to retrieve information about. The radio objects we send can be any mix of supported radio types. We identify each radio using two numbers based on its physical locations. Cell networks are divided into several geographic areas, each of which can support between 1 and 65,534 base stations. Each geographic area is assigned a unique <em>location area code (LAC)</em>. Similar to the area code prefix on a telephone number, a LAC describes roughly where the base station is located. The second number is the<em> cell ID (CID)</em>, which identifies each individual base station within a LAC <span aria-label="annotation5" class="CodeAnnotation">❺</span>. You can think of the LAC and the CID like a zip code and a street address, respectively. They work together to create a unique identifier for every base station on a network. Finally, the <code>address</code> field <span aria-label="annotation6" class="CodeAnnotation">❻</span> tells the API to return the human-readable address along with the other result fields. If you don’t need the address, you can save some bytes by excluding this field.</p>
<p><a href="#listing8-2" id="listinganchor8-2">Listing 8-2</a> defines a Python function called <code>lookup_tower</code> to send the single radio payload from <a href="#listing8-1">Listing 8-1</a> to the API.</p>
<pre><code>def lookup_tower(payload):
    url = "https://us1.unwiredlabs.com/v2/process.php"
    response = requests.request("POST", url, data=json.dumps(payload))
        return json.loads(response.text)</code></pre>
<p class="CodeListingCaption"><a id="listing8-2">Listing 8-2</a>: A function to call the API and decode the response</p>
<p><span epub:type="pagebreak" id="Page_147" title="147"/>Before running anything, let’s begin by verifying that the URL presented here (<code>https://us1.unwiredlabs.com/v2/process.php</code>) is still the most up to date and appropriate for our use case. Unwired hosts several API endpoints around the world, so there may be another that is closer to you or one with less traffic (which helps reduce latency). You can do this by going to the Unwired Labs API list at <a class="LinkURL" href="https://unwiredlabs.com/api">https://unwiredlabs.com/api</a> and selecting Endpoints from the options on the left. You can then copy the URL for the API endpoint that is geographically closest to you.</p>
<p>We must convert the JSON payload into a string object before passing it to the request library. To do so, we call the <code>json.dumps</code> (short for <em>dump string</em>) function on our JSON payload. We pass the function to the request library through the <code>data</code> parameter. The <code>response</code> object we get back will be a JSON object transmitted as text unless there’s an error, in which case we’ll get a nasty blob of HTML and the function will choke when trying to decode the <code>response.text</code> property. To avoid this, we’d expand our production code to wrap the call to <code>requests.request</code> in a <code>try...catch</code> block or other safety net. </p>
<p><a href="#listing8-3" id="listinganchor8-3">Listing 8-3</a> shows the format of the response.</p>
<pre><code>{
    "status":string,
    "balance":int,
    "lat":float,
    "lon":float,
    "accuracy":int,
    "address":string
}</code></pre>
<p class="CodeListingCaption"><a id="listing8-3">Listing 8-3</a>: A single-tower JSON query response </p>
<p>The status string will be <code>"ok"</code> in cases where the request succeeded and <code>"error"</code> if the API detected a problem. The <code>balance</code> field holds the number of requests remaining for the day. We can take the <code>lat</code> (latitude), <code>lon</code> (longitude), and <code>accuracy</code> fields to plot the tower on a map. Finally, if we pass the <code>address=1</code> parameter, the <code>address</code> field holds this information as a string. <a href="#figure8-2" id="figureanchor8-2">Figure 8-2</a> shows the result of <a href="#listing8-3">Listing 8-3</a> plotted on a map.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502567c08/f08002.png"/>
<figcaption><p><a id="figure8-2">Figure 8-2</a>: Displaying a tower range</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_148" title="148"/><h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate the map overlay in <a href="#figure8-2">Figure 8-2</a> is in the 4th cell of the <em>OpenCell_API_Examples.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The map area shows the city of Seattle, where the tower is located. The dark gray circle in the middle of the image shows the approximate area covered by the tower, and the pin in the center of the gray circle represents the exact latitude and longitude of the tower. Each of the white lines crisscrossing the image represents a city street. You can see the maximum coverage area of one tower is pretty large—several city blocks at least. If we had only this one tower to try to locate the device, we’d have a lot of ground to cover! In the next section we’ll see how to narrow the area further by geolocating several towers and finding their overlapping service region using the GeoPandas and Shapely libraries.</p>
<h2 class="HeadProject" id="h1-502567c08-0004"><span>The Proof of Concept: Locating a Device from Nearby Cell Towers</span></h2>
<p class="BodyFirst">We’ve seen how we can interact with the OpenCellID API to get back information on towers in our data. Now it’s time to put this knowledge together into an application that will locate a device based on the cell towers within its range. We’ll extend the <code>lookup_tower</code> function from <a href="#listing8-2">Listing 8-2</a> to locate each tower in the list recovered from the test device. The data we’ll be using to test our application can be found in the file <em>cellular_networks.json </em>in the chapter’s supplemental materials. </p>
<p><a href="#figure8-3" id="figureanchor8-3">Figure 8-3</a> shows the four towers from the sample data laid out over a map. </p>
<figure>
<img alt="" class="keyline" src="image_fi/502567c08/f08003.png"/>
<figcaption><p><a id="figure8-3">Figure 8-3</a>: Tower signal overlap</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_149" title="149"/><h2><span class="NoteHead">Note</span></h2>
<p>	You’ll find code to generate an image similar to <a href="#figure8-3">Figure 8-3</a> in the 4th cell of the <em>OpenCell_API_Examples.ipynb</em> notebook, but there’s a problem with it: the coverage area doesn’t scale with the zoom level. <a href="#figure8-3">Figure 8-3</a> was actually generated using the MapBox JavaScript API and a CherryPy web server. The code for that server is in the <em>locator_server.py</em> file in the chapter’s supplemental materials. After starting the server with the Python interpreter, like so </p>
<pre><code>$ <code class="bold">python locator_server.py</code></code></pre>
<p>you should be able to navigate to <em>http://127.0.0.1:8080/towers</em> and see the map as it’s presented here. If you get an error like <code>"Import Error: Module Not Found: locate"</code> you’ll need to add the directory with the server scripts to your <code>PYTHONPATH</code> environment variable. There are many good online tutorials on how to accomplish this for each operating system. </p>

<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Your eye can easily locate the area where all the signals overlap, but it isn’t quite as easy for a computer to determine. Therefore, our goal is to programmatically identify that portion of the map where all four towers overlap using Shapely to produce a bounded search area. We’ll then compare our results with the location guess returned from OpenCellID API to see which is more accurate.</p>
<h3 id="h2-502567c08-0001">Gathering Tower Locations</h3>
<p class="BodyFirst">Our first step, shown in <a href="#listing8-4" id="listinganchor8-4">Listing 8-4</a>, is to gather the location information from each of the four towers using the <code>lookup_tower</code> function from <a href="#listing8-2">Listing 8-2</a>.</p>
<pre><code>with open("cellular_networks.json") as f:
    cells = json.load(f)["cells"]
tower_locs = []
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> for c in cells:
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> payload["cells"] = c
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> tower_loc = lookup_tower(payload)
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> tower_locs.append(tower_loc)</code></pre>
<p class="CodeListingCaption"><a id="listing8-4">Listing 8-4</a>: Gathering tower geolocation information</p>
<p>After loading in the data, we create a <code>for</code> loop to loop over each cell <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We need to send in each tower by itself to get back its geolocation information; otherwise, we’ll get back a location guess using the towers you sent to the API as the reference information. We’ll replace the cells in the payload from <a href="#listing8-1">Listing 8-1</a> with the tower info loaded in from the <em>networks.json</em> file <span aria-label="annotation2" class="CodeAnnotation">❷</span>. In a production application, this would be the portion of information you recover from the device you want to track. Next, we call the <code>lookup_tower</code> function <span aria-label="annotation3" class="CodeAnnotation">❸</span> and store the result into a list called <code>tower_locs</code> <span aria-label="annotation4" class="CodeAnnotation">❹</span>. </p>
<p>Now we have a list containing JSON objects, which in turn contain geolocation information in the form of latitude and longitude coordinates for <span epub:type="pagebreak" id="Page_150" title="150"/>each tower. This is very close to a standard object format called GeoJSON, which many programs of different languages know how to interpret. To make our data more flexible and standardized, let’s finish converting the data to GeoJSON format. We can do this simply enough using the pandas data science library and its sister, GeoPandas, which adds support for geometric coordinates and operations. <a href="#listing8-5" id="listinganchor8-5">Listing 8-5</a> shows how to convert the JSON data the rest of the way to the GeoJSON format.</p>
<pre><code>import pandas as pd
import geopandas as gpd

tower_df = pd.DataFrame(tower_locs)
tower_df.drop(["status", "balance"], axis=1, inplace=True)
geo_df = gpd.GeoDataFrame(
    tower_df,
    geometry=gpd.points_from_xy(tower_df.lat, tower_df.lon)
)</code></pre>
<p class="CodeListingCaption"><a id="listing8-5">Listing 8-5</a>: Creating a <code>GeoDataFrame</code> from tower locations</p>
<p>First, we cast the list of JSON objects to a traditional pandas <code>DataFrame</code>, which gives us a chance to clean up any unnecessary fields in the next line. We’re dropping the <code>status</code> and <code>balance</code> fields since they don’t add any information to the analysis. Next, we use the GeoPandas <code>GeoDataFrame</code> class to cast <code>tower_df</code> into the more appropriate geolocation data, which contains a special field, aptly named <code>geometry</code>, to hold the geometric representation of each row in the <code>DataFrame</code>. In this case, we use the <code>lat</code> and <code>lon</code> columns from <code>tower_df</code> to define <code>Point</code> objects, which then get stored in the <code>geometry</code> column. The GeoPandas function <code>points_from_xy</code> takes in an x- and y-coordinate and returns a <code>Point</code> object that GeoPandas can use to associate a shape object with the data. You can see the structure of the <code>geo_df</code> data in the output of the 2nd cell in the <em>OpenCell_API_Examples.ipynb</em> notebook.</p>
<h3 id="h2-502567c08-0002">Translating a Geographic Point to a Polygon</h3>
<p class="BodyFirst">We’ll be converting these <code>Point</code> objects to polygons representing circles, but Shapely isn’t aware of specific coordinate systems or units, so first we need to convert the latitude and longitude into native (<em>x</em>, <em>y</em>) coordinates and back again. This requires a rather tricky bit of code that can store intermediate results and keep track of units. It relies on the pyproj (short for Python Projection) and functools libraries to do so. The functools library is for <em>higher-order functions</em>, functions that act on or return other functions. Examples include functions that modify the call structure or translate inefficient call flows into more modern and efficient ones<em>. </em>Consider the following example:</p>
<pre><code># A normal function
def complex(a, b, c, d, x):
    print(f"you sent in {a},{b},{c},{d},{x}")</code></pre>
<p>The <code>complex</code> function takes in five required parameters and prints them all out using a format string. But what if we know that in our use case we’ll <span epub:type="pagebreak" id="Page_151" title="151"/>always call <code>complex</code> with the same first four parameters and <code>x</code> is the only parameter we’ll ever need to change? In these situations we can use partial function copies to simplify the calling conventions. <em>Partial functions</em> allow us to fix a certain number of arguments for a function and generate a new function that we can call without including those fixed arguments. Here, <code>functools.partial</code> allows us to create a new simplified version of the <code>complex</code> function like so:</p>
<pre><code>import functools
# A partial function that simplifies the previous one
simple = functools.partial(complex, 1, 1, 2, 3)
simple(5)</code></pre>
<p> The <code>simple</code> function now contains a copy of the <code>complex</code> function, with the first four parameters statically defined to be the values <code>1</code>, <code>1</code>, <code>2</code>, and <code>3</code>, respectively. Now calling <code>simple</code> with any value will result in that value being passed to the <code>complex</code> function in the <code>x</code> parameter. Calling the <code>simple</code> function with the value <code>5</code> is now equivalent to calling the <code>complex</code> function with the values <code>1</code>, <code>1</code>, <code>2</code>, <code>3</code>, and <code>5</code>, as we can see from the code’s output:</p>
<pre><code>you sent in 1,1,2,3,5</code></pre>
<p> We’ll use the <code>functools.partial</code> function to programmatically create two new functions to handle the coordinate translations. To do so, we’ll be using the pyproj library, which is designed to translate between different coordinate systems internally. The <code>Proj</code> class can convert from geographic (lat, lon) to native map projection (<em>x</em>, <em>y</em>) coordinates and vice versa, which is perfect for our needs. <a href="#listing8-6" id="listinganchor8-6">Listing 8-6</a> shows the function I found and modified from a related GIS Stack Exchange post.<sup class="endnote"><a href="b01.xhtml#c08-endnote-006" id="c08-noteref-006">6</a></sup></p>
<pre><code>import pyproj
from functools import partial
from shapely.geometry import Point 
from shapely.ops import transform

def get_shapely_circle(x):
    lat = x["lat"]
    lon = x["lon"]
    radius = x["accuracy"]
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> az_proj = "+proj=aeqd +R=6371000 +units=m +lat_0={} +lon_0={}"
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> wgs84_to_aeqd = partial(
        pyproj.transform,
        pyproj.Proj("+proj=longlat +datum=WGS84 +no_defs"),
        pyproj.Proj(az_proj.format(lat, lon))
    )
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> aeqd_to_wgs84 = partial(
        pyproj.transform,
        pyproj.Proj(az_proj),
        pyproj.Proj("+proj=longlat +datum=WGS84 +no_defs"),
    )
<code>  </code><span aria-label="annotation4" class="CodeAnnotationCode">❹</span><code> </code>center = Point(float(lon), float(lat))
<code>  </code><span aria-label="annotation5" class="CodeAnnotationCode">❺</span><code> </code>point_t = transform(wgs84_to_aeqd, center)
<span epub:type="pagebreak" id="Page_152" title="152"/>  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> buffer = point_t.buffer(radius)
    # Get the polygon with lat lon coordinates.
  <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> circle_poly = transform(aeqd_to_wgs84, buffer)
    return circle_poly

<span aria-label="annotation8" class="CodeAnnotationHang">❽</span> geo_df["geometry"] = geo_df.apply(get_shapely_circle, axis=1)</code></pre>
<p class="CodeListingCaption"><a id="listing8-6">Listing 8-6</a>: Translating a geographic point to a geographic polygon</p>
<p>We define the <code>az_proj</code> (short for <em>azimuth projection</em>) string to contain all the variables that will be passed in to the projection code <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The most important are <code>+proj</code>, which tells the library to convert the coordinates using a method known as <em>azimuthal equidistance (AEQD)</em>; <code>+R</code>, which holds the radius (in meters) of earth; and <code>+units</code>, which tells the code that this number is in meters, but more generally tells the library what units to convert to. The only two variables we need to be able to change on each call are <code>lat_0</code> and <code>lon_0</code>, which define the (0, 0) point in the coordinate field. Currently our data is in <em>world geodesic system (WGS)</em> coordinates. WGS 84 is the standard US Department of Defense definition of a global reference system for geospatial information and is the reference system for GPS (the Global Positioning System). It is compatible with the International Terrestrial Reference System (ITRS) if that’s more your cup of tea.<sup class="endnote"><a href="b01.xhtml#c08-endnote-007" id="c08-noteref-007">7</a></sup> </p>
<p> In the <code>wgs84_to_aeqd</code> and <code>aeqd_to_wgs84</code> functions, we create a partial copy of the <code>pyproj.transform</code> function <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The <code>functools.partial</code> function freezes the first two parameters of the <code>pyproj.transform</code> function. Notice in the <code>aeqd_to_wgs84</code> function the two calls to the <code>Proj</code> class are reversed. That’s because the first two parameters to the <code>pyproj.transform</code> function define the current and desired representation, respectively. Reversing these two inputs reverses the translation direction, in this case from native coordinates back into geographic coordinates <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Since we’re creating simplified versions of the <code>transform</code> function, we freeze these two parameters in the appropriate order for our translation direction. The remaining parameters to the <code>pyproj.transform</code> function define the <em>x</em> and <em>y</em> values to translate. We’ll leave these unfrozen and pass them in when we call the functions in a moment. </p>
<p>Now that we have the two conversion functions defined, we create a <code>Point</code> object from the latitude and longitude <span aria-label="annotation4" class="CodeAnnotation">❹</span>. Shapely expects these in the reverse order than you might expect. If you try to pass the coordinates directly via the <code>geometry</code> column, you’ll run into the error <code>"latitude or longitude exceeded limits."</code> The <code>shapely.transform</code> function (not to be confused with the <code>pyproj.transform</code> function) applies a user-defined function to all the coordinates of a Shapely object and returns a new geometric object of the same type from the transformed coordinates. We’ll use the <code>shapely.transform</code> function to transform the point into native coordinates using the previously defined <code>wgs84_to_aeqd</code> function <span aria-label="annotation5" class="CodeAnnotation">❺</span>. Shapely points have a <code>buffer</code> function that adds a defined amount of space around the point. Essentially, given a point and a desired amount of buffer space around that point, Shapely generates a new set of points representing the location of the boundary of the buffer space. We can use this to generate a circle representing the approximate coverage area of each tower. Since we defined <span epub:type="pagebreak" id="Page_153" title="153"/>the units in the AEQD transformation function as meters, we can pass the radius for the buffer area in meters as well. This is handy because the <code>accuracy</code> field returned by the OpenCellID API is also in meters. The value in the accuracy field describes how much error is in the latitude and longitude. Calling <code>buffer</code> with the radius set to the accuracy of the radio creates a polygon that represents the estimated location of the tower. </p>
<p>The signal coverage area is a little more difficult to calculate accurately. If we wanted to be very specific, we could calculate wave propagation, but then we’d need to know the type of tower, its power ratings, its height, and any major obstructions. It turns out that the accuracy field also makes a handy signal strength estimate. The accuracy of the tower placement tends to be about 30 to 50 percent of the optimal signal coverage for the given type of tower. Assuming your target is in a metropolitan area, 30 to 50 percent is also a fair guess for signal dampening, especially without knowing any more about the towers or landscape itself. So I like to use the accuracy field as a quick-and-dirty guess at coverage area as well <span aria-label="annotation6" class="CodeAnnotation">❻</span>. By passing the accuracy as the radius to the <code>buffer</code> function, we’re defining a circle whose bounds will represent the probable coverage area of the tower. In reality the tower may not be in the center of the circle, but it will fall somewhere within it. This means the actual coverage area may be a bit bigger or smaller depending on the landscape and architectural construction of the area around the tower, but this will make a good starting point for our proof of concept. </p>
<p>At this point, we have a circular polygon defined around each tower’s <em>x</em> and <em>y</em> location that represents an approximation of its covered service area, but the points representing the hull of the polygon are currently in native map coordinates. To transform them into geodesic coordinates, we call <code>shapely.transform</code> again, this time with the <code>aeqd_to_wgs84</code> function <span aria-label="annotation7" class="CodeAnnotation">❼</span>, and return the results. </p>
<p>Lastly, we call the <code>apply</code> function to get the result of the <code>get_shapely_circle</code> function for each row in <code>geo_df</code> (setting <code>axis=1</code> operates on rows instead of columns) and use the results to overwrite the original <code>geometry</code> column in the data with the new polygons <span aria-label="annotation8" class="CodeAnnotation">❽</span>.</p>
<h3 id="h2-502567c08-0003">Calculating the Search Area</h3>
<p class="BodyFirst">In the previous section we tackled the first big hurdle to our project. We can now convert the latitude and longitude of a tower, along with the accuracy estimation, into a geometric object representing the potential service area for that tower. We’ve also converted the points around the hull of the geometry back into latitude and longitude coordinates we can use with maps. Our next step is to find the geographic area where all of these polygons overlap, or more formally, <em>A</em>∩(<em>B</em>, <em>C</em>, . . . , <em>N</em>) where <em>A</em>, <em>B</em>, <em>C</em>, and so forth represent the polygons created during the previous steps. To accomplish this, we’ll borrow some code from Stack Overflow<sup class="endnote"><a href="b01.xhtml#c08-endnote-008" id="c08-noteref-008">8</a></sup> that performs repeated Boolean operations to find the intersection between <em>A</em> and each other polygon. Let’s start by defining a function to handle the simplest case: returning the difference and intersection of two polygons, <em>A</em> and <em>B</em>. </p>
<p><span epub:type="pagebreak" id="Page_154" title="154"/><a href="#listing8-7" id="listinganchor8-7">Listing 8-7</a> shows the partitioning code.</p>
<pre><code>EMPTY = GeometryCollection()
def partition(poly_a, poly_b):
    if not poly_a.intersects(poly_b):
        return poly_a, poly_b, EMPTY
    only_a = poly_a.difference(poly_b)
    only_b = poly_b.difference(poly_a)
    inter = poly_a.intersection(poly_b)
    return only_a, only_b, inter</code></pre>
<p class="CodeListingCaption"><a id="listing8-7">Listing 8-7</a>: Partitioning polygons into difference and intersection elements</p>
<p>First, we check for the simplest case: when polygon <em>A</em> doesn’t intersect polygon <em>B</em> anywhere. In this case, we simply return both polygons along with an empty <code>GeometryCollection</code> object. If there’s some overlap between the two polygons, we want to return three things. First, we want to return the two differences—that is, the part of <em>A</em> that doesn’t overlap <em>B</em> and vice versa. The two differences are stored in <code>only_a</code> and <code>only_b</code>. Then, we also want to return the intersection of the two, which can be found using Shapely’s <code>intersection</code> function. </p>
<p>The code in <a href="#listing8-7">Listing 8-7</a> will be used within the main function that solves the intersection code, which uses a slightly modified version of a <em>sweep line algorithm</em>, a very famous way to efficiently process an arbitrarily large set of shapes with some Boolean operations (such as unions and intersections). Rather than stopping at each point, we sweep over whole polygons and compare them to all previously known polygons. Each pair of polygons and its subgeometries will be iteratively collected and compared to see which parts of <em>A</em> overlap with the other polygons. These overlaps will be treated as subsets of geometry and checked in turn. </p>
<p><a href="#listing8-8" id="listinganchor8-8">Listing 8-8</a> shows the main function.</p>
<pre><code>def cascaded_intersections(poly1, lst_poly):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> result = [(lst_poly[0], (0,))]
    for i, poly in enumerate(lst_poly[1:], start=1):
        current = []
        while result:
            r_geo, res_idxs = result.pop(0)
          <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> only_res, only_poly, inter = partition(r_geo, poly)
          <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> for geo, idxs in ((only_res, res_idxs), (inter, res_idxs + (i,))):
                if not geo.is_empty:
                    current.append((geo, idxs))
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> curr_union = cascaded_union([elt[0] for elt in current])
        only_poly = poly.difference(curr_union)
      <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> if not only_poly.is_empty:
            current.append((only_poly, (i,)))
        result = current
      <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> for r in range(len(result)-1, -1, -1):
            geo, idxs = result[r]
          <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> if poly1.intersects(geo):
                inter = poly1.intersection(geo)
                result[r] = (inter, idxs)
<span epub:type="pagebreak" id="Page_155" title="155"/>            else:
                del result[r]
    only_poly1 = poly1.difference(cascaded_union([elt[0] for elt in result]))
  <span aria-label="annotation8" class="CodeAnnotationCode">❽</span> only_poly1 = eliminate_small_areas(only_poly1, 1e-16*poly1.area)
    if not only_poly1.is_empty:
        result.append((only_poly1, None))
    return [r[0] for r in result]

<span aria-label="annotation9" class="CodeAnnotationHang">❾</span> polys = list(geo_df["geometry"])
<span aria-label="annotation10" class="CodeAnnotationHang">❿</span> results = cascaded_intersections(polys[0], polys[1:])</code></pre>
<p class="CodeListingCaption"><a id="listing8-8">Listing 8-8</a>: Sweep line algorithm for cascading intersection of polygons<sup class="endnote"><a href="b01.xhtml#c08-endnote-009" id="c08-noteref-009">9</a></sup></p>
<p>First we create the <code>result</code> field with the first polygon in the list to check for intersection <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We loop over the rest of the polygon list and use the <code>partition</code> function from <a href="#listing8-7">Listing 8-7</a> to generate all of the intersections and differences for the polygons (<em>B</em>, . . . , <em>N</em>) <span aria-label="annotation2" class="CodeAnnotation">❷</span>. For each of these, we check the geometry to ensure no empty geometry objects get passed through <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Once we create all these subgeometries, we can take the cascading union to create the remainder section of polygon <em>A</em>. This represents the shape of <em>A</em> that doesn’t intersect any other polygon <span aria-label="annotation4" class="CodeAnnotation">❹</span>. If it is non-empty, we add it to the current list of results <span aria-label="annotation5" class="CodeAnnotation">❺</span>. </p>
<p>Next, we once again loop over the resulting intersections <span aria-label="annotation6" class="CodeAnnotation">❻</span> to see which of them also intersects with the primary polygon <em>A</em> <span aria-label="annotation7" class="CodeAnnotation">❼</span>. We repeat this process until no more intersections are left to check. Sometimes the intersection operation creates tiny polygons, which are really just artifacts that we can toss. To do so, we have a second function that compares each intersection polygon’s area to the area of the first polygon; if it’s less than 1<em>e</em> – 16 × <code>A.area</code>, the polygon is removed. The remaining polygons are assigned back to the <code>only_poly1</code> variable <span aria-label="annotation8" class="CodeAnnotation">❽</span> (we’ll cover the <code>eliminate_small_areas</code> function momentarily). Lastly, we check if the remaining polygon list is empty. If not, we append it to the list of results being held in the <code>result</code> variable.</p>
<p>We can now call the <code>cascaded_intersections</code> function with the list of tower service areas represented by the shape data stored in the <code>geometry</code> column of the <code>geo_df</code> data. We create a list containing the shape data we generated in <a href="#listing8-6">Listing 8-6</a> representing the tower service areas and assign it to the <code>polys</code> variable <span aria-label="annotation9" class="CodeAnnotation">❾</span>. We pass the zeroth polygon in the <code>polys</code> list as the first argument to the <code>cascaded_intersections</code> function. This will be the primary polygon (polygon <em>A</em>) the rest of the algorithm is considering intersections for. We pass the remainder of the list as the second argument (polygons <em>B</em>–<em>N</em>) to tell the <code>cascaded_intersections</code> function these are the polygons that may intersect polygon <em>A</em>. The <code>cascaded_intersections</code> function returns a list of different geometries of interest, which we assign to the <code>results</code> variable <span aria-label="annotation10" class="CodeAnnotation">❿</span>. </p>
<p>The zeroth element of <code>results</code> will be the remainder of polygon <em>A</em> that doesn’t intersect with any other polygon. The first element will be the intersection of polygon <em>A</em> with all the other polygons. The remaining elements will depend on the layout of the polygons but will follow the pattern (<em>A</em>⋂<em>B</em> ∉ <em>CD</em>, <em>A</em>⋂<em>BC</em> ∉ <em>D</em>. . .). We need only the first element, the intersection <span epub:type="pagebreak" id="Page_156" title="156"/>of all the polygons, but the other results are there for you to explore on your own as well. One way we might use this output is to print out the minimum and maximum values for the latitude and longitude of the intersection result. This gives us a boundary in the shape of a box that completely encloses the geometry of the intersection polygon. We can find this search area pretty simply:</p>
<pre><code>x,y = results[1].exterior.xy
print(f"""Search bounded area:
({min(y)}, {min(x)})
to
({max(y)}, {max(x)})""")</code></pre>
<p>First we create two variables, <code>x</code> and <code>y</code>, to hold their respective list of coordinate values. Remember that we’ve already converted the coordinates to latitude and longitude, so all we need to do now is print out the minimum and maximum values from each list to find the latitude and longitude bounds of our search area. The output of the code for our test towers is shown here:</p>
<pre><code>Search bounded area:
(47.61858939197041, -122.35438376445335)
to
(47.6221396080296, -122.34381687278278)</code></pre>
<p>The coordinates in the output represent the lower-left and upper-right corners and can be used to form a box around the polygon resulting from the cascaded intersection function. We could give this information to a ground team who could go to the area and perform a search. </p>
<p>The code in <a href="#listing8-8">Listing 8-8</a> relies on the <code>eliminate_small_areas</code> function, which, by comparison, is very simple to grok. <a href="#listing8-9" id="listinganchor8-9">Listing 8-9</a> shows the code to eliminate any potential artifact polygons.</p>
<pre><code>def eliminate_small_areas(poly, small_area):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if isinstance(poly, Polygon):
        if poly.area &lt; small_area:
            return EMPTY
        else:
            return poly
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> assert isinstance(poly, MultiPolygon)
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> l = [p for p in poly if p.area &gt; small_area]
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> if len(l) == 0:
        return EMPTY
  <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> if len(l) == 1:
        return l[0]
  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> return MultiPolygon(l)</code></pre>
<p class="CodeListingCaption"><a id="listing8-9">Listing 8-9</a>: Removing small area polygons</p>
<p><span epub:type="pagebreak" id="Page_157" title="157"/>First we use <code>isinstance</code> to check whether the polygon passed in is an instance of a single polygon <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If it is, we check if the polygon’s area is smaller than the <code>small_area</code> parameter. If so, we return an empty <code>GeometryCollection</code>; otherwise, we return the polygon instance. If the object passed in the <code>poly</code> parameter isn’t an instance of a single polygon, we assert it must then be an instance of a <code>MultiPolygon</code> (essentially a list of polygons). If the assertion fails (say you pass in a dictionary by mistake), the code will raise an exception <span aria-label="annotation2" class="CodeAnnotation">❷</span>. In the case where the object is a <code>MultiPolygon</code>, we use list comprehension to check each individual polygon’s area against the <code>small_area</code> parameter <span aria-label="annotation3" class="CodeAnnotation">❸</span>. If the length of the resulting list is 0 <span aria-label="annotation4" class="CodeAnnotation">❹</span>, no polygons remain after the artifacts are removed, so we return <code>EMPTY</code>. If exactly one polygon object remains in the list <span aria-label="annotation5" class="CodeAnnotation">❺</span>, we return it as a single polygon instance; there’s no need to carry the additional weight of a <code>MultiPolygon</code> object forward. Otherwise, if more than one polygon remains in the list, we return them all as a <code>MultiPolygon</code> object <span aria-label="annotation6" class="CodeAnnotation">❻</span>.</p>
<p>After we call the <code>cascading_intersections</code> function, we can plot the first item in the result to see the search area identified. <a href="#figure8-4" id="figureanchor8-4">Figure 8-4</a> shows the polygon representing the intersection of all the towers.</p>
<figure>
<img alt="" class="" src="image_fi/502567c08/f08004.png"/>
<figcaption><p><a id="figure8-4">Figure 8-4</a>: Intersection of all four towers as a polygon</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure8-4">Figure 8-4</a> is in the 8th cell of the <em>OpenCell_API_Examples.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If you compare the shape of the polygon in <a href="#figure8-4">Figure 8-4</a> to the overlapping areas from <a href="#figure8-3">Figure 8-3</a>, you’ll see that they look very similar, meaning we’ve achieved our goal of programmatically identifying the area of interest. We could pass these coordinates in raw form to any GPS device to create a more accurate bounded search area. </p>
<h3 id="h2-502567c08-0004">Mapping the Search Area for Investigators</h3>
<p class="BodyFirst">We could also overlay the result on a map to see the search area we should pass on to investigators, as shown in <a href="#figure8-5" id="figureanchor8-5">Figure 8-5</a>.</p>
<span epub:type="pagebreak" id="Page_158" title="158"/><figure>
<img alt="" class="keyline" src="image_fi/502567c08/f08005.png"/>
<figcaption><p><a id="figure8-5">Figure 8-5</a>: Resulting search area</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate the overlay in <a href="#figure8-5">Figure 8-5</a> is in the 9th cell of the <em>OpenCell_API_Examples.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The polygon lays directly over the area known as Seattle Center, home of the Space Needle. Indeed, when I captured the sample data I was standing near the foot of the Space Needle, close to the center of the search area. Now let’s compare our result to the one presented by the OpenCellID API, shown in <a href="#figure8-6" id="figureanchor8-6">Figure 8-6</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502567c08/f08006.png"/>
<figcaption><p><a id="figure8-6">Figure 8-6</a>: Comparing location estimates</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate the overlay in <a href="#figure8-6">Figure 8-6</a> is in the 15th cell of the <em>OpenCell_API_Examples.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" id="Page_159" title="159"/>The light gray outer circle shows the search area provided by the OpenCellID API based on three of the four sample towers (it was actually more accurate after one of the towers was removed). The dark gray area near the middle is our search area produced using basic computational geometry. As you can see, we have reduced the overall search area considerably. Also worth mentioning is that the OpenCellID result is centered on the very edge of our search area, which means my actual location was farther from the center of the search area.</p>
<h3 id="h2-502567c08-0005">Reducing the Search Area</h3>
<p class="BodyFirst">Using cell tower data will never be as accurate or reliable as GPS, but there are still some techniques we can apply to improve the result. By improving the signal coverage, you’ll get more accurate search areas. They may actually be smaller in area, but your confidence will be higher, leading to better resource usage.</p>
<p>To further reduce the search area, you can take advantage of Wi-Fi networks in the area, if any are available. I wouldn’t rely on them to find the initial search area, but they’re a good option for shrinking a search area once you’ve defined one. I’m a fan of the WiGLE database for Wi-Fi searches, but the OpenCellID API also supports Wi-Fi antennas, as I mentioned previously. By combining the two APIs (and any additional APIs you may find), you’ll improve your chances of finding networks with location information available. You can use the limited range of these networks to drastically reduce the search area, sometimes to a single building. The FCC has investigated using this type of Wi-Fi geolocation as one option to help emergency service dispatchers find callers who don’t know their location.</p>
<p>You may also choose to use cell towers in your data that have the weakest signal, if you can capture the necessary information from the device you want to locate. Ideally, you’ll find several towers with weak signals. These usually turn out to be the towers that are farthest apart and thus create the smallest overlapping region. This is purely heuristic, though, since a weak signal could also indicate a closer tower with more obstructions. If you can capture multiple antennas (say 12 different towers), you can try an iterative approach by testing different groups of three to four antennas at a time. You can compare the resulting search areas and determine a sort of search area heat map, where the most likely places are the ones that show up in the highest number of polygon intersections (or the overlap of the overlaps, if you prefer).</p>
<h2 id="h1-502567c08-0005">Summary</h2>
<p class="BodyFirst">The power of geolocation in a security context can’t be overstated. In a world of cell phones, evolving smart cities, and the proliferation of the Internet of Things (IoT), people are constantly saturated by network transmissions. As you’ve seen, an intrepid researcher, corporate overlord, or motivated hacker can take this information and turn it into a physical location. Combine that with the common business practice of helpfully naming <span epub:type="pagebreak" id="Page_160" title="160"/>Wi-Fi access points after the company, and it becomes a scarily accurate tracking tool. There are a lot of ethical and legal concerns you should consider before you deploy this type of tracking system beyond a research environment.</p>
<p>There are several data sets that encourage users to contribute up-to-date information on the towers in their area through a process called <em>war driving</em>. Despite its antisocial name (rooted in hacker history), war driving is simply traveling around an area recording what networks are visible. Some folks have even attached recording devices to their outdoor animals so that, as the animal wanders, it also contributes to the owner’s network map.<sup class="endnote"><a href="b01.xhtml#c08-endnote-010" id="c08-noteref-010">10</a></sup> </p>
<p>It’s not all gloom and doom, though. In the next project we’ll look at applying the same principles of converting physical locations into geometric data to help a city plan for new emergency services. We’ll revisit the topic of tessellation and discuss one of my favorite geometric algorithms, the Voronoi diagram. </p>
</section>
</body>
</html>