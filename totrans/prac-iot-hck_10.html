<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="157" id="Page_157"/>7</span><br/>
<span class="ChapterTitle">UART, JTAG, and SWD Exploitation</span>
</h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="204" height="204"/>
</figure>
<p class="ChapterIntro">If you understand the protocols that interact directly with a system’s electronic components, you can target IoT devices at the physical level. The <em>Universal Asynchronous Receiver-Transmitter (UART)</em> is one of the simplest serial protocols, and its exploitation provides one of the easiest ways to gain access to IoT devices. Vendors typically use it for debugging, which means that you can often obtain root access through it. To accomplish this, you’ll need some specialized hardware tools; for instance, it’s common for attackers to identify the UART pins on a device’s printed circuit board (PCB) using a multimeter or logic analyzer. They then connect a USB-to-serial adapter to these pins and open a serial debug console from the attacking workstation. Most of the time, if you do this, you’ll be dropped to a root shell. </p>
<p>The <em>Joint Test Action Group (JTAG)</em> is an industry standard (defined in IEEE 1491.1) for debugging and testing increasingly complex PCBs. JTAG interfaces on embedded devices allow us to read and write memory contents, including <span epub:type="pagebreak" title="158" id="Page_158"/>dumping the entire firmware, which means it serves as a way to gain complete control of a target device. <em>Serial Wire Debug</em> (<em>SWD</em>) is a very similar, even simpler electrical interface than JTAG that we’ll examine here as well.</p>
<p>We spend most of this chapter walking through a lengthy practical exercise; you’ll program, debug, and exploit a microcontroller to bypass its authentication process using UART and SWD. But first we explain the inner workings of these protocols and show you how to identify UART and JTAG pinouts on a PCB using hardware and software tools. </p>
<h2 id="h1-500907c07-0001">UART</h2>
<p class="BodyFirst">UART is a <em>serial </em>protocol, which means it transfers data between components one bit at a time. In contrast, <em>parallel communication</em> protocols transmit data simultaneously through multiple channels. Common serial protocols include RS-232, I<sup>2</sup>C, SPI, CAN, Ethernet, HDMI, PCI Express, and USB. </p>
<p>UART is simpler than many of the protocols you’ve likely encountered. To synchronize communications, the UART transmitter and receiver must agree on a specific baud rate (the rate of bits transmitted per second). <a id="figureanchor7-1" href="#figure7-1">Figure 7-1</a> shows the UART packet format.</p>
<figure>
<img src="Images/f07001.png" alt="f07001" width="750" height="227"/>
<figcaption><p><a id="figure7-1">Figure 7-1:</a> UART packet format</p></figcaption>
</figure>
<p>Generally, the line is held high (at a logical 1 value) while UART is in the <em>idle</em> state. Then, to signal the start of a data transfer, the transmitter sends a <em>start bit</em> to the receiver, during which the signal is held low (at a logical 0 value). Next, the transmitter sends five to eight <em>data bits</em> containing the actual message, followed by an optional parity bit and one or two stop bits (with a logical 1 value), depending on the configuration. The <em>parity bit</em>, used for error checking, is rarely seen in practice. The <em>stop bit</em> (or bits) signify the end of transmission. </p>
<p>We call the most common configuration <em>8N1</em>: eight data bits, no parity, and one stop bit. For example, if we wanted to send the character C, or 0x43 in ASCII, in an 8N1 UART configuration, we would send the following bits: <code>0</code> (the start bit); <code>0</code>, <code>1</code>, <code>0</code>, <code>0</code>, <code>0</code>, <code>0</code>, <code>1</code>, <code>1</code> (the value of 0x43 in binary), and <code>0</code> (the stop bit). </p>
<h3 id="h2-500907c07-0001">Hardware Tools for Communicating with UART</h3>
<p class="BodyFirst">You can use a variety of hardware tools to communicate with UART. One easy option is a USB-to-serial adapter, like the one we use in “Hacking a Device Through UART and SWD” on page 168. Other options include adapters with <span epub:type="pagebreak" title="159" id="Page_159"/>the CP2102 or PL2303 chips. If you are new to hardware hacking, we recommend getting a multipurpose tool that supports protocols other than just UART, such as the Bus Pirate, the Adafruit FT232H, the Shikra, or the Attify Badge. </p>
<p>You can also find a list of tools and their descriptions, as well as links to buy them, in “Tools for IoT Hacking” at the end of this book.</p>
<h3 id="h2-500907c07-0002">Identifying UART Ports</h3>
<p class="BodyFirst">To exploit a device through UART, you first need to locate its four UART ports, or connectors, which typically come in the form of pins or <em>pads</em> (plated holes). The term <em>pinout</em> refers to the diagram of all the ports. We’ll use these terms interchangeably throughout this book. A UART pinout has four ports: <em>TX (Transmit)</em>,<em> RX (Receive)</em>,<em> Vcc (Voltage)</em>, and<em> GND (Ground)</em>. Start by opening the device’s external case and removing the PCB. Be warned that this might void your warranty. </p>
<p>These four ports often appear next to each other on the board. If you’re lucky, you might even find markings that indicate the TX and RX ports, as shown in <a id="figureanchor7-2" href="#figure7-2">Figure 7-2</a>. In that case, you can be fairly certain that the set of four pins are the UART pins. </p>
<figure>
<img src="Images/f07002.png" alt="f07002" width="750" height="478"/>
<figcaption><p><a id="figure7-2">Figure 7-2:</a> UART pins clearly marked as DBG_TXD and DBG_RXD on the PCB in a St. Jude/Abbott Medical Merlin@home Transmitter </p></figcaption>
</figure>
<p>In other cases, you might see four through-hole pads next to each other, like those in the TP-Link router in <a id="figureanchor7-3" href="#figure7-3">Figure 7-3</a>. This might occur because vendors have removed the UART header pins from the PCB, which means that you might have to either perform some soldering to reach them or use test probes. (<em>Test probes</em> are physical devices that connect electronic test equipment to a device. They include a probe, cable, and terminating connector. We show a few examples of test probes in Chapter 8.) </p>
<span epub:type="pagebreak" title="160" id="Page_160"/><figure>
<img src="Images/f07003.png" alt="f07003" width="562" height="750"/>
<figcaption><p><a id="figure7-3">Figure 7-3:</a> A PCB in a TP-Link TL WR840N router. On the bottom left, you can see a zoomed-in part of the PCB with the UART pads.</p></figcaption>
</figure>
<p>Also, keep in mind that some devices emulate UART ports by programming the General-Purpose Input/Output (GPIO) pins if there isn’t enough space on the board for dedicated hardware UART pins. </p>
<p>When UART pins aren’t marked as clearly as those shown here, you can typically identify them on a device in two ways: by using a multimeter or by using a logic analyzer. A <em>multimeter</em> measures voltage, current, and resistance. Having a multimeter in your arsenal when doing hardware hacking is highly important, because it can serve a variety of purposes. For example, we <span epub:type="pagebreak" title="161" id="Page_161"/>commonly use it to test for <em>continuity</em>. A continuity test sounds a buzzer when a circuit’s resistance is low enough (less than a few ohms), indicating that there’s a continuous path between the two points probed by the multimeter’s leads. </p>
<p>Although a cheap multimeter will do the job, we recommend that you invest in a robust and precise multimeter, if you plan to delve deeper into hardware hacking. True RMS multimeters are more accurate for measuring AC currents. <a id="figureanchor7-4" href="#figure7-4">Figure 7-4</a> shows a typical multimeter.</p>
<figure>
<img src="Images/f07004.png" alt="f07004" width="750" height="637"/>
<figcaption><p><a id="figure7-4">Figure 7-4:</a> Common multimeter. Highlighted is the Continuity Test mode, which typically has an icon that looks like a sound wave (because of the buzzer that sounds when detecting continuity).</p></figcaption>
</figure>
<p>To identify UART pinouts using a multimeter, start by making sure the device is powered off. By convention, you should connect a black test lead to the multimeter’s COM jack. Insert a red lead in the <span class="ColorText" style="color:#212121">VΩ</span> jack. </p>
<p>Begin by identifying the UART GND. Turn the multimeter dial to the Continuity Test mode, which typically has an icon that looks like a sound wave. It might share a spot on the dial with one or more functions, usually resistance. Place the other end of the black lead on any grounded metallic surface (an area that has a direct conductive path to earth), be it a part of the tested PCB or not. </p>
<p><span epub:type="pagebreak" title="162" id="Page_162"/>Then place the red probe on each of the ports you suspect might be part of the UART pinout. When you hear a beeping sound from the multimeter, you’ve found a GND pin. Keep in mind that the device might have more than one GND pin and you might have found one that isn’t necessarily part of the UART pinout. </p>
<p>Continue by identifying the Vcc port. Turn the multimeter dial to the DC voltage mode in and set it up to 20 V of voltage. Keep the multimeter’s black probe on a grounded surface. Place the red probe in a suspected pad and turn on the device. If the multimeter measures a constant voltage of either 3.3 V or 5 V, you’ve found the Vcc pin. If you get other voltages, place the red probe on another port, reboot the device, and measure the voltage again. Do the same for every port until you identify Vcc.</p>
<p>Next, identify the TX port. Keep the multimeter mode at a DC voltage of 20 V or less, and leave the black probe in a grounded surface. Move the red probe to the suspected pad and power cycle the device. If the voltage fluctuates for a few seconds and then stabilizes at the Vcc value (either 3.3 or 5), you’ve most likely found the TX port. This behavior happens because, during bootup, the device sends serial data through that TX port for debugging purposes. Once it finishes booting, the UART line goes idle. Recall from <a href="#figure7-1">Figure 7-1</a> that an idle UART line remains at a logical high, which means that it has the Vcc value.</p>
<p>If you’ve already identified the rest of the UART ports, the nearby fourth pin is most likely the RX port. Otherwise, you can identify it because it has the lowest voltage fluctuation and lowest overall value of all the UART pins.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>It’s not a big deal if you confuse the UART RX and TX ports with each other, because you can easily swap the wires connecting to them without any consequences. But confusing the Vcc with the GND and connecting wires to them incorrectly might fry the circuit. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>To identify the UART pins more accurately, use a <em>logic analyzer</em>, a device that captures and displays signals from a digital system. Many kinds of logic analyzers are available. They range from cheaper ones, such as the HiLetgo or the Open Workbench Logic Sniffer, to the more professional Saleae family (<a id="figureanchor7-5" href="#figure7-5">Figure 7-5</a>), which support higher sampler rates and are more robust. </p>
<p>We’ll walk through the process of using a logic analyzer against a target device in “Using a Logic Analyzer to Identify the UART Pins” on page 176.</p>
<h3 id="h2-500907c07-0003">Identifying the UART Baud Rate</h3>
<p class="BodyFirst">Next, you have to identify the baud rate the UART ports use. Otherwise, you can’t communicate with the device. Given the absence of a synchronizing clock, the baud rate is the only way for the transmitter and receiver to exchange data in sync. </p>
<span epub:type="pagebreak" title="163" id="Page_163"/><figure>
<img src="Images/f07005.png" alt="f07005" width="750" height="688"/>
<figcaption><p><a id="figure7-5">Figure 7-5:</a> Saleae is a family of professional logic analyzers.</p></figcaption>
</figure>
<p>The easiest way to identify the correct baud rate is to look at the TX pin’s output and try to read the data. If the data you receive isn’t readable, switch to the next possible baud rate until the data becomes readable. You can use a USB-to-serial adapter or a multipurpose device like Bus Pirate to do this, paired with a helper script, such as <em>baudrate.py</em> (<a href="https://github.com/devttys0/baudrate/" class="LinkURL">https://github.com/devttys0/baudrate/</a>) by Craig Heffner, to help automate this process. The most common baud rates are 9600, 38400, 19200, 57600, and 115200, all of which Heffner’s Python script tests by default.</p>
<h2 id="h1-500907c07-0002">JTAG and SWD</h2>
<p class="BodyFirst">Like UART, the JTAG and SWD interfaces on IoT embedded devices can serve as a way to gain control of a device. In this section, we’ll cover the basics of these interfaces and how you can communicate with them. In “Hacking a Device Through UART and SWD” on page 168, we’ll walk through a detailed example of interacting with SWD.</p>
<h3 id="h2-500907c07-0004"><span epub:type="pagebreak" title="164" id="Page_164"/>JTAG</h3>
<p class="BodyFirst">As manufacturers started producing smaller, denser components, testing them efficiently became harder. Engineers used to test hardware for defects using a <em>bed of nails</em> process, in which they placed the board on a number of fixtures arranged to mate with various parts of the board. When manufacturers began using multilayer boards and ball grid array packages, the fixtures could no longer access all nodes on the board. </p>
<p><em>JTAG</em> solved this problem by introducing a more effective alternative to the bed of nails test: the boundary scan. The <em>boundary scan</em> analyzes certain circuitry, including embedded boundary-scan cells and registers for each pin. By leveraging these boundary scan cells, engineers can test that a certain point on the circuit board correctly connects to another point more easily than they could before. </p>
<h4 id="h3-500907c07-0001">Boundary Scan Commands</h4>
<p class="BodyFirst">The JTAG standard defines specific commands for conducting boundary scans, including the following:</p>
<ul>
<li><em>BYPASS</em> allows you to test a specific chip without the overhead of passing through other chips. </li>
<li><em>SAMPLE/PRELOAD</em> takes a sample of the data entering and leaving the device when it’s in its normal functioning mode.</li>
<li><em>EXTEST</em> sets and reads pin states.</li>
</ul>
<p>The device must support these commands to be considered JTAG compliant. Devices might also support optional commands, like <em>IDCODE </em>(for identifying a device)<em> </em>and <em>INTEST</em> (for the internal testing of the device), among others. You might come across these instructions when you use a tool like the JTAGulator (described later in "Identifying JTAG pins" on page 166) for identifying JTAG pins.</p>
<h4 id="h3-500907c07-0002">The Test Access Port</h4>
<p class="BodyFirst">Boundary scans include tests of the four-wire <em>Test Access Port (TAP)</em>, a general-purpose port that provides access to the JTAG test support functions built into a component. It uses a 16-stage finite state machine that moves from state to state. Note that JTAG doesn’t define any protocol for the data coming in or out of the chip. </p>
<p>TAP uses the following five signals:</p>
<ol class="none">
<li><span class="RunInHead"><b>Test clock input (TCK)</b></span>  The TCK is the clock that defines how often the TAP controller will take a single action (in other words, jump to the next state in the state machine). The clock’s speed isn’t specified by the JTAG standard. The device performing the JTAG test can determine it. </li>
<li><span class="RunInHead"><b>Test mode select (TMS) input </b></span>  TMS controls the finite state machine. On each beat of the clock, the device’s JTAG TAP controller checks the voltage on the TMS pin. If the voltage is below a certain <span epub:type="pagebreak" title="165" id="Page_165"/>threshold, the signal is considered low and interpreted as 0, whereas if the voltage is above a certain threshold, the signal is considered high and interpreted as 1.</li>
<li><span class="RunInHead"><b>Test data input (TDI)</b></span>  TDI is the pin that sends data into the chip through the scan cells. Each vendor is responsible for defining the communication protocol over this pin, because JTAG doesn’t define this. The signal presented at TDI is sampled on the rising edge of TCK.</li>
<li><span class="RunInHead"><b>Test data output (TDO)</b></span>  TDO is the pin that sends data out of the chip. According to the standard, changes in the state of the signal driven through TDO should occur only on the falling edge of TCK.</li>
<li><b>Test reset (TRST) input</b>  The optional TRST resets the finite state machine to a known good state. It’s active on low (0). Alternatively, if the TMS is held at 1 for five consecutive clock cycles, it invokes a reset, the same way the TRST pin would, which is why TRST is optional. </li>
</ol>
<h3 id="h2-500907c07-0005">How SWD Works</h3>
<p class="BodyFirst">SWD is a two-pin electrical interface that works very similarly to JTAG. Whereas JTAG was made primarily for chip and board testing, SWD is an ARM-specific protocol designed for debugging. Given the large prevalence of ARM processors in the IoT world, SWD has become increasingly important. If you find an SWD interface, you can almost always gain complete control of the device. </p>
<p>The SWD interface requires two pins: a bidirectional <em>SWDIO</em> signal, which is the equivalent of JTAG’s TDI and TDO pins and a clock, and <em>SWCLK</em>, which is the equivalent of TCK in JTAG. Many devices support the <em>Serial Wire or JTAG Debug Port (SWJ-DP)</em>, a combined JTAG and SWD interface that enables you to connect either a SWD or JTAG probe to the target. </p>
<h3 id="h2-500907c07-0006">Hardware Tools for Communicating with JTAG and SWD</h3>
<p class="BodyFirst">A variety of tools allow us to communicate with JTAG and SWD. Popular tools include the Bus Blaster FT2232H chip, as well as any tool with the FT232H chip, such as the Adafruit FT232H breakout board, the Shikra, or the Attify Badge. The Bus Pirate can also support JTAG if you load it with special firmware, but we don’t recommend using that functionality because it can be unstable. The Black Magic Probe, a specialized tool for JTAG and SWD hacking, has built-in GNU Debugger (GDB) support, which is useful because you won’t need intermediary programs like the <em>Open On-Chip Debugger (OpenOCD)</em> (discussed in “Installing OpenOCD” on page 171). A professional debugging tool, the <em>Segger J-Link Debug Probe</em> supports JTAG, SWD, and even SPI, and it comes with proprietary software. If you want to communicate with SWD only, you can use a tool like the <em>ST-Link</em> programmer, which we’ll use later in this chapter in “Hacking a Device Through UART and SWD” on page 168. </p>
<p>You can find additional tools, their descriptions, and links in “Tools for IoT Hacking.”</p>
<h3 id="h2-500907c07-0007"><span epub:type="pagebreak" title="166" id="Page_166"/>Identifying JTAG Pins</h3>
<p class="BodyFirst">Sometimes a PCB has markings indicating the location of a JTAG header (<a id="figureanchor7-6" href="#figure7-6">Figure 7-6</a>). But most times you’ll have to manually identify the header, as well as which pins correspond to the four signals (TDI, TDO, TCK, and TMS). </p>
<figure>
<img src="Images/f07006.png" alt="f07006" width="750" height="563"/>
<figcaption><p><a id="figure7-6">Figure 7-6:</a> Sometimes the JTAG header is clearly marked on the PCB, as in this mobile Point of Sale (POS) device, where even the individual JTAG pins are labeled (TMS, TDO, TDI, TCK).</p></figcaption>
</figure>
<p>You can take several approaches to identify JTAG pins on a target device. The fastest but most expensive way to detect JTAG ports is by using the <em>JTAGulator</em>, a device created specifically for this purpose (although it can also detect UART pinouts). The tool, shown in <a id="figureanchor7-7" href="#figure7-7">Figure 7-7</a>, has 24 channels that you can connect to a board’s pins. It performs a brute force of these pins by issuing the IDCODE and BYPASS boundary scan commands to every permutation of pins and waits for a response. If it receives a response, it displays the channel corresponding to each JTAG signal, allowing you to identify the JTAG pinout.</p>
<figure>
<img src="Images/f07007.png" alt="f07007" width="750" height="317"/>
<figcaption><p><a id="figure7-7">Figure 7-7:</a> The JTAGulator (<a href="http://www.grandideastudio.com/jtagulator/" class="LinkURL">http://www.grandideastudio.com/jtagulator/</a>) can help you identify JTAG pins on a target device.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="167" id="Page_167"/>To use the JTAGulator, connect it to your computer with a USB cable and then communicate with it over serial (for example, using the <code>screen</code> utility on Linux). You’ll see an example of interfacing over serial later in this chapter in “Connecting the USB to a Serial Adapter” on page 178. You can watch a demonstration of the JTAGulator by its creator, Joe Grand, at <a href="https://www.youtube.com/watch?v=uVIsbXzQOIU/" class="LinkURL">https://www.youtube.com/watch?v=uVIsbXzQOIU/</a>.</p>
<p>A cheaper but much slower way of identifying JTAG pinouts is by using the <em>JTAGenum</em> utility (<a href="https://github.com/cyphunk/JTAGenum/" class="LinkURL">https://github.com/cyphunk/JTAGenum/</a>) loaded on an Arduino-compatible microcontroller, like the STM32F103 blue and black pill devices we’ll attack later in this chapter in “Hacking a Device Through UART and SWD” on page 168. Using JTAGenum, you’d first define the pins of the probing device that you’ll use for the enumeration. For example, for the STM32 blue pill, we’ve selected the following pins (but you can change them):</p>
<pre><code>#elif defined(STM32)       // STM32 bluepill, 
 byte       pins[] = {  10 ,  11 ,  12 ,  13 ,  14 ,  15 ,  16 ,  17, 18 , 19 , 21 , 22  };</code></pre>
<p>You’d have to reference the device’s pinout diagram, and then connect these pins with the test points on your target device. Then you’ll have to flash the JTAGenum Arduino code (<a href="https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.ino/" class="LinkURL">https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.ino/</a>) on the device and communicate with it over serial (the <code>s</code> command will scan for JTAG combinations).</p>
<p>A third way to identify JTAG pins is by inspecting the PCB for one of the pinouts shown in <a id="figureanchor7-8" href="#figure7-8">Figure 7-8</a>. In some cases, PCBs might conveniently provide the <em>Tag-Connect interface</em>, which is a clear indication that the board has a JTAG connector, too. You can see what that interface looks like at <a href="https://www.tag-connect.com/info/" class="LinkURL">https://www.tag-connect.com/info/</a>. Additionally, inspecting the datasheets of the chipsets on the PCB might reveal pinout diagrams that point to JTAG interfaces. </p>
<figure>
<img src="Images/f07008.png" alt="f07008" width="679" height="200"/>
<figcaption><p><a id="figure7-8">Figure 7-8:</a> Finding any of these pin interfaces in the PCB, depending on the manufacturer (ARM, STMicroelectronics, or Infineon for OCDS), would be a good indication that you’re dealing with a JTAG connector.</p></figcaption>
</figure>
<h2 id="h1-500907c07-0003"><span epub:type="pagebreak" title="168" id="Page_168"/>Hacking a Device Through UART and SWD</h2>
<p class="BodyFirst">In this section, we’ll exploit a microcontroller’s UART and SWD ports to retrieve the device memory and bypass the flashed program’s authentication routine. To attack the device, we’ll use two tools: a mini ST-Link programmer and a USB-to-serial adapter.</p>
<p>The <em>mini ST-Link programmer</em> (<a id="figureanchor7-9" href="#figure7-9">Figure 7-9</a>) lets us interact with our target device through SWD. </p>
<figure>
<img src="Images/f07009.png" alt="f07009" width="750" height="375"/>
<figcaption><p><a id="figure7-9">Figure 7-9:</a> The mini ST-Link V2 programmer lets us interact with STM32 cores through SWD.</p></figcaption>
</figure>
<p>The <em>USB-to-serial adapter</em> (<a id="figureanchor7-10" href="#figure7-10">Figure 7-10</a>) lets us communicate with the device’s UART pins through our computer’s USB port. This adapter is a <em>transistor-transistor logic (TTL)</em> device, which means it uses currents of 0 and 5 volts to represent the values 0 and 1, respectively. Many adapters use the FT232R chip, and you can easily find one if you search for USB-to-serial adapters online.</p>
<figure>
<img src="Images/f07010.png" alt="f07010" width="750" height="335"/>
<figcaption><p><a id="figure7-10">Figure 7-10:</a> A USB-to-serial (TTL) adapter. This one can also switch between 5 V and 3.3 V.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="169" id="Page_169"/>You’ll need a minimum of ten <em>jumper wires</em> to connect the devices by their pins. We also recommend getting a <em>breadboard</em>, which is a construction base that you can use to hold the black pill steady. You should be able to purchase these hardware components online. We specifically selected the components used here because they’re easy to find and inexpensive. But if you wanted an alternative to the ST-Link programmer, you could use the Bus Blaster, and as an alternative to the USB-to-serial adapter, you could use the Bus Pirate. </p>
<p>As for the software, we’ll use Arduino to code the authentication program we’ll attack; we’ll use OpenOCD with GDB for debugging. The following sections show you how to set up this testing and debugging environment.</p>
<h3 id="h2-500907c07-0008">The STM32F103C8T6 (Black Pill) Target Device</h3>
<p class="BodyFirst">The STM32F103xx is a very popular, inexpensive microcontroller family used in a large variety of applications in the industrial, medical, and consumer markets. It has an ARM Cortex-M3 32-bit RISC core operating at 72 MHz frequency, a flash memory of up to 1MB, static random-access memory (SRAM) of up to 96KB, and an extensive range of I/Os and peripherals.</p>
<p>The two versions of this device are known as the blue pill and the black pill (based on the board’s color). We’ll use the black pill (STM32F103C8T6) as our target device. The main difference between the two versions is that the black pill consumes less energy and is sturdier than the blue pill. You can easily order it online. We recommend getting a board that has presoldered headers and the Arduino bootloader flashed. That way, you won’t have to solder the headers and you’ll be able to use the device directly through USB. But in this exercise, we’ll show you how to load a program to the black pill without the Arduino bootloader. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>We chose the black pill because we came across some issues when using the blue pill with the UART interface, so we strongly advise you to use it instead of the cheaper blue pill. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><a id="figureanchor7-11" href="#figure7-11">Figure 7-11</a> shows the device’s pinout diagram. Notice that although some pins are 5 V-resistant, others aren’t; so we’ll have to send them no more than 3.3 V. If you’re interested in learning more about the internals of the STM32 microcontroller in general, you can find a very good reference at <a href="https://legacy.cs.indiana.edu/~geobrown/book.pdf" class="LinkURL">https://legacy.cs.indiana.edu/~geobrown/book.pdf</a>.</p>
<p>Make sure you don’t connect any 5 V output to any of the black pill’s 3.3 V pins, or you’ll most likely burn them.</p>
<span epub:type="pagebreak" title="170" id="Page_170"/><figure>
<img src="Images/f07011.png" alt="f07011" width="750" height="521"/>
<figcaption><p><a id="figure7-11">Figure 7-11:</a> STM32F103C8T6 (black pill) pinout diagram</p></figcaption>
</figure>
<h3 id="h2-500907c07-0009">Setting Up the Debugging Environment </h3>
<p class="BodyFirst">We’ll start by programming our target device using the <em>Arduino Integrated Development Environment (IDE)</em>. The Arduino is an inexpensive, easy-to-use, open source electronics platform that lets you program microcontrollers using its Arduino programming language. Its IDE contains a text editor for writing code; a board and library manager; built-in functionality for verifying, compiling, and uploading the code to an Arduino board; and a serial monitor to display output from the hardware. </p>
<h4 id="h3-500907c07-0003">Installing the Arduino Environment</h4>
<p class="BodyFirst">You can get the latest version of the Arduino IDE at <a href="https://www.arduino.cc/en/Main/Software/" class="LinkURL">https://www.arduino.cc/en/Main/Software/</a>. For this demonstration, we’ll use version 1.8.9 on Ubuntu 18.04.3 LTS, but the operating system you use won’t matter. On Linux, download the package manually and follow the instructions at <a href="https://www.arduino.cc/en/guide/linux/" class="LinkURL">https://www.arduino.cc/en/guide/linux/</a>. Alternatively, if you’re using a Debian-based distribution, such as Kali or Ubuntu, you can enter the following command in a terminal to install everything you’ll need:</p>
<pre><code># <b>apt-get install arduino</b></code></pre>
<p><span epub:type="pagebreak" title="171" id="Page_171"/>After installing the IDE, download the latest Arduino STM32 core files from GitHub, install them in the <em>hardware</em> folder in the Arduino sketches directory, and run the <em>udev rules</em> installation script.</p>
<pre><code>$ <b>wget https://github.com/rogerclarkmelbourne/Arduino_STM32/archive/master.zip</b>
$ <b>unzip master.zip</b>
$ <b>cp -r Arduino_STM32-master /home/</b><em>ithilgore</em><b>/Arduino/hardware/</b>
$ <b>cd /home/</b><em>ithilgore</em><b>/Arduino/hardware/Arduino_STM 32-master/tools/linux</b>
$ <b>./install.sh</b></code></pre>
<p>Make sure you replace the username after <em>/home/</em> with your own username.</p>
<p>If the <em>hardware</em> folder doesn’t exist, create it. To discover where the Arduino sketches are saved, run the Arduino IDE by entering <code>arduino</code> in a terminal or clicking the Arduino icon on your Desktop. Then click <b>File</b><span class="MenuArrow">▶</span><b>Preferences</b> and note the <b>Sketchbook location</b> file path. In this example, it’s <em>/home/&lt;ithilgore&gt;/Arduino</em>. </p>
<p>You’ll also need to install the 32-bit version of <code>libusb-1.0</code> as follows because the <code>st-link</code> utility that comes bundled with the Arduino STM32 relies on it:</p>
<pre><code>$ <b>sudo apt-get install libusb-1.0-0:i386</b></code></pre>
<p>In addition, install the Arduino SAM boards (Cortex-M3). These are the cores for the Cortex-M3 microcontroller. <em>Cores</em> are low-level APIs that make specific microcontrollers compatible with your Arduino IDE. You can install these inside the Arduino IDE by clicking <b>Tools</b><span class="MenuArrow">▶</span><b>Board</b><span class="MenuArrow">▶</span><b>Boards Manager</b>. Then search for <b>SAM Boards</b>. Click <b>Install</b> on the <b>Arduino SAM Boards (32-bits ARM Cortex-M3)</b> option that should appear. We used version 1.6.12. </p>
<p>You can also find the latest installation instructions for Arduino STM32 at <a href="https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation/" class="LinkURL">https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation/</a>.</p>
<h4 id="h3-500907c07-0004">Installing OpenOCD</h4>
<p class="BodyFirst"><em>OpenOCD</em> is a free and open source testing tool that provides JTAG and SWD access through GDB to ARM, MIPS, and RISC-V systems. We’ll use it to debug the black pill. To install it in your Linux system, enter the following commands:</p>
<pre><code>$ <b>sudo apt-get install libtool autoconf texinfo libusb-dev libftdi-dev libusb-1.0</b>
$ <b>git clone git://git.code.sf.net/p/openocd/code openocd</b>
$ <b>cd openocd</b>
$ <b>./bootstrap</b>
$ <b>./configure --enable-maintainer-mode --disable-werror --enable-buspirate --enable-ftdi </b>
$ <b>make</b>
$ <b>sudo make install</b></code></pre>
<p>Notice that you also install <code>libusb-1.0</code>, which you’ll need to enable support for Future Technology Devices International (FTDI) devices. Then compile OpenOCD from the source. This allows us to enable support for FTDI devices and the Bus Pirate tool. </p>
<p><span epub:type="pagebreak" title="172" id="Page_172"/>To learn more about OpenOCD, consult its extensive user guide at <a href="http://openocd.org/doc/html/index.html" class="LinkURL">http://openocd.org/doc/html/index.html</a>.</p>
<h4 id="h3-500907c07-0005">Installing the GNU Debugger</h4>
<p class="BodyFirst"><em>GDB</em> is a portable debugger that runs on Unix-like systems. It supports many target processors and programming languages. We’ll use GDB to remotely trace and alter the target program’s execution.</p>
<p>On Ubuntu, you’ll have to install the original <code>gdb</code> and <code>gdb-multiarch</code>, which extends GDB support for multiple target architectures, including ARM (the black pill’s architecture). You can do so by entering the following in a terminal:</p>
<pre><code>$ <b>sudo apt install gdb gdb-multiarch</b></code></pre>
<h3 id="h2-500907c07-0010">Coding a Target Program in Arduino</h3>
<p class="BodyFirst">Now we’ll write a program in Arduino that we’ll load onto the black pill and target for exploitation. In an actual test, you might not have access to the device’s source code, but we’re showing it to you for two reasons. First, you’ll learn how Arduino code gets translated to a binary that you can upload onto the device. Second, when we perform debugging with OpenOCD and GDB, you’ll get to see how the assembly code corresponds to the original source code. </p>
<p>The program (<a id="listinganchor7-1" href="#listing7-1">Listing 7-1</a>) uses the serial interface to send and receive data. It emulates an authentication process by checking for a password. If it receives the right password from the user, it prints <code>ACCESS GRANTED</code>. Otherwise, it keeps prompting the user to log in.  </p>
<pre><code>const byte bufsiz = 32; <span class="CodeAnnotation">1</span>
char buf[bufsiz];
boolean new_data = false;
boolean start = true;

void setup() { <span class="CodeAnnotation">2</span>
  delay(3000);
  Serial1.begin(9600);
}

void loop() { <span class="CodeAnnotation">3</span>
  if (start == true) {
    Serial1.print("Login: ");
    start = false;
  }
  recv_data();
  if (new_data == true)
    validate();
}

void recv_data() { <span class="CodeAnnotation">4</span>
  static byte i = 0;
<span epub:type="pagebreak" title="173" id="Page_173"/>  static char last_char;
  char end1 = '\n';
  char end2 = '\r';
  char rc;

  while (Serial1.available() &gt; 0 &amp;&amp; new_data == false) { <span class="CodeAnnotation">5</span>
    rc = Serial1.read();       
    // skip next character if previous one was \r or \n and this one is \r or \n
    if ((rc == end1 || rc == end2) &amp;&amp; (last_char == end2 || last_char == end1)) <span class="CodeAnnotation">6</span>
      return;
    last_char = rc;

    if (rc != end1 &amp;&amp; rc != end2) { <span class="CodeAnnotation">7</span>
      buf[i++] = rc;
      if (i &gt;= bufsiz)
        i = bufsiz - 1;
    } else { <span class="CodeAnnotation">8</span>
      buf[i] = '\0'; // terminate the string
      i = 0;
      new_data = true;       
    }
  } 
}

void validate() { <span class="CodeAnnotation">9</span>
  Serial1.println(buf);
  new_data = false;
  if (strcmp(buf, "sock-raw.org") == 0) <span class="CodeAnnotation">a</span>
    Serial1.println("ACCESS GRANTED");
  else {
    Serial1.println("Access Denied.");
    Serial1.print("Login: ");
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1:</a> A serial communication program in Arduino for the STM32F103 chip</p>
<p>We begin by defining four global variables <span class="CodeAnnotation">1</span>. The <code>bufsiz</code> variable holds the number of bytes for the character array <code>buf</code>,<code/>which stores the bytes coming through the serial port from the user or device interacting with the port. The <code>new_data</code> variable is a boolean that becomes <code>true</code> every time the main program loop receives a new line of serial data. The boolean variable <code>start</code> is <code>true</code> only upon the first iteration of the main loop, so it prints the first “Login” prompt. </p>
<p>The <code>setup()</code> function <span class="CodeAnnotation">2</span> is a built-in Arduino function that gets executed once when the program initializes. Inside this function, we initialize the serial interface (<code>Serial1.begin</code>) with<code/>a baud rate of 9600 bits per second. Note that <code>Serial1</code> is different from <code>Serial</code>, <code>Serial2</code>, and <code>Serial3</code>, each of which corresponds to different UART pins on the black pill. The object <code>Serial1</code> corresponds to pins A9 and A10. </p>
<p>The <code>loop()</code> function <span class="CodeAnnotation">3</span> is another built-in Arduino function that gets called automatically after <code>setup()</code>, looping consecutively and executing the main program. It continuously calls <code>recv_data()</code>, which is responsible <span epub:type="pagebreak" title="174" id="Page_174"/>for receiving and validating serial data. When the program has finished receiving all bytes (which happens when <code>new_data</code> becomes <code>true</code>), <code>loop()</code> calls <code>validate()</code>, which checks whether the received bytes constitute the correct passphrase. </p>
<p>The <code>recv_data()</code> function <span class="CodeAnnotation">4</span> begins by defining two <em>static</em> variables (which means their value will be retained between every call of this function): <code>i</code> for iterating through the <code>buf</code> array and <code>last_char</code> for storing the last character we read from the serial port. The <code>while</code> loop <span class="CodeAnnotation">5</span> checks whether there are any bytes available for reading from the serial port (through <code>Serial1.available</code>), reads the next available byte with <code>Serial1.read</code>,<code/>and checks whether the previously stored character (which is held in <code>last_char</code>) is a carriage return <code>‘\r’</code> or new line <code>‘\n’ </code><span class="CodeAnnotation">6</span>. It does that so it can deal with devices that send a carriage return, new line, or both to terminate their lines when they send serial data. If the next byte doesn’t indicate the end of the line <span class="CodeAnnotation">7</span>, we store the newly read byte <code>rc</code> in <code>buf</code> and increment the <code>i</code> counter by one. If <code>i</code> reaches the end of the buffer length, the program no longer stores any new bytes in the buffer. If the read byte signifies the end of the line <span class="CodeAnnotation">8</span>, meaning the user on the serial interface most likely pressed <span class="KeyCaps">ENTER</span>, we null terminate the string in the array, reset the <code>i</code> counter, and set <code>new_data</code> to <code>true</code>.</p>
<p>In that case, we call the <code>validate()</code> function <span class="CodeAnnotation">9</span>, which prints the received line and compares it with the correct password <span class="CodeAnnotation">a</span>. If the password is correct, it prints <code>ACCESS GRANTED</code>. Otherwise, it prints <code>Access Denied</code> and prompts the user to try logging in again.</p>
<h3 id="h2-500907c07-0011">Flashing and Running the Arduino Program</h3>
<p class="BodyFirst">Now upload the Arduino program to the black pill. This process varies slightly depending on whether or not you purchased the black pill with the Arduino bootloader preflashed, but we’ll walk through both methods. You could also upload the program using a third method: a serial adapter, which allows you to flash your own bootloader (such as <a href="https://github.com/rogerclarkmelbourne/STM32duino-bootloader/" class="LinkURL">https://github.com/rogerclarkmelbourne/STM32duino-bootloader/</a>), but we won’t cover this process here; you’ll find multiple resources online for doing this.</p>
<p>Either way, we’ll use the ST-Link programmer and write the program to the main flash memory. Alternatively, you could write it to the embedded SRAM if you encounter any problems with writing it to flash. The main problem with that approach is that you’ll have to reupload the Arduino program every time you power cycle the device, because the SRAM content is volatile, which means it gets lost every time you power off the device.</p>
<h4 id="h3-500907c07-0006">Selecting the Boot Mode</h4>
<p class="BodyFirst">To make sure you upload the program to the black pill’s flash memory, you’ll have to select the correct boot mode. STM32F10<em>xxx</em> devices have three different boot modes, which you can choose from using the <em>BOOT1</em> and <em>BOOT0</em> pins, as shown in <a href="#table7-1" id="tableanchor7-1">Table 7-1</a>. Reference the pinout diagram in <a href="#figure7-11" id="tableanchor7-11">Figure 7-11</a> to locate these two pins on the black pill.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table7-1">Table 7-1</a>: Boot Modes for the Black Pill and Other STM32F10<em>xxx</em> Microcontrollers<span epub:type="pagebreak" title="175" id="Page_175"/></p></figcaption>
<table id="table-500907c07-0001" border="1">
<thead>
<tr>
<td colspan="2"><b>Boot mode selection pins</b></td><td><b>Boot mode</b></td><td><b>Aliasing</b></td></tr>
</thead>
<tbody>
<tr>
<td>BOOT1</td><td>BOOT0</td><td/><td/></tr>
<tr>
<td>x</td><td>0</td><td>Main flash memory</td><td>Selects the main flash memory as the boot space</td></tr>
<tr>
<td>0</td><td>1</td><td>System memory</td><td>Selects the system memory as the boot space</td></tr>
<tr>
<td>1</td><td>1</td><td>Embedded SRAM</td><td>Selects the embedded SRAM as the boot space</td></tr>
</tbody>
</table>
</figure>
<p>Use the jumper pin that comes with the black pill to select the boot mode. A <em>jumper pin</em> is a set of small pins in a plastic box that creates an electrical connection between two pin headers (<a id="figureanchor7-12" href="#figure7-12">Figure 7-12</a>). You can use the jumper pin to connect the boot mode selection pins to VDD (logical 1) or GND (logical 0).</p>
<figure>
<img src="Images/f07012.png" alt="f07012" width="329" height="316"/>
<figcaption><p><a id="figure7-12">Figure 7-12:</a> A jumper pin, also known as a jumper shunt or shunt</p></figcaption>
</figure>
<p>Connect the jumper pin for both BOOT0 and BOOT1 of the black pill to the GND. If you wanted to write to SRAM, you would connect both to VDD.</p>
<h4 id="h3-500907c07-0007">Uploading the Program </h4>
<p class="BodyFirst">To upload the program, first, make sure the jumpers for BOOT0 and BOOT1 are connected to the GND. Create a new file in the Arduino IDE, copy and paste the code from <a href="#listing7-1">Listing 7-1</a> into it, and then save the file. We used the name <em>serial-simple</em>. Click <b>Tools</b><span class="MenuArrow">▶</span><b>Board</b> and select <b>Generic STM32F103C series</b> in the <b>STM32F1 Boards</b> section. Next, click <b>Tools</b><span class="MenuArrow">▶</span><b>Variant</b> and select <b>STM32F103C8 (20k RAM, 64k Flash)</b>, which should be the default option. Check that <b>Tools</b><span class="MenuArrow">▶</span><b>Upload method</b> is set to <b>STLink</b> and, ideally, that <b>Optimize </b>is set to <b>Debug (-g)</b>.<b> </b>This ensures that debug symbols appear in the final binary. Leave the rest of the options as-is. </p>
<p>If the black pill has the Arduino bootloader flashed, you can directly connect it to your computer via the USB cable without the ST-Link programmer. Then set the <b>Upload</b> method to <b>STM32duino bootloader</b> instead of <b>STLink</b>. But for learning purposes, we’ll use the ST-Link programmer, so you don’t need the bootloader preflashed. </p>
<p>To upload the program to the black pill, connect the ST-Link programmer to it. Use four jumper wires to link the SWCLK, SWDIO, GND, and <span epub:type="pagebreak" title="176" id="Page_176"/>3.3 V pins of the ST-Link to the CLK, DIO, GND, 3.3 V pins of the black pill, respectively. These pins are located on the bottom part of the black pill’s pin header. Reference <a id="figureanchor7-14" href="#figure7-14">Figure 7-14</a> and <a id="figureanchor7-15" href="#figure7-15">Figure 7-15</a> to see what this looks like.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>You should avoid connecting any of the devices to the USB ports before finishing the wiring setup. It’s good practice to avoid having devices powered on while connecting their pins. This way, you’ll prevent accidentally short-circuiting the pins, which, when the devices are powered on at the same time, might lead to an overvoltage and destroy them. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500907c07-0008">Using a Logic Analyzer to Identify the UART Pins </h4>
<p class="BodyFirst">Next, identify the UART pins on the device. We showed you how to do this with a multimeter earlier in this chapter, but now we’ll use a logic analyzer to identify a UART TX pin. A TX pin transmits output, so it’s easy to recognize. You can use an inexpensive HiLetgo USB logic analyzer with eight channels for this exercise, because it’s compatible with the Saleae Logic software we’ll use. Download that software for your operating system from <a href="https://saleae.com/downloads/" class="LinkURL">https://saleae.com/downloads/</a>. (We used the Linux version in this example.) Then unzip the bundle to a local folder, browse to it in a terminal, and enter the following:</p>
<pre><code>$ <b>sudo ./Logic</b></code></pre>
<p>This command will open Saleae Logic’s graphic interface. Leave it open for now.</p>
<p>Make sure any system you’re testing is powered off when you connect the logic analyzer’s probes to it to avoid short-circuiting. In this case, because the black pill is powered by the ST-Link programmer, temporarily disconnect the programmer from your computer’s USB port. Remember that if you power off the black pill after uploading the Arduino code to the SRAM instead of the flash, you’ll have to reupload the code to the black pill. </p>
<p>Use a jumper wire to connect one of your logic analyzer’s GND pins to one of the black pill’s GND pins so they share a common ground. Next, use two more jumper wires to connect the logic analyzer’s CH0<em> </em>and CH1 channels (all channel pins should be labeled) to the black pill’s A9 and A10 pins. Connect the logic analyzer to a USB port on your computer.</p>
<p>In the Saleae interface, you should see at least a couple of channels in the left pane, each of which corresponds to one of the logic analyzer’s channel pins. You can always add more channels, if your logic analyzer supports them, so you can sample more pins at the same time. Add them by clicking the two arrows next to the green Start button to open the settings. You can then select how many channels you want to display by toggling the number next to each channel. </p>
<p>In the settings, change the <b>Speed (Sample Rate)</b> to 50 kS/s and the <b>Duration</b> to 20 seconds. As a rule, you should sample digital signals at least four times faster than their bandwidth. With serial communications, which are generally very slow, a 50 kS/s sampling rate is more than enough, although sampling faster than this does no harm. As for the duration, 20 seconds is enough time for the device to power on and start transmitting data. </p>
<p><span epub:type="pagebreak" title="177" id="Page_177"/>Click the <b>Start</b> button to begin capturing the signals and immediately power on the black pill by connecting the ST-Link programmer to a USB port. The session will last for 20 seconds, but you can stop it at any time before then. If you don’t see any data on the channels, try power cycling the black pill while the session is on. At some point, you should see a signal coming from the channel corresponding to the A9 (TX) pin. Zoom in or out using your mouse wheel to inspect it more clearly. </p>
<p>To decode the data, click the <b>+</b> beside <b>Analyzers</b> in the Graphical User Interface (GUI)’s right pane, select <b>Async Serial</b>, choose the channel on which you’re reading the signal, and set the <b>Bit Rate</b> to 9600. (The bit rate in this case is the same as the baud rate.) Note that when you don’t know the bit rate, you can select <b>Use Autobaud</b> and let the software work its magic to detect the right one. You should now see the <code>Login:</code> prompt from the Arduino program as a series of UART packets in the signal you just captured (<a id="figureanchor7-13" href="#figure7-13">Figure 7-13</a>).</p>
<figure>
<img src="Images/f07013.png" alt="f07013" width="750" height="378"/>
<figcaption><p><a id="figure7-13">Figure 7-13:</a> Decoding the UART data coming from the black pill’s TX pin using the Saleae Logic software. In the bottom right, you can see the <code>Login:</code> prompt that the Arduino program runs when the device boots.</p></figcaption>
</figure>
<p>Notice in <a href="#figure7-13">Figure 7-13</a> how the device sends the letter “L,” which indicates the beginning of the login message. The communication starts with an idle line (at a logical 1 value). The black pill then sends a start bit with a logical 0 value, followed by the data bits, from least to most significant. In ASCII, the letter L is 0x4C, or 00110010 in binary, as you can see in the transmission. Finally, the black pill sends a stop bit (with a logical 1 value), before beginning the letter “o.” </p>
<p>We placed two timing markers (A1 and A2 in <a href="#figure7-13">Figure 7-13</a>) on either side of one random bit. <em>Timing markers</em> are annotations that you can use to measure the time elapsed between any two locations in your data. We measured a duration of 100 μs, which proves that the transmission has a baud rate of 9600 bits/sec. (One bit takes 1/9600 seconds to transmit, or 0.000104 seconds, which is roughly 100 μs.) </p>
<h4 id="h3-500907c07-0009"><span epub:type="pagebreak" title="178" id="Page_178"/>Connecting the USB to a Serial Adapter</h4>
<p class="BodyFirst">To test the USB-to-serial adapter, let’s connect it to our computer. Some USB-to-serial adapters, including the one we used, come with a jumper pin preinstalled on the RX and TX pins (<a href="#figure7-12">Figure 7-12</a>). The jumper pin will short-circuit the RX and TX pin headers, creating a loop between them. This is useful for testing that the adapter works: connect it to your computer’s USB port and then open a terminal emulator program, such as <code>screen </code>or <code>minicom</code>, to that port. Try using the terminal emulator to send serial data to the connected devices. If you see the keystrokes echoed in the terminal, you know the adapter works. The reason is that your keyboard sends characters through the USB port to the adapter’s TX pin; because of the jumper, the characters get sent to the RX pin and then returned to the computer through the USB port. </p>
<p>Plug the adapter into your computer with the jumper pin in place, and then enter the following command to see which device file descriptor it was assigned to: </p>
<pre><code>$ <b>sudo dmesg</b> 
…
usb 1-2.1: FTDI USB Serial Device converter now attached to ttyUSB0</code></pre>
<p>Typically, it will be assigned to <em>/dev/ttyUSB0</em> if you don’t have any other peripheral devices attached. Then start <code>screen</code> and pass it the file descriptor as an argument:</p>
<pre><code>$ <b>screen /dev/ttyUSB0</b></code></pre>
<p>To exit the screen session, press <span class="KeyCaps">CTRL</span>-A followed by <b>\</b>. </p>
<p>You can also provide the baud rate as a second argument. To find the current baud rate of the adapter, enter the following:</p>
<pre><code>$ <b>stty -F /dev/ttyUSB0</b>
speed 9600 baud; line =0;
…</code></pre>
<p>This output shows that the adapter has a baud speed of 9600. </p>
<p>Verify that the adapter is working and then remove the jumper pin, because we’ll need to connect the RX and TX pins to the black pill. <a href="#figure7-14">Figure 7-14</a> shows the connections you have to make. </p>
<p>Connect the adapter’s RX pin to a TX pin on the black pill (pin A9, in this case). Then connect the adapter’s TX pin to the black pill’s RX pin (A10). Using A9 and A10 is important, because these pins correspond to the <code>Serial1</code> interface we used in the Arduino code. </p>
<p>The USB-to-serial adapter must have the same GND as the black pill, because the devices use GND as a point of reference for voltage levels. The Clear to Send (CTS) pin should be set to GND as well, because it’s considered active when low (meaning at a logic level of 0). If it weren’t connected to GND, it would float high, indicating that the adapter isn’t clear to send bytes to the black pill.</p>
<span epub:type="pagebreak" title="179" id="Page_179"/><figure>
<img src="Images/f07014.png" alt="f07014" width="750" height="603"/>
<figcaption><p><a id="figure7-14">Figure 7-14:</a> Pin connections between the black pill, ST-Link, USB-to-serial adapter, and laptop</p></figcaption>
</figure>
<h4 id="h3-500907c07-0010">Connecting to a Computer</h4>
<p class="BodyFirst">Once you’ve connected the black pill, ST-Link, and USB-to-serial adapter, connect the ST-Link to a USB port on your computer. Then connect the adapter to a USB port. <a href="#figure7-15">Figure 7-15</a> shows an example setup. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>Notice that the black pill isn’t connected to any USB port. Instead, it’s powered through the ST-Link programmer. Connecting the black pill to any USB port in this setup might burn it. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Now that the setup is ready, return to the Arduino IDE. Enable verbose output by clicking <b>File</b><span class="MenuArrow">▶</span><b>Preferences</b> and selecting the <b>Show verbose output during: compilation</b> checkbox. Then click <b>Sketch</b><span class="MenuArrow">▶</span><b>Upload</b> to compile the program and upload it to the black pill. </p>
<span epub:type="pagebreak" title="180" id="Page_180"/><figure>
<img src="Images/f07015.png" alt="f07015" width="750" height="354"/>
<figcaption><p><a id="figure7-15">Figure 7-15:</a> The black pill, ST-Link programmer, and USB-to-serial adapter are connected using jumper wires. Note that the black pill isn’t connected to any USB port; the ST-Link programmer powers it.</p></figcaption>
</figure>
<p>Because we enabled verbose output in the Arduino IDE, compiling and uploading the program should give you a lot of information about the process, including a temporary directory that stores the intermediate files necessary for compilation (<a id="figureanchor7-16" href="#figure7-16">Figure 7-16</a>). </p>
<figure>
<img src="Images/f07016.png" alt="f07016" width="750" height="106"/>
<figcaption><p><a id="figure7-16">Figure 7-16:</a> Verbose output from Arduino IDE when compiling and uploading the program. Highlighted is the temporary directory you’ll need.</p></figcaption>
</figure>
<p>On Linux, this directory typically looks like <em>/tmp/arduino_build_336697</em>, where the last number is a random identifier (yours will obviously be different) that changes with new builds. When you compile your program, take note of this directory, because you’ll need it later.</p>
<p>At this point, open the serial monitor console by clicking <b>Tools</b><span class="MenuArrow">▶</span><b>Serial Monitor</b>. The <em>Serial Monitor </em>is a pop-up window that can send and receive UART data to and from the black pill. It has similar functionality to <code>screen</code>, used earlier, but it’s built into the Arduino IDE for convenience. Click <b>Tools</b><span class="MenuArrow">▶</span><b>Port</b> to make sure you’ve selected the USB port to which your USB-to-serial adapter is connected. Check that the Serial Monitor’s baud rate is 9600, like we specified in the code. You should then see the <code>Login:</code> prompt from our Arduino program. Enter some sample text to test the program. <a id="figureanchor7-17" href="#figure7-17">Figure 7-17</a> shows a sample session. </p>
<p>If you enter anything other than <code>sock-raw.org</code>, you should get the <code>Access Denied</code> message. Otherwise, you should get the <code>ACCESS GRANTED</code> message. </p>
<span epub:type="pagebreak" title="181" id="Page_181"/><figure>
<img src="Images/f07017.png" alt="f07017" width="750" height="270"/>
<figcaption><p><a id="figure7-17">Figure 7-17:</a> The Serial Monitor pop-up window in the Arduino IDE</p></figcaption>
</figure>
<h3 id="h2-500907c07-0012">Debugging the Target</h3>
<p class="BodyFirst">Now it’s time for the main exercise: debugging and hacking the black pill. If you followed all of the previous steps, you should have a fully working debugging environment and the black pill should contain the Arduino program we wrote. </p>
<p>We’ll use OpenOCD to communicate with the black pill using SWD through the ST-Link programmer. We’ll leverage that connection to open a remote debugging session with GDB. Then, using GDB, we’ll walk through the program’s instructions and bypass its authentication check.</p>
<h4 id="h3-500907c07-0011">Running an OpenOCD Server</h4>
<p class="BodyFirst">We’ll start OpenOCD as a server. We need OpenOCD to communicate with the black pill through SWD. To run it against the black pill’s STM32F103 core using the ST-Link, we have to specify the two relevant configuration files using the <code>-f</code> switch:</p>
<pre><code>$ <b>sudo openocd -f /usr/local/share/openocd/scripts/interface/stlink.cfg -f /usr/local/share/openocd/scripts/targets/stm32f1x.cfg</b>
 [sudo] password for ithilgore: 
Open On-Chip Debugger 0.10.0+dev-00936-g0a13ca1a (2019-10-06-12:35)
Licensed under GNU GPL v2
For bug reports, read
	http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport "hla_swd". To override use 'transport select &lt;transport&gt;'.
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
Info : clock speed 1000 kHz
Info : STLINK V2J31S7 (API v2) VID:PID 0483:3748
Info : Target voltage: 3.218073
Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints
Info : Listening on port 3333 for gdb connections</code></pre>
<p>These configuration files help OpenOCD understand how to interact with the devices using JTAG and SWD. If you installed OpenOCD from <span epub:type="pagebreak" title="182" id="Page_182"/>source, as described earlier, these configuration files should be in <em>/usr/local/share/openocd</em>. When you run the command, OpenOCD will start accepting local Telnet connections on TCP port 4444 and GDB connections on TCP port 3333.</p>
<p>At this point, we’ll connect to the OpenOCD session with Telnet and begin issuing some commands to the black pill over SWD. In another terminal, enter the following:</p>
<pre><code>$ <b>telnet localhost 4444</b>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Open On-Chip Debugger
&gt; <span class="CodeAnnotation">1</span><b>reset init </b>
target halted due to debug-request, current mode: Thread 
xPSR: 0x01000000 pc: 0x08000538 msp: 0x20005000
&gt; <span class="CodeAnnotation">2</span><b>halt </b>
&gt; <span class="CodeAnnotation">3</span><b>flash banks </b>
#0 : stm32f1x.flash (stm32f1x) at 0x08000000, size 0x00000000, buswidth 0, chipwidth 0
&gt; <span class="CodeAnnotation">4</span><b>mdw 0x08000000 0x20 </b>
0x08000000: 20005000 08000539 080009b1 080009b5 080009b9 080009bd 080009c1 08000e15 
0x08000020: 08000e15 08000e15 08000e15 08000e15 08000e15 08000e15 08000e15 08000e35 
0x08000040: 08000e15 08000e15 08000e15 08000e15 08000e15 08000e15 08000a11 08000a35 
0x08000060: 08000a59 08000a7d 08000aa1 080008f1 08000909 08000921 0800093d 08000959 
&gt; <span class="CodeAnnotation">5</span><b>dump_image firmware-serial.bin 0x08000000 17812 </b>
dumped 17812 bytes in 0.283650s (61.971 KiB/s)</code></pre>
<p>The <code>reset init</code> command <span class="CodeAnnotation">1</span> halts the target and performs a hard reset, executing the <em>reset-init</em> script that is associated with the target device. This script is an event handler that performs tasks like setting up clocks and JTAG clock rates. You can find examples of these handlers if you inspect the <em>openocd/scripts/targets/</em><code/>directory’s <em>.cfg</em> files. The <code>halt</code> command <span class="CodeAnnotation">2</span> sends a halt request for the target to halt and enter debug mode. The <code>flash banks</code> command <span class="CodeAnnotation">3</span> prints a one-line summary of each flash memory area that was specified in the OpenOCD <em>.cfg</em> file (in this case, <em>stm32f1x.cfg</em>). It printed the black pill’s main flash memory, which starts at the address <code>0x08000000</code>.<code/>This step is important, because it can help you identify which segment of memory to dump firmware from.<code/>Note that sometimes the size value isn’t reported correctly. Consulting the datasheets remains the best resource for this step.</p>
<p>We then send the 32-bit memory access command <code>mdw </code><span class="CodeAnnotation">4</span>, starting at that address, to read and display the first 32 bytes of flash memory. Finally, we dump the target’s memory from that address for <code>17812</code> bytes and save it into a file named <em>firmware-serial.bin</em> in our computer’s local directory <span class="CodeAnnotation">5</span>. We got the number 17812 by inspecting the size of the Arduino program file loaded in the flash memory. To do this, issue the following command from the temporary Arduino build directory:</p>
<pre><code>/tmp/arduino_build_336697 $ <b>stat -c '%s' serial-simple.ino.bin </b>
17812</code></pre>
<p><span epub:type="pagebreak" title="183" id="Page_183"/>You can then use tools like colordiff and xxd to see whether there are any differences between the <em>firmware-serial.bin</em> file that we dumped from the flash memory and the <em>serial-simple.ino.bin</em> file that we uploaded through the Arduino IDE. If you dumped the exact number of bytes as the size of the Arduino program, there should be no differences in the output of <code>colordiff</code>:</p>
<pre><code>$ <b>sudo apt install colordiff xxd</b>
$ <b>colordiff -y &lt;(xxd serial-simple.ino.bin) &lt;(xxd firmware-serial.bin) | less</b></code></pre>
<p>We recommend you experiment with more OpenOCD commands; they’re all documented on its website. One useful command to try is the following: </p>
<pre><code><code>&gt; <code class="bold">flash write_image erase custom_firmware.bin 0x08000000</code></code></code></pre>
<p class="BodyFirst">You can use it to flash new firmware.</p>
<h4 id="h3-500907c07-0012">Debugging with GDB</h4>
<p class="BodyFirst">Let’s debug and alter the execution flow of the Arduino program using GDB. With the OpenOCD server already running, we can start a remote GDB session. To help us, we’ll use the <em>Executable and Linkable Format (ELF)</em> file created during the Arduino program compilation. The ELF file format is the standard file format for executable files, object code, shared libraries, and core dumps in Unix-like systems. In this case, it acts as an intermediate file during compilation.</p>
<p>Browse to the temporary directory returned during compilation. Make sure you change the random number part of the directory name to the one that you got from your own Arduino compilation. Then, assuming your Arduino program was named <em>serial-simple, </em>start a remote GDB session using <code>gdb-multiarch</code> with the arguments shown here: </p>
<pre><code>$ <b>cd /tmp/arduino_build_336697/</b>
$ <b>gdb-multiarch </b><b>-q </b><b>--eval-command="target remote localhost:3333" serial-simple.ino.elf</b>
Reading symbols from serial-simple.ino.elf...done.
Remote debugging using localhost:3333
0x08000232 in loop () at /home/ithilgore/Arduino/serial-simple/serial-simple.ino:15
15       <span class="ColorText" style="color:#auto"/><span class="ColorText" style="color:#auto"/>if (start == true) { 
(gdb)</code></pre>
<p>This command will open the GDB session and use the local ELF binary file (called <em>serial-simple.ino.elf</em>) created by Arduino during compilation for debug symbols. <em>Debug symbols</em> are primitive data types that allow debuggers to gain access to information, such as variables and function names, from the binary’s source code. </p>
<p>In that terminal, you can now issue GDB commands. Start by entering the <code>info functions</code> command to verify that the symbols have indeed been loaded:</p>
<pre><code>(gdb) <b>info functions</b>
All defined functions:

<span epub:type="pagebreak" title="184" id="Page_184"/>File /home/ithilgore/Arduino/hardware/Arduino_STM32-master/STM32F1/cores/maple/HardwareSerial.cpp:
HardwareSerial *HardwareSerial::HardwareSerial(usart_dev*, unsigned char, unsigned char);
int HardwareSerial::available();
…
File /home/ithilgore/Arduino/serial-simple/serial-simple.ino:
void loop();
void recv_data();
void setup();
void validate();
…</code></pre>
<p>Now let’s place a breakpoint on the <code>validate()</code> function, because the name implies that it does some sort of checking, which might be related to authentication.</p>
<pre><code>(gdb) <b>b</b><b>reak</b><b> validate</b>
Breakpoint 1 at 0x800015c: file /home/ithilgore/Arduino/serial-simple/serial-simple.ino, line 55.</code></pre>
<p>Because the debugging information recorded in the ELF binary informs GDB about what source files were used to build it, we can use the <code>list</code> command to print parts of the program’s source. You’ll rarely have this convenience in real reverse engineering scenarios, where you’ll have to rely on the <code>disassemble</code> command, which shows the assembly code instead. Here is the output of both commands:</p>
<pre><code> (gdb) <b>l</b><b>ist</b><b> validate</b><b>,</b>
55     void validate() {
56       Serial1.println(buf);
57       new_data = false;
58
59       if (strcmp(buf, "sock-raw.org") == 0)
60         Serial1.println("ACCESS GRANTED");
61       else {
62         Serial1.println("Access Denied.");
63         Serial1.print("Login: ");
64       } 
(gdb) <b>disas</b><b>semble</b><b> validate</b>
Dump of assembler code for function validate():
   0x0800015c &lt;+0&gt;: push   {r3, lr}
   0x0800015e &lt;+2&gt;: ldr    r1, [pc, #56] ; (0x8000198 &lt;validate()+60&gt;)
   0x08000160 &lt;+4&gt;: ldr    r0, [pc, #56] ; (0x800019c &lt;validate()+64&gt;)
   0x08000162 &lt;+6&gt;: bl     0x80006e4 &lt;Print::println(char const*)&gt;
   0x08000166 &lt;+10&gt;: ldr    r3, [pc, #56] ; (0x80001a0 &lt;validate()+68&gt;)
   0x08000168 &lt;+12&gt;: movs   r2, #0
   0x0800016a &lt;+14&gt;: ldr    r0, [pc, #44] ; (0x8000198 &lt;validate()+60&gt;)
   0x0800016c &lt;+16&gt;: ldr    r1, [pc, #52] ; (0x80001a4 &lt;validate()+72&gt;)
   0x0800016e &lt;+18&gt;: strb   r2, [r3, #0]
   0x08000170 &lt;+20&gt;: bl     0x8002de8 &lt;strcmp&gt;
   0x08000174 &lt;+24&gt;: cbnz   r0, 0x8000182 &lt;validate()+38&gt;
   0x08000176 &lt;+26&gt;: ldr    r0, [pc, #36] ; (0x800019c &lt;validate()+64&gt;)
…</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="185" id="Page_185"/><h2><span class="NoteHead">NOTE</span></h2>
<p>You can use shorter versions of many GDB commands, such as<code> l</code> instead of <code>list</code>, <code>disas</code> instead of <code>disassemble</code>, and <code>b</code> instead of <code>break</code>. When you’ve spent enough time in GDB, these shortcuts prove invaluable.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If you have only the assembly code, import the file (in this case <em>serial-simple.ino.elf</em>)<b> </b>into a decompiler like those that Ghidra or IDA Pro provide. This will help you tremendously, because it will translate the assembly code into C, which is much easier to read (<a id="figureanchor7-18" href="#figure7-18">Figure 7-18</a>).</p>
<figure>
<img src="Images/f07018.png" alt="f07018" width="750" height="398"/>
<figcaption><p><a id="figure7-18">Figure 7-18:</a> Using the decompiler in Ghidra to quickly read C code instead of assembly code</p></figcaption>
</figure>
<p>If you have only the <em>hex </em>file (for example, the <em>firmware-serial.bin</em>) as a result of dumping the firmware from the flash memory, you’ll first have to disassemble it using the ARM toolchain like this:</p>
<pre><code>$ <b>arm-none-eabi-objdump -D -b binary -marm -Mforce-thumb firmware-serial.bin &gt; output.s</b></code></pre>
<p>The <em>output.s</em><code/>file will contain the assembly code. </p>
<p>Next, let’s look at how we can bypass our target’s simple authentication process. Allow normal execution of the program to continue by issuing the <code>continue</code> command (or <code>c</code> for short):</p>
<pre><code>(gdb) <b>c</b><b>ontinue</b>
Continuing.</code></pre>
<p>The program is now waiting for serial input. Open the serial monitor from the Arduino IDE like we did on page 180, enter a sample password, like <code>test123</code>, and press <span class="KeyCaps">ENTER</span>. On the GDB terminal, you should see that the breakpoint for the <code>validate</code> function gets triggered. From then on, we’ll make GDB automatically display the next instruction to be executed each time the program stops by issuing the command <code>display/i $pc</code>. Then we’ll <span epub:type="pagebreak" title="186" id="Page_186"/>gradually step one machine instruction at a time using the <code>stepi</code> command until we reach the <code>strcmp</code> call. When we reach the <code>Print::println</code> call, we’ll use the <code>next</code> command to step over it, because it doesn’t concern us in this context (<a id="listinganchor7-2" href="#listing7-2">Listing 7-2</a>).</p>
<pre><code>Breakpoint 1, validate () at /home/ithilgore/Arduino/serial-simple/serial-simple.ino:55
55     void validate() {
(gdb) <b>display/i $pc </b>
1: x/i $pc
=&gt; 0x800015c &lt;validate()&gt;:  push   {r3, lr}
(gdb) <b>stepi</b>
halted: PC: 0x0800015e
56         Serial1.println(buf);
3: x/i $pc
=&gt; 0x800015e &lt;validate()+2&gt;:	ldr    r1, [pc, #56]	; (0x8000198 &lt;validate()+60&gt;)
(gdb) <b>stepi</b>
halted: PC: 0x08000160
0x08000160    56         Serial1.println(buf);
1: x/i $pc
=&gt; 0x8000160 &lt;validate()+4&gt;:	ldr    r0, [pc, #56]	; (0x800019c &lt;validate()+64&gt;)
(gdb) <b>stepi</b>
halted: PC: 0x08000162
0x08000162    56         Serial1.println(buf);
1: x/i $pc
=&gt; 0x8000162 &lt;validate()+6&gt;:	bl     0x80006e4 &lt;Print::println(char const*)&gt;
(gdb) <b>next</b>
halted: PC: 0x080006e4
57         new_data = false;
1: x/i $pc
=&gt; 0x8000166 &lt;validate()+10&gt;:      ldr    r3, [pc, #56]	; (0x80001a0 &lt;validate()+68&gt;)
(gdb) <b>stepi</b>
halted: PC: 0x08000168
0x08000168    57         new_data = false;
1: x/i $pc
=&gt; 0x8000168 &lt;validate()+12&gt;:      movs   r2, #0
(gdb) <b>stepi</b>
halted: PC: 0x0800016a
59	     if (strcmp(buf, "sock-raw.org") == 0)
1: x/i $pc
=&gt; 0x800016a &lt;validate()+14&gt;:ldr    r0, [pc, #44]	; (0x8000198 &lt;validate()+60&gt;)
(gdb) <b>stepi</b>
halted: PC: 0x0800016c
0x0800016c    59         if (strcmp(buf, "sock-raw.org") == 0)
1: x/i $pc
=&gt; 0x800016c &lt;validate()+16&gt;:      ldr    r1, [pc, #52]	; (0x80001a4 &lt;validate()+72&gt;)
(gdb) <b>stepi</b>
halted: PC: 0x0800016e
57          new_data = false;
1: x/i $pc
=&gt; 0x800016e &lt;validate()+18&gt;:	strb	r2, [r3, #0]
(gdb) <b>stepi</b>
halted: PC: 0x08000170
<span epub:type="pagebreak" title="187" id="Page_187"/>59          if (strcmp(buf, "sock-raw.org") == 0)
1: x/i $pc
=&gt; 0x8000170 &lt;validate()+20&gt;:      bl     0x8002de8 &lt;strcmp&gt;
(gdb) <b>x/s $r0</b><b> </b><span class="CodeAnnotation">1</span>
0x200008ae &lt;buf&gt;:    "test123"
(gdb) <b>x/s $r1</b><b> </b><span class="CodeAnnotation">2</span>
0x8003a48:    "sock-raw.org"</code></pre>
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2:</a> Stepping through our program’s validate function in GDB</p>
<p>The last two GDB commands (<code>x/s $r0 </code><span class="CodeAnnotation">1</span> and <code>x/s $r1 </code><span class="CodeAnnotation">2</span>) display the contents of the registers <code>r0</code> and <code>r1</code> as strings. These registers should hold the two arguments passed to the <code>strcmp()</code> Arduino function, because according to the ARM Procedure Call Standard (APCS), the first four arguments of any function are passed in the first four ARM registers <code>r0</code>, <code>r1</code>, <code>r2</code>, <code>r3</code>. That means the <code>r0</code> and <code>r1</code> registers hold the addresses of the string <code>test123 </code>(which we supplied as a password) and the string of the valid password, <code>sock-raw.org</code>, against which it’s compared. You can display all the registers at any time in GDB by issuing the <code>info registers</code> command (or <code>i r</code> for short). </p>
<p>We can now bypass authentication in multiple ways. The easiest way is to set the value of <code>r0</code> to <code>sock-raw.org</code> right before execution reaches the <code>strcmp()</code> call. You can easily do that by issuing the following GDB command:</p>
<pre><code>set $r0=”sock-raw.org” </code></pre>
<p>Alternatively, if we didn’t know the correct passphrase’s string value, we could bypass the authentication by fooling the program into thinking that <code>strcmp()</code> had succeeded. To do that, we’ll change the return value of <code>strcmp()</code> right after it returns. Notice that <code>strcmp()</code> returns 0 if it succeeds. </p>
<p>We can change the return value using the <code>cbnz</code> command, which stands for <em>compare and branch on non-zero</em>. It checks the register in the left operand, and if it’s not zero, <em>branches</em>, or jumps, to the destination referenced in the right operand. In this case, the register is <code>r0</code> and it holds the return value of <code>strcmp()</code>:</p>
<pre><code>   0x08000170<span class="ColorText" style="color:#auto"/><span class="ColorText" style="color:#auto"/> &lt;+20&gt;:	bl     0x8002de8 &lt;strcmp&gt;
   0x08000174 &lt;+24&gt;:	cbnz   r0, 0x8000182 &lt;validate()+38&gt;</code></pre>
<p>Now we’ll step inside the <code>strcmp()</code> function by issuing another <code>stepi</code> when we reach it. Then we can step out of it by issuing a <code>finish</code> command. Immediately before the <code>cbnz</code> command executes, we’ll change the <code>r0</code> value to <code>0</code>, which indicates that <code>strcmp()</code> was successful:</p>
<pre><code>(gdb<span class="ColorText" style="color:#auto"/><span class="ColorText" style="color:#auto"/>) <b>stepi</b>
halted: PC: 0x08002de8
0x08002de8 in strcmp ()
3: x/i $pc
=&gt; 0x8002de8 &lt;strcmp&gt;:      orr.w  r12, r0, r1

(gdb) <b>finish</b>
<span epub:type="pagebreak" title="188" id="Page_188"/>Run till exit from #0  0x08002de8 in strcmp ()
0x08000174 in validate () at /home/ithilgore/Arduino/serial-simple/serial-simple.ino:59
59	    if (strcmp(buf, "sock-raw.org") == 0)
3: x/i $pc
=&gt; 0x8000174 &lt;validate()+24&gt;:      cbnz   r0, 0x8000182 &lt;validate()+38&gt;
(gdb) <b>set $r0=0</b>
(gdb) <b>x/x $r0</b>
0x0:   0x00
(gdb) <b>c</b>
Continuing.</code></pre>
<p>When we do this, our program won’t branch to the memory address 0x8000182. Instead, it will continue by executing the instructions immediately after <code>cbnz</code>. If you now let the rest of the program run by issuing a <code>continue</code> command, you’ll see an <code>ACCESS GRANTED</code> message in the Arduino serial monitor, indicating that you successfully hacked the program! </p>
<p>There are even more ways to hack the program, but we’ll leave such experimentation as an exercise for you. </p>
<h2 id="h1-500907c07-0004">Conclusion</h2>
<p class="BodyFirst">In this chapter, you learned how UART, JTAG, and SWD work and how you can exploit these protocols to gain complete access to a device. Most of the chapter walked through a practical exercise that used an STM32F103C8T6 (black pill) microcontroller as a target device. You learned how to code and flash a simple Arduino program that performs a very basic authentication routine through UART. Then you interfaced with the device using a USB-to-serial adapter. We leveraged an ST-Link programmer to access SWD on the target through OpenOCD and, finally, we used GDB to dynamically bypass the authentication function. </p>
<p>Exploiting UART—and especially JTAG and SWD—almost always means that you can gain complete access to the device, because these interfaces were designed to give manufacturers full debugging privileges for testing purposes. Learn how to leverage them to their fullest potential and your IoT hacking journey will become much more productive! </p>
</section>
</div></body></html>