<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_295"/><span class="big">13</span><br/>HIDING DATA WITH STEGANOGRAPHY</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">The word <em>steganography</em> is a combination of the Greek words <em>steganos</em>, which means to cover, conceal, or protect, and <em>graphien</em>, which means to write. In security, <em>steganography</em> refers to techniques and procedures used to obfuscate (or hide) data by implanting it within other data, such as an image, so it can be extracted at a future point in time. As part of the security community, you’ll explore this practice on a routine basis by hiding payloads that you’ll recover after they are delivered to the target.</p>&#13;
<p class="indent">In this chapter, you’ll implant data within a Portable Network Graphics (PNG) image. You’ll first explore the PNG format and learn how to read PNG data. You’ll then implant your own data into the existing image. Finally, you’ll explore XOR, a method for encrypting and decrypting your implanted data.</p>&#13;
<h3 class="h3" id="ch13lev1sec1"><span epub:type="pagebreak" id="page_296"/>Exploring the PNG Format</h3>&#13;
<p class="noindent">Let’s start by reviewing the PNG specification, which will help you understand the PNG image format and how to implant data into a file. You can find its technical specification at <a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html"><em>http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html</em></a>. It provides details about the byte format of a binary PNG image file, which is made up of repetitive byte chunks.</p>&#13;
<p class="indent">Open a PNG file within a hex editor and navigate through each of the relevant byte chunk components to see what each does. We’re using the native hexdump hex editor on Linux, but any hex editor should work. You can find the sample image that we’ll open at <a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/images/battlecat.png"><em>https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/images/battlecat.png</em></a>; however, all valid PNG images will follow the same format.</p>&#13;
<h4 class="h4" id="ch13lev2sec1">The Header</h4>&#13;
<p class="noindent">The first 8 bytes of the image file, <span class="literal">89 50 4e 47 0d 0a 1a 0a</span>, highlighted in <a href="ch13.xhtml#ch13fig1">Figure 13-1</a>, are called the <em>header</em>.</p>&#13;
<div class="image"><img src="Images/13fig01.jpg" alt="Image" width="926" height="217"/></div>&#13;
<p class="figcap" id="ch13fig1"><em>Figure 13-1: The PNG file’s header</em></p>&#13;
<p class="indent">The second, third, and fourth hex values literally read <span class="literal">PNG</span> when converted to ASCII. The arbitrary trailing bytes consist of both DOS and Unix Carriage-Return Line Feed (CRLF). This specific header sequence, referred to as a file’s <em>magic bytes</em>, will be identical in every valid PNG file. The variations in content occur in the remaining chunks, as you’ll soon see.</p>&#13;
<p class="indent">As we work through this spec, let’s start to build a representation of the PNG format in Go. It’ll help us expedite our end goal of embedding payloads. Since the header is 8 bytes long, it can be packed into a <span class="literal">uint64</span> data type, so let’s go ahead and build a struct called <span class="literal">Header</span> that will hold the value (<a href="ch13.xhtml#ch13list1">Listing 13-1</a>). (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.)</p>&#13;
<pre>//Header holds the first UINT64 (Magic Bytes)&#13;
type Header struct {&#13;
    Header uint64&#13;
}</pre>&#13;
<p class="caption" id="ch13list1"><em>Listing 13-1: Header struct definition (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<h4 class="h4" id="ch13lev2sec2"><span epub:type="pagebreak" id="page_297"/>The Chunk Sequence</h4>&#13;
<p class="noindent">The remainder of the PNG file, shown in <a href="ch13.xhtml#ch13fig2">Figure 13-2</a>, is composed of repeating byte chunks that follow this pattern: <span class="literal">SIZE</span> (4 bytes), <span class="literal">TYPE</span> (4 bytes), <span class="literal">DATA</span> (any number of bytes), and <span class="literal">CRC</span> (4 bytes).</p>&#13;
<div class="image"><img src="Images/13fig02.jpg" alt="Image" width="926" height="215"/></div>&#13;
<p class="figcap" id="ch13fig2"><em>Figure 13-2: The pattern of the chunks used for the remainder of the image data</em></p>&#13;
<p class="indent">Reviewing the hex dump in further detail, you can see that the first chunk—the <span class="literal">SIZE</span> chunk—consists of bytes <span class="literal">0x00 0x00 0x00 0x0d</span>. This chunk defines the length of the <span class="literal">DATA</span> chunk that’ll follow. The hexadecimal conversion to ASCII is 13—so this chunk dictates that the <span class="literal">DATA</span> chunk will consist of 13 bytes. The <span class="literal">TYPE</span> chunk’s bytes, <span class="literal">0x49 0x48 0x44 0x52</span>, convert to an ASCII value of <span class="literal">IHDR</span> in this case. The PNG spec defines various valid types. Some of these types, such as <span class="literal">IHDR</span>, are used to define image metadata or signal the end of an image data stream. Other types, specifically the <span class="literal">IDAT</span> type, contain the actual image bytes.</p>&#13;
<p class="indent">Next is the <span class="literal">DATA</span> chunk, whose length is defined by the <span class="literal">SIZE</span> chunk. Finally, the <span class="literal">CRC</span> chunk concludes the overall chunk segment. It consists of a CRC-32 checksum of the combined <span class="literal">TYPE</span> and <span class="literal">DATA</span> bytes. This particular <span class="literal">CRC</span> chunk’s bytes are <span class="literal">0x9a 0x76 0x82 0x70</span>. This format repeats itself throughout the entire image file until you reach an End of File (EOF) state, indicated by the chunk of type <span class="literal">IEND</span>.</p>&#13;
<p class="indent">Just as you did with the <span class="literal">Header</span> struct in <a href="ch13.xhtml#ch13list1">Listing 13-1</a>, build a struct to hold the values of a single chunk, as defined in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>.</p>&#13;
<pre>//Chunk represents a data byte chunk segment&#13;
type Chunk struct {&#13;
    Size uint32&#13;
    Type uint32&#13;
    Data []byte&#13;
    CRC  uint32&#13;
}</pre>&#13;
<p class="caption" id="ch13list2"><em>Listing 13-2: Chunk struct definition (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<h3 class="h3" id="ch13lev1sec2"><span epub:type="pagebreak" id="page_298"/>Reading Image Byte Data</h3>&#13;
<p class="noindent">The Go language handles binary data reads and writes with relative ease, thanks in part to the <span class="literal">binary</span> package (which you may remember from <a href="ch06.xhtml#ch6">Chapter 6</a>), but before you can parse PNG data, you’ll need to open a file for reading. Let’s create a <span class="literal">PreProcessImage()</span> function that will consume a file handle of type <span class="literal">*os.File</span> and return a type of <span class="literal">*bytes.Reader</span> (<a href="ch13.xhtml#ch13list3">Listing 13-3</a>).</p>&#13;
<pre>//PreProcessImage reads to buffer from file handle&#13;
func PreProcessImage(dat *os.File) (*bytes.Reader, error) {&#13;
 <span class="ent">❶</span> stats, err := dat.Stat()&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
 <span class="ent">❷</span> var size = stats.Size()&#13;
    b := make([]byte, size)&#13;
&#13;
 <span class="ent">❸</span> bufR := bufio.NewReader(dat)&#13;
    _, err = bufR.Read(b)&#13;
    bReader := bytes.NewReader(b)&#13;
&#13;
    return bReader, err&#13;
}</pre>&#13;
<p class="caption" id="ch13list3"><em>Listing 13-3: The</em> <span class="codeitalic">PreProcessImage()</span> <em>function definition (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/reader.go">/ch-13/imgInject/utils/reader.go</a><em>)</em></p>&#13;
<p class="indent">The function opens a file object in order to obtain a <span class="literal">FileInfo</span> structure <span class="ent">❶</span> used to grab size information <span class="ent">❷</span>. Immediately following are a couple of lines of code used to instantiate a <span class="literal">Reader</span> instance via <span class="literal">bufio.NewReader()</span> and then a <span class="literal">*bytes.Reader</span> instance via a call to <span class="literal">bytes.NewReader()</span> <span class="ent">❸</span>. The function returns a <span class="literal">*bytes.Reader</span>, which positions you to start using the <span class="literal">binary</span> package to read byte data. You’ll first read the header data and then read the chunk sequence.</p>&#13;
<h4 class="h4" id="ch13lev2sec3">Reading the Header Data</h4>&#13;
<p class="noindent">To validate that the file is actually a PNG file, use the first 8 bytes, which define a PNG file, to build the <span class="literal">validate()</span> method (<a href="ch13.xhtml#ch13list4">Listing 13-4</a>).</p>&#13;
<pre>func (mc *MetaChunk) validate(b *bytes.Reader) {&#13;
    var header Header&#13;
&#13;
    if err := binary.Read(b, binary.BigEndian, &amp;header.Header)<span class="ent">❶</span>; err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    bArr := make([]byte, 8)&#13;
    binary.BigEndian.PutUint64(bArr, header.Header)<span class="ent">❷</span>&#13;
&#13;
    if string(bArr[1:4])<span class="ent">❸</span> != "PNG" {&#13;
        log.Fatal("Provided file is not a valid PNG format")&#13;
<span epub:type="pagebreak" id="page_299"/>    } else {&#13;
        fmt.Println("Valid PNG so let us continue!")&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch13list4"><em>Listing 13-4: Validating that the file is a PNG file (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<p class="indent">Although this method may not seem overly complex, it introduces a couple of new items. The first, and the most obvious one, is the <span class="literal">binary.Read()</span> function <span class="ent">❶</span> that copies the first 8 bytes from the <span class="literal">bytes.Reader</span> into the <span class="literal">Header</span> struct value. Recall that you declared the <span class="literal">Header</span> struct field as type <span class="literal">uint64</span> (<a href="ch13.xhtml#ch13list1">Listing 13-1</a>), which is equivalent to 8 bytes. It’s also noteworthy that the <span class="literal">binary</span> package provides methods to read <span class="literal">Most Significant Bit</span> and <span class="literal">Least Significant Bit</span> formats via <span class="literal">binary.BigEndian</span> and <span class="literal">binary.LittleEndian</span>, respectively <span class="ent">❷</span>. These functions can also be quite helpful when you’re performing binary writes; for example, you could select <span class="literal">BigEndian</span> to place bytes on the wire dictating the use of network byte ordering.</p>&#13;
<p class="indent">The binary endianness function also contains the methods that facilitate the marshaling of data types to a literal data type (such as <span class="literal">uint64</span>). Here, you’re creating a byte array of length 8 and performing a binary read necessary to copy the data into a <span class="literal">unit64</span> data type. You can then convert the bytes to their string representations and use slicing and a simple string comparison to validate that bytes 1 through 4 produce PNG, indicating that you have a valid image file format <span class="ent">❸</span>.</p>&#13;
<p class="indent">To improve the process of checking that a file is a PNG file, we encourage you to look at the Go <span class="literal">bytes</span> package, as it contains convenience functions that you could use as a shortcut to compare a file header with the PNG magic byte sequence we mentioned earlier. We’ll let you explore this on your own.</p>&#13;
<h4 class="h4" id="ch13lev2sec4">Reading the Chunk Sequence</h4>&#13;
<p class="noindent">Once you validated that your file is a PNG image, you can write the code that reads the chunk sequence. The header will occur only once in a PNG file, whereas the chunk sequence will repeat the <span class="literal">SIZE</span>, <span class="literal">TYPE</span>, <span class="literal">DATA</span>, and <span class="literal">CRC</span> chunks until it reaches the EOF. Therefore, you need to be able to accommodate this repetition, which you can do most conveniently by using a Go conditional loop. With this in mind, let’s build out a <span class="literal">ProcessImage()</span> method, which iteratively processes all the data chunks up to the end of file (<a href="ch13.xhtml#ch13list5">Listing 13-5</a>).</p>&#13;
<pre>func (mc *MetaChunk) ProcessImage(b *bytes.Reader, c *models.CmdLineOpts)<span class="ent">❶</span> {&#13;
// Snip code for brevity (Only displaying relevant lines from code block)&#13;
      count := 1 //Start at 1 because 0 is reserved for magic byte&#13;
    <span class="ent">❷</span> chunkType := ""&#13;
    <span class="ent">❸</span> endChunkType := "IEND" //The last TYPE prior to EOF&#13;
    <span class="ent">❹</span> for chunkType != endChunkType {&#13;
          fmt.Println("---- Chunk # " + strconv.Itoa(count) + " ----")&#13;
          offset := chk.getOffset(b)&#13;
          fmt.Printf("Chunk Offset: %#02x\n", offset)&#13;
          chk.readChunk(b)&#13;
<span epub:type="pagebreak" id="page_300"/>          chunkType = chk.chunkTypeToString()&#13;
          count++&#13;
      }&#13;
}</pre>&#13;
<p class="caption" id="ch13list5"><em>Listing 13-5: The</em> <span class="codeitalic">ProcessImage()</span> <em>method (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<p class="indent">You first pass a reference to a <span class="literal">bytes.Reader</span> memory address pointer (<span class="literal">*bytes.Reader</span>) as an argument to <span class="literal">ProcessImage()</span> <span class="ent">❶</span>. The <span class="literal">validate()</span> method (<a href="ch13.xhtml#ch13list4">Listing 13-4</a>) you just created also took a reference to a <span class="literal">bytes.Reader</span> pointer. As convention dictates, multiple references to the same memory address pointer location will inherently allow mutable access to the referenced data. This essentially means that as you pass your <span class="literal">bytes.Reader</span> reference as an argument to <span class="literal">ProcessImage()</span>, the reader will have already advanced 8 bytes as a result of the size of the <span class="literal">Header</span> because you’re accessing the same instance of <span class="literal">bytes.Reader</span>.</p>&#13;
<p class="indent">Alternatively, had you not passed a pointer, the <span class="literal">bytes.Reader</span> would have either been a copy of the same PNG image data or separate unique instance data. That’s because advancing the pointer when you read the header would not have advanced the reader appropriately elsewhere. You want to avoid taking this approach. For one, passing around multiple copies of data when unnecessary is simply bad convention. More importantly, each time a copy is passed, it is positioned at the start of the file, forcing you to programmatically define and manage its position in the file prior to reading a chunk sequence.</p>&#13;
<p class="indent">As you progress through the block of code, you define a <span class="literal">count</span> variable to track how many chunk segments the image file contains. The <span class="literal">chunkType</span> <span class="ent">❷</span> and <span class="literal">endChunkType</span> <span class="ent">❸</span> are used as part of the comparative logic, which evaluates the current <span class="literal">chunkType</span> to <span class="literal">endChunkType</span>’s <span class="literal">IEND</span> value designating an EOF condition <span class="ent">❹</span>.</p>&#13;
<p class="indent">It would be nice to know where each chunk segment starts—or rather, each chunk’s absolute position within the file byte construct, a value known as the <em>offset</em>. If you know the offset value, it will be much easier to implant a payload into the file. For example, you can give a collection of offset locations to a <em>decoder</em>—a separate function that collects the bytes at each known offset—that then unwinds them into your intended payload. To get the offsets of each chunk, you’ll call the <span class="literal">mc.getOffset(b)</span> method (<a href="ch13.xhtml#ch13list6">Listing 13-6</a>).</p>&#13;
<pre>func (mc *MetaChunk) getOffset(b *bytes.Reader) {&#13;
    offset, _ := b.Seek(0, 1)<span class="ent">❶</span>&#13;
    mc.Offset = offset&#13;
}</pre>&#13;
<p class="caption" id="ch13list6"><em>Listing 13-6: The</em> <span class="codeitalic">getOffset()</span> <em>method (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<p class="indent">The <span class="literal">bytes.Reader</span> contains a <span class="literal">Seek()</span> method that makes deriving the current position quite simple. The <span class="literal">Seek()</span> method moves the current read or write offset and then returns the new offset relative to the start of the file. <span epub:type="pagebreak" id="page_301"/>Its first argument is the number of bytes by which you want to move the offset and its second argument defines the position from which the move will occur. The second argument’s optional values are <span class="literal">0</span> (Start of File), <span class="literal">1</span> (Current Position), and <span class="literal">2</span> (End of File). For example, if you wanted to shift 8 bytes to the left from your current position, you would use <span class="literal">b.Seek(-8,1)</span>.</p>&#13;
<p class="indent">Here, <span class="literal">b.Seek(0,1)</span> <span class="ent">❶</span> states that you want to move your offset 0 bytes from the current position, so it simply returns the current offset: essentially retrieving the offset without moving it.</p>&#13;
<p class="indent">The next methods we detail define how you read the actual chunk segment bytes. To make things a bit more legible, let’s create a <span class="literal">readChunk()</span> method and then create separate methods for reading each chunk subfield (<a href="ch13.xhtml#ch13list7">Listing 13-7</a>).</p>&#13;
<pre>func (mc *MetaChunk) readChunk(b *bytes.Reader) {&#13;
    mc.readChunkSize(b)&#13;
    mc.readChunkType(b)&#13;
    mc.readChunkBytes(b, mc.Chk.Size) <span class="ent">❶</span>&#13;
    mc.readChunkCRC(b)&#13;
}&#13;
func (mc *MetaChunk) readChunkSize(b *bytes.Reader) {&#13;
    if err := binary.Read(b, binary.BigEndian, &amp;mc.Chk.Size); err != nil { <span class="ent">❷</span>&#13;
        log.Fatal(err)&#13;
    }&#13;
}&#13;
func (mc *MetaChunk) readChunkType(b *bytes.Reader) {&#13;
    if err := binary.Read(b, binary.BigEndian, &amp;mc.Chk.Type); err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
}&#13;
func (mc *MetaChunk) readChunkBytes(b *bytes.Reader, cLen uint32) {&#13;
    mc.Chk.Data = make([]byte, cLen) <span class="ent">❸</span>&#13;
    if err := binary.Read(b, binary.BigEndian, &amp;mc.Chk.Data); err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
}&#13;
func (mc *MetaChunk) readChunkCRC(b *bytes.Reader) {&#13;
    if err := binary.Read(b, binary.BigEndian, &amp;mc.Chk.CRC); err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch13list7"><em>Listing 13-7: Chunk-reading methods (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<p class="indent">The methods <span class="literal">readChunkSize()</span>, <span class="literal">readChunkType()</span>, and <span class="literal">readChunkCRC()</span> are all similar. Each reads a <span class="literal">uint32</span> value into the respective field of the <span class="literal">Chunk</span> struct. However, <span class="literal">readChunkBytes()</span> is a bit of an anomaly. Because the image data is of variable length, we’ll need to supply this length to the <span class="literal">readChunkBytes()</span> function so that it knows how many bytes to read <span class="ent">❶</span>. Recall that the data length is maintained in the <span class="literal">SIZE</span> subfield of the chunk. You identify the <span class="literal">SIZE</span> value <span class="ent">❷</span> and pass it as an argument to <span class="literal">readChunkBytes()</span> to define a slice of <span epub:type="pagebreak" id="page_302"/>proper size <span class="ent">❸</span>. Only then can the byte data be read into the struct’s <span class="literal">Data</span> field. That’s about it for reading the data, so let’s press on and explore writing byte data.</p>&#13;
<h3 class="h3" id="ch13lev1sec3">Writing Image Byte Data to Implant a Payload</h3>&#13;
<p class="noindent">Although you can choose from many complex steganography techniques to implant payloads, in this section we’ll focus on a method of writing to a certain byte offset. The PNG file format defines <em>critical</em> and <em>ancillary</em> chunk segments within the specification. The critical chunks are necessary for the image decoder to process the image. The ancillary chunks are optional and provide various pieces of metadata that are not critical to encoding or decoding, such as timestamps and text.</p>&#13;
<p class="indent">Therefore, the ancillary chunk type provides an ideal location to either overwrite an existing chunk or insert a new chunk. Here, we’ll show you how to insert new byte slices into an ancillary chunk segment.</p>&#13;
<h4 class="h4" id="ch13lev2sec5">Locating a Chunk Offset</h4>&#13;
<p class="noindent">First, you need to identify an adequate offset somewhere in the ancillary data. You can spot ancillary chunks because they always start with lowercase letters. Let’s use the hex editor once again and open up the original PNG file while advancing to the end of the hex dump.</p>&#13;
<p class="indent">Every valid PNG image will have an <span class="literal">IEND</span> chunk type indicating the final chunk of the file (the <span class="literal">EOF</span> chunk). Moving to the 4 bytes that come before the final <span class="literal">SIZE</span> chunk will position you at the starting offset of the <span class="literal">IEND</span> chunk and the last of the arbitrary (critical or ancillary) chunks contained within the overall PNG file. Recall that ancillary chunks are optional, so it’s possible that the file you’re inspecting as you follow along won’t have the same ancillary chunks, or any for that matter. In our example, the offset to the <span class="literal">IEND</span> chunk begins at byte offset <span class="literal">0x85258</span> (<a href="ch13.xhtml#ch13fig3">Figure 13-3</a>).</p>&#13;
<div class="image"><img src="Images/13fig03.jpg" alt="Image" width="926" height="199"/></div>&#13;
<p class="figcap" id="ch13fig3"><em>Figure 13-3: Identifying a chunk offset relative to the <span class="codeitalic">IEND</span> position</em></p>&#13;
<h4 class="h4" id="ch13lev2sec6">Writing Bytes with the ProcessImage() Method</h4>&#13;
<p class="noindent">A standard approach to writing ordered bytes into a byte stream is to use a Go struct. Let’s revisit another section of the <span class="literal">ProcessImage()</span> method we started building in <a href="ch13.xhtml#ch13list5">Listing 13-5</a> and walk through the details. The code in <a href="ch13.xhtml#ch13list8">Listing 13-8</a> calls individual functions that you’ll build out as you progress through this section.</p>&#13;
<pre><span epub:type="pagebreak" id="page_303"/>func (mc *MetaChunk) ProcessImage(b *bytes.Reader, c *models.CmdLineOpts) <span class="ent">❶</span> {&#13;
    <span class="codeitalic1">--snip--</span>&#13;
  <span class="ent">❷</span> var m MetaChunk&#13;
  <span class="ent">❸</span> m.Chk.Data = []byte(c.Payload)&#13;
    m.Chk.Type = m.strToInt(c.Type)<span class="ent">❹</span>&#13;
    m.Chk.Size = m.createChunkSize()<span class="ent">❺</span>&#13;
    m.Chk.CRC = m.createChunkCRC()<span class="ent">❻</span>&#13;
    bm := m.marshalData()<span class="ent">❼</span>&#13;
    bmb := bm.Bytes()&#13;
    fmt.Printf("Payload Original: % X\n", []byte(c.Payload))&#13;
    fmt.Printf("Payload: % X\n", m.Chk.Data)&#13;
  <span class="ent">❽</span> utils.WriteData(b, c, bmb)&#13;
}</pre>&#13;
<p class="caption" id="ch13list8"><em>Listing 13-8: Writing bytes with the</em> <span class="literal">ProcessImage()</span> <em>method (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib /commands.go</a><em>)</em></p>&#13;
<p class="indent">This method takes a <span class="literal">byte.Reader</span> and another struct, <span class="literal">models.CmdLineOpts</span>, as arguments <span class="ent">❶</span>. The <span class="literal">CmdLineOpts</span> struct, shown in <a href="ch13.xhtml#ch13list9">Listing 13-9</a>, contains flag values passed in via the command line. We’ll use these flags to determine what payload to use and where to insert it in the image data. Since the bytes you’ll write follow the same structured format as those read from preexisting chunk segments, you can just create a new <span class="literal">MetaChunk</span> struct instance <span class="ent">❷</span> that will accept your new chunk segment values.</p>&#13;
<p class="indent">The next step is to read the payload into a byte slice <span class="ent">❸</span>. However, you’ll need additional functionality to coerce the literal flag values into a usable byte array. Let’s dive into the details of the <span class="literal">strToInt()</span> <span class="ent">❹</span>, <span class="literal">createChunkSize()</span> <span class="ent">❺</span>, <span class="literal">createChunkCRC()</span> <span class="ent">❻</span>, <span class="literal">MarshalData()</span> <span class="ent">❼</span>, and <span class="literal">WriteData()</span> <span class="ent">❽</span> methods.</p>&#13;
<pre>package models&#13;
&#13;
//CmdLineOpts represents the cli arguments&#13;
type CmdLineOpts struct {&#13;
    Input    string&#13;
    Output   string&#13;
    Meta     bool&#13;
    Suppress bool&#13;
    Offset   string&#13;
    Inject   bool&#13;
    Payload  string&#13;
    Type     string&#13;
    Encode   bool&#13;
    Decode   bool&#13;
    Key      string&#13;
}</pre>&#13;
<p class="caption" id="ch13list9"><em>Listing 13-9: The</em> <span class="codeitalic">CmdLineOpts</span> <em>struct (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/models/opts.go">/ch-13/imgInject/models/opts.go</a><em>)</em></p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_304"/>The strToInt() Method</h5>&#13;
<p class="noindent">We’ll start with the <span class="literal">strToInt()</span> method (<a href="ch13.xhtml#ch13list10">Listing 13-10</a>).</p>&#13;
<pre>func (mc *MetaChunk) strToInt(s string)<span class="ent">❶</span> uint32 {&#13;
    t := []byte(s)&#13;
 <span class="ent">❷</span> return binary.BigEndian.Uint32(t)&#13;
}</pre>&#13;
<p class="caption" id="ch13list10"><em>Listing 13-10: The</em> <span class="codeitalic">strToInt()</span> <em>method (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<p class="indent">The <span class="literal">strToInt()</span> method is a helper that consumes a <span class="literal">string</span> <span class="ent">❶</span> as an argument and returns <span class="literal">uint32</span> <span class="ent">❷</span>, which is the necessary data type for your <span class="literal">Chunk</span> struct <span class="literal">TYPE</span> value.</p>&#13;
<h5 class="h5">The createChunkSize() Method</h5>&#13;
<p class="noindent">Next, you use the <span class="literal">createChunkSize()</span> method to assign the <span class="literal">Chunk</span> struct <span class="literal">SIZE</span> value (<a href="ch13.xhtml#ch13list11">Listing 13-11</a>).</p>&#13;
<pre>func (mc *MetaChunk) createChunkSize() uint32 {&#13;
        return uint32(len(mc.Chk.Data)<span class="ent">❷</span>)<span class="ent">❶</span>&#13;
}</pre>&#13;
<p class="caption" id="ch13list11"><em>Listing 13-11: The</em> <span class="codeitalic">createChunkSize()</span> <em>method (</em>/<a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<p class="indent">This method will obtain the length of the <span class="literal">chk.DATA</span> byte array <span class="ent">❷</span> and type-convert it to a <span class="literal">uint32</span> value <span class="ent">❶</span>.</p>&#13;
<h5 class="h5">The createChunkCRC() Method</h5>&#13;
<p class="noindent">Recall that the CRC checksum for each chunk segment comprises both the <span class="literal">TYPE</span> and <span class="literal">DATA</span> bytes. You’ll use the <span class="literal">createChunkCRC()</span> method to calculate this checksum. The method leverages Go’s <span class="literal">hash/crc32</span> package (<a href="ch13.xhtml#ch13list12">Listing 13-12</a>).</p>&#13;
<pre>func (mc *MetaChunk) createChunkCRC() uint32 {&#13;
    bytesMSB := new(bytes.Buffer) <span class="ent">❶</span>&#13;
    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.Type); err != nil { <span class="ent">❷</span>&#13;
    log.Fatal(err)&#13;
    }&#13;
    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.Data); err != nil { <span class="ent">❸</span>&#13;
        log.Fatal(err)&#13;
    }&#13;
    return crc32.ChecksumIEEE(bytesMSB.Bytes()) <span class="ent">❹</span>&#13;
}</pre>&#13;
<p class="caption" id="ch13list12"><em>Listing 13-12: The</em> <span class="codeitalic">createChunkCRC()</span> <em>method (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<p class="indent">Prior to arriving at the <span class="literal">return</span> statement, you declare a <span class="literal">bytes.Buffer</span> <span class="ent">❶</span> and write both the <span class="literal">TYPE</span> <span class="ent">❷</span> and <span class="literal">DATA</span> <span class="ent">❸</span> bytes into it. The byte slice from the buffer is then passed as an argument to the <span class="literal">ChecksumIEEE</span>, and the CRC-32 <span epub:type="pagebreak" id="page_305"/>checksum value is returned as a <span class="literal">uint32</span> data type. The <span class="literal">return</span> statement <span class="ent">❹</span> is doing all the heavy lifting here, actually calculating the checksum on the necessary bytes.</p>&#13;
<h5 class="h5">The marshalData() Method</h5>&#13;
<p class="noindent">All necessary pieces of a chunk are assigned to their respective struct fields, which can now be marshaled into a <span class="literal">bytes.Buffer</span>. This buffer will provide the raw bytes of the custom chunk that are to be inserted into the new image file. <a href="ch13.xhtml#ch13list13">Listing 13-13</a> shows what the <span class="literal">marshalData()</span> method looks like.</p>&#13;
<pre>func (mc *MetaChunk) marshalData() *bytes.Buffer {&#13;
    bytesMSB := new(bytes.Buffer) <span class="ent">❶</span>&#13;
    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.Size); err != nil { <span class="ent">❷</span>&#13;
        log.Fatal(err)&#13;
    }&#13;
    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.Type); err != nil { <span class="ent">❸</span>&#13;
        log.Fatal(err)&#13;
    }&#13;
    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.Data); err != nil { <span class="ent">❹</span>&#13;
        log.Fatal(err)&#13;
    }&#13;
    if err := binary.Write(bytesMSB, binary.BigEndian, mc.Chk.CRC); err != nil { <span class="ent">❺</span>&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    return bytesMSB&#13;
}</pre>&#13;
<p class="caption" id="ch13list13"><em>Listing 13-13: The</em> <span class="codeitalic">marshalData()</span> <em>method (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<p class="indent">The <span class="literal">marshalData()</span> method declares a <span class="literal">bytes.Buffer</span> <span class="ent">❶</span> and writes the chunk information to it, including the size <span class="ent">❷</span>, type <span class="ent">❸</span>, data <span class="ent">❹</span>, and checksum <span class="ent">❺</span>. The method returns all the chunk segment data into a single consolidated <span class="literal">bytes.Buffer</span>.</p>&#13;
<h5 class="h5">The WriteData() Function</h5>&#13;
<p class="noindent">Now all you have left to do is to write your new chunk segment bytes into the offset of the original PNG image file. Let’s have a peek at the <span class="literal">WriteData()</span> function, which exists in a package we created named <span class="literal">utils</span> (<a href="ch13.xhtml#ch13list14">Listing 13-14</a>).</p>&#13;
<pre>//WriteData writes new Chunk data to offset&#13;
func WriteData(r *bytes.Reader<span class="ent">❶</span>, c *models.CmdLineOpts<span class="ent">❷</span>, b []byte<span class="ent">❸</span>) {&#13;
  <span class="ent">❹</span> offset, _ := strconv.ParseInt(c.Offset, 10, 64)&#13;
  <span class="ent">❺</span> w, err := os.Create(c.Output)&#13;
     if err != nil {&#13;
         log.Fatal("Fatal: Problem writing to the output file!")&#13;
     }&#13;
     defer w.Close()&#13;
  <span class="ent">❻</span> r.Seek(0, 0)&#13;
<span epub:type="pagebreak" id="page_306"/>  <span class="ent">❼</span> var buff = make([]byte, offset)&#13;
     r.Read(buff)&#13;
  <span class="ent">❽</span> w.Write(buff)&#13;
  <span class="ent">❾</span> w.Write(b)&#13;
&#13;
  <span class="ent">❿</span> _, err = io.Copy(w, r)&#13;
     if err == nil {&#13;
         fmt.Printf("Success: %s created\n", c.Output)&#13;
     }&#13;
}</pre>&#13;
<p class="caption" id="ch13list14"><em>Listing 13-14: The</em> <span class="codeitalic">WriteData()</span> <em>function (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/writer.go">/ch-13/imgInject/utils/writer.go</a><em>)</em></p>&#13;
<p class="indent">The <span class="literal">WriteData()</span> function consumes a <span class="literal">bytes.Reader</span> <span class="ent">❶</span> containing the original image file byte data, a <span class="literal">models.CmdLineOpts</span> <span class="ent">❷</span> struct inclusive of the command line argument values, and a <span class="literal">byte</span> slice <span class="ent">❸</span> holding the new chunk byte segment. The code block starts with a <span class="literal">string</span>-to-<span class="literal">int64</span> conversion <span class="ent">❹</span> in order to obtain the offset value from the <span class="literal">models.CmdLineOpts</span> struct; this will help you write your new chunk segment to a specific location without corrupting other chunks. You then create a file handle <span class="ent">❺</span> so that the newly modified PNG image can be written to disk.</p>&#13;
<p class="indent">You use the <span class="literal">r.Seek(0,0)</span> function call <span class="ent">❻</span> to rewind to the absolute beginning of the <span class="literal">bytes.Reader</span>. Recall that the first 8 bytes are reserved for the PNG header, so it’s important that the new output PNG image include these header bytes as well. You include them by instantiating a byte slice with a length determined by the <span class="literal">offset</span> value <span class="ent">❼</span>. You then read that number of bytes from the original image and write those same bytes to your new image file <span class="ent">❽</span>. You now have identical headers in both the original and new images.</p>&#13;
<p class="indent">You then write the new chunk segment bytes <span class="ent">❾</span> into the new image file. Finally, you append the remainder of the <span class="literal">bytes.Reader</span> bytes <span class="ent">❿</span> (that is, the chunk segment bytes from your original image) to the new image file. Recall that <span class="literal">bytes.Reader</span> has advanced to the offset location, because of the earlier read into a byte slice, which contains bytes from the offset to the EOF. You’re left with a new image file. Your new file has identical leading and trailing chunks as the original image, but it also contains your payload, injected as a new ancillary chunk.</p>&#13;
<p class="indent">To help visualize a working representation of what you built so far, reference the overall working project code at <em><a href="https://github.com/blackhat-go/bhg/tree/master/ch-13/imgInject">https://github.com/blackhat-go/bhg/tree/master/ch-13/imgInject/</a></em>. The <span class="literal">imgInject</span> program consumes command line arguments containing values for the original PNG image file, an offset location, an arbitrary data payload, the self-declared arbitrary chunk type, and the output filename for your modified PNG image file, as shown in <a href="ch13.xhtml#ch13list15">Listing 13-15</a>.</p>&#13;
<pre>$ <span class="codestrong1">go run main.go -i images/battlecat.png -o newPNGfile --inject -offset \&#13;
    0x85258 --payload 1234243525522552522452355525</span></pre>&#13;
<p class="caption" id="ch13list15"><em>Listing 13-15: Running the</em> <span class="codeitalic">imgInject</span> <em>command line program</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_307"/>If everything went as planned, <span class="literal">offset 0x85258</span> should now contain a new <span class="literal">rNDm</span> chunk segment, as shown in <a href="ch13.xhtml#ch13fig4">Figure 13-4</a>.</p>&#13;
<div class="image"><img src="Images/13fig04.jpg" alt="Image" width="926" height="174"/></div>&#13;
<p class="figcap" id="ch13fig4"><em>Figure 13-4: A payload injected as an ancillary chunk (such as <span class="codeitalic">rNDm</span>)</em></p>&#13;
<p class="indent">Congratulations—you’ve just written your first steganography program!</p>&#13;
<h3 class="h3" id="ch13lev1sec4">Encoding and Decoding Image Byte Data by Using XOR</h3>&#13;
<p class="noindent">Just as there are many types of steganography, so are there many techniques used to obfuscate data within a binary file. Let’s continue to build the sample program from the previous section. This time, you’ll include obfuscation to hide the true intent of your payload.</p>&#13;
<p class="indent">Obfuscation can help conceal your payload from network-monitoring devices and endpoint security solutions. If, for example, you’re embedding raw shellcode used for spawning a new Meterpreter shell or Cobalt Strike beacon, you want to make sure it avoids detection. For this, you’ll use Exclusive OR bitwise operations to encrypt and decrypt the data.</p>&#13;
<p class="indent">An <em>Exclusive OR</em> <em>(XOR)</em> is a conditional comparison between two binary values that produces a Boolean true value if and only if the two values are not the same, and a Boolean false value otherwise. In other words, the statement is true if either <em>x</em> or <em>y</em> are true—but not if both are true. You can see this represented in <a href="ch13.xhtml#ch13tab1">Table 13-1</a>, given that <em>x</em> and <em>y</em> are both binary input values.</p>&#13;
<p class="tabcap" id="ch13tab1"><strong>Table 13-1:</strong> XOR Truth Table</p>&#13;
<table class="topbot-d1">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>x</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>y</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>x ^ y output</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">True or 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">True or 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">False or 0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">False or 0</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can use this logic to obfuscate data by comparing the bits in the data to the bits of a secret key. When two values match, you change the bit in the payload to 0, and when they differ, you change it to 1. Let’s expand the code you created in the previous section to include an <span class="literal">encodeDecode()</span> function, along with <span class="literal">XorEncode()</span> and <span class="literal">XorDecode()</span> functions. We’ll insert these functions into the <span class="literal">utils</span> package (<a href="ch13.xhtml#ch13list16">Listing 13-16</a>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_308"/>func encodeDecode(input []byte<span class="ent">❶</span>, key string<span class="ent">❷</span>) []byte {&#13;
  <span class="ent">❸</span> var bArr = make([]byte, len(input))&#13;
    for i := 0; i &lt; len(input); i++ {&#13;
     <span class="ent">❹</span> bArr[i] += input[i] ^ key[i%len(key)]&#13;
    }&#13;
    return bArr&#13;
}</pre>&#13;
<p class="caption" id="ch13list16"><em>Listing 13-16: The</em> <span class="codeitalic">encodeDecode()</span> <em>function (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/encoders.go">/ch-13/imgInject/utils/encoders.go</a><em>)</em></p>&#13;
<p class="indent">The <span class="literal">encodeDecode()</span> function consumes a byte slice containing the payload <span class="ent">❶</span> and a secret key value <span class="ent">❷</span> as arguments. A new byte slice, <span class="literal">bArr</span> <span class="ent">❸</span>, is created within the function’s inner scope and initialized to the input byte length value (the length of the payload). Next, the function uses a conditional loop to iterate over each index position of input byte array.</p>&#13;
<p class="indent">Within the inner conditional loop, each iteration XORs the current index’s binary value with a binary value derived from the modulo of the current index value and length of the secret key <span class="ent">❹</span>. This allows you to use a key that is shorter than your payload. When the end of the key is reached, the modulo will force the next iteration to use the first byte of the key. Each XOR operation result is written to the new <span class="literal">bArr</span> byte slice, and the function returns the resulting slice.</p>&#13;
<p class="indent">The functions in <a href="ch13.xhtml#ch13list17">Listing 13-17</a> wrap the <span class="literal">encodeDecode()</span> function to facilitate the encoding and decoding process.</p>&#13;
<pre>   // XorEncode returns encoded byte array&#13;
<span class="ent">❶</span> func XorEncode(decode []byte, key string) []byte {&#13;
    <span class="ent">❷</span> return encodeDecode(decode, key)&#13;
   }&#13;
&#13;
   // XorDecode returns decoded byte array&#13;
<span class="ent">❶</span> func XorDecode(encode []byte, key string) []byte {&#13;
    <span class="ent">❷</span> return encodeDecode(encode, key)&#13;
   }</pre>&#13;
<p class="caption" id="ch13list17"><em>Listing 13-17: The</em> <span class="codeitalic">XorEncode()</span> <em>and</em> <span class="codeitalic">XorDecode()</span> <em>functions (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/encoders.go">/ch-13/imgInject/utils/encoders.go</a><em>)</em></p>&#13;
<p class="indent">You define two functions, <span class="literal">XorEncode()</span> and <span class="literal">XorDecode()</span>, which take the same literal arguments <span class="ent">❶</span> and return the same values <span class="ent">❷</span>. That’s because you decode XOR-encoded data by using the same process used to encode the data. However, you define these functions separately, to provide clarity within the program code.</p>&#13;
<p class="indent">To use these XOR functions in your existing program, you’ll have to modify the <span class="literal">ProcessImage()</span> logic you created in <a href="ch13.xhtml#ch13list8">Listing 13-8</a>. These updates will leverage the <span class="literal">XorEncode()</span> function to encrypt the payload. The modifications, shown in <a href="ch13.xhtml#ch13list18">Listing 13-18</a>, assume you’re using command line arguments to pass values to conditional encode and decode logic.</p>&#13;
<pre><span epub:type="pagebreak" id="page_309"/>// Encode Block&#13;
if (c.Offset != "") &amp;&amp; c.Encode {&#13;
    var m MetaChunk&#13;
 <span class="ent">❶</span> m.Chk.Data = utils.XorEncode([]byte(c.Payload), c.Key)&#13;
    m.Chk.Type = chk.strToInt(c.Type)&#13;
    m.Chk.Size = chk.createChunkSize()&#13;
    m.Chk.CRC = chk.createChunkCRC()&#13;
    bm := chk.marshalData()&#13;
    bmb := bm.Bytes()&#13;
    fmt.Printf("Payload Original: % X\n", []byte(c.Payload))&#13;
    fmt.Printf("Payload Encode: % X\n", chk.Data)&#13;
    utils.WriteData(b, c, bmb)&#13;
}</pre>&#13;
<p class="caption" id="ch13list18"><em>Listing 13-18: Updating</em> <span class="codeitalic">ProcessImage()</span> <em>to include XOR encoding (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<p class="indent">The function call to <span class="literal">XorEncode()</span> <span class="ent">❶</span> passes a <span class="literal">byte</span> slice containing the payload and secret key, XORs the two values, and returns a byte slice, which is assigned to <span class="literal">chk.Data</span>. The remaining functionality remains unchanged and marshals the new chunk segment to eventually be written to an image file.</p>&#13;
<p class="indent">The command line run of your program should produce a result similar to the one in <a href="ch13.xhtml#ch13list19">Listing 13-19</a>.</p>&#13;
<pre>   $ go run main.go -i images/battlecat.png --inject --offset 0x85258 --encode \&#13;
   --key gophers --payload 1234243525522552522452355525 --output encodePNGfile&#13;
   Valid PNG so let us continue!&#13;
<span class="ent">❶</span> Payload Original: 31 32 33 34 32 34 33 35 32 35 35 32 32 35 35 32 35 32 32&#13;
   34 35 32 33 35 35 35 32 35&#13;
<span class="ent">❷</span> Payload Encode: 56 5D 43 5C 57 46 40 52 5D 45 5D 57 40 46 52 5D 45 5A 57 46&#13;
   46 55 5C 45 5D 50 40 46&#13;
   Success: encodePNGfile created</pre>&#13;
<p class="caption" id="ch13list19"><em>Listing 13-19: Running the</em> <span class="codeitalic">imgInject</span> <em>program to XOR encode a data chunk block</em></p>&#13;
<p class="indent">The <span class="literal">payload</span> is written to a byte representation and displayed to stdout as <span class="literal">Payload Original</span> <span class="ent">❶</span>. The <span class="literal">payload</span> is then XORed with a <span class="literal">key</span> value of <span class="literal">gophers</span> and displayed to stdout as <span class="literal">Payload Encode</span> <span class="ent">❷</span>.</p>&#13;
<p class="indent">To decrypt your payload bytes, you use the decode function, as in <a href="ch13.xhtml#ch13list20">Listing 13-20</a>.</p>&#13;
<pre>//Decode Block&#13;
if (c.Offset != "") &amp;&amp; c.Decode {&#13;
    var m MetaChunk&#13;
  <span class="ent">❶</span> offset, _ := strconv.ParseInt(c.Offset, 10, 64)&#13;
  <span class="ent">❷</span> b.Seek(offset, 0)&#13;
  <span class="ent">❸</span> m.readChunk(b)&#13;
     origData := m.Chk.Data&#13;
  <span class="ent">❹</span> m.Chk.Data = utils.XorDecode(m.Chk.Data, c.Key)&#13;
     m.Chk.CRC = m.createChunkCRC()&#13;
  <span class="ent">❺</span> bm := m.marshalData()&#13;
 <span epub:type="pagebreak" id="page_310"/>    bmb := bm.Bytes()&#13;
     fmt.Printf("Payload Original: % X\n", origData)&#13;
     fmt.Printf("Payload Decode: % X\n", m.Chk.Data)&#13;
  <span class="ent">❻</span> utils.WriteData(b, c, bmb)&#13;
}</pre>&#13;
<p class="caption" id="ch13list20"><em>Listing 13-20: Decoding the image file and payload (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go">/ch-13/imgInject/pnglib/commands.go</a><em>)</em></p>&#13;
<p class="indent">The block requires the offset position of the chunk segment that contains the payload <span class="ent">❶</span>. You use the offset to <span class="literal">Seek()</span> <span class="ent">❷</span> the file position, along with a subsequent call to <span class="literal">readChunk()</span> <span class="ent">❸</span> that’s necessary to derive the <span class="literal">SIZE</span>, <span class="literal">TYPE</span>, <span class="literal">DATA</span>, and <span class="literal">CRC</span> values. A call to <span class="literal">XorDecode()</span> <span class="ent">❹</span> takes the <span class="literal">chk.Data</span> payload value and the same secret key used to encode the data, and then assigns the decoded payload value back to <span class="literal">chk.Data</span>. (Remember that this is symmetric encryption, so you use the same key to both encrypt and decrypt the data.) The code block continues by calling <span class="literal">marshalData()</span> <span class="ent">❺</span>, which converts your <span class="literal">Chunk</span> struct to a <span class="literal">byte</span> slice. Finally, you write the new chunk segment containing the decoded payload to a file by using the <span class="literal">WriteData()</span> function <span class="ent">❻</span>.</p>&#13;
<p class="indent">A command line run of your program, this time with a decode argument, should produce the result in <a href="ch13.xhtml#ch13list21">Listing 13-21</a>.</p>&#13;
<pre>   $  <span class="codestrong1">go run main.go -i encodePNGfile -o decodePNGfile --offset 0x85258 -decode \&#13;
   --key gophersValid PNG so let us continue!</span>&#13;
<span class="ent">❶</span> Payload Original: 56 5D 43 5C 57 46 40 52 5D 45 5D 57 40 46 52 5D 45 5A 57&#13;
   46 46 55 5C 45 5D 50 40 46&#13;
<span class="ent">❷</span> Payload Decode: 31 32 33 34 32 34 33 35 32 35 35 32 32 35 35 32 35 32 32 34&#13;
   35 32 33 35 35 35 32 35&#13;
   Success: decodePNGfile created</pre>&#13;
<p class="caption" id="ch13list21"><em>Listing 13-21: Running the</em> <span class="codeitalic">imgInject</span> <em>program to XOR decode a data chunk block</em></p>&#13;
<p class="indent">The <span class="literal">Payload Original</span> value <span class="ent">❶</span> is the encoded payload data read from the original PNG file, while the <span class="literal">Payload Decode</span> value <span class="ent">❷</span> is the decrypted payload. If you compare your sample command line run from before and the output here, you’ll notice that your decoded payload matches the original, cleartext value you supplied originally.</p>&#13;
<p class="indent">There is a problem with the code, though. Recall that the program code injects your new decoded chunk at an offset position of your specification. If you have a file that already contains the encoded chunk segment and then attempt to write a new file with a decoded chunk segment, you’ll end up with both chunks in the new output file. You can see this in <a href="ch13.xhtml#ch13fig5">Figure 13-5</a>.</p>&#13;
<div class="image"><img src="Images/13fig05.jpg" alt="Image" width="926" height="169"/></div>&#13;
<p class="figcap" id="ch13fig5"><em>Figure 13-5: The output file contains both the decoded chunk segment and encoded chunk segment.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_311"/>To understand why this happens, recall that the encoded PNG file has the encoded chunk segment at offset <span class="literal">0x85258</span>, as shown in <a href="ch13.xhtml#ch13fig6">Figure 13-6</a>.</p>&#13;
<div class="image"><img src="Images/13fig06.jpg" alt="Image" width="925" height="121"/></div>&#13;
<p class="figcap" id="ch13fig6"><em>Figure 13-6: The output file containing the encoded chunk segment</em></p>&#13;
<p class="indent">The problem presents itself when the decoded data is written to offset <span class="literal">0x85258</span>. When the decoded data gets written to the same location as the encoded data, our implementation doesn’t delete the encoded data; it merely shifts the remainder of the file bytes to the right, including the encoded chunk segment, as illustrated previously in <a href="ch13.xhtml#ch13fig5">Figure 13-5</a>. This can complicate payload extraction or produce unintended consequences, such as revealing the cleartext payload to network devices or security software.</p>&#13;
<p class="indent">Fortunately, this issue is quite easy to resolve. Let’s take a look at our previous <span class="literal">WriteData()</span> function. This time, you can modify it to address the problem (<a href="ch13.xhtml#ch13list22">Listing 13-22</a>).</p>&#13;
<pre>//WriteData writes new data to offset&#13;
func WriteData(r *bytes.Reader, c *models.CmdLineOpts, b []byte) {&#13;
    offset, err := strconv.ParseInt(c.Offset, 10, 64)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    w, err := os.OpenFile(c.Output, os.O_RDWR|os.O_CREATE, 0777)&#13;
    if err != nil {&#13;
        log.Fatal("Fatal: Problem writing to the output file!")&#13;
   }&#13;
   r.Seek(0, 0)&#13;
&#13;
   var buff = make([]byte, offset)&#13;
   r.Read(buff)&#13;
   w.Write(buff)&#13;
   w.Write(b)&#13;
<span class="ent">❶</span> if c.Decode {&#13;
    <span class="ent">❷</span> r.Seek(int64(len(b)), 1)&#13;
   }&#13;
<span class="ent">❸</span> _, err = io.Copy(w, r)&#13;
   if err == nil {&#13;
       fmt.Printf("Success: %s created\n", c.Output)&#13;
  }&#13;
}</pre>&#13;
<p class="caption" id="ch13list22"><em>Listing 13-22: Updating</em> <span class="codeitalic">WriteData()</span> <em>to prevent duplicate ancillary chunk types (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/writer.go">/ch-13/imgInject/utils/writer.go</a><em>)</em></p>&#13;
<p class="indent">You introduce the fix with the <span class="literal">c.Decode</span> conditional logic <span class="ent">❶</span>. The XOR operation produces a byte-for-byte transaction. Therefore, the encoded and decoded chunk segments are identical in length. Furthermore, the <span epub:type="pagebreak" id="page_312"/><span class="literal">bytes.Reader</span> will contain the remainder of the original encoded image file at the moment the decoded chunk segment is written. So, you can perform a right byte shift comprising the length of the decoded chunk segment on the <span class="literal">bytes.Reader</span> <span class="ent">❷</span>, advancing the <span class="literal">bytes.Reader</span> past the encoded chunk segment and writing the remainder of bytes to your new image file <span class="ent">❸</span>.</p>&#13;
<p class="indent">Voila! As you can see in <a href="ch13.xhtml#ch13fig7">Figure 13-7</a>, the hex editor confirms that you resolved the problem. No more duplicate ancillary chunk types.</p>&#13;
<div class="image"><img src="Images/13fig07.jpg" alt="Image" width="926" height="122"/></div>&#13;
<p class="figcap" id="ch13fig7"><em>Figure 13-7: The output file without duplicate ancillary data</em></p>&#13;
<p class="indent">The encoded data no longer exists. Additionally, running <span class="codestrong">ls -la</span> against the files should produce identical file lengths, even though file bytes have changed.</p>&#13;
<h3 class="h3" id="ch13lev1sec5">Summary</h3>&#13;
<p class="noindent">In this chapter, you learned how to describe the PNG image file format as a series of repetitive byte chunk segments, each with its respective purpose and applicability. Next, you learned methods of reading and navigating the binary file. Then you created byte data and wrote it to an image file. Finally, you used XOR encoding to obfuscate your payload.</p>&#13;
<p class="indent">This chapter focused on image files and only scratched the surface of what you can accomplish by using steganography techniques. But you should be able to apply what you learned here to explore other binary file types.</p>&#13;
<h3 class="h3" id="ch13lev1sec6">Additional Exercises</h3>&#13;
<p class="noindent">Like many of the other chapters in this book, this chapter will provide the most value if you actually code and experiment along the way. Therefore, we want to conclude with a few challenges to expand on the ideas already covered:</p>&#13;
<ol>&#13;
<li><p class="noindent">While reading the XOR section, you may have noticed that the <span class="literal">XorDecode()</span> function produces a decoded chunk segment, but never updates the CRC checksum. See if you can correct this issue.</p></li>&#13;
<li><p class="noindent">The <span class="literal">WriteData()</span> function facilitates the ability to inject arbitrary chunk segments. What code changes would you have to make if you wanted to overwrite existing ancillary chunk segments? If you need help, our explanation about byte shifting and the <span class="literal">Seek()</span> function may be useful in solving this problem.</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_313"/>Here’s a more challenging problem: try to inject a payload—the PNG <span class="literal">DATA</span> byte chunk—by distributing it throughout various ancillary chunk segments. You could do this one byte at a time, or with multiple groupings of bytes, so get creative. As an added bonus, create a decoder that reads exact payload byte offset locations, making it easier to extract the payload.</p></li>&#13;
<li><p class="noindent">The chapter explained how to use XOR as a confidentiality technique—a method to obfuscate the implanted payload. Try to implement a different technique, such as AES encryption. Go core packages provide a number of possibilities (see <a href="ch11.xhtml#ch11">Chapter 11</a> if you need a refresher). Observe how the solution affects the new image. Does it cause the overall size to increase, and if so, by how much?</p></li>&#13;
<li><p class="noindent">Use the code ideas within this chapter to expand support for other image file formats. Other image specifications may not be as organized as PNG. Want proof? Give the PDF specification a read, as it can be rather intimidating. How would you solve the challenges of reading and writing data to this new image format?<span epub:type="pagebreak" id="page_314"/></p></li>&#13;
</ol>&#13;
</div>



  </body></html>