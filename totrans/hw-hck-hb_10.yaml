- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: 'Splitting the Difference: Differential Power Analysis'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 差分功率分析：DPA攻击
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Using power measurements to learn about program flow has clear security implications,
    but what if we can go further than just learning about the program flow? It’s
    easy to imagine an algorithm where the code has the same program flow regardless
    of data being processed, but with a powerful technique called *differential power
    analysis (DPA)*, we can learn about the data being processed by a device, even
    if the program flow is exactly the same.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 利用功率测量来了解程序流程有明显的安全隐患，但如果我们能够进一步了解程序流程之外的内容呢？可以想象一种算法，其中无论处理的数据如何，代码的程序流程保持一致。然而，通过一种强大的技术——*差分功率分析（DPA）*，我们可以了解设备正在处理的数据，即使程序流程完全相同。
- en: In the previous chapter, you learned that simple power analysis uses a device’s
    power signature to broadly determine the operation it’s performing. Those operations
    could be the loops in a PIN verification or the modular operations in an RSA calculation.
    In SPA, we can treat each trace by itself. For instance, in an SPA attack on RSA,
    we may use the order of the modular operations to retrieve a key. In DPA, we analyze
    the *differences* between sets of traces. We use statistics to analyze small variations
    in our traces, which may allow us to determine what data the device is processing
    all the way down to individual bits.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你了解到简单功率分析利用设备的功率特征来大致确定它正在执行的操作。这些操作可能是PIN验证中的循环或RSA计算中的模运算。在SPA中，我们可以单独处理每个跟踪数据。例如，在RSA的SPA攻击中，我们可能使用模运算的顺序来恢复密钥。而在DPA中，我们分析的是一组跟踪数据之间的*差异*。我们使用统计方法分析跟踪数据中的微小变化，这可能帮助我们确定设备正在处理的数据，甚至是逐个位的数据。
- en: Since individual bits affect only a handful of transistors, you can imagine
    that the effect on the power consumption is tiny. In fact, you generally can’t
    measure a single bit in a power trace (unless it causes large operational differences,
    such as in the textbook implementation of RSA). What we can do, though, is capture
    many thousands, millions, billions of power traces and use the power of statistics
    (pun intended) to detect a small bias in current caused by a bit. The goal of
    a DPA attack is to use power measurements to determine some secret and constant
    state—typically a cryptographic key—of an algorithm that’s processing data on
    the target device.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单个位仅影响少数几个晶体管，你可以想象其对功率消耗的影响微乎其微。事实上，通常无法在功率跟踪中测量单个位（除非它引起了大规模的操作差异，比如RSA的教科书实现）。不过，我们可以做的是捕获成千上万、数百万、数十亿次功率跟踪数据，并利用统计学的力量（双关语）来检测由单个位引起的微小偏差。DPA攻击的目标是利用功率测量来确定算法中的某个秘密且恒定的状态——通常是处理数据的目标设备上的加密密钥。
- en: This incredibly powerful technique was first published in 1998 by Paul Kocher,
    Joshua Jaffe, and Benjamin Jun in the aptly named paper “Differential Power Analysis.”
    DPA is a specific side-channel power analysis algorithm, but the term is used
    generically to describe all related algorithms in the field. We’ll use it as a
    generic term here as well, unless otherwise specified.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这一极为强大的技术首次由Paul Kocher、Joshua Jaffe和Benjamin Jun于1998年在题为“差分功率分析”的论文中发布。DPA是一种特定的侧信道功率分析算法，但该术语通常用来描述该领域中的所有相关算法。除非另有说明，否则我们在这里也将使用该术语作为通用术语。
- en: Before you can perform a DPA attack, you need to be able to communicate with
    the target and cause it to perform the desired cryptographic operation. You’ll
    collect measurements on the target and record its power consumption. You’ll then
    process the measurements and perform the attack with the hope of recovering the
    encryption key. Although this attack sounds similar to the SPA attack described
    in Chapter 9, the processing step differs substantially.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行DPA攻击之前，你需要能够与目标设备进行通信，并使其执行所需的加密操作。你将收集目标设备的测量数据并记录其功率消耗。然后，你将处理这些数据并执行攻击，期望恢复加密密钥。尽管这种攻击听起来与第9章中描述的SPA攻击相似，但其处理步骤有很大不同。
- en: But before we delve into what processing is implemented in a DPA attack, you’ll
    need to understand what specific effect we are exploiting. We’ll start by looking
    at a humble microcontroller; these programmable digital devices are almost guaranteed
    to be in any hackable product.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入了解DPA攻击中实施的处理之前，你需要理解我们正在利用的具体效应。我们将从一个简单的微控制器开始；这些可编程数字设备几乎可以保证存在于任何可被破解的产品中。
- en: Inside the Microcontroller
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微控制器内部
- en: If you were to look deep inside your microcontroller, you would see all the
    conducting lines bringing signals from one side of the chip to the other, as shown
    in [Figure 10-1](#figure10-1). Various data lines flow from one section of the
    chip to another. An 8-bit microcontroller typically has one 8-bit-wide main *data
    bus*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入查看微控制器内部，你会看到所有的导线将信号从芯片的一侧传输到另一侧，如[图10-1](#figure10-1)所示。各种数据线从芯片的一个区域流向另一个区域。一个8位微控制器通常有一条8位宽的主*数据总线*。
- en: These lines transport data, and some of that data will be our target. All these
    lines eventually run into one of the building blocks of digital circuits, namely
    *transistors*. These are *field effect transistors (FETs)*, but all we care about
    is that they are basically a switch; they have one input that turns the output
    on or off. To toggle the FETs at the end of the data bus lines, we must move that
    data bus line high or low. The input to the FET along with all the lines in between
    can be thought of as a very small capacitor, and moving that line high or low
    really means changing the voltage across that capacitor, which means data values
    directly affect charges on internal capacitances.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些线传输数据，其中一些数据就是我们的目标。这些数据线最终会连接到数字电路的基本构件之一，即*晶体管*。这些是*场效应晶体管（FETs）*，但我们关心的仅仅是它们本质上是一个开关；它们有一个输入端，可以控制输出端的开关。为了切换数据总线末端的场效应晶体管，我们必须将数据总线线设为高电平或低电平。场效应晶体管的输入以及其间所有的线路可以看作是一个非常小的电容器，移动这条线路的高低电平实际上意味着改变电容器上的电压，这意味着数据值直接影响内部电容的电荷。
- en: '![f10001](image_fi/278748c10/f10001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![f10001](image_fi/278748c10/f10001.png)'
- en: 'Figure 10-1: Data lines in a chip'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1：芯片中的数据线
- en: Changing the Voltage on a Capacitor
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变电容器上的电压
- en: 'All kinds of capacitances in and around the microcontroller affect the power
    consumption. For the sake of the following discussion, we’ll refer to all these
    capacitances as a single capacitor. If you were paying attention in high-school
    physics, you may remember that to increase the voltage across a capacitor, you
    need to apply a *charge*, which has to come from somewhere—most usually through
    power lines. A digital integrated circuit (IC) will have both VCC (positive) and
    GND (ground) power lines. If you were to monitor the power consumption, you would
    see current spikes in the VCC line when switching from low to high. This comes
    about from the fundamental equations around changing the voltage on a capacitor,
    which can be stated as “the current through a capacitor is related to capacitance
    *C* and the rate of change of voltage,” as shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器内部和周围的各种电容影响着功耗。为了方便后续讨论，我们将所有这些电容视为一个单一的电容。如果你在高中物理课上认真听讲过，你可能还记得，要增加电容器上的电压，你需要施加一个*电荷*，而这个电荷必须来自某个地方——通常是通过电源线。数字集成电路（IC）会有VCC（正电源）和GND（地）电源线。如果你监控功耗，你会看到VCC线上在从低电平切换到高电平时会有电流尖峰。这是由于改变电容器上电压的基本方程所导致的，可以表述为“通过电容器的电流与电容*C*和电压变化率相关”，如下所示：
- en: '![e10001](image_fi/278748c10/e10001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![e10001](image_fi/278748c10/e10001.png)'
- en: If we have a changing voltage on the capacitor (such as what happens when switching
    from a low to high state), we have a current flowing in the circuit that capacitor
    is part of. If the voltage is changing on a low-to-high transition, we should
    see a current flow of one direction. If the voltage changes on a high-to-low transition,
    we should see this current flow reversed. Observing the magnitude and direction
    of the current flow allows us to infer something about the voltage changes over
    the “capacitor,” and thus over the entire circuit (including the transitions occurring
    on internal bus states of the microcontroller).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果电容器上的电压发生变化（例如从低电平切换到高电平时发生的情况），我们会在电容器所在的电路中看到电流流动。如果电压在低电平到高电平的过渡中变化，我们应该会看到电流沿一个方向流动。如果电压在高电平到低电平的过渡中变化，我们应该看到电流的方向发生反转。观察电流流动的大小和方向可以让我们推断电容器上的电压变化情况，从而推断整个电路（包括微控制器内部总线状态的过渡）的变化。
- en: To illustrate this, let’s assume we have a microcontroller that allows us to
    monitor the current consumption and the state of the internal data bus. If we
    change two data lines while monitoring the current going into the device, we expect
    the results of this measurement to look something like [Figure 10-2](#figure10-2).
    When data on the bus changes, the data lines all change state simultaneously relative
    to a system clock at well-defined points in time. At these moments we see current
    spikes resulting from the toggling data lines. Toggling data lines means charging
    and discharging a capacitor, which requires a current flow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，假设我们有一个微控制器，它允许我们监测电流消耗和内部数据总线的状态。如果我们在监测进入设备的电流时，改变两条数据线，我们预计这个测量的结果会像[图10-2](#figure10-2)那样。当总线上的数据发生变化时，所有数据线都会相对于系统时钟在定义明确的时间点同时改变状态。在这些时刻，我们会看到由于数据线切换而产生的电流峰值。切换数据线意味着充电和放电电容器，这需要电流流动。
- en: '![f10002](image_fi/278748c10/f10002.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f10002](image_fi/278748c10/f10002.png)'
- en: 'Figure 10-2: Monitoring current spikes when toggling data lines, showing current
    flowing in for both 0→1 and 1→0 transitions'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2：监测切换数据线时的电流峰值，展示0→1和1→0过渡时电流流入的情况
- en: Most real-life microcontroller buses go into a *pre-charge* state, which is
    halfway between a logic one and a logic zero. A logical state switch takes time,
    and the time depends on the voltage differential to put on the bus (that is, the
    voltage difference between the one state and zero state). Via pre-charging, this
    voltage differential is constant and only half the distance of a full zero-to-one
    switch, no matter whether there is a zero or a one on the bus. This results in
    bus operations taking less time to reach the final state and the whole operation
    being more dependable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数实际微控制器的总线会进入*预充电*状态，这种状态介于逻辑1和逻辑0之间。逻辑状态切换需要时间，而这个时间取决于施加在总线上的电压差（即1状态和0状态之间的电压差）。通过预充电，这个电压差是恒定的，并且只有完全从0到1切换的电压差的一半，无论总线上是0还是1。这使得总线操作所需的时间更短，整个操作也更可靠。
- en: From Power to Data and Back
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从功率到数据，再回到功率
- en: Most measurements we’ll be discussing in this book aim to capture the current
    of the device under test. The power is related to current with *P* = *I* × *V*;
    see Chapter 2 for details. If the device has a constant operating voltage, the
    power and current have a linear relationship. For the work that follows, we don’t
    need specific units on these measurements, and a linear (or even nonlinear) scaling
    factor makes little difference in application of the results.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们讨论的大多数测量旨在捕捉被测设备的电流。功率与电流的关系为*P* = *I* × *V*；详细信息见第二章。如果设备具有恒定的工作电压，功率和电流之间具有线性关系。对于接下来的工作，我们不需要这些测量的具体单位，线性（甚至非线性）缩放因子在结果应用中几乎没有影响。
- en: For this reason, the terms *current* and *power* are used interchangeably in
    the following discussion and for the remainder of this book. The common nomenclature
    for these attacks is one of *power analysis*, so you’ll see reference to attackers
    measuring the power of the device or having power traces. In most cases that’s
    not accurate because the current of the device in the circuit is being measured
    with tools such as current probes. (To confuse you even further, those currents
    are measured by an oscilloscope in volts. If you are especially pedantic about
    the difference between power and current, be warned that you may find existing
    in the field of power analysis to be entirely impossible.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在接下来的讨论中，以及本书剩余部分中，*电流*和*功率*这两个术语会被交替使用。对于这些攻击的常见术语是*功率分析*，所以你会看到攻击者测量设备的功率或拥有功率迹线的描述。在大多数情况下，这是不准确的，因为实际测量的是电路中设备的电流，通常使用电流探头等工具。（为了进一步困惑你，这些电流是通过示波器以伏特为单位进行测量的。如果你特别较真于功率和电流之间的区别，请注意，你可能会发现自己根本无法存在于功率分析的领域。）
- en: As attackers, we can use the aforementioned pre-charge state to directly determine
    the number of ones in the number being manipulated. This number is referred to
    as the *Hamming weight (HW)*. The Hamming weight of 0xA4 is 3 because 0xA4 is
    10010100 in binary and in it are three ones. With a simple pre-charged 2-bit bus,
    our power consumption trace would look like [Figure 10-3](#figure10-3).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击者，我们可以利用前面提到的预充电状态，直接确定正在操作的数字中1的个数。这个数字称为*海明重量 (HW)*。0xA4的海明重量为3，因为0xA4在二进制中是10010100，里面有三个1。通过简单的预充电2位总线，我们的功率消耗迹线会像[图10-3](#figure10-3)那样。
- en: As a result of pre-charging, the power spike depends only on the number of ones
    in the current value being sent over the bus. Note that we’re considering only
    the VCC rail current consumption, which is why there are no negative spikes when
    lines change to a low state. This behavior more closely matches what you would
    see in real systems, since you are observing power from only one rail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于预充电，功率峰值仅依赖于当前通过总线传输的值中 1 的数量。请注意，我们只考虑 VCC 电源轨的电流消耗，这就是为什么在线路变为低电平时没有负峰值的原因。这种行为更接近于你在实际系统中看到的情况，因为你观察的是单一电源轨的功耗。
- en: '![f10003](image_fi/278748c10/f10003.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f10003](image_fi/278748c10/f10003.png)'
- en: 'Figure 10-3: Hamming weights on a 2-bit data line'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3：2 位数据线上的海明重量
- en: In real life, microcontrollers do typically leak the Hamming weight of processed
    data. We can confirm this by averaging the power consumption at a moment in time
    when we know what data is being processed on the bus over many measurements. [Figure
    10-4](#figure10-4) shows an example for an STM32F303 microcontroller.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际中，微控制器通常会泄露处理数据的海明重量。我们可以通过在多次测量中，确定何时处理数据并平均功耗来确认这一点。图 [10-4](#figure10-4)
    显示了一个 STM32F303 微控制器的示例。
- en: '![f10004](image_fi/278748c10/f10004.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![f10004](image_fi/278748c10/f10004.png)'
- en: 'Figure 10-4: Increased power consumption of an STM32F303 microcontroller leads
    to a decreased voltage measurement.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4：STM32F303 微控制器的功耗增加导致电压测量下降。
- en: You might be surprised by just how perfectly linear this fit is, but our real-life
    measurements on microcontrollers often actually do result in matching this model.
    We measure the voltage drop over a series resistor in the VCC line, so an increased
    power consumption (increased Hamming weight) results in a larger drop in voltage.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶于这种拟合的线性程度，但我们在微控制器上的实际测量通常确实会与该模型匹配。我们通过 VCC 电源线上的串联电阻测量电压降，因此增加的功耗（增加的海明重量）会导致更大的电压下降。
- en: Sexy XORy Example
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性感的 XOR 示例
- en: Now that we can use averaged power consumption to determine the sum of the number
    of bits that are set to one in a digital device, let’s see how we could crack
    a simple device. Consider a basic circuit that XORs each byte of input with some
    unknown but constant 8-bit secret key. It then shoots that data through a lookup
    table with known values that replace every byte with another value, just like
    a substitution cipher, where the original input byte is replaced by a corresponding
    output byte in a lookup table, ending up with an “encrypted” result.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用平均功耗来确定数字设备中设置为 1 的位数总和，让我们看看如何破解一个简单设备。考虑一个基本电路，它将每个输入字节与某个未知但恒定的 8
    位密钥进行 XOR 运算。然后，它将这些数据通过一个查找表，该查找表用已知值替换每个字节，就像一个替换密码，其中原始输入字节被查找表中的对应输出字节替换，最终得到“加密”结果。
- en: We don’t have access to the output on this device; all we can do is send it
    data that it XORs and sends through the lookup table. We *can*, however, measure
    the power of this device, as shown in [Figure 10-5](#figure10-5), by inserting
    a shunt resistor in the VCC line of the device under test.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法访问该设备的输出；我们所能做的只是向其发送数据，它会将数据进行 XOR 运算并通过查找表发送。然而，我们*可以*，如图 [10-5](#figure10-5)
    所示，通过在待测设备的 VCC 线中插入分流电阻来测量该设备的功耗。
- en: '![f10005](image_fi/278748c10/f10005.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![f10005](image_fi/278748c10/f10005.png)'
- en: 'Figure 10-5: This simple device will be cracked using a DPA attack.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-5：这个简单设备将通过 DPA 攻击被破解。
- en: Now we send a bunch of random 8-bit input data bytes to the device and record
    each byte along with the power trace. We end up with a list of data sent to the
    device, along with the associated power trace measured during that operation,
    as shown in [Figure 10-6](#figure10-6).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们向设备发送一堆随机的 8 位输入数据字节，并记录每个字节及其功率轨迹。我们最终得到一个数据列表，列出了发送到设备的数据及其在该操作过程中测量的功率轨迹，如图
    [10-6](#figure10-6) 所示。
- en: '![f10006](image_fi/278748c10/f10006.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![f10006](image_fi/278748c10/f10006.png)'
- en: 'Figure 10-6: Input data vs. associated power trace'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-6：输入数据与相关功率轨迹
- en: This is all we need to start a DPA attack, where we’ll attempt to recover the
    secret key.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们开始进行 DPA 攻击所需的一切，在这个过程中我们将尝试恢复密钥。
- en: Differential Power Analysis Attack
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 差分功率分析攻击
- en: For the DPA attack on this XOR example from [Figure 10-5](#figure10-5), we target
    a single bit of the secret key at a time. We’ll describe how to break the least
    significant bit (LSB), but you can extend that to all 8 bits with a touch of creativity.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[图10-5](#figure10-5)中的这个异或（XOR）示例的DPA攻击，我们每次只针对一个秘密密钥位进行攻击。我们将描述如何破解最低有效位（LSB），但是你可以通过一些创意将这种方法扩展到所有8位。
- en: Fundamental to these attacks is *key enumeration*, which is a fancy way of saying
    we take informed guesses at the key. We try every possible key value, predict
    what the power consumption would be if the device used that key value, and match
    our predictions against the actual power traces. The best match is our *key candidate*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些攻击的核心是*密钥枚举*，这其实就是我们通过有根据的猜测来尝试密钥的值。我们尝试每一个可能的密钥值，预测如果设备使用该密钥值，功耗会是多少，然后将我们的预测与实际的功耗轨迹进行比对。最好的匹配就是我们的*密钥候选*。
- en: You are quite right at this point to think, “Why do I need power analysis instead
    of simply brute-forcing an 8-bit key?” For a brute-force attack, you need to input
    a key and get some feedback from the system on whether the key is correct. The
    problem here is that we assume the output is not available, so you could never
    test whether the guessed key was correct.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你此时完全正确地想，“为什么我需要功耗分析，而不是直接暴力破解一个8位密钥？”对于暴力攻击，你需要输入一个密钥并从系统中得到反馈，确认密钥是否正确。这里的问题是，我们假设输出不可用，因此你永远无法测试猜测的密钥是否正确。
- en: With DPA, we are going to be getting some “hints” on whether a guessed key is
    correct. We don’t actually learn whether the key decrypts the data. The best test
    of a guessed key would be to attempt to decrypt some data and see whether it results
    in valid output; if it does, we fundamentally know the key is correct. With a
    DPA attack, we technically just gain confidence in a *key hypothesis* or *key
    guess*. If this confidence is very high, we can deduce that the actual key is
    equal to our key hypothesis without needing to perform a test decryption. More
    crucially, we’ll later extend this example to larger keys that you can’t brute-force.
    For example, applying DPA to a 128-bit key is 128 times more work than applying
    it to a single bit, as we can perform attacks on key bits independently of the
    other key bits. Compare this to brute-forcing, where guessing a single-bit key
    requires at maximum two tries, but guessing all 128 bits requires at maximum 2^(128)
    tries. That’s a big number. It’s about the number of ants in the universe if each
    star in the universe had a billion queen ants, and each queen ant had a colony
    of a billion. This means with DPA, it’s feasible to break a 128-bit key, whereas
    with brute-forcing, it is not.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在DPA攻击中，我们将获得一些关于猜测密钥是否正确的“线索”。我们实际上并不直接得知密钥是否解密了数据。对猜测的密钥进行测试的最佳方法是尝试解密一些数据，看看是否能得到有效的输出；如果能得到有效输出，那么我们基本可以确定密钥是正确的。而在DPA攻击中，我们技术上只是对*密钥假设*或*密钥猜测*的信心有所增加。如果这个信心非常高，我们可以推断出实际密钥等于我们的密钥假设，而无需进行测试解密。更重要的是，我们稍后将把这个例子扩展到更大的密钥，针对这些密钥你无法使用暴力破解。例如，应用DPA攻击于一个128位的密钥，其工作量是应用于单个位时的128倍，因为我们可以独立地对密钥位进行攻击。相比之下，暴力破解一个单个位的密钥最多需要两次尝试，但破解全部128位的密钥则最多需要进行2^(128)次尝试。那是一个非常大的数字，差不多是宇宙中蚂蚁的数量，如果宇宙中的每颗星星都有十亿只蚁后，每只蚁后都有一个十亿只蚂蚁的巢穴。这意味着，通过DPA，破解128位密钥是可行的，而暴力破解则不可行。
- en: Predicting Power Consumption Using a Leakage Assumption
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用泄漏假设预测功耗
- en: To predict the device’s power consumption, we’ll use a *leakage assumption*
    in combination with our knowledge of the system. We assume that the system leaks
    the Hamming weight of all values processed, but we have a problem. We are able
    to measure only the total power consumption, and thus the total Hamming weight
    of all the data that is being processed, instead of the Hamming weight of only
    the secret value in which we are interested. Further, even if we can isolate the
    secret value, many different 8-bit values will have the same Hamming weight. Since
    this chapter has many more pages, you have guessed correctly that a solution to
    this difficulty exists.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测设备的功耗，我们将使用*泄漏假设*并结合我们对系统的了解。我们假设系统泄漏所有处理值的海明重量，但我们面临一个问题。我们只能测量总功耗，也就是所有正在处理的数据的海明重量，而不是我们感兴趣的仅仅是秘密值的海明重量。此外，即使我们能够隔离出秘密值，许多不同的8位值也会有相同的海明重量。由于本章内容较多，你应该已经猜到，解决这个难题的方法是存在的。
- en: Say we have an array of power traces called `t[]` and an array called `p[]`
    of associated input data. For example, the top entry from [Figure 10-6](#figure10-6)
    would have `p[0] = 0xAC`. The power trace `t[0]` is an array of sample values,
    shown as the top trace. We can apply the DPA algorithm to generate a list of differences
    for each key guess. The simple function presented in [Listing 10-1](#listing10-1)
    simulates the power consumption of a simple target device and guesses a single
    bit by means of a DPA attack.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`t[]`的功率轨迹数组和一个名为`p[]`的相关输入数据数组。例如，[图 10-6](#figure10-6)中的顶部条目将有`p[0]
    = 0xAC`。功率轨迹`t[0]`是一个样本值数组，如顶部轨迹所示。我们可以应用DPA算法生成每个密钥猜测的差异列表。[列表 10-1](#listing10-1)中呈现的简单函数模拟了一个简单目标设备的功耗，并通过DPA攻击猜测了一个单一位。
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 10-1: Simulated power consumption and guess of a single bit using a
    DPA attack'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-1：使用DPA攻击模拟功耗和猜测单一位
- en: We first enumerate over all possibilities for the byte being guessed 1. For
    each possible guess of the key byte, we loop over all recorded power traces 2.
    Using the input data associated with the trace `p[d]` and guess `i` of the secret
    key, we can generate a *hypothetical* output `h` 3 that’s only equal to what the
    microcontroller would have computed if we had guessed the key correctly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先列举出所有可能的字节猜测 1。对于每个可能的密钥字节猜测，我们遍历所有记录的功率轨迹 2。使用与轨迹`p[d]`和密钥猜测`i`相关的输入数据，我们可以生成一个*假设的*输出`h`
    3，只有在我们正确猜测密钥时，这个输出才等于微控制器所计算的结果。
- en: 'Finally, we look at the target bit (the LSB) in the hypothetical output 4.
    Based on the key guess, we add each recorded power trace `t[d]` into one of two
    groups: ones where we *think* the LSB was a one 5, and ones where we *think* the
    LSB was a zero 6.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们查看假设输出中的目标位（最低有效位，LSB） 4。根据密钥猜测，我们将每个记录的功率轨迹`t[d]`添加到两组中的一组：我们*认为*LSB为1的组
    5，以及我们*认为*LSB为0的组 6。
- en: Now consider the nature of this guess. If the guess is *incorrect*, what we
    think went into the lookup table isn’t what actually went in there on the device,
    and, consequently, what we think came out of the lookup table also isn’t what
    actually came out. Grouping by the incorrect LSB means that we basically split
    all power traces randomly into two groups. In that case, you would expect the
    mean power consumption of each group to be about the same. Thus, if you subtract
    the means from each other, you should get nothing but perhaps some noise. [Figure
    10-7](#figure10-7) shows some examples of the two groups and the resulting subtraction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑这个猜测的性质。如果猜测是*错误的*，我们认为输入查找表的数据实际上并非设备上实际输入的数据，因此，我们认为从查找表中得到的结果也不是实际得到的结果。根据错误的最低有效位（LSB）分组，意味着我们基本上将所有的功率轨迹随机分成两组。在这种情况下，您会期望每组的平均功耗大致相同。因此，如果你从两个平均值中相互减去，你应该得到的结果应该什么也没有，只可能是一些噪音。[图
    10-7](#figure10-7)展示了两组的例子以及得到的减法结果。
- en: If our guess is *correct*, what we think is computed is in reality the same
    as the data that was computed on the device. Therefore, we’ve moved all power
    traces where the LSB is actually set to 1 into one group and all traces where
    the LSB is actually set to 0 into the other group. If those ones and zeros consume
    a slightly different amount of power, that difference should become evident if
    we average large enough groups of traces. We would expect to see a small difference
    between the one and zero groups when this bit is manipulated, as shown in [Figure
    10-8](#figure10-8).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的猜测是*正确的*，我们认为计算的结果实际上与设备上计算的结果相同。因此，我们已将所有最低有效位（LSB）实际设置为1的功率轨迹分入一组，将所有LSB实际设置为0的功率轨迹分入另一组。如果这些1和0的功耗稍有不同，那么如果我们对足够大的轨迹组进行平均，这种差异应该变得明显。当我们操作该位时，我们预计在一组和零组之间会看到一个小的差异，如[图
    10-8](#figure10-8)所示。
- en: '![f10007](image_fi/278748c10/f10007.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![f10007](image_fi/278748c10/f10007.png)'
- en: 'Figure 10-7: Averaging many traces into ones and zeros for an incorrect guess
    (0xAB) with no specific peak visible'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-7：将多个功率轨迹平均为1和0，用于一个错误猜测（0xAB），且没有明显的峰值
- en: '![f10008](image_fi/278748c10/f10008.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![f10008](image_fi/278748c10/f10008.png)'
- en: 'Figure 10-8: Averaging many traces into ones and zeros for a correct guess
    (0x97) where a peak is clearly visible'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-8：将多个功率轨迹平均为1和0，用于一个正确猜测（0x97），其中明显可见一个峰值
- en: This difference (7 in [Listing 10-1](#listing10-1)) gives us the *differential*
    part of differential power analysis. The power of this analysis is that separating
    the traces from the table shown in [Figure 10-6](#figure10-6) into two groups
    allows us to average many traces to reduce noise, while not averaging out the
    contribution of the bit of interest. We can see the final blip at sample 35 in
    [Figure 10-8](#figure10-8), which demonstrates that we can see the small contribution
    of our LSB. Taking the difference between these two averaged groups will be called
    taking the *difference of means (DoM)*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异（在[列表 10-1](#listing10-1)中的7）给我们提供了**差分**功率分析中的*差分*部分。这种分析的优势在于，将[图 10-6](#figure10-6)中显示的表格中的痕迹分为两组，使我们能够平均多个痕迹以减少噪声，同时不会平均掉我们关注的位的贡献。我们可以在[图
    10-8](#figure10-8)中的样本35看到最终的波动，这表明我们可以看到最低有效位（LSB）的微小贡献。对这两组平均值之间的差异进行比较，将称为计算*均值差异（DoM）*。
- en: But wouldn’t such a tiny blip of power consumption be lost in the noise of so
    many other lines being switched in real-life chips? Well, all of that other noise
    is effectively uniformly distributed over the two groups. The only difference
    that remains statistically significant between the groups is the LSB, the single
    bit that we’ve chosen to split our groups on. When we average a sufficient number
    of such traces, the contributions of any other flipping bits cancel out.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这么微小的功率消耗波动会不会在现实芯片中其他许多线路切换的噪声中丢失呢？实际上，所有其他噪声在两个组中是均匀分布的。唯一在统计上仍然显著的差异是LSB，即我们选择用来划分组的那个单个位。当我们对足够多的痕迹进行平均时，任何其他翻转位的贡献都会相互抵消。
- en: A DPA Attack in Python
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python中的DPA攻击
- en: As proof of concept, the companion Jupyter notebook for this chapter ([https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/))
    implements a DPA attack on our example in Python. The `measure_power()` function,
    partially shown in [Listing 10-2](#listing10-2), performs an XOR of the input
    data using a secret byte and passes it through a lookup table.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为概念验证，本章的配套Jupyter笔记本（[https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/)）实现了一个对我们示例的DPA攻击，使用Python编写。`measure_power()`函数，在[列表
    10-2](#listing10-2)中部分展示，使用一个秘密字节对输入数据进行XOR运算，并通过查找表进行传递。
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 10-2: Lookup table that XORs the input with some secret key'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-2：使用某个秘密密钥对输入进行XOR运算的查找表
- en: In the following examples, the lookup table is randomly generated (that is,
    the `lookup` array from [Listing 10-2](#listing10-2)). The lookup table should
    at least be a bijection, and if we were implementing a real encryption algorithm,
    there would be more considerations. However, for the purpose of this demonstration,
    a randomly permuted sequence will work as well. Using such a lookup table will
    demonstrate that there is no fundamental “problem” with AES or another algorithm
    that makes the attack possible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，查找表是随机生成的（即[列表 10-2](#listing10-2)中的`lookup`数组）。查找表应该至少是一个双射，如果我们正在实现一个真实的加密算法，还需要更多的考虑。然而，出于演示的目的，随机排列的序列也可以使用。使用这样的查找表将展示AES或其他算法本身并没有根本的“问题”，正是这些算法使得攻击成为可能。
- en: Rather than simply performing the “encryption function,” we’ll simulate the
    power consumption of a piece of hardware running this function, which will make
    it easier to follow on a computer. You’ll see later how to perform the measurements
    on a real piece of hardware.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟运行该函数的硬件的功率消耗，而不仅仅是执行“加密功能”，这将使其更容易在计算机上跟踪。稍后你将看到如何在实际硬件上执行这些测量。
- en: Simulating a Single Power Measurement
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟单次功率测量
- en: To simulate a single power measurement, we’ll generate an array with random
    background noise to reflect the reality of noisy measurements and systems in the
    `measure_power()` function. We’ll then insert a power spike based on the number
    of ones in the intermediate value. This simulates the power consumption measurements
    of the system shown in [Figure 10-5](#figure10-5).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟单次功率测量，我们将在`measure_power()`函数中生成一个包含随机背景噪声的数组，以反映噪声测量和系统的现实情况。然后，我们将根据中间值中1的数量插入一个功率峰值。这模拟了[图
    10-5](#figure10-5)中显示的系统功率消耗测量。
- en: The Batch Measurement
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 批量测量
- en: Next, we perform the batch measurement. The `gen_traces()` function calls the
    `measure_power()` function with a number of random inputs while recording the
    resulting power trace. You can specify how many measurements to perform. (We’ll
    look at the effect of this on the attack success rate later.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进行批量测量。`gen_traces()`函数调用`measure_power()`函数，使用多个随机输入并记录结果功率轨迹。你可以指定执行多少次测量。（我们稍后会看看这对攻击成功率的影响。）
- en: '[Figure 10-9](#figure10-9) shows a single trace we “measured,” as plotted from
    Python.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-9](#figure10-9)展示了我们“测量”到的单个轨迹，这是通过Python绘制的。'
- en: '![f10009](image_fi/278748c10/f10009.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![f10009](image_fi/278748c10/f10009.png)'
- en: 'Figure 10-9: Example of a single trace generated (input = 0xAC)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-9：生成的单个轨迹示例（输入 = 0xAC）
- en: Enumerating the Possibilities and Splitting the Traces
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 枚举可能性并分割轨迹
- en: At this point, we have the measurement and input data arrays mentioned earlier
    in the “Predicting Power Consumption Using a Leakage Assumption” section. All
    we need to do now is to enumerate the key guesses and split the recorded power
    traces into two groups based on the hypothetical intermediate value.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经有了前面“通过泄漏假设预测功耗”部分提到的测量和输入数据数组。现在我们需要做的就是枚举密钥猜测，并根据假设的中间值将记录的功率轨迹分成两组。
- en: In the `dom()` function, we guess the intermediate value with `lookup[guess
    ^ p]` and then check the value to see whether a specific bit is set with the `(XX
    >> bitnum) & 1` expression. Based on the value of that bit, the traces are partitioned
    into two groups. In our example, before we were using the LSB, this would correspond
    to `bitnum` being set to 0.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dom()`函数中，我们用`lookup[guess ^ p]`猜测中间值，然后通过`(XX >> bitnum) & 1`表达式检查该值是否设置了特定的比特。根据该比特的值，轨迹被分为两组。在我们的示例中，在使用LSB之前，这对应于将`bitnum`设置为0。
- en: The Difference Array
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 差分数组
- en: Finally, we subtract the mean of each group to get the difference array. What
    does this difference look like? If the split was done correctly, we’d expect a
    large spike at some point. Look back at the difference of means in Figures 10-7
    and 10-8\. You should see the obvious positive spike when the separation of traces
    is done correctly, and thus we know our key guess is correct.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们减去每组的均值以得到差分数组。这些差分看起来是什么样的呢？如果分割正确，我们应该在某个时刻看到一个大的峰值。回顾图10-7和图10-8中的均值差异，你应该能看到当分离轨迹正确时，会出现明显的正峰值，从而知道我们的关键猜测是正确的。
- en: The graph in [Figure 10-8](#figure10-8) is the result of a correct guess, where
    we have partitioned the traces based on the assumption that the secret key byte
    was 0x97\. The graph in [Figure 10-7](#figure10-7) shows an incorrect key guess,
    where we have partitioned the traces based on the assumption that the secret key
    byte is 0xAB.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-8](#figure10-8)中的图表是正确猜测的结果，我们基于假设密钥字节为0x97对轨迹进行了分割。图10-7中的图表显示了一个错误的密钥猜测，我们假设密钥字节为0xAB，并对轨迹进行了分割。'
- en: As we separate the traces, even in very high noise environments, eventually
    everything that is not the DPA signal will average away, as you can see by comparing
    the left and right differences of means in [Figure 10-10](#figure10-10).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着轨迹的分离，即使在非常高噪声的环境下，最终所有非DPA信号的部分都会被平均掉，正如你可以通过比较[图10-10](#figure10-10)中的左右均值差异所看到的那样。
- en: '![f10010](image_fi/278748c10/f10010.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![f10010](image_fi/278748c10/f10010.png)'
- en: 'Figure 10-10: Difference of means on 1,000 (left) vs. 100,000 (right) traces
    to reduce noise'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-10：对1,000（左）与100,000（右）个轨迹的均值差异以减少噪声
- en: '[Figure 10-10](#figure10-10) shows 100,000 traces used on the right as opposed
    to 1,000 traces on the left. The result is that the random noise is further suppressed,
    and the signal becomes even more pronounced.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-10](#figure10-10)展示了右侧使用的100,000个轨迹，而左侧为1,000个轨迹。结果是随机噪声被进一步抑制，信号变得更加突出。'
- en: A Complete Attack
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完整攻击
- en: 'Next, we determine the most likely value of the encryption key from each bit
    by calculating the difference of means for each guess for a particular bit. From
    all those differences, we find the strongest peak, which indicates what the best
    guess at the key is for that bit. Running the code produces this output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过计算每个比特的每个猜测的均值差异，确定每个比特加密密钥的最可能值。从所有这些差异中，我们找到最强的峰值，表示该比特的最佳密钥猜测。运行代码会生成如下输出：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ve determined the correct value of the encryption key for each bit. While
    DPA deals with single bits at a time, the use of that funny lookup table in our
    sample encryption function meant we were able to break the entire eight bits of
    the encryption key by guessing only a single bit. This method worked because a
    single bit of the output of the lookup table may be related to all bits of the
    input to the table. This input is the 8-bit unknown key combined with the 8-bit
    known algorithm input data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了每个位的加密密钥的正确值。虽然 DPA 一次处理单个位，但在我们示例加密函数中使用那个奇怪的查找表意味着我们只需猜测一个位就能破解整个 8
    位的加密密钥。这种方法之所以有效，是因为查找表的输出的单个位可能与输入表的所有位相关。这个输入是 8 位的未知密钥和 8 位的已知算法输入数据组合而成。
- en: Using the lookup table ensures that if our guess of the key value is wrong,
    the partitioning of traces into one and zero categories would basically be random.
    Specifically, the lookup table is most likely nonlinear because we randomized
    it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查找表可以确保如果我们对密钥值的猜测是错误的，将追踪分为一类和零类的划分基本上是随机的。具体来说，查找表很可能是非线性的，因为我们对其进行了随机化处理。
- en: Had we been attacking just a simple input XOR key without the lookup table,
    each key bit would be related only to one bit of the intermediate state, which
    means we would have been able to determine only one bit of the key per bit of
    intermediate state.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只攻击简单的输入 XOR 密钥而没有查找表，那么每个密钥位只会与中间状态的一个位相关，这意味着我们每次只能确定中间状态的一个位对应的密钥位。
- en: 'Know Thy Enemy: An Advanced Encryption Standard Crash Course'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识你的敌人：高级加密标准速成课程
- en: 'Breaking our made-up algorithm that works on a single byte isn’t too exciting,
    so now we’re going to apply DPA to the advanced encryption standard (AES). AES
    always operates in 16-byte blocks, which means that you must encrypt 16 bytes
    at a time. AES has three possibilities for key length: 128-bit (16 bytes), 192-bit
    (24 bytes), or 256-bit (32 bytes). Longer keys typically mean stronger encryption,
    as any sort of brute-force attack takes exponentially longer to crack for longer
    keys.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 破解我们设计的仅对一个字节有效的算法并不算太刺激，因此现在我们要将 DPA 应用到高级加密标准（AES）。AES 总是以 16 字节的块进行操作，这意味着你必须一次加密
    16 字节。AES 有三种密钥长度的可能性：128 位（16 字节）、192 位（24 字节）或 256 位（32 字节）。较长的密钥通常意味着更强的加密，因为任何形式的暴力破解对更长的密钥破解的时间会呈指数增长。
- en: We primarily deal with AES-128 here (although you also can easily apply side-channel
    attacks to AES-192 or AES-256) using *Electronic Code Book (ECB)* mode. In ECB
    mode, a block of 16 bytes of unencrypted *plaintext* run through AES-128-ECB with
    the same secret key always maps to the same encrypted *ciphertext*. Most real-world
    encryption does not directly use ECB mode but instead uses various *modes of operation*,
    such as *cipher block chaining (CBC)* and *Galois Counter Mode (GCM)*. A straightforward
    DPA on AES would apply directly to AES in ECB mode. And once you know how to deal
    with AES in ECB mode, you can also extend it to attacks on AES CBC and AES GCM.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里主要讨论 AES-128（尽管你也可以轻松将旁道攻击应用于 AES-192 或 AES-256），使用 *电子密码本 (ECB)* 模式。在
    ECB 模式下，16 字节的未加密 *明文* 通过 AES-128-ECB 和相同的密钥总是映射到相同的加密 *密文*。大多数现实世界的加密不会直接使用 ECB
    模式，而是使用各种 *操作模式*，例如 *密码分组链接 (CBC)* 和 *Galois 计数模式 (GCM)*。对 AES 的直接 DPA 攻击将应用于
    ECB 模式下的 AES。一旦你掌握了如何处理 AES 的 ECB 模式，也可以将其扩展到 AES CBC 和 AES GCM 的攻击。
- en: '[Figure 10-11](#figure10-11) shows the general structure of the start of AES-128\.
    (We’ll limit our discussion to the beginning rounds of the algorithm, as our attacks
    take place within that section.)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-11](#figure10-11) 显示了 AES-128 开始部分的总体结构。（我们将讨论限制在算法的开始几轮，因为我们的攻击发生在该部分。）'
- en: '![f10011](image_fi/278748c10/f10011.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![f10011](image_fi/278748c10/f10011.png)'
- en: 'Figure 10-11: The complete first round and start of the second of the AES algorithm'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-11：AES 算法的完整第一轮和第二轮的开始
- en: In [Figure 10-11](#figure10-11), the 16-byte secret key is given as R[0]K[*k*]
    1, where *k* is the key byte number. The first subscript indicates to which round
    this key applies; AES uses a different 16-byte round key for each round. The input
    plaintext is entered 2, again with a subscript indicating the byte number. Each
    byte of the round key is XOR’d with each byte of the plaintext 3 in an operation
    referred to as `AddRoundKey`. Note that for AES-128, the first round key is the
    same as the AES key; all other round keys are derived from the AES key through
    the key-scheduling algorithm. For DPA on AES-128, we need to extract only one
    round key from which we can derive the AES key.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10-11](#figure10-11)中，16 字节的密钥表示为 R[0]K[*k*] 1，其中 *k* 是密钥字节的编号。第一个下标表示该密钥适用于哪一轮；AES
    在每一轮使用不同的 16 字节轮密钥。输入明文为 2，依然带有下标，表示字节编号。每个轮密钥的字节与明文 3 的每个字节进行异或操作，称为 `AddRoundKey`
    操作。请注意，对于 AES-128，第一轮的轮密钥与 AES 密钥相同；其他所有的轮密钥都是通过密钥调度算法从 AES 密钥派生出来的。对于 AES-128
    的 DPA，我们只需要提取一个轮密钥，通过它可以推导出 AES 密钥。
- en: Once the round key and plaintext have been XOR’d together in the `AddRoundKey`
    operation, each byte is passed through a *substitution-box* *(S-box)* 4, in an
    operation referred to as `SubBytes`. The S-box is an 8-bit lookup table with a
    one-to-one mapping (that is, every input maps to a unique output). This also means
    it is invertible; given the output of the S-box, you can determine the input.
    The S-box is designed to have a number of preferred properties that can discourage
    linear and differential cryptanalysis. (The exact definition of these lookup tables
    is irrelevant; we just want to note the S-box is more than just any old lookup
    table.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦轮密钥和明文在 `AddRoundKey` 操作中进行异或运算，每个字节就会通过一个 *替代盒* *(S-box)* 4，进行称为 `SubBytes`
    的操作。S-box 是一个 8 位查找表，具有一对一的映射关系（也就是说，每个输入都有一个唯一的输出）。这也意味着它是可逆的；给定 S-box 的输出，你可以确定输入。S-box
    设计具有许多优良的特性，可以抵抗线性和差分密码分析。（这些查找表的具体定义并不重要；我们只想指出，S-box 不仅仅是一个普通的查找表。）
- en: The next two layers further distribute the input across multiple output bits.
    The first layer is a function called `ShiftRows`, which shuffles the bytes 5.
    Next, the `MixColumns` operation 6 combines 4 bytes of input to create 4 bytes
    of output, which implies that if a single byte changes at the input to `MixColumns`,
    all 4 bytes of output will be affected.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两层进一步将输入分布到多个输出比特中。第一层是一个名为 `ShiftRows` 的函数，它会打乱字节 5。接下来，`MixColumns` 操作
    6 将 4 个字节的输入结合成 4 个字节的输出，这意味着如果输入到 `MixColumns` 的单个字节发生变化，所有 4 个字节的输出都会受到影响。
- en: The output of `MixColumns` becomes the input to the next round 7. This round
    has a round key 8, which will be XOR’d with the input round text 7 yet again using
    the `AddRoundKey` operation. The previous operations (`SubBytes`, `ShiftRows`,
    and `MixColumns`) then repeat. The consequence is that if we flip a single bit
    at the start of the AES, by the end of the 10 rounds, we should (on average) see
    half the output bits flip.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`MixColumns` 的输出成为下一轮7的输入。这一轮有一个轮密钥8，它将再次与输入的轮文本7通过 `AddRoundKey` 操作进行异或运算。之前的操作（`SubBytes`、`ShiftRows`
    和 `MixColumns`）然后会重复。结果是，如果我们在 AES 开始时翻转一个比特，经过 10 轮后，我们应该（平均而言）看到一半的输出比特发生翻转。'
- en: All rounds but the last will have exactly the same operations; only the data
    going into the round and the round key will differ. The last round will have another
    `AddRoundKey` instead of a `MixColumns` operation. However, we’ll need to attack
    only the first round with DPA to extract a full key, so we’re not too concerned
    about that last round!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一轮外，所有的轮次都会进行完全相同的操作；只有进入轮次的数据和轮密钥会有所不同。最后一轮将进行另一个 `AddRoundKey` 操作，而不是
    `MixColumns` 操作。然而，我们只需要通过 DPA 攻击第一轮来提取完整的密钥，因此对于最后一轮，我们并不太担心！
- en: Attacking AES-128 Using DPA
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 DPA 攻击 AES-128
- en: 'To break an AES-128 implementation with DPA, we first need to simulate an AES-128
    implementation. The XOR example we’ve been using is basically the first two steps
    of AES: a key addition (XOR) and an S-box lookup.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 DPA 破解 AES-128 实现，我们首先需要模拟 AES-128 实现。我们一直在使用的异或示例基本上是 AES 的前两步：密钥加法（异或）和
    S-box 查找。
- en: To build a real DPA attack on AES, we will modify the sample code from the companion
    Jupyter notebook (if you haven’t done so already, now is a good time to get it
    working). We simply need to change our randomized lookup table to be the proper
    AES S-box. In this case, we’re attacking the *output* of the S-box. The nonlinear
    effect of the S-box will make it easier to extract the complete encryption key.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个真正的 AES DPA 攻击，我们将修改来自附带的 Jupyter 笔记本的示例代码（如果你还没有这样做，现在是个好时机让它正常运行）。我们只需要将随机查找表改为正确的
    AES S-box。在这种情况下，我们攻击的是 S-box 的*输出*。S-box 的非线性效应将使得提取完整的加密密钥变得更加容易。
- en: 'If you run the sample code, it should produce the output in [Figure 10-12](#figure10-12),
    which shows a trace for each of the three values of the `guess` variable: 0x96,
    0x97, and 0x98\. These are the difference traces for three out of 256 values of
    the `guess` variable. When the `guess` variable matches the correct value of the
    key byte, you can see a large spike.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行示例代码，它应该会生成[图 10-12](#figure10-12)中的输出，显示 `guess` 变量的三种值：0x96、0x97 和 0x98
    的追踪。这些是 `guess` 变量 256 个值中的三种差异追踪。当 `guess` 变量与正确的密钥字节匹配时，你会看到一个大的峰值。
- en: '![f10012](image_fi/278748c10/f10012.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![f10012](image_fi/278748c10/f10012.png)'
- en: 'Figure 10-12: Output from a DPA attack on a single byte of the AES-128 encryption
    algorithm with key 0x97'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-12：对 AES-128 加密算法的单字节进行 DPA 攻击的输出，密钥为 0x97
- en: Although we are attacking only a single byte of the AES-128 encryption, we can
    repeat the attack for each byte of input to determine the entire 16-byte key.
    Remember how we fared guessing only over 8 bits? We didn’t make any special assumptions
    on which of the 8 bits of the key we broke. Therefore, we can do the same attack
    on any of the key bytes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只攻击了 AES-128 加密的一个字节，但我们可以对每个输入字节重复攻击，以确定整个 16 字节的密钥。记得我们猜测只有 8 位时的情况吗？我们没有做出任何关于破解哪个密钥的
    8 位的特殊假设。因此，我们可以对任何密钥字节进行相同的攻击。
- en: We now claim we can break all AES key bytes by attacking 16 times and only guessing
    8 bits for each attack! This is computationally entirely feasible, whereas doing
    a brute-force attack of 2^(128) is out of the question. The fundamental strength
    of DPA is that instead of brute-forcing the entire keyspace, we separate the cryptographic
    algorithm into subkeys and then brute-force those subkeys using additional information
    from power traces to validate subkey guesses. In this way, we have transformed
    the breaking of AES-128 implementations from the impossible to an achievable reality.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在声明，我们可以通过攻击 16 次并且每次仅猜测 8 位来破解所有 AES 密钥字节！从计算上来说，这是完全可行的，而进行 2^(128) 的暴力破解则根本不可能。DPA
    的基本强度在于，我们不是暴力破解整个密钥空间，而是将加密算法分解成子密钥，然后通过使用来自功率追踪的附加信息来验证子密钥猜测，从而暴力破解这些子密钥。通过这种方式，我们将破解
    AES-128 实现从不可能变为可以实现的现实。
- en: Correlation Power Analysis Attack
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关功率分析攻击
- en: The DPA attack assumes that for a particular device, you’ll get a difference
    in power consumption when a bit is a 1 or a 0\. As we explained, we can use any
    one of the 8 bits extracted from the lookup table to predict the key. This redundancy
    is something we can actually use to strengthen our attack. A straightforward way
    would be to use each bit as a separate “vote” into what subkey is the likely candidate,
    but we can be smarter. We can use a more advanced attack called a *correlation
    power analysis (CPA**)*, which will simultaneously model any number of bits and
    can, therefore, yield a stronger attack. In DPA/CPA terms, this means we need
    fewer traces to recover the key. CPA was introduced by Eric Brier, Christophe
    Clavier, and Francis Olivier in the CHES 2004 paper “Correlation Power Analysis
    with a Leakage Model.” We’ll present the mathematical notation along with the
    Python implementation so you can match the theory to real-world code. Until you
    actually implement the attack, the details will escape you (trust us), so grab
    a pen and paper and let’s dig in.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: DPA 攻击假设，对于某个特定设备，当一个比特是 1 或 0 时，功耗会有所不同。正如我们所解释的，我们可以使用从查找表中提取的任意 8 个比特之一来预测密钥。这个冗余实际上是我们可以用来增强攻击的东西。一种直接的方法是使用每个位作为一个单独的“投票”，来判断哪个子密钥是最有可能的候选者，但我们可以更加聪明。我们可以使用一种更高级的攻击，称为*相关功率分析（CPA**）*，它将同时对任意数量的比特进行建模，因此可以产生更强的攻击。在
    DPA/CPA 术语中，这意味着我们需要更少的追踪来恢复密钥。CPA 是由 Eric Brier、Christophe Clavier 和 Francis
    Olivier 在 CHES 2004 论文《带泄漏模型的相关功率分析》中引入的。我们将呈现数学符号及 Python 实现，帮助你将理论与实际代码对接。直到你真正实现这个攻击，细节可能会逃避你（相信我们），所以拿起笔和纸，让我们深入探讨吧。
- en: In DPA, we’re basically saying, “if some intermediate bit varies, the power
    consumption varies with it.” Although that’s true, it doesn’t capture the full
    extent of the relationship between data and power consumption. Refer to [Figure
    10-4](#figure10-4). The higher the Hamming weight of a word (that is, the more
    bits set), the higher the power consumption. It’s close to a perfect linear relationship.
    This relation seems to hold for any type of CMOS, so it applies quite nicely to
    microcontrollers. Now, how do we exploit this linearity?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在DPA中，我们基本上是在说：“如果某个中间位发生变化，功耗也会随之变化。”虽然这是对的，但它并没有完全捕捉到数据与功耗之间关系的全部范围。请参见[图10-4](#figure10-4)。一个字的哈明权重越高（即，设置的位越多），功耗越高。这接近完美的线性关系。这个关系似乎适用于任何类型的CMOS，因此它对微控制器非常适用。那么，我们如何利用这种线性呢？
- en: 'The basic idea in DPA is to make key guesses and predict what one bit in an
    intermediate value would be. In CPA, we make the same key guesses but predict
    the entire word of an intermediate value. In our AES example, we predict the 8-bit
    output of the S-box:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: DPA的基本思想是进行关键猜测并预测一个中间值中某一位的值。在CPA中，我们做相同的关键猜测，但预测整个中间值的字。在我们的AES示例中，我们预测S盒的8位输出：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, here comes the magic: after prediction, we calculate the Hamming weight
    of this predicted value. We know it’s very nearly linearly related to the actual
    power consumption. So, if our guess is correct, we should be able to find a linear
    relationship between the Hamming weight of the S-box outputs and the actual measured
    power consumption of a device. If our guess is incorrect, we won’t see a linear
    relationship because the Hamming weight we calculated for the predicted value
    was actually the Hamming weight for some other as-yet-unknown value, not for the
    value we predicted. What will be very useful to us is to find the `guess` that
    gives this linear relationship. How to exploit this linear relationship will become
    apparent as we turn our attention to a certain Mr. Pearson.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，魔法来了：预测之后，我们计算该预测值的哈明权重。我们知道它与实际的功耗几乎是线性相关的。因此，如果我们的猜测是正确的，我们应该能够找到S盒输出的哈明权重与设备实际测量功耗之间的线性关系。如果我们的猜测是错误的，我们就看不到线性关系，因为我们为预测值计算的哈明权重实际上是某个其他尚未知的值的哈明权重，而不是我们预测的那个值。对我们非常有用的是找到那个给出这种线性关系的`猜测`。如何利用这种线性关系将在我们关注某位皮尔逊先生时变得显而易见。
- en: Correlation Coefficient
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关系数
- en: The *sample Pearson’s correlation coefficient* *r* does what we are looking
    for. It measures the linear relationship between samples of two random variables—in
    our case, the measured power traces and the Hamming weight of the S-box output
    for a certain key `guess`. By definition, the Pearson correlation coefficient
    is +1 if these are perfectly linearly related; that is, the greater the power
    consumption, the higher the Hamming weight. If the correlation coefficient is
    –1, they are perfectly negatively correlated; that is, a higher Hamming weight
    correlates to a lesser power consumption.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*样本皮尔逊相关系数* *r* 做的正是我们所需要的。它衡量两个随机变量样本之间的线性关系——在我们这里，就是测量的功率轨迹与某个`猜测`的S盒输出的哈明权重之间的线性关系。根据定义，皮尔逊相关系数为+1时，表示它们完全线性相关；也就是说，功耗越大，哈明权重越高。如果相关系数为-1，则表示它们完全负相关；也就是说，更高的哈明权重与较低的功耗相关。'
- en: A negative correlation can happen in practice for various reasons, so we are
    typically interested in the absolute value of the correlation coefficient. If
    the correlation is 0, there is no linear relation whatsoever, and for our practical
    purposes, it means that for a certain key `guess`, the measured traces don’t correspond
    significantly at all to the Hamming weight of the S-box. By this observation,
    we can test how good a guess is and compare different guesses simply by looking
    at the absolute value of the Pearson correlation. The guess with the highest absolute
    correlation wins and is therefore likely the actual key!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实际中可能会出现负相关性，因此我们通常对相关系数的绝对值更感兴趣。如果相关系数为0，则说明完全没有线性关系，对于我们的实际目的来说，这意味着对于某个`猜测`，测量的轨迹与S盒的哈明权重之间没有显著的对应关系。通过这个观察，我们可以通过简单地查看皮尔逊相关系数的绝对值来测试一个猜测的好坏，并比较不同的猜测。相关系数绝对值最高的猜测获胜，因此很可能就是实际的密钥！
- en: First Some Nomenclature
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 先了解一些术语
- en: We’re about to introduce a bunch of variables in equations that map to Python
    expressions in the notebook. For your convenience, we give the mapping in [Table
    10-1](#table10-1).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将介绍许多在方程式中映射到笔记本中 Python 表达式的变量。为了方便你使用，我们在[表 10-1](#table10-1)中给出了映射。
- en: Converting from equation to Python is an important part of the following process,
    along with many of the attacks you’ll read about in the future. Creating simple
    mapping tables like [Table 10-1](#table10-1) can make your life a lot easier.
    If you have the companion code up and running, keep this page open to convert
    between equation and code quickly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从方程式转换为 Python 是以下过程中的一个重要部分，未来你将读到的许多攻击也与此相关。像[表 10-1](#table10-1)这样的简单映射表可以让你的工作变得更加轻松。如果你已经运行了伴随代码，保持此页面打开，以便快速在方程和代码之间转换。
- en: 'Table 10-1: Mapping Correlation Equation Variables to Notebook'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1：将相关方程变量映射到笔记本
- en: '| **Equation variable** | **Notebook** | **Meaning** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **方程变量** | **笔记本** | **含义** |'
- en: '| --- | --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *d* | `tnum` | Trace index [*0..D* – *1*] |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| *d* | `tnum` | 跟踪索引 [*0..D* – *1*] |'
- en: '| *D* | `number_traces` | Total number of traces |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| *D* | `number_traces` | 跟踪总数 |'
- en: '| *i* | `guess` | Guess that a subkey has value *i*[*0*..*I* – *1*] |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| *i* | `guess` | 假设子密钥的值为 *i*[*0*..*I* – *1*] |'
- en: '| *I* | `256` | Total number of possible subkey guesses |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| *I* | `256` | 可用子密钥猜测的总数 |'
- en: '| *j* | N/A (thanks, NumPy!) | Sample index [*0*..*T* – *1*] |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| *j* | 不适用（谢谢，NumPy！） | 样本索引 [*0*..*T* – *1*] |'
- en: '| h[*d,i*] | `hyp, intermediate()` | Hypothetical power consumption for trace
    *d* and subkey guess *i* |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| h[*d,i*] | `hyp, intermediate()` | 跟踪 *d* 和子密钥猜测 *i* 的假设功耗 |'
- en: '| *p*[*d*] | `input_data[d]` | Plaintext value for trace *d* |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| *p*[*d*] | `input_data[d]` | 跟踪 *d* 的明文值 |'
- en: '| *r*[*i,j*] | `cpaoutput` | Correlation coefficient for subkey guess *i* at
    sample index *j* |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| *r*[*i,j*] | `cpaoutput` | 子密钥猜测 *i* 在样本索引 *j* 处的相关系数 |'
- en: '| *t*[*d,j*] | `traces[d][j]` | Sample value for trace *d* at sample index
    *j* |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| *t*[*d,j*] | `traces[d][j]` | 跟踪 *d* 在样本索引 *j* 处的样本值 |'
- en: '| *T* | `numpoint` | The number of samples in each trace |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| *T* | `numpoint` | 每个跟踪中的样本数 |'
- en: Calculating the Data to Correlate
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算要关联的数据
- en: To calculate the correlation coefficient, we’ll need a table of actual power
    measurements from a device (see [Table 10-2](#table10-2)) and a column of hypothetical
    power measurements (see [Table 10-3](#table10-3)). Let’s first look at [Table
    10-2](#table10-2), the power measurement, which is generated using the code in
    the companion notebook.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算相关系数，我们需要一张来自设备的实际功率测量表（见[表 10-2](#table10-2)）和一列假设的功率测量值（见[表 10-3](#table10-3)）。我们首先来看[表
    10-2](#table10-2)，这是使用伴随笔记本中的代码生成的功率测量数据。
- en: 'Table 10-2: Power Measurements of *D* Traces (Rows), with Plaintext *p*[*d*]
    and *T* Samples at Various Time Indices *j* (Columns)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-2：*D* 个跟踪（行）的功率测量，包括明文 *p*[*d*] 和 *T* 个样本，在不同时间索引 *j*（列）处的测量数据
- en: '|  | **Plaintext *p*[*d*]** | **Measured ***j*** = 0** | **Measured ***j***
    = 1** | **Measured ***j*** = *T* – 1** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  | **明文 *p*[*d*]** | **测量值 ***j*** = 0** | **测量值 ***j*** = 1** | **测量值 ***j***
    = *T* – 1** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Trace *d* = 0** | 0xA1 | 151.24 | 153.56 | 152.11 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **Trace *d* = 0** | 0xA1 | 151.24 | 153.56 | 152.11 |'
- en: '| **Trace *d* = 1** | 0xC5 | 151.16 | 150.35 | 148.54 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **Trace *d* = 1** | 0xC5 | 151.16 | 150.35 | 148.54 |'
- en: '| **Trace *d* = 2** | 0x1B | 150.06 | 149.67 | 151.28 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **Trace *d* = 2** | 0x1B | 150.06 | 149.67 | 151.28 |'
- en: '| **Trace *d* = *D* – 1** | 0x55 | 149.09 | 152.42 | 151.00 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **Trace *d* = *D* – 1** | 0x55 | 149.09 | 152.42 | 151.00 |'
- en: The trace number *d* represents a given encryption operation, plaintext, and
    corresponding power trace. For the entire operation, we would record *T* samples
    of the power trace, each sample being a power measurement at a different point
    in time during the operation. The total number of samples in each trace depends
    on the sampling rate of our measurement and how long the operation is. For example,
    if our AES operation took 10ms (0.01s), and our oscilloscope recorded 100 million
    samples per second (MS/s), we would have 0.01 × 100,000,000 = 1,000,000 samples
    (that is, *T* = 1,000,000). In practical scenarios, *T* can be almost anything,
    but often it’s somewhere in the range of 100 to 1,000,000 samples. Our CPA attack
    will consider each sample independently, so we technically need only a *single*
    sample for each trace (but that single sample would need to be at the right time).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪编号 *d* 代表给定的加密操作、明文和相应的功率跟踪。对于整个操作，我们会记录 *T* 个功率跟踪样本，每个样本代表在操作过程中某个时间点的功率测量。每个跟踪中的样本总数取决于我们的测量采样率以及操作的持续时间。例如，如果我们的
    AES 操作花费了 10 毫秒（0.01 秒），且我们的示波器每秒记录 1 亿个样本（MS/s），那么我们将得到 0.01 × 100,000,000 =
    1,000,000 个样本（即 *T* = 1,000,000）。在实际场景中，*T* 可以是几乎任何数值，但通常在 100 到 1,000,000 个样本之间。我们的
    CPA 攻击将独立考虑每个样本，因此从技术上讲，我们每个跟踪只需要一个 *单一* 样本（但这个单一样本必须在正确的时间）。
- en: For the hypothetical power measurements, we no longer have a sample (or time)
    axis. Instead, we consider what the hypothetical power consumption would be for
    the same trace number (the same *d* index), given a key guess *i*. What happened
    to time then? Earlier, we said that the attack could succeed with a single sample
    point at the “right time.” The “right time” actually means the time when the device
    is performing the operation on which we modeled our hypothetical power consumption.
    This means our hypothetical measurement doesn’t need a time index because we are
    defining the time as being during the operation of interest. With the physical
    measurement, we don’t know when that operation occurred, so we need to record
    a longer power trace that includes that operation (but also includes other stuff
    our attack will weed out). [Table 10-3](#table10-3) shows the hypothetical value
    table we’re working with in this example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于假设的功率测量，我们不再拥有样本（或时间）轴。相反，我们考虑在给定密钥猜测 *i* 的情况下，针对相同的跟踪编号（相同的 *d* 索引），假设的功率消耗是什么。那时，时间发生了什么变化？之前我们说过，攻击可以通过单个样本点在“正确的时间”成功。“正确的时间”实际上是指设备正在执行我们为其建模假设功率消耗的操作时的时间。这意味着我们的假设测量不需要时间索引，因为我们已经将时间定义为操作发生的时刻。对于物理测量，我们不知道操作发生的具体时间，因此我们需要记录一个更长的功率跟踪，其中包含该操作（但也包括我们的攻击会排除的其他部分）。[表
    10-3](#table10-3)展示了我们在这个示例中使用的假设值表。
- en: 'Table 10-3: Plaintext and Hypothetical Value with *d* Traces and *i* Guesses'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-3：具有 *d* 跟踪和 *i* 猜测的明文与假设值
- en: '|  | **Plaintext *p*[*d*]** | **Guess ***i*** = 0** | **Guess ***i*** = 1**
    | **Guess ***i*** = 2** | **Guess ***i*** = *I*– 1** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  | **明文 *p*[*d*]** | **猜测 ***i*** = 0** | **猜测 ***i*** = 1** | **猜测 ***i***
    = 2** | **猜测 ***i*** = *I*– 1** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **Trace *d* = 0** | 0xA1 | 3 | 3 | 2 | 3 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **跟踪 *d* = 0** | 0xA1 | 3 | 3 | 2 | 3 |'
- en: '| **Trace *d* = 1** | 0xC5 | 4 | 3 | 4 | 1 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **跟踪 *d* = 1** | 0xC5 | 4 | 3 | 4 | 1 |'
- en: '| **Trace *d* = 2** | 0x1B | 6 | 3 | 4 | 4 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **跟踪 *d* = 2** | 0x1B | 6 | 3 | 4 | 4 |'
- en: '| **Trace *d* = *D* – 1** | 0x55 | 6 | 1 | 5 | 4 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **跟踪 *d* = *D* – 1** | 0x55 | 6 | 1 | 5 | 4 |'
- en: For each key guess, we calculate the Hamming weight of the S-box output and
    put the results in a table, with one column for each guess, numbered from 0 to
    255\. Our hypothesis is that if the secret key byte is 0x00, the power measurements
    will look like column 0; if the secret key byte is 0x01, the power measurements
    will look like column 1; and if the secret key byte is 0xFF, the power measurements
    will be as in column 255\. We want to see which column (if any) strongly correlates
    to the physical power measurements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个密钥猜测，我们计算 S-box 输出的汉明重量，并将结果放入表格中，每个猜测占一列，编号从 0 到 255。我们的假设是，如果秘密密钥字节是 0x00，则功率测量将类似于第
    0 列；如果秘密密钥字节是 0x01，则功率测量将类似于第 1 列；如果秘密密钥字节是 0xFF，则功率测量将与第 255 列类似。我们想查看哪一列（如果有的话）与物理功率测量高度相关。
- en: Earlier, we used tables of measured power traces. Here, we’ll represent those
    tables by the notation *t*[*d,j*] , where *j* = 0,1, . . ., *T – 1* is the time
    index in the trace, and *d* = 0,1, . . . , *D – 1* is the trace number. If you
    are following along with the code example in the Jupyter notebook for this section,
    we are indexing into a variable called `traces[d][j]`. As we mentioned before,
    if the attacker knows exactly where a cryptographic operation occurred, they would
    need to measure only a single point, such that *T* = 1\. For each trace number
    *d*, the attacker also knows the plaintext corresponding to that power trace,
    defined as *p*[*d*]. The variable *p*[*d*] is equivalent to `input_data[d]` in
    the companion code, and it’s the first column in Tables 10-2 and 10-3.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用了测量的功率跟踪表。在这里，我们将使用符号 *t*[*d,j*] 来表示这些表，其中 *j* = 0,1, . . ., *T – 1*
    是跟踪中的时间索引，*d* = 0,1, . . . , *D – 1* 是跟踪编号。如果你正在跟随本节的 Jupyter 笔记本中的代码示例，我们正在索引一个名为
    `traces[d][j]` 的变量。如前所述，如果攻击者确切知道加密操作发生的位置，他们只需要测量一个单独的点，即 *T* = 1。对于每个跟踪编号 *d*，攻击者还知道与该功率跟踪对应的明文，定义为
    *p*[*d*]。变量 *p*[*d*] 相当于随附代码中的 `input_data[d]`，并且是表 10-2 和 10-3 中的第一列。
- en: Bring in the Functions
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引入函数
- en: 'We’ll define several functions here: we write the hypothetical power consumption
    of a device for trace number *d* and secret key guess *i* as *h*[*d,i*] = *l*(*w*(*p*[*d*],
    *i*)), where *l*(*x*) is the *leakage model* for a given intermediate value *x*,
    and *w*(*p*[*d*], *i*) generates this intermediate value *x* given the input plaintext
    *p*[*d*] and the guess of value *i* as the secret key. (We’ll dive into leakage
    models soon.) This function *h*[*d,i*] becomes the *hypothetical value table*,
    where we are asking what the power measurement should look like for a hypothetical
    secret key byte. These are the remaining columns in [Table 10-3](#table10-3).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此定义几个函数：我们将设备在跟踪编号 *d* 和秘密密钥猜测 *i* 下的假设功耗表示为 *h*[*d,i*] = *l*(*w*(*p*[*d*],
    *i*)), 其中 *l*(*x*) 是给定中间值 *x* 的 *泄漏模型*，*w*(*p*[*d*], *i*) 给定输入明文 *p*[*d*] 和秘密密钥的猜测
    *i* 生成该中间值 *x*。 （我们很快会深入研究泄漏模型。）此函数 *h*[*d,i*] 成为 *假设值表*，我们在这里询问在假设的秘密密钥字节下，功率测量应该是什么样子。这些是[表
    10-3](#table10-3)中的剩余列。
- en: 'Let’s again assume that the power consumption of a microcontroller depends
    on the Hamming weight of the output of the S-box, as in the DPA example of AES-128\.
    Now, we can update our function definitions to be more specific for AES-128 (⊕
    means XOR):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再假设微控制器的功耗取决于 S-box 输出的 Hamming 权重，就像 AES-128 的 DPA 示例一样。现在，我们可以更新我们的函数定义，使其更具体地适用于
    AES-128（⊕ 表示异或）：
- en: '*l(x) = HammingWeight(x)*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*l(x) = HammingWeight(x)*'
- en: '*w(p,i) = SBox(p ⊕ i)*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*w(p,i) = SBox(p ⊕ i)*'
- en: The `HammingWeight()` function returns the number of ones in an 8-bit value,
    and the `SBox()` function returns the value of the AES S-box lookup table. Check
    the companion notebook for a Python implementation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`HammingWeight()` 函数返回一个 8 位值中的 1 的个数，而 `SBox()` 函数返回 AES S-box 查找表的值。请查看随附的笔记本以获取
    Python 实现。'
- en: Calculating the Correlation
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算相关性
- en: 'Now we’ll use the correlation coefficient *r* to look for a linear relationship
    between the hypothetical power consumption *l*(*x*) and the measured power consumption
    *t*[*d*],[*j*] . Finally, we can calculate the correlation coefficient for each
    point 0 ≤ *j* < *T* over all traces 0 ≤ *d* < *D*, for each possible subkey value
    0 ≤ *i* < *I*, by plugging these values into the formula for the Pearson correlation
    coefficient:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用相关系数 *r* 来寻找假设功耗 *l*(*x*) 和测量功耗 *t*[*d*],[*j*] 之间的线性关系。最后，我们可以通过将这些值代入
    Pearson 相关系数的公式，计算每个点 0 ≤ *j* < *T* 在所有跟踪 0 ≤ *d* < *D* 中的相关系数，对于每个可能的子密钥值 0 ≤
    *i* < *I*：
- en: '![e10002](image_fi/278748c10/e10002.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![e10002](image_fi/278748c10/e10002.png)'
- en: 'Here’s some detail on the functions just introduced:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是刚才介绍的函数的一些细节：
- en: '![](image_fi/278748c10/e10007.png) *x* is the sum of *x* performed over all
    *D* traces.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](image_fi/278748c10/e10007.png) *x* 是在所有 *D* 跟踪中执行的 *x* 的总和。'
- en: '*h*[*i*] is the average (mean) hypothetical leakage over all traces *D* for
    guess *i*. If the leakage is the Hamming weight of a byte, the leakage could range
    from 0 to 8, inclusive. (For a large number of traces, this leakage thus should
    have a mean of 4 and be independent of *i*.)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*h*[*i*] 是猜测 *i* 对所有 *D* 跟踪的平均（均值）假设泄漏。如果泄漏是字节的 Hamming 权重，则泄漏的范围可以从 0 到 8（包括）。
    （对于大量的跟踪，泄漏的均值应为 4，并且与 *i* 无关。）'
- en: '*t*[*j*] is the average (mean) power measurement over all *D* traces at point
    *j*.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t*[*j*] 是在所有 *D* 跟踪中，点 *j* 处的平均（均值）功率测量值。'
- en: If we compute this correlation for [Table 10-2](#table10-2) and [Table 10-3](#table10-3),
    we get [Table 10-4](#table10-4). The rows in this table are the *correlation traces*,
    and the columns are various points in time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-4: The Correlation Trace *r* for Each Key Guess *i*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Corr ***j*** = 0** | **Corr ***j*** = 35** | **Corr ***j*** = *T* –
    1** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| **Guess ***i*** = 0x00** | 0.02 | –0.01 | 0.11 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| **Guess ***i*** = 0x01** | 0.06 | –0.01 | 0.06 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| **Guess ***i*** = 0x97** | –0.00 | 0.54 | –0.12 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| **Guess ***i*** = 0xFF** | –0.01 | 0.18 | 0.12 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: For the correct time (*j* = 35) and key guess (*i* = 0x97), the correlation
    is significantly higher. Of course, the “full” table would have all sample points
    (times), with the *j* index ranging from 0 to *T* – 1, along with all key guesses
    from 0 to *I* – 1\. The endpoint of key guesses *I* – 1 in this example is 0xFF,
    as our leakage model was based on a single-byte input, which can only take on
    the values 0x00 to 0xFF. We’ve shown a few examples of some sample points to keep
    this table looking presentable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Attacking AES-128 Using CPA
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we can use CPA to detect leakage, let’s run through an example of attacking
    a single byte of the AES-128 algorithm as we did in the “Attacking AES-128 Using
    DPA” section on page 310. We’ll use the `measure_power()` function again, with
    the goal of attacking this single byte. We’ll extend the previous examples to
    create an `intermediate()` function, which represents the value h[d,i] = l(w(p[d],
    i)). For a given byte of plaintext input and a guess of the key, this function
    returns the expected Hamming weight of the intermediate value. The CPA attack
    will use this when comparing the expected leakage to the actual measured leakage.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Summation Loop
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Notice in the Pearson correlation coefficient equation that there are effectively
    three sums over all traces. For this initial implementation, we’ll calculate some
    of those sums and break them into this format:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![e10003](image_fi/278748c10/e10003.png)![e10004](image_fi/278748c10/e10004.png)![e10005](image_fi/278748c10/e10005.png)![e10006](image_fi/278748c10/e10006.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: In Python, we first calculate all means using the current key guess. Then, for
    each trace, we update all the sum variables. A sum is generated for each sample
    point presented at the input. Again, the Pearson correlation coefficient result
    (which is used by the CPA attack) determines where the specific sensitive operation
    occurred; you don’t need to know ahead of time when the encryption occurred.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Correlation Calculation and Analysis
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To finish the attack, we generate the correlation trace by combining the sums.
    We plot the correlation trace for different guess numbers with the expectation
    that the largest peak occurs with the correct key guess (see [Figure 10-13](#figure10-13)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![f10013](image_fi/278748c10/f10013.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-13: Correlation plot of the correct key guess (0x97) and two incorrect
    key guesses'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The correlation traces ought to show a strong correlation at the point where
    the guess matches the secret value in use by the device. The spike in [Figure
    10-13](#figure10-13) and in correlation graphs in general show a strong *positive*
    correlation, but you might end up with a strong *negative* correlation for the
    correct key guess if you measure the power consumption in reverse of what the
    model predicts. This negative correlation might be because you are measuring in
    the GND path instead of the VCC path, or your probe might be connected in reverse
    polarity, or your measurement setup may cause inverted readings for some other
    reason. So, in order to determine the correct key guess, we just look at the absolute
    value of the correlation peak.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性追踪应该在猜测与设备使用的秘密值匹配的点上显示强相关性。[图10-13](#figure10-13)中的峰值以及相关性图表通常显示强*正*相关，但如果你反向测量功耗，你可能会得到一个强*负*相关性，尽管这是正确的密钥猜测。这种负相关性可能是因为你在GND路径而不是VCC路径中进行测量，或者你的探针可能连接了反向极性，或者你的测量设置可能因为其他原因导致反向读取。因此，为了确定正确的密钥猜测，我们只需查看相关性峰值的绝对值。
- en: The CPA attack is a way to break cryptographic implementations that are generally
    too secure for a DPA attack because CPA considers the leakage from all 8 bits
    (for an 8-bit system). The DPA attack considers only a single bit. The principle
    of a CPA attack is based on the observation that you can linearly relate the Hamming
    weight of an intermediate variable to a device’s power consumption, and that it
    employs correlation to exploit this relationship.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: CPA攻击是一种破解加密实现的方法，通常对于DPA攻击来说过于安全，因为CPA考虑了来自所有8个比特（对于一个8位系统）的泄漏，而DPA攻击仅考虑一个比特。CPA攻击的原理基于这样的观察：你可以将中间变量的哈明重量与设备的功耗线性相关，并且它利用相关性来利用这种关系。
- en: Try adjusting the number of traces downward on both the DPA and CPA attacks
    until they fail to recover the correct key reliably. You’ll probably find that
    at around 200 traces, the DPA attack will fail to recover the correct key, while
    the CPA attack will recover the correct key down to about 40 traces. Both simulated
    systems have the same amount of noise; the CPA attack uses the contribution from
    multiple bits to achieve much better results.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将DPA和CPA攻击的追踪次数减少，直到它们无法可靠地恢复正确的密钥。你可能会发现，在大约200次追踪时，DPA攻击无法恢复正确的密钥，而CPA攻击则能够在大约40次追踪下恢复正确的密钥。两个模拟系统的噪声量相同；CPA攻击通过使用多个比特的贡献来实现更好的结果。
- en: Leakage Models and Sensitive Values
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 泄漏模型和敏感值
- en: A *leakage model* describes how data values processed on a device are expressed
    in a side channel. So far, we’ve used the Hamming weight leakage model, where
    the power consumption had some linear relationship to the number of bits set in
    an I/O line. As a sensitive value, we chose an intermediate state shortly after
    a secret value was mixed with our known input data and after a nonlinear operation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*泄漏模型*描述了在设备上处理的数据值如何在旁路通道中表现出来。到目前为止，我们使用了哈明重量泄漏模型，其中功耗与I/O线中设置的比特数之间有某种线性关系。作为敏感值，我们选择了一个中间状态，即在一个秘密值与已知输入数据混合并经过非线性操作后不久的状态。'
- en: Hamming weight leakage occurred due to the phenomenon of bus pre-charging. However,
    not all leakage in the chip is due to pre-charged buses. Another commonly found
    leakage model is *Hamming distance (HD)*. The HD model is based on the fact that
    when a register moves from one state to the next, the power consumption depends
    solely on the number of bits that change state. Therefore, when using this model,
    you will care only about the number-of-bits difference between two clock cycles.
    [Figure 10-14](#figure10-14) shows an example of the HD for a register.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于总线预充电现象，发生了哈明重量泄露。然而，并非所有芯片中的泄露都是由于预充电总线引起的。另一种常见的泄露模型是*哈明距离（HD）*。HD模型基于这样的事实：当一个寄存器从一个状态转移到下一个状态时，功耗仅取决于改变状态的比特数。因此，在使用该模型时，您只关心两个时钟周期之间的比特数差异。[图10-14](#figure10-14)显示了寄存器的HD示例。
- en: '![f10014](image_fi/278748c10/f10014.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![f10014](image_fi/278748c10/f10014.png)'
- en: 'Figure 10-14: The Hamming distance of a register over three consecutive clock
    cycles'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-14：寄存器在三个连续时钟周期中的哈明距离
- en: This progression shows that the leakage reflects the changes in the register’s
    state. If this register was holding the output of an S-box, you’d need to know
    (or guess) the *previous* state of this register to break the *current* state.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程表明，泄漏反映了寄存器状态的变化。如果这个寄存器保存的是 S-box 的输出，你需要知道（或猜测）这个寄存器的*先前*状态，才能破解*当前*状态。
- en: Cryptographic implementations in hardware, such as an AES peripheral in a microcontroller
    where the algorithm isn’t running as a software process, are much more likely
    to be vulnerable to the HD leakage. Since they typically have only a small number
    of interconnections between registers (compared to the main data bus), they don’t
    bring data lines to a pre-charge state, which leads us to detect a Hamming distance
    as opposed to a Hamming weight. When attacking these devices, we need to calculate
    the hypothetical power consumption of a change, which means we need to determine
    the previous state of such a sensitive register. It might be that the previous
    state was simply the last used input byte, or it could have been the output from
    the last time the encryption operation was run.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件中的密码学实现，例如微控制器中的 AES 外设，其中算法并未作为软件进程运行，更容易受到 HD 泄漏的影响。由于它们通常只有少数几个寄存器之间的连接（与主数据总线相比），它们不会将数据线预充电，这导致我们检测到的是哈明距离而不是哈明权重。在攻击这些设备时，我们需要计算变化的假设功耗，这意味着我们需要确定该敏感寄存器的先前状态。先前的状态可能只是最后使用的输入字节，或者可能是上次加密操作运行时的输出。
- en: Determining the previous value in circuits that are specialized for implementing
    AES-128 can be expected to present more challenges because that value will now
    depend on hardware design details (as shown earlier in [Figure 10-11](#figure10-11)).
    Hardware designers have more flexibility than software designers do, and in implementing
    AES-128, they may choose to use 16 copies of the S-box lookup tables running in
    parallel or to share a single S-box lookup table between all input bytes by successively
    performing the lookup, as shown in [Figure 10-15](#figure10-15). It may take some
    sleuthing to identify which approach they chose.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在专门实现 AES-128 的电路中，确定先前的值可能会面临更多挑战，因为该值现在将依赖于硬件设计的细节（如前面在[图 10-11](#figure10-11)中所示）。硬件设计师比软件设计师具有更大的灵活性，在实现
    AES-128 时，他们可能会选择使用 16 个并行运行的 S-box 查找表，或者像[图 10-15](#figure10-15)中所示，逐个执行查找操作来共享一个
    S-box 查找表给所有输入字节。可能需要一些侦查工作才能确定他们选择了哪种方式。
- en: '![f10015](image_fi/278748c10/f10015.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![f10015](image_fi/278748c10/f10015.png)'
- en: 'Figure 10-15: Approaches to implementing AES in hardware'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-15：硬件中实现 AES 的方法
- en: 'The choice of implementation will depend on the purpose of the device: a general-purpose
    microcontroller will likely accept slower throughput when a very small, low-power
    AES core is being designed, whereas an AES core designed to operate on a hard
    drive or network controller will trade off whatever power or device size restrictions
    there may be to accommodate multi-Gbps throughput. You may be able to deduce something
    about the structure by measuring the number of clock cycles AES takes and then
    dividing it by the number of rounds. At roughly 1 clock per round, all S-boxes
    (and other AES operations within the round) run in parallel. At roughly 4 clocks
    per round, operations such as `SubBytes` and `MixColumns` are executed in separate
    clock cycles. Once you get to 20+ clock per round, `SubBytes` is likely implemented
    with a single S-box.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的选择将取决于设备的目的：当设计一个非常小且低功耗的 AES 核心时，一般用途的微控制器可能会接受较慢的吞吐量，而设计用于硬盘或网络控制器的 AES
    核心则会在吞吐量达到多 Gbps 的情况下，牺牲可能存在的功率或设备大小限制。你可能通过测量 AES 所需的时钟周期数，并将其除以轮次，来推测某些结构。在大约每轮
    1 个时钟周期时，所有的 S-box（和轮内其他 AES 操作）都是并行运行的；在大约每轮 4 个时钟周期时，`SubBytes` 和 `MixColumns`
    等操作会在单独的时钟周期中执行。当每轮时钟周期数达到 20+ 时，`SubBytes` 很可能是通过单个 S-box 实现的。
- en: 'The less you know about a target, the more you need to use trial and error
    to determine how it implements crypto. If you find that the output of a device’s
    S-box isn’t leaking, try guessing bytes after the `MixColumns` operation (described
    earlier in the section “Know Thy Enemy: An Advanced Encryption Standard Crash
    Course”). If the Hamming weight method shows no correlation, try the Hamming distance
    approach. Ilya Kizhvatov’s “Side Channel Analysis of AVR XMEGA Crypto Engine”
    provides a great example of this in practical circuits, showing how to break the
    XMEGA AES peripheral. You’ll also find a step-by-step tutorial repeating that
    XMEGA attack as part of the ChipWhisperer project, where you can experiment with
    these results yourself.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: DPA on Real (but Still Toy) Hardware
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Chapter 8 explained how to perform power measurements for SPA. The acquisition
    setup in this chapter for DPA is the same, so we’ll build on that here. Don’t
    attempt to attack a real device until you understand how DPA works and have simulated
    the Python attack. Take it from the experts: triple-check every step you take.
    It’s easy for a single bug in your acquisition or analysis to prevent you from
    seeing any leakage.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: We’ll insert AES into a simple software framework, with the firmware performing
    an encryption operation. You can use any AES library for the encryption, such
    as the open source avr-crypto-lib. You’ll even find ports of this library to Arduino([https://github.com/DavyLandman/AESLib/](https://github.com/DavyLandman/AESLib/),
    for example).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-3](#listing10-3) shows an example of source code that is capable
    of receiving data over the serial port and initiating an encryption.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 10-3: Sample microcontroller firmware in C for performing a simple
    encryption on a trigger'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: This example has a very simple serial protocol; you send 16 bytes of the key
    in ASCII, 16 bytes of plaintext, and the system responds with the encrypted data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could open a serial port and send the following text:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The AES-128 module would then respond with `3ad77bb40d7a3660a89ecaf32466ef97`.
    Test your implementation by researching “AES-128 Test Vectors” on the internet.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with a Target Device
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having defined your own serial protocol to send and receive data, communication
    with the target should be simple. As with the SPA examples, we’ll send some data
    to the target and record its power consumption during the AES operation. If you
    followed along with the companion notebook, it showed how to perform the measurement
    on a virtual device; simply replace the measurement function with a call to the
    physical device.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The previous simulated measurement examples performed this attack on a single
    byte, but you’ll need to send 16 bytes to the real device. You can choose to perform
    the attack on any arbitrary byte or iterate through each byte.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Again, trigger on the rising edge of the I/O line to determine the exact data
    points of interest. When targeting the first round of AES, for example, move the
    `trigger_high()` code shown in [Listing 10-3](#listing10-3) inside the AES function
    such that the line is high only at around the time of your sensitive operation
    (such as the output of the S-box lookup).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Oscilloscope Capture Speed
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As in the SPA attack, you can determine the required sample rate experimentally
    for any platform or device. In general, the DPA attack will require considerably
    higher sample rates than SPA, because we’ll be classifying the data into one of
    many groups based on small variations in the power. In contrast, the SPA attack
    often matches only large variations in the appearance of the power traces, with
    the result that SPA can operate in conditions with much larger noise and timing
    jitter than what DPA can.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In general, when attacking a software implementation such as AES on a microcontroller,
    it should be sufficient to sample the device at around 1 to 5 times the clock
    speed. Attacking hardware implementations requires a higher sample rate, frequently
    (pun intended) at 5 to 10 times the clock speed. These are, however, vague rules
    of thumb at best; your choice of sample rate will depend on your device leakage,
    measurement setup, and quality of oscilloscope. Certain sampling methods, such
    as the synchronous sampling used in the ChipWhisperer platform, can also relax
    those requirements so you can even sample at the clock speed itself (1 times the
    clock speed) and have a successful attack.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter (and the previous two chapters) concentrated on attacking platforms
    that you control. These are great learning targets, and we encourage you to try
    a range of algorithms and measurement variants to get a feel for how your choices
    affect leakage detection. With this ability, you’ll be ready to move on to the
    next level: attacking black-box systems. To do so effectively, you need a fundamental
    understanding of how cryptography is implemented on embedded systems and how to
    use your side-channel analysis toolbox against those systems.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce some additional tools for attacks on real systems
    where you don’t have a convenient trigger signal or know the implementation’s
    exact details. Your patience will be tested severely.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
