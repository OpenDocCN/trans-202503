- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I²C Programming in Real-Time Operating Systems
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: I²C transmissions are slow, typically 100 kHz. In systems like Arduino, your
    code must wait for each transmission or reception to complete before doing other
    work, which drastically reduces your application’s performance. While waiting,
    the CPU is just executing a busy-waiting loop (also called a *spin loop*), wasting
    CPU cycles. In this chapter, you’ll learn to use real-time operating systems (RTOSs)
    to put those CPU cycles to work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces several different RTOSs—µC/OS, FreeRTOS, Teensy Threads,
    and Mbed—that you can run on typical SBCs, and it provides an example program
    using I²C for each. Some RTOSs, such as Mbed, provide full I²C support. Others,
    like FreeRTOS and Teensy Threads, are simple schedulers for which you must provide
    your own compatible I²C library code. The choice of RTOS is often dictated by
    the SBC you’re using, since if you’ve chosen a particular SBC to use, you can
    run only an RTOS that has been ported to that board. Conversely, if you want to
    use a particular RTOS, you must choose an SBC to which it has been ported—unless
    you’re willing to set up the port yourself, which is generally a lot of work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins with a description of some basic RTOS concepts and then
    introduces a few RTOSs, along with one or a few representative SBCs to use with
    the RTOS the section describes. This is not to suggest that the SBC I pair with
    a given RTOS is the only (or even the best) SBC to use with that RTOS—these are
    just the components I had available while writing this book. For most of these
    RTOSs, you’ll generally have a much wider selection of platforms to choose from
    when designing your own systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 Real-Time Operating System Basics
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of an RTOS is to handle asynchronous events, such as the completion
    of an I²C transmission, within a guaranteed amount of time. Another way to do
    this, of course, is via *polling*—the CPU simply waits in a spin loop, testing
    for the event until it occurs and then immediately handling it. While polling
    has some advantages (in particular, it can provide the fastest response time to
    an event), there’s also a huge disadvantage: the CPU is tied up in the spin loop
    and cannot do other work.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: This book will typically use the term *task* to denote some generic execution
    unit that is running (pseudo-)concurrently with other execution units. Threads
    and processes are examples of types of tasks, which I’ll discuss shortly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: RTOSs allow other tasks to do work while the CPU is waiting for some event to
    occur. Some hardware support is needed to make this practical; in particular,
    the external event must be capable of generating an interrupt signal on the CPU.
    As its name suggests, an *interrupt signal* will cause the CPU to suspend execution
    of the currently executing task and transfer control to a special ISR that will
    handle the event. For some devices, the ISR completely handles the event, and
    the suspended task resumes control. With most RTOSs and ISRs, however, the ISR
    simply sets a flag that notes the event has occurred, and the RTOS will schedule
    the execution of the original code (which was waiting for the completion of an
    I²C transaction or some other task) for some point in the future.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: In the context of an I²C write, for example, a call to the write function will
    set up the I²C hardware to begin the transmission of the data on the I²C bus.
    Then the task that is writing the data will *suspend*, allowing other tasks to
    do some work. When the I²C transmission is complete, the I²C hardware will generate
    an interrupt, and the ISR will make a special system call to the RTOS telling
    it to wake up the suspended task that was writing data to the I²C bus.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The RTOS moves the I²C write task from a suspended queue to a ready-to-run queue.
    This, however, does not guarantee that the I²C write task immediately begins execution
    (that depends on various RTOS scheduling policies). Control might transfer back
    to the task that was just suspended when the interrupt came along.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: At some point in the future, the RTOS will decide to allow the I²C write task
    to continue execution. It will then move the task off the ready-to-run queue and
    start it running, suspending the currently executing task. At that time, the I²C
    write task can continue doing whatever it needs to do, such as writing additional
    data, reading data, or simply returning to the application that requested the
    I²C write operation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.1 Processes and Threads
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Operating systems theory defines multiple levels of tasks, including processes
    and threads. As noted earlier, this book will use the generic term *task* *to
    describe both processes and threads.*
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '*A *thread* is a unit of execution that shares an address space with other
    concurrently executing threads. Because the threads share memory (the address
    space), one thread can change the memory that another thread reads. This provides
    an easy way for the threads to communicate with one another, but it also introduces
    some problems, as you’ll see in the next section.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: A *process* is a unit of execution that has its own address space and does not
    share that memory with other processes. Communication between processes is a little
    more difficult than with threads, since you typically have to use files or other
    OS-defined data structures for the communication. However, because the processes
    can’t overwrite each other’s memory spaces, there’s less opportunity for them
    to interfere with one another.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: An application may consist of one or more processes. Each process will contain
    one or more threads. The simplest application consists of a single process executing
    a single thread. One step up in complexity is an application executing a single
    process that has multiple threads of execution. Above that are applications with
    multiple processes, each with one or more threads of execution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The easiest visualization of multiple processes and threads is to think of each
    process and thread corresponding to procedures or functions in a programming language.
    Each independent process or thread corresponds to a unique function that executes
    the code for that process or thread. While this is a simple model to visualize,
    it is actually common for different processes and threads to share the same code.
    For example, two threads of execution could run the same function in memory, perhaps
    being passed different parameters to allow them to do different operations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.2 Multithreading and Multitasking
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The principal function of an RTOS is to allow multiple threads to run concurrently.
    A few microcontrollers include multiple CPUs (*multicore CPUs*), meaning two or
    more tasks really can run on different CPUs at exactly the same time. However,
    most embedded microcontrollers are limited to a single CPU (core), allowing only
    a single task to run at any given time. To simulate multitasking (also known as
    *multithreading*), RTOSs rapidly switch between tasks to give the illusion that
    multiple tasks are executing concurrently.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Most modern RTOSs use preemption to suspend one task and then allow another
    to execute. Each RTOS uses a given policy to determine how to preempt a running
    task. Some RTOSs give each task a fixed amount of time to run and switch between
    tasks when the timer expires. This time period is known as a *time slice* or *time
    quantum*; the process of switching between tasks is called *time multiplexing*.
    Other RTOSs assign priorities to different tasks and allow higher-priority tasks
    to run unimpeded until they suspend or a higher-priority task is ready to run.
    Many RTOSs use a combination of these policies. For example, if two tasks with
    the same priority are ready to run, they use time slicing to switch between themselves,
    while lower-priority tasks remain suspended until both tasks suspend themselves.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In a pure priority-based system, lower-priority tasks may never run if some
    higher-priority task is always running. This could lead to *starvation*, meaning
    a given task never executes. Many RTOSs temporarily raise the priority of a low-priority
    task after some time period to ensure it gets some attention every now and then.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: An RTOS’s scheduling policy determines how it selects the next task to run.
    For example, if an RTOS assigns equal priority to tasks and gives each task a
    time slice of equal size, the scheduling policy decides how the CPU chooses the
    next task to run when one task completes its time slice (or suspends for some
    other reason). One obvious solution is a *round-robin* scheduling policy in which
    the RTOS maintains a queue of ready-to-run tasks and picks the task off the front
    of the queue when switching between tasks; it places the newly suspended task
    at the end of the queue. Most of the time, this ensures a fair allocation of CPU
    resources to each of the ready-to-run tasks. There are some degenerate cases where
    this scheme is not entirely fair. For example, if a particular task suspends more
    frequently than others, it must wait through the whole queue again even though
    it uses little CPU time while actually running. However, as a quick-and-dirty
    solution, round-robin scheduling works well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes an application can control various aspects of the scheduling priority,
    but more often than not the application has to live with the scheduling policies
    provided by the operating system. Tuning RTOS policies is beyond the scope of
    this book, but to learn more, see “For More Information” at the end of this chapter
    or the manual for your particular RTOS. Fortunately, I²C activities tend to be
    very slow (at least, when running at 100 kHz), so scheduling tuning generally
    won’t affect the performance of an I²C-based application by that much.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.3 Reentrancy
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps the biggest problem with programming I²C devices in a multithreaded
    environment is *reentrancy*, which occurs when two separate threads attempt to
    run the same code concurrently. An I²C device is a single, shared system resource.
    If a function called by two separate threads attempts to communicate with an I²C
    device, a second thread reentering that same function will attempt to talk to
    that same device concurrently. If one thread started to write a 2- or 3-byte sequence
    to the device and was interrupted after transmitting the first byte, then from
    the device’s perspective, the first byte from the second thread would look like
    the second byte from the first thread. If two threads are going to share the same
    I²C device, proper operation will take very careful synchronization on the part
    of the two threads.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Even if two threads don’t access the same device, two different threads cannot
    talk to two different devices simultaneously on the same bus. Once again, different
    threads must synchronize their use of the same I²C bus. In some respects, this
    is similar to having two controllers sharing the bus; however, there is no protocol
    to handle conflicts—the individual threads must handle contention on their own.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.4 Synchronization
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Synchronization is typically handled by mutexes (mutual exclusion primitives),
    critical sections, semaphores, events, and other such OS synchronization primitives.
    The basic idea behind all of these operations is to allow access to some section
    of code by only one thread at a time. In a typical RTOS, a thread will request
    exclusive access to a critical section of code. If the RTOS grants this request,
    future requests by other threads will be blocked until the original thread holding
    the critical section releases it. This mechanism allows only a single thread to
    enter the critical section at a time, thus eliminating the problems with reentrancy.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: While a thread is waiting for some other thread to release a critical section,
    the waiting thread is suspended (blocked) and does not consume any CPU cycles
    waiting for the release of the critical section. In the case of I²C transmission,
    this blockage could last a considerable amount of time; the thread holding the
    critical section could be transmitting and receiving several bytes on the I²C
    bus (typically requiring 100 μmsec to 1,000 μmsec per byte, plus more if clock
    stretching occurs). The good news is that the blocked thread does not interfere
    with the current transmission taking place on the I²C bus.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.5 Safety Critical Systems
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Certain RTOSs such as µC/OS or FreeRTOS have been *safety qualified*, meaning
    that they have been thoroughly tested using stringent quality-assurance programs.
    This is a major advantage, since if you’re developing medical equipment, nuclear
    instrumentation, or automotive applications, industry regulators will probably
    require that you use either a safety-qualified operating system or provide appropriate
    documentation and testing that makes the case for the system you’ve chosen before
    they allow you to deploy your system. For example, I’ve used µC/OS (running on
    a NetBurner) in the development of instrumentation for nuclear reactors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you’re not developing mission-critical applications, you might
    not need a safety-qualified RTOS. Obviously, the choice is very application dependent,
    but be aware that quality assurance issues may restrict your choice of real-time
    OSs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Real-Time Operating System I²C Programming
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter focuses on four RTOSs: µC/OS, FreeRTOS, Teensy Threads (not really
    an RTOS, just a multithreading package), and Mbed.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: FreeRTOS and Teensy Threads are really just thread scheduling packages that
    provide basic multitasking and thread synchronization functions. They do not provide
    any other library code, such as I²C communication functions; you’re expected to
    provide that code yourself. In particular, you are responsible for synchronizing
    access to shared resources like the I²C bus.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The second two RTOSs, µC/OS and Mbed, are full-featured RTOSs that include library
    support for many activities, such as I²C communication. These fancier RTOSs provide
    synchronized access to the resources they use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections provide a brief discussion of each of these RTOSs.
    Where applicable, they also describe how to protect access to shared resources,
    such as the I²C bus.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.1 µC/OS
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I’m going to use the NBRTOS variant of µC/OS provided by NetBurner,
    Inc., running on their NetBurner MOD54415 SBC. NBRTOS is a variant of µC/OS I
    that includes several additional libraries to support the MOD54415, including
    a couple of I²C libraries.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The original µC/OS I RTOS was a purely priority-based RTOS with 64 different
    priority levels. It had the onerous restriction that each task (the µC/OS name
    for thread) had to run at a different priority so that you could not have two
    tasks running at the same priority while using round-robin/time multiplexed scheduling
    for those tasks at the same priority. Later versions of µC/OS, such as µC/OS III,
    introduced more priority levels (up to 256) and allowed multiple tasks to run
    at the same priority by using time multiplexing to switch between tasks of equal
    priority. However, as NBRTOS uses a version of µC/OS I, this book will stick with
    priority-based scheduling for µC/OS. Most of the other RTOSs in this book use
    time slicing (time multiplexing) rather than a priority-based scheme, so µC/OS
    is unusual in this respect.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The MOD54415 SBC supports up to four different I²C ports. A special library,
    `MultiChannel_I2C`, provides support in a multithreaded environment for these
    four channels. This library provides several different I²C functions you can call,
    though this chapter will use only two of them, `MultiChannel_I2CInit()` and `MultiChannel_I2CSendBuf()`,
    to demonstrate writing to the MCP4725 DAC:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first function, `MultiChannel_I2CInit()`, initializes the I²C port you’re
    going to use. This is usually a small integer in the range 0 to 3 (for ports i2c-0
    through i2c-3). The second parameter specifies a peripheral address for the port;
    you specify this only if you’re using the I²C port in peripheral mode. If you’re
    using the port in controller mode, you can ignore this argument (the default of
    `0x08` is fine). The last argument specifies the frequency divisor for the I²C
    bus. The default of `0x3C` is fine for 100-kHz operation; see the NetBurner documentation
    if you want to operate at a different clock frequency.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The second function, `MultiChannel_I2CSendBuf()`, writes data to the I²C bus.
    The first argument is the I²C port number (for example, `0` for i2c-0), the second
    argument is the I²C address of the device, the third argument is an array of bytes
    containing the data to be written, the fourth argument specifies the number of
    bytes to write, and the last argument specifies whether a stop condition is written
    to the I²C bus after the transmission (the default is `true``, which means to
    send the stop condition).`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数`MultiChannel_I2CSendBuf()`将数据写入I²C总线。第一个参数是I²C端口号（例如，`0`表示i2c-0），第二个参数是设备的I²C地址，第三个参数是一个包含要写入数据的字节数组，第四个参数指定要写入的字节数，最后一个参数指定在传输后是否向I²C总线写入停止条件（默认值为`true`，即发送停止条件）。
- en: '[PRE1]*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]*'
