- en: '**17'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**17'
- en: OAUTH VULNERABILITIES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: OAUTH 漏洞
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: '*OAuth* is an open protocol that simplifies and standardizes secure authorization
    on web, mobile, and desktop applications. It allows users to create accounts on
    websites without having to create a username or password. It’s commonly seen on
    websites as the Sign in with *platform* button like the one shown in [Figure 17-1](ch17.xhtml#ch17fig01),
    where the platform is Facebook, Google, LinkedIn, Twitter, or so on.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*OAuth* 是一种开放协议，简化并标准化了 web、移动和桌面应用程序中的安全授权。它允许用户在网站上创建账户，而无需创建用户名或密码。在网站上通常可以看到类似
    *platform* 的“一键登录”按钮，如 [图 17-1](ch17.xhtml#ch17fig01) 所示，平台可以是 Facebook、Google、LinkedIn、Twitter
    等等。'
- en: '![image](../images/17fig01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig01.jpg)'
- en: '*Figure 17-1: Example OAuth Sign in with Google button*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-1：示例 OAuth 使用 Google 登录按钮*'
- en: OAuth vulnerabilities are a type of application configuration vulnerability,
    meaning they rely on a developer’s implementation mistakes. However, given the
    impact and frequency of OAuth vulnerabilities, they’re worth devoting an entire
    chapter to. Although there are many kinds of OAuth vulnerabilities, the examples
    in this chapter will mainly include cases when an attacker is able to exploit
    OAuth to steal authentication tokens and access a targeted user’s account information
    on the resource server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 漏洞是一种应用程序配置漏洞，意味着它们依赖于开发人员的实现错误。然而，考虑到 OAuth 漏洞的影响和发生频率，值得专门用一整章来讨论它们。虽然
    OAuth 漏洞有许多种类型，本章将主要讨论攻击者如何利用 OAuth 漏洞窃取认证令牌并访问目标用户在资源服务器上的账户信息的案例。
- en: At the time of writing, OAuth has two versions, 1.0a and 2.0, which are incompatible
    with each other. Entire books have been written on OAuth, but this chapter focuses
    on OAuth 2.0 and the basic OAuth workflow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，OAuth 有两个版本：1.0a 和 2.0，这两个版本互不兼容。关于 OAuth 有很多书籍，但本章主要关注 OAuth 2.0 及其基本工作流程。
- en: '**The OAuth Workflow**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**OAuth 工作流程**'
- en: 'The OAuth process is complex, so let’s begin with basic terms. Three actors
    are involved in the most basic OAuth flow:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 过程较为复杂，我们先从基本术语开始介绍。最基本的 OAuth 流程涉及三个角色：
- en: The *resource owner* is the user attempting to log in via OAuth.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源所有者* 是通过 OAuth 尝试登录的用户。'
- en: The *resource server* is a third-party API that authenticates the resource owner.
    Any site can be a resource server, but the most popular ones include Facebook,
    Google, LinkedIn, and so on.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源服务器* 是一个第三方 API，用于验证资源所有者的身份。任何网站都可以是资源服务器，但最常见的包括 Facebook、Google、LinkedIn
    等等。'
- en: The *client* is the third-party application that the resource owner visits.
    The client is allowed to access data on the resource server.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端* 是资源所有者访问的第三方应用。客户端被允许访问资源服务器上的数据。'
- en: When you attempt to log in using OAuth, the client requests access to your information
    from the resource server and asks the resource owner (in this case, you) for approval
    to access the data. The client might ask for access to all your information or
    only specific pieces. The information that a client requests is defined by scopes.
    Scopes are similar to permissions in that they restrict what information an application
    can access from the resource server. For example, Facebook scopes include the
    user’s `email`, `public_profile`, `user_friends`, and so on. If you grant a client
    access to only the `email` scope, the client can’t access your profile information,
    friends list, and other information.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用 OAuth 登录时，客户端会向资源服务器请求访问你的信息，并询问资源所有者（即你）是否批准访问数据。客户端可能会请求访问你所有的信息，或者仅请求某些特定的数据。客户端请求的信息由作用域（scopes）定义。作用域类似于权限，它们限制了应用程序可以访问资源服务器上的哪些信息。例如，Facebook
    的作用域包括用户的 `email`、`public_profile`、`user_friends` 等等。如果你仅授予客户端 `email` 作用域的访问权限，那么客户端无法访问你的个人资料信息、好友列表和其他信息。
- en: 'Now that you understand the actors involved, let’s examine the OAuth process
    when logging into a client for the first time using Facebook as the example resource
    server. The OAuth process begins when you visit a client and click the Login with
    Facebook button. This results in a `GET` request to an authentication endpoint
    on the client. Often, the path looks like this: *https://www.<example>.com/oauth/facebook/*.
    Shopify, for example, uses Google for OAuth with the URL *https://<STORE>.myshopify.com/admin/auth/login?google_apps=1/*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了涉及的各方，让我们以Facebook作为示例资源服务器，来看看OAuth过程在首次登录客户端时是如何运作的。当你访问客户端并点击“使用Facebook登录”按钮时，OAuth过程就开始了。此时会向客户端的认证端点发送一个`GET`请求。通常，该路径看起来像这样：*https://www.<example>.com/oauth/facebook/*。例如，Shopify使用Google进行OAuth，URL为*https://<STORE>.myshopify.com/admin/auth/login?google_apps=1/*。
- en: 'The client responds to this HTTP request with a 302 redirect to the resource
    server. The redirect URL will include parameters to facilitate the OAuth process,
    which are defined as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端会通过302重定向响应此HTTP请求，重定向URL将包括用于促进OAuth过程的参数，定义如下：
- en: The *client_id* identifies the client to the resource server. Each client will
    have its own *client_id* so the resource server can identify the application initiating
    the request to access the resource owner’s information.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*client_id*标识客户端在资源服务器上的身份。每个客户端都会有自己的*client_id*，以便资源服务器能够识别发起请求的应用程序，从而访问资源所有者的信息。'
- en: The *redirect_uri* identifies where the resource server should redirect the
    resource owner’s browser after the resource server has authenticated the resource
    owner.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*redirect_uri*标识了在资源服务器验证资源所有者后，应该将资源所有者的浏览器重定向到哪里。'
- en: The *response_type* identifies what type of response to provide. This is usually
    a token or code, although a resource server can define other accepted values.
    A token response type provides an access token that immediately allows access
    to information from the resource server. A code response type provides an access
    code that must be exchanged for an access token via an extra step in the OAuth
    process.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*response_type*标识应提供什么类型的响应。通常，这可以是令牌或代码，尽管资源服务器可以定义其他接受的值。令牌响应类型提供一个访问令牌，使得能够立即访问资源服务器中的信息。代码响应类型提供一个访问代码，必须通过OAuth过程中的额外步骤交换为访问令牌。'
- en: The *scope*, mentioned earlier, identifies the permissions a client is requesting
    to access from the resource server. During the first authorization request, the
    resource owner should be presented with a dialog to review and approve the requested
    scopes.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，*scope*标识了客户端请求访问资源服务器的权限。在第一次授权请求时，资源所有者应该看到一个对话框，以审查并批准请求的权限范围。
- en: The *state* is an unguessable value that prevents cross-site request forgeries.
    This value is optional but should be implemented on all OAuth applications. It
    should be included in the HTTP request to the resource server. Then it should
    be returned and validated by the client to ensure an attacker can’t maliciously
    invoke the OAuth process on another user’s behalf.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*state*是一个无法猜测的值，用于防止跨站请求伪造。这个值是可选的，但应在所有OAuth应用中实现。它应该包含在发送到资源服务器的HTTP请求中，然后由客户端返回并进行验证，以确保攻击者不能恶意地代表另一个用户触发OAuth过程。'
- en: 'An example URL initiating the OAuth process with Facebook would look like this:
    *https://www.facebook.com/v2.0/dialog/oauth?client_id=123&redirect_uri=https%3A%2F%2Fwww.<example>.com%2Foauth%2Fcallback&response_type=token&scope=email&state=XYZ*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个启动OAuth过程的示例URL看起来像这样：*https://www.facebook.com/v2.0/dialog/oauth?client_id=123&redirect_uri=https%3A%2F%2Fwww.<example>.com%2Foauth%2Fcallback&response_type=token&scope=email&state=XYZ*。
- en: After receiving the 302 redirect response, the browser sends a `GET` request
    to the resource server. Assuming you’re logged in to the resource server, you
    should see a dialog to approve the client’s requested scopes. [Figure 17-2](ch17.xhtml#ch17fig02)
    shows an example of the website Quora (the client) requesting access to information
    from Facebook (the resource server) on the resource owner’s behalf.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到302重定向响应后，浏览器会向资源服务器发送一个`GET`请求。如果你已经登录到资源服务器，应该会看到一个对话框，要求你批准客户端请求的权限范围。[图
    17-2](ch17.xhtml#ch17fig02)展示了网站Quora（客户端）代表资源所有者请求访问Facebook（资源服务器）信息的示例。
- en: 'Clicking the Continue as John button approves Quora’s request to access the
    listed scopes, including the resource owner’s public profile, friends list, birthday,
    hometown, and so on. After the resource owner clicks the button, Facebook returns
    a 302 HTTP response redirecting the browser back to the URL defined by the *redirect_uri*
    parameter discussed previously. The redirect also includes a token and the state
    parameter. Here’s an example of a URL redirect from Facebook to Quora (which has
    been modified for this book):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“继续以 John 身份”按钮批准 Quora 请求访问列出的权限范围，包括资源拥有者的公共资料、好友列表、生日、家乡等。在资源拥有者点击按钮后，Facebook
    会返回 302 HTTP 响应，将浏览器重定向回先前讨论的 *redirect_uri* 参数所定义的 URL。重定向还包括令牌和状态参数。以下是 Facebook
    到 Quora 的 URL 重定向示例（已根据本书进行了修改）：
- en: '*https://www.quora.com?access_token=EAAAAH86O7bQBAApUu2ZBTuEo0MZA5xBXTQixBUYxrauhNqFtdxViQQ3CwtliGtKqljBZA8&expires_in=5625&state=F32AB83299DADDBAACD82DA*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*https://www.quora.com?access_token=EAAAAH86O7bQBAApUu2ZBTuEo0MZA5xBXTQixBUYxrauhNqFtdxViQQ3CwtliGtKqljBZA8&expires_in=5625&state=F32AB83299DADDBAACD82DA*'
- en: In this case, Facebook returned an access token that Quora (the client) could
    use to immediately query the resource owner’s information. Once the client has
    the *access_token*, the resource owner’s involvement in the OAuth process is complete.
    The client would query the Facebook API directly to obtain the information it
    requires about the resource owner. The resource owner would be able to use the
    client without being aware of the interaction between the client and API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Facebook 返回了一个访问令牌，Quora（客户端）可以使用该令牌立即查询资源拥有者的信息。一旦客户端拥有了 *access_token*，资源拥有者在
    OAuth 过程中的参与便已完成。客户端将直接查询 Facebook API 获取所需的资源拥有者信息。资源拥有者能够使用该客户端，而不必知道客户端与 API
    之间的交互。
- en: '![image](../images/17fig02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig02.jpg)'
- en: '*Figure 17-2: Quora login with Facebook OAuth scope authorization*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-2：通过 Facebook OAuth 权限授权登录 Quora*'
- en: 'However, if Facebook returned a code instead of an access token, Quora would
    need to exchange that code for an access token to query information from the resource
    server. This process is completed between the client and the resource server without
    the resource owner’s browser. To obtain a token, the client makes its own HTTP
    request to the resource server that includes three URL parameters: an access *code*,
    the *client_id*, and a *client_secret*. The access *code* is the value returned
    from the resource server through the 302 HTTP redirect. The *client_secret* is
    a value meant to be kept private by the client. It is generated by the resource
    server when the application is configured and the *client_id* is assigned.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 Facebook 返回的是代码而不是访问令牌，Quora 需要用该代码换取访问令牌以从资源服务器查询信息。这个过程是在客户端和资源服务器之间完成的，不涉及资源拥有者的浏览器。为了获得令牌，客户端向资源服务器发出
    HTTP 请求，其中包含三个 URL 参数：访问 *code*，*client_id* 和 *client_secret*。访问 *code* 是通过 302
    HTTP 重定向从资源服务器返回的值。*client_secret* 是一个应由客户端保密的值。它是在应用程序配置时由资源服务器生成，并分配 *client_id*。
- en: Finally, once the resource server receives a request from the client with the
    *client_secret*, *client_id*, and access *code*, it validates the values and returns
    an *access_token* to the client. At this stage, the client can query the resource
    server for information about the resource owner, and the OAuth process is complete.
    Once you’ve approved a resource server to access your information, the next time
    you log in to the client using Facebook, the OAuth authentication process will
    usually happen in the background. You won’t see any of this interaction unless
    you monitor your HTTP requests. Clients can change this default behavior to require
    resource owners to reauthenticate and approve scopes; however, this is very uncommon.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦资源服务器接收到带有 *client_secret*、*client_id* 和访问 *code* 的客户端请求，它会验证这些值并返回 *access_token*
    给客户端。在此阶段，客户端可以查询资源服务器以获取关于资源拥有者的信息，OAuth 过程也就完成了。一旦你批准了资源服务器访问你的信息，下一次使用 Facebook
    登录客户端时，OAuth 验证过程通常会在后台进行。除非你监控 HTTP 请求，否则你不会看到任何这种交互。客户端可以更改此默认行为，要求资源拥有者重新认证并批准权限范围；不过，这种情况非常罕见。
- en: The severity of an OAuth vulnerability depends on the permitted scopes associated
    with the stolen token, as you’ll see in the following examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 漏洞的严重性取决于与被窃取的令牌相关联的权限范围，如下文示例所示。
- en: '**Stealing Slack OAuth Tokens**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**窃取 Slack OAuth 令牌**'
- en: '**Difficulty:** Low'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 低'
- en: '**URL:** *[https://slack.com/oauth/authorize/](https://slack.com/oauth/authorize/)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL：** *[https://slack.com/oauth/authorize/](https://slack.com/oauth/authorize/)*'
- en: '**Source:** *[http://hackerone.com/reports/2575/](http://hackerone.com/reports/2575/)*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[http://hackerone.com/reports/2575/](http://hackerone.com/reports/2575/)*'
- en: '**Date reported:** March 1, 2013'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2013年3月1日'
- en: '**Bounty paid:** $100'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**悬赏金额：** $100'
- en: A common OAuth vulnerability occurs when a developer improperly configures or
    compares permitted *redirect_uri* parameters, allowing attackers to steal OAuth
    tokens. In March 2013, Prakhar Prasad found just that on Slack’s OAuth implementation.
    Prasad informed Slack that he could bypass their *redirect_uri* restrictions by
    appending anything to a whitelisted *redirect_uri*. In other words, Slack was
    only validating the beginning of the *redirect_uri* parameter. If a developer
    registered a new application with Slack and whitelisted *https://www.<example>.com*,
    an attacker could append a value to the URL and cause the redirect to go somewhere
    unintended. For example, modifying the URL to pass *redirect_uri=https://<attacker>.com*
    would be rejected, but passing *redirect_uri=https://www.<example>.com.mx* would
    be accepted.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的 OAuth 漏洞发生在开发者错误地配置或比较允许的 *redirect_uri* 参数时，这使得攻击者可以窃取 OAuth 令牌。在2013年3月，Prakhar
    Prasad 就在 Slack 的 OAuth 实现中发现了这一点。Prasad 通知了 Slack，表示他可以通过将任意内容附加到一个白名单中的 *redirect_uri*
    来绕过他们的 *redirect_uri* 限制。换句话说，Slack 仅验证了 *redirect_uri* 参数的开头部分。如果开发者在 Slack 注册了一个新应用并将
    *https://www.<example>.com* 加入白名单，那么攻击者就可以将一个值附加到 URL 中，从而导致重定向发生到一个不期望的位置。例如，修改
    URL 使其传递 *redirect_uri=https://<attacker>.com* 会被拒绝，但传递 *redirect_uri=https://www.<example>.com.mx*
    则会被接受。
- en: To exploit this behavior, an attacker only has to create a matching subdomain
    on their malicious site. If a targeted user visits the maliciously modified URL,
    Slack sends the OAuth token to the attacker’s site. An attacker could invoke the
    request on behalf of the targeted user by embedding an `<img>` tag on a malicious
    web page, such as `<img src=https://slack.com/oauth/authorize?response_type=token&client_id=APP_ID&redirect_uri=https://www.`example`.com.`attacker`.com>`.
    Using an `<img>` tag automatically invokes an HTTP `GET` request when rendered.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这种行为，攻击者只需要在其恶意网站上创建一个匹配的子域名。如果目标用户访问了恶意修改过的 URL，Slack 会将 OAuth 令牌发送到攻击者的网站。攻击者可以通过在恶意网页中嵌入
    `<img>` 标签来代表目标用户发起请求，例如 `<img src=https://slack.com/oauth/authorize?response_type=token&client_id=APP_ID&redirect_uri=https://www.`example`.com.`attacker`.com>`。使用
    `<img>` 标签在渲染时会自动发起一个 HTTP `GET` 请求。
- en: '***Takeaways***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点***'
- en: Vulnerabilities in which the *redirect_uri* haven’t been strictly checked are
    a common OAuth misconfiguration. Sometimes, the vulnerability is the result of
    an application registering a domain, such as **.<example>.com*, as an acceptable
    *redirect_uri*. Other times, it’s the result of a resource server not performing
    a strict check on the beginning and end of the *redirect_uri* parameter. In this
    example, it was the latter. When you’re looking for OAuth vulnerabilities, always
    be sure to test any parameter that indicates a redirection is being used.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *redirect_uri* 没有严格检查的情况下的漏洞是常见的 OAuth 配置错误。有时，这种漏洞是因为一个应用程序将一个域名（如 **.<example>.com*）注册为可接受的
    *redirect_uri*。其他时候，这个漏洞是由于资源服务器没有严格检查 *redirect_uri* 参数的开头和结尾部分导致的。在这个例子中，是后者。当你在寻找
    OAuth 漏洞时，一定要测试任何表明正在使用重定向的参数。
- en: '**Passing Authentication with Default Passwords**'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用默认密码通过身份验证**'
- en: '**Difficulty:** Low'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 低'
- en: '**URL:** *https://flurry.com/auth/v1/account/*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**网址：** *https://flurry.com/auth/v1/account/*'
- en: '**Source:** *[https://lightningsecurity.io/blog/password-not-provided/](https://lightningsecurity.io/blog/password-not-provided/)*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://lightningsecurity.io/blog/password-not-provided/](https://lightningsecurity.io/blog/password-not-provided/)*'
- en: '**Date reported:** June 30, 2017'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2017年6月30日'
- en: '**Bounty paid:** Undisclosed'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**悬赏金额：** 未公开'
- en: Looking for vulnerabilities in any OAuth implementation involves reviewing the
    entire authentication process, from start to finish. This includes recognizing
    HTTP requests that aren’t part of the standardized process. Such requests commonly
    indicate that the developers have customized the process and might have introduced
    bugs. Jack Cable noticed such a situation in June 2017, when he looked at Yahoo’s
    bug bounty program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 OAuth 实现中的漏洞需要审查整个身份验证过程，从头到尾。这包括识别那些不属于标准化过程的 HTTP 请求。这些请求通常表明开发者已经定制了该过程，并可能引入了漏洞。Jack
    Cable 就是在2017年6月发现了这种情况，当时他查看了 Yahoo 的漏洞赏金计划。
- en: 'Yahoo’s bounty program included the analytics site *[Flurry.com](http://Flurry.com)*.
    To begin his testing, Cable registered for a Flurry account using his *@yahoo.com*
    email address through Yahoo’s OAuth implementation. After Flurry and Yahoo! exchanged
    the OAuth token, the final `POST` request to Flurry was the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 雅虎的奖励计划包括分析网站 *[Flurry.com](http://Flurry.com)*。为了开始测试，Cable 使用他的 *@yahoo.com*
    电子邮件地址通过雅虎的 OAuth 实现注册了一个 Flurry 账户。Flurry 和雅虎交换了 OAuth 令牌后，向 Flurry 发送的最终 `POST`
    请求如下：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `"password":"not-provided"` part of the request ➊ caught Cable’s eye. Logging
    out of his account, he revisited *[https://login.flurry.com/](https://login.flurry.com/)*
    and signed in without using OAuth. Instead, he provided his email address and
    the password `not-provided`. This worked and Cable was logged into his account.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请求中的 `"password":"not-provided"` 部分 ➊ 引起了 Cable 的注意。退出账户后，他重新访问了 *[https://login.flurry.com/](https://login.flurry.com/)*，并在没有使用
    OAuth 的情况下登录。相反，他提供了他的电子邮件地址和密码 `not-provided`。这一操作成功，Cable 成功登录了他的账户。
- en: If any user registered for Flurry using their Yahoo! account and the OAuth process,
    Flurry would register the account in their system as the client. Then Flurry would
    save the user account with the default password `not-provided`. Cable submitted
    the vulnerability, and Yahoo! fixed it with within five hours of receiving his
    report.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何用户使用他们的雅虎账户和 OAuth 流程在 Flurry 注册，Flurry 会将该账户作为客户端注册到他们的系统中。然后，Flurry 会以默认密码
    `not-provided` 保存用户账户。Cable 提交了这个漏洞，雅虎在收到报告后五小时内修复了它。
- en: '***Takeaways***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总结***'
- en: In this case, Flurry included an extra, custom step in the authentication process
    that used a `POST` request to create a user account after a user was authenticated.
    Custom OAuth implementation steps are often misconfigured and result in vulnerabilities,
    so be sure to test these processes thoroughly. In this example, Flurry likely
    built its OAuth workflow on top of the existing user registration process to match
    the rest of the application. Flurry likely didn’t require users to create an account
    prior to implementing Yahoo! OAuth. To accommodate users without accounts, the
    Flurry developers probably decided to invoke the same registration `POST` request
    to create users. But the request required a password parameter, so Flurry set
    an insecure default one.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Flurry 在认证流程中加入了一个额外的自定义步骤，通过 `POST` 请求在用户认证后创建用户账户。自定义的 OAuth 实现步骤通常配置错误，从而导致漏洞，因此一定要彻底测试这些过程。在这个例子中，Flurry
    很可能是在现有的用户注册流程基础上构建了 OAuth 流程，以匹配应用程序的其他部分。Flurry 可能并未要求用户在实施雅虎 OAuth 前创建账户。为了方便没有账户的用户，Flurry
    的开发人员可能决定调用相同的注册 `POST` 请求来创建用户。但该请求需要一个密码参数，因此 Flurry 设置了一个不安全的默认密码。
- en: '**Stealing Microsoft Login Tokens**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**窃取 Microsoft 登录令牌**'
- en: '**Difficulty:** High'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 高'
- en: '**URL:** *[https://login.microsoftonline.com](https://login.microsoftonline.com)*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**网址：** *[https://login.microsoftonline.com](https://login.microsoftonline.com)*'
- en: '**Source:** *https://whitton.io/articles/obtaining-tokens-outlook-office-azure-account/*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *https://whitton.io/articles/obtaining-tokens-outlook-office-azure-account/*'
- en: '**Date reported:** January 24, 2016'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2016年1月24日'
- en: '**Bounty paid:** $13,000'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励金额：** $13,000'
- en: Although Microsoft doesn’t implement the standard OAuth flow, it uses a process
    that is very similar and applicable to testing OAuth applications. When you’re
    testing OAuth or any similar authentication processes, be sure to thoroughly test
    how redirect parameters are being validated. One way you can do this is by passing
    different URL structures to the application. This is exactly what Jack Whitton
    did in January 2016, when he tested Microsoft’s login process and found he could
    steal authentication tokens.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微软没有实施标准的 OAuth 流程，但它使用了一个非常相似的流程，适用于测试 OAuth 应用程序。当你测试 OAuth 或任何类似的认证流程时，务必彻底测试重定向参数是如何验证的。你可以通过将不同的
    URL 结构传递给应用程序来测试这一点。这正是 Jack Whitton 在2016年1月做的，当时他测试了微软的登录流程并发现他可以窃取认证令牌。
- en: 'Because it owns so many properties, Microsoft authenticates users through requests
    to *[login.live.com](http://login.live.com)*, *[login.microsoftonline.com](http://login.microsoftonline.com)*,
    and *[login.windows.net](http://login.windows.net)* depending on the service the
    user is being authenticated to. These URLs would return a session for the user.
    For example, the flow for *[outlook.office.com](http://outlook.office.com)* was
    the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微软拥有众多的服务，因此根据用户正在认证的服务，微软会通过请求 *[login.live.com](http://login.live.com)*、*[login.microsoftonline.com](http://login.microsoftonline.com)*
    和 *[login.windows.net](http://login.windows.net)* 来进行身份验证。这些 URL 会为用户返回一个会话。例如，*
    [outlook.office.com](http://outlook.office.com)* 的流程如下：
- en: A user would visit *[https://outlook.office.com](https://outlook.office.com)*.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将访问 *[https://outlook.office.com](https://outlook.office.com)*。
- en: The user would be redirected to *[https://login.microsoftonline.com/login.srf?wa=wsignin1.0&rpsnv=4&wreply=https%3a%2f%2foutlook.office.com%2fowa%2f&id=260563](https://login.microsoftonline.com/login.srf?wa=wsignin1.0&rpsnv=4&wreply=https%3a%2f%2foutlook.office.com%2fowa%2f&id=260563)*.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将被重定向到 *[https://login.microsoftonline.com/login.srf?wa=wsignin1.0&rpsnv=4&wreply=https%3a%2f%2foutlook.office.com%2fowa%2f&id=260563](https://login.microsoftonline.com/login.srf?wa=wsignin1.0&rpsnv=4&wreply=https%3a%2f%2foutlook.office.com%2fowa%2f&id=260563)*。
- en: If the user was logged in, a `POST` request would be made to the `wreply` parameter
    with a `t` parameter containing a token for the user.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户已经登录，将向 `wreply` 参数发送一个 `POST` 请求，`t` 参数中包含用户的令牌。
- en: Changing the `wreply` parameter to any other domain returned a process error.
    Whitton also tried double encoding characters by adding a *%252f* to the end of
    the URL to create *https%3a%2f%2foutlook.office.com%252f*. In this URL, special
    characters are encoded such that a colon (*:*) is *%3a* and a slash (*/*) is *%2f*.
    When *double encoding*, the attacker would also encode the percent sign (*%*)
    in the initial encoding. Doing so would make a double-encoded slash *%252f* (encoding
    special characters was discussed in “[Twitter HTTP Response Splitting](ch06.xhtml#ch06lev1sec3)”
    on [page 52](ch06.xhtml#page_52)). When Whitton changed the `wreply` parameter
    to the double-encoded URL, the application returned an error that indicated *https://outlook.office.com%f*
    wasn’t a valid URL.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `wreply` 参数更改为其他任何域名会导致流程错误。Whitton 还尝试通过在 URL 末尾添加 *%252f* 来对字符进行双重编码，形成
    *https%3a%2f%2foutlook.office.com%252f*。在这个 URL 中，特殊字符会被编码，例如冒号 (*:*) 被编码为 *%3a*，斜杠
    (*/*) 被编码为 *%2f*。当进行 *双重编码* 时，攻击者还会在初次编码时对百分号 (*%*) 进行编码。这样做会使得双重编码后的斜杠变成 *%252f*（编码特殊字符的讨论可以参见
    “[Twitter HTTP Response Splitting](ch06.xhtml#ch06lev1sec3)” 在 [第 52 页](ch06.xhtml#page_52)）。当
    Whitton 将 `wreply` 参数更改为双重编码后的 URL 时，应用程序返回了一个错误，表明 *https://outlook.office.com%f*
    不是一个有效的 URL。
- en: 'Next, Whitton appended *@example.com* to the domain, which didn’t result in
    an error. Instead, it returned *[https://outlook.office.com%2f@example.com/?wa=wsignin1.0](mailto:https://outlook.office.com%2f@example.com/?wa=wsignin1.0)*.
    The reason it did this is that the structure of a URL is the scheme: *[//[username:password@]host[:port]][/]path[?query][#fragment]*.
    The `username` and `password` parameters pass basic authorization credentials
    to a website. So, by adding *@example.com*, the redirect host was no longer *[outlook.office.com](http://outlook.office.com)*.
    Instead, the redirect could be set to any attacker-controlled host.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Whitton 将 *@example.com* 添加到域名中，但并未导致错误。相反，它返回了 *[https://outlook.office.com%2f@example.com/?wa=wsignin1.0](mailto:https://outlook.office.com%2f@example.com/?wa=wsignin1.0)*。之所以会这样，是因为
    URL 的结构是：* [//[用户名:密码@]主机[:端口]][/]路径[?查询][#片段]*。`用户名` 和 `密码` 参数将基本的授权凭证传递给网站。因此，通过添加
    *@example.com*，重定向的主机不再是 *[outlook.office.com](http://outlook.office.com)*，而是可以设置为任何攻击者控制的主机。
- en: According to Whitton, the cause of this vulnerability was the way in which Microsoft
    was handling decoding and URL validation. Microsoft was likely using a two-step
    process. First, Microsoft would perform a sanity check and ensure the domain was
    valid and conforming to the URL structure scheme. The URL *[https://outlook.office.com%2f@example.com](mailto:https://outlook.office.com%2f@example.com)*
    was valid because *[outlook.office.com%2f](http://outlook.office.com%2f)* would
    be recognized as a valid username.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Whitton 的说法，这个漏洞的根本原因在于微软处理解码和 URL 验证的方式。微软可能采用了一个两步过程。首先，微软会进行有效性检查，确保域名有效且符合
    URL 结构方案。URL *[https://outlook.office.com%2f@example.com](mailto:https://outlook.office.com%2f@example.com)*
    是有效的，因为 *[outlook.office.com%2f](http://outlook.office.com%2f)* 会被识别为有效的用户名。
- en: Second, Microsoft would decode the URL recursively until there were no other
    characters to decode. In this case, *https%3a%2f%2foutlook.office.com%252f@example.com*
    would be recursively decoded until it returned *[https://outlook.office.com/@example.com](mailto:https://outlook.office.com/@example.com)*.
    This meant *@example.com* was recognized as part of the URL path but not the host.
    The host would be validated as *[outlook.office.com](http://outlook.office.com)*
    because *@example.com* comes after a slash.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，微软会递归解码 URL，直到没有其他字符可以解码。在这种情况下，*https%3a%2f%2foutlook.office.com%252f@example.com*
    会被递归解码，直到返回 *[https://outlook.office.com/@example.com](mailto:https://outlook.office.com/@example.com)*。这意味着
    *@example.com* 被识别为 URL 路径的一部分，而不是主机。主机会被验证为 *[outlook.office.com](http://outlook.office.com)*，因为
    *@example.com* 出现在斜杠之后。
- en: When the parts of the URL were combined, Microsoft validated the URL structure,
    decoded the URL, and validated it as being whitelisted but returned a URL that
    was only decoded once. This meant that any targeted user who visited *https://login.microsoftonline.com/login.srf?wa=wsignin1.0&rpsnv=4&wreply=https%3a%2f%2foutlook.office.com%252f@example.com&id=260563*
    would have their access token sent to *example.com*. The malicious owner of *example.com*
    could then log in to the Microsoft service associated with the received token
    and access other people’s accounts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当 URL 的各个部分组合起来时，微软会验证 URL 结构、解码 URL，并将其验证为白名单中的 URL，但返回的 URL 仅被解码了一次。这意味着，任何访问
    *https://login.microsoftonline.com/login.srf?wa=wsignin1.0&rpsnv=4&wreply=https%3a%2f%2foutlook.office.com%252f@example.com&id=260563*
    的目标用户都会将其访问令牌发送到 *example.com*。*example.com* 的恶意所有者可以利用这个令牌登录与该令牌关联的微软服务，并访问其他人的账户。
- en: '***Takeaways***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点***'
- en: When you’re testing redirect parameters in the OAuth flow, include *@example.com*
    as part of the redirect URI to see how the application handles it. You should
    do this especially when you notice that the process is utilizing encoded characters
    that the application needs to decode to validate a whitelisted redirect URL. Additionally,
    always note any subtle differences in application behavior while you’re testing.
    In this case, Whitton noticed that the errors being returned were different when
    he fully changed the `wreply` parameter instead of appending a double-encoded
    forward slash. This put him on to Microsoft’s misconfigured validation logic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试 OAuth 流程中的重定向参数时，确保将 *@example.com* 作为重定向 URI 的一部分，以查看应用程序如何处理它。尤其当你注意到该过程正在使用编码字符，应用程序需要解码这些字符以验证白名单中的重定向
    URL 时，应该这样做。此外，在测试时始终注意应用程序行为中的任何细微差异。在这种情况下，Whitton 注意到，当他完全更改 `wreply` 参数时，返回的错误与附加双重编码的斜杠时不同，这使他发现了微软配置错误的验证逻辑。
- en: '**Swiping Facebook Official Access Tokens**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**窃取 Facebook 官方访问令牌**'
- en: '**Difficulty:** High'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 高'
- en: '**URL:** *[https://www.facebook.com](https://www.facebook.com)*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL：** *[https://www.facebook.com](https://www.facebook.com)*'
- en: '**Source:** *[http://philippeharewood.com/swiping-facebook-official-access-tokens/](http://philippeharewood.com/swiping-facebook-official-access-tokens/)*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[http://philippeharewood.com/swiping-facebook-official-access-tokens/](http://philippeharewood.com/swiping-facebook-official-access-tokens/)*'
- en: '**Date reported:** February 29, 2016'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2016年2月29日'
- en: '**Bounty paid:** Undisclosed'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励支付：** 未公开'
- en: 'When you’re looking for vulnerabilities, be sure to consider forgotten assets
    that the target application relies on. In this example, Philippe Harewood began
    with a single goal in mind: to capture a targeted user’s Facebook token and access
    their private information. But he wasn’t able to find any mistakes in Facebook’s
    OAuth implementation. Undeterred, he pivoted and started looking for a Facebook
    application he could take over, using an idea similar to a subdomain takeover.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找漏洞时，一定要考虑目标应用程序所依赖的被遗忘的资产。在这个例子中，Philippe Harewood 一开始只有一个目标：捕获目标用户的 Facebook
    令牌并访问他们的私人信息。但他未能找到 Facebook 在 OAuth 实现上的任何错误。没有灰心丧气，他转变思路，开始寻找可以接管的 Facebook
    应用程序，采用了一种类似子域名接管的思路。
- en: The idea was predicated on recognizing that the main Facebook functionality
    includes some Facebook-owned apps that rely on OAuth and are automatically authorized
    by all Facebook accounts. The list of these preauthorized apps was at *https://www.facebook.com/search/me/apps-used/*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法基于一个认识，即 Facebook 的主要功能包括一些依赖于 OAuth 的 Facebook 所有的应用程序，并且这些应用会自动被所有 Facebook
    账户授权。所有这些预授权应用的列表位于 *https://www.facebook.com/search/me/apps-used/*。
- en: Reviewing the list, Harewood found one application that was authorized, even
    though Facebook no longer owned or used the domain. This meant Harewood could
    register the whitelisted domain as the *redirect_uri* parameter to receive the
    Facebook tokens of any targeted user that visited the OAuth authorization endpoint
    *[https://facebook.com/v2.5/dialog/oauth?response_type=token&display=popup&client_id=APP_ID&redirect_uri=REDIRECT_URI/](https://facebook.com/v2.5/dialog/oauth?response_type=token&display=popup&client_id=APP_ID&redirect_uri=REDIRECT_URI/)*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看列表时，Harewood 发现有一个应用被授权，即便 Facebook 已经不再拥有或使用该域名。这意味着 Harewood 可以将该白名单域名注册为
    *redirect_uri* 参数，从而接收访问 OAuth 授权端点 *[https://facebook.com/v2.5/dialog/oauth?response_type=token&display=popup&client_id=APP_ID&redirect_uri=REDIRECT_URI/](https://facebook.com/v2.5/dialog/oauth?response_type=token&display=popup&client_id=APP_ID&redirect_uri=REDIRECT_URI/)*
    的任何目标用户的 Facebook 令牌。
- en: In the URL, the vulnerable app’s ID is denoted by *APP_ID*, which included access
    to all OAuth scopes. The whitelisted domain is denoted by *REDIRECT_URI* (Harewood
    didn’t disclose the misconfigured application). Because the application was already
    authorized for every Facebook user, any targeted user would never be required
    to approve requested scopes. In addition, the OAuth process would proceed entirely
    in background HTTP requests. By visiting the Facebook OAuth URL for this application,
    users would be redirected to the URL *http://REDIRECT_URI/#token=access_token_appended_here/*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URL 中，易受攻击的应用的 ID 由 *APP_ID* 表示，该 ID 包含对所有 OAuth 范围的访问权限。白名单域名由 *REDIRECT_URI*
    表示（Harewood 没有公开该配置错误的应用）。因为该应用已经获得了每个 Facebook 用户的授权，所以任何目标用户都不需要批准请求的范围。此外，OAuth
    过程会完全在后台 HTTP 请求中进行。通过访问该应用的 Facebook OAuth URL，用户将被重定向到 URL *http://REDIRECT_URI/#token=access_token_appended_here/*。
- en: Because Harewood registered the address for *REDIRECT_URI*, he was able to log
    the access token of any user who visited the URL, which gave him access to their
    entire Facebook account. Additionally, all official Facebook access tokens include
    access to other Facebook-owned properties, such as Instagram. As a result, Harewood
    could access all Facebook properties on behalf of a targeted user.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Harewood 注册了 *REDIRECT_URI* 的地址，他能够记录访问该 URL 的任何用户的访问令牌，这使他能够访问他们的整个 Facebook
    账户。此外，所有官方的 Facebook 访问令牌都包括对其他 Facebook 拥有的资产的访问权限，例如 Instagram。因此，Harewood 可以代表目标用户访问所有
    Facebook 资产。
- en: '***Takeaways***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点***'
- en: Consider potential forgotten assets when you’re looking for vulnerabilities.
    In this example, the forgotten asset was a sensitive Facebook application with
    full scope permissions. But other examples include subdomain CNAME records and
    application dependencies, such as Ruby Gems, JavaScript libraries, and so on.
    If an application relies on external assets, developers might someday stop using
    that asset and forget to disconnect it from the application. If an attacker can
    take over the asset, that could have severe consequences for the application and
    its users. Additionally, it’s important to recognize that Harewood began his testing
    with a hacking goal in mind. Doing the same is an effective way to focus your
    energy when you’re hacking on large applications, where there are an infinite
    number of areas to test and it’s easy to get distracted.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找漏洞时，要考虑可能被遗忘的资产。在这个例子中，遗忘的资产是一个敏感的 Facebook 应用，具有完全的权限范围。但其他例子包括子域名的 CNAME
    记录和应用依赖项，如 Ruby Gems、JavaScript 库等。如果一个应用依赖于外部资产，开发者有可能某天停止使用该资产，并忘记将其从应用中断开。如果攻击者能够接管该资产，这可能对应用及其用户造成严重后果。此外，需要认识到，Harewood
    在测试时有一个黑客攻击的目标。采取同样的方式是当你在对大型应用进行黑客攻击时有效的集中精力的方式，因为在这些应用中有无数区域可以测试，且很容易分心。
- en: '**Summary**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Despite its standardization as an authentication workflow, OAuth is easy for
    developers to misconfigure. Subtle bugs could allow attackers to steal authorization
    tokens and access the private information of targeted users. When you’re hacking
    on OAuth applications, be sure to thoroughly test the *redirect_uri* parameter
    to see whether an application is properly validating when access tokens are sent.
    Also, be on the lookout for custom implementations that support the OAuth workflow;
    the functionality won’t be defined by the OAuth standardized process and is more
    likely to be vulnerable. Before giving up on any OAuth hacking, be sure to consider
    whitelisted assets. Confirm whether the client has trusted any application by
    default that its developers might have forgotten about.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 OAuth 已被标准化为一种身份验证工作流，但它对开发者来说很容易被配置错误。细微的错误可能导致攻击者窃取授权令牌并访问目标用户的私人信息。在进行
    OAuth 应用程序黑客攻击时，一定要彻底测试*redirect_uri*参数，查看应用程序是否正确验证了访问令牌的发送情况。同时，也要留意支持 OAuth
    工作流的自定义实现；这些功能并未由 OAuth 标准化流程定义，更容易存在漏洞。在放弃任何 OAuth 黑客攻击之前，一定要考虑白名单资产。确认客户端是否默认信任了某些应用程序，这些应用程序可能是开发者遗忘的。
