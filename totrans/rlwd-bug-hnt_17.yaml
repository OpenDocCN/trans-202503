- en: '**17'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAUTH VULNERABILITIES**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*OAuth* is an open protocol that simplifies and standardizes secure authorization
    on web, mobile, and desktop applications. It allows users to create accounts on
    websites without having to create a username or password. It’s commonly seen on
    websites as the Sign in with *platform* button like the one shown in [Figure 17-1](ch17.xhtml#ch17fig01),
    where the platform is Facebook, Google, LinkedIn, Twitter, or so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: Example OAuth Sign in with Google button*'
  prefs: []
  type: TYPE_NORMAL
- en: OAuth vulnerabilities are a type of application configuration vulnerability,
    meaning they rely on a developer’s implementation mistakes. However, given the
    impact and frequency of OAuth vulnerabilities, they’re worth devoting an entire
    chapter to. Although there are many kinds of OAuth vulnerabilities, the examples
    in this chapter will mainly include cases when an attacker is able to exploit
    OAuth to steal authentication tokens and access a targeted user’s account information
    on the resource server.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, OAuth has two versions, 1.0a and 2.0, which are incompatible
    with each other. Entire books have been written on OAuth, but this chapter focuses
    on OAuth 2.0 and the basic OAuth workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '**The OAuth Workflow**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The OAuth process is complex, so let’s begin with basic terms. Three actors
    are involved in the most basic OAuth flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The *resource owner* is the user attempting to log in via OAuth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *resource server* is a third-party API that authenticates the resource owner.
    Any site can be a resource server, but the most popular ones include Facebook,
    Google, LinkedIn, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *client* is the third-party application that the resource owner visits.
    The client is allowed to access data on the resource server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you attempt to log in using OAuth, the client requests access to your information
    from the resource server and asks the resource owner (in this case, you) for approval
    to access the data. The client might ask for access to all your information or
    only specific pieces. The information that a client requests is defined by scopes.
    Scopes are similar to permissions in that they restrict what information an application
    can access from the resource server. For example, Facebook scopes include the
    user’s `email`, `public_profile`, `user_friends`, and so on. If you grant a client
    access to only the `email` scope, the client can’t access your profile information,
    friends list, and other information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand the actors involved, let’s examine the OAuth process
    when logging into a client for the first time using Facebook as the example resource
    server. The OAuth process begins when you visit a client and click the Login with
    Facebook button. This results in a `GET` request to an authentication endpoint
    on the client. Often, the path looks like this: *https://www.<example>.com/oauth/facebook/*.
    Shopify, for example, uses Google for OAuth with the URL *https://<STORE>.myshopify.com/admin/auth/login?google_apps=1/*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client responds to this HTTP request with a 302 redirect to the resource
    server. The redirect URL will include parameters to facilitate the OAuth process,
    which are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The *client_id* identifies the client to the resource server. Each client will
    have its own *client_id* so the resource server can identify the application initiating
    the request to access the resource owner’s information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *redirect_uri* identifies where the resource server should redirect the
    resource owner’s browser after the resource server has authenticated the resource
    owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *response_type* identifies what type of response to provide. This is usually
    a token or code, although a resource server can define other accepted values.
    A token response type provides an access token that immediately allows access
    to information from the resource server. A code response type provides an access
    code that must be exchanged for an access token via an extra step in the OAuth
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *scope*, mentioned earlier, identifies the permissions a client is requesting
    to access from the resource server. During the first authorization request, the
    resource owner should be presented with a dialog to review and approve the requested
    scopes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *state* is an unguessable value that prevents cross-site request forgeries.
    This value is optional but should be implemented on all OAuth applications. It
    should be included in the HTTP request to the resource server. Then it should
    be returned and validated by the client to ensure an attacker can’t maliciously
    invoke the OAuth process on another user’s behalf.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example URL initiating the OAuth process with Facebook would look like this:
    *https://www.facebook.com/v2.0/dialog/oauth?client_id=123&redirect_uri=https%3A%2F%2Fwww.<example>.com%2Foauth%2Fcallback&response_type=token&scope=email&state=XYZ*'
  prefs: []
  type: TYPE_NORMAL
- en: After receiving the 302 redirect response, the browser sends a `GET` request
    to the resource server. Assuming you’re logged in to the resource server, you
    should see a dialog to approve the client’s requested scopes. [Figure 17-2](ch17.xhtml#ch17fig02)
    shows an example of the website Quora (the client) requesting access to information
    from Facebook (the resource server) on the resource owner’s behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the Continue as John button approves Quora’s request to access the
    listed scopes, including the resource owner’s public profile, friends list, birthday,
    hometown, and so on. After the resource owner clicks the button, Facebook returns
    a 302 HTTP response redirecting the browser back to the URL defined by the *redirect_uri*
    parameter discussed previously. The redirect also includes a token and the state
    parameter. Here’s an example of a URL redirect from Facebook to Quora (which has
    been modified for this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '*https://www.quora.com?access_token=EAAAAH86O7bQBAApUu2ZBTuEo0MZA5xBXTQixBUYxrauhNqFtdxViQQ3CwtliGtKqljBZA8&expires_in=5625&state=F32AB83299DADDBAACD82DA*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Facebook returned an access token that Quora (the client) could
    use to immediately query the resource owner’s information. Once the client has
    the *access_token*, the resource owner’s involvement in the OAuth process is complete.
    The client would query the Facebook API directly to obtain the information it
    requires about the resource owner. The resource owner would be able to use the
    client without being aware of the interaction between the client and API.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: Quora login with Facebook OAuth scope authorization*'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if Facebook returned a code instead of an access token, Quora would
    need to exchange that code for an access token to query information from the resource
    server. This process is completed between the client and the resource server without
    the resource owner’s browser. To obtain a token, the client makes its own HTTP
    request to the resource server that includes three URL parameters: an access *code*,
    the *client_id*, and a *client_secret*. The access *code* is the value returned
    from the resource server through the 302 HTTP redirect. The *client_secret* is
    a value meant to be kept private by the client. It is generated by the resource
    server when the application is configured and the *client_id* is assigned.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once the resource server receives a request from the client with the
    *client_secret*, *client_id*, and access *code*, it validates the values and returns
    an *access_token* to the client. At this stage, the client can query the resource
    server for information about the resource owner, and the OAuth process is complete.
    Once you’ve approved a resource server to access your information, the next time
    you log in to the client using Facebook, the OAuth authentication process will
    usually happen in the background. You won’t see any of this interaction unless
    you monitor your HTTP requests. Clients can change this default behavior to require
    resource owners to reauthenticate and approve scopes; however, this is very uncommon.
  prefs: []
  type: TYPE_NORMAL
- en: The severity of an OAuth vulnerability depends on the permitted scopes associated
    with the stolen token, as you’ll see in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stealing Slack OAuth Tokens**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://slack.com/oauth/authorize/](https://slack.com/oauth/authorize/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[http://hackerone.com/reports/2575/](http://hackerone.com/reports/2575/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** March 1, 2013'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $100'
  prefs: []
  type: TYPE_NORMAL
- en: A common OAuth vulnerability occurs when a developer improperly configures or
    compares permitted *redirect_uri* parameters, allowing attackers to steal OAuth
    tokens. In March 2013, Prakhar Prasad found just that on Slack’s OAuth implementation.
    Prasad informed Slack that he could bypass their *redirect_uri* restrictions by
    appending anything to a whitelisted *redirect_uri*. In other words, Slack was
    only validating the beginning of the *redirect_uri* parameter. If a developer
    registered a new application with Slack and whitelisted *https://www.<example>.com*,
    an attacker could append a value to the URL and cause the redirect to go somewhere
    unintended. For example, modifying the URL to pass *redirect_uri=https://<attacker>.com*
    would be rejected, but passing *redirect_uri=https://www.<example>.com.mx* would
    be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: To exploit this behavior, an attacker only has to create a matching subdomain
    on their malicious site. If a targeted user visits the maliciously modified URL,
    Slack sends the OAuth token to the attacker’s site. An attacker could invoke the
    request on behalf of the targeted user by embedding an `<img>` tag on a malicious
    web page, such as `<img src=https://slack.com/oauth/authorize?response_type=token&client_id=APP_ID&redirect_uri=https://www.`example`.com.`attacker`.com>`.
    Using an `<img>` tag automatically invokes an HTTP `GET` request when rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Vulnerabilities in which the *redirect_uri* haven’t been strictly checked are
    a common OAuth misconfiguration. Sometimes, the vulnerability is the result of
    an application registering a domain, such as **.<example>.com*, as an acceptable
    *redirect_uri*. Other times, it’s the result of a resource server not performing
    a strict check on the beginning and end of the *redirect_uri* parameter. In this
    example, it was the latter. When you’re looking for OAuth vulnerabilities, always
    be sure to test any parameter that indicates a redirection is being used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing Authentication with Default Passwords**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://flurry.com/auth/v1/account/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://lightningsecurity.io/blog/password-not-provided/](https://lightningsecurity.io/blog/password-not-provided/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** June 30, 2017'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** Undisclosed'
  prefs: []
  type: TYPE_NORMAL
- en: Looking for vulnerabilities in any OAuth implementation involves reviewing the
    entire authentication process, from start to finish. This includes recognizing
    HTTP requests that aren’t part of the standardized process. Such requests commonly
    indicate that the developers have customized the process and might have introduced
    bugs. Jack Cable noticed such a situation in June 2017, when he looked at Yahoo’s
    bug bounty program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yahoo’s bounty program included the analytics site *[Flurry.com](http://Flurry.com)*.
    To begin his testing, Cable registered for a Flurry account using his *@yahoo.com*
    email address through Yahoo’s OAuth implementation. After Flurry and Yahoo! exchanged
    the OAuth token, the final `POST` request to Flurry was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `"password":"not-provided"` part of the request ➊ caught Cable’s eye. Logging
    out of his account, he revisited *[https://login.flurry.com/](https://login.flurry.com/)*
    and signed in without using OAuth. Instead, he provided his email address and
    the password `not-provided`. This worked and Cable was logged into his account.
  prefs: []
  type: TYPE_NORMAL
- en: If any user registered for Flurry using their Yahoo! account and the OAuth process,
    Flurry would register the account in their system as the client. Then Flurry would
    save the user account with the default password `not-provided`. Cable submitted
    the vulnerability, and Yahoo! fixed it with within five hours of receiving his
    report.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this case, Flurry included an extra, custom step in the authentication process
    that used a `POST` request to create a user account after a user was authenticated.
    Custom OAuth implementation steps are often misconfigured and result in vulnerabilities,
    so be sure to test these processes thoroughly. In this example, Flurry likely
    built its OAuth workflow on top of the existing user registration process to match
    the rest of the application. Flurry likely didn’t require users to create an account
    prior to implementing Yahoo! OAuth. To accommodate users without accounts, the
    Flurry developers probably decided to invoke the same registration `POST` request
    to create users. But the request required a password parameter, so Flurry set
    an insecure default one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stealing Microsoft Login Tokens**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://login.microsoftonline.com](https://login.microsoftonline.com)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *https://whitton.io/articles/obtaining-tokens-outlook-office-azure-account/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** January 24, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $13,000'
  prefs: []
  type: TYPE_NORMAL
- en: Although Microsoft doesn’t implement the standard OAuth flow, it uses a process
    that is very similar and applicable to testing OAuth applications. When you’re
    testing OAuth or any similar authentication processes, be sure to thoroughly test
    how redirect parameters are being validated. One way you can do this is by passing
    different URL structures to the application. This is exactly what Jack Whitton
    did in January 2016, when he tested Microsoft’s login process and found he could
    steal authentication tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because it owns so many properties, Microsoft authenticates users through requests
    to *[login.live.com](http://login.live.com)*, *[login.microsoftonline.com](http://login.microsoftonline.com)*,
    and *[login.windows.net](http://login.windows.net)* depending on the service the
    user is being authenticated to. These URLs would return a session for the user.
    For example, the flow for *[outlook.office.com](http://outlook.office.com)* was
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A user would visit *[https://outlook.office.com](https://outlook.office.com)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user would be redirected to *[https://login.microsoftonline.com/login.srf?wa=wsignin1.0&rpsnv=4&wreply=https%3a%2f%2foutlook.office.com%2fowa%2f&id=260563](https://login.microsoftonline.com/login.srf?wa=wsignin1.0&rpsnv=4&wreply=https%3a%2f%2foutlook.office.com%2fowa%2f&id=260563)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user was logged in, a `POST` request would be made to the `wreply` parameter
    with a `t` parameter containing a token for the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing the `wreply` parameter to any other domain returned a process error.
    Whitton also tried double encoding characters by adding a *%252f* to the end of
    the URL to create *https%3a%2f%2foutlook.office.com%252f*. In this URL, special
    characters are encoded such that a colon (*:*) is *%3a* and a slash (*/*) is *%2f*.
    When *double encoding*, the attacker would also encode the percent sign (*%*)
    in the initial encoding. Doing so would make a double-encoded slash *%252f* (encoding
    special characters was discussed in “[Twitter HTTP Response Splitting](ch06.xhtml#ch06lev1sec3)”
    on [page 52](ch06.xhtml#page_52)). When Whitton changed the `wreply` parameter
    to the double-encoded URL, the application returned an error that indicated *https://outlook.office.com%f*
    wasn’t a valid URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, Whitton appended *@example.com* to the domain, which didn’t result in
    an error. Instead, it returned *[https://outlook.office.com%2f@example.com/?wa=wsignin1.0](mailto:https://outlook.office.com%2f@example.com/?wa=wsignin1.0)*.
    The reason it did this is that the structure of a URL is the scheme: *[//[username:password@]host[:port]][/]path[?query][#fragment]*.
    The `username` and `password` parameters pass basic authorization credentials
    to a website. So, by adding *@example.com*, the redirect host was no longer *[outlook.office.com](http://outlook.office.com)*.
    Instead, the redirect could be set to any attacker-controlled host.'
  prefs: []
  type: TYPE_NORMAL
- en: According to Whitton, the cause of this vulnerability was the way in which Microsoft
    was handling decoding and URL validation. Microsoft was likely using a two-step
    process. First, Microsoft would perform a sanity check and ensure the domain was
    valid and conforming to the URL structure scheme. The URL *[https://outlook.office.com%2f@example.com](mailto:https://outlook.office.com%2f@example.com)*
    was valid because *[outlook.office.com%2f](http://outlook.office.com%2f)* would
    be recognized as a valid username.
  prefs: []
  type: TYPE_NORMAL
- en: Second, Microsoft would decode the URL recursively until there were no other
    characters to decode. In this case, *https%3a%2f%2foutlook.office.com%252f@example.com*
    would be recursively decoded until it returned *[https://outlook.office.com/@example.com](mailto:https://outlook.office.com/@example.com)*.
    This meant *@example.com* was recognized as part of the URL path but not the host.
    The host would be validated as *[outlook.office.com](http://outlook.office.com)*
    because *@example.com* comes after a slash.
  prefs: []
  type: TYPE_NORMAL
- en: When the parts of the URL were combined, Microsoft validated the URL structure,
    decoded the URL, and validated it as being whitelisted but returned a URL that
    was only decoded once. This meant that any targeted user who visited *https://login.microsoftonline.com/login.srf?wa=wsignin1.0&rpsnv=4&wreply=https%3a%2f%2foutlook.office.com%252f@example.com&id=260563*
    would have their access token sent to *example.com*. The malicious owner of *example.com*
    could then log in to the Microsoft service associated with the received token
    and access other people’s accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you’re testing redirect parameters in the OAuth flow, include *@example.com*
    as part of the redirect URI to see how the application handles it. You should
    do this especially when you notice that the process is utilizing encoded characters
    that the application needs to decode to validate a whitelisted redirect URL. Additionally,
    always note any subtle differences in application behavior while you’re testing.
    In this case, Whitton noticed that the errors being returned were different when
    he fully changed the `wreply` parameter instead of appending a double-encoded
    forward slash. This put him on to Microsoft’s misconfigured validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swiping Facebook Official Access Tokens**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://www.facebook.com](https://www.facebook.com)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[http://philippeharewood.com/swiping-facebook-official-access-tokens/](http://philippeharewood.com/swiping-facebook-official-access-tokens/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** February 29, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** Undisclosed'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re looking for vulnerabilities, be sure to consider forgotten assets
    that the target application relies on. In this example, Philippe Harewood began
    with a single goal in mind: to capture a targeted user’s Facebook token and access
    their private information. But he wasn’t able to find any mistakes in Facebook’s
    OAuth implementation. Undeterred, he pivoted and started looking for a Facebook
    application he could take over, using an idea similar to a subdomain takeover.'
  prefs: []
  type: TYPE_NORMAL
- en: The idea was predicated on recognizing that the main Facebook functionality
    includes some Facebook-owned apps that rely on OAuth and are automatically authorized
    by all Facebook accounts. The list of these preauthorized apps was at *https://www.facebook.com/search/me/apps-used/*.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the list, Harewood found one application that was authorized, even
    though Facebook no longer owned or used the domain. This meant Harewood could
    register the whitelisted domain as the *redirect_uri* parameter to receive the
    Facebook tokens of any targeted user that visited the OAuth authorization endpoint
    *[https://facebook.com/v2.5/dialog/oauth?response_type=token&display=popup&client_id=APP_ID&redirect_uri=REDIRECT_URI/](https://facebook.com/v2.5/dialog/oauth?response_type=token&display=popup&client_id=APP_ID&redirect_uri=REDIRECT_URI/)*.
  prefs: []
  type: TYPE_NORMAL
- en: In the URL, the vulnerable app’s ID is denoted by *APP_ID*, which included access
    to all OAuth scopes. The whitelisted domain is denoted by *REDIRECT_URI* (Harewood
    didn’t disclose the misconfigured application). Because the application was already
    authorized for every Facebook user, any targeted user would never be required
    to approve requested scopes. In addition, the OAuth process would proceed entirely
    in background HTTP requests. By visiting the Facebook OAuth URL for this application,
    users would be redirected to the URL *http://REDIRECT_URI/#token=access_token_appended_here/*.
  prefs: []
  type: TYPE_NORMAL
- en: Because Harewood registered the address for *REDIRECT_URI*, he was able to log
    the access token of any user who visited the URL, which gave him access to their
    entire Facebook account. Additionally, all official Facebook access tokens include
    access to other Facebook-owned properties, such as Instagram. As a result, Harewood
    could access all Facebook properties on behalf of a targeted user.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider potential forgotten assets when you’re looking for vulnerabilities.
    In this example, the forgotten asset was a sensitive Facebook application with
    full scope permissions. But other examples include subdomain CNAME records and
    application dependencies, such as Ruby Gems, JavaScript libraries, and so on.
    If an application relies on external assets, developers might someday stop using
    that asset and forget to disconnect it from the application. If an attacker can
    take over the asset, that could have severe consequences for the application and
    its users. Additionally, it’s important to recognize that Harewood began his testing
    with a hacking goal in mind. Doing the same is an effective way to focus your
    energy when you’re hacking on large applications, where there are an infinite
    number of areas to test and it’s easy to get distracted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Despite its standardization as an authentication workflow, OAuth is easy for
    developers to misconfigure. Subtle bugs could allow attackers to steal authorization
    tokens and access the private information of targeted users. When you’re hacking
    on OAuth applications, be sure to thoroughly test the *redirect_uri* parameter
    to see whether an application is properly validating when access tokens are sent.
    Also, be on the lookout for custom implementations that support the OAuth workflow;
    the functionality won’t be defined by the OAuth standardized process and is more
    likely to be vulnerable. Before giving up on any OAuth hacking, be sure to consider
    whitelisted assets. Confirm whether the client has trusted any application by
    default that its developers might have forgotten about.
  prefs: []
  type: TYPE_NORMAL
