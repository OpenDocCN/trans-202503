- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5'
- en: COLLECTIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 集合**
- en: '*I don’t want to belong to any club that would accept me as one of its members.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不想属于任何接受我作为成员的俱乐部。*'
- en: —Attributed to Groucho Marx
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —归因于格劳乔·马克思
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: A *collection* is a data structure that functions as a container. The values
    that it holds are its *elements*. Julia’s collections are distinguished from each
    other by what they can contain, whether or not they are mutable, how their elements
    are accessed, whether their contents are ordered, and several other characteristics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*是一个作为容器的数据结构。它包含的值称为其*元素*。Julia的集合通过它们可以包含的内容、是否可变、元素的访问方式、内容是否有序以及其他几个特征来区分。'
- en: We’ve already worked with arrays, strings, and other kinds of Julia containers.
    In this chapter, we’ll learn more about those collections and meet some new ones.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用过数组、字符串和其他类型的Julia容器。在本章中，我们将进一步了解这些集合，并接触一些新的集合类型。
- en: '**Controlling Loop Execution**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**控制循环执行**'
- en: There is an intimate relationship between loops and collections in Julia. The
    `for` loop, for example, depends on a collection or an iterable object whose elements
    are visited in turn.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，循环和集合之间有着密切的关系。例如，`for`循环依赖于一个集合或可迭代对象，循环会逐一访问其中的元素。
- en: We already know how to write loops using `while` and `for` blocks. In this section,
    we’ll explore how to further control loop execution with the `break` and `continue`
    statements, and how to write compact loops with *comprehensions*, a concise way
    to create collections.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何使用`while`和`for`语句块来编写循环。在本节中，我们将探讨如何通过`break`和`continue`语句进一步控制循环的执行，并学习如何使用*推导式*编写简洁的循环，这是一种创建集合的简洁方法。
- en: '***The break Statement***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***break语句***'
- en: Sometimes we need to end a loop based on some condition and prevent it from
    reaching its “normal” termination. This is the purpose of the `break` command,
    which terminates both `while` and `for` loops.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要根据某个条件结束一个循环，并阻止它达到“正常”的终止状态。这就是`break`命令的用途，它可以终止`while`和`for`循环。
- en: 'For example, the following loop repeatedly asks the user for a number and prints
    its square root:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下循环会重复要求用户输入一个数字并打印其平方根：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `while` condition is `true`, which never changes, so the loop would run
    forever were it not for the `break` statement ➊, which terminates the loop if
    the user enters `0` (or a negative number). This is a common pattern when intending
    a loop to run forever until halted by a condition arising with the loop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`条件是`true`，这个条件永远不会改变，因此，如果没有`break`语句 ➊，循环会一直运行下去，直到用户输入`0`（或负数）时终止。这是一个常见的模式，当我们希望循环永远执行，直到由某个条件中断。'
- en: The `readline()` statement reads a line of input from the terminal, terminated
    when the user presses ENTER, and puts the result into a string variable. We need
    to interpret this string as a number, which is what the `parse()` function does
    for us. The first argument to `parse()` specifies what data type to convert the
    string to. The multi-argument version of the `println()` function concatenates
    its arguments, converting numbers to strings as needed ➋.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`readline()`语句从终端读取一行输入，当用户按下ENTER时终止，并将结果存储到一个字符串变量中。我们需要将这个字符串解释为数字，这就是`parse()`函数为我们做的事情。`parse()`的第一个参数指定要将字符串转换成哪种数据类型。`println()`函数的多参数版本会将它的参数连接起来，并根据需要将数字转换为字符串➋。'
- en: 'The `break` statement also terminates `for` loops. In the following example,
    we loop through the numbers in a vector and stop if we get to one that’s a perfect
    square:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句也可以终止`for`循环。在下面的示例中，我们遍历一个向量中的数字，并在遇到完美平方数时停止：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When this is run, it prints this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个代码运行时，它会打印出以下内容：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A number is a perfect square if its square root is an integer. The code tests
    for that by comparing the number’s square root with the same quantity rounded
    by the `round()` function. Since `round()` rounds a number to the nearest integer,
    the two will have the same value if the number is already an integer. The `break`
    statement terminates the loop when the first perfect square is found, so we never
    hear about 16.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字是完美平方数，如果它的平方根是一个整数。代码通过将该数字的平方根与`round()`函数四舍五入后的相同值进行比较来测试这一点。由于`round()`函数会将数字四舍五入到最近的整数，因此，如果数字本身已经是整数，它们的值就会相同。当找到第一个完美平方数时，`break`语句终止循环，所以我们不会看到16。
- en: '***The continue Statement***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***continue语句***'
- en: 'The `continue` statement skips further processing in the current loop iteration
    and proceeds to the next one. This program prints out the first 100 prime numbers
    (we’ll skip the output):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句跳过当前循环迭代中的进一步处理，直接进入下一次迭代。该程序打印出前100个质数（我们将跳过输出部分）：'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The program tests the first 100 integers by checking for integer divisors up
    to the square root of the integer. If *x* is a divisor of *n*, there is no remainder
    when we calculate *n*/*x*; this is what `n % x == 0` checks for ➊. If we find
    a divisor, `n` is not prime, so we set a flag indicating that and `break` out
    of the `while` loop over `x`. In the outer `for` loop, we want to `continue` ➋
    to the next `n` if the current one is not prime, but print it if it is.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通过检查每个整数的平方根以内的整数除数来测试前100个整数。如果 *x* 是 *n* 的除数，那么当我们计算 *n*/*x* 时将没有余数；这就是
    `n % x == 0` 检查的内容 ➊。如果找到一个除数，`n` 就不是质数，因此我们设置一个标志并 `break` 出 `while` 循环。在外部的
    `for` 循环中，如果当前的 `n` 不是质数，我们希望 `continue` ➋ 到下一个 `n`，但如果是质数则打印它。
- en: '**Comprehensions and Generators**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**推导式与生成器**'
- en: 'We often can write `for` loops that create arrays more concisely as *array
    comprehensions*. As a simple example, suppose we wanted a `Vector` containing
    the first five perfect squares. We can construct this with a `for` loop, as in
    the following REPL session listing, but first we have to initialize an empty `Vector`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以更简洁地使用 *数组推导式* 来编写创建数组的 `for` 循环。作为一个简单的例子，假设我们需要一个 `Vector`，包含前五个完美的平方数。我们可以通过一个
    `for` 循环来构建它，如下面的 REPL 会话列表所示，但首先我们需要初始化一个空的 `Vector`：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can accomplish the same thing with an array comprehension:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个数组推导式来完成相同的任务：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We don’t need to initialize the `xs` vector, as the comprehension creates and
    populates it in one step. The types of the results in these examples are different,
    a subject that we’ll examine in [Chapter 8](ch08.xhtml).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要初始化 `xs` 向量，因为推导式在一步中创建并填充它。这些示例中的结果类型不同，这是我们将在 [第8章](ch08.xhtml) 中探讨的主题。
- en: Array comprehensions typically contain two main parts, separated by the keyword
    `for`. The first part is an expression involving a dummy variable, in this case
    `x`. The second part, beginning with `for`, has the same form as the first line
    of the familiar `for` loop and uses the dummy variable from the first part. The
    first part becomes the body of the implied loop, adding a new element to the resulting
    array at each iteration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数组推导式通常包含两部分，分别由关键字 `for` 分隔。第一部分是一个涉及虚拟变量的表达式，在此为 `x`。第二部分，从 `for` 开始，形式与熟悉的
    `for` 循环的第一行相同，并使用第一部分中的虚拟变量。第一部分成为隐式循环的主体，每次迭代时将一个新元素添加到结果数组中。
- en: 'The array that the comprehension creates will have the same shape as the container
    in its second part. Consider the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式创建的数组将具有与其第二部分容器相同的形状。请考虑以下例子：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, since the container iterates over a 2×2 matrix, that is the shape of the
    result as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于容器遍历的是一个 2×2 矩阵，因此结果的形状也是这个矩阵。
- en: 'An array comprehension can contain any number of implied loops. The shape of
    the result depends on whether the loops are separated by `for` or by a comma.
    The following examples illustrate the two possibilities:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数组推导式可以包含任意数量的隐式循环。结果的形状取决于循环是由 `for` 还是逗号分隔的。以下示例说明了这两种可能性：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first case, the result is a `Vector`, as we might expect from two nested
    `for` loops. The second case, using a comma to separate the implied loops, produces
    a `Matrix`. We can add more comma-separated loop clauses to extend this to any
    number of dimensions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，结果是一个 `Vector`，这正是我们从两个嵌套的 `for` 循环中预期的结果。第二种情况，使用逗号分隔隐式循环，产生一个 `Matrix`。我们可以通过添加更多逗号分隔的循环子句，将其扩展到任意维度。
- en: 'Consider the following example that determines which even numbers in the multiplication
    table are divisible by 7:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例，确定乘法表中哪些偶数能被 7 整除：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An `if` statement at the end of a comprehension filters the results; the final
    result of the comprehension is a `Vector`. This example depends on the order of
    operations to avoid unnecessary parentheses: multiplication comes before (binds
    more tightly) than the modulus operator `%`. We pass the result of the comprehension
    to the `unique()` function, which removes duplicate entries from a collection.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式末尾的 `if` 语句过滤结果；推导式的最终结果是一个 `Vector`。这个例子依赖于操作顺序以避免不必要的括号：乘法的优先级高于（绑定得更紧密）模运算符
    `%`。我们将推导式的结果传递给 `unique()` 函数，该函数会从集合中移除重复项。
- en: A *generator expression* has the same form as an array comprehension, but without
    the enclosing square brackets. It creates an iterator, rather than a populated
    array. We can loop, or iterate, over this object to use its members one at a time,
    but it occupies almost no memory. In this way it should recall range expressions
    and their relationship to vectors.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成器表达式*的形式与数组推导相同，但没有包围的方括号。它创建的是一个迭代器，而不是一个已填充的数组。我们可以遍历或迭代这个对象，以一次使用它的一个成员，但它几乎不占用任何内存。这样它应该让你想起范围表达式及其与向量的关系。'
- en: 'In practice, we sometimes need to enclose the generator expression in parentheses
    to avoid ambiguity, as with any other expression. This is the case in the following
    example, where we create a generator version of our multiplication table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，我们有时需要将生成器表达式括起来以避免歧义，就像其他表达式一样。这种情况出现在以下示例中，我们在其中创建了一个生成器版本的乘法表：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We need the parentheses because of the double `for` loop. Julia will not recognize
    this as a generator expression without them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要括号，因为这里有一个双重`for`循环。如果没有它们，Julia 就无法将其识别为生成器表达式。
- en: 'Now we can extract, as before, the even numbers in the table that are divisible
    by 7:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像以前一样提取表中能被7整除的偶数：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the table were large, rather than merely 9×9, using a generator rather than
    populating an array would provide significant memory savings. We can always use
    `collect()` to produce the realized table from the iterator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表格很大，而不仅仅是 9×9，使用生成器而不是填充数组将节省大量内存。我们始终可以使用`collect()`从迭代器中生成已实现的表格。
- en: '**More Ways to Join Strings**'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更多连接字符串的方法**'
- en: A string in Julia is a collection. Its elements are characters. We first met
    the `String` type in “Strings and Characters” on [page 44](ch02.xhtml#ch02lev4),
    and here we’ll explore the most important operations you can perform on strings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，字符串是一个集合。它的元素是字符。我们第一次在“字符串和字符”部分遇到`String`类型，见于[第 44 页](ch02.xhtml#ch02lev4)，在这里我们将探索你可以对字符串执行的最重要操作。
- en: 'We’ve seen how we can join strings using the `*` operator or using `join()`
    to form a string from a vector of strings. We can also use the `string()` function,
    which joins any number of literal strings and string-valued variables into a larger
    `String`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`*`运算符或使用`join()`函数将多个字符串连接成一个字符串。我们还可以使用`string()`函数，它将任何数量的字面量字符串和字符串值变量连接成一个更大的`String`：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since `comma_space` is a string, the `string()` function simply glues it to
    the other strings we supplied. If it were some other type of object, such as a
    number, the call would still work if the object had a string representation. In
    that case, the function first converts it to a string and then performs the join.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`comma_space`是一个字符串，`string()`函数简单地将它与我们提供的其他字符串连接起来。如果它是其他类型的对象，例如数字，只要该对象有字符串表示，调用仍然有效。在这种情况下，函数首先将其转换为字符串，然后进行连接。
- en: 'The `repeat()` function joins a string to itself a specified number of times:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()`函数将一个字符串与自身连接指定的次数：'
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the new string is formed from “ABC” repeated five times, as
    specified in the second argument.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，新字符串是由“ABC”重复五次组成的，正如第二个参数所指定的那样。
- en: We can also use this function to create arrays, as we’ll see in “The repeat()
    Function” on [page 139](ch05.xhtml#ch05lev1sec10).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这个函数创建数组，正如我们在“repeat()函数”中看到的那样，见于[第 139 页](ch05.xhtml#ch05lev1sec10)。
- en: '**Nonstandard String Literals**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**非标准字符串字面量**'
- en: A *string literal* is an expression such as `"abc"` that represents a `String`
    directly. Julia supports a variety of *nonstandard* string literals, represented
    by placing a keyword in front of the string literal with the prefix specifying
    what kind of special-purpose string the expression represents. Such objects carry
    a significance beyond their existence as strings.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串字面量*是像`"abc"`这样的表达式，直接表示一个`String`。Julia 支持多种*非标准*字符串字面量，通过在字符串字面量前加上一个关键字，前缀指定表达式表示的是什么类型的特殊用途字符串。这些对象的意义超出了它们作为字符串的存在。'
- en: We’ve already met an example of one of these objects. In “LaTeX Titles and Label
    Positioning by Data” on [page 103](ch04.xhtml#ch04lev1sec12), we described how
    to use LaTeX strings as graph labels. These are prefixed with an uppercase `L`,
    as in `L"e^{i`π`} + 1 = 0"`. When the graphing programs see an ordinary string
    used as a label, the string is printed on the graph verbatim, but if the label
    is a LaTeX string, the programs know to print its LaTeX-processed form. LaTeX
    strings are defined in the `LaTeXStrings` package. Some nonstandard string literals
    are defined in their own packages, which need to be imported before you can use
    them, while others are built in.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到过其中一个对象的例子。在《LaTeX 标题和标签定位》一书的 [第103页](ch04.xhtml#ch04lev1sec12) 中，我们描述了如何使用
    LaTeX 字符串作为图表标签。这些字符串以大写字母 `L` 为前缀，如 `L"e^{i`π`} + 1 = 0"`。当绘图程序看到普通字符串作为标签时，字符串会原样打印在图表上，但如果标签是
    LaTeX 字符串，程序会知道打印其经过 LaTeX 处理后的形式。LaTeX 字符串在 `LaTeXStrings` 包中定义。一些非标准字符串文字在它们自己的包中定义，使用前需要导入，而其他一些则是内建的。
- en: Under the hood, nonstandard string literals are implemented as macros (see “Macros”
    on [page 170](ch06.xhtml#ch06lev4)). The name of the macro is the tag of the string
    literal followed by `_str`. In other words, the name of the macro implementing
    LaTeX strings is `@L_str`. To see the documentation for a nonstandard string literal
    in the REPL, we enter either `?@L_str` or `?L""` (for LaTeX strings).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，非标准字符串文字是作为宏实现的（参见《宏》一节，在 [第170页](ch06.xhtml#ch06lev4)）。宏的名称是字符串文字的标签，后面跟着
    `_str`。换句话说，实现 LaTeX 字符串的宏名称是 `@L_str`。要在 REPL 中查看非标准字符串文字的文档，我们可以输入 `?@L_str`
    或 `?L""`（对于 LaTeX 字符串）。
- en: '***Raw Strings***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原始字符串***'
- en: 'One useful built-in nonstandard string literal is the *raw string*, written
    by prepending `raw`. Most keywords for nonstandard strings are single letters,
    but `raw` is an exception. Raw strings are used to represent certain character
    sequences literally, where in standard strings they would have an interpretation
    as control characters or something else. For example, ordinarily the sequence
    `\t` is converted into a TAB character when printing a string, but in a raw string
    it’s interpreted literally:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的内建非标准字符串文字是 *原始字符串*，通过在前面加上 `raw` 来表示。大多数非标准字符串的关键字是单个字母，但 `raw` 是一个例外。原始字符串用于按字面意思表示某些字符序列，在标准字符串中它们会被解释为控制字符或其他内容。例如，通常情况下，`\t`
    序列在打印字符串时会被转换为 TAB 字符，但在原始字符串中，它会按字面意思被解释：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the second print command, the non-escaped TAB character is rendered as a
    horizontal space.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个打印命令中，未转义的 TAB 字符被呈现为一个水平空格。
- en: 'Within raw strings, therefore, backslashes are interpreted literally, with
    one exception—they are still needed to escape double quotation marks:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在原始字符串中，反斜杠会按字面意思解释，唯一的例外是——它们仍然需要用来转义双引号：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If a backslash appears anywhere in a raw string aside from directly before a
    double quotation mark, it’s interpreted literally.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在原始字符串中出现反斜杠，除非它紧跟在双引号之前，否则它会被按字面意思解释。
- en: '***Semantic Version Strings***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***语义版本字符串***'
- en: Versions of software releases are identified with tags such as v1.7.1\. Different
    projects use different systems for version tags; one such system is called *semantic
    versioning*. The fields in the string refer to major and minor versions and, optionally,
    other versioning information. See “Further Reading” on [page 151](ch05.xhtml#fur5)
    for a link to the detailed specification.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 软件版本发布的版本通过类似 v1.7.1\. 的标签来标识。不同的项目使用不同的版本标签系统，其中一种系统被称为 *语义版本控制*。字符串中的字段表示主版本和次版本号，另外还可以包含其他版本信息。有关详细规范的链接，请参见《进一步阅读》一节，在
    [第151页](ch05.xhtml#fur5)。
- en: 'Prepend a `v` to create a semantic version string. We can compare versions
    and extract the numerical value of fields, which are returned as hexadecimal numbers,
    indicated by a leading `0x`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在语义版本字符串前加上 `v`。我们可以比较版本并提取字段的数值，这些数值以十六进制数形式返回，前面带有 `0x`：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Julia project itself uses an extended version of this scheme for numbering
    language and package releases, so semantic version strings are built into the
    language.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 项目本身使用这个方案的扩展版来编号语言和包的发布版本，因此语义版本字符串已内建于语言中。
- en: '***Byte Array Literals***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字节数组字面量***'
- en: 'Prepending a string with `b` creates a *byte array literal*: a sequence of
    unsigned, 8-bit integers representing the sequence of characters in the string
    in UTF-8 encoding. As described in “Strings and Characters” on [page 44](ch02.xhtml#ch02lev4),
    characters can take up one to four bytes. Here’s an example of turning a three-character
    string into a byte array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串前添加`b`会创建一个*字节数组字面量*：一系列无符号的8位整数，表示字符串中字符的UTF-8编码顺序。如在[第44页](ch02.xhtml#ch02lev4)的“字符串与字符”中所述，字符可以占用1到4个字节。下面是将一个三字符字符串转换为字节数组的示例：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The characters `a` and `2` are each represented by a single byte, but the character
    `∑` occupies two bytes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 字符`a`和`2`各自由一个字节表示，但字符`∑`占用了两个字节。
- en: 'We can enter the uppercase sigma as a character in the REPL to learn more about
    it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在REPL中输入大写的西格玛字符，以了解更多关于它的信息：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The response informs us that `03A3` is the Unicode *code point* for the character.
    The code point is a single, possibly large, hexadecimal integer that uniquely
    identifies the Unicode character.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 响应告诉我们，`03A3`是字符的Unicode*代码点*。代码点是一个单一的、可能较大的十六进制整数，唯一标识该Unicode字符。
- en: '**NOTE**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A Unicode character may not correspond to a single character when printed.
    Some of them combine with one or more neighboring characters to create accents
    or ligatures.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unicode字符在打印时可能不对应一个单独的字符。一些字符与一个或多个邻近字符结合，形成重音符号或连字。*'
- en: 'We can use code points directly in strings with the escape code `\u`, where
    they’ll be converted into the characters they represent:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在字符串中使用代码点，使用转义码`\u`，它们会被转换为所代表的字符：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To avoid the conversion, we can escape the backslash or use a raw string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免转换，我们可以转义反斜杠或使用原始字符串。
- en: '**String Searching and Replacing**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字符串查找与替换**'
- en: 'The `replace()` function replaces a substring with a different one. It can
    take any number of replacements, which are applied left to right, with the proviso
    that no character undergoes more than one substitution. The following example
    demonstrates the syntax as well as the consequence of the proviso:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace()`函数用另一个子字符串替换指定的子字符串。它可以接受任意数量的替换，按从左到右的顺序应用，但有一个前提条件，即每个字符只能经历一次替换。以下示例展示了语法以及前提条件的影响：'
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The proviso means that the `"Z"` in the first replacement in the last example
    is not replaced by `"WWW"`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该条款意味着最后一个例子中的第一个替换中的`"Z"`不会被替换成`"WWW"`。
- en: '**NOTE**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Multiple replacements in the string* replace() *function first appeared in
    Julia v1.7\. If you are using an earlier version, you can use the* replace() *function
    as described here, but with only one replacement.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串中的多重替换* replace() *函数首次出现在Julia v1.7中。如果你使用的是早期版本，可以按照此处描述的使用* replace()
    *函数，但只能进行一次替换。*'
- en: 'The `occursin()` function tests for the presence of a substring in a string:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`occursin()`函数测试子字符串是否存在于字符串中：'
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This tests for the existence, in the second argument, of the string given in
    the first argument, and it’s case-sensitive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它测试第二个参数中是否存在第一个参数给定的字符串，并且是区分大小写的。
- en: The `occursin()` function follows the tradition of other functions, such as
    `iseven()`, that test a condition and return `true` or `false` (see “The filter()
    Operator” on [page 163](ch06.xhtml#ch06sec1sec4)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`occursin()`函数延续了其他函数的传统，如`iseven()`，用于测试条件并返回`true`或`false`（请参见[第163页](ch06.xhtml#ch06sec1sec4)的“filter()
    操作符”）。'
- en: 'The `findfirst()` and `findlast()` functions each search for the location of
    a character or string in another string. If we ask for the location of a character,
    the functions return the index of its first or last occurence:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`findfirst()`和`findlast()`函数分别查找一个字符或字符串在另一个字符串中的位置。如果我们要求某个字符的位置，这些函数会返回其首次或最后一次出现的索引：'
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If, instead of a character, we supply a string in the first argument, the functions
    return a range giving the location of the string in the second string:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在第一个参数中提供的是一个字符串，而不是一个字符，函数将返回一个范围，给出字符串在第二个字符串中的位置：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These functions return `nothing` if the character or string we’re searching
    for does not exist in the second string.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要查找的字符或字符串在第二个字符串中不存在，这些函数会返回`nothing`。
- en: 'The `findnext()` function behaves similarly, but it accepts a third argument
    giving the location to begin the search:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`findnext()`函数行为类似，但它接受一个第三个参数，用于指定搜索开始的位置：'
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This demonstrates a third optional positional argument for `join()`, which is
    inserted in place of the delimiter (given in the second argument) between the
    final two elements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了`join()`的第三个可选位置参数，它会替代第二个参数给定的分隔符，插入到最后两个元素之间。
- en: 'When we run this program, it prints:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，它会打印：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If `findnext()` or the other string search functions don’t find what they’re
    looking for, they return nothing, or, more specifically, a particular value called
    `nothing`. We take advantage of this in the `while` condition ➊ to end the loop
    when there are no further `e` characters to be found.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `findnext()` 或其他字符串搜索函数没有找到它们要找的内容，它们会返回“什么也没有”，或者更具体地说，返回一个叫做 `nothing`
    的特殊值。我们在 `while` 条件中 ➊ 利用了这一点，当找不到更多的 `e` 字符时结束循环。
- en: All of the searching and replacing functions described in this section work
    with regular expressions as well. Julia uses Perl-compatible regular expressions;
    consult “Further Reading” on [page 151](ch05.xhtml#fur5) for a link to the syntax.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的所有搜索和替换函数也可以与正则表达式一起使用。Julia 使用 Perl 兼容的正则表达式；有关语法的链接，请参阅《进一步阅读》部分，见 [第151页](ch05.xhtml#fur5)。
- en: To define a regular expression, we use a nonstandard string literal with the
    `r` keyword. For example, `r"A.*B"` is a regular expression matching `A` followed
    by any number of characters ending with `B`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义正则表达式，我们使用带有 `r` 关键字的非标准字符串字面量。例如，`r"A.*B"` 是一个正则表达式，匹配 `A` 后跟任意数量的字符，最后是
    `B`。
- en: 'Here’s a simple use of a regular expression to delete everything between a
    particular pair of characters:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的正则表达式示例，用来删除特定字符对之间的所有内容：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Parenthesized fragments in the regular expression become targets that we can
    refer to, in the replacement text, using escaped integers. These integers follow
    the order of the parenthesized fragments, so the first one is referenced by `\1`,
    and so on. In a normal string such escaped integers are interpreted as control
    characters; therefore, Julia has another nonstandard string literal for this purpose,
    using the `s` keyword:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中的括号片段成为我们可以在替换文本中使用转义整数引用的目标。这些整数按照括号片段的顺序排列，所以第一个片段用 `\1` 引用，以此类推。在普通字符串中，这些转义的整数会被解释为控制字符；因此，Julia
    为此目的提供了另一种非标准字符串字面量，使用 `s` 关键字：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This replacement moves the delimited string to the end, preceded by some punctuation,
    instead of deleting the string between the angle brackets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个替换操作将带有定界符的字符串移动到末尾，前面加上一些标点符号，而不是删除尖括号之间的字符串。
- en: '**String Interpolation**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字符串插值**'
- en: Julia happily borrows good ideas from other languages. Perl not only has powerful
    regular expressions, it also has a convenient syntax for *string interpolation*,
    which you can use in Julia.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 高兴地借鉴了其他语言的好点子。Perl 不仅有强大的正则表达式，还具有方便的 *字符串插值* 语法，你也可以在 Julia 中使用。
- en: 'We use string interpolation when we want to insert the values of variables
    or expressions into a string. The interpolation syntax tells Julia to create the
    string representations of these values and place them within a larger string.
    Interpolation lets us avoid messy sequences of string concatenations in favor
    of neater code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想将变量或表达式的值插入到字符串中时，我们使用字符串插值。插值语法告诉 Julia 创建这些值的字符串表示，并将它们放置在更大的字符串中。插值让我们避免了凌乱的字符串连接序列，取而代之的是更整洁的代码：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This example demonstrates the two kinds of string interpolation, both in the
    argument to the `println()` call ➋. After the name entered by the user is stored
    in the variable `name` ➊, we can access its value using string interpolation.
    To interpolate the value of the variable, just use its name after a dollar sign
    (`$`). To interpolate another type of expression, put it inside parentheses after
    the `$`. We did this in order to interpolate the length of the user’s name ➋.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了两种类型的字符串插值，都在 `println()` 调用的参数中 ➋。在用户输入的名称被存储在变量 `name` 中 ➊ 后，我们可以通过字符串插值来访问它的值。要插入变量的值，只需在美元符号（`$`）后面使用它的名称。要插入另一种类型的表达式，将其放在
    `$` 后面的括号内。我们这样做是为了插入用户名称的长度 ➋。
- en: 'We can interpolate any expression into a string. If we want to exclude spaces
    (because they are not letters) from the length of the name, we could use the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何表达式插入到字符串中。如果我们想排除空格（因为它们不是字母）来计算名称的长度，我们可以使用如下方式：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you need an actual dollar sign, escape it with a backslash: `\$`. Naturally,
    `raw` strings do not partake of the interpolation process.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要实际的美元符号，可以用反斜杠转义：`\$`。自然地，`raw` 字符串不会参与插值过程。
- en: '**Additional Collection Types**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**附加集合类型**'
- en: 'This section describes additional types of collections that are all part of
    routine Julia programming: dictionaries, sets, structs, and named tuples.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了其他类型的集合，它们都是日常 Julia 编程的一部分：字典、集合、结构体和具名元组。
- en: '***Dictionaries***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字典***'
- en: Julia’s `Dict` type is similar to dictionaries in Python or associative arrays
    in Bash. It’s a one-dimensional collection like a vector that’s indexed by *key*
    rather than position. [Listing 5-1](ch05.xhtml#ch5lis1) shows one of two ways
    to initialize a dictionary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的`Dict`类型类似于Python中的字典或Bash中的关联数组。它是一个一维集合，像向量一样，但通过*键*而不是位置进行索引。[列表 5-1](ch05.xhtml#ch5lis1)展示了初始化字典的两种方式之一。
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 5-1: Creating a dictionary from key-value pairs*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：从键值对创建字典*'
- en: After this initialization, the new dictionary contains two key-value pairs.
    Each key in this dictionary happens to be the name of the number that it indexes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始化之后，新字典包含了两个键值对。这个字典中的每个键恰好是它所索引的数字的名称。
- en: In addition to supplying the key-value pairs as separate arguments, we can supply
    any iterable object that yields key-value pairs when iterated over. We can initialize
    the dictionary from [Listing 5-1](ch05.xhtml#ch5lis1), for example, with `Dict(["one"=>1;`
    `"two"=>2])`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将键值对作为单独的参数提供外，我们还可以提供任何可迭代对象，当迭代时，它会生成键值对。例如，我们可以通过`Dict(["one"=>1; "two"=>2])`从[列表
    5-1](ch05.xhtml#ch5lis1)初始化字典。
- en: The keys and values in a dictionary can be of any type. In `bd` both of the
    keys are strings, and the values they point to are integers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的键和值可以是任何类型。在`bd`中，两个键都是字符串，且它们指向的值是整数。
- en: 'The syntax for indexing dictionaries is the same as for indexing vectors, but
    the indices are the keys, not the positions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 索引字典的语法与索引向量相同，但索引是键而不是位置：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We initialize the `bd` dictionary with two key-value pairs; as 2 is not one
    of the keys, our attempt to index it with 2 produces an error.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个键值对初始化了`bd`字典；由于2不是其中的键，我们尝试用2来索引字典时会产生错误。
- en: The `keys(bd)` function returns a list of the keys in `bd`; a corresponding
    `values()` function returns a list of values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys(bd)`函数返回`bd`中键的列表；相应的`values()`函数返回值的列表。'
- en: 'The keys in a `Dict` must be unique. If we define an entry with a key that
    already exists, the later definition replaces the existing one:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dict`中的键必须是唯一的。如果我们定义一个已经存在的键，后面的定义将替换掉现有的：'
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the first line we reuse the `"one"` key. Displaying the dictionary shows
    that the new value has replaced the earlier one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中我们重新使用了`"one"`键。显示字典时，可以看到新值已替换了之前的值。
- en: 'The other way to initialize dictionaries is to pass a single argument to `Dict()`.
    The argument can be any iterable that yields tuples; each tuple generates a key-value
    pair:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化字典的另一种方式是向`Dict()`传递一个单一的参数。该参数可以是任何生成元组的可迭代对象；每个元组生成一个键值对：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that the dictionary is printed in what appears to be a random order.
    This is normal, as dictionaries are *unordered* collections, unlike vectors.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字典按看似随机的顺序打印出来。这是正常现象，因为字典是*无序*的集合，不像向量。
- en: '***Sets***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集合***'
- en: Julia’s `Set` data type implements many of the properties of mathematical sets.
    A set in Julia is a collection defined by what elements are contained within it.
    The elements have no order, and the set can’t be indexed. If you add an element
    that’s already there, the set doesn’t change because it already contains the element,
    which can appear only once.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的`Set`数据类型实现了数学集合的许多属性。Julia中的集合是通过其中包含的元素来定义的。元素没有顺序，并且集合不能被索引。如果你添加一个已经存在的元素，集合不会改变，因为它已经包含该元素，而且每个元素只能出现一次。
- en: 'Let’s define two simple sets that we’ll use to illustrate some of the operations
    we can perform on them:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义两个简单的集合，用来说明我们可以在集合上执行的一些操作：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Set()` function, which takes any iterable object, initializes sets. The
    sets’ members are listed in the REPL in an arbitrary order, as order is meaningless
    within a set.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set()`函数接受任何可迭代对象，并初始化集合。集合的成员会按任意顺序列出，因为在集合中顺序是没有意义的。'
- en: 'Let’s ask for the intersection and union of the two sets we just created:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来查看我们刚刚创建的两个集合的交集和并集：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The results in both examples are also sets. The intersection is the set of elements
    common to both sets, while the union is the set of elements existing in either
    set.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 两个示例中的结果也是集合。交集是两个集合中共有的元素，而并集是出现在任一集合中的元素。
- en: 'We can test for a subset relationship between sets with the `issubset()` function,
    which has a Unicode synonym that we also can use as a binary operator:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`issubset()`函数来测试集合之间的子集关系，该函数有一个Unicode同义词，也可以作为二元操作符使用：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To create the subset or superset ➊ characters, we enter \subseteq or \supseteq,
    respectively, followed by TAB. The functions converted the range `4:7` into a
    set automatically and told us that `Set(4:7)` is a subset of `s2`, because every
    member of the former is a member of the latter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建子集或超集 ➊ 字符，可以分别输入 \subseteq 或 \supseteq，然后按 TAB 键。函数将 `4:7` 范围自动转换为一个集合，并告诉我们
    `Set(4:7)` 是 `s2` 的子集，因为前者的每个成员都是后者的成员。
- en: 'We can find the *difference* between two sets, which are the elements of one
    set that are not in another set, using the `setdiff()` function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `setdiff()` 函数找到两个集合之间的*差集*，即一个集合中不在另一个集合中的元素：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The result shows us what remains after removing 3, 4, and 5 from `s1`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示我们在从 `s1` 中移除 3、4 和 5 后剩下的部分。
- en: 'The mutating form of this function removes the members of the second set from
    the first. To add new elements to a set, use `push!()`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的变异形式将第二个集合的成员从第一个集合中移除。要向集合中添加新元素，可以使用 `push!()`：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, first we enlarge `s1` with the member 999, and then we remove
    the elements in `Set(1:3)`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，首先我们使用成员 999 扩展 `s1`，然后移除 `Set(1:3)` 中的元素。
- en: '***Structs***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结构体***'
- en: A `struct` is a collection of named values packaged together under one identifier.
    For an example, [Listing 5-2](ch05.xhtml#ch5lis2) creates a struct to hold two
    pieces of information identifying a web page.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 是一组命名值的集合，这些值在一个标识符下打包在一起。例如，[列表 5-2](ch05.xhtml#ch5lis2) 创建了一个结构体，用来保存标识网页的两条信息。'
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 5-2: Defining a struct*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：定义一个结构体*'
- en: First we define a new struct called `Website`, and then we create a variable,
    `google`, that holds a particular instance of `Website` with specific values for
    `url` and `title`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义一个新的结构体，叫做 `Website`，然后创建一个名为 `google` 的变量，用于存储一个具有特定 `url` 和 `title`
    值的 `Website` 实例。
- en: Conventional style is to capitalize the names of structs. A struct’s name is
    used as a *constructor* that creates *composite objects* with the struct’s type.
    Therefore, making a struct extends Julia by adding a new type to the language.
    Asking Julia for the type of `google` with `typeof(google)` returns `Website`.
    See “User-Defined Types” on [page 234](ch08.xhtml#ch08lev3) for more about the
    utility and power of user-defined types.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的风格是将结构体的名称首字母大写。结构体的名称作为一个*构造函数*，用来创建具有该结构体类型的*复合对象*。因此，定义一个结构体就等于通过向语言中添加新类型来扩展
    Julia。通过 `typeof(google)` 请求 Julia 获取 `google` 的类型时，将返回 `Website`。有关用户自定义类型的更多信息，请参见
    [第234页](ch08.xhtml#ch08lev3)的“用户定义类型”部分。
- en: 'We can reference the fields of composite objects such as structs and the named
    tuples (described next) using *property notation*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*属性符号*来引用复合对象的字段，例如结构体和命名元组（下文会描述）：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After noticing that we forgot to capitalize the title of the website, we try
    to correct it, but Julia doesn’t allow the change because, by default, structs
    are immutable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 发现我们忘记了将网站标题大写后，我们尝试修正它，但 Julia 不允许修改，因为结构体默认是不可变的。
- en: 'We can fix our error by defining `google` anew, but if we plan to mutate `Website`
    objects routinely, we can define them as *mutable structs*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重新定义 `google` 来修复我们的错误，但如果我们计划经常变更 `Website` 对象，我们可以将其定义为*可变结构体*：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now we can change the values of `google`’s fields whenever we want.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以随时更改 `google` 的字段值。
- en: '***Named Tuples***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***命名元组***'
- en: 'A named tuple is just like Julia’s ordinary `Tuple`, except we can give names
    to its values:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组就像是 Julia 的普通 `Tuple`，只是我们可以给它的值命名：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we have a new named tuple called `nt`, with three fields called `a`, `b`,
    and `c`. As this example shows, we extract values from a named tuple using property
    notation, just as with structs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个新的命名元组，叫做 `nt`，它有三个字段，分别叫做 `a`、`b` 和 `c`。如本例所示，我们使用属性符号从命名元组中提取值，就像使用结构体一样。
- en: 'Named tuples are immutable, just as (immutable) structs and ordinary tuples:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组是不可变的，就像（不可变的）结构体和普通元组一样：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The attempt to assign to a field of an immutable data type is not allowed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试给不可变数据类型的字段赋值是不允许的。
- en: Tuples and named tuples are intimately related to function argument lists, as
    we’ll explore in “Functions and Their Arguments” on [page 154](ch06.xhtml#ch06lev1).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 元组和命名元组与函数参数列表密切相关，正如我们将在“函数及其参数”部分（[第154页](ch06.xhtml#ch06lev1)）中探讨的那样。
- en: '**Initializing Arrays with Functions**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用函数初始化数组**'
- en: Julia provides a handful of functions to initialize arrays. Using one of these
    is often more convenient and concise than the literal array definitions that we’ve
    been using up to now.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了一些函数来初始化数组。使用这些函数通常比我们之前一直在使用的字面量数组定义更方便简洁。
- en: '***The repeat() Function***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***repeat() 函数***'
- en: 'The `repeat()` function repeats an array a given number of times along each
    dimension corresponding to the arguments you supply:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()`函数沿着你提供的参数所对应的每个维度重复一个数组指定的次数：'
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, the elements of the one-row array `[`'a' 'b' '|'] are replicated
    four times in the first (column) direction and three times in the second (row)
    direction.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，单行数组`['a' 'b' '|']`的元素在第一（列）方向上复制了四次，在第二（行）方向上复制了三次。
- en: We’ve already met `repeat()`, as a function that replicates a string, in “More
    Ways to Join Strings” on [page 128](ch05.xhtml#ch05lev3).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在《更多字符串连接方法》一节中遇到过`repeat()`，它是一个复制字符串的函数，出现在[第128页](ch05.xhtml#ch05lev3)。
- en: '***The fill() Function***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***fill()函数***'
- en: The `fill()` function takes the value supplied in its first argument and creates
    an array with a shape given by its subsequent arguments, filling it with the value.
    [Listing 5-3](ch05.xhtml#ch5lis3) shows how it works.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill()`函数接受其第一个参数提供的值，并创建一个由后续参数指定形状的数组，用该值填充它。[列表 5-3](ch05.xhtml#ch5lis3)展示了它是如何工作的。'
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 5-3: Filling an array*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：填充数组*'
- en: Here the value `['X' 'Y']` is used to fill a 3×4 array. Unlike `repeat()`, `fill()`
    can accept the dimensions as a tuple as well as separate arguments, so we can
    write the above as `fill(['X' 'Y'], (3, 4))`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，值`['X' 'Y']`用于填充一个3×4的数组。与`repeat()`不同，`fill()`可以接受作为元组的维度以及单独的参数，因此我们可以将上述写作`fill(['X'
    'Y'], (3, 4))`。
- en: The most important difference beteen `repeat()` and `fill()` is that the former
    concatenates the elements of the array supplied in the first argument into the
    requested shape, whereas the latter concatenates the array itself. This can be
    seen in the results of the two examples just shown.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()`和`fill()`之间最重要的区别是，前者将第一个参数中提供的数组元素连接成所请求的形状，而后者则连接整个数组本身。这可以通过刚才展示的两个示例的结果看到。'
- en: '***Mutability with the fill() and repeat() Functions***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***fill()和repeat()函数的可变性***'
- en: 'Let’s try to change one of the elements of the matrix `XY` defined in [Listing
    5-3](ch05.xhtml#ch5lis3). We’ll try to change the `''X''` to an `''O''` in the
    top-right element:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试修改在[列表 5-3](ch05.xhtml#ch5lis3)中定义的矩阵`XY`的一个元素。我们会尝试把右上角的`'X'`改成`'O'`：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The result is surprising to many who encounter it for the first time. In altering
    one of the elements of `XY`, we’ve altered them all. This happens because `fill()`
    doesn’t *copy* its first argument into multiple locations in the result. Each
    element of `XY` is the identical one-row matrix; the output here shows the result
    of mutating this matrix.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 结果对许多首次遇到它的人来说是令人惊讶的。在改变`XY`的一个元素时，我们改变了所有元素。这是因为`fill()`并不会将它的第一个参数*复制*到结果中的多个位置。`XY`的每个元素都是相同的一行矩阵；这里的输出显示了变异这个矩阵后的结果。
- en: 'If, instead of mutating the element, we *replace* it, something different happens:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是变异元素，而是*替换*它，事情就会有所不同：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now `XY` contains two different matrices, one of them appearing 11 times.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`XY`包含了两个不同的矩阵，其中一个出现了11次。
- en: 'We would observe exactly the same behavior using `repeat()` if we placed the
    first argument within an extra set of square brackets:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在额外的一对方括号内放入第一个参数，使用`repeat()`时会观察到完全相同的行为：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this way, after `repeat()` extracts the contents of the first argument and
    concatenates them, we still have an array of arrays.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在`repeat()`提取第一个参数的内容并将它们连接起来后，我们仍然得到了一个数组的数组。
- en: 'To get an array of *different* arrays, rather than the array of references
    to a single array that `fill()` constructs, we can use a comprehension:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到一个*不同*的数组，而不是`fill()`构造的指向单一数组的引用数组，我们可以使用列表推导式：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now altering one of the arrays has no effect on the other elements of `xy` because
    each element is a separate array.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在修改其中一个数组不会影响`xy`的其他元素，因为每个元素都是独立的数组。
- en: '***The zeros() and ones() Functions***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***zeros()和ones()函数***'
- en: 'The `zeros()` and `ones()` functions act as special cases of `fill()` with
    0.0 or 1.0 as a first argument. Like `fill()`, they accept either tuples or separate
    numbers for dimensions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`zeros()`和`ones()`函数是`fill()`的特例，它们的第一个参数分别是0.0或1.0。像`fill()`一样，它们接受元组或单独的数字作为维度：'
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `zeros()` function creates a 4×5 matrix and fills it with 0.0.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`zeros()`函数创建一个4×5的矩阵，并用0.0填充它。'
- en: Using `zeros()` or `ones()` is common when we need to initialize an array of
    floating-point numbers that’s going to be populated by direct indexing. This method
    is faster than using `push!()` to enlarge the array as it’s populated because
    the compiler knows the size of the array at the start, so reallocating memory
    isn’t needed. However, `push!()` may be a better choice if you don’t know the
    size of the array ahead of time and prefer not to allocate memory that the array
    won’t need.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要初始化一个将通过直接索引填充的浮动点数数组时，使用`zeros()`或`ones()`是常见的做法。这种方法比使用`push!()`逐步增大数组更快，因为编译器知道数组的初始大小，因此不需要重新分配内存。然而，如果你事先不知道数组的大小，并且不想为数组未使用的内存分配空间，`push!()`可能是更好的选择。
- en: '***The reshape() Function***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***reshape() 函数***'
- en: 'You can transform an array into a new shape with `reshape()`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`reshape()`将数组转换为新形状：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first two examples show how to use `reshape()`: give the array as a first
    argument and its new dimensions either in a tuple or as a series of individual
    arguments. The last example produces an error because `reshape()` will not change
    the total number of elements.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例展示了如何使用`reshape()`：将数组作为第一个参数传入，并将其新的维度以元组形式或作为一系列单独的参数传入。最后一个示例会产生错误，因为`reshape()`不会改变元素的总数。
- en: 'The `reshape()` function does not create a new array, but returns the original
    array molded into a different shape. You can see the consequence of that when
    mutating either incarnation of the array:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape()`函数不会创建一个新的数组，而是返回原始数组并将其重新塑形。你可以看到这种影响，当你修改数组的任一形态时：'
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Changing the fifth element of `a1` also changes the fifth element of `a2`, where,
    as always, the elements are in column-major order.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`a1`的第五个元素也会修改`a2`的第五个元素，其中元素始终按列主序排列。
- en: 'The behavior of `reshape()` should call to mind the remarks in “Scalar Indexing”
    on [page 38](ch02.xhtml#ch02sec1sec9): arrays are stored contiguously in the computer’s
    one-dimensional memory, which is reflected in their scalar indexing. The multidimensional
    forms of arrays that we use in our programs are abstractions, without which algorithms
    would be far more cumbersome to express in code.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape()`的行为应让你联想到《标量索引》一节中[第38页](ch02.xhtml#ch02sec1sec9)的相关内容：数组在计算机的一维内存中是连续存储的，这反映在它们的标量索引中。我们在程序中使用的数组的多维形式是一种抽象，如果没有这些抽象，算法在代码中表达起来将更加繁琐。'
- en: '**Array Manipulations Useful in Numerical Algorithms**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在数值算法中常用的数组操作**'
- en: Arrays are the most important data type, aside from numbers, in scientific and
    numerical computing. Our algorithms often take the form of a series of transformations
    and operations upon vectors, matrices, and higher-dimensional arrays. Julia’s
    powerful array handling helps us to express these computations in terms of high-level
    operations on entire arrays, rather than verbose loops over their elements. This
    style of programming, when we can use it, is conceptually clearer and less prone
    to error. This section surveys several array operations that arise repeatedly
    in scientific code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是科学和数值计算中最重要的数据类型之一，仅次于数字。我们的算法通常表现为对向量、矩阵和更高维数组的一系列变换和操作。Julia强大的数组处理能力帮助我们通过对整个数组的高层操作来表达这些计算，而不是通过对其元素的冗长循环。当我们能使用这种编程风格时，它在概念上更清晰，也更不容易出错。本节概述了在科学代码中反复出现的几种数组操作。
- en: '***General Concatenation***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***常规拼接***'
- en: 'We’ve discussed the semicolon as a concatenation operator along the first dimension,
    as in this example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过分号作为沿第一个维度进行拼接的运算符，正如这个示例所示：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As an alternative, we can replace the single semicolon with a newline, making
    the input resemble the way Julia prints the matrix in the REPL.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方法，我们可以将单个分号替换为换行符，使输入的格式类似于Julia在REPL中打印矩阵的方式。
- en: '**NOTE**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The use of repeated semicolons described in this section arrived with Julia
    v1.7\. In earlier versions, repeated semicolons were treated as a single semicolon.*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节中描述的重复分号的用法是在Julia v1.7引入的。在早期版本中，重复的分号被视为单个分号。*'
- en: 'A series of *n* semicolons concatenates along the *n*th dimension, adding new
    dimensions as needed, so two semicolons concatenate along the second dimension,
    which is also how a space concatenates:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列的*n*个分号会沿着第*n*个维度进行拼接，并根据需要添加新维度，因此两个分号会沿第二个维度拼接，这也是空格拼接的方式：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Both examples perform the same operation: `[1 2]` is concatenated with `[3
    4]` along the second, or column, dimension, increasing the number of columns.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子执行相同的操作：`[1 2]` 与 `[3 4]` 在第二维（即列）上连接，增加了列数。
- en: 'Using three semicolons creates a new third dimension and joins along it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个分号可以创建一个新的第三维度，并沿其连接：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this example, the `[3 4]` array is put “on top” of the `[1 2]` array, in
    what is sometimes called a new *plane*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`[3 4]` 数组被放置在 `[1 2]` 数组的“上面”，这种操作有时称为创建一个新的 *平面*。
- en: '***Logical Indexing***'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***逻辑索引***'
- en: Julia can store an array of Boolean values in a space-efficient manner with
    its `BitArray` data type. In a `BitArray`, or the subtypes `BitVector` and `BitMatrix`,
    `true` and `false` are represented by 1 and 0\. These logical arrays are used
    for indexing, where they act as filters, selecting elements corresponding in position
    to the 1 values and rejecting the ones corresponding to the 0 values. When used
    for indexing, the array being indexed and the `BitArray` must have the same number
    of elements.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 可以通过其 `BitArray` 数据类型以空间高效的方式存储布尔值数组。在 `BitArray` 中，或者其子类型 `BitVector`
    和 `BitMatrix` 中，`true` 和 `false` 分别由 1 和 0 表示。这些逻辑数组用于索引操作，它们充当过滤器，选择与 1 对应位置的元素，并排除与
    0 对应位置的元素。在用于索引时，被索引的数组和 `BitArray` 必须具有相同的元素数量。
- en: 'We create a `BitArray` with a logical condition broadcast into an array. For
    example, the following creates a `BitArray` that picks out which elements of `1:9`
    are divisible by 3:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 `BitArray`，通过逻辑条件将其广播到一个数组中。例如，下面的代码创建了一个 `BitArray`，选择 `1:9` 中能被 3 整除的元素：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In order to return the result, Julia instantiates the range expression into
    an array. Each location that gives a zero remainder when divided by 3 is indicated
    by a `1`, and the others by a `0`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了返回结果，Julia 将范围表达式实例化为一个数组。每个当除以 3 后余数为零的位置用 `1` 表示，其他位置用 `0` 表示。
- en: 'We assigned the `BitArray` to a variable so we can use it in other expressions.
    We can use it on the `1:9` range itself:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `BitArray` 分配给一个变量，这样可以在其他表达式中使用它。我们可以直接在 `1:9` 范围上使用它：
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The 1s in `s3` pick out the elements in `1:9` that are divisible by 3.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`s3` 中的 1 选择了 `1:9` 中能被 3 整除的元素。'
- en: 'We can also use it to select every third element from any collection with nine
    elements:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用它从任何包含九个元素的集合中选择每第三个元素：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Although the collection we’re indexing and the `BitArray` must have the same
    number of elements, the collection can have any shape if the `BitArray` is a `BitVector`;
    otherwise, the array and the `BitArray` must have the same shape.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们正在索引的集合和 `BitArray` 必须具有相同数量的元素，但如果 `BitArray` 是 `BitVector` 类型，集合可以具有任意形状；否则，数组和
    `BitArray` 必须具有相同的形状。
- en: 'Here’s an example of using `BitArray` indexing, also called logical indexing,
    as a concise way to print out all the integers in [1, 100] that are divisible
    by 17:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 `BitArray` 索引的例子，也叫做逻辑索引，它是一种简洁的方式，打印出 [1, 100] 范围内所有能被 17 整除的整数：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The only difference here is that we create the bit index and use it in an indexing
    expression in one step, rather than storing it in a variable for later use.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的区别是我们在一步操作中创建比特索引并在索引表达式中使用它，而不是将其存储在变量中以便后续使用。
- en: '***Adjoints and Transposes***'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***伴随矩阵和转置矩阵***'
- en: The transpose of a matrix is the matrix formed by flipping it across its diagonal,
    so that ![Image](../images/math144.jpg) when *M^'* is the transpose of *M*. The
    adjoint of a matrix is formed by taking its transpose and replacing each of its
    elements by its complex conjugate (the terminology is consistent with the concept
    of the adjoint of a linear operator, if matrices are regarded as linear transformations
    applied to vectors through conventional matrix multiplication).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的转置是通过将矩阵沿其对角线翻转形成的矩阵，因此 ![Image](../images/math144.jpg)，其中 *M^'* 是 *M* 的转置。矩阵的伴随矩阵是通过取其转置并将每个元素替换为其共轭复数得到的（这一术语与线性算子的伴随概念一致，如果矩阵被视为通过常规矩阵乘法应用于向量的线性变换）。
- en: 'To flip a matrix `MR` containing real numbers across its diagonal, we can use
    three notations: `MR'', adjoint(MR)`, or `permutedims(MR)`. [Listing 5-4](ch05.xhtml#ch5lis4)
    shows that they all give the same results.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要将包含实数的矩阵 `MR` 沿其对角线翻转，我们可以使用三种表示法：`MR'`，`adjoint(MR)`，或 `permutedims(MR)`。[Listing
    5-4](ch05.xhtml#ch5lis4) 显示它们都会给出相同的结果。
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Listing 5-4: Matrix adjoint notations*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-4: 矩阵伴随表示法*'
- en: Since the elements of `MR` are their own complex conjugates, its adjoint is
    just its transpose.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `MR` 的元素是其自身的共轭复数，因此它的伴随矩阵就是其转置矩阵。
- en: 'However, if the matrix’s elements are almost anything else, `adjoint()` and
    `permutedims()` generally give different results; the `''` operator is a synonym
    for `adjoint()`. The `permutedims()` function flips the matrix around the diagonal
    and does nothing else, as shown here, and `adjoint()` does the same flip, called
    a *transpose*, but also takes the complex conjugate of each element. This operation
    is also known as the *Hermitian adjoint*. Consider this example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果矩阵的元素几乎是其他任何类型，`adjoint()`和`permutedims()`通常会给出不同的结果；`'`运算符是`adjoint()`的同义词。`permutedims()`函数仅在对角线周围翻转矩阵，不做其他处理，正如这里所示，而`adjoint()`则做同样的翻转，称为*转置*，但还会对每个元素取复共轭。这个操作也被称为*厄米共轭*。考虑这个例子：
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The matrix is flipped, as before, but now with each element replaced by its
    complex conjugate. Note that we can’t use the `adjoint()` function on non-numerical
    matrices, where the complex conjugate of the elements has no meaning.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵像之前一样被翻转，但现在每个元素都被其复共轭所替代。请注意，我们不能对非数值矩阵使用`adjoint()`函数，因为在这些矩阵中，元素的复共轭没有意义。
- en: 'In addition to `adjoint()` and `permutedims()`, we have the `transpose()` function:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`adjoint()`和`permutedims()`，我们还有`transpose()`函数：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The result looks like the simple transposition of `M`, with no complex conjugates
    taken, but this is what `permutedims()` is supposed to do. Why do we have two
    functions that seem to do the same thing?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像是对`M`进行了简单的转置，没有进行复共轭处理，但这正是`permutedims()`应该做的。那么，为什么我们有两个看起来做同样事情的函数呢？
- en: 'The `adjoint()` and `transpose()` functions, on the one hand, and `permutedims()`,
    on the other, behave quite differently. The first two functions mentioned act
    recursively: if the elements of `M` are themselves matrices, `adjoint()` and `transpose()`
    will first act on `M`, then on the elements of `M`, and so on, all the way down.
    In contrast, `permutedims()` just flips `M` and stops.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`adjoint()`和`transpose()`函数一方面，`permutedims()`另一方面，表现得非常不同。前两个函数是递归的：如果`M`的元素本身是矩阵，`adjoint()`和`transpose()`会先对`M`进行操作，然后对`M`的元素进行操作，依此类推，一直处理下去。相比之下，`permutedims()`只是翻转`M`并停止。'
- en: The second difference is that, like `reshape()`, `adjoint()` and `transpose()`
    return the same array in a different form, so mutating the result mutates the
    original, unlike `permutedims()`, which returns a new array.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别在于，像`reshape()`一样，`adjoint()`和`transpose()`返回的是相同数组的不同形式，因此对结果进行修改会修改原始数组，这与`permutedims()`不同，后者返回一个新数组。
- en: In general, to flip around tables of numbers, we turn to the `permutedims()`
    function. The other two functions are intended for more specialized linear algebra
    applications.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，要翻转数值表格，我们使用`permutedims()`函数。其他两个函数则用于更专业的线性代数应用。
- en: 'The `conj()` function, which takes the complete conjugate of a number, can
    of course be broadcast to work on each element of an array by using the dot operator.
    However, unlike most other math functions, it acts elementwise on arrays without
    broadcasting:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`conj()`函数，它对一个数字进行完全的共轭，可以通过使用点操作符广播到数组的每个元素。然而，和大多数其他数学函数不同，它在数组上逐元素操作，而不会进行广播：'
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here we’ve taken the complex conjugate of each element to transform the matrix.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经对每个元素进行了复共轭操作，以转换矩阵。
- en: '***Matrix Multiplication***'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***矩阵乘法***'
- en: 'The multiplication operator (`*`) performs matrix multiplication when supplied
    with a pair of matrices or a matrix and a vector. As an example, we’ll make a
    rotation matrix and matrix-multiply to rotate a vector:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算符（`*`）在给定一对矩阵或一个矩阵和一个向量时执行矩阵乘法。举个例子，我们将创建一个旋转矩阵并进行矩阵乘法，以旋转一个向量：
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The exact result should be `[0, 1]`: the rotation of a unit vector pointing
    “to the right” when rotated π/2 radians counterclockwise. The answer we get is
    the result of roundoff in floating-point arithmetic.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 精确结果应该是`[0, 1]`：单位向量指向“右侧”，当其逆时针旋转π/2弧度时的旋转结果。我们得到的答案是浮点数运算中的舍入误差。
- en: 'For serious work with matrices, systems of linear equations, and related fields,
    you should import the `LinearAlgebra` package, which we’ll visit in “The LinearAlgebra
    Package” on [page 399](ch12.xhtml#ch12lev1sec5). That package has a function for
    calculating the *inverse* of a matrix, but we can calculate matrix inverses without
    importing the package with an intuitive notation:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵、线性方程组及相关领域的深入工作，你应该导入`LinearAlgebra`包，我们将在《线性代数包》一节中访问它，见[第399页](ch12.xhtml#ch12lev1sec5)。这个包有一个计算矩阵*逆*的函数，但我们也可以通过直观的符号在不导入包的情况下计算矩阵逆：
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example we use the matrix `MR` defined in [Listing 5-4](ch05.xhtml#ch5lis4).
    The result of multiplying a matrix by its inverse (with matrix multiplication)
    should be the identity matrix (1s along the diagonal and 0s elsewhere), which,
    within floating-point roundoff, is what we get.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了在[列表 5-4](ch05.xhtml#ch5lis4)中定义的矩阵 `MR`。将一个矩阵与其逆矩阵相乘（矩阵乘法）应该得到单位矩阵（对角线为
    1，其它位置为 0），这是我们通过浮点数舍入误差所得到的结果。
- en: '**Enumeration and Zipping**'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**枚举和合并**'
- en: Julia comes with several functions, common in modern high-level languages, for
    enumerating and zipping arrays. The former refers to the association of indices
    with the elements of a collection, while the latter refers to the joining, element
    by element, of two collections. All the functions in this section return iterators,
    either over a collection of tuples or over a collection of key-value pairs.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了多个函数，常见于现代高级编程语言，用于枚举和合并数组。前者指的是将集合的索引与元素关联，而后者则指的是将两个集合按元素逐一连接。本节中的所有函数都返回迭代器，这些迭代器可以是元组集合的迭代器，也可以是键值对集合的迭代器。
- en: '***The enumerate() Function***'
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***enumerate() 函数***'
- en: The `enumerate()` function takes a collection and returns an iterator into a
    collection of tuples that contains the number of the iteration as their first
    elements and the member of the collection retrieved as their second elements.
    [Listing 5-5](ch05.xhtml#ch5lis5) shows that the collection of tuples has the
    same shape as the original collection.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()` 函数接受一个集合，并返回一个迭代器，该迭代器生成一个元组集合，每个元组包含迭代的编号作为第一个元素，以及从集合中获取的成员作为第二个元素。[列表
    5-5](ch05.xhtml#ch5lis5) 显示了元组集合与原始集合的形状相同。'
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '*Listing 5-5: Using enumerate()*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：使用 enumerate()*'
- en: Since `enumerate()` returns an iterator, we need to `collect()` it to see it.
    These iterators, like ranges and other iterators, such as the ones created by
    generators (see “Comprehensions and Generators” on [page 125](ch05.xhtml#ch05lev2)),
    take up almost no space until we use them to loop over a collection or turn them
    into an actual array with the `collect()` function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `enumerate()` 返回的是一个迭代器，我们需要使用 `collect()` 来查看它。与范围（ranges）和由生成器（参见[第 125
    页](ch05.xhtml#ch05lev2)的“推导式与生成器”）创建的其它迭代器一样，这些迭代器几乎不占用空间，直到我们使用它们来循环遍历集合，或使用
    `collect()` 函数将它们转化为实际的数组。
- en: The array that `collect()` returns in [Listing 5-5](ch05.xhtml#ch5lis5) is laid
    out as specified in the argument to `enumerate()`, and the iteration numbers,
    the first elements of the tuples, reflect the column-major order in which the
    array was traversed.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-5](ch05.xhtml#ch5lis5) 中 `collect()` 返回的数组按照传递给 `enumerate()` 的参数排列，迭代编号（即元组的第一个元素）反映了数组遍历时的列主序。'
- en: The iteration numbers that `enumerate()` returns aren’t guaranteed to be legal
    indices of the array. Even when they are, they don’t necessarily return the element
    that they index. In other words, if one of the tuples `enumerate(A)` returns is
    `(i, e)`, `A[i]` may be an error. If it’s not an error, it may be the case that
    `A[i]` does not equal `e`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()` 返回的迭代编号并不保证是数组的合法索引。即使它们是合法的，也不一定能返回其所索引的元素。换句话说，如果 `enumerate(A)`
    返回的某个元组是 `(i, e)`，那么 `A[i]` 可能会出错。如果没有出错，也有可能 `A[i]` 不等于 `e`。'
- en: In the case of a numerical array, such as in [Listing 5-5](ch05.xhtml#ch5lis5),
    the first elements of the tuples *can* be used as scalar indices into the array,
    and `enumerate()` is sometimes used for this purpose.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字数组的情况下，比如在[列表 5-5](ch05.xhtml#ch5lis5)中，元组的第一个元素 *可以* 用作数组的标量索引，而 `enumerate()`
    有时也会用于这个目的。
- en: 'An example of where the iteration number *cannot* be used as an index involves
    our old friend François:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不能将迭代编号用作索引的例子涉及到我们的老朋友 François：
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The iteration number tells us where each character appears in the string, but,
    as we saw in “Strings and Characters” on [page 44](ch02.xhtml#ch02lev4), not all
    of these character positions are legal indices:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代编号告诉我们每个字符在字符串中出现的位置，但正如我们在[第 44 页](ch02.xhtml#ch02lev4)的“字符串与字符”一节中看到的，并非所有字符位置都是合法的索引：
- en: '[PRE67]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In summary, don’t confuse iteration numbers with indexing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，不要将迭代编号与索引混淆。
- en: '***The pairs() Function***'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***pairs() 函数***'
- en: 'The `pairs()` function is similar to `enumerate()`, except it creates an iterator
    over key-value pairs rather than over tuples:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairs()` 函数与 `enumerate()` 类似，唯一不同的是它创建的是键值对的迭代器，而不是元组的迭代器：'
- en: '[PRE68]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The indices returned by `pairs()` are legal indices into the collection rather
    than iteration numbers as with `enumerate()`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairs()` 返回的索引是集合的合法索引，而不是像 `enumerate()` 那样的迭代编号。'
- en: 'The objects in the iterator returned by `enumerate()` are tuples; those in
    the iterator returned by `pairs()` are key-value pairs. Such pairs have their
    own data type: `Pair`. If `p` is a `Pair`, we can access its key with `p.first`
    and its value with `p.second`. Therefore, if we need a vector of indices into
    the name of our French friend, we can get it this way:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`返回的迭代器中的对象是元组；`pairs()`返回的迭代器中的对象是键值对。这些键值对有自己的数据类型：`Pair`。如果`p`是一个`Pair`，我们可以通过`p.first`访问它的键，通过`p.second`访问它的值。因此，如果我们需要一个指向我们法国朋友名字的索引向量，可以通过以下方式获得：'
- en: '[PRE69]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We can create a `Pair` with a constructor like `Pair(9, 's')`, or by using the
    `=>` operator—for example, `9 => 's'`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构造函数`Pair(9, 's')`来创建一个`Pair`，或者使用`=>`运算符，例如`9 => 's'`。
- en: 'In [Listing 5-1](ch05.xhtml#ch5lis1), we created a dictionary from a series
    of key-value pairs entered directly. Each of those literal key-value pairs is
    a `Pair`; here’s another way to construct the dictionary:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 5-1](ch05.xhtml#ch5lis1)中，我们从一系列直接输入的键值对创建了一个字典。每个字面量的键值对都是一个`Pair`；这里还有另一种构造字典的方法：
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We make the pair `p1` using the `=>` operator and `p2` using the `Pair()` constructor.
    Passing them to the `Dict()` function creates the same dictionary as in [Listing
    5-1](ch05.xhtml#ch5lis1).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`=>`运算符创建`p1`，并使用`Pair()`构造函数创建`p2`。将它们传递给`Dict()`函数，创建与[清单 5-1](ch05.xhtml#ch5lis1)中相同的字典。
- en: 'A dictionary is an unordered collection of `Pair`s. Iterating through a dictionary
    produces each `Pair` in turn, but in an unpredictable order:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一个无序的`Pair`集合。遍历字典会依次返回每个`Pair`，但顺序是不可预测的：
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***The zip() Function***'
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***zip() 函数***'
- en: The `zip()` function takes any number of collections and returns an iterator
    into a collection of tuples that combines the elements of the collections.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数接受任意数量的集合，并返回一个迭代器，该迭代器合并了各个集合的元素，形成一个包含元组的集合。'
- en: 'When the collections passed in have the same shape, the returned iterator will
    have that shape as well:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当传入的集合具有相同的形状时，返回的迭代器也将具有该形状：
- en: '[PRE72]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first elements of each collection are paired together, followed by the second,
    and so on. In this use of `zip()`, the shapes of the arguments must match.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合的第一个元素被配对在一起，接着是第二个元素，依此类推。在这种`zip()`用法中，参数的形状必须匹配。
- en: 'If one of the collections is a list, the other can have any shape. The elements
    of the list are paired with the elements of the other collection in column-major
    order:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个集合是列表，另一个集合可以具有任何形状。列表中的元素与另一个集合的元素按照列主序进行配对：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here a one-dimensional list is zipped with a 2×2 matrix; each has four elements.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，一个一维列表与一个2×2矩阵进行配对；每个都包含四个元素。
- en: 'When using a vector, the numbers of elements need not match; `zip()` will continue
    until it runs out of elements:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用向量时，元素的数量不必匹配；`zip()`会继续直到元素耗尽：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the first example, the three-element vector is exhausted before we run out
    of elements in the 2×2 matrix. In the second example, the second argument is exhausted
    before we use up all the elements in `1:5`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，三元素向量在2×2矩阵的元素耗尽之前已经耗尽。在第二个示例中，第二个参数在我们用完`1:5`中的所有元素之前就已耗尽。
- en: '**Conclusion**'
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: 'Julia is a somewhat “big” language: it has a lot of syntax and a large stable
    of data types. These features have a purpose, and they contribute to Julia’s power
    and convenience. Fortunately, you don’t have to use everything in the language
    in every program. In this chapter, we’ve encountered some new syntax that makes
    working with collections more concise and intuitive. In the next chapter, we’ll
    explore some new concepts that afford the Julia programmer higher levels of flexibility
    and control.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 是一个相对“庞大”的语言：它有大量的语法和数据类型。这些特性是有目的的，它们有助于提升Julia的强大功能和便利性。幸运的是，你并不需要在每个程序中都使用语言中的所有内容。在本章中，我们遇到了一些新的语法，它使得处理集合更加简洁和直观。在下一章，我们将探索一些新的概念，为Julia程序员提供更高的灵活性和控制力。
- en: '**FURTHER READING**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: The specification for semantic versioning is available at [*https://semver.org*](https://semver.org).
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义版本控制的规范可以在[*https://semver.org*](https://semver.org)找到。
- en: For more information on Perl-compatible regular expressions, visit [*http://www.pcre.org*](http://www.pcre.org).
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欲了解更多关于Perl兼容正则表达式的信息，请访问[*http://www.pcre.org*](http://www.pcre.org)。
