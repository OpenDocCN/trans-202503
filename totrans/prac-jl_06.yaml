- en: '**5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: COLLECTIONS**
  prefs: []
  type: TYPE_NORMAL
- en: '*I don’t want to belong to any club that would accept me as one of its members.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Attributed to Groucho Marx
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A *collection* is a data structure that functions as a container. The values
    that it holds are its *elements*. Julia’s collections are distinguished from each
    other by what they can contain, whether or not they are mutable, how their elements
    are accessed, whether their contents are ordered, and several other characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already worked with arrays, strings, and other kinds of Julia containers.
    In this chapter, we’ll learn more about those collections and meet some new ones.
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlling Loop Execution**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is an intimate relationship between loops and collections in Julia. The
    `for` loop, for example, depends on a collection or an iterable object whose elements
    are visited in turn.
  prefs: []
  type: TYPE_NORMAL
- en: We already know how to write loops using `while` and `for` blocks. In this section,
    we’ll explore how to further control loop execution with the `break` and `continue`
    statements, and how to write compact loops with *comprehensions*, a concise way
    to create collections.
  prefs: []
  type: TYPE_NORMAL
- en: '***The break Statement***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes we need to end a loop based on some condition and prevent it from
    reaching its “normal” termination. This is the purpose of the `break` command,
    which terminates both `while` and `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following loop repeatedly asks the user for a number and prints
    its square root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `while` condition is `true`, which never changes, so the loop would run
    forever were it not for the `break` statement ➊, which terminates the loop if
    the user enters `0` (or a negative number). This is a common pattern when intending
    a loop to run forever until halted by a condition arising with the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `readline()` statement reads a line of input from the terminal, terminated
    when the user presses ENTER, and puts the result into a string variable. We need
    to interpret this string as a number, which is what the `parse()` function does
    for us. The first argument to `parse()` specifies what data type to convert the
    string to. The multi-argument version of the `println()` function concatenates
    its arguments, converting numbers to strings as needed ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `break` statement also terminates `for` loops. In the following example,
    we loop through the numbers in a vector and stop if we get to one that’s a perfect
    square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is run, it prints this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A number is a perfect square if its square root is an integer. The code tests
    for that by comparing the number’s square root with the same quantity rounded
    by the `round()` function. Since `round()` rounds a number to the nearest integer,
    the two will have the same value if the number is already an integer. The `break`
    statement terminates the loop when the first perfect square is found, so we never
    hear about 16.
  prefs: []
  type: TYPE_NORMAL
- en: '***The continue Statement***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `continue` statement skips further processing in the current loop iteration
    and proceeds to the next one. This program prints out the first 100 prime numbers
    (we’ll skip the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The program tests the first 100 integers by checking for integer divisors up
    to the square root of the integer. If *x* is a divisor of *n*, there is no remainder
    when we calculate *n*/*x*; this is what `n % x == 0` checks for ➊. If we find
    a divisor, `n` is not prime, so we set a flag indicating that and `break` out
    of the `while` loop over `x`. In the outer `for` loop, we want to `continue` ➋
    to the next `n` if the current one is not prime, but print it if it is.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comprehensions and Generators**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We often can write `for` loops that create arrays more concisely as *array
    comprehensions*. As a simple example, suppose we wanted a `Vector` containing
    the first five perfect squares. We can construct this with a `for` loop, as in
    the following REPL session listing, but first we have to initialize an empty `Vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can accomplish the same thing with an array comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need to initialize the `xs` vector, as the comprehension creates and
    populates it in one step. The types of the results in these examples are different,
    a subject that we’ll examine in [Chapter 8](ch08.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Array comprehensions typically contain two main parts, separated by the keyword
    `for`. The first part is an expression involving a dummy variable, in this case
    `x`. The second part, beginning with `for`, has the same form as the first line
    of the familiar `for` loop and uses the dummy variable from the first part. The
    first part becomes the body of the implied loop, adding a new element to the resulting
    array at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The array that the comprehension creates will have the same shape as the container
    in its second part. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, since the container iterates over a 2×2 matrix, that is the shape of the
    result as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array comprehension can contain any number of implied loops. The shape of
    the result depends on whether the loops are separated by `for` or by a comma.
    The following examples illustrate the two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, the result is a `Vector`, as we might expect from two nested
    `for` loops. The second case, using a comma to separate the implied loops, produces
    a `Matrix`. We can add more comma-separated loop clauses to extend this to any
    number of dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example that determines which even numbers in the multiplication
    table are divisible by 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An `if` statement at the end of a comprehension filters the results; the final
    result of the comprehension is a `Vector`. This example depends on the order of
    operations to avoid unnecessary parentheses: multiplication comes before (binds
    more tightly) than the modulus operator `%`. We pass the result of the comprehension
    to the `unique()` function, which removes duplicate entries from a collection.'
  prefs: []
  type: TYPE_NORMAL
- en: A *generator expression* has the same form as an array comprehension, but without
    the enclosing square brackets. It creates an iterator, rather than a populated
    array. We can loop, or iterate, over this object to use its members one at a time,
    but it occupies almost no memory. In this way it should recall range expressions
    and their relationship to vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, we sometimes need to enclose the generator expression in parentheses
    to avoid ambiguity, as with any other expression. This is the case in the following
    example, where we create a generator version of our multiplication table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We need the parentheses because of the double `for` loop. Julia will not recognize
    this as a generator expression without them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can extract, as before, the even numbers in the table that are divisible
    by 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the table were large, rather than merely 9×9, using a generator rather than
    populating an array would provide significant memory savings. We can always use
    `collect()` to produce the realized table from the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Ways to Join Strings**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A string in Julia is a collection. Its elements are characters. We first met
    the `String` type in “Strings and Characters” on [page 44](ch02.xhtml#ch02lev4),
    and here we’ll explore the most important operations you can perform on strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen how we can join strings using the `*` operator or using `join()`
    to form a string from a vector of strings. We can also use the `string()` function,
    which joins any number of literal strings and string-valued variables into a larger
    `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since `comma_space` is a string, the `string()` function simply glues it to
    the other strings we supplied. If it were some other type of object, such as a
    number, the call would still work if the object had a string representation. In
    that case, the function first converts it to a string and then performs the join.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `repeat()` function joins a string to itself a specified number of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the new string is formed from “ABC” repeated five times, as
    specified in the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use this function to create arrays, as we’ll see in “The repeat()
    Function” on [page 139](ch05.xhtml#ch05lev1sec10).
  prefs: []
  type: TYPE_NORMAL
- en: '**Nonstandard String Literals**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *string literal* is an expression such as `"abc"` that represents a `String`
    directly. Julia supports a variety of *nonstandard* string literals, represented
    by placing a keyword in front of the string literal with the prefix specifying
    what kind of special-purpose string the expression represents. Such objects carry
    a significance beyond their existence as strings.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already met an example of one of these objects. In “LaTeX Titles and Label
    Positioning by Data” on [page 103](ch04.xhtml#ch04lev1sec12), we described how
    to use LaTeX strings as graph labels. These are prefixed with an uppercase `L`,
    as in `L"e^{i`π`} + 1 = 0"`. When the graphing programs see an ordinary string
    used as a label, the string is printed on the graph verbatim, but if the label
    is a LaTeX string, the programs know to print its LaTeX-processed form. LaTeX
    strings are defined in the `LaTeXStrings` package. Some nonstandard string literals
    are defined in their own packages, which need to be imported before you can use
    them, while others are built in.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, nonstandard string literals are implemented as macros (see “Macros”
    on [page 170](ch06.xhtml#ch06lev4)). The name of the macro is the tag of the string
    literal followed by `_str`. In other words, the name of the macro implementing
    LaTeX strings is `@L_str`. To see the documentation for a nonstandard string literal
    in the REPL, we enter either `?@L_str` or `?L""` (for LaTeX strings).
  prefs: []
  type: TYPE_NORMAL
- en: '***Raw Strings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One useful built-in nonstandard string literal is the *raw string*, written
    by prepending `raw`. Most keywords for nonstandard strings are single letters,
    but `raw` is an exception. Raw strings are used to represent certain character
    sequences literally, where in standard strings they would have an interpretation
    as control characters or something else. For example, ordinarily the sequence
    `\t` is converted into a TAB character when printing a string, but in a raw string
    it’s interpreted literally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the second print command, the non-escaped TAB character is rendered as a
    horizontal space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within raw strings, therefore, backslashes are interpreted literally, with
    one exception—they are still needed to escape double quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If a backslash appears anywhere in a raw string aside from directly before a
    double quotation mark, it’s interpreted literally.
  prefs: []
  type: TYPE_NORMAL
- en: '***Semantic Version Strings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Versions of software releases are identified with tags such as v1.7.1\. Different
    projects use different systems for version tags; one such system is called *semantic
    versioning*. The fields in the string refer to major and minor versions and, optionally,
    other versioning information. See “Further Reading” on [page 151](ch05.xhtml#fur5)
    for a link to the detailed specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepend a `v` to create a semantic version string. We can compare versions
    and extract the numerical value of fields, which are returned as hexadecimal numbers,
    indicated by a leading `0x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Julia project itself uses an extended version of this scheme for numbering
    language and package releases, so semantic version strings are built into the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: '***Byte Array Literals***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Prepending a string with `b` creates a *byte array literal*: a sequence of
    unsigned, 8-bit integers representing the sequence of characters in the string
    in UTF-8 encoding. As described in “Strings and Characters” on [page 44](ch02.xhtml#ch02lev4),
    characters can take up one to four bytes. Here’s an example of turning a three-character
    string into a byte array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The characters `a` and `2` are each represented by a single byte, but the character
    `∑` occupies two bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enter the uppercase sigma as a character in the REPL to learn more about
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The response informs us that `03A3` is the Unicode *code point* for the character.
    The code point is a single, possibly large, hexadecimal integer that uniquely
    identifies the Unicode character.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A Unicode character may not correspond to a single character when printed.
    Some of them combine with one or more neighboring characters to create accents
    or ligatures.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use code points directly in strings with the escape code `\u`, where
    they’ll be converted into the characters they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To avoid the conversion, we can escape the backslash or use a raw string.
  prefs: []
  type: TYPE_NORMAL
- en: '**String Searching and Replacing**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `replace()` function replaces a substring with a different one. It can
    take any number of replacements, which are applied left to right, with the proviso
    that no character undergoes more than one substitution. The following example
    demonstrates the syntax as well as the consequence of the proviso:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The proviso means that the `"Z"` in the first replacement in the last example
    is not replaced by `"WWW"`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Multiple replacements in the string* replace() *function first appeared in
    Julia v1.7\. If you are using an earlier version, you can use the* replace() *function
    as described here, but with only one replacement.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `occursin()` function tests for the presence of a substring in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This tests for the existence, in the second argument, of the string given in
    the first argument, and it’s case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: The `occursin()` function follows the tradition of other functions, such as
    `iseven()`, that test a condition and return `true` or `false` (see “The filter()
    Operator” on [page 163](ch06.xhtml#ch06sec1sec4)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findfirst()` and `findlast()` functions each search for the location of
    a character or string in another string. If we ask for the location of a character,
    the functions return the index of its first or last occurence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If, instead of a character, we supply a string in the first argument, the functions
    return a range giving the location of the string in the second string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These functions return `nothing` if the character or string we’re searching
    for does not exist in the second string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findnext()` function behaves similarly, but it accepts a third argument
    giving the location to begin the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates a third optional positional argument for `join()`, which is
    inserted in place of the delimiter (given in the second argument) between the
    final two elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this program, it prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If `findnext()` or the other string search functions don’t find what they’re
    looking for, they return nothing, or, more specifically, a particular value called
    `nothing`. We take advantage of this in the `while` condition ➊ to end the loop
    when there are no further `e` characters to be found.
  prefs: []
  type: TYPE_NORMAL
- en: All of the searching and replacing functions described in this section work
    with regular expressions as well. Julia uses Perl-compatible regular expressions;
    consult “Further Reading” on [page 151](ch05.xhtml#fur5) for a link to the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: To define a regular expression, we use a nonstandard string literal with the
    `r` keyword. For example, `r"A.*B"` is a regular expression matching `A` followed
    by any number of characters ending with `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple use of a regular expression to delete everything between a
    particular pair of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Parenthesized fragments in the regular expression become targets that we can
    refer to, in the replacement text, using escaped integers. These integers follow
    the order of the parenthesized fragments, so the first one is referenced by `\1`,
    and so on. In a normal string such escaped integers are interpreted as control
    characters; therefore, Julia has another nonstandard string literal for this purpose,
    using the `s` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This replacement moves the delimited string to the end, preceded by some punctuation,
    instead of deleting the string between the angle brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '**String Interpolation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Julia happily borrows good ideas from other languages. Perl not only has powerful
    regular expressions, it also has a convenient syntax for *string interpolation*,
    which you can use in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use string interpolation when we want to insert the values of variables
    or expressions into a string. The interpolation syntax tells Julia to create the
    string representations of these values and place them within a larger string.
    Interpolation lets us avoid messy sequences of string concatenations in favor
    of neater code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates the two kinds of string interpolation, both in the
    argument to the `println()` call ➋. After the name entered by the user is stored
    in the variable `name` ➊, we can access its value using string interpolation.
    To interpolate the value of the variable, just use its name after a dollar sign
    (`$`). To interpolate another type of expression, put it inside parentheses after
    the `$`. We did this in order to interpolate the length of the user’s name ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can interpolate any expression into a string. If we want to exclude spaces
    (because they are not letters) from the length of the name, we could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need an actual dollar sign, escape it with a backslash: `\$`. Naturally,
    `raw` strings do not partake of the interpolation process.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Collection Types**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section describes additional types of collections that are all part of
    routine Julia programming: dictionaries, sets, structs, and named tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Dictionaries***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia’s `Dict` type is similar to dictionaries in Python or associative arrays
    in Bash. It’s a one-dimensional collection like a vector that’s indexed by *key*
    rather than position. [Listing 5-1](ch05.xhtml#ch5lis1) shows one of two ways
    to initialize a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-1: Creating a dictionary from key-value pairs*'
  prefs: []
  type: TYPE_NORMAL
- en: After this initialization, the new dictionary contains two key-value pairs.
    Each key in this dictionary happens to be the name of the number that it indexes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to supplying the key-value pairs as separate arguments, we can supply
    any iterable object that yields key-value pairs when iterated over. We can initialize
    the dictionary from [Listing 5-1](ch05.xhtml#ch5lis1), for example, with `Dict(["one"=>1;`
    `"two"=>2])`.
  prefs: []
  type: TYPE_NORMAL
- en: The keys and values in a dictionary can be of any type. In `bd` both of the
    keys are strings, and the values they point to are integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for indexing dictionaries is the same as for indexing vectors, but
    the indices are the keys, not the positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We initialize the `bd` dictionary with two key-value pairs; as 2 is not one
    of the keys, our attempt to index it with 2 produces an error.
  prefs: []
  type: TYPE_NORMAL
- en: The `keys(bd)` function returns a list of the keys in `bd`; a corresponding
    `values()` function returns a list of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in a `Dict` must be unique. If we define an entry with a key that
    already exists, the later definition replaces the existing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the first line we reuse the `"one"` key. Displaying the dictionary shows
    that the new value has replaced the earlier one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to initialize dictionaries is to pass a single argument to `Dict()`.
    The argument can be any iterable that yields tuples; each tuple generates a key-value
    pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the dictionary is printed in what appears to be a random order.
    This is normal, as dictionaries are *unordered* collections, unlike vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia’s `Set` data type implements many of the properties of mathematical sets.
    A set in Julia is a collection defined by what elements are contained within it.
    The elements have no order, and the set can’t be indexed. If you add an element
    that’s already there, the set doesn’t change because it already contains the element,
    which can appear only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define two simple sets that we’ll use to illustrate some of the operations
    we can perform on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `Set()` function, which takes any iterable object, initializes sets. The
    sets’ members are listed in the REPL in an arbitrary order, as order is meaningless
    within a set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask for the intersection and union of the two sets we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The results in both examples are also sets. The intersection is the set of elements
    common to both sets, while the union is the set of elements existing in either
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test for a subset relationship between sets with the `issubset()` function,
    which has a Unicode synonym that we also can use as a binary operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To create the subset or superset ➊ characters, we enter \subseteq or \supseteq,
    respectively, followed by TAB. The functions converted the range `4:7` into a
    set automatically and told us that `Set(4:7)` is a subset of `s2`, because every
    member of the former is a member of the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find the *difference* between two sets, which are the elements of one
    set that are not in another set, using the `setdiff()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The result shows us what remains after removing 3, 4, and 5 from `s1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mutating form of this function removes the members of the second set from
    the first. To add new elements to a set, use `push!()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, first we enlarge `s1` with the member 999, and then we remove
    the elements in `Set(1:3)`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Structs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `struct` is a collection of named values packaged together under one identifier.
    For an example, [Listing 5-2](ch05.xhtml#ch5lis2) creates a struct to hold two
    pieces of information identifying a web page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-2: Defining a struct*'
  prefs: []
  type: TYPE_NORMAL
- en: First we define a new struct called `Website`, and then we create a variable,
    `google`, that holds a particular instance of `Website` with specific values for
    `url` and `title`.
  prefs: []
  type: TYPE_NORMAL
- en: Conventional style is to capitalize the names of structs. A struct’s name is
    used as a *constructor* that creates *composite objects* with the struct’s type.
    Therefore, making a struct extends Julia by adding a new type to the language.
    Asking Julia for the type of `google` with `typeof(google)` returns `Website`.
    See “User-Defined Types” on [page 234](ch08.xhtml#ch08lev3) for more about the
    utility and power of user-defined types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reference the fields of composite objects such as structs and the named
    tuples (described next) using *property notation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After noticing that we forgot to capitalize the title of the website, we try
    to correct it, but Julia doesn’t allow the change because, by default, structs
    are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix our error by defining `google` anew, but if we plan to mutate `Website`
    objects routinely, we can define them as *mutable structs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now we can change the values of `google`’s fields whenever we want.
  prefs: []
  type: TYPE_NORMAL
- en: '***Named Tuples***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A named tuple is just like Julia’s ordinary `Tuple`, except we can give names
    to its values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a new named tuple called `nt`, with three fields called `a`, `b`,
    and `c`. As this example shows, we extract values from a named tuple using property
    notation, just as with structs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Named tuples are immutable, just as (immutable) structs and ordinary tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The attempt to assign to a field of an immutable data type is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and named tuples are intimately related to function argument lists, as
    we’ll explore in “Functions and Their Arguments” on [page 154](ch06.xhtml#ch06lev1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing Arrays with Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Julia provides a handful of functions to initialize arrays. Using one of these
    is often more convenient and concise than the literal array definitions that we’ve
    been using up to now.
  prefs: []
  type: TYPE_NORMAL
- en: '***The repeat() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `repeat()` function repeats an array a given number of times along each
    dimension corresponding to the arguments you supply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the elements of the one-row array `[`'a' 'b' '|'] are replicated
    four times in the first (column) direction and three times in the second (row)
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already met `repeat()`, as a function that replicates a string, in “More
    Ways to Join Strings” on [page 128](ch05.xhtml#ch05lev3).
  prefs: []
  type: TYPE_NORMAL
- en: '***The fill() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `fill()` function takes the value supplied in its first argument and creates
    an array with a shape given by its subsequent arguments, filling it with the value.
    [Listing 5-3](ch05.xhtml#ch5lis3) shows how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-3: Filling an array*'
  prefs: []
  type: TYPE_NORMAL
- en: Here the value `['X' 'Y']` is used to fill a 3×4 array. Unlike `repeat()`, `fill()`
    can accept the dimensions as a tuple as well as separate arguments, so we can
    write the above as `fill(['X' 'Y'], (3, 4))`.
  prefs: []
  type: TYPE_NORMAL
- en: The most important difference beteen `repeat()` and `fill()` is that the former
    concatenates the elements of the array supplied in the first argument into the
    requested shape, whereas the latter concatenates the array itself. This can be
    seen in the results of the two examples just shown.
  prefs: []
  type: TYPE_NORMAL
- en: '***Mutability with the fill() and repeat() Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s try to change one of the elements of the matrix `XY` defined in [Listing
    5-3](ch05.xhtml#ch5lis3). We’ll try to change the `''X''` to an `''O''` in the
    top-right element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The result is surprising to many who encounter it for the first time. In altering
    one of the elements of `XY`, we’ve altered them all. This happens because `fill()`
    doesn’t *copy* its first argument into multiple locations in the result. Each
    element of `XY` is the identical one-row matrix; the output here shows the result
    of mutating this matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, instead of mutating the element, we *replace* it, something different happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now `XY` contains two different matrices, one of them appearing 11 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would observe exactly the same behavior using `repeat()` if we placed the
    first argument within an extra set of square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this way, after `repeat()` extracts the contents of the first argument and
    concatenates them, we still have an array of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an array of *different* arrays, rather than the array of references
    to a single array that `fill()` constructs, we can use a comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now altering one of the arrays has no effect on the other elements of `xy` because
    each element is a separate array.
  prefs: []
  type: TYPE_NORMAL
- en: '***The zeros() and ones() Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `zeros()` and `ones()` functions act as special cases of `fill()` with
    0.0 or 1.0 as a first argument. Like `fill()`, they accept either tuples or separate
    numbers for dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `zeros()` function creates a 4×5 matrix and fills it with 0.0.
  prefs: []
  type: TYPE_NORMAL
- en: Using `zeros()` or `ones()` is common when we need to initialize an array of
    floating-point numbers that’s going to be populated by direct indexing. This method
    is faster than using `push!()` to enlarge the array as it’s populated because
    the compiler knows the size of the array at the start, so reallocating memory
    isn’t needed. However, `push!()` may be a better choice if you don’t know the
    size of the array ahead of time and prefer not to allocate memory that the array
    won’t need.
  prefs: []
  type: TYPE_NORMAL
- en: '***The reshape() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can transform an array into a new shape with `reshape()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two examples show how to use `reshape()`: give the array as a first
    argument and its new dimensions either in a tuple or as a series of individual
    arguments. The last example produces an error because `reshape()` will not change
    the total number of elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reshape()` function does not create a new array, but returns the original
    array molded into a different shape. You can see the consequence of that when
    mutating either incarnation of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Changing the fifth element of `a1` also changes the fifth element of `a2`, where,
    as always, the elements are in column-major order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of `reshape()` should call to mind the remarks in “Scalar Indexing”
    on [page 38](ch02.xhtml#ch02sec1sec9): arrays are stored contiguously in the computer’s
    one-dimensional memory, which is reflected in their scalar indexing. The multidimensional
    forms of arrays that we use in our programs are abstractions, without which algorithms
    would be far more cumbersome to express in code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Array Manipulations Useful in Numerical Algorithms**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays are the most important data type, aside from numbers, in scientific and
    numerical computing. Our algorithms often take the form of a series of transformations
    and operations upon vectors, matrices, and higher-dimensional arrays. Julia’s
    powerful array handling helps us to express these computations in terms of high-level
    operations on entire arrays, rather than verbose loops over their elements. This
    style of programming, when we can use it, is conceptually clearer and less prone
    to error. This section surveys several array operations that arise repeatedly
    in scientific code.
  prefs: []
  type: TYPE_NORMAL
- en: '***General Concatenation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve discussed the semicolon as a concatenation operator along the first dimension,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As an alternative, we can replace the single semicolon with a newline, making
    the input resemble the way Julia prints the matrix in the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The use of repeated semicolons described in this section arrived with Julia
    v1.7\. In earlier versions, repeated semicolons were treated as a single semicolon.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A series of *n* semicolons concatenates along the *n*th dimension, adding new
    dimensions as needed, so two semicolons concatenate along the second dimension,
    which is also how a space concatenates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Both examples perform the same operation: `[1 2]` is concatenated with `[3
    4]` along the second, or column, dimension, increasing the number of columns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using three semicolons creates a new third dimension and joins along it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `[3 4]` array is put “on top” of the `[1 2]` array, in
    what is sometimes called a new *plane*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Logical Indexing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia can store an array of Boolean values in a space-efficient manner with
    its `BitArray` data type. In a `BitArray`, or the subtypes `BitVector` and `BitMatrix`,
    `true` and `false` are represented by 1 and 0\. These logical arrays are used
    for indexing, where they act as filters, selecting elements corresponding in position
    to the 1 values and rejecting the ones corresponding to the 0 values. When used
    for indexing, the array being indexed and the `BitArray` must have the same number
    of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a `BitArray` with a logical condition broadcast into an array. For
    example, the following creates a `BitArray` that picks out which elements of `1:9`
    are divisible by 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In order to return the result, Julia instantiates the range expression into
    an array. Each location that gives a zero remainder when divided by 3 is indicated
    by a `1`, and the others by a `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We assigned the `BitArray` to a variable so we can use it in other expressions.
    We can use it on the `1:9` range itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The 1s in `s3` pick out the elements in `1:9` that are divisible by 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use it to select every third element from any collection with nine
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Although the collection we’re indexing and the `BitArray` must have the same
    number of elements, the collection can have any shape if the `BitArray` is a `BitVector`;
    otherwise, the array and the `BitArray` must have the same shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using `BitArray` indexing, also called logical indexing,
    as a concise way to print out all the integers in [1, 100] that are divisible
    by 17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is that we create the bit index and use it in an indexing
    expression in one step, rather than storing it in a variable for later use.
  prefs: []
  type: TYPE_NORMAL
- en: '***Adjoints and Transposes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The transpose of a matrix is the matrix formed by flipping it across its diagonal,
    so that ![Image](../images/math144.jpg) when *M^'* is the transpose of *M*. The
    adjoint of a matrix is formed by taking its transpose and replacing each of its
    elements by its complex conjugate (the terminology is consistent with the concept
    of the adjoint of a linear operator, if matrices are regarded as linear transformations
    applied to vectors through conventional matrix multiplication).
  prefs: []
  type: TYPE_NORMAL
- en: 'To flip a matrix `MR` containing real numbers across its diagonal, we can use
    three notations: `MR'', adjoint(MR)`, or `permutedims(MR)`. [Listing 5-4](ch05.xhtml#ch5lis4)
    shows that they all give the same results.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-4: Matrix adjoint notations*'
  prefs: []
  type: TYPE_NORMAL
- en: Since the elements of `MR` are their own complex conjugates, its adjoint is
    just its transpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the matrix’s elements are almost anything else, `adjoint()` and
    `permutedims()` generally give different results; the `''` operator is a synonym
    for `adjoint()`. The `permutedims()` function flips the matrix around the diagonal
    and does nothing else, as shown here, and `adjoint()` does the same flip, called
    a *transpose*, but also takes the complex conjugate of each element. This operation
    is also known as the *Hermitian adjoint*. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The matrix is flipped, as before, but now with each element replaced by its
    complex conjugate. Note that we can’t use the `adjoint()` function on non-numerical
    matrices, where the complex conjugate of the elements has no meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `adjoint()` and `permutedims()`, we have the `transpose()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The result looks like the simple transposition of `M`, with no complex conjugates
    taken, but this is what `permutedims()` is supposed to do. Why do we have two
    functions that seem to do the same thing?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `adjoint()` and `transpose()` functions, on the one hand, and `permutedims()`,
    on the other, behave quite differently. The first two functions mentioned act
    recursively: if the elements of `M` are themselves matrices, `adjoint()` and `transpose()`
    will first act on `M`, then on the elements of `M`, and so on, all the way down.
    In contrast, `permutedims()` just flips `M` and stops.'
  prefs: []
  type: TYPE_NORMAL
- en: The second difference is that, like `reshape()`, `adjoint()` and `transpose()`
    return the same array in a different form, so mutating the result mutates the
    original, unlike `permutedims()`, which returns a new array.
  prefs: []
  type: TYPE_NORMAL
- en: In general, to flip around tables of numbers, we turn to the `permutedims()`
    function. The other two functions are intended for more specialized linear algebra
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `conj()` function, which takes the complete conjugate of a number, can
    of course be broadcast to work on each element of an array by using the dot operator.
    However, unlike most other math functions, it acts elementwise on arrays without
    broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve taken the complex conjugate of each element to transform the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '***Matrix Multiplication***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The multiplication operator (`*`) performs matrix multiplication when supplied
    with a pair of matrices or a matrix and a vector. As an example, we’ll make a
    rotation matrix and matrix-multiply to rotate a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The exact result should be `[0, 1]`: the rotation of a unit vector pointing
    “to the right” when rotated π/2 radians counterclockwise. The answer we get is
    the result of roundoff in floating-point arithmetic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For serious work with matrices, systems of linear equations, and related fields,
    you should import the `LinearAlgebra` package, which we’ll visit in “The LinearAlgebra
    Package” on [page 399](ch12.xhtml#ch12lev1sec5). That package has a function for
    calculating the *inverse* of a matrix, but we can calculate matrix inverses without
    importing the package with an intuitive notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this example we use the matrix `MR` defined in [Listing 5-4](ch05.xhtml#ch5lis4).
    The result of multiplying a matrix by its inverse (with matrix multiplication)
    should be the identity matrix (1s along the diagonal and 0s elsewhere), which,
    within floating-point roundoff, is what we get.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enumeration and Zipping**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Julia comes with several functions, common in modern high-level languages, for
    enumerating and zipping arrays. The former refers to the association of indices
    with the elements of a collection, while the latter refers to the joining, element
    by element, of two collections. All the functions in this section return iterators,
    either over a collection of tuples or over a collection of key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '***The enumerate() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `enumerate()` function takes a collection and returns an iterator into a
    collection of tuples that contains the number of the iteration as their first
    elements and the member of the collection retrieved as their second elements.
    [Listing 5-5](ch05.xhtml#ch5lis5) shows that the collection of tuples has the
    same shape as the original collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-5: Using enumerate()*'
  prefs: []
  type: TYPE_NORMAL
- en: Since `enumerate()` returns an iterator, we need to `collect()` it to see it.
    These iterators, like ranges and other iterators, such as the ones created by
    generators (see “Comprehensions and Generators” on [page 125](ch05.xhtml#ch05lev2)),
    take up almost no space until we use them to loop over a collection or turn them
    into an actual array with the `collect()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The array that `collect()` returns in [Listing 5-5](ch05.xhtml#ch5lis5) is laid
    out as specified in the argument to `enumerate()`, and the iteration numbers,
    the first elements of the tuples, reflect the column-major order in which the
    array was traversed.
  prefs: []
  type: TYPE_NORMAL
- en: The iteration numbers that `enumerate()` returns aren’t guaranteed to be legal
    indices of the array. Even when they are, they don’t necessarily return the element
    that they index. In other words, if one of the tuples `enumerate(A)` returns is
    `(i, e)`, `A[i]` may be an error. If it’s not an error, it may be the case that
    `A[i]` does not equal `e`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a numerical array, such as in [Listing 5-5](ch05.xhtml#ch5lis5),
    the first elements of the tuples *can* be used as scalar indices into the array,
    and `enumerate()` is sometimes used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of where the iteration number *cannot* be used as an index involves
    our old friend François:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The iteration number tells us where each character appears in the string, but,
    as we saw in “Strings and Characters” on [page 44](ch02.xhtml#ch02lev4), not all
    of these character positions are legal indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In summary, don’t confuse iteration numbers with indexing.
  prefs: []
  type: TYPE_NORMAL
- en: '***The pairs() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `pairs()` function is similar to `enumerate()`, except it creates an iterator
    over key-value pairs rather than over tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The indices returned by `pairs()` are legal indices into the collection rather
    than iteration numbers as with `enumerate()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The objects in the iterator returned by `enumerate()` are tuples; those in
    the iterator returned by `pairs()` are key-value pairs. Such pairs have their
    own data type: `Pair`. If `p` is a `Pair`, we can access its key with `p.first`
    and its value with `p.second`. Therefore, if we need a vector of indices into
    the name of our French friend, we can get it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We can create a `Pair` with a constructor like `Pair(9, 's')`, or by using the
    `=>` operator—for example, `9 => 's'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 5-1](ch05.xhtml#ch5lis1), we created a dictionary from a series
    of key-value pairs entered directly. Each of those literal key-value pairs is
    a `Pair`; here’s another way to construct the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We make the pair `p1` using the `=>` operator and `p2` using the `Pair()` constructor.
    Passing them to the `Dict()` function creates the same dictionary as in [Listing
    5-1](ch05.xhtml#ch5lis1).
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary is an unordered collection of `Pair`s. Iterating through a dictionary
    produces each `Pair` in turn, but in an unpredictable order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '***The zip() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `zip()` function takes any number of collections and returns an iterator
    into a collection of tuples that combines the elements of the collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the collections passed in have the same shape, the returned iterator will
    have that shape as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The first elements of each collection are paired together, followed by the second,
    and so on. In this use of `zip()`, the shapes of the arguments must match.
  prefs: []
  type: TYPE_NORMAL
- en: 'If one of the collections is a list, the other can have any shape. The elements
    of the list are paired with the elements of the other collection in column-major
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Here a one-dimensional list is zipped with a 2×2 matrix; each has four elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a vector, the numbers of elements need not match; `zip()` will continue
    until it runs out of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the three-element vector is exhausted before we run out
    of elements in the 2×2 matrix. In the second example, the second argument is exhausted
    before we use up all the elements in `1:5`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Julia is a somewhat “big” language: it has a lot of syntax and a large stable
    of data types. These features have a purpose, and they contribute to Julia’s power
    and convenience. Fortunately, you don’t have to use everything in the language
    in every program. In this chapter, we’ve encountered some new syntax that makes
    working with collections more concise and intuitive. In the next chapter, we’ll
    explore some new concepts that afford the Julia programmer higher levels of flexibility
    and control.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: The specification for semantic versioning is available at [*https://semver.org*](https://semver.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on Perl-compatible regular expressions, visit [*http://www.pcre.org*](http://www.pcre.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
