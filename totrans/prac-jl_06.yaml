- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: COLLECTIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*I don’t want to belong to any club that would accept me as one of its members.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: —Attributed to Groucho Marx
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: A *collection* is a data structure that functions as a container. The values
    that it holds are its *elements*. Julia’s collections are distinguished from each
    other by what they can contain, whether or not they are mutable, how their elements
    are accessed, whether their contents are ordered, and several other characteristics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already worked with arrays, strings, and other kinds of Julia containers.
    In this chapter, we’ll learn more about those collections and meet some new ones.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlling Loop Execution**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is an intimate relationship between loops and collections in Julia. The
    `for` loop, for example, depends on a collection or an iterable object whose elements
    are visited in turn.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: We already know how to write loops using `while` and `for` blocks. In this section,
    we’ll explore how to further control loop execution with the `break` and `continue`
    statements, and how to write compact loops with *comprehensions*, a concise way
    to create collections.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '***The break Statement***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes we need to end a loop based on some condition and prevent it from
    reaching its “normal” termination. This is the purpose of the `break` command,
    which terminates both `while` and `for` loops.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following loop repeatedly asks the user for a number and prints
    its square root:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `while` condition is `true`, which never changes, so the loop would run
    forever were it not for the `break` statement ➊, which terminates the loop if
    the user enters `0` (or a negative number). This is a common pattern when intending
    a loop to run forever until halted by a condition arising with the loop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The `readline()` statement reads a line of input from the terminal, terminated
    when the user presses ENTER, and puts the result into a string variable. We need
    to interpret this string as a number, which is what the `parse()` function does
    for us. The first argument to `parse()` specifies what data type to convert the
    string to. The multi-argument version of the `println()` function concatenates
    its arguments, converting numbers to strings as needed ➋.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The `break` statement also terminates `for` loops. In the following example,
    we loop through the numbers in a vector and stop if we get to one that’s a perfect
    square:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When this is run, it prints this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A number is a perfect square if its square root is an integer. The code tests
    for that by comparing the number’s square root with the same quantity rounded
    by the `round()` function. Since `round()` rounds a number to the nearest integer,
    the two will have the same value if the number is already an integer. The `break`
    statement terminates the loop when the first perfect square is found, so we never
    hear about 16.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '***The continue Statement***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `continue` statement skips further processing in the current loop iteration
    and proceeds to the next one. This program prints out the first 100 prime numbers
    (we’ll skip the output):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The program tests the first 100 integers by checking for integer divisors up
    to the square root of the integer. If *x* is a divisor of *n*, there is no remainder
    when we calculate *n*/*x*; this is what `n % x == 0` checks for ➊. If we find
    a divisor, `n` is not prime, so we set a flag indicating that and `break` out
    of the `while` loop over `x`. In the outer `for` loop, we want to `continue` ➋
    to the next `n` if the current one is not prime, but print it if it is.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Comprehensions and Generators**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We often can write `for` loops that create arrays more concisely as *array
    comprehensions*. As a simple example, suppose we wanted a `Vector` containing
    the first five perfect squares. We can construct this with a `for` loop, as in
    the following REPL session listing, but first we have to initialize an empty `Vector`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can accomplish the same thing with an array comprehension:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We don’t need to initialize the `xs` vector, as the comprehension creates and
    populates it in one step. The types of the results in these examples are different,
    a subject that we’ll examine in [Chapter 8](ch08.xhtml).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Array comprehensions typically contain two main parts, separated by the keyword
    `for`. The first part is an expression involving a dummy variable, in this case
    `x`. The second part, beginning with `for`, has the same form as the first line
    of the familiar `for` loop and uses the dummy variable from the first part. The
    first part becomes the body of the implied loop, adding a new element to the resulting
    array at each iteration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The array that the comprehension creates will have the same shape as the container
    in its second part. Consider the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, since the container iterates over a 2×2 matrix, that is the shape of the
    result as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'An array comprehension can contain any number of implied loops. The shape of
    the result depends on whether the loops are separated by `for` or by a comma.
    The following examples illustrate the two possibilities:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first case, the result is a `Vector`, as we might expect from two nested
    `for` loops. The second case, using a comma to separate the implied loops, produces
    a `Matrix`. We can add more comma-separated loop clauses to extend this to any
    number of dimensions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example that determines which even numbers in the multiplication
    table are divisible by 7:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An `if` statement at the end of a comprehension filters the results; the final
    result of the comprehension is a `Vector`. This example depends on the order of
    operations to avoid unnecessary parentheses: multiplication comes before (binds
    more tightly) than the modulus operator `%`. We pass the result of the comprehension
    to the `unique()` function, which removes duplicate entries from a collection.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: A *generator expression* has the same form as an array comprehension, but without
    the enclosing square brackets. It creates an iterator, rather than a populated
    array. We can loop, or iterate, over this object to use its members one at a time,
    but it occupies almost no memory. In this way it should recall range expressions
    and their relationship to vectors.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, we sometimes need to enclose the generator expression in parentheses
    to avoid ambiguity, as with any other expression. This is the case in the following
    example, where we create a generator version of our multiplication table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We need the parentheses because of the double `for` loop. Julia will not recognize
    this as a generator expression without them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can extract, as before, the even numbers in the table that are divisible
    by 7:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the table were large, rather than merely 9×9, using a generator rather than
    populating an array would provide significant memory savings. We can always use
    `collect()` to produce the realized table from the iterator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**More Ways to Join Strings**'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A string in Julia is a collection. Its elements are characters. We first met
    the `String` type in “Strings and Characters” on [page 44](ch02.xhtml#ch02lev4),
    and here we’ll explore the most important operations you can perform on strings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen how we can join strings using the `*` operator or using `join()`
    to form a string from a vector of strings. We can also use the `string()` function,
    which joins any number of literal strings and string-valued variables into a larger
    `String`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since `comma_space` is a string, the `string()` function simply glues it to
    the other strings we supplied. If it were some other type of object, such as a
    number, the call would still work if the object had a string representation. In
    that case, the function first converts it to a string and then performs the join.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'The `repeat()` function joins a string to itself a specified number of times:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the new string is formed from “ABC” repeated five times, as
    specified in the second argument.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: We can also use this function to create arrays, as we’ll see in “The repeat()
    Function” on [page 139](ch05.xhtml#ch05lev1sec10).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**Nonstandard String Literals**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *string literal* is an expression such as `"abc"` that represents a `String`
    directly. Julia supports a variety of *nonstandard* string literals, represented
    by placing a keyword in front of the string literal with the prefix specifying
    what kind of special-purpose string the expression represents. Such objects carry
    a significance beyond their existence as strings.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already met an example of one of these objects. In “LaTeX Titles and Label
    Positioning by Data” on [page 103](ch04.xhtml#ch04lev1sec12), we described how
    to use LaTeX strings as graph labels. These are prefixed with an uppercase `L`,
    as in `L"e^{i`π`} + 1 = 0"`. When the graphing programs see an ordinary string
    used as a label, the string is printed on the graph verbatim, but if the label
    is a LaTeX string, the programs know to print its LaTeX-processed form. LaTeX
    strings are defined in the `LaTeXStrings` package. Some nonstandard string literals
    are defined in their own packages, which need to be imported before you can use
    them, while others are built in.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到过其中一个对象的例子。在《LaTeX 标题和标签定位》一书的 [第103页](ch04.xhtml#ch04lev1sec12) 中，我们描述了如何使用
    LaTeX 字符串作为图表标签。这些字符串以大写字母 `L` 为前缀，如 `L"e^{i`π`} + 1 = 0"`。当绘图程序看到普通字符串作为标签时，字符串会原样打印在图表上，但如果标签是
    LaTeX 字符串，程序会知道打印其经过 LaTeX 处理后的形式。LaTeX 字符串在 `LaTeXStrings` 包中定义。一些非标准字符串文字在它们自己的包中定义，使用前需要导入，而其他一些则是内建的。
- en: Under the hood, nonstandard string literals are implemented as macros (see “Macros”
    on [page 170](ch06.xhtml#ch06lev4)). The name of the macro is the tag of the string
    literal followed by `_str`. In other words, the name of the macro implementing
    LaTeX strings is `@L_str`. To see the documentation for a nonstandard string literal
    in the REPL, we enter either `?@L_str` or `?L""` (for LaTeX strings).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，非标准字符串文字是作为宏实现的（参见《宏》一节，在 [第170页](ch06.xhtml#ch06lev4)）。宏的名称是字符串文字的标签，后面跟着
    `_str`。换句话说，实现 LaTeX 字符串的宏名称是 `@L_str`。要在 REPL 中查看非标准字符串文字的文档，我们可以输入 `?@L_str`
    或 `?L""`（对于 LaTeX 字符串）。
- en: '***Raw Strings***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原始字符串***'
- en: 'One useful built-in nonstandard string literal is the *raw string*, written
    by prepending `raw`. Most keywords for nonstandard strings are single letters,
    but `raw` is an exception. Raw strings are used to represent certain character
    sequences literally, where in standard strings they would have an interpretation
    as control characters or something else. For example, ordinarily the sequence
    `\t` is converted into a TAB character when printing a string, but in a raw string
    it’s interpreted literally:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的内建非标准字符串文字是 *原始字符串*，通过在前面加上 `raw` 来表示。大多数非标准字符串的关键字是单个字母，但 `raw` 是一个例外。原始字符串用于按字面意思表示某些字符序列，在标准字符串中它们会被解释为控制字符或其他内容。例如，通常情况下，`\t`
    序列在打印字符串时会被转换为 TAB 字符，但在原始字符串中，它会按字面意思被解释：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the second print command, the non-escaped TAB character is rendered as a
    horizontal space.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个打印命令中，未转义的 TAB 字符被呈现为一个水平空格。
- en: 'Within raw strings, therefore, backslashes are interpreted literally, with
    one exception—they are still needed to escape double quotation marks:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在原始字符串中，反斜杠会按字面意思解释，唯一的例外是——它们仍然需要用来转义双引号：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If a backslash appears anywhere in a raw string aside from directly before a
    double quotation mark, it’s interpreted literally.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在原始字符串中出现反斜杠，除非它紧跟在双引号之前，否则它会被按字面意思解释。
- en: '***Semantic Version Strings***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***语义版本字符串***'
- en: Versions of software releases are identified with tags such as v1.7.1\. Different
    projects use different systems for version tags; one such system is called *semantic
    versioning*. The fields in the string refer to major and minor versions and, optionally,
    other versioning information. See “Further Reading” on [page 151](ch05.xhtml#fur5)
    for a link to the detailed specification.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 软件版本发布的版本通过类似 v1.7.1\. 的标签来标识。不同的项目使用不同的版本标签系统，其中一种系统被称为 *语义版本控制*。字符串中的字段表示主版本和次版本号，另外还可以包含其他版本信息。有关详细规范的链接，请参见《进一步阅读》一节，在
    [第151页](ch05.xhtml#fur5)。
- en: 'Prepend a `v` to create a semantic version string. We can compare versions
    and extract the numerical value of fields, which are returned as hexadecimal numbers,
    indicated by a leading `0x`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在语义版本字符串前加上 `v`。我们可以比较版本并提取字段的数值，这些数值以十六进制数形式返回，前面带有 `0x`：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Julia project itself uses an extended version of this scheme for numbering
    language and package releases, so semantic version strings are built into the
    language.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 项目本身使用这个方案的扩展版来编号语言和包的发布版本，因此语义版本字符串已内建于语言中。
- en: '***Byte Array Literals***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字节数组字面量***'
- en: 'Prepending a string with `b` creates a *byte array literal*: a sequence of
    unsigned, 8-bit integers representing the sequence of characters in the string
    in UTF-8 encoding. As described in “Strings and Characters” on [page 44](ch02.xhtml#ch02lev4),
    characters can take up one to four bytes. Here’s an example of turning a three-character
    string into a byte array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The characters `a` and `2` are each represented by a single byte, but the character
    `∑` occupies two bytes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enter the uppercase sigma as a character in the REPL to learn more about
    it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The response informs us that `03A3` is the Unicode *code point* for the character.
    The code point is a single, possibly large, hexadecimal integer that uniquely
    identifies the Unicode character.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '*A Unicode character may not correspond to a single character when printed.
    Some of them combine with one or more neighboring characters to create accents
    or ligatures.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use code points directly in strings with the escape code `\u`, where
    they’ll be converted into the characters they represent:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To avoid the conversion, we can escape the backslash or use a raw string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '**String Searching and Replacing**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `replace()` function replaces a substring with a different one. It can
    take any number of replacements, which are applied left to right, with the proviso
    that no character undergoes more than one substitution. The following example
    demonstrates the syntax as well as the consequence of the proviso:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The proviso means that the `"Z"` in the first replacement in the last example
    is not replaced by `"WWW"`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '*Multiple replacements in the string* replace() *function first appeared in
    Julia v1.7\. If you are using an earlier version, you can use the* replace() *function
    as described here, but with only one replacement.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The `occursin()` function tests for the presence of a substring in a string:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This tests for the existence, in the second argument, of the string given in
    the first argument, and it’s case-sensitive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The `occursin()` function follows the tradition of other functions, such as
    `iseven()`, that test a condition and return `true` or `false` (see “The filter()
    Operator” on [page 163](ch06.xhtml#ch06sec1sec4)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findfirst()` and `findlast()` functions each search for the location of
    a character or string in another string. If we ask for the location of a character,
    the functions return the index of its first or last occurence:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If, instead of a character, we supply a string in the first argument, the functions
    return a range giving the location of the string in the second string:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These functions return `nothing` if the character or string we’re searching
    for does not exist in the second string.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findnext()` function behaves similarly, but it accepts a third argument
    giving the location to begin the search:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This demonstrates a third optional positional argument for `join()`, which is
    inserted in place of the delimiter (given in the second argument) between the
    final two elements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this program, it prints:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If `findnext()` or the other string search functions don’t find what they’re
    looking for, they return nothing, or, more specifically, a particular value called
    `nothing`. We take advantage of this in the `while` condition ➊ to end the loop
    when there are no further `e` characters to be found.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: All of the searching and replacing functions described in this section work
    with regular expressions as well. Julia uses Perl-compatible regular expressions;
    consult “Further Reading” on [page 151](ch05.xhtml#fur5) for a link to the syntax.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: To define a regular expression, we use a nonstandard string literal with the
    `r` keyword. For example, `r"A.*B"` is a regular expression matching `A` followed
    by any number of characters ending with `B`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple use of a regular expression to delete everything between a
    particular pair of characters:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Parenthesized fragments in the regular expression become targets that we can
    refer to, in the replacement text, using escaped integers. These integers follow
    the order of the parenthesized fragments, so the first one is referenced by `\1`,
    and so on. In a normal string such escaped integers are interpreted as control
    characters; therefore, Julia has another nonstandard string literal for this purpose,
    using the `s` keyword:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This replacement moves the delimited string to the end, preceded by some punctuation,
    instead of deleting the string between the angle brackets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '**String Interpolation**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Julia happily borrows good ideas from other languages. Perl not only has powerful
    regular expressions, it also has a convenient syntax for *string interpolation*,
    which you can use in Julia.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'We use string interpolation when we want to insert the values of variables
    or expressions into a string. The interpolation syntax tells Julia to create the
    string representations of these values and place them within a larger string.
    Interpolation lets us avoid messy sequences of string concatenations in favor
    of neater code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This example demonstrates the two kinds of string interpolation, both in the
    argument to the `println()` call ➋. After the name entered by the user is stored
    in the variable `name` ➊, we can access its value using string interpolation.
    To interpolate the value of the variable, just use its name after a dollar sign
    (`$`). To interpolate another type of expression, put it inside parentheses after
    the `$`. We did this in order to interpolate the length of the user’s name ➋.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'We can interpolate any expression into a string. If we want to exclude spaces
    (because they are not letters) from the length of the name, we could use the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you need an actual dollar sign, escape it with a backslash: `\$`. Naturally,
    `raw` strings do not partake of the interpolation process.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional Collection Types**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section describes additional types of collections that are all part of
    routine Julia programming: dictionaries, sets, structs, and named tuples.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '***Dictionaries***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia’s `Dict` type is similar to dictionaries in Python or associative arrays
    in Bash. It’s a one-dimensional collection like a vector that’s indexed by *key*
    rather than position. [Listing 5-1](ch05.xhtml#ch5lis1) shows one of two ways
    to initialize a dictionary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 5-1: Creating a dictionary from key-value pairs*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: After this initialization, the new dictionary contains two key-value pairs.
    Each key in this dictionary happens to be the name of the number that it indexes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In addition to supplying the key-value pairs as separate arguments, we can supply
    any iterable object that yields key-value pairs when iterated over. We can initialize
    the dictionary from [Listing 5-1](ch05.xhtml#ch5lis1), for example, with `Dict(["one"=>1;`
    `"two"=>2])`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The keys and values in a dictionary can be of any type. In `bd` both of the
    keys are strings, and the values they point to are integers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for indexing dictionaries is the same as for indexing vectors, but
    the indices are the keys, not the positions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We initialize the `bd` dictionary with two key-value pairs; as 2 is not one
    of the keys, our attempt to index it with 2 produces an error.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The `keys(bd)` function returns a list of the keys in `bd`; a corresponding
    `values()` function returns a list of values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in a `Dict` must be unique. If we define an entry with a key that
    already exists, the later definition replaces the existing one:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the first line we reuse the `"one"` key. Displaying the dictionary shows
    that the new value has replaced the earlier one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to initialize dictionaries is to pass a single argument to `Dict()`.
    The argument can be any iterable that yields tuples; each tuple generates a key-value
    pair:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that the dictionary is printed in what appears to be a random order.
    This is normal, as dictionaries are *unordered* collections, unlike vectors.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '***Sets***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia’s `Set` data type implements many of the properties of mathematical sets.
    A set in Julia is a collection defined by what elements are contained within it.
    The elements have no order, and the set can’t be indexed. If you add an element
    that’s already there, the set doesn’t change because it already contains the element,
    which can appear only once.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define two simple sets that we’ll use to illustrate some of the operations
    we can perform on them:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Set()` function, which takes any iterable object, initializes sets. The
    sets’ members are listed in the REPL in an arbitrary order, as order is meaningless
    within a set.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask for the intersection and union of the two sets we just created:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The results in both examples are also sets. The intersection is the set of elements
    common to both sets, while the union is the set of elements existing in either
    set.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test for a subset relationship between sets with the `issubset()` function,
    which has a Unicode synonym that we also can use as a binary operator:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To create the subset or superset ➊ characters, we enter \subseteq or \supseteq,
    respectively, followed by TAB. The functions converted the range `4:7` into a
    set automatically and told us that `Set(4:7)` is a subset of `s2`, because every
    member of the former is a member of the latter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find the *difference* between two sets, which are the elements of one
    set that are not in another set, using the `setdiff()` function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The result shows us what remains after removing 3, 4, and 5 from `s1`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The mutating form of this function removes the members of the second set from
    the first. To add new elements to a set, use `push!()`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, first we enlarge `s1` with the member 999, and then we remove
    the elements in `Set(1:3)`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '***Structs***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `struct` is a collection of named values packaged together under one identifier.
    For an example, [Listing 5-2](ch05.xhtml#ch5lis2) creates a struct to hold two
    pieces of information identifying a web page.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 5-2: Defining a struct*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: First we define a new struct called `Website`, and then we create a variable,
    `google`, that holds a particular instance of `Website` with specific values for
    `url` and `title`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Conventional style is to capitalize the names of structs. A struct’s name is
    used as a *constructor* that creates *composite objects* with the struct’s type.
    Therefore, making a struct extends Julia by adding a new type to the language.
    Asking Julia for the type of `google` with `typeof(google)` returns `Website`.
    See “User-Defined Types” on [page 234](ch08.xhtml#ch08lev3) for more about the
    utility and power of user-defined types.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reference the fields of composite objects such as structs and the named
    tuples (described next) using *property notation*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After noticing that we forgot to capitalize the title of the website, we try
    to correct it, but Julia doesn’t allow the change because, by default, structs
    are immutable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix our error by defining `google` anew, but if we plan to mutate `Website`
    objects routinely, we can define them as *mutable structs*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now we can change the values of `google`’s fields whenever we want.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '***Named Tuples***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A named tuple is just like Julia’s ordinary `Tuple`, except we can give names
    to its values:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we have a new named tuple called `nt`, with three fields called `a`, `b`,
    and `c`. As this example shows, we extract values from a named tuple using property
    notation, just as with structs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Named tuples are immutable, just as (immutable) structs and ordinary tuples:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The attempt to assign to a field of an immutable data type is not allowed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and named tuples are intimately related to function argument lists, as
    we’ll explore in “Functions and Their Arguments” on [page 154](ch06.xhtml#ch06lev1).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing Arrays with Functions**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Julia provides a handful of functions to initialize arrays. Using one of these
    is often more convenient and concise than the literal array definitions that we’ve
    been using up to now.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '***The repeat() Function***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `repeat()` function repeats an array a given number of times along each
    dimension corresponding to the arguments you supply:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, the elements of the one-row array `[`'a' 'b' '|'] are replicated
    four times in the first (column) direction and three times in the second (row)
    direction.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already met `repeat()`, as a function that replicates a string, in “More
    Ways to Join Strings” on [page 128](ch05.xhtml#ch05lev3).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '***The fill() Function***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `fill()` function takes the value supplied in its first argument and creates
    an array with a shape given by its subsequent arguments, filling it with the value.
    [Listing 5-3](ch05.xhtml#ch5lis3) shows how it works.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 5-3: Filling an array*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Here the value `['X' 'Y']` is used to fill a 3×4 array. Unlike `repeat()`, `fill()`
    can accept the dimensions as a tuple as well as separate arguments, so we can
    write the above as `fill(['X' 'Y'], (3, 4))`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The most important difference beteen `repeat()` and `fill()` is that the former
    concatenates the elements of the array supplied in the first argument into the
    requested shape, whereas the latter concatenates the array itself. This can be
    seen in the results of the two examples just shown.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '***Mutability with the fill() and repeat() Functions***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s try to change one of the elements of the matrix `XY` defined in [Listing
    5-3](ch05.xhtml#ch5lis3). We’ll try to change the `''X''` to an `''O''` in the
    top-right element:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The result is surprising to many who encounter it for the first time. In altering
    one of the elements of `XY`, we’ve altered them all. This happens because `fill()`
    doesn’t *copy* its first argument into multiple locations in the result. Each
    element of `XY` is the identical one-row matrix; the output here shows the result
    of mutating this matrix.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'If, instead of mutating the element, we *replace* it, something different happens:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now `XY` contains two different matrices, one of them appearing 11 times.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'We would observe exactly the same behavior using `repeat()` if we placed the
    first argument within an extra set of square brackets:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this way, after `repeat()` extracts the contents of the first argument and
    concatenates them, we still have an array of arrays.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an array of *different* arrays, rather than the array of references
    to a single array that `fill()` constructs, we can use a comprehension:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now altering one of the arrays has no effect on the other elements of `xy` because
    each element is a separate array.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '***The zeros() and ones() Functions***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `zeros()` and `ones()` functions act as special cases of `fill()` with
    0.0 or 1.0 as a first argument. Like `fill()`, they accept either tuples or separate
    numbers for dimensions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `zeros()` function creates a 4×5 matrix and fills it with 0.0.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Using `zeros()` or `ones()` is common when we need to initialize an array of
    floating-point numbers that’s going to be populated by direct indexing. This method
    is faster than using `push!()` to enlarge the array as it’s populated because
    the compiler knows the size of the array at the start, so reallocating memory
    isn’t needed. However, `push!()` may be a better choice if you don’t know the
    size of the array ahead of time and prefer not to allocate memory that the array
    won’t need.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '***The reshape() Function***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can transform an array into a new shape with `reshape()`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first two examples show how to use `reshape()`: give the array as a first
    argument and its new dimensions either in a tuple or as a series of individual
    arguments. The last example produces an error because `reshape()` will not change
    the total number of elements.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reshape()` function does not create a new array, but returns the original
    array molded into a different shape. You can see the consequence of that when
    mutating either incarnation of the array:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Changing the fifth element of `a1` also changes the fifth element of `a2`, where,
    as always, the elements are in column-major order.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of `reshape()` should call to mind the remarks in “Scalar Indexing”
    on [page 38](ch02.xhtml#ch02sec1sec9): arrays are stored contiguously in the computer’s
    one-dimensional memory, which is reflected in their scalar indexing. The multidimensional
    forms of arrays that we use in our programs are abstractions, without which algorithms
    would be far more cumbersome to express in code.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Array Manipulations Useful in Numerical Algorithms**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays are the most important data type, aside from numbers, in scientific and
    numerical computing. Our algorithms often take the form of a series of transformations
    and operations upon vectors, matrices, and higher-dimensional arrays. Julia’s
    powerful array handling helps us to express these computations in terms of high-level
    operations on entire arrays, rather than verbose loops over their elements. This
    style of programming, when we can use it, is conceptually clearer and less prone
    to error. This section surveys several array operations that arise repeatedly
    in scientific code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '***General Concatenation***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve discussed the semicolon as a concatenation operator along the first dimension,
    as in this example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As an alternative, we can replace the single semicolon with a newline, making
    the input resemble the way Julia prints the matrix in the REPL.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '*The use of repeated semicolons described in this section arrived with Julia
    v1.7\. In earlier versions, repeated semicolons were treated as a single semicolon.*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'A series of *n* semicolons concatenates along the *n*th dimension, adding new
    dimensions as needed, so two semicolons concatenate along the second dimension,
    which is also how a space concatenates:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Both examples perform the same operation: `[1 2]` is concatenated with `[3
    4]` along the second, or column, dimension, increasing the number of columns.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Using three semicolons creates a new third dimension and joins along it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this example, the `[3 4]` array is put “on top” of the `[1 2]` array, in
    what is sometimes called a new *plane*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '***Logical Indexing***'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia can store an array of Boolean values in a space-efficient manner with
    its `BitArray` data type. In a `BitArray`, or the subtypes `BitVector` and `BitMatrix`,
    `true` and `false` are represented by 1 and 0\. These logical arrays are used
    for indexing, where they act as filters, selecting elements corresponding in position
    to the 1 values and rejecting the ones corresponding to the 0 values. When used
    for indexing, the array being indexed and the `BitArray` must have the same number
    of elements.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a `BitArray` with a logical condition broadcast into an array. For
    example, the following creates a `BitArray` that picks out which elements of `1:9`
    are divisible by 3:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In order to return the result, Julia instantiates the range expression into
    an array. Each location that gives a zero remainder when divided by 3 is indicated
    by a `1`, and the others by a `0`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'We assigned the `BitArray` to a variable so we can use it in other expressions.
    We can use it on the `1:9` range itself:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The 1s in `s3` pick out the elements in `1:9` that are divisible by 3.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use it to select every third element from any collection with nine
    elements:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Although the collection we’re indexing and the `BitArray` must have the same
    number of elements, the collection can have any shape if the `BitArray` is a `BitVector`;
    otherwise, the array and the `BitArray` must have the same shape.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using `BitArray` indexing, also called logical indexing,
    as a concise way to print out all the integers in [1, 100] that are divisible
    by 17:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The only difference here is that we create the bit index and use it in an indexing
    expression in one step, rather than storing it in a variable for later use.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '***Adjoints and Transposes***'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The transpose of a matrix is the matrix formed by flipping it across its diagonal,
    so that ![Image](../images/math144.jpg) when *M^'* is the transpose of *M*. The
    adjoint of a matrix is formed by taking its transpose and replacing each of its
    elements by its complex conjugate (the terminology is consistent with the concept
    of the adjoint of a linear operator, if matrices are regarded as linear transformations
    applied to vectors through conventional matrix multiplication).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'To flip a matrix `MR` containing real numbers across its diagonal, we can use
    three notations: `MR'', adjoint(MR)`, or `permutedims(MR)`. [Listing 5-4](ch05.xhtml#ch5lis4)
    shows that they all give the same results.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Listing 5-4: Matrix adjoint notations*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Since the elements of `MR` are their own complex conjugates, its adjoint is
    just its transpose.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the matrix’s elements are almost anything else, `adjoint()` and
    `permutedims()` generally give different results; the `''` operator is a synonym
    for `adjoint()`. The `permutedims()` function flips the matrix around the diagonal
    and does nothing else, as shown here, and `adjoint()` does the same flip, called
    a *transpose*, but also takes the complex conjugate of each element. This operation
    is also known as the *Hermitian adjoint*. Consider this example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The matrix is flipped, as before, but now with each element replaced by its
    complex conjugate. Note that we can’t use the `adjoint()` function on non-numerical
    matrices, where the complex conjugate of the elements has no meaning.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `adjoint()` and `permutedims()`, we have the `transpose()` function:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The result looks like the simple transposition of `M`, with no complex conjugates
    taken, but this is what `permutedims()` is supposed to do. Why do we have two
    functions that seem to do the same thing?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'The `adjoint()` and `transpose()` functions, on the one hand, and `permutedims()`,
    on the other, behave quite differently. The first two functions mentioned act
    recursively: if the elements of `M` are themselves matrices, `adjoint()` and `transpose()`
    will first act on `M`, then on the elements of `M`, and so on, all the way down.
    In contrast, `permutedims()` just flips `M` and stops.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The second difference is that, like `reshape()`, `adjoint()` and `transpose()`
    return the same array in a different form, so mutating the result mutates the
    original, unlike `permutedims()`, which returns a new array.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In general, to flip around tables of numbers, we turn to the `permutedims()`
    function. The other two functions are intended for more specialized linear algebra
    applications.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The `conj()` function, which takes the complete conjugate of a number, can
    of course be broadcast to work on each element of an array by using the dot operator.
    However, unlike most other math functions, it acts elementwise on arrays without
    broadcasting:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here we’ve taken the complex conjugate of each element to transform the matrix.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '***Matrix Multiplication***'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The multiplication operator (`*`) performs matrix multiplication when supplied
    with a pair of matrices or a matrix and a vector. As an example, we’ll make a
    rotation matrix and matrix-multiply to rotate a vector:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The exact result should be `[0, 1]`: the rotation of a unit vector pointing
    “to the right” when rotated π/2 radians counterclockwise. The answer we get is
    the result of roundoff in floating-point arithmetic.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'For serious work with matrices, systems of linear equations, and related fields,
    you should import the `LinearAlgebra` package, which we’ll visit in “The LinearAlgebra
    Package” on [page 399](ch12.xhtml#ch12lev1sec5). That package has a function for
    calculating the *inverse* of a matrix, but we can calculate matrix inverses without
    importing the package with an intuitive notation:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example we use the matrix `MR` defined in [Listing 5-4](ch05.xhtml#ch5lis4).
    The result of multiplying a matrix by its inverse (with matrix multiplication)
    should be the identity matrix (1s along the diagonal and 0s elsewhere), which,
    within floating-point roundoff, is what we get.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**Enumeration and Zipping**'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Julia comes with several functions, common in modern high-level languages, for
    enumerating and zipping arrays. The former refers to the association of indices
    with the elements of a collection, while the latter refers to the joining, element
    by element, of two collections. All the functions in this section return iterators,
    either over a collection of tuples or over a collection of key-value pairs.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '***The enumerate() Function***'
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `enumerate()` function takes a collection and returns an iterator into a
    collection of tuples that contains the number of the iteration as their first
    elements and the member of the collection retrieved as their second elements.
    [Listing 5-5](ch05.xhtml#ch5lis5) shows that the collection of tuples has the
    same shape as the original collection.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '*Listing 5-5: Using enumerate()*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Since `enumerate()` returns an iterator, we need to `collect()` it to see it.
    These iterators, like ranges and other iterators, such as the ones created by
    generators (see “Comprehensions and Generators” on [page 125](ch05.xhtml#ch05lev2)),
    take up almost no space until we use them to loop over a collection or turn them
    into an actual array with the `collect()` function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The array that `collect()` returns in [Listing 5-5](ch05.xhtml#ch5lis5) is laid
    out as specified in the argument to `enumerate()`, and the iteration numbers,
    the first elements of the tuples, reflect the column-major order in which the
    array was traversed.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The iteration numbers that `enumerate()` returns aren’t guaranteed to be legal
    indices of the array. Even when they are, they don’t necessarily return the element
    that they index. In other words, if one of the tuples `enumerate(A)` returns is
    `(i, e)`, `A[i]` may be an error. If it’s not an error, it may be the case that
    `A[i]` does not equal `e`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a numerical array, such as in [Listing 5-5](ch05.xhtml#ch5lis5),
    the first elements of the tuples *can* be used as scalar indices into the array,
    and `enumerate()` is sometimes used for this purpose.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of where the iteration number *cannot* be used as an index involves
    our old friend François:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The iteration number tells us where each character appears in the string, but,
    as we saw in “Strings and Characters” on [page 44](ch02.xhtml#ch02lev4), not all
    of these character positions are legal indices:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In summary, don’t confuse iteration numbers with indexing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '***The pairs() Function***'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `pairs()` function is similar to `enumerate()`, except it creates an iterator
    over key-value pairs rather than over tuples:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The indices returned by `pairs()` are legal indices into the collection rather
    than iteration numbers as with `enumerate()`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The objects in the iterator returned by `enumerate()` are tuples; those in
    the iterator returned by `pairs()` are key-value pairs. Such pairs have their
    own data type: `Pair`. If `p` is a `Pair`, we can access its key with `p.first`
    and its value with `p.second`. Therefore, if we need a vector of indices into
    the name of our French friend, we can get it this way:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We can create a `Pair` with a constructor like `Pair(9, 's')`, or by using the
    `=>` operator—for example, `9 => 's'`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 5-1](ch05.xhtml#ch5lis1), we created a dictionary from a series
    of key-value pairs entered directly. Each of those literal key-value pairs is
    a `Pair`; here’s another way to construct the dictionary:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We make the pair `p1` using the `=>` operator and `p2` using the `Pair()` constructor.
    Passing them to the `Dict()` function creates the same dictionary as in [Listing
    5-1](ch05.xhtml#ch5lis1).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary is an unordered collection of `Pair`s. Iterating through a dictionary
    produces each `Pair` in turn, but in an unpredictable order:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***The zip() Function***'
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `zip()` function takes any number of collections and returns an iterator
    into a collection of tuples that combines the elements of the collections.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'When the collections passed in have the same shape, the returned iterator will
    have that shape as well:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first elements of each collection are paired together, followed by the second,
    and so on. In this use of `zip()`, the shapes of the arguments must match.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'If one of the collections is a list, the other can have any shape. The elements
    of the list are paired with the elements of the other collection in column-major
    order:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here a one-dimensional list is zipped with a 2×2 matrix; each has four elements.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a vector, the numbers of elements need not match; `zip()` will continue
    until it runs out of elements:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the first example, the three-element vector is exhausted before we run out
    of elements in the 2×2 matrix. In the second example, the second argument is exhausted
    before we use up all the elements in `1:5`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Julia is a somewhat “big” language: it has a lot of syntax and a large stable
    of data types. These features have a purpose, and they contribute to Julia’s power
    and convenience. Fortunately, you don’t have to use everything in the language
    in every program. In this chapter, we’ve encountered some new syntax that makes
    working with collections more concise and intuitive. In the next chapter, we’ll
    explore some new concepts that afford the Julia programmer higher levels of flexibility
    and control.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The specification for semantic versioning is available at [*https://semver.org*](https://semver.org).
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on Perl-compatible regular expressions, visit [*http://www.pcre.org*](http://www.pcre.org).
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
