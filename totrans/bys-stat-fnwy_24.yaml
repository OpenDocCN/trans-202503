- en: '**A'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**A'
- en: A QUICK INTRODUCTION TO R**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: R**快速介绍
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: In this book, we use the R programming language to do some tricky mathematical
    work for us. R is a programming language that specializes in statistics and data
    science. If you don’t have experience with R, or with programming in general,
    don’t worry—this appendix will get you started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用 R 编程语言来帮助我们完成一些复杂的数学工作。R 是一种专门用于统计学和数据科学的编程语言。如果你没有 R 的使用经验，或者没有编程经验，别担心——本附录将帮助你入门。
- en: '**R and RStudio**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**R 和 RStudio**'
- en: To run the code examples in this book, you’ll need to have R installed on your
    computer. To install R, visit *[https://cran.rstudio.com/](https://cran.rstudio.com/)*
    and follow the installation steps for the operating system you’re using.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本书中的代码示例，你需要在电脑上安装 R。安装 R，请访问 *[https://cran.rstudio.com/](https://cran.rstudio.com/)*
    并按照你使用的操作系统的安装步骤进行安装。
- en: Once you’ve installed R, you should also install *RStudio*, an integrated development
    environment (IDE) that makes it extremely easy to run R projects. Download and
    install RStudio from *[www.rstudio.com/products/rstudio/download/](http://www.rstudio.com/products/rstudio/download/)*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 R 后，你还应该安装 *RStudio*，它是一个集成开发环境（IDE），使得运行 R 项目变得极为简单。从 *[www.rstudio.com/products/rstudio/download/](http://www.rstudio.com/products/rstudio/download/)*
    下载并安装 RStudio。
- en: When you open RStudio, you should be greeted with several panels ([Figure A-1](app01.xhtml#app01fig01)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开 RStudio 时，你应该会看到几个面板（见[图 A-1](app01.xhtml#app01fig01)）。
- en: '![Image](../images/afig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/afig01.jpg)'
- en: '*Figure A-1: Viewing the console in RStudio*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-1：查看 RStudio 中的控制台*'
- en: The most important panel is the big one in the middle, called the *console*.
    In the console, you can enter any of the code examples from the book and run them
    simply by pressing ENTER. The console runs all the code you enter immediately,
    which makes it hard to keep track of the code you’ve written so far.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的面板是中间的大面板，叫做 *控制台*。在控制台中，你可以输入书中的任何代码示例，并通过按下 ENTER 键来运行它们。控制台会立即运行你输入的所有代码，这使得跟踪你到目前为止写过的代码变得困难。
- en: To write programs that you can save and come back to, you can place your code
    in an *R script*, which is a text file that you can load into the console later.
    R is an extremely interactive programming language, so rather than thinking of
    the console as a place you can test out code, think of R scripts as a way to quickly
    load tools you can use in the console.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写可以保存并稍后继续使用的程序，你可以将代码放入一个 *R 脚本* 中，R 脚本是一个文本文件，稍后你可以加载到控制台中。R 是一种极具交互性的编程语言，因此不要把控制台仅仅看作是你可以测试代码的地方，应该把
    R 脚本看作是一种可以快速加载到控制台中使用的工具。
- en: '**Creating an R Script**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建 R 脚本**'
- en: To create an R script, go to **File▸New File▸R Script** in RStudio. This should
    create a new blank panel in the top left ([Figure A-2](app01.xhtml#app01fig02)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 R 脚本，在 RStudio 中选择 **文件▸新建文件▸R 脚本**。这将会在左上方创建一个新的空白面板（见[图 A-2](app01.xhtml#app01fig02)）。
- en: '![Image](../images/afig02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/afig02.jpg)'
- en: '*Figure A-2: Creating an R script*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-2：创建 R 脚本*'
- en: In this panel, you can enter code and save it as a file. To run the code, simply
    click the **Source** button at the top right of the panel, or run individual lines
    by clicking the **Run** button. The Source button will automatically load your
    file into the console as though you had typed it there yourself.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个面板中，你可以输入代码并将其保存为文件。要运行代码，只需点击面板右上角的 **源代码** 按钮，或者点击 **运行** 按钮来运行单独的代码行。源代码按钮将自动把你的文件加载到控制台，就像你自己输入的那样。
- en: '**Basic Concepts in R**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**R 中的基本概念**'
- en: We’ll be using R as an advanced calculator in this book, which means you’ll
    only need to understand a few basics to work through the problems and extend the
    examples in the book on your own.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们将把 R 用作一个高级计算器，这意味着你只需要理解一些基础知识，就能自己解决问题并扩展书中的示例。
- en: '***Data Types***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据类型***'
- en: All programming languages have different types of data, which you can use for
    different purposes and manipulate in different ways. R has a rich variety of types
    and data structures, but we’ll only be using a very small number of them in this
    book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言都有不同类型的数据，你可以根据不同的用途使用这些数据并以不同的方式进行操作。R 有丰富的数据类型和数据结构，但本书中我们只会使用其中一小部分。
- en: '**Doubles**'
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**双精度**'
- en: The numbers we use in R will all be of the type *double* (short for “double-precision
    floating-point,” which is the most common way to represent decimal numbers on
    a computer). The double is the default type for representing decimal numbers.
    Unless otherwise specified, all numbers you enter into the console are of the
    double type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'We can manipulate numbers in the double type using standard mathematical operations.
    For example, we can add two numbers with the `+` operator. Try this out in the
    console:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also divide any numbers that give us decimal results using the `/` operator:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can multiply values with the `*` operator like so:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'and take the exponential of a value using the `^` operator. For example, 5²
    is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also add `-` in front of a number to make it negative:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And we can also use scientific notation with `e+`. So 5 × 10² is just:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we use `e-` we get the same result as 5 × 10^(–2):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is useful to know because sometimes R will return the result in scientific
    notation if it is too large to easily fit on the screen, like so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Strings**'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another important type in R is the *string*, which is just a group of characters
    used to represent text. In R, we surround a string with quotation marks, like
    this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that if you put a number inside a string, you can’t use that number in
    regular numeric operations because strings and numbers are different types. For
    example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We won’t be making much use of strings in this book. We’ll primarily use them
    to pass arguments to functions and to give labels to plots. But it’s important
    to remember them if you’re using text.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Logicals**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Logical* or *binary* types are true or false values represented by the codes
    `TRUE` and `FALSE`. Note that `TRUE` and `FALSE` aren’t strings—they’re not surrounded
    by quotes, and they’re written in all uppercase. (R also allows you to simply
    use `T` or `F` instead of writing out the full words.)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine logical types with the symbols `&` (“and”) and `|` (“or”) to
    perform basic logical operations. For example, if we wanted to know whether it’s
    possible for something to be both true *and* false at the same time, we might
    enter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'R would return:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: telling us that a value can’t be both true and false.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: But what about true *or* false?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Like strings, in this book logical values will primarily be used to provide
    arguments to functions we’ll be using, or as the results of comparing two different
    values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '***Missing Values***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In practical statistics and data science, data is often missing some values.
    For example, say you have temperature data for the morning and afternoon of every
    day for a month, but something malfunctioned one day and you’re missing a morning
    temperature. Because missing values are so common, R has a special way of representing
    them: using the value `NA`. It’s important to have a way to handle missing values
    because they can mean very different things in different contexts. For example,
    when you’re measuring rainfall a missing value might mean there was no rain in
    the gauge, or it might mean that there was plenty of rain but temperatures were
    freezing that night, cracking the gauge and causing all the water to leak out.
    In the first case, we might consider missing values to mean 0, but in the latter
    case it’s not clear what the value should be. Keeping missing values separate
    from other values forces us to consider these differences.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际统计学和数据科学中，数据经常缺失一些值。例如，假设你有一个月每天早晚的温度数据，但某一天出现了故障，导致缺失了早晨的温度。由于缺失值非常常见，R
    语言有一种特殊的方式来表示它们：使用值`NA`。处理缺失值非常重要，因为它们在不同的上下文中可能意味着截然不同的事情。例如，当你测量降水量时，缺失值可能意味着雨量计里没有雨水，或者可能意味着那天晚上温度非常低，导致雨量计破裂，所有的水都泄漏了。在第一种情况下，我们可能会认为缺失值意味着0，但在后者情况下，缺失值到底应该是多少就不太清楚了。将缺失值与其他值区分开来，迫使我们考虑这些差异。
- en: 'To prompt us to make sense of what our missing values are whenever we try to
    use one, R will output `NA` for any operation using a missing value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提示我们在尝试使用缺失值时弄清楚它们的含义，R 会在任何涉及缺失值的操作中输出`NA`：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we’ll see in a bit, various functions in R can handle missing values in different
    ways, but you shouldn’t have to worry about missing values for the R you’ll use
    in this book.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将看到的，R 中的各种函数可以用不同的方式处理缺失值，但对于本书中的 R，你不需要担心缺失值。
- en: '***Vectors***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***向量***'
- en: Nearly every programming language contains certain features that make it unique
    and especially suited to solving problems in its domain. R’s special feature is
    that it is a *vector language*. A vector is a list of values, and everything R
    does is an operation on a vector. We use the code `c(...)` to define vectors (but
    even if we put in just a single value, R does this for us!).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每种编程语言都有一些特殊功能，使得它在解决特定领域的问题时格外合适。R 语言的特别之处在于它是一个*向量语言*。向量是一个值的列表，R 做的每一件事都是对向量的操作。我们使用代码`c(...)`来定义向量（即使我们只输入一个值，R
    也会自动为我们处理！）。
- en: 'To understand how vectors work, let’s consider an example. Enter the next example
    in a script, rather than the console. We first create a new vector by assigning
    the variable `x` to the vector `c(1,2,3)` using the assignment operator `<-` like
    so:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解向量的工作原理，我们来看一个例子。请输入下面的代码到脚本中，而不是控制台。我们首先通过将变量`x`赋值为向量`c(1,2,3)`，并使用赋值操作符`<-`来创建一个新的向量，如下所示：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have a vector, we can use it in our calculations. When we perform
    a simple operation, like adding `3` to `x`, when we enter this in the console,
    we get a rather unexpected result (especially if you’re used to another programming
    language):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个向量，可以将它用于我们的计算中。当我们执行一个简单的操作，比如将`3`加到`x`时，在控制台中输入这个操作会得到一个相当意外的结果（尤其是如果你习惯了其他编程语言的话）：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result of `x + 3` tells us what happens if we add `3` to each value in our
    `x` vector. (In many other programming languages, we’d need to use a `for` loop
    or some other iterator to perform this operation.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`x + 3`的结果告诉我们，如果将`3`加到`x`向量中的每个值上，会发生什么情况。（在许多其他编程语言中，我们可能需要使用`for`循环或其他迭代器来执行此操作。）'
- en: 'We can also add vectors to each other. Here, we’ll create a new vector containing
    three elements, each with a value of `2`. We’ll name this vector `y`, then add
    `y` to `x`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将向量相加。在这里，我们将创建一个新向量，包含三个元素，每个元素的值为`2`。我们将这个向量命名为`y`，然后将`y`加到`x`上：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, this operation added each element in `x` to its corresponding
    element in `y`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个操作将`x`中的每个元素与`y`中的对应元素相加。
- en: What if we multiply our two vectors?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将两个向量相乘会怎样？
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each value in `x` was multiplied by its corresponding value in `y`. If the lists
    weren’t the same size, or a multiple of the same size, then we’d get an error.
    If a vector is a multiple of the same size, R will just repeatedly apply the smaller
    vector to the larger one. However, we won’t be making use of this feature in this
    book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`中的每个值都被其在`y`中对应的值相乘。如果列表大小不一样，或者不是同一大小的倍数，那么我们会遇到错误。如果一个向量是另一个向量的倍数，R会反复将较小的向量应用到较大的向量上。然而，在本书中，我们不会利用这一特性。'
- en: 'We can quite easily combine vectors in R by defining another vector based on
    the existing ones. Here, we’ll create the vector `z` by combining `x` and `y`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过基于现有的向量定义另一个向量来轻松地组合向量。在这里，我们通过将`x`和`y`组合在一起创建向量`z`：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that this operation didn’t give us a vector of vectors; instead, we got
    a single vector that contains the values from both, in the order you set `x` and
    `y` when you defined `z`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个操作没有给我们一个向量的向量；相反，我们得到了一个单一的向量，其中包含了`x`和`y`中所有的值，顺序就是你在定义`z`时设定的`x`和`y`的顺序。
- en: 'Learning to use vectors efficiently in R can be a bit tricky for beginners.
    Ironically, programmers who are experienced in a non-vector-based language often
    have the most difficulty. Don’t worry, though: in this book, we’ll use vectors
    to make reading code easier.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，学习在R中高效使用向量可能有点棘手。具有非向量语言经验的程序员常常是最难适应的。别担心：在本书中，我们将使用向量使代码更易读。
- en: '**Functions**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '*Functions* are blocks of code that perform a particular operation on a value,
    and we’ll use them in R to solve problems.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是执行特定操作的代码块，我们将在R中使用它们来解决问题。'
- en: In R and RStudio, all functions come equipped with documentation. If you enter
    `?` followed by a function name into the R console, you’ll get the full documentation
    for that function. For example, if you enter `?sum` into the RStudio console,
    you should see the documentation shown in [Figure A-3](app01.xhtml#app01fig03)
    in the bottom-right screen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在R和RStudio中，所有函数都配有文档。如果你在R控制台中输入`?`加上函数名，你将看到该函数的完整文档。例如，如果你在RStudio控制台中输入`?sum`，你应该能在右下角的屏幕上看到如[图A-3](app01.xhtml#app01fig03)所示的文档。
- en: '![Image](../images/afig03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/afig03.jpg)'
- en: '*Figure A-3: Viewing the documentation for the sum() function*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A-3：查看sum()函数的文档*'
- en: This documentation gives us the definition of the `sum()` function and some
    of its uses. The `sum()` function takes a vector’s values and adds them all together.
    The documentation says it takes `...` as an argument, which means it can accept
    any number of values. Usually these values will be a vector of numbers, but they
    can consist of multiple vectors, too.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这份文档给出了`sum()`函数的定义及其一些用法。`sum()`函数将一个向量的值相加。文档中提到它接受`...`作为参数，这意味着它可以接受任意数量的值。通常这些值是一个数字向量，但它们也可以是多个向量。
- en: 'The documentation also lists an *optional argument*: `na.rm = FALSE`. Optional
    arguments are arguments that you don’t have to pass in to the function for it
    to work; if you don’t pass an optional argument in, R will use the argument’s
    default value. In the case of `na.rm`, which automatically removes any missing
    values, the default value, after the equal sign, is `FALSE`. That means that,
    by default, `sum()` won’t remove missing values.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 文档还列出了一个*可选参数*：`na.rm = FALSE`。可选参数是你不需要传递给函数的参数，函数仍然可以正常工作；如果你没有传递可选参数，R将使用该参数的默认值。在`na.rm`的情况下，它会自动删除任何缺失值，默认值在等号后是`FALSE`。这意味着默认情况下，`sum()`不会删除缺失值。
- en: '***Basic Functions***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础函数***'
- en: Here are some of R’s most important functions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是R中一些最重要的函数。
- en: '**The length() and nchar() Functions**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**length()和nchar()函数**'
- en: 'The `length()` function will return the length of a vector:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`length()`函数将返回一个向量的长度：'
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since there are three elements in this vector, the `length()` function returns
    `3`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该向量中有三个元素，`length()`函数返回`3`。
- en: 'Because everything in R is a vector, you can use the `length()` function to
    find the length of anything—even a string, like `“doggies”`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为R中的一切都是向量，所以你可以使用`length()`函数来查找任何东西的长度——即使是像`“doggies”`这样的字符串：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: R tells us that `“doggies”` is a vector containing one string.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: R告诉我们`“doggies”`是一个包含一个字符串的向量。
- en: 'Now, if we had two strings, `“doggies”` and `“cats”`, we’d get:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有两个字符串，`“doggies”`和`“cats”`，我们将得到：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To find the number of characters in a string, we use the `nchar()` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找字符串中的字符数，我们使用`nchar()`函数：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that if we use `nchar()` on the `c(“doggies”,”cats”)` vector, R returns
    a new vector containing the number of characters in each string:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们对`c(“doggies”,”cats”)`向量使用`nchar()`，R会返回一个新向量，包含每个字符串的字符数：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**The sum(), cumsum(), and diff() Functions**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**sum()、cumsum()和diff()函数**'
- en: 'The `sum()` function takes a vector of numbers and adds all those numbers together:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()`函数接受一个数字向量，并将所有这些数字相加：'
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we saw in the documentation in the previous section, `sum()` takes `...`
    as its argument, which means it can accept any number of values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节的文档中看到的，`sum()`接受`...`作为其参数，这意味着它可以接受任意数量的值：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, no matter how many vectors we provide, `sum()` adds them up
    as though they were a single vector of integers. If you wanted to sum up multiple
    vectors, you’d call `sum()` on them each separately.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，无论我们提供多少个向量，`sum()`都会将它们加起来，就好像它们是一个整数的单一向量。如果你想对多个向量求和，你需要分别对它们调用`sum()`。
- en: Remember, also, that the `sum()` function takes the optional argument `na.rm`,
    which by default is set to `FALSE`. The `na.rm` argument determines if `sum()`
    removes `NA` values or not.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另外请记住，`sum()`函数有一个可选参数`na.rm`，默认设置为`FALSE`。`na.rm`参数决定了`sum()`是否移除`NA`值。
- en: 'If we leave `na.rm` set to `FALSE`, here’s what happens if we try to use `sum()`
    on a vector with a missing value:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`na.rm`保持为`FALSE`，当我们尝试对包含缺失值的向量使用`sum()`时，会发生以下情况：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we saw when `NA` was introduced, adding a value to an `NA` value results
    in `NA`. If we’d like R to give us a number as an answer instead, we can tell
    `sum()` to remove `NA` values by setting `na.rm = TRUE`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在引入`NA`时看到的，将一个值加到`NA`值上会得到`NA`。如果我们希望R给出一个数字作为答案，我们可以通过设置`na.rm = TRUE`来告诉`sum()`去除`NA`值：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `cumsum()` function takes a vector and calculates its *cumulative sum*—a
    vector of the same length as the input that replaces each number with the sum
    of the numbers that come before it (including that number). Here’s an example
    in code to make this clearer:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`cumsum()`函数接受一个向量并计算其*累积和*——一个与输入向量长度相同的向量，将每个数字替换为它前面所有数字的和（包括该数字）。下面是一个代码示例，使这一点更加清晰：'
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `diff()` function takes a vector and subtracts each number from the number
    that precedes it in the vector:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff()`函数接受一个向量，并从向量中每个数字中减去前一个数字：'
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that the result of the `diff()` function contains one fewer element than
    the original vector did. That’s because nothing gets subtracted from the first
    value in the vector.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`diff()`函数的结果比原始向量少了一个元素。这是因为第一个值没有被减去。
- en: '**The : operator and the seq() Function**'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`:`运算符和`seq()`函数**'
- en: 'Often, rather than manually listing each element of a vector, we’d prefer to
    generate vectors automatically. To automatically create a vector of whole numbers
    in a certain range, we can use the `:` operator to separate the start and end
    of the range. R can even figure out if you want to count up or down (the `c()`
    wrapping this operator is not strictly necessary):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会希望自动生成向量，而不是手动列出每个元素。为了自动创建某个范围内的整数向量，我们可以使用`:`运算符来分隔范围的起始值和结束值。R甚至能够判断你是想递增还是递减（将`c()`包裹此运算符并非严格必要）：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you use `:`, R will count from the first value to the last.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`:`时，R会从第一个值数到最后一个值。
- en: 'Sometimes we’ll want to count by something other than increments of one. The
    `seq()` function allows us to create vectors of a sequence of values that increment
    by a specified amount. The arguments to `seq()` are, in order:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望按其他增量计数，而不是每次增加1。`seq()`函数允许我们创建递增指定数值的序列向量。`seq()`的参数依次是：
- en: The start of the sequence
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列的起始
- en: The end of the sequence
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列的结束
- en: The amount to increment the sequence by
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列的递增量
- en: 'Here are some examples of using `seq()`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用`seq()`的示例：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we want to count down to a certain value using the `seq()` function, we
    use a minus value as our increment, like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用`seq()`函数倒数到某个值，我们可以使用负值作为递增量，例如这样：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**The ifelse() Function**'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`ifelse()`函数**'
- en: 'The `ifelse()` function tells R to take one of two actions based on some condition.
    This function can be a bit confusing if you’re used to the normal `if ... else`
    control structure in other languages. In R, it takes the following three arguments
    (in order):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifelse()`函数告诉R根据某个条件执行两种操作之一。如果你习惯于其他语言中的普通`if ... else`控制结构，这个函数可能会有点让人困惑。在R中，它接受以下三个参数（按顺序）：'
- en: A statement about a vector that may be either true or false of its values
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个关于向量的陈述，表明该向量的值可能为真或假
- en: What happens in the case that the statement is true
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当条件为真时会发生什么
- en: What happens in the case that the statement is false
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当条件为假时会发生什么
- en: 'The `ifelse()` function operates on entire vectors at once. When it comes to
    vectors containing a single value, its use is pretty intuitive:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifelse()`函数会一次性操作整个向量。当向量只包含单个值时，它的使用非常直观：'
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here the statement is that 2 is smaller than 3, and we ask R to output `“small”`
    if it is, and `“too big”` if it isn’t.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的条件是2小于3，我们要求R如果成立则输出`“small”`，否则输出`“too big”`。
- en: 'Suppose we have a vector `x` that contains multiple values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含多个值的向量`x`：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `ifelse()` function will return a value for each element in the vector:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifelse()`函数会为向量中的每个元素返回一个值：'
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can also use vectors in the results arguments for the `ifelse()`. Suppose
    that, in addition to our `x` vector, we had another vector, `y`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`ifelse()`的结果参数中使用向量。假设除了我们的`x`向量外，我们还有另一个向量`y`：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We want to generate a new list that contains the greatest value from `x` and
    `y` for each element in the vector. We could use `ifelse()` to solve this very
    simply:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想生成一个新列表，其中包含向量中每个元素对应的`x`和`y`的最大值。我们可以使用`ifelse()`来非常简单地解决这个问题：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see R has compared the values in `x` to the respective value in `y`
    and outputs the largest of the two for each element.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到R已将`x`中的值与`y`中相应的值进行了比较，并输出每个元素中较大的那个。
- en: '**Random Sampling**'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**随机抽样**'
- en: We’ll often use R to randomly sample values. This allows us to have the computer
    pick a random number or value for us. We use this sample to simulate activities
    like flipping a coin, playing “rock, paper, scissors,” or picking a number between
    1 and 100.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用R来随机抽样。这使得计算机可以为我们选择一个随机的数字或值。我们使用这个样本来模拟活动，例如抛硬币、玩“剪刀石头布”或从1到100之间选择一个数字。
- en: '***The runif() Function***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***runif()函数***'
- en: 'One way to randomly sample values is with the function `runif()`, short for
    “random uniform,” which takes a required argument `n` and gives that many samples
    in the range 0 to 1:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一种随机抽样的方法是使用`runif()`函数，它是“随机均匀”的缩写，接受一个必需的参数`n`，并在0到1的范围内提供相应数量的样本：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can use this function with `ifelse()` to generate a value `A` 20 percent
    of the time. In this case we’ll use `runif(5)` to create five random values between
    0 and 1\. Then if the value is less than 0.2, we’ll return `“A”`; otherwise, we’ll
    return `“B”`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个函数与`ifelse()`结合使用，以20%的概率生成值`A`。在这种情况下，我们将使用`runif(5)`创建五个0到1之间的随机值。如果某个值小于0.2，则返回`“A”`；否则，返回`“B”`：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Since the numbers we’re generating are random, we’ll get a different result
    each time we run the `ifelse()` function. Here are some possible outcomes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们生成的数字是随机的，因此每次运行`ifelse()`函数时我们都会得到不同的结果。以下是一些可能的结果：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `runif()` function can take optional second and third arguments, which
    are the minimum and maximum values of the range to be uniformly sampled from.
    By default, the function uses the range between 0 and 1 inclusive, but you can
    set the range to be whatever you’d like:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`runif()`函数可以接受可选的第二和第三个参数，分别是均匀抽样范围的最小值和最大值。默认情况下，函数使用的是0到1（包括1）之间的范围，但你可以设置成任何你想要的范围：'
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***The rnorm() Function***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***rnorm()函数***'
- en: 'We can also sample from a normal distribution using the `rnorm()` function,
    which we’ll discuss in more depth in the book (the normal distribution is covered
    in [Chapter 12](ch12.xhtml#ch12)):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`rnorm()`函数从正态分布中抽样，书中将更深入讨论这一点（正态分布内容见[第12章](ch12.xhtml#ch12)）：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: By default, `rnorm()` samples from a normal distribution with a mean of 0 and
    standard deviation of 1, as is the case in this example. For readers unfamiliar
    with the normal distribution, this means that samples will have a “bell-shaped”
    distribution around 0, with most samples being close to 0 and very few being less
    than –3 or greater than 3.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`rnorm()`从均值为0，标准差为1的正态分布中抽样，就像这个例子一样。对于不熟悉正态分布的读者来说，这意味着样本将围绕0呈“钟形”分布，大多数样本接近0，极少有小于-3或大于3的样本。
- en: 'The `rnorm()` function has two optional arguments, `mean` and `sd`, which allow
    you to set a different mean and standard deviation, respectively:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`rnorm()`函数有两个可选参数，`mean`和`sd`，允许你分别设置不同的均值和标准差：'
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In statistics, sampling from a normal distribution is often more common than
    sampling from a uniform distribution, so `rnorm()` comes in quite handy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，从正态分布中抽样通常比从均匀分布中抽样更为常见，因此`rnorm()`非常有用。
- en: '***The sample() Function***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***sample()函数***'
- en: 'Sometimes, we want to sample from something other than just a well-studied
    distribution. Suppose you have a drawer containing socks of many colors:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要从其他分布中进行采样，而不仅仅是从一个经过充分研究的分布中进行采样。假设你有一个抽屉，里面装着多种颜色的袜子：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you wanted to simulate the act of randomly picking any two socks, you could
    use R’s `sample()` function, which takes as arguments a vector of values and the
    number of elements to sample:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想模拟随机挑选两只袜子的行为，你可以使用 R 的 `sample()` 函数，该函数的参数是一个值的向量和要采样的元素数量：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `sample()` function behaves as though we’ve picked two random socks out
    of the drawer—without putting any back. If we sample five socks, we’ll get all
    of the socks we originally had in the drawer:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample()` 函数的行为就像我们从抽屉里挑选了两只随机的袜子 —— 而且没有将任何袜子放回去。如果我们采样五只袜子，我们将得到最初抽屉里所有的袜子：'
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That means that if we try to take six socks from the drawer where there are
    only five available socks, we’ll get an error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们尝试从抽屉中拿出六只袜子，而抽屉里只有五只袜子可用，我们将会得到一个错误：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we want to both sample and “put the socks back,” we can set the optional
    argument `replace` to `TRUE`. Now, each time we sample a sock, we put it back
    in the drawer. This allows us to sample more socks than are in the drawer. It
    also means the distribution of socks in the drawer never changes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望同时进行采样并且“把袜子放回去”，我们可以将可选参数 `replace` 设置为 `TRUE`。现在，每次我们采样一只袜子时，我们都会把它放回抽屉。这使得我们能够采样更多的袜子，而抽屉里的袜子数量并不会改变。这也意味着抽屉中袜子的分布永远不会变化。
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With these simple sampling tools, you can run surprisingly sophisticated simulations
    in R that save you from doing a lot of math.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些简单的采样工具，你可以在 R 中运行出令人惊讶的复杂模拟，省去了大量数学计算。
- en: '***Using set.seed() for Predictable Random Results***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 set.seed() 获取可预测的随机结果***'
- en: 'The “random numbers” generated by R aren’t truly random numbers. As in all
    programming languages, random numbers are generated by a *pseudorandom number
    generator*, which takes a *seed value* and uses that to create a sequence of numbers
    that are random enough for most purposes. The seed value sets the initial state
    of the random number generator and determines which numbers will come next in
    the sequence. In R, we can manually set this seed using the `set.seed()` function.
    Setting the seed is extremely useful for cases when we want to use the same random
    results again:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: R 生成的“随机数”并不是真正的随机数。像所有编程语言一样，随机数是通过*伪随机数生成器*生成的，该生成器采用一个*种子值*，并利用该种子值生成一串足够随机的数字，适用于大多数用途。种子值设置了随机数生成器的初始状态，并决定接下来会生成哪些数字。在
    R 中，我们可以通过 `set.seed()` 函数手动设置这个种子。设置种子在我们希望使用相同的随机结果时非常有用：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, when we used the same seed twice with the `runif()` function,
    it generated the same set of supposedly random values. The main benefit of using
    `set.seed()` is making the results reproducible. This can make tracking down bugs
    in programs that involve sampling much easier, since the results don’t change
    each time the program is run.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当我们使用相同的种子两次，并调用 `runif()` 函数时，它生成了相同的所谓随机值。使用 `set.seed()` 的主要好处是使结果可复现。这可以大大简化跟踪程序中涉及采样的
    bug，因为每次运行程序时，结果都不会发生变化。
- en: '**Defining Your Own Functions**'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义你自己的函数**'
- en: Sometimes it’s helpful to write our own functions for specific operations we’ll
    have to perform repeatedly. In R, we can define functions using the keyword `function`
    (a *keyword* in a programming language is simply a special word reserved by the
    programming language for a specific use).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时编写我们自己的函数来执行一些需要反复操作的特定任务是非常有用的。在 R 中，我们可以使用关键字 `function` 来定义函数（在编程语言中，*关键字*是指编程语言为特定用途保留的特殊单词）。
- en: Here’s the definition of a function that takes a single argument, `val`—which
    here stands for the value the user will input to the function—and then doubles
    `val` and cubes it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个函数的定义，它接受一个单一参数 `val` —— 这里代表用户输入的值 —— 然后将 `val` 进行两倍和立方操作。
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once we’ve defined our function, we can use it, just like R’s built-in functions.
    Here’s our `double_then_cube()` function applied to the number 8:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了函数，就可以像使用 R 的内建函数一样使用它。下面是我们应用于数字 8 的 `double_then_cube()` 函数：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Also, because everything we did to define our function is *vectorized* (that
    is, all values work on vectors of values), our function will work on vectors as
    well as single values:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们定义函数时所做的所有操作都是*向量化*的（也就是说，所有的值都作用于值的向量），我们的函数不仅能作用于单个值，也能作用于向量：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can define functions that take more than one argument as well. The `sum_then_square()`
    function, defined here, adds two arguments together, then squares the result:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义接受多个参数的函数。这里定义的 `sum_then_square()` 函数将两个参数相加，然后对结果进行平方：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'By including the two arguments `(x,y)` in the function definition, we’re telling
    R the `sum_then_square()` function expects two arguments. Now we can use our new
    function, like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数定义中包含两个参数 `(x,y)`，我们告诉 R `sum_then_square()` 函数期望两个参数。现在我们可以像这样使用我们新的函数：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can also define functions that require multiple lines. In R, when a function
    is called it will always return the result of the calculation on the final line
    of the function definition. That means we could have rewritten `sum_then_square()`
    like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义需要多行代码的函数。在 R 中，当调用函数时，它始终返回函数定义最后一行计算的结果。这意味着我们可以像这样重写 `sum_then_square()`：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Typically, when you write functions, you’ll want to write them in an R script
    file so you can save them and reuse them later.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你编写函数时，你会希望将它们写入 R 脚本文件中，这样你就可以保存它们并在以后重用。
- en: '**Creating Basic Plots**'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建基本图表**'
- en: In R, we can quickly generate plots of data very easily. Though R has an extraordinary
    plotting library called `ggplot2`, which contains many useful functions for generating
    beautiful plots, we’ll restrict ourselves to R’s base plotting functions for now,
    which are plenty useful on their own.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，我们可以非常轻松地生成数据的图表。虽然 R 拥有一个非常强大的绘图库 `ggplot2`，其中包含许多用于生成美丽图表的有用函数，但我们暂时将自己限制在
    R 的基础绘图函数，这些函数本身已经非常有用。
- en: 'To show how plotting works, we’ll create two vectors of values, our `xs` and
    our `ys`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示绘图如何工作，我们将创建两个值的向量，即我们的 `xs` 和 `ys`：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we can use these vectors as arguments to the `plot()` function, which
    will plot our data for us. The `plot()` function takes two arguments: the values
    of the plot’s points on the x-axis and the values of those points on the y-axis,
    in that order:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将这些向量作为参数传递给 `plot()` 函数，后者将为我们绘制数据。`plot()` 函数有两个参数：x 轴上各点的值和 y 轴上这些点的值，顺序是这样的：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This function should generate the plot shown in [Figure A-4](app01.xhtml#app01fig04)
    in the bottom-left window of RStudio.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数应在 RStudio 的左下角窗口中生成 [图 A-4](app01.xhtml#app01fig04) 中所示的图表。
- en: '![Image](../images/afig04.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/afig04.jpg)'
- en: '*Figure A-4: A simple plot created with R’s plot() function*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-4：使用 R 的 plot() 函数创建的简单图表*'
- en: 'This plot shows the relationship between our `xs` values and their corresponding
    `ys` values. If we return to the function, we can give this plot a title using
    the optional `main` argument. We can also change the x- and y-axis labels with
    the `xlab` and `ylab` arguments, like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表显示了我们 `xs` 值与其对应的 `ys` 值之间的关系。如果我们回到函数中，可以使用可选的 `main` 参数为该图表添加标题。我们还可以使用
    `xlab` 和 `ylab` 参数更改 x 轴和 y 轴的标签，像这样：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The new labels should show up as they appear in [Figure A-5](app01.xhtml#app01fig05).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 新的标签应按 [图 A-5](app01.xhtml#app01fig05) 中的显示方式出现。
- en: '![Image](../images/afig05.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/afig05.jpg)'
- en: '*Figure A-5: Changing the plot title and labels with the plot() function*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-5：使用 plot() 函数更改图表标题和标签*'
- en: 'We can also change the plot’s type using the `type` argument. The first kind
    of plot we generated is called a *point plot*, but if we wanted to make a line
    plot, which draws a line through each value, we could set `type=”l”`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `type` 参数更改图表的类型。我们生成的第一种图表叫做 *点图*，但如果我们想制作折线图，通过每个值绘制一条线，我们可以设置 `type="l"`：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It would then look like [Figure A-6](app01.xhtml#app01fig06).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它看起来就像 [图 A-6](app01.xhtml#app01fig06)。
- en: '![Image](../images/afig06.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/afig06.jpg)'
- en: '*Figure A-6: A line plot generated with R’s plot() function*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-6：使用 R 的 plot() 函数生成的折线图*'
- en: 'Or we can do both! An R function called `lines()` can add lines to an existing
    plot. It takes most of the same arguments as `plot()`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以两者都做！一个叫做 `lines()` 的 R 函数可以向现有图表添加线条。它接受与 `plot()` 相似的大多数参数：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[Figure A-7](app01.xhtml#app01fig07) shows the plot this function would generate.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-7](app01.xhtml#app01fig07) 显示了此函数生成的图表。'
- en: '![Image](../images/afig07.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/afig07.jpg)'
- en: '*Figure A-7: Adding lines to an existing plot with R’s lines() function*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-7：使用 R 的 lines() 函数向现有图表添加线条*'
- en: There are many more amazing ways to use R’s basic plots, and you can consult
    `?plot` for more information on them. However, if you want to create truly beautiful
    plots in R, you should research the `ggplot2` library (*[https://ggplot2.tidyverse.org/](https://ggplot2.tidyverse.org/)*).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 R 的基础图形还有很多令人惊叹的方式，你可以通过查阅 `?plot` 获取更多信息。然而，如果你想在 R 中创建真正美丽的图表，建议研究 `ggplot2`
    库 (*[https://ggplot2.tidyverse.org/](https://ggplot2.tidyverse.org/)*).
- en: '**Exercise: Simulating a Stock Price**'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习：模拟股票价格**'
- en: Now let’s put everything we’ve learned together to create a simulated stock
    ticker! People often model stock prices using the cumulative sum of normally distributed
    random values. To start, we’ll simulate stock movement for a period of time by
    generating a sequence of values from 1 to 20, incrementing by 1 each time using
    the `seq()` function. We’ll call the vector representing the period of time `t.vals`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把学到的所有内容结合起来，创建一个模拟的股票行情！人们通常使用正态分布随机值的累积和来模拟股票价格。首先，我们通过使用 `seq()` 函数生成一个从
    1 到 20 的数值序列，每次递增 1 来模拟一段时间内的股票价格变动。我们将代表这段时间的向量命名为 `t.vals`。
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now `t.vals` is a vector containing the sequence of numbers from 1 to 20 incremented
    by 1\. Next, we’ll create some simulated prices by taking the cumulative sum of
    a normally distributed value for each time in your `t.vals`. To do this we’ll
    use `rnorm()` to sample the number of values equal to the length of `t.vals`.
    Then we’ll use `cumsum()` to calculate the cumulative sum of this vector of values.
    This will represent the idea of a price moving up or down based on random motion;
    less extreme movements are more common than more extreme ones.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`t.vals` 是一个包含从 1 到 20 的数字序列的向量，每次递增 1。接下来，我们通过对每个 `t.vals` 中的时间点使用正态分布值的累积和来创建模拟的价格。为此，我们将使用
    `rnorm()` 来抽取与 `t.vals` 长度相等的随机值，然后使用 `cumsum()` 来计算这些值的累积和。这将代表价格基于随机运动的上下波动；较小的波动比极端波动更常见。
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Finally, we can plot all these values to see how they look! We’ll use both the
    `plot()` and `lines()` functions, and label the axes according to what they represent.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将所有这些数值绘制成图，看看它们的效果！我们将同时使用 `plot()` 和 `lines()` 函数，并根据它们所代表的内容标记坐标轴。
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `plot()` and `lines()` functions should generate the plot shown in [Figure
    A-8](app01.xhtml#app01fig08).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()` 和 `lines()` 函数应生成[图 A-8](app01.xhtml#app01fig08)所示的图表。'
- en: '![Image](../images/afig08.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/afig08.jpg)'
- en: '*Figure A-8: The plot generated for our simulated stock ticker*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-8：为我们模拟的股票行情生成的图表*'
- en: '**Summary**'
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This appendix should cover enough R to give you a grasp of the examples in this
    book. I recommend following along with the book’s chapters, then playing around
    by modifying the code examples to learn more. R also has some great online documentation
    if you want to take your experimentation further.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录应涵盖足够的 R 知识，以便你理解本书中的示例。我建议你跟着书中的章节学习，然后通过修改代码示例来进一步探索。R 还提供了丰富的在线文档，如果你想深入实验，可以参考它们。
