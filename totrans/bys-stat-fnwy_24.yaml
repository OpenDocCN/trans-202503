- en: '**A'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A QUICK INTRODUCTION TO R**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this book, we use the R programming language to do some tricky mathematical
    work for us. R is a programming language that specializes in statistics and data
    science. If you don’t have experience with R, or with programming in general,
    don’t worry—this appendix will get you started.
  prefs: []
  type: TYPE_NORMAL
- en: '**R and RStudio**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run the code examples in this book, you’ll need to have R installed on your
    computer. To install R, visit *[https://cran.rstudio.com/](https://cran.rstudio.com/)*
    and follow the installation steps for the operating system you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve installed R, you should also install *RStudio*, an integrated development
    environment (IDE) that makes it extremely easy to run R projects. Download and
    install RStudio from *[www.rstudio.com/products/rstudio/download/](http://www.rstudio.com/products/rstudio/download/)*.
  prefs: []
  type: TYPE_NORMAL
- en: When you open RStudio, you should be greeted with several panels ([Figure A-1](app01.xhtml#app01fig01)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/afig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-1: Viewing the console in RStudio*'
  prefs: []
  type: TYPE_NORMAL
- en: The most important panel is the big one in the middle, called the *console*.
    In the console, you can enter any of the code examples from the book and run them
    simply by pressing ENTER. The console runs all the code you enter immediately,
    which makes it hard to keep track of the code you’ve written so far.
  prefs: []
  type: TYPE_NORMAL
- en: To write programs that you can save and come back to, you can place your code
    in an *R script*, which is a text file that you can load into the console later.
    R is an extremely interactive programming language, so rather than thinking of
    the console as a place you can test out code, think of R scripts as a way to quickly
    load tools you can use in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an R Script**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create an R script, go to **File▸New File▸R Script** in RStudio. This should
    create a new blank panel in the top left ([Figure A-2](app01.xhtml#app01fig02)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/afig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-2: Creating an R script*'
  prefs: []
  type: TYPE_NORMAL
- en: In this panel, you can enter code and save it as a file. To run the code, simply
    click the **Source** button at the top right of the panel, or run individual lines
    by clicking the **Run** button. The Source button will automatically load your
    file into the console as though you had typed it there yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Concepts in R**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll be using R as an advanced calculator in this book, which means you’ll
    only need to understand a few basics to work through the problems and extend the
    examples in the book on your own.
  prefs: []
  type: TYPE_NORMAL
- en: '***Data Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All programming languages have different types of data, which you can use for
    different purposes and manipulate in different ways. R has a rich variety of types
    and data structures, but we’ll only be using a very small number of them in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Doubles**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The numbers we use in R will all be of the type *double* (short for “double-precision
    floating-point,” which is the most common way to represent decimal numbers on
    a computer). The double is the default type for representing decimal numbers.
    Unless otherwise specified, all numbers you enter into the console are of the
    double type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can manipulate numbers in the double type using standard mathematical operations.
    For example, we can add two numbers with the `+` operator. Try this out in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also divide any numbers that give us decimal results using the `/` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can multiply values with the `*` operator like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'and take the exponential of a value using the `^` operator. For example, 5²
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add `-` in front of a number to make it negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can also use scientific notation with `e+`. So 5 × 10² is just:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use `e-` we get the same result as 5 × 10^(–2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful to know because sometimes R will return the result in scientific
    notation if it is too large to easily fit on the screen, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Strings**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another important type in R is the *string*, which is just a group of characters
    used to represent text. In R, we surround a string with quotation marks, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you put a number inside a string, you can’t use that number in
    regular numeric operations because strings and numbers are different types. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We won’t be making much use of strings in this book. We’ll primarily use them
    to pass arguments to functions and to give labels to plots. But it’s important
    to remember them if you’re using text.
  prefs: []
  type: TYPE_NORMAL
- en: '**Logicals**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Logical* or *binary* types are true or false values represented by the codes
    `TRUE` and `FALSE`. Note that `TRUE` and `FALSE` aren’t strings—they’re not surrounded
    by quotes, and they’re written in all uppercase. (R also allows you to simply
    use `T` or `F` instead of writing out the full words.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine logical types with the symbols `&` (“and”) and `|` (“or”) to
    perform basic logical operations. For example, if we wanted to know whether it’s
    possible for something to be both true *and* false at the same time, we might
    enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'R would return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: telling us that a value can’t be both true and false.
  prefs: []
  type: TYPE_NORMAL
- en: But what about true *or* false?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Like strings, in this book logical values will primarily be used to provide
    arguments to functions we’ll be using, or as the results of comparing two different
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '***Missing Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In practical statistics and data science, data is often missing some values.
    For example, say you have temperature data for the morning and afternoon of every
    day for a month, but something malfunctioned one day and you’re missing a morning
    temperature. Because missing values are so common, R has a special way of representing
    them: using the value `NA`. It’s important to have a way to handle missing values
    because they can mean very different things in different contexts. For example,
    when you’re measuring rainfall a missing value might mean there was no rain in
    the gauge, or it might mean that there was plenty of rain but temperatures were
    freezing that night, cracking the gauge and causing all the water to leak out.
    In the first case, we might consider missing values to mean 0, but in the latter
    case it’s not clear what the value should be. Keeping missing values separate
    from other values forces us to consider these differences.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To prompt us to make sense of what our missing values are whenever we try to
    use one, R will output `NA` for any operation using a missing value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we’ll see in a bit, various functions in R can handle missing values in different
    ways, but you shouldn’t have to worry about missing values for the R you’ll use
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '***Vectors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Nearly every programming language contains certain features that make it unique
    and especially suited to solving problems in its domain. R’s special feature is
    that it is a *vector language*. A vector is a list of values, and everything R
    does is an operation on a vector. We use the code `c(...)` to define vectors (but
    even if we put in just a single value, R does this for us!).
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how vectors work, let’s consider an example. Enter the next example
    in a script, rather than the console. We first create a new vector by assigning
    the variable `x` to the vector `c(1,2,3)` using the assignment operator `<-` like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a vector, we can use it in our calculations. When we perform
    a simple operation, like adding `3` to `x`, when we enter this in the console,
    we get a rather unexpected result (especially if you’re used to another programming
    language):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The result of `x + 3` tells us what happens if we add `3` to each value in our
    `x` vector. (In many other programming languages, we’d need to use a `for` loop
    or some other iterator to perform this operation.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add vectors to each other. Here, we’ll create a new vector containing
    three elements, each with a value of `2`. We’ll name this vector `y`, then add
    `y` to `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this operation added each element in `x` to its corresponding
    element in `y`.
  prefs: []
  type: TYPE_NORMAL
- en: What if we multiply our two vectors?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Each value in `x` was multiplied by its corresponding value in `y`. If the lists
    weren’t the same size, or a multiple of the same size, then we’d get an error.
    If a vector is a multiple of the same size, R will just repeatedly apply the smaller
    vector to the larger one. However, we won’t be making use of this feature in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quite easily combine vectors in R by defining another vector based on
    the existing ones. Here, we’ll create the vector `z` by combining `x` and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this operation didn’t give us a vector of vectors; instead, we got
    a single vector that contains the values from both, in the order you set `x` and
    `y` when you defined `z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learning to use vectors efficiently in R can be a bit tricky for beginners.
    Ironically, programmers who are experienced in a non-vector-based language often
    have the most difficulty. Don’t worry, though: in this book, we’ll use vectors
    to make reading code easier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Functions* are blocks of code that perform a particular operation on a value,
    and we’ll use them in R to solve problems.'
  prefs: []
  type: TYPE_NORMAL
- en: In R and RStudio, all functions come equipped with documentation. If you enter
    `?` followed by a function name into the R console, you’ll get the full documentation
    for that function. For example, if you enter `?sum` into the RStudio console,
    you should see the documentation shown in [Figure A-3](app01.xhtml#app01fig03)
    in the bottom-right screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/afig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-3: Viewing the documentation for the sum() function*'
  prefs: []
  type: TYPE_NORMAL
- en: This documentation gives us the definition of the `sum()` function and some
    of its uses. The `sum()` function takes a vector’s values and adds them all together.
    The documentation says it takes `...` as an argument, which means it can accept
    any number of values. Usually these values will be a vector of numbers, but they
    can consist of multiple vectors, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation also lists an *optional argument*: `na.rm = FALSE`. Optional
    arguments are arguments that you don’t have to pass in to the function for it
    to work; if you don’t pass an optional argument in, R will use the argument’s
    default value. In the case of `na.rm`, which automatically removes any missing
    values, the default value, after the equal sign, is `FALSE`. That means that,
    by default, `sum()` won’t remove missing values.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Basic Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here are some of R’s most important functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**The length() and nchar() Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `length()` function will return the length of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since there are three elements in this vector, the `length()` function returns
    `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because everything in R is a vector, you can use the `length()` function to
    find the length of anything—even a string, like `“doggies”`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: R tells us that `“doggies”` is a vector containing one string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we had two strings, `“doggies”` and `“cats”`, we’d get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the number of characters in a string, we use the `nchar()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if we use `nchar()` on the `c(“doggies”,”cats”)` vector, R returns
    a new vector containing the number of characters in each string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**The sum(), cumsum(), and diff() Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `sum()` function takes a vector of numbers and adds all those numbers together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw in the documentation in the previous section, `sum()` takes `...`
    as its argument, which means it can accept any number of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, no matter how many vectors we provide, `sum()` adds them up
    as though they were a single vector of integers. If you wanted to sum up multiple
    vectors, you’d call `sum()` on them each separately.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, also, that the `sum()` function takes the optional argument `na.rm`,
    which by default is set to `FALSE`. The `na.rm` argument determines if `sum()`
    removes `NA` values or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we leave `na.rm` set to `FALSE`, here’s what happens if we try to use `sum()`
    on a vector with a missing value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw when `NA` was introduced, adding a value to an `NA` value results
    in `NA`. If we’d like R to give us a number as an answer instead, we can tell
    `sum()` to remove `NA` values by setting `na.rm = TRUE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cumsum()` function takes a vector and calculates its *cumulative sum*—a
    vector of the same length as the input that replaces each number with the sum
    of the numbers that come before it (including that number). Here’s an example
    in code to make this clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `diff()` function takes a vector and subtracts each number from the number
    that precedes it in the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the result of the `diff()` function contains one fewer element than
    the original vector did. That’s because nothing gets subtracted from the first
    value in the vector.
  prefs: []
  type: TYPE_NORMAL
- en: '**The : operator and the seq() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, rather than manually listing each element of a vector, we’d prefer to
    generate vectors automatically. To automatically create a vector of whole numbers
    in a certain range, we can use the `:` operator to separate the start and end
    of the range. R can even figure out if you want to count up or down (the `c()`
    wrapping this operator is not strictly necessary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When you use `:`, R will count from the first value to the last.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we’ll want to count by something other than increments of one. The
    `seq()` function allows us to create vectors of a sequence of values that increment
    by a specified amount. The arguments to `seq()` are, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: The start of the sequence
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The end of the sequence
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The amount to increment the sequence by
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are some examples of using `seq()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to count down to a certain value using the `seq()` function, we
    use a minus value as our increment, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**The ifelse() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `ifelse()` function tells R to take one of two actions based on some condition.
    This function can be a bit confusing if you’re used to the normal `if ... else`
    control structure in other languages. In R, it takes the following three arguments
    (in order):'
  prefs: []
  type: TYPE_NORMAL
- en: A statement about a vector that may be either true or false of its values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens in the case that the statement is true
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens in the case that the statement is false
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ifelse()` function operates on entire vectors at once. When it comes to
    vectors containing a single value, its use is pretty intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here the statement is that 2 is smaller than 3, and we ask R to output `“small”`
    if it is, and `“too big”` if it isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a vector `x` that contains multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ifelse()` function will return a value for each element in the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use vectors in the results arguments for the `ifelse()`. Suppose
    that, in addition to our `x` vector, we had another vector, `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to generate a new list that contains the greatest value from `x` and
    `y` for each element in the vector. We could use `ifelse()` to solve this very
    simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can see R has compared the values in `x` to the respective value in `y`
    and outputs the largest of the two for each element.
  prefs: []
  type: TYPE_NORMAL
- en: '**Random Sampling**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll often use R to randomly sample values. This allows us to have the computer
    pick a random number or value for us. We use this sample to simulate activities
    like flipping a coin, playing “rock, paper, scissors,” or picking a number between
    1 and 100.
  prefs: []
  type: TYPE_NORMAL
- en: '***The runif() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One way to randomly sample values is with the function `runif()`, short for
    “random uniform,” which takes a required argument `n` and gives that many samples
    in the range 0 to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this function with `ifelse()` to generate a value `A` 20 percent
    of the time. In this case we’ll use `runif(5)` to create five random values between
    0 and 1\. Then if the value is less than 0.2, we’ll return `“A”`; otherwise, we’ll
    return `“B”`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the numbers we’re generating are random, we’ll get a different result
    each time we run the `ifelse()` function. Here are some possible outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `runif()` function can take optional second and third arguments, which
    are the minimum and maximum values of the range to be uniformly sampled from.
    By default, the function uses the range between 0 and 1 inclusive, but you can
    set the range to be whatever you’d like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '***The rnorm() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also sample from a normal distribution using the `rnorm()` function,
    which we’ll discuss in more depth in the book (the normal distribution is covered
    in [Chapter 12](ch12.xhtml#ch12)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: By default, `rnorm()` samples from a normal distribution with a mean of 0 and
    standard deviation of 1, as is the case in this example. For readers unfamiliar
    with the normal distribution, this means that samples will have a “bell-shaped”
    distribution around 0, with most samples being close to 0 and very few being less
    than –3 or greater than 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rnorm()` function has two optional arguments, `mean` and `sd`, which allow
    you to set a different mean and standard deviation, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In statistics, sampling from a normal distribution is often more common than
    sampling from a uniform distribution, so `rnorm()` comes in quite handy.
  prefs: []
  type: TYPE_NORMAL
- en: '***The sample() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, we want to sample from something other than just a well-studied
    distribution. Suppose you have a drawer containing socks of many colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to simulate the act of randomly picking any two socks, you could
    use R’s `sample()` function, which takes as arguments a vector of values and the
    number of elements to sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sample()` function behaves as though we’ve picked two random socks out
    of the drawer—without putting any back. If we sample five socks, we’ll get all
    of the socks we originally had in the drawer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'That means that if we try to take six socks from the drawer where there are
    only five available socks, we’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If we want to both sample and “put the socks back,” we can set the optional
    argument `replace` to `TRUE`. Now, each time we sample a sock, we put it back
    in the drawer. This allows us to sample more socks than are in the drawer. It
    also means the distribution of socks in the drawer never changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: With these simple sampling tools, you can run surprisingly sophisticated simulations
    in R that save you from doing a lot of math.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using set.seed() for Predictable Random Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The “random numbers” generated by R aren’t truly random numbers. As in all
    programming languages, random numbers are generated by a *pseudorandom number
    generator*, which takes a *seed value* and uses that to create a sequence of numbers
    that are random enough for most purposes. The seed value sets the initial state
    of the random number generator and determines which numbers will come next in
    the sequence. In R, we can manually set this seed using the `set.seed()` function.
    Setting the seed is extremely useful for cases when we want to use the same random
    results again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we used the same seed twice with the `runif()` function,
    it generated the same set of supposedly random values. The main benefit of using
    `set.seed()` is making the results reproducible. This can make tracking down bugs
    in programs that involve sampling much easier, since the results don’t change
    each time the program is run.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Your Own Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes it’s helpful to write our own functions for specific operations we’ll
    have to perform repeatedly. In R, we can define functions using the keyword `function`
    (a *keyword* in a programming language is simply a special word reserved by the
    programming language for a specific use).
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the definition of a function that takes a single argument, `val`—which
    here stands for the value the user will input to the function—and then doubles
    `val` and cubes it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we’ve defined our function, we can use it, just like R’s built-in functions.
    Here’s our `double_then_cube()` function applied to the number 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, because everything we did to define our function is *vectorized* (that
    is, all values work on vectors of values), our function will work on vectors as
    well as single values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define functions that take more than one argument as well. The `sum_then_square()`
    function, defined here, adds two arguments together, then squares the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'By including the two arguments `(x,y)` in the function definition, we’re telling
    R the `sum_then_square()` function expects two arguments. Now we can use our new
    function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define functions that require multiple lines. In R, when a function
    is called it will always return the result of the calculation on the final line
    of the function definition. That means we could have rewritten `sum_then_square()`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Typically, when you write functions, you’ll want to write them in an R script
    file so you can save them and reuse them later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Basic Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In R, we can quickly generate plots of data very easily. Though R has an extraordinary
    plotting library called `ggplot2`, which contains many useful functions for generating
    beautiful plots, we’ll restrict ourselves to R’s base plotting functions for now,
    which are plenty useful on their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show how plotting works, we’ll create two vectors of values, our `xs` and
    our `ys`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use these vectors as arguments to the `plot()` function, which
    will plot our data for us. The `plot()` function takes two arguments: the values
    of the plot’s points on the x-axis and the values of those points on the y-axis,
    in that order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This function should generate the plot shown in [Figure A-4](app01.xhtml#app01fig04)
    in the bottom-left window of RStudio.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/afig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-4: A simple plot created with R’s plot() function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This plot shows the relationship between our `xs` values and their corresponding
    `ys` values. If we return to the function, we can give this plot a title using
    the optional `main` argument. We can also change the x- and y-axis labels with
    the `xlab` and `ylab` arguments, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The new labels should show up as they appear in [Figure A-5](app01.xhtml#app01fig05).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/afig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-5: Changing the plot title and labels with the plot() function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also change the plot’s type using the `type` argument. The first kind
    of plot we generated is called a *point plot*, but if we wanted to make a line
    plot, which draws a line through each value, we could set `type=”l”`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It would then look like [Figure A-6](app01.xhtml#app01fig06).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/afig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-6: A line plot generated with R’s plot() function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can do both! An R function called `lines()` can add lines to an existing
    plot. It takes most of the same arguments as `plot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure A-7](app01.xhtml#app01fig07) shows the plot this function would generate.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/afig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-7: Adding lines to an existing plot with R’s lines() function*'
  prefs: []
  type: TYPE_NORMAL
- en: There are many more amazing ways to use R’s basic plots, and you can consult
    `?plot` for more information on them. However, if you want to create truly beautiful
    plots in R, you should research the `ggplot2` library (*[https://ggplot2.tidyverse.org/](https://ggplot2.tidyverse.org/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise: Simulating a Stock Price**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s put everything we’ve learned together to create a simulated stock
    ticker! People often model stock prices using the cumulative sum of normally distributed
    random values. To start, we’ll simulate stock movement for a period of time by
    generating a sequence of values from 1 to 20, incrementing by 1 each time using
    the `seq()` function. We’ll call the vector representing the period of time `t.vals`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now `t.vals` is a vector containing the sequence of numbers from 1 to 20 incremented
    by 1\. Next, we’ll create some simulated prices by taking the cumulative sum of
    a normally distributed value for each time in your `t.vals`. To do this we’ll
    use `rnorm()` to sample the number of values equal to the length of `t.vals`.
    Then we’ll use `cumsum()` to calculate the cumulative sum of this vector of values.
    This will represent the idea of a price moving up or down based on random motion;
    less extreme movements are more common than more extreme ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can plot all these values to see how they look! We’ll use both the
    `plot()` and `lines()` functions, and label the axes according to what they represent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `plot()` and `lines()` functions should generate the plot shown in [Figure
    A-8](app01.xhtml#app01fig08).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/afig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-8: The plot generated for our simulated stock ticker*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This appendix should cover enough R to give you a grasp of the examples in this
    book. I recommend following along with the book’s chapters, then playing around
    by modifying the code examples to learn more. R also has some great online documentation
    if you want to take your experimentation further.
  prefs: []
  type: TYPE_NORMAL
