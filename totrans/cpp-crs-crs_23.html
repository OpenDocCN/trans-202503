<html><head></head><body>
<h2 class="h2" id="ch20"><span epub:type="pagebreak" id="page_663"/><strong><span class="big">20</span><br/>NETWORK PROGRAMMING WITH BOOST ASIO</strong></h2>&#13;
<p class="quote"><em>Anyone who has lost track of time when using a computer knows the propensity to dream, the urge to make dreams come true, and the tendency to miss lunch.<br/>—Tim Berners-Lee</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">Boost Asio is a library for low-level I/O programming. In this chapter, you’ll learn about Boost Asio’s basic networking facilities, which enable programs to interact easily and efficiently with network resources. Unfortunately, the stdlib doesn’t contain a network-programming library as of C++17. For this reason, Boost Asio plays a central role in many C++ programs with a networking component.</p>&#13;
<p class="indent">Although Boost Asio is the primary choice for C++ developers who want to incorporate cross-platform, high-performance I/O into their programs, it’s a notoriously complicated library. This complication combined with an unfamiliarity with low-level network programming might be too overwhelming for newcomers. If you find this chapter obtuse or if you don’t need information on network programming, you can skip this chapter.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_664"/><em>Boost Asio also contains facilities for I/O with serial ports, streams, and some operating system–specific objects. In fact, the name is derived from the phrase “asynchronous I/O.” See the Boost Asio documentation for more information.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch20lev1sec1"><strong>The Boost Asio Programming Model</strong></h3>&#13;
<p class="noindent">In the Boost programming model, an <em>I/O context object</em> abstracts the operating system interfaces that handle asynchronous data processing. This object is a registry for <em>I/O objects</em>, which initiate asynchronous operations. Each object knows its corresponding service, and the context object mediates the connection.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>All Boost Asio classes appear in the <span class="codeitalic">&lt;boost/asio.hpp&gt;</span> convenience header.</em></p>&#13;
</div>&#13;
<p class="indent">Boost Asio defines a single service object, <code>boost::asio::io_context</code>. Its constructor takes an optional integer argument called the <em>concurrency hint</em>, which is the number of threads the <code>io_context</code> should allow to run concurrently. For example, on an eight-core machine, you might construct an <code>io_context</code> as follows:</p>&#13;
<pre>boost::asio::io_context io_context{ 8 };</pre>&#13;
<p class="indent">You’ll pass the same <code>io_context</code> object into the constructors of your I/O objects. Once you’ve set up all your I/O objects, you’ll call the <code>run</code> method on the <code>io_context</code>, which will block until all pending I/O operations complete.</p>&#13;
<p class="indent">One of the simplest I/O objects is the <code>boost::asio::steady_timer</code>, which you can use to schedule tasks. Its constructor accepts an <code>io_context</code> object and an optional <code>std::chrono::time_point</code> or <code>std::chrono_duration</code>. For example, the following constructs a <code>steady_timer</code> that expires in three seconds:</p>&#13;
<pre>boost::asio::steady_timer timer{&#13;
  io_context, std::chrono::steady_clock::now() + std::chrono::seconds{ 3 }&#13;
};</pre>&#13;
<p class="indent">You can wait on the timer with a blocking or a non-blocking call. To block the current thread, you use the timer’s <code>wait</code> method. The result is essentially similar to using <code>std::this_thread::sleep_for</code>, which you learned about in “Chrono” on <a href="ch12.xhtml#page_387">page 387</a>. To wait asynchronously, you use the timer’s <code>async_wait</code> method. This accepts a function object referred to as a <em>callback</em>. The operating system will invoke the function object once it’s time for the thread to wake up. Due to complications arising from modern operating systems, this might or might not be due to the timer’s expiring.</p>&#13;
<p class="indent">Once a timer expires, you can create another timer if you want to perform an additional wait. If you wait on an expired timer, it will return immediately. This is probably not what you intend to do, so make sure you wait only on unexpired timers.</p>&#13;
<p class="indent">To check whether the timer has expired, the function object must accept a <code>boost::system::error_code</code>. The <code>error_code</code> class is a simple class that represents <span epub:type="pagebreak" id="page_665"/>operating system–specific errors. It converts implicitly to <code>bool</code> (<code>true</code> if it represents an error condition; <code>false</code> otherwise). If the callback’s <code>error_code</code> evaluates to <code>false</code>, the timer expired.</p>&#13;
<p class="indent">Once you enqueue an asynchronous operation using <code>async_wait</code>, you’ll call the <code>run</code> method on your <code>io_context</code> object because this method blocks until all asynchronous operations are complete.</p>&#13;
<p class="indent"><a href="ch20.xhtml#ch20ex01">Listing 20-1</a> illustrates how to construct and use timers for blocking and non-blocking waits.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;chrono&gt;&#13;
&#13;
boost::asio::steady_timer make_timer(boost::asio::io_context&amp; io_context) { <span class="ent">➊</span>&#13;
  return boost::asio::steady_timer{&#13;
          io_context,&#13;
          std::chrono::steady_clock::now() + std::chrono::seconds{ 3 }&#13;
  };&#13;
}&#13;
&#13;
int main() {&#13;
  boost::asio::io_context io_context; <span class="ent">➋</span>&#13;
&#13;
  auto timer1 = make_timer(io_context); <span class="ent">➌</span>&#13;
  std::cout &lt;&lt; "entering steady_timer::wait\n";&#13;
  timer1.wait(); <span class="ent">➍</span>&#13;
  std::cout &lt;&lt; "exited steady_timer::wait\n";&#13;
&#13;
  auto timer2 = make_timer(io_context); <span class="ent">➎</span>&#13;
  std::cout &lt;&lt; "entering steady_timer::async_wait\n";&#13;
  timer2.async_wait([] (const boost::system::error_code&amp; error) { <span class="ent">➏</span>&#13;
    if (!error) std::cout &lt;&lt; "&lt;&lt;callback function&gt;&gt;\n";&#13;
  });&#13;
  std::cout &lt;&lt; "exited steady_timer::async_wait\n";&#13;
  std::cout &lt;&lt; "entering io_context::run\n";&#13;
  io_context.run(); <span class="ent">➐</span>&#13;
  std::cout &lt;&lt; "exited io_context::run\n";&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">entering steady_timer::wait</span>&#13;
<span class="color1">exited steady_timer::wait</span>&#13;
<span class="color1">entering steady_timer::async_wait</span>&#13;
<span class="color1">exited steady_timer::async_wait</span>&#13;
<span class="color1">entering io_context::run</span>&#13;
<span class="color1">&lt;&lt;callback function&gt;&gt;</span>&#13;
<span class="color1">exited io_context::run</span></pre>&#13;
<p class="listing"><a id="ch20ex01"/><em>Listing 20-1: A program using <code>boost::asio::steady_timer</code> for synchronous and asynchronous waiting</em></p>&#13;
<p class="indent">You define the <code>make_timer</code> function for building a <code>steady_timer</code> that expires in three seconds <span class="ent">➊</span>. Within <code>main</code>, you initialize your program’s <code>io_context</code> <span class="ent">➋</span> and construct your first timer from <code>make_timer</code> <span class="ent">➌</span>. When you call <code>wait</code> on this <span epub:type="pagebreak" id="page_666"/>timer <span class="ent">➍</span>, the thread blocks for three seconds before proceeding. Next, you construct another timer with <code>make_timer</code> <span class="ent">➎</span>, and then you invoke <code>async_wait</code> with a lambda that prints <code>&lt;&lt;callback_function&gt;&gt;</code> when the timer expires <span class="ent">➏</span>. Finally, you invoke <code>run</code> on your <code>io_context</code> to begin processing operations <span class="ent">➐</span>.</p>&#13;
<h3 class="h3" id="ch20lev1sec2"><strong>Network Programming with Asio</strong></h3>&#13;
<p class="noindent">Boost Asio contains facilities for performing network-based I/O over several important network protocols. Now that you know the basic usage of <code>io_context</code> and how to enqueue asynchronous I/O operations, you can explore how to perform more involved kinds of I/O. In this section, you’ll extend what you learned about waiting for timers and employ Boost Asio’s network I/O facilities. By the end of this chapter, you’ll know how to build programs that communicate over a network.</p>&#13;
<h4 class="h4" id="ch20lev2sec1"><strong><em>The Internet Protocol Suite</em></strong></h4>&#13;
<p class="noindent">The Internet Protocol (IP) is the primary protocol for ferrying data across networks. Each participant in an IP network is called a <em>host</em>, and each host gets an IP address to identify it. IP addresses come in two versions: IPv4 and IPv6. An IPv4 address is 32 bits, and an IPv6 address is 128 bits.</p>&#13;
<p class="indent">The Internet Control Message Protocol (ICMP) is used by network devices to send information that supports operation of an IP network. The ping and traceroute programs use ICMP messages to query a network. Typically, end user applications don’t need to interface with ICMP directly.</p>&#13;
<p class="indent">To send data across an IP network, you typically use either the Transmission Control Protocol (TCP) or User Datagram Protocol (UDP). In general, you use TCP when you need to be sure that data arrives at its destination, and you use UDP when you need to be sure that data transits quickly. TCP is a connection-oriented protocol where receivers acknowledge that they’ve received messages intended for them. UDP is a simple, connectionless protocol that has no built-in reliability.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You might be wondering what connection means in the TCP/UDP context or thinking that a “connectionless” protocol seems absurd. Here a connection means establishing a channel between two participants in a network that guarantees delivery and order of messages. Those participants perform a handshake to establish a connection, and they have a mechanism for informing each other that they want to close the connection. In a connectionless protocol, a participant sends a packet to another participant without establishing a channel first.</em></p>&#13;
</div>&#13;
<p class="indent">With TCP and UDP, network devices connect to each other using <em>ports</em>. A port is an integer ranging from 0 to 65,535 (2 bytes) that specifies a particular service running on a given network device. This way, a single device can run multiple services and each can be addressed separately. When one device, called a <em>client</em><em>,</em> initiates communication with another device, called a <em>server</em>, the client specifies which port it wants to connect to. When you pair a device’s IP address with a port number, the result is called a <em>socket</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_667"/>For example, a device with IP address 10.10.10.100 could serve a web page by binding a web server application to port 80. This creates a server socket at 10.10.10.100:80. Next, a device with IP address 10.10.10.200 launches a web browser, which opens a “random high port,” such as 55123. This creates a client socket at 10.10.10.200:55123. The client then connects to the server by creating a TCP connection between the client socket and the server socket. Many other processes could be running on either or both devices with many other network connections simultaneously.</p>&#13;
<p class="indent">The Internet Assigned Numbers Authority (IANA) maintains a list of assigned numbers to standardize the ports that certain kinds of services use (the list is available at <em><a href="https://www.iana.org/">https://www.iana.org/</a></em>). <a href="ch20.xhtml#ch20tab01">Table 20-1</a> provides a few commonly used protocols on this list.</p>&#13;
<p class="tabcap" id="ch20tab01"><strong>Table 20-1:</strong> Well-Known Protocols Assigned by IANA</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Port</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>TCP</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>UDP</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Keyword</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">7</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">echo</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Echo Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">13</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">daytime</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Daytime Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">21</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">ftp</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">File Transfer Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">22</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">ssh</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Secure Shell Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">23</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">telnet</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Telnet Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">25</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">smtp</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Simple Mail Transfer Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">53</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">domain</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Domain Name System</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">80</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">http</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Hypertext Transfer Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">110</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">pop3</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Post Office Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">123</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">ntp</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Network Time Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">143</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">imap</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Internet Message Access Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">179</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"/>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">bgp</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Border Gateway Protocol</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">194</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"/>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">irc</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Internet Relay Chat</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">443</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"/>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">https</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Hypertext Transfer Protocol (Secure)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Boost Asio supports network I/O over ICMP, TCP, and UDP. For brevity, this chapter only discusses TCP because the Asio classes involved in all three protocols are so similar.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you’re unfamiliar with network protocols, <em>The TCP/IP Guide</em> by Charles M. Kozierok is a definitive reference.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch20lev2sec2"><strong><em>Hostname Resolution</em></strong></h4>&#13;
<p class="noindent">When a client wants to connect to a server, it needs the server’s IP address. In some scenarios, the client might already have this information. In others, the client might have only a service name. The process of converting a service name to an IP address is called <em>hostname resolution</em>. Boost Asio contains <span epub:type="pagebreak" id="page_668"/>the <code>boost::asio::ip::tcp::resolver</code> class to perform hostname resolution. To construct a resolver, you pass an <code>io_context</code> instance as the only constructor parameter, as in the following:</p>&#13;
<pre>boost::asio::ip::tcp::resolver my_resolver{ my_io_context };</pre>&#13;
<p class="indent">To perform hostname resolution, you use the <code>resolve</code> method, which accepts at least two <code>string_view</code> arguments: the hostname and the service. You can provide either a keyword or a port number for service (refer to <a href="ch20.xhtml#ch20tab01">Table 20-1</a> for some example keywords). The <code>resolve</code> method returns a range of <code>boost::asio::ip::tcp::resolver::basic_resolver_entry</code> objects, which expose several useful methods:</p>&#13;
<ul>&#13;
<li class="noindent"><code>endpoint</code> gets the IP address and port.</li>&#13;
<li class="noindent"><code>host_name</code> gets the hostname.</li>&#13;
<li class="noindent"><code>service_name</code> gets the name of the service associated with this port.</li>&#13;
</ul>&#13;
<p class="indent">If the resolution fails, <code>resolve</code> throws a <code>boost::system::system_error</code>. Alternatively, you can pass a <code>boost::system::error_code</code> reference, which receives the error in lieu of throwing an exception. For example, <a href="ch20.xhtml#ch20ex02">Listing 20-2</a> determines the IP address and port for the No Starch Press web server using Boost Asio.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;boost/asio.hpp&gt;&#13;
&#13;
int main() {&#13;
  boost::asio::io_context io_context; <span class="ent">➊</span>&#13;
  boost::asio::ip::tcp::resolver resolver{ io_context }; <span class="ent">➋</span>&#13;
  boost::system::error_code ec;&#13;
  for(auto&amp;&amp; result : resolver.resolve("www.nostarch.com", "http", ec)) { <span class="ent">➌</span>&#13;
    std::cout &lt;&lt; result.service_name() &lt;&lt; " " <span class="ent">➍</span>&#13;
              &lt;&lt; result.host_name() &lt;&lt; " " <span class="ent">➎</span>&#13;
              &lt;&lt; result.endpoint() <span class="ent">➏</span>&#13;
              &lt;&lt; std::endl;&#13;
  }&#13;
  if(ec) std::cout &lt;&lt; "Error code: " &lt;&lt; ec &lt;&lt; std::endl; <span class="ent">➐</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">http <a href="http://www.nostarch.com">www.nostarch.com</a> 104.20.209.3:80</span>&#13;
<span class="color1">http <a href="http://www.nostarch.com">www.nostarch.com</a> 104.20.208.3:80</span></pre>&#13;
<p class="listing"><a id="ch20ex02"/><em>Listing 20-2: Blocking hostname resolution with Boost Asio</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Your results might vary depending on where the No Starch Press web servers reside in IP space.</em></p>&#13;
</div>&#13;
<p class="indent">You initialize an <code>io_context</code> <span class="ent">➊</span> and a <code>boost::asio::ip::tcp::resolver</code> <span class="ent">➋</span>. Within a range-based <code>for</code> loop, you iterate over each <code>result</code> <span class="ent">➌</span> and extract the <code>service_name</code> <span class="ent">➍</span>, the <code>host_name</code> <span class="ent">➎</span>, and the <code>endpoint</code> <span class="ent">➏</span>. If <code>resolve</code> encounters an error, you print it to stdout <span class="ent">➐</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_669"/>You can perform asynchronous hostname resolution using the <code>async_resolve</code> method. As with <code>resolve</code>, you pass a hostname and a service as the first two arguments. Additionally, you provide a callback function object that accepts two arguments: a <code>system_error_code</code> and a range of <code>basic_resolver_entry</code> objects. <a href="ch20.xhtml#ch20ex03">Listing 20-3</a> illustrates how to refactor <a href="ch20.xhtml#ch20ex02">Listing 20-2</a> to use asynchronous hostname resolution instead.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;boost/asio.hpp&gt;&#13;
&#13;
int main() {&#13;
  boost::asio::io_context io_context;&#13;
  boost::asio::ip::tcp::resolver resolver{ io_context };&#13;
  resolver.async_resolve("www.nostarch.com", "http", <span class="ent">➊</span>&#13;
    [](boost::system::error_code ec, const auto&amp; results) { <span class="ent">➋</span>&#13;
      if (ec) { <span class="ent">➌</span>&#13;
        std::cerr &lt;&lt; "Error:" &lt;&lt; ec &lt;&lt; std::endl;&#13;
        return; <span class="ent">➍</span>&#13;
      }&#13;
      for (auto&amp;&amp; result : results) { <span class="ent">➎</span>&#13;
        std::cout &lt;&lt; result.service_name() &lt;&lt; " "&#13;
                  &lt;&lt; result.host_name() &lt;&lt; " "&#13;
                  &lt;&lt; result.endpoint() &lt;&lt; " "&#13;
                  &lt;&lt; std::endl; <span class="ent">➏</span>&#13;
      }&#13;
    }&#13;
  );&#13;
  io_context.run(); <span class="ent">➐</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">http <a href="http://www.nostarch.com">www.nostarch.com</a> 104.20.209.3:80</span>&#13;
<span class="color1">http <a href="http://www.nostarch.com">www.nostarch.com</a> 104.20.208.3:80</span></pre>&#13;
<p class="listing"><a id="ch20ex03"/><em>Listing 20-3: Refactoring <a href="ch20.xhtml#ch20ex02">Listing 20-2</a> to use <code>async_resolve</code></em></p>&#13;
<p class="indent">The setup is identical to <a href="ch20.xhtml#ch20ex02">Listing 20-2</a> until you invoke <code>async_resolve</code> on your resolver <span class="ent">➊</span>. You pass the same hostname and service as before, but you add a callback argument that accepts the obligatory parameters <span class="ent">➋</span>. Within the body of the callback lambda, you check for an error condition <span class="ent">➌</span>. If one exists, you print a friendly error message and <code>return</code> <span class="ent">➍</span>. In the error-free case, you iterate over the results as before <span class="ent">➎</span>, printing the <code>service_name</code>, <code>host_name</code>, and <code>endpoint</code> <span class="ent">➏</span>. As with the timer, you need to invoke <code>run</code> on the <code>io_context</code> to give the asynchronous operations the opportunity to complete <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch20lev2sec3"><strong><em>Connecting</em></strong></h4>&#13;
<p class="noindent">Once you’ve obtained a range of endpoints either through hostname resolution or through constructing one on your own, you’re ready to make a connection.</p>&#13;
<p class="indent">First, you’ll need a <code>boost::asio::ip::tcp::socket</code>, a class that abstracts the underlying operating system’s socket and presents it for use in Asio. The socket takes an <code>io_context</code> as an argument.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_670"/>Second, you’ll need to make a call to the <code>boost::asio::connect</code> function, which accepts a <code>socket</code> representing the endpoint you want to connect with as its first argument and an <code>endpoint</code> range as its second argument. You can provide an <code>error_code</code> reference as an optional third argument; otherwise, <code>connect</code> will throw a <code>system_error</code> exception if an error occurs. If successful, <code>connect</code> returns a single <code>endpoint</code>, the <code>endpoint</code> in the input range to which it successfully connected. After this point, the <code>socket</code> object represents a real socket in your system’s environment.</p>&#13;
<p class="indent"><a href="ch20.xhtml#ch20ex04">Listing 20-4</a> illustrates how to connect to No Starch Press’s web server.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;boost/asio.hpp&gt;&#13;
&#13;
int main() {&#13;
  boost::asio::io_context io_context;&#13;
  boost::asio::ip::tcp::resolver resolver{ io_context }; <span class="ent">➊</span>&#13;
  boost::asio::ip::tcp::socket socket{ io_context }; <span class="ent">➊</span>&#13;
  try  {&#13;
    auto endpoints = resolver.resolve("www.nostarch.com", "http"); <span class="ent">➌</span>&#13;
    const auto connected_endpoint = boost::asio::connect(socket, endpoints); <span class="ent">➍</span>&#13;
    std::cout &lt;&lt; connected_endpoint; <span class="ent">➎</span>&#13;
  } catch(boost::system::system_error&amp; se) {&#13;
    std::cerr &lt;&lt; "Error: " &lt;&lt; se.what() &lt;&lt; std::endl; <span class="ent">➏</span>&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">104.20.209.3:80 <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch20ex04"/><em>Listing 20-4: Connecting to the No Starch web server</em></p>&#13;
<p class="indent">You construct a <code>resolver</code> <span class="ent">➊</span> as in <a href="ch20.xhtml#ch20ex03">Listing 20-3</a>. In addition, you initialize a <code>socket</code> with the same <code>io_context</code> <span class="ent">➋</span>. Next, you invoke the <code>resolve</code> method to obtain every <code>endpoint</code> associated with <em><a href="http://www.nostarch.com">www.nostarch.com</a></em> at port 80 <span class="ent">➌</span>. Recall that each <code>endpoint</code> is an IP address and a port corresponding to the host you resolved. In this case, <code>resolve</code> used the domain name system to determine that <em><a href="http://www.nostarch.com">www.nostarch.com</a></em> at port 80 resides at the IP address 104.20.209.3. You then invoke <code>connect</code> using your socket and endpoints <span class="ent">➍</span>, which returns the endpoint to which <code>connect</code> successfully connected <span class="ent">➎</span>. In the event of an error, <code>resolve</code> or <code>connect</code> would throw an exception, which you would catch and print to stderr <span class="ent">➏</span>.</p>&#13;
<p class="indent">You can also connect asynchronously with <code>boost::asio::async_connect</code>, which accepts the same two arguments as <code>connect</code>: a <code>socket</code> and an <code>endpoint</code> range. The third argument is a function object acting as the callback, which must accept an <code>error_code</code> as its first argument and an <code>endpoint</code> as its second argument. <a href="ch20.xhtml#ch20ex05">Listing 20-5</a> illustrates how to connect asynchronously.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;boost/asio.hpp&gt;&#13;
&#13;
int main() {&#13;
  boost::asio::io_context io_context;&#13;
<span epub:type="pagebreak" id="page_671"/>  boost::asio::ip::tcp::resolver resolver{ io_context };&#13;
  boost::asio::ip::tcp::socket socket{ io_context };&#13;
  boost::asio::async_connect(socket, <span class="ent">➊</span>&#13;
    resolver.resolve("www.nostarch.com", "http"), <span class="ent">➋</span>&#13;
    [] (boost::system::error_code ec, const auto&amp; endpoint){ <span class="ent">➌</span>&#13;
      std::cout &lt;&lt; endpoint; <span class="ent">➍</span>&#13;
  });&#13;
  io_context.run(); <span class="ent">➎</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">104.20.209.3:80 <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch20ex05"/><em>Listing 20-5: Connecting to the No Starch web server asynchronously</em></p>&#13;
<p class="indent">The setup is exactly as in <a href="ch20.xhtml#ch20ex04">Listing 20-4</a> except you replace <code>connect</code> with <code>async_connect</code> and pass the same first <span class="ent">➊</span> and second <span class="ent">➋</span> arguments. The third argument is your callback function object <span class="ent">➌</span> inside of which you print the endpoint to stdout <span class="ent">➍</span>. As with all asynchronous Asio programs, you make a call to <code>run</code> on your <code>io_context</code> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch20lev2sec4"><strong><em>Buffers</em></strong></h4>&#13;
<p class="noindent">Boost Asio provides several buffer classes. A <em>buffer</em> (or <em>data buffer</em>) is memory that stores transient data. The Boost Asio buffer classes form the interface for all I/O operations. Before you can do anything with the network connections you make, you’ll need an interface for reading and writing data. For this, you’ll need just three buffer types:</p>&#13;
<ul>&#13;
<li class="noindent"><code>boost::asio::const_buffer</code> holds a buffer that cannot be modified once you’ve constructed it.</li>&#13;
<li class="noindent"><code>boost::asio::mutable_buffer</code> holds a buffer that can be modified after construction.</li>&#13;
<li class="noindent"><code>boost::asio::streambuf</code> holds an automatically resizable buffer based on <code>std::streambuf.</code></li>&#13;
</ul>&#13;
<p class="indent">All three buffer classes provide two important methods for accessing their underlying data: <code>data</code> and <code>size</code>.</p>&#13;
<p class="indent">The <code>mutable_buffer</code> and <code>const_buffer</code> classes’ <code>data</code> methods return a pointer to the first element in the underlying data sequence, and their <code>size</code> methods return the number of elements in that sequence. The elements are contiguous. Both buffers provide default constructors, which initialize an empty buffer, as <a href="ch20.xhtml#ch20ex06">Listing 20-6</a> illustrates.</p>&#13;
<pre>#include &lt;boost/asio.hpp&gt;&#13;
&#13;
TEST_CASE("const_buffer default constructor") {&#13;
  boost::asio::const_buffer cb; <span class="ent">➊</span>&#13;
  REQUIRE(cb.size() == 0); <span class="ent">➋</span>&#13;
}&#13;
&#13;
TEST_CASE("mutable_buffer default constructor") {&#13;
<span epub:type="pagebreak" id="page_672"/>  boost::asio::mutable_buffer mb; <span class="ent">➌</span>&#13;
  REQUIRE(mb.size() == 0); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch20ex06"/><em>Listing 20-6: Default constructing <code>const_buffer</code> and <code>mutable_buffer</code> yields empty buffers.</em></p>&#13;
<p class="indent">Using the default constructors <span class="ent">➊</span><span class="ent">➌</span>, you build empty buffers that have zero <code>size</code> <span class="ent">➋</span><span class="ent">➍</span>.</p>&#13;
<p class="indent">Both <code>mutable_buffer</code> and <code>const_buffer</code> provide constructors that accept a <code>void*</code> and a <code>size_t</code> corresponding to the data you want to wrap. Note that these constructors don’t take ownership of the pointed-to memory, so <em>you must ensure that the storage duration of that memory is at least as long as the lifetime of the buffer you’re constructing</em>. This is a design decision that gives you, as the Boost Asio user, maximum flexibility. Unfortunately, it also leads to potentially nasty errors. Failure to properly manage the lifetimes of buffers and the objects they point to will result in undefined behavior.</p>&#13;
<p class="indent"><a href="ch20.xhtml#ch20ex07">Listing 20-7</a> illustrates how to construct buffers using the pointer-based constructor.</p>&#13;
<pre>#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
TEST_CASE("const_buffer constructor") {&#13;
  boost::asio::const_buffer cb{ "Blessed are the cheesemakers.", 7 }; <span class="ent">➊</span>&#13;
&#13;
  REQUIRE(cb.size() == 7); <span class="ent">➋</span>&#13;
  REQUIRE(*static_cast&lt;const char*&gt;(cb.data()) == 'B'); <span class="ent">➌</span>&#13;
}&#13;
&#13;
TEST_CASE("mutable_buffer constructor") {&#13;
  std::string proposition{ "Charity for an ex-leper?" };&#13;
  boost::asio::mutable_buffer mb{ proposition.data(), proposition.size() }; <span class="ent">➍</span>&#13;
&#13;
  REQUIRE(mb.data() == proposition.data()); <span class="ent">➎</span>&#13;
  REQUIRE(mb.size() == proposition.size()); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch20ex07"/><em>Listing 20-7: Constructing a <code>const_buffer</code> and a <code>mutable_buffer</code> using the pointer-based constructor</em></p>&#13;
<p class="indent">In the first test, you construct a <code>const_buffer</code> using a C-style string and a fixed length of <code>7</code> <span class="ent">➊</span>. This fixed length is smaller than the length of the string literal <code>Blessed are the cheesemakers.</code>, so this buffer refers to <code>Blessed</code> rather than the entire string. This illustrates that you can select a subset of an array (just as with <code>std::string_view</code>, which you learned about in “String View” on <a href="ch15.xhtml#page_500">page 500</a>). The resulting buffer has <code>size 7</code> <span class="ent">➋</span>, and if you cast the pointer from <code>data</code> to a <code>const char*</code>, you’ll see that it points to the character <code>B</code> from your C-style string <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second test, you construct a <code>mutable_buffer</code> using a <code>string</code> by invoking its <code>data</code> and <code>size</code> members within the buffer’s constructor <span class="ent">➍</span>. The <span epub:type="pagebreak" id="page_673"/>resulting buffer’s <code>data</code> <span class="ent">➎</span> and <code>size</code> <span class="ent">➏</span> methods return identical data to your original <code>string</code>.</p>&#13;
<p class="indent">The <code>boost::asio::streambuf</code> class accepts two optional constructor arguments: a <code>size_t</code> maximum size and an allocator. By default, the maximum size is <code>std::numeric_limits&lt;std::size_t&gt;</code> and the allocator is similar to the default allocator for stdlib containers. The <code>streambuf</code> input sequence’s initial size is always zero, which <a href="ch20.xhtml#ch20ex08">Listing 20-8</a> illustrates.</p>&#13;
<pre>#include &lt;boost/asio.hpp&gt;&#13;
&#13;
TEST_CASE("streambuf constructor") {&#13;
  boost::asio::streambuf sb; <span class="ent">➊</span>&#13;
  REQUIRE(sb.size() == 0); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch20ex08"/><em>Listing 20-8: Default constructing a <code>streambuf</code></em></p>&#13;
<p class="indent">You default construct a <code>streambuf</code> <span class="ent">➊</span>, and when you invoke its <code>size</code> method, it returns <code>0</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">You can pass a pointer to a <code>streambuf</code> into a <code>std::istream</code> or <code>std::ostream</code> constructor. Recall from “Stream Classes” on <a href="ch16.xhtml#page_524">page 524</a> that these are specializations of <code>basic_istream</code> and <code>basic_ostream</code> that expose stream operations to an underlying sync or source. <a href="ch20.xhtml#ch20ex09">Listing 20-9</a> illustrates how to write into and subsequently read from a <code>streambuf</code> using these classes.</p>&#13;
<pre>TEST_CASE("streambuf input/output") {&#13;
  boost::asio::streambuf sb; <span class="ent">➊</span>&#13;
  std::ostream os{ &amp;sb }; <span class="ent">➋</span>&#13;
  os &lt;&lt; "Welease Wodger!"; <span class="ent">➌</span>&#13;
&#13;
  std::istream is{ &amp;sb }; <span class="ent">➍</span>&#13;
  std::string command; <span class="ent">➎</span>&#13;
  is &gt;&gt; command; <span class="ent">➏</span>&#13;
&#13;
  REQUIRE(command == "Welease"); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch20ex09"/><em>Listing 20-9: Writing to and reading from a <code>streambuf</code></em></p>&#13;
<p class="indent">You again construct an empty <code>streambuf</code> <span class="ent">➊</span>, and you pass its address into the constructor of an <code>ostream</code> <span class="ent">➋</span>. You then write the string <code>Welease  Wodger!</code> into the <code>ostream</code>, which in turn writes the string into the underlying <code>streambuf</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">Next, you create an <code>istream</code> again using the address of the <code>streambuf</code> <span class="ent">➍</span>. You then create a <code>string</code> <span class="ent">➎</span> and write the <code>istream</code> into the <code>string</code> <span class="ent">➏</span>. Recall from “Special Formatting for Fundamental Types” on <a href="ch16.xhtml#page_529">page 529</a> that this operation will skip any leading whitespace and then read the following string until the next whitespace. This yields the first word of the string, <code>Welease</code> <span class="ent">➐</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_674"/>Boost Asio also offers the convenience function template <code>boost::asio::buffer</code>, which accepts a <code>std::array</code> or <code>std::vector</code> of POD elements or a <code>std::string</code>. For example, you can create the <code>std::string</code> backed <code>mutable_buffer</code> in <a href="ch20.xhtml#ch20ex07">Listing 20-7</a> using the following construction instead:</p>&#13;
<pre>std::string proposition{ "Charity for an ex-leper?" };&#13;
auto mb = boost::asio::buffer(proposition);</pre>&#13;
<p class="indent">The <code>buffer</code> template is specialized so if you provide a <code>const</code> argument, it will return a <code>const_buffer</code> instead. In other words, to make a <code>const_buffer</code> out of <code>proposition</code>, simply make it <code>const</code>:</p>&#13;
<pre>const std::string proposition{ "Charity for an ex-leper?" };&#13;
auto cb = boost::asio::buffer(proposition);</pre>&#13;
<p class="indent">You’ve now created a <code>const_buffer cb</code>.</p>&#13;
<p class="indent">Additionally, you can create a dynamic buffer, which is a dynamically resizable buffer backed by a <code>std::string</code> or a <code>std::vector</code>. You can create one by using the <code>boost::asio::dynamic_buffer</code> function template, which accepts either a <code>string</code> or a <code>vector</code> and returns a <code>boost::asio::dynamic_string_buffer</code> or <code>boost::asio::dynamic_vector_buffer</code> as appropriate. For example, you can make a dynamic buffer using the following construction:</p>&#13;
<pre>std::string proposition{ "Charity for an ex-leper?" };&#13;
auto db = boost::asio::dynamic_buffer(proposition);</pre>&#13;
<p class="indent">Although a dynamic buffer is dynamically resizable, recall that the <code>vector</code> and <code>string</code> classes use an allocator and that allocation can be a relatively slow operation. So, if you know how much data you’ll write into a buffer, you might have better performance using a non-dynamic buffer. As always, measuring and experimenting will help you decide which approach to take.</p>&#13;
<h4 class="h4" id="ch20lev2sec5"><strong><em>Reading and Writing Data with Buffers</em></strong></h4>&#13;
<p class="noindent">With your new knowledge of how to store and retrieve data using buffers, you can learn how to pull data off a socket. You can read data from active <code>socket</code> objects into buffer objects using built-in Boost Asio functions. For blocking reads, Boost Asio offers three functions:</p>&#13;
<ul>&#13;
<li class="noindent"><code>boost::asio::read</code> attempts to read a fixed-size data chunk.</li>&#13;
<li class="noindent"><code>boost::asio::read_at</code> attempts to read a fixed-size data chunk beginning at an offset.</li>&#13;
<li class="noindent"><code>boost::asio::read_until</code> attempts to read until a delimiter, regular expression, or arbitrary predicate matches.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_675"/>All three methods take a <code>socket</code> as their first argument and a buffer object as their second argument. The remaining arguments are optional and depend on which function you’re using:</p>&#13;
<ul>&#13;
<li class="noindent">A <em>completion condition</em> is a function object that accepts an <code>error_code</code> and a <code>size_t</code> argument. The <code>error_code</code> will be set if the Asio function encountered an error, and the <code>size_t</code> argument corresponds with the number of bytes transferred so far. The function object returns a <code>size_t</code> corresponding to the number of bytes remaining to be transferred, and it returns 0 if the operation is complete.</li>&#13;
<li class="noindent">A <em>match condition</em> is a function object that accepts a range specified by a begin and end iterator. It must return a <code>std::pair</code>, where the first element is an iterator indicating the starting point for the next attempt at matching and the second element is a <code>bool</code> representing whether the range contains a match.</li>&#13;
<li class="noindent"><code>boost::system::error_code</code> reference, which the function will set if it encounters an error condition.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch20.xhtml#ch20tab02">Table 20-2</a> lists many of the ways you can invoke one of the read functions.</p>&#13;
<p class="tabcap" id="ch20tab02"><strong>Table 20-2:</strong> Arguments for <code>read</code>, <code>read_at</code>, and <code>read_until</code></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Invocation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>read(</code><span class="codestrong">s</span>,  <span class="codestrong">b</span>, <code>[</code><span class="codestrong">cmp</span><code>], [</code><span class="codestrong">ec</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Reads a certain amount of data from <code>socket</code> <span class="codestrong">s</span> into a mutable buffer <span class="codestrong">b</span> according to completion condition <span class="codestrong">cmp</span>. Sets the <code>error_code</code> <span class="codestrong">ec</span> if an error condition is encountered; otherwise, throws a <code>system_error</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>read_at(</code><span class="codestrong">s</span>,  <span class="codestrong">off</span>,  <span class="codestrong">b</span>, <code>[</code><span class="codestrong">cmp</span><code>], [</code><span class="codestrong">ec</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Reads a certain amount of data starting from <code>socket</code> <span class="codestrong">s</span>, starting from <code>size_t</code> offset <span class="codestrong">off</span>, into a mutable buffer <span class="codestrong">b</span> according to completion condition <span class="codestrong">cmp</span>. Sets the <code>error_code</code> <span class="codestrong">ec</span> if an error condition is encountered; otherwise, throws a <code>system_error</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>read_until(</code><span class="codestrong">s</span>,  <span class="codestrong">b</span>,  <span class="codestrong">x</span>, <code>[</code><span class="codestrong">ec</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Reads data from <code>socket</code> <span class="codestrong">s</span> into a mutable buffer <span class="codestrong">b</span> until it meets a condition represented by <span class="codestrong">x</span>, which can be one of the following: a <code>char</code>, a <code>string_view</code>, a <code>boost::regex</code>, or a match condition. Sets the <code>error_code</code> <span class="codestrong">ec</span> if an error condition is encountered; otherwise, throws a <code>system_error</code>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can also write data to an active <code>socket</code> object from a buffer. For blocking writes, Boost Asio offers two functions:</p>&#13;
<ul>&#13;
<li class="noindent"><code>boost::asio::write</code> attempts to write a fixed-size data chunk.</li>&#13;
<li class="noindent"><code>boost::asio::write_at</code> attempts to write a fixed-size data chunk beginning at an offset.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_676"/><a href="ch20.xhtml#ch20tab03">Table 20-3</a> shows how to invoke these two methods. Their arguments are analogous to those for the reading methods.</p>&#13;
<p class="tabcap" id="ch20tab03"><strong>Table 20-3:</strong> Arguments for <code>write</code> and <code>write_at</code></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Invocation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>write(</code><span class="codestrong">s</span>,  <span class="codestrong">b</span>, <code>[</code><span class="codestrong">cmp</span><code>], [</code><span class="codestrong">ec</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Writes a certain amount of data into <code>socket</code> <span class="codestrong">s</span> from a <code>const</code> buffer <span class="codestrong">b</span> according to completion condition <span class="codestrong">cmp</span>. Sets the <code>error_code</code> <span class="codestrong">ec</span> if an error condition is encountered; otherwise, throws a <code>system_error</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>write_at(</code><span class="codestrong">s</span>,  <span class="codestrong">off</span>,  <span class="codestrong">b</span>, <code>[</code><span class="codestrong">cmp</span><code>], [</code><span class="codestrong">ec</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Writes a certain amount of data from <code>const</code> buffer <span class="codestrong">b</span>, starting from <code>size_t</code> offset <span class="codestrong">off</span>, into <code>socket</code> <code>s</code> according to completion condition <span class="codestrong">cmp</span>. Sets the <code>error_code</code> <span class="codestrong">ec</span> if an error condition is encountered; otherwise, throws a <code>system_error</code>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There are <em>many</em> permutations for invoking the read and write functions. Be sure to read the documentation carefully when you incorporate Boost Asio into your code.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch20lev2sec6"><strong><em>The Hypertext Transfer Protocol (HTTP)</em></strong></h4>&#13;
<p class="noindent">HTTP is the 30-year-old protocol undergirding the web. Although it’s a very complicated protocol to use to introduce networking, its ubiquity makes it one of the most relevant choices. In the next section, you’ll use Boost Asio to make very simple HTTP requests. It’s not strictly necessary that you have a solid foundation in HTTP, so you can skip this section on first reading. However, the information here adds some color to the examples in the next section and provides references for further study.</p>&#13;
<p class="indent">HTTP sessions have two parties: a client and a server. An HTTP client sends a plaintext request over TCP containing one or more lines separated by a carriage return and a line feed (a “CR-LF newline”).</p>&#13;
<p class="indent">The first line is the request line, which contains three tokens: an HTTP method, a uniform resource locator (URL), and the HTTP version of the request. For example, if a client wants a file called <em>index.htm</em>, the status line might be <em>GET /index.htm HTTP/1.1</em>.</p>&#13;
<p class="indent">Directly following the request line are one or more <em>headers</em>, which define the parameters of an HTTP transaction. Each header contains a key and a value. The key must be composed of alphanumeric characters and dashes. A colon plus a space delimits the key from the value. A CR-LF newline terminates the header. The following headers are especially common in requests:</p>&#13;
<ul>&#13;
<li class="noindent"><code>Host</code> specifies the domain of the service requested. Optionally, you can include a port. For example, <code>Host: <a href="http://www.google.com">www.google.com</a></code> specifies <em><a href="http://www.google.com">www.google.com</a></em> as the host for the requested service.</li>&#13;
<li class="noindent"><code>Accept</code> specifies the acceptable media types in MIME format for the response. For example, <code>Accept: text/plain</code> specifies that the requester can process plaintext.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_677"/><code>Accept-Language</code> specifies the acceptable human languages for the response. For example, <code>Accept-Language: en-US</code> specifies that the requester can process American English.</li>&#13;
<li class="noindent"><code>Accept-Encoding</code> specifies the acceptable encodings for the response. For example, <code>Accept-Encoding: identity</code> specifies that the requester can process contents without any encoding.</li>&#13;
<li class="noindent"><code>Connection</code> specifies control options for the current connection. For example, <code>Connection: close</code> specifies that the connection will be closed after completion of the response.</li>&#13;
</ul>&#13;
<p class="indent">You terminate the headers with an additional CR-LF newline. For certain kinds of HTTP requests, you’ll also include a body following the headers. If you do, you’ll also include <code>Content-Length</code> and <code>Content-Type</code> headers. The <code>Content-Length</code> value specifies the length of the request body in bytes, and the <code>Content-Type</code> value specifies the MIME format of the body.</p>&#13;
<p class="indent">An HTTP response’s first line is the <em>status line</em>, which includes the HTTP version of the response, a status code, and a reason message. For example, the status line <code>HTTP/1.1 200 OK</code> indicates a successful (“OK”) request. Status codes are always three digits. The leading digit indicates the status group of the code:</p>&#13;
<p class="bq"><strong><code>1**</code> (Informational)</strong> The request was received.</p>&#13;
<p class="bq"><strong><code>2**</code> (Successful)</strong> The request was received and accepted.</p>&#13;
<p class="bq"><strong><code>3**</code> (Redirection)</strong> Further action is required.</p>&#13;
<p class="bq"><strong><code>4**</code> (Client Error)</strong> The request was bad.</p>&#13;
<p class="bq"><strong><code>5**</code> (Server Error)</strong> The request seems okay, but the server encountered an internal error.</p>&#13;
<p class="indent">After the status line, the response contains any number of headers in the same format as the response. Many of the same request headers are also common response headers. For example, if the HTTP response contains a body, the response headers will include <code>Content-Length</code> and <code>Content-Type</code>.</p>&#13;
<p class="indent">If you need to program HTTP applications, you should absolutely refer to the Boost Beast library, which provides high-performance, low-level HTTP and WebSockets facilities. It’s built atop Asio and works seamlessly with it.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For an excellent treatment of HTTP and its tenant security issues, refer to</em> The Tangled Web: A Guide to Securing Modern Web Applications <em>by Michal Zalewski. For all the gory details, refer to the Internet Engineering Task Force’s RFCs 7230, 7231, 7232, 7233, 7234, and 7235.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch20lev2sec7"><strong><em>Implementing a Simple Boost Asio HTTP Client</em></strong></h4>&#13;
<p class="noindent">In this section, you’ll implement a (very) simple HTTP client. You’ll build an HTTP request, resolve an endpoint, connect to a web server, write the request, and read the response. <a href="ch20.xhtml#ch20ex10">Listing 20-10</a> illustrates one possible implementation.</p>&#13;
<pre><span epub:type="pagebreak" id="page_678"/>#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;istream&gt;&#13;
#include &lt;ostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
std::string request(std::string host, boost::asio::io_context&amp; io_context) { <span class="ent">➊</span>&#13;
  std::stringstream request_stream;&#13;
  request_stream &lt;&lt; "GET / HTTP/1.1\r\n"&#13;
                    "Host: " &lt;&lt; host &lt;&lt; "\r\n"&#13;
                    "Accept: text/html\r\n"&#13;
                    "Accept-Language: en-us\r\n"&#13;
                    "Accept-Encoding: identity\r\n"&#13;
                    "Connection: close\r\n\r\n";&#13;
  const auto request = request_stream.str(); <span class="ent">➋</span>&#13;
  boost::asio::ip::tcp::resolver resolver{ io_context };&#13;
  const auto endpoints = resolver.resolve(host, "http"); <span class="ent">➌</span>&#13;
  boost::asio::ip::tcp::socket socket{ io_context };&#13;
  const auto connected_endpoint = boost::asio::connect(socket, endpoints); <span class="ent">➍</span>&#13;
  boost::asio::write(socket, boost::asio::buffer(request)); <span class="ent">➎</span>&#13;
  std::string response;&#13;
  boost::system::error_code ec;&#13;
  boost::asio::read(socket, boost::asio::dynamic_buffer(response), ec); <span class="ent">➏</span>&#13;
  if (ec &amp;&amp; ec.value() != 2) throw boost::system::system_error{ ec }; <span class="ent">➐</span>&#13;
  return response;&#13;
}&#13;
&#13;
int main() {&#13;
  boost::asio::io_context io_context;&#13;
  try  {&#13;
    const auto response = request("www.arcyber.army.mil", io_context); <span class="ent">➑</span>&#13;
    std::cout &lt;&lt; response &lt;&lt; "\n"; <span class="ent">➒</span>&#13;
  } catch(boost::system::system_error&amp; se) {&#13;
    std::cerr &lt;&lt; "Error: " &lt;&lt; se.what() &lt;&lt; std::endl;&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">HTTP/1.1 200 OK</span>&#13;
<span class="color1">Pragma: no-cache</span>&#13;
<span class="color1">Content-Type: text/html; charset=utf-8</span>&#13;
<span class="color1">X-UA-Compatible: IE=edge</span>&#13;
<span class="color1">pw_value: 3ce3af822980b849665e8c5400e1b45b</span>&#13;
<span class="color1">Access-Control-Allow-Origin: *</span>&#13;
<span class="color1">X-Powered-By:</span>&#13;
<span class="color1">Server:</span>&#13;
<span class="color1">X-ASPNET-VERSION:</span>&#13;
<span class="color1">X-FRAME-OPTIONS: SAMEORIGIN</span>&#13;
<span class="color1">Content-Length: 76199</span>&#13;
<span class="color1">Cache-Control: private, no-cache</span>&#13;
<span class="color1">Expires: Mon, 22 Oct 2018 14:21:09 GMT</span>&#13;
<span class="color1">Date: Mon, 22 Oct 2018 14:21:09 GMT</span>&#13;
<span class="color1">Connection: close</span>&#13;
<span class="color1">&lt;!DOCTYPE html&gt;</span>&#13;
<span class="color1">&lt;html  lang="en-US"&gt;</span>&#13;
<span class="color1">&lt;head id="Head"&gt;</span>&#13;
<span class="color1">--<span class="codeitalic1">snip</span>--</span>&#13;
<span class="color1">&lt;/body&gt;</span>&#13;
<span class="color1">&lt;/html&gt;</span></pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_679"/><a id="ch20ex10"/><em>Listing 20-10: Completing a simple request to the United States Army Cyber Command web server</em></p>&#13;
<p class="indent">You first define a <code>request</code> function, which accepts a <code>host</code> and an <code>io_context</code> and returns an HTTP response <span class="ent">➊</span>. First, you use a <code>std::stringstream</code> to build a <code>std::string</code> containing an HTTP request <span class="ent">➋</span>. Next, you resolve the <code>host</code> using a <code>boost::asio::ip::tcp::resolver</code> <span class="ent">➌</span> and connect a <code>boost::asio::ip::tcp::socket</code> to the resulting endpoint range <span class="ent">➍</span>. (This matches the approach in <a href="ch20.xhtml#ch20ex04">Listing 20-4</a>.)</p>&#13;
<p class="indent">Then you write your HTTP request to the server you’ve connected to. You use <code>boost::asio::write</code>, passing in your connected <code>socket</code> and your <code>request</code>. Because write accepts Asio buffers, you use <code>boost::asio::buffer</code> to create a <code>mutable_buffer</code> from your request (which is a <code>std::string</code>) <span class="ent">➎</span>.</p>&#13;
<p class="indent">Next, you read the HTTP response from the server. Because you don’t know the length of the response in advance, you create a <code>std::string</code> called <code>response</code> to receive the response. Eventually, you’ll use this to back a dynamic buffer. For simplicity, the HTTP request contains a <code>Connection: close</code> header that causes the server to terminate the connection immediately after it sends its response. This will result in Asio returning an “end of file” error code (value 2). Because you expect this behavior, you declare a <code>boost::system::error_code</code> to receive this error.</p>&#13;
<p class="indent">Next, you invoke <code>boost::asio::read</code> with the connected <code>socket</code>, a dynamic buffer that will receive the response, and the <code>error_condition</code> <span class="ent">➏</span>. You use <code>boost::asio_dynamic_buffer</code> to construct your dynamic buffer from <code>response</code>. Immediately after <code>read</code> returns, you check for an <code>error_condition</code> other than end of file (which you throw) <span class="ent">➐</span>. Otherwise, you return the <code>response</code>.</p>&#13;
<p class="indent">Within <code>main</code>, you invoke your <code>request</code> function with the <code>www.arcyber.army.mil</code> host and an <code>io_context</code> object <span class="ent">➑</span>. Finally, you print the response to stdout <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch20lev2sec8"><strong><em>Asynchronous Reading and Writing</em></strong></h4>&#13;
<p class="noindent">You can also read and write asynchronously with Boost Asio. The corresponding asynchronous functions are analogous to their blocking corollaries. For asynchronous reads, Boost Asio offers three functions:</p>&#13;
<ul>&#13;
<li class="noindent"><code>boost::asio::async_read</code> attempts to read a fixed-size data chunk.</li>&#13;
<li class="noindent"><code>boost::asio::async_read_at</code> attempts to read a fixed-size data chunk beginning at an offset.</li>&#13;
<li class="noindent"><code>boost::asio::async_read_until</code> attempts to read until a delimiter, regular expression, or arbitrary predicate matches.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_680"/>Boost Asio also offers two asynchronous write functions:</p>&#13;
<ul>&#13;
<li class="noindent"><code>boost::asio::async_write</code> attempts to write a fixed-size data chunk.</li>&#13;
<li class="noindent"><code>boost::asio::async_write_at</code> attempts to write a fixed-size data chunk beginning at an offset.</li>&#13;
</ul>&#13;
<p class="indent">All five of these asynchronous functions accept the same arguments as their blocking counterparts, except their final argument is always a callback function object that accepts two arguments: a <code>boost::system::error_code</code> indicating whether the function met an error and a <code>size_t</code> indicating the number of bytes it transferred. For the asynchronous <code>write</code> functions, you need to determine whether Asio wrote the entire payload. Because these calls are asynchronous, your thread doesn’t block while it’s waiting for I/O to complete. Instead, the operating system calls your thread back whenever a portion of your I/O request completes.</p>&#13;
<p class="indent">Because the callback’s second argument is a <code>size_t</code> corresponding to the number of transferred bytes, you can do the arithmetic to figure out whether you have anything left to write. If there is, you must invoke another asynchronous write function by passing the remaining data.</p>&#13;
<p class="indent"><a href="ch20.xhtml#ch20ex11">Listing 20-11</a> contains an asynchronous version of the simple web client in <a href="ch20.xhtml#ch20ex10">Listing 20-10</a>. Note that using the asynchronous functions is a bit more complicated. But there’s a pattern with callbacks and handlers that’s consistent across the request’s lifetime.</p>&#13;
<pre>#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;sstream&gt;&#13;
&#13;
using ResolveResult = boost::asio::ip::tcp::resolver::results_type;&#13;
using Endpoint = boost::asio::ip::tcp::endpoint;&#13;
&#13;
struct Request {&#13;
  explicit Request(boost::asio::io_context&amp; io_context, std::string host)&#13;
      : resolver{ io_context },&#13;
        socket{ io_context },&#13;
        host{ std::move(host) } { <span class="ent">➊</span>&#13;
    std::stringstream request_stream;&#13;
    request_stream &lt;&lt; "GET / HTTP/1.1\r\n"&#13;
                      "Host: " &lt;&lt; this-&gt;host &lt;&lt; "\r\n"&#13;
                      "Accept: text/plain\r\n"&#13;
                      "Accept-Language: en-us\r\n"&#13;
                      "Accept-Encoding: identity\r\n"&#13;
                      "Connection: close\r\n"&#13;
                      "User-Agent: C++ Crash Course Client\r\n\r\n";&#13;
    request = request_stream.str(); <span class="ent">➋</span>&#13;
    resolver.async_resolve(this-&gt;host, "http",&#13;
       [this] (boost::system::error_code ec, const ResolveResult&amp; results) {&#13;
         resolution_handler(ec, results); <span class="ent">➌</span>&#13;
       });&#13;
  }&#13;
<span epub:type="pagebreak" id="page_681"/> void resolution_handler(boost::system::error_code ec,&#13;
                          const ResolveResult&amp; results) {&#13;
    if (ec) { <span class="ent">➍</span>&#13;
      std::cerr &lt;&lt; "Error resolving " &lt;&lt; host &lt;&lt; ": " &lt;&lt; ec &lt;&lt; std::endl;&#13;
      return;&#13;
    }&#13;
    boost::asio::async_connect(socket, results,&#13;
            [this] (boost::system::error_code ec, const Endpoint&amp; endpoint){&#13;
              connection_handler(ec, endpoint); <span class="ent">➎</span>&#13;
            });&#13;
  }&#13;
&#13;
  void connection_handler(boost::system::error_code ec,&#13;
                          const Endpoint&amp; endpoint) { <span class="ent">➏</span>&#13;
    if (ec) {&#13;
      std::cerr &lt;&lt; "Error connecting to " &lt;&lt; host &lt;&lt; ": "&#13;
                &lt;&lt; ec.message() &lt;&lt; std::endl;&#13;
      return;&#13;
    }&#13;
    boost::asio::async_write(socket, boost::asio::buffer(request),&#13;
            [this] (boost::system::error_code ec, size_t transferred){&#13;
              write_handler(ec, transferred);&#13;
            });&#13;
  }&#13;
&#13;
  void write_handler(boost::system::error_code ec, size_t transferred) { <span class="ent">➐</span>&#13;
    if (ec) {&#13;
      std::cerr &lt;&lt; "Error writing to " &lt;&lt; host &lt;&lt; ": " &lt;&lt; ec.message()&#13;
                &lt;&lt; std::endl;&#13;
    } else if (request.size() != transferred) {&#13;
      request.erase(0, transferred);&#13;
      boost::asio::async_write(socket, boost::asio::buffer(request),&#13;
                               [this] (boost::system::error_code ec,&#13;
                                       size_t transferred){&#13;
                                 write_handler(ec, transferred);&#13;
                               });&#13;
    } else {&#13;
      boost::asio::async_read(socket, boost::asio::dynamic_buffer(response),&#13;
                              [this] (boost::system::error_code ec,&#13;
                                      size_t transferred){&#13;
                                read_handler(ec, transferred);&#13;
                              });&#13;
    }&#13;
  }&#13;
&#13;
  void read_handler(boost::system::error_code ec, size_t transferred) { <span class="ent">➑</span>&#13;
    if (ec &amp;&amp; ec.value() != 2)&#13;
      std::cerr &lt;&lt; "Error reading from " &lt;&lt; host &lt;&lt; ": "&#13;
                &lt;&lt; ec.message() &lt;&lt; std::endl;&#13;
  }&#13;
&#13;
  const std::string&amp; get_response() const noexcept {&#13;
    return response;&#13;
  }&#13;
private:&#13;
<span epub:type="pagebreak" id="page_682"/>  boost::asio::ip::tcp::resolver resolver;&#13;
  boost::asio::ip::tcp::socket socket;&#13;
  std::string request, response;&#13;
  const std::string host;&#13;
};&#13;
&#13;
int main() {&#13;
  boost::asio::io_context io_context;&#13;
  Request request{ io_context, "www.arcyber.army.mil" }; <span class="ent">➒</span>&#13;
  io_context.run(); <span class="ent">➓</span>&#13;
  std::cout &lt;&lt; request.get_response();&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">HTTP/1.1 200 OK</span>&#13;
<span class="color1">Pragma: no-cache</span>&#13;
<span class="color1">Content-Type: text/html; charset=utf-8</span>&#13;
<span class="color1">X-UA-Compatible: IE=edge</span>&#13;
<span class="color1">pw_value: 3ce3af822980b849665e8c5400e1b45b</span>&#13;
<span class="color1">Access-Control-Allow-Origin: *</span>&#13;
<span class="color1">X-Powered-By:</span>&#13;
<span class="color1">Server:</span>&#13;
<span class="color1">X-ASPNET-VERSION:</span>&#13;
<span class="color1">X-FRAME-OPTIONS: SAMEORIGIN</span>&#13;
<span class="color1">Content-Length: 76199</span>&#13;
<span class="color1">Cache-Control: private, no-cache</span>&#13;
<span class="color1">Expires: Mon, 22 Oct 2018 14:21:09 GMT</span>&#13;
<span class="color1">Date: Mon, 22 Oct 2018 14:21:09 GMT</span>&#13;
<span class="color1">Connection: close</span>&#13;
&#13;
<span class="color1">&lt;!DOCTYPE html&gt;</span>&#13;
<span class="color1">&lt;html  lang="en-US"&gt;</span>&#13;
<span class="color1">&lt;head id="Head"&gt;</span>&#13;
<span class="color1">--<span class="codeitalic1">snip</span>--</span>&#13;
<span class="color1">&lt;/body&gt;</span>&#13;
<span class="color1">&lt;/html&gt;</span></pre>&#13;
<p class="listing"><a id="ch20ex11"/><em>Listing 20-11: An asynchronous refactor of <a href="ch20.xhtml#ch20ex09">Listing 20-9</a></em></p>&#13;
<p class="indent">You first declare a <code>Request</code> class that will handle a web request. It has a single constructor that takes an <code>io_context</code> and a <code>string</code> containing the host you want to connect with <span class="ent">➊</span>. Just as in <a href="ch20.xhtml#ch20ex09">Listing 20-9</a>, you create an HTTP GET request using a <code>std::stringstream</code> and save the resulting <code>string</code> into the <code>request</code> field <span class="ent">➋</span>. Next, you use <code>async_resolve</code> to request the endpoints corresponding to the requested <code>host</code>. Within the callback, you invoke the <code>resolution_handler</code> method on the current <code>Request</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The <code>resolution_handler</code> receives the callback from <code>async_resolve</code>. It first checks for an error condition, printing to stderr and returning if it finds one <span class="ent">➍</span>. If <code>async_resolve</code> didn’t pass an error, <code>resolution_handler</code> invokes <code>async_connect</code> using the endpoints contained in its <code>results</code> variable. It also passes the <code>socket</code> field of the current <code>Request</code>, which will store the connection that <code>async_connect</code> is about to create. Finally, it passes a connection callback as the third parameter. Within the callback, you invoke the <code>connection_handler</code> method of the current request <span class="ent">➎</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_683"/>The <code>connection_handler</code> <span class="ent">➏</span> follows a similar pattern to the <code>resolution_handler</code> method. It checks for an error condition, and if one exists, it prints to stderr and returns; otherwise, it proceeds to process the request by invoking <code>async_write</code>, which takes three parameters: the active <code>socket</code>, a mutable buffer-wrapping <code>request</code>, and a callback function. The callback function, in turn, invokes the <code>write_handler</code> method on the current request.</p>&#13;
<p class="indent">Are you seeing a pattern here in these handler functions? The <code>write_handler</code> <span class="ent">➐</span> checks for an error and proceeds to determine whether the entire request has been sent. If it hasn’t, you still need to write some of the request, so you adjust the <code>request</code> accordingly and invoke <code>async_write</code> again. If <code>async_write</code> has written the entire request into <code>socket</code>, it’s time to read the response. For this, you invoke <code>async_read</code> using your <code>socket</code>, a dynamic buffer wrapping the <code>response</code> field, and a callback function that invokes the <code>read_handler</code> method on the current request.</p>&#13;
<p class="indent">The <code>read_handler</code> <span class="ent">➑</span> first checks for an error. Because your request used the <code>Connection: close</code> header, you expect an end-of-file error (value 2) as in <a href="ch20.xhtml#ch20ex10">Listing 20-10</a> and so ignore it. If it encounters a different kind of error, you print it to stderr and return. Your request is complete at this point. (Phew.)</p>&#13;
<p class="indent">Within <code>main</code>, you declare your <code>io_context</code> and initialize a <code>Request</code> to <em><a href="http://www.arcyber.army.mil">www.arcyber.army.mil</a></em> <span class="ent">➒</span>. Because you’re using asynchronous functions, you invoke the <code>run</code> method on <code>io_context</code> <span class="ent">➓</span>. After <code>io_context</code> returns, you know that no asynchronous operations are pending, so you print the contents of the response on your <code>Request</code> object to stdout.</p>&#13;
<h4 class="h4" id="ch20lev2sec9"><strong><em>Serving</em></strong></h4>&#13;
<p class="noindent">Building a server atop Boost Asio is essentially similar to building a client. To accept TCP connections, you use the <code>boost::asio::ip::tcp::acceptor</code> class, which takes a <code>boost::asio::io_context</code> object as its only constructor argument.</p>&#13;
<p class="indent">To accept a TCP connection using a blocking approach, you use the <code>acceptor</code> object’s <code>accept</code> method, which takes a <code>boost::asio::ip::tcp::socket</code> reference, which will hold the client’s socket, and an optional <code>boost::error_code</code> reference, which will hold any error conditions that arise. If you don’t provide a <code>boost::error_code</code> and an error arises, <code>accept</code> will throw a <code>boost::system_error</code> instead. Once <code>accept</code> returns without error, you can use the <code>socket</code> you passed in to read and write with the same read and write methods you used with the client in the previous sections.</p>&#13;
<p class="indent">For example, <a href="ch20.xhtml#ch20ex12">Listing 20-12</a> illustrates how to build an echo server that receives a message and sends it back uppercased to the client.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;boost/algorithm/string/case_conv.hpp&gt;&#13;
&#13;
using namespace boost::asio;&#13;
&#13;
void handle(ip::tcp::socket&amp; socket) { <span class="ent">➊</span>&#13;
  boost::system::error_code ec;&#13;
  std::string message;&#13;
  do {&#13;
    boost::asio::read_until(socket, dynamic_buffer(message), "\n"); <span class="ent">➋</span>&#13;
    boost::algorithm::to_upper(message); <span class="ent">➌</span>&#13;
    boost::asio::write(socket, buffer(message), ec); <span class="ent">➍</span>&#13;
    if (message == "\n") return; <span class="ent">➎</span>&#13;
    message.clear();&#13;
  } while(!ec); <span class="ent">➏</span>&#13;
}&#13;
&#13;
int main()  {&#13;
  try {&#13;
    io_context io_context;&#13;
    ip::tcp::acceptor acceptor{ io_context,&#13;
                                ip::tcp::endpoint(ip::tcp::v4(), 1895) }; <span class="ent">➐</span>&#13;
    while (true) {&#13;
      ip::tcp::socket socket{ io_context };&#13;
      acceptor.accept(socket); <span class="ent">➑</span>&#13;
      handle(socket); <span class="ent">➒</span>&#13;
    }&#13;
  } catch (std::exception&amp; e) {&#13;
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_684"/><a id="ch20ex12"/><em>Listing 20-12: An uppercasing echo server</em></p>&#13;
<p class="indent">You declare the <code>handle</code> function that accepts a <code>socket</code> reference corresponding to a client and handles messages from it <span class="ent">➊</span>. Within a <code>do</code>-<code>while</code> loop, you read a line of text from the client into a <code>string</code> called <code>message</code> <span class="ent">➋</span>, you convert it to uppercase using the <code>to_upper</code> function illustrated in <a href="ch15.xhtml#ch15ex31">Listing 15-31</a> <span class="ent">➌</span>, and write it back to the client <span class="ent">➍</span>. If the client sent a blank line, you exit from <code>handle</code> <span class="ent">➎</span>; otherwise, you clear the contents of the message and loop if no error condition occurred <span class="ent">➏</span>.</p>&#13;
<p class="indent">Within <code>main</code>, you initialize an <code>io_context</code> and an <code>acceptor</code> so that the program binds to the <code>localhost:1895</code> socket <span class="ent">➐</span>. Within an infinite loop, you create a <code>socket</code> and call <code>accept</code> on the acceptor <span class="ent">➑</span>. As long as this doesn’t throw an exception, the <code>socket</code> will represent a new client, and you can pass this <code>socket</code> to <code>handle</code> to service the request <span class="ent">➒</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In <a href="ch20.xhtml#ch20ex12">Listing 20-12</a>, the choice was to listen on port 1895. This choice is technically immaterial, as long as no other program running on your computer is currently using that port. However, there are guidelines about how to decide which port your program will listen on. IANA maintains a list of registered ports at</em> <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt">https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt</a> <em>that you might want to avoid. Additionally, modern operating systems typically require that a program have elevated privileges to bind to a port with a value of 1023 or below, a</em> system port. <em>The ports 1024 to 49151 don’t typically require elevated privileges and are called</em> user ports. <em>The ports 49152 to 65535 are the</em> dynamic/private ports, <em>which are generally safe to use because they won’t be registered with IANA.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_685"/>To interact with the server in <a href="ch20.xhtml#ch20ex12">Listing 20-12</a>, you can use <em>GNU Netcat</em>, a network utility that allows you to create inbound and outbound TCP and UDP connections and then read and write data. If you’re using a Unix-like system, you probably have it installed. If you don’t, see <a href="https://nmap.org/ncat/"><em>https://nmap.org/ncat/</em></a>. <a href="ch20.xhtml#ch20ex13">Listing 20-13</a> shows a sample session that connects to the uppercasing echo server.</p>&#13;
<pre>$ ncat localhost 1895 <span class="ent">➊</span>&#13;
The 300 <span class="ent">➋</span>&#13;
THE 300&#13;
This is Blasphemy! <span class="ent">➋</span>&#13;
THIS IS BLASPHEMY!&#13;
This is madness! <span class="ent">➋</span>&#13;
THIS IS MADNESS!&#13;
Madness...? <span class="ent">➋</span>&#13;
MADNESS...?&#13;
This is Sparta! <span class="ent">➋</span>&#13;
THIS IS SPARTA!&#13;
<span class="ent">➌</span>&#13;
Ncat: Broken pipe. <span class="ent">➍</span></pre>&#13;
<p class="listing"><a id="ch20ex13"/><em>Listing 20-13: Interacting with the uppercasing echo server using Netcat</em></p>&#13;
<p class="indent">Netcat (<code>ncat</code>) takes two arguments: a host and a port <span class="ent">➊</span>. Once you’ve invoked the program, each line you enter results in an uppercased result from the server. When you type text into stdin, Netcat sends it to the server <span class="ent">➋</span>, which responds in uppercase. Once you send it an empty line <span class="ent">➌</span>, the server terminates the socket and you get a <code>Broken pipe</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">To accept connections using an asynchronous approach, you use the <code>async_accept</code> method on the <code>acceptor</code>, which takes a single argument: a callback object that accepts an <code>error_code</code> and a <code>socket</code>. If an error occurs, the <code>error_code</code> contains an error condition; otherwise, the <code>socket</code> represents the successfully connected client. From there, you can use the socket in the same way you did in the blocking approach.</p>&#13;
<p class="indent">A common pattern for asynchronous, connection-oriented servers is to use the <code>std::enable_shared_from_this</code> template discussed in “Advanced Patterns” on <a href="ch11.xhtml#page_362">page 362</a>. The idea is to create a shared pointer to a session object for each connection. When you register callbacks for reading and writing within the session object, you capture a shared pointer “from <code>this</code>” within the callback object so that while I/O is pending, the session stays alive. Once no I/O is pending, the session object dies along with all the shared pointers. <a href="ch20.xhtml#ch20ex14">Listing 20-14</a> illustrates how to reimplement the upper-casing echo server using asynchronous I/O.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;boost/algorithm/string/case_conv.hpp&gt;&#13;
#include &lt;memory&gt;&#13;
<span epub:type="pagebreak" id="page_686"/>using namespace boost::asio;&#13;
&#13;
struct Session : std::enable_shared_from_this&lt;Session&gt; {&#13;
  explicit Session(ip::tcp::socket socket) : socket{ std::move(socket) } { } <span class="ent">➊</span>&#13;
  void read() {&#13;
    async_read_until(socket, dynamic_buffer(message), '\n', <span class="ent">➋</span>&#13;
            [self=shared_from_this()] (boost::system::error_code ec,&#13;
                                       std::size_t length) {&#13;
              if (ec || self-&gt;message == "\n") return; <span class="ent">➌</span>&#13;
              boost::algorithm::to_upper(self-&gt;message);&#13;
              self-&gt;write();&#13;
            });&#13;
  }&#13;
  void write() {&#13;
    async_write(socket, buffer(message), <span class="ent">➍</span>&#13;
                [self=shared_from_this()] (boost::system::error_code ec,&#13;
                                           std::size_t length) {&#13;
                  if (ec) return; <span class="ent">➎</span>&#13;
                  self-&gt;message.clear();&#13;
                  self-&gt;read();&#13;
                });&#13;
  }&#13;
private:&#13;
  ip::tcp::socket socket;&#13;
  std::string message;&#13;
};&#13;
&#13;
void serve(ip::tcp::acceptor&amp; acceptor) {&#13;
  acceptor.async_accept([&amp;acceptor](boost::system::error_code ec, <span class="ent">➏</span>&#13;
                                    ip::tcp::socket socket) {&#13;
    serve(acceptor); <span class="ent">➐</span>&#13;
    if (ec) return;&#13;
    auto session = std::make_shared&lt;Session&gt;(std::move(socket)); <span class="ent">➑</span>&#13;
    session-&gt;read();&#13;
  });&#13;
}&#13;
&#13;
int main()  {&#13;
  try {&#13;
    io_context io_context;&#13;
    ip::tcp::acceptor acceptor{ io_context,&#13;
                                ip::tcp::endpoint(ip::tcp::v4(), 1895) };&#13;
    serve(acceptor);&#13;
    io_context.run(); <span class="ent">➒</span>&#13;
  } catch (std::exception&amp; e) {&#13;
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch20ex14"/><em>Listing 20-14: An asynchronous version of <a href="ch20.xhtml#ch20ex12">Listing 20-12</a></em></p>&#13;
<p class="indent">You first define a <code>Session</code> class to manage connections. Within the constructor, you take ownership of the <code>socket</code> corresponding to the connecting client and store it as a member <span class="ent">➊</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_687"/>Next, you declare a <code>read</code> method that invokes <code>async_read_until</code> on the <code>socket</code> so it reads into a <code>dynamic_buffer</code> wrapping the <code>message</code> member <code>string</code> up to the next newline character <code>\n</code> <span class="ent">➋</span>. The callback object captures this as a <code>shared_ptr</code> using the <code>shared_from_this</code> method. When invoked, the function checks for either an error condition or an empty line, in which case it returns <span class="ent">➌</span>. Otherwise, the callback converts <code>message</code> to uppercase and invokes the <code>write</code> method.</p>&#13;
<p class="indent">The <code>write</code> method follows a similar pattern as the <code>read</code> method. It invokes <code>async_read</code>, passing the <code>socket</code>, the <code>message</code> (now uppercase), and a callback function <span class="ent">➍</span>. Within the callback function, you check for an error condition and return immediately if one exists <span class="ent">➎</span>. Otherwise, you know that Asio successfully sent your uppercased <code>message</code> to the client, so you invoke <code>clear</code> on it to prepare for the next message from the client. Then you invoke the <code>read</code> method, which starts the process over.</p>&#13;
<p class="indent">Next, you define a <code>serve</code> function that accepts an <code>acceptor</code> object. Within the function, you invoke <code>async_accept</code> on the acceptor object and pass a callback function to handle connections <span class="ent">➏</span>. The callback function first invokes <code>serve</code> again using the acceptor so your program can handle new connections immediately <span class="ent">➐</span>. This is the secret sauce that makes the asynchronous handling so powerful on the server side: you can handle many connections at once because the running thread doesn’t need to service one client before handling another. Next, you check for an error condition and exit if one exists; otherwise, you create a <code>shared_ptr</code> owning a new <code>Session</code> object <span class="ent">➑</span>. This <code>Session</code> object will own the <code>socket</code> that the <code>acceptor</code> just set up for you. You invoke the <code>read</code> method on the new <code>Session</code> object, which creates a second reference within the <code>shared_ptr</code> thanks to the <code>shared_from_this</code> capture. Now you’re all set! Once the <code>read</code> and <code>write</code> cycle ends due to an empty line from the client or some error condition, the <code>shared_ptr</code> reference will go to zero and the <code>Session</code> object will destruct.</p>&#13;
<p class="indent">Finally, within <code>main</code> you construct an <code>io_context</code> and an <code>acceptor</code> as in <a href="ch20.xhtml#ch20ex12">Listing 20-12</a>. You then pass the <code>acceptor</code> to your <code>serve</code> function to begin the service loop and invoke <code>run</code> on the <code>io_context</code> to start servicing asynchronous operations <span class="ent">➒</span>.</p>&#13;
<h3 class="h3" id="ch20lev1sec3"><strong>Multithreading Boost Asio</strong></h3>&#13;
<p class="noindent">To make your Boost Asio program multithreaded, you can simply spawn tasks that invoke <code>run</code> on your <code>io_context</code> object. Of course, this doesn’t make your program safe, and all the admonitions in “Sharing and Coordinating” on <a href="ch19.xhtml#page_647">page 647</a> are in full effect. <a href="ch20.xhtml#ch20ex15">Listing 20-15</a> illustrates how to multithread your server from <a href="ch20.xhtml#ch20ex14">Listing 20-14</a>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;boost/algorithm/string/case_conv.hpp&gt;&#13;
#include &lt;memory&gt;&#13;
#include &lt;future&gt;&#13;
<span epub:type="pagebreak" id="page_688"/>struct Session : std::enable_shared_from_this&lt;Session&gt; {&#13;
--snip--&#13;
};&#13;
&#13;
void serve(ip::tcp::acceptor&amp; acceptor) {&#13;
--snip--&#13;
}&#13;
&#13;
int main()  {&#13;
  const int n_threads{ 4 };&#13;
  boost::asio::io_context io_context{ n_threads };&#13;
  ip::tcp::acceptor acceptor{ io_context,&#13;
                              ip::tcp::endpoint(ip::tcp::v4(), 1895) }; <span class="ent">➊</span>&#13;
  serve(acceptor); <span class="ent">➋</span>&#13;
&#13;
  std::vector&lt;std::future&lt;void&gt;&gt; futures;&#13;
  std::generate_n(std::back_inserter(futures), n_threads, <span class="ent">➌</span>&#13;
                  [&amp;io_context] {&#13;
                    return std::async(std::launch::async,&#13;
                                      [&amp;io_context] { io_context.run(); }); <span class="ent">➍</span>&#13;
                  });&#13;
&#13;
  for(auto&amp; future : futures) { <span class="ent">➎</span>&#13;
    try {&#13;
      future.get(); <span class="ent">➏</span>&#13;
    } catch (const std::exception&amp; e) {&#13;
      std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
    }&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch20ex15"/><em>Listing 20-15: Multithreading your asynchronous echo server</em></p>&#13;
<p class="indent">Your <code>Session</code> and <code>serve</code> definitions are identical. Within <code>main</code>, you declare <code>n_threads</code> constant representing the number of threads you’ll use to serve, an <code>io_context</code>, and an <code>acceptor</code> with parameters identical to those in <a href="ch12.xhtml#ch12ex12">Listing 12-12</a> <span class="ent">➊</span>. Next, you invoke <code>serve</code> to begin the <code>async_accept</code> loop <span class="ent">➋</span>.</p>&#13;
<p class="indent">More or less, <code>main</code> is almost identical to <a href="ch12.xhtml#ch12ex12">Listing 12-12</a>. The difference is that you’ll dedicate multiple threads to running the <code>io_context</code> rather than just one. First, you initialize a <code>vector</code> to store each <code>future</code> corresponding to the tasks you’ll launch. Second, you use a similar approach with <code>std::generate_n</code> to create tasks <span class="ent">➌</span>. As the generative function object, you pass a lambda that invokes <code>std::async</code> <span class="ent">➍</span>. Within the <code>std::async</code> call, you pass the execution policy <code>std::launch::async</code> and a function object that invokes <code>run</code> on your <code>io_context</code>.</p>&#13;
<p class="indent">Boost Asio is off to the races now that you’ve assigned some tasks to running your <code>io_context</code>. You’ll want to wait for all asynchronous operations to complete, so you call <code>get</code> on each <code>future</code> you stored in <code>futures</code> <span class="ent">➎</span>. Once this loop completes, each <code>Request</code> has finished and you’re ready to print a summary of the resulting responses <span class="ent">➏</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_689"/>Sometimes it makes sense to create additional threads and assign them to processing I/O. Often, one thread will suffice. You must measure whether the optimization (and attendant difficulties arising from concurrent code) are worth it.</p>&#13;
<h3 class="h3" id="ch20lev1sec4"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter covered Boost Asio, a library for low-level I/O programming. You learned the basics of queuing asynchronous tasks and providing a thread pool in Asio, as well as how to interact with its basic networking facilities. You built several programs, including a simple HTTP client using synchronous and asynchronous approaches and an echo server.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>20-1.</strong> Use the Boost Asio documentation to investigate the UDP class analogs to the TCP classes you’ve learned about in this chapter. Rewrite the uppercasing echo server in <a href="ch20.xhtml#ch20ex14">Listing 20-14</a> as a UDP service.</p>&#13;
<p class="noindent"><strong>20-2.</strong> Use the Boost Asio documentation to investigate the ICMP classes. Write a program that pings all hosts on a given subnetwork to perform network analysis. Investigate <em>Nmap</em>, a network-mapping program available for free at <em><a href="https://nmap.org/">https://nmap.org/</a></em>.</p>&#13;
<p class="noindent"><strong>20-3.</strong> Investigate the Boost Beast documentation. Rewrite <a href="ch20.xhtml#ch20ex10">Listings 20-10</a> and <a href="ch20.xhtml#ch20ex11">20-11</a> using Beast.</p>&#13;
<p class="noindent"><strong>20-4.</strong> Use Boost Beast to write an HTTP server that serves files from a directory. For help, refer to the Boost Beast example projects available in the documentation.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>The TCP/IP Guide</em> by Charles M. Kozierok (No Starch Press, 2005)</li>&#13;
<li class="noindent"><em>Tangled Web: A Guide to Securing Modern Web Applications</em> by Michal Zalewski (No Starch Press, 2012)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>Boost.Asio C++ Network Programming</em>, 2nd Edition, by Wisnu Anggoro and John Torjo (Packt, 2015)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>