- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CROSS-SITE SCRIPTING**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the most famous examples of a *cross-site scripting (XSS)* vulnerability
    is the Myspace Samy Worm created by Samy Kamkar. In October 2005, Kamkar exploited
    a vulnerability on Myspace that allowed him to store a JavaScript payload on his
    profile. Whenever a logged-in user would visit his Myspace profile, the payload
    code would execute, making the viewer Kamkar’s friend on Myspace and updating
    the viewer’s profile to display the text “but most of all, samy is my hero.” Then
    the code would copy itself to the viewer’s profile and continue infecting other
    Myspace user pages.
  prefs: []
  type: TYPE_NORMAL
- en: Although Kamkar didn’t create the worm with malicious intent, the government
    raided Kamkar’s residence as a result. Kamkar was arrested for releasing the worm
    and pleaded guilty to a felony charge.
  prefs: []
  type: TYPE_NORMAL
- en: Kamkar’s worm is an extreme example, but his exploit shows the broad impact
    an XSS vulnerability could have on a website. Similar to other vulnerabilities
    I’ve covered so far, XSS occurs when websites render certain characters unsanitized,
    causing browsers to execute malicious JavaScript. Characters that allow an XSS
    vulnerability to occur include double quotes (`"`), single quotes (`'`), and angle
    brackets (`< >`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If a site properly sanitizes characters, the characters render as HTML entities.
    For example, the page source for a web page would show these characters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A double quote (`"`) as `&quot;` or `&#34;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single quote (`'`) as `&apos;` or `&#39;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An opening angle bracket (`<`) as `&lt;` or `&#60;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A closing angle bracket (`>`) as `&gt;` or `&#62;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These special characters, when unsanitized, define a web page’s structure in
    HTML and JavaScript. For example, if a site doesn’t sanitize angle brackets, you
    could insert `<script></script>` to inject a payload, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you submit this payload to a website that renders it unsanitized, the `<script></script>`
    tags instruct the browser to execute the JavaScript between them. The payload
    executes the `alert` function, creating a pop-up dialog that displays the information
    passed to `alert`. The reference to `document` inside the parentheses is the DOM,
    which returns the domain name of the site. For example, if the payload executes
    on *https://www.<example>.com/foo/bar/*, the pop-up dialog displays *www.<example>.com*.
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve found an XSS vulnerability, confirm its impact because not all XSS
    vulnerabilities are the same. Confirming the impact of a bug and including this
    analysis improves your report, helps triagers validate your bug, and might raise
    your bounty.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an XSS vulnerability on a site that doesn’t use the `httponly`
    flag on sensitive cookies is different from an XSS vulnerability that does. When
    a site has no `httponly` flag, your XSS can read cookie values; if those values
    include session-identifying cookies, you could steal a target’s session and access
    their account. You can alert `document.cookie` to confirm that you can read sensitive
    cookies (knowing which cookies a site considers sensitive requires trial and error
    on each site). Even when you can’t access sensitive cookies, you can alert `document.domain`
    to confirm whether you can access sensitive user information from the DOM and
    perform actions on behalf of the target.
  prefs: []
  type: TYPE_NORMAL
- en: But the XSS might not be a vulnerability for the site if you don’t alert the
    correct domain. For example, if you alert `document.domain` from a sandboxed iFrame,
    your JavaScript could be harmless because it can’t access cookies, perform actions
    on the user’s account, or access sensitive user information from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript is rendered harmless because browsers implement a *Same Origin
    Policy (SOP)* as a security mechanism. The SOP restricts how documents (the D
    in DOM) can interact with resources loaded from another origin. The SOP protects
    innocent websites from malicious sites attempting to exploit the website through
    the user. For example, if you visited *www.<malicious>.com* and it invoked a `GET`
    request to *www.<example>.com/profile* in your browser, the SOP would prevent
    *www.<malicious>.com* from reading the *www.<example>.com/profile* response. The
    *www.<example>.com* site might allow sites from a different origin to interact
    with it, but usually those interactions are limited to specific websites *www.<example>.com*
    trusts.
  prefs: []
  type: TYPE_NORMAL
- en: A website’s protocol (e.g., HTTP or HTTPS), host (e.g., *www.<example>.com*),
    and port determine a site’s origin. Internet Explorer is an exception to this
    rule. It doesn’t consider the port to be part of the origin. [Table 7-1](ch07.xhtml#ch07tab01)
    shows examples of origins and whether they would be considered the same as *http://www.<example>.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Examples of SOP'
  prefs: []
  type: TYPE_NORMAL
- en: '| **URL** | **Same origin?** | **Reason** |'
  prefs: []
  type: TYPE_TB
- en: '| *http://www.<example>.com/countries* | Yes | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| *http://www.<example>.com/countries/Canada* | Yes | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| *https://www.<example>.com/countries* | No | Different protocol |'
  prefs: []
  type: TYPE_TB
- en: '| *http://store.<example>.com/countries* | No | Different host |'
  prefs: []
  type: TYPE_TB
- en: '| *http://www.<example>.com:8080/countries* | No | Different port |'
  prefs: []
  type: TYPE_TB
- en: 'In some situations, the URL won’t match the origin. For example, `about:blank`
    and `javascript:` schemes inherit the origin of the document opening them. The
    `about:blank` context accesses information from or interacts with the browser,
    whereas `javascript:` executes JavaScript. The URL doesn’t provide information
    about its origin, so browsers handle these two contexts differently. When you
    find an XSS vulnerability, using `alert(document.domain)` in your proof of concept
    is helpful: it confirms the origin where the XSS executes, especially when the
    URL shown in the browser is different from the origin the XSS executes against.
    This is exactly what happens when a website opens a `javascript:` URL. If *www.<example>.com*
    opened a `javascript:alert(document.domain)` URL, the browser address would show
    `javascript:alert(document.domain)`. But the alert box would show *www.<example>.com*
    because the alert inherits the origin of the previous document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although I’ve only covered an example that uses the HTML `<script>` tag to
    achieve XSS, you can’t always submit HTML tags when you find a potential injection.
    In those cases, you might be able to submit single or double quotes to inject
    an XSS payload. The XSS could be significant depending on where your injection
    occurs. For example, let’s say you can access the following code’s `value` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By injecting a double quote in the `value` attribute, you could close the existing
    quote and inject a malicious XSS payload into the tag. You might do this by changing
    the `value` attribute to `hacker" onfocus=alert(document.cookie) autofocus "`,
    which would result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `autofocus` attribute instructs the browser to place the cursor focus on
    the input text box as soon as the page loads. The `onfocus` JavaScript attribute
    tells the browser to execute JavaScript when the input text box is the focus (without
    `autofocus`, the `onfocus` would occur when a person clicks the text box). But
    these two attributes have limits: you can’t autofocus on a hidden field. Also,
    if multiple fields are on a page with autofocus, either the first or last element
    will be the focus depending on the browser. When the payload runs, it would alert
    on `document.cookie`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, let’s say you had access to a variable within a `<script>` tag.
    If you could inject single quotes into the value for the `name` variable in the
    following code, you could close the variable and execute your own JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we control the value `hacker`, changing the `name` variable to `hacker'';alert(document.cookie);''`
    would result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Injecting a single quote and semicolon closes the variable `name`. Because we’re
    using a `<script>` tag, the JavaScript function `alert(document.cookie)`, which
    we also injected, will execute. We add an additional `;'` to end our function
    call and ensure the JavaScript is syntactically correct because the site includes
    a `';` to close the `name` variable. Without the `';` syntax at the end, there
    would be a dangling single quote, which could break the page syntax.
  prefs: []
  type: TYPE_NORMAL
- en: As you now know, you can execute XSS using several methods. The website *[http://html5sec.org/](http://html5sec.org/)*,
    which the penetration testing experts at Cure53 maintain, is a great reference
    for XSS payloads.
  prefs: []
  type: TYPE_NORMAL
- en: '**Types of XSS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two main types of XSS: reflected and stored. *Reflected XSS* occurs
    when a single HTTP request that isn’t stored anywhere on the site delivers and
    executes the XSS payload. Browsers, including Chrome, Internet Explorer, and Safari,
    try to prevent this type of vulnerability by introducing *XSS Auditors* (in July
    2018, Microsoft announced they are retiring the XSS Auditor in the Edge browser
    due to other security mechanisms available to prevent XSS). XSS Auditors attempt
    to protect users from malicious links that execute JavaScript. When an XSS attempt
    occurs, the browser shows a broken page with a message stating the page has been
    blocked to protect users. [Figure 7-1](ch07.xhtml#ch07fig01) shows an example
    in Google Chrome.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: A page blocked by the XSS Auditor in Google Chrome*'
  prefs: []
  type: TYPE_NORMAL
- en: Despite browser developers’ best efforts, attackers frequently bypass XSS Auditors
    because JavaScript can execute in complex ways on a site. Because these methods
    of bypassing XSS Auditors often change, they’re beyond the scope of this book.
    But two great resources to learn more are FileDescriptor’s blog post at *[https://blog.innerht.ml/the-misunderstood-x-xss-protection/](https://blog.innerht.ml/the-misunderstood-x-xss-protection/)*
    and Masato Kinugawa’s filter bypass cheat sheet at *https://github.com/masatokinugawa/filterbypass/wiki/Browser’s-XSS-Filter-Bypass-Cheat-Sheet/*.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, *stored XSS* occurs when a site saves a malicious payload and renders
    it unsanitized. Sites might also render the inputted payload in various locations.
    The payload might not execute immediately after submission, but it could execute
    when another page is accessed. For example, if you create a profile on a website
    with an XSS payload as your name, the XSS might not execute when you view your
    profile; instead, it might execute when someone searches for your name or sends
    you a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also sort XSS attacks into the following three subcategories: DOM-based,
    blind, and self. *DOM-based XSS* attacks involve manipulating a website’s existing
    JavaScript code to execute malicious JavaScript; it can be either stored or reflected.
    For example, let’s say the web page *www.<example>.com/hi/* used the following
    HTML to replace its page contents with a value from a URL without checking for
    malicious input. It might be possible to execute XSS.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example web page, the script tag calls the document object’s `getElementById`
    method to find the HTML element with the ID `'name'`. The call returns a reference
    to the span element in the `<h1>` tag. Next, the script tag modifies the text
    between the `<span id="name"></span>` tags using the `innerHTML` method. The script
    sets the text between `<span></span>` to the value from the `location.hash`, which
    is any text that occurs after a `#` in the URL (`location` is another browser
    API, similar to the DOM; it provides access to information about the current URL).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, visiting *www.<example>.com/hi#Peter/* would result in the page’s HTML
    dynamically being updated to `<h1><span id="name">Peter</span></h1>`. But this
    page doesn’t sanitize the `#` value in the URL before updating the `<span>` element.
    So if a user visited *www.<example>.com/h1#<img src=x onerror=alert(document.domain)>*,
    a JavaScript alert box would pop up and display *www.<example>.com* (assuming
    no image `x` was returned to the browser). The resulting HTML from the page would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This time, instead of rendering Peter between `<h1>` tags, the webpage would
    display a JavaScript alert box with the `document.domain` name. An attacker could
    use this because, to execute any JavaScript, they provide the JavaScript attribute
    of the `<img>` tag to the `onerror`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Blind XSS* is a stored XSS attack in which another user renders the XSS payload
    from a location of the website a hacker can’t access. For example, this might
    happen if you could add XSS as your first and last name when you create a personal
    profile on a site. Those values can be escaped when regular users view your profile.
    But when an administrator visits an administrative page listing all new users
    on the site, the values might not be sanitized and the XSS might execute. The
    tool XSSHunter (*[https://xsshunter.com/](https://xsshunter.com/)*) by Matthew
    Bryant is ideal for detecting blind XSS. The payloads Bryant designed execute
    JavaScript, which loads a remote script. When the script executes, it reads the
    DOM, browser information, cookies, and other information the payload sends back
    to your XSSHunter account.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Self XSS* vulnerabilities are those that can impact only the user entering
    the payload. Because an attacker can attack only themselves, self XSS is considered
    low severity and doesn’t qualify for a reward in most bug bounty programs. For
    example, it can occur when the XSS is submitted via a `POST` request. But because
    the request is protected by CSRF, only the target can submit the XSS payload.
    Self XSS may or may not be stored.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find a self XSS, look for opportunities to combine it with another vulnerability
    that can affect other users, such as *login/logout CSRF*. In this type of attack,
    a target is logged out of their account and logged into the attacker’s account
    to execute the malicious JavaScript. Typically, a login/logout CSRF attack requires
    the ability to log the target back into an account using malicious JavaScript.
    We won’t look at a bug that uses login/logout CSRF, but a great example is one
    that Jack Whitton found on an Uber site, which you can read about at *https://whitton.io/articles/uber-turning-self-xss-into-good-xss/*.
  prefs: []
  type: TYPE_NORMAL
- en: 'XSS’s impact depends on a variety of factors: whether it’s stored or reflected,
    whether cookies are accessible, where the payload executes, and so on. Despite
    the potential damage XSS can cause on a site, fixing XSS vulnerabilities is often
    easy, requiring only that software developers sanitize user input (just as with
    HTML injection) before rendering it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shopify Wholesale**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[wholesale.shopify.com/](http://wholesale.shopify.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/106293/](https://hackerone.com/reports/106293/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** December 21, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $500'
  prefs: []
  type: TYPE_NORMAL
- en: 'XSS payloads don’t have to be complicated, but you do need to tailor them to
    the location where they’ll be rendered and whether they’ll be contained in HTML
    or JavaScript tags. In December 2015, Shopify’s wholesale website was a simple
    web page with a distinct search box at the top. The XSS vulnerability on this
    page was simple but easily missed: text input into the search box was being reflected
    unsanitized within existing JavaScript tags.'
  prefs: []
  type: TYPE_NORMAL
- en: People overlooked this bug because the XSS payload wasn’t exploiting unsanitized
    HTML. When XSS exploits how HTML is rendered, attackers can see the effect of
    the payload because HTML defines the look and feel of a site. In contrast, JavaScript
    code can *change* the look and feel of a site or perform another action, but it
    doesn’t *define* the site’s look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, entering `"><script>alert('XSS')</script>` wouldn’t execute the
    XSS payload `alert('XSS')` because Shopify was encoding the HTML tags `<>`. These
    characters would have been rendered harmlessly as `&lt;` and `&gt;`. A hacker
    realized the input was being rendered unsanitized within `<script></script>` tags
    on the web page. Most likely, the hacker reached this conclusion by viewing the
    page’s source, which contains the HTML and JavaScript for the page. You can view
    the source for any web page by entering *view-source:URL* in a browser address
    bar. As an example, [Figure 7-2](ch07.xhtml#ch07fig02) shows part of the *[https://nostarch.com/](https://nostarch.com/)*
    site’s page source.
  prefs: []
  type: TYPE_NORMAL
- en: After realizing the input was rendered unsanitized, the hacker entered `test';alert('XSS');'`
    into Shopify’s search box, creating a JavaScript alert box with the text `'XSS'`
    in it when rendered. Although it’s unclear in the report, it’s likely that Shopify
    was rendering the searched term in a JavaScript statement, like `var search_term
    = '`<INJECTION>`'`. The first part of the injection, `test';`, would have closed
    that tag and inserted the `alert('XSS');` as a separate statement. The final `'`
    would have ensured the JavaScript syntax was correct. The result would presumably
    have looked like `var search_term = 'test';alert('xss'); '';`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: The page source for* [https://nostarch.com/](https://nostarch.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'XSS vulnerabilities don’t have to be intricate. The Shopify vulnerability wasn’t
    complex: it was just a simple input text field that didn’t sanitize user input.
    When you’re testing for XSS, be sure to view the page source and confirm whether
    your payloads are being rendered in HTML or JavaScript tags.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shopify Currency Formatting**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *<YOURSITE>.myshopify.com/admin/settings/general/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/104359/](https://hackerone.com/reports/104359/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Report date:** December 9, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $1,000'
  prefs: []
  type: TYPE_NORMAL
- en: XSS payloads don’t always execute immediately. Because of this, hackers should
    make sure the payload is properly sanitized in all the places it might be rendered.
    In this example, Shopify’s store settings allowed users to change currency formatting.
    In December 2015, the values from those input boxes weren’t properly sanitized
    when setting up social media pages. A malicious user could set up a store and
    inject an XSS payload in a store’s currency settings field, as shown in [Figure
    7-3](ch07.xhtml#ch07fig03). The payload was rendered in the store’s social media
    sales channel. The malicious user could configure the store to execute the payload
    when another store administrator visited the sales channel.
  prefs: []
  type: TYPE_NORMAL
- en: Shopify uses the Liquid template engine to dynamically render content on shop
    pages. For example, `${{ }}` is the syntax for Liquid; the variable to be rendered
    is entered inside the inner set of braces. In [Figure 7-3](ch07.xhtml#ch07fig03),
    `${{amount}}` is a legitimate value but is appended with the value `"><img src=x
    onerror=alert(document.domain)>`, which is the XSS payload. The `">` closes the
    HTML tag that the payload is being injected into. When the HTML tag is closed,
    the browser renders the image tag and looks for an image `x` indicated in the
    `src` attribute. Because an image with this value is unlikely to exist on Shopify’s
    website, the browser encounters an error and calls the JavaScript event handler
    `onerror`. The event handler executes the JavaScript defined in the handler. In
    this case, it’s the function `alert(document.domain)`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Shopify’s currency settings page at the time of the report*'
  prefs: []
  type: TYPE_NORMAL
- en: While the JavaScript wouldn’t execute when a user visited the currency page,
    the payload also appeared in the Shopify store’s social media sales channel. When
    other store administrators clicked the vulnerable sales channel tab, the malicious
    XSS would be rendered unsanitized and execute the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: XSS payloads don’t always execute immediately after they’re submitted. Because
    a payload could be used in multiple locations on a site, be sure to visit each
    location. In this case, simply submitting the malicious payload on the currency
    page didn’t execute the XSS. The bug reporter had to configure another website
    feature to cause the XSS to execute.
  prefs: []
  type: TYPE_NORMAL
- en: '**Yahoo! Mail Stored XSS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** Yahoo! Mail'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://klikki.fi/adv/yahoo.html](https://klikki.fi/adv/yahoo.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** December 26, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $10,000'
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing user input by modifying the inputted text can sometimes lead to problems
    if done incorrectly. In this example, Yahoo! Mail’s editor allowed people to embed
    images in an email via HTML using an `<img>` tag. The editor sanitized the data
    by removing any JavaScript attributes, such as `onload`, `onerror`, and so on,
    to avoid XSS vulnerabilities. However, it failed to avoid vulnerabilities that
    occurred when a user intentionally submitted malformed `<img>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Most HTML tags accept attributes, which are additional information about the
    HTML tag. For example, the `<img>` tag requires a `src` attribute pointing to
    the address of the image to render. The tag also allows for `width` and `height`
    attributes to define the image’s size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some HTML attributes are Boolean attributes: when they’re included in the HTML
    tag, they’re considered true, and when they’re omitted, they’re considered false.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this vulnerability, Jouko Pynnonen found that if he added Boolean attributes
    to HTML tags with a value, Yahoo! Mail would remove the value but leave the attribute’s
    equal sign. Here is one of Pynnonen’s examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the HTML input tag might include a `CHECKED` attribute denoting whether
    a check box should be rendered as checked off. Based on Yahoo’s tag parsing, the
    line would become this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This may look harmless, but HTML allows zero or more space characters around
    the equal sign in an unquoted attribute value. So browsers read this as `CHECKED`
    having the value of `NAME="check` and the input tag having a third attribute named
    `box`, which doesn’t have a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exploit this, Pynnonen submitted the following `<img>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Yahoo! Mail filtering would change this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `ismap` value is a Boolean `<img>` tag attribute that indicates whether
    an image has clickable areas. In this case, Yahoo! removed `'xxx'`, and the single
    quote from the end of the string was moved to the end of the `yyy`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the backend of a site will be a black box and you won’t know how
    code is being processed, as in this case. We don’t know why the `'xxx'` was removed
    or why the single quote was moved to the end of `yyy`. Yahoo’s parsing engine
    or the way the browser handled whatever Yahoo! returned could have made these
    changes. Still, you can use these oddities to find vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way the code was processed, an `<img>` tag with a height and
    width of 100 percent was rendered, making the image take up the entire browser
    window. When a user moved their mouse over the web page, the XSS payload would
    execute because of the `onmouseover=alert(/XSS/)` part of the injection.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When sites sanitize user input by modifying it instead of encoding or escaping
    values, you should continue testing the site’s server-side logic. Think about
    how a developer might have coded their solution and what assumptions they’ve made.
    For example, check whether the developer considered what happens if two `src`
    attributes are submitted or if spaces are replaced with slashes. In this case,
    the bug reporter checked what would happen when Boolean attributes were submitted
    with values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Google Image Search**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[images.google.com/](http://images.google.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://mahmoudsec.blogspot.com/2015/09/how-i-found-xss-vulnerability-in-google.html](https://mahmoudsec.blogspot.com/2015/09/how-i-found-xss-vulnerability-in-google.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** September 12, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** Undisclosed'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on where your input is being rendered, you don’t always need to use
    special characters to exploit XSS vulnerabilities. In September 2015, Mahmoud
    Jamal was using Google Images to find an image for his HackerOne profile. While
    browsing, he noticed the image URL *[http://www.google.com/imgres?imgurl=https://lh3.googleuser.com/](http://www.google.com/imgres?imgurl=https://lh3.googleuser.com/)*...
    from Google.
  prefs: []
  type: TYPE_NORMAL
- en: Noting the reference to `imgurl` in the URL, Jamal realized he could control
    the parameter’s value; it would likely be rendered on the page as a link. When
    hovering over the thumbnail image for his profile, Jamal confirmed that the `<a>`
    tag `href` attribute included the same URL. He tried changing the `imgurl` parameter
    to `javascript:alert(1)` and noticed that the `href` attribute also changed to
    the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `javascript:alert(1)` payload is useful when special characters are sanitized
    because the payload doesn’t contain special characters for the website to encode.
    When clicking a link to `javascript:alert(1)`, a new browser window opens and
    the `alert` function executes. In addition, because the JavaScript executes in
    the context of the initial web page, which contains the link, the JavaScript can
    access the DOM of that page. In other words, a link to `javascript:alert(1)` would
    execute the `alert` function against Google. This result shows that a malicious
    attacker could potentially access information on the web page. If clicking a link
    to the JavaScript protocol didn’t inherit the context of the initial site rendering
    the link, the XSS would be harmless: attackers couldn’t access the vulnerable
    web page’s DOM.'
  prefs: []
  type: TYPE_NORMAL
- en: Excited, Jamal clicked what he thought would be his malicious link, but no JavaScript
    executed. Google had sanitized the URL address when the mouse button was clicked
    via the anchor tag’s `onmousedown` JavaScript attribute.
  prefs: []
  type: TYPE_NORMAL
- en: As a workaround, Jamal tried tabbing through the page. When he got to the View
    Image button, he pressed ENTER. The JavaScript was triggered because he could
    visit the link without clicking the mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Always be on the lookout for URL parameters that might be reflected on the page
    because you have control over those values. If you find any URL parameters that
    are rendered on a page, consider their context as well. URL parameters might present
    opportunities to get around filters that remove special characters. In this example,
    Jamal didn’t need to submit any special characters because the value was rendered
    as the `href` attribute in an anchor tag.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, look for vulnerabilities even on Google and other major sites.
    It’s easy to assume that just because a company is huge, all its vulnerabilities
    have been discovered. Clearly, that isn’t always the case.
  prefs: []
  type: TYPE_NORMAL
- en: '**Google Tag Manager Stored XSS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[tagmanager.google.com/](http://tagmanager.google.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://blog.it-securityguard.com/bugbounty-the-5000-google-xss/](https://blog.it-securityguard.com/bugbounty-the-5000-google-xss/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** October 31, 2014'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $5,000'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common best practice of websites is to sanitize user input when rendering
    it instead of when it’s being saved on submission. The reason is that it’s easy
    to introduce new ways to submit data to a site (like a file upload) and to forget
    to sanitize the input. In some cases, however, companies don’t follow this practice:
    Patrik Fehrenbach of HackerOne discovered this lapse in October 2014 when he was
    testing Google for XSS vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Google Tag Manager is an SEO tool that makes it easy for marketers to add and
    update website tags. To do this, the tool has a number of web forms that users
    interact with. Fehrenbach began by finding available form fields and entering
    XSS payloads, such as `#"><img src=/ onerror=alert(3)>`. If the payload was accepted
    by the form field, the payload would close the existing HTML tag and then try
    to load a nonexistent image. Because the image wouldn’t be found, the website
    would execute the `onerror` JavaScript function `alert(3)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But Fehrenbach’s payload didn’t work. Google was properly sanitizing his input.
    Fehrenbach noticed an alternative way to submit his payload. In addition to the
    form fields, Google provides the ability to upload a JSON file with multiple tags.
    So Fehrenbach uploaded the following JSON file to Google’s service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the value of the `name` attribute is the same XSS payload Fehrenbach
    tried previously. Google wasn’t following best practices and was sanitizing input
    from the web form on submission instead of at the time of rendering. As a result,
    Google forgot to sanitize input from the file upload, so Fehrenbach’s payload
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two details are worth noting in Fehrenbach’s report. First, Fehrenbach found
    an alternative input method for his XSS payload. You should look for an alternative
    input method as well. Be sure to test all methods a target provides to enter input,
    because the way each input is processed might be different. Second, Google was
    attempting to sanitize on input instead of at the time of rendering. Google could
    have prevented this vulnerability by following best practices. Even when you know
    website developers typically use common countermeasures against certain attacks,
    check for vulnerabilities. Developers can make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: '**United Airlines XSS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Hard'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[checkin.united.com/](http://checkin.united.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[http://strukt93.blogspot.jp/2016/07/united-to-xss-united.html](http://strukt93.blogspot.jp/2016/07/united-to-xss-united.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** July 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** Undisclosed'
  prefs: []
  type: TYPE_NORMAL
- en: In July 2016, while searching for cheap flights, Mustafa Hasan began looking
    for bugs on United Airlines sites. He found that visiting the subdomain *[checkin.united.com](http://checkin.united.com)*
    redirected to a URL that included an `SID` parameter. Noticing that any value
    passed to the parameter was rendered in the page HTML, he tested `"><svg onload=confirm(1)>`.
    If rendered improperly, the tag would close the existing HTML tag and inject Hasan’s
    `<svg>` tag, resulting in a JavaScript pop-up courtesy of the `onload` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'But when he submitted his HTTP request, nothing happened, although his payload
    was rendered as is, unsanitized. Rather than giving up, Hasan opened the site’s
    JavaScript files, likely with the browser’s development tools. He found the following
    code, which overrides JavaScript attributes that might lead to XSS, such as the
    attributes `alert`, `confirm`, `prompt`, and `write`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Even if you don’t know JavaScript, you might guess what’s happening via the
    use of certain words. For example, the `exec_original` parameter name ➊ in the
    `XSSObject proxy` definition implies a relationship that executes something. Immediately
    below the parameter is a list of all our interesting functions and the value `false`
    being passed (except in the last instance) ➋. We can assume the site is trying
    to protect itself by disallowing the execution of the JavaScript attributes passed
    into `XSSObject proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notably, JavaScript allows you to override existing functions. So Hasan first
    tried to restore the `document.write` function by adding the following value in
    the `SID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This value sets the document’s `write` function to its original functionality
    by using the `write` function’s prototype. Because JavaScript is object oriented,
    all objects have a prototype. By calling on the `HTMLDocument`, Hasan set the
    current document’s `write` function back to the original implementation from `HTMLDocument`.
    He then called `document.write('STRUKT')` to add his name in plaintext to the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'But when Hasan tried to exploit this vulnerability, he got stuck again. He
    reached out to Rodolfo Assis for help. Working together, they realized that United’s
    XSS filter was missing the override for a function similar to `write`: the `writeln`
    function. The difference between these two functions is that `writeln` adds a
    newline after writing its text, whereas `write` doesn’t.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assis believed he could use the `writeln` function to write content to the
    HTML document. Doing so would allow him to bypass one piece of United’s XSS filter.
    He did this with the following payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But his JavaScript still didn’t execute because the XSS filter was still being
    loaded and overriding the `alert` function: Assis needed to use a different method.
    Before we look at the final payload and how Assis worked around the `alert` override,
    let’s break down his initial payload.'
  prefs: []
  type: TYPE_NORMAL
- en: The first piece, `";}`, closes the existing JavaScript being injected into.
    Next, `{` opens the JavaScript payload, and `document.writeln` calls the JavaScript
    document object’s `writeln` function to write content to the DOM. The `decodeURI`
    function passed to `writeln` decodes encoded entities in a URL (for example, `%22`
    will become `"`). The `location.hash` code passed to `decodeURI` returns all parameters
    after the `#` in the URL, which is defined later. After this initial setup is
    done, `-"` replaces the quote at the start of the payload to ensure proper JavaScript
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece, `#<img src=1 onerror=alert(1)>`, adds a parameter that is never
    sent to the server. This last piece is a defined, optional part of a URL, called
    a *fragment*, and it’s meant to refer to a part of the document. But in this case,
    Assis used a fragment to take advantage of the hash (`#`) that defines the start
    of the fragment. The reference to `location.hash` returns all content after the
    `#`. But the returned content will be URL encoded, so the input `<img src=1 onerror=alert(1)>`
    will be returned as `%3Cimg%20src%3D1%20onerror%3Dalert%281%29%3E%20`. To address
    the encoding, the function `decodeURI` decodes the content back to the HTML `<img
    src=1 onerror=alert(1)>`. This is important because the decoded value is passed
    to the `writeln` function, which writes the HTML `<img>` tag to the DOM. The HTML
    tag executes the XSS when the site can’t find the image `1` referenced in the
    `src` attribute of the tag. If the payload is successful, a JavaScript alert box
    would pop up with the number `1` in it. But it didn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assis and Hasan realized they needed a fresh HTML document within the context
    of the United site: they needed a page that didn’t have the XSS filter JavaScript
    loaded but still had access to the United web page information, cookies, and so
    on. So they used an iFrame with the following payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This payload behaved just like the original URL with the `<img>` tag. But in
    this one they wrote an `<iframe>` to the DOM and changed the `src` attribute to
    use the JavaScript scheme to `alert(document.domain)`. This payload is similar
    to the XSS vulnerability discussed in “[Google Image Search](ch07.xhtml#ch07lev1sec5)”
    on [page 65](ch07.xhtml#page_65), because the JavaScript scheme inherits the context
    of the parent DOM. Now the XSS could access the United DOM, so `document.domain`
    printed *[www.united.com](http://www.united.com)*. The vulnerability was confirmed
    when the site rendered a pop-up alert.
  prefs: []
  type: TYPE_NORMAL
- en: An iFrame can take a source attribute to pull in remote HTML. As a result, Assis
    could set the source to be JavaScript, which immediately called the `alert` function
    with the document domain.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Note three important details about this vulnerability. First, Hasan was persistent.
    Rather than giving up when his payload wouldn’t fire, he dug into the JavaScript
    to find out why. Second, the use of a JavaScript attribute blacklist should tip
    off hackers that XSS bugs might exist in the code because they’re opportunities
    for developer mistakes. Third, having JavaScript knowledge is essential for successfully
    confirming more complex vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XSS vulnerabilities represent real risk for site developers and are still prevalent
    on sites, often in plain sight. By submitting a malicious payload, like `<img
    src=x onerror=alert(document.domain)>`, you can check whether an input field is
    vulnerable. But this isn’t the only way to test for XSS vulnerabilities. Any time
    a site sanitizes input through modification (by removing characters, attributes,
    and so on), you should thoroughly test the sanitization functionality. Look for
    opportunities where sites are sanitizing input on submission rather than when
    rendering the input, and test all methods of input. Also, look for URL parameters
    you control being reflected on the page; these might allow you to find an XSS
    exploit that can bypass encoding, such as adding `javascript:alert(document.domain)`
    to the `href` value in an anchor tag.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to consider all places that a site is rendering your input and
    whether it’s in HTML or JavaScript. Keep in mind that XSS payloads might not execute
    immediately.
  prefs: []
  type: TYPE_NORMAL
