- en: Appendix A. Perl’s Special Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this appendix, I summarize Perl’s most commonly used special (predefined)
    variables, such as `$_`, `$.`, `$/`, `$\`, `$1`, `$2`, `$3` (and so on), `$`,,
    `@F`, and `@ARGV`, among others.
  prefs: []
  type: TYPE_NORMAL
- en: A.1 Variable $_
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `$_` variable, called the *default variable*, is the most commonly used
    variable in Perl. Often this variable is pronounced “it” (when not pronounced
    “dollar-underscore”); as you read on, you’ll understand why.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `-n` and `-p` command-line arguments, it’s (see?) where the
    input is stored. Also, many operators and functions act on it implicitly. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, I place the string `"foo"` in the `$_` variable and then call `print`.
    When given no arguments, `print` prints the contents of the `$_` variable, which
    is `"foo"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `$_` is used by the `s/regex/replace/` and `/regex/` operators when
    used without the `=~` operator. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This one-liner prints only lines that match `/foo/`. The `/foo/` operator implicitly
    operates on the `$_` variable that contains the current line. You could rewrite
    this as follows, but doing so would require too much typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '“If it matches `/foo/`, print it”—you get the idea. You could also replace
    text in all the lines simply by calling `s/foo/bar/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, Perl borrows the `$_` variable from sed. Remember that sed has
    a pattern space? The `$_` variable can also be called Perl’s pattern space. If
    you wrote the previous one-liner (`perl -pe 's/foo/bar/'`) in sed, it would look
    like `sed 's/foo/bar/'` because sed puts each line in the pattern space and the
    `s` command acts on it implicitly. Perl borrows many concepts and commands from
    sed.
  prefs: []
  type: TYPE_NORMAL
- en: Using $_ with the -n argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using the `-n` argument, Perl puts the following loop around your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while (<>)` loop reads lines from standard input or files named on the
    command line and puts each line into the `$_` variable. You can then modify the
    lines and print them. For example, you can reverse the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because I’m using the `-n` argument here, this program becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: which is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The two programs are equivalent because many Perl functions act on `$_` implicitly,
    which makes writing `reverse` and `reverse $_` functionally the same thing. You
    need `scalar` to put the `reverse` function in the scalar context. Otherwise it’s
    in the list context (`print` forces the list context) and won’t reverse strings.
    (I explain the `-n` flag in great detail in one-liner 2.6 on page 12 and line
    reversing in one-liner 6.22 on page 67.)
  prefs: []
  type: TYPE_NORMAL
- en: Using $_ with the -p argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use the `-p` argument, Perl puts the following loop around your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The result is almost the same as for the `-n` argument, except that after each
    iteration the content of `$_` is printed (through `print` in the `continue` block).
  prefs: []
  type: TYPE_NORMAL
- en: 'To reverse the lines as I did with `-n`, I can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The program now becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I’ve modified the `$_` variable and set it to `reverse $_`, which reverses the
    line. The `continue` block makes sure that it’s printed. (One-liner 2.1 on page
    7 explains the `-p` argument in more detail.)
  prefs: []
  type: TYPE_NORMAL
- en: Using $_ explicitly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `$_` variable is also often used explicitly. Here are some examples of
    using the `$_` variable explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output of this one-liner is `2 4 6 8 10 12 14 16 18 20`. Here, I use the
    `map` function to map an expression over each element in the given list and return
    a new list, where each element is the result of the expression. In this case,
    the list is `1..10` (`1 2 3 4 5 6 7 8 9 10`) and the expression is `$_ * 2`, which
    means multiply each element (“it”) by `2`. As you can see, I’m using `$_` explicitly.
    When the `map` function iterates over the list, each element is put into `$_`
    for my convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s use `map` in a handy one-liner. How about one that multiplies each
    element on a line by 2?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner maps the expression `$_ * 2` onto each element in `@F`. The crazy-looking
    `"@{[...]}"` is just a way to execute code inside quotes. (One-liner 4.2 on page
    30 explains `@F`, and one-liner 4.4 on page 32 explains `"@{[...]}"`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Another function that explicitly uses `$_` is `grep`, which lets you filter
    the elements from a list. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The output of this one-liner is `6 7 8 9 10`. As you can see, `grep` filtered
    elements greater than 5 from the list. The condition `$_ > 5` asks, “Is the current
    element greater than 5?”—or, more succinctly, “Is it greater than 5?”
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use `grep` in a one-liner. How about one that finds and prints all elements
    on the current line that are palindromes?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition specified to the `grep` function here is `$_ eq reverse $_`,
    which asks, “Is the current element the same as its reverse?” This condition is
    true only for palindromes. For example, given the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'the one-liner outputs this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all of these elements are palindromes.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn even more about the `$_` variable by typing `perldoc perlvar`
    at the command line. The *perlvar* documentation explains all the predefined variables
    in Perl.
  prefs: []
  type: TYPE_NORMAL
- en: A.2 Variable $.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When reading a file, the `$.` variable always contains the line number of the
    line currently being read. For example, this one-liner numbers the lines in `file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do the same thing with this one-liner, which replaces the current line
    with the line number followed by the same line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `$.` variable isn’t reset across files, so to number multiple files simultaneously,
    you write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner continues numbering lines in `file2` where `file1` left off.
    (If `file1` contains 10 lines, the first line of `file2` is numbered 11.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To reset the `$.` variable, you use an explicit `close` on the current file
    handle `ARGV`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`ARGV` is a special file handle that contains the currently open file. By calling
    `eof`, I’m checking to see if it’s the end of the current file. If so, `close`
    closes it, which resets the `$.` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: You can change what Perl considers to be a line by modifying the `$/` variable.
    The next section discusses this variable.
  prefs: []
  type: TYPE_NORMAL
- en: A.3 Variable $/
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `$/` variable is the input record separator, which is a newline by default.
    This variable tells Perl what to consider a line. Say you have this simple program
    that numbers lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Because `$/` is a newline by default, Perl reads everything up to the first
    newline, puts it in the `$_` variable, and increments the `$.` variable. Next,
    it calls `print "$. $_"`, which prints the current line number and the line. But
    if you change the value of `$/` to two newlines, like `$/ = "\n\n"`, Perl reads
    everything up to the first two newlines; that is, it reads text paragraph by paragraph
    rather than line by line.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another example. If you have a file like the following, you can set `$/`
    to `:`, and Perl will read the file digit by digit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if you set `$/` to `undef`, Perl reads the entire file in a single read
    (called *slurping*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner slurps the entire file `file` in variable `$contents`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also set `$/` to reference an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Perl reads the file 1024 bytes at a time. (This is also called
    *record-by-record reading*.)
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `-0` command-line switch to provide this variable with
    a value, but note that you can’t do the record-by-record version like this. For
    example, to set `$/` to `:`, specify `-0072` because `072` is the octal value
    of the `:` character.
  prefs: []
  type: TYPE_NORMAL
- en: To remember what this variable does, recall that when quoting poetry, lines
    are separated by `/`.
  prefs: []
  type: TYPE_NORMAL
- en: A.4 Variable $\
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dollar-backslash variable is appended after every `print` operation. For
    example, you could append a dot followed by a space `". "` after each `print`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This one-liner produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Modifying this variable is especially helpful when you want to separate printouts
    by double newlines.
  prefs: []
  type: TYPE_NORMAL
- en: To remember this variable, just recall that you probably want to print `\n`
    after every line. Note that for Perl 5.10 and later, the function `say` is available,
    which is like `print`, except that it always adds a newline at the end and doesn’t
    use the `$\` variable.
  prefs: []
  type: TYPE_NORMAL
- en: A.5 Variables $1, $2, $3, and so on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables `$1`, `$2`, `$3`, and so on contain the matches from the corresponding
    set of capturing parentheses in the last pattern match. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner matches lines that contain the string `She said:` and then captures
    everything after the string in variable `$1` and prints it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use another pair of parentheses, the text is captured in variable
    `$2`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this one-liner, first either `"She"` or `"He"` is captured in variable `$1`
    and then anything she or he said is captured in variable `$2` and printed as `"$1:
    $2"`. You’ll get the same number of capture variables as you have pairs of parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid capturing text in a variable, use the `?:` symbols inside the opening
    parenthesis. For example, changing `(She|He)` to `(?:She|He)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: will not capture `"She"` or `"He"` in variable `$1`. Instead, the second pair
    of parentheses captures what she or he said in variable `$1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning with Perl 5.10, you can use named capture groups as in `(?<name>...)`.
    When you do, instead of using variables `$1`, `$2`, and so on, you can use `$+{name}`
    to refer to the group. For example, this captures `"She"` or `"He"` in the named
    group `gender` and the said text in the named group `text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A.6 Variable $,
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `$`, variable is the output field separator for `print` when printing multiple
    values. It’s undefined by default, which means that all items printed are concatenated
    together. Indeed, if you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'you get `123` printed out. If you set `$`, to a colon, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: you get `1:2:3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose you want to print an array of values. If you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'the output is `123`. But if you quote the variable, the values are space separated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So the output is `1 2 3` because the array is interpolated in a double-quoted
    string.
  prefs: []
  type: TYPE_NORMAL
- en: A.7 Variable $”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This brings us to the `$"` variable: a single white space (by default) that’s
    inserted between every array value when it’s interpolated. When you write things
    like `print "@data"`, the `@data` array gets interpolated, and the value of `$"`
    is inserted between every array element. For example, this prints `1 2 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you change `$"` to, say, a dash `-`, the output becomes `1-2-3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Recall the `@{[...]}` trick here. If you `print "@{[...]}"`, you can execute
    code placed between the square brackets. For examples and more details, see section
    [A.1 Variable $_](apa.html#a_1_variable_dollar "A.1 Variable $_")’s discussion
    of the `$_` variable on page 95 and one-liner 4.4 on page 32.
  prefs: []
  type: TYPE_NORMAL
- en: A.8 Variable @F
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@F` variable is created in your Perl program when you use the `-a` argument,
    which stands for auto-split fields. When you use `-a`, the input is split on whitespace
    characters and the resulting fields are put in `@F`. For example, if the input
    line is `foo bar baz`, then `@F` is an array `("foo", "bar", "baz")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique allows you to operate on individual fields. For instance, you
    can access `$F[2]` to print the third field as follows (remembering that arrays
    start from index 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also perform various calculations, like multiplying the fifth field
    by 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, the fifth field `$F[4]` is multiplied by 2, and `print "@F"` prints all
    the fields, separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `-a` argument with the `-F` argument, which specifies the
    character to split on. For example, to process the colon-separated entries in
    */etc/passwd* entries, you write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: which prints the usernames from */etc/passwd*.
  prefs: []
  type: TYPE_NORMAL
- en: A.9 Variable @ARGV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@ARGV` variable contains the arguments that you pass to your Perl program.
    For example, this prints `foo bar baz`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use `-n` or `-p` flags, the arguments that you pass to your Perl program
    are opened one by one as files and removed from `@ARGV`. To access the filenames
    passed to your program, save them in a new variable in the `BEGIN` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now you can use `@A` in your program, which contains `("file1", "file2")`. If
    you didn’t do this and you used `@ARGV`, it would contain `("file2")` at first,
    but when `file1` was processed, it would be empty `()`. Be careful here!
  prefs: []
  type: TYPE_NORMAL
- en: A similar-looking variable, `$ARGV`, contains the filename of the file currently
    being read, which is `"-"` if the program is currently reading from the standard
    input.
  prefs: []
  type: TYPE_NORMAL
- en: A.10 Variable %ENV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `%ENV` hash contains environment variables from your shell. This variable
    comes in handy when you wish to predefine some values in your script and then
    use these values in your Perl program or one-liner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you want to use the `system` function to execute a program that’s not in
    the path. You could modify the `$ENV{PATH}` variable and append the needed path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This one-liner prints all environment variables from Perl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It loops over the keys (environment variable names) of the `%ENV` hash, puts
    each key into the `$_` variable, and then prints the name followed by `$ENV{$_}`,
    which is the value of the environment variable.
  prefs: []
  type: TYPE_NORMAL
