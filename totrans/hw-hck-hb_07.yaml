- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: 'X Marks the Spot: Trezor One Wallet Memory Dump'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 标记地点：Trezor One 钱包内存转储
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Let’s complete this series of chapters on fault injection by breaking a real
    target: the Trezor One wallet. We’ll use electromagnetic fault injection to demonstrate
    memory dumping and to allow us to extract the recovery seed, which is all that’s
    needed to access the wallet’s contents.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过破解一个真实目标来完成这一系列关于故障注入的章节：Trezor One 钱包。我们将使用电磁故障注入技术来演示内存转储，并提取恢复种子，恢复种子是访问钱包内容所需的唯一信息。
- en: This chapter will be the most open-ended one in the book. It describes an advanced
    attack that may require more specialized equipment and has a very low success
    rate, even when well-tuned. In fact, re-creating this attack would make a good
    academic term project. To follow along with the entire attack, you’ll need a solid
    understanding of embedded design, along with some complicated instrumentation
    setup and a little bit of luck on top. However, we think it’s important to show
    what it takes to move from simple devices to actual products.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是本书中最开放的一章。它描述了一种高级攻击，可能需要更专业的设备，并且即使调整得很精确，成功率也非常低。事实上，重新创建这种攻击将是一个很好的学期项目。要跟进整个攻击过程，你需要对嵌入式设计有扎实的理解，配合一些复杂的仪器设置，并且还需要一些运气。不过，我们认为展示从简单设备到实际产品的过渡是很重要的。
- en: We discussed electromagnetic fault injection, or EMFI, in the section “Electromagnetic
    Fault Injection” in Chapter 5. EMFI tries to build a powerful pulse immediately
    above the top surface of the device itself, causing all sorts of corruption within
    the target. In this chapter, we’ll use an EMFI tool called ChipSHOUTER to perform
    the injection.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第5章的“电磁故障注入”一节中讨论过电磁故障注入（EMFI）。EMFI 试图在设备表面上方立即产生强大的脉冲，导致目标内部发生各种破坏。在本章中，我们将使用一款名为
    ChipSHOUTER 的 EMFI 工具来进行故障注入。
- en: Attack Introduction
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击介绍
- en: Our victim is a Trezor One bitcoin wallet. This little device can be used to
    store bitcoins, which ultimately means that it provides a method of securely storing
    a private key used for cryptographic operations. We don’t need to dig into details
    of the wallet’s operation, but understanding the idea of a *recovery seed* is
    critical. The recovery seed is a series of words that encode a recovery key, and
    knowing that recovery seed is sufficient to recover the private key. This means
    that someone who steals only the recovery seed (without further access to the
    wallet) could access funds stored in the wallet itself. An attack that finds the
    key would be rather detrimental to the security of the owner’s precious coin.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是 Trezor One 比特币钱包。这个小设备可以用来存储比特币，实际上意味着它提供了一种安全存储用于加密操作的私钥的方法。我们不需要深入探讨钱包的操作细节，但理解
    *恢复种子* 的概念至关重要。恢复种子是一系列编码恢复密钥的单词，知道该恢复种子就足以恢复私钥。这意味着，盗取恢复种子的人（如果没有进一步访问钱包）也可以访问钱包中存储的资金。任何能找到密钥的攻击，都会对所有者珍贵的比特币安全构成严重威胁。
- en: The attack we describe here was inspired by some other work. The “wallet.fail”
    presentation at Chaos Computer Club (CCC) by Dmitry Nedospasov, Thomas Roth, and
    Josh Datko demonstrated how to break the STM32F2 security protection and dump
    the static RAM (SRAM) contents. Instead, we’ll show how to dump the flash memory
    contents directly where the seed is stored, so it’s a different attack but with
    similar end results.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述的攻击灵感来自于其他一些工作。Dmitry Nedospasov、Thomas Roth 和 Josh Datko 在 Chaos Computer
    Club (CCC) 上的“wallet.fail”演示展示了如何突破 STM32F2 安全保护并转储静态 RAM (SRAM) 内容。相反，我们将展示如何直接转储存储种子的闪存内容，因此这是一个不同的攻击方式，但结果相似。
- en: We’ll use EMFI, allowing us to perform the attack without even removing the
    enclosure. This means someone can perform the attack without leaving any trace
    of modifying the wallet, no matter how carefully it’s inspected. This chapter
    introduces several more advanced tools, and you’ll see in their usage that it
    can be worth the investment when it comes to looking at real targets. As an example,
    we’ll use USB as a way of timing our attack. A true USB sniffer (such as a Total
    Phase Beagle USB 480) is instrumental here in understanding this timing. We have
    a longer discussion of tools in Appendix A.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 EMFI 技术，这样我们可以在不拆除外壳的情况下进行攻击。这意味着攻击者可以在不留下任何修改钱包痕迹的情况下进行攻击，无论钱包经过多仔细的检查。本章介绍了几种更高级的工具，你将看到，使用这些工具时，投资在真实目标的攻击上是值得的。例如，我们将使用
    USB 作为我们攻击的时序工具。真正的 USB 嗅探器（例如 Total Phase Beagle USB 480）在理解时序方面至关重要。附录 A 中有关于工具的更详细讨论。
- en: Trezor One Wallet Internals
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Trezor One 钱包内部结构
- en: The Trezor One wallet is open source, which makes this attack a wonderful demonstration
    for teaching EMFI and fault injection. You can freely modify the code or program
    older versions that have not yet patched the vulnerability.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Trezor One 钱包是开源的，这使得这个攻击成为了一个很好的演示案例，用于教授 EMFI 和故障注入。你可以自由修改代码或编程旧版本，这些版本尚未修补该漏洞。
- en: The Trezor sources are available on GitHub in the trezor-mcu project. If you
    want to follow the steps in this chapter, select the “v1.7.3” tag on GitHub, or
    follow the link [https://github.com/trezor/trezor-mcu/tree/v1.7.3/](https://github.com/trezor/trezor-mcu/tree/v1.7.3/),
    which will take you to this exact version. These flaws have long been fixed in
    a firmware release that will be available by the time you read this book, so you’ll
    need to look at the older (vulnerable) code to better understand the exact attack.
    The Trezor is based on an STM32F205\. [Figure 7-1](#figure7-1) shows the device
    sans enclosure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Trezor 的源代码可以在 GitHub 上的 trezor-mcu 项目中找到。如果你想按照本章的步骤进行操作，可以在 GitHub 上选择“v1.7.3”标签，或者点击链接[https://github.com/trezor/trezor-mcu/tree/v1.7.3/](https://github.com/trezor/trezor-mcu/tree/v1.7.3/)，该链接将带你到这个确切版本。这个漏洞在固件发布后早已被修复，届时你阅读本书时该版本已经不可用，所以你需要查看较旧的（存在漏洞的）代码，以更好地理解具体的攻击方式。Trezor
    基于 STM32F205。图[7-1](#figure7-1)显示了没有外壳的设备。
- en: '![f07001](image_fi/278748c07/f07001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![f07001](image_fi/278748c07/f07001.png)'
- en: 'Figure 7-1: Trezor One wallet internals'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：Trezor One 钱包内部结构
- en: The six pin sockets on the left-hand side of the printed circuit board (PCB)
    are the JTAG header. The STM32F205 is just below the surface of the enclosure,
    a feature we’ll use to make our attack more realistic in practical scenarios.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 打印电路板（PCB）左侧的六个插座是 JTAG 接口。STM32F205 芯片位于外壳表面下方，这是我们在实际场景中使攻击更加真实的一个特点。
- en: The actual sensitive recovery seed is stored in flash memory in a section called
    the *metadata*. It’s located just after the bootloader, as shown in [Listing 7-1](#listing7-1).
    Part of the header file defines the location of various items of interest within
    the flash memory space.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的敏感恢复种子存储在一个叫做 *metadata* 的闪存部分。它位于引导加载程序之后，如[列表 7-1](#listing7-1)所示。部分头文件定义了闪存空间中各个感兴趣项目的位置。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: Location of various items of interest within the flash memory
    space'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1：闪存空间中各个感兴趣项目的位置
- en: The `FLASH_META_START` address is at the end of the bootloader section. You
    can enter the bootloader by holding down the two buttons on the front of the Trezor,
    which allows a firmware update to be loaded over USB. Since a malicious firmware
    update could simply read out the metadata, the bootloader verifies that various
    signatures are present on a firmware update in order to prevent such an attack.
    Using fault injection to load unverified firmware would be one method of attack,
    but it’s not what we are going to use. The problem with all of these attacks is
    that the Trezor erases the flash memory *before* loading and validating the new
    file, storing the sensitive metadata in SRAM during this process. The wallet.fail
    disclosure actually attacked this process, since it’s possible to glitch the STM32
    to go from code read-protection level RDP2 (which completely disables JTAG) to
    level RDP1 (which enables JTAG to read from SRAM, but not from code).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`FLASH_META_START` 地址位于引导加载程序部分的末尾。通过按住 Trezor 前面的两个按钮，你可以进入引导加载程序，这样就可以通过
    USB 加载固件更新。由于恶意固件更新可能会简单地读取元数据，引导加载程序会验证固件更新中是否存在各种签名，以防止此类攻击。使用故障注入加载未经验证的固件是一种攻击方法，但这并不是我们将要使用的方法。所有这些攻击的问题在于，Trezor
    会在加载并验证新文件之前*擦除*闪存，并在此过程中将敏感元数据存储在 SRAM 中。wallet.fail 的披露实际上攻击了这个过程，因为有可能通过故障操作将
    STM32 从代码读保护级别 RDP2（完全禁用 JTAG）切换到级别 RDP1（使 JTAG 能够从 SRAM 中读取，但不能读取代码）。'
- en: If our attack corrupted the SRAM (or needed a power cycle to recover from error
    states), performing that erase is very dangerous. The wallet.fail attack was able
    to recover the SRAM, but the attack method we’ll use could corrupt the SRAM, which
    means any mistake would permanently destroy the recovery seed. Instead, we’ll
    try to read out the flash memory directly, which is much safer since we make sure
    that an erase command won’t be performed, meaning that the data is safely stored
    in memory, waiting for us to extract it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的攻击破坏了 SRAM（或需要重新启动来恢复错误状态），执行该擦除操作是非常危险的。wallet.fail 攻击能够恢复 SRAM，但我们将使用的攻击方法可能会破坏
    SRAM，这意味着任何错误都会永久销毁恢复种子。相反，我们将尝试直接读取闪存，这样更安全，因为我们确保不会执行擦除命令，意味着数据安全地存储在内存中，等待我们提取。
- en: USB Read Request Faulting
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USB 读取请求故障
- en: Since the bootloader supports USB, it also contains very standard USB processing
    code. [Listing 7-2](#listing7-2) shows part of it, which comes from the *winusb.c*
    file in the Trezor firmware source tree. We’ve chosen this particular “control
    vendor request” function because it sends out the “guid” through USB.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引导加载程序支持 USB，因此它还包含非常标准的 USB 处理代码。[列表 7-2](#listing7-2) 显示了其中的一部分，这来自 Trezor
    固件源代码树中的 *winusb.c* 文件。我们选择这个特定的“控制厂商请求”函数，因为它通过 USB 发送“guid”。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-2: The WinUSB control request function that we attempt to fault'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-2：我们尝试故障的 WinUSB 控制请求函数
- en: 'The control request function first checks some information sent about the USB
    request. It looks for a matching `bRequest`, `bmRequestType`, and `wIndex`, which
    are all attributes of a USB request. Finally, the original USB request itself
    contains a `wLength` field, which is how much data the computer is requesting
    be sent back. This is passed into the function from [Listing 7-2](#listing7-2)
    as the `*len` argument. (The careful observer will also note the `dwLength` struct
    member in [Listing 7-2](#listing7-2), which has a completely different function:
    `dwLength` is the size of the available data to send back based on the descriptor
    programmed into the device.) We can freely request up to `0xFFFF` bytes of data,
    and that’s exactly what we’ll do. However, the code performs a `MIN()` operation
    1 to limit the length of the actual data sent back to the computer to the minimum
    of either the requested length or the size of the descriptor we’ll send back.
    The computer can always request a smaller amount of data than the size of the
    descriptor, but if it requests more data than the device has (that is, if it requests
    a larger response size than the length of the descriptor), the device simply sends
    back only the valid data.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 控制请求函数首先检查有关 USB 请求的一些信息。它会查找匹配的`bRequest`、`bmRequestType`和`wIndex`，这些都是 USB
    请求的属性。最后，原始的 USB 请求本身包含一个`wLength`字段，表示计算机请求返回的数据量。这作为`*len`参数从[清单 7-2](#listing7-2)传入函数。（细心的观察者还会注意到[清单
    7-2](#listing7-2)中的`dwLength`结构成员，其功能完全不同：`dwLength`是根据设备中编程的描述符确定的可返回数据的大小。）我们可以自由地请求最多`0xFFFF`字节的数据，这正是我们将要做的。但是，代码会执行`MIN()`操作
    1，将实际发送回计算机的数据长度限制为请求长度和我们将返回的描述符大小中的较小者。计算机始终可以请求比描述符大小更小的数据量，但如果请求的数据量大于设备所拥有的（也就是请求的响应大小大于描述符的长度），设备会只发送有效数据。
- en: What happens if that `MIN()` call on `wLength` returns the wrong value? While
    the code would respond with the descriptor (as expected), it would also send all
    data after the descriptor up to offset `0xFFFF` from the start of the descriptor.
    This happens because the `MIN()` call is ensuring the user request allows only
    the read-back of the valid memory, but if the `MIN()` call returns the wrong value,
    it now means the user request can read back more than the anticipated memory.
    This “more than anticipated” memory section includes our precious metadata. The
    USB stack doesn’t know the data shouldn’t be sent back. The USB stack is simply
    sending back the block of data as the computer requested. The entire security
    of the system depends on one simple length check.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对`wLength`的`MIN()`调用返回错误的值，会发生什么？虽然代码会按预期返回描述符，但它也会将描述符后的所有数据一直发送到从描述符起始位置的偏移`0xFFFF`。之所以会发生这种情况，是因为`MIN()`调用确保用户请求只允许读取有效内存，但如果`MIN()`调用返回错误的值，那么就意味着用户请求可以读取比预期更多的内存。这个“比预期更多”的内存区域包括了我们宝贵的元数据。USB堆栈并不知道这些数据不应该被返回。USB堆栈只是简单地按照计算机的请求发送数据块。整个系统的安全性仅依赖于一个简单的长度检查。
- en: 'Here’s our plan: We’ll use fault injection to bypass the check 1 that depends
    on a single instruction. We take advantage of the fact that the bootloader (and
    the “guid”) is located at a lower address in memory than where the sensitive recovery
    seed is. We are planning on dumping memory by reading from a lower address to
    a higher address, so the attack is likely to succeed only when attacking USB code
    in the bootloader. If we attack USB code in the regular application that lives
    at `FLASH_APP_START`, it’s most likely that the interesting parts are already
    pointing beyond the sensitive `FLASH_META_START` area (refer back to [Listing
    7-1](#listing7-1)).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的计划：我们将使用故障注入绕过依赖于单条指令的检查 1。我们利用引导加载程序（和“guid”）位于内存中低于敏感恢复种子位置的事实。我们计划通过从低地址读取到高地址的方式转储内存，因此只有在攻击引导加载程序中的
    USB 代码时，攻击才可能成功。如果我们攻击常规应用程序中的 USB 代码，而该应用程序位于`FLASH_APP_START`，那么很可能有趣的部分已经指向超出了敏感的`FLASH_META_START`区域（请参见[清单
    7-1](#listing7-1)）。
- en: Before we dive into the details of performing the actual fault, let’s do a bit
    of a sanity checking on our claims. You can use such checks in your own code to
    help understand the impact of similar vulnerabilities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入执行实际故障的细节之前，让我们先对我们的说法进行一些合理性检查。你可以在自己的代码中使用这些检查来帮助理解类似漏洞的影响。
- en: Disassembling Code
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反汇编代码
- en: The first sanity check is to confirm that a simple fault can cause our intended
    operation. We easily can do that by inspecting a disassembly of the Trezor firmware
    running on the device using the Interactive Disassembler (IDA), which displays
    a breakdown of the assembly code (from [Listing 7-2](#listing7-2)), as shown in
    [Figure 7-2](#figure7-2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个健全性检查是确认简单的故障是否能够导致我们预期的操作。我们可以通过检查 Trezor 固件的反汇编代码来轻松完成这一点，使用交互式反汇编器（IDA），它显示了汇编代码的分解（来自[清单
    7-2](#listing7-2)），如[图 7-2](#figure7-2)所示。
- en: '![f07002](image_fi/278748c07/f07002.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![f07002](image_fi/278748c07/f07002.png)'
- en: 'Figure 7-2: Example of possible fault-injection location'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：可能的故障注入位置示例
- en: The incoming value of `wLength` was stored in `R1`, and `R1` is compared to
    `0x92` in the disassembly. If it’s larger, it’s set to `0x92` with a conditional
    move (`MOVCS` in Arm assembly). These assembly lines are the implementation of
    the `MIN(*len, guid.header.dwLength)` call in the C source from [Listing 7-2](#listing7-2).
    Due to the resulting code flow that we can observe in the disassembly, we need
    to skip only the `MOVCS` instruction to accomplish our goal of having the user-supplied
    `wLength` field be accepted.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`wLength` 的传入值被存储在 `R1` 中，并且在反汇编中，`R1` 与 `0x92` 进行比较。如果它更大，则通过条件移动指令（Arm 汇编中的
    `MOVCS`）将其设置为 `0x92`。这些汇编语句是 C 源代码中对 `MIN(*len, guid.header.dwLength)` 调用的实现，来源于[清单
    7-2](#listing7-2)。由于我们在反汇编中可以观察到的代码流程，我们只需要跳过 `MOVCS` 指令，就能实现接受用户提供的 `wLength`
    字段的目标。'
- en: The second sanity check is to confirm no higher-layer protection exists. For
    example, maybe the USB stack does not actually accept such a large response since
    there is no real requirement to do so. Confirming this is a little harder to do
    by simple inspection, but the Trezor’s open source nature makes it possible. We
    can simply modify the code to comment out the security check, and then verify
    that we can request a large amount of memory. If you don’t want to recompile the
    code but have debugger access, you could also use an attached debugger to set
    a breakpoint on the `MOVCS` and toggle the status of the flag or manipulate the
    program counter to bypass the instruction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个健全性检查是确认没有更高层的保护存在。例如，也许 USB 堆栈实际上不接受如此大的响应，因为没有真正的需求这样做。确认这一点稍微难以通过简单检查完成，但
    Trezor 的开源特性使得这一点成为可能。我们可以简单地修改代码，注释掉安全检查，然后验证我们是否可以请求大量内存。如果你不想重新编译代码，但有调试器访问权限，你也可以使用附加的调试器在
    `MOVCS` 指令上设置断点，并切换标志的状态或操作程序计数器以绕过该指令。
- en: Validating this sanity check is done in the same way as the actual attack. We’ll
    work out all the details in the sections that follow. For now, we’ll just show
    how no other obstacles exist to getting out a large buffer through the control
    request. The attack code sends a length request of `0xFFFF` for the request. [Figure
    7-3](#figure7-3) shows the USB traffic captured with Total Phase Beagle USB 480\.
    When we don’t modify the `MOVCS` instruction, the USB request results in the expected
    length of 146 (`0x92`) bytes, shown at index 3, index 24, and index 45.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 验证此健全性检查与实际攻击的方式相同。我们将在接下来的章节中详细说明所有细节。目前，我们只展示没有其他障碍阻止通过控制请求发送大型缓冲区。攻击代码发送一个
    `0xFFFF` 长度的请求。[图 7-3](#figure7-3) 显示了使用 Total Phase Beagle USB 480 捕获的 USB 流量。当我们不修改
    `MOVCS` 指令时，USB 请求返回预期的 146 字节（`0x92`）长度，显示在索引 3、索引 24 和索引 45。
- en: '![f07003](image_fi/278748c07/f07003.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![f07003](image_fi/278748c07/f07003.png)'
- en: 'Figure 7-3: Capturing USB traffic with the length check disabled'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：禁用长度检查后捕获的 USB 流量
- en: Modifying the instruction (or using a debugger to clear the comparison flag
    manually) to bypass this check results in a full-size response, as the length
    of index 66 is 65535, or `0xFFFF`. This demonstrates that no hidden feature exists
    that will fundamentally prevent the attack from working.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 修改指令（或使用调试器手动清除比较标志）来绕过此检查，结果是返回完整大小的响应，因为索引 66 的长度是 65535，或 `0xFFFF`。这表明不存在任何隐藏的功能，根本不会阻止攻击的成功。
- en: Building Firmware and Validating the Glitch
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建固件并验证故障
- en: 'We’ll roughly be following the documentation for building the Trezor firmware
    from the Trezor Developer’s Guide available on the Trezor Wiki ([https://wiki.trezor.io/](https://wiki.trezor.io/)).
    Here are the specific steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大致会遵循 Trezor 开发者指南中关于构建 Trezor 固件的文档，该文档可在 Trezor Wiki 上找到 ([https://wiki.trezor.io/](https://wiki.trezor.io/))。以下是具体步骤：
- en: Clone the production firmware and check out a known vulnerable revision.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆生产固件并检查已知的易受攻击版本。
- en: Build the firmware without memory protection.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建不带内存保护的固件。
- en: Program and test the device.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程并测试设备。
- en: Edit the firmware to remove the USB length check and try our attack.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑固件以删除USB长度检查并尝试我们的攻击。
- en: '[Figure 7-4](#figure7-4) shows the Trezor with a JTAG debugger attached. This
    Trezor is a production unit with the main chip replaced.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4](#figure7-4)显示了一个附加了JTAG调试器的Trezor。这台Trezor是一个生产单元，已更换主芯片。'
- en: '![f07004](image_fi/278748c07/f07004.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![f07004](image_fi/278748c07/f07004.png)'
- en: 'Figure 7-4: A production Trezor that has had the JTAG port enabled by replacing
    the STM32F205 with a new device'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：一台生产Trezor，已通过更换STM32F205为新设备来启用JTAG端口
- en: We used a SEGGER J-Link for the debugger, but an ST-Link/V2 would work as well
    and costs much less. The schematic for the Trezor board is available in the Trezor
    hardware GitHub repository, [https://github.com/trezor/trezor-hardware/tree/master/electronics/trezor_one/](https://github.com/trezor/trezor-hardware/tree/master/electronics/trezor_one/),
    which details the pinout of the test points on the board.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了SEGGER J-Link作为调试器，但ST-Link/V2也可以使用，而且成本更低。Trezor板的原理图可以在Trezor硬件的GitHub仓库中找到，[https://github.com/trezor/trezor-hardware/tree/master/electronics/trezor_one/](https://github.com/trezor/trezor-hardware/tree/master/electronics/trezor_one/)，该仓库详细说明了板上的测试点引脚排列。
- en: Because any firmware we build this way will be unsigned, the Trezor will block
    our ability to reprogram the bootloader from the unsigned firmware. This means
    fully building the final firmware is pointless since that means we’d need to rewrite
    the bootloader. [Listing 7-3](#listing7-3) shows a section of the code that protects
    the bootloader.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们以这种方式构建的固件都是未签名的，Trezor将阻止我们从未签名的固件重新编程引导加载程序。这意味着完全构建最终固件是没有意义的，因为这意味着我们需要重写引导加载程序。[列表7-3](#listing7-3)展示了保护引导加载程序的代码部分。
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 7-3: The bootloader disables an application’s ability to overwrite
    itself for untrusted firmware (taken from *util.h*)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-3：引导加载程序禁用应用程序覆盖自己以防止不受信任固件的能力（摘自*util.h*）
- en: If untrusted firmware is loaded, the memory protection unit is configured to
    disable access to the bootloader section of the flash memory. Had the code in
    [Listing 7-3](#listing7-3) not been there, we could have used a custom application
    code build to load the bootloader we want to evaluate.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载了不受信任的固件，内存保护单元将配置为禁用对闪存中引导加载程序部分的访问。如果[列表7-3](#listing7-3)中的代码没有出现，我们本可以使用自定义应用程序代码构建来加载我们想要评估的引导加载程序。
- en: The first few steps to building the bootloader are easy (see [Listing 7-4](#listing7-4))
    and roughly follow the documentation. You’ll need to do this on a Linux box or
    Linux virtual machine; our examples are on Ubuntu. We’ll build only the bootloader
    itself since that’s where the vulnerability lies. This build sequence avoids a
    few dependencies for building the full application (mainly `protobuf`) that can
    be a little more effort to install.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 构建引导加载程序的前几个步骤很简单（见[列表7-4](#listing7-4)），大致遵循文档。你需要在Linux机器或Linux虚拟机上执行这些操作；我们的示例基于Ubuntu。我们只构建引导加载程序本身，因为漏洞就存在于这里。此构建序列避免了一些构建完整应用程序（主要是`protobuf`）所需的依赖项，这些依赖项的安装可能稍微麻烦一些。
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-4: Setting up and building the bootloader for Trezor 1.7.3'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-4：为Trezor 1.7.3设置和构建引导加载程序
- en: You may need to make additional tweaks to make this work. Depending on the compiler,
    the bootloader may get too large, in which case `export CFLAGS=-Os` can help.
    If this works, you’ll produce a file named *bootloader/bootloader.elf*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要做一些额外的调整来使其工作。根据编译器的不同，引导加载程序可能会变得太大，此时`export CFLAGS=-Os`可以提供帮助。如果这样做有效，你将生成一个名为*bootloader/bootloader.elf*的文件。
- en: The line with `MEMORY_PROTECT=0` is critical for debugging. If you misspell
    (or forget) this line, some memory protection logic is enabled. One thing that
    memory protection does is *lock the JTAG* such that future use is impossible.
    To save yourself from future mistakes, we recommend editing the *memory.c* file
    and immediately returning from the function `memory_protect()` at line 30\. Should
    you program and run the bootloader without disabling memory protection, you will
    *immediately lose the ability to reprogram or debug the chip* (permanently). Editing
    that file will prevent you from becoming very unhappy when you need to replace
    the chip on your board.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`MEMORY_PROTECT=0`的这一行对调试至关重要。如果你拼写错误（或忘记）这一行，一些内存保护逻辑将被启用。内存保护的一项功能是*锁定JTAG*，使得未来无法使用。为了避免未来的错误，我们建议编辑*memory.c*文件，并立即从第30行的`memory_protect()`函数返回。如果你在没有禁用内存保护的情况下编程并运行引导加载程序，你将*立即失去重新编程或调试芯片的能力*（永久性）。编辑该文件将防止你在需要更换板上芯片时感到非常不开心。
- en: The main *Makefile* file builds a small library, which includes the memory protection
    logic. To avoid accidentally forgetting to rebuild the library, we suggest running
    the two commands on one line as shown in [Listing 7-3](#listing7-3). This will
    also build the *winusb.c* file that has the code we want to validate.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 主 *Makefile* 文件构建了一个小型库，其中包含了内存保护逻辑。为了避免忘记重新构建该库，我们建议在 [清单 7-3](#listing7-3)
    中将两条命令写在一行中。这也将构建包含我们要验证代码的 *winusb.c* 文件。
- en: What next? You can now load the built firmware code using a programmer. We used
    an ST-Link/V2\. Before programming the code, once again confirm that you’ve disabled
    the memory protection code on this build. Again, [Figure 7-4](#figure7-4) shows
    the JTAG’s physical connection. You’ll need the programming software for the ST-Link/V2;
    on Windows, this is the ST-provided STM32 ST-LINK utility, and on Mac or Linux,
    you can build the open source `stlink` utility.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来怎么办？你现在可以使用编程器加载固件代码。我们使用的是 ST-Link/V2。编程代码之前，再次确认你已经禁用了此构建中的内存保护代码。[图 7-4](#figure7-4)再次显示了
    JTAG 的物理连接。你需要 ST-Link/V2 的编程软件；在 Windows 上，这是 ST 提供的 STM32 ST-LINK 工具，而在 Mac
    或 Linux 上，你可以构建开源的 `stlink` 工具。
- en: The next step is to keep bootloader mode on and send some interesting USB requests.
    To do so, plug in the device while holding down the two buttons to enter bootloader
    mode. If you’re using a device with an LCD (not required for this experiment),
    you’ll see the bootloader mode listed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是保持引导加载程序模式并发送一些有趣的 USB 请求。为此，插入设备时按住两个按钮进入引导加载程序模式。如果你使用的是带有 LCD 屏幕的设备（本实验不要求），你将看到引导加载程序模式显示在屏幕上。
- en: Next, you’ll use Python with PyUSB, which you can install with the `pip install
    pyusb` command.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用 Python 和 PyUSB，你可以通过 `pip install pyusb` 命令来安装它。
- en: On Linux, you should be able to talk to the Trezor device directly. The goal
    is to run the Python code in [Listing 7-5](#listing7-5), which will print that
    it has read 146 bytes. You will likely need to perform the `udev` rules setup
    for the Trezor device (or run the script as root).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，你应该能够直接与 Trezor 设备通信。目标是运行 [清单 7-5](#listing7-5) 中的 Python 代码，它会打印出已读取
    146 字节的消息。你可能需要为 Trezor 设备设置 `udev` 规则（或者以 root 权限运行脚本）。
- en: Using a Unix-like system directly will provide the most reliable results. Windows
    often disables a USB port if too many odd events happen on it, which complicates
    our research attempts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用类似 Unix 的系统将提供最可靠的结果。如果在 Windows 上发生过多异常事件，USB 端口通常会被禁用，这会使我们的研究尝试变得复杂。
- en: '[Listing 7-5](#listing7-5) assumes you’re using Linux.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-5](#listing7-5) 假设你使用的是 Linux。'
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-5: Attempting to read the USB descriptor'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-5：尝试读取 USB 描述符
- en: The `data_or_wLength` variable has requested `0x1ff` (511) bytes, but only 146
    should be returned, as that’s the length of the descriptor. Experiment with how
    much data you can request. You may notice that at some point your OS actually
    returns an “invalid parameter.” In theory, on some systems, we can request up
    to `0xFFFF` bytes, but many OSs don’t let you go that high. When it comes time
    to glitch, you’ll want to ensure that your request isn’t killed by the OS itself,
    so find the upper limit of your setup.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_or_wLength` 变量请求了 `0x1ff`（511）字节，但实际上应该返回的是 146 字节，因为那是描述符的长度。你可以尝试请求更多的数据。你可能会注意到，在某个时刻，操作系统会返回一个“无效参数”错误。理论上，在某些系统上，我们可以请求最多
    `0xFFFF` 字节，但许多操作系统并不允许你请求这么高的数值。当你准备进行故障注入时，你需要确保请求不会被操作系统自己终止，因此要找到你设置的上限。'
- en: You also may need to increase the timeout for the `dev.ctrl_transfer()` call
    in [Listing 7-5](#listing7-5) by appending the `timeout=50` parameter. The control
    requests normally return very quickly, but if you successfully read huge blocks
    of data, the default timeouts may be too short.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要通过附加 `timeout=50` 参数来增加 [清单 7-5](#listing7-5) 中 `dev.ctrl_transfer()`
    调用的超时。控制请求通常会非常迅速地返回，但如果你成功地读取了大块数据，默认的超时可能太短。
- en: USB Triggering and Timing
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USB 触发与定时
- en: Before we can insert the glitch, we need to know when to insert it. We know
    the exact instruction we want the glitch to target, and we know the command we
    sent over USB. We need to do better than that, however, to time the fault on the
    exact instruction. In our case, since we have access to the software, we’re going
    to “cheat” during our first test and measure the actual execution time. If we
    didn’t have this capability, we would end up with a much slower process or need
    to brute-force the right timing by trial and error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们插入故障之前，需要知道何时插入故障。我们知道我们想要故障目标的确切指令，也知道我们通过 USB 发送的命令。然而，我们需要做得更好，以便在确切的指令上定位故障。在我们的案例中，由于我们可以访问软件，我们将在第一次测试中“作弊”，并测量实际执行时间。如果没有这种能力，我们将会遇到一个更慢的过程，或者需要通过反复试验强行找出正确的时机。
- en: First, we’ll need to get a more solid trigger on the USB data itself. The classic
    method for this is to use something like the Total Phase Beagle USB 480, which
    can perform triggering based on physical data going over the USB line. [Figure
    7-5](#figure7-5) shows the setup.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获得 USB 数据本身的更稳定触发。经典方法是使用像 Total Phase Beagle USB 480 这样的设备，它可以基于通过 USB
    线传输的物理数据进行触发。[图 7-5](#figure7-5)展示了这个设置。
- en: '![f07005](image_fi/278748c07/f07005.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![f07005](image_fi/278748c07/f07005.png)'
- en: 'Figure 7-5: Setup for triggering on the WinUSB message'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '图 7-5: 触发 WinUSB 消息的设置'
- en: The Total Phase Beagle USB 480 also has a beautiful sniffer interface, so we
    can sniff the traffic and better understand what (malformed) packets are coming
    back. This capability is very useful since we can see, for example, the exact
    portion of the USB request being interrupted/corrupted, which might provide some
    hints as to how far into the code the program has executed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Total Phase Beagle USB 480 还具有一个漂亮的嗅探器界面，因此我们可以嗅探流量，更好地理解返回的（格式错误的）数据包。这个功能非常有用，因为我们可以看到，例如，USB
    请求的确切部分被中断/损坏，这可能为我们提供一些线索，帮助我们判断程序执行到代码的哪一部分。
- en: If you don’t have the Beagle, Micah Scott developed a simple module to perform
    real-time glitching called FaceWhisperer, which is available on GitHub ([https://github.com/scanlime/facewhisperer/](https://github.com/scanlime/facewhisperer/)).
    It uses USB for glitch triggering and has been used with voltage glitching to
    dump the firmware from a drawing tablet. Kate Temkin at Great Scott Gadgets has
    also made several tools, including add-ons for the GreatFET and various USB tools
    such as LUNA. We use a tool that Colin developed, the PhyWhisperer-USB.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 Beagle，Micah Scott 开发了一个简单的模块，叫做 FaceWhisperer，它可以进行实时故障注入，并且可以在 GitHub
    上找到（[https://github.com/scanlime/facewhisperer/](https://github.com/scanlime/facewhisperer/)）。它使用
    USB 进行故障触发，并已与电压故障结合使用，用于从绘图板提取固件。Great Scott Gadgets 的 Kate Temkin 也开发了多个工具，包括
    GreatFET 的附加模块以及各种 USB 工具，如 LUNA。我们使用的是 Colin 开发的工具——PhyWhisperer-USB。
- en: The open source PhyWhisperer-USB is designed to perform USB triggering based
    on specific packets. The Trezor USB passes through the PhyWhisperer-USB such that
    a computer is still sending the actual USB messages to the Trezor device.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 开源的 PhyWhisperer-USB 旨在根据特定数据包执行 USB 触发。Trezor USB 数据通过 PhyWhisperer-USB 传输，从而使计算机仍然可以向
    Trezor 设备发送实际的 USB 消息。
- en: The PhyWhisperer-USB is used via a Python program (or Jupyter notebooks). [Listing
    7-6](#listing7-6) shows the initial setup, which simply connects to the PhyWhisperer-USB.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PhyWhisperer-USB 通过 Python 程序（或 Jupyter 笔记本）使用。[Listing 7-6](#listing7-6)展示了初始设置，简单地连接到
    PhyWhisperer-USB。
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-6: PhyWhisperer-USB setup'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-6: PhyWhisperer-USB 设置'
- en: The setup requires that you hold down buttons on the Trezor to ensure that it
    starts in bootloader mode. This script power-cycles the target so that the PhyWhisperer-USB
    can match the USB speed by observing the enumeration sequence.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该设置要求你按住 Trezor 上的按钮，以确保它以引导加载程序模式启动。此脚本通过电源循环目标设备，以便 PhyWhisperer-USB 可以通过观察枚举序列来匹配
    USB 速度。
- en: Every time we want a trigger, we set up the trigger and arm the PhyWhisperer-USB,
    as in [Listing 7-7](#listing7-7).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想要触发时，我们都会设置触发器并使 PhyWhisperer-USB 处于准备状态，如[Listing 7-7](#listing7-7)所示。
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-7: Trigger based on the request we’re sending'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-7: 基于我们发送请求的触发器'
- en: Here we set the trigger based on the request we’re sending (shown in [Listing
    7-5](#listing7-5)). We can run the code in [Listing 7-5](#listing7-5) on the host
    system, which starts the code we want to fault in [Listing 7-2](#listing7-2) on
    the Trezor. The Trig Out connector on the PhyWhisperer-USB will have a short trigger
    pulse that coincides with the USB request going over the wire.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据我们发送的请求来设置触发器（如 [列表 7-5](#listing7-5) 所示）。我们可以在主机系统上运行 [列表 7-5](#listing7-5)
    中的代码，这将启动我们在 Trezor 上的 [列表 7-2](#listing7-2) 中想要攻击的代码。PhyWhisperer-USB 上的 Trig
    Out 连接器将发出一个短暂的触发脉冲，该脉冲与 USB 请求通过电缆的时刻一致。
- en: Later, during the fault attack, we’ll use the PhyWhisperer-USB to determine
    the time interval between the USB request and the specific instruction we want
    to fault. After the USB request triggers the code execution, it will take a small
    amount of time before the actual target instruction is executed. Adjusting the
    `set_trigger()` parameters lets us change the trigger output to a later point
    in time in order to line up the timing of the fault to the target instruction.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，在故障攻击过程中，我们将使用 PhyWhisperer-USB 来确定 USB 请求与我们想要攻击的特定指令之间的时间间隔。在 USB 请求触发代码执行之后，会有一小段时间才会执行实际的目标指令。调整
    `set_trigger()` 参数可以让我们将触发输出推迟到稍后的时间点，以便将故障的时机与目标指令对齐。
- en: The advantage of PhyWhisperer-USB is that we can also monitor the USB traffic.
    The USB data capture starts with the trigger; we used the code in [Listing 7-8](#listing7-8)
    to read it out of the PhyWhisperer-USB.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: PhyWhisperer-USB 的优势在于我们还可以监视 USB 流量。USB 数据捕获从触发开始；我们使用 [列表 7-8](#listing7-8)
    中的代码从 PhyWhisperer-USB 中读取数据。
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-8: Code to read USB data out of the PhyWhisperer-USB'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-8：从 PhyWhisperer-USB 读取 USB 数据的代码
- en: '[Listing 7-9](#listing7-9) shows the capture results, which are useful to observe
    that the right packets were used for the trigger and whether USB errors have been
    thrown.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-9](#listing7-9) 显示了捕获结果，这对于观察是否使用了正确的触发数据包以及是否抛出了 USB 错误非常有用。'
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 7-9: The output from running the code in [Listing 7-8](#listing7-8)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-9：运行 [列表 7-8](#listing7-8) 中代码的输出
- en: Note the `Err - bad PID of 01` error on the first line due to the capture having
    started partway through a control packet. Adjusting the trigger pattern to include
    the full packet would prevent this error. For our attack here, this error is irrelevant.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于捕获在控制包的中途开始，第一行中出现了 `Err - bad PID of 01` 错误。调整触发模式以包括完整的数据包将防止此错误。对于我们这里的攻击来说，这个错误无关紧要。
- en: When automating our fault attack, we can detect faults that aren’t the desired
    effect (reading too much data) but that still corrupt USB data or cause errors.
    Knowing the timing of those errors is useful information. If we see an error occurring
    after we’ve already returned the USB data, we know our fault is too late to be
    effective, for example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化我们的故障攻击时，我们可以检测到不是预期效果的故障（例如读取过多数据），但仍然会破坏 USB 数据或导致错误。知道这些错误的时机是有用的信息。例如，如果我们看到错误发生在已经返回
    USB 数据之后，我们就知道我们的故障发生得太晚，效果不佳。
- en: Once we have a trigger based on the USB request going “over the wire,” we will
    also insert a second trigger by setting an I/O pin high on the Trezor when the
    sensitive code runs. We use this to characterize the timing, since we can use
    an oscilloscope to measure the time from the USB packet going over the wire to
    the time of sensitive code executing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们基于 USB 请求设置了“通过电缆”传输的触发器，我们还会通过在 Trezor 上设置一个 I/O 引脚为高电平来插入第二个触发器，当敏感代码运行时触发该引脚。我们使用它来表征时序，因为我们可以使用示波器测量从
    USB 数据包传输到电缆到敏感代码执行之间的时间。
- en: We can find a useful spare I/O pin by inspecting the Trezor board’s schematic;
    in our case, we find the schematic for v1.1 at [https://github.com/trezor/trezor-hardware/blob/master/electronics/trezor_one/trezor_v1.1.sch.png](https://github.com/trezor/trezor-hardware/blob/master/electronics/trezor_one/trezor_v1.1.sch.png).
    We see that the SWO pin from header K2 (visible in [Figure 7-1](#figure7-1)) is
    routed to I/O pin PB3\. If the Trezor can toggle PB3 during the comparison operation,
    this will provide useful timing information for doing fault injection. It saves
    us from having to sweep a large time span. [Listing 7-10](#listing7-10) shows
    a simple example of how to perform a GPIO toggle on the STM32F215 in the Trezor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查 Trezor 板的原理图来找到一个有用的备用 I/O 引脚；在我们的案例中，我们找到了 v1.1 的原理图，链接为 [https://github.com/trezor/trezor-hardware/blob/master/electronics/trezor_one/trezor_v1.1.sch.png](https://github.com/trezor/trezor-hardware/blob/master/electronics/trezor_one/trezor_v1.1.sch.png)。我们看到来自
    K2 接口的 SWO 引脚（在 [图 7-1](#figure7-1) 中可见）被接到 I/O 引脚 PB3。如果 Trezor 在比较操作过程中能够切换
    PB3，那么这将为故障注入提供有用的时序信息。这样可以避免我们需要扫描一个较大的时间范围。[清单 7-10](#listing7-10) 显示了如何在 Trezor
    的 STM32F215 上执行 GPIO 切换的简单示例。
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-10: Toggling PB3, which routes to the SWO pin on header K2'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-10：切换 PB3，PB3 引脚连接到 K2 接口上的 SWO 引脚
- en: If we insert the code in [Listing 7-10](#listing7-10) at the location we want
    to fault, rebuild the bootloader, and then run the code, we should get a short
    pulse on the SWO pin that we can use for the timing. Again, to perform this evaluation,
    you’ll need a Trezor that has been hacked to allow reprogramming.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 [清单 7-10](#listing7-10) 中的代码插入到我们希望故障的地方，重建引导加载程序，然后运行该代码，我们应该会在 SWO 引脚上获得一个短脉冲，供我们进行时序控制。再次提醒，为了执行此评估，你需要一台已经被破解以允许重新编程的
    Trezor。
- en: In this case, the time between the PhyWhisperer-USB trigger and the Trezor trigger
    ends up being around 4.2 to 5.5 microseconds. It’s not perfect timing, since there
    appears to be some jitter due to the USB packets being processed by a queue. Seeing
    such jitter tells us that when performing the fault injection, we shouldn’t expect
    to achieve perfect reliability. However, it gives us a range in which we can vary
    the timing parameter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，PhyWhisperer-USB 触发器与 Trezor 触发器之间的时间大约为 4.2 到 5.5 微秒。这并不是完美的时序，因为似乎存在由于
    USB 包被队列处理而产生的抖动。看到这样的抖动告诉我们，在进行故障注入时，我们不应期望实现完美的可靠性。然而，它为我们提供了一个时间范围，我们可以在其中调整时序参数。
- en: Glitching Through the Case
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过外壳进行故障注入
- en: In this section, we’ll go from exploration of the target to actually faulting
    it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将从目标的探索阶段进入实际故障注入的阶段。
- en: Setting Up
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: To insert the glitch, our setup (shown in [Figure 7-6](#figure7-6)) includes
    a ChipSHOUTER EMFI tool mounted on a manual XY table for accurately positioning
    the coil. The Trezor target is also mounted on an XY table, and the PhyWhisperer-USB
    provides triggering and target power control via a switch inside the PhyWhisperer-USB.
    The power control capability is useful as we can reset the target when it crashes.
    The power control is a common feature on fault-injection-specific equipment, but
    general-purpose tools such as the Beagle USB 480 are missing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了插入故障，我们的设置（如 [图 7-6](#figure7-6) 所示）包括将 ChipSHOUTER EMFI 工具安装在手动 XY 工作台上，以便精确定位线圈。Trezor
    目标也安装在 XY 工作台上，PhyWhisperer-USB 通过内部开关提供触发和目标电源控制。电源控制功能很有用，因为我们可以在目标崩溃时重置它。电源控制是故障注入专用设备的常见功能，但像
    Beagle USB 480 这样的通用工具却没有此功能。
- en: The physical “jig” on which the Trezor is mounted depresses the two front panel
    buttons, ensuring that it always enters bootloader mode on startup.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Trezor 安装的物理“夹具”按下了两个前面板按钮，确保它在启动时始终进入引导加载程序模式。
- en: '![f07006](image_fi/278748c07/f07006.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![f07006](image_fi/278748c07/f07006.png)'
- en: 'Figure 7-6: Complete setup with Trezor (middle), ChipSHOUTER (left), and PhyWhisperer-USB
    (right)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-6：完整设置，包含 Trezor（中）、ChipSHOUTER（左）和 PhyWhisperer-USB（右）
- en: Reviewing the Code for Fault Injection
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回顾故障注入的代码
- en: The script in Listings 7-11 and 7-12 (split for readability) allows us to power-cycle
    the device, issue the WinUSB requests, and trigger the ChipSHOUTER based on the
    WinUSB request detected in the PhyWhisperer-USB.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-11 和 7-12 中的脚本（为可读性分割）允许我们对设备进行电源循环，发出 WinUSB 请求，并基于 PhyWhisperer-USB 中检测到的
    WinUSB 请求触发 ChipSHOUTER。
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-11: Part 1 of a simple script for glitching the Trezor bitcoin wallet
    when in bootloader mode'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-11：当 Trezor 处于引导加载程序模式时，简单的脚本部分 1，用于故障注入 Trezor 比特币钱包
- en: In this setup, we use the PhyWhisperer-USB target device power control features,
    as evidenced by the `reinit()` function 1 that power-cycles the target when called.
    This function is performing error recovery when the target crashes. A more robust
    script might power-cycle the device on every attempt, but there is a trade-off
    here, as the power cycling is the slowest operation in the loop. We can attempt
    to perform a faster glitch loop by power-cycling only when the target stops responding,
    but the trade-off there is we don’t guarantee that the device is actually starting
    in the same state every time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置中，我们使用了PhyWhisperer-USB目标设备的电源控制功能，正如`reinit()`函数1所示，当调用时会对目标进行电源循环。此功能在目标崩溃时执行错误恢复。一个更稳健的脚本可能会在每次尝试时都进行电源循环，但这里有一个权衡，因为电源循环是循环中最慢的操作。我们可以尝试通过仅在目标停止响应时进行电源循环来执行更快的故障循环，但这样做的权衡是我们无法保证每次设备都以相同的状态启动。
- en: '[Listing 7-12](#listing7-12) shows the actual loop body of the attack.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-12](#listing7-12)显示了攻击的实际循环体。'
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7-12: Part 2 of a simple script for glitching the Trezor bitcoin wallet
    when in bootloader mode'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-12：一个简单脚本的第二部分，用于在Trezor比特币钱包处于引导加载程序模式时进行故障注入
- en: The actual timing of the trigger output relative to the USB message trigger
    and the width of the EMFI pulse are set 1. The width (`12`) was discovered using
    the techniques discussed previously, mostly by adjusting the width until we saw
    the device reset (probably too wide a pulse!) and then reducing the width until
    the device appeared to be on the edge of crashing. We confirm this edge is a successful
    width by looking for signs of corruption without a full device crash. For the
    Trezor, we can find that by looking for invalid messages or certain error messages
    being displayed. For tuning the width, we didn’t use the loop from [Listing 7-12](#listing7-12).
    Instead, we’d insert the glitch during the device boot when it’s performing validation
    of the internal memory. The Trezor displays a message if the signature check fails,
    and we could use this message to indicate that we had found good parameters for
    our EMFI tool that will cause a fault on this device. The signature check failing
    in the presence of a glitch most likely means we somehow affected the program
    flow (enough to disrupt the signature check), but the glitch wasn’t “too strong”
    such that it caused a crash of the device.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 触发输出相对于USB消息触发的实际时序和EMFI脉冲宽度已设置为1。脉冲宽度（`12`）是通过前面讨论的技术发现的，主要是通过调整宽度，直到看到设备重置（可能是脉冲太宽！），然后再减少宽度，直到设备似乎快崩溃为止。我们通过寻找损坏的迹象而不是完全崩溃的设备来确认这个边界是成功的宽度。对于Trezor，我们可以通过查看无效消息或显示某些错误消息来找到这一点。对于调节宽度，我们没有使用[清单
    7-12](#listing7-12)中的循环。相反，我们会在设备启动时插入故障，当时它正在验证内部内存。如果签名检查失败，Trezor会显示一条消息，我们可以利用这条消息来指示我们已经找到适用于我们EMFI工具的良好参数，这些参数将在此设备上引发故障。出现故障时签名检查失败，很可能意味着我们以某种方式影响了程序流程（足够干扰签名检查），但故障“强度”不够大，因此没有导致设备崩溃。
- en: The message pattern on which our setup is being triggered is set 2, which should
    match the later USB request we are sending to the device. On each iteration, the
    Trezor bootloader is reconnected using the `libusb` call `dev.set_configuration()`
    3, which is also part of the error handling. If this line throws an exception,
    it’s likely because the host USB stack didn’t detect the device.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的触发条件消息模式是设置2，它应与我们稍后发送给设备的USB请求相匹配。在每次迭代中，Trezor引导加载程序会通过`libusb`调用`dev.set_configuration()`
    3重新连接，这也是错误处理的一部分。如果这一行抛出异常，很可能是因为主机的USB堆栈没有检测到设备。
- en: Beware of the `except` block’s silent error suppression right after the `libusb`
    call 3. This `except` block assumes that a power cycle is sufficient to recover
    the target, but if the host USB stack has crashed, the script silently stops working.
    As mentioned before, we recommend running this on a bare-metal Unix system, as
    Windows typically causes problems quickly due to the host USB stack blocking the
    device after several quick disconnect/reconnect cycles. We’ve had similarly negative
    experiences inside virtual machines.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`libusb`调用3后`except`块的静默错误抑制。此`except`块假设电源循环足以恢复目标，但如果主机USB堆栈崩溃，脚本会静默停止工作。如前所述，我们建议在裸机Unix系统上运行此脚本，因为Windows通常由于主机USB堆栈在几次快速断开/重新连接循环后阻塞设备而迅速导致问题。我们在虚拟机中也有类似的负面体验。
- en: In order to know whether the glitch had any effect, we keep a “golden reference”
    of the expected USB request response. The actual glitch is inserted only when
    the `arm()` function 4 is called prior to the USB request 5. The first time through,
    when the golden reference is taken 6, the `arm()` function is not called to ensure
    that we capture unglitched (“golden”) output.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: With this golden reference, we can now mark any odd response. The USB traffic
    that occurred during the fault injection is printed 7. This downloads the data
    that was automatically captured when the request matched the pattern set 2.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The code currently prints information only about valid responses. You may also
    want to print USB captures for invalid responses to determine whether the fault
    is causing errors to be inserted. The PhyWhisperer-USB still captures the invalid
    data. You would need to move the capture and print routine into the `except OSError`
    block 8. Any errors will branch the code to the `OSError` exception block, because
    the USB stack does not return partial or invalid data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an example, [Listing 7-13](#listing7-13) shows the golden reference for the
    WinUSB request.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-13: The golden reference for the USB transaction'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: This golden reference is the value of the returned data, so any returned data
    that differs is expected to indicate an interesting (or useful) fault.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-14](#listing7-14) shows one repeatable condition we observed in
    an experiment. The returned data (82 bytes) is shorter than the length of the
    golden reference (146 bytes).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-14: Output of Listings 7-11 and 7-12 with the first 64 bytes missing'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The returned data is simply the golden reference *without* the first 64 bytes
    1. It appears that a whole USB `IN` transaction is missing, which suggests that
    an entire USB data transfer was “skipped” on this fault injection run. Since no
    error was flagged on this transfer, the USB device must have thought it was only
    *supposed* to return the shorter length of data. Such a fault is interesting,
    because it proves that program flow changes in the target device are occurring,
    which is good to know since it shows that our overall goal is reasonable. Note
    again the `bad PID error`, which is due to missing the first part of a USB packet;
    it’s on the first decoded frame only and not indicative of an error caused by
    a fault.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Confirming a Dump
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do we confirm we actually have a successful glitch (and get the magic recovery
    seed)? Initially, we just look for a “too-long” response and hope that the returned
    area of memory includes the recovery seed. Because the secret recovery seed is
    stored as a human-readable string, if we had a binary, we would simply run `strings
    -a` on the returned memory. Because we are implementing the attack in Python,
    we could instead use the `re` (regular expression) module. Assuming we have a
    list of data called `resp` (for example, from [Listing 7-14](#listing7-14)), we
    could simply find all strings with only letters or spaces of length four or longer
    with a regular expression, as shown in [Listing 7-15](#listing7-15).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确认我们确实成功地进行了故障注入（并获得神奇的恢复种子）？最初，我们只是寻找一个“过长”的响应，并希望返回的内存区域包含恢复种子。因为秘密恢复种子是作为人类可读的字符串存储的，如果我们有二进制数据，我们只需对返回的内存运行
    `strings -a`。由于我们在 Python 中实现攻击，我们可以使用 `re`（正则表达式）模块。假设我们有一个名为 `resp` 的数据列表（例如，来自[列表
    7-14](#listing7-14)），我们可以通过正则表达式简单地查找所有只包含字母或空格且长度为四个或更多的字符串，如[列表 7-15](#listing7-15)所示。
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-15: A “simple” regular expression to find strings consisting of four
    or more letters or a space'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-15：一个“简单”的正则表达式，用于查找由四个或更多字母或空格组成的字符串
- en: With any luck, we’ll get a list of strings present in the returned data, as
    in [Listing 7-16](#listing7-16).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果幸运的话，我们会得到返回数据中存在的字符串列表，如[列表 7-16](#listing7-16)所示。
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 7-16: The recovery seed would be the long string with 24 English words.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-16：恢复种子将是由 24 个英文单词组成的长字符串。
- en: One of the strings should be the recovery seed, which will be the long string
    of English language words. Seeing that means a successful attack!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个字符串应该是恢复种子，它将是由英文单词组成的长字符串。看到这个意味着攻击成功！
- en: Fine-Tuning the EM Pulse
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微调电磁脉冲
- en: The final step when running the experiment is to fine-tune the EM pulse itself,
    which in this case means physically scanning the coil above the surface, along
    with adjusting the glitch width and power level. We can control the glitch width
    from the PhyWhisperer-USB script, but the power level is adjusted via the ChipSHOUTER
    serial interface. A more powerful glitch is simply likely to reset the device,
    whereas a less powerful glitch may have no effect. In between those extremes,
    we may see indications that we’re injecting errors, such as triggering error handlers
    or causing invalid USB responses. Triggering error handlers indicates that we’re
    probably not fully rebooting the device but are having some effects on the internal
    data being manipulated. On the Trezor in particular, the LCD screen visually indicates
    when the device entered an error handler routine and reports the type of error.
    Again, the USB protocol analyzer can be helpful in seeing whether invalid or strange
    results are occurring. Finding a location that occasionally enters an error is
    typically a useful starting point, as this suggests that the area is sensitive
    but is not so aggressive that it causes memory or bus faults 100 percent of the
    time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 运行实验的最后一步是微调电磁脉冲本身，在这种情况下，意味着要在表面上方物理扫描线圈，同时调整故障宽度和功率级别。我们可以通过 PhyWhisperer-USB
    脚本控制故障宽度，但功率级别是通过 ChipSHOUTER 串行接口调整的。更强大的故障很可能会重置设备，而较弱的故障可能没有任何效果。在这些极端之间，我们可能会看到一些迹象，表明我们正在注入错误，比如触发错误处理程序或导致无效的
    USB 响应。触发错误处理程序表明我们可能没有完全重启设备，但对内部数据的操作产生了一些影响。特别是在 Trezor 上，LCD 屏幕会直观地显示设备何时进入错误处理程序，并报告错误类型。同样，USB
    协议分析器在查看是否发生无效或异常结果时会很有帮助。找到一个偶尔会进入错误的区域通常是一个有用的起点，因为这表明该区域敏感，但又不至于过于激进，以至于每次都会导致内存或总线故障。
- en: Tuning Timing Based on USB Messages
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于 USB 消息调整时序
- en: A successful glitch is one where the USB request comes through with the full
    length of data, having been able to bypass the length check. Finding the exact
    timing takes some experimentation. You will get many system crashes due to memory
    errors, hard faults, and resets. Using a hardware USB analyzer, you can see where
    these errors are occurring, which helps you understand the glitch timing, as previously
    shown in [Listing 7-14](#listing7-14). Without the “cheat” of being able to modify
    the source code in order to discover the timing, it would be absolutely essential
    to understand where those errors are occurring; they are flags we can use to understand
    the timing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的故障是指USB请求能够通过并带有完整长度的数据，成功绕过了长度检查。找到确切的时机需要一些实验。你将会由于内存错误、硬故障和重置而遭遇许多系统崩溃。使用硬件USB分析仪，你可以看到这些错误发生的位置，这有助于你理解故障时机，正如之前在[清单7-14](#listing7-14)中展示的那样。如果没有能够修改源代码来发现时机的“作弊”，理解这些错误发生的地点将变得至关重要；它们是我们理解时机的标志。
- en: '[Figure 7-7](#figure7-7) shows another sample capture, this time with a Total
    Phase Beagle USB 480.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-7](#figure7-7)显示了另一张样本捕获图，这次使用的是Total Phase Beagle USB 480。'
- en: '![f07007](image_fi/278748c07/f07007.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![f07007](image_fi/278748c07/f07007.png)'
- en: 'Figure 7-7: A simple example where a USB error indicates when a fault injection
    corrupts program flow'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-7：一个简单的例子，USB错误指示故障注入何时破坏程序流程
- en: 'The upper few rows in [Figure 7-7](#figure7-7) show a number of correct 146-byte
    control transfers. The first part is the `SETUP` phase. The Trezor has `ACK`’d
    the `SETUP` packet but then never sends the follow-up data. The Trezor entered
    an infinite loop as it jumped to one of the various interrupt handlers for error
    detection. As the timing of the fault is shifted, various effects on the USB traffic
    are observed: moving the glitch earlier often prevents the `ACK` of the setup
    packet; moving the glitch later allows the first packet of follow-up data to be
    sent but not the second; and moving the glitch much later allows the complete
    USB transaction to be carried out but then crashes the device. This knowledge
    helps us understand in which part of the USB code the fault is being inserted,
    even if that fault continues to be a sledgehammer causing a device reset instead
    of an intended single instruction skip.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-7](#figure7-7)的上几行显示了多个正确的146字节控制传输。第一部分是`SETUP`阶段。Trezor已经对`SETUP`数据包进行了`ACK`确认，但随后从未发送后续数据。Trezor进入了一个无限循环，跳转到多个中断处理程序之一进行错误检测。由于故障的时机被移位，观察到USB流量的不同效果：将故障时机提前通常会阻止`SETUP`数据包的`ACK`确认；将故障时机推后允许发送第一包后续数据，但不能发送第二包；而将故障时机推得更晚，则允许完整的USB事务执行，但随后导致设备崩溃。这些知识帮助我们理解了故障被插入USB代码的哪个部分，即使该故障依然是一个大锤子，导致设备重置，而不是预期的单一指令跳过。
- en: As you can see, this gives us a timing window for faulting the device, without
    using our earlier “cheat.”
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这为我们提供了一个故障时机窗口，用于使设备发生故障，而不需要使用我们之前的“作弊”方法。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we walked through taking an unmodified bitcoin wallet and finding
    the recovery seed stored within it. We leveraged some features of the target’s
    open source design to provide insight, although the attack could have succeeded
    without that information. The target’s open source design means you can also use
    it as a reference for investigating your own products where you do have access
    to the source code. In particular, we showed how you could easily simulate the
    effect of a fault injection using a debugger attached to the device.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何获取未修改的比特币钱包并找到其中存储的恢复种子。我们利用目标的开源设计的一些特性提供了见解，尽管没有这些信息，攻击仍然可以成功。目标的开源设计意味着你也可以将其作为参考，调查你自己的产品，前提是你能够访问源代码。特别地，我们展示了如何使用附加到设备的调试器轻松模拟故障注入的效果。
- en: Finding a successful glitch timing is not easy. The previous experiments demonstrated
    when the comparison was happening, which is when we want the glitch to be inserted.
    As this time had jitter, there is no single “correct” time. In addition to time,
    some spatial positioning is required. If you had a computer-controlled XY scanning
    table, you could also automate the search for the correct location. In this example,
    we simply used a manual table, as very specific positioning didn’t seem necessary.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个成功的故障时机并不容易。之前的实验展示了在比较发生时，即我们希望插入故障的时机。由于这个时机存在抖动，因此没有单一的“正确”时机。除了时间外，还需要一些空间定位。如果你有一个计算机控制的XY扫描桌面，你也可以自动化搜索正确的位置。在这个例子中，我们只是使用了一个手动桌面，因为非常具体的定位似乎并不是必要的。
- en: Again, due to the nature of the glitch timing, take care to decide on an economical
    strategy of how to search for candidate glitch settings. You can quickly see that
    the combination of physical location, glitch time, glitch width, and EMFI power
    settings means a huge number of parameters to search. Finding ways to narrow the
    search range (such as using information about error states to understand effective
    zones) is critical in keeping the problem space tractable. Logging “odd” outputs
    is also useful when investigating possible effects, because if you are looking
    only for a very narrow range of “success,” you may miss some other useful glitches.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，由于故障时序的性质，请小心选择一种经济的策略来搜索候选故障设置。你会很快发现，物理位置、故障时间、故障宽度和 EMFI 功率设置的组合意味着需要搜索大量的参数。找到缩小搜索范围的方法（例如，利用错误状态信息来理解有效区域）对保持问题空间的可处理性至关重要。在调查可能的影响时，记录“奇怪”的输出也是有用的，因为如果你只关注非常狭窄的“成功”范围，可能会错过其他有用的故障。
- en: The ultimate success rate of EMFI dumping is low. Once the glitches have been
    correctly tuned, 99.9 percent of the glitches return a result that is too short
    and, thus, they aren’t successful. We can, however, achieve a successful glitch
    within about one or two hours on average (subsequent to tuning location and timing),
    making it a relatively useful attack in practice.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: EMFI 故障注入的最终成功率较低。一旦故障得到正确调整，99.9%的故障会返回过短的结果，因此不会成功。然而，我们平均大约在一到两个小时内（调整位置和时间后）能够实现一次成功的故障注入，这使得它在实际中仍然是一个相对有用的攻击方法。
- en: We want to highlight that when you perform fault injection on real devices,
    a significant portion of reverse engineering goes on in order to figure out what
    can be faulted, such as USB dumping, looking at code, and so on. We hope the earlier
    chapters have prepared you for some of that, but you’ll certainly bump into challenges
    that aren’t covered here. As always, try to bring the challenges down to the simplest
    instance, solve them there, and then map them back to the full device.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想强调的是，当你在真实设备上执行故障注入时，反向工程的一个重要部分就是要弄清楚可以引发故障的地方，比如 USB 转储、查看代码等等。我们希望前面的章节已经为你提供了一些准备，但你肯定会遇到这里没有涉及的挑战。像往常一样，尽量将挑战简化为最简单的实例，解决它们后，再将解决方案应用到整个设备上。
- en: If you try to re-create this full attack, you’ll likely find it more difficult
    than the labs we covered in Chapter 6, which should give you a feel for how fault
    attacks on a real device can be more difficult in practice, even though the fundamental
    operations are similar.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试重新创建这个完整的攻击，你会发现它比我们在第六章中讨论的实验更加困难，这应该能让你体会到，尽管基本操作相似，实际设备上的故障攻击会更加困难。
- en: 'And now for something completely different. In the next chapter, we’ll move
    on to side-channel analysis and dive into more details on what we alluded to in
    earlier chapters: how power consumed by a device can tell us both the operations
    and data being used by the device under attack.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来点完全不同的内容。在接下来的章节中，我们将转向旁路分析，并深入探讨我们在前几章中提到的内容：设备消耗的电力如何揭示设备正在执行的操作和数据。
