<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="37" id="Page_37"/>4</span><br/>
<span class="ChapterTitle">Controlling User Commands with sudo</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">So far, you have secured access to your VM with a public key and two-factor authentication. You have also controlled access to a specific file and directory, using group permissions. The next foundational piece is allowing users to run elevated commands on the VM. Users typically need access to commands that may require administrative permissions, such as restarting a service or installing a missing package. As an administrator, you want to keep a tight control on who can run which commands. On Linux operating systems, the <code>sudo</code> (superuser do) command allows users to run specific commands as <em>root</em> or another user while keeping an audit trail of events. </p>
<p><span epub:type="pagebreak" title="38" id="Page_38"/>In this chapter, you’ll use Ansible to install a simple Python Flask web application. You’ll also use Ansible to create a <em>sudoers</em> security policy, which is configured by a file and determines what permissions users have when they invoke the <code>sudo</code> command. This policy will allow members of the <em>developers</em> group to use the <code>sudo</code> command to start, stop, restart, and edit the sample web application. Although this is a made-up example, it follows a typical release workflow that software engineers should be accustomed to. By the end of the chapter, you’ll have a good grasp of how to automate application deployment and control it with a <em>sudoers</em> policy.</p>
<h2 id="h1-502482c04-0001">What Is sudo?</h2>
<p class="BodyFirst">If you are new to <code>sudo</code>, it is a command line tool on most Unix OSs that allows a user or group of users to run commands as another user. For example, a software engineer may need to restart an Nginx web server that’s owned by the <em>root</em> user, or a system administrator may need elevated permissions to install some software packages. If you have been around Linux long enough, you have likely used <code>sudo</code> to run a command that requires elevated privileges. Normally, you would not allow just anyone to have such privileges, due to various security implications. Regardless of your use case, users will need a safe and accountable way to access privileged commands to do their jobs. </p>
<p>One of the best features of <code>sudo</code> is its ability to leave an audit trail. If someone runs a command with <code>sudo</code>, you can check the log to see who ran what command. Without <code>sudo</code>, there is zero accountability if you blindly allow people to switch to other users to run commands.</p>
<p>You also can enhance <code>sudo</code> with plug-ins. In fact, <code>sudo</code> comes with a default security policy plug-in called <em>sudoers</em>, which determines what permissions users have when they invoke the <code>sudo</code> command. You’ll implement this policy for your user <em>bender</em>.</p>
<h3 id="h2-502482c04-0001">Planning a sudoers Security Policy</h3>
<p class="BodyFirst">When you are planning a <em>sudoers</em> policy, less is more. You want a user or group of users to have just the right amount of permissions on a host. If you have a user that can run many privileged commands while administering the company website at the same time, you’ll have serious issues if that user is compromised. This is because any attackers will inherit the same access that the compromised user has. </p>
<p>That said, it is naive to think you can lock down a host completely and still get things done. Imagine a software delivery workflow where an application needs to be restarted after each deployment. Without proper user permissions, you will not be able to automate continuous delivery for that application. </p>
<p>For the example security policy you’ll set up in this chapter, everyone in the <em>developers </em>group will be able to access the sample web application. They’ll also be able to stop, start, and edit the main application file. </p>
<h2 id="h1-502482c04-0002"><span epub:type="pagebreak" title="39" id="Page_39"/>Installing the Greeting Web Application</h2>
<p class="BodyFirst">The sample Python web application I have provided is cleverly (and lazily) named <em>Greeting</em>. This simple web application responds with an enthusiastic “Greetings!” when you visit <em>http://localhost:5000</em> on the VM. I am providing this application so you can focus on learning automation and provisioning; I won’t go over its code here.</p>
<p>You’ll use Ansible tasks to install the necessary libraries and files to run the web application. You’ll also install a <em>systemd</em> unit file, the standard service manager that manages processes and services on a Linux host, to make it easier to start and stop the web application. </p>
<p>The Ansible tasks to install the web application (and all the other tasks for this chapter) are located in the <em>ansible/chapter4/</em> directory. You should navigate to that directory and open the task file named <em>web_application.yml</em> in your favorite editor.</p>
<p>This file contains four individual tasks, named as follows:</p>
<ol class="decimal">
<li value="1">Install <code>python3-flask</code>, <code>gunicorn3</code>, and <code>nginx</code></li>
<li value="2">Copy Flask Sample Application</li>
<li value="3">Copy <em>Systemd</em> Unit file for Greeting</li>
<li value="4">Start and enable Greeting Application</li>
</ol>
<p>I’ll go over each of these tasks, starting with the one that installs the web application dependencies: <code>python3-flask</code>, <code>gunicorn3</code>, and <code>nginx</code>. It’s the first task at the top of the file, and it should look like this:</p>
<pre><code>- name: Install python3-flask, gunicorn3, and nginx
  apt:
    name:
      - python3-flask
      - gunicorn3
      - nginx
    update_cache: yes</code></pre>
<p>The task <code>name</code> describes its intent, which is to <code>Install</code> some software packages. The <code>apt</code> module is used again to install the <code>python3-flask</code>, the <code>gunicorn3</code>, and the <code>nginx</code> packages from the Ubuntu repository on the VM. This time, however, the <code>apt</code> module uses some syntactical sugar: a YAML list. This feature allows you to install multiple packages (or remove them) in a single task, instead of having to create a task for each package you want to install.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p> 	Flask (<a href="https://palletsprojects.com/p/flask/" class="LinkURL">https://palletsprojects.com/p/flask/</a>) is a web framework that is written in Python and known for its small code base and easy-to-use syntax. Gunicorn (<a href="https://gunicorn.org/" class="LinkURL">https://gunicorn.org/</a>), or Green Unicorn, is an HTTP server that is built on top of the web server gateway interface (WSGI, <a href="https://wsgi.readthedocs.io/en/latest/" class="LinkURL">https://wsgi.readthedocs.io/en/latest/</a>) standard. Gunicorn sits in front of the Flask application and proxies requests.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="40" id="Page_40"/>The second task from the top copies the sample Greeting application over to the VM. You need two files to bring the Greeting web application to life, and the task should look like this:</p>
<pre><code>- name: Copy Flask Sample Application
  copy:
    src: "../ansible/chapter4/{{ item }}"
    dest: "/opt/engineering/{{ item }}"
  group: developers
  mode: '0750'
  loop:
    - greeting.py
    - wsgi.py</code></pre>
<p>The <code>copy</code> module copies the two files from the provided repository to the VM. The <code>src</code> and <code>dest</code> lines are templated (with double curly brackets) and replaced by the values from the <code>loop</code> module. Here, the <code>loop</code> module references two files by name: <em>greeting.py</em> and <em>wsgi.py</em>. The <em>greeting.py</em> file is the actual Python Flask code, while the <em>wsgi.py</em> file contains the application object for the HTTP server. During this task’s runtime, the placeholder <code>{{ item }}</code> will be replaced with each of these two filenames from the <code>loop</code>. For example, the <code>src</code> line will look like <code>"../ansible/chapter4/greeting.py"</code> after the first pass of the <code>loop</code>. The <code>mode</code> line sets the permissions on both files to be read and to execute for anyone in the <em>developers</em> group.</p>
<p>Next, let’s look at the task that copies the <em>systemd</em> unit file over to the VM. This task, located third from the top, should look like this:</p>
<pre><code>- name: Copy Systemd Unit file for Greeting
  copy:
    src: "../ansible/chapter4/greeting.service"
    dest: "/etc/systemd/system/greeting.service"</code></pre>
<p>This task starts with a descriptive <code>name</code>, as usual. Then, the familiar Ansible <code>copy</code> module copies a file from the local host to the VM. In this case, it copies the <em>greeting.service</em> file to a place on the VM where <code>systemd</code> can find it: <em>/etc/systemd/system</em>. </p>
<p>Let’s review the <em>system service</em> file. Such files can have many options and settings, but for this example, I’ve provided a simple one to control the Greeting web application’s life cycle. </p>
<p>Open the <em>ansible/chapter4/greeting.service</em> file in your editor. It should look like this:</p>
<pre><code>[Unit]
Description=The Highly Complicated Greeting Application
After=network.target

[Service]
Group=developers
<b>WorkingDirectory=/opt/engineering </b>
<b>ExecStart=/usr/bin/gunicorn3 --bind 0.0.0.0:5000 --access-logfile - --error-logfile - wsgi:app </b>
ExecReload=/bin/kill -s HUP $MAINPID
<span epub:type="pagebreak" title="41" id="Page_41"/>KillMode=mixed

[Install]
WantedBy=multi-user.target</code></pre>
<p>The <code>WorkingDirectory</code> and <code>ExecStart</code> lines are the most important in this file. The first sets the working directory to <em>/opt/engineering</em>, since that’s where your application code lives. In the <code>ExecStart</code> line, the <code>gunicorn3</code> application calls the <em>wsgi.py</em> file to start the web application. You’ll also tell <code>gunicorn3</code> to log STDOUT (<code>--access-logfile -</code> ) and STDERR (<code>--error-logfile -</code> ) to the <em>systemd</em> journal, which is forwarded by default to the <em>/var/log/syslog</em> file. Close the <em>greeting.service</em> file for now.</p>
<p>The last task in the <em>web_application.yml</em> file ensures that the Greeting web application is started and that the <code>systemd</code> daemon is reloaded each time a provision is run. It should look like this:</p>
<pre><code>- name: Start and enable Greeting Application
  systemd:
    name: greeting.service
    daemon_reload: yes
    state: started
    enabled: yes</code></pre>
<p>Here, the <code>systemd</code> Ansible module starts the Greeting web application. The module requires you to set the <code>name</code> and <code>state</code>, which in this case are <code>greeting.service</code> and <code>started</code>, respectively. The <code>enabled</code> parameter tells <code>systemd</code> to start the service automatically during startup. Using the <code>daemon_reload</code> parameter also forces <code>systemd</code> to reload all service files and discover the <em>greeting.service</em> file before doing anything else. It’s equivalent to running <code>systemctl daemon-reload</code>. The <code>daemon_reload </code>parameter is useful on the first provision of a host to make sure <code>systemd</code> knows about the service. Be sure to use the <code>daemon_reload </code>parameter so that <code>systemd</code> always knows about any changes to the service file.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	In <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, you’ll see more advanced examples to help you learn how to deploy an application using a CI/CD pipeline inside Kubernetes.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502482c04-0003">Anatomy of a sudoers File</h2>
<p class="BodyFirst">A <em>sudoers</em> file is the place where you configure security policies (for users and groups) that invoke the <code>sudo</code> command. This type of security file is composed of sections called <code>Defaults</code>, <code>User Specifications</code>, and <code>Aliases</code>. A <em>sudoers</em> file is read from the top down, and since rules are applied in that order, the last matching rule always wins.</p>
<p>The <code>Defaults</code> syntax allows you to override some <em>sudoers</em> options at runtime, such as setting environment variables that users have access to when they run <code>sudo</code>. The <code>User Specifications</code> section determines which commands users can run and on which host they can run them. For example, you could give the <em>bender</em> user permission to run the <code>apt install</code> command on all web <span epub:type="pagebreak" title="42" id="Page_42"/>server hosts. The <code>Aliases</code> syntax references other objects inside the file, and that is useful for keeping the configuration clear and concise when there is a lot of duplication. </p>
<p>The four aliases you can mix and match are as follows:</p>
<ol class="none">
<li><code class="bold">Host_Alias</code>  A host or a group of hosts</li>
<li><code class="bold">Runas_Alias</code>  A list of users or groups a command can be run as</li>
<li><code class="bold">Cmnd_Alias</code>  Specifies a command or multiple commands</li>
<li><code class="bold">User_Alias</code>  A user or group of users</li>
</ol>
<p>For this example, you’ll only use <code>Cmnd_Alias</code> and <code>Host_Alias</code><em> </em>in your <em>sudoers</em> file. </p>
<h3 id="h2-502482c04-0002">Creating the sudoers File</h3>
<p class="BodyFirst">To create the <em>sudoers</em> file, you’ll use the Ansible <code>template</code> module and a template file. The Ansible <code>template</code> module is useful for creating files that will require some modification with variables. The <code>template</code> module creates files using the Jinja2 template engine for Python templates. You’ll keep template files in a separate directory called <em>ansible/templates/</em> (more on this later).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Jinja2 is a modern templating engine for the Python language. It is modeled after the Django web application templates. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>In the <em>ansible/chapter4/</em> directory, open the task file named <em>sudoers.yml</em> in your favorite editor. The first thing you should notice, at the top of the file, is a new Ansible module called <code>set_fact</code>. This module allows you to set host variables that can be used in a task or across a playbook. Here, you’ll set a variable with it for use in your template file:</p>
<pre><code>- set_fact:
    greeting_application_file: "/opt/engineering/greeting.py"</code></pre>
<p class="BodyContinued">This creates a variable named <code>greeting_application_file</code> and sets its value to <em>/opt/engineering/greeting.py</em> (where the previous tasks will install the web application). As noted previously, anyone in the <em>developers</em> group can read and execute in the <em>/opt/engineering/</em> directory. </p>
<p>Next, locate the task right below the <code>set_fact</code> module. This task creates the <em>sudoers</em> file for the <em>developers</em> group and should look like this:</p>
<pre><code>- name: Create sudoers file for the developers group
  template:
    src: "../ansible/templates/developers.j2"
    dest: "/etc/sudoers.d/developers"
    validate: 'visudo -cf %s'
    owner: root
    group: root
    mode: 0440</code></pre>
<p><span epub:type="pagebreak" title="43" id="Page_43"/>The Ansible <code>template</code> module builds out your <em>sudoers</em> file. It requires a source file (<code>src</code>) and a destination file (<code>dest</code>). The source file is your local Jinja2 template (<em>developers.j2</em>), and the destination file will be the <em>developers sudoers</em> file on the VM. The <code>template</code> module also contains a <code>validate</code> step to verify whether the template is correct. In this case, the <code>visudo</code> command edits and validates your <em>sudoers</em> file in a safe manner. Adding the <code>-cf</code> flag to <code>visudo</code> makes sure the <em>sudoers</em> file is compliant and free of syntax errors. The <var>%s</var> is a placeholder for the file in the <code>dest</code> parameter. If the <code>validate </code>command fails for any reason, the Ansible task will fail, too. Finally, set the owner, group, and permissions of the file to <code>root</code>, <code>root</code>, and <code>0440</code> (respectively). This is what <em>sudoers</em> is expecting for proper permissions.</p>
<h3 id="h2-502482c04-0003">The sudoers Template</h3>
<p class="BodyFirst">The Ansible <code>template</code> module task referenced a source Jinja2 template file located in the <em>ansible/templates/</em> directory. It has the building blocks of your <em>sudoers</em> policy for the <em>developers</em> group.</p>
<p>Navigate to the <em>ansible/templates/</em> directory and open the <em>developers.j2</em> file in your editor. The <em>.j2</em> suffix on the file tells Ansible that it’s a Jinja2 template. The contents of the file should look like this:</p>
<pre><code># Command alias
Cmnd_Alias	START_GREETING    = /bin/systemctl start greeting , \
				    /bin/systemctl start greeting.service
Cmnd_Alias	STOP_GREETING     = /bin/systemctl stop greeting , \
				    /bin/systemctl stop greeting.service
Cmnd_Alias	RESTART_GREETING  = /bin/systemctl restart greeting , \
				    /bin/systemctl restart greeting.service

# Host Alias
Host_Alias  LOCAL_VM = {{ hostvars[inventory_hostname]['ansible_default_ipv4']['address'] }}
# User specification
%developers LOCAL_VM = (root) NOPASSWD: START_GREETING, STOP_GREETING, \
	    	       RESTART_GREETING, \
		       sudoedit {{ greeting_application_file }}
</code></pre>
<p>The file begins with three <code>Cmnd_Alias</code> declarations that stop, start, and restart the Greeting web application. (In <code>systemd</code>, a service can be referred to as either <code>greeting</code> or <code>greeting.service</code>, so this handles both cases.) Next, a <code>Host_Alias</code> called <code>LOCAL_VM</code> is set to the private IP address of the VM. The built-in Ansible variable <code>hostvars</code> dynamically fetches the IP address of the VM during provision runtime. This is useful if you are provisioning many hosts at the same time. Finally, this creates a user specification for the <em>developers</em> group. (The <code>%</code> denotes it is a group and not a user.) The user specification rule states that anyone in the <em>developers</em> group, on the <code>LOCAL_VM</code>, can start, stop, restart, and edit the Greeting web application without a password, as the <em>root</em> user. Notice that issuing the <code>sudoedit</code> command is allowed only for <span epub:type="pagebreak" title="44" id="Page_44"/>editing the web application. (I’ll discuss <code>sudoedit</code> in more detail later.) The <code>{{ greeting_application_file }}</code> variable will be set during runtime to point to your Greeting web application file via <code>set_fact</code>. </p>
<p>At this point, it is safe to close all open files. Next, you’ll configure the VM and test <em>bender</em>’s <code>sudo</code> privileges.</p>
<h2 id="h1-502482c04-0004">Provisioning the VM</h2>
<p class="BodyFirst">To run all the tasks for this chapter, you need to uncomment them in the playbook like you did in previous chapters. Open the <em>ansible/site.yml</em> file in your editor and locate the task for installing the web application. It should look like this:</p>
<pre><code><b>#- </b><b>import_tasks</b><b>: chapter4/</b><b>web_application.yml</b></code></pre>
<p>Remove the <code>#</code> symbol to uncomment it.</p>
<p>Next, find the task that creates the <em>developers sudoer</em> policy:</p>
<pre><code><b>#- import_tasks: chapter4/sudoers.yml</b></code></pre>
<p>Uncomment that line by removing the <code>#</code> symbol as well. </p>
<p>The playbook should now look like this:</p>
<pre><code>---
- name: Provision VM
  hosts: all
  become: yes
  become_method: sudo
  remote_user: ubuntu
  tasks:
    - import_tasks: chapter2/pam_pwquality.yml
    - import_tasks: chapter2/user_and_group.yml
    - import_tasks: chapter3/authorized_keys.yml
    - import_tasks: chapter3/two_factor.yml
<b>    - </b><b>import_tasks</b><b>: chapter4/</b><b>web_application.yml</b>
<b>    - </b><b>import_tasks</b><b>: chapter4/</b><b>sudoers.yml</b>
  <var>--snip--</var>
  handlers:
    - import_tasks: handlers/restart_ssh.yml</code></pre>
<p class="BodyContinued">The changes to the playbook for Chapter 4 are added to the changes from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. </p>
<p>Now, you’ll run the Ansible tasks using Vagrant. Navigate back to the <em>vagrant/</em> directory where your <em>Vagrant</em> file is located and enter the following command to provision the VM:</p>
<pre><code>$ <b>vagrant</b> <b>provision</b>
<var>--snip--</var>
PLAY RECAP *********************************************************************
default       : ok=21  changed=6   unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</code></pre>
<p><span epub:type="pagebreak" title="45" id="Page_45"/>The values from the provision output will vary, depending on how many times you run the <code>provision</code> command, as Ansible makes sure your environment is consistent and doesn’t do extra work if it’s not needed. The total task count here has increased to <code>21</code>. You’ve also changed these six things on the VM:</p>
<ul>
<li>Five new tasks from Chapter 4</li>
<li>One task that updates the timestamp on the empty file from Chapter 2 </li>
</ul>
<p>Once again, make sure no actions have failed before you continue.</p>
<h2 id="h1-502482c04-0005">Testing Permissions</h2>
<p class="BodyFirst">With the VM successfully provisioned, you can now check your security policy by testing <em>bender</em>’s command access. First, you’ll need to log in to the VM as <em>bender</em> again. The <em>sudoers</em> policy should allow anyone in the <em>developers</em> group (<em>bender</em>, in this case) to start, stop, restart, or edit the web application. </p>
<p>To log in as <em>bender</em>, grab another 2FA token. This time, locate the second 2FA token from the top in the <em>ansible/chapter3/google_authenticator</em> file; it should be <code>68385555</code>. Once you have it, enter the following command in your terminal to log in as <em>bender</em>:</p>
<pre><code>$ <b>ssh</b> <b>-i ~/.ssh/dftd</b> <b>-p 2222 bender@localhost</b>
Enter passphrase for key '/Users/bradleyd/.ssh/dftd: <var class="bold">&lt;passphrase&gt;</var>
Verification code: <var class="bold">&lt;68385555&gt;</var>
<var>--snip--</var>
bender@dftd:~$</code></pre>
<p>Here, you’re using the SSH parameters from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> to log in to the VM. When prompted for the 2FA token, use the second one you just grabbed. This login process should be familiar by now, but if not, revisit <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> for a refresher.</p>
<h3 id="h2-502482c04-0004">Accessing the Web Application</h3>
<p class="BodyFirst">You’ll need to make sure the web application is running and responding to requests. You’ll test it with the <code>curl</code> command, which transfers data to servers (in this case, an HTTP server). The Greeting application server listens for requests on all interfaces on port 5000. So, in the terminal, enter the following command to send an <code>HTTP GET</code> request to the greeting server on port 5000:</p>
<pre><code>bender@dftd:~$ <b>curl http://localhost:5000</b>
&lt;h1 style='color:green'&gt;Greetings!&lt;/h1&gt;</code></pre>
<p class="BodyContinued">The output shows the Greeting web application is responding to requests successfully on <code>localhost</code> in the VM.</p>
<h3 id="h2-502482c04-0005"><span epub:type="pagebreak" title="46" id="Page_46"/>Editing greeting.py to Test the sudoers Policy</h3>
<p class="BodyFirst">Next, you’ll make a small change to the Greeting application using <code>sudoedit</code> to test <em>bender</em>’s permissions. The <em>sudoers</em> policy you set earlier in this chapter allows the <em>developers</em> group members to edit the <em>/opt/engineering/greeting.py</em> file with the <code>sudoedit</code> command, which lets users edit a file with any editor. It also makes a copy of the file before editing, in case things go awry. Without <code>sudoedit</code>, you might need to create multiple command aliases for each editor a user wants to use.</p>
<p>In a real production system, you probably would not edit a file directly on a host. Instead, you would edit the source-controlled version and allow your automation to update it with the newest version. However, I’m describing this approach to show how to test your <em>sudoers</em> policy. </p>
<p>While still logged in as <em>bender</em>, enter the following command to edit the <em>greeting.py</em> file:</p>
<pre><code>bender@dftd:~$ <b>sudoedit /opt/engineering/greeting.py</b></code></pre>
<p>The command should drop you into the Nano text editor (default for Ubuntu). Once there, locate the line that looks like this inside the <code>hello()</code> function:</p>
<pre><code>return "&lt;h1 style='color:green'&gt;Greetings!&lt;/h1&gt;"</code></pre>
<p>Change the <code>Greetings!</code> text inside the heading tag to <code class="bold">Greetings and Salutations!</code> so the line looks like this:</p>
<pre><code>return "&lt;h1 style='color:green'&gt;<b>Greetings and Salutations!</b>&lt;/h1&gt;"</code></pre>
<p>Save the file and exit the Nano text editor. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Feel free to use a different editor, such as Vim, if you prefer. Just be sure to set the <code>EDITOR</code> environment variable (<code class="bold">export EDITOR=vim</code>) before using the <code>sudoedit</code> command. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502482c04-0006">Stopping and Starting with systemctl</h3>
<p class="BodyFirst">For the Greeting string changes to take effect, you’ll need to stop and start the web application server using <code>sudo</code> and the <code>systemctl</code> command (the latter of which is a command line application that allows you to control a service governed by <code>systemd</code>). The <code>Cmnd_Alias</code> declarations in your <em>sudoers</em> policy allow anyone in the <em>developers</em> group to run <code>/bin/systemctl stop greeting</code> or <code>/bin/systemctl start greeting</code>. </p>
<p>To stop the already running Greeting application using <code>systemctl</code>, enter the following command:</p>
<pre><code>bender@dftd:-$ <b>sudo systemctl stop greeting</b></code></pre>
<p class="BodyContinued">There should be no output from the command, and you should not be prompted for a password.  </p>
<p><span epub:type="pagebreak" title="47" id="Page_47"/>Next, run <code>curl</code> again to be sure the web application is stopped:</p>
<pre><code>bender@dftd:~$ <b>curl http://localhost:5000</b>
curl: (7) Failed to connect to localhost port 5000: Connection refused</code></pre>
<p class="BodyContinued">Here, <code>curl</code> responded with a <code>Connection refused</code> error since the server is not running any longer.</p>
<p>Restart the stopped Greeting server by entering this command:</p>
<pre><code>bender@dftd:-$ <b>sudo systemctl start greeting</b></code></pre>
<p class="BodyContinued">There won’t be any output from this command if it is successful. </p>
<p>Run the <code>curl</code> command again to check whether the web application is running with the new code changes:</p>
<pre><code>bender@dftd:~$ <b>curl http://localhost:5000</b>
&lt;h1 style='color:green'&gt;Greetings and Salutations!&lt;/h1&gt;</code></pre>
<p>The Greeting server provides a successful response with the new and improved greeting. If, for some reason, your Greeting application isn’t responding like this, go back and retrace your steps. Start by looking for errors in the <em>/var/log/syslog</em> file or the<em> /var/log/auth.log</em> file on the VM.</p>
<h2 id="h1-502482c04-0006">Audit Logs</h2>
<p class="BodyFirst">As mentioned previously, one great feature of <code>sudo</code> is that it leaves behind an audit trail. The events in this trail are typically used in a monitoring framework or when doing forensics during an incident response. No matter what, you should make sure the audit data is in an accessible area so you can review it. </p>
<p>If you followed along with the testing in this chapter, you ran the <code>sudo</code> command three different times. Those events were captured in the <em>/var/log/auth.log</em> file, so let’s explore some of the log lines from those <code>sudo</code> commands. I have cherry-picked a few that are pertinent to this example so you won’t get bogged down in the art of log parsing. However, feel free to explore the logfile in more depth on your own.</p>
<p>The first line in <em>auth.log</em> you’ll look at pertains to <em>bender</em>’s use of <code>sudoedit</code>:</p>
<pre><code>Jul 23 23:17:43 ubuntu-focal sudo:   bender : TTY=pts/0 ; PWD=/home/bender ; USER=root ; COMMAND=sudoedit /opt/engineering/greeting.py</code></pre>
<p class="BodyContinued">This line provides quite a bit of information, but let’s focus on the <code>date/time</code>, <code>USER</code>, and <code>COMMAND</code> columns. You can see that <em>bender</em> invoked <code>sudo</code> on <code>July 23</code> at <code>23:17:43</code>, using the <code>sudoedit /opt/engineering/greeting.py</code> command. This happened when you changed the <em>greeting.py</em> file to alter the greeting text.</p>
<p>This log line shows when you used <em>bender</em> to stop the Greeting server:</p>
<pre><code>Jul 23 23:18:19 ubuntu-focal sudo:   bender : TTY=pts/0 ; PWD=/home/bender ; USER=root ; COMMAND=/usr/bin/systemctl stop greeting</code></pre>
<p class="BodyContinued"><span epub:type="pagebreak" title="48" id="Page_48"/>On <code>July 23</code> at <code>23:18:19</code>, <em>bender</em> used <code>sudo</code> to execute the <code>/bin/systemctl stop greeting</code> command as the <em>root</em> user.</p>
<p>Finally, here is the log line showing <em>bender</em> starting the Greeting application:</p>
<pre><code>Jul 23 23:18:39 ubuntu-focal sudo:   bender : TTY=pts/0 ; PWD=/home/bender ; USER=root ; COMMAND=/usr/bin/systemctl start greeting</code></pre>
<p class="BodyContinued">On <code>July 23</code> at <code>23:18:39</code>, <em>bender</em> used <code>sudo</code> to execute the command <code>/bin/systemctl start greeting</code> as the <em>root</em> user.</p>
<p>So far, I have shown log entries that were successful and expected. The following line shows <em>bender</em> executing an unsuccessful command:</p>
<pre><code>Jul 23 23:25:14 ubuntu-focal sudo:   bender : command not allowed ; TTY=pts/0 ; PWD=/home/bender ; USER=root ; COMMAND=/usr/bin/tail /var/log/auth.log</code></pre>
<p class="BodyContinued">On <code>July 23</code> at <code>23:25:14</code>, <em>bender</em> tried to run the <code>/usr/bin/tail /var/log/auth.log</code> command, and it was denied. These are the types of log lines you probably want to track in an alerting system, as this could be a bad actor trying to navigate a host.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The <em>auth</em> log requires elevated permissions to read, and since your <em>sudoers</em> policy does not grant that to <em>bender</em>, you’ll need to issue <code>sudo</code> as the <em>vagrant</em> user to view it.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502482c04-0007">Summary</h2>
<p class="BodyFirst">This chapter explored the importance of allowing users to run commands with elevated privileges. Using Ansible, the <code>sudo</code> command, and a <em>sudoers</em> file, you can restrict command access and log an audit trail for security. You also worked with some different Ansible modules like <code>template</code>, <code>systemd</code>, and <code>set_fact</code>, which allowed you to automate the installation of your web application and control its life cycle. </p>
<p>In the next chapter, you’ll wrap up this section on provisioning and security. You’ll also use some provided Ansible tasks to secure the network and implement a firewall for the VM.</p>
</section>
</body></html>