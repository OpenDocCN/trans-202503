- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nonbinary Analysis
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter focuses on the static analysis of nonbinary file formats, such
    as packages, disk images, and scripts, that you’ll commonly encounter while analyzing
    Mac malware. Packages and disk images are compressed file formats often used to
    deliver malware to a user’s system. When we come across these compressed file
    types, our goal is to extract their contents, including any malicious files. These
    files, for example a malware’s installer, can come in various formats, though
    most commonly as either scripts or compiled binaries (often within an application
    bundle). Because of their plaintext readability, scripts are rather easy to manually
    analyze, though malware authors often attempt to complicate the analysis by applying
    obfuscation techniques. On the other hand, compiled binaries are not readily understandable
    by humans. Analyzing such files requires both an understanding of the macOS binary
    file format as well as the use of specific binary analysis tools. Subsequent chapters
    will cover these topics.
  prefs: []
  type: TYPE_NORMAL
- en: More often than not, the static analysis of a file starts with determining the
    file type. This first step is essential, as the majority of static analysis tools
    are file-type specific. For example, if we identify a file as a package or disk
    image, we’ll then leverage tools capable of extracting components from these compressed
    installation media. On the other hand, if the file turns out to be a compiled
    binary, we must instead use binary-specific analysis tools to assist our analysis
    efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying File Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted, most static analysis tools are file-type specific. Thus, the first
    step in analyzing a potentially malicious file is identifying its file type. If
    a file has an extension, the extension will likely identify the file’s type, and
    this is especially true of extensions used by the operating system to invoke a
    default action. For example, a malicious disk image without the *.dmg* extension
    won’t be automatically mounted if the user double-clicks it, so malware authors
    are unlikely to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Often, though, malware authors will attempt to mask the true file type of their
    creation in order to trick or coerce the user into running it. It goes without
    saying that looks can be deceiving, and you shouldn’t identify a file’s type solely
    by its appearance (such as its icon) or what appears to be its file extension.
    For example, the WindTail malware is specifically designed to masquerade as a
    benign Microsoft Office document. In reality, the file is a malicious application
    that, when executed, will persistently infect the system.
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of the spectrum, malicious files may have no icon or file extension.
    Moreover, a cursory triage of the contents of such files may provide no clues
    about the file’s actual type. For example, [Listing 4-1](#listing4-1) is a suspected
    malicious file, simply named *5mLen*, of some unknown binary format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: An unknown file type'
  prefs: []
  type: TYPE_NORMAL
- en: 'So how can we effectively identify a file’s format? One great option is macOS’s
    built-in `file` command. For example, running the `file` command on the unknown
    *5mLen* file identifies the file’s type as byte-compiled Python code ([Listing
    4-2](#listing4-2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-2: Using `file` to identify a byte-compiled Python script'
  prefs: []
  type: TYPE_NORMAL
- en: More on this adware soon, but knowing that a file is byte-compiled Python code
    allows us to leverage various tools *specific to this file format*; for example,
    we can reconstruct a readable representation of the original Python code using
    a Python decompiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to WindTail, we can again use the `file` utility to reveal that the
    malicious files (which recall, used icons in an attempt to masquerade as harmless
    Office documents), are actually application bundles containing 64-bit Mach-O executables
    ([Listing 4-3](#listing4-3)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-3: Using `file` to identify a compiled 64-bit Mach-O executable (WindTail)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `file` utility sometimes doesn’t identify a file’s type in a very
    helpful way. For example, it often misidentifies disk images (*.dmg*), which can
    be compressed, as simply `VAX COFF` files. In this case, other tools such as WhatsYourSign
    may be of more assistance.^([1](#c04-endnote-1))
  prefs: []
  type: TYPE_NORMAL
- en: 'I wrote WhatsYourSign (WYS) as a free, open source tool primarily designed
    to display cryptographic signing information, but it also can identify file types.
    Once you’ve installed WYS, it adds a context menu option to Finder. This allows
    you to ctrl-click any file, then select the **Signing Info** option in the drop-down
    context menu to view its type. For example, WYS can readily identify WindTail’s
    true type: a standard application ([Figure 4-1](#figure4-1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![WhatsYourSign’s Signing Info screen shows WindTail information, including
    “Item Type: Application,” “Hashes: View Hashes” (a clickable link), “Entitled:
    None,” and “Sign Auths: Unavailable, as certificate has been revoked”](image_fi/501942c04/f04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: Using WhatsYourSign to identify an application (WindTail)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides providing a convenient way to determine a file’s type via the macOS
    user interface, WYS can also identify file types that the command line `file`
    tool may struggle with, such as disk images. Take the example in [Listing 4-4](#listing4-4),
    in which we run `file` on a disk image trojanized with EvilQuest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-4: With disk images, `file` struggles (EvilQuest)'
  prefs: []
  type: TYPE_NORMAL
- en: The `file` tool rather unhelpfully responds with `zlib compressed data`. While
    this is technically true (a disk image *is* compressed data), the output from
    WYS is more helpful. As you can see in [Figure 4-2](#figure4-2), it lists the
    item type as “Disk Image.”
  prefs: []
  type: TYPE_NORMAL
- en: '![WhatsYourSign’s Signing Info screen shows Evil Quest information, including
    “Item Type: Disk Image” and “Sign Auths: unsigned (‘errSecCSUnsigned’).”](image_fi/501942c04/f04002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: Using WYS to identify a disk image (EvilQuest)'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Malicious Files from Distribution Packaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After identifying an item’s file type, you’ll often continue static analysis
    with the assistance of tools specific to the identified file type. For example,
    if an item turns out to be a disk image or an installer package, you can leverage
    tools designed specifically to extract the files from these distribution mechanisms.
    Let’s take a look at this now.
  prefs: []
  type: TYPE_NORMAL
- en: Apple Disk Images (.dmg)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apple Disk Images (*.dmg*) are a popular way to distribute software to Mac users.
    Of course, there is nothing stopping malware authors from leveraging this software
    distribution format too.
  prefs: []
  type: TYPE_NORMAL
- en: You can generally identify disk images by their file extension, *.dmg*. Malware
    authors will rarely change this extension because, when the user double-clicks
    any file with a *.dmg* extension, the operating system will automatically mount
    it and display its contents, which is often what malware authors want. Alternatively,
    you can use WYS to identify this file type, as the `file` tool may struggle to
    conclusively identify such disk images.
  prefs: []
  type: TYPE_NORMAL
- en: 'For analysis purposes, we can manually mount an Apple Disk Image via macOS’s
    built-in `hdiutil` command, which allows us to examine the disk image structure
    and extract the files’ contents, such as a malicious installer or application,
    for analysis. When invoked with the `attach` option, `hdiutil` will mount the
    disk image to the */Volumes* directory. As an example, [Listing 4-5](#listing4-5)
    mounts a trojanized disk image via the command `hdiutil attach`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-5: Using `hdiutil` to mount an infected disk image (CreativeUpdate)'
  prefs: []
  type: TYPE_NORMAL
- en: Once the disk image has been mounted, `hdiutil` displays the mount directory
    (for example, */Volumes/Firefox*). You can now directly access the files within
    the disk image. Browsing this mounted disk image, either via the terminal (with
    `cd /Volumes/Firefox`) or the user interface, reveals a Firefox application, trojanized
    with the CreativeUpdate malware. For more details on the *.dmg* file format, see
    “Demystifying the DMG File Format.”^([2](#c04-endnote-2))
  prefs: []
  type: TYPE_NORMAL
- en: Packages (.pkg)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common file format that attackers often abuse to distribute Mac malware
    is the ubiquitous macOS package. Like with a disk image, the output from the `file`
    utility when examining a package may be somewhat confusing. Specifically, it may
    identify the package as a compressed *.xar* archive, the underlying file format
    of packers. From an analysis point of view, it’s far more helpful to know it is
    a package.
  prefs: []
  type: TYPE_NORMAL
- en: WYS can more accurately identify such files as packages. Moreover, when distributed,
    packages will end with the *.pkg* or *.mpkg* file extensions. These extensions
    ensure that macOS will automatically launch the package when, for example, a user
    double-clicks it. Packages can also be signed, a fact that can provide insight
    during analysis. For example, if a package is signed by a reputable company (such
    as Apple), the package and its contents are likely benign.
  prefs: []
  type: TYPE_NORMAL
- en: As with disk images, you generally won’t be interested in the package per se,
    but rather its contents. Our goal, therefore, is to extract the contents of the
    package for analysis. Since packages are compressed archives, you’ll need a tool
    to decompress and examine or extract the package’s contents. If you are comfortable
    using the terminal, macOS’s built-in `pkgutil` utility can extract the contents
    of a package via the `--expand-full` command line option. Another option is the
    free Suspicious Package application, which, as explained by its documentation,
    lets you open and explore macOS installer packages without having to install them
    first.^([3](#c04-endnote-3)) Specifically, Suspicious Package allows you to examine
    package metadata, such as code-signing information, as well as browse, view, and
    export any files found within the package.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s use Suspicious Package to explore a package containing
    the CPUMeaner malware ([Figure 4-3](#figure4-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Suspicious Package’s Package Info tab shows information for the CPUMeaner
    malware, mosx3.pkg. The information is as follows: “Installs 2 items—332 KB on
    disk,” “REVOKED: Claims to be signed by ‘Developer ID Installer: Artur Nurgaliev
    (DEWCRD3789),’” “Runs 2 install scripts,” “Downloaded by Safari—today at 9:04
    pm,” and “Found one critical issue for review.”](image_fi/501942c04/f04003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: Using Suspicious Package to examine a package (CPUMeaner)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suspicious Package’s Package Info tab provides general information about the
    package, including:'
  prefs: []
  type: TYPE_NORMAL
- en: That it installs two items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That its certificate has been revoked by Apple (a critical issue and large red
    flag, likely indicating it contains malicious code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That it runs two install scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The All Files tab ([Figure 4-4](#figure4-4)) reveals the directories and files
    the package would install if it ran. Plus, this tab allows us to export any of
    these items.
  prefs: []
  type: TYPE_NORMAL
- en: '![Suspicious Package’s All Files tab shows the files CPUMeaner’s mosx3.pkg
    would install: Library▶Application Support▶CpuCooler▶cpucooler. The CpuCooler
    folder contains the executable cpucooler, which can be exported.](image_fi/501942c04/f04004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: Using Suspicious Package to export a file (CPUMeaner)'
  prefs: []
  type: TYPE_NORMAL
- en: Packages often contain pre- and post-install bash scripts that may contain additional
    logic required to complete the installation. As these files are automatically
    executed during installation, you should always check for and examine these files
    when analyzing a potentially malicious package! Malware authors are quite fond
    of abusing these scripts to perform malicious actions, such as persistently installing
    their code.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, clicking the All Scripts tab reveals a malicious post-install script
    ([Figure 4-5](#figure4-5)).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, CPUMeaner’s post-install script contains an embedded launch
    agent property list and commands to configure and write to the file */Library/LaunchAgents/com.osxext.cpucooler.plist*.
    Once this property list has been installed, the malware’s binary, */Library/Application
    Support/CpuCooler/cpucooler*, will be automatically started each time the user
    logs in.
  prefs: []
  type: TYPE_NORMAL
- en: '![Suspicious Package’s All Scripts tab contains CPUMeaner’s post-install script.
    The script includes the identifier (com.osxext.cpucooler), install location, launch
    agent property list (/Library/LaunchAgents/$IDENTIFIER.plist), and commands to
    write to the identifier file.](image_fi/501942c04/f04005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: Using Suspicious Package to examine a post-install script (CPUMeaner)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a write-up titled “Pass the AppleJeus,” I highlighted another example of
    a malicious package, this time belonging to the Lazarus Group.^([4](#c04-endnote-4))
    As the malicious package is contained within an Apple disk image, the *.dmg* must
    first be mounted. As shown in [Listing 4-6](#listing4-6), we first mount the malicious
    disk image, *JMTTrader_Mac.dmg*. Once it’s mounted to */Volumes/JMTTrader/*, we
    can list its files. We observe it contains a single package, *JMTTrader.pkg*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-6: Listing a disk image’s files (AppleJeus)'
  prefs: []
  type: TYPE_NORMAL
- en: Once the disk image has been mounted, we can access and examine the malicious
    package (*JMTTrader.pkg*), again via Suspicious Package ([Figure 4-6](#figure4-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Suspicious Package’s Package Info tab contains information for JMTTrader.pkg
    as follows: “Installer Package,” “Installs 132 items—31.8 MB on disk,” “Not signed,”
    “Runs 1 install script.”](image_fi/501942c04/f04006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: Using Suspicious Package to examine a package (AppleJeus)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The package is unsigned (which is rather unusual) and contains the following
    post-install script containing the malware’s installation logic ([Listing 4-7](#listing4-7)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-7: A post-install script, containing installer logic (AppleJeus)'
  prefs: []
  type: TYPE_NORMAL
- en: Examining this post-install script reveals it will persistently install the
    malware (*CrashReporter*) as a launch daemon (*org.jmttrading.plist*).
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve extracted the malware from its distribution packaging (whether a
    *.dmg*, *.pkg*, *.zip*, or some other format), it’s time to analyze the actual
    malware specimen. Generally, such malware is either a script (like a shell script,
    a Python script, or an AppleScript) or a compiled Mach-O binary. Due to their
    readability, scripts are often rather trivial to analyze and may require no special
    analysis tools, so we’ll start there.
  prefs: []
  type: TYPE_NORMAL
- en: Bash Shell Scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll find various Mac malware specimens written in shell scripting languages.
    Unless the shell script code has been obfuscated, it’s easy to understand. For
    example, in Chapter 3 we took a look at a bash script that the Dummy malware persists
    as a launch daemon. Recall the script simply executed a handful of Python commands
    in order to launch an interactive remote shell.
  prefs: []
  type: TYPE_NORMAL
- en: We find a slightly more complex example of a malicious bash script in Siggen.^([5](#c04-endnote-5))
    Siggen is distributed as a ZIP file containing a malicious, script-based application,
    *WhatsAppService.app*. The application was created via the popular developer tool
    Platypus, which packages up a script into a native macOS application.^([6](#c04-endnote-6))
    When a “platypussed” application is run, it executes a script aptly named *script*
    from the application’s *Resources/* directory ([Figure 4-7](#figure4-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![WhatsAppService’s Contents folder includes two folders, Resources and MacOS.
    The Resources folder contains a script named script, a PDF named Applcon.icns,
    MainMenu.nib, and AppSettings.plist](image_fi/501942c04/f04007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: A script-based payload (Siggen)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at this shell script to see what we can learn from it ([Listing
    4-8](#listing4-8)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-8: A malicious bash script (Siggen)'
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that various parts of the script are obfuscated, such as the
    long gibberish section 1. We can identify the obfuscation scheme as base64, since
    the script pipes the obfuscated strings to macOS’s `base64` command (along with
    the decode flag, `-D`) 2. Using the same `base64` command, we can manually decode
    and thus fully deobfuscate the script.
  prefs: []
  type: TYPE_NORMAL
- en: Once these encoded script snippets are decoded, it is easy to comprehensively
    understand the script. The first line, `echo c2NyZ...Wwn | base64 -D | sh`, decodes
    and executes `screen -dm bash -c 'sleep 5;killall Terminal'`, which effectively
    kills any running instances of *Terminal.app*, likely as a basic anti-analysis
    technique. Then, via `curl`, the malware downloads and persists a launch agent
    named *a.plist.* Next, it decodes and executes another obfuscated command. The
    deobfuscated command, `chmod +x ~/Library/LaunchAgents/a.plist`, unnecessarily
    sets the launch agent property list to be executable. This property list is then
    loaded via the `launchctl load` command. The malware then downloads another file,
    another script named *c.sh*. Decoding the final two lines reveals that the malware
    first sets this script to be executable, and then executes it.
  prefs: []
  type: TYPE_NORMAL
- en: And what does the */Users/Shared/c.sh* script do? Let’s take a peek ([Listing
    4-9](#listing4-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-9: Another malicious bash script (Siggen)'
  prefs: []
  type: TYPE_NORMAL
- en: After connecting to *usb.mine.nu/p.php*, it checks for a response containing
    the string `'open'`. Following this, the script checks if a launch service named
    `HEYgiNb` is running. At that point, it decodes a large blob of base64-encoded
    data and executes it via Python. Let’s now discuss how to statically analyze such
    Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Python Scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anecdotally speaking, Python seems to be the preferred scripting language for
    Mac malware authors, as it is quite powerful, versatile, and natively supported
    by macOS. Though these scripts often leverage basic encoding and obfuscation techniques
    aimed at complicating analysis, analyzing malicious Python scripts is still a
    fairly straightforward endeavor. The general approach is to first decode or deobfuscate
    the Python script, then read through the decoded code. Though various online sites
    can help you analyze obfuscated Python scripts, a manual approach works too. Here
    we’ll discuss both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first consider [Listing 4-10](#listing4-10), an unobfuscated example:
    Dummy’s small Python payload (found wrapped in a bash script).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-10: A malicious Python script (Dummy)'
  prefs: []
  type: TYPE_NORMAL
- en: As this code isn’t obfuscated, understanding the malware’s logic is straightforward.
    It begins by importing various standard Python modules, such as `socket`, `subprocess`,
    and `os` 1. It then makes a socket and connection to `185.243.115.230` on port
    `1337` 2. The file handles for `STDIN` (`0`), `STDOUT` (`1`), and `STDERR` (`2`)
    are then duplicated, 3 redirecting them to the socket.
  prefs: []
  type: TYPE_NORMAL
- en: The script then executes the shell, */bin/sh*, interactively via the `-i` flag
    4. As the file handles for `STDIN`, `STDOUT`, and `STDERR` have been duplicated
    to the connected socket, any remote commands entered by the attacker will be executed
    locally on the infected system, and any output will be sent back through the socket.
    In other words, the Python code implements a simple, interactive remote shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another piece of macOS malware that is at least partially written in Python
    is Siggen. As discussed in the previous section, Siggen contains a bash script
    that decodes a large chunk of base64-encoded data and executes it via Python.
    [Listing 4-11](#listing4-11) shows the decoded Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-11: A decoded Python payload (Siggen)'
  prefs: []
  type: TYPE_NORMAL
- en: Following the imports of a few modules, the script defines a function called
    `get_uid`. This subroutine generates a unique identifier based on the user and
    MAC address of the infected system. The script then builds a dictionary to hold
    HTTP headers for use in a subsequent HTTP request 1. The embedded, hardcoded base64-encoded
    data `-eyJ0eXBlIj...ifX0=` 2 decodes to a JSON dictionary ([Listing 4-12](#listing4-12)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-12: Decoded configuration data (Siggen)'
  prefs: []
  type: TYPE_NORMAL
- en: The script then makes a request to the attacker’s server at *http://zr.webhop.org*
    on port `1337` via the `urllib2.urlopen` method 3. It expects the server to respond
    with a 404 HTTP code, which normally means the requested resource was not found.
    However, examining the script reveals that the malware expects this response to
    contain base64-encoded data, which it extracts, decodes, and then executes 4.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the *http://zr.webhop.org* server was no longer serving up this
    final-stage payload at the time of my analysis in early 2019\. However, Phil Stokes,
    a well-known Mac security researcher, noted that the script “leverages a public
    post-exploitation kit, *Evil.OSX*, to install a backdoor.”^([7](#c04-endnote-7))
    And, of course, the attackers could swap out the remote Python payload anytime
    to execute whatever they wanted on the infected systems!
  prefs: []
  type: TYPE_NORMAL
- en: As a final example, let’s return to the adware file named *5mLen*. We discussed
    it earlier in this chapter when we ran the `file` tool to determine it was compiled
    Python code. As Python is an interpreted language, programs written in this language
    are usually distributed as human-readable scripts. However, these scripts can
    also be compiled and distributed as Python bytecode, a binary file format. In
    order to statically analyze the file, you must first decompile the Python bytecode
    back to a representation of the original Python code. An online resource, such
    as Decompiler, can perform this decompilation for you.^([8](#c04-endnote-8)) Another
    option is to install the uncomplye6 Python package to locally decompile the Python
    bytecode.^([9](#c04-endnote-9))
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-13](#listing4-13) shows the decompiled Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-13: Decompiled Python code (unspecified adware)'
  prefs: []
  type: TYPE_NORMAL
- en: Though we now have Python source code, the majority of the code is still obfuscated
    in what appears to be an encoded string 1. From the API calls `zlib.decompress`
    and `base64.b64decode`, we can conclude that the original source code has been
    base64-encoded and zlib-compressed in order to (slightly) complicate static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to deobfuscate the code is via the Python shell interpreter.
    We can convert the `exec` statement to a `print` statement, then have the interpreter
    fully deobfuscate the code for us ([Listing 4-14](#listing4-14)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-14: Deobfuscated Python code (unspecified adware)'
  prefs: []
  type: TYPE_NORMAL
- en: With the fully deobfuscated Python code in hand, we can continue our analysis
    by reading the script to figure out what it does. In the `wvn` class’s `__init__`
    method, we see references to various variables of interest 1. Based on their names
    (and continued analysis) we conclude such variables contain the name of a base64-encoded
    file (*ij1.b64*), an XOR encryption key (`1bm5pbmcKc`), and an “injection” URL
    (*https://1049434604.rsc.cdn77.org/ij1.min.js*). The latter, as you’ll see, gets
    locally injected into user webpages in order to load malicious JavaScript. In
    the `wvR` method, the code checks if the script was invoked with the `f=` command
    line option 2. If so, it sets the `B64_ENC_FILE` variable to the specified file
    3. On an infected system, the script was persistently invoked with `python 5mLen
    f=6bLJC`, meaning the `B64_ENC_FILE` will be set to `6bLJC`.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a peek at the `6bLJC` file reveals it is encoded, or possibly encrypted.
    Though we might be able to manually decode it (as we have an `XOR` key, `1bm5pbmcKc`),
    there is a simpler way. Again, by inserting a `print` statement immediately after
    the logic that decodes the contents of the file, we can coerce the malware to
    output the decoded contents. This output turns out to be yet another script that
    the malware executes. However, this script is not Python, but rather AppleScript,
    which we’ll explore in the next section. For a more detailed walkthrough of the
    static analysis of this malware, see my write-up “Mac Adware, à la Python.”^([10](#c04-endnote-10))
  prefs: []
  type: TYPE_NORMAL
- en: AppleScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AppleScript is a macOS-specific scripting language generally used for benign
    purposes, and often for system administration, such as task automation or to interact
    with other applications on the system. By design, its grammar is rather close
    to spoken English. For example, to display a dialog with an alert ([Listing 4-15](#listing4-15)),
    you can simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-15: “Hello, World!” in AppleScript'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute these scripts via the `/usr/bin/osascript` command. AppleScripts
    can be distributed in their raw, human-readable form or compiled. The former case
    uses the *.applescript* extension, while the latter normally uses a *.scpt* extension,
    as shown in [Listing 4-16](#listing4-16):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-16: Using `file` to identify compiled AppleScript'
  prefs: []
  type: TYPE_NORMAL
- en: And unless the script has been compiled with the “run-only” option (more on
    this later), Apple’s Script Editor can reconstruct the source code from compiled
    scripts. For example, [Figure 4-8](#figure4-8) shows the Script Editor successfully
    decompiling our compiled “Hello, World!” script.
  prefs: []
  type: TYPE_NORMAL
- en: '![AppleScript has decompiled the script HELLOWORLD.SCPT, shown by “display
    dialog: ‘Hello World!’”](image_fi/501942c04/f04008_new.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8: Apple’s Script Editor'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also decompile scripts via macOS’s built-in `osadecompile` command
    ([Listing 4-17](#listing4-17)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-17: “Hello, World!” via AppleScript'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by discussing an easy example. Earlier in this chapter, we discussed
    a Python-compiled adware specimen and noted that it contained an AppleScript component.
    The Python code decrypts this AppleScript stored in the `wvd.PLAIN_TEXT_SCRIPT`
    variable and then executes it via a call to the `osascript` command. [Listing
    4-18](#listing4-18) shows the AppleScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-18: Malicious AppleScript (unspecified adware)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, this AppleScript invokes an `is_Chrome_running` function to check
    if Google Chrome is running by asking the operating system if the process list
    contains `"Google Chrome"` 4. If it does, the script grabs the HTML code of the
    page in the active tab, and checks for an injection marker: `493024ui5o` 1. If
    this marker is not found, the script injects and executes two pieces of JavaScript
    2. From our analysis, we can ascertain that the ultimate goal of this AppleScript-injected-JavaScript
    is to load and execute another malicious JavaScript file, *ij1.min.js*, from *https://1049434604.rsc.cdn77.org/*
    in the user’s browser 3. Unfortunately, as this URL was offline at the time of
    analysis, we cannot know exactly what the script would do, although malware like
    this typically injects ads or pop-ups in a user’s browser session in order to
    generate revenue for its authors. Of course, injected JavaScript could easily
    perform more nefarious actions, such as capturing passwords or piggybacking on
    authenticated user sessions.'
  prefs: []
  type: TYPE_NORMAL
- en: A rather archaic example of Mac malware that abused AppleScript is DevilRobber.^([11](#c04-endnote-11))
    Though this malware focused primarily on stealing Bitcoins and mining cryptocurrencies,
    it also targeted the user’s keychain in order to extract accounts, passwords,
    and other sensitive information. In order to access the keychain, DevilRobber
    had to bypass the keychain access prompt, and it did so via AppleScript.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, DevilRobber executed a malicious AppleScript file named *kcd.scpt*
    via macOS’s built-in `osascript` utility. This script sent a synthetic mouse click
    event to the Always Allow button of the keychain access prompt, allowing the malware
    to access the contents of the keychain ([Figure 4-9](#figure4-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '![DevilRobber’s synthetic mouse click event shows a pop-up window that states,
    “security wants to access key ‘ids: identity-rsa-private-key’ in your keychain.
    Do you want to allow access to this item?” and has three clickable options: Always
    Allow, Deny, and Allow. ](image_fi/501942c04/f04009_new.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-9: Synthetic click via AppleScript (DevilRobber)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The AppleScript used to perform this synthetic mouse click is straightforward;
    it simply tells the `SecurityAgent` process, which owns the keychain access window,
    to click the Always Allow button ([Listing 4-19](#listing4-19)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-19: Synthetic click via AppleScript (DevilRobber)'
  prefs: []
  type: TYPE_NORMAL
- en: The readability of the AppleScript grammar, coupled with the ability of Apple’s
    Script Editor to parse and often decompile such scripts, makes analysis of malicious
    AppleScripts quite simple. From an attacker’s point of view, the extreme readability
    of AppleScript is a rather large negative, as it means malware analysts can easily
    understand any malicious script. As noted earlier, though, attackers can export
    AppleScripts as run-only ([Figure 4-10](#figure4-10)). Unfortunately, the Script
    Editor cannot decompile AppleScripts exported via the run-only option, (or via
    the `osacompile` command with the `-x` option), complicating certain analyses.
  prefs: []
  type: TYPE_NORMAL
- en: '![The helloWorld.scpt can be exported as run-only through AppleScripts. AppleScript’s
    exporting screen shows helloWorld.scpt renamed to be exported as helloWorld_RO.scpt,
    with the file format set as “Script.” Of the options “Show startup screen,” “Stay
    open after run handler,” and “Run-only,” only the latter is selected. Under Code
    Sign, “Don’t Code Sign” is selected.](image_fi/501942c04/f04010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-10: Generating a run-only AppleScript'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run-only AppleScript files are not human readable, nor are they decompilable
    via `osadecompile`. As you can see in [Listing 4-20](#listing4-20), an attempt
    to decompile a run-only script causes an `errOSASourceNotAvailable` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-20: Decompiling a run-only AppleScript via `osadecompile` fails'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a Mac malware specimen that leverages run-only AppleScript is
    OSAMiner, which Mac malware researcher Phil Stokes thoroughly examined in “Adventures
    in Reversing Malicious Run-Only AppleScripts.”^([12](#c04-endnote-12)) In doing
    so, he presented a comprehensive list of techniques for analyzing run-only AppleScript
    files. His write-up noted that OSAMiner installs a launch item that persists an
    AppleScript. This launch item is shown in [Listing 4-21](#listing4-21). Note that
    the values in the `ProgramArguments` key will instruct macOS to invoke the `osascript`
    command to execute an AppleScript file named *com.apple.4V.plist* 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-21: A persistent launch item plist (OSAMiner)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `file` and `osadecompile` commands confirm the persisted item,
    *com.apple.4V.plist*, is a run-only AppleScript that cannot be decompiled via
    macOS’s built-in tools ([Listing 4-22](#listing4-22)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-22: Decompiling run-only AppleScript via `osadecompile` fails (OSAMiner)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we can turn to an open source AppleScript disassembler created by
    Jinmo.^([13](#c04-endnote-13)) After installing this disassembler, we can disassemble
    the *com.apple.4V.plist* file ([Listing 4-23](#listing4-23)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-23: Decompiling run-only AppleScript via the AppleScript disassembler'
  prefs: []
  type: TYPE_NORMAL
- en: The disassembler breaks out the run-only AppleScript into various functions
    (called *handlers* in AppleScript parlance). For example, we can see a function
    named `e` (“encode”?) adding 0x64 to an item in a loop, while the `d` (“decode”?)function
    appears to do the inverse by subtracting 0x64\. The latter, `d`, is invoked several
    times elsewhere in the code, to deobfuscate various strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, the disassembly leaves much to be desired. For example, in various places
    within the code, the disassembler does not sufficiently extract hardcoded strings
    in a human-readable manner. To address its shortcomings, Stokes created his own
    open source AppleScript decompiler named `aevt_decompile`.^([14](#c04-endnote-14))
    This decompiler takes as input the output from the AppleScript disassembler ([Listing
    4-24](#listing4-24)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-24: Decompiling run-only AppleScripts via an AppleScript disassembler
    and `aevt_decompile`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aevt_decompile` decompiler produces output that is more conducive to analysis.
    For example, it extracts hardcoded strings and makes them readable while correctly
    identifying and annotating Apple Event codes. Armed with the decompiled AppleScript,
    analysis can continue. In his write-up, Stokes noted that the malware would write
    out an embedded AppleScript to *~/Library/k.plist* and then execute it. Looking
    through the decompiled code, we can identify this logic ([Listing 4-25](#listing4-25)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-25: Further decompiling run-only AppleScript via `aevt_decompile`
    (OSAMiner)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the code writes out the embedded script via a call to the `do
    shell script` command 1. Then it executes this script with the `osascript` command
    (redirecting any output or errors to `/dev/null`) 2.
  prefs: []
  type: TYPE_NORMAL
- en: Reading through the rest of the decompiled AppleScript reveals the remaining
    capabilities of this component of the OSAMiner malware. For a continued discussion
    on how malware authors abuse AppleScript, see “How AppleScript Is Used for Attacking
    macOS.”^([15](#c04-endnote-15))
  prefs: []
  type: TYPE_NORMAL
- en: Perl Scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the world of macOS malware, Perl is not a common scripting language. However,
    at least one infamous macOS malware specimen was written in Perl: FruitFly. Created
    in the mid-2000s, it remained undetected in the wild for almost 15 years. FruitFly’s
    main persistent component, most commonly named *fpsaud*, was written in Perl ([Listing
    4-26](#listing4-26)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-26: Obfuscated Perl (FruitFly)'
  prefs: []
  type: TYPE_NORMAL
- en: Like other scripting languages, programs written in Perl are generally distributed
    as scripts rather than compiled. Thus, analyzing them is relatively straightforward.
    However, in the case of FruitFly, the malware author attempted to complicate the
    analysis by removing unnecessary whitespace in the code and renaming variables
    and subroutines using nonsensical single-letter names, a common tactic for both
    obfuscating and minimizing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leveraging any one of various online Perl “beautifiers,” we can reformat the
    malicious script and produce more readable code, as in [Listing 4-27](#listing4-27)
    (though the names of variables and subroutines remain nonsensical):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-27: Beautified, though still somewhat obfuscated, Perl (FruitFly)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The beautified Perl script still isn’t the easiest thing to read, but with
    a little patience, we can deduce the malware’s full capabilities. First, the script
    imports various Perl modules with the `use` keyword. These modules provide hints
    as to what the script is up to: the `IO:Socket` module indicates network capabilities,
    while the `IPC:Open2` module suggests that the malware interacts with processes.'
  prefs: []
  type: TYPE_NORMAL
- en: A few lines later, the script invokes `IO::Socket::INET` to create a connection
    to the attacker’s remote command and control server 1. Next, we can see that it
    invokes the built-in `scutil`, `hostname`, and `whoami` commands 2, which the
    malware likely uses to generate a basic survey of the infected macOS system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elsewhere in the code, the malware invokes other system commands to provide
    more capabilities. For example, it invokes the `ps` command to generate a process
    listing 3. This approach, of focusing on the commands invoked by the malware’s
    Perl code, provides sufficient insight into its capabilities. For a comprehensive
    analysis of this threat, see my research paper, “Offensive Malware Analysis: Dissecting
    OSX/FruitFly.”^([16](#c04-endnote-16))'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Office Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Malware researchers who analyze Windows malware are quite likely to encounter
    malicious, macro-laden Microsoft Office documents. Unfortunately, opportunistic
    malware authors have recently stepped up efforts to infect Office documents aimed
    at Mac users, too. These documents might contain only Mac-specific macro code
    or both Windows-specific and Mac-specific code, making them cross platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'We briefly discussed malicious Office documents in Chapter 1. Recall that macros
    provide a way to make a document dynamic, typically by adding executable code
    to the Microsoft Office documents. Using the `file` command, you can readily identify
    Microsoft Office documents ([Listing 4-28](#listing4-28)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-28: Using `file` to identify an Office document'
  prefs: []
  type: TYPE_NORMAL
- en: The *.docm* extension is a good indication that a file contains macros. Beyond
    this, determining whether the macros are malicious takes a tad more effort. Various
    tools can assist in this static analysis. The oletools toolset is one of the best.^([17](#c04-endnote-17))
    Free and open source, it contains various Python scripts created to facilitate
    the analysis of Microsoft Office documents and other OLE files.
  prefs: []
  type: TYPE_NORMAL
- en: 'This toolset includes the `olevba` utility designed to extract embedded macros
    from Office documents. After installing oletools via pip, execute `olevba` with
    the `-c` flag and the path to the macro-laden document. If the document contains
    macros, they will be extracted and printed to standard out ([Listing 4-29](#listing4-29)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-29: Using `olevba` to extract macros'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s take a closer look at a malicious Office document called
    *U.S. Allies and Rivals Digest Trump’s Victory.docm* that was sent to unsuspecting
    Mac users shortly after the 2016 US presidential election. First, we use `olevba`
    to both confirm the presence of, and extract, the document’s embedded macros ([Listing
    4-30](#listing4-30)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-30: Using `olevba` to extract malicious macros'
  prefs: []
  type: TYPE_NORMAL
- en: If you open an Office document containing macros and enable macros, code within
    subroutines such as `AutoOpen`, `AutoExec`, or `Document_Open` will run automatically.
    As you can see, this “Trump’s Victory” document contains macro code in one of
    these subroutines 1. Macro subroutine names are case-insensitive (for example,
    `AutoOpen` and `autoopen` are equivalent). For more details on subroutines that
    are automatically invoked, see Microsoft’s developer documentation “Description
    of behaviors of AutoExec and AutoOpen macros in Word.”^([18](#c04-endnote-18))
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the code within the `autoopen` subroutine invokes a subroutine
    named `Fisher` that builds a large base64-encoded string, stored in a variable
    named `cmd` 2, before invoking the system API and passing this string to Python
    for execution 3. Decoding the embedded string confirms that it’s Python code,
    which is unsurprising considering the macro code hands it off to Python. Entering
    various parts of the Python code in a search engine quickly reveals it is a well-known
    open source post-exploitation agent, Empyre.^([19](#c04-endnote-19))
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know that the goal of the malicious macro code is to download and execute
    to a fully featured interactive backdoor. Handing off control to some other malware
    is a common theme in macro-based attacks; after all, who wants to write a complete
    backdoor in VBA? For a thorough technical analysis of this macro attack, including
    a link to the malicious document, see “New Attack, Old Tricks: Analyzing a malicious
    document with a mac-specific payload.”^([20](#c04-endnote-20))'
  prefs: []
  type: TYPE_NORMAL
- en: Sophisticated APT groups, such as the Lazarus Group, also leverage malicious
    Office documents. For example, in Chapter 1 we analyzed a macro used to target
    macOS users in South Korea and discovered that it downloaded and executed a second-stage
    payload. The downloaded payload, *mt.dat*, turned out to be the malware known
    as Yort, a Mach-O binary that implements standard backdoor capabilities. For a
    comprehensive technical analysis of this malicious document and attack as a whole,
    see either my analysis “OSX.Yort” or the write-up “Lazarus Apt Targets Mac Users
    With Poisoned Word Document.”^([21](#c04-endnote-21))
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attackers often package Mac malware in malicious applications. Applications
    are a file format familiar to all Mac users, so a user may not think twice before
    running one. Moreover, as applications are tightly integrated with macOS, a double-click
    may be sufficient to fully infect a Mac system (although since macOS Catalina,
    notarization requirements do help prevent certain inadvertent infections).
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, an application is actually a directory, albeit one with a
    well-defined structure. In Apple parlance, we refer to this directory as an *application
    bundle*. You can view the contents of an application bundle (such as the malware
    WindTail) in Finder by CTRL-clicking an application’s icon and selecting **Show
    Package Contents** ([Figure 4-11](#figure4-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04011_1](image_fi/501942c04/f04011_1.png)![After selecting “Show [WindTail’s]
    Package Contents” in Finder, a new screen opens that shows the folders inside
    the Contents folder: _CodeSignature, MacOS, and Resources. The MacOS folder contains
    USRNODE, a Unix Executable File.](image_fi/501942c04/f04011_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-11: Viewing the contents of an application bundle (WindTail)'
  prefs: []
  type: TYPE_NORMAL
- en: However, a more comprehensive approach is to leverage the free Apparency application,
    which was designed specifically for the task of statically analyzing application
    bundles ([Figure 4-12](#figure4-12)).^([22](#c04-endnote-22)) In its user interface,
    you can browse components of the application to gain valuable insight into all
    aspects of the bundle, including identifier and version information, code-signing,
    and other security features, and information about the application’s main executable
    and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: '![In Apparency, highlighting the WindTail application shows a list of information,
    including its location, identifier (“com.alis.tre”), version (“1.0 [1]”), gatekeeper
    (“Can’t evaluate”), and who it was signed by (“Untrusted certificate”). Clicking
    the WindTail application opens a new window showing its Info Property List.](image_fi/501942c04/f04012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-12: Using Apparency to view the contents of an application bundle
    (WindTail)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet Apparency, as noted in its user guide, doesn’t show every file inside the
    app bundle. Thus, you might find the terminal useful for viewing all of the application
    bundle’s files ([Listing 4-31](#listing4-31)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-31: Using `find` to view the contents of an application bundle (WindTail)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard application bundles include the following files and subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Contents/*: A directory that contains all files and subdirectories of the
    application bundle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contents/_CodeSignature*: If the application is signed, contains code-signing
    information about the application (like hashes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contents/MacOS*: A directory that contains the application’s binary, which
    is what executes when the user double-clicks the application icon in the user
    interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contents/Resources*: A directory that contains user interface elements of
    the application, such as images, documents, and *nib/xib* files that describe
    various user interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contents/Info.plist*: The application’s main configuration file. Apple notes
    that macOS uses this file to ascertain pertinent information about the application
    (such as the location of the application’s main binary).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that not all of the aforementioned files and directories of an application
    bundle are required. Though it’s unusual, if an *Info.plist* file is not found
    in the bundle, the operating system will assume that the application’s executable
    will be found in the *Contents/MacOS* directory with a name that matches the application
    bundle. For a comprehensive discussion of application bundles, see Apple’s authoritative
    developer documentation on the matter: “Bundle Structures.”^([23](#c04-endnote-23))'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of statically analyzing a malicious application, the two most
    important files are the application’s *Info.plist* file and its main executable.
    As we’ve discussed, when an application is launched, the system consults its *Info.plist*
    property list file if one is present, because it contains important metadata about
    the application stored in key/value pairs. Let’s take a look at a snippet of WindTail’s
    *Info.plist*, highlighting several key/value pairs of particular interest in the
    context of triaging an application ([Listing 4-32](#listing4-32)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-32: An *Info.plist* file (WindTail)'
  prefs: []
  type: TYPE_NORMAL
- en: WindTail’s *Info.plist* file begins with various key/value pairs describing
    the system on which the malware was compiled. For example, the `BuildMachineOSBuild`
    key contains a value of `14B25`, which is the build number of OS X Yosemite (10.10.1).
    Following this, we find the `CFBundleExecutable` key, which specifies to macOS
    which binary to execute when the application is launched. Thus, when WindTail
    is launched, the system will execute the *usrnode* binary from within the *Contents/MacOS*
    directory. This `CFBundleExecutable` key/value pair is generally necessary, as
    the application’s binary may not match the application’s name, or there may be
    several executable files within the *Contents/MacOS* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'From an analysis point of view, the other key/value pairs in the WindTail*Info.plist*
    file are less interesting, save for the `NSUIElement` key. This key, named `LSUIElement`
    on newer versions of macOS, tells the system to hide the application icon in the
    dock if it’s set to 1\. Legitimate applications rarely have this key set. For
    more information about the keys and values in an application’s *Info.plist* file,
    see Apple’s document on the topic: “About Info.plist Keys and Values.”^([24](#c04-endnote-24))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Though you’ll generally find application *Info.plist* files written in plaintext
    XML, so they’re directly readable in the terminal or in a text editor, macOS also
    supports a binary property list (*plist*) format. Siggen is an example of malware
    with a malicious application containing an *Info.plist* file in this binary format
    ([Listing 4-33](#listing4-33)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-33: Using `file` to identify a binary property list (Siggen)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To read this binary file format, use macOS’s `defaults` command with the `read`
    command line flag, as shown in [Listing 4-34](#listing4-34):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-34: Using `defaults` to read a binary property list (Siggen)'
  prefs: []
  type: TYPE_NORMAL
- en: As noted, the `CFBundleExecutable` key in an application’s *Info.plist* contains
    the name of the application’s main executable component. Though Siggen’s application
    is named *WhatsAppService.app*, its *Info.plist* file specifies that a binary
    named *Dropbox* should be executed when that application is launched.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that unless an application has been notarized, the
    other values in a malicious application’s *Info.plist* file may be deceptive.
    For example, Siggen sets its bundle identifier, `CFBundleIdentifier`, to *inc.dropbox.com*
    in an effort to masquerade as legitimate Dropbox software.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve perused the *Info.plist* file, you’ll likely turn your attention
    toward analyzing the binary specified in the `CFBundleExecutable` key. More often
    than not, this binary is a Mach-O, the native executable file format of macOS.
    We’ll discuss this format in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: Up Next
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we introduced the concept of static analysis and highlighted
    how tools such as macOS’s built-in `file` utility and my own WYS, can identify
    a file’s true type. This is an important first analysis step, as many static analysis
    tools are file-type specific. We then examined various nonbinary file types commonly
    encountered while analyzing Mac malware. For each file type, we discussed its
    purpose and highlighted static analysis tools that you can use to analyze the
    file format.
  prefs: []
  type: TYPE_NORMAL
- en: However, this chapter focused only on the analysis of nonbinary file formats,
    such as distribution mediums and scripts. While many Mac malware specimens are
    scripts, the majority are compiled into Mach-O binaries. In the next chapter we’ll
    discuss this binary file format and then explore binary analysis tools and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Endnotes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
