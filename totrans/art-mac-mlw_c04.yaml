- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Nonbinary Analysis
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 非二进制分析
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter focuses on the static analysis of nonbinary file formats, such
    as packages, disk images, and scripts, that you’ll commonly encounter while analyzing
    Mac malware. Packages and disk images are compressed file formats often used to
    deliver malware to a user’s system. When we come across these compressed file
    types, our goal is to extract their contents, including any malicious files. These
    files, for example a malware’s installer, can come in various formats, though
    most commonly as either scripts or compiled binaries (often within an application
    bundle). Because of their plaintext readability, scripts are rather easy to manually
    analyze, though malware authors often attempt to complicate the analysis by applying
    obfuscation techniques. On the other hand, compiled binaries are not readily understandable
    by humans. Analyzing such files requires both an understanding of the macOS binary
    file format as well as the use of specific binary analysis tools. Subsequent chapters
    will cover these topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍对非二进制文件格式的静态分析，例如你在分析 Mac 恶意软件时常遇到的包、磁盘映像和脚本。包和磁盘映像是压缩文件格式，通常用于将恶意软件传递到用户的系统。当我们遇到这些压缩文件类型时，我们的目标是提取它们的内容，包括任何恶意文件。这些文件，例如恶意软件的安装程序，可能有各种格式，但最常见的是脚本或已编译的二进制文件（通常在应用程序包内）。由于脚本是纯文本格式，因此手动分析相对容易，尽管恶意软件作者常常通过混淆技术来增加分析的难度。另一方面，已编译的二进制文件不易为人理解。分析这些文件需要理解
    macOS 二进制文件格式，并使用特定的二进制分析工具。后续章节将涵盖这些内容。
- en: More often than not, the static analysis of a file starts with determining the
    file type. This first step is essential, as the majority of static analysis tools
    are file-type specific. For example, if we identify a file as a package or disk
    image, we’ll then leverage tools capable of extracting components from these compressed
    installation media. On the other hand, if the file turns out to be a compiled
    binary, we must instead use binary-specific analysis tools to assist our analysis
    efforts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析文件时，通常的第一步是确定文件类型。这一步至关重要，因为大多数静态分析工具都是文件类型特定的。例如，如果我们识别一个文件是包或磁盘映像，我们会使用能够从这些压缩安装介质中提取组件的工具。另一方面，如果文件是已编译的二进制文件，我们就必须使用专门的二进制分析工具来帮助我们的分析工作。
- en: Identifying File Types
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别文件类型
- en: As noted, most static analysis tools are file-type specific. Thus, the first
    step in analyzing a potentially malicious file is identifying its file type. If
    a file has an extension, the extension will likely identify the file’s type, and
    this is especially true of extensions used by the operating system to invoke a
    default action. For example, a malicious disk image without the *.dmg* extension
    won’t be automatically mounted if the user double-clicks it, so malware authors
    are unlikely to remove it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，大多数静态分析工具都是文件类型特定的。因此，分析潜在恶意文件的第一步是识别其文件类型。如果文件有扩展名，扩展名通常可以识别文件的类型，尤其是操作系统用来调用默认操作的扩展名。例如，如果恶意磁盘映像没有
    *.dmg* 扩展名，用户双击时它不会被自动挂载，因此恶意软件作者不太可能删除它。
- en: Often, though, malware authors will attempt to mask the true file type of their
    creation in order to trick or coerce the user into running it. It goes without
    saying that looks can be deceiving, and you shouldn’t identify a file’s type solely
    by its appearance (such as its icon) or what appears to be its file extension.
    For example, the WindTail malware is specifically designed to masquerade as a
    benign Microsoft Office document. In reality, the file is a malicious application
    that, when executed, will persistently infect the system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，恶意软件作者常常会试图掩盖其创作的真实文件类型，以欺骗或强迫用户运行它。显而易见，外观可能具有欺骗性，不能仅凭文件的外观（例如图标）或看似的扩展名来识别文件类型。例如，WindTail
    恶意软件专门设计成伪装成无害的 Microsoft Office 文档。实际上，该文件是一个恶意应用程序，当执行时会持续感染系统。
- en: At the other end of the spectrum, malicious files may have no icon or file extension.
    Moreover, a cursory triage of the contents of such files may provide no clues
    about the file’s actual type. For example, [Listing 4-1](#listing4-1) is a suspected
    malicious file, simply named *5mLen*, of some unknown binary format.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，恶意文件可能没有图标或文件扩展名。此外，对这类文件内容的初步筛查可能无法提供任何关于文件实际类型的线索。例如，[列表 4-1](#listing4-1)
    是一个疑似恶意文件，名为 *5mLen*，格式为未知的二进制文件。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: An unknown file type'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：未知文件类型
- en: 'So how can we effectively identify a file’s format? One great option is macOS’s
    built-in `file` command. For example, running the `file` command on the unknown
    *5mLen* file identifies the file’s type as byte-compiled Python code ([Listing
    4-2](#listing4-2)):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何有效地识别一个文件的格式呢？一个很好的选择是 macOS 内置的 `file` 命令。例如，运行 `file` 命令在未知的 *5mLen*
    文件上，可以识别该文件的类型为字节编译的 Python 代码（[示例 4-2](#listing4-2)）：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 4-2: Using `file` to identify a byte-compiled Python script'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-2：使用 `file` 识别字节编译的 Python 脚本
- en: More on this adware soon, but knowing that a file is byte-compiled Python code
    allows us to leverage various tools *specific to this file format*; for example,
    we can reconstruct a readable representation of the original Python code using
    a Python decompiler.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很快会详细介绍这个广告软件，但知道一个文件是字节编译的 Python 代码，能够让我们利用各种*特定于此文件格式*的工具；例如，我们可以使用 Python
    反编译器重构出原始 Python 代码的可读表示。
- en: 'Returning to WindTail, we can again use the `file` utility to reveal that the
    malicious files (which recall, used icons in an attempt to masquerade as harmless
    Office documents), are actually application bundles containing 64-bit Mach-O executables
    ([Listing 4-3](#listing4-3)):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 WindTail，我们再次可以使用 `file` 工具来揭示那些恶意文件（这些文件尝试通过使用图标伪装成无害的 Office 文档），实际上是包含
    64 位 Mach-O 可执行文件的应用程序包（[示例 4-3](#listing4-3)）：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-3: Using `file` to identify a compiled 64-bit Mach-O executable (WindTail)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-3：使用 `file` 识别编译后的 64 位 Mach-O 可执行文件（WindTail）
- en: Note that the `file` utility sometimes doesn’t identify a file’s type in a very
    helpful way. For example, it often misidentifies disk images (*.dmg*), which can
    be compressed, as simply `VAX COFF` files. In this case, other tools such as WhatsYourSign
    may be of more assistance.^([1](#c04-endnote-1))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`file` 工具有时并不能以非常有用的方式识别文件类型。例如，它经常错误地识别磁盘镜像（*.dmg*），即使它们可能是压缩的，也常被误识别为
    `VAX COFF` 文件。在这种情况下，像 WhatsYourSign 这样的工具可能更加有帮助。^([1](#c04-endnote-1))
- en: 'I wrote WhatsYourSign (WYS) as a free, open source tool primarily designed
    to display cryptographic signing information, but it also can identify file types.
    Once you’ve installed WYS, it adds a context menu option to Finder. This allows
    you to ctrl-click any file, then select the **Signing Info** option in the drop-down
    context menu to view its type. For example, WYS can readily identify WindTail’s
    true type: a standard application ([Figure 4-1](#figure4-1)).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了 WhatsYourSign（WYS）作为一款免费、开源的工具，主要设计用来显示加密签名信息，但它也能识别文件类型。安装 WYS 后，它会在 Finder
    中添加一个上下文菜单选项。这样，你就可以 ctrl+点击任何文件，然后在下拉菜单中选择 **签名信息** 选项查看文件的类型。例如，WYS 可以轻松识别 WindTail
    的真实类型：一个标准应用程序（[图 4-1](#figure4-1)）。
- en: '![WhatsYourSign’s Signing Info screen shows WindTail information, including
    “Item Type: Application,” “Hashes: View Hashes” (a clickable link), “Entitled:
    None,” and “Sign Auths: Unavailable, as certificate has been revoked”](image_fi/501942c04/f04001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![WhatsYourSign 的签名信息屏幕显示 WindTail 信息，包括“项目类型：应用程序”，“哈希：查看哈希”（可点击的链接），“授权：无”，“签名授权：不可用，因为证书已被撤销”](image_fi/501942c04/f04001.png)'
- en: 'Figure 4-1: Using WhatsYourSign to identify an application (WindTail)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1：使用 WhatsYourSign 识别应用程序（WindTail）
- en: 'Besides providing a convenient way to determine a file’s type via the macOS
    user interface, WYS can also identify file types that the command line `file`
    tool may struggle with, such as disk images. Take the example in [Listing 4-4](#listing4-4),
    in which we run `file` on a disk image trojanized with EvilQuest:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过 macOS 用户界面提供便捷的方式来确定文件类型，WYS 还能够识别一些命令行工具 `file` 可能识别困难的文件类型，例如磁盘镜像。以[示例
    4-4](#listing4-4)中的例子为例，我们对一个被 EvilQuest 恶意软件感染的磁盘镜像运行 `file` 命令：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 4-4: With disk images, `file` struggles (EvilQuest)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-4：对于磁盘镜像，`file` 无法识别（EvilQuest）
- en: The `file` tool rather unhelpfully responds with `zlib compressed data`. While
    this is technically true (a disk image *is* compressed data), the output from
    WYS is more helpful. As you can see in [Figure 4-2](#figure4-2), it lists the
    item type as “Disk Image.”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 工具的响应并不太有帮助，它只是显示“zlib 压缩数据”。虽然这在技术上是正确的（磁盘镜像确实是压缩数据），但是 WYS 的输出更加有用。如你在[图
    4-2](#figure4-2)中所见，它将项目类型列为“磁盘镜像”。'
- en: '![WhatsYourSign’s Signing Info screen shows Evil Quest information, including
    “Item Type: Disk Image” and “Sign Auths: unsigned (‘errSecCSUnsigned’).”](image_fi/501942c04/f04002.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![WhatsYourSign 的签名信息屏幕显示 Evil Quest 信息，包括“项目类型：磁盘镜像”和“签名授权：未签名（‘errSecCSUnsigned’）”。](image_fi/501942c04/f04002.png)'
- en: 'Figure 4-2: Using WYS to identify a disk image (EvilQuest)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：使用 WYS 识别磁盘镜像（EvilQuest）
- en: Extracting Malicious Files from Distribution Packaging
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从分发包装中提取恶意文件
- en: After identifying an item’s file type, you’ll often continue static analysis
    with the assistance of tools specific to the identified file type. For example,
    if an item turns out to be a disk image or an installer package, you can leverage
    tools designed specifically to extract the files from these distribution mechanisms.
    Let’s take a look at this now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定一个项目的文件类型后，通常会借助专门针对该文件类型的工具继续进行静态分析。例如，如果某个项目是磁盘镜像或安装包，你可以利用专门设计的工具从这些分发机制中提取文件。我们现在来看看这个过程。
- en: Apple Disk Images (.dmg)
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apple 磁盘镜像（.dmg）
- en: Apple Disk Images (*.dmg*) are a popular way to distribute software to Mac users.
    Of course, there is nothing stopping malware authors from leveraging this software
    distribution format too.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Apple 磁盘镜像（*.dmg*）是向 Mac 用户分发软件的一种流行方式。当然，恶意软件作者也可以利用这种软件分发格式。
- en: You can generally identify disk images by their file extension, *.dmg*. Malware
    authors will rarely change this extension because, when the user double-clicks
    any file with a *.dmg* extension, the operating system will automatically mount
    it and display its contents, which is often what malware authors want. Alternatively,
    you can use WYS to identify this file type, as the `file` tool may struggle to
    conclusively identify such disk images.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以通过文件扩展名 *.dmg* 来识别磁盘镜像。恶意软件作者很少会更改这个扩展名，因为当用户双击任何 *.dmg* 扩展名的文件时，操作系统会自动挂载它并显示其内容，这通常是恶意软件作者所希望的。或者，你也可以使用
    WYS 来识别这种文件类型，因为 `file` 工具可能无法明确识别这种磁盘镜像。
- en: 'For analysis purposes, we can manually mount an Apple Disk Image via macOS’s
    built-in `hdiutil` command, which allows us to examine the disk image structure
    and extract the files’ contents, such as a malicious installer or application,
    for analysis. When invoked with the `attach` option, `hdiutil` will mount the
    disk image to the */Volumes* directory. As an example, [Listing 4-5](#listing4-5)
    mounts a trojanized disk image via the command `hdiutil attach`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析过程中，我们可以通过 macOS 内置的 `hdiutil` 命令手动挂载 Apple 磁盘镜像，这样我们就能检查磁盘镜像的结构，并提取文件内容，例如恶意安装程序或应用程序，进行进一步分析。通过
    `attach` 选项调用 `hdiutil` 时，`hdiutil` 会将磁盘镜像挂载到 */Volumes* 目录。例如，清单 4-5 通过命令 `hdiutil
    attach` 挂载一个被特洛伊木马感染的磁盘镜像：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-5: Using `hdiutil` to mount an infected disk image (CreativeUpdate)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-5：使用`hdiutil`挂载感染的磁盘镜像（CreativeUpdate）
- en: Once the disk image has been mounted, `hdiutil` displays the mount directory
    (for example, */Volumes/Firefox*). You can now directly access the files within
    the disk image. Browsing this mounted disk image, either via the terminal (with
    `cd /Volumes/Firefox`) or the user interface, reveals a Firefox application, trojanized
    with the CreativeUpdate malware. For more details on the *.dmg* file format, see
    “Demystifying the DMG File Format.”^([2](#c04-endnote-2))
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦磁盘镜像被挂载，`hdiutil` 会显示挂载目录（例如 */Volumes/Firefox*）。现在，你可以直接访问磁盘镜像中的文件。通过终端（使用
    `cd /Volumes/Firefox`）或用户界面浏览这个挂载的磁盘镜像，能发现一个被 CreativeUpdate 恶意软件感染的 Firefox 应用程序。有关
    *.dmg* 文件格式的更多细节，请参见《解密 DMG 文件格式》^([2](#c04-endnote-2))
- en: Packages (.pkg)
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装包（.pkg）
- en: Another common file format that attackers often abuse to distribute Mac malware
    is the ubiquitous macOS package. Like with a disk image, the output from the `file`
    utility when examining a package may be somewhat confusing. Specifically, it may
    identify the package as a compressed *.xar* archive, the underlying file format
    of packers. From an analysis point of view, it’s far more helpful to know it is
    a package.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种攻击者常常滥用的文件格式是无处不在的 macOS 安装包。与磁盘镜像类似，当使用 `file` 工具分析安装包时，输出可能会有些令人困惑。具体来说，它可能会将安装包识别为压缩的
    *.xar* 存档文件，这是打包工具的底层文件格式。从分析的角度来看，知道它是一个安装包远比知道它是一个 *.xar* 文件更有帮助。
- en: WYS can more accurately identify such files as packages. Moreover, when distributed,
    packages will end with the *.pkg* or *.mpkg* file extensions. These extensions
    ensure that macOS will automatically launch the package when, for example, a user
    double-clicks it. Packages can also be signed, a fact that can provide insight
    during analysis. For example, if a package is signed by a reputable company (such
    as Apple), the package and its contents are likely benign.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: WYS 可以更准确地识别此类文件为安装包。此外，当分发时，安装包通常会以 *.pkg* 或 *.mpkg* 文件扩展名结尾。这些扩展名确保 macOS
    会自动启动该安装包，例如，当用户双击该文件时。安装包也可以进行签名，这一事实可以在分析时提供一些线索。例如，如果一个安装包由知名公司（如 Apple）签名，那么该安装包及其内容很可能是良性的。
- en: As with disk images, you generally won’t be interested in the package per se,
    but rather its contents. Our goal, therefore, is to extract the contents of the
    package for analysis. Since packages are compressed archives, you’ll need a tool
    to decompress and examine or extract the package’s contents. If you are comfortable
    using the terminal, macOS’s built-in `pkgutil` utility can extract the contents
    of a package via the `--expand-full` command line option. Another option is the
    free Suspicious Package application, which, as explained by its documentation,
    lets you open and explore macOS installer packages without having to install them
    first.^([3](#c04-endnote-3)) Specifically, Suspicious Package allows you to examine
    package metadata, such as code-signing information, as well as browse, view, and
    export any files found within the package.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与磁盘映像类似，您通常不会对包本身感兴趣，而是对其内容感兴趣。因此，我们的目标是提取包的内容进行分析。由于包是压缩档案，您需要一个工具来解压并检查或提取包的内容。如果您习惯使用终端，macOS
    内置的 `pkgutil` 工具可以通过 `--expand-full` 命令行选项提取包的内容。另一种选择是免费的 Suspicious Package
    应用程序，正如其文档所解释的那样，它可以让您在不先安装的情况下打开和探索 macOS 安装包。^([3](#c04-endnote-3)) 具体来说，Suspicious
    Package 允许您检查包的元数据，如代码签名信息，还可以浏览、查看和导出包中找到的任何文件。
- en: As an example, let’s use Suspicious Package to explore a package containing
    the CPUMeaner malware ([Figure 4-3](#figure4-3)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们使用 Suspicious Package 来查看一个包含 CPUMeaner 恶意软件的包 ([图 4-3](#figure4-3))。
- en: '![Suspicious Package’s Package Info tab shows information for the CPUMeaner
    malware, mosx3.pkg. The information is as follows: “Installs 2 items—332 KB on
    disk,” “REVOKED: Claims to be signed by ‘Developer ID Installer: Artur Nurgaliev
    (DEWCRD3789),’” “Runs 2 install scripts,” “Downloaded by Safari—today at 9:04
    pm,” and “Found one critical issue for review.”](image_fi/501942c04/f04003.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Suspicious Package 的“包信息”标签显示了 CPUMeaner 恶意软件 mosx3.pkg 的信息。信息如下：“安装 2 项——占用
    332 KB 磁盘空间”，“已吊销：声称由‘开发者 ID 安装程序：Artur Nurgaliev (DEWCRD3789)’签名”，“运行 2 个安装脚本”，“通过
    Safari 下载——今天晚上 9:04”，以及“发现一个需要审核的关键问题。”](image_fi/501942c04/f04003.png)'
- en: 'Figure 4-3: Using Suspicious Package to examine a package (CPUMeaner)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3：使用 Suspicious Package 检查包（CPUMeaner）
- en: 'Suspicious Package’s Package Info tab provides general information about the
    package, including:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Suspicious Package 的“包信息”标签提供了有关该包的一般信息，包括：
- en: That it installs two items
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它安装了两个项目
- en: That its certificate has been revoked by Apple (a critical issue and large red
    flag, likely indicating it contains malicious code)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其证书已被 Apple 吊销（这是一个关键问题和一个巨大的警告标志，可能表示它包含恶意代码）
- en: That it runs two install scripts
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它运行两个安装脚本
- en: The All Files tab ([Figure 4-4](#figure4-4)) reveals the directories and files
    the package would install if it ran. Plus, this tab allows us to export any of
    these items.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: “所有文件”标签 ([图 4-4](#figure4-4)) 显示了如果该包运行时将安装的目录和文件。此外，该标签还允许我们导出这些项目中的任何一个。
- en: '![Suspicious Package’s All Files tab shows the files CPUMeaner’s mosx3.pkg
    would install: Library▶Application Support▶CpuCooler▶cpucooler. The CpuCooler
    folder contains the executable cpucooler, which can be exported.](image_fi/501942c04/f04004.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Suspicious Package 的“所有文件”标签显示了 CPUMeaner 的 mosx3.pkg 会安装的文件：Library▶Application
    Support▶CpuCooler▶cpucooler。CpuCooler 文件夹包含可执行文件 cpucooler，可以导出。](image_fi/501942c04/f04004.png)'
- en: 'Figure 4-4: Using Suspicious Package to export a file (CPUMeaner)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-4：使用 Suspicious Package 导出文件（CPUMeaner）
- en: Packages often contain pre- and post-install bash scripts that may contain additional
    logic required to complete the installation. As these files are automatically
    executed during installation, you should always check for and examine these files
    when analyzing a potentially malicious package! Malware authors are quite fond
    of abusing these scripts to perform malicious actions, such as persistently installing
    their code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 包通常包含安装前和安装后的 bash 脚本，这些脚本可能包含完成安装所需的额外逻辑。由于这些文件在安装过程中会自动执行，因此在分析潜在恶意包时，您应该始终检查并检查这些文件！恶意软件作者非常喜欢滥用这些脚本来执行恶意操作，例如持续安装他们的代码。
- en: Indeed, clicking the All Scripts tab reveals a malicious post-install script
    ([Figure 4-5](#figure4-5)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，点击“所有脚本”标签显示了一个恶意的安装后脚本 ([图 4-5](#figure4-5))。
- en: As you can see, CPUMeaner’s post-install script contains an embedded launch
    agent property list and commands to configure and write to the file */Library/LaunchAgents/com.osxext.cpucooler.plist*.
    Once this property list has been installed, the malware’s binary, */Library/Application
    Support/CpuCooler/cpucooler*, will be automatically started each time the user
    logs in.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，CPUMeaner 的安装后脚本包含一个嵌入的启动代理属性列表，并包含配置和写入文件 */Library/LaunchAgents/com.osxext.cpucooler.plist*
    的命令。一旦这个属性列表被安装，恶意软件的二进制文件（*/Library/Application Support/CpuCooler/cpucooler*）将在每次用户登录时自动启动。
- en: '![Suspicious Package’s All Scripts tab contains CPUMeaner’s post-install script.
    The script includes the identifier (com.osxext.cpucooler), install location, launch
    agent property list (/Library/LaunchAgents/$IDENTIFIER.plist), and commands to
    write to the identifier file.](image_fi/501942c04/f04005.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Suspicious Package 的“所有脚本”标签包含 CPUMeaner 的安装后脚本。脚本包括标识符（com.osxext.cpucooler）、安装位置、启动代理属性列表（/Library/LaunchAgents/$IDENTIFIER.plist）以及写入标识符文件的命令。](image_fi/501942c04/f04005.png)'
- en: 'Figure 4-5: Using Suspicious Package to examine a post-install script (CPUMeaner)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：使用 Suspicious Package 检查安装后脚本（CPUMeaner）
- en: 'In a write-up titled “Pass the AppleJeus,” I highlighted another example of
    a malicious package, this time belonging to the Lazarus Group.^([4](#c04-endnote-4))
    As the malicious package is contained within an Apple disk image, the *.dmg* must
    first be mounted. As shown in [Listing 4-6](#listing4-6), we first mount the malicious
    disk image, *JMTTrader_Mac.dmg*. Once it’s mounted to */Volumes/JMTTrader/*, we
    can list its files. We observe it contains a single package, *JMTTrader.pkg*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在一篇名为“Pass the AppleJeus”的文章中，我指出了另一个恶意包的例子，这次属于 Lazarus 组织。^([4](#c04-endnote-4))
    由于该恶意包被包含在一个 Apple 磁盘映像中，必须先挂载 *.dmg* 文件。如 [列表 4-6](#listing4-6) 所示，我们首先挂载恶意磁盘映像
    *JMTTrader_Mac.dmg*。一旦它被挂载到 */Volumes/JMTTrader/*，我们就可以列出它的文件。我们观察到它包含一个包，*JMTTrader.pkg*：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-6: Listing a disk image’s files (AppleJeus)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-6：列出磁盘映像中的文件（AppleJeus）
- en: Once the disk image has been mounted, we can access and examine the malicious
    package (*JMTTrader.pkg*), again via Suspicious Package ([Figure 4-6](#figure4-6)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦磁盘映像被挂载，我们可以通过 Suspicious Package 访问并检查恶意包（*JMTTrader.pkg*），如 [图 4-6](#figure4-6)
    所示。
- en: '![Suspicious Package’s Package Info tab contains information for JMTTrader.pkg
    as follows: “Installer Package,” “Installs 132 items—31.8 MB on disk,” “Not signed,”
    “Runs 1 install script.”](image_fi/501942c04/f04006.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Suspicious Package 的“包信息”标签包含 JMTTrader.pkg 的信息，如下所示：“安装包”，“安装 132 个项目—磁盘上占用
    31.8 MB”，“未签名”，“运行 1 个安装脚本。”](image_fi/501942c04/f04006.png)'
- en: 'Figure 4-6: Using Suspicious Package to examine a package (AppleJeus)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6：使用 Suspicious Package 检查包（AppleJeus）
- en: 'The package is unsigned (which is rather unusual) and contains the following
    post-install script containing the malware’s installation logic ([Listing 4-7](#listing4-7)):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该包未签名（这相当不寻常），并包含以下安装后脚本，其中包含恶意软件的安装逻辑（[列表 4-7](#listing4-7)）：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-7: A post-install script, containing installer logic (AppleJeus)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-7：一个包含安装逻辑的安装后脚本（AppleJeus）
- en: Examining this post-install script reveals it will persistently install the
    malware (*CrashReporter*) as a launch daemon (*org.jmttrading.plist*).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这个安装后脚本会发现它会持久性地安装恶意软件（*CrashReporter*）作为启动守护进程（*org.jmttrading.plist*）。
- en: Analyzing Scripts
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本分析
- en: Once you’ve extracted the malware from its distribution packaging (whether a
    *.dmg*, *.pkg*, *.zip*, or some other format), it’s time to analyze the actual
    malware specimen. Generally, such malware is either a script (like a shell script,
    a Python script, or an AppleScript) or a compiled Mach-O binary. Due to their
    readability, scripts are often rather trivial to analyze and may require no special
    analysis tools, so we’ll start there.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你从其分发包中提取了恶意软件（无论是 *.dmg*、*.pkg*、*.zip* 还是其他格式），接下来就可以分析实际的恶意软件样本。通常，这类恶意软件要么是脚本（如
    shell 脚本、Python 脚本或 AppleScript），要么是编译过的 Mach-O 二进制文件。由于脚本的可读性，通常比较容易分析，而且可能不需要特殊的分析工具，所以我们从这里开始。
- en: Bash Shell Scripts
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bash Shell 脚本
- en: You’ll find various Mac malware specimens written in shell scripting languages.
    Unless the shell script code has been obfuscated, it’s easy to understand. For
    example, in Chapter 3 we took a look at a bash script that the Dummy malware persists
    as a launch daemon. Recall the script simply executed a handful of Python commands
    in order to launch an interactive remote shell.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现各种使用 shell 脚本语言编写的 Mac 恶意软件样本。除非 shell 脚本代码经过混淆，否则它们很容易理解。例如，在第 3 章中，我们查看了一个
    bash 脚本，Dummy 恶意软件将其作为启动守护进程持久化。回忆一下，这个脚本只是执行了一些 Python 命令，以启动一个交互式远程 Shell。
- en: We find a slightly more complex example of a malicious bash script in Siggen.^([5](#c04-endnote-5))
    Siggen is distributed as a ZIP file containing a malicious, script-based application,
    *WhatsAppService.app*. The application was created via the popular developer tool
    Platypus, which packages up a script into a native macOS application.^([6](#c04-endnote-6))
    When a “platypussed” application is run, it executes a script aptly named *script*
    from the application’s *Resources/* directory ([Figure 4-7](#figure4-7)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Siggen 中发现了一个稍微复杂一些的恶意 bash 脚本示例。^([5](#c04-endnote-5)) Siggen 被作为一个 ZIP
    文件分发，其中包含了一个恶意的基于脚本的应用程序，*WhatsAppService.app*。这个应用程序是通过流行的开发者工具 Platypus 创建的，Platypus
    会将一个脚本打包成一个原生的 macOS 应用程序。^([6](#c04-endnote-6)) 当运行一个“platypussed”应用程序时，它会执行名为
    *script* 的脚本，该脚本位于应用程序的 *Resources/* 目录中（[图 4-7](#figure4-7)）。
- en: '![WhatsAppService’s Contents folder includes two folders, Resources and MacOS.
    The Resources folder contains a script named script, a PDF named Applcon.icns,
    MainMenu.nib, and AppSettings.plist](image_fi/501942c04/f04007.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![WhatsAppService 的 Contents 文件夹包括两个文件夹，Resources 和 MacOS。Resources 文件夹包含一个名为
    script 的脚本，一个名为 Applcon.icns 的 PDF，一个名为 MainMenu.nib 的文件，以及一个名为 AppSettings.plist
    的文件](image_fi/501942c04/f04007.png)'
- en: 'Figure 4-7: A script-based payload (Siggen)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-7：基于脚本的有效载荷（Siggen）
- en: 'Let’s take a look at this shell script to see what we can learn from it ([Listing
    4-8](#listing4-8)):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个 shell 脚本，看看我们能从中学到什么（[清单 4-8](#listing4-8)）：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-8: A malicious bash script (Siggen)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-8：一个恶意的 bash 脚本（Siggen）
- en: You might notice that various parts of the script are obfuscated, such as the
    long gibberish section 1. We can identify the obfuscation scheme as base64, since
    the script pipes the obfuscated strings to macOS’s `base64` command (along with
    the decode flag, `-D`) 2. Using the same `base64` command, we can manually decode
    and thus fully deobfuscate the script.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到脚本的各个部分是经过模糊化的，比如第一段长长的乱码。我们可以识别出模糊化方案是 base64，因为脚本将模糊化字符串通过管道传递给 macOS
    的 `base64` 命令（并使用解码标志 `-D`）2。使用相同的 `base64` 命令，我们可以手动解码，从而完全去除脚本的模糊化。
- en: Once these encoded script snippets are decoded, it is easy to comprehensively
    understand the script. The first line, `echo c2NyZ...Wwn | base64 -D | sh`, decodes
    and executes `screen -dm bash -c 'sleep 5;killall Terminal'`, which effectively
    kills any running instances of *Terminal.app*, likely as a basic anti-analysis
    technique. Then, via `curl`, the malware downloads and persists a launch agent
    named *a.plist.* Next, it decodes and executes another obfuscated command. The
    deobfuscated command, `chmod +x ~/Library/LaunchAgents/a.plist`, unnecessarily
    sets the launch agent property list to be executable. This property list is then
    loaded via the `launchctl load` command. The malware then downloads another file,
    another script named *c.sh*. Decoding the final two lines reveals that the malware
    first sets this script to be executable, and then executes it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些编码的脚本片段被解码，就容易全面理解脚本。第一行，`echo c2NyZ...Wwn | base64 -D | sh`，解码并执行 `screen
    -dm bash -c 'sleep 5;killall Terminal'`，它有效地终止任何正在运行的 *Terminal.app* 实例，这很可能是作为一种基本的反分析技巧。接着，通过
    `curl`，恶意软件下载并保持一个名为 *a.plist* 的启动代理。接下来，它解码并执行另一个模糊化的命令。解码后的命令，`chmod +x ~/Library/LaunchAgents/a.plist`，不必要地将启动代理的属性列表设置为可执行。然后，通过
    `launchctl load` 命令加载这个属性列表。恶意软件接着下载另一个文件，即另一个名为 *c.sh* 的脚本。解码最后两行后可以发现，恶意软件首先将该脚本设置为可执行，然后执行它。
- en: And what does the */Users/Shared/c.sh* script do? Let’s take a peek ([Listing
    4-9](#listing4-9)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 */Users/Shared/c.sh* 脚本做了什么呢？让我们来看看（[清单 4-9](#listing4-9)）。
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 4-9: Another malicious bash script (Siggen)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-9：另一个恶意的 bash 脚本（Siggen）
- en: After connecting to *usb.mine.nu/p.php*, it checks for a response containing
    the string `'open'`. Following this, the script checks if a launch service named
    `HEYgiNb` is running. At that point, it decodes a large blob of base64-encoded
    data and executes it via Python. Let’s now discuss how to statically analyze such
    Python scripts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接到 *usb.mine.nu/p.php* 后，它会检查响应中是否包含字符串 `'open'`。之后，脚本检查是否有名为 `HEYgiNb` 的启动服务正在运行。此时，它解码一大段
    base64 编码的数据，并通过 Python 执行它。接下来我们来讨论如何静态分析这样的 Python 脚本。
- en: Python Scripts
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 脚本
- en: Anecdotally speaking, Python seems to be the preferred scripting language for
    Mac malware authors, as it is quite powerful, versatile, and natively supported
    by macOS. Though these scripts often leverage basic encoding and obfuscation techniques
    aimed at complicating analysis, analyzing malicious Python scripts is still a
    fairly straightforward endeavor. The general approach is to first decode or deobfuscate
    the Python script, then read through the decoded code. Though various online sites
    can help you analyze obfuscated Python scripts, a manual approach works too. Here
    we’ll discuss both.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 轶事性地说，Python 似乎是 Mac 恶意软件作者的首选脚本语言，因为它非常强大、灵活，并且 macOS 原生支持。尽管这些脚本通常利用基本的编码和混淆技术来使分析变得复杂，但分析恶意
    Python 脚本仍然是一项相对直接的任务。一般的做法是首先解码或去混淆 Python 脚本，然后阅读解码后的代码。尽管各种在线网站可以帮助分析混淆的 Python
    脚本，但手动分析的方法也同样有效。接下来我们将讨论两种方法。
- en: 'Let’s first consider [Listing 4-10](#listing4-10), an unobfuscated example:
    Dummy’s small Python payload (found wrapped in a bash script).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑 [清单 4-10](#listing4-10)，一个未混淆的示例：虚拟脚本的小型 Python 载荷（包含在一个 bash 脚本中）。
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-10: A malicious Python script (Dummy)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-10：一个恶意的 Python 脚本（虚拟脚本）
- en: As this code isn’t obfuscated, understanding the malware’s logic is straightforward.
    It begins by importing various standard Python modules, such as `socket`, `subprocess`,
    and `os` 1. It then makes a socket and connection to `185.243.115.230` on port
    `1337` 2. The file handles for `STDIN` (`0`), `STDOUT` (`1`), and `STDERR` (`2`)
    are then duplicated, 3 redirecting them to the socket.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码没有被混淆，理解恶意软件的逻辑是很直接的。它首先导入了多个标准的 Python 模块，如 `socket`、`subprocess` 和 `os`
    1。接着，它创建了一个套接字，并连接到 `185.243.115.230` 的 `1337` 端口 2。然后，它将 `STDIN`（`0`）、`STDOUT`（`1`）和
    `STDERR`（`2`）的文件句柄复制， 3 将它们重定向到套接字。
- en: The script then executes the shell, */bin/sh*, interactively via the `-i` flag
    4. As the file handles for `STDIN`, `STDOUT`, and `STDERR` have been duplicated
    to the connected socket, any remote commands entered by the attacker will be executed
    locally on the infected system, and any output will be sent back through the socket.
    In other words, the Python code implements a simple, interactive remote shell.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本接着通过 `-i` 标志 4 以交互模式执行 shell，*/bin/sh*。由于 `STDIN`、`STDOUT` 和 `STDERR` 的文件句柄已经被复制到连接的套接字，攻击者输入的任何远程命令都将在受感染的系统上本地执行，任何输出也会通过套接字发送回来。换句话说，这段
    Python 代码实现了一个简单的交互式远程 shell。
- en: 'Another piece of macOS malware that is at least partially written in Python
    is Siggen. As discussed in the previous section, Siggen contains a bash script
    that decodes a large chunk of base64-encoded data and executes it via Python.
    [Listing 4-11](#listing4-11) shows the decoded Python code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种至少部分用 Python 编写的 macOS 恶意软件是 Siggen。如前一部分所述，Siggen 包含一个 bash 脚本，用于解码大量 base64
    编码的数据，并通过 Python 执行它。[清单 4-11](#listing4-11) 显示了解码后的 Python 代码：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4-11: A decoded Python payload (Siggen)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-11：解码后的 Python 载荷（Siggen）
- en: Following the imports of a few modules, the script defines a function called
    `get_uid`. This subroutine generates a unique identifier based on the user and
    MAC address of the infected system. The script then builds a dictionary to hold
    HTTP headers for use in a subsequent HTTP request 1. The embedded, hardcoded base64-encoded
    data `-eyJ0eXBlIj...ifX0=` 2 decodes to a JSON dictionary ([Listing 4-12](#listing4-12)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入了几个模块后，脚本定义了一个名为 `get_uid` 的函数。这个子程序根据受感染系统的用户和 MAC 地址生成一个唯一标识符。接着，脚本构建了一个字典，用于保存
    HTTP 请求头，以便在随后的 HTTP 请求中使用 1。内嵌的、硬编码的 base64 编码数据 `-eyJ0eXBlIj...ifX0=` 2 解码成一个
    JSON 字典（[清单 4-12](#listing4-12)）。
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-12: Decoded configuration data (Siggen)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-12：解码后的配置数据（Siggen）
- en: The script then makes a request to the attacker’s server at *http://zr.webhop.org*
    on port `1337` via the `urllib2.urlopen` method 3. It expects the server to respond
    with a 404 HTTP code, which normally means the requested resource was not found.
    However, examining the script reveals that the malware expects this response to
    contain base64-encoded data, which it extracts, decodes, and then executes 4.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本随后通过 `urllib2.urlopen` 方法 3 向攻击者的服务器 *http://zr.webhop.org* 发送请求，端口为 `1337`。它期待服务器返回一个
    404 HTTP 状态码，通常意味着请求的资源未找到。然而，检查脚本后可以发现，恶意软件期望该响应包含 base64 编码的数据，它会提取并解码这些数据，然后执行
    4。
- en: Unfortunately, the *http://zr.webhop.org* server was no longer serving up this
    final-stage payload at the time of my analysis in early 2019\. However, Phil Stokes,
    a well-known Mac security researcher, noted that the script “leverages a public
    post-exploitation kit, *Evil.OSX*, to install a backdoor.”^([7](#c04-endnote-7))
    And, of course, the attackers could swap out the remote Python payload anytime
    to execute whatever they wanted on the infected systems!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在我 2019 年初进行分析时，*http://zr.webhop.org* 服务器已经不再提供该最终阶段的有效载荷。然而，知名的 Mac 安全研究员
    Phil Stokes 提到该脚本“利用了一个公共的后期利用工具包，*Evil.OSX*，来安装后门。”^([7](#c04-endnote-7)) 当然，攻击者随时可以替换远程的
    Python 有效载荷，以在被感染的系统上执行任何他们想要的操作！
- en: As a final example, let’s return to the adware file named *5mLen*. We discussed
    it earlier in this chapter when we ran the `file` tool to determine it was compiled
    Python code. As Python is an interpreted language, programs written in this language
    are usually distributed as human-readable scripts. However, these scripts can
    also be compiled and distributed as Python bytecode, a binary file format. In
    order to statically analyze the file, you must first decompile the Python bytecode
    back to a representation of the original Python code. An online resource, such
    as Decompiler, can perform this decompilation for you.^([8](#c04-endnote-8)) Another
    option is to install the uncomplye6 Python package to locally decompile the Python
    bytecode.^([9](#c04-endnote-9))
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，让我们回到名为 *5mLen* 的广告软件文件。在本章前面我们已经讨论过，当时我们使用 `file` 工具确定它是一个编译后的 Python
    代码。由于 Python 是一种解释型语言，用这种语言编写的程序通常会以可读的脚本形式分发。然而，这些脚本也可以被编译并以 Python 字节码的二进制文件格式分发。为了静态分析该文件，你必须首先将
    Python 字节码反编译回原始 Python 代码的表示。一个在线资源，比如 Decompiler，可以帮助你完成这一反编译工作。^([8](#c04-endnote-8))
    另一种选择是安装 uncompyle6 Python 包来本地反编译 Python 字节码。^([9](#c04-endnote-9))
- en: '[Listing 4-13](#listing4-13) shows the decompiled Python code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-13](#listing4-13) 显示了反编译后的 Python 代码：'
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 4-13: Decompiled Python code (unspecified adware)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-13：反编译的 Python 代码（未指定的广告软件）
- en: Though we now have Python source code, the majority of the code is still obfuscated
    in what appears to be an encoded string 1. From the API calls `zlib.decompress`
    and `base64.b64decode`, we can conclude that the original source code has been
    base64-encoded and zlib-compressed in order to (slightly) complicate static analysis.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在我们得到了 Python 源代码，但大部分代码仍然以看似编码字符串的形式混淆。通过 `zlib.decompress` 和 `base64.b64decode`
    的 API 调用，我们可以得出结论，原始源代码已被 base64 编码并使用 zlib 压缩，以稍微增加静态分析的难度。
- en: 'The easiest way to deobfuscate the code is via the Python shell interpreter.
    We can convert the `exec` statement to a `print` statement, then have the interpreter
    fully deobfuscate the code for us ([Listing 4-14](#listing4-14)):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 去混淆代码最简单的方法是通过 Python Shell 解释器。我们可以将 `exec` 语句转换为 `print` 语句，然后让解释器为我们完全去混淆代码（[列表
    4-14](#listing4-14)）：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 4-14: Deobfuscated Python code (unspecified adware)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-14：去混淆后的 Python 代码（未指定的广告软件）
- en: With the fully deobfuscated Python code in hand, we can continue our analysis
    by reading the script to figure out what it does. In the `wvn` class’s `__init__`
    method, we see references to various variables of interest 1. Based on their names
    (and continued analysis) we conclude such variables contain the name of a base64-encoded
    file (*ij1.b64*), an XOR encryption key (`1bm5pbmcKc`), and an “injection” URL
    (*https://1049434604.rsc.cdn77.org/ij1.min.js*). The latter, as you’ll see, gets
    locally injected into user webpages in order to load malicious JavaScript. In
    the `wvR` method, the code checks if the script was invoked with the `f=` command
    line option 2. If so, it sets the `B64_ENC_FILE` variable to the specified file
    3. On an infected system, the script was persistently invoked with `python 5mLen
    f=6bLJC`, meaning the `B64_ENC_FILE` will be set to `6bLJC`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到完整的去混淆 Python 代码后，我们可以通过阅读脚本来继续分析，弄清楚它的功能。在 `wvn` 类的 `__init__` 方法中，我们看到涉及多个感兴趣变量的引用1。根据它们的名称（以及进一步的分析），我们推断这些变量包含了一个
    base64 编码文件的名称（*ij1.b64*）、一个 XOR 加密密钥（`1bm5pbmcKc`），以及一个“注入”URL（*https://1049434604.rsc.cdn77.org/ij1.min.js*）。如你所见，后者会被本地注入到用户网页中，用来加载恶意的
    JavaScript。在 `wvR` 方法中，代码检查脚本是否通过 `f=` 命令行选项被调用2。如果是，它会将 `B64_ENC_FILE` 变量设置为指定的文件3。在被感染的系统上，脚本会持续通过
    `python 5mLen f=6bLJC` 命令被调用，这意味着 `B64_ENC_FILE` 会被设置为 `6bLJC`。
- en: Taking a peek at the `6bLJC` file reveals it is encoded, or possibly encrypted.
    Though we might be able to manually decode it (as we have an `XOR` key, `1bm5pbmcKc`),
    there is a simpler way. Again, by inserting a `print` statement immediately after
    the logic that decodes the contents of the file, we can coerce the malware to
    output the decoded contents. This output turns out to be yet another script that
    the malware executes. However, this script is not Python, but rather AppleScript,
    which we’ll explore in the next section. For a more detailed walkthrough of the
    static analysis of this malware, see my write-up “Mac Adware, à la Python.”^([10](#c04-endnote-10))
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `6bLJC` 文件会发现它被编码，或者可能被加密。虽然我们可能能够手动解码它（因为我们有 `XOR` 密钥 `1bm5pbmcKc`），但还有一种更简单的方法。同样，通过在解码文件内容的逻辑后立即插入
    `print` 语句，我们可以强制恶意软件输出解码后的内容。这个输出结果竟然是另一个恶意软件执行的脚本。然而，这个脚本不是 Python，而是 AppleScript，接下来我们将深入探讨它。关于该恶意软件静态分析的更详细步骤，请参见我的文章《Mac
    广告软件，类 Python》。^([10](#c04-endnote-10))
- en: AppleScript
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AppleScript
- en: 'AppleScript is a macOS-specific scripting language generally used for benign
    purposes, and often for system administration, such as task automation or to interact
    with other applications on the system. By design, its grammar is rather close
    to spoken English. For example, to display a dialog with an alert ([Listing 4-15](#listing4-15)),
    you can simply write:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: AppleScript 是一种特定于 macOS 的脚本语言，通常用于无害目的，且经常用于系统管理，例如任务自动化或与系统中其他应用程序进行交互。其语法设计上与口语英语非常接近。例如，要显示一个带有警报的对话框（[Listing
    4-15](#listing4-15)），你可以简单地写：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 4-15: “Hello, World!” in AppleScript'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-15: 在 AppleScript 中的“Hello, World！”'
- en: 'You can execute these scripts via the `/usr/bin/osascript` command. AppleScripts
    can be distributed in their raw, human-readable form or compiled. The former case
    uses the *.applescript* extension, while the latter normally uses a *.scpt* extension,
    as shown in [Listing 4-16](#listing4-16):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `/usr/bin/osascript` 命令执行这些脚本。AppleScript 可以以其原始的、可读的人类形式或编译后的形式分发。前者使用
    *.applescript* 扩展名，而后者通常使用 *.scpt* 扩展名，如 [Listing 4-16](#listing4-16) 所示：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 4-16: Using `file` to identify compiled AppleScript'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-16: 使用 `file` 来识别编译过的 AppleScript'
- en: And unless the script has been compiled with the “run-only” option (more on
    this later), Apple’s Script Editor can reconstruct the source code from compiled
    scripts. For example, [Figure 4-8](#figure4-8) shows the Script Editor successfully
    decompiling our compiled “Hello, World!” script.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除非脚本是使用“仅运行”选项编译的（稍后将详细说明），否则 Apple 的脚本编辑器可以从编译后的脚本中重建源代码。例如，[Figure 4-8](#figure4-8)
    显示了脚本编辑器成功地反编译了我们编译过的“Hello, World！”脚本。
- en: '![AppleScript has decompiled the script HELLOWORLD.SCPT, shown by “display
    dialog: ‘Hello World!’”](image_fi/501942c04/f04008_new.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![AppleScript 已经反编译了脚本 HELLOWORLD.SCPT，显示为“display dialog: ‘Hello World!’”](image_fi/501942c04/f04008_new.png)'
- en: 'Figure 4-8: Apple’s Script Editor'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4-8: 苹果的脚本编辑器'
- en: 'You can also decompile scripts via macOS’s built-in `osadecompile` command
    ([Listing 4-17](#listing4-17)):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 macOS 内置的 `osadecompile` 命令反编译脚本（[Listing 4-17](#listing4-17)）：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 4-17: “Hello, World!” via AppleScript'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-17: 通过 AppleScript 显示“Hello, World！”'
- en: 'Let’s start by discussing an easy example. Earlier in this chapter, we discussed
    a Python-compiled adware specimen and noted that it contained an AppleScript component.
    The Python code decrypts this AppleScript stored in the `wvd.PLAIN_TEXT_SCRIPT`
    variable and then executes it via a call to the `osascript` command. [Listing
    4-18](#listing4-18) shows the AppleScript:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的示例开始。之前在本章中，我们讨论了一个用 Python 编译的广告软件样本，并指出它包含一个 AppleScript 组件。Python
    代码解密存储在 `wvd.PLAIN_TEXT_SCRIPT` 变量中的 AppleScript，然后通过调用 `osascript` 命令执行它。[Listing
    4-18](#listing4-18) 显示了这个 AppleScript：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 4-18: Malicious AppleScript (unspecified adware)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-18: 恶意 AppleScript（未指定的广告软件）'
- en: 'In short, this AppleScript invokes an `is_Chrome_running` function to check
    if Google Chrome is running by asking the operating system if the process list
    contains `"Google Chrome"` 4. If it does, the script grabs the HTML code of the
    page in the active tab, and checks for an injection marker: `493024ui5o` 1. If
    this marker is not found, the script injects and executes two pieces of JavaScript
    2. From our analysis, we can ascertain that the ultimate goal of this AppleScript-injected-JavaScript
    is to load and execute another malicious JavaScript file, *ij1.min.js*, from *https://1049434604.rsc.cdn77.org/*
    in the user’s browser 3. Unfortunately, as this URL was offline at the time of
    analysis, we cannot know exactly what the script would do, although malware like
    this typically injects ads or pop-ups in a user’s browser session in order to
    generate revenue for its authors. Of course, injected JavaScript could easily
    perform more nefarious actions, such as capturing passwords or piggybacking on
    authenticated user sessions.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这段AppleScript调用了一个`is_Chrome_running`函数，通过向操作系统询问进程列表中是否包含“Google Chrome”来检查Google
    Chrome是否正在运行。如果是，脚本会获取当前标签页的HTML代码，并检查是否存在注入标记：`493024ui5o`。如果没有找到这个标记，脚本就会注入并执行两段JavaScript代码。通过我们的分析，可以确定这段AppleScript注入的JavaScript的最终目标是从*https://1049434604.rsc.cdn77.org/*加载并执行另一个恶意的JavaScript文件*ij1.min.js*，在用户的浏览器中运行。不幸的是，由于在分析时该URL已下线，我们无法确切知道该脚本会做什么，尽管像这样的恶意软件通常会在用户的浏览器会话中注入广告或弹窗，以便为其作者创造收入。当然，注入的JavaScript也可能执行更恶意的操作，比如捕获密码或借助已认证用户的会话进行攻击。
- en: A rather archaic example of Mac malware that abused AppleScript is DevilRobber.^([11](#c04-endnote-11))
    Though this malware focused primarily on stealing Bitcoins and mining cryptocurrencies,
    it also targeted the user’s keychain in order to extract accounts, passwords,
    and other sensitive information. In order to access the keychain, DevilRobber
    had to bypass the keychain access prompt, and it did so via AppleScript.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当古老的Mac恶意软件示例是利用AppleScript的DevilRobber。^([11](#c04-endnote-11))虽然这个恶意软件主要集中在窃取比特币和挖掘加密货币，但它也瞄准了用户的钥匙串，试图提取账户、密码和其他敏感信息。为了访问钥匙串，DevilRobber必须绕过钥匙串访问提示，它通过AppleScript实现了这一点。
- en: Specifically, DevilRobber executed a malicious AppleScript file named *kcd.scpt*
    via macOS’s built-in `osascript` utility. This script sent a synthetic mouse click
    event to the Always Allow button of the keychain access prompt, allowing the malware
    to access the contents of the keychain ([Figure 4-9](#figure4-9)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言，DevilRobber通过macOS内置的`osascript`工具执行了一个名为*kcd.scpt*的恶意AppleScript文件。这个脚本发送了一个合成鼠标点击事件到钥匙串访问提示的“始终允许”按钮，从而允许恶意软件访问钥匙串中的内容（[图4-9](#figure4-9)）。
- en: '![DevilRobber’s synthetic mouse click event shows a pop-up window that states,
    “security wants to access key ‘ids: identity-rsa-private-key’ in your keychain.
    Do you want to allow access to this item?” and has three clickable options: Always
    Allow, Deny, and Allow. ](image_fi/501942c04/f04009_new.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![DevilRobber的合成鼠标点击事件显示了一个弹出窗口，上面写着“安全性要求访问你钥匙串中的密钥‘ids: identity-rsa-private-key’。你是否允许访问此项？”并有三个可点击选项：始终允许、拒绝和允许。](image_fi/501942c04/f04009_new.png)'
- en: 'Figure 4-9: Synthetic click via AppleScript (DevilRobber)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-9：通过AppleScript（DevilRobber）进行的合成鼠标点击
- en: 'The AppleScript used to perform this synthetic mouse click is straightforward;
    it simply tells the `SecurityAgent` process, which owns the keychain access window,
    to click the Always Allow button ([Listing 4-19](#listing4-19)):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 用于执行这个合成鼠标点击的AppleScript非常简单；它只是告诉`SecurityAgent`进程（该进程拥有钥匙串访问窗口）点击“始终允许”按钮（[Listing
    4-19](#listing4-19)）：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 4-19: Synthetic click via AppleScript (DevilRobber)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-19：通过AppleScript（DevilRobber）进行的合成鼠标点击
- en: The readability of the AppleScript grammar, coupled with the ability of Apple’s
    Script Editor to parse and often decompile such scripts, makes analysis of malicious
    AppleScripts quite simple. From an attacker’s point of view, the extreme readability
    of AppleScript is a rather large negative, as it means malware analysts can easily
    understand any malicious script. As noted earlier, though, attackers can export
    AppleScripts as run-only ([Figure 4-10](#figure4-10)). Unfortunately, the Script
    Editor cannot decompile AppleScripts exported via the run-only option, (or via
    the `osacompile` command with the `-x` option), complicating certain analyses.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: AppleScript 语法的可读性，再加上 Apple 的脚本编辑器解析并常常能反编译此类脚本的能力，使得恶意 AppleScript 的分析变得相当简单。从攻击者的角度来看，AppleScript
    极高的可读性是一个相当大的负面因素，因为这意味着恶意软件分析师可以轻松理解任何恶意脚本。如前所述，攻击者可以将 AppleScript 导出为仅运行模式（[图
    4-10](#figure4-10)）。不幸的是，脚本编辑器无法反编译通过仅运行选项导出的 AppleScript（或通过 `osacompile` 命令与
    `-x` 选项），这使得某些分析变得复杂。
- en: '![The helloWorld.scpt can be exported as run-only through AppleScripts. AppleScript’s
    exporting screen shows helloWorld.scpt renamed to be exported as helloWorld_RO.scpt,
    with the file format set as “Script.” Of the options “Show startup screen,” “Stay
    open after run handler,” and “Run-only,” only the latter is selected. Under Code
    Sign, “Don’t Code Sign” is selected.](image_fi/501942c04/f04010.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![helloWorld.scpt 可以通过 AppleScripts 以仅运行模式导出。AppleScript 的导出屏幕显示 helloWorld.scpt
    被重命名为 helloWorld_RO.scpt，并且文件格式设置为“脚本”。在“显示启动屏幕”、“运行处理程序后保持打开”和“仅运行”选项中，只有后者被选中。在代码签名下，选择了“不要进行代码签名”。](image_fi/501942c04/f04010.png)'
- en: 'Figure 4-10: Generating a run-only AppleScript'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-10：生成仅运行的 AppleScript
- en: 'Run-only AppleScript files are not human readable, nor are they decompilable
    via `osadecompile`. As you can see in [Listing 4-20](#listing4-20), an attempt
    to decompile a run-only script causes an `errOSASourceNotAvailable` error:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 仅运行的 AppleScript 文件无法被人类阅读，也不能通过 `osadecompile` 反编译。如在[清单 4-20](#listing4-20)中所示，尝试反编译仅运行的脚本会导致
    `errOSASourceNotAvailable` 错误：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 4-20: Decompiling a run-only AppleScript via `osadecompile` fails'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-20：通过 `osadecompile` 反编译仅运行的 AppleScript 失败
- en: 'An example of a Mac malware specimen that leverages run-only AppleScript is
    OSAMiner, which Mac malware researcher Phil Stokes thoroughly examined in “Adventures
    in Reversing Malicious Run-Only AppleScripts.”^([12](#c04-endnote-12)) In doing
    so, he presented a comprehensive list of techniques for analyzing run-only AppleScript
    files. His write-up noted that OSAMiner installs a launch item that persists an
    AppleScript. This launch item is shown in [Listing 4-21](#listing4-21). Note that
    the values in the `ProgramArguments` key will instruct macOS to invoke the `osascript`
    command to execute an AppleScript file named *com.apple.4V.plist* 1:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个利用仅运行 AppleScript 的 Mac 恶意软件示例是 OSAMiner，Mac 恶意软件研究员 Phil Stokes 在《逆向分析恶意仅运行
    AppleScripts 的冒险》中对其进行了详细分析。^([12](#c04-endnote-12)) 在分析过程中，他提供了一个全面的技术列表，用于分析仅运行的
    AppleScript 文件。他的文章指出，OSAMiner 安装了一个启动项，持久化一个 AppleScript。此启动项在[清单 4-21](#listing4-21)中显示。请注意，`ProgramArguments`
    键中的值将指示 macOS 调用 `osascript` 命令执行一个名为 *com.apple.4V.plist* 的 AppleScript 文件 1：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 4-21: A persistent launch item plist (OSAMiner)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-21：一个持久化启动项 plist（OSAMiner）
- en: 'Running the `file` and `osadecompile` commands confirm the persisted item,
    *com.apple.4V.plist*, is a run-only AppleScript that cannot be decompiled via
    macOS’s built-in tools ([Listing 4-22](#listing4-22)):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `file` 和 `osadecompile` 命令确认持久化项 *com.apple.4V.plist* 是一个仅运行的 AppleScript，无法通过
    macOS 的内置工具进行反编译（[清单 4-22](#listing4-22)）：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 4-22: Decompiling run-only AppleScript via `osadecompile` fails (OSAMiner)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-22：通过 `osadecompile` 反编译仅运行的 AppleScript 失败（OSAMiner）
- en: 'Luckily, we can turn to an open source AppleScript disassembler created by
    Jinmo.^([13](#c04-endnote-13)) After installing this disassembler, we can disassemble
    the *com.apple.4V.plist* file ([Listing 4-23](#listing4-23)):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以转向 Jinmo 创建的开源 AppleScript 反汇编器。^([13](#c04-endnote-13)) 安装该反汇编器后，我们可以反汇编
    *com.apple.4V.plist* 文件（[清单 4-23](#listing4-23)）：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 4-23: Decompiling run-only AppleScript via the AppleScript disassembler'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-23：通过 AppleScript 反汇编器反编译仅运行的 AppleScript
- en: The disassembler breaks out the run-only AppleScript into various functions
    (called *handlers* in AppleScript parlance). For example, we can see a function
    named `e` (“encode”?) adding 0x64 to an item in a loop, while the `d` (“decode”?)function
    appears to do the inverse by subtracting 0x64\. The latter, `d`, is invoked several
    times elsewhere in the code, to deobfuscate various strings.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编器将只能运行的 AppleScript 分解成多个函数（在 AppleScript 术语中称为 *handlers*）。例如，我们可以看到一个名为
    `e`（“encode”？）的函数，它在循环中将 0x64 加到某个项上，而 `d`（“decode”？）函数似乎通过减去 0x64 执行反向操作。后者 `d`
    在代码的其他地方被多次调用，以解混淆各种字符串。
- en: 'Still, the disassembly leaves much to be desired. For example, in various places
    within the code, the disassembler does not sufficiently extract hardcoded strings
    in a human-readable manner. To address its shortcomings, Stokes created his own
    open source AppleScript decompiler named `aevt_decompile`.^([14](#c04-endnote-14))
    This decompiler takes as input the output from the AppleScript disassembler ([Listing
    4-24](#listing4-24)):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，反汇编的结果仍然有待改进。例如，在代码中的多个地方，反汇编器没有以人类可读的方式充分提取硬编码的字符串。为了弥补这些不足，Stokes 创建了一个名为
    `aevt_decompile` 的开源 AppleScript 反编译器。^([14](#c04-endnote-14)) 这个反编译器的输入是 AppleScript
    反汇编器的输出（见[清单 4-24](#listing4-24)）：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 4-24: Decompiling run-only AppleScripts via an AppleScript disassembler
    and `aevt_decompile`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-24：通过 AppleScript 反汇编器和 `aevt_decompile` 反编译只能运行的 AppleScript
- en: 'The `aevt_decompile` decompiler produces output that is more conducive to analysis.
    For example, it extracts hardcoded strings and makes them readable while correctly
    identifying and annotating Apple Event codes. Armed with the decompiled AppleScript,
    analysis can continue. In his write-up, Stokes noted that the malware would write
    out an embedded AppleScript to *~/Library/k.plist* and then execute it. Looking
    through the decompiled code, we can identify this logic ([Listing 4-25](#listing4-25)):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`aevt_decompile` 反编译器生成的输出更有利于分析。例如，它提取了硬编码的字符串并使其可读，同时正确识别并注释了 Apple Event
    代码。通过反编译得到的 AppleScript，分析可以继续进行。在他的写作中，Stokes 提到，恶意软件会将嵌入的 AppleScript 写入 *~/Library/k.plist*
    并执行它。通过查看反编译的代码，我们可以识别出这一逻辑（见[清单 4-25](#listing4-25)）：'
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 4-25: Further decompiling run-only AppleScript via `aevt_decompile`
    (OSAMiner)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-25：通过 `aevt_decompile` 进一步反编译只能运行的 AppleScript（OSAMiner）
- en: As you can see, the code writes out the embedded script via a call to the `do
    shell script` command 1. Then it executes this script with the `osascript` command
    (redirecting any output or errors to `/dev/null`) 2.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码通过调用 `do shell script` 命令 1 输出嵌入的脚本。然后，它使用 `osascript` 命令执行这个脚本（将任何输出或错误重定向到
    `/dev/null`）2。
- en: Reading through the rest of the decompiled AppleScript reveals the remaining
    capabilities of this component of the OSAMiner malware. For a continued discussion
    on how malware authors abuse AppleScript, see “How AppleScript Is Used for Attacking
    macOS.”^([15](#c04-endnote-15))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读反编译后的 AppleScript 其余部分可以揭示该 OSAMiner 恶意软件组件的其他功能。有关恶意软件作者如何滥用 AppleScript
    的进一步讨论，请参见“AppleScript 如何用于攻击 macOS。”^([15](#c04-endnote-15))
- en: Perl Scripts
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Perl 脚本
- en: 'In the world of macOS malware, Perl is not a common scripting language. However,
    at least one infamous macOS malware specimen was written in Perl: FruitFly. Created
    in the mid-2000s, it remained undetected in the wild for almost 15 years. FruitFly’s
    main persistent component, most commonly named *fpsaud*, was written in Perl ([Listing
    4-26](#listing4-26)):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 恶意软件的世界中，Perl 并不是一种常见的脚本语言。然而，至少有一种臭名昭著的 macOS 恶意软件是用 Perl 编写的：FruitFly。FruitFly
    于 2000 年代中期创建，在野外几乎存在了 15 年之久都未被发现。FruitFly 的主要持久组件，通常命名为 *fpsaud*，就是用 Perl 编写的（见[清单
    4-26](#listing4-26)）：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 4-26: Obfuscated Perl (FruitFly)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-26：混淆的 Perl（FruitFly）
- en: Like other scripting languages, programs written in Perl are generally distributed
    as scripts rather than compiled. Thus, analyzing them is relatively straightforward.
    However, in the case of FruitFly, the malware author attempted to complicate the
    analysis by removing unnecessary whitespace in the code and renaming variables
    and subroutines using nonsensical single-letter names, a common tactic for both
    obfuscating and minimizing the code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他脚本语言一样，使用 Perl 编写的程序通常以脚本形式分发，而不是编译后的形式。因此，分析它们相对直接。然而，在 FruitFly 的情况下，恶意软件作者通过删除代码中的不必要空白、重命名变量和子程序并使用无意义的单个字母名称，试图复杂化分析，这是一种常见的混淆和代码最小化的策略。
- en: 'Leveraging any one of various online Perl “beautifiers,” we can reformat the
    malicious script and produce more readable code, as in [Listing 4-27](#listing4-27)
    (though the names of variables and subroutines remain nonsensical):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 利用各种在线Perl“美化工具”中的任何一个，我们可以重新格式化恶意脚本并生成更易读的代码，如[清单4-27](#listing4-27)所示（尽管变量和子程序的名称依然没有意义）：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 4-27: Beautified, though still somewhat obfuscated, Perl (FruitFly)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-27：已美化，尽管仍然有些混淆的Perl（FruitFly）
- en: 'The beautified Perl script still isn’t the easiest thing to read, but with
    a little patience, we can deduce the malware’s full capabilities. First, the script
    imports various Perl modules with the `use` keyword. These modules provide hints
    as to what the script is up to: the `IO:Socket` module indicates network capabilities,
    while the `IPC:Open2` module suggests that the malware interacts with processes.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 美化过的Perl脚本仍然不容易阅读，但只需一点耐心，我们就可以推测出恶意软件的全部能力。首先，脚本使用`use`关键字导入了多个Perl模块。这些模块提供了脚本正在进行的操作的线索：`IO::Socket`模块表明具有网络功能，而`IPC::Open2`模块则暗示恶意软件与进程交互。
- en: A few lines later, the script invokes `IO::Socket::INET` to create a connection
    to the attacker’s remote command and control server 1. Next, we can see that it
    invokes the built-in `scutil`, `hostname`, and `whoami` commands 2, which the
    malware likely uses to generate a basic survey of the infected macOS system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 几行后，脚本调用了`IO::Socket::INET`来创建与攻击者远程命令与控制服务器的连接1。接着，我们可以看到它调用了内置的`scutil`、`hostname`和`whoami`命令2，这些命令可能是恶意软件用来生成被感染的macOS系统基本信息的。
- en: 'Elsewhere in the code, the malware invokes other system commands to provide
    more capabilities. For example, it invokes the `ps` command to generate a process
    listing 3. This approach, of focusing on the commands invoked by the malware’s
    Perl code, provides sufficient insight into its capabilities. For a comprehensive
    analysis of this threat, see my research paper, “Offensive Malware Analysis: Dissecting
    OSX/FruitFly.”^([16](#c04-endnote-16))'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的其他部分，恶意软件调用其他系统命令以提供更多功能。例如，它调用`ps`命令生成进程列表3。通过关注恶意软件Perl代码中调用的命令，这种方法可以提供足够的关于其能力的洞察。要对该威胁进行全面分析，请参阅我的研究论文《进攻性恶意软件分析：剖析OSX/FruitFly》^([16](#c04-endnote-16))。
- en: Microsoft Office Documents
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Microsoft Office文档
- en: Malware researchers who analyze Windows malware are quite likely to encounter
    malicious, macro-laden Microsoft Office documents. Unfortunately, opportunistic
    malware authors have recently stepped up efforts to infect Office documents aimed
    at Mac users, too. These documents might contain only Mac-specific macro code
    or both Windows-specific and Mac-specific code, making them cross platform.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 分析Windows恶意软件的研究人员很可能会遇到包含恶意宏的Microsoft Office文档。不幸的是，最近机会主义的恶意软件作者也加大了感染针对Mac用户的Office文档的力度。这些文档可能仅包含特定于Mac的宏代码，或者同时包含针对Windows和Mac的宏代码，使其具备跨平台能力。
- en: 'We briefly discussed malicious Office documents in Chapter 1. Recall that macros
    provide a way to make a document dynamic, typically by adding executable code
    to the Microsoft Office documents. Using the `file` command, you can readily identify
    Microsoft Office documents ([Listing 4-28](#listing4-28)):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第1章中简要讨论了恶意Office文档。回想一下，宏为文档提供了动态化的方式，通常通过向Microsoft Office文档中添加可执行代码来实现。使用`file`命令，你可以轻松识别Microsoft
    Office文档（[清单4-28](#listing4-28)）：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 4-28: Using `file` to identify an Office document'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-28：使用`file`命令识别Office文档
- en: The *.docm* extension is a good indication that a file contains macros. Beyond
    this, determining whether the macros are malicious takes a tad more effort. Various
    tools can assist in this static analysis. The oletools toolset is one of the best.^([17](#c04-endnote-17))
    Free and open source, it contains various Python scripts created to facilitate
    the analysis of Microsoft Office documents and other OLE files.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*.docm*扩展名是文件包含宏的一个很好的指示。除此之外，判断宏是否具有恶意性则需要更多的努力。各种工具可以帮助进行这种静态分析。oletools工具集就是其中最好的之一。^([17](#c04-endnote-17))
    该工具集是免费的开源软件，包含多种Python脚本，用于促进对Microsoft Office文档和其他OLE文件的分析。'
- en: 'This toolset includes the `olevba` utility designed to extract embedded macros
    from Office documents. After installing oletools via pip, execute `olevba` with
    the `-c` flag and the path to the macro-laden document. If the document contains
    macros, they will be extracted and printed to standard out ([Listing 4-29](#listing4-29)):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具集包括`olevba`实用程序，旨在提取Office文档中嵌入的宏。通过pip安装oletools后，执行`olevba`并加上`-c`标志和宏文件的路径。如果文档中包含宏，它们将被提取并打印到标准输出（[清单4-29](#listing4-29)）：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 4-29: Using `olevba` to extract macros'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-29：使用`olevba`提取宏
- en: 'For example, let’s take a closer look at a malicious Office document called
    *U.S. Allies and Rivals Digest Trump’s Victory.docm* that was sent to unsuspecting
    Mac users shortly after the 2016 US presidential election. First, we use `olevba`
    to both confirm the presence of, and extract, the document’s embedded macros ([Listing
    4-30](#listing4-30)):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们来仔细看看一个恶意的Office文档，名为*U.S. Allies and Rivals Digest Trump’s Victory.docm*，它在2016年美国总统选举后不久被发送给毫无防备的Mac用户。首先，我们使用`olevba`来确认文档中是否存在宏，并提取出嵌入的宏（[列表
    4-30](#listing4-30)）：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 4-30: Using `olevba` to extract malicious macros'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-30：使用`olevba`提取恶意宏
- en: If you open an Office document containing macros and enable macros, code within
    subroutines such as `AutoOpen`, `AutoExec`, or `Document_Open` will run automatically.
    As you can see, this “Trump’s Victory” document contains macro code in one of
    these subroutines 1. Macro subroutine names are case-insensitive (for example,
    `AutoOpen` and `autoopen` are equivalent). For more details on subroutines that
    are automatically invoked, see Microsoft’s developer documentation “Description
    of behaviors of AutoExec and AutoOpen macros in Word.”^([18](#c04-endnote-18))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开一个包含宏的Office文档并启用宏，像`AutoOpen`、`AutoExec`或`Document_Open`这样的子程序中的代码将自动运行。如你所见，这个“特朗普胜利”文档包含了其中一个子程序的宏代码
    1。宏子程序名称不区分大小写（例如，`AutoOpen`和`autoopen`是等价的）。有关自动调用的子程序的更多详细信息，请参见微软的开发者文档《Word中AutoExec和AutoOpen宏行为的描述》。^([18](#c04-endnote-18))
- en: In this example, the code within the `autoopen` subroutine invokes a subroutine
    named `Fisher` that builds a large base64-encoded string, stored in a variable
    named `cmd` 2, before invoking the system API and passing this string to Python
    for execution 3. Decoding the embedded string confirms that it’s Python code,
    which is unsurprising considering the macro code hands it off to Python. Entering
    various parts of the Python code in a search engine quickly reveals it is a well-known
    open source post-exploitation agent, Empyre.^([19](#c04-endnote-19))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`autoopen`子程序中的代码调用了一个名为`Fisher`的子程序，构建了一个大型的base64编码字符串，存储在名为`cmd`的变量中
    2，然后调用系统API并将该字符串传递给Python进行执行 3。解码嵌入的字符串确认它是Python代码，这并不令人惊讶，因为宏代码将其交给了Python。将Python代码的各个部分输入搜索引擎，很快就能发现它是一个著名的开源后期利用代理，名为Empyre。^([19](#c04-endnote-19))
- en: 'Now we know that the goal of the malicious macro code is to download and execute
    to a fully featured interactive backdoor. Handing off control to some other malware
    is a common theme in macro-based attacks; after all, who wants to write a complete
    backdoor in VBA? For a thorough technical analysis of this macro attack, including
    a link to the malicious document, see “New Attack, Old Tricks: Analyzing a malicious
    document with a mac-specific payload.”^([20](#c04-endnote-20))'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道恶意宏代码的目标是下载并执行一个功能齐全的交互式后门。在基于宏的攻击中，将控制权交给其他恶意软件是一个常见的主题；毕竟，谁愿意在VBA中编写一个完整的后门呢？关于这个宏攻击的详细技术分析，包括指向恶意文档的链接，请参见《新攻击，旧手法：分析一个带有Mac特定有效载荷的恶意文档》。^([20](#c04-endnote-20))
- en: Sophisticated APT groups, such as the Lazarus Group, also leverage malicious
    Office documents. For example, in Chapter 1 we analyzed a macro used to target
    macOS users in South Korea and discovered that it downloaded and executed a second-stage
    payload. The downloaded payload, *mt.dat*, turned out to be the malware known
    as Yort, a Mach-O binary that implements standard backdoor capabilities. For a
    comprehensive technical analysis of this malicious document and attack as a whole,
    see either my analysis “OSX.Yort” or the write-up “Lazarus Apt Targets Mac Users
    With Poisoned Word Document.”^([21](#c04-endnote-21))
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 精密的APT组织，如拉撒路集团，也利用恶意Office文档。例如，在第一章中，我们分析了一个针对韩国macOS用户的宏，并发现它下载并执行了一个二阶段的有效载荷。下载的有效载荷*mt.dat*实际上是被称为Yort的恶意软件，一个Mach-O二进制文件，具有标准的后门功能。关于此恶意文档及其攻击整体的详细技术分析，请参见我的分析《OSX.Yort》或文章《拉撒路APT通过毒化的Word文档针对Mac用户》。^([21](#c04-endnote-21))
- en: Applications
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: Attackers often package Mac malware in malicious applications. Applications
    are a file format familiar to all Mac users, so a user may not think twice before
    running one. Moreover, as applications are tightly integrated with macOS, a double-click
    may be sufficient to fully infect a Mac system (although since macOS Catalina,
    notarization requirements do help prevent certain inadvertent infections).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者常常将Mac恶意软件打包在恶意应用程序中。应用程序是Mac用户熟悉的文件格式，因此用户可能不会多想就运行了它们。此外，由于应用程序与macOS紧密集成，双击就足以完全感染Mac系统（尽管自macOS
    Catalina以来，公证要求有助于防止某些无意的感染）。
- en: Behind the scenes, an application is actually a directory, albeit one with a
    well-defined structure. In Apple parlance, we refer to this directory as an *application
    bundle*. You can view the contents of an application bundle (such as the malware
    WindTail) in Finder by CTRL-clicking an application’s icon and selecting **Show
    Package Contents** ([Figure 4-11](#figure4-11)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，应用程序实际上是一个目录，尽管它有一个明确的结构。在苹果的术语中，我们将这个目录称为*应用程序包*。你可以通过在Finder中CTRL点击应用程序图标并选择**显示包内容**来查看应用程序包的内容（如恶意软件WindTail）（[图4-11](#figure4-11)）。
- en: '![f04011_1](image_fi/501942c04/f04011_1.png)![After selecting “Show [WindTail’s]
    Package Contents” in Finder, a new screen opens that shows the folders inside
    the Contents folder: _CodeSignature, MacOS, and Resources. The MacOS folder contains
    USRNODE, a Unix Executable File.](image_fi/501942c04/f04011_2.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![f04011_1](image_fi/501942c04/f04011_1.png)![在Finder中选择“显示[WindTail]包内容”后，会打开一个新屏幕，显示Contents文件夹中的子文件夹：_CodeSignature、MacOS和Resources。MacOS文件夹包含USRNODE，一个Unix可执行文件。](image_fi/501942c04/f04011_2.png)'
- en: 'Figure 4-11: Viewing the contents of an application bundle (WindTail)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-11：查看应用程序包的内容（WindTail）
- en: However, a more comprehensive approach is to leverage the free Apparency application,
    which was designed specifically for the task of statically analyzing application
    bundles ([Figure 4-12](#figure4-12)).^([22](#c04-endnote-22)) In its user interface,
    you can browse components of the application to gain valuable insight into all
    aspects of the bundle, including identifier and version information, code-signing,
    and other security features, and information about the application’s main executable
    and frameworks.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更全面的方法是利用免费的Apparency应用程序，它是专门为静态分析应用程序包而设计的([图4-12](#figure4-12))。^([22](#c04-endnote-22))
    在其用户界面中，你可以浏览应用程序的组件，从中获取关于包的各个方面的宝贵信息，包括标识符和版本信息、代码签名及其他安全功能，以及关于应用程序主可执行文件和框架的信息。
- en: '![In Apparency, highlighting the WindTail application shows a list of information,
    including its location, identifier (“com.alis.tre”), version (“1.0 [1]”), gatekeeper
    (“Can’t evaluate”), and who it was signed by (“Untrusted certificate”). Clicking
    the WindTail application opens a new window showing its Info Property List.](image_fi/501942c04/f04012.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![在Apparency中，突出显示WindTail应用程序时，会显示一系列信息，包括其位置、标识符（“com.alis.tre”）、版本（“1.0
    [1]”）、Gatekeeper状态（“无法评估”）、以及签名者（“不受信任的证书”）。点击WindTail应用程序会打开一个新窗口，显示其信息属性列表。](image_fi/501942c04/f04012.png)'
- en: 'Figure 4-12: Using Apparency to view the contents of an application bundle
    (WindTail)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-12：使用Apparency查看应用程序包的内容（WindTail）
- en: 'Yet Apparency, as noted in its user guide, doesn’t show every file inside the
    app bundle. Thus, you might find the terminal useful for viewing all of the application
    bundle’s files ([Listing 4-31](#listing4-31)):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如Apparency的用户指南所述，它并不会显示应用程序包中的每一个文件。因此，你可能会发现终端对于查看应用程序包的所有文件非常有用（[列表4-31](#listing4-31)）：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 4-31: Using `find` to view the contents of an application bundle (WindTail)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-31：使用`find`命令查看应用程序包的内容（WindTail）
- en: 'Standard application bundles include the following files and subdirectories:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 标准应用程序包通常包括以下文件和子目录：
- en: '*Contents/*: A directory that contains all files and subdirectories of the
    application bundle.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Contents/*：包含应用程序包所有文件和子目录的目录。'
- en: '*Contents/_CodeSignature*: If the application is signed, contains code-signing
    information about the application (like hashes).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Contents/_CodeSignature*：如果应用程序已签名，则包含应用程序的代码签名信息（如哈希值）。'
- en: '*Contents/MacOS*: A directory that contains the application’s binary, which
    is what executes when the user double-clicks the application icon in the user
    interface.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Contents/MacOS*：一个包含应用程序二进制文件的目录，用户在界面中双击应用程序图标时会执行该二进制文件。'
- en: '*Contents/Resources*: A directory that contains user interface elements of
    the application, such as images, documents, and *nib/xib* files that describe
    various user interfaces.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contents/Info.plist*: The application’s main configuration file. Apple notes
    that macOS uses this file to ascertain pertinent information about the application
    (such as the location of the application’s main binary).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that not all of the aforementioned files and directories of an application
    bundle are required. Though it’s unusual, if an *Info.plist* file is not found
    in the bundle, the operating system will assume that the application’s executable
    will be found in the *Contents/MacOS* directory with a name that matches the application
    bundle. For a comprehensive discussion of application bundles, see Apple’s authoritative
    developer documentation on the matter: “Bundle Structures.”^([23](#c04-endnote-23))'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of statically analyzing a malicious application, the two most
    important files are the application’s *Info.plist* file and its main executable.
    As we’ve discussed, when an application is launched, the system consults its *Info.plist*
    property list file if one is present, because it contains important metadata about
    the application stored in key/value pairs. Let’s take a look at a snippet of WindTail’s
    *Info.plist*, highlighting several key/value pairs of particular interest in the
    context of triaging an application ([Listing 4-32](#listing4-32)):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 4-32: An *Info.plist* file (WindTail)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: WindTail’s *Info.plist* file begins with various key/value pairs describing
    the system on which the malware was compiled. For example, the `BuildMachineOSBuild`
    key contains a value of `14B25`, which is the build number of OS X Yosemite (10.10.1).
    Following this, we find the `CFBundleExecutable` key, which specifies to macOS
    which binary to execute when the application is launched. Thus, when WindTail
    is launched, the system will execute the *usrnode* binary from within the *Contents/MacOS*
    directory. This `CFBundleExecutable` key/value pair is generally necessary, as
    the application’s binary may not match the application’s name, or there may be
    several executable files within the *Contents/MacOS* directory.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'From an analysis point of view, the other key/value pairs in the WindTail*Info.plist*
    file are less interesting, save for the `NSUIElement` key. This key, named `LSUIElement`
    on newer versions of macOS, tells the system to hide the application icon in the
    dock if it’s set to 1\. Legitimate applications rarely have this key set. For
    more information about the keys and values in an application’s *Info.plist* file,
    see Apple’s document on the topic: “About Info.plist Keys and Values.”^([24](#c04-endnote-24))'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Though you’ll generally find application *Info.plist* files written in plaintext
    XML, so they’re directly readable in the terminal or in a text editor, macOS also
    supports a binary property list (*plist*) format. Siggen is an example of malware
    with a malicious application containing an *Info.plist* file in this binary format
    ([Listing 4-33](#listing4-33)):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 4-33: Using `file` to identify a binary property list (Siggen)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'To read this binary file format, use macOS’s `defaults` command with the `read`
    command line flag, as shown in [Listing 4-34](#listing4-34):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 4-34: Using `defaults` to read a binary property list (Siggen)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: As noted, the `CFBundleExecutable` key in an application’s *Info.plist* contains
    the name of the application’s main executable component. Though Siggen’s application
    is named *WhatsAppService.app*, its *Info.plist* file specifies that a binary
    named *Dropbox* should be executed when that application is launched.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that unless an application has been notarized, the
    other values in a malicious application’s *Info.plist* file may be deceptive.
    For example, Siggen sets its bundle identifier, `CFBundleIdentifier`, to *inc.dropbox.com*
    in an effort to masquerade as legitimate Dropbox software.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve perused the *Info.plist* file, you’ll likely turn your attention
    toward analyzing the binary specified in the `CFBundleExecutable` key. More often
    than not, this binary is a Mach-O, the native executable file format of macOS.
    We’ll discuss this format in Chapter 5.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Up Next
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we introduced the concept of static analysis and highlighted
    how tools such as macOS’s built-in `file` utility and my own WYS, can identify
    a file’s true type. This is an important first analysis step, as many static analysis
    tools are file-type specific. We then examined various nonbinary file types commonly
    encountered while analyzing Mac malware. For each file type, we discussed its
    purpose and highlighted static analysis tools that you can use to analyze the
    file format.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: However, this chapter focused only on the analysis of nonbinary file formats,
    such as distribution mediums and scripts. While many Mac malware specimens are
    scripts, the majority are compiled into Mach-O binaries. In the next chapter we’ll
    discuss this binary file format and then explore binary analysis tools and techniques.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Endnotes
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
