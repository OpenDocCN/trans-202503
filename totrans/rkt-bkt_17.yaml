- en: '**15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15'
- en: CONTEMPORARY UEFI BOOTKITS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当代 UEFI 引导工具**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: These days, it’s rare to catch a new and innovative rootkit or bootkit in the
    wild. Most malware threats have migrated to user mode because modern security
    technologies have rendered old rootkits and bootkit methods obsolete. Security
    methods like Microsoft’s Kernel-Mode Code Signing Policy, PatchGuard, Virtual
    Secure Mode (VSM), and Device Guard create limitations for kernel-mode code modifications
    and raise the threshold of complexity for kernel-mode rootkit development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，在野外很少能捕捉到新的创新根工具或引导工具。大多数恶意软件威胁已经转向用户模式，因为现代安全技术使得旧有的根工具和引导工具方法已经过时。像微软的内核模式代码签名策略、PatchGuard、虚拟安全模式（VSM）和设备保护等安全措施限制了内核模式代码的修改，并提高了内核模式根工具开发的复杂性。
- en: The move to UEFI-based systems and spread of the Secure Boot scheme have changed
    the landscape of bootkit development, increasing development costs for kernel-mode
    rootkits and bootkits. In the same way that the introduction of the Kernel-Mode
    Code Signing Policy drove malware developers to look for new bootkit functionality
    rather than find ways to evolve rootkits to bypass the code signing protections,
    the most recent changes have lead security researchers to turn their attention
    toward BIOS firmware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 向基于 UEFI 的系统过渡，以及安全启动方案的推广，改变了引导工具开发的格局，提高了内核模式根工具和引导工具的开发成本。就像内核模式代码签名策略的引入促使恶意软件开发者寻求新的引导工具功能，而不是寻找绕过代码签名保护的方法一样，最近的变化也使安全研究人员将注意力转向了
    BIOS 固件。
- en: From the attacker’s perspective, the next logical step to infecting a system
    is to move the point of infection down into the software stack, after the boot
    code is initialized, to get into the BIOS (illustrated in [Figure 15-1](ch15.xhtml#ch15fig01)).
    The BIOS starts the initial stages for the hardware setup in the boot process,
    meaning the BIOS firmware level is the last boundary before hardware.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从攻击者的角度来看，感染系统的下一个逻辑步骤是将感染点向下移动到软件堆栈中，在引导代码初始化之后，进入 BIOS（如 [图 15-1](ch15.xhtml#ch15fig01)
    所示）。BIOS 在引导过程中启动硬件设置的初步阶段，这意味着 BIOS 固件级别是硬件之前的最后一道屏障。
- en: '![image](../images/15fig01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig01.jpg)'
- en: '*Figure 15-1: Development of rootkits and bootkits in response to developments
    in security*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：根工具和引导工具对安全性发展的回应*'
- en: The persistence level required for the BIOS is very different from anything
    else we’ve discussed so far in this book. Firmware implants can survive after
    reinstallation of the operating system and even after replacement of the hard
    drive, meaning that the rootkit infection potentially stays active for the lifetime
    of the infected hardware.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS 所需的持久性级别与我们在本书中迄今讨论的其他任何内容都非常不同。固件植入可以在重新安装操作系统后甚至更换硬盘后继续存活，这意味着根工具感染有可能在感染硬件的整个生命周期内保持活跃。
- en: This chapter focuses on bootkit infection of the UEFI firmware, because at the
    time of this writing, most of the system firmware for x86 platforms is based on
    UEFI specifications. Before we get to those modern UEFI firmware infection methods,
    though, we’ll discuss some legacy BIOS bootkits for historical perspective.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论 UEFI 固件的引导工具感染，因为在撰写本文时，大多数 x86 平台的系统固件都基于 UEFI 规范。然而，在讨论这些现代 UEFI 固件感染方法之前，我们将先讨论一些历史遗留的
    BIOS 引导工具，以便提供历史背景。
- en: '**Overview of Historical BIOS Threats**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**历史 BIOS 威胁概览**'
- en: 'BIOS malware has always had a reputation for complexity, and with all the modern
    BIOS features the malware must work with or around, that’s truer today than ever.
    Even before vendors began taking it seriously, BIOS malware had a rich history.
    We’ll look at a couple of early examples of BIOS malware in detail, then briefly
    list the main characteristics of all the threats detected since the first BIOS-infecting
    malware: WinCIH.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS 恶意软件一直以其复杂性而著称，而随着现代 BIOS 特性的增加，恶意软件需要与之协作或绕过，今天这一点比以往任何时候都更加真实。即便在厂商开始认真对待之前，BIOS
    恶意软件已经有了丰富的历史。我们将详细看几个早期的 BIOS 恶意软件示例，然后简要列出自第一个 BIOS 感染恶意软件 WinCIH 以来所有威胁的主要特征。
- en: '***WinCIH, the First Malware to Target BIOS***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***WinCIH，首个针对 BIOS 的恶意软件***'
- en: The virus WinCIH, also known as Chernobyl, was the first malware publicly known
    to attack the BIOS. Developed by Taiwanese student Chen Ing-hau, it was detected
    in the wild in 1998 and spread very quickly through pirated software. WinCIH infected
    Microsoft Windows 95 and 98 executable files; then, once an infected file was
    executed, the virus stayed in memory and set up filesystem hooks to infect other
    programs as they were accessed. This method made WinCIH highly effective at propagation,
    but the most destructive part of the virus was its attempt to overwrite the memory
    of the flash BIOS chip on the infected machine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: WinCIH 病毒，也被称为切尔诺贝利病毒，是第一个公开被知道攻击 BIOS 的恶意软件。它由台湾学生陈英豪开发，1998 年在野外被发现，并通过盗版软件迅速传播。WinCIH
    会感染 Microsoft Windows 95 和 98 的可执行文件；当感染的文件被执行时，病毒会驻留在内存中并设置文件系统钩子，以便在访问其他程序时将其感染。这种方法使
    WinCIH 在传播上极为有效，但病毒最具破坏性的部分是它试图覆盖感染机器上闪存 BIOS 芯片的内存。
- en: The destructive WinCIH payload was timed to strike on the date of the Chernobyl
    nuclear disaster, April 26\. If the flash BIOS overwrite was successful, the machine
    was unable to boot unless the original BIOS was recovered. In the resources for
    this chapter (*[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*),
    you can download the original assembly code of WinCIH as distributed by its author.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 具有破坏性的 WinCIH 载荷被定时设置在切尔诺贝利核灾难的日期——4 月 26 日。如果闪存 BIOS 覆盖成功，除非恢复原始 BIOS，否则机器将无法启动。在本章的资源中（*[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*），你可以下载
    WinCIH 的原始汇编代码，该代码由其作者分发。
- en: '**NOTE**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re interested in reading more about legacy BIOS reverse engineering
    and architecture, we recommend the book* BIOS Disassembly Ninjutsu Uncovered *by
    Darmawan Mappatutu Salihun, also known as pinczakko. The electronic copy of the
    book can be downloaded for free from the author’s GitHub account* ([https://github.com/pinczakko/BIOS-Disassembly-Ninjutsu-Uncovered](https://github.com/pinczakko/BIOS-Disassembly-Ninjutsu-Uncovered)).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你有兴趣深入了解传统 BIOS 逆向工程和架构，我们推荐由 Darmawan Mappatutu Salihun（也被称为 pinczakko）所著的《BIOS
    Disassembly Ninjutsu Uncovered》一书。该书的电子版可以从作者的 GitHub 账户免费下载* ([https://github.com/pinczakko/BIOS-Disassembly-Ninjutsu-Uncovered](https://github.com/pinczakko/BIOS-Disassembly-Ninjutsu-Uncovered))。'
- en: '***Mebromi***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Mebromi***'
- en: After WinCIH, the next BIOS-attacking malware discovered in the wild didn’t
    appear until 2011\. It was known as Mebromi, or BIOSkit, and targeted machines
    with legacy BIOS. By this time, security researchers had produced and released
    infection ideas and proofs of concept (PoCs) for BIOS attacks at conferences and
    in e-zines. Most of these ideas were difficult to implement in real-life infectious
    malware, but BIOS infection was seen as an interesting theoretical direction for
    targeted attacks that needed to keep up a long-term persistent infection.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WinCIH 之后，直到 2011 年，下一种在野外发现的 BIOS 攻击恶意软件才出现。它被称为 Mebromi 或 BIOSkit，目标是具有传统
    BIOS 的机器。到那时，安全研究人员已经在会议和电子杂志上发布了 BIOS 攻击的感染思路和概念证明（PoC）。这些思路中的大多数在实际的恶意软件中难以实施，但
    BIOS 感染被视为针对性攻击的一种有趣理论方向，因为这种攻击需要维持长期的持久感染。
- en: Rather than implementing these theoretical techniques, Mebromi used the BIOS
    infection as a simple way to keep the MBR consistently infected at system boot.
    Mebromi was able to restore the infection even when the MBR was recovered to its
    original state or the OS was reinstalled, and even after the hard drive was replaced;
    the BIOS part of the infection would remain and reinfect the rest of the system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Mebromi 并没有实现这些理论技术，而是将 BIOS 感染作为一种简单的方法，用来保持 MBR 在系统启动时始终处于感染状态。即使 MBR 被恢复到原始状态或操作系统重新安装，甚至硬盘被更换，Mebromi
    也能恢复感染；感染的 BIOS 部分会保留并重新感染系统的其他部分。
- en: In its initial stage, Mebromi used the original BIOS update software to deliver
    malicious firmware updates, specifically on Award BIOS systems, which was one
    of the most popular BIOS vendors at the time (it was acquired by Phoenix BIOS
    in 1998). During Mebromi’s lifetime, few protections existed to prevent malicious
    updates to the legacy BIOS. Similar to WinCIH, Mebromi modified the BIOS update
    routine’s System Management Interrupt (SMI) handler in order to deliver a modified,
    malicious BIOS update. Since measures like firmware signing did not exist at the
    time, infection was relatively easy; you can examine this classic piece of malware
    for yourself using the resource links at *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在初期阶段，Mebromi 使用原始的 BIOS 更新软件传递恶意固件更新，特别是在 Award BIOS 系统上，这些系统曾是当时最流行的 BIOS
    供应商之一（1998年被 Phoenix BIOS 收购）。在 Mebromi 存在期间，几乎没有保护措施可以防止恶意更新遗留 BIOS。与 WinCIH
    类似，Mebromi 修改了 BIOS 更新例程的系统管理中断（SMI）处理程序，以传递修改后的恶意 BIOS 更新。由于当时没有固件签名等防护措施，感染相对容易；你可以使用*
    [https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*提供的资源链接自行检查这一经典恶意软件。
- en: '**NOTE**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re interested in reading more about Mebromi, a detailed analysis is
    available in the paper “A New BIOS Rootkit Spreads in China” by Zhitao Zhou* ([https://www.virusbulletin.com/virusbulletin/2011/10/new-bios-rootkit-spreads-china/](https://www.virusbulletin.com/virusbulletin/2011/10/new-bios-rootkit-spreads-china/)).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你对阅读更多关于Mebromi的内容感兴趣，可以在 Zhitao Zhou 撰写的论文《一种新的 BIOS 根套件在中国传播》中找到详细分析*
    ([https://www.virusbulletin.com/virusbulletin/2011/10/new-bios-rootkit-spreads-china/](https://www.virusbulletin.com/virusbulletin/2011/10/new-bios-rootkit-spreads-china/))。'
- en: '***An Overview of Other Threats and Counters***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他威胁及应对概述***'
- en: Let’s now look at the timeline of in-the-wild BIOS threats and the related activities
    of security researchers. As you can see in [Figure 15-2](ch15.xhtml#ch15fig02),
    the most active period of discovery of BIOS rootkits and implants began in 2013
    and continues to the present day.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看野外 BIOS 威胁的时间线以及安全研究人员的相关活动。正如你在[图 15-2](ch15.xhtml#ch15fig02)中所见，BIOS
    根套件和植入物的发现最活跃的时期始于 2013 年，并持续至今。
- en: '![image](../images/15fig02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig02.jpg)'
- en: '*Figure 15-2: Timeline of BIOS threats*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：BIOS 威胁时间线*'
- en: To give you a brief idea of the evolution of the BIOS bootkit, we’ve listed
    the highlights of each threat chronologically in [Table 15-1](ch15.xhtml#ch15tab01).
    The left column lists the evolution of PoCs developed by researchers for the purposes
    of demonstrating security problems, and the middle columns list real BIOS threat
    samples found in the wild. The third column gives you resources for further reading.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简要说明 BIOS bootkit 的演变，我们在[表 15-1](ch15.xhtml#ch15tab01)中按时间顺序列出了每个威胁的重点。左列列出了研究人员为展示安全问题而开发的
    PoC 的演变，中间列列出了在野外发现的真实 BIOS 威胁样本。第三列提供了进一步阅读的资源。
- en: Many of these exploit SMI handlers, which are responsible for interfacing between
    the hardware and the OS, and are executed in System Management Mode (SMM). For
    the purposes of this chapter, we provide a brief description of the most frequently
    exploited SMI handler vulnerabilities used to infect BIOS. We provide a more thorough
    discussion of different UEFI firmware vulnerabilities in [Chapter 16](ch16.xhtml#ch16).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些威胁中许多利用了 SMI 处理程序，它负责硬件与操作系统之间的接口，并在系统管理模式（SMM）下执行。为了本章的讨论，我们简要描述了最常被利用的 SMI
    处理程序漏洞，这些漏洞被用来感染 BIOS。对于不同 UEFI 固件漏洞的更详细讨论，请参考[第16章](ch16.xhtml#ch16)。
- en: '**Table 15-1:** BIOS Rootkits Historical Timeline'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-1：** BIOS 根套件历史时间线'
- en: '| **PoC BIOS bootkit evolution** | **BIOS bootkit threat evolution** | **Further
    resources** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **PoC BIOS bootkit 演变** | **BIOS bootkit 威胁演变** | **进一步资源** |'
- en: '| --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  | **WinCIH, 1998**The first known malware that attacked the BIOS from OS
    |  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  | **WinCIH, 1998** 第一个已知的攻击操作系统的BIOS恶意软件 |  |'
- en: '| **APCI rootkit, 2006**The first ACPI-based rootkit (Advanced Configuration
    and Power Interface), presented at Black Hat by John Heasman |  | “Implementing
    and Detecting an ACPI BIOS Rootkit,” Black Hat 2006, *[https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Heasman.pdf](https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Heasman.pdf)*
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **APCI rootkit, 2006** 第一个基于 ACPI 的根套件（高级配置与电源接口），由 John Heasman 在 Black
    Hat 会议上展示 |  | “实现和检测 ACPI BIOS 根套件”，Black Hat 2006，*[https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Heasman.pdf](https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Heasman.pdf)*
    |'
- en: '| **PCI OptRom rootkit, 2007**The first Option ROM rootkit for PCI, presented
    at Black Hat by John Heasman |  | “Implementing and Detecting a PCI Rootkit,”
    Black Hat 2007, *[https://www.blackhat.com/presentations/bh-dc-07/Heasman/Paper/bh-dc-07-Heasman-WP.pdf](https://www.blackhat.com/presentations/bh-dc-07/Heasman/Paper/bh-dc-07-Heasman-WP.pdf)*
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **PCI OptRom rootkit, 2007**第一个针对PCI的Option ROM根工具，由John Heasman在Black Hat上展示
    |  | “实现和检测PCI根工具，”Black Hat 2007，* [https://www.blackhat.com/presentations/bh-dc-07/Heasman/Paper/bh-dc-07-Heasman-WP.pdf](https://www.blackhat.com/presentations/bh-dc-07/Heasman/Paper/bh-dc-07-Heasman-WP.pdf)*
    |'
- en: '| **IceLord rootkit, 2007**A Chinese BIOS bootkit PoC; the binaries were released
    publicly on the researcher’s forum |  |  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **IceLord rootkit, 2007**一个中国的BIOS引导工具PoC；二进制文件在研究者的论坛上公开发布 |  |  |'
- en: '| **SMM rootkit, 2007**The first known PoC of an SMM rootkit from Rodrigo Branco,
    shown at the H2HC conference in Brazil |  | “System Management Mode Hack Using
    SMM for ‘Other Purposes,’” *[http://phrack.org/issues/65/7.html](http://phrack.org/issues/65/7.html)*
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **SMM rootkit, 2007**首次已知的SMM根工具PoC，由Rodrigo Branco展示，在巴西的H2HC大会上亮相 |  |
    “使用SMM进行‘其他用途’的系统管理模式攻击，” *[http://phrack.org/issues/65/7.html](http://phrack.org/issues/65/7.html)*
    |'
- en: '| **SMM rootkit, 2008**The second known PoC of an SMM rootkit, shown at Black
    Hat |  | “SMM Rootkits: A New Breed of OS Independent Malware,” Black Hat 2008,
    *[http://dl.acm.org/citation.cfm?id=1460892](http://dl.acm.org/citation.cfm?id=1460892)*;
    see also *[http://phrack.org/issues/65/7.html](http://phrack.org/issues/65/7.html)*
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **SMM rootkit, 2008**第二个已知的SMM根工具PoC，在Black Hat上展示 |  | “SMM根工具：一种新的操作系统独立恶意软件类型，”Black
    Hat 2008，* [http://dl.acm.org/citation.cfm?id=1460892](http://dl.acm.org/citation.cfm?id=1460892)*；另见
    *[http://phrack.org/issues/65/7.html](http://phrack.org/issues/65/7.html)* |'
- en: '| **BIOS patching, 2009**Multiple researchers published papers about BIOS image
    modifications | **Computrace, 2009**The first known research about reverse engineering,
    published by Anibal Sacco and Alfredo Ortega | “Deactivate the Rootkit,” Black
    Hat 2009, *[https://www.coresecurity.com/corelabs-research/publications/deactivate-rootkit/](https://www.coresecurity.com/corelabs-research/publications/deactivate-rootkit/)*
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **BIOS修补，2009**多位研究人员发表了关于BIOS镜像修改的论文 | **Computrace, 2009**首个已知的逆向工程研究，由Anibal
    Sacco和Alfredo Ortega发布 | “停用根工具，”Black Hat 2009，* [https://www.coresecurity.com/corelabs-research/publications/deactivate-rootkit/](https://www.coresecurity.com/corelabs-research/publications/deactivate-rootkit/)*
    |'
- en: '|  | **Mebromi, 2011**The first BIOS bootkit detected in the wild, Mebromi
    uses ideas similar to IceLord | “Mebromi: The First BIOS Rootkit in the Wild,”
    *[https://www.webroot.com/blog/2011/09/13/mebromi-the-first-bios-rootkit-in-the-wild/](https://www.webroot.com/blog/2011/09/13/mebromi-the-first-bios-rootkit-in-the-wild/)*
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  | **Mebromi, 2011**首个在野外被发现的BIOS引导工具，Mebromi使用的思路类似于IceLord | “Mebromi：首个在野外发现的BIOS
    Rootkit，” *[https://www.webroot.com/blog/2011/09/13/mebromi-the-first-bios-rootkit-in-the-wild/](https://www.webroot.com/blog/2011/09/13/mebromi-the-first-bios-rootkit-in-the-wild/)*
    |'
- en: '| **Rakshasa, 2012**The PoC of a persistent BIOS rootkit, presented by Jonathan
    Brossard at Black Hat |  |  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **Rakshasa, 2012**一个持久性BIOS根工具的PoC，由Jonathan Brossard在Black Hat上展示 |  |  |'
- en: '| **DreamBoot, 2013**The first public PoC of a UEFI bootkit | **BadBIOS, 2013**An
    alleged persistent BIOS rootkit, reported by Dragos Ruiu | “UEFI and Dreamboot,”
    HiTB 2013, *[https://conference.hitb.org/hitbsecconf2013ams/materials/D2T1%20-%20Sebastien%20Kaczmarek%20-%20Dreamboot%20UEFI%20Bootkit.pdf](https://conference.hitb.org/hitbsecconf2013ams/materials/D2T1%20-%20Sebastien%20Kaczmarek%20-%20Dreamboot%20UEFI%20Bootkit.pdf)*“Meet
    ‘badBIOS,’ the Mysterious Mac and PC Malware That Jumps Airgaps,” *[https://arstechnica.com/information-technology/2013/10/meet-badbios-the-mysterious-mac-and-pc-malware-that-jumps-airgaps/](https://arstechnica.com/information-technology/2013/10/meet-badbios-the-mysterious-mac-and-pc-malware-that-jumps-airgaps/)*
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **DreamBoot, 2013**UEFI引导工具的首个公开PoC | **BadBIOS, 2013**据称是一个持久性BIOS根工具，由Dragos
    Ruiu报告 | “UEFI和Dreamboot，”HiTB 2013，* [https://conference.hitb.org/hitbsecconf2013ams/materials/D2T1%20-%20Sebastien%20Kaczmarek%20-%20Dreamboot%20UEFI%20Bootkit.pdf](https://conference.hitb.org/hitbsecconf2013ams/materials/D2T1%20-%20Sebastien%20Kaczmarek%20-%20Dreamboot%20UEFI%20Bootkit.pdf)*
    “认识‘badBIOS’，这个神秘的Mac和PC恶意软件能够跨越空气隔离，” *[https://arstechnica.com/information-technology/2013/10/meet-badbios-the-mysterious-mac-and-pc-malware-that-jumps-airgaps/](https://arstechnica.com/information-technology/2013/10/meet-badbios-the-mysterious-mac-and-pc-malware-that-jumps-airgaps/)*
    |'
- en: '| **x86 Memory bootkit, 2013**UEFI-based in-memory bootkit PoC |  | “x86 Memory
    Bootkit,” *[https://github.com/AaLl86/retroware/tree/master/MemoryBootkit](https://github.com/AaLl86/retroware/tree/master/MemoryBootkit)*
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **x86 Memory bootkit, 2013**基于UEFI的内存引导工具PoC |  | “x86内存引导工具，” *[https://github.com/AaLl86/retroware/tree/master/MemoryBootkit](https://github.com/AaLl86/retroware/tree/master/MemoryBootkit)*
    |'
- en: '| **Secure Boot bypass from BIOS, 2013**The first bypass of Secure Boot for
    Microsoft Windows 8 made public |  | “A Tale of One Software Bypass of Windows
    8 Secure Boot,” Black Hat 2013, *[http://c7zero.info/stuff/Windows8SecureBoot_Bulygin-Furtak-Bazhniuk_BHUSA2013.pdf](http://c7zero.info/stuff/Windows8SecureBoot_Bulygin-Furtak-Bazhniuk_BHUSA2013.pdf)*
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **从BIOS绕过安全启动，2013**首次公开了绕过Microsoft Windows 8安全启动的技术 |  | “Windows 8安全启动软件绕过的故事，”
    Black Hat 2013， *[http://c7zero.info/stuff/Windows8SecureBoot_Bulygin-Furtak-Bazhniuk_BHUSA2013.pdf](http://c7zero.info/stuff/Windows8SecureBoot_Bulygin-Furtak-Bazhniuk_BHUSA2013.pdf)*
    |'
- en: '| **Implementation and implications of a stealth hard drive backdoor, 2013**Jonas
    Zaddach et al. demonstrate a PoC of a hard drive firmware backdoor |  | “Implementation
    and implications of a stealth hard drive backdoor,” Annual Computer Security Applications
    Conference (ACSAC) 2013, *[http://www.syssec-project.eu/m/page-media/3/acsac13_zaddach.pdf](http://www.syssec-project.eu/m/page-media/3/acsac13_zaddach.pdf)*
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **隐秘硬盘后门的实现及其影响，2013**Jonas Zaddach等人演示了硬盘固件后门的概念验证 |  | “隐秘硬盘后门的实现及其影响，”年度计算机安全应用大会（ACSAC）2013，
    *[http://www.syssec-project.eu/m/page-media/3/acsac13_zaddach.pdf](http://www.syssec-project.eu/m/page-media/3/acsac13_zaddach.pdf)*
    |'
- en: '| **Darth Venamis, 2014**Rafal Wojtczuk and Corey Kallenberg discovered an
    S3BootSript vulnerability (VU#976132) | First reports of an allegedly state-sponsored
    SMM-based implant are published | “VU#976132,” *[https://www.kb.cert.org/vuls/id/976132/](https://www.kb.cert.org/vuls/id/976132/)*
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **Darth Venamis，2014**Rafal Wojtczuk和Corey Kallenberg发现了S3BootSript漏洞（VU#976132）
    | 首次公开涉嫌国家支持的基于SMM的植入程序的报告 | “VU#976132，” *[https://www.kb.cert.org/vuls/id/976132/](https://www.kb.cert.org/vuls/id/976132/)*
    |'
- en: '| **Thunderstrike, 2014**Attack on Apple devices with a malicious Option ROM
    over the Thunderbolt port, presented by Trammell Hudson at the 31C3 conference
    |  | “Thunderstrike: EFI Bootkits for Apple MacBooks,” *[https://events.ccc.de/congress/2014/Fahrplan/events/6128.html](https://events.ccc.de/congress/2014/Fahrplan/events/6128.html)*
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **雷击攻击，2014**通过Thunderbolt端口利用恶意Option ROM攻击Apple设备，由Trammell Hudson在31C3会议上展示
    |  | “雷击：针对Apple MacBook的EFI Bootkit，” *[https://events.ccc.de/congress/2014/Fahrplan/events/6128.html](https://events.ccc.de/congress/2014/Fahrplan/events/6128.html)*
    |'
- en: '| **LightEater, 2015**A UEFI-based rootkit that demonstrates how to expose
    sensitive information from the memory in firmware, presented by Corey Kallenberg
    and Xeno Kovah | **Hacking Team rkloader, 2015**The first known commercial-grade
    UEFI firmware bootkit leak, revealed by Hacking Team rkloader |  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **LightEater，2015**基于UEFI的rootkit，演示了如何从固件中的内存中暴露敏感信息，由Corey Kallenberg和Xeno
    Kovah展示 | **Hacking Team rkloader，2015**首次公开的商业级UEFI固件bootkit泄露，由Hacking Team
    rkloader揭示 |  |'
- en: '| **SmmBackdoor, 2015**The first public PoC of a UEFI firmware bootkit, released
    with source code on GitHub |  | “Building Reliable SMM Backdoor for UEFI-Based
    Platforms,” *[http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html](http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html)*
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **SmmBackdoor，2015**首次公开的UEFI固件bootkit的概念验证，源代码发布在GitHub上 |  | “为UEFI平台构建可靠的SMM后门，”
    *[http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html](http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html)*
    |'
- en: '| **Thunderstrike2, 2015**A demonstration of a mixed attack approach using
    Darth Venamis and Thunderstrike exploits |  | “Thunderstrike 2: Sith Strike—A
    MacBook Firmware Worm,” Black Hat 2015, *[http://legbacore.com/Research_files/ts2-blackhat.pdf](http://legbacore.com/Research_files/ts2-blackhat.pdf)*
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **Thunderstrike2，2015**展示了一种混合攻击方法，结合了Darth Venamis和Thunderstrike漏洞 |  |
    “雷击2：西斯之击——MacBook固件蠕虫，” Black Hat 2015， *[http://legbacore.com/Research_files/ts2-blackhat.pdf](http://legbacore.com/Research_files/ts2-blackhat.pdf)*
    |'
- en: '| **Memory Sinkhole, 2015**A vulnerability that existed in the Advanced Programmable
    Interrupt Controller (APIC) and could allow an attacker to target the SMM memory
    area used by the OS, discovered by Christopher Domas; an attacker could exploit
    this vulnerability to install a rootkit |  | “The Memory Sinkhole,” Black Hat
    2015, *[https://github.com/xoreaxeaxeax/sinkhole/](https://github.com/xoreaxeaxeax/sinkhole/)*
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **Memory Sinkhole，2015**存在于高级可编程中断控制器（APIC）中的漏洞，攻击者可以利用该漏洞攻击操作系统使用的SMM内存区域，发现者为Christopher
    Domas；攻击者可以利用该漏洞安装rootkit |  | “内存陷阱，” Black Hat 2015， *[https://github.com/xoreaxeaxeax/sinkhole/](https://github.com/xoreaxeaxeax/sinkhole/)*
    |'
- en: '| **Privilege escalation from SMM to VMM, 2015**A group of Intel researchers
    presented a PoC of privilege escalation from SMM to hypervisor and demonstrated
    the PoC for exposing memory regions protected by VMM on MS Hyper-V and Xen |  |
    “Attacking Hypervisors via Firmware and Hardware,” Black Hat 2015, *[http://2015.zeronights.org/assets/files/10-Matrosov.pdf](http://2015.zeronights.org/assets/files/10-Matrosov.pdf)*
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **提权从SMM到VMM，2015**一组英特尔研究人员提出了从SMM到hypervisor的提权PoC，并演示了在MS Hyper-V和Xen上暴露VMM保护内存区域的PoC
    |  | “通过固件和硬件攻击Hypervisor”，Black Hat 2015，*[http://2015.zeronights.org/assets/files/10-Matrosov.pdf](http://2015.zeronights.org/assets/files/10-Matrosov.pdf)*
    |'
- en: '| **PeiBackdoor, 2016**The first publicly released PoC of a UEFI rootkit that
    operated at the PEI (Pre-EFI Initialization) phase of boot; released with source
    code on GitHub | **Cisco router-targeting implant, 2016**Reports of an allegedly
    state-sponsored implant for Cisco router BIOS | “PeiBackdoor,” *[https://github.com/Cr4sh/PeiBackdoor/](https://github.com/Cr4sh/PeiBackdoor/)*
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **PeiBackdoor, 2016**第一个公开发布的在启动的PEI（Pre-EFI Initialization）阶段操作的UEFI rootkit
    PoC；在GitHub上发布了源代码 | **Cisco路由器定向植入物，2016**据称是面向Cisco路由器BIOS的国家赞助植入物的报道 | “PeiBackdoor”，*[https://github.com/Cr4sh/PeiBackdoor/](https://github.com/Cr4sh/PeiBackdoor/)*
    |'
- en: '| **ThinkPwn, 2016**A privilege escalation vulnerability, promoting to SMM;
    originally discovered on the ThinkPad series of laptops by Dmytro Oleksiuk, also
    known as Cr4sh |  | “Exploring and Exploiting Lenovo Firmware Secrets,” *[http://blog.cr4.sh/2016/06/exploring-and-exploiting-lenovo.html](http://blog.cr4.sh/2016/06/exploring-and-exploiting-lenovo.html)*
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **ThinkPwn, 2016**提权漏洞，晋升至SMM；最初由Dmytro Oleksiuk，也被称为Cr4sh，在ThinkPad系列笔记本上发现
    |  | “探索和利用联想固件秘密”，*[http://blog.cr4.sh/2016/06/exploring-and-exploiting-lenovo.html](http://blog.cr4.sh/2016/06/exploring-and-exploiting-lenovo.html)*
    |'
- en: '|  | **MacBook-targeting implant, 2017**Reports of an allegedly state-sponsored
    UEFI implant targeting Apple laptops |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  | **MacBook定向植入物，2017**据称是面向苹果笔记本的国家赞助UEFI植入物的报道 |  |'
- en: '|  | **Lojax implant, 2018**UEFI rootkit discovered in the wild by ESET researchers
    | “LOJAX,” *[https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf](https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf)*
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|  | **Lojax植入物，2018**ESET研究人员在野外发现的UEFI rootkit | “LOJAX”，*[https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf](https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf)*
    |'
- en: BIOS firmware has always been a challenging target for researchers, due to both
    lack of information and the difficulty of modifying or instrumenting the BIOS
    by adding new code to execute during the boot process. But since 2013, we’ve seen
    a larger effort from the security research community to find new exploits and
    to demonstrate weaknesses and attacks on recently introduced security features,
    such as Secure Boot.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS固件一直是研究人员的一个挑战目标，这既因为信息缺乏，也因为在启动过程中添加新代码来修改或调节BIOS的难度。但自2013年以来，我们看到安全研究社区在寻找新漏洞并展示最近引入的安全功能（如安全启动）方面做出了更大的努力。
- en: Looking at the evolution of real BIOS malware, you may notice that very few
    BIOS threat PoCs actually became a trend for firmware-based implants, and most
    were used for targeted attacks. We’ll focus here on approaches to infecting the
    BIOS with a persistent rootkit that can survive not only reboots of the operating
    system but also any changes to hardware (except the motherboard) with a flash
    memory–infected BIOS firmware. Multiple media reports of UEFI implants being available
    to state-sponsored actors suggest that these implants are a technical reality
    and have been for a considerable time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 查看实际BIOS恶意软件的发展，您可能会注意到，很少有BIOS威胁PoC实际上成为固件基础植入物的趋势，大多数用于定向攻击。我们将在这里重点讨论感染BIOS的持久rootkit的方法，该rootkit不仅可以在操作系统重新启动时生存，而且还可以在具有感染的固件的BIOS中进行任何硬件更改（除了主板）。多个媒体报道显示，国家赞助的行动者可用的UEFI植入物表明，这些植入物是技术上的现实，并且已经存在相当长的时间。
- en: '**All Hardware Has Firmware**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**所有硬件都有固件**'
- en: Before we start digging into the specifics of UEFI rootkits and bootkits, let’s
    take a look at modern x86 hardware and how different kinds of firmware are stored
    inside. These days, all hardware comes with some firmware; even laptop batteries
    have firmware that’s updated by the operating system to allow for more accurate
    measurement of battery parameters and usage.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入研究UEFI rootkit和bootkit的具体细节之前，让我们先看看现代x86硬件及其内部存储的不同类型固件。如今，所有硬件都带有一些固件；甚至笔记本电脑电池也有固件，由操作系统更新以实现更准确的电池参数和使用情况测量。
- en: '**NOTE**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Charlie Miller was the first researcher to publicly focus on laptop batteries.
    He presented the talk “Battery Firmware Hacking”* ([https://media.blackhat.com/bh-us-11/Miller/BH_US_11_Miller_Battery_Firmware_Public_Slides.pdf](https://media.blackhat.com/bh-us-11/Miller/BH_US_11_Miller_Battery_Firmware_Public_Slides.pdf))
    *at Black Hat 2011.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*查理·米勒是第一位公开关注笔记本电池的研究人员。他在2011年黑帽大会上发表了名为“电池固件黑客攻击”的演讲* ([https://media.blackhat.com/bh-us-11/Miller/BH_US_11_Miller_Battery_Firmware_Public_Slides.pdf](https://media.blackhat.com/bh-us-11/Miller/BH_US_11_Miller_Battery_Firmware_Public_Slides.pdf))
    *。'
- en: 'Each piece of firmware is an area where an attacker can store and execute code
    and is thus an opportunity for a malicious implant. Most modern desktops and laptops
    have the following kinds of firmware:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每一块固件都是攻击者可以存储和执行代码的区域，因此也是恶意植入的机会。大多数现代桌面和笔记本电脑拥有以下几种类型的固件：
- en: UEFI firmware (BIOS) Manageability Engine firmware (Intel ME, for instance)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UEFI固件（BIOS）管理引擎固件（例如，英特尔ME）
- en: Hard drive firmware (HDD/SSD)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬盘固件（HDD/SSD）
- en: Peripheral device firmware (for example, network adapters)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外设设备固件（例如，网络适配器）
- en: Graphics card firmware (GPU)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显卡固件（GPU）
- en: Despite many apparent attack vectors, firmware attacks are not common among
    cybercrime perpetrators, who tend to prefer attacks that can target a broad range
    of victims. Because firmware tends to vary from system to system, most known incidents
    of firmware compromise have been targeted attacks rather than PoCs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在许多明显的攻击途径，固件攻击在网络犯罪分子中并不常见，因为他们更倾向于选择能够针对广泛受害者的攻击。由于固件在不同系统之间存在差异，大多数已知的固件泄漏事件都是针对性的攻击，而非概念验证攻击（PoC）。
- en: For example, the first hard drive firmware implant found in the wild was discovered
    by Kaspersky Lab researchers in early 2015\. Kaspersky dubbed the creators of
    this malware the *Equation Group* and classified them as a state-level threat
    actor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第一个在野外发现的硬盘固件植入是由卡巴斯基实验室的研究人员在2015年初发现的。卡巴斯基将这种恶意软件的创作者称为*方程组*并将其分类为国家级威胁行为者。
- en: According to Kaspersky Lab, the malware they discovered had the ability to infect
    specific hard drive models, including some very common brands. None of the target
    drive models had authentication requirements for firmware updates, which is what
    made such an attack feasible.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据卡巴斯基实验室的说法，他们发现的恶意软件具备感染特定硬盘型号的能力，包括一些非常常见的品牌。所有目标硬盘型号都没有固件更新的认证要求，这也是这种攻击得以实施的原因。
- en: In this attack, the hard drive infection module *nls933w.dll*, detected by Kaspersky
    as *Trojan.Win32.EquationDrug.c*, delivered modified firmware over the *Advanced
    Technology Attachment (ATA)* storage device connection commands interface. Accessing
    ATA commands allowed attackers to reprogram or update HDD/SSD firmware, with only
    weak update verification or authentication required. This kind of firmware implant
    can spoof the disk sectors at the firmware level or modify data streams by intercepting
    read or write requests to, for example, deliver modified versions of the MBR.
    These hard drive firmware implants are low in the firmware stack and therefore
    very difficult to detect.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次攻击中，卡巴斯基检测到的硬盘感染模块*nls933w.dll*，被标记为*Trojan.Win32.EquationDrug.c*，通过*高级技术附件（ATA）*存储设备连接命令接口传送了修改过的固件。访问ATA命令允许攻击者重新编程或更新硬盘（HDD）/固态硬盘（SSD）固件，只需进行非常简单的更新验证或认证。这种固件植入可以在固件层面伪造磁盘扇区，或者通过拦截读写请求来修改数据流，例如传送修改版的MBR。这些硬盘固件植入位于固件栈的低层，因此非常难以检测。
- en: Firmware-targeting malware generally delivers firmware implants by reflashing
    malicious firmware updates via the normal OS update process. This means it mostly
    affects the hard drives that don’t support authentication for firmware updates,
    instead just setting up new firmware as is. In the following sections, we’ll focus
    on UEFI-based rootkits and implants, but it’s useful to know that the BIOS isn’t
    the only place for developing persistent firmware implants.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 针对固件的恶意软件通常通过正常的操作系统更新过程重新闪存恶意固件更新，从而进行固件植入。这意味着它主要影响那些不支持固件更新认证的硬盘，而是直接设置新的固件。接下来的部分，我们将重点讨论基于UEFI的根套件和植入物，但了解BIOS并不是唯一可以开发持久固件植入的地方，也是很有用的。
- en: '***UEFI Firmware Vulnerabilities***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***UEFI固件漏洞***'
- en: 'Discussions and examples of different types of vulnerabilities in modern operating
    systems are plentiful online, but discussions of UEFI firmware vulnerabilities
    are much rarer. Here we’ll list the kinds of rootkit-relevant vulnerabilities
    that have been publicly disclosed over the past few years. Most are memory corruption
    and SMM callout vulnerabilities that can lead to arbitrary code execution when
    the CPU is in SMM. An attacker can use these types of vulnerabilities to bypass
    BIOS protection bits and achieve arbitrary writes to and reads from the SPI flash
    memory regions on some systems. We’ll go into more detail in [Chapter 16](ch16.xhtml#ch16),
    but here are a couple of representative highlights:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统中关于不同类型漏洞的讨论和示例在网上有很多，但关于UEFI固件漏洞的讨论却较为罕见。在这里，我们将列出过去几年公开披露的与rootkit相关的漏洞类型。大多数是内存损坏和SMM调用漏洞，当CPU处于SMM模式时，这些漏洞可能导致任意代码执行。攻击者可以利用这些漏洞绕过BIOS保护位，从而实现对某些系统上SPI闪存区域的任意写入和读取。我们将在[第16章](ch16.xhtml#ch16)中详细介绍，但这里有几个具有代表性的重点：
- en: '**ThinkPwn (LEN-8324)** An arbitrary SMM code execution exploit for multiple
    BIOS vendors. This vulnerability allows an attacker to disable flash write protections
    and modify platform firmware.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**ThinkPwn (LEN-8324)** 一个针对多个BIOS厂商的任意SMM代码执行漏洞。此漏洞允许攻击者禁用闪存写保护，并修改平台固件。'
- en: '**Aptiocalypsis (INTEL-SA-00057)** An arbitrary SMM code execution exploit
    for AMI-based firmware that allows an attacker to disable flash write protection
    bits and modify platform firmware.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Aptiocalypsis (INTEL-SA-00057)** 一个针对基于AMI固件的任意SMM代码执行漏洞，允许攻击者禁用闪存写保护位并修改平台固件。'
- en: Any of these issues can allow an attacker to install persistent rootkits or
    implants into the victim hardware. Many of these kinds of vulnerabilities rely
    either on the attacker being able to bypass memory protection bits or on the bits
    not being enabled or effective.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些问题都可能允许攻击者将持久的rootkit或植入物安装到受害者硬件中。许多这类漏洞依赖于攻击者能够绕过内存保护位，或者依赖于这些位没有启用或没有效果。
- en: '***(In)Effectiveness of Memory Protection Bits***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***(内)存保护位的有效性***'
- en: 'Most common technologies that protect the SPI flash from arbitrary writes are
    based on *memory protection bits*, a fairly old defense approach introduced by
    Intel decade ago. Memory protection bits are the only kind of protection available
    for cheap UEFI-based hardware used in the Internet of Things (IoT) market. An
    SMM vulnerability that enables attackers to gain privileges to access SMM and
    execute arbitrary code will allow the attacker to change those bits. Let’s look
    at the bits more closely:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 保护SPI闪存免受任意写入的最常见技术基于*内存保护位*，这是一种相当古老的防御方法，Intel十年前就引入了这一方法。内存保护位是便宜的基于UEFI的硬件在物联网（IoT）市场中唯一可用的保护手段。一个允许攻击者获得SMM访问权限并执行任意代码的SMM漏洞将使攻击者能够更改这些位。让我们更仔细地看看这些位：
- en: '**BIOSWE** The BIOS Write Enable bit, usually set up as `0` and changed to
    `1` by SMM to authenticate firmware or allow an update.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**BIOSWE** BIOS写使能位，通常设置为`0`，并由SMM更改为`1`以验证固件或允许更新。'
- en: '**BLE** The BIOS Lock Enable bit, which should be set to `1` by default to
    protect from arbitrary modification of the SPI flash BIOS regions. This bit can
    be changed by an attacker with SMM privileges.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**BLE** BIOS锁定使能位，默认应设置为`1`以防止对SPI闪存BIOS区域的任意修改。此位可被具有SMM权限的攻击者更改。'
- en: '**SMM_BWP** The SMM BIOS Write Protection bit should be set to `1` to protect
    SPI flash memory from writes outside of SMM. In 2015, researchers Corey Kallenberg
    and Rafal Wojtczuk found a race condition vulnerability (VU#766164) in which this
    unset bit could lead to the disabling of the BLE bit.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**SMM_BWP** SMM BIOS写保护位应设置为`1`以防止SPI闪存内存被SMM以外的方式写入。2015年，研究人员Corey Kallenberg和Rafal
    Wojtczuk发现了一个竞态条件漏洞（VU#766164），该漏洞使得此位未设置时，可能导致BLE位被禁用。'
- en: '**PRx** SPI Protected Ranges (PR registers PR0–PR5) do not protect the entire
    BIOS region from modifications, but they offer some flexibility for configuring
    specific BIOS regions with the ability to read or write policies. The PR registers
    are protected from arbitrary changes by SMM. If all security bits are set and
    PR registers are configured correctly, it can be incredibly difficult for attackers
    to modify SPI flash.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRx** SPI受保护区域（PR寄存器PR0–PR5）并不保护整个BIOS区域免受修改，但它们为配置特定的BIOS区域提供了一定的灵活性，并能设置读取或写入策略。PR寄存器受到SMM的保护，防止任意修改。如果所有安全位都已设置，并且PR寄存器配置正确，那么攻击者修改SPI闪存将变得非常困难。'
- en: These security bits are set up in the DXE stage, which we discussed in [Chapter
    14](ch14.xhtml#ch14). If you’re curious, you can find an example of platform initialization
    stage code in the Intel EDK2 GitHub repository.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些安全位在DXE阶段设置，我们在[第14章](ch14.xhtml#ch14)中讨论过这一点。如果你感兴趣，可以在Intel EDK2的GitHub仓库中找到平台初始化阶段代码的示例。
- en: '***Checks for Protection Bits***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查保护位***'
- en: We can check whether BIOS protection bits are enabled and effective by using
    a platform for security assessment named *Chipsec*, developed and open sourced
    by the Intel Security Center of Excellence (now known as IPAS, Intel Product Assurance
    and Security).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用一个名为*Chipsec*的安全评估平台来检查BIOS保护位是否已启用且有效，*Chipsec*由Intel安全卓越中心（现称为IPAS，Intel产品保障与安全）开发并开源。
- en: We’ll be examining Chipsec from a forensic perspective in [Chapter 19](ch19.xhtml#ch19),
    but for now, we’ll use just the `bios_wp` module (*[https://github.com/chipsec/chipsec/blob/master/chipsec/modules/common/bios_wp.py](https://github.com/chipsec/chipsec/blob/master/chipsec/modules/common/bios_wp.py)*),
    which checks that the protections are correctly configured and protect the BIOS.
    The `bios_wp` module reads the actual values of the protection bits and outputs
    the status of SPI flash protection, warning the user if it is misconfigured.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第19章](ch19.xhtml#ch19)中从法医角度检查Chipsec，但现在，我们只使用`bios_wp`模块（* [https://github.com/chipsec/chipsec/blob/master/chipsec/modules/common/bios_wp.py](https://github.com/chipsec/chipsec/blob/master/chipsec/modules/common/bios_wp.py)*），该模块检查保护是否正确配置并保护BIOS。`bios_wp`模块读取保护位的实际值，并输出SPI闪存保护的状态，如果配置错误，则警告用户。
- en: 'To use the `bios_wp` module, install Chipsec and then run it with the following
    command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`bios_wp`模块，首先安装Chipsec，然后运行以下命令：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As an example, we performed this check on a vulnerable platform based on MSI
    Cubi2 with an Intel seventh-generation CPU on board, which was fairly new hardware
    at the time of this writing. The output from this check is shown in [Listing 15-1](ch15.xhtml#ch15list01).
    The UEFI firmware of Cubi2 is based on AMI’s framework.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们在一个基于MSI Cubi2且搭载Intel第七代CPU的易受攻击平台上进行了此检查，这款硬件在撰写本文时相对较新。此检查的输出结果见于[清单
    15-1](ch15.xhtml#ch15list01)。Cubi2的UEFI固件基于AMI的框架。
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 15-1: Chipsec tool output from the module `common.bios_wp`*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-1：来自模块`common.bios_wp`的Chipsec工具输出*'
- en: The output shows that the `BLE` ➊ is not enabled, meaning an attacker can modify
    any BIOS memory region on the SPI flash chip directly from the kernel mode of
    a regular OS. Additionally, `SMM_BWP` ➋ and `PRx` ➌ are not being used at all,
    suggesting that this platform does not have any SPI flash memory protections.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果显示`BLE` ➊没有启用，这意味着攻击者可以直接从常规操作系统的内核模式修改SPI闪存芯片上的任何BIOS内存区域。此外，`SMM_BWP`
    ➋和`PRx` ➌完全未使用，这表明该平台没有任何SPI闪存内存保护。
- en: 'If the BIOS updates for the platform tested in [Listing 15-1](ch15.xhtml#ch15list01)
    are not signed, or the hardware vendor doesn’t authenticate updates properly,
    an attacker can easily modify firmware with a malicious BIOS update. It may seem
    like an anomaly, but these kinds of simple mistakes are actually fairly common.
    The reasons vary: some vendors just don’t care about security, while others are
    aware of security problems but don’t want to develop complex update schemes for
    cheap hardware. Let’s now look at some other ways of infecting the BIOS.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在[清单 15-1](ch15.xhtml#ch15list01)中测试的平台的BIOS更新没有签名，或者硬件供应商没有正确地验证更新，攻击者就可以轻松通过恶意的BIOS更新修改固件。这看起来可能像一个异常，但实际上这类简单的错误相当常见。原因各异：有些供应商根本不关心安全性，而另一些则意识到安全问题，但不想为廉价硬件开发复杂的更新方案。现在让我们看看其他几种感染BIOS的方式。
- en: '**Ways to Infect the BIOS**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**感染BIOS的方式**'
- en: We examined the complex and multifaceted UEFI boot process in [Chapter 14](ch14.xhtml#ch14).
    The takeaway from that chapter for our current discussion is that, before the
    UEFI firmware transfers control to the operating system loader and the OS starts
    booting, there are a lot of places for an attacker to hide or infect the system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第14章](ch14.xhtml#ch14)中检查了复杂且多面的UEFI启动过程。对于我们当前讨论的要点，来自那一章的收获是，在UEFI固件将控制权交给操作系统加载器并启动操作系统之前，攻击者有很多机会隐藏或感染系统。
- en: In fact, modern UEFI firmware increasingly looks like an operating system of
    its own. It has its own network stack and a task scheduler, and it can communicate
    directly with physical devices outside of the boot process—for example, many devices
    communicate with the OS via the UEFI DXE drivers. [Figure 15-3](ch15.xhtml#ch15fig03)
    shows what a firmware infection might look like through the different boot stages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，现代 UEFI 固件越来越像一个独立的操作系统。它有自己的网络堆栈和任务调度器，并且可以在引导过程之外直接与物理设备通信——例如，许多设备通过
    UEFI DXE 驱动程序与操作系统通信。[图 15-3](ch15.xhtml#ch15fig03) 显示了固件感染在不同引导阶段可能的表现。
- en: '![image](../images/15fig03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig03.jpg)'
- en: '*Figure 15-3: UEFI firmware boot flow with attack pointers*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-3：带有攻击指针的 UEFI 固件启动流程*'
- en: 'Over the years, security researchers have identified many vulnerabilities that
    allow an attacker to modify the boot process with additional malicious code. As
    of today, most of these have been fixed, but some hardware—even new hardware—can
    still be vulnerable to those old issues. The following are different ways to infect
    UEFI firmware with a persistent rootkit or implant:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，安全研究人员已识别出许多漏洞，允许攻击者修改引导过程并添加恶意代码。到今天为止，大多数这些漏洞已经被修复，但一些硬件——甚至是新硬件——仍然可能容易受到这些旧问题的影响。以下是感染
    UEFI 固件并植入持久性 rootkit 的不同方式：
- en: '**Modifying an unsigned UEFI Option ROM** An attacker can modify a UEFI DXE
    driver in some add-on cards (used for networks, storage, and so forth) to allow
    malicious code execution at the DXE stage.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改未签名的 UEFI 选项 ROM** 攻击者可以修改某些附加卡（用于网络、存储等）中的 UEFI DXE 驱动程序，以便在 DXE 阶段执行恶意代码。'
- en: '**Adding/modifying a DXE driver** An attacker can modify an existing DXE driver
    or add malicious DXE drivers to the UEFI firmware image. As a result, the added/modified
    DXE driver will be executed at the DXE stage.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加/修改 DXE 驱动程序** 攻击者可以修改现有的 DXE 驱动程序或向 UEFI 固件镜像中添加恶意的 DXE 驱动程序。结果是，添加/修改的
    DXE 驱动程序将在 DXE 阶段执行。'
- en: '**Replacing the Windows Boot Manager (fallback bootloader)** An attacker can
    replace the boot manager (fallback bootloader) on the EFI system partition (ESP)
    of the hard drive (*ESP\EFI\Microsoft\Boot\bootmgfw.efi* or *ESP\EFI\ BOOT\bootx64.efi*)
    to take over code execution at the point when the UEFI firmware transfers control
    to the OS bootloader.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**替换 Windows 启动管理器（后备引导加载程序）** 攻击者可以替换硬盘的 EFI 系统分区（ESP）上的引导管理器（后备引导加载程序）（*ESP\EFI\Microsoft\Boot\bootmgfw.efi*
    或 *ESP\EFI\ BOOT\bootx64.efi*），以在 UEFI 固件将控制权交给操作系统引导加载程序时接管代码执行。'
- en: '**Adding a new bootloader (*bootkit.efi*)** An attacker can add another bootloader
    to the list of the available bootloaders by modifying the `BootOrder`/`Boot`####
    EFI variables, which determine the order of OS bootloaders.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加新的引导加载程序（*bootkit.efi*）** 攻击者可以通过修改 `BootOrder`/`Boot`#### EFI 变量，向可用引导加载程序列表中添加另一个引导加载程序，这些变量决定操作系统引导加载程序的顺序。'
- en: Of these methods, the first two are the most interesting in the context of this
    chapter, as they execute malicious code during the UEFI DXE phase; these are the
    two we’ll look at in more detail. The last two methods—though related to UEFI
    boot process—focus on attacking OS bootloaders and executing malicious code after
    UEFI firmware execution, so we won’t discuss them further here.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法中，前两种方法在本章的上下文中最为有趣，因为它们会在 UEFI DXE 阶段执行恶意代码；这两种方法我们将更详细地讨论。最后两种方法——尽管与
    UEFI 启动过程相关——专注于攻击操作系统引导加载程序，并在 UEFI 固件执行后执行恶意代码，因此我们在这里不再进一步讨论它们。
- en: '***Modifying an Unsigned UEFI Option ROM***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改未签名的 UEFI 选项 ROM***'
- en: An *Option ROM* is PCI/PCIe expansion firmware (ROM) in x86 code located on
    a PCI-compatible device. An Option ROM is loaded, configured, and executed during
    the boot process. John Heasman first revealed Option ROMs as an entry point for
    stealth rootkit infection in 2007 at the Black Hat conference (refer back to [Table
    15-1](ch15.xhtml#ch15tab01)). Then, in 2012, a hacker known as Snare introduced
    a variety of techniques for infecting Apple laptops, including through Option
    ROMs (*[http://ho.ax/downloads/De_Mysteriis_Dom_Jobsivs_Black_Hat_Slides.pdf](http://ho.ax/downloads/De_Mysteriis_Dom_Jobsivs_Black_Hat_Slides.pdf)*).
    At Black Hat 2015, presenters Trammell Hudson, Xeno Kovah, and Corey Kallenberg
    demonstrated an attack named *Thunderstrike* that infiltrated the Apple Ethernet
    adapter with modified firmware that loaded malicious code (*[https://www.blackhat.com/docs/us-15/materials/us-15-Hudson-Thunderstrike-2-Sith-Strike.pdf](https://www.blackhat.com/docs/us-15/materials/us-15-Hudson-Thunderstrike-2-Sith-Strike.pdf)*).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*选项 ROM* 是位于 PCI 兼容设备上的 x86 代码中的 PCI/PCIe 扩展固件（ROM）。选项 ROM 在启动过程中被加载、配置并执行。John
    Heasman 在 2007 年的 Black Hat 大会上首次揭示了选项 ROM 作为潜伏 rootkit 感染的入口点（参见 [表 15-1](ch15.xhtml#ch15tab01)）。随后，在
    2012 年，一位名为 Snare 的黑客介绍了多种通过选项 ROM 感染 Apple 笔记本电脑的技术（* [http://ho.ax/downloads/De_Mysteriis_Dom_Jobsivs_Black_Hat_Slides.pdf](http://ho.ax/downloads/De_Mysteriis_Dom_Jobsivs_Black_Hat_Slides.pdf)
    *）。在 2015 年的 Black Hat 大会上，演讲者 Trammell Hudson、Xeno Kovah 和 Corey Kallenberg 演示了一种名为
    *Thunderstrike* 的攻击，通过修改固件渗透 Apple 以太网适配器并加载恶意代码（* [https://www.blackhat.com/docs/us-15/materials/us-15-Hudson-Thunderstrike-2-Sith-Strike.pdf](https://www.blackhat.com/docs/us-15/materials/us-15-Hudson-Thunderstrike-2-Sith-Strike.pdf)
    *）。'
- en: An Option ROM contains a PE image that’s a specific DXE driver for the PCI device.
    In Intel’s open source EDK2 kit (*[https://github.com/tianocore/edk2/](https://github.com/tianocore/edk2/)*),
    you can find code that loads these DXE drivers; in the source code you’ll find
    the implementation of an Option ROM loader in *PciOptionRomSupport.h* in the folder
    *PciBusDxe*. [Listing 15-2](ch15.xhtml#ch15list02) shows the `LoadOpRomImage()`
    function of that code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 ROM 包含一个 PE 镜像，这是一个特定的 PCI 设备的 DXE 驱动程序。在英特尔的开源 EDK2 工具包中（* [https://github.com/tianocore/edk2/](https://github.com/tianocore/edk2/)
    *），你可以找到加载这些 DXE 驱动程序的代码；在源代码中，你会在 *PciOptionRomSupport.h* 文件中找到实现选项 ROM 加载器的代码，该文件位于
    *PciBusDxe* 文件夹内。[清单 15-2](ch15.xhtml#ch15list02) 显示了该代码中的 `LoadOpRomImage()`
    函数。
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 15-2: The `LoadOpRomImage()` routine from EDK2*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-2：EDK2 中的 `LoadOpRomImage()` 例程*'
- en: 'We see that the `LoadOpRomImage()` function receives two input parameters:
    a pointer to a PCI device instance ➊ and the address of the Option ROM image ➋.
    From this we can assume this function maps a ROM image into memory and prepares
    it for execution. The next function, `ProcessOpRomImage()`, is shown in [Listing
    15-3](ch15.xhtml#ch15list03).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 `LoadOpRomImage()` 函数接收两个输入参数：一个指向 PCI 设备实例的指针 ➊ 和选项 ROM 镜像的地址 ➋。由此我们可以推测，该函数将
    ROM 镜像映射到内存中并为执行做准备。下一个函数 `ProcessOpRomImage()` 如 [清单 15-3](ch15.xhtml#ch15list03)
    所示。
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 15-3: The `ProcessOpRomImage()` routine from EDK2*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-3：EDK2 中的 `ProcessOpRomImage()` 例程*'
- en: '`ProcessOpRomImage()` is responsible for starting the execution process for
    the specific device driver contained in the Option ROM. The creators of the Thunderstrike
    attack, which uses an Option ROM as its entry point, made their attack by modifying
    the Thunderbolt Ethernet adapter so that it would allow the connection of external
    peripherals. This adapter, developed by Apple and Intel, is based on the GN2033
    chip and provides the Thunderbolt interface. A disassembled Thunderbolt Ethernet
    adapter similar to the one used in the Thunderstrike exploit is shown in [Figure
    15-4](ch15.xhtml#ch15fig04).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessOpRomImage()` 负责启动选项 ROM 中包含的特定设备驱动程序的执行过程。使用选项 ROM 作为入口点的 Thunderstrike
    攻击者通过修改 Thunderbolt 以太网适配器，使其能够连接外部外设，从而发起攻击。该适配器由 Apple 和 Intel 开发，基于 GN2033
    芯片，提供 Thunderbolt 接口。[图 15-4](ch15.xhtml#ch15fig04) 显示了一个类似于 Thunderstrike 攻击中使用的
    Thunderbolt 以太网适配器的反汇编图。'
- en: '![image](../images/15fig04.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig04.jpg)'
- en: '*Figure 15-4: A disassembled Apple Thunderbolt Ethernet adapter*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：反汇编的 Apple Thunderbolt 以太网适配器*'
- en: Specifically, Thunderstrike loaded the original Option ROM driver with additional
    code that was then executed because the firmware didn’t authenticate the Option
    ROM’s extension driver during the boot process (this attack was demonstrated on
    Apple Macbooks but can be applied to other hardware as well). Apple fixed this
    issue in its hardware, but many other vendors could still be vulnerable to this
    type of attack.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，Thunderstrike 加载了原始的 Option ROM 驱动程序，并加入了额外的代码，随后该代码在固件没有对 Option ROM 扩展驱动程序进行身份验证的情况下被执行（此攻击在苹果
    MacBook 上演示过，但同样可以应用于其他硬件）。苹果在其硬件上修复了这个问题，但许多其他厂商仍然可能容易受到这种攻击。
- en: Many of the BIOS vulnerabilities listed in [Table 15-1](ch15.xhtml#ch15tab01)
    have been fixed in modern hardware and operating systems, such as more recent
    versions of Windows, where Secure Boot is activated by default when hardware and
    firmware can support it. We’ll discuss Secure Boot implementation approaches and
    weaknesses in more detail in [Chapter 17](ch17.xhtml#ch17), but for now it suffices
    to say that any loaded firmware or extension driver lacking serious authentication
    requirements can be a security problem. On modern enterprise hardware, third-party
    Option ROMs are usually blocked by default, but they can be reenabled in the BIOS
    management interface, as shown in [Figure 15-5](ch15.xhtml#ch15fig05).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-1](ch15.xhtml#ch15tab01)中列出的许多 BIOS 漏洞已经在现代硬件和操作系统中得到了修复，例如 Windows 的较新版本，当硬件和固件支持时，Secure
    Boot 默认启用。我们将在[第 17 章](ch17.xhtml#ch17)中更详细地讨论 Secure Boot 的实现方法和弱点，但目前可以简单地说，任何缺乏严格认证要求的加载固件或扩展驱动程序都可能成为安全问题。在现代企业硬件上，第三方
    Option ROM 通常默认被阻止，但可以在 BIOS 管理界面中重新启用，如[图 15-5](ch15.xhtml#ch15fig05)所示。'
- en: '![image](../images/15fig05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig05.jpg)'
- en: '*Figure 15-5: Blocking third-party Option ROMs in the BIOS management interface*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-5：在 BIOS 管理界面中阻止第三方 Option ROM*'
- en: 'After the release of the Thunderstrike PoC, some vendors, including Apple,
    have become more aggressive about blocking all unsigned or third-party Option
    ROMs. We believe this is the right policy: the circumstances under which you need
    to load a third-party Option ROM are rare, and blocking all Option ROMs from third-party
    devices significantly reduces security risks. If you’re using peripheral device
    extensions with Option ROMs on board, be sure to buy them from the same vendor
    as the device; buying a random one isn’t worth the risk.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Thunderstrike PoC 发布后，包括苹果在内的一些厂商变得更加积极地阻止所有未签名或第三方 Option ROM。我们认为这是正确的政策：需要加载第三方
    Option ROM 的情况很少，而且阻止所有第三方设备的 Option ROM 可以显著降低安全风险。如果你正在使用带有 Option ROM 的外设扩展，请确保从与设备相同的供应商处购买；购买随机的并不值得冒这个险。
- en: '***Adding or Modifying a DXE Driver***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加或修改 DXE 驱动程序***'
- en: 'Now let’s take a look at the second type of attack on our list: adding or modifying
    a DXE driver in a UEFI firmware image. In essence, this attack is pretty straightforward:
    by modifying a legitimate DXE driver in the firmware, an attacker is able to introduce
    malicious code that will be executed in the preboot environment, at the DXE stage.
    However, the most interesting (and probably the most complicated) part of this
    attack is adding or modifying the DXE driver, which involves an intricate chain
    of exploitations of vulnerabilities present in the UEFI firmware, operating system,
    and user-mode applications.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下列表中的第二种攻击类型：在 UEFI 固件映像中添加或修改 DXE 驱动程序。本质上，这种攻击相当简单：通过修改固件中的合法 DXE
    驱动程序，攻击者能够引入恶意代码，该代码将在预启动环境中的 DXE 阶段执行。然而，这种攻击最有趣（也可能是最复杂）的一部分是添加或修改 DXE 驱动程序，这涉及到利用
    UEFI 固件、操作系统和用户模式应用程序中的漏洞，形成复杂的攻击链。
- en: One way to modify a DXE driver in the UEFI firmware image is to bypass the SPI
    flash protection bits we talked about earlier in this chapter, by exploiting a
    privilege escalation vulnerability. Elevated privileges allow the attacker to
    disable SPI flash protection by turning off the protection bits.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 UEFI 固件映像中的 DXE 驱动程序的一种方式是绕过我们在本章前面讨论的 SPI 闪存保护位，通过利用特权升级漏洞。提高的特权允许攻击者通过关闭保护位来禁用
    SPI 闪存保护。
- en: Another way is to exploit a vulnerability in the BIOS update process that allows
    an attacker to bypass update authentication and write malicious code to SPI flash
    memory. Let’s take a look at how these approaches are employed to infect BIOS
    with malicious code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是利用BIOS更新过程中的漏洞，允许攻击者绕过更新认证并将恶意代码写入SPI闪存。让我们来看看这些方法是如何被用来感染BIOS的恶意代码。
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*These two methods aren’t the only approaches used to modify protected SPI
    flash contents, but we focus on them here to illustrate how malicious BIOS code
    can be persisted on the victim’s computer. A more thorough list of vulnerabilities
    in UEFI firmware is provided in [Chapter 16](ch16.xhtml#ch16).*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*这两种方法并不是修改受保护的SPI闪存内容的唯一途径，但我们在这里重点讨论它们，以说明恶意BIOS代码是如何在受害者的计算机上持久存在的。[第16章](ch16.xhtml#ch16)提供了UEFI固件中漏洞的更全面列表。*'
- en: '**Understanding Rootkit Injection**'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解Rootkit注入**'
- en: 'Most of the users’ secrets and sensitive information of interest to attackers
    are either stored at the kernel level of the operation system or protected by
    code running at that level. This is why rootkits long sought to compromise kernel-mode
    (“Ring 0”): from this level, a rootkit could observe all the user activity or
    target specific user-mode (“Ring 3”) applications, including any components these
    applications loaded.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户的机密和敏感信息都存储在操作系统的内核级别，或受到在该级别运行的代码保护。这就是为什么Rootkit长期以来一直试图妥协内核模式（“Ring
    0”）：从这个层次，Rootkit可以观察所有用户活动，或针对特定的用户模式（“Ring 3”）应用程序，包括这些应用程序加载的任何组件。
- en: 'However, there is one aspect in which a Ring 0 rootkit is at a disadvantage:
    it lacks the user-mode context. When a rootkit operating from the kernel mode
    is looking to steal some data held by a Ring 3 application, the rootkit is not
    getting the most natural view of that data, as the kernel mode is, by design,
    not supposed to be aware of user-level data abstractions. Thus, a kernel-mode
    rootkit often has to reconstruct such data by using some trick or other, especially
    when the data is spread across several memory pages. Thus kernel-mode rootkits
    would need to skillfully reuse code that implemented user-level abstractions.
    Still, with just one level of separation, such code reuse was not particularly
    tricky.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些方面，Ring 0 Rootkit处于劣势：它缺乏用户模式上下文。当从内核模式运行的Rootkit试图窃取一个Ring 3应用程序持有的数据时，Rootkit并没有获得该数据最自然的视图，因为内核模式的设计本来就不应该意识到用户级的数据抽象。因此，内核模式Rootkit通常不得不使用某些技巧来重构这些数据，尤其是当数据分布在多个内存页面时。因此，内核模式Rootkit需要巧妙地重用实现用户级抽象的代码。然而，由于只有一层分离，这种代码重用并不特别棘手。
- en: SMM added an even better target into the mix, but also added another level of
    separation from user-level abstractions. An SMM-based rootkit can control both
    kernel-level and user-level memory by having control over any physical memory
    page. Yet this strength of SMM-level malicious code is also a weakness, as that
    code must reliably reimplement the upper-level abstractions such as virtual memory
    and handle all the complexity involved in this task.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: SMM添加了一个更好的目标，但也增加了与用户级抽象之间的另一个分离层次。基于SMM的Rootkit可以通过控制任何物理内存页面来控制内核级和用户级的内存。然而，SMM级恶意代码的这个优势也是其弱点，因为这段代码必须可靠地重新实现上层抽象，如虚拟内存，并处理这一任务中涉及的所有复杂性。
- en: Luckily for the attacker, an SMM rootkit can inject a malicious Ring 0 rootkit
    module into the OS kernel in a similar way to bootkits, and not just at boot time.
    Then it can rely on this code to make use of the kernel-mode structures in the
    kernel-mode context, while protecting that code from detection by kernel-level
    security tools. Critically, SMM-based code could choose the point at which the
    implant was injected.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于攻击者而言，SMM Rootkit可以通过类似于引导程序的方式将恶意的Ring 0 Rootkit模块注入操作系统内核，而不仅仅是在引导时。然后，它可以依赖这段代码在内核模式上下文中使用内核模式结构，同时保护这些代码免受内核级安全工具的检测。关键是，基于SMM的代码可以选择植入的注入点。
- en: Specifically, firmware implants can even bypass some Secure Boot implementations—something
    that straight-up bootkits could not do, by moving the point of infection *after*
    the integrity checks were completed. In [Figure 15-6](ch15.xhtml#ch15fig06), we
    show how delivery methods evolved from a simple delivery scheme with a user-mode
    (Ring 3) loader, which exploited a vulnerability to elevate its privilege to install
    a malicious kernel-mode (Ring 0) driver. Yet the evolution of mitigations caught
    up with this scheme. Microsoft’s kernel-mode signing policies rendered it ineffective
    and started the bootkit era, which the Secure Boot technology was in turn introduced
    to counteract. Then SMM threats arose to undermine Secure Boot.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言，固件植入物甚至可以绕过一些安全启动实现——这是直接的启动工具无法做到的，它通过将感染点移动到*完整性检查*完成之后来实现。在[图 15-6](ch15.xhtml#ch15fig06)中，我们展示了交付方式如何从一个简单的用户模式（Ring
    3）加载器的交付方案演变而来，该加载器利用漏洞提升权限，安装恶意的内核模式（Ring 0）驱动程序。然而，缓解措施的演变赶上了这一方案。微软的内核模式签名政策使其无效，并开启了启动工具时代，而安全启动技术则应运而生以应对这一问题。随后，SMM威胁出现，试图破坏安全启动。
- en: '![image](../images/15fig06.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig06.jpg)'
- en: '*Figure 15-6: Possible ways of loading a Ring 0 rootkit*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-6：加载Ring 0根工具的可能方式*'
- en: As of this writing, SMM threats have succeeded in bypassing Secure Boot on most
    of the Intel-based platforms. SMM rootkits and implants yet again moved the security
    boundary down, closer to the physical hardware.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文写作时，SMM威胁已经成功绕过了大多数基于Intel的平台的安全启动。SMM根工具和植入物再次将安全边界下移，接近物理硬件。
- en: With SMM threats growing in popularity, forensic analysis of the firmware is
    an emerging and very important area of research.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 随着SMM威胁日益严重，固件的取证分析成为一个新兴且非常重要的研究领域。
- en: '**Injecting Malicious Code via SMM Privilege Escalation**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过SMM权限提升注入恶意代码**'
- en: To escalate privileges to the SMM level to be able to modify SPI flash contents,
    the attacker must use callback interfaces to the operating system that are handled
    by System Management Interrupt handlers (we’ll cover SMI handlers more in [Chapter
    16](ch16.xhtml#ch16). The SMI handlers responsible for hardware interfaces to
    an operating system are executed in SMM, so if an attacker can exploit a vulnerability
    inside an SMM driver, they might be able to gain SMM execution privileges. Malicious
    code executed with SMM privileges can disable SPI flash protection bits and modify
    or add a DXE driver to the UEFI firmware on some platforms.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提升权限到SMM级别，以便能够修改SPI闪存内容，攻击者必须利用操作系统的回调接口，这些接口由系统管理中断（SMI）处理程序处理（我们将在[第16章](ch16.xhtml#ch16)中详细讨论SMI处理程序）。负责操作系统硬件接口的SMI处理程序是在SMM中执行的，因此如果攻击者能够利用SMM驱动程序中的漏洞，他们可能获得SMM执行权限。以SMM权限执行的恶意代码可以禁用SPI闪存保护位，并在某些平台上修改或添加DXE驱动程序到UEFI固件中。
- en: To understand this kind of attack, we need to think about attack tactics for
    persistent schemes of infection from the operating system level. What does the
    attacker need to do in order to modify the SPI flash memory? [Figure 15-7](ch15.xhtml#ch15fig07)
    depicts the necessary steps.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这种攻击，我们需要考虑从操作系统层级持久化感染方案的攻击策略。攻击者需要做什么才能修改SPI闪存内存？[图 15-7](ch15.xhtml#ch15fig07)展示了必要的步骤。
- en: '![image](../images/15fig07.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig07.jpg)'
- en: '*Figure 15-7: Generic scheme of UEFI rootkit infection*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-7：UEFI根工具感染的通用方案*'
- en: 'As we can see, the exploitation path is pretty complex and involves exploits
    at many levels. Let’s break this process down into its stages:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，利用路径相当复杂，涉及多个层级的漏洞利用。让我们将这个过程分解为几个阶段：
- en: '**Stage 1, user mode** A client-side exploit, such as web browser *remote code
    execution (RCE)*, drops a malicious installer onto the system. The installer then
    uses an elevation of privilege exploit to gain access to `LOCALSYSTEM` and continues
    execution with these new privileges.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段 1，用户模式** 客户端漏洞利用，如网页浏览器的*远程代码执行（RCE）*，将恶意安装程序放到系统上。然后，安装程序使用提升权限漏洞来获得对`LOCALSYSTEM`的访问权限，并以这些新权限继续执行。'
- en: '**Stage 2, kernel mode** The installer bypasses code-signing policies (discussed
    in [Chapter 6](ch06.xhtml#ch06)) to execute its code in kernel mode. The *kernel-mode
    payload* (driver) runs an exploit to gain privileges to SMM.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段 2，内核模式** 安装程序绕过代码签名策略（在[第6章](ch06.xhtml#ch06)中讨论）以在内核模式下执行其代码。*内核模式有效载荷*（驱动程序）运行一个漏洞利用程序来获得SMM权限。'
- en: '**Stage 3, System Management Mode** The *SMM code* successfully executes, and
    privileges are elevated to SMM. The *SMM payload* disables protections of SPI
    flash memory modifications.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段3，系统管理模式** *SMM代码*成功执行，特权提升到SMM。*SMM负载*禁用了SPI闪存内存修改的保护。'
- en: '**Stage 4, SPI flash** All SPI flash protections are disabled, and the flash
    memory is open to arbitrary writes. The *rootkit/implant* is then installed into
    the firmware onto the SPI flash chip. This exploit reaches a very high level of
    persistence in the system.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段4，SPI闪存** 所有SPI闪存保护都被禁用，闪存内存可进行任意写入。然后，*rootkit/植入程序*被安装到SPI闪存芯片的固件中。这个漏洞可以在系统中达到非常高的持久性。'
- en: 'This generic scheme of infection in [Figure 15-8](ch15.xhtml#ch15fig08) actually
    shows a real case of an SMM ransomware PoC, which we presented at Black Hat Asia
    2017\. The presentation is called “UEFI Firmware Rootkits: Myths and Reality,”
    and we recommend reading it if you’d like to know more (*[https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf](https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf)*).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个[图15-8](ch15.xhtml#ch15fig08)的通用感染模式实际上展示了一个SMM勒索病毒PoC的真实案例，我们在2017年Black
    Hat Asia会议上进行了展示。该报告名为“UEFI固件Rootkit：神话与现实”，如果你想了解更多，推荐阅读它（*[https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf](https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf)*）。
- en: '**Exploiting BIOS Update Process (In)Security**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**利用BIOS更新过程中的（不）安全性**'
- en: Another way to inject malicious code into BIOS is to abuse the BIOS update authentication
    process. BIOS update authentication is intended to prevent the installation of
    BIOS updates whose authenticity cannot be verified, ensuring that only BIOS update
    images issued by the vendor of the platform are authorized to install. If an attacker
    manages to exploit a vulnerability in this authentication mechanism, they can
    inject malicious code into the update image that will subsequently be written
    to the SPI flash.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注入恶意代码到BIOS的另一种方式是滥用BIOS更新认证过程。BIOS更新认证旨在防止无法验证真实性的BIOS更新安装，确保只有平台供应商发布的BIOS更新映像被授权安装。如果攻击者能够利用该认证机制中的漏洞，他们就能将恶意代码注入到更新映像中，并随后写入SPI闪存。
- en: In March 2017, Alex Matrosov, one of the authors of this book, demonstrated
    a UEFI ransomware PoC at Black Hat Asia (*[https://www.cylance.com/en_us/blog/gigabyte-brix-systems-vulnerabilities.html](https://www.cylance.com/en_us/blog/gigabyte-brix-systems-vulnerabilities.html)*).
    His PoC showed how the weak update process implemented by Gigabyte could be exploited.
    He used a recent platform from Gigabyte, based on the Intel sixth-generation CPU
    (Skylake) and Microsoft Windows 10, with all protections enabled, including Secure
    Boot with the BLE bit. Despite these protections, the Gigabyte Brix platform didn’t
    authenticate updates, thereby allowing an attacker to install any firmware update
    from the OS kernel (*[http://www.kb.cert.org/vuls/id/507496/](http://www.kb.cert.org/vuls/id/507496/)*).
    [Figure 15-8](ch15.xhtml#ch15fig08) shows the vulnerable process of the BIOS update
    routine on the Gigabyte Brix hardware.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年3月，本书的作者之一Alex Matrosov在Black Hat Asia演示了一个UEFI勒索病毒PoC（*[https://www.cylance.com/en_us/blog/gigabyte-brix-systems-vulnerabilities.html](https://www.cylance.com/en_us/blog/gigabyte-brix-systems-vulnerabilities.html)*）。他的PoC展示了Gigabyte实施的弱更新过程如何被利用。他使用了Gigabyte的一个基于英特尔第六代CPU（Skylake）和微软Windows
    10的最新平台，且启用了所有保护措施，包括带有BLE位的安全启动。尽管有这些保护措施，Gigabyte Brix平台没有对更新进行身份验证，因此允许攻击者从操作系统内核安装任何固件更新（*[http://www.kb.cert.org/vuls/id/507496/](http://www.kb.cert.org/vuls/id/507496/)*）。[图15-8](ch15.xhtml#ch15fig08)展示了Gigabyte
    Brix硬件上BIOS更新过程中的漏洞。
- en: '![image](../images/15fig08.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig08.jpg)'
- en: '*Figure 15-8: The UEFI ransomware infection algorithm*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-8：UEFI勒索病毒感染算法*'
- en: As we can see, the attacker can use the original kernel-mode driver from the
    BIOS update software, provided and signed by the hardware vendor, to deliver the
    malicious BIOS update. The driver communicates with the SWSMI handler SmiFlash,
    which has write and read interfaces to SPI flash memory. Specifically for this
    presentation, one of the DXE drivers was modified and executed in SMM to demonstrate
    the highest level of persistence possible in UEFI firmware and to control the
    boot process from the earliest boot stages. If infection of the UEFI ransomware
    is successful, the target machine displays the ransom message shown in [Figure
    15-9](ch15.xhtml#ch15fig09).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，攻击者可以利用硬件厂商提供并签名的 BIOS 更新软件中的原始内核模式驱动程序，来交付恶意的 BIOS 更新。该驱动程序与 SWSMI
    处理程序 SmiFlash 通信，SmiFlash 具有读写 SPI 闪存的接口。特别是为了这次展示，其中一个 DXE 驱动程序被修改并在 SMM 中执行，以演示在
    UEFI 固件中可能实现的最高级别的持久性，并控制从最早的启动阶段开始的启动过程。如果 UEFI 勒索软件感染成功，目标机器会显示 [图 15-9](ch15.xhtml#ch15fig09)
    中所示的赎金信息。
- en: '![image](../images/15fig09.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig09.jpg)'
- en: '*Figure 15-9: Active UEFI ransomware infection screen from Black Hat Asia 2017*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-9: 2017 年 Black Hat Asia 活动中的 UEFI 勒索软件感染屏幕*'
- en: In legacy BIOS firmware, before UEFI became the industry standard, mainstream
    hardware vendors didn’t think too much about securing firmware update authentication.
    This meant they were massively vulnerable to malicious BIOS implants; when those
    implants began showing up, vendors were forced to care. Nowadays, to militate
    against such attacks, UEFI firmware updates have a unified format named Capsule
    Update, described in detail in the UEFI specification. Capsule Update was developed
    to introduce a better process for delivering BIOS updates. Let’s take a look at
    it in detail using the Intel EDK2 repository mentioned earlier.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 BIOS 固件中，在 UEFI 成为行业标准之前，主流硬件厂商并没有过多考虑固件更新的认证安全性。这意味着他们在面对恶意 BIOS 植入时非常脆弱；当这些植入开始出现时，厂商们才被迫关注这个问题。如今，为了抵御此类攻击，UEFI
    固件更新采用了统一格式，称为 Capsule 更新，详细描述见 UEFI 规范。Capsule 更新的开发旨在提供一种更好的 BIOS 更新交付过程。让我们通过前面提到的
    Intel EDK2 仓库来详细了解它。
- en: '**The Capsule Update Improvement**'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Capsule 更新改进**'
- en: The Capsule Update has a header (`EFI_CAPSULE_HEADER` in EDK2 notation) and
    a body to store all information about the update’s executable modules, including
    DXE and PEI drivers. The Capsule Update image contains a mandatory digital signature
    of the update data and the code used for authentication and integrity protection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Capsule 更新包含一个头部（在 EDK2 标注中为`EFI_CAPSULE_HEADER`）和一个主体，用于存储关于更新可执行模块的所有信息，包括
    DXE 和 PEI 驱动程序。Capsule 更新镜像包含了更新数据的强制数字签名，以及用于认证和完整性保护的代码。
- en: Let’s look at the layout of Capsule Update image using the UEFITool utility
    developed by Nikolaj Schlej (*[https://github.com/LongSoft/UEFITool](https://github.com/LongSoft/UEFITool)*).
    This tool allows us to parse UEFI firmware images, including those provided in
    UEFI Capsule Updates, and to extract different DXE or PEI executable modules as
    standalone binaries. We will come back to UEFITool in [Chapter 19](ch19.xhtml#ch19).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 Nikolaj Schlej 开发的 UEFITool 工具来查看 Capsule 更新镜像的布局 (*[https://github.com/LongSoft/UEFITool](https://github.com/LongSoft/UEFITool)*)。这个工具允许我们解析
    UEFI 固件镜像，包括那些包含在 UEFI Capsule 更新中的镜像，并提取不同的 DXE 或 PEI 可执行模块作为独立的二进制文件。我们将在 [第
    19 章](ch19.xhtml#ch19) 中回到 UEFITool 的讨论。
- en: '[Figure 15-10](ch15.xhtml#ch15fig10) shows the structure of the UEFI Capsule
    Update in the output of the UEFITool.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-10](ch15.xhtml#ch15fig10) 展示了 UEFI Capsule 更新在 UEFITool 输出中的结构。'
- en: '![image](../images/15fig10.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig10.jpg)'
- en: '*Figure 15-10: The UEFITool interface*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-10: UEFITool 界面*'
- en: 'The capsule image starts with a header ➊ that describes the general parameters
    of the update image, such as header size and update image size. Then we see the
    capsule body, which here consists of a single *firmware volume* ➋. (Firmware volumes
    are objects defined in the platform initialization specification and used to store
    firmware file images, including DXE and PEI modules. We’ll discuss them in more
    detail in [Chapter 19](ch19.xhtml#ch19).) This firmware volume contains the actual
    BIOS update data to be written to SPI flash memory in multiple firmware files:
    for instance, `BootBlockAreas` ➌ and `RecoveryAreas` ➍ contain updates for the
    PEI phase, while `MainAreas` ➎ contain updates for the DXE phase.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: capsule镜像从一个头部➊开始，描述了更新镜像的一般参数，如头部大小和更新镜像大小。然后我们看到capsule体，通常由一个*固件卷* ➋组成。（固件卷是在平台初始化规范中定义的对象，用于存储固件文件镜像，包括DXE和PEI模块。我们将在[第19章](ch19.xhtml#ch19)中详细讨论它们。）此固件卷包含实际的BIOS更新数据，要写入SPI闪存内存的多个固件文件：例如，`BootBlockAreas`
    ➌和`RecoveryAreas` ➍包含PEI阶段的更新，而`MainAreas` ➎包含DXE阶段的更新。
- en: The important point is that the contents of the firmware volume that holds the
    BIOS updates are signed (even though UEFITool doesn’t display this information
    in [Figure 15-11](ch15.xhtml#ch15fig11)). As a result, an attacker is unable to
    introduce modifications to the updates without invalidating the digital signature.
    If implemented correctly, Capsule Update militates against attackers leveraging
    unauthenticated firmware updates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，包含BIOS更新的固件卷内容是有签名的（尽管UEFITool在[图15-11](ch15.xhtml#ch15fig11)中未显示此信息）。因此，攻击者无法在不使数字签名失效的情况下对更新进行修改。如果实施得当，Capsule
    Update可以防止攻击者利用未经认证的固件更新。
- en: '**UEFI Rootkits in the Wild**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**野外的UEFI根工具**'
- en: Since the UEFI malware discovered by Kaspersky Labs in 2015, we’ve seen multiple
    media reports of even more sophisticated rootkits in the wild, allegedly developed
    by nation-state actors. In the rest of this chapter, we’ll discuss other examples
    of UEFI rootkits, including those that have been broadly deployed by commercial
    organizations, such as Vector-EDK and Computrace.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 自从卡巴斯基实验室在2015年发现UEFI恶意软件以来，我们已经看到多篇媒体报道了更为复杂的根工具，声称是由国家级行为者开发的。在本章的其余部分，我们将讨论其他UEFI根工具的例子，包括那些已被商业组织广泛部署的工具，如Vector-EDK和Computrace。
- en: '***Hacking Team’s Vector-EDK Rootkit***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***黑客团队的Vector-EDK根工具***'
- en: In 2015, an Italian company developing spyware for law enforcement organizations
    and other government clients, known as *Hacking Team*, was breached, and much
    of the company’s confidential information was exposed, including descriptions
    of an interesting project called *Vector-EDK*. Analysis of the breach revealed
    that Vector-EDK was a UEFI firmware rootkit that installed and executed its malicious
    components directly in the user-mode NTFS subsystem of Windows.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，一家为执法机构和其他政府客户开发间谍软件的意大利公司——*黑客团队*，遭到攻击，公司的大量机密信息被曝光，其中包括一个名为*Vector-EDK*的有趣项目的描述。对这一泄漏事件的分析揭示，Vector-EDK是一个UEFI固件根工具，它直接在Windows的用户模式NTFS子系统中安装并执行其恶意组件。
- en: 'Alex Matrosov, one of the authors of this book and at the time a member of
    the Intel Advanced Threat Research (ATR) group, recognized the attack potential
    of Vector-EDK and published the blog post “Hacking Team’s ‘Bad BIOS’: A Commercial
    Rootkit for UEFI Firmware?” (*[https://www.mcafee.com/enterprise/en-us/threat-center/advanced-threat-research/uefi-rootkit.html](https://www.mcafee.com/enterprise/en-us/threat-center/advanced-threat-research/uefi-rootkit.html)*).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Alex Matrosov，本书的作者之一，当时是Intel高级威胁研究（ATR）组的成员，意识到Vector-EDK的攻击潜力，并发布了博客文章《黑客团队的‘坏BIOS’：一种商业根工具用于UEFI固件？》（*[https://www.mcafee.com/enterprise/en-us/threat-center/advanced-threat-research/uefi-rootkit.html](https://www.mcafee.com/enterprise/en-us/threat-center/advanced-threat-research/uefi-rootkit.html)*）。
- en: '**Discovering Vector-EDK**'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**发现Vector-EDK**'
- en: Our investigation took off when we discovered a curious file, named *Z5WE1X64.fd*,
    attached to one of the leaked Hacking Team emails inside a compressed file named
    *Uefi_windows_persistent.zip* (see [Figure 15-11](ch15.xhtml#ch15fig11)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一个被泄露的黑客团队邮件中发现一个名为*Z5WE1X64.fd*的奇怪文件，并附在一个名为*Uefi_windows_persistent.zip*的压缩文件中时，我们的调查便开始了（见[图15-11](ch15.xhtml#ch15fig11)）。
- en: '![image](../images/15fig11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig11.jpg)'
- en: '*Figure 15-11: One of the leaked emails from the Hacking Team archive*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-11：来自黑客团队档案中的一封泄露邮件*'
- en: After we analyzed the attachment, it became clear that it was a UEFI firmware
    image, and after reading a few more leaked emails, we could see that we were dealing
    with a UEFI rootkit. A quick investigation with UEFITool revealed the suggestive
    name *rkloader* (implying *rootkit loader*) in the list of DXE drivers. [Figure
    15-12](ch15.xhtml#ch15fig12) shows our analysis.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分析附件后，很明显它是一个 UEFI 固件映像，经过进一步阅读泄露的几封邮件后，我们看到我们正在处理的是一个 UEFI rootkit。使用 UEFITool
    进行的快速调查揭示了在 DXE 驱动列表中有一个暗示性的名称 *rkloader*（暗示 *rootkit loader*）。[图 15-12](ch15.xhtml#ch15fig12)
    显示了我们的分析结果。
- en: '![image](../images/15fig12.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig12.jpg)'
- en: '*Figure 15-12: Hacking Team Vector-EDK detection with UEFITool*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-12：使用 UEFITool 检测 Hacking Team Vector-EDK*'
- en: This caught our attention because we had never encountered a DXE driver of this
    name before. We took a more careful look at the leaked archive and discovered
    the source code of the Vector-EDK project. This is where our technical investigation
    started in earnest.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这引起了我们的注意，因为我们之前从未遇到过这个名称的 DXE 驱动。我们更加仔细地查看了泄露的档案，发现了 Vector-EDK 项目的源代码。这就是我们的技术调查真正开始的地方。
- en: '**Analyzing Vector-EDK**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分析 Vector-EDK**'
- en: 'The Vector-EDK rootkit uses the previously discussed UEFI implant (*rkloader*)
    delivery methods. This rootkit, however, works only at the DXE stage and can’t
    survive a BIOS update. Inside the infected *Z5WE1X64.fd* BIOS image, there were
    three main modules:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Vector-EDK rootkit 使用了之前讨论过的 UEFI 植入（*rkloader*）传递方法。然而，这个 rootkit 仅在 DXE 阶段工作，无法在
    BIOS 更新后存活。在感染的 *Z5WE1X64.fd* BIOS 映像中，有三个主要模块：
- en: '**NTFS parser (*Ntfs.efi*)** A DXE driver containing a full parser for the
    NTFS, for read and write operations.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTFS 解析器 (*Ntfs.efi*)** 一款 DXE 驱动，包含完整的 NTFS 解析器，用于读写操作。'
- en: '**Rootkit (*rkloader.efi*)** A DXE driver that registers a callback to intercept
    the `EFI_EVENT_GROUP_READY_TO_BOOT` event (which signifies that the platform is
    ready to execute the OS bootloader) and load the *fsbg.efi* UEFI application before
    the start of the OS boot.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rootkit (*rkloader.efi*)** 一款 DXE 驱动，注册了一个回调函数，用来拦截 `EFI_EVENT_GROUP_READY_TO_BOOT`
    事件（这表明平台已准备好执行操作系统引导程序），并在操作系统引导开始之前加载 *fsbg.efi* UEFI 应用程序。'
- en: '**Bootkit (*fsbg.efi*)** A UEFI application that runs just before the BIOS
    passes control to the OS bootloaders. This contains the main bootkit functions
    that parse the NTFS with *Ntfs.efi* and inject malware agents into the filesystem.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bootkit (*fsbg.efi*)** 一款 UEFI 应用程序，在 BIOS 将控制权传递给操作系统引导程序之前运行。它包含了主要的 bootkit
    功能，解析 NTFS 文件系统并使用 *Ntfs.efi* 将恶意软件注入文件系统。'
- en: We analyzed the leaked Vector-EDK source code and discovered that the components
    *rkloader.efi* and *fsbg.efi* implement the core functionality of the rootkit.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了泄露的 Vector-EDK 源代码，并发现组件 *rkloader.efi* 和 *fsbg.efi* 实现了 rootkit 的核心功能。
- en: First, let’s take a look at *rkloader.efi*, which runs *fsbg.efi*. [Listing
    15-4](ch15.xhtml#ch15list04) shows the main routine `_ModuleEntryPoint()` for
    the UEFI DXE driver *rkloader*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下 *rkloader.efi*，它会运行 *fsbg.efi*。[列表 15-4](ch15.xhtml#ch15list04) 显示了
    UEFI DXE 驱动 *rkloader* 的主要例程 `_ModuleEntryPoint()`。
- en: '[PRE4]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 15-4: The `_ModuleEntryPoint()` routine from the* rkloader *component*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-4：* rkloader *组件中的 `_ModuleEntryPoint()` 例程*'
- en: We discovered that the routine `_ModuleEntryPoint()` does only two things, the
    first of which is to create a trigger ➊ for the event group `EFI_EVENT_GROUP_READY_TO_BOOT`.
    The second task, once the event arrives, is to execute an SMI handler ➋ by `CallbackSMI()`.
    The first parameter of the `CreateEventEx()` routine indicates that the immediate
    value of `EFI_EVENT_GROUP_READY_TO_BOOT` is 0x200\. This event occurs right before
    the OS bootloader receives control at the end of the BIOS DXE phase, allowing
    the malicious payload, *fsbg.efi*, to take over execution before the operating
    system can.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现例程 `_ModuleEntryPoint()` 只做了两件事，其中第一件是为事件组 `EFI_EVENT_GROUP_READY_TO_BOOT`
    创建触发器 ➊。第二件事是在事件到达时，通过 `CallbackSMI()` 执行 SMI 处理程序 ➋。`CreateEventEx()` 例程的第一个参数表明
    `EFI_EVENT_GROUP_READY_TO_BOOT` 的即时值是 0x200\。这个事件发生在操作系统引导程序接管控制之前，位于 BIOS DXE
    阶段的末尾，允许恶意负载 *fsbg.efi* 在操作系统之前接管执行。
- en: Most of the interesting logic is contained inside the `CallbackSMI()` routine
    in [Listing 15-5](ch15.xhtml#ch15list05). The code for this routine is pretty
    long, so we’ve included only the most important parts of its flow here.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分有趣的逻辑都包含在 [列表 15-5](ch15.xhtml#ch15list05) 中的 `CallbackSMI()` 例程内。这个例程的代码相当长，因此我们这里只展示了其流程中最重要的部分。
- en: '[PRE5]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 15-5: The `CallbackSMI()` routine from* fsbg *component*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-5：来自* fsbg *组件的 `CallbackSMI()` 例程*'
- en: 'First we see multiple UEFI protocol initializations ➊, such as:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们看到多个 UEFI 协议初始化 ➊，例如：
- en: EFI_LOADED_IMAGE_PROTOCOL Provides information on the loaded UEFI images (image
    base address, image size, and location of the image in the UEFI firmware).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: EFI_LOADED_IMAGE_PROTOCOL 提供有关已加载 UEFI 映像的信息（映像基地址、映像大小以及映像在 UEFI 固件中的位置）。
- en: EFI_FIRMWARE_VOLUME_PROTOCOL Provides an interface for reading from and writing
    to firmware volumes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: EFI_FIRMWARE_VOLUME_PROTOCOL 提供读取和写入固件卷的接口。
- en: EFI_DEVICE_PATH_PROTOCOL Provides an interface for building a path to a device.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: EFI_DEVICE_PATH_PROTOCOL 提供构建设备路径的接口。
- en: The interesting part here starts with multiple `EFI_DEVICE_PATH_PROTOCOL` initializations;
    we can see many variable names prefixed with `New`, which usually indicates that
    they are hooks. The `LoadedImage` variable is initialized ➋ with a pointer to
    `EFI_LOADED_IMAGE_PROTOCOL`, after which `LoadedImage` may be used to determine
    the device on which the current module (*rkloader*) is located.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的有趣部分从多个 `EFI_DEVICE_PATH_PROTOCOL` 初始化开始；我们可以看到许多变量名以 `New` 为前缀，通常表示它们是钩子。`LoadedImage`
    变量在 ➋ 时被初始化为指向 `EFI_LOADED_IMAGE_PROTOCOL` 的指针，之后 `LoadedImage` 可用于确定当前模块（*rkloader*）所在的设备。
- en: Next the code obtains the `EFI_FIRMWARE_VOLUME_PROTOCOL` ➌ and `EFI_DEVICE_PATH_PROTOCOL`
    ➍ protocols for the device on which *rkloader* is located. These protocols are
    necessary for constructing a path to the next malicious module—namely, *fsbg.efi*—to
    load from the firmware volume.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码获取 `EFI_FIRMWARE_VOLUME_PROTOCOL` ➌ 和 `EFI_DEVICE_PATH_PROTOCOL` ➍ 协议，这些协议用于构建指向
    *rkloader* 所在设备的路径。这些协议对于构建下一个恶意模块的路径非常必要——即 *fsbg.efi*——从固件卷加载。
- en: 'Once these protocols are obtained, *rkloader* constructs a path to the *fsbg.efi*
    module to load it from the firmware volume. The first part of the path ➎ is the
    path to the firmware volume on which *rkloader* resides (*fsbg.efi* is located
    on exactly the same firmware volume as *rkloader*), and the second part ➏ appends
    a unique identifier for the *fsbg.efi* module: `LAUNCH_APP = {eaea9aec-c9c1-46e2-9d52432ad25a9b0b}`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取到这些协议，*rkloader* 构建一个路径来加载 *fsbg.efi* 模块，从固件卷中加载它。路径的第一部分 ➎ 是 *rkloader*
    所在固件卷的路径（*fsbg.efi* 就位于与 *rkloader* 完全相同的固件卷上），第二部分 ➏ 添加了 *fsbg.efi* 模块的唯一标识符：`LAUNCH_APP
    = {eaea9aec-c9c1-46e2-9d52432ad25a9b0b}`。
- en: The final step is the call to the `LoadImage()` routine ➐ that takes over execution
    of the *fsbg.efi* module. This malicious component contains the main payload with
    the direct paths to the filesystem it wants to modify. [Listing 15-6](ch15.xhtml#ch15list06)
    provides a list of directories in which the *fsbg.efi* module drops an OS-level
    malicious module.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用 `LoadImage()` 例程 ➐，该例程接管 *fsbg.efi* 模块的执行。这个恶意组件包含了主负载，并带有它想要修改的文件系统的直接路径。[列表
    15-6](ch15.xhtml#ch15list06) 提供了 *fsbg.efi* 模块在其中丢弃操作系统级恶意模块的目录列表。
- en: '[PRE6]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 15-6: Hardcoded paths to OS-level components*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-6：操作系统级组件的硬编码路径*'
- en: 'At a high level, the *fsbg.efi* module follows these steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 高层次上，*fsbg.efi* 模块遵循以下步骤：
- en: Check if the system is already actively infected via a predefined UEFI variable
    named `fTA`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查系统是否已经通过预定义的 UEFI 变量 `fTA` 被主动感染。
- en: Initialize the NTFS protocol.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 NTFS 协议。
- en: Look for malicious executables in the BIOS image by looking at predefined sections.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看预定义的部分，在BIOS映像中寻找恶意可执行文件。
- en: Check for existing users on the machine by reviewing the names in the home directory
    to look for specific targets.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看主目录中的名称来检查机器上是否有现有用户，以寻找特定目标。
- en: Install the malware executable modules *scoute.exe* (backdoor) and *soldier.exe*
    (RCS agent) by writing directly into the NTFS.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过直接写入 NTFS 安装恶意可执行模块 *scoute.exe*（后门）和 *soldier.exe*（RCS 代理）。
- en: 'The `fTA` UEFI variable is installed by *fsbg.efi* at the point of first infection,
    and each subsequent boot checks for its presence: if the variable `fTA` is present,
    it means the active infection is already present on the hard drive and *fsbg.efi*
    doesn’t need to deliver the OS-level malicious binary to the filesystem. If malicious
    components from the OS level ([Listing 15-6](ch15.xhtml#ch15list06)) are not found
    in the hardcoded path locations, the *fsbg.efi* module installs them again in
    the boot process.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`fTA` UEFI 变量由 *fsbg.efi* 在第一次感染时安装，每次启动时都会检查其存在：如果变量 `fTA` 存在，则意味着活动感染已存在于硬盘上，*fsbg.efi*
    不需要将操作系统级的恶意二进制文件传送到文件系统。如果在硬编码路径位置没有找到操作系统级的恶意组件（[列表 15-6](ch15.xhtml#ch15list06)），*fsbg.efi*
    模块将在启动过程中重新安装它们。'
- en: Hacking Team’s Vector-EDK is a very instructive example of a UEFI bootkit. We
    highly recommend reading its full source code for a better understanding of how
    it works.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Hacking Team 的 Vector-EDK 是一个非常具有教育意义的 UEFI 启动工具包示例。我们强烈建议阅读其完整源代码，以更好地理解其工作原理。
- en: '**Absolute Software’s Computrace/LoJack**'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Absolute Software 的 Computrace/LoJack**'
- en: Our next example of a UEFI rootkit is not malicious exactly. *Computrace*, also
    known as LoJack, is actually a common proprietary antitheft system developed by
    Absolute Software that’s found in almost all popular enterprise laptops. Computrace
    implements a laptop-tracking system over the internet and includes features such
    as remote locking and remote wiping of hard drives in case of a lost or stolen
    laptop.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个 UEFI 根套件的示例并不完全是恶意的。*Computrace*，也叫 LoJack，实际上是一个由 Absolute Software 开发的常见专有防盗系统，几乎在所有流行的企业级笔记本电脑中都能找到。Computrace
    实现了一个基于互联网的笔记本电脑追踪系统，并包含远程锁定和远程擦除硬盘等功能，以防笔记本丢失或被盗。
- en: Many researchers have independently claimed that Computrace was technically
    a rootkit, because the software had behaviors very similar to a BIOS rootkit.
    The main difference, however, is that Computrace doesn’t try to hide. Its configuration
    menu can even be found in the BIOS setup menu ([Figure 15-13](ch15.xhtml#ch15fig13)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 许多研究人员独立宣称 Computrace 从技术上讲是一个根套件，因为该软件的行为与 BIOS 根套件非常相似。然而，主要区别在于 Computrace
    并不会试图隐藏其存在。其配置菜单甚至可以在 BIOS 设置菜单中找到（[图 15-13](ch15.xhtml#ch15fig13)）。
- en: '![image](../images/15fig13.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig13.jpg)'
- en: '*Figure 15-13: Computrace menu from the BIOS setup on Lenovo ThinkPad T540p*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-13: Lenovo ThinkPad T540p 中 BIOS 设置中的 Computrace 菜单*'
- en: On non-enterprise computers out of the box, Computrace will usually be disabled
    by default in the BIOS menu, as shown in [Figure 15-13](ch15.xhtml#ch15fig13).
    There is also an option to disable Computrace permanently by setting an NVRAM
    variable, which disallows reactivation of Computrace and can be programmed only
    once in the hardware.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在非企业级计算机中，默认情况下 Computrace 通常在 BIOS 菜单中被禁用，如 [图 15-13](ch15.xhtml#ch15fig13)
    所示。还有一个选项可以通过设置 NVRAM 变量来永久禁用 Computrace，该变量不允许重新激活 Computrace，并且只能在硬件中编程一次。
- en: Here we’ll analyze implementations of Computrace on Lenovo T540p and P50 laptops.
    Our conceptual understanding of the Computrace architecture is shown in [Figure
    15-14](ch15.xhtml#ch15fig14).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将分析 Computrace 在 Lenovo T540p 和 P50 笔记本电脑上的实现。我们对 Computrace 架构的概念性理解见于
    [图 15-14](ch15.xhtml#ch15fig14)。
- en: Computrace has a complex architecture with multiple DXE drivers that include
    components working in SMM. It also contains an agent, *rpcnetp.exe*, that executes
    in the operating system and is responsible for all network communications with
    the cloud (C&C server).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Computrace 拥有复杂的架构，包含多个 DXE 驱动程序，其中包括在 SMM 中运行的组件。它还包含一个代理程序，*rpcnetp.exe*，该程序在操作系统中执行，并负责与云（C&C
    服务器）的所有网络通信。
- en: LenovoComputraceEnableDxe DXE driver that tracks the BIOS menu for Computrace
    options to trigger the installation phase for `LenovoComputraceLoaderDxe`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: LenovoComputraceEnableDxe 是一个 DXE 驱动程序，用于追踪 BIOS 菜单中的 Computrace 选项，以触发 `LenovoComputraceLoaderDxe`
    的安装阶段。
- en: LenovoComputraceLoaderDxe DXE driver to verify security policies and load `AbsoluteComputraceInstallerDxe`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: LenovoComputraceLoaderDxe 是一个 DXE 驱动程序，用于验证安全策略并加载 `AbsoluteComputraceInstallerDxe`。
- en: AbsoluteComputraceInstallerDxe DXE driver that installs the Computrace agent
    into the operating system, via direct filesystem (NTFS) modifications. The agent
    binary is embedded into the DXE driver image as shown on [Figure 15-15](ch15.xhtml#ch15fig15).
    On a modern laptop, ACPI tables are used for agent installation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: AbsoluteComputraceInstallerDxe 是一个 DXE 驱动程序，它通过直接修改文件系统（NTFS）将 Computrace 代理程序安装到操作系统中。代理程序二进制文件被嵌入到
    DXE 驱动程序映像中，如 [图 15-15](ch15.xhtml#ch15fig15) 所示。在现代笔记本电脑上，ACPI 表用于代理程序的安装。
- en: '![image](../images/15fig14.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig14.jpg)'
- en: '*Figure 15-14: Computrace high-level architecture*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-14: Computrace 高级架构*'
- en: '![image](../images/15fig15.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig15.jpg)'
- en: '*Figure 15-15: `AbsoluteComputraceInstallerDxe` binary inside Hiew hex editor*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-15: `AbsoluteComputraceInstallerDxe` 二进制文件在 Hiew 十六进制编辑器中的显示*'
- en: LenovoComputraceSmiServices DXE driver that executes inside SMM to support communications
    with the OS agent and other BIOS components.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: LenovoComputraceSmiServices 是一个 DXE 驱动程序，在 SMM 内部执行，以支持与 OS 代理和其他 BIOS 组件的通信。
- en: '**Computrace agent (*rpcnetp.exe*)** PE executable image stored inside `AbsoluteComputraceInstallerDxe`.
    The Computrace agent executes after the operating system user login.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**Computrace 代理程序 (*rpcnetp.exe*)** 是一个 PE 可执行映像，存储在 `AbsoluteComputraceInstallerDxe`
    中。Computrace 代理程序在操作系统用户登录后执行。'
- en: The main functions of Computrace’s *rpcnetp.exe* agent are collecting geolocation
    information and sending it to Absolute Software’s cloud. This is achieved by injecting
    Computrace’s component *rpcnetp.dll* into *iexplore.exe* and *svchost.exe* processes,
    as shown on [Figure 15-16](ch15.xhtml#ch15fig16). The agent also receives commands
    from the cloud, such as a low-level hard drive wiping action for securely deleting
    files.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Computrace的*rpcnetp.exe*代理的主要功能是收集地理位置信息并将其发送到Absolute Software的云端。这是通过将Computrace的组件*rpcnetp.dll*注入到*iexplore.exe*和*svchost.exe*进程中实现的，如[图
    15-16](ch15.xhtml#ch15fig16)所示。该代理还从云端接收命令，例如执行低级别硬盘擦除操作以安全删除文件。
- en: '![image](../images/15fig16.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/15fig16.jpg)'
- en: '*Figure 15-16: The* rpcnetp.exe *process injection scheme*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-16: * rpcnetp.exe *进程注入方案*'
- en: Computrace is a good example of a technology that clearly looks like a BIOS
    rootkit but delivers persistent functionality for legitimate purposes, such as
    theft recovery. This type of persistence allows the main Computrace components
    to work independently of the OS and to integrate deeply with UEFI firmware. Disabling
    Computrace requires a lot more work from the attacker than merely stopping its
    OS agent component!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Computrace是一个很好的例子，它看起来明显像一个BIOS rootkit，但它为合法目的提供了持久功能，例如盗窃恢复。这种类型的持久性允许主要的Computrace组件独立于操作系统工作，并与UEFI固件深度集成。禁用Computrace需要攻击者付出比仅仅停止其操作系统代理组件更多的努力！
- en: '**Conclusion**'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: BIOS rootkits and implants are the next evolution stage for bootkits. As we’ve
    seen in this chapter, this evolution creates a new level of firmware persistence
    not yet addressed by antivirus software, meaning that malware that uses these
    techniques can remain active for years. We’ve tried to give a detailed overview
    of BIOS rootkits, from the initial PoCs and in-the-wild samples to advanced UEFI
    implants. However, this topic is complex and would require many more chapters
    for deeper coverage. We encourage you to follow the links given, read further
    for yourself, and follow our blogs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS rootkit和植入物是bootkit的下一阶段进化。正如我们在本章所看到的，这一进化创造了一种新的固件持久性层次，尚未被杀毒软件解决，这意味着使用这些技术的恶意软件可以保持活动多年。我们尽力提供了关于BIOS
    rootkit的详细概述，从最初的PoC和野外样本到高级的UEFI植入物。然而，这一主题非常复杂，需要更多的章节来深入探讨。我们鼓励你访问提供的链接，进一步阅读，并关注我们的博客。
- en: Mitigation approaches for this kind of malware are still weak, but it’s also
    true that hardware vendors continue to introduce more and more complex secure
    boot implementations, in which boot integrity checks start from the earlier boot
    steps, even before the BIOS runs. [Chapter 17](ch17.xhtml#ch17) will dive deeper
    into modern implementations of Secure Boot. At the time of this writing, the security
    industry is only just starting to learn how to forensically investigate firmware,
    as information about real, in-the-wild cases is unfortunately sparse. We will
    cover more UEFI firmware forensics in the final chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这种恶意软件的缓解方法仍然薄弱，但也有一个事实是，硬件厂商继续推出越来越复杂的安全启动实现，其中启动完整性检查从更早的启动步骤开始，甚至在BIOS运行之前就已启动。[第17章](ch17.xhtml#ch17)将更深入探讨现代安全启动的实现。在撰写本文时，安全行业才刚刚开始学习如何进行固件的法医调查，因为关于真实、实际发生的案例的信息不幸地仍然很少。我们将在最后一章中深入探讨更多的UEFI固件法医调查。
- en: '[Chapter 16](ch16.xhtml#ch16) explores UEFI vulnerabilities. As far as we know,
    no other book to date has covered this topic in comparable detail, so hold on
    to your hats!'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[第16章](ch16.xhtml#ch16)探讨了UEFI漏洞。据我们所知，迄今为止没有其他书籍在相同的详细程度上涵盖这一主题，因此请准备好！'
