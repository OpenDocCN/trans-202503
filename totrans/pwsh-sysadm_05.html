<html><head></head><body>
<h2 class="h2" id="ch4"><span epub:type="pagebreak" id="page_47"/><span class="big">4</span><br/>CONTROL FLOW</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">Let’s do a quick recap. In <a href="ch03.xhtml#ch3">Chapter 3</a>, you learned how to combine commands by using the pipeline and external scripts. In <a href="ch02.xhtml#ch2">Chapter 2</a>, you learned how to use variables to store values. One of the major benefits of working with variables is they allow you to write code that deals with</span> what a value means: instead of working with the number 3, for example, you’ll work with the more general <span class="literal">$serverCount</span>, so you can write code that runs the same whether you have one, or two, or a thousand servers. Combine this ability to write general solutions with the ability to store your code in a script that you can run on many computers, and you can start solving problems at a much bigger scale.</p>&#13;
<p class="indent">But in the real world, sometimes it matters whether you’re working with one server, or two servers, or a thousand. Right now, you don’t have a good way to account for that: your scripts run in one direction—top to bottom—and they don’t have any way of changing based on the specific values you’re working with. In this chapter, you’ll use control flow and conditional logic to write scripts that execute different sequences of instructions based on <span epub:type="pagebreak" id="page_48"/>the values they’re working with. By the end of the chapter, you’ll know how to use <span class="literal">if/then</span> statements, <span class="literal">switch</span> statements, and all manner of loops to give your code some much-needed flexibility.</p>&#13;
<h3 class="h3" id="ch4lev1">Understanding Control Flow</h3>&#13;
<p class="noindent">You’re going to write a script that reads the contents of a file stored in various remote computers. To follow along, download a file called <em>App_configuration.txt</em> from the book’s resources at <a href="https://github.com/adbertram/PowerShellForSysadmins/"><em>https://github.com/adbertram/PowerShellForSysadmins/</em></a> and place it in the root of the <em>C:\</em> drive of a few remote computers. (If you don’t have access to remote servers, just follow along in the text for now.) In this example, I’ll be using servers with the names <span class="literal">SRV1</span>, <span class="literal">SRV2</span>, <span class="literal">SRV3</span>, <span class="literal">SRV4</span>, and <span class="literal">SRV5</span>.</p>&#13;
<p class="indent">To access the file’s contents, you’ll use the <span class="literal">Get-Content</span> command and provide the path to the file as the argument to the <span class="literal">Path</span> parameter, as shown here:</p>&#13;
<pre>Get-Content -Path "\\<span class="codeitalic1">servername</span>\c$\App_configuration.txt"</pre>&#13;
<p class="indent">As a first attempt, let’s store all our server names in an array, and run this command for every server in the array. Open a new <em>.ps1</em> file and enter the code in <a href="ch04.xhtml#ch4list1">Listing 4-1</a>.</p>&#13;
<pre>$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')&#13;
Get-Content -Path "\\$($servers[0])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[1])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[2])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[3])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[4])\c$\App_configuration.txt"</pre>&#13;
<p class="caption" id="ch4list1"><em>Listing 4-1: Getting the contents of a file on multiple servers</em></p>&#13;
<p class="indent">In theory, this code will run with no problems. But this example assumes that everything in your environment is pristine. What if <span class="literal">SRV2</span> is down? What if someone forgot to move <em>App_configuration.txt</em> onto <span class="literal">SRV4</span>? Or used a different file path? You could write a different script for each server, but that solution won’t scale—especially as you start to add more and more servers. What you need is code that can execute differently depending on what it encounters.</p>&#13;
<p class="indent">That’s the basic idea behind <em>control flow</em>, the ability to have your code execute different sequences of instructions depending on predetermined logic. You can think of your scripts as executing along a certain path. Right now, that path goes straight from the first line of code to the last one, but you can use control flow statements to add forks in the road, circle back to places you’ve already been, or take you over lines. By introducing different paths for your script to run along, you allow for much greater flexibility, enabling you to write a single script that can handle many situations.</p>&#13;
<p class="indent">You’ll start by looking at the most basic type of control flow: the conditional statement.</p>&#13;
<h3 class="h3" id="ch4lev2"><span epub:type="pagebreak" id="page_49"/>Using Conditional Statements</h3>&#13;
<p class="noindent">In <a href="ch02.xhtml#ch2">Chapter 2</a>, you learned about the concept of a boolean: a true or false value. You use booleans to build <em>conditional statements</em>, which tell PowerShell to execute a certain code block based on whether an expression (called a <em>condition</em>) evaluates to <span class="literal">True</span> or <span class="literal">False</span>. A condition is a yes/no question: Do you have more than five servers? Is server 3 up? Does this file path exist? To start using conditional statements, let’s see how to translate these kinds of questions into expressions.</p>&#13;
<h4 class="h4" id="ch4lev2sec1">Building Expressions by Using Operators</h4>&#13;
<p class="noindent">You can write expressions by using <em>comparison operators</em>, which compare values. To use a comparison operator, you put it between two values, like this:</p>&#13;
<pre>PS&gt; <span class="codestrong1">1 –eq 1</span>&#13;
True</pre>&#13;
<p class="indent">You use the <span class="literal">–eq</span> operator to determine whether two values are equal. Here’s a list of the most common comparison operators you’ll use:</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-eq</span></strong> Compares two values and returns <span class="literal">True</span> if they are equal.</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-ne</span></strong> Compares two values and returns <span class="literal">True</span> if they are not equal.</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-gt</span></strong> Compares two values and returns <span class="literal">True</span> if the first is greater than the second.</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-ge</span></strong> Compares two values and returns <span class="literal">True</span> if the first is greater than or equal to the second.</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-lt</span></strong> Compares two values and returns <span class="literal">True</span> if the first is less than the second.</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-le</span></strong> Compares two values and returns <span class="literal">True</span> if the first is less than or equal to the second.</p>&#13;
<p class="noindentib"><strong><span class="codestrong">-contains</span></strong> Returns <span class="literal">True</span> if the second value is “in” the first. You can use this to determine whether a value is inside an array.</p>&#13;
<p class="indent">PowerShell offers more advanced comparison operators. I won’t go into them now, but I encourage you to read about them in the Microsoft documentation at <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators"><em>https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators</em></a><em>/</em>, or in the PowerShell help (see <a href="ch01.xhtml#ch1">Chapter 1</a>).</p>&#13;
<p class="indent">You can use the preceding operators to compare variables and values. But an expression doesn’t have to be a comparison. Sometimes PowerShell commands can be used as conditions. In the previous example, you wanted to know whether a server was online. You can test to see whether a server can be pinged by using the <span class="literal">Test-Connection</span> cmdlet. Normally, the output of <span class="literal">Test-Connection</span> returns an object full of information, but by using the <span class="literal">Quiet</span> parameter, you can force the command to return a simple <span class="literal">True</span> or <span class="literal">False</span> and limit the test to a single attempt via the <span class="literal">Count</span> parameter.</p>&#13;
<pre><span epub:type="pagebreak" id="page_50"/>PS&gt; <span class="codestrong1">Test-Connection -ComputerName</span> <span class="codeitalicst1">offlineserver</span><span class="codestrong1"> -Quiet -Count 1</span>&#13;
False&#13;
&#13;
PS&gt; <span class="codestrong1">Test-Connection -ComputerName</span> <span class="codeitalicst1">onlineserver</span><span class="codestrong1"> -Quiet -Count 1</span>&#13;
True</pre>&#13;
<p class="indent">If you wanted to know whether the server was offline, you could use the <span class="literal">–not</span> operator to convert the expression to its opposite:</p>&#13;
<pre>PS&gt; <span class="codestrong1">-not (Test-Connection -ComputerName</span> <span class="codeitalicst1">offlineserver</span><span class="codestrong1"> -Quiet -Count 1)</span>&#13;
True</pre>&#13;
<p class="indent">Now that you’ve seen the basics of expressions, let’s look at the simplest conditional statement.</p>&#13;
<h4 class="h4" id="ch4lev2sec2">The if Statement</h4>&#13;
<p class="noindent">The <span class="literal">if</span> statement is straightforward: if <em>X</em> is true, then do <em>Y</em>. That’s it!</p>&#13;
<p class="indent">To write an <span class="literal">if</span> statement, you begin with an <span class="literal">if</span> keyword followed by parentheses containing a condition. After the expression comes a code block, demarcated in curly brackets. PowerShell will execute that code block only when the expression evaluates to <span class="literal">True</span>. If the <span class="literal">if</span> expression evaluates to <span class="literal">False</span> or returns nothing at all, the code block is skipped. You can see the basic syntax of an <span class="literal">if/then</span> statement in <a href="ch04.xhtml#ch4list2">Listing 4-2</a>.</p>&#13;
<pre>if (<span class="codeitalic1">condition</span>) {&#13;
    # code to run if the condition evaluates to be True&#13;
}</pre>&#13;
<p class="caption" id="ch4list2"><em>Listing 4-2: The syntax of an <span class="codeitalic">if</span> statement</em></p>&#13;
<p class="indent">This example uses a bit of new syntax: the hash mark (<span class="literal">#</span>) signals a <em>comment</em>, which is text PowerShell will ignore. You can use comments to leave yourself, or anyone else reading your code, helpful notes and descriptions.</p>&#13;
<p class="indent">Now let’s take a second look at the code in <a href="ch04.xhtml#ch4list1">Listing 4-1</a> and see how to use an <span class="literal">if</span> statement to make sure you don’t try to access a server that’s not up. In the preceding section, you saw how <span class="literal">Test-Connection</span> can be used as an expression that returns <span class="literal">True</span> or <span class="literal">False</span>, so let’s wrap a <span class="literal">Test-Connection</span> command in an <span class="literal">if</span> statement and then use <span class="literal">Get-Content</span> in the following code block to avoid accessing a server that’s down. For now, you’ll change the code for only the first server, as in <a href="ch04.xhtml#ch4list3">Listing 4-3</a>.</p>&#13;
<pre>$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')&#13;
if (Test-Connection -ComputerName $servers[0] -Quiet -Count 1) {&#13;
    Get-Content -Path "\\$($servers[0])\c$\App_configuration.txt"&#13;
}&#13;
Get-Content -Path "\\$($servers[1])\c$\App_configuration.txt"&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch4list3"><em>Listing 4-3: Using an <span class="codeitalic">if</span> statement to selectively get server content</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_51"/>Because you have <span class="literal">Get-Content</span> in an <span class="literal">if</span> statement, you won’t run into any errors if you try to access a dead server; if the test fails, your script will know not to attempt to read the file. You’ll try to access the server only if you <em>already</em> know it’s up. But notice that this code handles only the case in which the condition is true. Often enough, you’ll want to have one behavior if a condition is true and another behavior if it’s false. In the next section, you’ll see how to specify behavior for a false condition by using the <span class="literal">else</span> statement.</p>&#13;
<h4 class="h4" id="ch4lev2sec3">The else Statement</h4>&#13;
<p class="noindent">To add an alternate behavior to your <span class="literal">if</span> statement, you use the <span class="literal">else</span> keyword after the closing parenthesis of your <span class="literal">if</span> block, followed by another pair of curly brackets containing a code block. As shown in <a href="ch04.xhtml#ch4list4">Listing 4-4</a>, use an <span class="literal">else</span> statement to return an error to the console when the first server isn’t responding.</p>&#13;
<pre>if (Test-Connection -ComputerName $servers[0] -Quiet -Count 1) {&#13;
    Get-Content -Path "\\$($servers[0])\c$\App_configuration.txt"&#13;
} else {&#13;
    Write-Error -Message "The server $($servers[0]) is not responding!"&#13;
}</pre>&#13;
<p class="caption" id="ch4list4"><em>Listing 4-4: Using the <span class="codeitalic">else</span> statement to run code if the condition is not true</em></p>&#13;
<p class="indent">The <span class="literal">if/else</span> statement works perfectly when you have two mutually exclusive situations. Here, the server is either online or it’s not; you need only two branches of code. Let’s look at how to handle more complex situations.</p>&#13;
<h4 class="h4" id="ch4lev2sec4">The elseif Statement</h4>&#13;
<p class="noindent">The <span class="literal">else</span> statement works like a catchall: if the first <span class="literal">if</span> fails, do this no matter what. For a binary condition, such as a server being up or down, this works well. But sometimes you’ll need to account for even more variability. For example, let’s say you have a server that you know doesn’t have the file you want to get, and you’ve stored the name of that server in the variable <span class="literal">$problemServer</span> (add this line of code to the script on your own!). This means you need an extra check to see whether the server you’re dealing with is the problem server. You could account for this statement by using a nested <span class="literal">if</span>, as in the following code:</p>&#13;
<pre>if (Test-Connection -ComputerName $servers[0] -Quiet -Count 1) {&#13;
    if ($servers[0] –eq $problemServer) {&#13;
        Write-Error -Message "The server $servers[0] does not have the right file!"&#13;
    } else {&#13;
        Get-Content -Path "\\$servers[0]\c$\App_configuration.txt"&#13;
    }&#13;
} else {&#13;
    Write-Error -Message "The server $servers[0] is not responding!"&#13;
}&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_52"/>But a cleaner way to write this same logic is to use an <span class="literal">elseif</span> statement, which lets you add an extra condition to check before falling back on the code in the <span class="literal">else</span> block. The syntax of an <span class="literal">elseif</span> block is identical to that of an <span class="literal">if</span> block. So, to check for the problem server by using <span class="literal">elseif</span> statements, try the code in <a href="ch04.xhtml#ch4list5">Listing 4-5</a>.</p>&#13;
<pre>if (-not (Test-Connection -ComputerName $servers[0] -Quiet -Count 1)) { <span class="ent">❶</span>&#13;
    Write-Error -Message "The server $servers[0] is not responding!"&#13;
} elseif ($servers[0] –eq $problemServer) { <span class="ent">❷</span>&#13;
    Write-Error -Message "The server $servers[0] does not have the right file!"&#13;
} else {&#13;
    Get-Content -Path "\\$servers[0]\c$\App_configuration.txt" <span class="ent">❸</span>&#13;
} &#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch4list5"><em>Listing 4-5: Using an <span class="codeitalic">elseif</span> block</em></p>&#13;
<p class="indent">Notice that you haven’t just added an <span class="literal">elseif</span>; you’ve also changed the logic. Now you check to see whether the server is offline by first using the <span class="literal">–not</span> operator <span class="ent">❶</span>. Then, once you’ve determined whether the server is online, you check to see whether it’s a problem server <span class="ent">❷</span>. If it’s not, you use the <span class="literal">else</span> statement to run the default behavior—getting the file <span class="ent">❸</span>. As you can see, there are multiple ways to structure code like this. What matters is that the code works and is readable to someone seeing it with fresh eyes, whether that’s a coworker reading it for the first time, or you looking back at a script you wrote a while ago.</p>&#13;
<p class="indent">You can chain together as many <span class="literal">elseif</span> statements as you like, which allows you to account for many scenarios. However, <span class="literal">elseif</span> statements are mutually exclusive: when one <span class="literal">elseif</span> evaluates to <span class="literal">True</span>, PowerShell will run only the code in its block and will not test the rest of the cases. In <a href="ch04.xhtml#ch4list5">Listing 4-5</a>, this didn’t cause any issues, as you needed to test only whether you were working with the problem server after you had checked that it was up, but it’s something to keep in mind moving forward.</p>&#13;
<p class="indent">The <span class="literal">if</span>, <span class="literal">else</span>, and <span class="literal">elseif</span> statements are great for handling simple yes/no questions. In the next section, you’ll learn how to handle slightly more complicated logic.</p>&#13;
<h4 class="h4" id="ch4lev2sec5">The switch Statement</h4>&#13;
<p class="noindent">Let’s tweak our example a bit. Say you have five servers, and <em>each</em> server has the file in a different path. Based on what you know now, you’d need to write a separate <span class="literal">elseif</span> statement for each individual server. This would work, but there’s a cleaner method.</p>&#13;
<p class="indent">Notice that now you’re working with a different kind of condition. Whereas before you wanted the answers to yes/no questions, here you want to know the specific value of one thing: Is the server <span class="literal">SRV1</span>? Is it <span class="literal">SRV2</span>? And so forth. If you were working with only one or two specific values, an <span class="literal">if</span> would do, but in this case, using a <span class="literal">switch</span> statement would be cleaner.</p>&#13;
<p class="indent">A <span class="literal">switch</span> statement allows you to execute various pieces of code based on a value. It consists of the <span class="literal">switch</span> keyword followed by an expression in <span epub:type="pagebreak" id="page_53"/>parentheses. Inside the <span class="literal">switch</span> block are a series of statements that have a value, followed by a set of curly brackets containing a code block, and eventually a <span class="literal">default</span> block, as in <a href="ch04.xhtml#ch4list6">Listing 4-6</a>.</p>&#13;
<pre>switch (<span class="codeitalic1">expression</span>) {&#13;
    <span class="codeitalic1">expressionvalue</span> {&#13;
        # Do something with code here.&#13;
    }&#13;
    <span class="codeitalic1">expressionvalue</span> {&#13;
    }&#13;
    default {&#13;
        # Stuff to do if no matches were found&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch4list6"><em>Listing 4-6: Template for a <span class="codeitalic">switch</span> statement</em></p>&#13;
<p class="indent">A <span class="literal">switch</span> statement can contain an (almost) unlimited number of values. If the expression evaluates to a value, the code inside that value’s block is executed. Critically, unlike with <span class="literal">elseif</span>, after one code block runs, PowerShell will continue to evaluate the other conditions unless otherwise specified. If none of the values match the evaluated value, PowerShell executes the code embedded under the <span class="literal">default</span> keyword. To force PowerShell to stop evaluating conditions in the <span class="literal">switch</span> statement, use the <span class="literal">break</span> keyword at the end of the code block, as in <a href="ch04.xhtml#ch4list7">Listing 4-7</a>.</p>&#13;
<pre>switch (<span class="codeitalic1">expression</span>) {&#13;
    <span class="codeitalic1">expressionvalue</span> {&#13;
        # Do something with code here.&#13;
        break&#13;
    }&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch4list7"><em>Listing 4-7: Using the <span class="codeitalic">break</span> keyword in a <span class="codeitalic">switch</span> statement</em></p>&#13;
<p class="indent">The <span class="literal">break</span> keyword can be used to make your <span class="literal">switch</span> conditions mutually exclusive. Let’s go back to our example of five servers with the same file at different paths. You know that the server you’re working with can have only one value (it can’t be both <span class="literal">SRV1</span> and <span class="literal">SRV2</span>), so you have to use <span class="literal">break</span> statements. Your script should look something like <a href="ch04.xhtml#ch4list8">Listing 4-8</a>.</p>&#13;
<pre>$currentServer = $servers[0]&#13;
switch ($currentServer) {&#13;
    $servers[0] {&#13;
        # Check if server is online and get content at SRV1 path.&#13;
        break&#13;
    }&#13;
    $servers[1] {&#13;
        ## Check if server is online and get content at SRV2 path.&#13;
        break&#13;
    }&#13;
&#13;
    $servers[2] {&#13;
<span epub:type="pagebreak" id="page_54"/>        ## Check if server is online and get content at SRV3 path.&#13;
        break&#13;
    }&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch4list8"><em>Listing 4-8: Checking various servers by using a <span class="codeitalic">switch</span> statement</em></p>&#13;
<p class="indent">You could rewrite this code by using only <span class="literal">if</span> and <span class="literal">elseif</span> statements (and I encourage you to try!). But however you choose to write it, you’ll have to repeat the same structure for each server in your list, meaning that your script is going to get pretty long—and just think about if you wanted to test 500 servers instead of 5. In the next section, you’ll learn how to spare yourself that trouble by using one of the most fundamental control flow structures: the loop.</p>&#13;
<h3 class="h3" id="ch4lev3">Using Loops</h3>&#13;
<p class="noindent">A good rule of thumb for computer work: Don’t Repeat Yourself (DRY). If you find yourself doing the same thing more than once, chances are there’s a way to automate it. The same is true of writing code: if you’re using the same lines of code over and over, there’s probably a better solution.</p>&#13;
<p class="indent">One way to avoid repetitive code is to use loops. A <em>loop</em> lets you execute code repeatedly until a condition changes. The <em>stop condition</em> can be used to run a loop a set number of times, or until a boolean value has changed, or even to have a loop run infinitely. We call each run of the loop an <em>iteration</em>.</p>&#13;
<p class="indent">PowerShell offers five types of loops: <span class="literal">foreach</span>, <span class="literal">for</span>, <span class="literal">do/while</span>, <span class="literal">do/until</span>, and <span class="literal">while</span>. This section explains each type of loop, noting what makes it unique, and highlighting the best situations to use it.</p>&#13;
<h4 class="h4" id="ch4lev3sec6">The foreach Loop</h4>&#13;
<p class="noindent">We’ll start with the type of loop you’ll probably use the most in PowerShell, the <span class="literal">foreach</span> loop. A <span class="literal">foreach</span> loop goes through a list of objects and performs the same action for every object, ending when it’s finished with the last one. This list of objects is typically represented by an array. When you run a loop over a list of objects, we say you’re <em>iterating</em> over the list.</p>&#13;
<p class="indent">A <span class="literal">foreach</span> loop is useful when you have to perform the same task on a lot of different, but related, objects. Let’s go back to <a href="ch04.xhtml#ch4list1">Listing 4-1</a> (reproduced here):</p>&#13;
<pre>$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')&#13;
Get-Content -Path "\\$($servers[0])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[1])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[2])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[3])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[4])\c$\App_configuration.txt"</pre>&#13;
<p class="indent">You’re going to ignore all the fancy logic you added in the preceding section for now and put this into a <span class="literal">foreach</span> loop. But unlike other loops in PowerShell, the <span class="literal">foreach</span> loop can be used in three ways: as a <span class="literal">foreach</span> <span epub:type="pagebreak" id="page_55"/>statement, as a <span class="literal">ForEach-Object</span> cmdlet, or as a <span class="literal">foreach()</span> method. Although each is similar to use, you should understand the differences. In the following three sections, you’ll rewrite <a href="ch04.xhtml#ch4list1">Listing 4-1</a> by using each type of <span class="literal">foreach</span> loop.</p>&#13;
<h5 class="h5">The foreach Statement</h5>&#13;
<p class="noindent">The first type of <span class="literal">foreach</span> you’ll look at is the <span class="literal">foreach</span> statement. <a href="ch04.xhtml#ch4list9">Listing 4-9</a> has the loop version of <a href="ch04.xhtml#ch4list1">Listing 4-1</a>.</p>&#13;
<pre>foreach ($server in $servers) {&#13;
    Get-Content -Path "\\$server\c$\App_configuration.txt"&#13;
}</pre>&#13;
<p class="caption" id="ch4list9"><em>Listing 4-9: Using a <span class="codeitalic">foreach</span> statement</em></p>&#13;
<p class="indent">As you can see, the <span class="literal">foreach</span> statement is followed by parentheses that contain three elements, in order: a variable, the keyword <span class="literal">in</span>, and the object or array to iterate over. The variable you provide can have any name, but I recommend keeping the name as descriptive as possible.</p>&#13;
<p class="indent">As it moves through the list, PowerShell will <em>copy</em> the object it’s looking at into the variable. Note that because the variable is just a copy, you cannot directly change the item in the original list. To test this, try running the following:</p>&#13;
<pre>$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')&#13;
foreach ($server in $servers) {&#13;
    $server = "new $server"&#13;
}&#13;
$servers</pre>&#13;
<p class="indent">You should get something like this:</p>&#13;
<pre>SRV1&#13;
SRV2&#13;
SRV3&#13;
SRV4&#13;
SRV5</pre>&#13;
<p class="indent">Nothing changed! This is because you’re modifying only a copy of the original variable in the array. This is one of the downsides of using a <span class="literal">foreach</span> loop (of any kind). To directly modify the original contents of the list you’re looping through, you have to use one of the other loop types.</p>&#13;
<h5 class="h5">The ForEach-Object cmdlet</h5>&#13;
<p class="noindent">Like the <span class="literal">foreach</span> statement, the <span class="literal">ForEach-Object</span> cmdlet can iterate over a set of objects and perform an action. But because <span class="literal">ForEach-Object</span> is a cmdlet, you have to pass that set of objects and the action to complete as parameters.</p>&#13;
<p class="indent">Check out <a href="ch04.xhtml#ch4list10">Listing 4-10</a> to see how you’d do the same thing as <a href="ch04.xhtml#ch4list9">Listing 4-9</a> with the <span class="literal">ForEach-Object</span> cmdlet.</p>&#13;
<pre><span epub:type="pagebreak" id="page_56"/>$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')&#13;
ForEach-Object -InputObject $servers -Process {&#13;
    Get-Content -Path "\\$_\c$\App_configuration.txt"&#13;
}</pre>&#13;
<p class="caption" id="ch4list10"><em>Listing 4-10: Using the <span class="codeitalic">ForEach-Object</span> cmdlet</em></p>&#13;
<p class="indent">A bit is different here, so let’s walk through it. Notice that the <span class="literal">ForEach-Object</span> cmdlet takes an <span class="literal">InputObject</span> parameter. In this case, you’re using the <span class="literal">$servers</span> array, but you could use any object, such as a string or integer. In those cases, PowerShell will simply perform a single iteration. The cmdlet also accepts a <span class="literal">Process</span> parameter, which should be a scriptblock containing the code you’d like to run for each element inside the input object. (A <em>scriptblock</em> is a collection of statements that you pass into a cmdlet as a single unit.)</p>&#13;
<p class="indent">You may have noticed something else strange about <a href="ch04.xhtml#ch4list10">Listing 4-10</a>. Instead of using a <span class="literal">$server</span> variable, as you did with the <span class="literal">foreach</span> statement, you use the syntax <span class="literal">$_</span>. This special syntax represents the current object in the pipeline. The major difference between the <span class="literal">foreach</span> statement and the <span class="literal">ForEach-Object</span> cmdlet is that the cmdlet accepts pipeline input. In practice, <span class="literal">ForEach-Object</span> is almost always used by passing in the <span class="literal">InputObject</span> parameter through the pipeline, like so:</p>&#13;
<pre>$servers | ForEach-Object -Process {&#13;
    Get-Content -Path "\\$_\c$\App_configuration.txt"&#13;
}</pre>&#13;
<p class="indent">The <span class="literal">ForEach-Object</span> cmdlet can be a major time-saver.</p>&#13;
<h5 class="h5">The foreach() Method</h5>&#13;
<p class="noindent">The final type of <span class="literal">foreach</span> loop you’ll look at is the <span class="literal">foreach()</span> object method, introduced in PowerShell V4. The <span class="literal">foreach()</span> method exists on all arrays in PowerShell, and can be used to accomplish the same thing as <span class="literal">foreach</span> and <span class="literal">ForEach-Object</span>. The <span class="literal">foreach()</span> method accepts a scriptblock parameter that should contain the code to execute each iteration. As with <span class="literal">ForEach-Object</span>, you use <span class="literal">$_</span> to capture the current iteration’s object, as you can see in <a href="ch04.xhtml#ch4list11">Listing 4-11</a>.</p>&#13;
<pre>$servers.foreach({Get-Content -Path "\\$_\c$\App_configuration.txt"})</pre>&#13;
<p class="caption" id="ch4list11"><em>Listing 4-11: Using the <span class="codeitalic">foreach()</span> method</em></p>&#13;
<p class="indent">The <span class="literal">foreach()</span> method is considerably faster than the other two, and noticeably so when processing large datasets. I recommend that you use this method over the other two wherever possible.</p>&#13;
<p class="indent">A <span class="literal">foreach</span> loop is great when you want to perform a task on an object-by-object basis. But say you want to do something simpler. What if you wanted to execute a task a certain number of times?</p>&#13;
<h4 class="h4" id="ch4lev3sec7"><span epub:type="pagebreak" id="page_57"/>The for Loop</h4>&#13;
<p class="noindent">To execute code a predetermined number of times, you use a <span class="literal">for</span> loop. <a href="ch04.xhtml#ch4list12">Listing 4-12</a> shows the syntax for a basic <span class="literal">for</span> loop.</p>&#13;
<pre>for (<span class="ent">❶</span>$i = 0; <span class="ent">❷</span>$i -lt 10; <span class="ent">❸</span>$i++) {&#13;
    <span class="ent">❹</span> $i&#13;
}</pre>&#13;
<p class="caption" id="ch4list12"><em>Listing 4-12: A simple <span class="codeitalic">for</span> loop</em></p>&#13;
<p class="indent">A <span class="literal">for</span> loop consists of four pieces: the <em>iteration variable</em> declaration <span class="ent">❶</span>, the condition to continue running the loop <span class="ent">❷</span>, the action to perform on the iteration variable after each successful loop <span class="ent">❸</span>, and the code you want to execute <span class="ent">❹</span>. In this example, you start the loop by initializing the variable <span class="literal">$i</span> to 0. Then, you check to see whether <span class="literal">$i</span> is less than 10; if it is, you execute the code in the curly brackets, which prints <span class="literal">$ix</span>. After the code has executed, you increment <span class="literal">$i</span> by 1 <span class="ent">❸</span> and then check whether it is still smaller than 10 <span class="ent">❷</span>. You repeat this process until <span class="literal">$i</span> is no longer less than 10, resulting in 10 iterations.</p>&#13;
<p class="indent">A <span class="literal">for</span> loop can be used like this to execute a task any number of times—simply replace the condition <span class="ent">❷</span> to fit your needs. But the <span class="literal">for</span> loop has many more uses. One of the most powerful is manipulating the elements in an array. Earlier, you saw how you <em>couldn’t</em> use a <span class="literal">foreach</span> loop to change the elements in your array. Let’s try again, using a <span class="literal">for</span> loop:</p>&#13;
<pre>$servers = @('SERVER1','SERVER2','SERVER3','SERVER4','SERVER5')&#13;
for ($i = 0; $i –lt $servers.Length; $i++) {&#13;
    $servers[$i] = "new $($servers[$i])"&#13;
}&#13;
$servers</pre>&#13;
<p class="indent">Try running this script. The server names should change.</p>&#13;
<p class="indent">A <span class="literal">for</span> loop is also particularly useful when performing an action that requires multiple elements in the array. For instance, let’s say that your <span class="literal">$servers</span> array is arranged in a particular order, and you want to know which server comes after which. To do this, you could use a <span class="literal">for</span> loop:</p>&#13;
<pre>for (<span class="ent">❶</span>$i = 1; $i –lt $servers.Length; $i++) {&#13;
    Write-Host $servers[$i] "comes after" $servers[$i-1]&#13;
}</pre>&#13;
<p class="indent">Notice that this time you declare the iteration variable to start at 1 <span class="ent">❶</span>. This ensures that you don’t try to access the server that comes before the first one, which would give you an error.</p>&#13;
<p class="indent">As you’ll see over the course of this book, the <span class="literal">for</span> loop is a powerful tool that has many uses outside the simple examples provided here. For now, let’s move on to the next type of loop.</p>&#13;
<h4 class="h4" id="ch4lev3sec8"><span epub:type="pagebreak" id="page_58"/>The while Loop</h4>&#13;
<p class="noindent">The <span class="literal">while</span> loop is the simplest loop: while a condition is true, do something. To get a sense of the <span class="literal">while</span> loop syntax, let’s rewrite the <span class="literal">for</span> loop from <a href="ch04.xhtml#ch4list12">Listing 4-12</a> as shown in <a href="ch04.xhtml#ch4list13">Listing 4-13</a>.</p>&#13;
<pre>$counter = 0&#13;
while ($counter -lt 10) {&#13;
    $counter&#13;
    $counter++&#13;
}</pre>&#13;
<p class="caption" id="ch4list13"><em>Listing 4-13: A simple counter using a <span class="codeitalic">while</span> loop</em></p>&#13;
<p class="indent">As you can see, to use a <span class="literal">while</span> loop, just place the condition you want to evaluate inside the parentheses, and the code you want to run inside the curly brackets.</p>&#13;
<p class="indent">The <span class="literal">while</span> loop is best used when the number of iterations for the loop is <em>not</em> predetermined. Say you have a Windows server (again called <span class="literal">$problemServer</span>) that’s frequently going down. But there’s a file you need on it, and you don’t want to sit there testing the server every few minutes to get it. You can use a <span class="literal">while</span> loop to automate this process for you, as in <a href="ch04.xhtml#ch4list14">Listing 4-14</a>.</p>&#13;
<pre>while (Test-Connection -ComputerName $problemServer -Quiet -Count 1) {&#13;
    Get-Content -Path "\\$problemServer\c$\App_configuration.txt"  &#13;
    break&#13;
}</pre>&#13;
<p class="caption" id="ch4list14"><em>Listing 4-14: Using a <span class="codeitalic">while</span> loop to deal with a problematic server</em></p>&#13;
<p class="indent">By using a <span class="literal">while</span> loop instead of an <span class="literal">if</span>, you can repeatedly check to see whether the service is up. Then, once you get the content you need, you can <span class="literal">break</span> out of the loop to make sure you don’t continue to check the server. The <span class="literal">break</span> keyword can be used in any loop to stop the loop from running. This is especially important when using one of the most common <span class="literal">while</span> loops: the <span class="literal">while($true)</span> loop. By using <span class="literal">$true</span> as your condition, your <span class="literal">while</span> loop will run forever unless you stop it with a <span class="literal">break</span> or keyboard input.</p>&#13;
<h4 class="h4" id="ch4lev3sec9">The do/while and do/until Loops</h4>&#13;
<p class="noindent">Similar to the <span class="literal">while</span> loop are the <span class="literal">do/while</span> and <span class="literal">do/until</span> loops. The two are essentially inverses: the <span class="literal">do/while</span> loop does something <em>while</em> a condition is true, and the <span class="literal">do/until</span> loop does something <em>until</em> a condition is true.</p>&#13;
<p class="indent">An empty <span class="literal">do/while</span> loop looks like this:</p>&#13;
<pre>do {&#13;
    } while ($true)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_59"/>As you can see, the <span class="literal">do</span> code comes before the <span class="literal">while</span> condition. The major difference between a <span class="literal">while</span> loop and a <span class="literal">do/while</span> loop is that a <span class="literal">do/while</span> loop will execute the code <em>before</em> the condition is evaluated.</p>&#13;
<p class="indent">This can be useful in certain situations, particularly when you are continually receiving input from a source and want to evaluate it. For example, say you want to prompt the user to ask them for the best programming language. To do so, you could use the code in <a href="ch04.xhtml#ch4list15">Listing 4-15</a>. Here, you’ll use the <span class="literal">do/until</span> loop:</p>&#13;
<pre>do {&#13;
    $choice = Read-Host -Prompt 'What is the best programming language?'&#13;
} until ($choice -eq 'PowerShell')&#13;
Write-Host -Object 'Correct!'</pre>&#13;
<p class="caption" id="ch4list15"><em>Listing 4-15: Using a <span class="codeitalic">do/until</span> loop</em></p>&#13;
<p class="indent">The <span class="literal">do/while</span> and <span class="literal">do/until</span> loops are <em>very</em> similar. Often this means you can accomplish the same thing using each loop simply by inverting the condition, as you’ve done here.</p>&#13;
<h3 class="h3" id="ch4lev4">Summary</h3>&#13;
<p class="noindent">We covered a lot in this chapter. You learned about control flow, and how to use conditional logic to introduce alternative paths through your code. You saw various types of control flow statements, including the <span class="literal">if</span> statement, <span class="literal">switch</span> statement, and <span class="literal">foreach</span>, <span class="literal">for</span>, and <span class="literal">while</span> loops. Finally, you gained some hands-on experience, using PowerShell to check whether servers are up and to access files on them.</p>&#13;
<p class="indent">You can use conditional logic to handle some errors, but chances are you’ll miss something. In <a href="ch05.xhtml#ch5">Chapter 5</a>, you’ll take a closer look at errors and some techniques you can use to handle them.<span epub:type="pagebreak" id="page_60"/></p>&#13;
</body></html>