<html><head></head><body>
<h2 class="h2" id="ch4"><span epub:type="pagebreak" id="page_47"/><span class="big">4</span><br/>CONTROL FLOW</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">Let’s do a quick recap. In <a href="ch03.xhtml#ch3">Chapter 3</a>, you learned how to combine commands by using the pipeline and external scripts. In <a href="ch02.xhtml#ch2">Chapter 2</a>, you learned how to use variables to store values. One of the major benefits of working with variables is they allow you to write code that deals with</span> what a value means: instead of working with the number 3, for example, you’ll work with the more general <code>$serverCount</code>, so you can write code that runs the same whether you have one, or two, or a thousand servers. Combine this ability to write general solutions with the ability to store your code in a script that you can run on many computers, and you can start solving problems at a much bigger scale.</p>&#13;
<p class="indent">But in the real world, sometimes it matters whether you’re working with one server, or two servers, or a thousand. Right now, you don’t have a good way to account for that: your scripts run in one direction—top to bottom—and they don’t have any way of changing based on the specific values you’re working with. In this chapter, you’ll use control flow and conditional logic to write scripts that execute different sequences of instructions based on <span epub:type="pagebreak" id="page_48"/>the values they’re working with. By the end of the chapter, you’ll know how to use <code>if/then</code> statements, <code>switch</code> statements, and all manner of loops to give your code some much-needed flexibility.</p>&#13;
<h3 class="h3" id="ch4lev1">Understanding Control Flow</h3>&#13;
<p class="noindent">You’re going to write a script that reads the contents of a file stored in various remote computers. To follow along, download a file called <em>App_configuration.txt</em> from the book’s resources at <a href="https://github.com/adbertram/PowerShellForSysadmins/"><em>https://github.com/adbertram/PowerShellForSysadmins/</em></a> and place it in the root of the <em>C:\</em> drive of a few remote computers. (If you don’t have access to remote servers, just follow along in the text for now.) In this example, I’ll be using servers with the names <code>SRV1</code>, <code>SRV2</code>, <code>SRV3</code>, <code>SRV4</code>, and <code>SRV5</code>.</p>&#13;
<p class="indent">To access the file’s contents, you’ll use the <code>Get-Content</code> command and provide the path to the file as the argument to the <code>Path</code> parameter, as shown here:</p>&#13;
<pre>Get-Content -Path "\\<span class="codeitalic1">servername</span>\c$\App_configuration.txt"</pre>&#13;
<p class="indent">As a first attempt, let’s store all our server names in an array, and run this command for every server in the array. Open a new <em>.ps1</em> file and enter the code in <a href="ch04.xhtml#ch4list1">Listing 4-1</a>.</p>&#13;
<pre>$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')&#13;
Get-Content -Path "\\$($servers[0])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[1])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[2])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[3])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[4])\c$\App_configuration.txt"</pre>&#13;
<p class="caption" id="ch4list1"><em>Listing 4-1: Getting the contents of a file on multiple servers</em></p>&#13;
<p class="indent">In theory, this code will run with no problems. But this example assumes that everything in your environment is pristine. What if <code>SRV2</code> is down? What if someone forgot to move <em>App_configuration.txt</em> onto <code>SRV4</code>? Or used a different file path? You could write a different script for each server, but that solution won’t scale—especially as you start to add more and more servers. What you need is code that can execute differently depending on what it encounters.</p>&#13;
<p class="indent">That’s the basic idea behind <em>control flow</em>, the ability to have your code execute different sequences of instructions depending on predetermined logic. You can think of your scripts as executing along a certain path. Right now, that path goes straight from the first line of code to the last one, but you can use control flow statements to add forks in the road, circle back to places you’ve already been, or take you over lines. By introducing different paths for your script to run along, you allow for much greater flexibility, enabling you to write a single script that can handle many situations.</p>&#13;
<p class="indent">You’ll start by looking at the most basic type of control flow: the conditional statement.</p>&#13;
<h3 class="h3" id="ch4lev2"><span epub:type="pagebreak" id="page_49"/>Using Conditional Statements</h3>&#13;
<p class="noindent">In <a href="ch02.xhtml#ch2">Chapter 2</a>, you learned about the concept of a boolean: a true or false value. You use booleans to build <em>conditional statements</em>, which tell PowerShell to execute a certain code block based on whether an expression (called a <em>condition</em>) evaluates to <code>True</code> or <code>False</code>. A condition is a yes/no question: Do you have more than five servers? Is server 3 up? Does this file path exist? To start using conditional statements, let’s see how to translate these kinds of questions into expressions.</p>&#13;
<h4 class="h4" id="ch4lev2sec1">Building Expressions by Using Operators</h4>&#13;
<p class="noindent">You can write expressions by using <em>comparison operators</em>, which compare values. To use a comparison operator, you put it between two values, like this:</p>&#13;
<pre>PS&gt; <span class="codestrong1">1 –eq 1</span>&#13;
True</pre>&#13;
<p class="indent">You use the <code>–eq</code> operator to determine whether two values are equal. Here’s a list of the most common comparison operators you’ll use:</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-eq</span></strong> Compares two values and returns <code>True</code> if they are equal.</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-ne</span></strong> Compares two values and returns <code>True</code> if they are not equal.</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-gt</span></strong> Compares two values and returns <code>True</code> if the first is greater than the second.</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-ge</span></strong> Compares two values and returns <code>True</code> if the first is greater than or equal to the second.</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-lt</span></strong> Compares two values and returns <code>True</code> if the first is less than the second.</p>&#13;
<p class="noindenti"><strong><span class="codestrong">-le</span></strong> Compares two values and returns <code>True</code> if the first is less than or equal to the second.</p>&#13;
<p class="noindentib"><strong><span class="codestrong">-contains</span></strong> Returns <code>True</code> if the second value is “in” the first. You can use this to determine whether a value is inside an array.</p>&#13;
<p class="indent">PowerShell offers more advanced comparison operators. I won’t go into them now, but I encourage you to read about them in the Microsoft documentation at <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators"><em>https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators</em></a><em>/</em>, or in the PowerShell help (see <a href="ch01.xhtml#ch1">Chapter 1</a>).</p>&#13;
<p class="indent">You can use the preceding operators to compare variables and values. But an expression doesn’t have to be a comparison. Sometimes PowerShell commands can be used as conditions. In the previous example, you wanted to know whether a server was online. You can test to see whether a server can be pinged by using the <code>Test-Connection</code> cmdlet. Normally, the output of <code>Test-Connection</code> returns an object full of information, but by using the <code>Quiet</code> parameter, you can force the command to return a simple <code>True</code> or <code>False</code> and limit the test to a single attempt via the <code>Count</code> parameter.</p>&#13;
<pre><span epub:type="pagebreak" id="page_50"/>PS&gt; <span class="codestrong1">Test-Connection -ComputerName</span> <span class="codeitalicst1">offlineserver</span><span class="codestrong1"> -Quiet -Count 1</span>&#13;
False&#13;
&#13;
PS&gt; <span class="codestrong1">Test-Connection -ComputerName</span> <span class="codeitalicst1">onlineserver</span><span class="codestrong1"> -Quiet -Count 1</span>&#13;
True</pre>&#13;
<p class="indent">If you wanted to know whether the server was offline, you could use the <code>–not</code> operator to convert the expression to its opposite:</p>&#13;
<pre>PS&gt; <span class="codestrong1">-not (Test-Connection -ComputerName</span> <span class="codeitalicst1">offlineserver</span><span class="codestrong1"> -Quiet -Count 1)</span>&#13;
True</pre>&#13;
<p class="indent">Now that you’ve seen the basics of expressions, let’s look at the simplest conditional statement.</p>&#13;
<h4 class="h4" id="ch4lev2sec2">The if Statement</h4>&#13;
<p class="noindent">The <code>if</code> statement is straightforward: if <em>X</em> is true, then do <em>Y</em>. That’s it!</p>&#13;
<p class="indent">To write an <code>if</code> statement, you begin with an <code>if</code> keyword followed by parentheses containing a condition. After the expression comes a code block, demarcated in curly brackets. PowerShell will execute that code block only when the expression evaluates to <code>True</code>. If the <code>if</code> expression evaluates to <code>False</code> or returns nothing at all, the code block is skipped. You can see the basic syntax of an <code>if/then</code> statement in <a href="ch04.xhtml#ch4list2">Listing 4-2</a>.</p>&#13;
<pre>if (<span class="codeitalic1">condition</span>) {&#13;
    # code to run if the condition evaluates to be True&#13;
}</pre>&#13;
<p class="caption" id="ch4list2"><em>Listing 4-2: The syntax of an <span class="codeitalic">if</span> statement</em></p>&#13;
<p class="indent">This example uses a bit of new syntax: the hash mark (<code>#</code>) signals a <em>comment</em>, which is text PowerShell will ignore. You can use comments to leave yourself, or anyone else reading your code, helpful notes and descriptions.</p>&#13;
<p class="indent">Now let’s take a second look at the code in <a href="ch04.xhtml#ch4list1">Listing 4-1</a> and see how to use an <code>if</code> statement to make sure you don’t try to access a server that’s not up. In the preceding section, you saw how <code>Test-Connection</code> can be used as an expression that returns <code>True</code> or <code>False</code>, so let’s wrap a <code>Test-Connection</code> command in an <code>if</code> statement and then use <code>Get-Content</code> in the following code block to avoid accessing a server that’s down. For now, you’ll change the code for only the first server, as in <a href="ch04.xhtml#ch4list3">Listing 4-3</a>.</p>&#13;
<pre>$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')&#13;
if (Test-Connection -ComputerName $servers[0] -Quiet -Count 1) {&#13;
    Get-Content -Path "\\$($servers[0])\c$\App_configuration.txt"&#13;
}&#13;
Get-Content -Path "\\$($servers[1])\c$\App_configuration.txt"&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch4list3"><em>Listing 4-3: Using an <span class="codeitalic">if</span> statement to selectively get server content</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_51"/>Because you have <code>Get-Content</code> in an <code>if</code> statement, you won’t run into any errors if you try to access a dead server; if the test fails, your script will know not to attempt to read the file. You’ll try to access the server only if you <em>already</em> know it’s up. But notice that this code handles only the case in which the condition is true. Often enough, you’ll want to have one behavior if a condition is true and another behavior if it’s false. In the next section, you’ll see how to specify behavior for a false condition by using the <code>else</code> statement.</p>&#13;
<h4 class="h4" id="ch4lev2sec3">The else Statement</h4>&#13;
<p class="noindent">To add an alternate behavior to your <code>if</code> statement, you use the <code>else</code> keyword after the closing parenthesis of your <code>if</code> block, followed by another pair of curly brackets containing a code block. As shown in <a href="ch04.xhtml#ch4list4">Listing 4-4</a>, use an <code>else</code> statement to return an error to the console when the first server isn’t responding.</p>&#13;
<pre>if (Test-Connection -ComputerName $servers[0] -Quiet -Count 1) {&#13;
    Get-Content -Path "\\$($servers[0])\c$\App_configuration.txt"&#13;
} else {&#13;
    Write-Error -Message "The server $($servers[0]) is not responding!"&#13;
}</pre>&#13;
<p class="caption" id="ch4list4"><em>Listing 4-4: Using the <span class="codeitalic">else</span> statement to run code if the condition is not true</em></p>&#13;
<p class="indent">The <code>if/else</code> statement works perfectly when you have two mutually exclusive situations. Here, the server is either online or it’s not; you need only two branches of code. Let’s look at how to handle more complex situations.</p>&#13;
<h4 class="h4" id="ch4lev2sec4">The elseif Statement</h4>&#13;
<p class="noindent">The <code>else</code> statement works like a catchall: if the first <code>if</code> fails, do this no matter what. For a binary condition, such as a server being up or down, this works well. But sometimes you’ll need to account for even more variability. For example, let’s say you have a server that you know doesn’t have the file you want to get, and you’ve stored the name of that server in the variable <code>$problemServer</code> (add this line of code to the script on your own!). This means you need an extra check to see whether the server you’re dealing with is the problem server. You could account for this statement by using a nested <code>if</code>, as in the following code:</p>&#13;
<pre>if (Test-Connection -ComputerName $servers[0] -Quiet -Count 1) {&#13;
    if ($servers[0] –eq $problemServer) {&#13;
        Write-Error -Message "The server $servers[0] does not have the right file!"&#13;
    } else {&#13;
        Get-Content -Path "\\$servers[0]\c$\App_configuration.txt"&#13;
    }&#13;
} else {&#13;
    Write-Error -Message "The server $servers[0] is not responding!"&#13;
}&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_52"/>But a cleaner way to write this same logic is to use an <code>elseif</code> statement, which lets you add an extra condition to check before falling back on the code in the <code>else</code> block. The syntax of an <code>elseif</code> block is identical to that of an <code>if</code> block. So, to check for the problem server by using <code>elseif</code> statements, try the code in <a href="ch04.xhtml#ch4list5">Listing 4-5</a>.</p>&#13;
<pre>if (-not (Test-Connection -ComputerName $servers[0] -Quiet -Count 1)) { <span class="ent">❶</span>&#13;
    Write-Error -Message "The server $servers[0] is not responding!"&#13;
} elseif ($servers[0] –eq $problemServer) { <span class="ent">❷</span>&#13;
    Write-Error -Message "The server $servers[0] does not have the right file!"&#13;
} else {&#13;
    Get-Content -Path "\\$servers[0]\c$\App_configuration.txt" <span class="ent">❸</span>&#13;
} &#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch4list5"><em>Listing 4-5: Using an <span class="codeitalic">elseif</span> block</em></p>&#13;
<p class="indent">Notice that you haven’t just added an <code>elseif</code>; you’ve also changed the logic. Now you check to see whether the server is offline by first using the <code>–not</code> operator <span class="ent">❶</span>. Then, once you’ve determined whether the server is online, you check to see whether it’s a problem server <span class="ent">❷</span>. If it’s not, you use the <code>else</code> statement to run the default behavior—getting the file <span class="ent">❸</span>. As you can see, there are multiple ways to structure code like this. What matters is that the code works and is readable to someone seeing it with fresh eyes, whether that’s a coworker reading it for the first time, or you looking back at a script you wrote a while ago.</p>&#13;
<p class="indent">You can chain together as many <code>elseif</code> statements as you like, which allows you to account for many scenarios. However, <code>elseif</code> statements are mutually exclusive: when one <code>elseif</code> evaluates to <code>True</code>, PowerShell will run only the code in its block and will not test the rest of the cases. In <a href="ch04.xhtml#ch4list5">Listing 4-5</a>, this didn’t cause any issues, as you needed to test only whether you were working with the problem server after you had checked that it was up, but it’s something to keep in mind moving forward.</p>&#13;
<p class="indent">The <code>if</code>, <code>else</code>, and <code>elseif</code> statements are great for handling simple yes/no questions. In the next section, you’ll learn how to handle slightly more complicated logic.</p>&#13;
<h4 class="h4" id="ch4lev2sec5">The switch Statement</h4>&#13;
<p class="noindent">Let’s tweak our example a bit. Say you have five servers, and <em>each</em> server has the file in a different path. Based on what you know now, you’d need to write a separate <code>elseif</code> statement for each individual server. This would work, but there’s a cleaner method.</p>&#13;
<p class="indent">Notice that now you’re working with a different kind of condition. Whereas before you wanted the answers to yes/no questions, here you want to know the specific value of one thing: Is the server <code>SRV1</code>? Is it <code>SRV2</code>? And so forth. If you were working with only one or two specific values, an <code>if</code> would do, but in this case, using a <code>switch</code> statement would be cleaner.</p>&#13;
<p class="indent">A <code>switch</code> statement allows you to execute various pieces of code based on a value. It consists of the <code>switch</code> keyword followed by an expression in <span epub:type="pagebreak" id="page_53"/>parentheses. Inside the <code>switch</code> block are a series of statements that have a value, followed by a set of curly brackets containing a code block, and eventually a <code>default</code> block, as in <a href="ch04.xhtml#ch4list6">Listing 4-6</a>.</p>&#13;
<pre>switch (<span class="codeitalic1">expression</span>) {&#13;
    <span class="codeitalic1">expressionvalue</span> {&#13;
        # Do something with code here.&#13;
    }&#13;
    <span class="codeitalic1">expressionvalue</span> {&#13;
    }&#13;
    default {&#13;
        # Stuff to do if no matches were found&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch4list6"><em>Listing 4-6: Template for a <span class="codeitalic">switch</span> statement</em></p>&#13;
<p class="indent">A <code>switch</code> statement can contain an (almost) unlimited number of values. If the expression evaluates to a value, the code inside that value’s block is executed. Critically, unlike with <code>elseif</code>, after one code block runs, PowerShell will continue to evaluate the other conditions unless otherwise specified. If none of the values match the evaluated value, PowerShell executes the code embedded under the <code>default</code> keyword. To force PowerShell to stop evaluating conditions in the <code>switch</code> statement, use the <code>break</code> keyword at the end of the code block, as in <a href="ch04.xhtml#ch4list7">Listing 4-7</a>.</p>&#13;
<pre>switch (<span class="codeitalic1">expression</span>) {&#13;
    <span class="codeitalic1">expressionvalue</span> {&#13;
        # Do something with code here.&#13;
        break&#13;
    }&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch4list7"><em>Listing 4-7: Using the <span class="codeitalic">break</span> keyword in a <span class="codeitalic">switch</span> statement</em></p>&#13;
<p class="indent">The <code>break</code> keyword can be used to make your <code>switch</code> conditions mutually exclusive. Let’s go back to our example of five servers with the same file at different paths. You know that the server you’re working with can have only one value (it can’t be both <code>SRV1</code> and <code>SRV2</code>), so you have to use <code>break</code> statements. Your script should look something like <a href="ch04.xhtml#ch4list8">Listing 4-8</a>.</p>&#13;
<pre>$currentServer = $servers[0]&#13;
switch ($currentServer) {&#13;
    $servers[0] {&#13;
        # Check if server is online and get content at SRV1 path.&#13;
        break&#13;
    }&#13;
    $servers[1] {&#13;
        ## Check if server is online and get content at SRV2 path.&#13;
        break&#13;
    }&#13;
&#13;
    $servers[2] {&#13;
<span epub:type="pagebreak" id="page_54"/>        ## Check if server is online and get content at SRV3 path.&#13;
        break&#13;
    }&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch4list8"><em>Listing 4-8: Checking various servers by using a <span class="codeitalic">switch</span> statement</em></p>&#13;
<p class="indent">You could rewrite this code by using only <code>if</code> and <code>elseif</code> statements (and I encourage you to try!). But however you choose to write it, you’ll have to repeat the same structure for each server in your list, meaning that your script is going to get pretty long—and just think about if you wanted to test 500 servers instead of 5. In the next section, you’ll learn how to spare yourself that trouble by using one of the most fundamental control flow structures: the loop.</p>&#13;
<h3 class="h3" id="ch4lev3">Using Loops</h3>&#13;
<p class="noindent">A good rule of thumb for computer work: Don’t Repeat Yourself (DRY). If you find yourself doing the same thing more than once, chances are there’s a way to automate it. The same is true of writing code: if you’re using the same lines of code over and over, there’s probably a better solution.</p>&#13;
<p class="indent">One way to avoid repetitive code is to use loops. A <em>loop</em> lets you execute code repeatedly until a condition changes. The <em>stop condition</em> can be used to run a loop a set number of times, or until a boolean value has changed, or even to have a loop run infinitely. We call each run of the loop an <em>iteration</em>.</p>&#13;
<p class="indent">PowerShell offers five types of loops: <code>foreach</code>, <code>for</code>, <code>do/while</code>, <code>do/until</code>, and <code>while</code>. This section explains each type of loop, noting what makes it unique, and highlighting the best situations to use it.</p>&#13;
<h4 class="h4" id="ch4lev3sec6">The foreach Loop</h4>&#13;
<p class="noindent">We’ll start with the type of loop you’ll probably use the most in PowerShell, the <code>foreach</code> loop. A <code>foreach</code> loop goes through a list of objects and performs the same action for every object, ending when it’s finished with the last one. This list of objects is typically represented by an array. When you run a loop over a list of objects, we say you’re <em>iterating</em> over the list.</p>&#13;
<p class="indent">A <code>foreach</code> loop is useful when you have to perform the same task on a lot of different, but related, objects. Let’s go back to <a href="ch04.xhtml#ch4list1">Listing 4-1</a> (reproduced here):</p>&#13;
<pre>$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')&#13;
Get-Content -Path "\\$($servers[0])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[1])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[2])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[3])\c$\App_configuration.txt"&#13;
Get-Content -Path "\\$($servers[4])\c$\App_configuration.txt"</pre>&#13;
<p class="indent">You’re going to ignore all the fancy logic you added in the preceding section for now and put this into a <code>foreach</code> loop. But unlike other loops in PowerShell, the <code>foreach</code> loop can be used in three ways: as a <code>foreach</code> <span epub:type="pagebreak" id="page_55"/>statement, as a <code>ForEach-Object</code> cmdlet, or as a <code>foreach()</code> method. Although each is similar to use, you should understand the differences. In the following three sections, you’ll rewrite <a href="ch04.xhtml#ch4list1">Listing 4-1</a> by using each type of <code>foreach</code> loop.</p>&#13;
<h5 class="h5">The foreach Statement</h5>&#13;
<p class="noindent">The first type of <code>foreach</code> you’ll look at is the <code>foreach</code> statement. <a href="ch04.xhtml#ch4list9">Listing 4-9</a> has the loop version of <a href="ch04.xhtml#ch4list1">Listing 4-1</a>.</p>&#13;
<pre>foreach ($server in $servers) {&#13;
    Get-Content -Path "\\$server\c$\App_configuration.txt"&#13;
}</pre>&#13;
<p class="caption" id="ch4list9"><em>Listing 4-9: Using a <span class="codeitalic">foreach</span> statement</em></p>&#13;
<p class="indent">As you can see, the <code>foreach</code> statement is followed by parentheses that contain three elements, in order: a variable, the keyword <code>in</code>, and the object or array to iterate over. The variable you provide can have any name, but I recommend keeping the name as descriptive as possible.</p>&#13;
<p class="indent">As it moves through the list, PowerShell will <em>copy</em> the object it’s looking at into the variable. Note that because the variable is just a copy, you cannot directly change the item in the original list. To test this, try running the following:</p>&#13;
<pre>$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')&#13;
foreach ($server in $servers) {&#13;
    $server = "new $server"&#13;
}&#13;
$servers</pre>&#13;
<p class="indent">You should get something like this:</p>&#13;
<pre>SRV1&#13;
SRV2&#13;
SRV3&#13;
SRV4&#13;
SRV5</pre>&#13;
<p class="indent">Nothing changed! This is because you’re modifying only a copy of the original variable in the array. This is one of the downsides of using a <code>foreach</code> loop (of any kind). To directly modify the original contents of the list you’re looping through, you have to use one of the other loop types.</p>&#13;
<h5 class="h5">The ForEach-Object cmdlet</h5>&#13;
<p class="noindent">Like the <code>foreach</code> statement, the <code>ForEach-Object</code> cmdlet can iterate over a set of objects and perform an action. But because <code>ForEach-Object</code> is a cmdlet, you have to pass that set of objects and the action to complete as parameters.</p>&#13;
<p class="indent">Check out <a href="ch04.xhtml#ch4list10">Listing 4-10</a> to see how you’d do the same thing as <a href="ch04.xhtml#ch4list9">Listing 4-9</a> with the <code>ForEach-Object</code> cmdlet.</p>&#13;
<pre><span epub:type="pagebreak" id="page_56"/>$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')&#13;
ForEach-Object -InputObject $servers -Process {&#13;
    Get-Content -Path "\\$_\c$\App_configuration.txt"&#13;
}</pre>&#13;
<p class="caption" id="ch4list10"><em>Listing 4-10: Using the <span class="codeitalic">ForEach-Object</span> cmdlet</em></p>&#13;
<p class="indent">A bit is different here, so let’s walk through it. Notice that the <code>ForEach-Object</code> cmdlet takes an <code>InputObject</code> parameter. In this case, you’re using the <code>$servers</code> array, but you could use any object, such as a string or integer. In those cases, PowerShell will simply perform a single iteration. The cmdlet also accepts a <code>Process</code> parameter, which should be a scriptblock containing the code you’d like to run for each element inside the input object. (A <em>scriptblock</em> is a collection of statements that you pass into a cmdlet as a single unit.)</p>&#13;
<p class="indent">You may have noticed something else strange about <a href="ch04.xhtml#ch4list10">Listing 4-10</a>. Instead of using a <code>$server</code> variable, as you did with the <code>foreach</code> statement, you use the syntax <code>$_</code>. This special syntax represents the current object in the pipeline. The major difference between the <code>foreach</code> statement and the <code>ForEach-Object</code> cmdlet is that the cmdlet accepts pipeline input. In practice, <code>ForEach-Object</code> is almost always used by passing in the <code>InputObject</code> parameter through the pipeline, like so:</p>&#13;
<pre>$servers | ForEach-Object -Process {&#13;
    Get-Content -Path "\\$_\c$\App_configuration.txt"&#13;
}</pre>&#13;
<p class="indent">The <code>ForEach-Object</code> cmdlet can be a major time-saver.</p>&#13;
<h5 class="h5">The foreach() Method</h5>&#13;
<p class="noindent">The final type of <code>foreach</code> loop you’ll look at is the <code>foreach()</code> object method, introduced in PowerShell V4. The <code>foreach()</code> method exists on all arrays in PowerShell, and can be used to accomplish the same thing as <code>foreach</code> and <code>ForEach-Object</code>. The <code>foreach()</code> method accepts a scriptblock parameter that should contain the code to execute each iteration. As with <code>ForEach-Object</code>, you use <code>$_</code> to capture the current iteration’s object, as you can see in <a href="ch04.xhtml#ch4list11">Listing 4-11</a>.</p>&#13;
<pre>$servers.foreach({Get-Content -Path "\\$_\c$\App_configuration.txt"})</pre>&#13;
<p class="caption" id="ch4list11"><em>Listing 4-11: Using the <span class="codeitalic">foreach()</span> method</em></p>&#13;
<p class="indent">The <code>foreach()</code> method is considerably faster than the other two, and noticeably so when processing large datasets. I recommend that you use this method over the other two wherever possible.</p>&#13;
<p class="indent">A <code>foreach</code> loop is great when you want to perform a task on an object-by-object basis. But say you want to do something simpler. What if you wanted to execute a task a certain number of times?</p>&#13;
<h4 class="h4" id="ch4lev3sec7"><span epub:type="pagebreak" id="page_57"/>The for Loop</h4>&#13;
<p class="noindent">To execute code a predetermined number of times, you use a <code>for</code> loop. <a href="ch04.xhtml#ch4list12">Listing 4-12</a> shows the syntax for a basic <code>for</code> loop.</p>&#13;
<pre>for (<span class="ent">❶</span>$i = 0; <span class="ent">❷</span>$i -lt 10; <span class="ent">❸</span>$i++) {&#13;
    <span class="ent">❹</span> $i&#13;
}</pre>&#13;
<p class="caption" id="ch4list12"><em>Listing 4-12: A simple <span class="codeitalic">for</span> loop</em></p>&#13;
<p class="indent">A <code>for</code> loop consists of four pieces: the <em>iteration variable</em> declaration <span class="ent">❶</span>, the condition to continue running the loop <span class="ent">❷</span>, the action to perform on the iteration variable after each successful loop <span class="ent">❸</span>, and the code you want to execute <span class="ent">❹</span>. In this example, you start the loop by initializing the variable <code>$i</code> to 0. Then, you check to see whether <code>$i</code> is less than 10; if it is, you execute the code in the curly brackets, which prints <code>$ix</code>. After the code has executed, you increment <code>$i</code> by 1 <span class="ent">❸</span> and then check whether it is still smaller than 10 <span class="ent">❷</span>. You repeat this process until <code>$i</code> is no longer less than 10, resulting in 10 iterations.</p>&#13;
<p class="indent">A <code>for</code> loop can be used like this to execute a task any number of times—simply replace the condition <span class="ent">❷</span> to fit your needs. But the <code>for</code> loop has many more uses. One of the most powerful is manipulating the elements in an array. Earlier, you saw how you <em>couldn’t</em> use a <code>foreach</code> loop to change the elements in your array. Let’s try again, using a <code>for</code> loop:</p>&#13;
<pre>$servers = @('SERVER1','SERVER2','SERVER3','SERVER4','SERVER5')&#13;
for ($i = 0; $i –lt $servers.Length; $i++) {&#13;
    $servers[$i] = "new $($servers[$i])"&#13;
}&#13;
$servers</pre>&#13;
<p class="indent">Try running this script. The server names should change.</p>&#13;
<p class="indent">A <code>for</code> loop is also particularly useful when performing an action that requires multiple elements in the array. For instance, let’s say that your <code>$servers</code> array is arranged in a particular order, and you want to know which server comes after which. To do this, you could use a <code>for</code> loop:</p>&#13;
<pre>for (<span class="ent">❶</span>$i = 1; $i –lt $servers.Length; $i++) {&#13;
    Write-Host $servers[$i] "comes after" $servers[$i-1]&#13;
}</pre>&#13;
<p class="indent">Notice that this time you declare the iteration variable to start at 1 <span class="ent">❶</span>. This ensures that you don’t try to access the server that comes before the first one, which would give you an error.</p>&#13;
<p class="indent">As you’ll see over the course of this book, the <code>for</code> loop is a powerful tool that has many uses outside the simple examples provided here. For now, let’s move on to the next type of loop.</p>&#13;
<h4 class="h4" id="ch4lev3sec8"><span epub:type="pagebreak" id="page_58"/>The while Loop</h4>&#13;
<p class="noindent">The <code>while</code> loop is the simplest loop: while a condition is true, do something. To get a sense of the <code>while</code> loop syntax, let’s rewrite the <code>for</code> loop from <a href="ch04.xhtml#ch4list12">Listing 4-12</a> as shown in <a href="ch04.xhtml#ch4list13">Listing 4-13</a>.</p>&#13;
<pre>$counter = 0&#13;
while ($counter -lt 10) {&#13;
    $counter&#13;
    $counter++&#13;
}</pre>&#13;
<p class="caption" id="ch4list13"><em>Listing 4-13: A simple counter using a <span class="codeitalic">while</span> loop</em></p>&#13;
<p class="indent">As you can see, to use a <code>while</code> loop, just place the condition you want to evaluate inside the parentheses, and the code you want to run inside the curly brackets.</p>&#13;
<p class="indent">The <code>while</code> loop is best used when the number of iterations for the loop is <em>not</em> predetermined. Say you have a Windows server (again called <code>$problemServer</code>) that’s frequently going down. But there’s a file you need on it, and you don’t want to sit there testing the server every few minutes to get it. You can use a <code>while</code> loop to automate this process for you, as in <a href="ch04.xhtml#ch4list14">Listing 4-14</a>.</p>&#13;
<pre>while (Test-Connection -ComputerName $problemServer -Quiet -Count 1) {&#13;
    Get-Content -Path "\\$problemServer\c$\App_configuration.txt"  &#13;
    break&#13;
}</pre>&#13;
<p class="caption" id="ch4list14"><em>Listing 4-14: Using a <span class="codeitalic">while</span> loop to deal with a problematic server</em></p>&#13;
<p class="indent">By using a <code>while</code> loop instead of an <code>if</code>, you can repeatedly check to see whether the service is up. Then, once you get the content you need, you can <code>break</code> out of the loop to make sure you don’t continue to check the server. The <code>break</code> keyword can be used in any loop to stop the loop from running. This is especially important when using one of the most common <code>while</code> loops: the <code>while($true)</code> loop. By using <code>$true</code> as your condition, your <code>while</code> loop will run forever unless you stop it with a <code>break</code> or keyboard input.</p>&#13;
<h4 class="h4" id="ch4lev3sec9">The do/while and do/until Loops</h4>&#13;
<p class="noindent">Similar to the <code>while</code> loop are the <code>do/while</code> and <code>do/until</code> loops. The two are essentially inverses: the <code>do/while</code> loop does something <em>while</em> a condition is true, and the <code>do/until</code> loop does something <em>until</em> a condition is true.</p>&#13;
<p class="indent">An empty <code>do/while</code> loop looks like this:</p>&#13;
<pre>do {&#13;
    } while ($true)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_59"/>As you can see, the <code>do</code> code comes before the <code>while</code> condition. The major difference between a <code>while</code> loop and a <code>do/while</code> loop is that a <code>do/while</code> loop will execute the code <em>before</em> the condition is evaluated.</p>&#13;
<p class="indent">This can be useful in certain situations, particularly when you are continually receiving input from a source and want to evaluate it. For example, say you want to prompt the user to ask them for the best programming language. To do so, you could use the code in <a href="ch04.xhtml#ch4list15">Listing 4-15</a>. Here, you’ll use the <code>do/until</code> loop:</p>&#13;
<pre>do {&#13;
    $choice = Read-Host -Prompt 'What is the best programming language?'&#13;
} until ($choice -eq 'PowerShell')&#13;
Write-Host -Object 'Correct!'</pre>&#13;
<p class="caption" id="ch4list15"><em>Listing 4-15: Using a <span class="codeitalic">do/until</span> loop</em></p>&#13;
<p class="indent">The <code>do/while</code> and <code>do/until</code> loops are <em>very</em> similar. Often this means you can accomplish the same thing using each loop simply by inverting the condition, as you’ve done here.</p>&#13;
<h3 class="h3" id="ch4lev4">Summary</h3>&#13;
<p class="noindent">We covered a lot in this chapter. You learned about control flow, and how to use conditional logic to introduce alternative paths through your code. You saw various types of control flow statements, including the <code>if</code> statement, <code>switch</code> statement, and <code>foreach</code>, <code>for</code>, and <code>while</code> loops. Finally, you gained some hands-on experience, using PowerShell to check whether servers are up and to access files on them.</p>&#13;
<p class="indent">You can use conditional logic to handle some errors, but chances are you’ll miss something. In <a href="ch05.xhtml#ch5">Chapter 5</a>, you’ll take a closer look at errors and some techniques you can use to handle them.<span epub:type="pagebreak" id="page_60"/></p>&#13;
</body></html>