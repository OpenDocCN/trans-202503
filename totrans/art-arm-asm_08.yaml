- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 6 ARITHMETIC
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6 算术运算
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter discusses arithmetic computation in assembly language, including
    floating-point arithmetic on the ARM processor and architectural support for real
    arithmetic. By the end of this chapter, you should be able to translate arithmetic
    expressions and assignment statements from HLLs like Pascal, Swift, and C/C++
    into ARM assembly language. You’ll learn to pass floating-point values as parameters
    to procedures and return real values as function results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了汇编语言中的算术运算，包括ARM处理器上的浮点运算和对实数运算的架构支持。在本章结束时，你应该能够将高阶语言（如Pascal、Swift和C/C++）中的算术表达式和赋值语句转换为ARM汇编语言。你将学习如何将浮点值作为参数传递给过程，并将实数值作为函数结果返回。
- en: 6.1 Additional ARM Arithmetic Instructions
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1 额外的ARM算术指令
- en: Before learning to encode arithmetic expressions in assembly language, you should
    learn the rest of the arithmetic instructions in the ARM instruction set. Previous
    chapters have covered most of the arithmetic and logical instructions, so this
    section covers the remaining few.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何在汇编语言中编码算术表达式之前，你应该先学习ARM指令集中的其他算术指令。前面的章节已经涵盖了大部分的算术和逻辑指令，因此本节将介绍剩余的少数几条指令。
- en: 6.1.1 Multiplication
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1 乘法
- en: '[Chapter 4](chapter4.xhtml) provided a brief introduction to multiplication
    with the mul and madd instructions. As a reminder, those instructions are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](chapter4.xhtml)简要介绍了使用mul和madd指令进行的乘法。作为提醒，这些指令如下：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As long as overflow doesn’t occur, these instructions produce correct results
    for both unsigned and signed multiplications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 只要没有发生溢出，这些指令对无符号和有符号乘法都能产生正确的结果。
- en: These instructions multiply two 64-bit integers and produce a 64-bit result.
    The multiplication of two *n*-bit numbers can actually produce a 2 × *n*–bit result,
    meaning that multiplying two 64-bit registers could produce up to a 128-bit result.
    These instructions ignore any overflow and keep only the LO 64 bits of the product
    ([Chapter 8](chapter8.xhtml) discusses how to produce a full 128-bit result, if
    you require that).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将两个64位整数相乘并产生一个64位的结果。两个*n*位数相乘实际上可能会产生一个2 × *n*位的结果，这意味着将两个64位寄存器相乘可能会产生一个最多128位的结果。这些指令会忽略任何溢出，并且只保留结果的低64位（[第8章](chapter8.xhtml)讨论了如何生成完整的128位结果，如果你需要的话）。
- en: 'You can also specify 32-bit registers for these two instructions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为这两条指令指定32位寄存器：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These instructions produce 32-bit results, ignoring any overflow. There are
    two additional multiplication instructions: multiply and subtract, and multiply
    and negate:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令会生成32位结果，忽略任何溢出。还有两条额外的乘法指令：乘法并减法、乘法并取负：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As with the previous instructions, these multiplications ignore any overflow
    beyond 32 or 64 bits.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的指令一样，这些乘法操作会忽略32位或64位之外的溢出。
- en: The ARM does not provide multiplication instructions that affect the condition
    code flags. These instructions have no s-suffix versions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ARM不提供会影响条件码标志的乘法指令。这些指令没有带有s后缀的版本。
- en: 6.1.2 Division and Modulo
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2 除法和取模
- en: 'The ARM64 CPU provides only two division instructions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ARM64 CPU仅提供两条除法指令：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unlike with multiplication, you must use separate instructions for signed and
    unsigned integer values.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与乘法不同，对于有符号和无符号整数值，你必须使用不同的指令。
- en: 'Division has two special cases that you must consider: division by 0 and dividing
    the smallest negative number by –1 (which would, mathematically, produce an overflow).
    A division by 0 produces 0 as the result, with no indication of the problem. A
    signed division (sdiv) of 0x8000000000000000 (the smallest 64-bit negative number)
    by 0xFFFFFFFFFFFFFFFF (–1) will produce the result 0x8000000000000000, also without
    indication of an error. You’ll get similar results for the 32-bit division: 0x80000000
    / 0xFFFFFFFF. You must explicitly test for these operands before the division
    to catch these errors.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除法有两个特殊情况需要考虑：除以0和将最小的负数除以–1（在数学上会导致溢出）。除以0的结果是0，但没有任何错误提示。将0x8000000000000000（最小的64位负数）除以0xFFFFFFFFFFFFFFFF（–1）的有符号除法（sdiv）会得到0x8000000000000000，同样也不会提示错误。32位除法也会得到类似的结果：0x80000000
    / 0xFFFFFFFF。在除法前，你必须明确检查这些操作数，以便捕捉这些错误。
- en: 'There’s no single instruction to compute the remainder after a division operation
    on the ARM64 CPU. You can compute the remainder by combining a division and a
    multiplication operation:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ARM64 CPU 上没有单一指令来计算除法操作后的余数。您可以通过组合除法和乘法操作来计算余数：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, you can compute the same result by using the following two instructions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过使用以下两条指令来计算相同的结果：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After this sequence, X2 and X3 hold the following values
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在此序列之后，X2 和 X3 保存以下值
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: thus providing the modulo in X3.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从而在 X3 中提供模运算结果。
- en: 6.1.3 cmp Revisited
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3 cmp 操作回顾
- en: As noted in section 2.10.4, “cmp and Corresponding Conditional Branches,” on
    [page 78](chapter2.xhtml#pg_78), the cmp instruction updates the ARM’s flags according
    to the result of the subtraction operation (LeftOperand - RightOperand). Based
    on the way the ARM sets the flags, you can read this instruction as “compare LeftOperand
    to RightOperand.” You can test the result of the comparison by using conditional
    branch instructions (see [Chapter 2](chapter2.xhtml) for the conditional branches
    or [Chapter 7](chapter7.xhtml) for more on control structure implementations).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 2.10.4 节“cmp 和相应的条件分支”中所述，见 [第 78 页](chapter2.xhtml#pg_78)，cmp 指令会根据减法操作（左操作数
    - 右操作数）的结果更新 ARM 的标志。根据 ARM 设置标志的方式，您可以将此指令理解为“将左操作数与右操作数进行比较”。您可以通过使用条件分支指令来测试比较的结果（有关条件分支的详细内容，请参见[第
    2 章](chapter2.xhtml)，有关控制结构实现的更多内容，请参见[第 7 章](chapter7.xhtml)）。
- en: 'A good place to start when exploring cmp is to look at exactly how it affects
    the flags. Consider the following cmp instruction:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 cmp 时，一个好的起点是准确查看它如何影响标志。考虑以下 cmp 指令：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This instruction performs the computation W0 – W1 and sets the flags depending
    on the result of the computation. The flags are set as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令执行 W0 - W1 的计算，并根据计算结果设置标志。标志的设置如下：
- en: '**Z**    The zero flag is set if and only if W0 = W1\. This is the only time
    W0 – W1 produces a zero result. Hence, you can use the zero flag to test for equality
    or inequality.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Z**    当且仅当 W0 = W1 时，零标志会被设置。这是 W0 – W1 产生零结果的唯一情况。因此，您可以使用零标志来测试相等或不相等。'
- en: '**N**    The negative (sign) flag is set to 1 if the result is negative. You
    might think this flag would be set if W0 is less than W1, but this isn’t always
    the case. If W0 = 0x7FFFFFFFh and W1 = –1 (0xFFFFFFFF), then subtracting W1 from
    W0 produces 0x80000000, which is negative (so the negative flag will be set).
    For signed comparisons, at least, the negative flag doesn’t contain the proper
    status. For unsigned operands, consider W0 = 0xFFFFFFFF and W1 = 1\. Here, W0
    is greater than W1, but their difference is 0xFFFFFFFEh, which is still negative.
    As it turns out, the negative flag and the overflow flag, taken together, can
    be used for comparing two signed values.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**N**    如果结果为负数，负（符号）标志会被设置为 1。您可能认为只有当 W0 小于 W1 时该标志才会被设置，但事实并非总是如此。如果 W0
    = 0x7FFFFFFFh 且 W1 = -1（0xFFFFFFFF），那么从 W0 中减去 W1 会得到 0x80000000，这是负数（因此负标志会被设置）。至少对于带符号比较，负标志不会包含正确的状态。对于无符号操作数，考虑
    W0 = 0xFFFFFFFF 和 W1 = 1。在这里，W0 大于 W1，但它们的差值是 0xFFFFFFFEh，这仍然是负数。事实证明，负标志和溢出标志结合起来，可以用于比较两个带符号值。'
- en: '**V**    The overflow flag is set after a cmp operation if the difference of
    W0 and W1 produces a signed overflow or underflow. As mentioned previously, the
    sign and overflow flags are both used when performing signed comparisons.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**V**    在执行 cmp 操作后，如果 W0 和 W1 的差值导致符号溢出或下溢，溢出标志会被设置。如前所述，符号标志和溢出标志在执行带符号比较时都会被使用。'
- en: '**C**    The carry flag is set after a cmp operation if subtracting W1 from
    W0 requires a borrow (unsigned overflow or underflow). This occurs only when W0
    is less than W1, where W0 and W1 are both unsigned values.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**C**    如果从 W0 中减去 W1 时需要借位（无符号溢出或下溢），则会设置进位标志。仅当 W0 小于 W1 且 W0 和 W1 都是无符号值时，才会发生这种情况。'
- en: '[Table 6-1](chapter6.xhtml#tab6-1) shows how the cmp instruction affects the
    flags after comparing to unsigned or signed values.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-1](chapter6.xhtml#tab6-1) 显示了 cmp 指令在比较无符号或带符号值之后如何影响标志。'
- en: 'Table 6-1: Condition Code Settings After cmp'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1：cmp 操作后的条件代码设置
- en: '| Flag | Unsigned result | Signed result |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 无符号结果 | 带符号结果 |'
- en: '| --- | --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Zero (Z) | Equality/inequality | Equality/inequality |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 零（Z） | 相等/不相等 | 相等/不相等 |'
- en: '| Carry (C) | Left ≥ right (C = 1) Left < right (C = 0) | No meaning |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 进位（C） | 左边 ≥ 右边（C = 1） 左边 < 右边（C = 0） | 无意义 |'
- en: '| Overflow (V) | No meaning | See discussion in this section |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 溢出（V） | 无意义 | 请参阅本节讨论 |'
- en: '| Sign (N) | No meaning | See discussion in this section |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 符号（N） | 无意义 | 请参阅本节讨论 |'
- en: 'Given that the cmp instruction sets the flags in this fashion, you can test
    the comparison of the two signed operands with the following flags:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于cmp指令以这种方式设置标志，你可以通过以下标志测试两个有符号操作数的比较：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For signed comparisons, the N and V flags, taken together, have the following
    meanings:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号比较，N和V标志组合起来有以下含义：
- en: If [N != V], then Left < Right for a signed comparison.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[N != V]，则左操作数 < 右操作数（有符号比较）。
- en: If [N == V], then Left ≥ Right for a signed comparison.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[N == V]，则左操作数 ≥ 右操作数（有符号比较）。
- en: To understand why these flags are set in this manner, consider the 32-bit examples
    in [Table 6-2](chapter6.xhtml#tab6-2). The values easily sign-extend to 64 bits,
    and the results are the same.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这些标志以这种方式设置，可以参考[表6-2](chapter6.xhtml#tab6-2)中的32位示例。这些值可以轻松地扩展为64位，结果是相同的。
- en: 'Table 6-2: Sign and Overflow Flag Settings After Subtraction (32-Bit Values)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-2：减法后的符号和溢出标志设置（32位值）
- en: '| Left | Minus | Right | N | V |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 左操作数 | 减法 | 右操作数 | N | V |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0xFFFFFFFF (–1) | – | 0xFFFFFFFE (–2) | 0 | 0 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 0xFFFFFFFF (–1) | – | 0xFFFFFFFE (–2) | 0 | 0 |'
- en: '| 0x80000000 (–2 billion+) | – | 0x000000001 | 0 | 1 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 0x80000000 (–20亿+) | – | 0x000000001 | 0 | 1 |'
- en: '| 0xFFFFFFFE (–2) | – | 0xFFFFFFFF (–1) | 1 | 0 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 0xFFFFFFFE (–2) | – | 0xFFFFFFFF (–1) | 1 | 0 |'
- en: '| 0x7FFFFFFF (2 billion+) | – | 0xFFFFFFFF (–1) | 1 | 1 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 0x7FFFFFFF (20亿+) | – | 0xFFFFFFFF (–1) | 1 | 1 |'
- en: Remember, the cmp operation is really a subtraction; therefore, the first example
    in [Table 6-2](chapter6.xhtml#tab6-2) computes (–1) – (–2), which is +1\. The
    result is positive, and an overflow did not occur, so both the N and V flags are
    0\. Because (N == V), Left is greater than or equal to Right.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，cmp操作实际上是减法；因此，[表6-2](chapter6.xhtml#tab6-2)中的第一个示例计算（–1）–（–2），结果是+1。结果为正，且没有发生溢出，因此N和V标志都是0。因为（N
    == V），左操作数大于或等于右操作数。
- en: The cmp instruction would compute (–2,147,483,648) – (+1), which is (–2,147,483,649),
    in the second example. Because a 32-bit signed integer cannot represent this value,
    the value wraps around to 0x7FFFFFFF (+2,147,483,647) and sets the overflow flag.
    The result is positive (at least as a 32-bit value), so the CPU clears the negative
    flag. Because (N == V) here, Left is less than Right.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: cmp指令在第二个示例中将计算（–2,147,483,648）–（+1），结果为（–2,147,483,649）。由于32位有符号整数无法表示此值，该值会回绕到0x7FFFFFFF（+2,147,483,647），并设置溢出标志。结果为正（至少作为32位值），因此CPU会清除负标志。因为（N
    == V）在此情况下，左操作数小于右操作数。
- en: In the third example, cmp computes (–2) – (–1), which produces (–1). No overflow
    occurred, so the V is 0; the result is negative, so N is 1\. Because (N != V),
    Left is less than Right.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，cmp计算（–2）–（–1），结果是（–1）。没有发生溢出，因此V为0；结果为负数，因此N为1。因为（N != V），左操作数小于右操作数。
- en: In the final example, cmp computes (+2,147,483,647) – (–1). This produces (+2,147,483,648),
    setting the overflow flag. Furthermore, the value wraps around to 0x80000000 (−2,147,483,648),
    so the negative flag is set as well. Because (N == V) is 0, Left is greater than
    or equal to Right.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，cmp计算（+2,147,483,647）–（–1）。这会产生（+2,147,483,648），设置溢出标志。此外，值会回绕到0x80000000（−2,147,483,648），因此负标志也被设置。因为（N
    == V）为0，左操作数大于或等于右操作数。
- en: 'The cmn (compare negative) instruction compares its first source operand against
    a negated second operand; like cmp, it sets the flags and ignores the result.
    It is also, like cmp, an alias for a different instruction, add:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: cmn（比较负数）指令将第一个源操作数与取反后的第二个操作数进行比较；与cmp一样，它设置标志并忽略结果。它也像cmp一样，是另一个指令add的别名：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is because cmp is equivalent to a sub instruction, using WZR/XZR as the
    destination register; when comparing a negated value, you get the expression left
    – (–right), which is mathematically equivalent to left + right.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为cmp等同于一个sub指令，使用WZR/XZR作为目标寄存器；当比较一个取反的值时，得到的表达式为left – (–right)，这在数学上等价于left
    + right。
- en: 'Using add as a synonym for cmn has one issue: add doesn’t set the carry flag
    properly if the second (right) operand is 0\. As a result, you cannot use the
    unsigned condition codes (hs, hi, ls, or lo) after a cmn instruction if there
    is any possibility that the right operand is 0\. This shouldn’t generally be a
    problem because, by definition, you are using cmn to compare signed values and
    you should be using signed conditionals after the use of the instruction.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将 add 用作 cmn 的同义词存在一个问题：如果第二个（右侧）操作数为 0，add 并不会正确设置进位标志。因此，如果右侧操作数有可能是 0，你不能在
    cmn 指令之后使用无符号条件码（hs、hi、ls 或 lo）。通常这不会是问题，因为按定义，cmn 用于比较有符号值，并且你应该在使用该指令后使用有符号条件。
- en: Arguably the main reason for the existence of cmn is that Operand2 immediate
    values must be in the range 0 to 4,095\. You cannot compare a register against
    a negative immediate value by using the cmp instruction. The cmn instruction is
    also limited to constants in the range 0 to 4,095, but it will negate the immediate
    value before the comparison, allowing negative constants in the range –1 to –4,095
    (–0 is still 0).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，cmn 存在的主要原因是操作数 2 的立即数值必须在 0 到 4,095 的范围内。你不能通过 cmp 指令将寄存器与负的立即数值进行比较。cmn
    指令也仅限于范围 0 到 4,095 的常数，但它会在比较前对立即数值进行取反，从而允许在 –1 到 –4,095 的范围内使用负常数（–0 仍然为 0）。
- en: 6.1.4 Conditional Instructions
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4 条件指令
- en: In the original, 32-bit ARM architecture, most of the data manipulation instructions
    were conditional. You could execute an instruction, such as add, conditionally,
    based on PSTATE condition code flag settings. Alas, the 4 bits required to test
    the 16 possible conditions (same as the conditional branch instructions) were
    needed for other encodings in 64-bit mode. Nevertheless, condition instruction
    execution is useful, so the ARM64 kept a few of the more commonly used condition
    instructions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的 32 位 ARM 架构中，大多数数据处理指令都是条件性的。你可以根据 PSTATE 条件码标志设置，选择性地执行诸如加法等指令。可惜的是，在
    64 位模式下，测试 16 种可能条件所需的 4 位（与条件分支指令相同）被其他编码所占用。然而，条件指令执行仍然很有用，因此 ARM64 保留了一些常用的条件指令。
- en: The first condition instruction is csel (conditional select)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件指令是 csel（条件选择）
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: where cond is one of the following condition specifications
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 cond 是以下条件规范之一
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: which have the same meanings as for the conditional branch instructions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义与条件分支指令的含义相同。
- en: 'The *aoaa.inc* include file provides definitions for the following opposite
    conditions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*aoaa.inc* 包含文件提供了以下相反条件的定义：'
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These are synonyms for lo, ls, hi, hs, le, lt, ge, and gt, respectively.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分别是 lo、ls、hi、hs、le、lt、ge 和 gt 的同义词。
- en: As its name suggests, the csel instruction selects one of the two source operands
    to copy into the destination register, based on the current flag settings. For
    example, the following instruction
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，csel 指令根据当前标志设置，选择两个源操作数中的一个并复制到目标寄存器。例如，以下指令
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: copies X1 into X0 if the zero flag is set; otherwise, it copies X2 into X0.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果零标志被设置，它将复制 X1 到 X0；否则，它将复制 X2 到 X0。
- en: 'The csinc instruction allows for a conditional select (if true condition) or
    increment (if false condition) operation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: csinc 指令允许执行条件选择（如果条件为真）或递增（如果条件为假）操作：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using the predefined macro cinc is sometimes more convenient:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用预定义的宏 cinc 更加方便：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That is, cinc increments and copies the source into the destination if the condition
    is true; otherwise, it just copies the source without incrementing it. Of course,
    the source and destination registers can be the same if you simply want to conditionally
    increment a specific register. Note that the conditions for the cinc macros are
    reversed from the csinc instruction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果条件为真，cinc 会递增并将源复制到目标寄存器；否则，它仅复制源而不进行递增。当然，如果你只是想有条件地递增某个特定寄存器，源和目标寄存器可以相同。请注意，cinc
    宏的条件与 csinc 指令的条件相反。
- en: 'The next two conditional instructions are csinv and csneg, which conditionally
    invert or negate values:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个条件指令是 csinv 和 csneg，它们会有条件地对值进行取反或求负：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are also cinv and cneg macros that take only a single source operand
    (like cinc). The cset and csetm macros are variants of csinc and cinv:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 cinv 和 cneg 宏，它们只使用一个源操作数（类似于 cinc）。cset 和 csetm 宏是 csinc 和 cinv 的变体：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The cset macro is equivalent to cinc with WZR or XZR as both source operands,
    and csetm is equivalent to cinv with WZR or XZR as the source operands. These
    macros are useful for setting a register to a Boolean value (either true/–1 or
    false/0) based on the condition codes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: cset 宏等同于将 WZR 或 XZR 作为源操作数的 cinc，而 csetm 宏等同于将 WZR 或 XZR 作为源操作数的 cinv。这些宏用于根据条件码将寄存器设置为布尔值（真/–1
    或假/0）。
- en: 'Finally, the ARM also supports two conditional compare instructions, ccmp and
    ccmn (conditional compare negative), each with a few forms:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，ARM 还支持两条条件比较指令，ccmp 和 ccmn（条件比较负数），每条指令都有几种形式：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Whereas ccmp compares by subtracting the second operand from the first, ccmn
    compares by adding the second operand to the first. These instructions test the
    provided condition (cond). If it is false, these instructions copy the 4-bit immediate
    value #nzcv4 directly into the condition codes (bit 3 to N, bit 2 to Z, bit 1
    to C, and bit 0 to V).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '而 ccmp 通过将第二个操作数从第一个操作数中减去来进行比较，ccmn 则通过将第二个操作数加到第一个操作数上来进行比较。这些指令会测试提供的条件（cond）。如果条件为假，这些指令会将
    4 位立即数 #nzcv4 直接复制到条件码中（第 3 位到 N，第 2 位到 Z，第 1 位到 C，第 0 位到 V）。'
- en: If the condition specified by cond is true, these instructions compare the destination
    register to the source operand (register or 5-bit unsigned immediate value) and
    set the condition code bits based on the comparison. As you’ll see later in this
    chapter, the conditional comparisons are useful for evaluating complex Boolean
    expressions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 cond 指定的条件为真，这些指令会将目标寄存器与源操作数（寄存器或 5 位无符号立即数）进行比较，并根据比较结果设置条件码位。正如你在本章后面将看到的，条件比较在评估复杂的布尔表达式时非常有用。
- en: 6.2 Memory Variables vs. Registers
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2 内存变量与寄存器
- en: Before jumping into converting arithmetic expressions into assembly language
    statements, let’s also wrap up the discussion of variables from the last five
    chapters. As I’ve pointed out many times, the ARM is based on a load/store architecture.
    The ARM has been blessed with many general-purpose registers that you can use
    in lieu of memory locations for your more commonly used variables. With careful
    planning, you should be able to keep most of your often-used variables in registers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始将算术表达式转换为汇编语言语句之前，让我们先总结一下前五章关于变量的讨论。正如我多次指出的，ARM 基于加载/存储架构。ARM 配备了许多通用寄存器，你可以用它们来代替内存位置存储更常用的变量。通过仔细规划，你应该能够将大多数常用的变量保存在寄存器中。
- en: 'Consider the following C/C++ statement and its conversion to ARM assembly language:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 C/C++ 语句及其转换为 ARM 汇编语言的代码：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you keep x, y, and z in registers W19, W20, and W21, respectively, the translation
    of that expression into assembly language would be
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 x、y 和 z 分别保存在寄存器 W19、W20 和 W21 中，那么将该表达式转换为汇编语言的代码如下：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: which is one-tenth the size and much faster than the conversion just given.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅为前述转换大小的十分之一，且速度更快。
- en: On RISC CPUs like the ARM, it’s a much better idea to keep variables in registers
    rather than in memory. Your job as an assembly language programmer is to carefully
    choose the variables you keep in registers versus the (less often used) values
    you will have to maintain in memory. You can do this by counting the number of
    times you access a variable during execution and keep the most-frequently accessed
    variables in registers, leaving the least-frequently accessed variables in memory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 ARM 这样的 RISC CPU 中，保持变量在寄存器中而不是内存中是一种更好的做法。作为汇编语言程序员，你的工作是仔细选择保存在寄存器中的变量和必须保存在内存中的（使用频率较低的）值。你可以通过计算在执行过程中访问变量的次数来做到这一点，将访问频率最高的变量保存在寄存器中，将访问频率最低的变量保存在内存中。
- en: 6.2.1 Volatile vs. Nonvolatile Register Usage
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1 易失性寄存器与非易失性寄存器的使用
- en: 'If you are adhering to the ARM ABI in your assembly code, you must also be
    cognizant of the difference between volatile and nonvolatile registers in your
    procedures. Using nonvolatile registers has a cost: if you modify a nonvolatile
    register’s value, you must preserve the register’s original value within a procedure.
    This generally involves allocating storage in the procedure’s activation record,
    storing the nonvolatile register’s value on entry to the procedure, and restoring
    the register’s value before returning.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在汇编代码中遵循 ARM ABI，你还必须注意过程中的易失性寄存器和非易失性寄存器之间的差异。使用非易失性寄存器是有成本的：如果你修改了非易失性寄存器的值，你必须在过程内保存寄存器的原始值。这通常涉及在过程的激活记录中分配存储空间，在进入过程时存储非易失性寄存器的值，并在返回之前恢复该寄存器的值。
- en: Using volatile registers means you’re spared the expense and storage required
    to preserve them. However, volatile registers may have their contents disturbed
    if you make calls to other procedures, which aren’t known to explicitly preserve
    the volatile registers. Because it is the caller’s responsibility to preserve
    any volatile register contents across other function calls, you may as well use
    a nonvolatile register (assuming one is available) if you’re making calls to other
    functions within your procedures.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用易变寄存器意味着你可以避免为保存它们所需的开销和存储空间。然而，如果你调用了其他过程，而这些过程没有显式保存易变寄存器的内容，那么易变寄存器的内容可能会受到干扰。因为是调用者负责在其他函数调用之间保存任何易变寄存器的内容，所以如果你在过程内调用其他函数，你最好使用非易变寄存器（假设有可用的寄存器）。
- en: This assumes, of course, that the functions you’re calling adhere to the ARM
    ABI conventions. If, for example, you’re calling assembly language functions that
    preserve all register values they modify, you don’t have to worry about preserving
    those registers, even if the ARM ABI considers them volatile.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这假设你所调用的函数遵循 ARM ABI 约定。例如，如果你调用的汇编语言函数保留了它们修改的所有寄存器值，即使 ARM ABI 将它们视为易变寄存器，你也不需要担心保存这些寄存器。
- en: 6.2.2 Global vs. Local Variables
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2 全局变量与局部变量
- en: If you have to use memory—because you don’t have sufficient register resources
    available or because you have a large data structure to manipulate that won’t
    fit in registers—you can locate the variables you must maintain in memory. You
    can put them in either a global, static data section (such as .data, .bss, and
    so on) or in an activation record you’ve created for your current procedure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须使用内存——因为你没有足够的寄存器资源，或者因为你需要操作一个无法适应寄存器的大数据结构——你可以将必须保留的变量放入内存中。你可以将它们放在全局静态数据段（如
    .data、.bss 等）中，或者放在你为当前过程创建的激活记录中。
- en: 'When you learned to program in an HLL, you were probably taught to avoid using
    global variables in your programs. That advice applies even more in ARM assembly
    language, especially when programming under macOS. Under macOS, as you’ve seen
    many times, accessing global data is more expensive than accessing local data
    in an activation record. To fetch a 32-bit variable from global (.data) memory
    requires code such as the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习高级语言编程时，可能被教导要避免在程序中使用全局变量。这个建议在 ARM 汇编语言中更为适用，尤其是在 macOS 上编程时。在 macOS 下，正如你多次看到的那样，访问全局数据比访问激活记录中的局部数据更昂贵。要从全局（.data）内存中获取一个
    32 位变量，需要使用以下代码：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Fetching data from a local variable takes only a single instruction (assuming
    the variable’s offset into the activation record is relatively small):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从局部变量中获取数据只需一条指令（前提是该变量在激活记录中的偏移量相对较小）：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That means accessing local variables takes one-third the number of instructions
    it takes to access global variables.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，访问局部变量所需的指令数量是访问全局变量的三分之一。
- en: 'Of course, if you’re running under Linux and don’t need your assembly code
    to run under macOS as well, you can also access global variables by using a single
    instruction and the PC-relative addressing mode:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你在 Linux 上运行，并且不需要你的汇编代码也能在 macOS 上运行，你也可以通过使用单条指令和 PC 相对寻址模式来访问全局变量：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just keep in mind that the data must sit within ±1MB of this instruction. Blowing
    past this limit is pretty easy when writing larger applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，数据必须位于该指令的±1MB范围内。当编写较大应用程序时，超出这个限制是非常容易的。
- en: Local variables are not without their own limitations. In general, the activation
    record has a limit of about ±256 bytes of storage, a little more if you can use
    the scaled-indirect-plus-offset addressing mode with half-word, word, and double-word
    variables. Fortunately, you’ll rarely surpass that number of bytes of scalar (non-array/nonstructure)
    variables in a single procedure. If you do require more space, you’ll have to
    compute the effective address of the variable within the activation record, which
    winds up taking as many instructions as accessing global variables.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量也不是没有限制。通常，激活记录的存储限制约为 ±256 字节，如果你能使用缩放间接加偏移寻址模式来处理半字、字和双字变量，存储空间会稍微多一点。幸运的是，在单个过程中，你很少会超过这个字节数的标量（非数组/非结构体）变量。如果你确实需要更多空间，你必须计算变量在激活记录中的有效地址，这将需要和访问全局变量一样多的指令。
- en: 6.2.3 Easy Access to Global Variables
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3 轻松访问全局变量
- en: 'To make it just as easy to access global variables in a .data or .bss section
    as it is to access local variables within an activation record, you can create
    a static activation record. Local variables are easy to access because you use
    the indirect-plus-offset (or scaled indirect-plus-offset) addressing mode to index
    off the FP register. What if you had the equivalent of FP pointing into a static
    data section? Although the ARM doesn’t provide an SB (static base) register, nothing
    is stopping you from creating your own:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使访问`.data`或`.bss`节中的全局变量和访问激活记录中的局部变量一样容易，你可以创建一个静态激活记录。局部变量容易访问，因为你使用间接加偏移量（或缩放的间接加偏移量）寻址模式，从FP寄存器索引。如果FP指向静态数据节的等效位置呢？尽管ARM没有提供SB（静态基址）寄存器，但没有任何限制阻止你创建自己的寄存器：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I chose to use X28 in this example, since it’s a nonvolatile register in the
    ARM ABI and is right below the FP (X29) register.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我选择使用X28，因为它是ARM ABI中的一个非易失性寄存器，且位于FP（X29）寄存器下方。
- en: Listing 6-1 demonstrates using the SB register (X28) to efficiently access global
    variables.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-1演示了如何使用SB寄存器（X28）高效访问全局变量。
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Keep in mind that the [sb, #offset] addressing mode is limited to ±256 bytes
    (or up to 1KB when using the scaled indirect-plus-offset modes), so it’s best
    to keep nonscalar (composite) variables outside the static record.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，[sb, #offset]寻址模式的范围限制为±256字节（或者在使用缩放的间接加偏移量模式时，最多为1KB），因此最好将非标量（复合）变量放在静态记录之外。'
- en: 'As written, the globals record in Listing 6-1 provides access to only 256 bytes
    of storage (because all the struct field offsets are positive or 0). The following
    declaration starts the offsets at –256, providing an additional 256 bytes of storage
    in the static record:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如写出，清单6-1中的globals记录仅提供256字节的存储空间（因为所有结构字段偏移量都是正数或0）。以下声明将偏移量从-256开始，在静态记录中提供额外的256字节存储空间：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, if you do this, you must adjust the value you load into SB appropriately,
    as shown here
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你这样做，你必须适当地调整加载到SB中的值，如下所示：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: so that SB will point into the correct place in the globals_t structure.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样SB将指向globals_t结构中的正确位置。
- en: 6.3 Arithmetic Expressions
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3 算术表达式
- en: 'The biggest shock to beginners facing assembly language for the first time
    will likely be the lack of familiar arithmetic expressions. Arithmetic expressions
    in most HLLs look similar to their algebraic equivalents. For example, in C you
    could write the following algebraic-like statement:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 初次接触汇编语言的初学者可能会感到最大的震惊是缺乏熟悉的算术表达式。大多数高级语言中的算术表达式与代数表达式相似。例如，在C语言中，你可以写出类似以下的代数式：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In assembly language, you’ll need several statements to accomplish this same
    task if these variables are sitting in memory locations (assume they’re local
    variables):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，如果这些变量位于内存位置（假设它们是局部变量），你需要使用多个语句来完成相同的任务：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Obviously, the HLL version is much easier to type, read, and understand. Although
    a lot of typing is involved, converting an arithmetic expression into assembly
    language isn’t difficult. By attacking the problem in steps, the same way you
    would solve the problem by hand, you can easily break any arithmetic expression
    into an equivalent sequence of assembly language statements.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，高级语言版本更容易输入、阅读和理解。尽管涉及很多打字，转换算术表达式为汇编语言并不困难。通过分步解决问题，就像你手动解决问题一样，你可以轻松地将任何算术表达式分解为等效的汇编语言语句序列。
- en: 6.3.1 Simple Assignments
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1 简单赋值
- en: 'The easiest expressions to convert to assembly language are *simple assignments*,
    which copy a single value into a variable and take one of two forms:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为汇编语言最简单的表达式是*简单赋值*，它将一个值复制到一个变量中，具有两种形式：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: or
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If your variables are sitting in registers, converting these statements to
    assembly language is simple:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的变量位于寄存器中，将这些语句转换为汇编语言是很简单的：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This mov instruction copies the source constant or register into the destination
    register.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该mov指令将源常量或寄存器复制到目标寄存器中。
- en: 'If the constant is too large, you’ll either have to use the movk sequence (see
    section 2.20.2, “movk,” on [page 112](chapter2.xhtml#pg_112)) or the constant
    form of ldr:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果常量太大，你将不得不使用movk序列（见第2.20.2节，“movk”，在[第112页](chapter2.xhtml#pg_112)）或ldr的常量形式：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the source variable is in memory, you must use the ldr instruction to fetch
    the data from memory, as shown in the following examples:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源变量在内存中，你必须使用ldr指令从内存中获取数据，如以下示例所示：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the destination is a memory variable, you must first load the source variable
    or constant into a register (if it isn’t already in a register) and use the str
    instruction to store the value into the memory variable:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是内存变量，必须先将源变量或常量加载到寄存器中（如果它尚未在寄存器中），然后使用 str 指令将值存储到内存变量中：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Clearly, the most efficient code occurs when both variables are in a register
    or the destination is a register and the source value is a small constant, in
    which case a single mov instruction suffices.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最有效的代码是在两个变量都在寄存器中，或者目标是寄存器且源值是一个小常量的情况下，在这种情况下只需一条 mov 指令即可。
- en: 6.3.2 Simple Expressions
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2 简单表达式
- en: The next level of complexity is a *simple expression*, which takes the form
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一层复杂度是 *简单表达式*，其形式为
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: where var1 is a variable, term1 and term2 are variables or constants, and op
    is an arithmetic operator (addition, subtraction, multiplication, and so on).
    Most expressions take this form. It should come as no surprise, then, that the
    ARM architecture was optimized for just this type of expression.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，var1 是一个变量，term1 和 term2 是变量或常量，op 是一个算术操作符（加法、减法、乘法等）。大多数表达式采取这种形式。因此，ARM
    架构专门针对这种类型的表达式进行了优化，这一点也不足为奇。
- en: Assuming var1, term1, and term2 are all in registers, a typical conversion for
    this type of expression takes the form
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 var1、term1 和 term2 都在寄存器中，典型的转换形式如下：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: where op is the mnemonic that corresponds to the specified operation (for example,
    + is add, – is sub, and so forth).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，op 是与指定操作对应的助记符（例如，+ 是 add，– 是 sub，等等）。
- en: Note that the simple expression
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，简单表达式
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: is easily handled with a compile-time expression and a single mov instruction.
    For example, to compute
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编译时表达式和单条 mov 指令可以轻松处理。例如，计算
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'you would use the single instruction:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用单条指令：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If term2 is a (small enough) constant, you can typically use an instruction
    of the following form:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 term2 是一个（足够小的）常量，通常可以使用如下形式的指令：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Exceptions exist, however. Certain instructions, such as mul and udiv/sdiv,
    do not allow immediate operands. In such cases, you’ll need to use the two instructions
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一些例外情况。某些指令，如 mul 和 udiv/sdiv，不允许立即数操作数。在这种情况下，你需要使用两条指令
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: where someReg is an available temporary register.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，someReg 是一个可用的临时寄存器。
- en: If term1 is a constant and term2 is a register, you can get away with simply
    swapping the two source operands in the instruction for commutative operations.
    For example
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 term1 是常量，而 term2 是寄存器，则对于交换律操作，你只需在指令中交换两个源操作数即可。例如
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'becomes this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 变成这样：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For noncommutative operations, such as subtraction and division, this scheme
    doesn’t work. You may have to load the constant into a register prior to the operation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非交换的操作（如减法和除法），这种方案不起作用。你可能需要在操作之前将常量加载到寄存器中。
- en: Of course, if the constant is too large (generally 12 bits for arithmetic instructions),
    you’ll have to first load that constant into a register by using the mov, movk,
    or ldr instructions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果常量太大（通常是算术指令的 12 位），你将需要先使用 mov、movk 或 ldr 指令将该常量加载到寄存器中。
- en: If your terms are memory variables rather than registers (or constants), you
    will need to use the ldr instruction to move the memory variable(s) into register(s)
    prior to the operation. Likewise, if the destination variable is in memory, you
    will have to use a str instruction to store the value after the operation is complete.
    For example
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的操作数是内存变量而不是寄存器（或常量），则需要使用 ldr 指令将内存变量加载到寄存器中，然后再进行操作。同样，如果目标变量在内存中，操作完成后需要使用
    str 指令将值存储到内存变量中。例如
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'becomes this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 变成这样：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here are some examples of common simple expressions (assume x, y, and z are
    in W0, W1, and W2):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常见简单表达式的示例（假设 x、y 和 z 分别在 W0、W1 和 W2 寄存器中）：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If any of the operands are memory variables, you will first have to load them
    into registers by using the ldr instruction. If any operands are constants, follow
    the guidelines from the previous section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任一操作数是内存变量，首先必须使用 ldr 指令将其加载到寄存器中。如果操作数是常量，则请按照上一节的指导进行处理。
- en: 6.3.3 Complex Expressions
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3 复杂表达式
- en: A *complex expression* is any arithmetic expression involving more than two
    terms and one operator. Such expressions are commonly found in programs written
    in an HLL. Complex expressions may include parentheses to override operator precedence,
    function calls, array accesses, and so on. This section outlines the rules for
    converting such expressions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *复杂表达式* 是指包含两个以上项和一个运算符的任何算术表达式。这样的表达式通常出现在用高级语言编写的程序中。复杂表达式可能包含括号来覆盖运算符优先级、函数调用、数组访问等。本节概述了转换此类表达式的规则。
- en: 'Complex expressions that are easy to convert to assembly language involve three
    terms and two operators. Here’s an example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 容易转换为汇编语言的复杂表达式通常包含三个项和两个运算符。以下是一个例子：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Clearly, the straightforward assembly language conversion of this statement
    requires two sub instructions. However, even with an expression as simple as this,
    the conversion is not trivial. You can convert the preceding statement into assembly
    language in two ways (assume w is in W0, y is in W1, and z is in W2):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个语句的直接汇编语言转换需要两个子指令。然而，即使是像这样的简单表达式，转换也不是小事。你可以通过两种方式将上述语句转换为汇编语言（假设 w 在
    W0 中，y 在 W1 中，z 在 W2 中）：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: or
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Both methods can produce different results, with the first conversion largely
    adhering to C language semantics. The problem is associativity. The second sequence
    in the preceding example computes w = w - (y - z), which is not the same as w
    = (w - y) - z. The placement of the parentheses around the subexpressions can
    affect the result.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法可能会产生不同的结果，第一个转换大体上遵循 C 语言语义。问题在于结合性。前面的第二个序列计算 w = w - (y - z)，这与 w = (w
    - y) - z 不同。子表达式周围括号的位置会影响结果。
- en: '*Precedence*, the order in which operations occur, is another issue. Consider
    this expression:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先级*，即操作发生的顺序，是另一个问题。考虑以下表达式：'
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once again, you can evaluate this expression in one of two ways:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以通过两种方式来计算这个表达式：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: or
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By now, you’re probably thinking that this explanation is crazy—everyone knows
    the correct way to evaluate these expressions is to use the former form. However,
    this isn’t always correct. The APL programming language, for example, evaluates
    expressions solely from right to left and does not give one operator precedence
    over another. The “correct” method depends entirely on how you define precedence
    in your arithmetic system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能会觉得这个解释有些疯狂——每个人都知道正确的方式是使用前一种形式来计算这些表达式。然而，这并不总是正确的。例如，APL 编程语言仅从右到左计算表达式，并且不赋予任何运算符优先级。所谓的“正确”方法完全取决于你如何定义算术系统中的优先级。
- en: 'Consider this expression:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表达式：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If op1 takes precedence over op2, this evaluates to (x op1 y) op2 z*.* Otherwise,
    if op2 takes precedence over op1, the expression evaluates to x op1 (y op2 z).
    Depending on the operators and operands involved, these two computations could
    produce different results.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 op1 的优先级高于 op2，则此表达式计算为 (x op1 y) op2 z*.* 否则，如果 op2 的优先级高于 op1，则表达式计算为 x
    op1 (y op2 z)。根据涉及的运算符和操作数，这两个计算可能会产生不同的结果。
- en: Most HLLs use a fixed set of precedence rules to describe the order of evaluation
    in an expression involving two or more different operators. Such programming languages
    usually compute multiplication and division before addition and subtraction. Those
    that support exponentiation (for example, FORTRAN and BASIC) usually compute that
    before multiplication and division. These rules are intuitive because most people
    learn them before high school.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言（HLL）使用一组固定的优先级规则来描述包含两个或更多不同运算符的表达式的计算顺序。这些编程语言通常在加法和减法之前计算乘法和除法。那些支持指数运算的语言（例如
    FORTRAN 和 BASIC）通常在乘法和除法之前计算指数运算。这些规则是直观的，因为大多数人在上高中之前就学到了它们。
- en: 'When converting expressions into assembly language, you must be sure to compute
    the subexpression with the highest precedence first. The following example demonstrates
    this technique (assuming multiplication has higher precedence than addition):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在将表达式转换为汇编语言时，必须确保首先计算具有最高优先级的子表达式。以下示例演示了这一技术（假设乘法的优先级高于加法）：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If two operators appearing within an expression have the same precedence, use
    the associativity rules to determine the order of evaluation. Most operators are
    *left-associative*, meaning that they evaluate from left to right. Addition, subtraction,
    multiplication, and division are all left-associative. A *right-associative* operator
    evaluates from right to left. The exponentiation operator in FORTRAN is a good
    example of a right-associative operator. For instance:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在一个表达式中出现的两个操作符具有相同的优先级，则使用结合性规则来确定求值顺序。大多数操作符是*左结合*的，这意味着它们从左到右求值。加法、减法、乘法和除法都是左结合的。*右结合*的操作符从右到左求值。FORTRAN中的幂运算符就是一个右结合操作符的好例子。例如：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: is equal to
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 等于
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: not
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 不是
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The precedence and associativity rules determine the order of evaluation. Indirectly,
    these rules tell you where to place parentheses in an expression to determine
    the order of evaluation. Of course, you can always use parentheses to override
    the default precedence and associativity. However, the ultimate point is that
    your assembly code must complete certain operations before others to correctly
    compute the value of a given expression. The following examples demonstrate this
    principle:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级和结合性规则决定了求值的顺序。间接地，这些规则告诉你在表达式中该把括号放在哪里，以确定求值顺序。当然，你始终可以使用括号来覆盖默认的优先级和结合性。然而，最重要的一点是，你的汇编代码必须在其他操作之前完成某些操作，以正确计算给定表达式的值。以下示例演示了这一原则：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: or, even better
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更好的是
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The associativity rule has one exception: if an expression involves multiplication
    and division, it is generally better to perform the multiplication first. For
    example, given an expression of the form'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 结合性规则有一个例外：如果一个表达式涉及乘法和除法，通常最好先进行乘法。例如，给定如下形式的表达式
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: it is usually better to compute x * z and then divide the result by y, rather
    than dividing x by y and multiplying the quotient by z. Doing the multiplication
    first increases the accuracy of the computation. Remember, (integer) division
    often produces an inexact result. For example, if you compute 5 / 2, you will
    get the value 2, not 2.5\. Computing (5 / 2) × 3 produces 6\. However, computing
    (5 × 3) / 2 gives you the value 7, which is a little closer to the real quotient
    (7.5).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好先计算x * z，然后将结果除以y，而不是先将x除以y，再将商乘以z。先进行乘法运算能提高计算的精确度。记住，（整数）除法通常会产生不精确的结果。例如，如果你计算5
    / 2，你将得到2，而不是2.5。计算(5 / 2) × 3得到6。然而，计算(5 × 3) / 2得到7，这比实际商7.5更接近。
- en: Therefore, if you encounter an expression of the form
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你遇到如下形式的表达式
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'you can usually convert it to the following assembly code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以将其转换为以下汇编代码：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If the multiplication will likely produce an overflow, computing the division
    operation first may be better.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果乘法可能会导致溢出，首先进行除法运算可能会更好。
- en: If the algorithm you’re encoding depends on the truncation effect of the division
    operation, you cannot use this trick to improve the algorithm. The moral of the
    story is that you should always make sure you fully understand any expression
    you are converting to assembly language. If the semantics dictate that you must
    perform the division first, do so.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编码的算法依赖于除法运算的截断效果，那么不能使用这个技巧来优化算法。这个故事的教训是，你应该始终确保完全理解你要转换成汇编语言的任何表达式。如果语义要求你必须首先执行除法操作，那就照做。
- en: 'Consider the following statement:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下语句：
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Because subtraction is not commutative, you cannot compute y * x and then subtract
    x from this result. Rather than use a straightforward multiplication-and-subtraction
    sequence, you’ll have to use a temporary register to hold the product. For example,
    the following two instructions use W4 as a temporary:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因为减法不是交换律的，你不能先计算y * x，然后从结果中减去x。你不能使用简单的乘法和减法序列，而是必须使用一个临时寄存器来保存乘积。例如，以下两个指令使用W4作为临时寄存器：
- en: '[PRE65]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As your expressions increase in complexity, the need for temporaries grows.
    Consider the following C statement:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 随着表达式复杂度的增加，临时变量的需求也会增加。请考虑以下C语句：
- en: '[PRE66]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Following the normal rules of algebraic evaluation, compute the subexpressions
    inside the parentheses first (that is, the two subexpressions with the highest
    precedence) and set their values aside. When you’ve computed the values for both
    subexpressions, you can compute their product. One way to deal with a complex
    expression like this is to reduce it to a sequence of simple expressions whose
    results wind up in temporary variables. For example, you can convert the preceding
    single expression into the following sequence:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规的代数计算规则，首先计算括号内的子表达式（即优先级最高的两个子表达式），并将它们的值暂时保留。当你计算出两个子表达式的值后，就可以计算它们的乘积。处理这种复杂表达式的一种方法是将其简化为一系列简单表达式，其结果存储在临时变量中。例如，你可以将上面的单个表达式转换为以下的表达式序列：
- en: '[PRE67]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Since converting simple expressions to assembly language is easy, it’s now
    a snap to compute the former complex expression in assembly, as shown in the following
    code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将简单表达式转换为汇编语言很容易，现在转换前面的复杂表达式为汇编语言变得十分简单，如下面的代码所示：
- en: '[PRE68]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here’s yet another example of a complex arithmetic conversion:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个复杂算术转换的例子：
- en: '[PRE69]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You can convert this to a set of four simple expressions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其转换为一组四个简单表达式：
- en: '[PRE70]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can convert these four expressions into the following assembly language
    statements:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这四个表达式转换成以下的汇编语言语句：
- en: '[PRE71]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Most important, make sure you keep temporary values in registers for efficiency.
    Use memory locations to hold temporaries only if you’ve run out of registers.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，确保为了效率，临时值保存在寄存器中。只有当寄存器用尽时，才使用内存位置来保存临时值。
- en: In short, as you’ve seen, converting a complex expression to assembly language
    is a little different from solving the expression by hand. Instead of computing
    the result at each stage of the computation, you write the assembly code that
    computes the result.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，正如你所看到的，将复杂的表达式转换为汇编语言与手动求解表达式有所不同。你并不是在每个计算阶段计算结果，而是编写汇编代码来计算结果。
- en: 6.3.4 Commutative Operators
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.4 交换律运算符
- en: 'If op represents an operator, that operator is *commutative* if the following
    relationship is always true:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果op表示一个运算符，则如果以下关系始终成立，则该运算符是*交换律*的：
- en: '[PRE72]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you learned in the previous section, commutative operators are easy to translate
    because the order of their operands is immaterial, which lets you rearrange a
    computation, often making it easier or more efficient. Often, rearranging a computation
    allows you to use fewer temporary variables. Whenever you encounter a commutative
    operator in an expression, check whether you can use a better sequence to improve
    the size or speed of your code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节学到的，交换律运算符容易转换，因为其操作数的顺序不重要，这使得你可以重排计算，通常能使计算更加简便或高效。重排计算往往能减少临时变量的使用。每当你在表达式中遇到交换律运算符时，检查是否可以使用更好的顺序来提高代码的大小或速度。
- en: '[Table 6-3](chapter6.xhtml#tab6-3) lists the commutative operators typically
    found in HLLs.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-3](chapter6.xhtml#tab6-3)列出了通常在高级语言中找到的交换律运算符。'
- en: 'Table 6-3: Commutative Dyadic (Two-Operand) Operators'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-3：交换律二元（双操作数）运算符
- en: '| Pascal | C/C++ and similar | Description |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| Pascal | C/C++及类似语言 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| + | + | Addition |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| + | + | 加法 |'
- en: '| * | * | Multiplication |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| * | * | 乘法 |'
- en: '| and | && or & | Logical or bitwise AND |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| and | && 或 & | 逻辑与按位与 |'
- en: '| or | &#124;&#124; or &#124; | Logical or bitwise OR |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| or | &#124;&#124; 或 &#124; | 逻辑或按位或 |'
- en: '| xor | ^ | Logical or bitwise exclusive-OR |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| xor | ^ | 逻辑或按位异或 |'
- en: '| = | == | Equality |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| = | == | 等于 |'
- en: '| <> | != | Inequality |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| <> | != | 不等于 |'
- en: '[Table 6-4](chapter6.xhtml#tab6-4) lists many of the noncommutative operators.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-4](chapter6.xhtml#tab6-4)列出了许多非交换律运算符。'
- en: 'Table 6-4: Noncommutative Dyadic Operators'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-4：非交换二元运算符
- en: '| Pascal | C/C++ and similar | Description |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| Pascal | C/C++及类似语言 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| - | - | Subtraction |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| - | - | 减法 |'
- en: '| / or div | / | Division |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| / 或 div | / | 除法 |'
- en: '| mod | % | Remainder (modulo) |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| mod | % | 余数（模） |'
- en: '| < | < | Less than |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| < | < | 小于 |'
- en: '| <= | <= | Less than or equal |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| <= | <= | 小于或等于 |'
- en: '| > | > | Greater than |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| > | > | 大于 |'
- en: '| >= | >= | Greater than or equal |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| >= | >= | 大于或等于 |'
- en: If you encounter any other operator types, check the associated HLL definition
    for the operators to determine whether they are commutative or noncommutative
    and determine their precedence and associativity.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到其他类型的运算符，请检查相关的高级语言定义，确定它们是交换律运算符还是非交换律运算符，并确定它们的优先级和结合性。
- en: 6.4 Logical Expressions
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4 逻辑表达式
- en: 'Consider the following logical (Boolean) expression from a C/C++ program:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自 C/C++ 程序的逻辑（布尔）表达式：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, bb is a Boolean variable, and the remaining variables are all integers.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，bb 是一个布尔变量，其他变量都是整数。
- en: Though it takes only a single bit to represent a Boolean value, most assembly
    language programmers allocate a whole byte or even a word to represent Boolean
    variables. Most programmers (and, indeed, some programming languages like C) choose
    0 to represent *false* and anything else to represent *true*. Some people prefer
    to represent true and false with 1 and 0, respectively, and not allow any other
    values. Others select all 1 bits (0xFFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF, 0xFFFF,
    or 0xFF) for true and 0 for false. You could also use a positive value for true
    and a negative value for false.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只需要一个比特来表示布尔值，大多数汇编语言程序员会分配一个完整的字节，甚至一个字（word）来表示布尔变量。大多数程序员（实际上，一些编程语言如 C）选择
    0 表示 *假*（false），而其他任何值表示 *真*（true）。有些人喜欢用 1 和 0 来分别表示真和假，不允许其他值。还有一些人选择使用全 1 位（0xFFFF_FFFF_FFFF_FFFF、0xFFFF_FFFF、0xFFFF
    或 0xFF）表示真，0 表示假。你也可以使用正值表示真，负值表示假。
- en: 'All these mechanisms have their advantages and drawbacks. Using only 0 and
    1 to represent false and true offers two big advantages. First, the cset instruction
    produces this result, so this scheme is compatible with that instruction. Second,
    the ARM logical instructions (and, orr, eor, and, to a lesser extent, mvn) operate
    on these values exactly as you would expect. If you have two Boolean variables
    a and bb, the following instructions perform the basic logical operations on these
    two variables:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些机制都有各自的优缺点。仅使用 0 和 1 来表示假（false）和真（true）有两个很大的优点。首先，cset 指令可以产生这种结果，因此该方案与该指令兼容。其次，ARM
    逻辑指令（and, orr, eor 和 mvn）正如你所期望的那样，操作这些值。如果你有两个布尔变量 a 和 bb，以下指令将对这两个变量执行基本的逻辑操作：
- en: '[PRE74]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The mvn instruction will not properly compute logical negation. The bitwise
    NOT of 0 is 0xFF (assuming a byte value), and the bitwise NOT of 1 is 0FEh. Neither
    result is 0 or 1\. However, ANDing the result with 1 gives you the proper result.
    You can implement the NOT operation more efficiently by using the eor instruction
    (as shown in the last eor example just given) because it affects only the LO bit.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: mvn 指令无法正确计算逻辑取反操作。0 的按位 NOT 结果是 0xFF（假设是字节值），而 1 的按位 NOT 结果是 0FEh。两者的结果都不是
    0 或 1。然而，将结果与 1 做与运算（AND）会得到正确的结果。你可以通过使用 eor 指令（如最后给出的 eor 示例所示）更高效地实现取反操作，因为它只影响最低有效位（LO
    位）。
- en: 'Using 0 for false and anything else for true has a lot of subtle advantages.
    The test for true or false is often implicit in the execution of any logical instruction.
    However, this mechanism has a major downside: you cannot always use the ARM and,
    orr, eor, and mvn instructions to implement the Boolean operations of the same
    name. Consider the two values 0x55 and 0xAA. They’re both nonzero, so they both
    represent the value true. However, if you logically AND 0x55 and 0xAA together
    using the ARM and instruction, the result is 0\. True AND true should produce
    true, not false. Although you can account for situations like this, it usually
    requires a few extra instructions and is somewhat less efficient when computing
    Boolean operations.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 0 表示假（false），而其他任何值表示真（true）有许多微妙的优点。真假测试通常隐式地包含在任何逻辑指令的执行中。然而，这种机制有一个主要的缺点：你不能总是使用
    ARM 的 and、orr、eor 和 mvn 指令来实现同名的布尔运算。考虑以下两个值 0x55 和 0xAA。它们都是非零值，因此它们都表示真（true）。然而，如果你使用
    ARM 的 and 指令对 0x55 和 0xAA 进行逻辑与运算，结果将是 0。真与真应该得到真，而不是假（false）。尽管你可以处理这种情况，但通常需要额外的一些指令，且计算布尔运算时效率较低。
- en: 'A system that uses nonzero values to represent true and 0 to represent false
    is an *arithmetic logical system*. A system that uses two distinct values like
    0 and 1 to represent false and true is called a *Boolean logical system*, or simply
    a Boolean system. You can use either system as convenient. Consider this Boolean
    expression:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非零值表示真，0 表示假是 *算术逻辑系统*。使用 0 和 1 两个不同值来表示假和真的是一个 *布尔逻辑系统*，简称布尔系统。你可以根据需要选择使用这两种系统。考虑这个布尔表达式：
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The resulting simple expressions might be as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的简单表达式可能如下所示：
- en: '[PRE76]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When working with Boolean expressions, don’t forget that you might be able to
    optimize your code by simplifying it with algebraic transformations. In [Chapter
    7](chapter7.xhtml), you’ll also see how to use control flow to calculate a Boolean
    result, which can be a bit more efficient than using the methods taught by the
    examples in this section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理布尔表达式时，不要忘记你可以通过代数变换简化代码来优化它。在[第7章](chapter7.xhtml)中，你还将看到如何使用控制流来计算布尔结果，这比本节示例中使用的方法可能更高效。
- en: 6.5 Conditional Comparisons and Boolean Expressions
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5 条件比较和布尔表达式
- en: 'The conditional comparison instruction, ccmp, is quite useful for encoding
    complex Boolean expressions in assembly language. Consider the following Boolean
    expression:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 条件比较指令ccmp在汇编语言中编码复杂的布尔表达式时非常有用。考虑以下布尔表达式：
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Using the logic from the previous section, you could translate this into the
    following assembly language code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节的逻辑，你可以将其转换为以下汇编语言代码：
- en: '[PRE78]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'By using the conditional comparison instruction, you can keep the temporary
    values in the condition code flags to shorten your code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用条件比较指令，你可以将临时值保存在条件代码标志中，从而缩短代码长度：
- en: '[PRE79]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The first cmp instruction sets the Z flag if x is equal to y. If that condition
    is false, the whole logical expression must return false. If it’s true, this code
    has to test whether a is less than or equal to d.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个cmp指令如果x等于y，会设置Z标志。如果该条件为假，则整个逻辑表达式必须返回假。如果条件为真，这段代码必须测试a是否小于或等于d。
- en: Assuming that x does not equal y, the Z flag will be clear after the first cmp
    instruction. In that case, the ccmp instruction will not compare W3 (a) to W4
    (d) but will load the flags with 0b0000 instead (because the ccmp instruction
    compares only the first two operands if the condition, eq, is true; at this point,
    it is not). Because all the flags are clear (meaning N == V and Z != 1), the le
    condition for the cset is false; therefore, that instruction will store a 0 into
    W0 (bb), exactly what you want.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 假设x不等于y，在第一次cmp指令之后，Z标志将被清除。在这种情况下，ccmp指令不会将W3（a）与W4（d）进行比较，而是将标志加载为0b0000（因为当条件eq为真时，ccmp指令只比较前两个操作数；此时它不为真）。由于所有标志都被清除（即N
    == V且Z != 1），cset指令的le条件为假；因此，该指令将把0存入W0（bb），这正是你想要的。
- en: On the other hand, if x is equal to y, the eq condition for the ccmp instruction
    will be true and will compare the value of W3 (a) to W4 (d). If a is less than
    or equal to d, the N, V, and Z flags will be set in such a way that the cset instruction
    moves a 1 into W0\. Otherwise, cset will move a 0 into W0, which is again exactly
    what you want. This sequence with only three instructions does the work of the
    earlier sequence with five instructions, a huge win.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果x等于y，则ccmp指令的eq条件为真，并将比较W3（a）与W4（d）的值。如果a小于或等于d，N、V和Z标志将被设置，以使得cset指令将1移动到W0中。否则，cset将把0移动到W0，这同样是你想要的。这个只有三条指令的序列完成了早期五条指令的工作，是一个巨大的胜利。
- en: 6.5.1 Implementing Conjunction Using ccmp
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.1 使用ccmp实现与运算
- en: 'Consider this C/C++ logical expression:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个C/C++逻辑表达式：
- en: '[PRE80]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In general, to convert this expression containing the logical conjunction operator
    (&&) into ARM assembly using conditional comparison instructions, you would use
    the following five steps:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，要将包含逻辑与操作符（&&）的表达式转换为ARM汇编，使用条件比较指令，你需要按照以下五个步骤进行：
- en: 1.  Compare the operands on the left-hand side of the conjunction operator,
    cc1 (see [Table 6-5](chapter6.xhtml#tab6-5)).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  比较与运算符左侧的操作数cc1（见[表 6-5](chapter6.xhtml#tab6-5)）。
- en: 2.  Immediately after the first comparison, execute a ccmp instruction, supplying
    cc1 as the conditional field.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  在第一次比较之后，立即执行ccmp指令，提供cc1作为条件字段。
- en: '3.  Choose the corresponding #nzcv encoding from the opposite column in [Table
    6-5](chapter6.xhtml#tab6-5) to match cc2. The full ccmp instruction should be:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  从对面一列的[表 6-5](chapter6.xhtml#tab6-5)中选择相应的#nzcv编码，以匹配cc2。完整的ccmp指令应为：
- en: '[PRE81]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '4.  The last instruction in the sequence should test cc2, as in the following
    example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  序列中的最后一条指令应当测试cc2，如以下示例所示：
- en: '[PRE82]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '5.  If cc1 fails, the ccmp instruction will set the flags to the #nzcvop value
    and not compare c against d. Since you want the Boolean expression to yield false
    in this situation, choose an #nzcvop value that is the opposite of cc2 so that
    the following test (for example, cset) produces a false result. If cc1 is true
    upon executing the ccmp instruction, ccmp will compare c and d and set the flags.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '5. 如果 cc1 失败，ccmp 指令将会把标志设置为 #nzcvop 的值，而不是比较 c 和 d。由于你希望布尔表达式在这种情况下为假，选择一个与
    cc2 相反的 #nzcvop 值，以使得接下来的测试（例如 cset）返回假结果。如果在执行 ccmp 指令时 cc1 为真，ccmp 将会比较 c 和
    d 并设置标志。'
- en: 'Table 6-5: Conditional Operators, Opposites, and NZCV Settings'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-5：条件运算符、反义和 NZCV 设置
- en: '| C/C++ | Operator | #nzcv | Opposite | #nzcvop |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| C/C++ | 运算符 | #nzcv | 反义 | #nzcvop |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| == | eq | 0b0100 | ne | 0b0000 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| == | eq | 0b0100 | ne | 0b0000 |'
- en: '| != | ne | 0b0000 | eq | 0b0100 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| != | ne | 0b0000 | eq | 0b0100 |'
- en: '| > (unsigned) | hi | 0b0010 | ls | 0b0100 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| > (无符号) | hi | 0b0010 | ls | 0b0100 |'
- en: '| >= (unsigned) | hs | 0b0110 | lo | 0b0000 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| >= (无符号) | hs | 0b0110 | lo | 0b0000 |'
- en: '| < (unsigned) | lo | 0b0000 | hs | 0b0110 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| < (无符号) | lo | 0b0000 | hs | 0b0110 |'
- en: '| <= (unsigned) | ls | 0b0100 | hi | 0b0010 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| <= (无符号) | ls | 0b0100 | hi | 0b0010 |'
- en: '| > (signed) | gt | 0b0000 | le | 0b0101 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| > (有符号) | gt | 0b0000 | le | 0b0101 |'
- en: '| >= (signed) | ge | 0b0100 | lt | 0b0001 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| >= (有符号) | ge | 0b0100 | lt | 0b0001 |'
- en: '| < (signed) | lt | 0b0001 | ge | 0b0100 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| < (有符号) | lt | 0b0001 | ge | 0b0100 |'
- en: '| <= (signed) | le | 0b0101 | gt | 0b0000 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| <= (有符号) | le | 0b0101 | gt | 0b0000 |'
- en: '| Same as hs | cs | 0b0010 | cc | 0b0000 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 同 hs | cs | 0b0010 | cc | 0b0000 |'
- en: '| Same as lo | cc | 0b0000 | cs | 0b0010 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 同 lo | cc | 0b0000 | cs | 0b0010 |'
- en: '| N/A | vs | 0b0001 | vc | 0b0000 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| N/A | vs | 0b0001 | vc | 0b0000 |'
- en: '| N/A | vc | 0b0000 | vs | 0b0001 |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| N/A | vc | 0b0000 | vs | 0b0001 |'
- en: '| N/A | mi | 0b1000 | pl | 0b0000 |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| N/A | mi | 0b1000 | pl | 0b0000 |'
- en: '| N/A | pl | 0b0000 | mi | 0b1000 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| N/A | pl | 0b0000 | mi | 0b1000 |'
- en: Because keeping the flag settings for the third ccmp operand straight in your
    mind is difficult and error-prone, the *aoaa.inc* include file contains several
    defines to make it easy to choose these values, as well as some defines for opposite
    conditions. [Table 6-6](chapter6.xhtml#tab6-6) lists these defines and their values.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 因为保持第三个 ccmp 操作数的标志设置在脑海中是困难且容易出错的，*aoaa.inc* 包含了多个定义，使得选择这些值变得更容易，同时还包含了一些用于反义条件的定义。[表
    6-6](chapter6.xhtml#tab6-6)列出了这些定义及其值。
- en: 'Table 6-6: NZCV Constant Defines'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-6：NZCV 常量定义
- en: '| Condition | Define | Value |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | 定义 | 值 |'
- en: '| --- | --- | --- |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| eq | cceq | 0b0100 (nZcv) |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| eq | cceq | 0b0100 (nZcv) |'
- en: '| ne | ccne | 0b0000 (nzcv) |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| ne | ccne | 0b0000 (nzcv) |'
- en: '| hi | cchi | 0b0010 (nzCv) |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| hi | cchi | 0b0010 (nzCv) |'
- en: '| hs | cchs | 0b0110 (nZCv) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| hs | cchs | 0b0110 (nZCv) |'
- en: '| lo | cclo | 0b0000 (nzcv) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| lo | cclo | 0b0000 (nzcv) |'
- en: '| ls | ccls | 0b0100 (nZcv) |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| ls | ccls | 0b0100 (nZcv) |'
- en: '| gt | ccgt | 0b0000 (nzcv) |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| gt | ccgt | 0b0000 (nzcv) |'
- en: '| ge | ccge | 0b0100 (nZcv) |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| ge | ccge | 0b0100 (nZcv) |'
- en: '| lt | cclt | 0b0001 (nzcV) |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| lt | cclt | 0b0001 (nzcV) |'
- en: '| le | ccle | 0b0101 (nZcV) |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| le | ccle | 0b0101 (nZcV) |'
- en: '| cs | cccs | 0b0010 (nzCv) |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| cs | cccs | 0b0010 (nzCv) |'
- en: '| cc | cccc | 0b0000 (nzcv) |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| cc | cccc | 0b0000 (nzcv) |'
- en: '| vs | ccvs | 0b0001 (nzcV) |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| vs | ccvs | 0b0001 (nzcV) |'
- en: '| vc | ccvc | 0b0000 (nzcV) |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| vc | ccvc | 0b0000 (nzcV) |'
- en: '| mi | ccmi | 0b1000 (Nzcv) |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| mi | ccmi | 0b1000 (Nzcv) |'
- en: '| pl | ccpl | 0b0000 (nzcv) |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| pl | ccpl | 0b0000 (nzcv) |'
- en: '[Table 6-7](chapter6.xhtml#tab6-7) lists some common antonyms (opposite conditions).'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-7](chapter6.xhtml#tab6-7)列出了常见的反义（对立条件）。'
- en: 'Table 6-7: NZCV Antonym Constants'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-7：NZCV 反义常量
- en: '| Condition | Define | Same as |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | 定义 | 相同的 |'
- en: '| --- | --- | --- |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Not hi | ccnhi | ccls |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 非 hi | ccnhi | ccls |'
- en: '| Not hs | ccnhs | cclo |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 非 hs | ccnhs | cclo |'
- en: '| Not lo | ccnlo | cchs |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 非 lo | ccnlo | cchs |'
- en: '| Not ls | ccnls | cchi |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 非 ls | ccnls | cchi |'
- en: '| Not gt | ccngt | ccle |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 非 gt | ccngt | ccle |'
- en: '| Not ge | ccnge | cclt |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 非 ge | ccnge | cclt |'
- en: '| Not lt | ccnlt | ccge |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 非 lt | ccnlt | ccge |'
- en: '| Not le | ccnle | ccgt |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 非 le | ccnle | ccgt |'
- en: Using these symbols instead of constants for the immediate ccmp instruction
    operand can make your code easier to read and understand.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些符号代替立即数 ccmp 指令操作数，可以使你的代码更易于阅读和理解。
- en: Sometimes specifying the opposite condition in one of the conditional instructions
    can create confusion. It’s easy to think that the opposite of “less than” is “greater
    than” when it’s actually “greater than or equal,” for example. To help reduce
    this confusion, the *aoaa.inc* include file also provides defines for several
    opposite conditions, as listed in [Table 6-8](chapter6.xhtml#tab6-8).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在条件指令中指定相反条件可能会造成混淆。比如，容易认为“小于”的相反是“大于”，而实际上应该是“大于或等于”。为减少这种混淆，*aoaa.inc*包含文件还提供了几个相反条件的定义，如[表6-8](chapter6.xhtml#tab6-8)所列。
- en: 'Table 6-8: Opposite Condition Defines'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-8：相反条件定义
- en: '| Condition | Opposite define |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| Condition | 相反定义 |'
- en: '| --- | --- |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| lo | nlo (same as hs) |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| lo | nlo（与hs相同） |'
- en: '| ls | nls (same as hi) |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| ls | nls（与hi相同） |'
- en: '| hi | nhi (same as ls) |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| hi | nhi（与ls相同） |'
- en: '| hs | nhs (same as lo) |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| hs | nhs（与lo相同） |'
- en: '| gt | ngt (same as le) |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| gt | ngt（与le相同） |'
- en: '| ge | nge (same as lt) |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| ge | nge（与lt相同） |'
- en: '| lt | nlt (same as ge) |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| lt | nlt（与ge相同） |'
- en: '| le | nle (same as gt) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| le | nle（与gt相同） |'
- en: By using the *aoaa.inc* definitions, you can make your code easier to read and
    understand.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用*aoaa.inc*定义，你可以让你的代码更容易阅读和理解。
- en: 6.5.2 Implementing Disjunction Using ccmp
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.2 使用ccmp实现析取
- en: 'The conditional comparison can also be used to simulate disjunction (logical
    OR). Consider the following expression:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 条件比较也可以用来模拟析取（逻辑或）。考虑以下表达式：
- en: '[PRE83]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here’s the translation of this expression to assembly language:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该表达式转换为汇编语言的过程：
- en: '[PRE84]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Notice how the conditional compare instruction tests for the not equal condition.
    If x is equal to y, you don’t need to do this comparison. In that case, the ccmp
    instruction will load 0b0100 into the condition codes, which sets Z to 1 and clears
    all the other flags. When the cset instruction tests for less than or equal, the
    equal condition (Z = 1) exists, setting W0 (bb) to 1\. Comparing a and d plays
    no role in the computation of bb’s value.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，条件比较指令如何测试不等于条件。如果x等于y，则不需要进行此比较。在这种情况下，ccmp指令会将0b0100加载到条件码中，这将使Z设为1并清除所有其他标志。当cset指令测试小于或等于时，存在相等条件（Z
    = 1），将W0（bb）设为1。比较a和d在bb值的计算中没有任何作用。
- en: If x does not equal y, the ne condition will exist when the program executes
    the ccmp instruction. Therefore, ccmp will compare a and d and set the condition
    code bits on the basis of that comparison. At that point, the cset instruction
    will set bb’s value based on the comparison of a and d.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果x不等于y，当程序执行ccmp指令时，ne条件将会存在。因此，ccmp将比较a和d，并根据该比较设置条件码位。此时，cset指令将根据a和d的比较设置bb的值。
- en: 'The following algorithm describes how to convert an expression containing disjunction
    into ARM assembly language using a conditional comparison:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法描述了如何通过条件比较将包含析取（disjunction）的表达式转换为ARM汇编语言：
- en: '[PRE85]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Here are the four steps to follow for this conversion:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是转换过程中需要遵循的四个步骤：
- en: 1.  Compare the operands on the left-hand side of the disjunction operator (operator
    is cc1).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 比较析取操作符左侧的操作数（操作符为cc1）。
- en: 2.  Immediately after the first cmp instruction, execute a ccmp instruction,
    supplying the opposite of cc1 as the conditional field (return to [Table 6-5](chapter6.xhtml#tab6-5)
    to find the opposite conditions).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在第一次cmp指令之后，立即执行ccmp指令，提供cc1的相反条件作为条件字段（返回[表6-5](chapter6.xhtml#tab6-5)查找相反条件）。
- en: '3.  Choose the corresponding #nzcv encoding from the regular column in [Table
    6-5](chapter6.xhtml#tab6-5) to match cc2. The full ccmp instruction should be
    as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 选择与cc2匹配的#nzcv编码，参见[表6-5](chapter6.xhtml#tab6-5)中的常规列。完整的ccmp指令应如下所示：
- en: '[PRE86]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '4.  The last instruction in the sequence should test cc2. For example:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 序列中的最后一条指令应测试cc2。例如：
- en: '[PRE87]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If cc1 succeeds, the ccmp instruction will set the flags to the #nzcvop value
    and not compare c against d, because you’ve chosen the opposite of cc1 for the
    ccmp condition. As you want the Boolean expression to yield true in this situation,
    choose an #nzcvop value that is the same as cc2 so that the following test (for
    example, cset) produces a true result. If cc1 is false upon executing the ccmp
    instruction, ccmp will compare c and d and set the flags appropriate for the following
    test.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果cc1成功，ccmp指令将会将标志设置为#nzcvop值，并且不再比较c与d，因为你已经为ccmp条件选择了cc1的相反条件。由于你希望布尔表达式在这种情况下为真，因此选择一个与cc2相同的#nzcvop值，使得接下来的测试（例如cset）产生真实的结果。如果执行ccmp指令时cc1为假，ccmp将比较c和d，并根据接下来的测试设置适当的标志。
- en: 6.5.3 Handling Complex Boolean Expressions
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.3 处理复杂布尔表达式
- en: You can extend the Boolean expressions by adding additional ccmp instructions
    to the sequence. Just keep in mind that, at least in C/C++, conjunction has higher
    precedence than disjunction, so you must modify your order of evaluation to handle
    conjunction first when expressions contain both operators.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在序列中添加额外的ccmp指令来扩展布尔表达式。只需记住，至少在C/C++中，连接的优先级高于析取，所以当表达式中包含两者运算符时，你必须调整评估顺序，首先处理连接。
- en: Also note that the ccmp scheme uses *complete Boolean evaluation* (meaning it
    evaluates every subterm of the Boolean expression), whereas the C++ programming
    language uses *short-circuit Boolean evaluation* (which may not compute all subterms).
    [Chapter 7](chapter7.xhtml) covers these two forms in greater detail, but for
    now, just know that the two forms may produce different results.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，ccmp方案使用*完整的布尔评估*（意味着它会评估布尔表达式的每个子项），而C++编程语言使用*短路布尔评估*（这可能不会计算所有的子项）。[第7章](chapter7.xhtml)对这两种形式进行了更详细的介绍，但目前只需知道这两种形式可能会产生不同的结果。
- en: 6.6 Machine and Arithmetic Idioms
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6 机器和算术习惯用法
- en: An *idiom* is an idiosyncrasy (a peculiarity). Several arithmetic operations
    and ARM instructions have idiosyncrasies that you can take advantage of when writing
    assembly language code. Some people refer to the use of machine and arithmetic
    idioms as *tricky programming* that you should always avoid in well-written programs.
    While it is wise to avoid tricks just for the sake of tricks, many machine and
    arithmetic idioms are well known and commonly found in assembly language programs.
    This section provides an overview of the idioms you’ll see most often.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*习惯用法*是指特殊的个性特征（独特性）。一些算术操作和ARM指令具有你可以利用的特性，在编写汇编语言代码时可以发挥作用。有些人称使用机器和算术习惯用法为*技巧编程*，而你应该始终避免在编写良好程序时使用这些技巧。虽然仅仅为了使用技巧而使用技巧是不明智的，但许多机器和算术习惯用法是广为人知的，并且在汇编语言程序中很常见。本节概述了你最常见的习惯用法。'
- en: 6.6.1 Multiplying Without mul
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.1 无需mul的乘法
- en: When multiplying by a constant, you can sometimes write equivalent code by using
    shifts, additions, and subtractions in place of multiplication instructions. Although
    performance differs little between using a mul instruction and other arithmetic
    instructions, some addressing mode variants involving shifts can spare you an
    extra multiply instruction.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当乘以常数时，有时你可以通过使用移位、加法和减法来代替乘法指令，从而编写等效代码。尽管使用mul指令与其他算术指令在性能上的差异很小，但某些涉及移位的寻址模式变体可以避免额外的乘法指令。
- en: 'Remember, a lsl instruction computes the same result as multiplying the specified
    operand by 2\. Shifting to the left two bit positions multiplies the operand by
    4\. Shifting to the left three bit positions multiplies the operand by 8\. In
    general, shifting an operand to the left *n* bits multiplies it by 2*^n*. You
    can multiply any value by a constant by using a series of shifts and additions
    or shifts and subtractions. For example, to multiply the W0 register by 10, you
    need only multiply it by 8 and then add 2 times the original value. That is, 10
    × W0 = 8 × W0 + 2 × W0\. Use the following code to accomplish this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，lsl指令计算的结果与将指定操作数乘以2的结果相同。将操作数左移两位将其乘以4，左移三位将其乘以8。一般来说，将操作数左移*n*位将其乘以2*^n*。你可以通过一系列的移位和加法或移位和减法来将任何值乘以常数。例如，要将W0寄存器乘以10，你只需先将其乘以8，然后再加上原始值的2倍。即，10
    × W0 = 8 × W0 + 2 × W0。你可以使用以下代码来实现这一点：
- en: '[PRE88]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The first instruction multiplies W0 by 2, so when the second instruction shifts
    W0 2 bits to the left, it’s actually shifting the original W0 value to the left
    by 3 bits.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令将W0乘以2，因此当第二条指令将W0左移2位时，实际上是将原始W0值左移3位。
- en: Looking at the instruction timings, you’ll see that the multiply instruction
    executes at the same speed as the lsl or add instructions, so this second sequence
    isn’t faster. However, if you have to load the constant 10 into a register to
    do the multiplication by 10, this sequence is no slower. If you’ve already done
    the shift as part of another calculation, this sequence could turn out to be faster.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 从指令时序来看，你会发现乘法指令与lsl或add指令的执行速度相同，因此第二个序列并不更快。然而，如果你必须将常数10加载到寄存器中以进行乘以10的操作，这个序列并不比乘法指令慢。如果你已经在其他计算中进行了移位操作，这个序列可能会更快。
- en: 'You can also use subtraction with shifts to perform a multiplication operation.
    Consider the following multiplication by 7:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过结合移位和减法来执行乘法操作。考虑下面的乘以7的例子：
- en: '[PRE89]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Beginning assembly language programmers commonly make the error of subtracting
    or adding 1 or 2 rather than W0 × 1 or W0 × 2\. The following does not compute
    W0 × 7:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 初学汇编语言的程序员常犯一个错误，即用1或2相加或相减，而不是使用W0 × 1或W0 × 2。下面的代码并没有计算W0 × 7：
- en: '[PRE90]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Rather, this code computes (8 × W0) – 1, which is entirely different (unless,
    of course, W0 = 1). Beware of this pitfall when using shifts, additions, and subtractions
    to perform multiplication operations.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，这段代码计算的是(8 × W0) – 1，结果完全不同（除非W0 = 1）。在使用移位、加法和减法来执行乘法操作时要小心这个陷阱。
- en: 'The Operand2 addressing mode variations, particularly those involving lsl,
    are quite useful for combining shifts along with other arithmetic operations.
    For example, consider the following pair of instructions:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数2寻址模式的变化，尤其是涉及lsl的那些变化，对于将移位操作与其他算术操作结合起来非常有用。例如，考虑下面这对指令：
- en: '[PRE91]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You can easily replace this by a single instruction:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地用一条指令替换这段代码：
- en: '[PRE92]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Because RISC CPUs, such as the ARM, tend to execute most instructions in a single
    CPU clock cycle, using *strength-reduction optimizations* like substituting shifts
    and adds for multiplication rarely pays off. Generally, a single shift instruction
    (for a multiplication by a power of 2) may produce better results than mul; beyond
    that, it’s unlikely to improve the speed, unless you need those shifts and adds
    for other calculations.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 因为像ARM这样的RISC CPU通常能够在单个CPU时钟周期内执行大多数指令，所以使用*强度削减优化*（例如，用移位和加法替代乘法）很少能够带来好处。一般来说，单个移位指令（用于乘以2的幂）可能比乘法指令（mul）效果更好；超出这个范围，除非你需要这些移位和加法来进行其他计算，否则通常不会提高速度。
- en: 6.6.2 Dividing Without sdiv or udiv
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.2 没有sdiv或udiv的除法
- en: Just as the lsl instruction is useful for simulating a multiplication by a power
    of 2, the lsr and asr instructions can simulate a division by a power of 2\. Unfortunately,
    you cannot easily use shifts, additions, and subtractions to perform division
    by an arbitrary constant. Therefore, this trick is useful only when dividing by
    powers of 2\. Also, don’t forget that the asr instruction rounds toward negative
    infinity, unlike the sdiv instruction, which rounds toward 0.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 正如lsl指令对于模拟乘以2的幂非常有用一样，lsr和asr指令可以模拟除以2的幂。不幸的是，你不能轻松地通过移位、加法和减法来执行除以任意常数的操作。因此，这个技巧只在除以2的幂时有用。另外，别忘了，asr指令是向负无穷大舍入的，而sdiv指令则是向0舍入的。
- en: On the ARM64 CPU, the division instructions tend to take about twice as long
    as other instructions to execute. Therefore, if you can simulate a division by
    a power of 2 by using a single shift-right instruction, your code will run a little
    faster. You can also divide by a value by multiplying by its reciprocal. This
    is usually faster than division, since the multiply instruction is faster than
    the divide instruction.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARM64 CPU上，除法指令的执行时间通常是其他指令的两倍。因此，如果你能够通过使用一个右移指令模拟除以2的幂，代码的执行速度将稍微提高。你还可以通过乘以倒数来进行除法。通常，乘法比除法要快，因为乘法指令比除法指令执行得更快。
- en: 'To multiply by a reciprocal when dealing with integers, you must cheat. If
    you want to multiply by 1/10, there is no way you can load the value 1/10 into
    an ARM integer register prior to performing the multiplication. It won’t work
    to multiply 1/10 by 10, perform the multiplication, and divide the result by 10
    to get the final result. In fact, this would make performance worse, because you’re
    now doing a multiplication by 10 as well as a division by 10\. However, suppose
    you multiply 1/10 by 65,536 (6,554), perform the multiplication, and then divide
    by 65,536\. Consider the following code that divides W0 by 10:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理整数时，如果想要乘以倒数，你必须采取一些技巧。如果你想乘以1/10，事先将1/10加载到ARM整数寄存器中是做不到的。将1/10乘以10进行运算，然后再用10除以结果以得到最终结果是行不通的。实际上，这会使性能更差，因为你现在需要执行一次乘法（乘以10）和一次除法（除以10）。但是，假设你将1/10乘以65,536（即6,554），执行乘法后再除以65,536，看看下面这段代码，它实现了W0除以10：
- en: '[PRE93]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This code leaves W0 / 10 in the W0 register. To understand how this works, consider
    what happens when you use the mul instruction to multiply W0 by 65,536 (0x1_0000).
    This moves the LO half word of W0 into the HO half word and sets the LO half word
    to 0 (a multiplication by 0x1_0000 is equivalent to a shift left by 16 bits).
    Multiplying by 6,554 (65,536 divided by 10) puts W0 divided by 10 into the HO
    half word of the W0 register.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将W0 / 10存放在W0寄存器中。要理解这如何工作，可以考虑使用mul指令将W0乘以65,536（0x1_0000）时会发生什么。这会将W0的低16位移动到高16位，并将低16位设置为0（乘以0x1_0000相当于左移16位）。将W0乘以6,554（65,536除以10）后，W0除以10的结果会放入W0寄存器的高16位。
- en: Multiplying by a reciprocal works well only when dividing by a constant, such
    as 10\. While you could coerce the calculation with multiple instructions to divide
    a register by a nonconstant value, the udiv/sdiv instructions would certainly
    be faster by that point; it’s questionable whether multiplying by a reciprocal
    is faster than a division.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 乘以倒数仅在除以常数（如10）时有效。虽然你可以通过多条指令强制执行将寄存器除以非恒定值的计算，但到那时udiv/sdiv指令显然会更快；而乘以倒数是否比除法更快仍然值得怀疑。
- en: 6.6.3 Implementing Modulo-N Counters with AND
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.3 使用与运算实现模N计数器
- en: To implement a counter variable that counts up to 2*^n* – 1 and then resets
    to 0, use the following code
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个计数器变量，该变量从0计数到2*^n* – 1然后重置为0，可以使用以下代码：
- en: '[PRE94]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'where nBits is a binary value containing *n* bits of 1s right-justified in
    the number. For example, to create a counter that cycles from 0 to 15 (2⁴ – 1),
    you could use the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 其中nBits是一个包含*n*个1位、右对齐的二进制值。例如，要创建一个从0计数到15（2⁴ – 1）的计数器，你可以使用以下代码：
- en: '[PRE95]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 6.6.4 Avoiding Needlessly Complex Machine Idioms
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.4 避免不必要的复杂机器习语
- en: The machine idioms you’ve just learned work well to improve performance on older
    complex instruction set computers (CISCs) that typically take a varying number
    of CPU clock cycles to execute each instruction. Complex instructions like division
    can take upward of 50 clock cycles on an x86 CPU, for example. RISC CPUs, such
    as the ARM, try to execute instructions in one clock cycle. While the ARM doesn’t
    always achieve this (sdiv and udiv are a little slower, for example), the additional
    time required doesn’t justify replacing the instruction with a long sequence of
    other instructions.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习的机器习语在提高老旧的复杂指令集计算机（CISC）的性能时效果很好，这些计算机通常需要执行每条指令时消耗不同数量的CPU时钟周期。例如，在x86
    CPU上，像除法这样的复杂指令可能需要超过50个时钟周期。RISC CPU，如ARM，试图在一个时钟周期内执行指令。虽然ARM并不总是能做到这一点（例如sdiv和udiv稍慢一些），但所需的额外时间不足以让我们用其他长指令序列来替代这条指令。
- en: Using machine idioms makes your code harder to read and understand. If using
    a machine idiom offers no clear performance benefit, stick with using easier-to-understand
    code. Those who work on your project afterward (including yourself, in the future)
    will thank you.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 使用机器习语会使你的代码更难以阅读和理解。如果使用机器习语没有明显的性能提升，最好使用更易于理解的代码。之后在你项目中工作的人（包括未来的你）会感谢你。
- en: 6.7 Floating-Point and Finite-Precision Arithmetic
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7 浮点和有限精度运算
- en: Before discussing how the ARM CPU implements floating-point arithmetic, it is
    worthwhile to first describe the mathematical theory behind floating-point arithmetic
    and the problems you will encounter when using it. This section presents a simplified
    model to explain floating-point arithmetic and why you cannot apply standard algebraic
    rules to calculations involving it.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论ARM CPU如何实现浮点运算之前，首先描述浮点运算背后的数学理论以及你在使用过程中会遇到的问题是很有价值的。本节将介绍一个简化模型，来解释浮点运算以及为什么你不能将标准代数规则应用于涉及浮点运算的计算。
- en: 6.7.1 Basic Floating-Point Terminology
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.7.1 基础浮点术语
- en: 'Integer arithmetic does not let you represent fractional numeric values. Therefore,
    modern CPUs support an approximation of *real* arithmetic: *floating-point arithmetic*.
    To represent real numbers, most floating-point formats employ scientific notation
    and use a certain number of bits to represent a mantissa and a smaller number
    of bits to represent an exponent.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 整数运算无法表示小数值。因此，现代CPU支持*实数*运算的近似：*浮点运算*。为了表示实数，大多数浮点格式采用科学记数法，并使用一定数量的位来表示尾数，较少的位来表示指数。
- en: For example, in the number 3.456e+12, the mantissa consists of 3.456, and the
    exponent digits are 12\. Because the number of bits is fixed in computer-based
    representations, computers can represent only a certain number of digits (known
    as *significant digits*) in the mantissa. For example, if a floating-point representation
    could handle only three significant digits, then the fourth digit in 3.456e+12
    (the 6) could not be accurately represented with that format, as three significant
    digits can represent only 3.45e+12 or 3.46e+12 correctly.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在数字 3.456e+12 中，尾数是 3.456，而指数位是 12。因为计算机中的位数是固定的，所以计算机只能表示尾数中的某些数字（称为 *有效数字*）。例如，如果浮动点表示只能处理三个有效数字，那么
    3.456e+12 中的第四位数字（6）就无法准确表示，因为三个有效数字只能正确表示 3.45e+12 或 3.46e+12。
- en: Because computer-based floating-point representations also use a finite number
    of bits to represent the exponent, that exponent also has a limited range of values,
    approximately ranging from 10 ^(± 38) for the single-precision format to about
    10 ^(± 308) for the double-precision format. This is known as the *dynamic range*
    of the value. Denormalized numbers (which I’ll define shortly) can represent values
    as small as ±4.94066 × 10^(–324).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 因为基于计算机的浮动点表示也使用有限的位数来表示指数，所以该指数也有一个有限的值范围，大约从单精度格式的 10 ^(± 38) 到双精度格式的 10 ^(±
    308)。这被称为值的*动态范围*。非标准化数（我稍后会定义）可以表示小到 ±4.94066 × 10^(–324) 的值。
- en: 6.7.2 Limited-Precision Arithmetic and Accuracy
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.7.2 有限精度算术与准确性
- en: A big problem with floating-point arithmetic is that it does not follow the
    standard rules of algebra. Normal algebraic rules apply only to *infinite-precision*
    arithmetic. Therefore, if you translate an algebraic formula into code, that code
    might produce different results from what you would (mathematically) expect. This
    can introduce defects in your software.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动点算术的一个大问题是它不遵循标准的代数规则。标准代数规则仅适用于 *无限精度* 算术。因此，如果你将一个代数公式转化为代码，这段代码可能会产生与你（数学上）期望的不同结果。这可能会在你的软件中引入缺陷。
- en: Consider the simple statement *x* = *x* + 1, where *x* is an integer. On any
    modern computer, this statement follows the normal rules of algebra *as long as
    overflow does not occur.* That is, this statement is valid only for certain values
    of *x* (*minint* ≤ *x* < *maxint*). Most programmers do not have a problem with
    this because they are well aware that integers in a program do not follow the
    standard algebraic rules (for example, 5 / 2 does not equal 2.5).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑简单的语句 *x* = *x* + 1，其中 *x* 是一个整数。在任何现代计算机上，这个语句遵循正常的代数规则，*只要没有溢出发生*。也就是说，这个语句仅对某些
    *x* 的值有效（*minint* ≤ *x* < *maxint*）。大多数程序员对此不会有问题，因为他们非常清楚程序中的整数并不遵循标准的代数规则（例如，5
    / 2 不等于 2.5）。
- en: Integers do not follow the standard rules of algebra because the computer represents
    them with a finite number of bits. You cannot represent any of the (integer) values
    above the maximum integer or below the minimum integer. Floating-point values
    suffer from this same problem, only worse. After all, integers are a subset of
    real numbers. Therefore, the floating-point values must represent the same infinite
    set of integers. However, an infinite number of real values exist between any
    two integer values. In addition to having to limit your values between a maximum
    and minimum range, you cannot represent all the values between any pair of integers
    either.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 整数不遵循标准的代数规则，因为计算机用有限的位数表示它们。你无法表示任何超出最大整数或小于最小整数的（整数）值。浮动点值也有这个问题，而且问题更严重。毕竟，整数是实数的一个子集。因此，浮动点值必须表示同一无限集合的整数。然而，在任何两个整数之间存在无限多个实数值。除了必须将值限制在最大和最小范围之间之外，你还无法表示任何一对整数之间的所有值。
- en: To demonstrate the impact of limited-precision arithmetic, this chapter adopts
    a simplified decimal floating-point format for our examples. This format provides
    a mantissa with three significant digits and a decimal exponent with two digits.
    The mantissa and exponents are both signed values, as shown in [Figure 6-1](chapter6.xhtml#fig6-1).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示有限精度算术的影响，本章采用了一种简化的十进制浮动点格式作为我们的示例。该格式提供了一个三位有效数字的尾数和一个两位数的十进制指数。尾数和指数都是有符号值，如[图
    6-1](chapter6.xhtml#fig6-1)所示。
- en: '![](../images/Figure6-1.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-1.jpg)'
- en: 'Figure 6-1: A floating-point format'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：浮动点格式
- en: When adding and subtracting two numbers in scientific notation, you must adjust
    the two values so that their exponents are the same. Multiplication and division
    don’t require the exponents to be the same; instead, the exponent after a multiplication
    is the sum of the two operand exponents, and the exponent after a division is
    the difference of the dividend and divisor’s exponents.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行科学计数法的加减法时，必须调整两个值，使它们的指数相同。乘法和除法则不要求指数相同；相反，乘法后的指数是两个操作数指数的和，而除法后的指数是被除数和除数指数的差。
- en: For example, when adding 1.2e1 and 4.5e0, you must adjust the values so that
    they have the same exponent. One way to do this is to convert 4.5e0 to 0.45e1
    and then add, producing 1.65e1\. Because the computation and result require only
    three significant digits, you can compute the correct result via the representation
    shown in [Figure 6-1](chapter6.xhtml#fig6-1).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当加上1.2e1和4.5e0时，你必须调整这两个值，使它们具有相同的指数。实现这一点的一种方法是将4.5e0转换为0.45e1，然后相加，得到1.65e1。由于计算和结果只需要三位有效数字，因此你可以通过[图6-1](chapter6.xhtml#fig6-1)中所示的表示法来计算正确的结果。
- en: However, suppose you want to add the two values 1.23e1 and 4.56e0\. Although
    both values can be represented using the three-significant-digit format, the computation
    and result do not fit into three significant digits. That is, 1.23e1 + 0.456e1
    requires four digits of precision in order to compute the correct result of 1.686,
    so you must either *round* or *truncate* the result to three significant digits.
    Rounding generally produces the most accurate result, so round the result to obtain
    1.69e1.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设你要将两个值1.23e1和4.56e0相加。尽管这两个值都可以使用三位有效数字格式表示，但计算和结果并不适合三位有效数字。也就是说，1.23e1
    + 0.456e1需要四位精度才能计算出正确的结果1.686，因此你必须将结果*四舍五入*或*截断*为三位有效数字。四舍五入通常能产生最准确的结果，因此应将结果四舍五入为1.69e1。
- en: In fact, the rounding does not occur after adding the two values together (that
    is, producing the sum 1.686e1 and then rounding this to 1.69e1), but rather when
    converting 4.56e0 to 0.456e1, because four digits of precision are required to
    maintain the value 0.456e1\. Therefore, during the conversion, you have to round
    0.456e1 to 0.46e1 so that the result fits into three significant digits. The sum
    of 1.23e1 and 0.46e1 then produces the final rounded sum of 1.69e1.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，四舍五入并不是在两个值相加后发生的（即，得到和1.686e1并四舍五入为1.69e1），而是在将4.56e0转换为0.456e1时发生的，因为保持值0.456e1需要四位精度。因此，在转换过程中，你必须将0.456e1四舍五入为0.46e1，以便结果适应三位有效数字。1.23e1和0.46e1的和然后得出最终四舍五入的和1.69e1。
- en: As you can see, the lack of *precision* (the number of digits or bits maintained
    in a computation) affects the *accuracy* (the correctness of the computation).
    In the addition/subtraction example, you could round the result because you maintained
    four significant digits *during* the calculation (specifically, when converting
    4.56e0 to 0.456e1). If your floating-point calculation had been limited to three
    significant digits during computation, you would have had to truncate the last
    digit of the smaller number, obtaining 0.45e1 and producing a sum of 1.68e1, a
    value that is even less accurate.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*精度*（计算中保持的数字或位数）影响了*准确性*（计算的正确性）。在加法/减法示例中，由于你在计算过程中保持了四个有效数字*在*计算中（具体来说，在将4.56e0转换为0.456e1时），你可以对结果进行四舍五入。如果你的浮点计算在计算过程中只保留了三位有效数字，你就不得不截断较小数字的最后一位，得到0.45e1，并得出1.68e1的和，这个结果的准确性更低。
- en: To improve the accuracy of floating-point calculations, it is useful to maintain
    one or more extra digits for use during the calculation, such as the extra digit
    used to convert 4.56e0 to 0.456e1\. Extra digits available during a computation
    are known as *guard digits* (or *guard bits* in the case of a binary format).
    They greatly enhance accuracy during a long chain of computations.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高浮点计算的精确度，保持一个或多个额外的数字用于计算中是有用的，例如将4.56e0转换为0.456e1时使用的额外数字。计算过程中可用的额外数字被称为*保护数字*（在二进制格式中称为*保护位*）。它们在长链计算中能大大提高精度。
- en: 6.7.3 Errors in Floating-Point Calculations
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.7.3 浮点计算中的误差
- en: In a sequence of floating-point operations, errors can accumulate and greatly
    affect the computation itself. For example, suppose you were to add 1.23e3 to
    1.00e0\. Adjusting the numbers so their exponents are the same before the addition
    produces 1.23e3 + 0.001e3\. The sum of these two values, even after rounding,
    is 1.23e3\. This might seem perfectly reasonable; after all, you can maintain
    only three significant digits, so adding in a small value shouldn’t affect the
    result at all.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在一系列浮点数运算中，误差可能会积累，并极大地影响计算结果。例如，假设你将1.23e3加到1.00e0。若在加法前调整数字，使它们的指数相同，就会变成1.23e3
    + 0.001e3。即使进行四舍五入，这两个数的和仍然是1.23e3。这看起来似乎很合理；毕竟，你只能保留三位有效数字，因此加一个小的数值不应该影响结果。
- en: 'However, suppose you were to add 1.00e0 to 1.23e3 *ten times* (though not in
    the same calculation, where guard digits could maintain the fourth digit during
    the calculation). The first time you add 1.00e0 to 1.23e3, you get 1.23e3\. You
    get this same result the second, third, fourth ... and tenth times you add 1.00e0
    to 1.23e3\. On the other hand, had you added 1.00e0 to itself 10 times, then added
    the result (1.00e1) to 1.23e3, you would have gotten a different result, 1.24e3\.
    Keep in mind this important guideline for limited-precision arithmetic:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设你将1.00e0加到1.23e3上*十次*（尽管这些操作不是在同一个计算中进行的，在计算过程中，保护数字可以保持第四位数字）。第一次将1.00e0加到1.23e3时，你得到1.23e3。第二次、第三次、第四次……直到第十次，你仍然得到相同的结果1.23e3。另一方面，如果你先将1.00e0加到自身十次，再将结果（1.00e1）加到1.23e3，你将得到不同的结果：1.24e3。请记住，有限精度运算中的这个重要原则：
- en: When performing complex operations, watch the order of evaluation, as it can
    affect the accuracy of the result.
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在进行复杂运算时，注意评估顺序，因为它可能会影响结果的准确性。
- en: You’ll get more accurate results if the relative magnitudes (the exponents)
    are close to one another when adding and subtracting floating-point values. If
    you’re performing a chain calculation involving addition and subtraction, attempt
    to group the values appropriately.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浮点数的相对大小（即指数）接近，当进行加法和减法时，你将得到更准确的结果。如果你进行的是包含加法和减法的连锁计算，尽量适当分组这些数值。
- en: 'When computing addition and subtraction, you can also wind up with *false precision*.
    Consider the computation 1.23e0 – 1.22e0, which produces 0.01e0\. Although the
    result is mathematically equivalent to 1.00e – 2, this latter form suggests that
    the last two digits are exactly 0\. Unfortunately, you have only a single significant
    digit at this time (remember, the original result was 0.01e0, and those two leading
    0s were significant digits). Indeed, some floating-point unit (FPU) or software
    packages might actually insert random digits (or bits) into the LO positions.
    This highlights a second important rule concerning limited-precision arithmetic:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算加法和减法时，你还可能遇到*虚假的精度*。考虑计算1.23e0 – 1.22e0，结果为0.01e0。虽然该结果在数学上等同于1.00e–2，但后一种形式暗示最后两位数字正好为0。遗憾的是，此时你只有一个有效数字（记住，原始结果是0.01e0，那两个前导0是有效数字）。实际上，一些浮点单元（FPU）或软件包可能会在低位位置插入随机数字（或位）。这突出了关于有限精度运算的第二条重要规则：
- en: When subtracting two numbers with the same signs (or adding two numbers with
    different signs), be aware that the result may contain high-order significant
    digits (bits) that are 0\. This reduces the number of significant digits (bits)
    by a like amount in the final result. If possible, try to arrange your calculations
    to avoid this.
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在进行两个符号相同的数字相减（或两个符号不同的数字相加）时，请注意结果可能包含高阶的有效数字（位），这些数字为0。这会使最终结果的有效数字（位）减少相同的数量。如果可能的话，尽量调整你的计算方式，避免这种情况。
- en: 'By themselves, multiplication and division do not produce particularly poor
    results. However, they tend to multiply any error that already exists in a value.
    For example, if you multiply 1.23e0 by 2 when you should be multiplying 1.24e0
    by 2, the result is even less accurate. This leads to a third important rule for
    working with limited-precision arithmetic:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，乘法和除法并不会产生特别差的结果。然而，它们往往会放大已经存在的误差。例如，如果你应该将1.24e0乘以2，但却将1.23e0乘以2，那么结果会更加不准确。这也导致了关于有限精度运算的第三条重要规则：
- en: When performing a chain of calculations involving addition, subtraction, multiplication,
    and division, try to perform the multiplication and division operations first.
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在进行一连串包含加法、减法、乘法和除法的计算时，尽量先执行乘法和除法操作。
- en: Often, by applying normal algebraic transformations, you can arrange a calculation
    so the multiply and divide operations occur first. For example, suppose you want
    to compute *x* * (*y* + *z*). Normally, you would add *y* and *z* together and
    multiply their sum by *x*. However, your results will be a little more accurate
    if you transform *x* * (*y* + *z*) to get *x* * *y* + *x* * z and compute the
    result by performing the multiplications first. Of course, the drawback is that
    you must now perform two multiplications rather than one, so the result may be
    slower.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过应用正常的代数变换，你可以调整计算顺序，使得乘法和除法操作优先执行。例如，假设你想计算 *x* * (*y* + *z*)。通常，你会先将 *y*
    和 *z* 相加，然后将它们的和乘以 *x*。然而，如果你将 *x* * (*y* + *z*) 转换为 *x* * *y* + *x* * *z* 并首先进行乘法运算，你的结果将更加精确。当然，缺点是你现在需要执行两次乘法而不是一次，所以结果可能会更慢。
- en: 'Multiplication and division have their own problems. When multiplying two very
    large or very small numbers, it is quite possible for *overflow* or *underflow*
    to occur. The same situation occurs when dividing a small number by a large number,
    or dividing a large number by a small (fractional) number. This brings us to a
    fourth rule to follow when multiplying or dividing values:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法和除法也有其问题。当乘以两个非常大或非常小的数字时，*溢出* 或 *下溢* 很可能发生。当除以一个小数和一个大数，或者将大数除以一个小（分数）数时，也会发生类似的情况。这就引出了我们在乘法或除法中应该遵循的第四条规则：
- en: When multiplying and dividing sets of numbers, try to arrange the multiplications
    so that they multiply large and small numbers together; likewise, try to divide
    numbers that have the same relative magnitudes.
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在乘法和除法运算中，尽量安排乘法，使得它们将大数和小数相乘；同样，尝试将相对大小相同的数进行除法运算。
- en: 6.7.4 Floating-Point Value Comparisons
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.7.4 浮点值比较
- en: Given the inaccuracies present in any computation (including converting an input
    string to a floating-point value), you should *never* compare two floating-point
    values to see if they are equal. In a binary floating-point format, different
    computations that produce the same (mathematical) result may differ in their least
    significant bits. For example, 1.31e0 + 1.69e0 should produce 3.00e0\. Likewise,
    1.50e0 + 1.50e0 should also produce 3.00e0\. However, if you were to compare (1.31e0
    + 1.69e0) against (1.50e0 + 1.50e0), you might find out that these sums are *not*
    equal to each other.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何计算中都会存在不准确性（包括将输入字符串转换为浮点值），你*永远不要*比较两个浮点值是否相等。在二进制浮点格式中，不同的计算结果可能会在最不重要的位上有所不同，即使它们产生相同的（数学）结果。例如，1.31e0
    + 1.69e0 应该产生 3.00e0。同样，1.50e0 + 1.50e0 也应该产生 3.00e0。然而，如果你将 (1.31e0 + 1.69e0)
    与 (1.50e0 + 1.50e0) 进行比较，你可能会发现这些和*不*相等。
- en: 'The test for equality succeeds if and only if all bits (or digits) in the two
    operands are exactly the same. Because this is not necessarily true after two
    different floating-point computations that should produce the same result, a straight
    test for equality may not work. Instead, use the following test:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当两个操作数的所有位（或数字）完全相同时，平等性测试才会成功。因为在两个不同的浮点计算中，它们应该产生相同的结果，但这不一定成立，直接的平等性测试可能无法正常工作。因此，使用以下测试：
- en: '[PRE96]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Another common way to handle this same comparison is to use a statement of
    this form:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的方法来处理相同的比较是使用如下形式的语句：
- en: '[PRE97]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In these statements, error should be a value slightly greater than the largest
    amount of error that will creep into your computations. The exact value will depend
    on the particular floating-point format you use. In short, follow this final rule:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些语句中，误差应该是一个稍大于你计算中可能出现的最大误差值的数值。确切的值将取决于你使用的具体浮点格式。简而言之，遵循以下最终规则：
- en: When comparing two floating-point numbers, always compare one value to see whether
    it is in the range given by the second value plus or minus a small error value.
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在比较两个浮点数时，始终比较一个值，看看它是否在第二个值加上或减去一个小的误差值的范围内。
- en: Many other little problems can occur when using floating-point values. This
    book points out only some of the major problems and will make you aware that you
    cannot treat floating-point arithmetic like real arithmetic because of the inaccuracies
    present in limited-precision arithmetic. A good text on numerical analysis or
    even scientific computing can help fill in the details. If you plan to work with
    floating-point arithmetic in any language, take the time to study the effects
    of limited-precision arithmetic on your computations (see section 6.13, “For More
    Information,” on [page 352](chapter6.xhtml#pg_352)).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浮点值时可能会出现许多其他小问题。本书仅指出了一些主要问题，并会提醒你，由于有限精度运算中的不准确性，你不能像对待实数运算一样对待浮点运算。有关数值分析或科学计算的好书可以帮助你了解这些细节。如果你计划在任何语言中处理浮点运算，花时间研究有限精度运算对计算的影响（见第6.13节，“更多信息”，[第352页](chapter6.xhtml#pg_352)）。
- en: Now that you’ve seen the theory behind floating-point arithmetic, we’ll review
    the ARM’s implementation of floating-point.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了浮点运算的理论，接下来我们将回顾ARM对浮点运算的实现。
- en: 6.8 Floating-Point Arithmetic on the ARM
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8 ARM上的浮点运算
- en: When the ARM CPU was first designed, floating-point arithmetic was among the
    set of “complex” instructions that RISC CPUs avoided. Those who required floating-point
    arithmetic were forced to implement it in software. As time passed, it became
    clear that high-performance systems required fast floating-point arithmetic, so
    it was added to the ARM’s instruction set.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当ARM CPU首次设计时，浮点运算是RISC CPU回避的“复杂”指令之一。需要浮点运算的人不得不通过软件实现它。随着时间的推移，人们逐渐意识到高性能系统需要快速的浮点运算，因此它被加入到了ARM的指令集中。
- en: The ARM64 supports the IEEE single- and double-precision floating-point formats
    (see section 2.13, “IEEE Floating-Point Formats,” on [page 93](chapter2.xhtml#pg_93)),
    as well as a 16-bit half-precision floating-point format that appeared in later
    revisions of the IEEE standard. To support floating-point arithmetic, the ARM
    provides an extra set of registers and augments the instruction set with suitable
    floating-point instructions. Originally, these types of instructions were handled
    by coprocessors—separate chips that handled floating-point instructions (while
    the main CPU handled integer operations). In the ARM64 architecture, the FPU is
    built into the main CPU’s integrated circuit.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ARM64支持IEEE单精度和双精度浮点格式（见第2.13节，“IEEE浮点格式”，[第93页](chapter2.xhtml#pg_93)），以及在IEEE标准后期版本中出现的16位半精度浮点格式。为了支持浮点运算，ARM提供了额外的寄存器组，并通过合适的浮点指令增强了指令集。最初，这些类型的指令由协处理器处理——协处理器是专门处理浮点指令的芯片（而主CPU处理整数运算）。在ARM64架构中，FPU（浮点单元）被集成进主CPU的集成电路中。
- en: The following subsections introduce the floating-point register set, the floating-point
    status register, and the floating-point control register. These are the programmer-visible
    components of the floating-point hardware on the ARM CPU.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节介绍了浮点寄存器集、浮点状态寄存器和浮点控制寄存器。这些是ARM CPU上浮点硬件中程序员可见的组件。
- en: 6.8.1 Neon Registers
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.8.1 Neon寄存器
- en: To support floating-point arithmetic, the ARM64 provides a second set of 32
    registers specifically tailored to hold floating-point and other values. These
    are known as the *Neon registers* because, in addition to supporting scalar floating-point
    (FP) arithmetic, they also support vector arithmetic using the Neon instruction
    set extensions, covered in [Chapter 11](chapter11.xhtml).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持浮点运算，ARM64提供了第二组专门设计用来存储浮点和其他值的32个寄存器。这些被称为*Neon寄存器*，因为除了支持标量浮点（FP）运算外，它们还支持使用Neon指令集扩展进行的向量运算，相关内容见[第11章](chapter11.xhtml)。
- en: 'The 32 main FP/Neon registers are 128 bits each. Just as the general-purpose
    registers are divided into two sets based on their size (W*n* and X*n*), the FP/Neon
    registers are broken into five groups based on their size:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 32个主要的FP/Neon寄存器每个为128位。就像通用寄存器根据其大小（W*n*和X*n*）被分为两组一样，FP/Neon寄存器也根据大小分为五组：
- en: '**V0 to V31**    The 128-bit *vector* registers (for Neon instructions), also
    referenced as Q0 to Q31, the qword registers. The V*n* names support special syntax
    for vector operations.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**V0到V31**    128位的*向量*寄存器（用于Neon指令），也称为Q0到Q31，qword寄存器。V*n*名称支持向量操作的特殊语法。'
- en: '**D0 to D31**    The 64-bit *double-precision* floating-point registers.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**D0到D31**    64位的*双精度*浮点寄存器。'
- en: '**S0 to S31**     The 32-bit *single-precision* floating-point registers.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**S0到S31**    32位的*单精度*浮点寄存器。'
- en: '**H0 to H31**    The 16-bit *half-precision* floating-point registers.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**H0到H31**    16位的*半精度*浮点寄存器。'
- en: '**B0 to B31**    The 8-bit *byte* registers.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**B0到B31**    8位的*字节*寄存器。'
- en: 'In addition to the 32 main registers, this set includes two special-purpose
    floating-point registers: the floating-point status register (FPSR) and the floating-point
    control register (FPCR), shown in [Figure 6-2](chapter6.xhtml#fig6-2). You’ll
    learn more about these registers in the following subsections.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 除了32个主寄存器外，该集合还包括两个特殊用途的浮点寄存器：浮点状态寄存器（FPSR）和浮点控制寄存器（FPCR），如[图6-2](chapter6.xhtml#fig6-2)所示。在以下小节中你将进一步了解这些寄存器。
- en: '![](../images/Figure6-2.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-2.jpg)'
- en: 'Figure 6-2: The FP/Neon registers'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：FP/Neon寄存器
- en: The B*n*, H*n*, S*n*, D*n*, and V*n* registers overlay one another, as shown
    in [Figure 6-3](chapter6.xhtml#fig6-3).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: B*n*、H*n*、S*n*、D*n*和V*n*寄存器互相覆盖，如[图6-3](chapter6.xhtml#fig6-3)所示。
- en: '![](../images/Figure6-3.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-3.jpg)'
- en: 'Figure 6-3: The FP/Neon register overlays'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：FP/Neon寄存器覆盖
- en: For historical reasons, the even-numbered single-precision registers (S0, S2,
    ..., S30) are mapped to bits 0 through 31 in D0 through D15, and the odd-numbered
    single-precision registers are mapped to bits 32 through 64\. No S*n* registers
    are mapped to D16 through D31 (see [Figure 6-4](chapter6.xhtml#fig6-4)).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，偶数编号的单精度寄存器（S0, S2, ..., S30）被映射到D0到D15中的第0到第31位，奇数编号的单精度寄存器被映射到第32到第64位。没有S*n*寄存器映射到D16到D31（见[图6-4](chapter6.xhtml#fig6-4)）。
- en: '![](../images/Figure6-4.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-4.jpg)'
- en: 'Figure 6-4: How Sn registers overlay Dn registers'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：Sn寄存器如何覆盖Dn寄存器
- en: The following sections concentrate mainly on the D*n* and S*n* register sets.
    This book doesn’t discuss half-precision floating-point arithmetic in depth, as
    it’s used mainly by graphics processing units (GPUs) and certain graphics routines.
    The floating-point hardware doesn’t actually work with half-precision values—it
    only allows you to convert between half- and single- or double-precision values.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节主要集中在D*n*和S*n*寄存器集。本书不深入讨论半精度浮点算术，因为它主要用于图形处理单元（GPU）和某些图形例程。浮点硬件实际上并不处理半精度值——它仅允许你在半精度和单精度或双精度值之间转换。
- en: Most of the ARM floating-point instructions operate on the D*n* or S*n* registers.
    This chapter collectively refers to these registers as F*n*, meaning you can substitute
    any double- or single-precision register for F*n*. I will also note exceptions
    as needed. Vector registers (V*n*) are the subject of [Chapter 11](chapter11.xhtml).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数ARM浮点指令作用于D*n*或S*n*寄存器。本章将这些寄存器统称为F*n*，意味着你可以将任何双精度或单精度寄存器替代为F*n*。我还会根据需要指出例外情况。向量寄存器（V*n*）是[第11章](chapter11.xhtml)的内容。
- en: 6.8.2 Control Register
  id: totrans-486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.8.2 控制寄存器
- en: The *floating-point control register (FPCR)* specifies how certain floating-point
    operations take place. Although this register is 32 bits, only 6 bits are used,
    as you can see in [Figure 6-5](chapter6.xhtml#fig6-5).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮点控制寄存器（FPCR）*指定某些浮点操作如何进行。尽管该寄存器是32位的，但只有6个位被使用，正如你在[图6-5](chapter6.xhtml#fig6-5)中所看到的。'
- en: '![](../images/Figure6-5.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-5.jpg)'
- en: 'Figure 6-5: The FPCR layout'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：FPCR布局
- en: '[Table 6-9](chapter6.xhtml#tab6-9) describes the meaning of each of these bits.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6-9](chapter6.xhtml#tab6-9)描述了这些位的含义。'
- en: 'Table 6-9: FPCR Bits'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-9：FPCR位
- en: '| Bit(s) | Name | Description |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| 位(s) | 名称 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 19 | FZ16 | Flush-to-zero mode for half-precision arithmetic. 0 = disabled,
    1 = enabled. This replaces denormalized values with 0\. The result may not be
    as precise, but the instructions may execute faster. |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| 19 | FZ16 | 半精度算术的零值清除模式。0 = 禁用，1 = 启用。此模式将非规范化值替换为0。结果可能不如精确，但指令可能执行得更快。
    |'
- en: '| 22, 23 | Rmode | Rounding mode: 00 = round to nearest, 01 = round to +infinity,
    10 = round to –infinity, 11 = truncate (round toward 0). |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| 22, 23 | Rmode | 舍入模式：00 = 四舍五入到最接近的值，01 = 向+∞舍入，10 = 向-∞舍入，11 = 截断（向0舍入）。
    |'
- en: '| 24 | FZ | Flush-to-zero mode for single- and double-precision arithmetic.
    |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| 24 | FZ | 单精度和双精度算术的零值清除模式。 |'
- en: '| 25 | DN | Default NaN (not a number) mode. 0 = disable default NaN mode,
    1 = enable. When disabled, NaNs propagate through arithmetic operations; when
    enabled, invalid operations return the default NaN. |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| 25 | DN | 默认NaN（非数字）模式。0 = 禁用默认NaN模式，1 = 启用。当禁用时，NaN会在算术操作中传播；当启用时，无效操作返回默认NaN。
    |'
- en: '| 26 | AHP | Alternate half-precision bit. Enables (1) alternate half-precision
    mode or (0) IEEE half-precision mode. |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| 26 | AHP | 备用半精度位。启用（1）备用半精度模式或（0）IEEE半精度模式。 |'
- en: For the most part, you’ll leave all these bits set to 0\. Setting Rmode to 0b11
    is a reasonable change when you want to truncate rather than round a floating-point
    calculation.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你会将这些位保持为0。当你希望截断而不是舍入浮点计算时，将Rmode设置为0b11是一个合理的变化。
- en: 'To manipulate the FPCR register, use the mrs (move system to register) and
    msr (move register to system) instructions, specifying FPCR as the system register:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 要操作FPCR寄存器，请使用mrs（将系统移动到寄存器）和msr（将寄存器移动到系统）指令，指定FPCR作为系统寄存器：
- en: '[PRE98]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'For example, to clear all the (defined) bits in the FPCR, you’d use the following
    instructions:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要清除FPCR中的所有（已定义）位，可以使用以下指令：
- en: '[PRE99]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Set the rounding mode to truncate with the following instructions:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下指令将舍入模式设置为截断：
- en: '[PRE100]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The default FPCR settings are unknown on a warm reset, so you should always
    initialize this register before performing floating-point operations.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的FPCR设置在热重启时未知，因此在执行浮点操作之前，你应始终初始化此寄存器。
- en: 6.8.3 Status Register
  id: totrans-507
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.8.3 状态寄存器
- en: The FPSR holds status information about ARM floating-point hardware. Reading
    this register provides the current floating-point status, while writing to it
    allows you to clear exception conditions. Although this is a 32-bit register,
    only 11 bits are defined and, in fact, only 7 of those are used in 64-bit mode
    (see [Figure 6-6](chapter6.xhtml#fig6-6)).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 'FPSR保存关于ARM浮点硬件的状态信息。读取此寄存器提供当前的浮点状态，而写入它则可以清除异常条件。尽管这是一个32位寄存器，但仅定义了11个位，实际上在64位模式下仅使用其中7个位（参见[图6-6](chapter6.xhtml#fig6-6)）。 '
- en: '![](../images/Figure6-6.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-6.jpg)'
- en: 'Figure 6-6: The FPSR layout'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6：FPSR布局
- en: '[Table 6-10](chapter6.xhtml#tab6-10) describes the purpose of each of the bits
    in the FPSR.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6-10](chapter6.xhtml#tab6-10)描述了FPSR中每个位的用途。'
- en: 'Table 6-10: FPSR Bits'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-10：FPSR 位
- en: '| Bit(s) | Name | Definition |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| 位 | 名称 | 定义 |'
- en: '| --- | --- | --- |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | IOC | Invalid operation cumulative flag. This bit is set when the result
    of an operation has no mathematical value or cannot be represented. |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| 0 | IOC | 无效操作累计标志。当一个操作的结果没有数学意义或无法表示时，设置此位。 |'
- en: '| 1 | DZC | Division by zero cumulative flag. This bit is set when a division
    by zero occurs. |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| 1 | DZC | 除零累计标志。当发生除零操作时，设置此位。 |'
- en: '| 2 | OFC | Overflow cumulative flag. This bit is set when a floating-point
    operation causes an overflow situation. |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| 2 | OFC | 溢出累计标志。当浮点操作导致溢出时，设置此位。 |'
- en: '| 3 | UFC | Underflow cumulative flag. This bit is set when underflow occurs
    during an arithmetic operation. |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| 3 | UFC | 下溢累计标志。当在算术操作中发生下溢时，设置此位。 |'
- en: '| 4 | IXC | Inexact cumulative flag. This bit is set (often!) when a floating-point
    operation produces an inexact result. |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| 4 | IXC | 不精确累计标志。当浮点操作产生不精确结果时，通常会设置此位。 |'
- en: '| 7 | IDC | Input denormal cumulative flag. This bit is set when a denormalized
    input operand is replaced in the computation by a zero. |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| 7 | IDC | 输入非正规化累计标志。当一个非正规化的输入操作数在计算中被替换为零时，设置此位。 |'
- en: '| 27 | QC | Saturation cumulative flag. This flag is set when a saturation
    instruction clips a value. See [Chapter 11](chapter11.xhtml) for a discussion
    of the saturating instructions. |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| 27 | QC | 饱和累计标志。当饱和指令剪裁一个值时，设置此标志。有关饱和指令的讨论，请参见[第11章](chapter11.xhtml)。
    |'
- en: '| 28–31 | N, C, Z, V | These flags are used only in 32-bit mode. In 64-bit
    mode, the floating-point comparisons and other instructions directly set the N,
    Z, C, and V flags in the PSTATE register. |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| 28–31 | N, C, Z, V | 这些标志仅在32位模式下使用。在64位模式下，浮点比较和其他指令直接设置PSTATE寄存器中的N、Z、C和V标志。
    |'
- en: 'You can read and write the FPSR with the mrs and msr instructions, using FPSR
    as the system register name. Read the FPSR to determine if any floating-point
    exceptions have occurred, and write the FPSR to clear the exception bits (by writing
    0s to the affected bits in the register). For example the following code clears
    the Invalid Operation Cumulative flag in the FPSR:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过mrs和msr指令读取和写入FPSR，使用FPSR作为系统寄存器名称。读取FPSR以确定是否发生了任何浮点异常，写入FPSR则可以清除异常位（通过将0写入寄存器中的受影响位）。例如，以下代码清除FPSR中的无效操作累计标志：
- en: '[PRE101]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 6.9 Floating-Point Instructions
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9 浮点指令
- en: The FPU adds many instructions to the ARM instruction set. I will classify these
    as data movement instructions, conversions, arithmetic instructions, comparisons,
    and miscellaneous instructions. This section describes each instruction in these
    categories.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 向 ARM 指令集添加了许多指令。我将这些指令分类为数据传输指令、转换指令、算术指令、比较指令和杂项指令。本节描述了这些类别中的每条指令。
- en: 6.9.1 FPU Data Movement Instructions
  id: totrans-527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.9.1 FPU 数据传输指令
- en: The *data movement instructions* transfer data between the internal FPU registers
    and memory. The instructions in this category are ldr/ldur, str/stur, ldp/ldnp,
    stp/stnp, and fmov.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据传输指令*在内部 FPU 寄存器和内存之间传输数据。该类别的指令包括 ldr/ldur、str/stur、ldp/ldnp、stp/stnp 和
    fmov。'
- en: 6.9.1.1 ldr/ldur and str/stur
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.1.1 ldr/ldur 和 str/stur
- en: The ldr and str instructions load one of the FPU registers from a memory location,
    using the normal memory addressing modes. The ldur/stur instructions force an
    unscaled load or store operation, for cases where the assembler might choose a
    scaled indirect-plus-offset mode. Generally, rather than using ldur/stur, you’d
    let the assembler pick the appropriate underlying machine coding for you.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: ldr 和 str 指令从内存位置加载一个 FPU 寄存器，使用正常的内存寻址模式。ldur/stur 指令强制执行一个未缩放的加载或存储操作，适用于汇编器可能选择缩放的间接加偏移模式的情况。通常，你会让汇编器为你选择合适的底层机器编码，而不是使用
    ldur/stur。
- en: 'You can specify any of the FPU register names when using this instruction.
    For example, the following code loads the specified floating-point registers from
    memory:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此指令时，你可以指定任何 FPU 寄存器的名称。例如，以下代码从内存中加载指定的浮点寄存器：
- en: '[PRE102]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 6.9.1.2 ldp/ldnp and stp/stnp
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.1.2 ldp/ldnp 和 stp/stnp
- en: 'The ldp and stp instructions work similarly to their integer counterparts with
    floating-point registers: they load or store a pair of registers at a time. These
    instructions do not support the H*n* or B*n* registers; you can load only word,
    dword, or qword FPU registers using these instructions.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: ldp 和 stp 指令的工作方式类似于它们的整数对应指令，作用于浮点寄存器：它们一次加载或存储一对寄存器。这些指令不支持 H*n* 或 B*n* 寄存器；你只能使用这些指令加载字（word）、双字（dword）或四字（qword）FPU
    寄存器。
- en: 'The following examples demonstrate loading 256, 128, and 64 bits from memory:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何从内存中加载 256 位、128 位和 64 位的数据：
- en: '[PRE103]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The ldnp and stnp instructions do nontemporal loads and stores. This informs
    the CPU that you don’t intend to access the specified memory location again in
    the near future, so the CPU won’t copy the data into its cache (a convenient example
    of what you can do in assembly and not in an HLL). This can improve performance
    by helping to prevent a situation known as *thrashing*, in which the CPU constantly
    moves data in and out of the cache memory.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: ldnp 和 stnp 指令执行非暂时性加载和存储操作。这通知 CPU 你不打算在不久的将来再次访问指定的内存位置，因此 CPU 不会将数据复制到缓存中（这是汇编语言中能做的，而高级语言中无法做到的一个便利示例）。这可以通过帮助防止称为
    *thrashing* 的情况，从而提高性能，在这种情况下，CPU 不断地将数据从缓存中移入移出。
- en: 6.9.1.3 fmov
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.1.3 fmov
- en: 'The fmov instruction transfers data between two like-sized floating-point registers
    (where both registers are either 32 or 64 bits), or between a 32- or 64-bit general-purpose
    (GP) register and a like-sized floating-point register. Here is the allowable
    syntax for this instruction:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: fmov 指令在两个大小相同的浮点寄存器之间（这两个寄存器都是 32 位或 64 位）或在一个 32 位或 64 位通用寄存器（GP 寄存器）和一个大小相同的浮点寄存器之间传输数据。以下是该指令的允许语法：
- en: '[PRE104]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Moving a general-purpose register into a floating-point register does not convert
    an integer value in the GP register to a floating-point value; such an fmov operation
    assumes that the GP register contains the bit pattern for a floating-point number.
    Likewise, moving a floating-point register into a general-purpose register does
    not convert the floating-point value into an integer.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 将通用寄存器的值移动到浮点寄存器并不会将 GP 寄存器中的整数值转换为浮点值；这种 fmov 操作假定 GP 寄存器包含的是浮点数的位模式。同样，将浮点寄存器的值移动到通用寄存器也不会将浮点值转换为整数。
- en: '##### 6.9.1.4 fmov with Immediate Operand'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 6.9.1.4 带立即数操作数的 fmov'
- en: The ARM provides an fmov instruction that allows a very limited immediate operand.
    The syntax is as follows
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了一个 fmov 指令，允许使用非常有限的立即数操作数。其语法如下：
- en: '[PRE105]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: where fimm is a floating-point constant from a very small set of possible values.
    The allowable values are ±*n* / 16 × 2*^m*, where 16 ≤ *n* ≤ 31 and –3 ≤ *m* ≤
    4\. This means you can represent values such as 1.0 or –2.0 but cannot represent
    1.2345e5.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 fimm 是一个来自非常小集合的浮点常量。允许的值是 ±*n* / 16 × 2*^m*，其中 16 ≤ *n* ≤ 31 且 -3 ≤ *m*
    ≤ 4。这意味着你可以表示诸如 1.0 或 -2.0 这样的值，但不能表示 1.2345e5。
- en: 'You cannot represent the value 0.0 with this immediate form. However, you can
    load 0.0 into a floating-point register by using one of the following two instructions:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能通过这种立即数形式表示值 0.0。然而，你可以通过以下两条指令之一将 0.0 加载到浮点寄存器中：
- en: '[PRE106]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'If you want to load an arbitrary floating-point constant into a register, you
    will have to stick that constant into a memory location, using the .single or
    .double directive, and load the register from that location. Unfortunately, the
    ldr instruction doesn’t accept floating-point immediate operands:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将一个任意浮点常数加载到寄存器中，你需要将该常数放入一个内存位置，使用 .single 或 .double 指令，然后从该位置加载寄存器。遗憾的是，ldr
    指令不接受浮点立即数操作数：
- en: '[PRE107]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Fortunately, the PC-relative addressing mode does work, so you can access memory
    locations you’ve initialized in your .text section (preferably in the .pool area),
    as the following example demonstrates:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，PC 相对寻址模式是有效的，因此你可以访问在 .text 区段中初始化的内存位置（最好在 .pool 区域中），如下例所示：
- en: '[PRE108]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: By adding the .pool directive, Gas can embed other assembler-generated constants
    in this area too.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 .pool 指令，Gas 还可以将其他汇编生成的常数嵌入到这个区域中。
- en: 6.9.2 FPU Arithmetic Instructions
  id: totrans-553
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.9.2 FPU 算术指令
- en: 'The ARM CPU provides a large set of floating-point instructions that operate
    on single-precision and double-precision floating-point values. As for the integer
    operations, most of these instructions require three (floating-point) register
    operands: a destination, a left source, and a right source.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU 提供了一大套浮点指令，能够对单精度和双精度浮点值进行操作。与整数操作一样，这些指令大多数都需要三个（浮点）寄存器操作数：一个目标寄存器，一个左侧源寄存器和一个右侧源寄存器。
- en: '[Table 6-11](chapter6.xhtml#tab6-11) lists the syntax for the arithmetic instructions.
    In this table, Fd, Fn, Fm, and Fa represent floating-point registers and can be
    S*n* or D*n* (*n* = 0 to 31), depending on the precision of the instruction. For
    a given instruction, all registers must be the same size (32 or 64 bits).'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-11](chapter6.xhtml#tab6-11)列出了算术指令的语法。在此表中，Fd、Fn、Fm 和 Fa 代表浮点寄存器，依据指令的精度，可能是
    S*n* 或 D*n*（*n* = 0 到 31）。对于给定的指令，所有寄存器必须具有相同的大小（32 位或 64 位）。'
- en: 'Table 6-11: Floating-Point Arithmetic Instructions'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-11：浮点算术指令
- en: '| Instruction | Operands | Description |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 操作数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| fadd | Fd, Fn, Fm | Fd = Fn + Fm |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| fadd | Fd, Fn, Fm | Fd = Fn + Fm |'
- en: '| fsub | Fd, Fn, Fm | Fd = Fn – Fm |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| fsub | Fd, Fn, Fm | Fd = Fn – Fm |'
- en: '| fmul | Fd, Fn, Fm | Fd = Fn × Fm |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| fmul | Fd, Fn, Fm | Fd = Fn × Fm |'
- en: '| fnmul | Fd, Fn, Fm | Fd = –(Fn × Fm) |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| fnmul | Fd, Fn, Fm | Fd = –(Fn × Fm) |'
- en: '| fmadd | Fd, Fn, Fm, Fa | Fd = Fa + Fn × Fm |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| fmadd | Fd, Fn, Fm, Fa | Fd = Fa + Fn × Fm |'
- en: '| fmsub | Fd, Fn, Fm, Fa | Fd = Fa – Fn × Fm |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| fmsub | Fd, Fn, Fm, Fa | Fd = Fa – Fn × Fm |'
- en: '| fnmadd | Fd, Fn, Fm, Fa | Fd = –(Fa + Fn × Fm) |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| fnmadd | Fd, Fn, Fm, Fa | Fd = –(Fa + Fn × Fm) |'
- en: '| fnmsub | Fd, Fn, Fm, Fa | Fd = –(Fa – Fn × Fm) |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| fnmsub | Fd, Fn, Fm, Fa | Fd = –(Fa – Fn × Fm) |'
- en: '| fdiv | Fd, Fn, Fm | Fd = Fn / Fm |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| fdiv | Fd, Fn, Fm | Fd = Fn / Fm |'
- en: '| fmax | Fd, Fn, Fm | Fd = max(Fn, Fm), NaN if either operand is NaN |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| fmax | Fd, Fn, Fm | Fd = max(Fn, Fm)，若任一操作数为 NaN，则结果为 NaN |'
- en: '| fmaxnm | Fd, Fn, Fm | Fd = max(Fn, Fm), number if other operand is (quiet)
    NaN |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| fmaxnm | Fd, Fn, Fm | Fd = max(Fn, Fm)，若另一个操作数为（安静的）NaN，则结果为数字 |'
- en: '| fmin | Fd, Fn, Fm | Fd = min(Fn, Fm), NaN if either operand is NaN |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| fmin | Fd, Fn, Fm | Fd = min(Fn, Fm)，若任一操作数为 NaN，则结果为 NaN |'
- en: '| fminnm | Fd, Fn, Fm | Fd = min(Fn, Fm), number if other operand is (quiet)
    NaN |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| fminnm | Fd, Fn, Fm | Fd = min(Fn, Fm)，若另一个操作数为（安静的）NaN，则结果为数字 |'
- en: '| fabs | Fd, Fn | Fd = fabs(Fn), absolute value |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| fabs | Fd, Fn | Fd = fabs(Fn)，绝对值 |'
- en: '| fneg | Fd, Fn | Fd = –Fn |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| fneg | Fd, Fn | Fd = –Fn |'
- en: '| fsqrt | Fd, Fn | Fd = sqrt(Fn) |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| fsqrt | Fd, Fn | Fd = sqrt(Fn) |'
- en: Many operations can raise an exception of one sort or another. For example,
    fdiv can set the DZC flag in the FPSR if a division by 0 occurs. Some operations,
    such as fsqrt, can produce an invalid result—for example, when trying to take
    the square root of a negative number. After a sequence of floating-point instructions,
    check the FPSR to see if the result obtained is valid. The FPSR bits are sticky
    and will remain set once an exception occurs; this allows you to check for an
    error at the end of a chain of calculations, rather than after each floating-point
    instruction.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 许多操作可能会引发某种异常。例如，fdiv 操作会在发生除以 0 的情况下设置 FPSR 中的 DZC 标志。一些操作，如 fsqrt，可能会产生无效结果——例如，当尝试对负数取平方根时。在一系列浮点指令执行后，检查
    FPSR 以查看所获得的结果是否有效。FPSR 位是粘性的，一旦发生异常，它们会保持设置状态；这使得你可以在计算链条的末尾检查错误，而不必在每条浮点指令后都进行检查。
- en: 6.9.3 Floating-Point Comparisons
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.9.3 浮点比较
- en: The ARM provides a floating-point compare and a conditional compare instruction.
    Both have a couple of forms
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了一个浮点比较和条件比较指令。两者都有几种形式。
- en: '[PRE109]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: where nzcv and cond have the same meanings they did with the ccmp instruction.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 nzcv 和 cond 的含义与 ccmp 指令中的相同。
- en: The instructions with the e suffix raise an exception if either operand is NaN
    during the comparison. Dealing with exceptions raised by these instructions is
    beyond the scope of this book, so subsequent example code uses just the forms
    without the e suffix.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 e 后缀的指令在比较过程中如果任一操作数是 NaN，会触发异常。处理这些指令引发的异常超出了本书的范围，因此后续示例代码仅使用不带 e 后缀的形式。
- en: The fcmp instruction will compare an FPU register against either another FPU
    register or the immediate constant 0.0. If you need to compare against any other
    floating-point constant, you’ll have to first load that into a register. Note
    that fccmp doesn’t provide a form that allows a comparison against 0.0 (although
    you can copy XZR or WZR into another FPU register and compare against that).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: fcmp 指令将一个 FPU 寄存器与另一个 FPU 寄存器或立即数 0.0 进行比较。如果你需要与其他浮点常数进行比较，你必须先将其加载到一个寄存器中。请注意，fccmp
    不提供允许与 0.0 比较的形式（尽管你可以将 XZR 或 WZR 复制到另一个 FPU 寄存器，并与其进行比较）。
- en: 6.9.3.1 Comparison Logic
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.3.1 比较逻辑
- en: The fcmp instruction sets the (PSR, not FPSR) condition code bits N, Z, C, and
    V in response to the comparison, allowing you to use the conditional branches
    and other conditional instructions to test the result of the comparison. However,
    the behavior of the settings is a bit different from integer comparisons. First
    of all, there aren’t unsigned and signed comparisons (floating-point values are
    always signed); second, floating-point comparisons can be unordered.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: fcmp 指令根据比较设置 (PSR，而非 FPSR) 条件码位 N、Z、C 和 V，允许你使用条件分支和其他条件指令来测试比较结果。然而，这些设置的行为与整数比较有所不同。首先，浮点值始终是有符号的，因此没有无符号和有符号的比较；其次，浮点比较可能是无序的。
- en: '*Unordered comparisons* occur when one or both of two values you’re comparing
    are NaN, since two values are incomparable under those circumstances. At best,
    you can say they are not equal to each other; it’s safer simply to say the result
    is unordered and leave it at that. Generally, if the result of a comparison is
    unordered, something is seriously wrong and you’ll want to take corrective action.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '*无序比较*发生在你比较的两个值中有一个或两个是 NaN，因为在这种情况下，这两个值是不可比较的。最多，你可以说它们不相等；更安全的做法是直接说结果是无序的，就这么处理。通常，如果比较的结果是无序的，说明出现了严重问题，你需要采取纠正措施。'
- en: One way to avoid this issue is to use the fcmpe form, which can generate an
    exception, and leave it up to the exception handler to deal with unordered values.
    However, as noted earlier, dealing with those exceptions is beyond the scope of
    this book, so I recommend sticking with fcmp.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 避免此问题的一种方法是使用 fcmpe 形式，它可以生成异常，并让异常处理程序处理无序值。然而，如前所述，处理这些异常超出了本书的范围，因此我建议坚持使用
    fcmp。
- en: The fcmp instruction sets the N, Z, V, and C flags in such a way that you can
    test them for ordered and unordered results after a comparison. The good news
    is that you can handle unordered and ordered comparisons by using normal conditional
    branch and other instructions. The bad news is that the fcmp results slightly
    change the definition of those conditional branch instructions. [Table 6-12](chapter6.xhtml#tab6-12)
    describes how fcmp sets the flags.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: fcmp 指令设置 N、Z、V 和 C 标志，以便在比较后可以测试这些标志来判断有序或无序结果。好消息是，你可以通过使用正常的条件分支和其他指令来处理有序和无序的比较。坏消息是，fcmp
    结果稍微改变了这些条件分支指令的定义。[表 6-12](chapter6.xhtml#tab6-12) 描述了 fcmp 如何设置这些标志。
- en: 'Table 6-12: Flags Set by fcmp'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '表 6-12: fcmp 设置的标志'
- en: '| Condition | Meaning |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | 含义 |'
- en: '| --- | --- |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| EQ | Equal |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| EQ | 相等 |'
- en: '| NE | Not equal, or unordered |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| NE | 不相等，或无序 |'
- en: '| GE | Greater than or equal |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| GE | 大于或等于 |'
- en: '| LT | Less than, or unordered |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| LT | 小于，或无序 |'
- en: '| GT | Greater than |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| GT | 大于 |'
- en: '| LE | Less than or equal, or unordered |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| LE | 小于或等于，或无序 |'
- en: '| HI | Greater than, or unordered |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| HI | 大于，或无序 |'
- en: '| HS/CS | Greater than or equal, or unordered |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| HS/CS | 大于或等于，或无序 |'
- en: '| LO/CC | Less than |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| LO/CC | 小于 |'
- en: '| LS | Less than or equal |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| LS | 小于或等于 |'
- en: '| MI | Less than |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| MI | 小于 |'
- en: '| PL | Greater than or equal, or unordered |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| PL | 大于或等于，或无序 |'
- en: '| VS | Unordered |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| VS | 无序 |'
- en: '| VC | Ordered |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| VC | 有序 |'
- en: 'Two points in [Table 6-12](chapter6.xhtml#tab6-12) are easy to miss:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6-12](chapter6.xhtml#tab6-12)中有两点很容易被忽略：'
- en: The fcmp instruction sets the V flag if the comparison is unordered.
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果比较结果是无序的，`fcmp`指令会设置V标志。
- en: Both signed and unsigned tests are used for floating-point comparisons, which
    are intrinsically signed values.
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点比较使用有符号和无符号测试，而浮点值本身是有符号值。
- en: You’ll notice that GE and GT are ordered comparisons, while LE and LT handle
    unordered comparisons. Likewise, LS and LO are ordered comparisons, while HI and
    HS also handle unordered comparisons. At first glance, this might seem weird;
    why not make one set (signed or unsigned) ordered and the other set unordered?
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，GE和GT是有序比较，而LE和LT处理无序比较。同样，LS和LO是有序比较，而HI和HS也处理无序比较。乍一看，这可能有些奇怪；为什么不把一个集合（有符号或无符号）设置为有序，另一个集合设置为无序呢？
- en: However, you want the two opposite tests (for example, LE and GT, or LT and
    GE) to handle all possible outcomes. One of the outcomes is unordered. Therefore,
    one of the opposite comparisons needs to handle unordered so that the two tests
    in each pair provide total coverage of the conditionals (the same logic applies
    to HI-LS and HS-LO). You can always test the overflow flag (V) to see whether
    a comparison is ordered or unordered.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你需要两个相反的测试（例如，LE和GT，或者LT和GE）来处理所有可能的结果。某个结果是无序的。因此，其中一个相反的比较需要处理无序情况，这样每对测试就能全面覆盖条件（同样的逻辑适用于HI-LS和HS-LO）。你始终可以测试溢出标志（V）来查看比较是有序还是无序。
- en: 6.9.3.2 Conditional Comparisons
  id: totrans-609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.3.2 条件比较
- en: The conditional floating-point comparison instruction, fccmp, is the floating-point
    analog to the integer conditional comparison instruction. You can use it to reduce
    complex Boolean expressions involving conjunction (AND) and disjunction (OR),
    as noted earlier (see section 6.5, “Conditional Comparisons and Boolean Expressions,”
    on [page 314](chapter6.xhtml#pg_314)).
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 条件浮点比较指令`fccmp`是整数条件比较指令的浮点类对应物。你可以使用它来简化涉及合取（AND）和析取（OR）的复杂布尔表达式，如前面所述（参见第6.5节，“条件比较和布尔表达式”，[第314页](chapter6.xhtml#pg_314)）。
- en: 6.9.3.3 Comparison for Equality
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.3.3 相等比较
- en: As discussed in section 6.7, “Floating-Point and Finite-Precision Arithmetic,”
    on [page 322](chapter6.xhtml#pg_322), you should be very careful about comparing
    two floating-point values (especially for equality). Minor inaccuracies in two
    calculations that would produce the same result using infinite-precision real
    arithmetic may yield different results when using limited-precision floating-point
    arithmetic. If you want to compare two values for equality, compute their difference
    and determine whether the absolute value of their difference is within an acceptable
    error range.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 如第6.7节“浮点数与有限精度算术”（[第322页](chapter6.xhtml#pg_322)）所讨论的，你在比较两个浮点值时（特别是相等比较）要非常小心。两个计算中的微小误差，在使用无限精度实数算术时可能产生相同的结果，但在使用有限精度浮点算术时可能会得出不同的结果。如果你想比较两个值是否相等，应该计算它们的差值，并确定其绝对值是否在可接受的误差范围内。
- en: The real question is how to determine an acceptable range for the error. Because
    the difference between these (presumably equal) floating-point values will manifest
    itself in the LO bits of the mantissa, the error value should be something corresponding
    to a 1 bit in one of those positions.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 关键问题是如何确定误差的可接受范围。因为这些（假定相等的）浮点值之间的差异会表现在尾数的低位（LO位），所以误差值应该对应于这些位置中的某个1位。
- en: Listing 6-2 demonstrates how to calculate this error value.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6-2展示了如何计算这个误差值。
- en: '[PRE110]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The mask 0x7FF0_0000_0000_0000 ❶, when ANDed with a double-precision floating-point
    value, will strip out the mantissa and sign bits, leaving the exponent in bit
    positions 52 to 62 (11-bit exponent).
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 当将掩码0x7FF0_0000_0000_0000 ❶与双精度浮点值做与运算时，它会剥离出尾数和符号位，保留在第52到62位（11位指数）的位置上的指数。
- en: The bits constant ❷ in this listing determines the number of LO bits in the
    mantissa that the code will eliminate when generating the error value (this is
    currently 4 bits, so the 4 LO bits of the mantissa become insignificant, but in
    most cases it should be 2 to 3 bits for single-precision and 3 to 4 bits for double-precision
    comparisons). Once the computeError function generates the error value, the main
    program uses that error to compare a couple of floating-point numbers and report
    whether they should be treated as equal (their difference is less than the error
    value) or not equal (their difference is greater). The bitMask value is just a
    string of 1 bits (4 in Listing 6-2).
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 本清单中的位常量❷确定在生成误差值时代码将消除尾数中低位（LO位）的数量（当前为4位，因此尾数的4个低位变得不重要，但在大多数情况下，对于单精度比较应为2到3位，对于双精度比较应为3到4位）。一旦computeError函数生成误差值，主程序就会使用该误差值来比较两个浮点数，并报告它们是否应该视为相等（它们的差异小于误差值）或不相等（它们的差异较大）。bitMask值只是由1位组成的字符串（在清单6-2中为4位）。
- en: The procedure computeError ❸ is passed a floating-point value in D0\. This function
    computes an error value for that floating-point number such that if it is compared
    with a second number, their difference will be less than the error value if they
    should be considered equal. This function returns the error value in the D0 register.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 程序computeError❸接收一个浮点值到D0寄存器。此函数为该浮点数计算误差值，以便在与第二个数字比较时，如果它们应该被视为相等，其差异将小于误差值。此函数将误差值返回到D0寄存器。
- en: To compute the error value, computeError begins by shifting the exponent down
    to bits 0 to 10 so that it is easier to work with ❹. If the exponent is less than
    52 – 5 bits, the error value will turn out to be a subnormal (denormalized) number.
    The code determines whether the error value will be normalized or subnormal ❺.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算误差值，computeError首先将指数移到位0到10，以便更容易操作❹。如果指数小于52 – 5位，则误差值将变为一个次规范（非规范化）数字。代码确定误差值将是规范化还是次规范❺。
- en: If the result will be a normalized number, the code generates the error value
    by 52 bits (47 if bits is 4) and then shifts the exponent back into its proper
    location ❻. The mantissa and sign bits will all be 0; however, the implied bit
    for double-precision numbers will be 1, because the exponent is not 0.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果将是一个规范化的数字，代码会通过52位生成误差值（如果位数是4，则为47位），然后将指数移回到其正确的位置❻。尾数和符号位将全部为0；然而，双精度数字的隐含位将为1，因为指数不为0。
- en: If the error value will turn out to be subnormal, the code sets the exponent
    to 0, denoting a denormalized value, and shifts the bitMask value to the left
    the number of bit positions specified by the exponent minus the bits value ❼.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 如果误差值变为次规范，代码将指数设为0，表示一个非规范化值，并将bitMask值向左移动指定的位数，位数由指数减去位数值❼确定。
- en: 'Here’s the build command and sample output for Listing 6-2:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清单6-2的构建命令和示例输出：
- en: '[PRE111]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This demonstrates that the difference between Value1 and Value2 is definitely
    outside the error range allowed for this comparison.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，Value1和Value2之间的差异肯定超出了此比较所允许的误差范围。
- en: 6.9.3.4 Conditional Select Instruction
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.3.4 条件选择指令
- en: 'Although the ARM does not support all the conditional instructions present
    in the integer instruction set, it does support the most often used conditional
    instruction: conditional select, or fcsel. The fcsel instruction has the following
    syntax:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ARM不支持整数指令集中所有的条件指令，但它支持最常用的条件指令：条件选择指令，或称fcsel。fcsel指令的语法如下：
- en: '[PRE112]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This instruction will test the condition and copy Ft to Fd if the condition
    is true, or it will copy Ff to Fd if the condition is false.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将测试条件，如果条件为真，则将Ft复制到Fd；如果条件为假，则将Ff复制到Fd。
- en: 6.9.4 Floating-Point Conversion Instructions
  id: totrans-629
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.9.4 浮点数转换指令
- en: The ARM instruction set includes a wide variety of instructions that convert
    between various floating-point formats and between signed/unsigned integers and
    floating-point formats. Certain CPUs even support conversions between floating-point
    and fixed-point formats. This section describes these conversions.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: ARM指令集包含各种各样的指令，用于在不同的浮点格式之间以及在带符号/无符号整数和浮点格式之间进行转换。某些CPU甚至支持浮点与定点格式之间的转换。本节将描述这些转换。
- en: 6.9.4.1 fcvt
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.4.1 fcvt
- en: 'The fcvt instruction converts between the three supported floating-point formats
    (half-, single-, and double-precision). This is one of the few instructions that
    supports the H*n* registers (ldr and str are the others). The syntax for this
    instruction is the following:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: fcvt 指令在三种支持的浮点格式（半精度、单精度和双精度）之间进行转换。这是为数不多的支持 H*n* 寄存器的指令之一（ldr 和 str 是其他支持的指令）。该指令的语法如下：
- en: '[PRE113]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'These instructions convert their source operand to the type of the destination
    operand and copy the converted data into that operand. Of course, not all conversions
    can happen without error—be aware that converting a larger-size format to a smaller-size
    format can produce underflow and underflow exceptions. You might want to consider
    checking the FPSR after such an operation:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将其源操作数转换为目标操作数的类型，并将转换后的数据复制到目标操作数中。当然，并非所有转换都能毫无错误地发生——请注意，将较大尺寸格式转换为较小尺寸格式可能会导致下溢和下溢异常。在进行此类操作后，您可能需要考虑检查
    FPSR：
- en: '[PRE114]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This code demonstrates checking the UFC, OFC, and IDC bits to see if an error
    occurred after the conversion.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了如何检查 UFC、OFC 和 IDC 位，以查看转换后是否发生了错误。
- en: 6.9.4.2 Conversion Between Floating-Point and Integer
  id: totrans-637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.4.2 浮点数与整数之间的转换
- en: The instructions in [Table 6-13](chapter6.xhtml#tab6-13) convert between various
    floating-point (single- and double-precision) and integer formats. The syntax
    for these instructions is as follows
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-13](chapter6.xhtml#tab6-13) 中的指令在各种浮点数（单精度和双精度）与整数格式之间进行转换。这些指令的语法如下：'
- en: '[PRE115]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: where m is a, m, n, p, or z that specifies a rounding mode (see [Table 6-13](chapter6.xhtml#tab6-13),
    where FP = floating-point, SI = signed integer, and UI = unsigned integer). Fn
    represents any single- or double-precision floating-point register, and Rd represents
    any general-purpose register (W*d* or X*d*).
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 m 是 a、m、n、p 或 z，表示舍入模式（参见[表 6-13](chapter6.xhtml#tab6-13)，其中 FP = 浮点数，SI
    = 有符号整数，UI = 无符号整数）。Fn 表示任何单精度或双精度浮点寄存器，Rd 表示任何通用寄存器（W*d* 或 X*d*）。
- en: 'Table 6-13: The fcvt{m}{s|u} Conversion Instructions'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '表 6-13: fcvt{m}{s|u} 转换指令'
- en: '| Instruction | Description |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| fcvtas | Convert FP to SI; round away from 0. |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| fcvtas | 将浮点数转换为有符号整数；舍入远离 0。 |'
- en: '| fcvtau | Convert FP to UI; round away from 0. |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| fcvtau | 将浮点数转换为无符号整数；舍入远离 0。 |'
- en: '| fcvtms | Convert FP to SI; round toward –infinity (floor function). |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| fcvtms | 将浮点数转换为有符号整数；舍入到负无穷（向下取整）。 |'
- en: '| fcvtmu | Convert FP to UI; round toward –infinity (floor function). |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| fcvtmu | 将浮点数转换为无符号整数；舍入到负无穷（向下取整）。 |'
- en: '| fcvtns | Convert FP to SI; round to even (standard IEEE rounding). |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| fcvtns | 将浮点数转换为有符号整数；舍入到偶数（标准 IEEE 舍入）。 |'
- en: '| fcvtnu | Convert FP to UI; round to even (standard IEEE rounding). |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| fcvtnu | 将浮点数转换为无符号整数；舍入到偶数（标准 IEEE 舍入）。 |'
- en: '| fcvtps | Convert FP to SI; round toward +infinity (ceil function). |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| fcvtps | 将浮点数转换为有符号整数；舍入到正无穷（向上取整）。 |'
- en: '| fcvtpu | Convert FP to UI; round toward +infinity (ceil function). |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| fcvtpu | 将浮点数转换为无符号整数；舍入到正无穷（向上取整）。 |'
- en: '| fcvtzs | Convert FP to SI; round toward 0 (truncation). |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| fcvtzs | 将浮点数转换为有符号整数；舍入到 0（截断）。 |'
- en: '| fcvtzu | Convert FP to SI; round toward 0 (truncation). |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| fcvtzu | 将浮点数转换为有符号整数；舍入到 0（截断）。 |'
- en: 'In addition to converting floating-point values to integers, the ARM provides
    two instructions that convert integers to floating-point values:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将浮点值转换为整数外，ARM 还提供了两条指令，将整数转换为浮点值：
- en: '[PRE116]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The scvtf instruction converts a signed integer to a floating-point value, and
    the ucvtf instruction converts an unsigned integer to floating-point. Note that
    some integer values cannot be exactly represented by a single- or double-precision
    value. For example, a double-precision floating-point value has a 56-bit mantissa,
    so it cannot precisely represent all 64-bit integers.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: scvtf 指令将有符号整数转换为浮点值，ucvtf 指令将无符号整数转换为浮点数。请注意，某些整数值不能被单精度或双精度值精确表示。例如，双精度浮点数有
    56 位尾数，因此无法精确表示所有 64 位整数。
- en: 6.9.4.3 Fixed-Point Conversions
  id: totrans-657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.4.3 定点转换
- en: 'Some 64-bit ARM CPUs support conversion between a fixed-point binary value
    and a floating-point value. These instructions take the following forms:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 64 位 ARM CPU 支持将定点二进制值与浮点值之间进行转换。这些指令的形式如下：
- en: '[PRE117]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Here, bits is the number of bits to the right of the binary point in the general-purpose
    register. It is a constant from 0 to one less than the size of the general-purpose
    register. For example, in a 64-bit register, a value of 32 would provide you with
    32 bits to the left and right of the binary point in the fixed-point number.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，bits 是通用寄存器中二进制点右侧的位数。它是一个常量，范围从 0 到比通用寄存器大小少 1。例如，在一个 64 位寄存器中，32 的值表示二进制点左右各有
    32 位的固定点数。
- en: 6.9.4.4 Rounding
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.9.4.4 舍入
- en: The ARM provides several floating-point rounding instructions. They are similar
    in nature to the floating-point-to-integer conversion insofar as they round a
    real number to an integral value. However, these instructions produce not binary
    integer values but rather floating-point results that just happen to be integer
    numbers (or, rather, the floating-point representation of those integer numbers).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了几条浮点舍入指令。它们与浮点到整数的转换类似，都是将实数舍入为整数值。然而，这些指令产生的不是二进制整数值，而是浮点结果，这些结果恰好是整数（或者说是这些整数的浮点表示）。
- en: 'These instructions all take a pair of floating-point registers as operands.
    Both registers must be the same size (single- or double-precision). The generic
    syntax is as follows:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令都将一对浮点寄存器作为操作数。两个寄存器必须具有相同的大小（单精度或双精度）。通用语法如下：
- en: '[PRE118]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The instruction descriptions appear in [Table 6-14](chapter6.xhtml#tab6-14).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 指令描述出现在 [表 6-14](chapter6.xhtml#tab6-14) 中。
- en: 'Table 6-14: The frint{m} Instructions'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-14：frint{m} 指令
- en: '| Instruction | Description |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| frinta | Round away from 0. |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '| frinta | 向 0 远离舍入。 |'
- en: '| frinti | Round using the Rmode setting in the FPCR. |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| frinti | 使用 FPCR 中的 Rmode 设置进行舍入。 |'
- en: '| frintm | Round toward –infinity. |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| frintm | 向负无穷方向舍入。 |'
- en: '| frintn | Normal rounding, exactly 0.5 rounds to nearest even value. |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| frintn | 正常舍入，精确的 0.5 舍入到最近的偶数值。 |'
- en: '| frintp | Round toward +infinity. |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| frintp | 向正无穷方向舍入。 |'
- en: '| frintx | Round using FPCR mode; raise an exception if value was not originally
    an integer. |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| frintx | 使用 FPCR 模式进行舍入；如果值最初不是整数，则引发异常。 |'
- en: '| frintz | Round toward 0. |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| frintz | 向 0 舍入。 |'
- en: Now that you’ve reviewed the floating-point conversion instructions, I’ll show
    you how to use floating-point instructions in code that interfaces with other
    programs.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经回顾了浮点转换指令，我将向您展示如何在与其他程序接口的代码中使用浮点指令。
- en: '### 6.10 The ARM ABI and Floating-Point Registers'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '### 6.10 ARM ABI 与浮点寄存器'
- en: The ARM ABI considers V0 through V7 and V16 through V31 to be volatile. The
    caller must preserve these registers across procedure calls if it requires that
    they retain their values across a call.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: ARM ABI 将 V0 到 V7 和 V16 到 V31 视为易失性寄存器。调用者必须在过程调用之间保存这些寄存器的值，如果需要它们在调用之间保持不变。
- en: Registers V8 through V15 are nonvolatile. A callee must preserve these registers
    within a procedure if it modifies their values. Of course, the advantage of these
    registers is that once a procedure preserves them (for its caller), it does not
    have to worry about modification to these registers by any functions it calls.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器 V8 到 V15 是非易失性的。如果被调用函数修改了这些寄存器的值，它必须在过程内部保存它们。当然，这些寄存器的优势在于，一旦过程保存了它们（为了调用者），它就不必担心任何它调用的函数修改这些寄存器。
- en: Callers pass the first eight floating-point parameters in registers to a procedure.
    When passing a combination of integer and floating-point parameters, the caller
    passes the non-floating-point parameters in the general- purpose registers (X0
    to X7) and the floating-point arguments in the floating-point registers. If the
    number of floating-point parameters exceeds eight, the caller passes the floating-point
    parameters on the stack.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者将前八个浮点参数通过寄存器传递给一个过程。当传递整数和浮点参数的组合时，调用者将非浮点参数通过通用寄存器（X0 到 X7）传递，浮点参数通过浮点寄存器传递。如果浮点参数的数量超过八个，调用者会将浮点参数放入栈中。
- en: 'Parameters are assigned the next available register, not a register number
    based on the parameter’s position in the parameter list. Consider the following
    C function prototype:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 参数被分配到下一个可用的寄存器，而不是根据参数在参数列表中的位置分配寄存器号。考虑以下 C 函数原型：
- en: '[PRE119]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The ARM ABI would associate the registers in [Table 6-15](chapter6.xhtml#tab6-15)
    with these formal parameters:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: ARM ABI 会将 [表 6-15](chapter6.xhtml#tab6-15) 中的寄存器与这些正式参数关联：
- en: 'Table 6-15: Parameter Assignments to Registers'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-15：寄存器的参数分配
- en: '| Register | Parameter |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| 寄存器 | 参数 |'
- en: '| --- | --- |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| X0 | i |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| X0 | i |'
- en: '| D0 | d |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| D0 | d |'
- en: '| X1 | j |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| X1 | j |'
- en: '| X2 | k |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| X2 | k |'
- en: '| D1 | e |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| D1 | e |'
- en: '| X3 | l |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| X3 | l |'
- en: '| D2 | f |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| D2 | f |'
- en: '| D3 | g |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| D3 | g |'
- en: '| D4 | h |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| D4 | h |'
- en: If a function passes a floating-point parameter by reference, the address of
    that floating-point value is passed in the next available general-purpose register
    (no floating-point registers for pass-by-reference parameters).
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数通过引用传递浮点参数，则该浮点值的地址将通过下一个可用的通用寄存器传递（对于通过引用传递的参数，没有浮点寄存器）。
- en: 'If a function returns a floating-point result, it returns that value in D0
    (or S0, if the language supports returning single-precision floats as function
    return results). See [Chapter 11](chapter11.xhtml) for details on returning vectors
    (multiple floating-point values) as function results (hint: V0). If a function
    returns an array of floating-point values, the caller must allocate storage for
    that array and pass a pointer to that array in X8\. The function will store the
    results into that storage before returning.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数返回浮点结果，它会将该值返回到D0（或者S0，如果语言支持将单精度浮点数作为函数返回结果）。有关将向量（多个浮点值）作为函数结果返回的详细信息，请参见[第11章](chapter11.xhtml)（提示：V0）。如果一个函数返回一个浮动点值数组，则调用者必须为该数组分配存储空间，并通过X8传递该数组的指针。函数将在返回之前将结果存储到该存储空间中。
- en: 6.11 Using C Standard Library Math Functions
  id: totrans-698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.11 使用C标准库数学函数
- en: 'Although the ARM instruction set provides a set of machine instructions that
    compute basic arithmetic operations, it does not have instructions for computing
    complex mathematical functions such as sine, cosine, and tangent. You could (with
    the appropriate knowledge) write these functions yourself in assembly language,
    but a much simpler solution is available: call functions that are already written
    for you. In particular, the C stdlib contains many useful mathematical functions
    you can use. This section describes how to call several of them.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ARM指令集提供了一组计算基本算术运算的机器指令，但它没有用于计算复杂数学函数（如正弦、余弦和正切）的指令。你可以（如果具备相应的知识）用汇编语言编写这些函数，但有一个更简单的解决方案：调用已经为你编写的函数。特别是，C标准库包含了许多有用的数学函数，你可以使用它们。本节将介绍如何调用其中的几个。
- en: As a sample program that demonstrates passing floating-point values to functions,
    Listing 6-3 makes calls to various C stdlib <math.h> functions (specifically sin(),
    cos(), and tan()). Each of these functions accepts a double-precision parameter
    and returns a double-precision result.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个演示将浮点值传递给函数的示例程序，列表6-3调用了各种C标准库<math.h>函数（特别是sin()、cos()和tan()）。这些函数中的每一个都接受一个双精度参数并返回一个双精度结果。
- en: '[PRE120]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This program calls the sin(), cos(), and tan() functions indirectly—the address
    of the particular function is passed as a parameter to the doPi procedure. Unfortunately,
    macOS’s PIE functionality prevents you from taking the address of such a function
    by using the lea macro, because there is no telling where the OS will load the
    dynamically linked (shared) library at runtime; it could be farther away than
    the ±4GB allowed by lea. Therefore, this code creates trampolines for these functions
    that the OS can patch to transfer control to wherever the functions are sitting
    in memory ❶. These trampolines are necessary only for macOS; though they will
    work with Linux code, Linux allows you to take the address of the C stdlib functions
    with lea.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序间接调用了sin()、cos()和tan()函数——特定函数的地址作为参数传递给doPi过程。不幸的是，macOS的PIE功能阻止你通过使用lea宏来获取这样的函数的地址，因为无法预测操作系统在运行时会将动态链接（共享）库加载到何处；它可能会远远超出lea所允许的±4GB范围。因此，这段代码为这些函数创建了跳板，操作系统可以修补这些跳板以将控制转移到函数在内存中的位置❶。这些跳板仅对macOS必要；虽然它们在Linux代码中也能工作，但Linux允许你使用lea获取C标准库函数的地址。
- en: The doPi function ❷ saves the values of X0, X1, and X19 in the activation record.
    Preserving X19 is necessary because this is a nonvolatile register. Saving X0
    and X1 is necessary because the procedure needs their values across calls to printf(),
    and these registers are volatile.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: doPi函数❷将X0、X1和X19的值保存在激活记录中。保存X19是必要的，因为它是一个不可丢失的寄存器。保存X0和X1是必要的，因为该过程需要它们的值以进行printf()调用，而这些寄存器是易失性的。
- en: The body of the doPi calls the appropriate function (sin(), cos(), or tan())
    four times with the values π, π/2, π/4, and π/8, and it then displays the result
    these functions return ❸. Note how doPi calls the function indirectly by using
    the blr instruction—the address of the function was originally passed to doPi
    in the X0 register.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: doPi 函数体会调用适当的函数（sin()、cos() 或 tan()）四次，分别使用 π、π/2、π/4 和 π/8 作为输入值，然后显示这些函数返回的结果
    ❸。注意 doPi 如何通过使用 blr 指令间接调用函数——函数的地址最初是通过 X0 寄存器传递给 doPi 的。
- en: The main procedure loads the address of the trampoline (veneer) function into
    X0, along with a string pointer, and calls doPi to compute the values and print
    the results ❹. (Trampolines and veneers are explained further in [Chapter 7](chapter7.xhtml).)
    Loading the address of the trampoline functions into X0 is necessary only under
    macOS; with Linux, you can load the address of the sin(), cos(), or tan() function
    directly and spare the minor inefficiency of having to jump through the trampoline
    function.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 主要程序将跳板函数（veneer）地址加载到 X0 寄存器中，同时加载一个字符串指针，并调用 doPi 计算值并打印结果 ❹。（跳板函数和 veneer
    在[第 7 章](chapter7.xhtml)中有进一步解释。）仅在 macOS 上需要将跳板函数的地址加载到 X0 寄存器；在 Linux 上，你可以直接加载
    sin()、cos() 或 tan() 函数的地址，从而避免跳板函数带来的轻微低效。
- en: 'Here’s the build command and sample output for Listing 6-3:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列表 6-3 的构建命令和示例输出：
- en: '[PRE121]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'You’ll notice one difference between this build command and most of the others
    in the book: the -math argument. This tells Linux to link in the C stdlib math
    library functions (macOS automatically links this in). Without the -math option,
    you’ll get a linker error when you try to build the program.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个构建命令和书中大多数其他命令之间的一个区别：-math 参数。这个参数告诉 Linux 链接 C 标准库中的数学库函数（macOS 会自动链接此库）。如果没有
    -math 选项，当你尝试构建程序时会遇到链接错误。
- en: The C stdlib contains many double-precision functions you might find useful.
    Check them out online for more details. Many of these functions are unnecessary
    in assembly language, as they correspond to one or two machine instructions. Nevertheless,
    the library contains complex functions that you wouldn’t want to write yourself.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准库包含许多你可能觉得有用的双精度函数。你可以在网上查看它们的详细信息。许多这些函数在汇编语言中是不必要的，因为它们对应着一到两条机器指令。然而，库中包含了一些复杂的函数，这些函数你可能不想自己编写。
- en: You may find various functions online that purport to be faster than those in
    the C stdlib. Be careful about using them because they tend to be notoriously
    inaccurate. Unless you’re well grounded in numerical analysis, don’t try to write
    these functions yourself.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在网上找到一些声称比 C 标准库中的函数更快的各种函数。使用这些函数时要小心，因为它们通常不准确。如果你没有扎实的数值分析基础，最好不要尝试自己编写这些函数。
- en: 6.12 Moving On
  id: totrans-711
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.12 继续前进
- en: 'This chapter covered a lot of material: the remaining arithmetic instructions
    (including multiplication, division, and remainder, as well as cmp and the various
    conditional instructions), maintaining variables in registers rather than memory
    locations, and the proper use of volatile and nonvolatile registers. It also discussed
    creating structures to provide efficient access to global variables, converting
    arithmetic and logical expressions (integer and floating-point) to their machine
    instruction equivalents, and calling functions written in C/C++.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量内容：剩余的算术指令（包括乘法、除法和取余，以及 cmp 和各种条件指令）、将变量保存在寄存器而非内存位置、以及正确使用易失性和非易失性寄存器。还讨论了如何创建结构以提供对全局变量的高效访问、将算术和逻辑表达式（整数和浮点）转换为机器指令等效项，并调用用
    C/C++ 编写的函数。
- en: Armed with this information, you can now convert arithmetic expressions in an
    HLL such as C/C++ to ARM assembly language. The only basic skill missing from
    your programming repertoire is a good understanding of control structures in assembly
    language, which you’ll learn in the next chapter.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些信息后，你现在可以将像 C/C++ 这样的高级语言中的算术表达式转换为 ARM 汇编语言。你编程技能中唯一缺失的基本技能是对汇编语言中的控制结构的良好理解，下一章你将学习这些内容。
- en: 6.13 For More Information
  id: totrans-714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.13 获取更多信息
- en: My book *Write Great Code*, Volume 1 (No Starch Press, 2020), includes sections
    on the cache and thrashing.
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的书《写出优秀代码》，第一卷（No Starch Press，2020）包括有关缓存和抖动的章节。
- en: 'Reference Wikipedia for details on fixed-point arithmetic: *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Fixed<wbr>-point<wbr>_arithmetic](https://en.wikipedia.org/wiki/Fixed-point_arithmetic)*.'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考 Wikipedia 了解有关定点算术的详细信息：[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Fixed<wbr>-point<wbr>_arithmetic](https://en.wikipedia.org/wiki/Fixed-point_arithmetic)。
- en: 'You can learn more about limited-precision arithmetic from the following resources:'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过以下资源了解更多关于有限精度算术的内容：
- en: 'A Central Connecticut State University tutorial in the form of an interactive
    questionnaire: *[https://<wbr>chortle<wbr>.ccsu<wbr>.edu<wbr>/assemblytutorial<wbr>/Chapter<wbr>-29<wbr>/ass29<wbr>_10<wbr>.html](https://chortle.ccsu.edu/assemblytutorial/Chapter-29/ass29_10.html)*.'
  id: totrans-718
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份来自中康涅狄格州中央大学的互动问卷形式的教程：*[https://chortle.ccsu.edu/assemblytutorial/Chapter-29/ass29_10.html](https://chortle.ccsu.edu/assemblytutorial/Chapter-29/ass29_10.html)*。
- en: 'Python documentation on the topic: *[https://<wbr>docs<wbr>.python<wbr>.org<wbr>/3<wbr>/tutorial<wbr>/floatingpoint<wbr>.html](https://docs.python.org/3/tutorial/floatingpoint.html)*.'
  id: totrans-719
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于这一主题的Python文档：*[https://docs.python.org/3/tutorial/floatingpoint.html](https://docs.python.org/3/tutorial/floatingpoint.html)*。
- en: 'For more information on writing better code using floating-point arithmetic,
    see the following post on the Society of Actuaries website: *[https://<wbr>www<wbr>.soa<wbr>.org<wbr>/news<wbr>-and<wbr>-publications<wbr>/newsletters<wbr>/compact<wbr>/2014<wbr>/may<wbr>/com<wbr>-2014<wbr>-iss51<wbr>/losing<wbr>-my<wbr>-precision<wbr>-tips<wbr>-for<wbr>-handling<wbr>-tricky<wbr>-floating<wbr>-point<wbr>-arithmetic](https://www.soa.org/news-and-publications/newsletters/compact/2014/may/com-2014-iss51/losing-my-precision-tips-for-handling-tricky-floating-point-arithmetic)*.'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用浮点算术编写更好代码的更多信息，请参阅精算学会网站上的以下帖子：*[https://www.soa.org/news-and-publications/newsletters/compact/2014/may/com-2014-iss51/losing-my-precision-tips-for-handling-tricky-floating-point-arithmetic](https://www.soa.org/news-and-publications/newsletters/compact/2014/may/com-2014-iss51/losing-my-precision-tips-for-handling-tricky-floating-point-arithmetic)*。
- en: Wikipedia documents the C stdlib math functions at *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/C<wbr>_mathematical<wbr>_functions](https://en.wikipedia.org/wiki/C_mathematical_functions)*.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科对C标准库数学函数进行了记录：*[https://en.wikipedia.org/wiki/C_mathematical_functions](https://en.wikipedia.org/wiki/C_mathematical_functions)*。
- en: 'If you insist on writing your own transcendental functions, you might try to
    locate a copy of the following book (long out of print), the “bible” of transcendental
    functions: *Computer Approximations,* by John F. Hart, E.W. Cheney, and Charles
    L. Lawson (Krieger Publishing, 1978).'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你坚持自己编写超越函数，可以尝试找到以下书籍的副本（已长期绝版），被誉为超越函数的“圣经”：《计算机近似法》，由John F. Hart、E.W.
    Cheney和Charles L. Lawson编著（Krieger出版社，1978年）。
