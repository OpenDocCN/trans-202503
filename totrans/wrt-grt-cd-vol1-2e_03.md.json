["```\nif(  (Value1 >= (Value2 – error))  and  (Value1 <= (Value2 + error)) then . . .\n```", "```\nif( abs(Value1 – Value2) <= error ) then . . .\n```", "```\nif( A < (B + error) ) then Eager_A_lessthan_B;\n\nif( A > (B – error) ) then Eager_A_greaterthan_B;\n```", "```\n1.mmmmmmm mmmmmmmm mmmmmmmm\n```", "```\n0.100000 × 21\n```", "```\n1.000000 × 20\n```", "```\n1.000_0100_1010_0100_1001_0101_0001 -> 1.000_0100_1010_0100_1001_0101\n\n1.000_0100_1010_0100_1001_0101_1100 -> 1.000_0100_1010_0100_1001_0110\n\n1.000_0100_1010_0100_1001_0101_1000 -> 1.000_0100_1010_0100_1001_0110\n\n1.000_0100_1010_0100_1001_0100_0001 -> 1.000_0100_1010_0100_1001_0100\n\n1.000_0100_1010_0100_1001_0100_1100 -> 1.000_0100_1010_0100_1001_0101\n\n1.000_0100_1010_0100_1001_0100_1000 -> 1.000_0100_1010_0100_1001_0100\n```", "```\ntypedef uint32_t  real;\n```", "```\n#define asreal(x) (*((float *) &x))\n```", "```\nvoid fpadd( real left, real right, real *dest );\n\nvoid fpsub( real left, real right, real *dest );\n```", "```\nvoid fpsub( real left, real right, real *dest )\n\n{\n\n    right = right ^ 0x80000000;   // Invert the sign bit of the right operand.\n\n    fpadd( left, right, dest );   // Let fpadd do the real work.\n\n}\n```", "```\ninline int extractSign( real from )\n\n{\n\n    return( from >> 31);\n\n}\n```", "```\n(from & 0x80000000) != 0\n```", "```\ninline int extractExponent( real from )\n\n{\n\n    return ((from >> 23) & 0xff) - 127;\n\n}\n```", "```\ninline int extractMantissa( real from )\n\n{\n\n    if( (from & 0x7fffffff) == 0 ) return 0;\n\n    return ((from & 0x7FFFFF) | 0x800000 );\n\n}\n```", "```\n12.345e2 123.45e1 1234.5 12345e-1\n```", "```\n0.87654e2 0.087654e3 0.0087654e4\n```", "```\nvoid shiftAndRound( uint32_t *valToShift, int bitsToShift )\n\n{\n\n    // Masks is used to mask out bits to check for a \"sticky\" bit.\n\n    static unsigned masks[24] =\n\n    {\n\n        0, 1, 3, 7, 0xf, 0x1f, 0x3f, 0x7f, \n\n        0xff, 0x1ff, 0x3ff, 0x7ff, 0xfff, 0x1fff, 0x3fff, 0x7fff,\n\n        0xffff, 0x1ffff, 0x3ffff, 0x7ffff, 0xfffff, 0x1fffff, 0x3fffff,\n\n        0x7fffff\n\n    };\n\n    // HOmasks: Masks out the HO bit of the value masked by the masks entry.\n\n    static unsigned HOmasks[24] =\n\n    {\n\n        0, \n\n        1, 2, 4, 0x8, 0x10, 0x20, 0x40, 0x80, \n\n        0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000, \n\n        0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000\n\n    };\n\n    // shiftedOut: Holds the value that will be shifted out of a mantissa\n\n    // during the denormalization operation (used to round a denormalized\n\n    // value).\n\n    int shiftedOut;\n\n    assert( bitsToShift <= 23 );\n\n    // Okay, first grab the bits we're going to shift out (so we can determine\n\n    // how to round this value after the shift).\n\n    shiftedOut = *valToShift & masks[ bitsToShift ];\n\n    // Shift the value to the right the specified number of bits.\n\n    // Note: bit 31 is always 0, so it doesn't matter if the C\n\n    // compiler does a logical shift right or an arithmetic shift right.\n\n    *valToShift = *valToShift >> bitsToShift;\n\n    // If necessary, round the value:\n\n    if(  shiftedOut > HOmasks[ bitsToShift ] )\n\n    {\n\n        // If the bits we shifted out are greater than 1/2 the LO bit, then\n\n        // round the value up by 1.\n\n        *valToShift = *valToShift + 1;\n\n    }\n\n    else if( shiftedOut == HOmasks[ bitsToShift ] )\n\n    {\n\n        // If the bits we shifted out are exactly 1/2 of the LO bit's value,\n\n        // then round the value to the nearest number whose LO bit is 0.\n\n        *valToShift = *valToShift + (*valToShift & 1);\n\n    }\n\n    // else\n\n    // We round the value down to the previous value. The current\n\n    // value is already truncated (rounded down), so we don't have to do\n\n    // anything.\n\n}\n```", "```\ninline real packFP( int sign, int exponent, int mantissa )\n\n{\n\n   return \n\n        (real)\n\n        ( \n\n                (sign << 31) \n\n            |   ((exponent + 127) << 23)  \n\n            |   (mantissa & 0x7fffff)\n\n        );\n\n}\n```", "```\nvoid fpadd( real left, real right, real *dest )\n\n{   \n\n    // The following variables hold the fields associated with the \n\n    // left operand:\n\n    int             Lexponent;\n\n    uint32_t        Lmantissa;\n\n    int             Lsign;\n\n    // The following variables hold the fields associated with the \n\n    // right operand:\n\n    int             Rexponent;\n\n    uint32_t        Rmantissa;\n\n    int             Rsign;\n\n    // The following variables hold the separate fields of the result:\n\n    int             Dexponent;\n\n    uint32_t        Dmantissa;\n\n    int             Dsign;\n\n    // Extract the fields so that they're easy to work with:\n\n    Lexponent = extractExponent( left );\n\n    Lmantissa = extractMantissa( left );\n\n    Lsign     = extractSign( left );\n\n    Rexponent = extractExponent( right );\n\n    Rmantissa = extractMantissa( right );\n\n    Rsign     = extractSign( right );\n\n    // Code to handle special operands (infinity and NaNs):\n\n    if( Lexponent == 127 )\n\n    {\n\n        if( Lmantissa == 0 )\n\n        {\n\n            // If the left operand is infinity, then the result\n\n            // depends upon the value of the right operand.\n\n            if( Rexponent == 127 )\n\n            {\n\n                // If the exponent is all 1 bits (127 after unbiasing)\n\n                // then the mantissa determines if we have an infinity value\n\n                // (zero mantissa), a QNaN (mantissa = 0x800000), or a SNaN\n\n                // (nonzero mantissa not equal to 0x800000). \n\n                if( Rmantissa == 0 )  // Do we have infinity?\n\n                {\n\n                    // infinity + infinity = infinity\n\n                    // -infinity - infinity = -infinity \n\n                    // -infinity + infinity = NaN\n\n                    // infinity - infinity = NaN\n\n                    if( Lsign == Rsign )\n\n                    {\n\n                        *dest = right;\n\n                    }\n\n                    else\n\n                    {\n\n                        *dest = 0x7fC00000;  // +QNaN\n\n                    }\n\n                }\n\n                else  // Rmantissa is nonzero, so it's a NaN\n\n                {\n\n                    *dest = right;  // Right is a NaN, propagate it.\n\n                }\n\n            }\n\n        }\n\n        else // Lmantissa is nonzero, Lexponent is all 1s.\n\n        {\n\n            // If the left operand is some NaN, then the result will\n\n            // also be the same NaN.\n\n            *dest = left;\n\n        }\n\n        // We've already calculated the result, so just return.\n\n        return;\n\n    }\n\n    else if( Rexponent == 127 )\n\n    {\n\n        // Two case: right is either a NaN (in which case we need to\n\n        // propagate the NaN regardless of left's value) or it is\n\n        // +/– infinity. Because left is a \"normal\" number, we'll also\n\n        // wind up propagating the infinity because any normal number\n\n        // plus infinity is infinity.\n\n        *dest = right;  // Right is a NaN, so propagate it.\n\n        return;\n\n    }\n\n    // Okay, we've got two actual floating-point values. Let's add them \n\n    // together. First, we have to \"denormalize\" one of the operands if\n\n    // their exponents aren't the same (when adding or subtracting values,\n\n    // the exponents must be the same).\n\n    //\n\n    // Algorithm: choose the value with the smaller exponent. Shift its \n\n    // mantissa to the right the number of bits specified by the difference \n\n    // between the two exponents.\n\n    Dexponent = Rexponent;\n\n    if( Rexponent > Lexponent )\n\n    {\n\n        shiftAndRound( &Lmantissa, (Rexponent - Lexponent));\n\n    }\n\n    else if( Rexponent < Lexponent )\n\n    {\n\n        shiftAndRound( &Rmantissa, (Lexponent - Rexponent));\n\n        Dexponent = Lexponent;\n\n    }\n\n    // Okay, add the mantissas. There is one catch: if the signs are opposite\n\n    // then we've actually got to subtract one value from the other (because\n\n    // the FP format is one's complement, we'll subtract the larger mantissa\n\n    // from the smaller and set the destination sign according to a\n\n    // combination of the original sign values and the largest mantissa).\n\n    if( Rsign ^ Lsign )\n\n    {\n\n        // Signs are different, so we must subtract one value from the other.\n\n        if( Lmantissa > Rmantissa )\n\n        {\n\n            // The left value is greater, so the result inherits the\n\n            // sign of the left operand.\n\n            Dmantissa = Lmantissa - Rmantissa;\n\n            Dsign = Lsign;\n\n        }\n\n        else\n\n        {\n\n            // The right value is greater, so the result inherits the\n\n            // sign of the right operand.\n\n            Dmantissa = Rmantissa - Lmantissa;\n\n            Dsign = Rsign;\n\n        }\n\n    }\n\n    else\n\n    {\n\n        // Signs are the same, so add the values:\n\n        Dsign = Lsign;\n\n        Dmantissa = Lmantissa + Rmantissa;\n\n    }\n\n    // Normalize the result here.\n\n    //\n\n    // Note that during addition/subtraction, overflow of 1 bit is possible.\n\n    // Deal with that possibility here (if overflow occurred, shift the \n\n    // mantissa to the right one position and adjust for this by incrementing \n\n    // the exponent). Note that this code returns infinity if overflow occurs \n\n    // when incrementing the exponent (infinity is a value with an exponent \n\n    // of $FF);\n\n   if( Dmantissa >= 0x1000000 )\n\n    {\n\n        // Never more than 1 extra bit when doing addition/subtraction.\n\n        // Note that by virtue of the floating-point format we're using,\n\n        // the maximum value we can produce via addition or subtraction is\n\n        // a mantissa value of 0x1fffffe. Therefore, when we round this\n\n        // value it will not produce an overflow into the 25th bit.\n\n        shiftAndRound( &Dmantissa, 1 ); // Move result into 24 bits.\n\n        ++Dexponent;                    // Shift operation did a div by 2,\n\n                                        // this counteracts the effect of\n\n                                        // the shift (incrementing exponent\n\n                                        // multiplies the value by 2).\n\n    }\n\n    else\n\n    {\n\n        // If the HO bit is clear, normalize the result\n\n        // by shifting bits up and simultaneously decrementing\n\n        // the exponent. We will treat 0 as a special case\n\n        // because it's a common enough result.\n\n        if( Dmantissa != 0 )\n\n        {\n\n            // The while loop multiplies the mantissa by 2 (via a shift \n\n            // left) and then divides the whole number by 2 (by \n\n            // decrementing the exponent. This continues until the HO bit of \n\n            // Dmantissa is set or the exponent becomes -127 (0 in the \n\n            // biased-127 form). If Dexponent drops down to -128, then we've \n\n            // got a denormalized number and we can stop.\n\n            while( (Dmantissa < 0x800000) && (Dexponent > -127 ))\n\n            {\n\n                Dmantissa = Dmantissa << 1;\n\n                --Dexponent;\n\n            }\n\n        }\n\n        else\n\n        {\n\n            // If the mantissa went to 0, clear everything else, too.\n\n            Dsign = 0;\n\n            Dexponent = 0;\n\n        }\n\n    }\n\n    // Reconstruct the result and store it away:\n\n    *dest = packFP( Dsign, Dexponent, Dmantissa );\n\n}\n```", "```\n// A simple main program that does some trivial tests on fpadd and fpsub.\n\nint main( int argc, char **argv )\n\n{\n\n    real l, r, d;\n\n    asreal(l) = 1.0;\n\n    asreal(r) = 2.0;\n\n    fpadd( l, r, &d );\n\n    printf( \"dest = %x\\n\", d );\n\n    printf( \"dest = %12E\\n\", asreal( d ));\n\n    l = d;\n\n    asreal(r) = 4.0;\n\n    fpsub( l, r, &d );\n\n    printf( \"dest2 = %x\\n\", d );\n\n    printf( \"dest2 = %12E\\n\", asreal( d ));\n\n}\n```", "```\nl = 3f800000\n\nl = 1.000000E+00\n\nr = 40000000\n\nr = 2.000000E+00\n\ndest = 40400000\n\ndest = 3.000000E+00\n\ndest2 = bf800000\n\ndest2 = -1.000000E+00\n```", "```\nprocedure fpmul( left:real32; right:real32 );  @returns( \"eax\" );\n\nprocedure fpdiv( left:real32; right:real32 );  @returns( \"eax\" );\n```", "```\nmov( (type dword left), ebx );  // Result sign is the XOR of the\n\nxor( (type dword right), ebx ); // operand signs.\n\nand( $8000_0000, ebx );         // Keep only the sign bit.\n```", "```\nmov( (type dword left), ecx );  // Exponent goes into bits 23..30\n\nand( $7f80_0000, ecx );         // of ECX; mask these bits.\n\nsub( 126 << 23, ecx );          // Eliminate the bias of 127 and multiply by 2\n\nmov( (type dword right), eax );\n\nand( $7f80_0000, eax );\n\n// For multiplication, we need to add the exponents:\n\nadd( eax, ecx );                // Exponent value is now in bits\n\n                                // 23..30 of ECX.\n```", "```\nmov( (type dword left), eax );\n\nmov( (type dword right), edx );\n\n// If we don't have a 0 value, then set the implied HO bit of the mantissa:\n\nif( eax <> 0 ) then\n\n    or( $80_0000, eax );  // Set the implied bit to 1.\n\nendif;\n\nshl( 8, eax );  // Moves mantissa to bits 8..31 and removes sign/exp.\n\n// Repeat this for the right operand.\n\nif( edx <> 0 ) then\n\n    or( $80_0000, edx );\n\nendif;\n\nshl( 8, edx );\n```", "```\nmul( edx );\n```", "```\ntest( $80, edx );  // Clears zero flag if bit 7 of EDX = 1.\n\nif( @nz ) then\n\n    add( $FFFF_FFFF, eax );  // Sets carry if EAX <> 0.\n\n    adc( $7f, dl );          // Sets carry if DL:EAX > $80_0000_0000.\n\n    if( @c ) then\n\n        // If DL:EAX > $80_0000_0000 then round the mantissa\n\n        // up by adding 1 to bit position 8:\n\n        add( 1 << 8, edx );\n\n    else // DL:EAX = $80_0000_0000\n\n        // We need to round to the value that has a 0\n\n        // in bit position 0 of the mantissa (bit #8 of EDX):\n\n        test( 8, edx );  // Clears zero flag if bit #8 contains a 1.\n\n        if( @nz ) then\n\n            add( 1 << 8, edx );  // Adds a 1 starting at bit position 8.\n\n            // If there was an overflow, renormalize:\n\n            if( @c ) then\n\n                rcr( 1, edx );  // Shift overflow (in carry) back into EDX.\n\n                inc( ecx );     // Shift did a divide by 2\\. Fix that.\n\n        endif;\n\n        endif;\n\n    endif;\n\nendif;\n```", "```\nshr( 8, edx );          // Move mantissa into bits 0..23.\n\nand( $7f_ffff, edx );   // Clear the implied bit.\n\nlea( eax, [edx+ecx] );  // Merge mantissa and exponent into EAX.\n\nor( ebx, eax );         // Merge in the sign.\n```", "```\nmov( (type dword left), ecx );  // Exponent comes from bits 23..30.\n\nshr( 23, ecx );\n\nand( $ff, ecx );                // Mask out the sign bit (in bit 8).\n\nmov( (type dword right), eax );\n\nshr( 23, eax );\n\nand( $ff, eax );\n\n// Eliminate the bias from the exponents:\n\nsub( 127, ecx );\n\nsub( 127, eax );\n\n// For division, we need to subtract the exponents:\n\nsub( eax, ecx );                // Leaves result exponent in ECX.\n```", "```\nmov (type dword left), edx );\n\nif( edx <> 0 ) then\n\n    or( $80_0000, edx );   // Set the implied bit to 1 in the left operand.\n\n    shl( 8, edx );\n\nendif;\n\nmov( (type dword right), edi );\n\nif( edi <> 0 ) then\n\n    or( $80_0000, edi );        // Set the implied bit to 1 in the right operand.\n\n    shl( 8, edi );\n\nelse\n\n    // Division by zero error, here.\n\nendif;\n```", "```\nxor( eax, eax );    // EAX := 0;\n\nshr( 1, edx );      // Shift EDX:EAX to the right 1 bit to\n\nrcr( 1, eax );      // prevent a division error.\n\ndiv( edi );         // Compute EAX = EDX:EAX / EDI.\n```", "```\ntest( $80, al );    // See if the bit just below the LO bit of the\n\nif( @nz ) then      // mantissa contains a 0 or 1.\n\n    // Okay, the bit just below the LO bit of our mantissa contains a 1.\n\n    // If all other bits below the mantissa and this bit contain 0s,\n\n    // we have to round to the nearest mantissa value whose LO bit is 0.\n\n    test( $7f, al );             // Clears zero flag if bits 0..6 <> 0.\n\n    if( @nz || edx <> 0 ) then   // If bits 0..6 in AL are 0 and EDX\n\n                                 // is 0.\n\n        // We need to round up:\n\n        add( $100, eax );  // Mantissa starts in bit #8 );\n\n        if( @c ) then      // Carry set if mantissa overflows.\n\n            // If there was an overflow, renormalize.\n\n            rcr( 1, eax );\n\n            inc( ecx );\n\n        endif;\n\n    else\n\n        // The bits below the mantissa are exactly 1/2 the value\n\n        // of the LO mantissa bit. So we need to round to the value\n\n        // that has a LO mantissa bit of 0:\n\n        test( $100, eax );\n\n        if( @nz ) then\n\n            add( $100, eax );\n\n            if( @c ) then\n\n                // If there was an overflow, renormalize.\n\n                rcr( 1, eax );  // Put overflow bit back into EAX.\n\n                inc( ecx );     // Adjust exponent accordingly.\n\n            endif;\n\n        endif;\n\n    endif;\n\nendif;\n```", "```\nif( (type int32 ecx) > 127 ) then\n\n    mov($ff-127, ecx );    // Set exponent value for infinity\n\n    xor( eax, eax );       // because we just had overflow.\n\nelseif( (type int32 ecx) < -128 ) then\n\n    mov( -127, ecx );      // Return 0 for underflow (note that\n\n    xor( eax, eax );       // next we add 127 to ECX).\n\nendif;                                      \n\nadd( 127, ecx );           // Add the bias back in.\n\nshl( 23, ecx );            // Move the exponent to bits 23..30.\n\n// Okay, assemble the final real32 value:\n\nshr( 8, eax );             // Move mantissa into bits 0..23.\n\nand( $7f_ffff, eax );      // Clear the implied bit.\n\nor( ecx, eax );            // Merge mantissa and exponent into EAX.\n\nor( ebx, eax );            // Merge in the sign.\n```"]