<html><head></head><body>
<div class="imagec"><span epub:type="pagebreak" id="page_105"/><img alt="Image" src="../images/common1.jpg"/></div>
<h2 class="h2" id="ch05"><strong>5</strong><br/><strong>AMAZING ACCELERATION</strong></h2>
<p class="noindent">The accelerometer is arguably the most useful of the BBC micro:bit’s built-in sensors. It lets you measure the direction and strength of a force, such as gravity, that is acting on the micro:bit.</p>
<p class="indent"><span epub:type="pagebreak" id="page_106"/>You can use the accelerometer for many things, including:</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Detecting gestures like shaking, or even finding out that your micro:bit is falling</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Learning which way and how much the micro:bit is tilted and using this to control your micro:bit</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Measuring how quickly your micro:bit is accelerating when it moves. (For example, you might use it in a pedometer to see how many steps you take in a day.)</p>
<div class="imagec"><img alt="Image" src="../images/f0106-01.jpg"/></div>
<h3 class="h3" id="ch00lev1sec123"><strong>EXPERIMENT 5: GESTURES</strong></h3>
<div class="image"><img alt="Image" src="../images/common2.jpg"/></div>
<p class="noindent">The micro:bit’s software includes gesture recognition, so it can respond to certain motions, like tilting or shaking, that are picked up by the accelerometer. In this section, you’ll program the micro:bit to display a smile whenever you shake it.</p>
<p class="indent">Later in this chapter, you’ll learn how to deal with the raw data that comes straight from the accelerometer chip so you can measure acceleration.</p>
<h4 class="h4" id="ch00lev1sec124"><strong>What You’ll Need</strong></h4>
<p class="noindent">In this experiment, you’ll just need your micro:bit.</p>
<h4 class="h4" id="ch00lev1sec125"><span epub:type="pagebreak" id="page_107"/><strong>Construction</strong></h4>
<ol>
<li class="noindent">Go to <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em> to access the book’s code repository and click the link for <strong>Experiment 5: Gestures</strong>. Once the program has opened, click <strong>Download</strong> and then copy the hex file onto your micro:bit. If you prefer to use Python, then download the code from the same website. For instructions for downloading and using the book’s examples, see “Downloading the Code” on <a href="ch01.xhtml#page_34">page 34</a>. The Python file for this experiment is <em>Experiment_05.py</em>.</li>
<li class="noindent">Once the program starts, shake your micro:bit, and you should see a smile appear, then disappear, on the display.</li>
</ol>
<h4 class="h4" id="ch00lev1sec126"><strong>Code</strong></h4>
<p class="noindent">Using gestures in your program is similar in both Blocks and MicroPython. Both languages have the same set of gesture types. The main difference is that in MicroPython there is no event mechanism for handling events; instead, you have to keep checking for gestures in a loop.</p>
<h5 class="h5" id="ch00lev1sec127"><strong>Blocks Code</strong></h5>
<p class="noindent">Here is the Blocks code for this experiment.</p>
<div class="image"><img alt="Image" src="../images/f0107-01.jpg"/></div>
<p class="indent">The acceleration gestures available in the Blocks code work as events, just as pressing a button does. Start with an <code>on</code> block. Click the triangle in to access a drop-down menu of possible gestures, shown in <a href="ch05.xhtml#ch5fig1">Figure 5-1</a>, and select <code><span class="codestrong1">shake</code></span>.</p>
<div class="image" id="ch5fig1"><span epub:type="pagebreak" id="page_108"/><img alt="Image" src="../images/05fig01.jpg"/></div>
<p class="figcap"><em>Figure 5-1: Selecting different gestures</em></p>
<div class="sidebar">
<p class="sidebart"><strong>THE DIFFERENT GESTURES</strong></p>
<p class="noindent">The shake gesture responds to any significant shaking of your micro:bit. The next two gestures, logo up and logo down, respond to tilting the micro:bit front to back. The logo this code refers to is the icon printed on the micro:bit board, near the USB socket.</p>
<p class="indent">The screen up and screen down gestures respond to the micro:bit’s orientation. For example, if you placed it screen side down, you’d trigger the screen down event.</p>
<p class="indent">The tilt left and tilt right events respond when you tilt the micro:bit from side to side by more than about 60 degrees. You have to tilt it quite a lot to trigger these events.</p>
<p class="indent">The final four events relate to the overall force acting on the accelerometer rather than the force in any particular direction. For example, if the micro:bit is in free fall, then the fall will trigger the free fall event. The gestures 3g, 6g, and 8g detect different amounts of force acting on the accelerometer, measured in <em>g</em> (the acceleration due to gravity, or the <em>g-force</em>). For example, you could detect a finger tap on the micro:bit. Tapping the micro:bit doesn’t move it much, so you might think that not much force is involved, but in fact tapping can exert quite a high g-force.</p>
</div>
<h5 class="h5" id="ch00lev1sec128"><span epub:type="pagebreak" id="page_109"/><strong>MicroPython Code</strong></h5>
<p class="noindent">Here’s the MicroPython code for this experiment:</p>
<div class="programs1"><span class="green">from</span> microbit <span class="green">import</span> <span class="purple">*</span><br/><br/><span class="green">while True</span><span class="purple">:</span><br/>    <span class="green">if</span> accelerometer<span class="purple">.</span>was_gesture<span class="purple">(</span><span class="red1">'shake'</span><span class="purple">):</span><br/>        display<span class="purple">.</span>show<span class="purple">(</span>Image<span class="purple">.</span>HAPPY<span class="purple">)</span><br/>        sleep<span class="purple">(</span><span class="blue1">500</span><span class="purple">)</span><br/>        display<span class="purple">.</span>clear<span class="purple">()</span></div>
<p class="indent">You’ll recognize most of the code here. We import the usual library and then start a <code>while True</code> loop so the main code runs continually. This loop checks whether the micro:bit has detected shaking and, if it has, shows the happy face!</p>
<p class="indent">Because MicroPython doesn’t have the concept of “events,” you have to use the <code>was_gesture</code> function inside a <code>while</code> loop to check for the shake gesture. You can also replace the <code>shake</code> block with <code>up</code>, <code>down</code>, <code>left</code>, <code>right</code>, <code>face up</code>, <code>face down</code>, <code>freefall</code>, <code>3g</code>, <code>6g</code>, or <code>8g</code>.</p>
<h4 class="h4" id="ch00lev1sec129"><strong>Things to Try</strong></h4>
<p class="noindent">Try adding more gestures to the program for Experiment 5. You can even make each gesture trigger a different icon on the screen.</p>
<p class="indent">In <a href="ch10.xhtml#ch10">Chapter 10</a>, you’ll use gesture detection again to steer a micro:bit-controlled robot rover!</p>
<h4 class="h4" id="ch00lev1sec130"><strong>How It Works: Force, Acceleration, and Gravity</strong></h4>
<p class="noindent">We’ve been talking about force, acceleration, and gravity as if the accelerometer measures all of these things, but it really just measures the distance a certain mass moves. Then it computes the other measurements. Let’s take a look at what the accelerometer chip actually does to get a better idea of what these three terms mean.</p>
<div class="image" id="ch5fig2"><span epub:type="pagebreak" id="page_110"/><img alt="Image" src="../images/05fig02.jpg"/></div>
<p class="figcap"><em>Figure 5-2: The micro:bit’s accelerometer</em></p>
<p class="indent"><a href="ch05.xhtml#ch5fig2">Figure 5-2</a> shows a rough sketch of what’s inside the tiny accelerometer chip attached to your micro:bit.</p>
<p class="indent">Imagine a tiny mass <em>m</em> attached to a spring. (The mass is drawn as a ball in <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>, but its shape isn’t important.) Normally, the mass is in position A, but if it’s being pulled against the spring by some force (for example, gravity), then it will move to some other position, which we’ll call position B. The stronger the force, the bigger the difference between A and B. By measuring this distance, the accelerometer calculates the force acting on the mass.</p>
<p class="indent">Looking at <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>, you can see that the force of gravity alone will pull the mass down. But the more the spring is stretched, the more the spring pulls the mass in the opposite direction to gravity. So gravity applies downward force to the mass, stretching the spring, which then applies upward force. When the two forces are equal but acting in opposite directions, the difference between the distances B and A is a measure of the gravitational force acting on the micro:bit. The larger the distance between A and B, the greater the force acting on the mass.</p>
<p class="indent">Remember that the g-force relates to the acceleration that occurs due to gravity. Acceleration is an increase in speed. In other words, if you drop your micro:bit off a tall building, the acceleration <em>g</em> is the number of meters per second the micro:bit’s speed increases by every second. If you dropped your micro:bit off a tall building in a vacuum, there wouldn’t be any air to slow down the micro:bit, and in this case, the speed of the micro:bit would increase by about 9.8 meters per second for every second it fell. So, if it were to start at a speed of 0 (as you’re holding it in your hand) and then fall for 10 seconds, it would reach a speed of 98 meters per second (about 220 miles per hour).</p>
<p class="indent">Also, when the micro:bit meets the ground after traveling at 220 miles per hour, it will probably be smashed to bits.</p>
<p class="indent">However, if you dropped your micro:bit in a vacuum, then its accelerometer would read 0 even though it was clearly <span epub:type="pagebreak" id="page_111"/>accelerating at 9.8 meters a second. This is because the accelerometer is not really measuring acceleration. As you saw in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>, it’s measuring the force acting on the mass inside of the micro:bit. That force would be zero if the mass and the spring were accelerating at the same rate, which they would be since they’re both in the micro:bit.</p>
<p class="indent">If you were in space, well away from the gravitational pull of celestial bodies, then the acceleration would be equal to the force acting on the object divided by the mass of the object. Because the mass is always the same, the accelerometer can tell us the acceleration of the micro:bit as long as some force, any force, is acting on it.</p>
<p class="indent">The accelerometer chip is actually more advanced than <a href="ch05.xhtml#ch5fig2">Figure 5-2</a> suggests because it has three force-measuring devices in it, set to measure force in three directions, all at right angles to each other. In other words, the chip measures the force acting on it in three dimensions, X, Y, and Z, as shown in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>.</p>
<div class="image" id="ch5fig3"><img alt="Image" src="../images/05fig03.jpg"/></div>
<p class="figcap"><em>Figure 5-3: The micro:bit’s accelerometer measures force in three dimensions.</em></p>
<p class="indent">If your micro:bit were sitting flat on a table, the X dimension would run left to right, the Y dimension would run front to back, and the Z dimension would run above and below the tabletop. So, if the micro:bit is completely horizontal on a flat <span epub:type="pagebreak" id="page_112"/>tabletop, the force of gravity will only be acting on the Z (up-down) dimension, while the X and Y dimensions will measure 0 acceleration. Now, if you tilt the micro:bit forward a little, then some of the force due to gravity will act on the Y dimension, so the Y value will no longer be 0. This also means that slightly less gravitational force is acting on the Z dimension, so the value of Z will decrease slightly.</p>
<p class="indent">From the description so far, you might think that the accelerometer is only useful for measuring the force of gravity. In fact, looking at <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>, it is easy to imagine how shaking the micro:bit or causing any kind of acceleration on it would change the position of the mass.</p>
<h3 class="h3" id="ch00lev1sec131"><strong>EXPERIMENT 6: REAL-TIME ACCELERATION PLOTTING</strong></h3>
<div class="image"><img alt="Image" src="../images/common2.jpg"/></div>
<p class="noindent">Mu has a great feature that will plot data coming from your micro:bit in real time. In this experiment, you’ll use the Plotter feature to see how the acceleration data changes when you move your micro:bit.</p>
<div class="note">
<p class="notep"><span class="yellow"><strong>NOTE</strong></span> <em>At the time of writing, the Plotter feature is available only on the Windows and Mac versions of the Mu Editor. The experiment also shows you how to get an overall measurement of acceleration, as well as separate readings for each of the X, Y, and Z dimensions.</em></p>
</div>
<h4 class="h4" id="ch00lev1sec132"><strong>What You’ll Need</strong></h4>
<p class="noindent">For this experiment, you just need a micro:bit connected to your computer by a USB cable.</p>
<h4 class="h4" id="ch00lev1sec133"><strong>Construction</strong></h4>
<ol>
<li class="noindent">This project uses Mu’s Plotter feature, which you’ll need Python for, so there’s no Blocks code for this. Find the code at <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em>. The Python file for this experiment is <em>Experiment_06.py</em>. Flash the program onto your micro:bit.</li>
<li class="noindent"><span epub:type="pagebreak" id="page_113"/>Click the <strong>Plotter icon</strong> in the Mu toolbar to open Mu’s Plotter, shown in <a href="ch05.xhtml#ch5fig4">Figure 5-4</a>. If you want to see the raw data that Mu is using to create graphs, click the <strong>REPL</strong> button.
<div class="image" id="ch5fig4"><img alt="Image" src="../images/05fig04.jpg"/></div>
<p class="figcap"><em>Figure 5-4: Plotting accelerometer data using Mu</em></p></li>
<li class="noindent">Tilt the micro:bit this way and that to see the changes in the Plotter.</li>
</ol>
<p class="indent">As you can see in <a href="ch05.xhtml#ch5fig4">Figure 5-4</a>, there are four plots, each drawn in a different color. There is one plot for each dimension (blue for X, green for Y, and orange for Z). There is also a purple plot for the <em>net acceleration</em>, which is the combination of the forces in all three dimensions. We’ll explain how the net acceleration is calculated in “How It Works: Calculating Net Acceleration” on <a href="ch01.xhtml#page_11">page 11</a>.</p>
<p class="indent">If you find that readings don’t appear in the REPL area of the screen, you may have an old micro:bit that needs an update for this to work. If this is the case, follow the instructions at <em><a href="https://support.microbit.org/support/solutions/articles/19000019131-how-to-upgrade-the-firmware-on-the-micro-bit/">https://support.microbit.org/support/solutions/articles/19000019131-how-to-upgrade-the-firmware-on-the-micro-bit/</a></em> to update your device.</p>
<h4 class="h4" id="ch00lev1sec134"><span epub:type="pagebreak" id="page_114"/><strong>Code</strong></h4>
<p class="noindent">Here’s the Python code that sends the accelerometer data to Mu’s plotter:</p>
<div class="programs1"><span class="green">from</span> microbit <span class="green">import</span> <span class="purple">*</span><br/><span class="green">from</span> math <span class="green">import</span> sqrt<br/><br/><span class="green">while True</span><span class="purple">:</span><br/>    x<span class="purple">,</span> y<span class="purple">,</span> z <span class="purple">=</span> accelerometer<span class="purple">.</span>get_values<span class="purple">()</span><br/>    net <span class="purple">=</span> sqrt<span class="purple">(</span>x<span class="purple">*</span>x <span class="purple">+</span> y<span class="purple">*</span>y <span class="purple">+</span> z<span class="purple">*</span>z<span class="purple">)</span><br/>    <span class="blue1">all</span> <span class="purple">=</span> <span class="purple">(</span>x<span class="purple">,</span> y<span class="purple">,</span> z<span class="purple">,</span> net<span class="purple">)</span><br/>    <span class="blue1">print</span><span class="purple">(</span><span class="blue1">all</span><span class="purple">)</span><br/>    sleep<span class="purple">(</span><span class="blue1">100</span><span class="purple">)</span></div>
<p class="indent">Import the usual micro:bit library. Then import the square root function <code>sqrt</code> from the Python math library. We’ll use this function to calculate net acceleration.</p>
<p class="indent">Add a <code>while</code> loop, which gets the readings for the X, Y, and Z dimensions from the accelerometer in one go using the <code>get_values</code> method. This line will return a <em>tuple</em>, which is a data structure capable of holding multiple values. Assign this tuple to three variables: <code>x</code>, <code>y</code>, and <code>z</code>. These will hold the three values, respectively. We use these variables to calculate the net acceleration, which we assign to the variable <code>net</code>.</p>
<p class="indent">Next, send the net acceleration value along with the individual values for the X, Y, and Z accelerations to Mu for plotting. Mu expects the values you want to plot to be in the form of a tuple, so create a new tuple, <code>all</code>, that contains all four values.</p>
<p class="indent">Finally, print the tuple, which not only shows the values on Mu’s REPL (for more information on this, see “The REPL” on <a href="ch01.xhtml#page_23">page 23</a>) but also provides these values to the Plotter. You can see the values printed in the bottom left of <a href="ch05.xhtml#ch5fig6">Figure 5-6</a>.</p>
<h4 class="h4" id="ch00lev1sec135"><strong>How It Works: Calculating Net Acceleration</strong></h4>
<p class="noindent">To calculate the net acceleration on the X, Y, and Z dimensions, you need to use some ancient Greek technology: the <em>Pythagorean theorem</em>.</p>
<p class="indent">To understand how this works, picture an acceleration force as a line with an arrow on the end. The arrow indicates <span epub:type="pagebreak" id="page_115"/>the direction of the force, and the length of the line indicates how strong the force is. Lines like these are called <em>vectors</em>, and they are used often in physics.</p>
<div class="image" id="ch5fig5"><img alt="Image" src="../images/05fig05.jpg"/></div>
<p class="figcap"><em>Figure 5-5: Two-dimensional vectors</em></p>
<p class="indent">Vectors are easier to understand in two dimensions than in three. <a href="ch05.xhtml#ch5fig5">Figure 5-5</a> shows some two-dimensional vectors on the X and Y dimensions. The blue vector along the X axis has a strength of 4, and the green vector along the Y axis has a strength of 3.</p>
<p class="indent">The purple vector, equivalent to the combined effect of the green and blue vectors, is the <em>net vector</em> our program calculated earlier. The net vector is useful because its length tells you the overall strength of the force. To calculate the strength of the net vector, you can use the Pythagorean theorem.</p>
<p class="indent">The Pythagorean theorem says that in a right triangle (a triangle that has a right angle), the square of the <em>hypotenuse</em> (the triangle’s longest side) equals the sum of the squares of the other two sides.</p>
<p class="indent">Looking at <a href="ch05.xhtml#ch5fig5">Figure 5-5</a>, you can see that we do indeed have a right triangle, because the blue and green vectors intersect at a right angle. Using the Pythagorean theorem, we can say that the square of the length of the purple line is equal to 32 + 42. That’s 9 + 16, which equals 25. So, the length of the purple line is the square root of 25, which is 5.</p>
<p class="indent">The math works in three dimensions as well as two. To find the length of a net vector for the dimensions X, Y, and Z, take the square root of the sum of the squares of all three X, Y, and Z vectors.</p>
<p class="indent"><a href="ch05.xhtml#ch5fig6">Figure 5-6</a> shows the three forces in the X, Y, and Z dimensions at some point in time.</p>
<div class="image" id="ch5fig6"><img alt="Image" src="../images/05fig06.jpg"/></div>
<p class="figcap"><em>Figure 5-6: Acceleration forces as vectors in three dimensions</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_116"/>Here’s the line of code that calculates the length of the single vector that would replace the X, Y, and Z vectors.</p>
<div class="programs1">    net <span class="purple">=</span> sqrt<span class="purple">(</span>x<span class="purple">*</span>x <span class="purple">+</span> y<span class="purple">*</span>y <span class="purple">+</span> z<span class="purple">*</span>z<span class="purple">)</span></div>
<p class="indent">The X, Y, and Z values are found in <code>a[0]</code>, <code>a[1]</code>, and <code>a[2]</code>, respectively, in the tuple returned by <code>accelerometer.get_values().</code></p>
<p class="indent">If the X, Y, and Z vectors were of lengths 4, 3, and 2, as shown in <a href="ch05.xhtml#ch5fig6">Figure 5-6</a>, then calculating the square of the length of the net vector would look like this:</p>
<p class="center">4 × 4 + 3 × 3 + 2 × 2 = 16 + 9 + 4 = 29</p>
<p class="indent">So, the length of the vector would be the square root of 29, or about 5.4.</p>
<h3 class="h3" id="ch00lev1sec136"><strong>PROJECT: TOOTHBRUSHING MONITOR</strong></h3>
<div class="image"><img alt="Image" src="../images/common3.jpg"/></div>
<p class="difficulty"><em>Difficulty: Easy</em></p>
<p class="noindent">The Mad Scientist is usually a bit distracted by all the interesting experiments going on, so they need some help brushing their teeth thoroughly. That’s why the Mad Scientist has used a micro:bit to create a toothbrush monitor (<a href="ch05.xhtml#ch5fig7">Figure 5-7</a>) that counts the number of strokes of the toothbrush.</p>
<div class="image" id="ch5fig7"><img alt="Image" src="../images/05fig07.jpg"/></div>
<p class="figcap"><em>Figure 5-7: A toothbrush monitor</em></p>
<p class="indent">The toothbrush monitor displays a score that ranges from 0 to 9 on the display. It increases the score by 1 for <span epub:type="pagebreak" id="page_117"/>every 50 strokes of the toothbrush. When it counts a score of 10, it displays the happy face icon to show the Mad Scientist that toothbrushing is all done—until next time.</p>
<div class="note">
<p class="notep"><span class="red"><strong>WARNING</strong></span> <em>Don’t let your micro:bit get wet—it might break!</em></p>
</div>
<h4 class="h4" id="ch00lev1sec137"><strong>What You’ll Need</strong></h4>
<p class="noindent">For this project, you will need the following items:</p>
<p class="noindentint"><strong><span class="blue">Micro:bit</span></strong></p>
<p class="noindentin"><strong><span class="blue">3V battery pack</span></strong> To power the micro:bit. (The switched type battery box is preferred.)</p>
<p class="noindentin"><strong><span class="blue">Manual toothbrush</span></strong> Not the electric type</p>
<p class="noindentinb"><strong><span class="blue">2 × Elastic bands</span></strong> To attach the micro:bit and battery pack to the toothbrush</p>
<p class="indent">This project is intended for a manual toothbrush. Electric toothbrushes won’t work with this project.</p>
<h4 class="h4" id="ch00lev1sec138"><strong>Construction</strong></h4>
<ol>
<li class="noindent">Go to <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em> to access the book’s code repository and click the link for <strong>Toothbrushing Monitor</strong>. Once the program has opened, click <strong>Download</strong> and then copy the hex file onto your micro:bit.
<p class="indent">If you prefer to use Python, then download the code from the same website. For instructions for downloading and using the book’s examples, see “Downloading the Code” on <a href="ch01.xhtml#page_34">page 34</a>. The Python file for this experiment is <em>ch_05_Toothbrush_Monitor.py</em>.</p></li>
<li class="noindent">Plug the battery pack into the micro:bit and attach the battery and micro:bit to the toothbrush using elastic bands, as shown in <a href="ch05.xhtml#ch5fig7">Figure 5-7</a>.
<p class="indent">When positioning the bands, make sure they don’t hide the display and that you can still reach the battery pack’s on/off switch. Also, check that the bands aren’t over the reset switch on the back of the micro:bit.</p></li>
<li class="noindent"><span epub:type="pagebreak" id="page_118"/>Switch on the battery pack. Once it’s on, the micro:bit should show 0. Brush vigorously, and after a little while, the display should show 1.</li>
</ol>
<h4 class="h4" id="ch00lev1sec139"><strong>Code</strong></h4>
<p class="noindent">The programs for this project measure the acceleration and, if it is above a certain level, they add 1 to a count variable to record the number of brush strokes.</p>
<p class="indent">When the count of brush strokes becomes big enough to qualify as another point in the tooth-brushing score, then the score is also incremented and displayed.</p>
<p class="indent">Eventually, when the score gets to 10, the smiley face icon is shown on the micro:bit’s display.</p>
<h5 class="h5" id="ch00lev1sec140"><strong>Blocks Code</strong></h5>
<p class="noindent">Here is the Blocks code for the project.</p>
<div class="image"><img alt="Image" src="../images/f0118-01.jpg"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_119"/>This is probably the most complex program so far in the book. The <code>on start</code> block defines four variables. Here’s what each of them does:</p>
<p class="noindentint"><span class="blue"><strong>strokes per point</strong></span> This specifies the number of brush strokes needed to advance your score by a point. If you are a lazy brusher, then you can decrease this number so that the points increase more quickly and you get your smiley-face reward faster. Note, however, that your next visit to the dentist may not be fun.</p>
<p class="noindentin"><span class="blue"><strong>score</strong></span> This is the number that increases as you complete each set of 50 brush strokes until it reaches 10.</p>
<p class="noindentin"><span class="blue"><strong>count</strong></span> This is used to track the number of strokes completed since you earned a point. It starts at 0 and resets each time the score goes up.</p>
<p class="noindentinb"><span class="blue"><strong>old mg</strong></span> This variable holds the acceleration value in milli-gravities the last time it checked for a brush stroke. The program will compare this value to the new value to detect brush strokes.</p>
<p class="indent">We make a <code>forever</code> block, and inside we have a <code>set XX to</code> block. From the drop-down, we select <code><span class="codestrong1">mg</code></span> so that that this block puts the overall acceleration reading into a variable called <code>mg</code>. In the <code>acceleration (mg)</code> block’s drop-down menu, choose <code><span class="codestrong1">strength</code>,</span> which does the Pythagorean theorem calculation for you. (If you’re using MicroPython, you’ll have to calculate it yourself.)</p>
<p class="indent">Then a <code>set change in mg</code> block calculates the change in acceleration strength by subtracting the current strength from the previous strength (held in <code>old mg</code>). If the change is greater than 800—indicating the start of a brushing movement—the <code>count</code> increases by 1. The value of 800 was chosen by looking at <a href="ch05.xhtml#ch5fig8">Figure 5-8</a>, which is a plot of the net acceleration for a short period of vigorous toothbrushing.</p>
<div class="image" id="ch5fig8"><span epub:type="pagebreak" id="page_120"/><img alt="Image" src="../images/05fig08.jpg"/></div>
<p class="figcap"><em>Figure 5-8: A plot of net acceleration during toothbrushing</em></p>
<p class="indent">On the plot, each peak represents one brush stroke, with the maximum net acceleration occurring when the brush changes direction. The value of 800 is enough to capture most strokes, since most strokes produce a change in acceleration of around 1,000. If you brush your teeth quite gently, you might need to decrease this threshold, or you could be left brushing your teeth forever, never racking up a large enough score to stop.</p>
<p class="indent">Next, place the first <code>if</code> block to detect acceleration large enough to indicate a brush stroke and, inside that, place a second <code>if</code> block that checks the value of <code>count</code>. If the value has exceeded the number you set earlier in <code>strokes per point</code>, then the program adds 1 to <code>score</code> and displays the new <code>score</code> value. Finally, the program checks whether <code>score</code> is greater than 9 and, if it is, displays a smiley-face icon.</p>
<h5 class="h5" id="ch00lev1sec141"><strong>MicroPython Code</strong></h5>
<p class="noindent">Here is the MicroPython version of the code.</p>
<div class="programs1"><span class="green">from</span> microbit <span class="green">import</span> <span class="purple">*</span><br/><span class="green">from</span> math <span class="green">import</span> sqrt<br/><br/>strokes_per_point <span class="purple">=</span> <span class="blue1">50</span><br/>old_mg <span class="purple">=</span> <span class="blue1">0</span><br/>count <span class="purple">=</span> <span class="blue1">0</span><br/>change_in_mg <span class="purple">=</span> <span class="blue1">0</span><br/>score <span class="purple">=</span> <span class="blue1">0</span><br/>mg <span class="purple">=</span> <span class="blue1">0</span><br/>display<span class="purple">.</span>show<span class="purple">(</span><span class="blue1">str</span><span class="purple">(</span>score<span class="purple">))</span><br/><span class="green"><span epub:type="pagebreak" id="page_121"/>while True</span><span class="purple">:</span><br/>    x<span class="purple">,</span> y<span class="purple">,</span> z <span class="purple">=</span> accelerometer<span class="purple">.</span>get_values<span class="purple">()</span><br/>    mg <span class="purple">=</span> sqrt<span class="purple">(</span>x<span class="purple">*</span>x <span class="purple">+</span> y<span class="purple">*</span>y <span class="purple">+</span> z<span class="purple">*</span>z<span class="purple">)</span><br/>    change_in_mg <span class="purple">=</span> mg <span class="purple">-</span> old_mg<br/>    old_mg <span class="purple">=</span> mg<br/>    <span class="green">if</span> change_in_mg <span class="purple">&gt;</span> <span class="blue1">800</span><span class="purple">:</span><br/>        count <span class="purple">+=</span> <span class="blue1">1</span><br/>        <span class="green">if</span> count <span class="purple">&gt;</span> strokes_per_point<span class="purple">:</span><br/>            score <span class="purple">+=</span> <span class="blue1">1</span><br/>            display<span class="purple">.</span>show<span class="purple">(</span><span class="blue1">str</span><span class="purple">(</span>score<span class="purple">))</span><br/>            count <span class="purple">=</span> <span class="blue1">0</span><br/>            <span class="green">if</span> score <span class="purple">&gt;</span> <span class="blue1">9</span><span class="purple">:</span><br/>                display<span class="purple">.</span>show<span class="purple">(</span>Image<span class="purple">.</span>HAPPY<span class="purple">)</span></div>
<p class="indent">The MicroPython code mirrors the Blocks code almost exactly, except that the overall strength of the force has to be calculated since MicroPython has no built-in function for this for the micro:bit.</p>
<h4 class="h4" id="ch00lev1sec142"><strong>Things to Try</strong></h4>
<p class="noindent">You could use this project as a <em>pedometer</em>—a device that measures how many steps you take when walking or running. To do this, try simplifying the code to get rid of the score variable, because we are now only interested in the number of steps (equivalent to the strokes when toothbrushing). You’ll want your code to keep track of steps and then, when you press button A, display the number of steps you’ve taken. To test it, tuck the project into your sock (remove the toothbrush first) and walk around while counting your steps in your head. Then see how many steps the pedometer says you’ve taken. If the measurement isn’t accurate, you may need to change the acceleration threshold from 800 to make the pedometer more or less sensitive.</p>
<h3 class="h3" id="ch00lev1sec143"><strong>EXPERIMENT 7: LOGGING ACCELERATION TO A FILE</strong></h3>
<div class="image"><img alt="Image" src="../images/common2.jpg"/></div>
<p class="noindent">The Plotter built into Mu is great if you don’t mind keeping your micro:bit tethered to your computer with a USB cable. However, sometimes the Mad Scientist finds it useful to record readings on the micro:bit remotely for later analysis.</p>
<p class="indent"><span epub:type="pagebreak" id="page_122"/>In this experiment, you’ll use your micro:bit to record accelerometer readings in a file saved on the micro:bit. You can wave the micro:bit around and do various other tests on it and then look at charts of the measured acceleration.</p>
<div class="image"><img alt="Image" src="../images/f0122-01.jpg"/></div>
<p class="indent">The program will take about 60 readings per second, and it can record about 45 seconds’ worth of samples before the micro:bit runs out of memory.</p>
<h4 class="h4" id="ch00lev1sec144"><strong>What You’ll Need</strong></h4>
<p class="noindent">For this experiment, you’ll need:</p>
<p class="noindentint"><strong><span class="blue">Micro:bit</span></strong></p>
<p class="noindentin"><strong><span class="blue">3V battery pack</span></strong></p>
<h4 class="h4" id="ch00lev1sec145"><strong>Construction</strong></h4>
<ol>
<li class="noindent">This project uses the micro:bit’s local filesystem, which is not available in Blocks code at the time of this writing. That means you’ll have to use Python for this experiment. Download the code from <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em>, along with instructions for downloading and using the book examples. The Python file for this experiment is <em>Experiment_07.py</em>. Load the program onto your micro:bit.</li>
<li class="noindent"><span epub:type="pagebreak" id="page_123"/>When you turn on the micro:bit, its display will show an X. This means it isn’t recording any readings. When you click button A, the icon will change to a check mark, and the micro:bit will start recording. It will stop recording when you press button A again, at which point it will save the accelerometer readings in a file that you can transfer to your computer.
<p class="indent">To test this out, press <strong>button A</strong>, wave the micro:bit around, and press <strong>button A</strong> again.</p></li>
<li class="noindent">To transfer the file containing the readings to your computer, use Mu’s <em>Files</em> feature. Connect your micro:bit to your computer with a USB cable and click the <strong>Files</strong> icon in Mu’s toolbar (<a href="ch05.xhtml#ch5fig9">Figure 5-9</a>).
<p class="indent">The bottom of the window now has two columns. On the left are the files saved on the micro:bit. In <a href="ch05.xhtml#ch5fig9">Figure 5-9</a>, there is only one file, <em>data.txt</em>. On the right are the files in Mu’s code directory, which is in your home directory under <em>mu code</em>.</p>
<div class="image" id="ch5fig9"><img alt="Image" src="../images/05fig09.jpg"/></div>
<p class="figcap"><em>Figure 5-9: Mu’s File feature in action</em></p>
<p class="indent">To copy the file from the micro:bit, just drag it from the left area to the right area in the Mu window.</p>
<p class="indent">As with Experiment 6, earlier in the chapter, if the Files feature doesn’t work in Mu, you may have an old <span epub:type="pagebreak" id="page_124"/>micro:bit that needs an update. In this case, follow the instructions at <em><a href="https://support.microbit.org/support/solutions/articles/19000019131-how-to-upgrade-the-firmware-on-the-micro-bit/">https://support.microbit.org/support/solutions/articles/19000019131-how-to-upgrade-the-firmware-on-the-micro-bit/</a></em> to update your device.</p></li>
<li class="noindent">Once you’ve transferred the data from the micro:bit to your computer, you’ll plot the data by importing the file into a spreadsheet, such as Excel or Google Sheets.
<p class="indent">The procedure is a bit different depending on which spreadsheet software you use. I’ll show you how to use Google Sheets since it’s free. You just need to be logged into a Google account.</p>
<p class="indent">Visit <em><a href="https://docs.google.com/spreadsheets/">https://docs.google.com/spreadsheets/</a></em> and click the <strong>Blank</strong> option in the <em>Start a new spreadsheet</em> area. Then, from the Google Sheets menu, select <strong>File</strong>▸ <strong>Import</strong>. From the pop-up window that appears, select the <strong>Upload</strong> tab and navigate to the <em>data.txt</em> file that you copied onto your computer.</p>
<p class="indent">The recorded data should appear in the first column of your spreadsheet. Select the column and click <strong>Insert</strong>▸<strong>Chart</strong> to create a chart of the data, like the one shown in <a href="ch05.xhtml#ch5fig10">Figure 5-10</a>.</p></li>
</ol>
<div class="image" id="ch5fig10"><img alt="Image" src="../images/05fig10.jpg"/></div>
<p class="figcap"><em>Figure 5-10: Charting data recorded on the micro:bit</em></p>
<h4 class="h4" id="ch00lev1sec146"><span epub:type="pagebreak" id="page_125"/><strong>Code</strong></h4>
<p class="noindent">Here is the MicroPython code for this experiment:</p>
<div class="programs1"><span class="green">from</span> microbit <span class="green">import</span> <span class="purple">*</span><br/><span class="green">from</span> math <span class="green">import</span> sqrt<br/><span class="green">import</span> os<br/><br/>filename <span class="purple">=</span> <span class="red1">'data.txt'</span><br/><br/>recording <span class="purple">=</span> <span class="green">False</span><br/>display<span class="purple">.</span>show<span class="purple">(</span>Image<span class="purple">.</span>NO<span class="purple">)</span><br/><br/><span class="green">while True</span><span class="purple">:</span><br/>    <span class="green">if</span> button_a<span class="purple">.</span>was_pressed<span class="purple">():</span><br/>        recording <span class="purple">=</span> <span class="green">not</span> recording<br/>        <span class="green">if</span> recording<span class="purple">:</span><br/>            display<span class="purple">.</span>show<span class="purple">(</span>Image<span class="purple">.</span>YES<span class="purple">)</span><br/>            <span class="green">try</span><span class="purple">:</span><br/>                os<span class="purple">.</span>remove<span class="purple">(</span>filename<span class="purple">)</span><br/>            <span class="green">except</span><span class="purple">:</span><br/>                <span class="green">pass</span><br/>            fs <span class="purple">=</span> <span class="blue1">open</span><span class="purple">(</span>filename<span class="purple">,</span> <span class="red1">'w'</span><span class="purple">)</span><br/>                <span class="green">else</span><span class="purple">:</span><br/>            display<span class="purple">.</span>show<span class="purple">(</span>Image<span class="purple">.</span>NO<span class="purple">)</span><br/>            fs<span class="purple">.</span>close<span class="purple">()</span><br/>    <span class="green">if</span> recording<span class="purple">:</span><br/>        x<span class="purple">,</span> y<span class="purple">,</span> z <span class="purple">=</span> accelerometer<span class="purple">.</span>get_values<span class="purple">()</span><br/>        net <span class="purple">=</span> sqrt<span class="purple">(</span>x<span class="purple">*</span>x <span class="purple">+</span> y<span class="purple">*</span>y <span class="purple">+</span> z<span class="purple">*</span>z<span class="purple">)</span><br/>        fs<span class="purple">.</span>write<span class="purple">(</span><span class="blue1">str</span><span class="purple">(</span>net<span class="purple">))</span><br/>        fs<span class="purple">.</span>write<span class="purple">(</span><span class="red1">'\n'</span><span class="purple">)</span><br/>        sleep<span class="purple">(</span><span class="blue1">10</span><span class="purple">)</span></div>
<p class="indent">The micro:bit can save only a limited amount of data, so import the <code>os</code> package, which will let you delete any data already on your micro:bit.</p>
<p class="indent">Set the data filename as <code>data.txt</code>. You can change the name of this file by altering the value of the <code>filename</code> variable, though I recommend keeping it as is until you’ve gotten the program working.</p>
<p class="indent">Make a variable called <code>recording</code> to keep track of whether the project is recording or not. This is toggled between <code>True</code> and <code>False</code> in the main <code>while</code> loop every time button A is pressed to start and stop the recording of data. That’s what the line <code>recording = not recording</code> does: if <code>recording</code> is <code>True</code>, the code sets it to <code>False</code>, and vice versa.</p>
<p class="indent"><span epub:type="pagebreak" id="page_126"/>Create a <code><span class="codestrong1">while True</code></span> loop to run forever. Inside this loop are two <code>if</code> statements. The first tells the micro:bit what to do when button A is pressed, and the second checks whether we are in recording mode. When button A is first pressed, recording starts, the screen displays the <code>YES</code> image, and the <code>os.remove</code> method deletes the existing data file.</p>
<p class="indent">We’ve put the <code>remove</code> command within a <code>try: except:</code> Python structure. This ensures that if any error occurs (in particular, if the data file can’t be deleted because it’s not there), the program ignores the error and doesn’t crash the program.</p>
<p class="indent">The program then opens the file with a mode of <code>w</code>, which means you can write in it. When button A is pressed again, the screen displays the <code>NO</code> image and the file closes.</p>
<p class="indent">Also contained in the main <code>while</code> loop is another <code>if</code> block that writes a reading from the accelerometer to the file as long as <code>recording</code> is <code>True</code>. If the program runs for too long and fills up all the file space, it will give an error. However, the data that it wrote before it ran out of room will still be available.</p>
<p class="indent">The <code>sleep</code> command at the end of the recording slows down the recording process so that you don’t run out of memory too quickly.</p>
<h4 class="h4" id="ch00lev1sec147"><strong>Things to Try</strong></h4>
<p class="noindent">This experiment will let you measure accelerations in various practical situations. You could, for example, record the accelerations on your micro:bit when you throw it into the air. If you plan to try this, then it’s wise to take a few precautions:</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Choose an environment with soft ground. That way, if you fail to catch your micro:bit, it might survive. During experiments like this, it’s not unusual for a battery to come loose or fall out of its holder.</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Don’t throw your micro:bit somewhere where it may hit someone in the head.</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Attach the micro:bit to the battery pack. Elastic bands are good for this.</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Put your micro:bit in a case. A Kitronik MI:pro case with MI:power battery backpack, shown in <a href="ch05.xhtml#ch5fig11">Figure 5-11</a>, is a great choice. If you use this case, you won’t need a battery pack, because the case contains a tiny 3V battery.</p>
<div class="image" id="ch5fig11"><span epub:type="pagebreak" id="page_127"/><img alt="Image" src="../images/05fig11.jpg"/></div>
<p class="figcap"><em>Figure 5-11: Kitronik MI:pro case with MI:power battery backpack</em></p>
<p class="indent">You could also measure acceleration by securely attaching a string to the micro:bit and swinging it gently in circles. Again, be careful as the micro:bit could easily become detached from its string, breaking or hurting someone nearby.</p>
<p class="indent">The filesystem used by the micro:bit is very limited; it has only about 40KB available for storage. Therefore, previous files may be erased every time you flash a new program onto the micro:bit.</p>
<h3 class="h3" id="ch00lev1sec148"><strong>PROJECT: ACCELERATION DISPLAY</strong></h3>
<div class="image"><img alt="Image" src="../images/common3.jpg"/></div>
<p class="difficulty"><em>Difficulty: Easy</em></p>
<p class="noindent">This project, shown in <a href="ch05.xhtml#ch5fig12">Figure 5-12</a>, allows you to see the micro:bit’s acceleration on its display. When the micro:bit is at rest, the middle row of LEDs on the display will be lit. If you rapidly move the micro:bit up, then the line of LEDs will move up the display, like an elevator, in response to the increase in the net force. Similarly, if you quickly move the micro:bit down, the line will move down, indicating the reduced effect of gravity, as if you were accelerating downward in an elevator.</p>
<div class="image" id="ch5fig12"><span epub:type="pagebreak" id="page_128"/><img alt="Image" src="../images/05fig12.jpg"/></div>
<p class="figcap"><em>Figure 5-12: A Micro:bit acceleration display</em></p>
<h4 class="h4" id="ch00lev1sec149"><strong>What You’ll Need</strong></h4>
<p class="noindent">For this project, you just need a micro:bit. However, it’s useful to have a battery pack if you want to make this project more mobile.</p>
<p class="indent">You could also use the MI:pro case and MI:power combination shown in <a href="ch05.xhtml#ch5fig11">Figure 5-11</a>.</p>
<h4 class="h4" id="ch00lev1sec150"><strong>Construction</strong></h4>
<ol>
<li class="noindent">Go to <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em> to access the book’s code repository and click the link for <strong>Acceleration Display</strong>. Once the program has opened, <strong>Download</strong> and then copy the hex file onto your micro:bit.
<p class="indent">If you prefer to use Python, then download the code from the same website. For instructions for downloading and using the book’s examples, see “Downloading the Code” on <a href="ch01.xhtml#page_34">page 34</a>. The Python file for this experiment is <em>ch_05_Acceleration_Display.py</em>.</p></li>
<li class="noindent">Try moving your micro:bit up and down, watching how acceleration in various directions affects the reading. If you can take your micro:bit for a ride in an elevator, watch as the display shows whether you’re going up or down.</li>
</ol>
<h4 class="h4" id="ch00lev1sec151"><span epub:type="pagebreak" id="page_129"/><strong>Code</strong></h4>
<p class="noindent">The code first takes a reading of acceleration and then uses a bit of math to decide which row of the display to light up.</p>
<h5 class="h5" id="ch00lev1sec152"><strong>Blocks Code</strong></h5>
<p class="noindent">Here is the Blocks code for this project.</p>
<div class="image"><img alt="Image" src="../images/f0129-01.jpg"/></div>
<p class="indent">All the code for this project is contained in the <code>forever</code> block. It first reads the net acceleration and then calculates a value for <code>y</code>. Here, <code>y</code> represents the row of the display that will light up. When the micro:bit is stationary, the only force acting on it is gravity, at a net force of 1,000 mg (1 g). Therefore, the program subtracts 1,000 from the net acceleration and divides the result by 100, so that each 1/10 of g will cause a change of 1 row in the display. Finally, we add 2 to this result to display row 2 (the middle row of LEDs, if you start counting at 0) by default.</p>
<p class="indent"><span epub:type="pagebreak" id="page_130"/>Use two <code>if</code> blocks to make sure that the value of <code>y</code> remains between 0 and 4 (for the 5 rows). To draw the correct row, first clear the screen so the old row isn’t displayed along with the new reading. Then use a <code>for</code> loop to loop over each of the five LEDs for that row, which are represented by values of <code>x</code>, to turn them on.</p>
<h5 class="h5" id="ch00lev1sec153"><strong>MicroPython Code</strong></h5>
<p class="noindent">Here’s the MicroPython equivalent of the code:</p>
<div class="programs1"><span class="green">from</span> microbit <span class="green">import</span> <span class="purple">*</span><br/><span class="green">from</span> math <span class="green">import</span> sqrt<br/><br/><span class="green">while True</span><span class="purple">:</span><br/>    x<span class="purple">,</span> y<span class="purple">,</span> z <span class="purple">=</span> accelerometer<span class="purple">.</span>get_values<span class="purple">()</span><br/>    acc <span class="purple">=</span> sqrt<span class="purple">(</span>x<span class="purple">*</span>x <span class="purple">+</span> y<span class="purple">*</span>y <span class="purple">+</span> z<span class="purple">*</span>z<span class="purple">)</span><br/>    y <span class="purple">=</span> <span class="blue1">int</span><span class="purple">(</span><span class="blue1">2</span> <span class="purple">+</span> <span class="purple">(</span>acc <span class="purple">-</span> <span class="blue1">1000</span><span class="purple">)</span> <span class="purple">/</span> <span class="blue1">100</span><span class="purple">)</span><br/>    display<span class="purple">.</span>clear<span class="purple">()</span><br/>    <span class="green">if</span> y <span class="purple">&lt;</span> <span class="blue1">0</span><span class="purple">:</span><br/>        y <span class="purple">=</span> <span class="blue1">0</span><br/>    <span class="green">if</span> y <span class="purple">&gt;</span> <span class="blue1">4</span><span class="purple">:</span><br/>        y <span class="purple">=</span> <span class="blue1">4</span><br/>    <span class="green">for</span> x <span class="green">in</span> <span class="blue1">range</span><span class="purple">(</span><span class="blue1">0</span><span class="purple">,</span> <span class="blue1">5</span><span class="purple">):</span><br/>        display<span class="purple">.</span>set_pixel<span class="purple">(</span>x<span class="purple">,</span> y<span class="purple">,</span> <span class="blue1">9</span><span class="purple">)</span></div>
<p class="noindent">This code is similar to the Blocks code, but you have to calculate the net acceleration yourself.</p>
<h3 class="h3" id="ch00lev1sec154"><strong>SUMMARY</strong></h3>
<p class="noindent">The micro:bit’s accelerometer opens up a lot of opportunities for projects that detect the movement or orientation of a micro:bit. In this chapter, you’ve explored some interesting ways you can use the accelerometer.</p>
<p class="indent">You’ve also learned how to plot data coming from the micro:bit using Mu’s Plotter and record readings into a file to chart and analyze later.</p>
</body></html>