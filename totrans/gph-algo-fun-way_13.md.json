["```\ndef prims(g: Graph) -> Union[list, None]:\n    pq: PriorityQueue = PriorityQueue(min_heap=True)\n    last: list = [-1] * g.num_nodes\n    mst_edges: list = []\n\n  ❶ pq.enqueue(0, 0.0)\n    for i in range(1, g.num_nodes):\n        pq.enqueue(i, float('inf'))\n\n  ❷ while not pq.is_empty():\n        index: int = pq.dequeue()\n        current: Node = g.nodes[index]\n\n      ❸ if last[index] != -1:\n            mst_edges.append(current.get_edge(last[index]))\n        elif index != 0:\n            return None\n\n      ❹ for edge in current.get_edge_list():\n            neighbor: int = edge.to_node\n            if pq.in_queue(neighbor):\n\n                if edge.weight < pq.get_priority(neighbor):\n                    pq.update_priority(neighbor, edge.weight)\n                    last[neighbor] = index\n\n    return mst_edges \n```", "```\ndef kruskals(g: Graph) -> Union[list, None]:\n    djs: UnionFind = UnionFind(g.num_nodes)\n    all_edges: list = []\n    mst_edges: list = []\n\n  ❶ for idx in range(g.num_nodes):\n        for edge in g.nodes[idx].get_edge_list():\n          ❷ if edge.to_node > edge.from_node:\n                all_edges.append(edge)\n  ❸ all_edges.sort(key=lambda edge: edge.weight)\n\n    for edge in all_edges:\n      ❹ if djs.are_disjoint(edge.to_node, edge.from_node):\n            mst_edges.append(edge)\n            djs.union_sets(edge.to_node, edge.from_node)\n\n  ❺ if djs.num_disjoint_sets == 1:\n        return mst_edges\n    else:\n        return None \n```", "```\ndef randomized_kruskals(g: Graph) -> list:\n  ❶ djs: UnionFind = UnionFind(g.num_nodes)\n    all_edges: list = []\n    maze_edges: list = []\n\n  ❷ for idx in range(g.num_nodes):\n        for edge in g.nodes[idx].get_edge_list():\n            if edge.to_node > edge.from_node:\n                all_edges.append(edge)\n\n  ❸ while djs.num_disjoint_sets > 1:\n        num_edges: int = len(all_edges)\n      ❹ edge_ind: int = random.randint(0, num_edges - 1)\n        new_edge: Edge = all_edges.pop(edge_ind)\n\n      ❺ if djs.are_disjoint(new_edge.to_node, new_edge.from_node):\n            maze_edges.append(new_edge)\n            djs.union_sets(new_edge.to_node, new_edge.from_node)\n\n    return maze_edges \n```", "```\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x: float = x\n        self.y: float = y\n\n    def distance(self, b) -> float:\n        diff_x: float = (self.x - b.x)\n        diff_y: float = (self.y - b.y)\n        dist: float = math.sqrt(diff_x*diff_x + diff_y*diff_y)\n        return dist \n```", "```\nclass Link:\n    def __init__(self, dist: float, id1: int, id2: int):\n        self.dist: float = dist\n        self.id1: int = id1\n        self.id2: int = id2 \n```", "```\ndef single_linkage_clustering(points: list) -> list:\n    num_pts: int = len(points)\n    djs: UnionFind = UnionFind(num_pts)\n    all_links: list = []\n    cluster_links: list = []\n\n  ❶ for id1 in range(num_pts):\n        for id2 in range(id1 + 1, num_pts):\n            dist = points[id1].distance(points[id2])\n            all_links.append(Link(dist, id1, id2))\n\n  ❷ all_links.sort(key=lambda link: link.dist)\n\n    for x in all_links:\n      ❸ if djs.are_disjoint(x.id1, x.id2):\n            cluster_links.append(x)\n            djs.union_sets(x.id1, x.id2)\n\n    return cluster_links \n```"]