<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;How Ruby Borrowed a Decades-Old Idea from Lisp"><div class="titlepage"><div><div><h1 class="title"><a id="how_ruby_borrowed_a_decades-old_idea_fro"/>Chapter 8. How Ruby Borrowed a Decades-Old Idea from Lisp</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00178"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>Blocks are Ruby’s implementation of closures.</em></span></p></blockquote></div><p><a class="indexterm" id="iddle1166"/><a class="indexterm" id="iddle1530"/><a class="indexterm" id="iddle1543"/><a class="indexterm" id="iddle1583"/>Blocks are one of the most commonly used and powerful features of Ruby because they allow you to pass a code snippet to <code class="literal">Enumerable</code> methods, such as <code class="literal">each</code>, <code class="literal">detect</code>, or <code class="literal">inject</code>. Using the <code class="literal">yield</code> keyword, you can also write your own custom iterators or functions that call blocks for other reasons. Ruby code containing blocks is often more succinct, elegant, and expressive than equivalent code in older languages, such as C.</p><p>But don’t jump to the conclusion that blocks are a new idea! In fact, blocks are not new to Ruby at all. The computer science concept behind blocks, called <span class="emphasis"><em>closures</em></span>, was first invented by Peter J. Landin in 1964, a few years after the original version of Lisp was created by John McCarthy in 1958. Closures were later adopted by Lisp, or—more precisely—a dialect <a class="indexterm" id="iddle1080"/><a class="indexterm" id="iddle1168"/><a class="indexterm" id="iddle1858"/><a class="indexterm" id="iddle1965"/><a class="indexterm" id="iddle2018"/><a class="indexterm" id="iddle2034"/>of Lisp called <span class="emphasis"><em>Scheme</em></span>, which was invented by Gerald Sussman and Guy Steele in 1975. Sussman and Steele’s use of closures in Scheme brought the idea to many programmers for the first time.</p><p>But what does the word <span class="emphasis"><em>closure</em></span> actually mean in this context? In other words, exactly what are Ruby blocks? Are they just the snippet of Ruby code that appears between the <code class="literal">do</code> and <code class="literal">end</code> keywords? In this chapter I’ll review how Ruby implements blocks internally and demonstrate how they meet the definition of <span class="emphasis"><em>closure</em></span> used by Sussman and Steele back in 1975. I’ll also show how blocks, lambdas, and procs are all different ways of looking at closures.</p><div class="sidebar"><a id="roadmap-id00029"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch08.html#blocks_closures_in_ruby" title="Blocks: Closures in Ruby">Blocks: Closures in Ruby</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch08.html#stepping_through_how_ruby_calls_a_block" title="Stepping Through How Ruby Calls a Block">Stepping Through How Ruby Calls a Block</a></p></li><li class="listitem"><p><a class="xref" href="ch08.html#borrowing_an_idea_from_1975" title="Borrowing an Idea from 1975">Borrowing an Idea from 1975</a></p></li><li class="listitem"><p><a class="xref" href="ch08.html#rbunderscoreblockunderscoret_and_rbu" title="The rb_block_t and rb_control_frame_t Structures">The rb_block_t and rb_control_frame_t Structures</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch08.html#experiment_8-1_which_is_faster_a_while_l" title="Experiment 8-1: Which Is Faster: A while Loop or Passing a Block to each?">Experiment 8-1: Which Is Faster: A while Loop or Passing a Block to each?</a></p></li><li class="listitem"><p><a class="xref" href="ch08.html#lambdas_and_procs_treating_a_function_as" title="Lambdas and Procs: Treating a Function as a First-Class Citizen">Lambdas and Procs: Treating a Function as a First-Class Citizen</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch08.html#stack_vsdot_heap_memory" title="Stack vs. Heap Memory">Stack vs. Heap Memory</a></p></li><li class="listitem"><p><a class="xref" href="ch08.html#closer_look_at_how_ruby_saves_a_string" title="A Closer Look at How Ruby Saves a String Value">A Closer Look at How Ruby Saves a String Value</a></p></li><li class="listitem"><p><a class="xref" href="ch08.html#how_ruby_creates_a_lambda" title="How Ruby Creates a Lambda">How Ruby Creates a Lambda</a></p></li><li class="listitem"><p><a class="xref" href="ch08.html#how_ruby_calls_a_lambda" title="How Ruby Calls a Lambda">How Ruby Calls a Lambda</a></p></li><li class="listitem"><p><a class="xref" href="ch08.html#proc_object" title="The Proc Object">The Proc Object</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch08.html#experiment_8-2_changing_local_variables" title="Experiment 8-2: Changing Local Variables After Calling lambda">Experiment 8-2: Changing Local Variables After Calling lambda</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch08.html#calling_lambda_more_than_once_in_the_sam" title="Calling lambda More Than Once in the Same Scope">Calling lambda More Than Once in the Same Scope</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch08.html#summary-id00033" title="Summary">Summary</a></p></li></ul></div></div><div class="sect1" title="Blocks: Closures in Ruby"><div class="titlepage"><div><div><h1 class="title"><a id="blocks_closures_in_ruby"/>Blocks: Closures in Ruby</h1></div></div></div><p>Internally, Ruby represents each block using a C structure called <code class="literal">rb_block_t</code>, shown in <a class="xref" href="ch08.html#whatapostrophes_inside_the_rbunderscoreb" title="Figure 8-1. What’s inside the rb_block_t C structure?">Figure 8-1</a>. By learning what Ruby stores in <code class="literal">rb_block_t</code>, we can find out exactly what a block is.</p><div class="figure"><a id="whatapostrophes_inside_the_rbunderscoreb"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00179"/><img alt="What’s inside the rb_block_t C structure?" src="httpatomoreillycomsourcenostarchimages1854175.png.jpg"/></div></div><p class="title">Figure 8-1. What’s inside the rb_block_t C structure?</p></div><p>As we did in <a class="xref" href="ch05.html" title="Chapter 5. Objects and Classes">Chapter 5</a> with the <code class="literal">RClass</code> structure, let’s deduce the contents of the <code class="literal">rb_block_t</code> structure based on what we know blocks can do in Ruby. We’ll begin with the most obvious attribute of blocks. We know that each block must consist of a piece of Ruby code, or internally a set of compiled YARV bytecode instructions. For example, suppose we call a method and pass a block as a parameter, as shown in <a class="xref" href="ch08.html#superficiallycomma_a_block_is_just_a_sni" title="Example 8-1. Superficially, a block is just a snippet of Ruby code.">Example 8-1</a>.</p><div class="example"><a id="superficiallycomma_a_block_is_just_a_sni"/><p class="title">Example 8-1. Superficially, a block is just a snippet of Ruby code.</p><div class="example-contents"><pre class="programlisting">10.times do
  str = "The quick brown fox jumps over the lazy dog."
  puts str
end</pre></div></div><p>When executing the <code class="literal">10.times</code> call, Ruby needs to know what code to iterate over. Therefore, the <code class="literal">rb_block_t</code> structure must contain a pointer to that code, as shown in <a class="xref" href="ch08.html#rbunderscoreblockunderscoret_structu" title="Figure 8-2. The rb_block_t structure contains a pointer to a snippet of YARV instructions.">Figure 8-2</a>.</p><div class="figure"><a id="rbunderscoreblockunderscoret_structu"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00180"/><img alt="The rb_block_t structure contains a pointer to a snippet of YARV instructions." src="httpatomoreillycomsourcenostarchimages1854177.png.jpg"/></div></div><p class="title">Figure 8-2. The <code class="literal">rb_block_t</code> structure contains a pointer to a snippet of YARV instructions.</p></div><p>The value <code class="literal">iseq</code> is a pointer to the YARV instructions for the Ruby code in the block.</p><p>Another obvious but often overlooked behavior of blocks is that they can access variables in the surrounding or parent Ruby scope, as shown in <a class="xref" href="ch08.html#code_inside_the_block_accesses_the_v" title="Example 8-2. The code inside the block accesses the variable str from the surrounding code.">Example 8-2</a>.</p><div class="example"><a id="code_inside_the_block_accesses_the_v"/><p class="title">Example 8-2. The code inside the block accesses the variable <code class="literal">str</code> from the surrounding code.</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> str = "The quick brown fox"
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> 10.times do
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   str2 = "jumps over the lazy dog."
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>   puts "#{str} #{str2}"
    end</pre></div></div><p>Here the <code class="literal">puts</code> function call at <span class="inlinemediaobject"><a id="inline_id00264"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> refers equally to the <code class="literal">str2</code> variable inside the block and the <code class="literal">str</code> variable defined in the surrounding code at <span class="inlinemediaobject"><a id="inline_id00265"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. Obviously blocks can access values from the code surrounding them. This ability is one of the things that makes blocks useful.</p><p><a class="indexterm" id="iddle1082"/><a class="indexterm" id="iddle1103"/><a class="indexterm" id="iddle1247"/><a class="indexterm" id="iddle1251"/><a class="indexterm" id="iddle1261"/><a class="indexterm" id="iddle1514"/><a class="indexterm" id="iddle1796"/><a class="indexterm" id="iddle1865"/><a class="indexterm" id="iddle2052"/>Blocks have in some sense a dual personality. On the one hand, they behave like separate methods: You can call them and pass them arguments just as you would any method. On the other hand, they’re part of the surrounding function or method.</p><div class="sect2" title="Stepping Through How Ruby Calls a Block"><div class="titlepage"><div><div><h2 class="title"><a id="stepping_through_how_ruby_calls_a_block"/>Stepping Through How Ruby Calls a Block</h2></div></div></div><p>How does this work internally? Does Ruby implement blocks as separate methods or as part of the surrounding method? Let’s step through <a class="xref" href="ch08.html#code_inside_the_block_accesses_the_v" title="Example 8-2. The code inside the block accesses the variable str from the surrounding code.">Example 8-2</a> to see what happens inside Ruby when you call a block.</p><p>When Ruby executes the first line of code from <a class="xref" href="ch08.html#code_inside_the_block_accesses_the_v" title="Example 8-2. The code inside the block accesses the variable str from the surrounding code.">Example 8-2</a> at <span class="inlinemediaobject"><a id="inline_id00266"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, <code class="literal">str = "The quick brown fox"</code>, YARV stores the local variable <code class="literal">str</code> on its internal stack. YARV tracks the location of <code class="literal">str</code> using the <code class="literal">EP</code>, or environment pointer, located in the current <code class="literal">rb_control_frame_t</code> structure, as shown in <a class="xref" href="ch08.html#ruby_saves_the_local_variable_str_on_the" title="Figure 8-3. Ruby saves the local variable str on the stack.">Figure 8-3</a>.<sup>[<a class="footnote" href="#ftn.ch08fn01" id="ch08fn01">1</a>]</sup></p><div class="figure"><a id="ruby_saves_the_local_variable_str_on_the"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00181"/><img alt="Ruby saves the local variable str on the stack." src="httpatomoreillycomsourcenostarchimages1854179.png.jpg"/></div></div><p class="title">Figure 8-3. Ruby saves the local variable <code class="literal">str</code> on the stack.</p></div><p>Next, Ruby reaches the <code class="literal">10.times do</code> call at <span class="inlinemediaobject"><a id="inline_id00267"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> in <a class="xref" href="ch08.html#code_inside_the_block_accesses_the_v" title="Example 8-2. The code inside the block accesses the variable str from the surrounding code.">Example 8-2</a>. Before executing the actual iteration—that is, before calling the <code class="literal">times</code> method—Ruby creates and initializes a new <code class="literal">rb_block_t</code> structure to represent the block. Ruby needs to create the block structure now because the block is really just another argument to the <code class="literal">times</code> method. <a class="xref" href="ch08.html#ruby_creates_a_new_rbunderscoreblockunde" title="Figure 8-4. Ruby creates a new rb_block_t structure before calling the method and passing the block to it.">Figure 8-4</a> shows this new <code class="literal">rb_block_t</code> structure.</p><p>When creating the new block structure, Ruby copies the current value of the <code class="literal">EP</code> into the new block. In other words, Ruby saves the location of the current stack frame in the new block.</p><div class="figure"><a id="ruby_creates_a_new_rbunderscoreblockunde"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00182"/><img alt="Ruby creates a new rb_block_t structure before calling the method and passing the block to it." src="httpatomoreillycomsourcenostarchimages1854181.png.jpg"/></div></div><p class="title">Figure 8-4. Ruby creates a new <code class="literal">rb_block_t</code> structure before calling the method and passing the block to it.</p></div><p>Next, Ruby calls the <code class="literal">times</code> method on the object <code class="literal">10</code>, an instance of the <code class="literal">Fixnum</code> class. While doing this, YARV creates a new frame on its internal stack. Now we have two stack frames: above, a new stack frame for the <code class="literal">Fixnum.times</code> method, and below, the original stack frame used by the top-level function (see <a class="xref" href="ch08.html#ruby_creates_a_new_stack_frame_when_it_e" title="Figure 8-5. Ruby creates a new stack frame when it executes the 10.times call.">Figure 8-5</a>).</p><div class="figure"><a id="ruby_creates_a_new_stack_frame_when_it_e"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00183"/><img alt="Ruby creates a new stack frame when it executes the 10.times call." src="httpatomoreillycomsourcenostarchimages1854183.png.jpg"/></div></div><p class="title">Figure 8-5. Ruby creates a new stack frame when it executes the <code class="literal">10.times</code> call.</p></div><p>Ruby implements the <code class="literal">times</code> method internally using its own C code. Although this is a built-in method, Ruby implements it just as you probably would. Ruby starts to iterate over the numbers 0, 1, 2, and so on, up to 9, and then it calls <code class="literal">yield</code>, calling the block once for each of these integers. Finally, the code that implements <code class="literal">yield</code> internally calls the block each time it moves through the loop, pushing a third frame onto the top of the stack for the code inside the block to use. <a class="xref" href="ch08.html#ruby_creates_a_third_stack_frame_when_th" title="Figure 8-6. Ruby creates a third stack frame when the 10.times method yields to the block.">Figure 8-6</a> shows this third stack frame.</p><div class="figure"><a id="ruby_creates_a_third_stack_frame_when_th"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00184"/><img alt="Ruby creates a third stack frame when the 10.times method yields to the block." src="httpatomoreillycomsourcenostarchimages1854185.png.jpg"/></div></div><p class="title">Figure 8-6. Ruby creates a third stack frame when the <code class="literal">10.times</code> method yields to the block.</p></div><p><a class="indexterm" id="iddle1859"/>On the left side of the figure, we now have three stack frames:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On the top is the new stack frame for the block, containing the <code class="literal">str2</code> variable defined at <span class="inlinemediaobject"><a id="inline_id00268"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> in <a class="xref" href="ch08.html#code_inside_the_block_accesses_the_v" title="Example 8-2. The code inside the block accesses the variable str from the surrounding code.">Example 8-2</a>.</p></li><li class="listitem"><p>In the middle is the stack frame used by the internal C code that implements the <code class="literal">Fixnum#times</code> method.</p></li><li class="listitem"><p>And at the bottom is the original function’s stack frame, containing the <code class="literal">str</code> variable defined at <span class="inlinemediaobject"><a id="inline_id00269"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> in <a class="xref" href="ch08.html#code_inside_the_block_accesses_the_v" title="Example 8-2. The code inside the block accesses the variable str from the surrounding code.">Example 8-2</a>.</p></li></ul></div><p>While creating the new stack frame, Ruby’s internal <code class="literal">yield</code> code copies the <code class="literal">EP</code> from the block into the new stack frame. Now the code inside the block can access both its local variables, directly via the <code class="literal">rb_control_frame_t</code> structure, and the variables from the parent scope, indirectly via the <code class="literal">EP</code> pointer using dynamic variable access. Specifically, this allows the <code class="literal">puts</code> statement at <span class="inlinemediaobject"><a id="inline_id00270"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> in <a class="xref" href="ch08.html#code_inside_the_block_accesses_the_v" title="Example 8-2. The code inside the block accesses the variable str from the surrounding code.">Example 8-2</a> to access the <code class="literal">str2</code> variable from the parent scope.</p></div><div class="sect2" title="Borrowing an Idea from 1975"><div class="titlepage"><div><div><h2 class="title"><a id="borrowing_an_idea_from_1975"/>Borrowing an Idea from 1975</h2></div></div></div><p>So far we’ve seen that Ruby’s <code class="literal">rb_block_t</code> structure contains two important values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A pointer to a snippet of YARV code instructions—the <code class="literal">iseq</code> pointer</p></li><li class="listitem"><p>A pointer to a location on YARV’s internal stack, the location that was at the top of the stack when the block was created—the <code class="literal">EP</code> pointer</p></li></ul></div><p><a class="xref" href="ch08.html#so_far_weapostropheve_seen_that_ruby_blo" title="Figure 8-7. So far we’ve seen that Ruby blocks contain a pointer to a YARV instruction snippet and a location on the YARV stack.">Figure 8-7</a> shows these two values in the <code class="literal">rb_block_t</code> structure.</p><div class="figure"><a id="so_far_weapostropheve_seen_that_ruby_blo"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00185"/><img alt="So far we’ve seen that Ruby blocks contain a pointer to a YARV instruction snippet and a location on the YARV stack." src="httpatomoreillycomsourcenostarchimages1854187.png.jpg"/></div></div><p class="title">Figure 8-7. So far we’ve seen that Ruby blocks contain a pointer to a YARV instruction snippet and a location on the YARV stack.</p></div><p><a class="indexterm" id="iddle1167"/><a class="indexterm" id="iddle1244"/><a class="indexterm" id="iddle1248"/><a class="indexterm" id="iddle1252"/><a class="indexterm" id="iddle1525"/><a class="indexterm" id="iddle1544"/><a class="indexterm" id="iddle1797"/><a class="indexterm" id="iddle1860"/><a class="indexterm" id="iddle1896"/><a class="indexterm" id="iddle1966"/><a class="indexterm" id="iddle2019"/><a class="indexterm" id="iddle2035"/>We also saw that Ruby uses the <code class="literal">EP</code> when a block accesses values from the surrounding code. At first, this seems like a very technical, unimportant detail. This is obviously a behavior we expect Ruby blocks to exhibit, and the <code class="literal">EP</code> seems to be a minor, uninteresting part of Ruby’s internal implementation of blocks. Or is it?</p><div class="informalfigure"><a id="med_id00186a"/><div class="mediaobject"><a id="med_id00186"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1854189.png.jpg"/><div class="caption"><p><span class="emphasis"><em>The IBM 704, above, was the first computer to run Lisp, in the early 1960s. (Credit: NASA)</em></span></p></div></div></div><p>The <code class="literal">EP</code> is actually a profoundly important part of Ruby internals. It’s the basis for Ruby’s implementation of <span class="emphasis"><em>closures</em></span>, the computer science concept introduced in Lisp long before Ruby was created in the 1990s. Here’s how Sussman and Steele defined the term <span class="emphasis"><em>closure</em></span> in 1975:</p><div class="blockquote"><blockquote class="blockquote"><p>In order to solve this problem we introduce the notion of a closure [11, 14] which is a data structure containing a lambda expression, and an environment to be used when that lambda expression is applied to arguments.<sup>[<a class="footnote" href="#ftn.ch08fn02" id="ch08fn02">2</a>]</sup></p></blockquote></div><p>They define a closure to be the combination of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A “lambda expression”—that is, a function that takes a set of arguments</p></li><li class="listitem"><p>An environment to be used when calling that lambda or function</p></li></ul></div><p><a class="indexterm" id="iddle1245"/><a class="indexterm" id="iddle1526"/><a class="indexterm" id="iddle1861"/><a class="indexterm" id="iddle1866"/><a class="indexterm" id="iddle1897"/><a class="indexterm" id="iddle2093"/>Let’s take another look at the internal <code class="literal">rb_block_t</code> structure, repeated for convenience in <a class="xref" href="ch08.html#blocks_are_the_combination_of_a_function" title="Figure 8-8. Blocks are the combination of a function and the environment to use when calling that function.">Figure 8-8</a>.</p><div class="figure"><a id="blocks_are_the_combination_of_a_function"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00187"/><img alt="Blocks are the combination of a function and the environment to use when calling that function." src="httpatomoreillycomsourcenostarchimages1854191.png.jpg"/></div></div><p class="title">Figure 8-8. Blocks are the combination of a function and the environment to use when calling that function.</p></div><p>This structure meets Sussman and Steele’s definition of a closure:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">iseq</code> is a pointer to a lambda expression—a function or code snippet.</p></li><li class="listitem"><p><code class="literal">EP</code> is a pointer to the environment to be used when calling that lambda or function—that is, a pointer to the surrounding stack frame.</p></li></ul></div><p>Following this train of thought, we can see that blocks are Ruby’s implementation of closures. Ironically, blocks—one of the features that makes Ruby so elegant and modern—are based on research and work done at least 20 years before the birth of Ruby!</p><div class="sidebar"><a id="rbunderscoreblockunderscoret_and_rbu"/><p class="title">The rb_block_t and rb_control_frame_t Structures</p><p>In Ruby 1.9 and later, you’ll find the definition of the <code class="literal">rb_block_t</code> structure in the <span class="emphasis"><em>vm_core.h</em></span> file, as shown in <a class="xref" href="ch08.html#definition_of_rbunderscoreblockunder" title="Example 8-3. The definition of rb_block_t from vm_core.h">Example 8-3</a>.</p><div class="example"><a id="definition_of_rbunderscoreblockunder"/><p class="title">Example 8-3. The definition of <code class="literal">rb_block_t</code> from <span class="emphasis"><em>vm_core.h</em></span></p><div class="example-contents"><pre class="programlisting">    typedef struct rb_block_struct {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>     VALUE self;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>     VALUE klass;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>     VALUE *ep;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>     rb_iseq_t *iseq;
<img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/>     VALUE proc;
    } rb_block_t;</pre></div></div><p><a class="indexterm" id="iddle1519"/><a class="indexterm" id="iddle1807"/><a class="indexterm" id="iddle1819"/><a class="indexterm" id="iddle1980"/>You can see the <code class="literal">iseq</code> <span class="inlinemediaobject"><a id="inline_id00276"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> and <code class="literal">ep</code> <span class="inlinemediaobject"><a id="inline_id00277"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> values described above, along with a few other values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">self</code> <span class="inlinemediaobject"><a id="inline_id00278"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>: The value the <code class="literal">self</code> pointer had when the block was first referred to is also an important part of the closure’s environment. Ruby executes block code inside the same object context that the code had outside the block.</p></li><li class="listitem"><p><code class="literal">klass</code> <span class="inlinemediaobject"><a id="inline_id00279"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>: Along with <code class="literal">self</code>, Ruby also keeps track of the class of the current object using this pointer.</p></li><li class="listitem"><p><code class="literal">proc</code> <span class="inlinemediaobject"><a id="inline_id00280"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span>: Ruby uses this value when it creates a proc object from a block. As we’ll see in the next section, procs and blocks are closely related.</p></li></ul></div><p>Right above the definition of <code class="literal">rb_block_t</code> in <span class="emphasis"><em>vm_core.h</em></span>, we see the definition of the <code class="literal">rb_control_frame_t</code> structure, as shown in <a class="xref" href="ch08.html#definition_of_rbunderscorecontrolund" title="Example 8-4. The definition of rb_control_frame_t from vm_core.h">Example 8-4</a>.</p><div class="example"><a id="definition_of_rbunderscorecontrolund"/><p class="title">Example 8-4. The definition of <code class="literal">rb_control_frame_t</code> from <span class="emphasis"><em>vm_core.h</em></span></p><div class="example-contents"><pre class="programlisting">    typedef struct rb_control_frame_struct {
        VALUE *pc;                  /* cfp[0] */
        VALUE *sp;                  /* cfp[1] */
        rb_iseq_t *iseq;            /* cfp[2] */
        VALUE flag;                 /* cfp[3] */
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>     VALUE self;                 /* cfp[4] / block[0] */
        VALUE klass;                /* cfp[5] / block[1] */
        VALUE *ep;                  /* cfp[6] / block[2] */
        rb_iseq_t *block_iseq;      /* cfp[7] / block[3] */
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>     VALUE proc;                 /* cfp[8] / block[4] */
        const rb_method_entry_t *me;/* cfp[9] */

    #if VM_DEBUG_BP_CHECK
        VALUE *bp_check;            /* cfp[10] */
    #endif
    } rb_control_frame_t;</pre></div></div><p>Notice that this C structure also contains the same values as the <code class="literal">rb_block_t</code> structure: everything from <code class="literal">self</code> at <span class="inlinemediaobject"><a id="inline_id00283"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> to <code class="literal">proc</code> at <span class="inlinemediaobject"><a id="inline_id00284"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. The fact that these two structures share the same values is one of the interesting, but confusing, optimizations Ruby uses internally to speed things up. Whenever you first refer to a block by passing it into a method call, Ruby needs to create a new <code class="literal">rb_block_t</code> structure and copy values such as the <code class="literal">EP</code> from the current <code class="literal">rb_control_frame_t</code> structure into it. However, because these two structures contain the same values in the same order (<code class="literal">rb_block_t</code> is a subset of <code class="literal">rb_control_frame_t</code>), Ruby can avoid creating a new <code class="literal">rb_block_t</code> structure and instead set the new block pointer to the common portion of the <code class="literal">rb_control_frame_t</code> structure. In other words, instead of allocating new memory to hold the new <code class="literal">rb_block_t</code> structure, Ruby simply passes a pointer to the middle of the <code class="literal">rb_control_frame_t</code> structure. By doing so, Ruby avoids unnecessary calls to <code class="literal">malloc</code> and speeds up the process of creating blocks.</p></div></div></div><div class="sect1" title="Experiment 8-1: Which Is Faster: A while Loop or Passing a Block to each?"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_8-1_which_is_faster_a_while_l"/>Experiment 8-1: Which Is Faster: A while Loop or Passing a Block to each?</h1></div></div></div><p><a class="indexterm" id="iddle1085"/><a class="indexterm" id="iddle1288"/><a class="indexterm" id="iddle1782"/><a class="indexterm" id="iddle2007"/><a class="indexterm" id="iddle2104"/>Ruby code containing blocks is often more elegant and succinct than the equivalent code in older languages, such as C. For example, in C we would write the simple <code class="literal">while</code> loop shown in <a class="xref" href="ch08.html#adding_up_1_through_10_in_c_using_a_whil" title="Example 8-5. Adding up 1 through 10 in C using a while loop">Example 8-5</a> to add up the numbers 1 through 10.</p><div class="example"><a id="adding_up_1_through_10_in_c_using_a_whil"/><p class="title">Example 8-5. Adding up 1 through 10 in C using a <code class="literal">while</code> loop</p><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;
main()
{
  int i, sum;
  i = 1;
  sum = 0;
  while (i &lt;= 10) {
    sum = sum + i;
    i++;
  }
  printf("Sum: %d\n", sum);
}</pre></div></div><p><a class="xref" href="ch08.html#adding_up_1_through_10_in_ruby_using_a_w" title="Example 8-6. Adding up 1 through 10 in Ruby using a while loop">Example 8-6</a> shows the same <code class="literal">while</code> loop in Ruby.</p><div class="example"><a id="adding_up_1_through_10_in_ruby_using_a_w"/><p class="title">Example 8-6. Adding up 1 through 10 in Ruby using a <code class="literal">while</code> loop</p><div class="example-contents"><pre class="programlisting">sum = 0
i = 1
while i &lt;= 10
  sum += i
  i += 1
end
puts "Sum: #{sum}"</pre></div></div><p>However, most Rubyists would write this code using a range object with a block, as shown in <a class="xref" href="ch08.html#adding_up_1_through_10_in_ruby_using_a_r" title="Example 8-7. Adding up 1 through 10 in Ruby using a range object and a block">Example 8-7</a>.</p><div class="example"><a id="adding_up_1_through_10_in_ruby_using_a_r"/><p class="title">Example 8-7. Adding up 1 through 10 in Ruby using a range object and a block</p><div class="example-contents"><pre class="programlisting">sum = 0
(1..10).each do |i|
  sum += i
end
puts "Sum: #{sum}"</pre></div></div><p>Aesthetics aside, is there any performance penalty for using a block here? Does Ruby slow down significantly in order to create the new <code class="literal">rb_block_t</code> structure, copy the <code class="literal">EP</code> value, and create new stack frames?</p><p>Well, I won’t benchmark the C code because clearly it will be faster than either option using Ruby. Instead, let’s measure how long it takes Ruby, using a simple <code class="literal">while</code> loop, to add up the integers 1 through 10 to obtain 55, as shown in <a class="xref" href="ch08.html#benchmarking_the_while_loop_left_parenth" title="Example 8-8. Benchmarking the while loop (while.rb)">Example 8-8</a>.</p><div class="example"><a id="benchmarking_the_while_loop_left_parenth"/><p class="title">Example 8-8. Benchmarking the <code class="literal">while</code> loop <span class="emphasis"><em>(while.rb)</em></span></p><div class="example-contents"><pre class="programlisting">require 'benchmark'
ITERATIONS = 1000000
Benchmark.bm do |bench|
  bench.report("iterating from 1 to 10, one million times") do
    ITERATIONS.times do
      sum = 0
      i = 1
      while i &lt;= 10
        sum += i
        i += 1
      end
    end
  end
end</pre></div></div><p>Here, I’m using the benchmark library to measure the time required to run the <code class="literal">while</code> loop one million times. Admittedly, I’m using a block to control the million iterations (<code class="literal">ITERATIONS.times do</code>), but I’ll use the same block in the next test as well. Using Ruby 2.0 on my laptop, I can run through this code in just under a half second:</p><a id="pro_id00055"/><pre class="programlisting">$ <span class="strong"><strong>ruby while.rb</strong></span>
      user     system      total        real
      iterating from 1 to 10, one million times  0.440000   0.000000
                                                 0.440000 (  0.445757)</pre><p>Now let’s measure the time required to run the code shown in <a class="xref" href="ch08.html#benchmarking_a_call_to_a_block_left_pare" title="Example 8-9. Benchmarking a call to a block (each.rb)">Example 8-9</a>, which uses <code class="literal">each</code> with a block.</p><div class="example"><a id="benchmarking_a_call_to_a_block_left_pare"/><p class="title">Example 8-9. Benchmarking a call to a block <span class="emphasis"><em>(each.rb)</em></span></p><div class="example-contents"><pre class="programlisting">require 'benchmark'
ITERATIONS = 1000000
Benchmark.bm do |bench|
  bench.report("iterating from 1 to 10, one million times") do
    ITERATIONS.times do
      sum = 0
      (1..10).each do |i|
        sum += i
      end
    end
  end
end</pre></div></div><p>This time it takes somewhat longer to run through the loop a million times, about 0.75 seconds:</p><a id="pro_id00056"/><pre class="programlisting">$ <span class="strong"><strong>ruby each.rb</strong></span>
      user     system      total        real
      iterating from 1 to 10, one million times  0.760000   0.000000
                                                 0.760000 (  0.765740)</pre><p>Ruby requires about 71 percent more time to call the block 10 times, compared to iterating through the simple <code class="literal">while</code> loop 10 times (see <a class="xref" href="ch08.html#ruby_2dot0_uses_71_percent_more_time_cal" title="Figure 8-9. Ruby 2.0 uses 71 percent more time calling a block vs. a simple while loop. The graph shows the time for one million iterations (in seconds).">Figure 8-9</a>).</p><div class="figure"><a id="ruby_2dot0_uses_71_percent_more_time_cal"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00188"/><img alt="Ruby 2.0 uses 71 percent more time calling a block vs. a simple while loop. The graph shows the time for one million iterations (in seconds)." src="httpatomoreillycomsourcenostarchimages1854193.png.jpg"/></div></div><p class="title">Figure 8-9. Ruby 2.0 uses 71 percent more time calling a block vs. a simple <code class="literal">while</code> loop. The graph shows the time for one million iterations (in seconds).</p></div><p>Using <code class="literal">each</code> is slower because internally the <code class="literal">Range#each</code> method has to call or yield to the block each time around the loop. This involves a fairly large amount of work. In order to yield to a block, Ruby first has to create a new <code class="literal">rb_block_t</code> structure for that block, setting the <code class="literal">EP</code> in the new block to the referencing environment and passing the block into the call to <code class="literal">each</code>. Then each time around the loop Ruby has to create a new stack frame on YARV’s internal stack, call the block’s code, and finally copy the <code class="literal">EP</code> from the block to the new stack frame. Running a simple <code class="literal">while</code> loop is faster because Ruby needs only to reset the <code class="literal">PC</code>, or program counter, each time around the loop. It never calls a method or creates a new stack frame or a new <code class="literal">rb_block_t</code> structure.</p><p>Seventy-one percent more time seems like a large performance penalty, and, depending on your work and the context of this <code class="literal">while</code> loop, it may or may not be important. If this loop were part of a time-sensitive, critical operation that your end users were waiting for, and if there weren’t other expensive operations inside the loop, it might be worth writing the iteration <a class="indexterm" id="iddle1295"/><a class="indexterm" id="iddle1302"/><a class="indexterm" id="iddle1527"/><a class="indexterm" id="iddle1836"/>using an old-fashioned C-style <code class="literal">while</code> loop. However, the performance of most Ruby applications, and certainly Ruby on Rails websites, is usually limited by database queries, network connections, and other factors, not by Ruby execution speed. It’s rare that Ruby’s execution speed has an immediate, direct impact on your application’s overall performance. (Of course, if you’re using a large framework, such as Ruby on Rails, then your Ruby code is a very small piece of a very large system. I imagine that Rails uses blocks and iterators many, many times while processing a simple HTTP request, apart from the Ruby code you write yourself.)</p></div><div class="sect1" title="Lambdas and Procs: Treating a Function as a First-Class Citizen"><div class="titlepage"><div><div><h1 class="title"><a id="lambdas_and_procs_treating_a_function_as"/>Lambdas and Procs: Treating a Function as a First-Class Citizen</h1></div></div></div><p>Now to look at a more convoluted way of printing the “quick brown fox” string to the console. <a class="xref" href="ch08.html#using_lambda_in_ruby" title="Example 8-10. Using lambda in Ruby">Example 8-10</a> shows an example of using <code class="literal">lambda</code>.</p><div class="example"><a id="using_lambda_in_ruby"/><p class="title">Example 8-10. Using <code class="literal">lambda</code> in Ruby</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> def message_function
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   str = "The quick brown fox"
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   lambda do |animal|
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>     puts "#{str} jumps over the lazy #{animal}."
      end
    end
<img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/> function_value = message_function
<img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/> function_value.call('dog')</pre></div></div><p>Let’s step through this code carefully. First, at <span class="inlinemediaobject"><a id="inline_id00291"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we define a method called <code class="literal">message_function</code>. Inside <code class="literal">message_function</code>, we create a local variable at <span class="inlinemediaobject"><a id="inline_id00292"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> called <code class="literal">str</code>. Next, at <span class="inlinemediaobject"><a id="inline_id00293"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> we call <code class="literal">lambda</code>, and pass it a block. Inside this block, at <span class="inlinemediaobject"><a id="inline_id00294"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span>, we print the “quick brown fox” string again. However, <code class="literal">message_function</code> won’t immediately display the string because it doesn’t actually call the block at <span class="inlinemediaobject"><a id="inline_id00295"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>. Instead, <code class="literal">lambda</code> returns the block we give it as a data value, which in turn is returned by <code class="literal">message_function</code>.</p><p>This is an example of “treating a function as a first-class citizen,” to paraphrase a commonly used computer science expression. Once the block is returned from <code class="literal">message_function</code>, we save it in the local variable <code class="literal">function_value</code> at <span class="inlinemediaobject"><a id="inline_id00296"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span> and then call it explicitly, using the <code class="literal">call</code> method at <span class="inlinemediaobject"><a id="inline_id00297"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/></span>. With the <code class="literal">lambda</code> keyword—or the equivalent <code class="literal">proc</code> keyword—Ruby allows you to convert a block into a data value in this way.</p><div class="figure"><a id="does_ruby_use_an_rbunderscorelambdaunder"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00189"/><img alt="Does Ruby use an rb_lambda_t C structure? And if so, what would it contain?" src="httpatomoreillycomsourcenostarchimages1854195.png.jpg"/></div></div><p class="title">Figure 8-10. Does Ruby use an <span class="emphasis"><em>rb_lambda_t</em></span> C structure? And if so, what would it contain?</p></div><p>I have lots of questions about <a class="xref" href="ch08.html#using_lambda_in_ruby" title="Example 8-10. Using lambda in Ruby">Example 8-10</a>. What happens when we call <code class="literal">lambda</code>? How does Ruby convert the block into a data value, and what does it mean to treat this block as a first-class citizen? Does <code class="literal">message_function</code> return an <code class="literal">rb_block_t</code> structure directly, or does it return an <code class="literal">rb_lambda_t</code> structure? And what information would <code class="literal">rb_lambda_t</code> contain (see <a class="xref" href="ch08.html#does_ruby_use_an_rbunderscorelambdaunder" title="Figure 8-10. Does Ruby use an rb_lambda_t C structure? And if so, what would it contain?">Figure 8-10</a>)?</p><div class="sect2" title="Stack vs. Heap Memory"><div class="titlepage"><div><div><h2 class="title"><a id="stack_vsdot_heap_memory"/>Stack vs. Heap Memory</h2></div></div></div><p><a class="indexterm" id="iddle1398"/><a class="indexterm" id="iddle1830"/><a class="indexterm" id="iddle1963"/><a class="indexterm" id="iddle2012"/><a class="indexterm" id="iddle2026"/><a class="indexterm" id="iddle2069"/><a class="indexterm" id="iddle2078"/>Before we can answer these questions, we need to take a closer look at how Ruby saves your data. Internally, Ruby saves your data in two places: on the <span class="emphasis"><em>stack</em></span> or in the <span class="emphasis"><em>heap</em></span>.</p><p>We’ve seen the <span class="emphasis"><em>stack</em></span> before. This is where Ruby saves local variables, return values, and arguments for each of the methods in your program. Values on the stack are valid only for as long as that method is running. When a method returns, YARV deletes its stack frame and all the values inside it.</p><p>Ruby uses the <span class="emphasis"><em>heap</em></span> to save information that you might need for a while, even after a particular method returns. Each value in the heap remains valid for as long as there is a reference to it. Once a value is no longer referred to by any variable or object in your program, Ruby’s garbage collection system deletes it, freeing its memory for other uses.</p><p>This scheme is not unique to Ruby. In fact, it’s used by many other programming languages, including Lisp and C. And remember, Ruby itself is a C program. YARV’s stack design is based on the way C programs use the stack, and Ruby’s heap uses the underlying C heap implementation.</p><p>The stack and heap differ in one other important aspect. Ruby saves only references to data on the stack—that is, the <code class="literal">VALUE</code> pointers. For simple integer values, symbols, and constants such as <code class="literal">nil</code>, <code class="literal">true</code>, or <code class="literal">false</code>, the reference is the actual value. However, for all other data types, the <code class="literal">VALUE</code> is a pointer to a C structure containing the actual data, such as <code class="literal">RObject</code>. If only the <code class="literal">VALUE</code> references go on the stack, where does Ruby save the structures? In the heap. Let’s look at an example to understand this better.</p></div><div class="sect2" title="A Closer Look at How Ruby Saves a String Value"><div class="titlepage"><div><div><h2 class="title"><a id="closer_look_at_how_ruby_saves_a_string"/>A Closer Look at How Ruby Saves a String Value</h2></div></div></div><p>Let’s look in detail at how Ruby handles the string value <code class="literal">str</code> from <a class="xref" href="ch08.html#using_lambda_in_ruby" title="Example 8-10. Using lambda in Ruby">Example 8-10</a>. First, imagine YARV has a stack frame for the outer scope but has yet to call <code class="literal">message_function</code>. <a class="xref" href="ch08.html#to_execute_the_code_in_listing_8-11comma" title="Figure 8-11. To execute the code in Example 8-11, Ruby starts with an initial stack frame.">Figure 8-11</a> shows this initial stack frame.</p><div class="figure"><a id="to_execute_the_code_in_listing_8-11comma"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00190"/><img alt="To execute the code in , Ruby starts with an initial stack frame." src="httpatomoreillycomsourcenostarchimages1854197.png.jpg"/></div></div><p class="title">Figure 8-11. To execute the code in <a class="xref" href="ch08.html#this_code_doesnapostrophet_call_lambdado" title="Example 8-11. This code doesn’t call lambda.">Example 8-11</a>, Ruby starts with an initial stack frame.</p></div><p>In this figure you can see YARV’s internal stack on the left and the <code class="literal">rb_control_frame_t</code> structure on the right. Now suppose Ruby executes the <code class="literal">message_function</code> function call shown at <span class="inlinemediaobject"><a id="inline_id00298"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span> in <a class="xref" href="ch08.html#using_lambda_in_ruby" title="Example 8-10. Using lambda in Ruby">Example 8-10</a>. <a class="xref" href="ch08.html#ruby_creates_a_second_stack_frame_when_c" title="Figure 8-12. Ruby creates a second stack frame when calling message_function.">Figure 8-12</a> shows what happens next.</p><div class="figure"><a id="ruby_creates_a_second_stack_frame_when_c"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00191"/><img alt="Ruby creates a second stack frame when calling message_function." src="httpatomoreillycomsourcenostarchimages1854199.png.jpg"/></div></div><p class="title">Figure 8-12. Ruby creates a second stack frame when calling <code class="literal">message_function</code>.</p></div><p><a class="indexterm" id="iddle1187"/><a class="indexterm" id="iddle1204"/><a class="indexterm" id="iddle1306"/><a class="indexterm" id="iddle1309"/><a class="indexterm" id="iddle1314"/><a class="indexterm" id="iddle1321"/><a class="indexterm" id="iddle1326"/><a class="indexterm" id="iddle1341"/><a class="indexterm" id="iddle1345"/><a class="indexterm" id="iddle1566"/><a class="indexterm" id="iddle1925"/><a class="indexterm" id="iddle2013"/>Ruby saves the <code class="literal">str</code> local variable in the new stack frame used by <code class="literal">message_function</code>. Let’s take a closer look at that <code class="literal">str</code> variable and how Ruby stores the “quick brown fox” string into it. Ruby stores each of your objects in a C structure called <code class="literal">RObject</code>, each of your arrays in a structure called <code class="literal">RArray</code>, each of your strings in a structure called <code class="literal">RString</code>, and so on. <a class="xref" href="ch08.html#ruby_uses_the_rstring_c_structure_to_sav" title="Figure 8-13. Ruby uses the RString C structure to save string values.">Figure 8-13</a> shows the “quick brown fox” string saved with <code class="literal">RString</code>.</p><div class="figure"><a id="ruby_uses_the_rstring_c_structure_to_sav"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00192"/><img alt="Ruby uses the RString C structure to save string values." src="httpatomoreillycomsourcenostarchimages1854201.png.jpg"/></div></div><p class="title">Figure 8-13. Ruby uses the <code class="literal">RString</code> C structure to save string values.</p></div><p>The actual string structure is shown on the right side of the figure, and a reference, or pointer, to the string is shown on the left. When Ruby saves a string value (or any object) onto the YARV stack, it actually places only the reference to the string on the stack. The actual string structure is saved in the heap instead, as shown in <a class="xref" href="ch08.html#str_value_on_the_stack_is_a_referenc" title="Figure 8-14. The str value on the stack is a reference to the RString structure saved in the heap.">Figure 8-14</a> on the next page.</p><p>Once there are no longer any pointers referencing a particular object or value in the heap, Ruby frees that object or value during the next run of the garbage collection system. To demonstrate, suppose that my example code didn’t call <code class="literal">lambda</code> at all but rather immediately returned <code class="literal">nil</code> after saving the <code class="literal">str</code> variable, as shown in <a class="xref" href="ch08.html#this_code_doesnapostrophet_call_lambdado" title="Example 8-11. This code doesn’t call lambda.">Example 8-11</a>.</p><div class="example"><a id="this_code_doesnapostrophet_call_lambdado"/><p class="title">Example 8-11. This code doesn’t call <code class="literal">lambda</code>.</p><div class="example-contents"><pre class="programlisting">def message_function
  str = "The quick brown fox"
  nil
end</pre></div></div><div class="figure"><a id="str_value_on_the_stack_is_a_referenc"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00193"/><img alt="The str value on the stack is a reference to the RString structure saved in the heap." src="httpatomoreillycomsourcenostarchimages1854203.png.jpg"/></div></div><p class="title">Figure 8-14. The <code class="literal">str</code> value on the stack is a reference to the <code class="literal">RString</code> structure saved in the heap.</p></div><p><a class="indexterm" id="iddle1926"/>Once this call to <code class="literal">message_function</code> finishes, YARV simply pops the <code class="literal">str</code> value off the stack (as well as any other temporary values saved there) and returns to the original stack frame, as shown in <a class="xref" href="ch08.html#now_there_is_no_longer_a_reference_to_th" title="Figure 8-15. Now there is no longer a reference to the RString structure.">Figure 8-15</a>.</p><div class="figure"><a id="now_there_is_no_longer_a_reference_to_th"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00194"/><img alt="Now there is no longer a reference to the RString structure." src="httpatomoreillycomsourcenostarchimages1854205.png.jpg"/></div></div><p class="title">Figure 8-15. Now there is no longer a reference to the <code class="literal">RString</code> structure.</p></div><p><a class="indexterm" id="iddle1214"/><a class="indexterm" id="iddle1307"/><a class="indexterm" id="iddle1333"/><a class="indexterm" id="iddle1529"/>As you can see in the figure, there is no longer a reference to the <code class="literal">RString</code> structure containing the “quick brown fox” string. Ruby’s garbage collection system is designed to identify values in the heap that don’t have any references to them, like the “quick brown fox” string here. After it identifies them, the GC system will free those orphaned values, returning that memory to the heap.</p></div><div class="sect2" title="How Ruby Creates a Lambda"><div class="titlepage"><div><div><h2 class="title"><a id="how_ruby_creates_a_lambda"/>How Ruby Creates a Lambda</h2></div></div></div><p>Now that we understand a bit more about the heap and how Ruby uses it, we’re ready to learn more about lambdas. Earlier when I used the phrase “treating a function as a first-class citizen,” I meant that Ruby allows you to treat functions or code as a data value, saving them into variables, passing them as arguments, and so on. Ruby implements this idea using blocks.</p><p>The <code class="literal">lambda</code> (or <code class="literal">proc</code>) keyword converts a block into a data value. But remember, blocks are Ruby’s implementation of closures. This means the new data value must somehow contain both the block’s code and referencing environment.</p><p>To see what I mean, let’s return to <a class="xref" href="ch08.html#using_lambda_in_ruby" title="Example 8-10. Using lambda in Ruby">Example 8-10</a>, repeated here in <a class="xref" href="ch08.html#using_lambda_in_ruby_left_parenthesisrep" title="Example 8-12. Using lambda in Ruby (repeated from Example 8-10)">Example 8-12</a> with an eye toward its use of <code class="literal">lambda</code>.</p><div class="example"><a id="using_lambda_in_ruby_left_parenthesisrep"/><p class="title">Example 8-12. Using <code class="literal">lambda</code> in Ruby (repeated from <a class="xref" href="ch08.html#using_lambda_in_ruby" title="Example 8-10. Using lambda in Ruby">Example 8-10</a>)</p><div class="example-contents"><pre class="programlisting">    def message_function
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   str = "The quick brown fox"
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   lambda do |animal|
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>     puts "#{str} jumps over the lazy #{animal}."
      end
    end
    function_value = message_function
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/> function_value.call('dog')</pre></div></div><p>Notice at <span class="inlinemediaobject"><a id="inline_id00303"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> that when we call the lambda (the block), the <code class="literal">puts</code> statement inside the block at <span class="inlinemediaobject"><a id="inline_id00304"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> can access the <code class="literal">str</code> string variable defined at <span class="inlinemediaobject"><a id="inline_id00305"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> inside <code class="literal">message_function</code>. How can this be? We’ve just seen how the <code class="literal">str</code> reference to the <code class="literal">RString</code> structure is popped off the stack when <code class="literal">message_function</code> returns! Obviously, after calling <code class="literal">lambda</code>, the value of <code class="literal">str</code> lives on so that the block can access it later.</p><p>When you call <code class="literal">lambda</code>, Ruby copies the entire contents of the current YARV stack frame into the heap, where the <code class="literal">RString</code> structure is located. For example, <a class="xref" href="ch08.html#ruby_creates_a_second_stack_fram-id00030" title="Figure 8-16. Ruby creates a second stack frame when calling message_function.">Figure 8-16</a> shows how the YARV stack looks just after the <code class="literal">message_function</code> starts at <span class="inlinemediaobject"><a id="inline_id00306"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> in <a class="xref" href="ch08.html#using_lambda_in_ruby_left_parenthesisrep" title="Example 8-12. Using lambda in Ruby (repeated from Example 8-10)">Example 8-12</a>. (To keep things simple, I’m not showing the <code class="literal">RString</code> structure, but remember that the <code class="literal">RString</code> structure will also be saved in the heap.)</p><div class="figure"><a id="ruby_creates_a_second_stack_fram-id00030"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00195"/><img alt="Ruby creates a second stack frame when calling message_function." src="httpatomoreillycomsourcenostarchimages1854207.png.jpg"/></div></div><p class="title">Figure 8-16. Ruby creates a second stack frame when calling <code class="literal">message_function</code>.</p></div><p><a class="indexterm" id="iddle1071"/><a class="indexterm" id="iddle1125"/><a class="indexterm" id="iddle1202"/><a class="indexterm" id="iddle1837"/><a class="indexterm" id="iddle1867"/><a class="indexterm" id="iddle1871"/>Next, <a class="xref" href="ch08.html#using_lambda_in_ruby_left_parenthesisrep" title="Example 8-12. Using lambda in Ruby (repeated from Example 8-10)">Example 8-12</a> calls <code class="literal">lambda</code> at <span class="inlinemediaobject"><a id="inline_id00307"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. <a class="xref" href="ch08.html#when_you_call_lambdacomma_ruby_copies_th" title="Figure 8-17. When you call lambda, Ruby copies the current stack frame to the heap.">Figure 8-17</a> shows what happens in Ruby when you call <code class="literal">lambda</code>.</p><p>The horizontal stack icon below the dotted line shows that Ruby creates a new copy of the stack frame for <code class="literal">message_function</code> in the heap. Now there is a second reference to the <code class="literal">str RString</code> structure, which means that Ruby won’t free it when <code class="literal">message_function</code> returns.</p><p>In fact, along with the copy of the stack frame, Ruby creates two other new objects in the heap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An internal environment object, represented by the <code class="literal">rb_env_t</code> C structure at the lower left of the figure. It’s essentially a wrapper for the heap copy of the stack. As we’ll see in <a class="xref" href="ch09.html" title="Chapter 9. Metaprogramming">Chapter 9</a>, you can access this environment object indirectly in your programs using the <code class="literal">Binding</code> class.</p></li><li class="listitem"><p>A Ruby proc object, represented by the <code class="literal">rb_proc_t</code> structure. This is the actual return value from the <code class="literal">lambda</code> keyword; it’s what the <code class="literal">message_function</code> function returns.</p></li></ul></div><p>Note that the new proc object, the <code class="literal">rb_proc_t</code> structure, contains an <code class="literal">rb_block_t</code> structure, including the <code class="literal">iseq</code> and <code class="literal">EP</code> pointers. Think of a proc as a kind of Ruby object that wraps up a block. As with a normal block, these keep track of the block’s code and the referencing environment for its closure. Ruby sets the <code class="literal">EP</code> in this block to point to the new heap copy of the stack frame.</p><p>Also, notice that the proc object contains an internal value called <code class="literal">is_lambda</code>. This is set to <code class="literal">true</code> for this example because we used the <code class="literal">lambda</code> keyword to create the proc. If I had instead created the proc using the <code class="literal">proc</code> keyword, or simply by calling <code class="literal">Proc.new</code>, then <code class="literal">is_lambda</code> would have been set to <code class="literal">false</code>. Ruby uses this flag to produce the slight behavior differences between procs and lambdas, though it’s best to think of procs and lambdas as essentially the same.</p><div class="figure"><a id="when_you_call_lambdacomma_ruby_copies_th"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00196"/><img alt="When you call lambda, Ruby copies the current stack frame to the heap." src="httpatomoreillycomsourcenostarchimages1854209.png.jpg"/></div></div><p class="title">Figure 8-17. When you call <code class="literal">lambda</code>, Ruby copies the current stack frame to the heap.</p></div></div><div class="sect2" title="How Ruby Calls a Lambda"><div class="titlepage"><div><div><h2 class="title"><a id="how_ruby_calls_a_lambda"/>How Ruby Calls a Lambda</h2></div></div></div><p><a class="indexterm" id="iddle1107"/><a class="indexterm" id="iddle1203"/><a class="indexterm" id="iddle1528"/><a class="indexterm" id="iddle1868"/><a class="indexterm" id="iddle1872"/><a class="indexterm" id="iddle2014"/>Let’s go back to our lambda example in <a class="xref" href="ch08.html#using_lambda_in_ruby_left_parent-id00031" title="Example 8-13. Using lambda in Ruby (repeated again from Example 8-10)">Example 8-13</a>.</p><div class="example"><a id="using_lambda_in_ruby_left_parent-id00031"/><p class="title">Example 8-13. Using <code class="literal">lambda</code> in Ruby (repeated again from <a class="xref" href="ch08.html#using_lambda_in_ruby" title="Example 8-10. Using lambda in Ruby">Example 8-10</a>)</p><div class="example-contents"><pre class="programlisting">    def message_function
      str = "The quick brown fox"
      lambda do |animal|
        puts "#{str} jumps over the lazy #{animal}."
      end
    end
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> function_value = message_function
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> function_value.call('dog')</pre></div></div><p>What happens when <code class="literal">message_function</code> returns at <span class="inlinemediaobject"><a id="inline_id00310"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>? Because the lambda or proc object is its return value, a reference to the lambda is saved in the stack frame for the outer scope in the <code class="literal">function_value</code> local variable. This prevents Ruby from freeing the proc, the internal environment object, and the <code class="literal">str</code> variable, and there are now pointers referring to all of these values in the heap (see <a class="xref" href="ch08.html#once_messageunderscorefunction_returnsco" title="Figure 8-18. Once message_function returns, the surrounding code holds a reference to the proc object.">Figure 8-18</a>).</p><div class="figure"><a id="once_messageunderscorefunction_returnsco"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00197"/><img alt="Once message_function returns, the surrounding code holds a reference to the proc object." src="httpatomoreillycomsourcenostarchimages1854211.png.jpg"/></div></div><p class="title">Figure 8-18. Once <code class="literal">message_function</code> returns, the surrounding code holds a reference to the proc object.</p></div><p>When Ruby executes the <code class="literal">call</code> method on the proc object at <span class="inlinemediaobject"><a id="inline_id00311"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>, it executes its block as well. <a class="xref" href="ch08.html#calling_a_proc_object_creates_a_new_stac" title="Figure 8-19. Calling a proc object creates a new stack frame as usual and sets the EP to point to the heap’s referencing environment.">Figure 8-19</a> shows what happens in Ruby when you use the <code class="literal">call</code> method on a lambda or proc.</p><p>As with any block, when Ruby calls the block inside a proc object it creates a new stack frame and sets the <code class="literal">EP</code> to the block’s referencing environment. However, that environment is a copy of a stack frame previously copied into the heap; the new stack frame contains an <code class="literal">EP</code> that points to the heap. This <code class="literal">EP</code> allows the block’s call to <code class="literal">puts</code> to access the <code class="literal">str</code> value defined in <code class="literal">message_function</code>. <a class="xref" href="ch08.html#calling_a_proc_object_creates_a_new_stac" title="Figure 8-19. Calling a proc object creates a new stack frame as usual and sets the EP to point to the heap’s referencing environment.">Figure 8-19</a> shows the argument to the proc, <code class="literal">animal</code>, saved in the new stack frame, like any other method or block argument.</p><div class="figure"><a id="calling_a_proc_object_creates_a_new_stac"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00198"/><img alt="Calling a proc object creates a new stack frame as usual and sets the EP to point to the heap’s referencing environment." src="httpatomoreillycomsourcenostarchimages1854213.png.jpg"/></div></div><p class="title">Figure 8-19. Calling a proc object creates a new stack frame as usual and sets the <code class="literal">EP</code> to point to the heap’s referencing environment.</p></div></div><div class="sect2" title="The Proc Object"><div class="titlepage"><div><div><h2 class="title"><a id="proc_object"/>The Proc Object</h2></div></div></div><p><a class="indexterm" id="iddle1140"/><a class="indexterm" id="iddle1835"/><a class="indexterm" id="iddle1838"/>We’ve seen that Ruby really has no structure called <code class="literal">rb_lambda_t</code>. In other words, the structure shown in <a class="xref" href="ch08.html#ruby_doesnapostrophet_actually_use_a_str" title="Figure 8-20. Ruby doesn’t actually use a structure called rb_lambda_t.">Figure 8-20</a> doesn’t actually exist.</p><div class="figure"><a id="ruby_doesnapostrophet_actually_use_a_str"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00199"/><img alt="Ruby doesn’t actually use a structure called rb_lambda_t." src="httpatomoreillycomsourcenostarchimages1854215.png.jpg"/></div></div><p class="title">Figure 8-20. Ruby doesn’t actually use a structure called <code class="literal">rb_lambda_t</code>.</p></div><p><a class="indexterm" id="iddle1873"/><a class="indexterm" id="iddle1928"/>Instead, in this example, Ruby’s <code class="literal">lambda</code> keyword created a proc object—really, a wrapper for the block we passed to the <code class="literal">lambda</code> or <code class="literal">proc</code> keyword. Ruby represents procs using an <code class="literal">rb_proc_t</code> C structure, as you can see in <a class="xref" href="ch08.html#ruby_procs_are_closuressemicolon_they_co" title="Figure 8-21. Ruby procs are closures; they contain pointers to a function and a referencing environment.">Figure 8-21</a>.</p><div class="figure"><a id="ruby_procs_are_closuressemicolon_they_co"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00200"/><img alt="Ruby procs are closures; they contain pointers to a function and a referencing environment." src="httpatomoreillycomsourcenostarchimages1854217.png.jpg"/></div></div><p class="title">Figure 8-21. Ruby procs are closures; they contain pointers to a function and a referencing environment.</p></div><p>This is a closure: It contains a function along with the environment that function was referred to or created in. The environment is a persistent copy of the stack frame saved in the heap.</p><p>A proc is a Ruby object. It contains the same information as other objects, including the <code class="literal">RBasic</code> structure. To save its object-related information, Ruby uses a structure called <code class="literal">RTypedData</code>, along with <code class="literal">rb_proc_t</code>, to represent instances of the proc object. <a class="xref" href="ch08.html#ruby_saves_the_object-related_informatio" title="Figure 8-22. Ruby saves the object-related information about proc objects in the RTypedData structure.">Figure 8-22</a> shows how these structures work together.</p><p>You might think of <code class="literal">RTypedData</code> as a kind of trick that Ruby’s C code uses to create a Ruby object wrapper around a C data structure. In this case, Ruby uses <code class="literal">RTypedData</code> to create an instance of the <code class="literal">Proc</code> Ruby class that represents a single copy of the <code class="literal">rb_proc_t</code> structure. The <code class="literal">RTypedData</code> structure contains the same <code class="literal">RBasic</code> information as all Ruby objects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="flags"><span class="title"><strong><span class="strong"><strong><code class="literal">flags</code></strong></span></strong></span>. Certain internal technical information Ruby needs to track</p></li><li class="listitem"><p title="klass"><span class="title"><strong><span class="strong"><strong><code class="literal">klass</code></strong></span></strong></span>. A pointer to the Ruby class that the object is an instance of; the <code class="literal">Proc</code> class in this example</p></li></ul></div><div class="figure"><a id="ruby_saves_the_object-related_informatio"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00201"/><img alt="Ruby saves the object-related information about proc objects in the RTypedData structure." src="httpatomoreillycomsourcenostarchimages1854219.png.jpg"/></div></div><p class="title">Figure 8-22. Ruby saves the object-related information about proc objects in the <code class="literal">RTypedData</code> structure.</p></div><p><a class="xref" href="ch08.html#comparing_a_ruby_string_with_a_proc" title="Figure 8-23. Comparing a Ruby string with a proc">Figure 8-23</a> takes another look at how Ruby represents a proc object. The proc object is on the right next to an <code class="literal">RString</code> structure.</p><p>Notice that Ruby handles the string value and the proc similarly. As with strings, procs can be saved into variables or passed as arguments to a function call. Ruby uses the <code class="literal">VALUE</code> pointer to the proc whenever you refer to one or save one into a variable.</p><div class="figure"><a id="comparing_a_ruby_string_with_a_proc"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00202"/><img alt="Comparing a Ruby string with a proc" src="httpatomoreillycomsourcenostarchimages1854221.png.jpg"/></div></div><p class="title">Figure 8-23. Comparing a Ruby string with a proc</p></div></div></div><div class="sect1" title="Experiment 8-2: Changing Local Variables After Calling lambda"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_8-2_changing_local_variables"/>Experiment 8-2: Changing Local Variables After Calling lambda</h1></div></div></div><p><a class="indexterm" id="iddle1280"/><a class="indexterm" id="iddle1508"/><a class="indexterm" id="iddle1524"/><a class="indexterm" id="iddle1555"/><a class="indexterm" id="iddle2089"/><a class="xref" href="ch08.html#using_lambda_in_ruby" title="Example 8-10. Using lambda in Ruby">Example 8-10</a> through <a class="xref" href="ch08.html#using_lambda_in_ruby_left_parent-id00031" title="Example 8-13. Using lambda in Ruby (repeated again from Example 8-10)">Example 8-13</a> show how calling <code class="literal">lambda</code> copies the current stack frame in the heap. Now for a slightly different example. <a class="xref" href="ch08.html#which_version_of_str_will_lambda_copy_to" title="Example 8-14. Which version of str will lambda copy to the heap (modify_after_lambda.rb)?">Example 8-14</a> is basically the same, except that the line at <span class="inlinemediaobject"><a id="inline_id00312"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> changes <code class="literal">str</code> after calling <code class="literal">lambda</code>.</p><div class="example"><a id="which_version_of_str_will_lambda_copy_to"/><p class="title">Example 8-14. Which version of <code class="literal">str</code> will <code class="literal">lambda</code> copy to the heap <span class="emphasis"><em>(modify_after_lambda.rb)</em></span>?</p><div class="example-contents"><pre class="programlisting">    def message_function
      str = "The quick brown fox"
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   func = lambda do |animal|
        puts "#{str} jumps over the lazy #{animal}."
      end
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   str = "The sly brown fox"
      func
    end
    function_value = message_function
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/> function_value.call('dog')</pre></div></div><p>Because we call <code class="literal">lambda</code> at <span class="inlinemediaobject"><a id="inline_id00316"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> before changing <code class="literal">str</code> to <code class="literal">The sly brown fox</code> at <span class="inlinemediaobject"><a id="inline_id00317"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>, Ruby should have copied the stack frame to the heap, including the original value of <code class="literal">str</code>. That means that when we call the lambda at <span class="inlinemediaobject"><a id="inline_id00318"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>, we should see the original “quick brown fox” string. However, running the code, we get the following:</p><a id="pro_id00057"/><pre class="programlisting">$ <span class="strong"><strong>ruby modify_after_lambda.rb</strong></span>
The sly brown fox jumps over the lazy dog.</pre><p>What happened? Ruby somehow copied the new value of <code class="literal">str</code>, <code class="literal">The sly brown fox</code>, to the heap so we could access it when we called the lambda at <span class="inlinemediaobject"><a id="inline_id00319"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>.</p><p>To find out how Ruby did this, let’s look more closely at what happens when you call <code class="literal">lambda</code>. <a class="xref" href="ch08.html#when_you_call_lambdacomma_ruby_c-id00032" title="Figure 8-24. When you call lambda, Ruby copies the stack frame to the heap.">Figure 8-24</a> shows how Ruby copies the stack frame to the heap, including the value <code class="literal">str</code> from <a class="xref" href="ch08.html#which_version_of_str_will_lambda_copy_to" title="Example 8-14. Which version of str will lambda copy to the heap (modify_after_lambda.rb)?">Example 8-14</a>.</p><div class="figure"><a id="when_you_call_lambdacomma_ruby_c-id00032"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00203"/><img alt="When you call lambda, Ruby copies the stack frame to the heap." src="httpatomoreillycomsourcenostarchimages1854223.png.jpg"/></div></div><p class="title">Figure 8-24. When you call <code class="literal">lambda</code>, Ruby copies the stack frame to the heap.</p></div><p>Once this copy is made, the code at <span class="inlinemediaobject"><a id="inline_id00320"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> in <a class="xref" href="ch08.html#which_version_of_str_will_lambda_copy_to" title="Example 8-14. Which version of str will lambda copy to the heap (modify_after_lambda.rb)?">Example 8-14</a> changes <code class="literal">str</code> to the “sly fox” string:</p><a id="pro_id00058"/><pre class="programlisting">str = "The sly brown fox"</pre><p>Because Ruby copied the stack frame when we called <code class="literal">lambda</code>, we should be modifying the original copy of <code class="literal">str</code>, not the new lambda copy (see <a class="xref" href="ch08.html#does_ruby_continue_to_use_the_original_s" title="Figure 8-25. Does Ruby continue to use the original stack frame after making a heap copy?">Figure 8-25</a>).</p><div class="figure"><a id="does_ruby_continue_to_use_the_original_s"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00204"/><img alt="Does Ruby continue to use the original stack frame after making a heap copy?" src="httpatomoreillycomsourcenostarchimages1854225.png.jpg"/></div></div><p class="title">Figure 8-25. Does Ruby continue to use the original stack frame after making a heap copy?</p></div><p>The new heap copy of the string should have remained unmodified, and calling the lambda later should have given the original “quick fox” string, not the modified “sly fox” one. How does Ruby allow us to modify the new persistent copy of the stack once it’s been created by <code class="literal">lambda</code>?</p><p>As it turns out, once Ruby creates the new heap copy of the stack (the new <code class="literal">rb_env_t</code> structure or internal environment object), it resets the <code class="literal">EP</code> in the <code class="literal">rb_control_frame_t</code> structure to point to the copy. <a class="xref" href="ch08.html#ruby_resets_the_ep_after_creating_a_pers" title="Figure 8-26. Ruby resets the EP after creating a persistent heap copy of a stack frame.">Figure 8-26</a> shows how Ruby resets the <code class="literal">EP</code> after creating a persistent heap copy of a stack frame.</p><div class="figure"><a id="ruby_resets_the_ep_after_creating_a_pers"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00205"/><img alt="Ruby resets the EP after creating a persistent heap copy of a stack frame." src="httpatomoreillycomsourcenostarchimages1854227.png.jpg"/></div></div><p class="title">Figure 8-26. Ruby resets the <code class="literal">EP</code> after creating a persistent heap copy of a stack frame.</p></div><p><a class="indexterm" id="iddle1106"/><a class="indexterm" id="iddle1507"/><a class="indexterm" id="iddle1523"/>The difference here is that the <code class="literal">EP</code> now points down to the heap. Now when we call <code class="literal">str = "The sly brown fox"</code> at in <a class="xref" href="ch08.html#which_version_of_str_will_lambda_copy_to" title="Example 8-14. Which version of str will lambda copy to the heap (modify_after_lambda.rb)?">Example 8-14</a>, Ruby will use the new <code class="literal">EP</code> and access the value in the heap, not the original value on the stack. Notice <code class="literal">The sly brown fox</code> appears in the heap at the bottom of <a class="xref" href="ch08.html#ruby_resets_the_ep_after_creating_a_pers" title="Figure 8-26. Ruby resets the EP after creating a persistent heap copy of a stack frame.">Figure 8-26</a>.</p><div class="sect2" title="Calling lambda More Than Once in the Same Scope"><div class="titlepage"><div><div><h2 class="title"><a id="calling_lambda_more_than_once_in_the_sam"/>Calling lambda More Than Once in the Same Scope</h2></div></div></div><p>Another interesting behavior of the <code class="literal">lambda</code> keyword is that Ruby avoids making copies of the stack frame more than once, as you can see in <a class="xref" href="ch08.html#calling_lambda_twice_in_the_same_scope" title="Example 8-15. Calling lambda twice in the same scope">Example 8-15</a>.</p><div class="example"><a id="calling_lambda_twice_in_the_same_scope"/><p class="title">Example 8-15. Calling <code class="literal">lambda</code> twice in the same scope</p><div class="example-contents"><pre class="programlisting">i = 0
increment_function = lambda do
  puts "Incrementing from #{i} to #{i+1}"
  i += 1
end
decrement_function = lambda do
  i -= 1
  puts "Decrementing from #{i+1} to #{i}"
end</pre></div></div><p>This code expects both lambda functions to operate on the local variable <code class="literal">i</code> in the main scope.</p><p>But if Ruby made a separate copy of the stack frame for each call to <code class="literal">lambda</code>, each function would operate on a separate copy of <code class="literal">i</code>. Look at the following example in <a class="xref" href="ch08.html#calling_the_lambdas_created_in_listing_8" title="Example 8-16. Calling the lambdas created in Example 8-15">Example 8-16</a>.</p><div class="example"><a id="calling_the_lambdas_created_in_listing_8"/><p class="title">Example 8-16. Calling the lambdas created in <a class="xref" href="ch08.html#calling_lambda_twice_in_the_same_scope" title="Example 8-15. Calling lambda twice in the same scope">Example 8-15</a></p><div class="example-contents"><pre class="programlisting">increment_function.call
decrement_function.call
increment_function.call
increment_function.call
decrement_function.call</pre></div></div><p>If Ruby used a separate copy of <code class="literal">i</code> for each lambda function, the previous listing would generate the output shown in <a class="xref" href="ch08.html#output_we_would_expect_if_each_call" title="Example 8-17. The output we would expect if each call to lambda created its own copy of the stack frame">Example 8-17</a>.</p><div class="example"><a id="output_we_would_expect_if_each_call"/><p class="title">Example 8-17. The output we would expect if each call to <code class="literal">lambda</code> created its own copy of the stack frame</p><div class="example-contents"><pre class="programlisting">Incrementing from 0 to 1
Decrementing from 0 to -1
Incrementing from 1 to 2
Incrementing from 2 to 3
Decrementing from -1 to -2</pre></div></div><p>But we actually see the output shown in <a class="xref" href="ch08.html#because_the_lambda_functions_share_the_s" title="Example 8-18. Because the lambda functions share the same heap copy of the stack, running Example 8-16 generates this output.">Example 8-18</a>.</p><div class="example"><a id="because_the_lambda_functions_share_the_s"/><p class="title">Example 8-18. Because the lambda functions share the same heap copy of the stack, running <a class="xref" href="ch08.html#calling_the_lambdas_created_in_listing_8" title="Example 8-16. Calling the lambdas created in Example 8-15">Example 8-16</a> generates this output.</p><div class="example-contents"><pre class="programlisting">Incrementing from 0 to 1
Decrementing from 1 to 0
Incrementing from 0 to 1
Incrementing from 1 to 2
Decrementing from 2 to 1</pre></div></div><p>Usually this is what you expect: Each block you pass to the lambdas accesses the same variable in the parent scope. Ruby achieves this by checking whether the <code class="literal">EP</code> already points to the heap. If so, as with the second call to <code class="literal">lambda</code> in <a class="xref" href="ch08.html#calling_lambda_twice_in_the_same_scope" title="Example 8-15. Calling lambda twice in the same scope">Example 8-15</a>, Ruby won’t create a second copy; it will simply reuse the same <code class="literal">rb_env_t</code> structure in the second <code class="literal">rb_proc_t</code> structure. Ultimately, both lambdas use the same heap copy of the stack.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00033"/>Summary</h1></div></div></div><p>In <a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a> we saw how YARV creates a new stack frame whenever you call a block, just as it does when you call a method. At first glance, Ruby blocks appear to be a special kind of method that you can call and pass arguments to. However, as we’ve seen in this chapter, there’s more to blocks than meets the eye.</p><p>Looking closely at the <code class="literal">rb_block_t</code> structure, we saw how blocks implement the computer science concept of <span class="emphasis"><em>closure</em></span> in Ruby. Blocks are the combination of a function and an environment to use when calling that function. We learned that blocks have a curious dual personality in Ruby: They are similar to methods, but they also become part of the method that you call them from. The simplicity with which Ruby’s syntax allows for this dual role is one of the language’s most beautiful and elegant features.</p><p>Later we saw how Ruby allows you to treat functions or code as first-class citizens using the <code class="literal">lambda</code> keyword, which converts a block into a data value that you can pass, save, and reuse. After reviewing the differences between stack and heap memory, we explored the way that Ruby implements lambdas and procs, and we saw that Ruby copies the stack frame to the heap when you call <code class="literal">lambda</code> or <code class="literal">proc</code> and reuses it when you call the lambda’s block. Finally, we saw how the proc object represents code as a data object in Ruby.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#ch08fn01" id="ftn.ch08fn01">1</a>] </sup>If the outer code was located inside a function or method, then the <code class="literal">EP</code> would point to the stack frame as shown. But if the outer code was located in the top-level scope of your Ruby program, then Ruby would use dynamic access to save the variable in the <code class="literal">TOPLEVEL_BINDING</code> environment instead. Regardless, the <code class="literal">EP</code> will always indicate the location of the <code class="literal">str</code> variable.</p></div><div class="footnote"><p><sup>[<a class="para" href="#ch08fn02" id="ftn.ch08fn02">2</a>] </sup>Gerald J. Sussman and Guy L. Steele, Jr., “Scheme: An Interpreter for Extended Lambda Calculus” (MIT Artificial Intelligence Laboratory, AI Memo No. 349, December 1975).</p></div></div></div></body></html>