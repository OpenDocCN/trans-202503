<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_273" aria-label="273"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch14">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">QUANTUM AND POST-QUANTUM</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">In this chapter, we’ll examine the future of cryptography over a time horizon of, say, a century or more—one in which quantum computers may exist. Quantum computers leverage phenomena from quantum physics to run different kinds of algorithms than we’re used to. While large quantum computers don’t exist yet, they have the potential to break RSA, Diffie–Hellman, and elliptic curve cryptography—all the public-key crypto deployed or standardized as of this writing.</p>&#13;
<p class="TX">To ensure against the quantum computing risk, cryptography researchers have developed alternative public-key <i>post-quantum</i> algorithms. In 2015, the NSA called for a transition to quantum-resistant algorithms, and in 2017 NIST began a process to standardize post-quantum algorithms, which they announced as part of new standards in 2022.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_274" aria-label="274"/>This chapter provides a nontechnical overview of the principles behind quantum computers as well as a glimpse of post-quantum algorithms. There’s some math involved, but only basic arithmetic and linear algebra, so don’t fret about the unusual notations.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-96"/><samp class="SANS_Futura_Std_Bold_B_11">How Quantum Computers Work</samp></h3>&#13;
<p class="TNI">Quantum computing uses quantum physics to compute differently and perform tasks that classical computers can’t, such as breaking RSA and elliptic curve cryptography efficiently. A quantum computer is not a superfast normal computer. In fact, quantum computers can’t efficiently solve any problem that’s too hard for a classical computer, such as brute-force search or <b>NP</b>-hard problems.</p>&#13;
<p class="TX">Quantum mechanics—the branch of physics that studies the behavior of subatomic particles, which behave truly randomly—is the basis of quantum computers. Unlike classical computers, which operate on bits that are either 0 or 1, quantum computers operate on <i>quantum bits</i> (or <i>qubits</i>), which can be “both 0 and 1 simultaneously.” This is a state of ambiguity called <i>superposition</i>, where my quotation marks indicate an oversimplification. In this microscopic world, physicists discovered that particles such as electrons and photons behave in a highly counterintuitive way: before you observe an electron, it isn’t at a definite location in space but in several locations at the same time (that is, in a state of superposition). Once you observe it—an operation called <i>measurement</i> —it stops at a fixed, random location and is no longer in superposition; the quantum state <i>collapsed</i>. This enables the creation of qubits in a quantum computer, along with the phenomena of entanglement and interference.</p>&#13;
<p class="TX">Quantum computers work because of <i>entanglement</i>, wherein two particles are connected (entangled) in a way that observing the value of one gives the value of the other, even if the two particles are widely separated (kilometers or even light-years away from each other). The <i>Einstein–Podolsky–Rosen (EPR) paradox</i> illustrates this behavior, which caused Albert Einstein to initially dismiss quantum mechanics. (See <i><a href="https://plato.stanford.edu/entries/qt-epr/">https://<wbr/>plato<wbr/>.stanford<wbr/>.edu<wbr/>/entries<wbr/>/qt<wbr/>-epr<wbr/>/</a></i> for an in-depth explanation.)</p>&#13;
<p class="TX"><i>Interference</i> is also crucial to the operation of quantum computers. With this property, particles can combine or cancel out each other’s effects due to their wave-like nature, as the double-slit experiment famously illustrates. Quantum computing exploits interference so that the “waves” of valid solutions reinforce each other and invalid solutions cancel each other out.</p>&#13;
<p class="TX">To explain how a quantum computer works, I’ll distinguish the actual quantum computer (the hardware, including its quantum bits) from quantum algorithms (the software that runs on it, composed of <i>quantum gates</i>).</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-174"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Quantum Bits</samp></h4>&#13;
<p class="TNI">You can characterize qubits, or groups thereof, with <i>amplitudes</i>, which are numbers akin to probabilities that aren’t <i>exactly</i> probabilities. Whereas a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_275" aria-label="275"/>probability is a number between 0 and 1, an amplitude is a complex number of the form <i>a</i> + <i>bi</i> (that is, <i>a</i> + <i>b</i> × <i>i</i>), where <i>a</i> and <i>b</i> are real numbers and <i>i</i> is an <i>imaginary unit</i>. You use the number <i>i</i> to form <i>imaginary numbers</i> of the form <i>bi</i>, with <i>b</i> a real number. When you multiply <i>i</i> by a real number, you get another imaginary number, and multiplying it by itself it results in –1 (that is, <i>i</i><sup>2</sup> = –1).</p>&#13;
<p class="TX">Unlike real numbers, which you see as belonging to a line (see <a href="chapter14.xhtml#fig14-1">Figure 14-1</a>), <i>complex numbers</i> belong to a plane (a space with two dimensions), as <a href="chapter14.xhtml#fig14-2">Figure 14-2</a> demonstrates.</p>&#13;
<figure class="IMG"><img id="fig14-1" class="img7" src="../images/fig14-1.jpg" alt="" width="838" height="63"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: A view of real numbers as points on an infinite straight line</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <a href="chapter14.xhtml#fig14-2">Figure 14-2</a>, the x-axis corresponds to the <i>a</i> in <i>a</i> + <i>bi</i>, the y-axis corresponds to the <i>b</i>, and the dotted lines correspond to the real and imaginary parts of each number. For example, the vertical dotted line going from the point 3 + 2<i>i</i> down to 3 is two units long (the 2 in the imaginary part 2<i>i</i>).</p>&#13;
<figure class="IMG"><img id="fig14-2" class="img7" src="../images/fig14-2.jpg" alt="" width="834" height="723"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: A view of complex numbers as points in a two-dimensional space</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can use the Pythagorean theorem to compute the length of the line segment going from the origin (0) to the point <i>a</i> + <i>bi</i> by viewing this line as the hypotenuse of a triangle. The hypotenuse’s length is equal to the square root of the sum of the squared coordinates of the point, or √(<i>a</i><sup>2</sup> + <i>b</i><sup>2</sup>), which is called the <i>modulus</i> of the complex number <i>a</i> + <i>bi</i>. You denote the modulus as |<i>a</i> + <i>bi</i>| and can use it as the length of a complex number.</p>&#13;
<p class="TX">In a quantum computer, registers consist of one or more qubits in a state of superposition, which can be characterized by a set of such complex <span role="doc-pagebreak" epub:type="pagebreak" id="pg_276" aria-label="276"/>numbers, or amplitudes. But as you’ll see, these amplitudes can’t be just any numbers.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h5 class="H3" id="sec3"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Amplitudes of a Single Qubit</samp></h5>&#13;
<p class="TNI">You can characterize a single qubit by two amplitudes that we’ll denote as <span class="greek"><span xml:lang="el" lang="el">α</span></span> (alpha) and <span class="greek"><span xml:lang="el" lang="el">β</span></span> (beta). You can then express a qubit’s state as <span class="greek"><span xml:lang="el" lang="el">α</span></span>|0⟩ + ® |1<span class="symbol">⟩</span>, where the | ⟩ notation denotes vectors in a quantum state. This notation means that when you observe this qubit, it appears as 0 with a probability |<span class="greek"><span xml:lang="el" lang="el">α</span></span>|<sup>2</sup> and 1 with a probability |<span class="greek"><span xml:lang="el" lang="el">β</span></span>|<sup>2</sup>. For these to be actual probabilities, |<span class="greek"><span xml:lang="el" lang="el">α</span></span>|<sup>2</sup> and |<span class="greek"><span xml:lang="el" lang="el">β</span></span>|<sup>2</sup> must be numbers between 0 and 1, and |<span class="greek"><span xml:lang="el" lang="el">α</span></span>|<sup>2</sup> + |<span class="greek"><span xml:lang="el" lang="el">β</span></span>|<sup>2</sup> must be equal to 1.</p>&#13;
<p class="TX">For example, say you have the qubit <span class="greek_Symbols"><span xml:lang="el" lang="el">Ψ</span></span> (psi) with amplitudes <span class="greek"><span xml:lang="el" lang="el">α</span></span> = 1/√2 and <span class="greek"><span xml:lang="el" lang="el">β</span></span> = 1/√2. You express this as follows:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg276-1.jpg" alt="" width="1390" height="66"/></figure>&#13;
<p class="TX">In the qubit <span class="greek_Symbols"><span xml:lang="el" lang="el">Ψ</span></span>, the value 0 has an amplitude of 1/√2, and the value 1 has the same amplitude, 1/√2. To get the actual probability from the amplitudes, compute the modulus of 1/√2 (which is equal to 1/√2 because it has no imaginary part) and then square it: (1/√2)<sup>2</sup> = 1/2. This means that if you observe the qubit <span class="greek_Symbols"><span xml:lang="el" lang="el">Ψ</span></span>, you’ll have a 1/2 chance of seeing a 0 and the same chance of seeing a 1.</p>&#13;
<p class="TX">Now consider the qubit <span class="greek_Symbols"><span xml:lang="el" lang="el">Φ</span></span> (phi), where:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg276-2.jpg" alt="" width="1390" height="66"/></figure>&#13;
<p class="TX">The qubit <span class="greek_Symbols"><span xml:lang="el" lang="el">Φ</span></span> is fundamentally distinct from <span class="greek_Symbols"><span xml:lang="el" lang="el">Ψ</span></span> because unlike <span class="greek_Symbols"><span xml:lang="el" lang="el">Ψ</span></span>, where amplitudes have equal values, the qubit <span class="greek"><span xml:lang="el" lang="el">Φ</span></span> has distinct amplitudes of <span class="greek"><span xml:lang="el" lang="el">α</span></span> = <i>i</i>/√2 (a positive imaginary number) and <span class="greek"><span xml:lang="el" lang="el">β</span></span> = –1/√2 (a negative real number). If, however, you observe <span class="greek"><span xml:lang="el" lang="el">Φ</span></span>, the chance of seeing a 0 or 1 is 1/2, the same as it is with <span class="greek"><span xml:lang="el" lang="el">Ψ</span></span>. Compute the probability of seeing a 0 as follows, based on the preceding rules:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg276-3.jpg" alt="" width="1390" height="112"/></figure>&#13;
<p class="TX">Note that because <span class="greek"><span xml:lang="el" lang="el">α</span></span> = <i>i</i>/√2, you can write <span class="greek"><span xml:lang="el" lang="el">α</span></span> as <i>a</i> + <i>bi</i> with <i>a</i> = 0 and <i>b</i> = 1/√2, and computing |<span class="greek"><span xml:lang="el" lang="el">α</span></span>| = √(<i>a</i><sup>2</sup> + <i>b</i><sup>2</sup>) yields 1/√2.</p>&#13;
<p class="TX">Different qubits can behave similarly to an observer (with the same probability of seeing a 0 for both qubits) but have different amplitudes. This says that the actual probabilities of seeing a 0 or a 1 characterize a qubit only partially; this is similar to observing the shadow of an object on a wall, which provides an idea of the object’s width and height but not of its depth. In the case of qubits, this hidden dimension is the value of its amplitude: Is it positive or negative? Is it a real or an imaginary number?</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>To simplify notations, we often write a qubit as its pair of amplitudes (</i><span class="note_greek_Symbols"><span xml:lang="el" lang="el">α</span></span><i>,</i> <span class="note_greek_Symbols"><span xml:lang="el" lang="el">β</span></span><i>). We can thus write the previous example as |</i><span class="note_greek_Symbols"><span xml:lang="el" lang="el">Ψ</span></span><span class="symbol">⟩</span> <i>= (1/√2, 1/√2).</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_277" aria-label="277"/>&#13;
<h5 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Amplitudes of Groups of Qubits</samp></h5>&#13;
<p class="TNI">How do we understand multiple qubits? For example, eight qubits can form a <i>quantum byte</i> when the quantum states of these eight qubits are connected via entanglement. You can describe such a quantum byte as follows, where the <span class="greek"><span xml:lang="el" lang="el">α</span></span>s are the amplitudes associated with each of the 256 possible values of the group of eight qubits:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg277-1.jpg" alt="" width="1494" height="48"/></figure>&#13;
<p class="TX">Note that you must have |<span class="greek"><span xml:lang="el" lang="el">α</span></span><sub>0</sub>|<sup>2</sup> + |<span class="symbol">〈</span><span class="greek"><span xml:lang="el" lang="el">α</span></span><sub>1</sub>|<sup>2</sup> + . . . + |<span class="greek"><span xml:lang="el" lang="el">α</span></span><sub>255</sub>|<sup>2</sup> = 1 so that all probabilities sum to 1.</p>&#13;
<p class="TX">You can view this group of eight qubits as a set of 2<sup>8</sup> = 256 amplitudes because it has 256 possible configurations, each with its own amplitude. In physical reality, however, you’d have eight physical objects, not 256. The 256 amplitudes are an implicit characteristic of the group of eight qubits; each of these 256 numbers can take any of infinitely many different values. Generalizing, you can characterize a group of <i>n</i> qubits by a set of 2<i><sup>n</sup></i> complex numbers, a number that grows exponentially with the numbers of qubits.</p>&#13;
<p class="TX">If you want to simulate the evolution of a quantum state using a classical computer, you need to store this exponential number of amplitudes and perform calculations to modify them. This requirement is one of the main reasons why a classical computer can’t efficiently simulate a quantum computer: doing so requires a gigantic amount of memory (of the order of 2<i><sup>n</sup></i>) to store the same amount of information contained in just <i>n</i> qubits using a quantum system. In practice, you can simulate a maximum of 50 or 60 qubits, depending on the type of calculation.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-175"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Quantum Gates</samp></h4>&#13;
<p class="TNI">The concepts of amplitude and <i>quantum gates</i> are unique to quantum computing. A quantum gate is essentially a transformation of one or more qubits, and it’s the counterpart of electronic gates in the quantum computing realm. Whereas a classical computer uses registers, memory, and a microprocessor to perform a sequence of instructions on data, a quantum computer transforms a group of qubits reversibly by applying a series of quantum gates and then measures the value of one or more qubits. Quantum computers promise more computing power because with only <i>n</i> qubits they can affect the values of 2<i><sup>n</sup></i> amplitudes. This property has profound implications.</p>&#13;
<p class="TX">From a mathematical standpoint, quantum algorithms are essentially a circuit of quantum gates that transforms a set of complex numbers (the amplitudes) before a final measurement, where the value of 1 or more qubits is observed (see <a href="chapter14.xhtml#fig14-3">Figure 14-3</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_278" aria-label="278"/>&#13;
<figure class="IMG"><img id="fig14-3" class="img7" src="../images/fig14-3.jpg" alt="" width="888" height="387"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: Principle of a quantum algorithm</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We also refer to quantum algorithms as <i>quantum gate arrays</i> or <i>quantum circuits</i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h5 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Quantum Gates as Matrix Multiplications</samp></h5>&#13;
<p class="TNI">Unlike the Boolean gates of a classical computer (AND, XOR, and so on), a quantum gate acts on a group of amplitudes just as a matrix acts when multiplied with a vector. For example, to apply the simplest quantum gate, the <i>identity</i> gate, to the qubit <span class="greek_Symbols"><span xml:lang="el" lang="el">Φ</span></span>, we see <i>I</i> as a 2×2 identity matrix and multiply it with the column vector consisting of the two amplitudes of <span class="greek_Symbols"><span xml:lang="el" lang="el">Φ</span></span>:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg278-1.jpg" alt="" width="1391" height="249"/></figure>&#13;
<p class="TX">The result of this matrix–vector multiplication is another column vector with two elements, where the top value is equal to the dot product of the <i>I</i> matrix’s first line with the input vector (the result of adding the product of the first elements 1 and <i>i</i>/√2 to the product of the second elements 0 and –1/√2) and likewise for the bottom value.</p>&#13;
<p class="TX">The identity gate <i>I</i> is pretty useless because it doesn’t do anything and leaves a qubit unchanged.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In practice, a quantum computer wouldn’t explicitly compute matrix–vector multiplications because the matrices would be way too large. (That’s why a classical computer can’t simulate quantum computing.) Instead, a quantum computer would transform qubits as physical particles through physical transformations that are equivalent to a matrix multiplication. Confused? Here’s what Richard Feynman had to say: “If you are not completely confused by quantum mechanics, you do not understand it.”</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Hadamard Quantum Gate</samp></h5>&#13;
<p class="TNI">One of the most useful quantum gates is the <i>Hadamard gate</i>, usually denoted as <i>H</i>. You can define the Hadamard gate as follows (note the negative value in the bottom-right position):</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_279" aria-label="279"/>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg279-1.jpg" alt="" width="1372" height="130"/></figure>&#13;
<p class="TX">Applying this gate to the qubit |<span class="greek"><span xml:lang="el" lang="el">Ψ</span></span><span class="symbol">⟩</span> = (1/√2, 1/√2) results in the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg279-2.jpg" alt="" width="1361" height="130"/></figure>&#13;
<p class="TX">By applying the Hadamard gate <i>H</i> to |<span class="greek_Symbols"><span xml:lang="el" lang="el">Ψ</span></span><span class="symbol">⟩</span>, you obtain the qubit |0<span class="symbol">⟩</span> for which the value |0<span class="symbol">⟩</span> has amplitude 1, and |1<span class="symbol">⟩</span> has amplitude 0. This tells you that the qubit behaves deterministically: if you observe this qubit, you’ll always see a 0 and never a 1. In other words, you’ve lost the randomness of the initial qubit |<span class="greek_Symbols"><span xml:lang="el" lang="el">Ψ</span></span><span class="symbol">⟩</span>.</p>&#13;
<p class="TX">Applying the Hadamard gate again to the qubit |0<span class="symbol">⟩</span> results in the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg279-3.jpg" alt="" width="1293" height="130"/></figure>&#13;
<p class="TX">This brings you back to the qubit |<span class="greek_Symbols"><span xml:lang="el" lang="el">Ψ</span></span><span class="symbol">⟩</span> and a randomized state. We often use the Hadamard gate in quantum algorithms to go from a deterministic state to a uniformly random one.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Not All Matrices Are Quantum Gates</samp></h5>&#13;
<p class="TNI">Although you can see the application of quantum gates as matrix multiplications, not all matrices correspond to quantum gates. Recall that a qubit consists of the complex numbers <span class="greek"><span xml:lang="el" lang="el">α</span></span> and <span class="greek"><span xml:lang="el" lang="el">β</span></span>, the amplitudes of the qubit, that satisfy the condition |<span class="greek"><span xml:lang="el" lang="el">α</span></span>|<sup>2</sup> + |<span class="greek"><span xml:lang="el" lang="el">β</span></span>|<sup>2</sup> = 1. If you get two amplitudes that don’t match this condition after multiplying a qubit by a matrix, the result can’t be a qubit. Quantum gates correspond only to <i>unitary matrices</i>, which preserve the property |<span class="greek"><span xml:lang="el" lang="el">α</span></span>|<sup>2</sup> + |<span class="greek"><span xml:lang="el" lang="el">β</span></span>|<sup>2</sup> = 1.</p>&#13;
<p class="TX">Unitary matrices (and quantum gates by definition) are <i>invertible</i>, meaning that given the result of an operation, you can compute back the original qubit by applying the <i>inverse</i> matrix. This is why quantum computing is a kind of <i>reversible computing</i>.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-97"/><samp class="SANS_Futura_Std_Bold_B_11">Quantum Speedup</samp></h3>&#13;
<p class="TNI">A <i>quantum speedup</i> occurs when a quantum computer can solve a problem fundamentally faster than a classical one. For example, to search for an item among <i>n</i> items of an unordered list on a classical computer, you need on average <i>n</i>/2 operations because you need to look at each item in the list before finding the one you’re looking for. (On average, you’ll find that item after searching half of the list.) No classical algorithm can do better than <i>n</i>/2. However, a quantum algorithm exists to search for an item in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_280" aria-label="280"/>only <i>O</i>(√<i>n</i>) operations, which is orders of magnitude smaller than <i>n</i>/2. For example, if <i>n</i> is equal to 1,000,000, then <i>n</i>/2 is 500,000, whereas √<i>n</i> is 1,000.</p>&#13;
<p class="TX">We quantify the difference between quantum and classical algorithms in terms of <i>time complexity</i>, which we represent with the <i>O</i>() notation. In the previous example, the quantum algorithm runs in time <i>O</i>(√<i>n</i>), but the classical algorithm can’t be faster than <i>O</i>(<i>n</i>). Because this difference in time complexity is due to the square exponent, we call this <i>quadratic speedup</i>. While such a speedup likely makes a difference, there are much more powerful ones.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-176"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exponential Speedup and Simon’s Problem</samp></h4>&#13;
<p class="TNI"><i>Exponential speedups</i> are the holy grail of quantum computing. They occur when a task that takes an exponential amount of time on a classical computer, such as <i>O</i>(2<i><sup>n</sup></i>), can be performed on a quantum computer with polynomial complexity—namely, <i>O</i>(<i>n</i><i><sup>k</sup></i>) for some fixed number <i>k</i>. This exponential speedup can turn a practically impossible task into a possible one. (Recall from <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> that cryptographers and complexity theorists associate exponential time with the impossible and polynomial time with the practical.)</p>&#13;
<p class="TX">The poster child of exponential speedups is <i>Simon’s problem</i>. In this computational problem, a function, <b>f</b>(), transforms <i>n</i>-bit strings to <i>n</i>-bit strings, such that the output of <b>f</b>() looks like a random <i>n</i>-bit string, but with one constraint: there’s a secret value, <i>m</i>, such that for any two values <i>x</i>, <i>y</i>, we have <b>f</b>(<i>x</i>) = <b>f</b>(<i>y</i>) if and only if <i>y</i> = <i>x</i> <span class="symbol">⊕</span> <i>m</i>. Simon’s problem consists in finding <i>m</i> given black-box access to <b>f</b>().</p>&#13;
<p class="TX">Solving Simon’s problem with a classical algorithm boils down to finding a collision, or values <i>x</i> and <i>y</i> such that <b>f</b>(<i>x</i>) = <b>f</b>(<i>y</i>). This takes approximately 2<i><sup>n</sup></i><sup>/2</sup> queries to <b>f</b>(). However, <a href="chapter14.xhtml#fig14-4">Figure 14-4</a> shows that a quantum algorithm can solve Simon’s problem in only approximately <i>n</i> queries, with the extremely efficient time complexity of <i>O</i>(<i>n</i>).</p>&#13;
<figure class="IMG"><img id="fig14-4" class="img7" src="../images/fig14-4.jpg" alt="" width="865" height="582"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: The circuit of the quantum algorithm that solves Simon’s problem efficiently</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_281" aria-label="281"/>In the quantum circuit solving Simon’s problem, you initialize 2<i>n</i> qubits to |0<span class="symbol">⟩</span>, apply Hadamard gates (<i>H</i>) to the first <i>n</i> qubits, and then apply the gate <i>Q</i><b><sub>f</sub></b> to the two groups of all <i>n</i> qubits. Given two <i>n</i>-qubit groups <i>x</i> and <i>y</i>, the gate <i>Q</i><span class="ePub-B-SUB">f</span> transforms the quantum state |<i>x</i>⟩|<i>y</i><span class="symbol">⟩</span> to the state |<i>x</i><span class="symbol">⟩</span>|<b>f</b>(<i>x</i>) <span class="symbol">⊕</span> <i>y</i><span class="symbol">⟩</span>. That is, it computes the function <b>f</b>() on the quantum state reversibly because you can go from the new state to the old one by computing <b>f</b>(<i>x</i>) and XORing it to <b>f</b>(<i>x</i>) <span class="symbol">⊕</span> <i>y</i>. (Explaining why this works is beyond this book’s scope.)</p>&#13;
<p class="TX">You can use the exponential speedup for Simon’s problem against symmetric ciphers only in very specific cases, but the next section will discuss some real crypto-killer applications of quantum computing.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-177"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Threat of Shor’s Algorithm</samp></h4>&#13;
<p class="TNI">In 1995, AT&amp;T researcher Peter Shor published an eye-opening article titled “Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer.” <i>Shor’s algorithm</i> is a quantum algorithm that causes an exponential speedup when solving the factoring, discrete logarithm (DLP), and elliptic curve discrete logarithm (ECDLP) problems. You can’t efficiently solve these problems with a classical computer, but you could with a quantum computer. This means that a quantum computer could solve any cryptographic algorithm that relies on those problems, including RSA, Diffie–Hellman, elliptic curve cryptography, and most currently deployed public-key cryptography mechanisms (except for those that transitioned to post-quantum cryptography). In other words, you could reduce the security of RSA or elliptic curve cryptography to that of Caesar’s cipher. (Shor might as well have titled his article “Breaking All Public-Key Crypto on a Quantum Computer.”) Renowned complexity theorist Scott Aaronson called Shor’s algorithm “one of the major scientific achievements of the late 20th century.”</p>&#13;
<p class="TX">Shor’s algorithm actually solves a more general class of problems than factoring and discrete logarithms. Specifically, if a function <b>f</b>() is <i>periodic</i>—that is, if there’s an <span class="greek"><span xml:lang="el" lang="el">ω</span></span> (the period) such that <b>f</b>(<i>x</i> + <span class="greek"><span xml:lang="el" lang="el">ω</span></span>) = <b>f</b>(<i>x</i>) for any <i>x</i>—then Shor’s algorithm will efficiently find <span class="greek"><span xml:lang="el" lang="el">ω</span></span>. (This looks very similar to Simon’s problem, as it was a major inspiration for Shor’s algorithm.)</p>&#13;
<p class="TX">Discussing the details of how Shor’s algorithm achieves its speedup is far too technical for this book, but the next section shows how to use Shor’s algorithm to solve the factoring and discrete logarithm problems (see <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>), the hard problems behind RSA and Diffie–Hellman.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h5 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Factoring Problem</samp></h5>&#13;
<p class="TNI">Say you want to factor a large number, <i>N</i> = <i>pq</i>. It’s easy to factor <i>N</i> if you can compute the period of <i>a</i><i><sup>x</sup></i> mod <i>N</i>, for some constant <i>a</i>. This task is hard to do with a classical computer but easy with a quantum one. First pick a random number <i>a</i> less than <i>N</i>, and ask Shor’s algorithm to find the period <span class="greek"><span xml:lang="el" lang="el">ω</span></span> of the function <b>f</b>(<i>x</i>) = <i>a</i><i><sup>x</sup></i> mod <i>N</i>. Once you’ve found the period, you’ll have <i>a</i><i><sup>x</sup></i> mod <i>N</i> = <i>a</i><i><sup>x +</sup></i> <sup><span xml:lang="el" lang="el">ω</span></sup> mod <i>N</i> (that is, <i>a</i><i><sup>x</sup></i> mod <i>N</i> = <i>a</i><i><sup>x</sup></i><i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup> mod <i>N</i>), which means <span role="doc-pagebreak" epub:type="pagebreak" id="pg_282" aria-label="282"/>that <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup> mod <i>N</i> = 1, or equivalently <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup> – 1 mod <i>N</i> = 0. In other words, <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup> – 1 is a multiple of <i>N</i>, meaning that <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup> – 1 = <i>kN</i> for some unknown number <i>k</i>.</p>&#13;
<p class="TX">When <span class="greek"><span xml:lang="el" lang="el">ω</span></span> is even, it’s easy to factor <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup> – 1 as (<i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup><i><sup>/</sup></i><sup>2</sup> – 1)(<i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup><i><sup>/</sup></i><sup>2</sup> + 1), where the value <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup><i><sup>/</sup></i><sup>2</sup> is a <i>root of unity</i>, as (<i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup><i><sup>/</sup></i><sup>2</sup>)<sup>2</sup> mod <i>N</i> = 1. When the period <span class="greek"><span xml:lang="el" lang="el">ω</span></span> is odd, rerun Shor with another value of <i>a</i> until you get an even number.</p>&#13;
<p class="TX">As the factors of <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup> – 1 contain the prime factors of <i>k</i> and <i>N</i>, you can find these factors distributed among those of <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup><i><sup>/</sup></i><sup>2</sup> – 1 and <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup><i><sup>/</sup></i><sup>2</sup> + 1. You can then calculate the greatest common divisor (GCD) between <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup><i><sup>/2</sup></i> – 1 and <i>N</i>, and between <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup><i><sup>/2</sup></i> + 1 and <i>N</i>, to obtain a nontrivial factor of <i>N</i>—that is, a value other than 1 or <i>N</i>. If this isn’t the case—for example, when <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup><i><sup>/</sup></i><sup>2</sup> – 1 or <i>a</i><sup><span xml:lang="el" lang="el">ω</span></sup><i><sup>/</sup></i><sup>2</sup> + 1 is a multiple of <i>N</i>—restart the attack with another <i>a</i>.</p>&#13;
<p class="TX">Having obtained the factors of <i>N</i>, you’ve now recovered the RSA private key from its public key, enabling you to decrypt encrypted messages or forge signatures.</p>&#13;
<p class="TX">Note that the best classical algorithm to use to factor a number <i>N</i> runs in time exponential in <i>n</i>, the bit length of <i>N</i> (that is, <i>n</i> = log<sub>2</sub> <i>N</i>). However, Shor’s algorithm runs in time <i>polynomial</i> in <i>n</i>—namely, <i>O</i>(<i>n</i><sup>2</sup>(log <i>n</i>)(log log <i>n</i>)). This means that if you had a quantum computer, you could run Shor’s algorithm and see the result within a more reasonable amount of time than thousands of years.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h5 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Discrete Logarithm Problem</samp></h5>&#13;
<p class="TNI">The challenge in the discrete logarithm problem is to find <i>x</i>, given <i>y</i> = <i>g</i><i><sup>x</sup></i> mod <i>p</i>, for some known numbers <i>g</i> and <i>p</i>. Solving this problem takes a (sub)exponential amount of time on a classical computer, but you can find <i>x</i> easily with Shor’s algorithm thanks to its efficient period-finding technique.</p>&#13;
<p class="TX">For example, consider the function <b>f</b>(<i>a</i>, <i>b</i>) = <i>g</i><i><sup>a</sup></i><i>y</i><i><sup>b</sup></i>. Say you want to find the period of this function, the numbers <span class="greek"><span xml:lang="el" lang="el">ω</span></span> and <span class="greek"><span xml:lang="el" lang="el">ω</span></span><span class="symbol">′</span><i>,</i> such that <b>f</b>(<i>a</i> + <span class="greek"><span xml:lang="el" lang="el">ω</span></span>, <i>b</i> + <span class="greek"><span xml:lang="el" lang="el">ω</span></span><span class="symbol">′</span>) = <b>f</b>(<i>a</i>, <i>b</i>) for any <i>a</i> and <i>b</i>. The solution you seek is then <i>x</i> = –<span class="greek"><span xml:lang="el" lang="el">ω</span></span>/<span class="greek"><span xml:lang="el" lang="el">ω</span></span><span class="symbol">′</span> modulo <i>q</i>, the order of <i>g</i>, which is a known parameter. The equality <b>f</b>(<i>a</i> + <span class="greek"><span xml:lang="el" lang="el">ω</span></span>, <i>b</i> + <span class="greek"><span xml:lang="el" lang="el">ω</span></span><span class="symbol">′</span>) = <b>f</b>(<i>a</i>, <i>b</i>) implies <i>g</i><sup><span xml:lang="el" lang="el">ω</span></sup><i>y</i><sup><span xml:lang="el" lang="el">ω</span></sup> <span class="symbol">′</span> mod <i>p</i> = 1. By substituting <i>y</i> with <i>g</i><i><sup>x</sup></i>, you have <i>g</i><sup><span xml:lang="el" lang="el">ω</span></sup> <i><sup>+ x</sup></i><sup><span xml:lang="el" lang="el">ω</span></sup><span class="symbol">′</span> mod <i>p</i> = 1, which is equivalent to <span class="greek"><span xml:lang="el" lang="el">ω</span></span> + <i>x</i><span class="greek"><span xml:lang="el" lang="el">ω</span></span><span class="symbol">′</span> mod <i>q</i> = 0, from which you derive <i>x</i> = – <span class="greek"><span xml:lang="el" lang="el">ω</span></span>/<span class="greek"><span xml:lang="el" lang="el">ω</span></span><span class="symbol">′</span>.</p>&#13;
<p class="TX">Again, the overall complexity is <i>O</i>(<i>n</i><sup>2</sup>(log <i>n</i>)(log log <i>n</i>)), with <i>n</i> the bit length of <i>p</i>. This algorithm generalizes to find discrete logarithms in any finite commutative group, not just the group of numbers modulo a prime number. You can thus apply it to solve ECDLP as well, the elliptic curve version of the discrete logarithm problem.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-178"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grover’s Algorithm</samp></h4>&#13;
<p class="TNI">Another important form of quantum speedup is the ability to search among <i>n</i> items in time proportional to the square root of <i>n</i>, whereas any classical algorithm would take time proportional to <i>n</i>. This quadratic speedup is possible thanks to <i>Grover’s algorithm</i>, a quantum algorithm discovered in 1996. I won’t cover the internals of Grover’s algorithm because they’re <span role="doc-pagebreak" epub:type="pagebreak" id="pg_283" aria-label="283"/>essentially a bunch of Hadamard gates, but I’ll explain what kind of problem Grover solves and its potential impact on cryptographic security. I’ll also show why you can salvage a symmetric crypto algorithm from quantum computers by doubling the key or hash value size, whereas asymmetric algorithms are destroyed for good.</p>&#13;
<p class="TX">Think of Grover’s algorithm as a way to find the value <i>x</i> among <i>n</i> possible values, such that <b>f</b>(<i>x</i>) = 1, and where <b>f</b>(<i>x</i>) = 0 for most other values. If <i>m</i> values of <i>x</i> satisfy <b>f</b>(<i>x</i>) = 1, Grover will find a solution in time <i>O</i>(√(<i>n</i>/<i>m</i>)); that is, in time proportional to the square root of <i>n</i> divided by <i>m</i>. In comparison, a classical algorithm can’t do better than <i>O</i>(<i>n</i>/<i>m</i>).</p>&#13;
<p class="TX">Now consider the fact that <b>f</b>() can be any function. It could be, for example, “<b>f</b>(<i>x</i>) = 1 if and only if <i>x</i> is equal to the unknown secret key <i>K</i> such that <b>E</b>(<i>K</i>, <i>P</i>) = <i>C</i>” for some known plaintext <i>P</i> and ciphertext <i>C</i>, and where <b>E</b>() is some encryption function. In practice, this means that if you’re looking for a 128-bit AES key with a quantum computer, you’ll find the key in time proportional to 2<sup>64</sup>, rather than 2<sup>128</sup> if you had only classical computers. You’d need a large enough plaintext to ensure the uniqueness of the key. (If the plaintext and ciphertext are, say, 32 bits, many candidate keys would map that plaintext to that ciphertext.) The complexity 2<sup>64</sup> is much smaller than 2<sup>128</sup>, meaning that a secret key would be much easier to recover. But there’s an easy solution: to restore 128-bit security, just use 256-bit keys! Grover’s algorithm will then reduce the complexity of searching a key to 2<sup>256 / 2</sup> = 2<sup>128</sup> operations.</p>&#13;
<p class="TX">Grover’s algorithm can also find preimages of hash functions (see <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>). To find a preimage of some value <i>h</i>, we define the <b>f</b>() function as “<b>f</b>(<i>x</i>) = 1 if and only if <b>Hash</b>(<i>x</i>) = <i>h</i>, otherwise <b>f</b>(<i>x</i>) = 0.” Grover thus gets you preimages of <i>n</i>-bit hashes at the cost of the order of 2<i><sup>n</sup></i><sup>/2</sup> operations. As with encryption, to ensure 2<i><sup>n</sup></i> post-quantum security, use hash values twice as large, since Grover’s algorithm finds a preimage of a 2<i>n</i>-bit value in at least 2<i><sup>n</sup></i> operations.</p>&#13;
<p class="TX">The bottom line is that you can salvage symmetric crypto algorithms from quantum computers by doubling the key or hash value size.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>There’s a famous quantum algorithm that finds hash function collisions in time</i> <span class="note_Italic">O</span><i>(2</i><sup>n</sup><i><sup>/3</sup></i><i>), instead of</i> <span class="note_Italic">O</span><i>(2</i><sup>n</sup><i><sup>/2</sup></i><i>), as with the classic birthday attack. This suggests that quantum computers can outperform classical computers for finding hash function collisions, except that the</i> <span class="note_Italic">O</span><i>(2</i><sup>n</sup><i><sup>/3</sup></i><i>)-time quantum algorithm also requires</i> <span class="note_Italic">O</span><i>(2</i><sup>n</sup><i><sup>/3</sup></i><i>) space, or memory, to run. Give</i> <span class="note_Italic">O</span><i>(2</i><sup>n</sup><i><sup>/3</sup></i><i>)’s worth of computer space to a classic algorithm, and it can run a parallel collision search algorithm with a collision time of only</i> <span class="note_Italic">O</span><i>(2</i><sup>n</sup><i><sup>/6</sup></i><i>), which is much faster than the</i> <span class="note_Italic">O</span><i>(2</i><sup>n</sup><i><sup>/3</sup></i><i>) quantum algorithm. (For details of this attack, see “Cost Analysis of Hash Collisions” by Daniel J. Bernstein at</i> <span class="note_LinkURL_Italic"><a href="https://cr.yp.to/papers.html#collisioncost">https://<wbr/>cr<wbr/>.yp<wbr/>.to<wbr/>/papers<wbr/>.html#collisioncost</a></span><i>.) In 2017, however, cryptographers proposed a quantum algorithm finding collisions in time</i> <span class="note_Italic">O</span><i>(2</i><i><sup>2</sup></i><sup>n</sup><i><sup>/5</sup></i><i>), requiring</i> <span class="note_Italic">O</span><i>(</i><span class="note_Italic">n</span><i>) quantum memory and</i> <span class="note_Italic">O</span><i>(2</i><sup>n</sup><i><sup>/5</sup></i><i>) classical memory. This may outperform classical search (see</i> <span class="note_LinkURL_Italic"><a href="https://eprint.iacr.org/2017/847">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2017<wbr/>/847</a></span><i>).</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_284" aria-label="284"/>&#13;
<h3 class="H1" id="sec15"><span id="h1-98"/><samp class="SANS_Futura_Std_Bold_B_11">Why Is It So Hard to Build a Quantum Computer?</samp></h3>&#13;
<p class="TNI">Although quantum computers can in principle be built, we don’t know how hard it will be or when that might happen, if at all. As of mid-2024, the record holder is a machine with 1,121 qubits (IBM’s “Condor”), whereas we’d need to keep millions of qubits stable for weeks to break any crypto. The point is, we’re not there yet.</p>&#13;
<p class="TX">The difficulty of building a quantum computer stems from needing extremely small things to play the role of qubits—smaller than atoms, such as photons. Because qubits must be so small, they’re also extremely fragile.</p>&#13;
<p class="TX">Also, qubits must be kept at extremely low temperatures (close to absolute zero) to remain stable. Even at freezing temperatures, the state of qubits decays, and they eventually become useless. As of this writing, we don’t yet know how to make qubits that last for more than a couple of seconds (their coherence time).</p>&#13;
<p class="TX">Another challenge is that the environment, such as heat and magnetic fields, can affect the qubits’ states and lead to computation errors. In theory, it’s possible to correct these errors, but it’s difficult to do so. Correcting qubits’ errors requires quantum error-correcting codes, which in turn require many additional qubits and a low enough rate of error.</p>&#13;
<p class="TX">At the moment, there are two main approaches to forming qubits: superconducting circuits and ion traps. Labs at Google and IBM champion using <i>superconducting circuits</i>, which is based on forming qubits as tiny electrical circuits that rely on quantum phenomena from superconductor materials, where charge carriers are pairs of electrons. Qubits made of superconducting circuits have a very short lifetime.</p>&#13;
<p class="TX"><i>Ion traps</i>, or trapped ions, consist of ions (charged atoms) and are manipulated using lasers to prepare the qubits in specific initial states. Ion traps tend to be more stable than superconducting circuits, but they’re slower to operate and seem harder to scale.</p>&#13;
<p class="TX">Building a quantum computer is really a moon shot effort. The challenge comes down to 1) building a system with a handful of qubits that’s stable, fault tolerant, and capable of applying basic quantum gates, and 2) scaling such a system to thousands or millions of qubits to make it useful. From a purely physical standpoint and to the best of our knowledge, there’s nothing to prevent the creation of large fault-tolerant quantum computers. But many things are possible in theory and prove hard or too costly to realize in practice (like secure computers). The future will tell who is right—the quantum optimists (who predict a large quantum computer within the decade) or the quantum skeptics (who argue that the human race will never see a quantum computer).</p>&#13;
<p class="TX">As mentioned earlier, as of January 2024, one of the most advanced achievements is IBM’s quantum computing chip Condor that includes 1,121 qubits, a technology based on superconducting circuits. But the number of qubits shouldn’t be the only metric when comparing quantum computing systems. Other important factors include the stability time, the number of qubits entangled together, and the ability to reliably correct errors.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_285" aria-label="285"/>&#13;
<h3 class="H1" id="sec16"><span id="h1-99"/><samp class="SANS_Futura_Std_Bold_B_11">Post-Quantum Cryptographic Algorithms</samp></h3>&#13;
<p class="TNI">The field of <i>post-quantum cryptography</i> focuses on designing public-key algorithms that a quantum computer can’t break; that is, they’re quantum safe and can replace RSA and elliptic curve–based algorithms in a future where off-the-shelf quantum computers could break 4,096-bit RSA moduli in a snap.</p>&#13;
<p class="TX">Such algorithms shouldn’t rely on a hard problem known to be efficiently solvable by Shor’s algorithm, which kills the hardness in factoring and discrete logarithm problems. Symmetric algorithms such as block ciphers and hash functions would lose only half their theoretical security in the face of a quantum computer but wouldn’t be as badly broken as RSA. They might constitute the basis for a post-quantum scheme.</p>&#13;
<p class="TX">In the following sections, we’ll review the four main types of post-quantum algorithms: code based, lattice based, multivariate, and hash based.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H2" id="sec17"><span id="h2-179"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Code-Based Cryptography</samp></h4>&#13;
<p class="TNI">Code-based post-quantum cryptographic algorithms are based on <i>error-correcting codes</i>, which are techniques designed to transmit bits over a noisy channel. The basic theory of error-correcting codes dates back to the 1950s. The first code-based encryption scheme (the <i>McEliece</i> cryptosystem) was developed in 1978 and is still unbroken. You can use code-based crypto schemes for both encryption and signatures. Their main limitation is the size of their public key, which is typically on the order of a hundred kilobytes. But is that really a problem when the average size of a web page is around 2MB?</p>&#13;
<p class="TX">Let me first explain what error-correcting codes are. Say you want to transmit a sequence of bits as a sequence of 3-bit words, but the transmission’s unreliable and you’re concerned about incorrectly transmitting one or more bits: you send 010, but the receiver gets 011. One might address this by using a basic error-correction <i>repetition code</i>: instead of transmitting 010, you transmit 000111000 (repeating each bit three times), and the receiver decodes the received word by taking the majority value for each of the 3 bits.</p>&#13;
<p class="TX">For example, a receiver would decode the repetition codeword 100110111 to 011 because 100 contains two 0s, then 110 contains two 1s, and 111 contains three 1s. This particular error-correcting code allows a receiver to correct only up to one error per 3-bit chunk, because if two errors occur in the same 3-bit chunk, the majority value would be the wrong one.</p>&#13;
<p class="TX"><i>Linear codes</i> are a less trivial example of error-correcting codes. In the case of linear codes, a word to encode is seen as an <i>n</i>-bit vector <i>v</i>, and encoding consists of multiplying <i>v</i> with an <i>m</i>×<i>n</i> matrix <i>G</i> to compute the code word <i>w</i> = <i>vG</i>. (In this example, <i>m</i> is greater than <i>n</i>, meaning the code word is longer than the original word.) One can structure the matrix <i>G</i> such that for a given number <i>t</i>, any <i>t</i>-bit error in <i>w</i> allows the recipient to recover the correct <i>v</i>. In other words, <i>t</i> is the maximum number of errors that one can correct.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_286" aria-label="286"/>To encrypt data using linear codes, the McEliece cryptosystem constructs <i>G</i> as a secret combination of three matrices and encrypts by computing <i>w</i> = <i>vG</i> added with some random value, <i>e</i>, which has a fixed number of bits set to 1. Here, <i>G</i> is the public key, and the private key is composed of the matrices <i>A</i>, <i>B</i>, and <i>C</i> such that <i>G</i> = <i>ABC.</i> Knowing <i>A</i>, <i>B</i>, and <i>C</i> allows one to decode a message reliably and retrieve <i>w</i>. But without these matrices, it should be impossible to decode the word and thus to decrypt.</p>&#13;
<p class="TX">The security of the McEliece encryption scheme relies on the hardness of decoding a linear code with insufficient information, a problem we know to be <b>NP</b>-hard and therefore out of reach of quantum computers. Bear in mind, however, that just because a problem is <b>NP</b>-hard doesn’t mean that all its instances will be impossible to solve in practice. It’s therefore necessary to evaluate which instances of the difficult problem are presented by a cryptosystem and whether these instances will always be difficult. McEliece’s cipher satisfies this criterion after years of analysis by cryptographers and coding theory experts.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-180"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lattice-Based Cryptography</samp></h4>&#13;
<p class="TNI"><i>Lattices</i> are mathematical structures that essentially consist of a set of points in an <i>n</i>-dimensional space, with some periodic structure. For example, <a href="chapter14.xhtml#fig14-5">Figure 14-5</a> shows how you can view a lattice in dimension two (<i>n</i> = 2) as the set of points.</p>&#13;
<figure class="IMG"><img id="fig14-5" class="img7" src="../images/fig14-5.jpg" alt="" width="893" height="499"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: Points of a two-dimensional lattice, where</samp> <samp class="SANS_Futura_Std_Book_11">v</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_11">w</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">are basis vectors of the lattice and</samp> <samp class="SANS_Futura_Std_Book_11">s</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">is the closest vector to the star-shaped point</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Lattice theory has led to deceptively simple cryptography schemes. I’ll give you the gist of it.</p>&#13;
<p class="TX"><i>Short integer solution (SIS)</i> is a hard problem in lattice-based crypto that consists of finding the secret vector <i>s</i> of <i>n</i> numbers given (<i>A</i>, <i>b</i>) such that <i>b</i> = <i>As</i> mod <i>q</i>, where <i>A</i> is a random <i>m</i>×<i>n</i> matrix and <i>q</i> is a prime number.</p>&#13;
<p class="TX">Another hard problem in lattice-based cryptography, <i>learning with errors (LWE)</i>, consists of finding the secret vector <i>s</i> of <i>n</i> numbers given (<i>A</i>, <i>b</i>), where <i>b</i> = <i>As</i> + <i>e</i> mod <i>q</i>, with <i>A</i> being a random <i>m</i>×<i>n</i> matrix, <i>e</i> a random vector of noise, and <i>q</i> a prime number. This problem looks a lot like noisy decoding in code-based cryptography.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_287" aria-label="287"/>SIS and LWE are somewhat equivalent, and we can restate them as instances of the <i>closest vector problem (CVP)</i> on a lattice, or the problem of finding the vector in a lattice closest to a given point, by combining a set of basis vectors. The dotted vector <i>s</i> in <a href="chapter14.xhtml#fig14-5">Figure 14-5</a> shows how to find the closest vector to the star-shaped point by combining the basis vectors <i>v</i> and <i>w</i>.</p>&#13;
<p class="TX">CVP and other lattice problems are believed to be hard both for classical and quantum computers. But this doesn’t directly transfer to secure cryptosystems, because some problems are hard only in the worst case (that is, for their hardest instance) rather than the average case (which is what we need for crypto). Furthermore, while finding the exact solution to CVP is hard, finding an approximation of the solution can be considerably easier.</p>&#13;
<p class="TX">That said, post-quantum cryptosystems based on lattices have proven to offer the best combination of security and performance. The standards chosen by NIST in 2022 are mainly from this family, as you’ll see later.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2" id="sec19"><span id="h2-181"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multivariate Cryptography</samp></h4>&#13;
<p class="TNI"><i>Multivariate cryptography</i> focuses on building cryptographic schemes that are as hard to break as it is to solve systems of multivariate equations, or equations involving multiple unknowns that are multiplied together in the equations. Consider, for example, the following system of equations involving four unknowns <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>, <i>x</i><sub>4</sub>:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg287-1.jpg" alt="" width="1339" height="229"/></figure>&#13;
<p class="TX">These equations consist of the sum of terms that are either a single unknown, such as <i>x</i><sub>4</sub> (or terms of degree one), or the product of two unknown values, such as <i>x</i><sub>2</sub><i>x</i><sub>3</sub> (terms of degree two or <i>quadratic</i> terms). To solve this system, you need to find the values of <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>, <i>x</i><sub>4</sub> that satisfy all four equations. Equations may be over all real numbers, integers only, or over finite sets of numbers. In cryptography, however, equations are typically over numbers modulo some prime numbers or over binary values (0 and 1).</p>&#13;
<p class="TX">The hard problem here is finding a solution to a random quadratic system, which is known as <i>multivariate quadratics (MQ)</i>. This problem is <b>NP</b>-hard and is therefore a potential basis for post-quantum systems because quantum computers won’t solve <b>NP</b>-hard problems efficiently.</p>&#13;
<p class="TX">Unfortunately, building a cryptosystem on top of MQ isn’t so straightforward. For example, if you were to use MQ for signatures, the private key might consist of three systems of equations: <i>L</i><sub>1</sub>, <i>N</i>, and <i>L</i><sub>2</sub>. Combining them in this order results in another system of equations called <i>P</i>, the public key. Applying the transformations <i>L</i><sub>1</sub>, <i>N</i>, and <i>L</i><sub>2</sub> consecutively (that is, transforming a group of values as per the system of equations) is then equivalent <span role="doc-pagebreak" epub:type="pagebreak" id="pg_288" aria-label="288"/>to applying <i>P</i> by transforming <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>, <i>x</i><sub>4</sub> to <i>y</i><sub>1</sub>, <i>y</i><sub>2</sub>, <i>y</i><sub>3</sub>, <i>y</i><sub>4</sub>, for example, defined as follows:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg288-1.jpg" alt="" width="1389" height="222"/></figure>&#13;
<p class="TX">In such a cryptosystem, <i>L</i><sub>1</sub>, <i>N</i>, and <i>L</i><sub>2</sub> are chosen such that <i>L</i><sub>1</sub> and <i>L</i><sub>2</sub> are linear transformations (that is, having equations where terms are only added, not multiplied) that are invertible, and where <i>N</i> is a quadratic system of equations that is also invertible. This makes the combination of the three an invertible quadratic system, but its inverse is hard to determine without knowing the inverses of <i>L</i><sub>1</sub>, <i>N</i>, and <i>L</i><sub>2</sub>.</p>&#13;
<p class="TX">Computing a signature then consists of computing the inverses of <i>L</i><sub>1</sub>, <i>N</i>, and <i>L</i><sub>2</sub> applied to some message, <i>M</i>, which we see as a sequence of variables, <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, . . .:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg288-2.jpg" alt="" width="1389" height="65"/></figure>&#13;
<p class="NoIndent">Verifying a signature then consists of verifying that <i>P</i>(<i>S</i>) = <i>M</i>.</p>&#13;
<p class="TX">Attackers could break such a cryptosystem if they manage to compute the inverse of <i>P</i> or to determine <i>L</i><sub>1</sub>, <i>N</i>, and <i>L</i><sub>2</sub> from <i>P</i>. The actual hardness of solving such problems depends on the parameters of the scheme, such as the number of equations used and the size and type of the numbers. But choosing secure parameters is hard, and more than one “safe” multivariate scheme has been broken.</p>&#13;
<p class="TX">Multivariate cryptography isn’t used in major applications due to the challenge of achieving a reliable trade-off between security and performance. A practical benefit of multivariate signature schemes, however, is that they produce short signatures.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h4 class="H2" id="sec20"><span id="h2-182"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hash-Based Cryptography</samp></h4>&#13;
<p class="TNI">Unlike the previous schemes, hash-based cryptography is based on the well-established security of cryptographic hash functions rather than on the hardness of mathematical problems. Because quantum computers can’t break hash functions, they can’t break anything that relies on the difficulty of finding collisions or preimages, which is the key idea of hash function–based signature schemes.</p>&#13;
<p class="TX">Hash-based cryptographic schemes are pretty complex, so we’ll take a look at their simplest building block: the <i>Winternitz one-time signature (WOTS)</i>, a trick discovered around 1979. Here <i>one-time</i> means that you can use a private key to sign only one message; otherwise, the signature scheme becomes insecure. (You can combine WOTS with other methods to sign multiple messages, as you’ll see shortly.)</p>&#13;
<p class="TX">Say you want to sign a message viewed as a number between 0 and <i>w</i> – 1, where <i>w</i> is some parameter of the scheme. The private key is a random string, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_289" aria-label="289"/><i>K</i>. To sign a message, <i>M</i>, with 0 ≤ <i>M</i> &lt; <i>w</i>, compute <b>Hash</b>(<b>Hash</b>(. . .(<b>Hash</b>(<i>K</i>))), where the hash function <b>Hash</b> repeats <i>M</i> times. You denote this value as <b>Hash</b><i><sup>M</sup></i>(<i>K</i>). The public key is <b>Hash</b><i><sup>w</sup></i>(<i>K</i>), or the result of <i>w</i> nested iterations of <b>Hash</b>, starting from <i>K</i>.</p>&#13;
<p class="TX">A WOTS signature is verified, <i>S</i>, by checking that <b>Hash</b><i><sup>w – M</sup></i>(<i>S</i>) is equal to the public key <b>Hash</b><i><sup>w</sup></i>(<i>K</i>). Note that <i>S</i> is <i>K</i> after <i>M</i> applications of <b>Hash</b>, so if you do another <i>w</i> – <i>M</i> applications of <b>Hash</b>, you’ll get a value equal to <i>K</i> hashed <i>M</i> + (<i>w</i> – <i>M</i>) = <i>w</i> times, which is the public key.</p>&#13;
<p class="TX">This scheme has significant limitations:</p>&#13;
<p class="RunInPara"><b>Attackers can forge signatures </b>From <b>Hash</b><i><sup>M</sup></i>(<i>K</i>), the signature of <i>M</i>, you can compute <b>Hash</b>(<b>Hash</b><i><sup>M</sup></i>(<i>K</i>)) = <b>Hash</b><i><sup>M</sup></i> <sup>+ 1</sup>(<i>K</i>), which is a valid signature of the message <i>M</i> + 1. You can fix this problem by signing not only <i>M</i> but also <i>w</i> – <i>M</i>, using a second key.</p>&#13;
<p class="RunInPara"><b>It works for only short messages </b>If messages are 8 bits long, there are up to 2<sup>8</sup> – 1 = 255 possible messages, so you have to compute <b>Hash</b> up to 255 times to create a signature. That might work for short messages, but not for longer ones—for example, with 128-bit messages, signing the message 2<sup>128</sup> – 1 takes forever. A workaround is to split longer messages into shorter ones and sign each chunk independently.</p>&#13;
<p class="RunInPara"><b>It works only once </b>If you use a private key to sign more than one message, an attacker can recover enough information to forge a signature. For example, if <i>w</i> = 8 and you sign the numbers 1 and 7 using the preceding trick to avoid trivial forgeries, the attacker gets <b>Hash</b><sup>1</sup>(<i>K</i>) and <b>Hash</b><sup>7</sup>(<i>K</i> <span class="symbol">′</span>) as a signature of 1, and <b>Hash</b><sup>7</sup>(<i>K</i>) and <b>Hash</b><sup>1</sup>(<i>K</i> <span class="symbol">′</span>) as a signature of 7. From these values, the attacker can compute <b>Hash</b><i><sup>x</sup></i>(<i>K</i>) and <b>Hash</b><i><sup>x</sup></i>(<i>K</i> <span class="symbol">′</span>) for any <i>x</i> in [1;7] and thus forge a signature on behalf of the owner of <i>K</i> and <i>K</i> <span class="symbol">′</span>. There’s no simple way to fix this.</p>&#13;
<p class="TX">State-of-the-art hash-based schemes rely on more complex versions of WOTS, combined with tree data structures and sophisticated techniques designed to sign different messages with different keys. Unfortunately, the resulting schemes produce large signatures (on the order of dozens of kilobytes, as with SPHINCS+, one of the signature algorithms chosen for standardization by NIST in 2022).</p>&#13;
<p class="TX">You should also note the difference between <i>stateful</i> and <i>stateless</i> signature schemes. SPHINCS+ is stateless, whereas XMSS is stateful, as it needs to maintain a counter. Statefulness greatly simplifies algorithm design but forces users to maintain a state such as a counter while using the algorithm.</p>&#13;
<p class="TX">Finally, note that public-key constructions relying on only hash functions can offer signature schemes but not encryption.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h3 class="H1" id="sec21"><span id="h1-100"/><samp class="SANS_Futura_Std_Bold_B_11">The NIST Standards</samp></h3>&#13;
<p class="TNI">In 2017, NIST organized an open competition to identify suitable post-quantum algorithm standards for encryption and signature. Like the previous competitions that gave us AES (Rijndael) and SHA-3 (Keccak), NIST’s Post-Quantum Cryptography Standardization project invited <span role="doc-pagebreak" epub:type="pagebreak" id="pg_290" aria-label="290"/>cryptographers to submit algorithms and cryptanalyze other submitters’ algorithms to eliminate them from the competition.</p>&#13;
<p class="TX">NIST received 69 submissions, most of which were lattice based. Of these submissions, 26 made it to the second round. In July 2020, NIST selected seven finalist and eight alternate algorithms. In July 2022, NIST announced the first four standards:</p>&#13;
<p class="RunInPara"><b>CRYSTALS-Kyber </b>A lattice-based <i>key encapsulation mechanism (KEM)</i>, which is a primitive that can be seen as an encryption scheme for secret keys. It can be used to encrypt data (within a hybrid scheme, where a symmetric cipher actually encrypts the data using a key encrypted by the KEM) and used for key agreement, in a similar way as Diffie–Hellman protocols.</p>&#13;
<p class="RunInPara"><b>CRYSTAL-Dilithium </b>A lattice-based signature scheme designed by the same team as CRYSTALS-Kyber.</p>&#13;
<p class="RunInPara"><b>Falcon </b>A lattice-based signature scheme based on slightly different techniques and assumptions than Dilithium.</p>&#13;
<p class="RunInPara"><b>SPHINCS+ </b>A hash-based signature scheme, thus the only algorithm not based on lattices.</p>&#13;
<p class="TX">NIST stated the following regarding having two lattice-based signature schemes:</p>&#13;
<p class="Blockquote">[Both] were selected for their strong security and excellent performance, and NIST expects them to work well in most applications. Falcon will also be standardized by NIST since there may be use cases for which CRYSTALS-Dilithium signatures are too large.</p>&#13;
<p class="TX">The shortest Dilithium signatures are approximately 2KB long, whereas Falcon’s are half as long. NIST also stated that it will standardize SPHINCS+ “to avoid relying only on the security of lattices for signatures.”</p>&#13;
<p class="TX">At the time of writing, draft standards have been published under the FIPS series for Kyber, Dilithium, and SPHINCS+ as FIPS 203 (Module-Lattice-Based Key-Encapsulation Mechanism Standard), FIPS 204 (Module-Lattice-Based Digital Signature Standard), and FIPS 205 (Stateless Hash-Based Digital Signature Standard), respectively, while Falcon’s standard is expected a bit later.</p>&#13;
<p class="TX">These post-quantum algorithms are expected to first be used in hybrid modes, in combination with a classical, non-quantum-resilient algorithm to hedge the risk of weaknesses. For example, Kyber is generally used in combination with X25519, the Diffie–Hellman scheme relying on Curve25519, to protect TLS connections.</p>&#13;
<p class="TX">NIST also announced four algorithms advancing to the “fourth round.” These include the three code-based encryption schemes BIKE, Classic McEliece, and HQC. The isogeny-based SIKE was found to be completely broken shortly after the announcement and thus withdrew from the competition.</p>&#13;
<p class="TX">NIST started a new project in summer 2022 to identify more post-quantum signature schemes, stating that “signature schemes that are not <span role="doc-pagebreak" epub:type="pagebreak" id="pg_291" aria-label="291"/>based on structured lattices are of greatest interest” and expecting submissions with “short signatures and fast verification.” In June 2023, NIST received 50 submissions, including 11 multivariate, 7 lattice-based, 6 code-based, 2 hash-based, and 7 that use <i>MPC-in-the-head</i>. This emerging technique turns a multiparty-computation (MPC) protocol into a zero-knowledge proof of knowledge—that is, a single piece of data whose verification corresponds to the verification of a signature. The proposed number and variety of schemes will lead to new attacks and new attack techniques, and hopefully to reliable standards.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h3 class="H1" id="sec22"><span id="h1-101"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">Post-quantum cryptography may be fundamentally stronger than RSA or elliptic curve cryptography, but it’s not infallible or omnipotent. Our understanding of the security of post-quantum schemes and their implementations is more limited than otherwise, which brings with it increased risk.</p>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h4 class="H2" id="sec23"><span id="h2-183"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unclear Security Level</samp></h4>&#13;
<p class="TNI">Post-quantum schemes can appear deceptively strong yet prove insecure against both quantum and classical attacks. Lattice-based algorithms, such as the ring-LWE family of computational problems (versions of the LWE problem that work with polynomials), are sometimes problematic. Ring-LWE is attractive for cryptographers because we can leverage it to build cryptosystems that are in principle as hard to break as it is to solve the hardest instances of ring-LWE problems, which can be <b>NP</b>-hard. But when security looks too good to be true, it often is.</p>&#13;
<p class="TX">Security proofs are often asymptotic, meaning they’re true only for large parameter values such as the dimension of the underlying lattice. However, in practice much smaller parameters are used. Even when a lattice-based scheme looks to be as hard to break as some <b>NP</b>-hard problem, its security remains hard to quantify. In the case of lattice-based algorithms, we rarely have a clear picture of the best attacks against them and the cost of such an attack in terms of computation or hardware, due to a lack of understanding of these recent constructions. This uncertainty makes lattice-based schemes harder to compare against better-understood constructions such as RSA. However, researchers have been making progress on this front and, ideally in a few years, lattice problems will be as well understood as RSA. (For more technical details on the ring-LWE problem, read Peikert’s excellent survey at <i><a href="https://eprint.iacr.org/2016/351">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2016<wbr/>/351</a></i>.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h4 class="H2" id="sec24"><span id="h2-184"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Eventual Existence of Large Quantum Computers</samp></h4>&#13;
<p class="TNI">Imagine this CNN headline circa April 2, 2048: “ACME, Inc. reveals its secretly built quantum computer, launches break-crypto-as-a-service platform.” OK, RSA and elliptic curve crypto are screwed. Now what?</p>&#13;
<p class="TX">The bottom line is that post-quantum encryption is way more critical than post-quantum signatures. Let’s look at the case of signatures first. If <span role="doc-pagebreak" epub:type="pagebreak" id="pg_292" aria-label="292"/>you were still using RSA-PSS or ECDSA as a signature scheme, you could issue new signatures using a post-quantum signature scheme to restore your signatures’ trust. You’d revoke your older, quantum-unsafe public keys and compute fresh signatures for every message you’d signed. After a bit of work, you’d be fine.</p>&#13;
<p class="TX">You’d have a reason to panic only if you were encrypting data using quantum-unsafe schemes, such as RSA-OAEP. In this case, all transmitted ciphertext could be compromised, so it would be pointless to reencrypt that plaintext with a post-quantum algorithm since your data’s confidentiality is already gone.</p>&#13;
<p class="TX">But what about key agreement, with Diffie–Hellman (DH) and its elliptic curve counterpart (ECDH)? At first glance, the situation looks to be as bad as with encryption: attackers who’ve collected public keys <i>g</i><i><sup>a</sup></i> and <i>g</i><i><sup>b</sup></i> could use their shiny new quantum computer to compute the secret exponent <i>a</i> or <i>b</i> and compute the shared secret <i>g</i><i><sup>ab</sup></i>, and then derive from it the keys that encrypted your traffic. But in practice, Diffie–Hellman isn’t always used in such a simplistic fashion. The actual session keys that encrypt your data may be derived from both the Diffie–Hellman shared secret and some internal state of your system. That’s how state-of-the-art mobile messaging systems work, thanks to a protocol pioneered with the Signal application. When you send a new message to a peer with Signal, it computes a new Diffie–Hellman shared secret and combines it with internal secrets that depend on the previous messages sent within that session (which can span long periods of time). Such advanced use of Diffie–Hellman makes the work of an attacker much harder, even with a quantum computer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h4 class="H2" id="sec25"><span id="h2-185"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementation Issues</samp></h4>&#13;
<p class="TNI">In practice, post-quantum schemes consist of code—software running on some physical processor—not just abstract algorithms. However strong the algorithms may be on paper, they won’t be immune to implementation errors, software bugs, or side-channel attacks. An algorithm may be completely post-quantum in theory but may still be broken once implemented—for example, by a classical computer program because a programmer forgot to enter a semicolon.</p>&#13;
<p class="TX">Furthermore, schemes such as code-based and lattice-based algorithms rely heavily on mathematical operations, the implementation of which uses a variety of tricks to make those operations as fast as possible. By the same token, the complexity of the code in these algorithms makes implementation more vulnerable to side-channel attacks, such as timing attacks, which infer information about secret values based on measurement of execution times. In fact, we’ve already applied such attacks to code-based encryption (see <i><a href="https://eprint.iacr.org/2010/479">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2010<wbr/>/479</a></i>) and to lattice-based signature schemes (see <i><a href="https://eprint.iacr.org/2016/300">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2016<wbr/>/300</a></i>).</p>&#13;
<p class="TX">Ironically, using post-quantum schemes may be less secure in practice at first than non-post-quantum ones due to potential vulnerabilities in their implementations.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_293" aria-label="293"/>&#13;
<h3 class="H1" id="sec26"><span id="h1-102"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">To learn the basics of quantum computation, read the classic <i>Quantum Computation and Quantum Information (Anniversary Edition)</i> by Michael Nielsen and Isaac Chuang (Cambridge, 2011). Scott Aaronson’s <i>Quantum Computing Since Democritus</i> (Cambridge, 2013), a less technical and more entertaining read, covers more than quantum computing.</p>&#13;
<p class="TX">Several software simulators allow you to experiment with quantum computing, such as The Quantum Computing Playground at <i><a href="https://www.quantumplayground.net">https://<wbr/>www<wbr/>.quantumplayground<wbr/>.net</a></i> or IBM’s platform at <i><a href="https://quantum.ibm.com">https://<wbr/>quantum<wbr/>.ibm<wbr/>.com</a></i>. These sites are relatively easy to use, thanks to intuitive visualizations.</p>&#13;
<p class="TX">For the latest research in post-quantum cryptography, see <i><a href="https://pqcrypto.org">https://<wbr/>pqcrypto<wbr/>.org</a></i> and the associated conference PQCrypto.</p>&#13;
<p class="TX">The coming years promise to be particularly exciting for post-quantum crypto, thanks to the continuation of NIST’s Post-Quantum Cryptography Standardization project and the deployment at scale of post-quantum solutions.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>