<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch6">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch6">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_103" aria-label=" Page 103. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">FILESYSTEM MINIFILTER DRIVERS</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">While the drivers covered in previous chapters can monitor many important events on the system, they aren’t able to detect a particularly critical kind of activity: filesystem operations. Using filesystem minifilter drivers, or <i>minifilters</i> for short, endpoint security products can learn about the files being created, modified, written to, and deleted.</p>&#13;
<p class="TX">These drivers are useful because they can observe an attacker’s interactions with the filesystem, such as the dropping of malware to disk. Often, they work in conjunction with other components of the system. By integrating with the agent’s scanning engine, for example, they can enable the EDR to scan files.</p>&#13;
<p class="TX">Minifilters might, of course, monitor the native Windows filesystem, which is called the New Technology File System (NTFS) and is implemented in <i>ntfs.sys</i>. However, they might also monitor other important filesystems, including named pipes, a bidirectional inter-process communication mechanism implemented in <i>npfs.sys</i>, and mailslots, a unidirectional <span role="doc-pagebreak" epub:type="pagebreak" id="pg_104" aria-label=" Page 104. "/>inter-process communication mechanism implemented in <i>msfs.sys</i>. Adversary tools, particularly command-and-control agents, tend to make heavy use of these mechanisms, so tracking their activities provides crucial telemetry. For example, Cobalt Strike’s Beacon uses named pipes for tasking and the linking of peer-to-peer agents.</p>&#13;
<p class="TX">Minifilters are similar in design to the drivers discussed in the previous chapters, but this chapter covers some unique details about their implementations, capabilities, and operations on Windows. We’ll also discuss evasion techniques that attackers can leverage to interfere with them.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-72"/><samp class="SANS_Futura_Std_Bold_B_11">Legacy Filters and the Filter Manager</samp></h2>&#13;
<p class="TNI">Before Microsoft introduced minifilters, EDR developers would write legacy filter drivers to monitor filesystem operations. These drivers would sit on the filesystem stack, directly inline of user-mode calls destined for the filesystem, as shown in <a href="#fig6-1">Figure 6-1</a>.</p>&#13;
<figure class="IMG"><img id="fig6-1" class="img100" src="../images/Figure6-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: The legacy filter driver architecture</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">These drivers were notoriously difficult to develop and support in production environments. A 2019 article published in <i>The NT Insider</i>, titled “Understanding Minifilters: Why and How File System Filter Drivers Evolved,” highlights seven large problems that developers face when writing legacy filter drivers:</p>&#13;
<p class="LH"><b>Confusing Filter Layering</b></p>&#13;
<p class="LIST1">In cases when there is more than one legacy filter installed on the system, the architecture defines no order for how these drivers should be placed on the filesystem stack. This prevents the driver developer from knowing when the system will load their driver in relation to the others.</p>&#13;
<p class="LH"><b>A Lack of Dynamic Loading and Unloading</b></p>&#13;
<p class="LIST1">Legacy filter drivers can’t be inserted into a specific location on the device stack and can only be loaded at the top of the stack. Additionally, legacy filters can’t be unloaded easily and typically require a full system reboot to unload.</p>&#13;
<p class="LH"><b>Tricky Filesystem-Stack Attachment and Detachment</b></p>&#13;
<p class="LIST1">The mechanics of how the filesystem stack attaches and detaches devices are extremely complicated, and developers must have a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_105" aria-label=" Page 105. "/>substantial amount of arcane knowledge to ensure that their driver can appropriately handle odd edge cases.</p>&#13;
<p class="LH"><b>Indiscriminate IRP Processing</b></p>&#13;
<p class="LIST1">Legacy filter drivers are responsible for processing <i>all</i> Interrupt Request Packets (IRPs) sent to the device stack, regardless of whether they are interested in the IRPs or not.</p>&#13;
<p class="LH"><b>Challenges with Fast I/O Data Operations</b></p>&#13;
<p class="LIST1">Windows supports a mechanism for working with cached files, called <i>Fast I/O</i>, that provides an alternative to its standard packet-based I/O model. It relies on a dispatch table implemented in the legacy drivers. Each driver processes Fast I/O requests and passes them down the stack to the next driver. If a single driver in the stack lacks a dispatch table, it disables Fast I/O processing for the entire device stack.</p>&#13;
<p class="LH"><b>An Inability to Monitor Non-data Fast I/O Operations</b></p>&#13;
<p class="LIST1">In Windows, filesystems are deeply integrated into other system components, such as the memory manager. For instance, when a user requests that a file be mapped into memory, the memory manager calls the Fast I/O callback <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireFileForNtCreateSection</samp>. These non-data requests always bypass the device stack, making it hard for a legacy filter driver to collect information about them. It wasn’t until Windows XP, which introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!FsRtlRegisterFileSystemFilterCallbacks()</samp>, that developers could request this information.</p>&#13;
<p class="LH"><b>Issues with Handling Recursion</b></p>&#13;
<p class="LIST1">Filesystems make heavy use of recursion, so filters in the filesystem stack must support it as well. However, due to the way that Windows manages I/O operations, this is easier said than done. Because each request passes through the entire device stack, a driver could easily deadlock or exhaust its resources if it handles recursion poorly.</p>&#13;
<p class="TX">To address some of these limitations, Microsoft introduced the filter manager model. The filter manager (<i>fltmgr.sys</i>) is a driver that ships with Windows and exposes functionality commonly used by filter drivers when intercepting filesystem operations. To leverage this functionality, developers can write minifilters. The filter manager then intercepts requests destined for the filesystem and passes them to the minifilters loaded on the system, which exist in their own sorted stack, as shown in <a href="#fig6-2">Figure 6-2</a>.</p>&#13;
<p class="TX">Minifilters are substantially easier to develop than their legacy counterparts, and EDRs can manage them more easily by dynamically loading and unloading them on a running system. The ability to access functionality exposed by the filter manager makes for less complex drivers, allowing for easier maintenance. Microsoft has made tremendous efforts to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_106" aria-label=" Page 106. "/>move developers away from the legacy filter model and over to the minifilter model. It has even included an optional registry value that allows administrators to block legacy filter drivers from being loaded on the system altogether.</p>&#13;
<figure class="IMG"><img id="fig6-2" class="img100" src="../images/Figure6-2.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: The filter manager and minifilter architecture</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h-73"/><samp class="SANS_Futura_Std_Bold_B_11">Minifilter Architecture</samp></h2>&#13;
<p class="TNI">Minifilters have a unique architecture in several respects. First is the role of the filter manager itself. In a legacy architecture, filesystem drivers would filter I/O requests directly, while in a minifilter architecture, the filter manager handles this task before passing information about the requests to the minifilters loaded on the system. This means that minifilters are only indirectly attached to the filesystem stack. Also, they register with the filter manager for the specific operations they’re interested in, removing the need for them to handle all I/O requests.</p>&#13;
<p class="TX">Next is how they interact with registered callback routines. As with the drivers discussed in the previous chapters, minifilters may register both pre- and post-operation callbacks. When a supported operation occurs, the filter manager first calls the correlated pre-operation callback function in each of the loaded minifilters. Once a minifilter completes its pre-operation routine, it passes control back to the filter manager, which calls the next callback function in the subsequent driver. When all drivers have completed their pre-operation callbacks, the request travels to the filesystem driver, which processes the operation. After receiving the I/O request for completion, the filter manager invokes the post-operation callback functions in the minifilters in reverse order. Once the post-operation callbacks complete, control is transferred back to the I/O manager, which eventually passes control back to the caller application.</p>&#13;
<p class="TX">Each minifilter has an <i>altitude</i>, which is a number that identifies its location in the minifilter stack and determines when the system will load that minifilter. Altitudes address the issue of ordering that plagued legacy filter drivers. Ideally, Microsoft assigns altitudes to the minifilters of production applications, and these values are specified in the drivers’ registry keys, under <samp class="SANS_TheSansMonoCd_W5Regular_11">Altitude</samp>. Microsoft sorts altitudes into load-order groups, which are shown in <a href="#tab6-1">Table 6-1</a>.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab6-1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_107" aria-label=" Page 107. "/><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp> <samp class="SANS_Futura_Std_Book_11">Microsoft’s Minifilter Load-Order Groups</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Altitude range</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Load-order group name</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Minifilter role</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">420000–429999</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Filter</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Legacy filter drivers</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">400000–409999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Top</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Filters that must attach above all others</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">360000–389999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Activity Monitor</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that observe and report on file I/O</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">340000–349999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Undelete</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that recover deleted files</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">320000–329998</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Anti-Virus</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Antimalware drivers</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">300000–309998</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Replication</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that copy data to a remote system</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">280000–289998</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Continuous Backup</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that copy data to backup media</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">260000–269998</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Content Screener</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that prevent the creation of specific files or content</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">240000–249999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Quota Management</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that provide enhanced filesystem quotas that limit the space allowed for a volume or folder</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">220000–229999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter System Recovery</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that maintain operating system integrity</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">200000–209999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Cluster File System</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers used by applications that provide file server metadata across a network</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">180000–189999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter HSM</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Hierarchical storage management drivers</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">170000–174999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Imaging</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">ZIP-like drivers that provide a virtual namespace</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">160000–169999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Compression</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">File-data compression drivers</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">140000–149999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Encryption</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">File-data encryption and decryption drivers</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">130000–139999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Virtualization</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Filepath virtualization drivers</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">120000–129999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Physical Quota Management</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that manage quotes by using physical block counts</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">100000–109999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Open File</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that provide snapshots of already-opened files</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">80000–89999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Security Enhancer</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that apply file-based lockdowns and enhanced access control</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">60000–69999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Copy Protection</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Drivers that check for out-of-band data on storage media</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">40000–49999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Bottom</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Filters that must attach below all others</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">20000–29999</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter System</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Reserved</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">&lt;20000</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FSFilter Infrastructure</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Reserved for system use but attaches closest to the filesystem</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">Most EDR vendors register their minifilters in the FSFilter Anti-Virus or FSFilter Activity Monitor group. Microsoft publishes a list of registered altitudes, as well as their associated filenames and publishers. <a href="#tab6-2">Table 6-2</a> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_108" aria-label=" Page 108. "/>lists altitudes assigned to minifilters belonging to popular commercial EDR solutions.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab6-2"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</samp> <samp class="SANS_Futura_Std_Book_11">Altitudes of Popular EDRs</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Altitude</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Vendor</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">EDR</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">389220</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Sophos</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">sophosed.sys</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">389040</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">SentinelOne</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">sentinelmonitor.sys</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">328010</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Microsoft</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">wdfilter.sys</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">321410</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">CrowdStrike</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">csagent.sys</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">388360</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">FireEye/Trellix</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">fekern.sys</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">386720</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Bit9/Carbon Black/VMWare</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_Oblique_I_11">carbonblackk.sys</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">While an administrator can change a minifilter’s altitude, the system can load only one minifilter at a single altitude at one time.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h2 class="H1" id="sec3"><span id="h-74"/><samp class="SANS_Futura_Std_Bold_B_11">Writing a Minifilter</samp></h2>&#13;
<p class="TNI">Let’s walk through the process of writing a minifilter. Each minifilter begins with a <samp class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp> function, defined in the same way as other drivers. This function performs any required global initializations and then registers the minifilter. Finally, it starts filtering I/O operations and returns an appropriate value.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h-75"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Beginning the Registration</samp></h3>&#13;
<p class="TNI">The first, and most important, of these actions is registration, which the <samp class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp> function performs by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltRegisterFilter()</samp>. This function adds the minifilter to the list of registered minifilter drivers on the host and provides the filter manager with information about the minifilter, including a list of callback routines. This function is defined in <a href="#list6-1">Listing 6-1</a>.</p>&#13;
<pre id="list6-1"><code>NTSTATUS FLTAPI FltRegisterFilter(&#13;
 [in] PDRIVER_OBJECT   Driver,&#13;
 [in] const FLT_REGISTRATION *Registration,&#13;
 [out] PFLT_FILTER   *RetFilter&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-1: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FltRegisterFilter()</samp> function definition</span></p>&#13;
<p class="TX">Of the three parameters passed to it, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Registration</samp> parameter is the most interesting. This is a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp> structure, defined in <a href="#list6-2">Listing 6-2</a>, which houses all the relevant information about the minifilter.</p>&#13;
<pre id="list6-2"><code>typedef struct _FLT_REGISTRATION {&#13;
 USHORT          Size;&#13;
 USHORT          Version;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_109" aria-label=" Page 109. "/>&#13;
 FLT_REGISTRATION_FLAGS     Flags;&#13;
 const FLT_CONTEXT_REGISTRATION    *ContextRegistration;&#13;
 const FLT_OPERATION_REGISTRATION    *OperationRegistration;&#13;
 PFLT_FILTER_UNLOAD_CALLBACK    FilterUnloadCallback;&#13;
 PFLT_INSTANCE_SETUP_CALLBACK   InstanceSetupCallback;&#13;
 PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK  InstanceQueryTeardownCallback;&#13;
 PFLT_INSTANCE_TEARDOWN_CALLBACK    InstanceTeardownStartCallback;&#13;
 PFLT_INSTANCE_TEARDOWN_CALLBACK    InstanceTeardownCompleteCallback;&#13;
 PFLT_GENERATE_FILE_NAME      GenerateFileNameCallback;&#13;
 PFLT_NORMALIZE_NAME_COMPONENT    NormalizeNameComponentCallback;&#13;
 PFLT_NORMALIZE_CONTEXT_CLEANUP    NormalizeContextCleanupCallback;&#13;
 PFLT_TRANSACTION_NOTIFICATION_CALLBACK  TransactionNotificationCallback;&#13;
 PFLT_NORMALIZE_NAME_COMPONENT_EX   NormalizeNameComponentExCallback;&#13;
 PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK  SectionNotificationCallback;&#13;
} FLT_REGISTRATION, *PFLT_REGISTRATION;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FLT_REGISTRATION</samp> structure definition</span></p>&#13;
<p class="TX">The first two members of this structure set the structure size, which is always <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(FLT_REGISTRATION)</samp>, and the structure revision level, which is always <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION_VERSION</samp>. The next member is <i>flags</i>, which is a bitmask that may be zero or a combination of any of the following three values:</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_DO_NOT_SUPPORT_SERVICE_STOP (1)</samp></p>&#13;
<p class="LIST1">The minifilter won’t be unloaded in the event of a service stop request.</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_SUPPORT_NPFS_MSFS</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(2)</samp></p>&#13;
<p class="LIST1">The minifilter supports named pipe and mailslot requests.</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_SUPPORT_DAX_VOLUME (4)</samp></p>&#13;
<p class="LIST1">The minifilter supports attaching to a Direct Access (DAX) volume.</p>&#13;
<p class="TX">Following this member is the context registration. This will be either an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CONTEXT_REGISTRATION</samp> structures or null. These contexts allow a minifilter to associate related objects and preserve state across I/O operations. After this array of context comes the critically important operation registration array. This is a variable length array of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp> structures, which are defined in <a href="#list6-3">Listing 6-3</a>. While this array can technically be null, it’s rare to see that configuration in an EDR sensor. The minifilter must provide a structure for each type of I/O for which it registers a pre-operation or post-operation callback routine.</p>&#13;
<pre id="list6-3"><code>typedef struct _FLT_OPERATION_REGISTRATION {&#13;
 UCHAR       MajorFunction;&#13;
 FLT_OPERATION_REGISTRATION_FLAGS Flags;&#13;
 PFLT_PRE_OPERATION_CALLBACK  PreOperation;&#13;
 PFLT_POST_OPERATION_CALLBACK  PostOperation;&#13;
 PVOID       Reserved1;&#13;
} FLT_OPERATION_REGISTRATION, *PFLT_OPERATION_REGISTRATION;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FLT_OPERATION_REGISTRATION</samp> structure definition</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_110" aria-label=" Page 110. "/>The first parameter indicates which major function the minifilter is interested in processing. These are constants defined in <i>wdm.h</i>, and <a href="#tab6-3">Table 6-3</a> lists some of those most relevant to security monitoring.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab6-3"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-3:</samp> <samp class="SANS_Futura_Std_Book_11">Major Functions and Their Purposes</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Major function</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x00)</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A new file is being created or a handle to an existing one is being opened.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x01)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A named pipe is being created or opened.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CLOSE (0x02)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A handle to a file object is being closed.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x03)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Data is being read from a file.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x04)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Data is being written to a file.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_INFORMATION</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x05)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Information about a file, such as its creation time, has been requested.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_INFORMATION</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x06)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Information about a file, such as its name, is being set or updated.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_EA</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x07)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A file’s extended information has been requested.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_EA</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x08)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A file’s extended information is being set or updated.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_LOCK_CONTROL</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x11)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A lock is being placed on a file, such as via a call to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!LockFileEx()</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_MAILSLOT</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x13)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A new mailslot is being created or opened.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_SECURITY</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x14)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Security information about a file is being requested.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_SECURITY</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x15)</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Security information related to a file is being set or updated.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SYSTEM_CONTROL</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x17)</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A new driver has been registered as a supplier of Windows Management Instrumentation.</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">The next member of the structure specifies the flags. This bitmask describes when the callback functions should be invoked for cached I/O or paging I/O operations. At the time of this writing, there are four supported flags, all of which are prefixed with <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_OPERATION_REGISTRATION_</samp>. First, <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_PAGING_IO</samp> indicates whether a callback should be invoked for IRP-based read or write paging I/O operations. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_CACHED_IO</samp> flag is used to prevent the invocation of callbacks on fast I/O-based read or write cached I/O operations. Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_NON_DASD_IO</samp> is used for requests issued on a Direct Access Storage Device (DASD) volume handle. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_NON_CACHED_NON_PAGING_IO</samp> prevents callback invocation on read or write I/O operations that are not cached or paging operations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h-76"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Pre-operation Callbacks</samp></h3>&#13;
<p class="TNI">The next two members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp> structure define the pre-operation or post-operation callbacks to be invoked when each of the target major functions occurs on the system. Pre-operation callbacks <span role="doc-pagebreak" epub:type="pagebreak" id="pg_111" aria-label=" Page 111. "/>are passed via a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PRE_OPERATION_CALLBACK</samp> structure, and post-operation routines are specified as a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POST_OPERATION_CALLBACK</samp> structure. While these functions’ definitions aren’t too dissimilar, their capabilities and limitations vary substantially.</p>&#13;
<p class="TX">As with callbacks in other types of drivers, pre-operation callback functions allow the developer to inspect an operation on its way to its destination (the target filesystem, in the case of a minifilter). These callback functions receive a pointer to the callback data for the operation and some opaque pointers for the objects related to the current I/O request, and they return an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp> return code. In code, this would look like what is shown in <a href="#list6-4">Listing 6-4</a>.</p>&#13;
<pre id="list6-4"><code>PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#13;
&#13;
FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#13;
 [in, out] PFLT_CALLBACK_DATA Data,&#13;
 [in]  PCFLT_RELATED_OBJECTS FltObjects,&#13;
 [out]  PVOID *CompletionContext&#13;
)&#13;
{...}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-4: Registering a pre-operation callback</span></p>&#13;
<p class="TX">The first parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>, is the most complex of the three and contains all the major information related to the request that the minifilter is processing. The <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CALLBACK_DATA</samp> structure is used by both the filter manager and the minifilter to process I/O operations and contains a ton of useful data for any EDR agent monitoring filesystem operations. Some of the important members of this structure include:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Flags</samp>   A bitmask that describes the I/O operation. These flags may come preset from the filter manager, though the minifilter may set additional flags in some circumstances. When the filter manager initializes the data structure, it sets a flag to indicate what type of I/O operation it represents: either fast I/O, filter, or IRP operations. The filter manager may also set flags indicating whether a minifilter generated or reissued the operation, whether it came from the non-paged pool, and whether the operation completed.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Thread</samp>   A pointer to the thread that initiated the I/O request. This is useful for identifying the application performing the operation.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Iopb</samp>   The I/O parameter block that contains information about IRP-based operations (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_BUFFERED_IO</samp>, which indicates that it is a buffered I/O operation); the major function code; special flags related to the operation (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">SL_CASE_SENSITIVE</samp>, which informs drivers in the stack that filename comparisons should be case sensitive); a pointer to the file object that is the target of the operation; and an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PARAMETERS</samp> structure containing the parameters unique to the specific I/O operation specified by the major or minor function code member of the structure.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_112" aria-label=" Page 112. "/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoStatus</samp>   A structure that contains the completion status of the I/O operation set by the filter manager.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">TagData</samp>   A pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_TAG_DATA_BUFFER</samp> structure containing information about reparse points, such as in the case of NTFS hard links or junctions.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">RequestorMode</samp>   A value indicating whether the request came from user mode or kernel mode.</p>&#13;
<p class="TX">This structure contains much of the information that an EDR agent needs to track file operations on the system. The second parameter passed to the pre-operation callback, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RELATED_OBJECTS</samp> structure, provides supplemental information. This structure contains opaque pointers to the object associated with the operation, including the volume, minifilter instance, and file object (if present). The last parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">CompletionContext</samp>, contains an optional context pointer that will be passed to the correlated post-operation callback if the minifilter returns <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SUCCESS_WITH_CALLBACK</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SYNCHRONIZE</samp>.</p>&#13;
<p class="TX">On completion of the routine, the minifilter must return an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp> value. Pre-operation callbacks may return one of seven supported values:</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SUCCESS_WITH_CALLBACK (0)</samp></p>&#13;
<p class="LIST1">Return the I/O operation to the filter manager for processing and instruct it to call the minifilter’s post-operation callback during completion.</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SUCCESS_NO_CALLBACK (1)</samp></p>&#13;
<p class="LIST1">Return the I/O operation to the filter manager for processing and instruct it <i>not</i> to call the minifilter’s post-operation callback during completion.</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_PENDING (2)</samp></p>&#13;
<p class="LIST1">Pend the I/O operation and do not process it further until the minifilter calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltCompletePendedPreOperation()</samp>.</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_DISALLOW_FASTIO (3)</samp></p>&#13;
<p class="LIST1">Block the fast I/O path in the operation. This code instructs the filter manager not to pass the operation to any other minifilters below the current one in the stack and to only call the post-operation callbacks of those drivers at higher altitudes.</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_COMPLETE (4)</samp></p>&#13;
<p class="LIST1">Instruct the filter manager not to send the request to minifilters below the current driver in the stack and to only call the post-operation callbacks of those minifilters above it in the driver stack.</p>&#13;
<p class="LH"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_113" aria-label=" Page 113. "/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SYNCHRONIZE (5)</samp></p>&#13;
<p class="LIST1">Pass the request back to the filter manager but don’t complete it. This code ensures that the minifilter’s post-operation callback is called at IRQL ≤ <i>APC_LEVEL</i> in the context of the original thread.</p>&#13;
<p class="LH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_DISALLOW_FSFILTER_IO (6)</samp></p>&#13;
<p class="LIST1">Disallow a fast <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryOpen</samp> operation and force the operation down the slower path, causing the I/O manager to process the request using an open, query, or close operation on the file.</p>&#13;
<p class="TX">The filter manager invokes the pre-operation callbacks for all minifilters that have registered functions for the I/O operation being processed before passing their requests to the filesystem, beginning with the highest altitude.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h-77"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Post-operation Callbacks</samp></h3>&#13;
<p class="TNI">After the filesystem performs the operations defined in every minifilter’s pre-operation callbacks, control is passed up the filter stack to the filter manager. The filter manager then invokes the post-operation callbacks of all minifilters for the request type, beginning with the lowest altitude. These post-operation callbacks have a similar definition to the pre-operation routines, as shown in <a href="#list6-5">Listing 6-5</a>.</p>&#13;
<pre id="list6-5"><code>PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#13;
&#13;
FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#13;
 [in, out]  PFLT_CALLBACK_DATA Data,&#13;
 [in]   PCFLT_RELATED_OBJECTS FltObjects,&#13;
 [in, optional] PVOID CompletionContext,&#13;
 [in]   FLT_POST_OPERATION_FLAGS Flags&#13;
)&#13;
{...}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-5: Post-operation callback routine definitions</span></p>&#13;
<p class="TX">Two notable differences here are the addition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> parameter and the different return type. The only documented flag that a minifilter can pass is <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_POST_OPERATION_DRAINING</samp>, which indicates that the minifilter is in the process of unloading. Additionally, post-operation callbacks can return different statuses. If the callback returns <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_FINISHED_PROCESSING</samp> (<i>0</i>), the minifilter has completed its post-operation callback routine and is passing control back to the filter manager to continue processing the I/O request. If it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_MORE_PROCESSING_REQUIRED</samp> (<i>1</i>), the minifilter has posted the IRP-based I/O operation to a work queue and halted completion of the request until the work item completes, and it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltCompletePendedPostOperation()</samp>. Lastly, if it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_DISALLOW_FSFILTER_IO</samp> (<i>2</i>), the minifilter is disallowing a fast <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryOpen</samp> operation and forcing the operation down the slower path. This is the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_DISALLOW_FSFILTER_IO</samp>.</p>&#13;
<p class="TX">Post-operation callbacks have some notable limitations that reduce their viability for security monitoring. The first is that they’re invoked in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_114" aria-label=" Page 114. "/>an arbitrary thread unless the pre-operation callback passes the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SYNCHRONIZE</samp> flag, preventing the system from attributing the operation to the requesting application. Next is that post-operation callbacks are invoked at IRQL ≤ <i>DISPATCH_LEVEL</i>. This means that certain operations are restricted, including accessing most synchronization primitives (for example, mutexes), calling kernel APIs that require an IRQL ≤ <i>DISPATCH_LEVEL</i>, and accessing paged memory. One workaround to these limitations involves delaying the execution of the post-operation callback via the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltDoCompletionProcessingWhenSafe()</samp>, but this solution has its own challenges.</p>&#13;
<p class="TX">The array of these <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp> structures passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp> member of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp> may look like <a href="#list6-6">Listing 6-6</a>.</p>&#13;
<pre id="list6-6"><code>const FLT_OPERATION_REGISTRATION Callbacks[] = {&#13;
 {IRP_MJ_CREATE, 0, MyPreCreate, MyPostCreate},&#13;
 {IRP_MJ_READ, 0, MyPreRead, NULL},&#13;
 {IRP_MJ_WRITE, 0, MyPreWrite, NULL},&#13;
 {IRP_MJ_OPERATION_END}&#13;
};</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-6: An array of operation registration callback structures</span></p>&#13;
<p class="TX">This array registers pre- and post-operation callbacks for <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> and only pre-operation callbacks for <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp>. No flags are passed in for any of the target operations. Also note that the final element in the array is <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_OPERATION_END</samp>. Microsoft requires this value to be present at the end of the array, and it serves no functional purpose in the context of monitoring.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-78"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Optional Callbacks</samp></h3>&#13;
<p class="TNI">The last section in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp> structure contains the optional callbacks. The first three callbacks, <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterUnloadCallback</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceSetupCallback</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceQueryTeardownCallback</samp>, may all technically be null, but this will impose some restrictions on the minifilter and system behavior. For example, the system won’t be able to unload the minifilter or attach to new filesystem volumes. The rest of the callbacks in this section of the structure relate to various functionality provided by the minifilter. These include things such as the interception of filename requests (<samp class="SANS_TheSansMonoCd_W5Regular_11">GenerateFileNameCallback</samp>) and filename normalization (<samp class="SANS_TheSansMonoCd_W5Regular_11">NormalizeNameComponentCallback</samp>). In general, only the first three semi-optional callbacks are registered, and the rest are rarely used.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h-79"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Activating the Minifilter</samp></h3>&#13;
<p class="TNI">After all callback routines have been set, a pointer to the created <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp> structure is passed as the second parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltRegisterFilter()</samp>. Upon completion of this function, an opaque filter pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</samp>) is returned to the caller in the <samp class="SANS_TheSansMonoCd_W5Regular_11">RetFilter</samp> parameter. This pointer uniquely identifies the minifilter and remains static as long as the driver is loaded on the system. This pointer is typically preserved as a global variable.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_115" aria-label=" Page 115. "/>When the minifilter is ready to start processing events, it passes the <samp class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</samp> pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltStartFilter()</samp>. This notifies the filter manager that the driver is ready to attach to filesystem volumes and start filtering I/O requests. After this function returns, the minifilter will be considered active and sit inline of all relevant filesystem operations. The callbacks registered in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp> structure will be invoked for their associated major functions. Whenever the minifilter is ready to unload itself, it passes the <samp class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</samp> pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltUnregisterFilter()</samp> to remove any contexts that the minifilter has set on files, volumes, and other components and calls the registered <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceTeardownStartCallback</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceTeardownCompleteCallback</samp> functions.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h2 class="H1" id="sec9"><span id="h-80"/><samp class="SANS_Futura_Std_Bold_B_11">Managing a Minifilter</samp></h2>&#13;
<p class="TNI">Compared to working with other drivers, the process of installing, loading, and unloading a minifilter requires special consideration. This is because minifilters have specific requirements related to the setting of registry values. To make the installation process easier, Microsoft recommends installing minifilters through a <i>setup information (INF)</i> file. The format of these INF files is beyond the scope of this book, but there are some interesting details relevant to how minifilters work that are worth mentioning.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassGuid</samp> entry in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp> section of the INF file is a GUID that corresponds to the desired load-order group (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">FSFilter Activity Monitor</samp>). In the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddRegistry</samp> section of the file, which specifies the registry keys to be created, you’ll find information about the minifilter’s altitude. This section may include multiple similar entries to describe where the system should load various instances of the minifilter. The altitude can be set to the name of a variable (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">%MyAltitude%</samp>) defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Strings</samp> section of the INF file. Lastly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServiceType</samp> entry under the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServiceInstall</samp> section is always set to <samp class="SANS_TheSansMonoCd_W5Regular_11">SERVICE_FILE_SYSTEM_DRIVER</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2)</samp>.</p>&#13;
<p class="TX">Executing the INF installs the driver, copying files to their specified locations and setting up the required registry keys. <a href="#list6-7">Listing 6-7</a> shows an example of what this looks like in the registry keys for <i>WdFilter</i>, Microsoft Defender’s minifilter driver.</p>&#13;
<pre id="list6-7"><code>PS &gt; <b>Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\WdFilter\" | Select * </b>&#13;
<b>-Exclude PS* | fl</b>&#13;
&#13;
DependOnService : {FltMgr}&#13;
Description  : @%ProgramFiles%\Windows Defender\MpAsDesc.dll,-340&#13;
DisplayName  : @%ProgramFiles%\Windows Defender\MpAsDesc.dll,-330&#13;
ErrorControl  : 1&#13;
Group    : FSFilter Anti-Virus&#13;
ImagePath   : system32\drivers\wd\WdFilter.sys&#13;
Start    : 0&#13;
SupportedFeatures : 7&#13;
Type    : 2<span role="doc-pagebreak" epub:type="pagebreak" id="pg_116" aria-label=" Page 116. "/>&#13;
&#13;
PS &gt; <b>Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\WdFilter\Instances\</b>&#13;
<b>WdFilter Instance" | Select * -Exclude PS* | fl</b>&#13;
&#13;
Altitude : 328010&#13;
Flags : 0</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-7: Viewing</span> <span class="eSANS_Futura_Std_Book_11a">WdFilter’</span><span class="eSANS_Futura_Std_Book_Oblique_I_11a">s altitude with PowerShell</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Start</samp> key dictates when the minifilter will be loaded. The service can be started and stopped using the Service Control Manager APIs, as well as through a client such as <i>sc.exe</i> or the Services snap-in. In addition, we can manage minifilters with the filter manager library, <i>FltLib</i>, which is leveraged by the <i>fltmc.exe</i> utility included by default on Windows. This setup also includes setting the altitude of the minifilter, which for <i>WdFilter</i> is 328010.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h2 class="H1" id="sec10"><span id="h-81"/><samp class="SANS_Futura_Std_Bold_B_11">Detecting Adversary Tradecraft with Minifilters</samp></h2>&#13;
<p class="TNI">Now that you understand the inner workings of minifilters, let’s explore how they contribute to the detection of attacks on a system. As discussed in <span class="Xref">“Writing a Minifilter” on <a href="#sec3">page 108</a></span>, a minifilter can register pre- or post-operation callbacks for activities that target any filesystem, including NTFS, named pipes, and mailslots. This provides an EDR with an extremely powerful sensor for detecting adversary activity on the host.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h-82"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">File Detections</samp></h3>&#13;
<p class="TNI">If an adversary interacts with the filesystem, such as by creating new files or modifying the contents of existing files, the minifilter has an opportunity to detect the behavior. Modern attacks have tended to avoid dropping artifacts directly onto the host filesystem in this way, embracing the “disk is lava” mentality, but many hacking tools continue to interact with files due to limitations of the APIs being leveraged. For example, consider <samp class="SANS_TheSansMonoCd_W5Regular_11">dbghelp!MiniDumpWriteDump()</samp>, a function used to create process memory dumps. This API requires that the caller pass in a handle to a file for the dump to be written to. The attacker must work with files if they want to use this API, so any minifilter that processes <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> I/O operations can indirectly detect those memory-dumping operations.</p>&#13;
<p class="TX">Additionally, the attacker has no control over the format of the data being written to the file, allowing a minifilter to coordinate with a scanner to detect a memory-dump file without using function hooking. An attacker might try to work around this by opening a handle to an existing file and overwriting its content with the dump of the target process’s memory, but a minifilter monitoring <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> could still detect this activity, as both the creation of a new file and the opening of a handle to an existing file would trigger it.</p>&#13;
<p class="TX">Some defenders use these concepts to implement <i>filesystem canaries</i>. These are files created in key locations that users should seldom, if ever, interact with. If an application other than a backup agent or the EDR <span role="doc-pagebreak" epub:type="pagebreak" id="pg_117" aria-label=" Page 117. "/>requests a handle to a canary file, the minifilter can take immediate action, including crashing the system. Filesystem canaries provide strong (though at times brutal) anti-ransomware control, as ransomware tends to indiscriminately encrypt files on the host. By placing a canary file in a directory nested deep in the filesystem, hidden from the user but still in one of the paths typically targeted by ransomware, an EDR can limit the damage to the files that the ransomware encountered before reaching the canary.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h-83"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Named Pipe Detections</samp></h3>&#13;
<p class="TNI">Another key piece of adversary tradecraft that minifilters can detect highly effectively is the use of named pipes. Many command-and-control agents, like Cobalt Strike’s Beacon, make use of named pipes for tasking, I/O, and linking. Other offensive techniques, such as those that use token impersonation for privilege escalation, revolve around the creation of a named pipe. In both cases, a minifilter monitoring <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp> requests would be able to detect the attacker’s behavior, in much the same way as those that detect file creation via <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>.</p>&#13;
<p class="TX">Minifilters commonly look for the creation of anomalously named pipes, or those originating from atypical processes. This is useful because many tools used by adversaries rely on the use of named pipes, so an attacker who wants to blend in should pick pipe and host process names that are typical in the environment. Thankfully for attackers and defenders alike, Windows makes enumerating existing named pipes easy, and we can straightforwardly identify many of the common process-to-pipe relationships. One of the most well-known named pipes in the realm of security is <i>mojo</i>. When a Chromium process spawns, it creates several named pipes with the format <i>mojo.PID.TID.VALUE</i> for use by an IPC abstraction library called Mojo. This named pipe became popular after its inclusion in a well-known repository for documenting Cobalt Strike’s Malleable profile options.</p>&#13;
<p class="TX">There are a few problems with using this specific named pipe that a minifilter can detect. The main one is related to the structured formatting used for the name of the pipe. Because Cobalt Strike’s pipe name is a static attribute tied to the instance of the Malleable profile, it is immutable at runtime. This means that an adversary would need to accurately predict the process and thread IDs of their Beacon to ensure the attributes of their process match those of the pipe name format used by Mojo. Remember that minifilters with pre-operation callbacks for monitoring <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp> requests are guaranteed to be invoked in the context of the calling thread. This means that when a Beacon process creates the “mojo” named pipe, the minifilter can check that its current context matches the information in the pipe name. Pseudocode to demonstrate this would look like that shown in <a href="#list6-8">Listing 6-8</a>.</p>&#13;
<pre id="list6-8"><code>DetectMojoMismatch(string mojoPipeName)&#13;
{&#13;
 pid = GetCurrentProcessId();&#13;
 tid = GetCurrentThreadId();<span role="doc-pagebreak" epub:type="pagebreak" id="pg_118" aria-label=" Page 118. "/>&#13;
&#13;
<span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if (!mojoPipeName.beginsWith("mojo. " + pid + "." + tid + "."))&#13;
&#13;
  {&#13;
  // Bad Mojo pipe found&#13;
  }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-8: Detecting anomalous Mojo named pipes</span></p>&#13;
<p class="TX">Since the format used in Mojo named pipes is known, we can simply concatenate the PID and TID <span class="CodeAnnotation" aria-label="annotation1">❶</span> of the thread creating the named pipe and ensure that it matches what is expected. If not, we can take some defensive action.</p>&#13;
<p class="TX">Not every command inside Beacon will create a named pipe. There are certain functions that will create an anonymous pipe (as in, a pipe without a name), such as <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp>. These types of pipes have limited operational viability, as their name can’t be referenced and code can interact with them through an open handle only. What they lose in functionality, however, they gain in evasiveness.</p>&#13;
<p class="TX">Riccardo Ancarani’s blog post “Detecting Cobalt Strike Default Modules via Named Pipe Analysis” details the OPSEC considerations related to Beacon’s usage of anonymous pipes. In his research, he found that while Windows components rarely used anonymous pipes, their creation could be profiled, and their creators could be used as viable <i>spawnto</i> binaries. These included <i>ngen.exe</i>, <i>wsmprovhost.exe</i>, and <i>firefox.exe</i>, among others. By setting their sacrificial processes to one of these executables, attackers could ensure that any actions resulting in the creation of anonymous pipes would likely remain undetected.</p>&#13;
<p class="TX">Bear in mind, however, that activities making use of named pipes would still be vulnerable to detection, so operators would need to restrict their tradecraft to activities that create anonymous pipes only.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h2 class="H1" id="sec13"><span id="h-84"/><samp class="SANS_Futura_Std_Bold_B_11">Evading Minifilters</samp></h2>&#13;
<p class="TNI">Most strategies for evading an EDR’s minifilters rely on one of three techniques: unloading, prevention, or interference. Let’s walk through examples of each to demonstrate how we can use them to our advantage.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H2" id="sec14"><span id="h-85"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unloading</samp></h3>&#13;
<p class="TNI">The first technique is to completely unload the minifilter. While you’ll need administrator access to do this (specifically, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp> token privilege), it’s the most surefire way to evade the minifilter. After all, if the driver is no longer on the stack, it can’t capture events.</p>&#13;
<p class="TX">Unloading the minifilter can be as simple as calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmc.exe</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">unload</samp>, but if the vendor has put a lot of effort into hiding the presence of their minifilter, it might require complex custom tooling. To explore this idea further, let’s target Sysmon, whose minifilter, <i>SysmonDrv</i>, is configured in the registry, as shown in <a href="#list6-9">Listing 6-9</a>.</p>&#13;
<pre id="list6-9"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_119" aria-label=" Page 119. "/>PS &gt; <b>Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\SysmonDrv" | Select * </b>&#13;
<b>-Exclude PS* | fl</b>&#13;
&#13;
Type   : 1&#13;
Start  : 0&#13;
ErrorControl : 1&#13;
ImagePath : SysmonDrv.sys&#13;
DisplayName : SysmonDrv&#13;
Description : System Monitor driver&#13;
&#13;
PS &gt; <b>Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\SysmonDrv\Instances\</b>&#13;
<b>Sysmon Instance\" | Select * -Exclude PS* | fl</b>&#13;
&#13;
Altitude : 385201&#13;
Flags : 0</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-9: Using PowerShell to view</span> <span class="eSANS_Futura_Std_Book_11a">SysmonDrv’</span><span class="eSANS_Futura_Std_Book_Oblique_I_11a">s configuration</span></p>&#13;
<p class="TX">By default, <i>SysmonDrv</i> has the altitude 385201, and we can easily unload it via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmc.exe unload SysmonDrv</samp>, assuming the caller has the required privilege. Doing so would create a <i>FilterManager</i> event ID of 1, which indicates that a filesystem filter was unloaded, and a Sysmon event ID of 255, which indicates a driver communication failure. However, Sysmon will no longer receive events.</p>&#13;
<p class="TX">To complicate this process for attackers, the minifilter sometimes uses a random service name to conceal its presence on the system. In the case of Sysmon, an administrator can implement this approach during installation by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> flag to the installer and specifying a new name. This prevents an attacker from using the built-in <i>fltmc.exe</i> utility unless they can also identify the service name.</p>&#13;
<p class="TX">However, an attacker can abuse another feature of production minifilters to locate the driver and unload it: their altitudes. Because Microsoft reserves specific altitudes for certain vendors, an attacker can learn these values and then simply walk the registry or use <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</samp> to locate any driver with the altitude in question. We can’t use <i>fltmc.exe</i> to unload minifilters based on an altitude, but we can either resolve the driver’s name in the registry or pass the minifilter’s name to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterUnload()</samp> for tooling that makes use of <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</samp>. This is how the Shhmon tool, which hunts and unloads <i>SysmonDrv</i>, works under the hood.</p>&#13;
<p class="TX">Defenders could further thwart attackers by modifying the minifilter’s altitude. This isn’t recommended in production applications, however, because another application might already be using the chosen value. EDR agents sometimes operate across millions of devices, raising the odds of an altitude collision. To mitigate this risk, a vendor might compile a list of active minifilter allocations from Microsoft and choose one not already in use, although this strategy isn’t bulletproof.</p>&#13;
<p class="TX">In the case of Sysmon, defenders could either patch the installer to set the altitude value in the registry to a different value upon installation or manually change the altitude after installation by directly modifying the registry value. Since Windows doesn’t place any technical controls on <span role="doc-pagebreak" epub:type="pagebreak" id="pg_120" aria-label=" Page 120. "/>altitudes, the engineer could move <i>SysmonDrv</i> to any altitude they wish. Bear in mind, however, that the altitude affects the minifilter’s position in the stack, so choosing too low a value could have unintended implications for the efficacy of the tool.</p>&#13;
<p class="TX">Even with all these obfuscation methods applied, an attacker could still unload a minifilter. Starting in Windows 10, both the vendor and Microsoft must sign a production driver before it can be loaded onto the system, and because these signatures are meant to identify the drivers, they include information about the vendor that signed them. This information is often enough to tip an adversary off to the presence of the target minifilter. In practice, the attacker could walk the registry or use the <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</samp> approach to enumerate minifilters, extract the path to the driver on disk, and parse the digital signatures of all enumerated files until they’ve identified a file signed by an EDR. At that point, they can unload the minifilter using one of the previously covered methods.</p>&#13;
<p class="TX">As you’ve just learned, there are no particularly great ways to hide a minifilter on the system. This doesn’t mean, however, that these obfuscations aren’t worthwhile. An attacker might lack the tooling or knowledge to counter the obfuscations, providing time for the EDR’s sensors to detect their activity without interference.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h3 class="H2" id="sec15"><span id="h-86"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Prevention</samp></h3>&#13;
<p class="TNI">To prevent filesystem operations from ever passing through an EDR’s minifilter, attackers can register their own minifilter and use it to force the completion of I/O operations. As an example, let’s register a malicious pre-operation callback for <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> requests, as shown in <a href="#list6-10">Listing 6-10</a>.</p>&#13;
<pre id="list6-10"><code>PFLT_PRE_OPERATION_CALLBACK EvilPreWriteCallback;&#13;
&#13;
FLT_PREOP_CALLBACK_STATUS EvilPreWriteCallback(&#13;
 [in, out] PFLT_CALLBACK_DATA Data,&#13;
 [in] PCFLT_RELATED_OBJECTS FltObjects,&#13;
 [out] PVOID *CompletionContext&#13;
)&#13;
{&#13;
 <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-10: Registering a malicious pre-operation callback routine</span></p>&#13;
<p class="TX">When the filter manager invokes this callback routine, it must return an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp> value. One of the possible values, <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_COMPLETE</samp>, tells the filter manager that the current minifilter is in the process of completing the request, so the request shouldn’t be passed to any minifilters below the current altitude. If a minifilter returns this value, it must set the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Status</samp> member of the I/O status block to the operation’s final status. Antivirus engines whose minifilters communicate with user-mode scanning engines commonly use this functionality to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_121" aria-label=" Page 121. "/>determine whether malicious content is being written to a file. If the scanner indicates to the minifilter that the content is malicious, the minifilter completes the request and returns a failure status, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_VIRUS_INFECTED</samp>, to the caller.</p>&#13;
<p class="TX">But attackers can abuse this feature of minifilters to prevent the security agent from ever intercepting their filesystem operations. Using the earlier callback we registered, this would look something like what’s shown in <a href="#list6-11">Listing 6-11</a>.</p>&#13;
<pre id="list6-11"><code>FLT_PREOP_CALLBACK_STATUS EvilPreWriteCallback(&#13;
  [in, out] PFLT_CALLBACK_DATA Data,&#13;
  [in]  PCFLT_RELATED_OBJECTS FltObjects,&#13;
  [out]  PVOID *CompletionContext&#13;
)&#13;
{&#13;
<var>    --snip--</var>&#13;
<var>    </var>if (IsThisMyEvilProcess(PsGetCurrentProcessId())&#13;
<var>    </var>{&#13;
        <var>--snip--</var>&#13;
     <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span>  Data-&gt;IoStatus.Status = STATUS_SUCCESS;&#13;
        return FLT_PREOP_COMPLETE&#13;
    }&#13;
<var>    --snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 6-11: Intercepting write operations and forcing their completion</span></p>&#13;
<p class="TX">The attacker first inserts their malicious minifilter at an altitude higher than the minifilter belonging to the EDR. Inside the malicious minifilter’s pre-operation callback would exist logic to complete the I/O requests coming from the adversary’s processes in user mode <span class="CodeAnnotation" aria-label="annotation1">❶</span>, preventing them from being passed down the stack to the EDR.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h-87"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interference</samp></h3>&#13;
<p class="TNI">A final evasion technique, interference, is built around the fact that a minifilter can alter members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CALLBACK_DATA</samp> structure passed to its callbacks on a request. An attacker can modify any members of this structure except the <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestorMode</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> members. This includes the file pointer in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_IO_PARAMETER_BLOCK</samp> structure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetFileObject</samp> member. The only requirement of the malicious minifilter is that it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltSetCallbackDataDirty()</samp>, which indicates that the callback data structure has been modified when it is passing the request to minifilters lower in the stack.</p>&#13;
<p class="TX">An adversary can abuse this behavior to pass bogus data to the minifilter associated with an EDR by inserting itself anywhere above it in the stack, modifying the data tied to the request and passing control back to the filter manager. A minifilter that receives the modified request may evaluate whether <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_CALLBACK_DATA_DIRTY</samp>, which is set by <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltSetCallbackDataDirty()</samp>, is present and act accordingly, but the data will still be modified.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec17">&#13;
<h2 class="H1" id="sec17"><span id="h-88"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_122" aria-label=" Page 122. "/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">Minifilters are the de facto standard for monitoring filesystem activity on Windows, whether it be for NTFS, named pipes, or even mailslots. Their implementation is somewhat more complex than the drivers discussed earlier in this book, but the way they work is very similar; they sit inline of some system operation and receive data about the activity. Attackers can evade minifilters by abusing some logical issue in the sensor or even unloading the driver entirely, but most adversaries have adapted their tradecraft to drastically limit creating new artifacts on disk to reduce the chances of a minifilter picking up their activity.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>