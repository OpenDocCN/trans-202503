- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HOW CIRCUITS UNDERSTAND ONES AND ZEROS
  prefs: []
  type: TYPE_NORMAL
- en: 'Mobile phones, computers, TVs, video game consoles, and almost all the other
    technology you see around you is built with digital electronics. If you’ve ever
    looked inside a computer, the circuits might seem complex, but when you break
    that hardware down into small pieces, it’s actually quite simple: every action
    a computer takes is based on whether some circuit sees a high or low voltage.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve used transistors to make circuits that control things, and in this chapter,
    you’ll learn the basics of using digital electronics to make even smarter circuits.
    You’re going to learn a new number system, what bits and bytes are, and how you
    can use bits and bytes to create messages with electricity.
  prefs: []
  type: TYPE_NORMAL
- en: ONES AND ZEROS AS VOLTAGES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When I was in school, my teacher told me that computers used ones and zeros
    to communicate, but he didn’t explain it any further. I wanted to know more, so
    I decided to ask my dad. Because computers are complex machines, I assumed the
    way they use ones and zeros was going to be complex, too, but my dad told me,
    “In a computer, a one is just a wire with voltage, and a zero is a wire without
    voltage.” (By “without voltage,” my dad meant the voltage was zero.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In “[How to Set the Output Speed of the 555 Timer](ch08.xhtml#ch08lev2sec02)”
    on [page 166](ch08.xhtml#page_166), I mentioned briefly that the pins of the 555
    timer could be either high or low. The pins on the ICs in a computer work the
    same way: high is one, and low is zero. Digital circuits work by flipping the
    voltages on different wires between high and low.'
  prefs: []
  type: TYPE_NORMAL
- en: MEET THE BINARY NUMBER SYSTEM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally, when you talk about numbers, you use *decimal numbers*, which are
    in the *base-10* number system. In base-10 numbers, a digit can have one of 10
    possible values, from 0 to 9\. But digital circuits can work with only two voltages
    (high and low), so they can understand only *binary numbers*. Binary is also called
    the *base-2* number system, and a binary number’s digits have only two possible
    values: 0 and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you’d count to 10 in both decimal and binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal number** | **Binary number** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 101 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 110 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 111 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 1001 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1010 |'
  prefs: []
  type: TYPE_TB
- en: What’s going on here? The number 2 in decimal is 10 in binary, and 4 in decimal
    is 100 in binary!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can figure out the value of any number in any system using the digits and
    their position. The rightmost digit always gets multiplied by 1\. Going left from
    there, each position’s value equals the base times the value of the previous position.
    In decimal, the base is 10, so the second position’s value is 10, or 10 × 1; the
    third position’s value is 100, or 10 × 10; the fourth position’s value is 1000,
    or 10 × 100; and so on. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0189-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the number 181, the first digit is 1, the second digit is 8, and the third
    digit is 1\. Once you multiply those digits by their position values, you can
    add the resulting values to get 181\. You don’t need to use this method to figure
    out decimal numbers, though. It’s pretty clear that 181 equals 181! But this method
    is very useful for finding the value of binary numbers. Binary follows the same
    rules, but it uses a base of 2 instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'PROJECT #18: CONVERT FROM BINARY TO DECIMAL'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this project, you’re going to *convert* a binary number into its decimal
    form. Converting a number to a different base just means calculating that number’s
    value and writing it using digits in the new base.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **A pen or pencil** to write with.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **Paper** to write on.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **A calculator** to add numbers. If you’re
    good at doing math in your head, try this project without one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Write It Down on Paper'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, write an eight-digit binary number on paper, leaving space between the
    digits, both above and below the number. I’m going to convert the binary number
    1011 0101, and I wrote it out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0190-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 2: Write the Position Values'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, write the value of each position above each digit. Binary works the same
    way as the decimal example, but the base is 2\. That means the value for the rightmost
    position is 1, and to find the next position to the left, you’d multiply the previous
    position’s value by 2\. For example, the second position’s value is 2 × 1 = 2;
    the third position’s value is 2 × 2 = 4; the fourth value is 4 × 2 = 8; and so
    on. Use a calculator if you don’t want to calculate it all in your head. When
    you write those values down, you should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0191-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 3: Find the Value of Each Digit'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Look at each digit of the binary number you wrote down. If a digit is 0, write
    0 below it. If the digit is 1, write the value of that position below it. Those
    are the values you’ll add together to get your final decimal number.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0191-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 4: Add the Numbers'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You should now have three rows of numbers. Add the numbers in the bottom row
    (you might find it helpful to write a + sign between each pair of numbers) to
    get the sum, which is the decimal value of your binary number.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0192-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The binary number 1011 0101 is 181 in decimal. If you’ve been following along
    with that number and your answer is different, go through the steps again and
    check your results against mine to find out where the error is.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRY IT OUT: TRANSFORM MORE BINARY NUMBERS**'
  prefs: []
  type: TYPE_NORMAL
- en: To get more practice with ones and zeros, let’s bring some more binary numbers
    into the decimal world. Here are a few to try:[*](ch09.xhtml#fn01a)
  prefs: []
  type: TYPE_NORMAL
- en: '1010'
  prefs: []
  type: TYPE_NORMAL
- en: 0011 1111
  prefs: []
  type: TYPE_NORMAL
- en: 1000 0000
  prefs: []
  type: TYPE_NORMAL
- en: 0011 1011 0101
  prefs: []
  type: TYPE_NORMAL
- en: '[*](ch09.xhtml#fn_01a) In decimal, these binary numbers are 10, 63, 128, and
    949.'
  prefs: []
  type: TYPE_NORMAL
- en: BITS AND BYTES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each digit in a binary number is called a *bit* (that’s short for *binary digit*),
    and computers handle numbers in blocks of eight bits called a *byte*. The binary
    number 1011 0101 has eight bits, so it’s a byte. You can interact with a computer
    in many ways, but all your mouse clicks, key presses, webcam videos, and so on
    need to be translated into bits and bytes before the computer can understand them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, when working with computers and other digital gadgets, you usually
    see much, much larger numbers than just 1 byte. All the files on a computer are
    collections of bytes, but if you tried to describe their size in bytes alone,
    those numbers would be huge! That’s why files are usually described in larger
    units, like kilobytes[*](footnote.xhtml#fn02) (kB), megabytes (MB), gigabytes
    (GB), terabytes (TB), and so on. Here’s what those units mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 kB | = 1,000 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 1 MB | = 1,000 kB = 1,000,000 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 1 GB | = 1,000 MB = 1,000,000 kB = 1,000,000,000 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 1 TB | = 1,000 GB = 1,000,000 MB = 1,000,000,000 kB = 1,000,000,000,000 bytes
    |'
  prefs: []
  type: TYPE_TB
- en: If a computer’s hard disk can hold 1 TB of data, then it can hold one trillion
    bytes, which is eight trillion ones and zeros!
  prefs: []
  type: TYPE_NORMAL
- en: NUMBERS CAN BE ANYTHING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you might be thinking, “Why on Earth would I ever need eight trillion ones
    and zeros in my computer?” The fact is, whether you use a computer to write stories,
    draw pictures, talk to your friends, play video games, or anything else, you’re
    actually using those ones and zeros.
  prefs: []
  type: TYPE_NORMAL
- en: For example, how does a computer show an image on a screen? A computer screen
    is made of a lot of small points called *pixels*, and each pixel can be set to
    a color that is a mix of red, green, and blue light. If you want a pixel to be
    the brightest yellow possible, you’d use numbers to tell the computer to turn
    that pixel’s red and green settings to full intensity and its blue setting to
    zero (because mixed red and green light looks like yellow). This way you can translate
    numbers into an image on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'PROJECT #19: COLOR GUESSING GAME'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this project, you’ll build a pixel-color guessing game using binary values.
    It’s a two-player game where you and a friend take turns being “the computer”
    and “the user.”
  prefs: []
  type: TYPE_NORMAL
- en: The person who is the computer sets the color of the pixel by pushing a combination
    of three buttons. When the computer is ready, the user must try to guess which
    color the pixel is. When the user is ready to make the guess, they should say
    the chosen color out loud and then push the color revealer button to show the
    actual color. If the user guesses correctly, they get one point and get to guess
    again. If the guess is wrong, you switch roles. The first one to reach three points
    wins the round.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0194-01.jpg)![image](../images/f0195-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Meet the RGB LED
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the pixel for this project, you’re going to use a *red-green-blue
    (RGB) LED*, which combines a red LED, a green LED, and a blue LED into one component.
    By turning on and off each of these LEDs, you can create different colors. For
    example, turning on only the red and green LEDs would give you yellow.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of RGB LEDs: *common anode* and *common cathode*. This
    is what a common anode RGB LED looks like, along with its symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0195-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: RGB LEDs have four legs. You’ll use three legs to set the color, and the fourth
    leg is the *common* leg. In common anode RGB LEDs, the positive (anode) sides
    of the three LEDs are combined into one pin; common cathode RGBs combine the negative
    (cathode) sides into one pin.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’re going to build the following circuit, which uses a common
    anode RGB LED and some buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Shopping List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![image](../images/f0196-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![image](../images/common-01.jpg) **A standard 9 V battery** to power the circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **A 9 V battery clip** (Jameco #11280, Bitsbox
    #BAT033) to connect the battery to the circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **A breadboard** (Jameco #20601, Bitsbox
    #CN329) with at least 30 rows.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **Breadboard jumper wires** (Jameco #2237044,
    Bitsbox #CN236) to easily connect parts. (Standard hookup wire works, too.)'
  prefs: []
  type: TYPE_IMG
- en: '![image](../images/common-01.jpg) **Three 330 Ω resistors** (Jameco #661386,
    Bitsbox #CR25330R) for limiting the current to the LED.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **RGB LED with common anode** (Jameco #2219567,
    Bitsbox #OP100) to create colors.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **Four push buttons** (Jameco #119011, Bitsbox
    #SW087) to set and reveal colors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Place the Color Chooser’s Push Buttons'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Orient your breadboard so that the notch down the middle runs from top to bottom.
    Then, place three push buttons at the bottom of your breadboard; each should have
    one pair of legs on the left side of the notch and one pair on the right. This
    should leave you plenty of room to connect components on both sides of the buttons,
    and you’ll be able to separate the computer’s buttons from the user’s button more
    easily. With your buttons in position, connect three jumper wires from the bottom-right
    pin of each push button to the negative supply column.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0197-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 2: Connect the RGB LED'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the middle of the board on the left, connect your RGB LED. The longest leg
    of the RGB LED is the common anode leg. Leave this unconnected for now. Connect
    a 330 Ω resistor from each of the remaining LED legs to an empty row on the right
    side of the breadboard. From each of these three rows, connect a jumper wire to
    the top-left pin of each push button.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0198-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 3: Connect the Color Revealer Button'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, add the button that reveals the computer’s chosen color to the user. Place
    a fourth push button all the way at the top of the breadboard, across the middle
    notch. Connect a jumper wire from the common anode leg of the RGB LED to the top-left
    pin of the fourth push button. Then, connect one jumper wire from the bottom-right
    pin of this push button to the positive supply column on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0199-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 4: Test the Colors'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Connect the battery clip to the supply columns on the right, connect a battery,
    and try it out! Push some of the buttons on the bottom and then push the color
    revealer button to see the color. In this photo, I set my RGB LED to green.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0199-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You should be able to see the following seven colors, depending on which buttons
    you push:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Color** | **Top button** | **Middle button** | **Lower button** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Red | Pushed (1) | Not pushed (0) | Not pushed (0) |'
  prefs: []
  type: TYPE_TB
- en: '| Green | Not pushed (0) | Pushed (1) | Not pushed (0) |'
  prefs: []
  type: TYPE_TB
- en: '| Blue | Not pushed (0) | Not pushed (0) | Pushed (1) |'
  prefs: []
  type: TYPE_TB
- en: '| Yellow | Pushed (1) | Pushed (1) | Not pushed (0) |'
  prefs: []
  type: TYPE_TB
- en: '| Cyan | Not pushed (0) | Pushed (1) | Pushed (1) |'
  prefs: []
  type: TYPE_TB
- en: '| Magenta | Pushed (1) | Not pushed (0) | Pushed (1) |'
  prefs: []
  type: TYPE_TB
- en: '| White | Pushed (1) | Pushed (1) | Pushed (1) |'
  prefs: []
  type: TYPE_TB
- en: If your buttons do not match these colors, switch the wires between the three
    resistors to the buttons so that they match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: What If the Game Doesn’t Work?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you see no colors at all, check that your connections match the circuit diagram.
    If the connections are correct and you still can’t see any colors when pushing
    the color revealer button, you may have a common cathode LED instead of a common
    anode. To check for this, simply switch the positive and negative connections
    from the battery.
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve verified that all the colors work, invite a friend to play!
  prefs: []
  type: TYPE_NORMAL
- en: '**TRY IT OUT: SOLDER THE COLOR GUESSING GAME**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a perfect circuit to practice your soldering skills on. Get a prototyping
    board and solder the circuit onto it so that you have a permanent Color Guessing
    Game to bring with you on a long car ride.
  prefs: []
  type: TYPE_NORMAL
- en: HOW BINARY NUMBERS CAN CREATE WORDS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Images aren’t the only things that can be stored as binary numbers; you can
    represent letters as numbers, too. One way to do this is to use the *ASCII code*,
    which is a standard set of bytes that computers understand as upper- and lowercase
    letters, numbers, punctuation marks, and so on. The numbers in this table represent
    the lowercase letters in the English alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Decimal ASCII code** | **Binary value** | **Lowercase letter** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 97 | 0110 0001 | a |'
  prefs: []
  type: TYPE_TB
- en: '| 98 | 0110 0010 | b |'
  prefs: []
  type: TYPE_TB
- en: '| 99 | 0110 0011 | c |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 0110 0100 | d |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | 0110 0101 | e |'
  prefs: []
  type: TYPE_TB
- en: '| 102 | 0110 0110 | f |'
  prefs: []
  type: TYPE_TB
- en: '| 103 | 0110 0111 | g |'
  prefs: []
  type: TYPE_TB
- en: '| 104 | 0110 1000 | h |'
  prefs: []
  type: TYPE_TB
- en: '| 105 | 0110 1001 | i |'
  prefs: []
  type: TYPE_TB
- en: '| 106 | 0110 1010 | j |'
  prefs: []
  type: TYPE_TB
- en: '| 107 | 0110 1011 | k |'
  prefs: []
  type: TYPE_TB
- en: '| 108 | 0110 1100 | l |'
  prefs: []
  type: TYPE_TB
- en: '| 109 | 0110 1101 | m |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | 0110 1110 | n |'
  prefs: []
  type: TYPE_TB
- en: '| 111 | 0110 1111 | o |'
  prefs: []
  type: TYPE_TB
- en: '| 112 | 0111 0000 | p |'
  prefs: []
  type: TYPE_TB
- en: '| 113 | 0111 0001 | q |'
  prefs: []
  type: TYPE_TB
- en: '| 114 | 0111 0010 | r |'
  prefs: []
  type: TYPE_TB
- en: '| 115 | 0111 0011 | s |'
  prefs: []
  type: TYPE_TB
- en: '| 116 | 0111 0100 | t |'
  prefs: []
  type: TYPE_TB
- en: '| 117 | 0111 0101 | u |'
  prefs: []
  type: TYPE_TB
- en: '| 118 | 0111 0110 | v |'
  prefs: []
  type: TYPE_TB
- en: '| 119 | 0111 0111 | w |'
  prefs: []
  type: TYPE_TB
- en: '| 120 | 0111 1000 | x |'
  prefs: []
  type: TYPE_TB
- en: '| 121 | 0111 1001 | y |'
  prefs: []
  type: TYPE_TB
- en: '| 122 | 0111 1010 | z |'
  prefs: []
  type: TYPE_TB
- en: For example, the letter *a* can be represented by the decimal number 97, which
    is the binary number 0110 0001\. You can use this table to encode and decode secret
    messages written with only ones and zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'PROJECT #20: THE SECRET MESSAGE MACHINE'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This project is a circuit that shows eight-bit binary numbers with LEDs. An
    LED that is lit is a 1, and an LED that is off is a 0\. You’ll use switches to
    set the binary number and a push button to show the binary number on the LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: Eight bits are enough to represent an ASCII character, so you can use this project
    to generate secret messages that can only be decoded by someone who knows binary!
    This finished Secret Message Machine shows the letter *w*, or 0111 0111.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0202-01.jpg)![image](../images/f0203-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Meet the DIP Switch
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This circuit uses eight switches to set the binary value, but it would be a
    pain to plug that many individual buttons into your breadboard. Fortunately, you
    can just use a *DIP switch*, which is a component with a row of one or more mini
    switches.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0204-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*DIP stands for* dual in-line package, *which is how the pins are arranged.
    A component with “DIP” in its name has two rows of pins that you can plug into
    a breadboard. The DIP switch in this project has eight individual switches. This
    is perfect for creating a binary value input to a row of LEDs.*'
  prefs: []
  type: TYPE_NORMAL
- en: Shopping List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **A standard 9 V battery** to power the circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **A 9 V battery clip** (Jameco #11280, Bitsbox
    #BAT033) to connect the battery to the circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **A breadboard** (Jameco #20601, Bitsbox
    #CN329) with at least 30 rows.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **Breadboard jumper wires** (Jameco #2237044,
    Bitsbox #CN236) to easily connect parts. (Standard hookup wire works, too.)'
  prefs: []
  type: TYPE_IMG
- en: '![image](../images/common-01.jpg) **Eight 330 Ω resistors** (Jameco #661386,
    Bitsbox #CR25330R) for limiting the current to the LEDs. Any value between 270
    Ω and 470 Ω works well.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **Eight blue LEDs** (Jameco #2193889, Bitsbox
    #OP033) to show the binary number.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **One 8-position DIP switch** (Jameco #696984,
    Bitsbox #SW098) to set the binary number.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg) **A push button** (Jameco #119011, Bitsbox
    #SW087) to turn on the LEDs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0205-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 1: Connect the Push Button'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Plug the push button into the top of your breadboard. This project will take
    up a lot of space on your breadboard, so from here on, try to keep your components
    as close together as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Connect a jumper wire from the top-right breadboard row, which should be connected
    to the upper pin of the push button, to the positive supply rail on the right
    side. Then, connect a jumper wire from the lower pin to the positive supply column
    on the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your breadboard should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0206-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This push button controls the connection from the battery’s positive terminal
    to the rest of the circuit. When the button is not pushed, there’s no closed loop
    for the current to flow through, and the circuit doesn’t have power.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Connect the DIP Switch'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, connect the DIP switch to your breadboard just below the push button,
    with the numbers on the right side of the middle notch. Run one jumper wire from
    each of the eight rows to the positive supply column on the left, for a total
    of eight wires. You’ll need to be able to set the switches on and off, so connect
    the wires as far away from the switch as possible to leave room for your fingers.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0207-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 3: Connect the LEDs'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, connect one LED’s short leg to the negative supply column on the right,
    and connect its long leg to the last row at the bottom of your breadboard. Follow
    the same pattern upward to plug the rest of the LEDs into the breadboard on rows
    of their own, leaving one empty row between LEDs. (If you want to make it easier
    to read the LEDs, put your LEDs in two groups of four by leaving a couple of extra
    rows after the fourth LED.) Then, connect a resistor from each row with an LED
    to the same row on the left side of the notch in the middle of the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0208-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It will be best to connect the LEDs and switches so that you and your friend
    can sit on opposite sides of the board and see the bits in the same order, so
    pay careful attention to these connections. With your resistors in place, connect
    a jumper wire from each resistor row on the left side of the breadboard notch
    to a DIP-switch pin on the right side of the notch. Connect the resistor closest
    to the bottom of the breadboard to Switch 1, the next LED to Switch 2, and so
    on; you should end by connecting the top resistor to Switch 8.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0208-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Step 4: Send a Secret Message!'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Connect the negative side of the battery clip to the negative supply column,
    and then connect the positive side to the positive supply column, as shown.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0209-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, push all the switches in the “on” direction, press and hold the button
    to see whether all the lights light up, and turn off each LED one by one.
  prefs: []
  type: TYPE_NORMAL
- en: If all the LEDs work, it’s time to play! Invite a friend over and use this circuit
    to “talk” to them without speaking. Sit on opposite sides of a table, write down
    a word on a piece of paper for your own reference, and keep it hidden from your
    friend. Look at the ASCII code table and set the switches to the binary values
    for the first letter in your word. For example, the switch in the next photo is
    set to display a lowercase letter *a*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0210-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When your switch bank is ready to show a letter, push the button so that the
    LEDs light up. Hold the push button while your friend writes down the binary value.
    Then, release the push button and set the binary value for the next character.
    Keep doing this until you’ve shown all the characters in your word. When you’re
    done, show the ASCII code table to your friend so they can try to figure out your
    word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: What If the Secret Message Machine Doesn’t Work?'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve been following along for the whole book, you’ve connected a lot of
    LED circuits, but this one does have a lot of components. It’s easy to make a
    wrong connection somewhere, so if your circuit doesn’t work right away, check
    each connection carefully against this project’s circuit diagram.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the lights work, first check that the battery’s positive and negative
    terminals are connected correctly. Next, check that the LEDs are oriented the
    right way and that the resistors are the right values. If some lights work while
    others don’t, then some of the LED or resistor legs may be touching when they
    shouldn’t. Inspect them closely to find the error.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHY COMPUTERS USE ONES AND ZEROS**'
  prefs: []
  type: TYPE_NORMAL
- en: Computers use ones and zeros instead of the decimal numbers from 0 to 9 because
    when you have only two values, it makes constructing electronic circuits to do
    calculations and store the values much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, because each digit has only two possible values, one or zero,
    it’s easy to create a simple memory block to store binary numbers using switches,
    as you did with the DIP switch in Project #20.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to save ones and zeros in many different ways, thereby creating
    *memory*. In the early days of computing, it was common to save sets of ones and
    zeros as physical cards with holes in them. Today, many hard disks save ones and
    zeros on magnetic disks, or even via electrons stored inside an integrated circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT’S NEXT?**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how binary numbers work. You’ve seen how ones and
    zeros can be used to show images on your computer screen and how to decode a bunch
    of seemingly random ones and zeros into readable text. To explore binary numbers
    a bit more, come up with your own binary codes for the letters in the alphabet.
    There are 26 letters from *a* to *z*. How many digits do you need to represent
    all 26 letters? To figure this out, you can start by saying that the binary number
    1 means *a*. The next binary number, 10, is *b*. Next, 11, is *c*. Write this
    down and keep increasing until you reach *z*. Then, count the number of digits
    you needed for the *z*. This is the minimum number of digits you need.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another thing to try. Normally, if you count with your fingers, you can
    count to 10, right? If you don’t use your thumbs, you can only count to 8\. But
    what if you count in binary instead? A straight finger is 1, and a bent finger
    is 0\. How high can you count with eight fingers now?
  prefs: []
  type: TYPE_NORMAL
- en: 'Digital values have another very important use: they allow you to create *logic
    circuits*, which make decisions based on whether certain wires see a high voltage
    or a low voltage. High is typically considered “true,” and low is typically “false.”
    If those wires are associated with simple true-or-false questions and the voltages
    are the answers, then you can think of the output from a logic circuit as a conclusion
    reached after asking a series of questions.'
  prefs: []
  type: TYPE_NORMAL
- en: With logic, you can make circuits that do math, like adding two numbers, or
    circuits that do something only under a certain condition, like a door lock that
    opens only if you input the right combination of numbers. In [Chapter 10](ch10.xhtml#ch10),
    I’ll show you some of the building blocks of digital logic and how you can make
    smart circuits with them.
  prefs: []
  type: TYPE_NORMAL
