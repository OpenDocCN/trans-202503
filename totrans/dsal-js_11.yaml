- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 9 SEARCHING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9 搜索
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'This chapter deals with a common problem: given a set of values, find whether
    a certain key is in the set. This definition has similar aspects to logic that
    we’ll explore in future chapters when you implement a dictionary abstract data
    type (ADT), but we’ll be concerned only with the search part here. We won’t look
    at adding or deleting keys. In addition, we’ll deal only with arrays and explore
    other data structures in future chapters.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的是一个常见问题：给定一组值，查找某个特定的键是否在这组值中。这个定义与我们将在未来章节中实现字典抽象数据类型（ADT）时所探讨的逻辑有相似之处，但我们这里只关注搜索部分，不涉及添加或删除键。此外，我们只讨论数组，其他数据结构将在未来章节中探讨。
- en: Search Definition
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索定义
- en: In all cases in this chapter, the problem to solve is that, given an array (ordered
    or unordered, possibly with repeated values) and a key, you want to learn at which
    position of the array you can find the key. You’ll return -1 to match several
    of JavaScript’s own methods if the key isn’t in the array.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有情况中，待解决的问题是：给定一个数组（有序或无序，可能包含重复值）和一个键，你需要知道在数组的哪个位置可以找到该键。如果数组中没有该键，你将返回
    -1，以匹配 JavaScript 的一些内置方法。
- en: As a further optional requirement, you may sometimes want to find the first
    (or last) occurrence of a key in an array (in the case where the array has repeated
    keys), or if an array doesn’t include a key, you might want to know in which position
    it should have been.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个进一步的可选要求，有时你可能需要在数组中查找某个键的第一次（或最后一次）出现（如果数组中有重复的键），或者如果数组中不包含某个键，你可能希望知道它应该位于哪个位置。
- en: It’s important to keep in mind whether you’re doing a single search or many
    searches. If the latter, you may amortize over time the cost of, say, sorting
    the data or building some other data structure. If the former, you just want the
    speediest possible search. (In later chapters you’ll explore examples of data
    structures that help make searches faster.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住你是进行一次搜索还是多次搜索。如果是后者，你可以随着时间的推移摊销某些操作的成本，比如排序数据或构建其他数据结构。如果是前者，你只需要最快的搜索速度。（在后续章节中，你将探讨一些数据结构示例，帮助加快搜索速度。）
- en: There are more efficient algorithms for sorted arrays than for unsorted ones;
    we’ll start with the latter and then move on to better-performing ones.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有序数组，有更高效的算法；我们将从无序数组开始，然后转向性能更好的算法。
- en: Searching Unsorted Arrays
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索无序数组
- en: The first set of algorithms you’ll consider performs a linear search in a disordered
    array and is the most basic (these are also known as sequential or serial searches).
    If the array is not in any order, there’s no other way to search than to start
    at the beginning and go through the whole array. This kind of search is obviously
    slow and *O*(*n*), but for small arrays, it’s quite reasonable. Furthermore, JavaScript
    has its own methods for this kind of search, so if the conditions of your problem
    allow it, the functions in the next section are probably the best bet.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你将考虑的第一组算法在无序数组中执行线性搜索，这是最基础的（这些也被称为顺序或串行搜索）。如果数组没有任何顺序，唯一的搜索方法就是从开始遍历整个数组。这种搜索显然比较慢，时间复杂度为
    *O*(*n*)，但对于小数组来说，还是相当合理的。此外，JavaScript 本身也有用于这种搜索的方法，所以如果问题的条件允许，接下来一节中的函数可能是最好的选择。
- en: JavaScript’s Methods
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JavaScript 的方法
- en: To find whether a given key is in an array along with its position, JavaScript
    provides several interesting functions. If you just want to know whether the key
    is there, you can use the array.includes(key) method, which returns true or false
    depending on whether the key was found. If you want the position of the key in
    the array (which you’ll want throughout this chapter), then array.indexOf(key)
    does the job. It returns the first position at which the key is found or -1 if
    it wasn’t found.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查找某个键是否在数组中及其位置，JavaScript 提供了几个有趣的函数。如果你只想知道键是否存在，可以使用 array.includes(key)
    方法，该方法根据键是否被找到返回 true 或 false。如果你需要知道键在数组中的位置（在本章中你将始终需要这个），那么 array.indexOf(key)
    就能完成这个任务。它返回键第一次出现的位置，如果没有找到，则返回 -1。
- en: These methods all perform in *O*(*n*) time, and they go through the array from
    the beginning to the end. This performance matches that of the linear search you’ll
    consider next.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都在 *O*(*n*) 时间内执行，并且它们从数组的开始遍历到末尾。这个性能与接下来你将考虑的线性搜索相匹配。
- en: Linear Search
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线性搜索
- en: The linear search algorithm is basically an implementation of JavaScript’s own
    .indexOf(...) method. It searches simply by looping through the whole array checking
    whether it finds what you want.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索算法基本上是 JavaScript 自带的 .indexOf(...) 方法的实现。它通过遍历整个数组来检查是否找到你需要的值。
- en: '[Figure 9-1](chapter9.xhtml#fig9-1) shows two searches: a successful one for
    60 and an unsuccessful one for 50.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](chapter9.xhtml#fig9-1)展示了两次搜索：一次是成功找到 60，另一次是未能找到 50。'
- en: '![](../images/Figure9-1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-1.jpg)'
- en: 'Figure 9-1: A linear search starts at the beginning and advances until it finds
    the desired key or gets to the end of the array.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：线性搜索从数组开始位置开始，直到找到目标值或到达数组末尾。
- en: 'The process starts at the beginning and continues until it reaches the desired
    key or the end of the array. This kind of algorithm is often taught very early
    to future developers as a basic example of looping. Here’s an implementation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程从头开始，直到找到目标值或到达数组末尾为止。这种算法通常在早期就教授给未来的开发者，作为循环的基本示例。以下是实现代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Loop through the array ❶, and if you find the key you want ❷, return its position.
    If the loop ends without success ❸, return -1 as defined.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历数组 ❶，如果找到目标值 ❷，返回它的位置。如果循环结束仍未找到目标值 ❸，则按定义返回 -1。
- en: 'The performance of this algorithm is *O*(*n*) in the worst case, and for successful
    searches, you do an average of *n*/2 probes, so the result is still *O*(*n*).
    There’s no way to seriously speed up a search in a disordered array, but a small
    trick may help a little bit: using a sentinel.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种算法在最坏情况下的性能是 *O*(*n*)，而对于成功的搜索，平均需要进行 *n*/2 次探测，因此结果仍然是 *O*(*n*)。在无序数组中，无法显著加速搜索，但一个小技巧可能稍微有点帮助：使用哨兵。
- en: Linear Search with Sentinels
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带有哨兵的线性搜索
- en: 'Before searching for a key, append that value at the end of the array, so the
    search is guaranteed to succeed. [Figure 9-2](chapter9.xhtml#fig9-2) shows the
    same two searches from the previous section: the first is successful because it
    found 60 before the end of the array, but the second is a failure because it found
    only the 50 that was added, as that value wasn’t originally in the array.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索目标值之前，先将该值添加到数组末尾，这样搜索就能确保成功。[图 9-2](chapter9.xhtml#fig9-2)展示了与前面相同的两次搜索：第一次成功，因为在数组末尾之前找到了
    60，而第二次失败，因为只找到了添加的 50，而这个值最初并不在数组中。
- en: '![](../images/Figure9-2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-2.jpg)'
- en: 'Figure 9-2: Adding a sentinel lets you advance without passing the end of the
    array.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：添加哨兵后，可以在不越过数组末尾的情况下继续搜索。
- en: 'You can loop through the array without checking for its end, because you know
    for sure that you’ll eventually find the key. The only consideration now is where
    you find it: if it’s at the end, you found only the added sentinel, so the search
    was unsuccessful. Here’s the logic:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不检查数组结束位置的情况下遍历数组，因为你确定最终会找到目标值。现在唯一需要考虑的是在哪里找到它：如果它出现在数组末尾，你只找到了添加的哨兵值，搜索是失败的。逻辑如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Start by adding the key to search for at the end of the array ❶. Then start
    searching at the first position as before ❷ until you find the key ❸. You don’t
    have to check for the end of the array because you know you’ll find the key you
    want. After finding the key, restore the array ❹ (assigning a new length is enough
    for this, but the .pop(...) method is probably more common) and then decide what
    to return depending on where you find the key ❺. If it’s at the end, it’s a failure,
    and if it’s earlier, it’s a success.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 先将要搜索的值添加到数组末尾 ❶。然后像之前一样从第一个位置开始搜索 ❷，直到找到目标值 ❸。你不需要检查数组的末尾，因为你知道一定会找到目标值。找到目标值后，恢复数组
    ❹（只需重新赋值数组的长度即可，虽然 .pop(...) 方法可能更常用），然后根据找到目标值的位置决定返回什么 ❺。如果目标值在末尾，则是失败；如果目标值在之前的位置，则是成功。
- en: The performance of this algorithm is still *O*(*n*); the only (slight) advantage
    may derive from the simpler check in the loop, so the iteration goes faster, but
    don’t expect a big impact from that. In addition, if adding the sentinel causes
    JavaScript to create a new array and copy the old one, the algorithm could become
    even slower.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种算法的性能仍然是 *O*(*n*)；唯一（轻微的）优势可能来自于循环中更简单的检查，使得迭代速度更快，但不要指望这个会产生大影响。此外，如果添加哨兵导致
    JavaScript 创建一个新数组并复制原数组，那么算法的速度可能会更慢。
- en: 'When all is said and done, using linear search can’t be enhanced by much, and
    you’ve gone as far as possible with unordered arrays. You’ll now move on to doing
    searches in ordered (sorted) arrays, for which far better algorithms are possible.  ###
    Searching Ordered Arrays'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切都说完后，线性搜索的提升空间非常有限，而且在无序数组中已经达到了极限。接下来你将开始在有序（排序）数组中进行搜索，针对有序数组，可以使用更优的算法。###
    搜索有序数组
- en: If the array to be searched is ordered, you can apply better techniques. For
    instance, if you learn that the value at a certain position of the array is greater
    than the key you’re searching for, you can instantly discard all values after
    that position, because the key can’t be there. All the nonlinear search algorithms
    (also known as *interval searches*) in this section take advantage of order either
    to advance more quickly through the array or to discard large portions of it,
    reducing the area to search.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要搜索的数组是有序的，你可以应用更好的技术。例如，如果你知道数组中某个位置的值大于你要查找的关键值，你可以立即舍弃该位置之后的所有值，因为关键值不可能在这些位置。本文节中的所有非线性搜索算法（也称为*区间搜索*）都利用了数组的顺序，要么加速数组的搜索，要么舍弃其中的大部分，从而减少需要搜索的区域。
- en: Jump Search
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跳跃搜索
- en: The basic linear search described earlier potentially goes through the complete
    array, which makes for *O*(*n*) performance with no possibility for enhancement.
    However, if the array is ordered, you don’t have to go through it one by one.
    Just as when someone is looking for a certain page in a book, they won’t turn
    each page one by one; they’ll skip through the book several pages at a time, and
    then go one by one when closer to the goal.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面描述的基本线性搜索可能会遍历整个数组，这使得其性能为*O*(*n*)，且无法进一步优化。然而，如果数组是有序的，你就不需要逐一遍历它。就像当有人在寻找书中的某一页时，他们不会一页一页翻，而是会一次跳过几页，靠近目标时再逐页查找。
- en: The idea behind the jump search algorithm is similar to that of Shell sort (see
    [Chapter 6](chapter6.xhtml)). You start with big jumps to get quickly to the vicinity
    of the key that you want and then do smaller jumps. [Figure 9-3](chapter9.xhtml#fig9-3)
    shows how we’d search for 42, assuming an initial jump size of 4\. (We’ll get
    to what the jump size should be later.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃搜索算法的思路与Shell排序相似（见[第6章](chapter6.xhtml)）。你首先进行大跳跃，快速接近目标位置，然后再进行小跳跃。[图9-3](chapter9.xhtml#fig9-3)展示了我们如何搜索42，假设初始跳跃大小为4。（我们稍后会讨论跳跃大小应该是多少。）
- en: '![](../images/Figure9-3.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-3.jpg)'
- en: 'Figure 9-3: A jump search tries to advance faster by making big jumps whenever
    possible.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3：跳跃搜索通过尽可能大幅度地跳跃来加速查找过程。
- en: At the top you do a linear search but with big jumps, skipping four values at
    a time. The first value you find is 04, which is too low, so you jump again. Next
    you find 14 and then 24, but both are still too low. The next jump gets you to
    49, so now you know that 42 is (if present) after the 24 and before the 49\. You
    then start a regular linear search, with short jumps advancing one position at
    a time. You check 34 and 40 and succeed at 42\. If you had been searching for
    41 instead, when you reached 42, you’d decide that 41 wasn’t present and return
    –1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，你进行线性搜索，但采用大跳跃，每次跳过四个值。你找到的第一个值是04，太小了，所以你再次跳跃。接着你找到了14和24，但它们依然太小。下一次跳跃让你到达49，现在你知道42（如果存在的话）在24之后、49之前。然后你开始进行常规的线性搜索，短跳跃，每次推进一个位置。你检查了34和40，并成功找到了42。如果你当时在寻找41，那么当你到达42时，你会判断41不存在并返回–1。
- en: 'What’s the expected number of tests for this algorithm? If the step size is
    *s* and the array size is *n*, you can have up to *n*/*s* long jumps, followed
    by *s* short jumps, which is *n*/*s* + *s* in total. Some calculus proves that
    this is optimum when *s* is √*n*, for a maximum of 2√*n* tests, so we’ll use that
    value, as shown in the following implementation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的预期测试次数是多少？如果步长是*s*，数组大小是*n*，你可以进行最多*n*/*s*次大跳跃，接着是*s*次小跳跃，总共是*n*/*s* +
    *s*次。通过一些微积分证明，当*s*为√*n*时，这是最优解，最多进行2√*n*次测试，所以我们将使用这个值，如以下实现所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Start by determining the size of the long jump ❶, making sure that it’s at least
    2\. (The jump size could be 1 only for very short arrays.) The i variable goes
    through the array ❷. Start by jumping s places every time ❸. If you don’t go past
    the end of the array and the array value you test is not greater than the key
    you are looking for, you can do a jump by updating i. After this series of jumps,
    i points to a value not greater than the key you want, and you do a new loop,
    advancing by 1 ❹. After this loop ends ❺, if you find the key, return its position;
    otherwise, return -1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确定长跳跃的大小 ❶，确保它至少为 2。（对于非常短的数组，跳跃大小只能为 1。）i 变量遍历数组 ❷。每次跳跃 s 个位置 ❸。如果没有越过数组的末尾且测试的数组值不大于你正在寻找的目标，则可以通过更新
    i 进行跳跃。在一系列跳跃之后，i 指向的值不大于目标值，然后进入新的循环，按 1 前进 ❹。这个循环结束后 ❺，如果找到目标，则返回其位置；否则返回 -1。
- en: The code has two similar while loops. In one case you jump by s, and in the
    other you jump by 1.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中有两个相似的 while 循环。在其中一个情况下，你按 s 跳跃，在另一个情况下，按 1 跳跃。
- en: 'Consider another implementation that suggests a more enhanced solution. First,
    here’s the code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一种实现方式，它提出了一种更为优化的解决方案。首先，这是代码：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You’re now not using a const for s ❶ because you’ll change its value for the
    second loop. Set up an external loop ❷ depending on s. When it reaches 0, you’re
    done. The internal loop is the same as before, where you always jump s places
    at a time ❸, but s later becomes 1 to make short jumps. After finishing a loop
    ❹, reduce s. If it was greater than 1, jump by 1, and if it already was 1, end
    the loop, setting it to 0\. Deciding what value to return ❺ is exactly the same
    as in the previous version of the algorithm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你不再为 s 使用常量 ❶，因为你会在第二个循环中更改它的值。根据 s 设置外部循环 ❷。当 s 为 0 时，循环结束。内部循环与之前相同，每次跳跃
    s 个位置 ❸，但随后 s 会变为 1，进行短跳跃。完成一个循环后 ❹，减少 s。如果 s 大于 1，则按 1 跳跃；如果 s 已为 1，则结束循环，将 s
    设置为 0。决定返回值 ❺ 与之前的版本相同。
- en: 'You did the search in two stages: long jumps first, followed by shorter jumps,
    and you got the searches down to *O*(√*n*). What if you had three stages, with
    very long jumps first, followed by not-as-long jumps, and shorter jumps to finish?
    Jumps at one level are proportionally greater to jumps in the next level. (We’ll
    revisit this concept of jumps that decrease in size when looking at skip lists
    in [Chapter 11](chapter11.xhtml).) [Figure 9-4](chapter9.xhtml#fig9-4) shows how
    it works with three jump levels, searching for a value in an array of 27.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你分两阶段完成了搜索：先进行长跳跃，再进行短跳跃，从而将搜索次数降低到 *O*(√*n*)。如果你有三个阶段，首先进行非常长的跳跃，然后是较长的跳跃，最后用较短的跳跃结束，会怎样呢？在每一阶段，跳跃的长度都相对上一阶段更小。（我们将在第[11章](chapter11.xhtml)的跳表中重新审视这种跳跃逐渐减小的概念。）[图9-4](chapter9.xhtml#fig9-4)展示了在27个元素的数组中使用三层跳跃搜索值的工作原理。
- en: '![](../images/Figure9-4.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-4.jpg)'
- en: 'Figure 9-4: A search in three levels'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-4：三层跳跃搜索
- en: The first jumps are nine elements apart. After finding in which block of nine
    the key should be, you start with jumps three elements apart; grayed elements
    are places where the key you want can’t be. After you learn in which block of
    three the key is (allowing you to gray out more elements), you finish with single-element
    jumps. In this case you’d have, on average, 4.5 tests to find a key, or 9 test
    tops.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次跳跃间隔为九个元素。找到目标所在的九个元素块后，开始进行每次间隔三个元素的跳跃；灰色区域表示目标无法出现在这些位置。之后，当你找出目标所在的三元素块后（这时可以将更多位置标记为灰色），最后进行单元素的跳跃。在这种情况下，平均需要进行4.5次测试才能找到目标，最多需要9次测试。
- en: 'You can code it like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样编码：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Start by defining the number of blocks b at each level ❶, and again (as with
    the jump size in previous algorithms) you want to have at least two blocks at
    each level. Then set the initial (longest) jump size ❷. And then proceed to search
    by levels in the same way as before: starting at the beginning ❸ and continuing
    the search until the number of jumps becomes zero ❹. The difference is how you
    reduce the jump size ❺, making it b times smaller every time. (Because b > 1,
    s is guaranteed to eventually reach 0, making the outer loop end.) The final return
    ❻ is the same as with other versions of jump searching.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义每个级别的块数 b ❶，并且（如同之前算法中的跳跃大小）你希望每个级别至少有两个块。然后设置初始的（最长）跳跃大小 ❷。接下来按照之前的方式按层次进行搜索：从头开始
    ❸，并继续搜索直到跳跃次数变为 0 ❹。不同之处在于如何减少跳跃大小 ❺，每次使其变为原来的 b 倍小。（因为 b > 1，s 最终会变为 0，外部循环结束。）最终返回
    ❻ 与其他版本的跳跃搜索相同。
- en: It can be shown that this scheme leads to *O*(³√*n*) test if you choose jumps
    that are each ³√*n* greater than the next, so the algorithm is even better. You
    could keep adding more and more levels (though, of course, that would be meaningful
    only with a seriously large array) and get the order of the algorithm to *O*(⁴√*n*),
    then *O*(⁵√*n*), and so on. (Question 9.3 shows just how far you can go.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可以证明，如果你选择每次跳跃的步长为 ³√*n*，这个方案的时间复杂度将为 *O*(³√*n*)，所以算法效果更佳。你可以继续添加更多的层级（当然，这只有在数组非常大的情况下才有意义），将算法的时间复杂度提高到
    *O*(⁴√*n*)，然后是 *O*(⁵√*n*)，依此类推。（问题 9.3 展示了你可以走多远。）
- en: We’ve managed to speed up the search algorithms from *O*(*n*) to *O*(*^p*√*n*),
    if we search in *p* levels. Let’s try a different approach and see if we can do
    even better.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功将搜索算法的速度从 *O*(*n*) 提升到了 *O*(*^p*√*n*)，前提是我们在 *p* 层次上进行搜索。让我们尝试一种不同的方法，看看能否做得更好。
- en: Binary Search
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二分查找
- en: 'Now try applying the divide-and-conquer idea to create a search algorithm:
    given an array to search, check its center value. If it’s the value you want,
    you’re done. If the center value is greater than the value you want, you can discard
    the right side of the array and search the left portion recursively. Similarly,
    if the center value is greater than the value, discard the left side and search
    the right. If at some point you have to search an empty array, you know the value
    wasn’t present. [Figure 9-5](chapter9.xhtml#fig9-5) illustrates the procedure
    where the search value is 18.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试应用分治法来创建一个搜索算法：给定一个要搜索的数组，检查它的中心值。如果它就是你想要的值，那就完成了。如果中心值大于你想要的值，你可以丢弃数组的右半部分，并递归地搜索左半部分。类似地，如果中心值小于你想要的值，丢弃左半部分并搜索右半部分。如果在某一时刻你需要搜索一个空数组，你就知道这个值不在其中。[图
    9-5](chapter9.xhtml#fig9-5) 演示了该过程，其中搜索值为 18。
- en: '![](../images/Figure9-5.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-5.jpg)'
- en: 'Figure 9-5: A binary search recursively splits the array to be searched in
    half at every pass.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：二分查找在每次迭代时都会将要搜索的数组一分为二。
- en: 'In [Figure 9-5](chapter9.xhtml#fig9-5), the triangle with an m points to the
    middle element of the array. Initially, the middle element is 22, so 18 (if present)
    had to be on the left side; you can discard the rest. The second line shows how
    you’d continue: the middle element is 12, so you search on the right. On the third
    line you succeed, as the middle element is what you wanted. You can code the method
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 9-5](chapter9.xhtml#fig9-5) 中，带有 m 的三角形指向数组的中间元素。最初，中间元素是 22，所以 18（如果存在）必须位于左侧；你可以丢弃其他部分。第二行显示了你如何继续：中间元素是
    12，所以你继续搜索右半部分。第三行你成功了，因为中间元素正是你想要的。你可以按如下方式编写这个方法：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If at any time the interval to search is empty ❶, the search was a failure.
    If not ❷, compute the middle of the interval. Using the right shift >> operator
    is an elegant and concise way of doing this rather than the more pedestrian Math.floor((l+r)/2).
    If the value in the middle is the key that you’re looking for ❸, you’re done.
    If the middle value is greater than the key you want ❹, search the left portion
    of the array; otherwise, search the right ❺.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候要搜索的区间为空 ❶，则表示搜索失败。如果不为空 ❷，计算区间的中间值。使用右移 >> 运算符是一种优雅且简洁的方式来实现这一点，而不是使用更常见的
    Math.floor((l+r)/2)。如果中间值就是你要寻找的关键值 ❸，那么你就完成了。如果中间值大于你想要的值 ❹，则搜索数组的左半部分；否则，搜索右半部分
    ❺。
- en: Since all of the recursion here is tail recursion, you can easily convert this
    method to an equivalent iterative one. In [Figure 9-6](chapter9.xhtml#fig9-6),
    the l and r (left and right) triangles show the portion of the array that you
    are searching, and the m (middle) triangle indicates the middle point of that
    portion. Once more, the search value is 18.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里的所有递归都是尾递归，你可以轻松地将这个方法转换为一个等效的迭代方法。在 [图 9-6](chapter9.xhtml#fig9-6) 中，l
    和 r（左和右）三角形显示了你正在搜索的数组部分，而 m（三角形中点）表示该部分的中间点。再次提醒，搜索值是 18。
- en: '![](../images/Figure9-6.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-6.jpg)'
- en: 'Figure 9-6: An iterative version of the algorithm uses two pointers (l and
    r) to keep track of the portion of the array that you’re searching.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6：该算法的迭代版本使用两个指针（l 和 r）来跟踪你正在搜索的数组部分。
- en: Grayed-out values won’t be considered further in the algorithm. Depending on
    the result of the comparison of the middle value with the key you want, you update
    l or r and loop again until you succeed or fail.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 被灰色标出的值将在算法中不再考虑。根据中间值与目标值的比较结果，你更新 l 或 r，并继续循环，直到成功或失败。
- en: How do you recognize a failed search? If you were searching for 17 instead,
    the search procedure would have continued as shown in [Figure 9-7](chapter9.xhtml#fig9-7).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如何判断搜索失败？如果你是在搜索 17，搜索过程将会像[图 9-7](chapter9.xhtml#fig9-7)所示那样继续。
- en: '![](../images/Figure9-7.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-7.jpg)'
- en: 'Figure 9-7: If the l and r pointers get “crossed,” you can conclude that the
    search was unsuccessful.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-7：如果 l 和 r 指针变得“交叉”，可以得出搜索失败的结论。
- en: When the search fails, the l and r pointers become “crossed,” which means the
    value can’t be in the array. (The missing value, 17, should have been to the left
    of l and to the right of r.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当搜索失败时，l 和 r 指针会变得“交叉”，这意味着该值不在数组中。（缺失的值 17 应该位于 l 左边和 r 右边。）
- en: 'You can implement the algorithm as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按如下方式实现该算法：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Keep searching ❶ as long as the l and r pointers don’t cross. You calculate
    the middle m the same way ❷ as for the recursive binary search. If the middle
    value equals the key you want ❸, you’re done. If the middle key is greater than
    the value you want ❹, update the right pointer r to keep looking in the left portion;
    otherwise, change the l pointer to search on the right ❺. If the loop ends without
    finding the key you want ❻, we return -1 to show the failure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 l 和 r 指针没有交叉，继续搜索 ❶。你像递归二分搜索那样计算中间值 m ❷。如果中间值等于你想要的键 ❸，那就完成了。如果中间值大于你想要的值
    ❹，更新右指针 r，继续在左侧部分查找；否则，更新 l 指针，改在右侧部分查找 ❺。如果循环结束仍未找到目标键 ❻，返回 -1，表示失败。
- en: What’s the performance of this method? We have seen a similar analysis before,
    and it should remind you of quicksort, for example. Each step halves the size
    of the array to search, so the order of the binary search is *O*(log *n*), which
    is a very good improvement on all the previous algorithms you’ve seen. (For math-oriented
    readers, question 9.4 calculates the actual average number of tests.) Let’s consider
    another algorithm that shows a similar performance, which actually uses binary
    search.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的性能如何？我们之前已经看过类似的分析，它应该让你联想到快速排序等算法。每一步都会将搜索数组的大小减半，因此二分搜索的时间复杂度是 *O*(log
    *n*)，这是对你之前看到的所有算法的一个很好的改进。（对于偏数学的读者，问题 9.4 会计算出实际的平均测试次数。）让我们考虑另一种显示相似性能的算法，它实际上使用了二分搜索。
- en: Exponential Search
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指数搜索
- en: '*Exponential search* (also known as *doubling* or *galloping search*) is a
    combination of two methods: first you determine in which range of the array you
    should find the desired key, and then you apply binary search to finish the job.
    For the first step, you want to find a value in the array that’s greater than
    the key you want to find, and you test the value at position 1; then the value
    at position 2; then at positions 4, 8, 16; and so on, always doubling, until you
    decide where to continue searching. [Figure 9-8](chapter9.xhtml#fig9-8) shows
    how the algorithm would search for 42.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*指数搜索*（也叫做 *加倍搜索* 或 *奔腾搜索*）是两种方法的结合：首先，你需要确定在数组的哪个范围内查找目标键，然后再应用二分搜索来完成搜索。在第一步中，你需要在数组中找到一个大于你想找的键的值，然后你先测试位置
    1 的值；接着是位置 2 的值；然后是位置 4、8、16 的值，依此类推，每次都加倍，直到你决定在哪里继续搜索。[图 9-8](chapter9.xhtml#fig9-8)展示了该算法如何查找
    42。'
- en: '![](../images/Figure9-8.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-8.jpg)'
- en: 'Figure 9-8: An exponential search combines ever-longer jumps with binary search.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-8：指数搜索结合了越来越长的跳跃和二分搜索。
- en: First, the doubling jumps are taken (size 1, 2, 4, and so on) until finding
    the section in which 42, if present, should be. (If you were looking for 22, the
    jumps would have ended after looking at the element in position 8, for instance.)
    After finding the portion of the array to search, binary search completes the
    process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行加倍跳跃（大小为 1、2、4 等），直到找到包含 42 的部分（如果存在的话）。（如果你在寻找 22，跳跃就会在查看位置 8 的元素后结束，例如。）找到搜索区间后，二分搜索完成剩余的查找过程。
- en: 'Here’s the code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First initialize the series of jumps at 1 ❶, and although you have neither reached
    the end nor found a value greater than the key you want ❷, double the jump size
    ❸ and loop again. If this line looks weird, you could also write it as i = i <<
    1, and the left shift << operator (you’ve already used the right shift operator
    in binary search) makes it equivalent to i = i * 2. After completing all the necessary
    jumps ❹, do a binary search, again using the shift operator to divide i by 2.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先初始化跳跃系列为1 ❶，尽管你还没有到达数组的末尾，也没有找到比你想要的关键值更大的值 ❷，但是将跳跃大小翻倍 ❸，然后再次循环。如果这行代码看起来很奇怪，你也可以写成i
    = i << 1，左移运算符 <<（你已经在二分查找中使用过右移运算符）使得它等同于i = i * 2。完成所有必要的跳跃 ❹ 后，进行二分查找，再次使用移位运算符将i除以2。
- en: 'What’s the order of this algorithm? Let’s start with the worst case, when you
    look for the last value in an array with up to 2*^p* elements. The first loop
    will be executed *p* times, and that will be followed by a binary search in an
    array with a size of less than 2*^p* ^(− 1): that also is *O*(*p*). As *p* is
    approximately log *n*, the total performance is, at worst, *O*(log *n*), but it’ll
    be better the closer the element is to the beginning. In fact, if the key is found
    at position *k*, the search will be *O*(log *k*).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的时间复杂度是多少？我们从最坏的情况开始，假设你在一个最多有2*^p*个元素的数组中查找最后一个值。第一次循环将执行*p*次，接下来会在一个小于2*^p*^(−1)大小的数组中进行二分查找：这也属于*O*(*p*)。由于*p*大约等于log
    *n*，最坏情况下总的性能是*O*(log *n*)，但是如果目标元素更靠近数组的前面，性能会更好。实际上，如果关键值位于位置*k*，查找将是*O*(log
    *k*)。
- en: Interpolation Search
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插值查找
- en: When searching for a word in the dictionary, no matter how well versed you are
    in binary search, if you are looking for a word starting with the letter *S*,
    you’d open the dictionary near the end, but if you’re looking for a word starting
    with *B*, you’d open the book nearer the beginning. You can apply this idea to
    searching in an ordered array, if you can interpolate and estimate the position
    at which a given value should be, assuming that values in the array are somewhat
    uniformly distributed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当在字典中查找一个单词时，无论你多么熟练于二分查找，如果你要查找一个以字母*S*开头的单词，你会翻到字典的后半部分，但如果你要查找一个以*B*开头的单词，你会翻到书的前半部分。你可以将这个想法应用到有序数组的查找中，如果你能进行插值并估算一个给定值应该所在的位置，前提是数组中的值大致均匀分布。
- en: But first some math. If the value at position *l* (for left) is *L* and the
    value at position *r* (for right) is *R* (with *R > L*), the position that would
    correspond to value *V* can be calculated as *l* + (*r – l*)(*V – L*)/(*R – L*).
    We can check this out. If *V* equals *L*, the formula produces *l*, which is correct.
    Similarly, if *V* equals *R*, the formula produces *r*, which is correct again.
    If you are searching an array with values that can be converted to numbers, you
    can apply this interpolation to more quickly find the value you want.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先做一些数学运算。如果左侧位置*l*的值是*L*，右侧位置*r*的值是*R*（且*R > L*），则与值*V*对应的位置可以通过以下公式计算：*l*
    + (*r – l*)(*V – L*)/(*R – L*)。我们可以验证一下这个公式。如果*V*等于*L*，公式的结果是*l*，这就是正确的。类似地，如果*V*等于*R*，公式的结果是*r*，这同样是正确的。如果你在查找一个值可以转化为数字的数组，可以应用这种插值方法，更快速地找到你想要的值。
- en: Consider this in practice. [Figure 9-9](chapter9.xhtml#fig9-9) shows a search
    for the value 34.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 看看实际应用中的情况。[图9-9](chapter9.xhtml#fig9-9)展示了查找值34的过程。
- en: '![](../images/Figure9-9.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-9.jpg)'
- en: 'Figure 9-9: An interpolation search tries to estimate the position of the searched-for
    value to find it faster.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-9：插值查找尝试估算目标值的位置，以便更快地找到它。
- en: To start, the left value (at position 0) is 4 and the right value (at position
    14) is 60, so the estimate is that 34 should be around position 7\. (See [Figure
    9-10](chapter9.xhtml#fig9-10); the dotted line joins the extreme values, and its
    intersection with a horizontal line at height 34 is between 7 and 8.) Since the
    value at that position is smaller than 34, move the left pointer to position 8\.
    Then redo the estimation with 24 at 8 and 60 at 14, so 34 should be at 10\. The
    value there is higher than 34, so now move the right pointer to 9\. The third
    iteration is successful, as 34 is estimated to be (and found at) position 9.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，左侧值（位置0）是4，右侧值（位置14）是60，因此估算34应该在位置7左右。（参见[图9-10](chapter9.xhtml#fig9-10)，虚线连接了最小值和最大值，它与水平线在高度34处的交点位于7和8之间。）由于该位置的值小于34，移动左指针到位置8。然后，用8位置的24和14位置的60重新估算，得出34应该在10的位置。该位置的值大于34，因此现在将右指针移动到9。第三次迭代成功，34的估算位置是（并且实际位置是）9。
- en: '![](../images/Figure9-10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-10.jpg)'
- en: 'Figure 9-10: Estimating the position for 42, if 4 is the start of the array
    and 60 is the end'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-10：估算42的位置，假设4是数组的起始位置，60是数组的结束位置
- en: 'You can directly implement the method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接实现这个方法：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Start by setting variables l and r to point to the extremes of the search range
    ❶ as in binary search, and the loop ❷ is the same as in that algorithm. Instead
    of calculating m as the middle point of l and r ❸, use the interpolation formula,
    but check whether the values at the extremes are equal because then you’d be dividing
    by zero. If m ends outside the interval from l to r, the value you want isn’t
    in the array (because the key you want must be smaller than the value at l or
    greater than the value at r), and you return -1 ❹. On the other hand, if m lies
    between l and r inclusive, compare the value at its position to the desired key.
    If the value is equal, you succeeded ❺. If the value is greater, search to the
    left ❻, and if the value is smaller, search to the right ❼. If the key wasn’t
    found, return –1 ❽.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从设置变量 l 和 r 开始，将它们指向查找范围的极端位置 ❶，就像在二分查找中一样，循环 ❷ 与该算法相同。不同的是，计算 m 时不再使用 l 和 r
    的中点 ❸，而是使用插值公式，但要检查极端位置的值是否相等，因为那样的话就会除以零。如果 m 超出了 l 到 r 的区间，那么你要找的值不在数组中（因为你要找的键必须小于
    l 处的值或大于 r 处的值），这时返回 -1 ❹。另一方面，如果 m 在 l 和 r 之间（包括两者），就比较它的位置上的值和目标键。如果值相等，表示成功
    ❺。如果值更大，向左查找 ❻，如果值更小，向右查找 ❼。如果没有找到目标键，返回 -1 ❽。
- en: This method performs well, but it has a couple of drawbacks. First, you must
    be working with numeric keys (as in the example) or with keys that can be transformed
    to numbers in order to perform interpolation (one possibility could be transforming
    characters to their ASCII or Unicode equivalents). This challenge needs to be
    solved in order to use interpolation search with more general keys.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法表现良好，但也有几个缺点。首先，你必须使用数字键（如示例中的情况）或可以转换为数字的键来执行插值（一个可能的方案是将字符转换为其ASCII或Unicode值）。为了能够在更通用的键上使用插值查找，需要解决这个问题。
- en: The second possible drawback has to do with the algorithm’s performance. Unlike
    binary search that always halves the search range at each stage, interpolation
    might do not so well (quicksort behaved similarly), and the performance would
    be *O*(*n*). (A possible case for bad performance is if values in the array are
    in a geometric progression, which means linear interpolation won’t produce good
    estimates; however, such a distribution isn’t really very likely.) On the other
    hand, if values are uniformly distributed, it can be shown (you won’t see it here)
    that performance will be *O*(log log *n*), which is a great improvement.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个可能的缺点与算法的性能有关。与每一步都将查找范围减半的二分查找不同，插值法可能表现不佳（快速排序也有类似表现），其性能可能是 *O*(*n*)。
    （一个可能的性能差的情形是，如果数组中的值呈几何级数增长，那么线性插值将无法产生好的估算；然而，这种分布实际上不太可能出现。）另一方面，如果值均匀分布，可以证明（你不会在这里看到）性能将是
    *O*(log log *n*)，这是一个很大的改进。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we’ve considered algorithms for searching ordered or unordered
    arrays of values, which is a common function. The methods covered have different
    rates of performance, and several of them are based on previous methods in order
    to illustrate interesting algorithm development techniques.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑了用于查找有序或无序值数组的算法，这是一个常见的功能。这些方法的性能各异，且其中一些方法基于之前的方法，以便展示有趣的算法开发技巧。
- en: This chapter ends the second part of the book. In [Part III](part3.xhtml), we’ll
    start our exploration of data structures, beginning with lists, an important dynamic
    structure with plenty of uses.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书的第二部分。在[第三部分](part3.xhtml)，我们将开始探索数据结构，从列表开始，列表是一种重要的动态结构，具有广泛的用途。
- en: Questions
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: '**9.1  Searching Right?**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.1  正确查找？**'
- en: Implement a framework to test a given search function and see whether it works
    on every element in the array and on missing elements as well. I used such a test
    on all of my code for this chapter, and I found some bugs!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个框架来测试给定的查找函数，并查看它是否能在数组的每个元素以及缺失元素上都正常工作。我在本章的所有代码中使用了这样的测试，并发现了一些bug！
- en: '**9.2  JavaScript’s Own**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.2  JavaScript 自带的**'
- en: Can you implement an alternative to JavaScript’s own array.indexOf(...) using
    some other available array methods?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否用其他可用的数组方法实现一个替代 JavaScript 自带的 array.indexOf(...)？
- en: '**9.3  Infinite Jump Levels?**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.3  无限跳跃层次？**'
- en: 'In the generalized jump search algorithm, what happens if you want to do the
    search on an infinite number of levels? (Hint: imagine that levels is infinitely
    large, and see how the algorithm behaves.) What’s the resulting algorithm like?'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在广义的跳跃搜索算法中，如果你想在无限多个级别上进行搜索，会发生什么？（提示：假设级别是无限大的，看看算法是如何表现的。）最终的算法是什么样的？
- en: '**9.4  Exactly How Much?**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.4 恰好多少？**'
- en: This question is for the mathematically inclined. Calculate the actual average
    of number of tests for a successful search. It may help to assume that the array
    is of length 2*^n* – 1\. In this case 1 element is found in just one question,
    2 elements in two questions, 4 found in three, 8 in four, and so on, up to 2*^n*
    ^(− 1) found in *n* questions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题适合数学思维较强的人。计算一次成功搜索的实际平均测试次数。假设数组的长度是 2*^n* – 1，可能会有所帮助。在这种情况下，1 个元素只需要
    1 次提问，2 个元素需要 2 次提问，4 个元素需要 3 次，8 个元素需要 4 次，依此类推，直到 2*^n* ^(− 1) 个元素在 *n* 次提问中找到。
- en: '**9.5  Three Tops Two?**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.5 三个顶部两个？**'
- en: Inspired by binary search, which uses a comparison to split the array to search
    in two, you could think of a ternary search, using comparisons to split the array
    in three, so you’ll have a smaller subarray to work with. How does this compare
    to binary search? Is ternary search really an improvement?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 受二分查找的启发，二分查找通过比较将数组分成两部分来进行搜索，你可以考虑三分查找，通过比较将数组分成三部分，这样你就可以处理更小的子数组。这与二分查找相比如何？三分查找真的有改进吗？
- en: '**9.6  Binary First**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.6 二进制先行**'
- en: Assuming that the sorted input array may have repeated values, modify binary
    search to return the first position of the searched key in the array. If you want
    to find the *last* position instead, what changes would you need?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设排序后的输入数组可能包含重复值，修改二分查找算法，使其返回搜索键在数组中的第一个位置。如果你想找到*最后*一个位置，应该做哪些修改？
- en: '**9.7  Count Faster**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.7 更快计数**'
- en: Given an input sorted array and a key, you could find how many times the key
    appears by writing something like count = arr.filter(x => x === key).length, but
    that would run in *O*(*n*) time. Can you find that count in *O*(log *n*) time?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个排序的输入数组和一个键，你可以通过编写类似 `count = arr.filter(x => x === key).length` 的代码来找出该键出现的次数，但这会以
    *O*(*n*) 的时间复杂度运行。你能在 *O*(log *n*) 的时间复杂度内找到这个计数吗？
- en: '**9.8  Rotation Finding**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.8 旋转查找**'
- en: 'Assume you have an array that was originally sorted, but later it possibly
    got rotated: for instance [4, 9, 12, 22, 34, 56, 60] might have become [34, 56,
    60, 4, 9, 12, 22]. Write a function that determines the position of the lowest
    value in the rotated array. For instance, in this example, the function should
    return 3\. Make sure your function also works for an array that *isn’t* rotated.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个原本是排序的数组，但后来可能被旋转了：例如 [4, 9, 12, 22, 34, 56, 60] 可能变成了 [34, 56, 60, 4,
    9, 12, 22]。写一个函数，确定旋转数组中最小值的位置。例如，在这个例子中，函数应该返回 3。确保你的函数也能在数组*没有*被旋转的情况下正常工作。
- en: '**9.9  Special First?**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.9 特殊的第一个？**'
- en: I found several implementations of exponential search that specifically tested,
    before any looping, whether the first position of the array had the key. Does
    the version in this book need this?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现了一些指数查找的实现，特别是在开始任何循环之前，先检查数组的第一个位置是否有目标键。书中的版本需要这样做吗？
