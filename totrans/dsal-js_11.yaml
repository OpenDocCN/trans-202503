- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 9 SEARCHING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter deals with a common problem: given a set of values, find whether
    a certain key is in the set. This definition has similar aspects to logic that
    we’ll explore in future chapters when you implement a dictionary abstract data
    type (ADT), but we’ll be concerned only with the search part here. We won’t look
    at adding or deleting keys. In addition, we’ll deal only with arrays and explore
    other data structures in future chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Search Definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all cases in this chapter, the problem to solve is that, given an array (ordered
    or unordered, possibly with repeated values) and a key, you want to learn at which
    position of the array you can find the key. You’ll return -1 to match several
    of JavaScript’s own methods if the key isn’t in the array.
  prefs: []
  type: TYPE_NORMAL
- en: As a further optional requirement, you may sometimes want to find the first
    (or last) occurrence of a key in an array (in the case where the array has repeated
    keys), or if an array doesn’t include a key, you might want to know in which position
    it should have been.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to keep in mind whether you’re doing a single search or many
    searches. If the latter, you may amortize over time the cost of, say, sorting
    the data or building some other data structure. If the former, you just want the
    speediest possible search. (In later chapters you’ll explore examples of data
    structures that help make searches faster.)
  prefs: []
  type: TYPE_NORMAL
- en: There are more efficient algorithms for sorted arrays than for unsorted ones;
    we’ll start with the latter and then move on to better-performing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Searching Unsorted Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first set of algorithms you’ll consider performs a linear search in a disordered
    array and is the most basic (these are also known as sequential or serial searches).
    If the array is not in any order, there’s no other way to search than to start
    at the beginning and go through the whole array. This kind of search is obviously
    slow and *O*(*n*), but for small arrays, it’s quite reasonable. Furthermore, JavaScript
    has its own methods for this kind of search, so if the conditions of your problem
    allow it, the functions in the next section are probably the best bet.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript’s Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To find whether a given key is in an array along with its position, JavaScript
    provides several interesting functions. If you just want to know whether the key
    is there, you can use the array.includes(key) method, which returns true or false
    depending on whether the key was found. If you want the position of the key in
    the array (which you’ll want throughout this chapter), then array.indexOf(key)
    does the job. It returns the first position at which the key is found or -1 if
    it wasn’t found.
  prefs: []
  type: TYPE_NORMAL
- en: These methods all perform in *O*(*n*) time, and they go through the array from
    the beginning to the end. This performance matches that of the linear search you’ll
    consider next.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Search
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The linear search algorithm is basically an implementation of JavaScript’s own
    .indexOf(...) method. It searches simply by looping through the whole array checking
    whether it finds what you want.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-1](chapter9.xhtml#fig9-1) shows two searches: a successful one for
    60 and an unsuccessful one for 50.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: A linear search starts at the beginning and advances until it finds
    the desired key or gets to the end of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process starts at the beginning and continues until it reaches the desired
    key or the end of the array. This kind of algorithm is often taught very early
    to future developers as a basic example of looping. Here’s an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Loop through the array ❶, and if you find the key you want ❷, return its position.
    If the loop ends without success ❸, return -1 as defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance of this algorithm is *O*(*n*) in the worst case, and for successful
    searches, you do an average of *n*/2 probes, so the result is still *O*(*n*).
    There’s no way to seriously speed up a search in a disordered array, but a small
    trick may help a little bit: using a sentinel.'
  prefs: []
  type: TYPE_NORMAL
- en: Linear Search with Sentinels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before searching for a key, append that value at the end of the array, so the
    search is guaranteed to succeed. [Figure 9-2](chapter9.xhtml#fig9-2) shows the
    same two searches from the previous section: the first is successful because it
    found 60 before the end of the array, but the second is a failure because it found
    only the 50 that was added, as that value wasn’t originally in the array.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: Adding a sentinel lets you advance without passing the end of the
    array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can loop through the array without checking for its end, because you know
    for sure that you’ll eventually find the key. The only consideration now is where
    you find it: if it’s at the end, you found only the added sentinel, so the search
    was unsuccessful. Here’s the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Start by adding the key to search for at the end of the array ❶. Then start
    searching at the first position as before ❷ until you find the key ❸. You don’t
    have to check for the end of the array because you know you’ll find the key you
    want. After finding the key, restore the array ❹ (assigning a new length is enough
    for this, but the .pop(...) method is probably more common) and then decide what
    to return depending on where you find the key ❺. If it’s at the end, it’s a failure,
    and if it’s earlier, it’s a success.
  prefs: []
  type: TYPE_NORMAL
- en: The performance of this algorithm is still *O*(*n*); the only (slight) advantage
    may derive from the simpler check in the loop, so the iteration goes faster, but
    don’t expect a big impact from that. In addition, if adding the sentinel causes
    JavaScript to create a new array and copy the old one, the algorithm could become
    even slower.
  prefs: []
  type: TYPE_NORMAL
- en: 'When all is said and done, using linear search can’t be enhanced by much, and
    you’ve gone as far as possible with unordered arrays. You’ll now move on to doing
    searches in ordered (sorted) arrays, for which far better algorithms are possible.  ###
    Searching Ordered Arrays'
  prefs: []
  type: TYPE_NORMAL
- en: If the array to be searched is ordered, you can apply better techniques. For
    instance, if you learn that the value at a certain position of the array is greater
    than the key you’re searching for, you can instantly discard all values after
    that position, because the key can’t be there. All the nonlinear search algorithms
    (also known as *interval searches*) in this section take advantage of order either
    to advance more quickly through the array or to discard large portions of it,
    reducing the area to search.
  prefs: []
  type: TYPE_NORMAL
- en: Jump Search
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The basic linear search described earlier potentially goes through the complete
    array, which makes for *O*(*n*) performance with no possibility for enhancement.
    However, if the array is ordered, you don’t have to go through it one by one.
    Just as when someone is looking for a certain page in a book, they won’t turn
    each page one by one; they’ll skip through the book several pages at a time, and
    then go one by one when closer to the goal.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind the jump search algorithm is similar to that of Shell sort (see
    [Chapter 6](chapter6.xhtml)). You start with big jumps to get quickly to the vicinity
    of the key that you want and then do smaller jumps. [Figure 9-3](chapter9.xhtml#fig9-3)
    shows how we’d search for 42, assuming an initial jump size of 4\. (We’ll get
    to what the jump size should be later.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: A jump search tries to advance faster by making big jumps whenever
    possible.'
  prefs: []
  type: TYPE_NORMAL
- en: At the top you do a linear search but with big jumps, skipping four values at
    a time. The first value you find is 04, which is too low, so you jump again. Next
    you find 14 and then 24, but both are still too low. The next jump gets you to
    49, so now you know that 42 is (if present) after the 24 and before the 49\. You
    then start a regular linear search, with short jumps advancing one position at
    a time. You check 34 and 40 and succeed at 42\. If you had been searching for
    41 instead, when you reached 42, you’d decide that 41 wasn’t present and return
    –1.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s the expected number of tests for this algorithm? If the step size is
    *s* and the array size is *n*, you can have up to *n*/*s* long jumps, followed
    by *s* short jumps, which is *n*/*s* + *s* in total. Some calculus proves that
    this is optimum when *s* is √*n*, for a maximum of 2√*n* tests, so we’ll use that
    value, as shown in the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Start by determining the size of the long jump ❶, making sure that it’s at least
    2\. (The jump size could be 1 only for very short arrays.) The i variable goes
    through the array ❷. Start by jumping s places every time ❸. If you don’t go past
    the end of the array and the array value you test is not greater than the key
    you are looking for, you can do a jump by updating i. After this series of jumps,
    i points to a value not greater than the key you want, and you do a new loop,
    advancing by 1 ❹. After this loop ends ❺, if you find the key, return its position;
    otherwise, return -1.
  prefs: []
  type: TYPE_NORMAL
- en: The code has two similar while loops. In one case you jump by s, and in the
    other you jump by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider another implementation that suggests a more enhanced solution. First,
    here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You’re now not using a const for s ❶ because you’ll change its value for the
    second loop. Set up an external loop ❷ depending on s. When it reaches 0, you’re
    done. The internal loop is the same as before, where you always jump s places
    at a time ❸, but s later becomes 1 to make short jumps. After finishing a loop
    ❹, reduce s. If it was greater than 1, jump by 1, and if it already was 1, end
    the loop, setting it to 0\. Deciding what value to return ❺ is exactly the same
    as in the previous version of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'You did the search in two stages: long jumps first, followed by shorter jumps,
    and you got the searches down to *O*(√*n*). What if you had three stages, with
    very long jumps first, followed by not-as-long jumps, and shorter jumps to finish?
    Jumps at one level are proportionally greater to jumps in the next level. (We’ll
    revisit this concept of jumps that decrease in size when looking at skip lists
    in [Chapter 11](chapter11.xhtml).) [Figure 9-4](chapter9.xhtml#fig9-4) shows how
    it works with three jump levels, searching for a value in an array of 27.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-4: A search in three levels'
  prefs: []
  type: TYPE_NORMAL
- en: The first jumps are nine elements apart. After finding in which block of nine
    the key should be, you start with jumps three elements apart; grayed elements
    are places where the key you want can’t be. After you learn in which block of
    three the key is (allowing you to gray out more elements), you finish with single-element
    jumps. In this case you’d have, on average, 4.5 tests to find a key, or 9 test
    tops.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can code it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by defining the number of blocks b at each level ❶, and again (as with
    the jump size in previous algorithms) you want to have at least two blocks at
    each level. Then set the initial (longest) jump size ❷. And then proceed to search
    by levels in the same way as before: starting at the beginning ❸ and continuing
    the search until the number of jumps becomes zero ❹. The difference is how you
    reduce the jump size ❺, making it b times smaller every time. (Because b > 1,
    s is guaranteed to eventually reach 0, making the outer loop end.) The final return
    ❻ is the same as with other versions of jump searching.'
  prefs: []
  type: TYPE_NORMAL
- en: It can be shown that this scheme leads to *O*(³√*n*) test if you choose jumps
    that are each ³√*n* greater than the next, so the algorithm is even better. You
    could keep adding more and more levels (though, of course, that would be meaningful
    only with a seriously large array) and get the order of the algorithm to *O*(⁴√*n*),
    then *O*(⁵√*n*), and so on. (Question 9.3 shows just how far you can go.)
  prefs: []
  type: TYPE_NORMAL
- en: We’ve managed to speed up the search algorithms from *O*(*n*) to *O*(*^p*√*n*),
    if we search in *p* levels. Let’s try a different approach and see if we can do
    even better.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Search
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now try applying the divide-and-conquer idea to create a search algorithm:
    given an array to search, check its center value. If it’s the value you want,
    you’re done. If the center value is greater than the value you want, you can discard
    the right side of the array and search the left portion recursively. Similarly,
    if the center value is greater than the value, discard the left side and search
    the right. If at some point you have to search an empty array, you know the value
    wasn’t present. [Figure 9-5](chapter9.xhtml#fig9-5) illustrates the procedure
    where the search value is 18.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-5: A binary search recursively splits the array to be searched in
    half at every pass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 9-5](chapter9.xhtml#fig9-5), the triangle with an m points to the
    middle element of the array. Initially, the middle element is 22, so 18 (if present)
    had to be on the left side; you can discard the rest. The second line shows how
    you’d continue: the middle element is 12, so you search on the right. On the third
    line you succeed, as the middle element is what you wanted. You can code the method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If at any time the interval to search is empty ❶, the search was a failure.
    If not ❷, compute the middle of the interval. Using the right shift >> operator
    is an elegant and concise way of doing this rather than the more pedestrian Math.floor((l+r)/2).
    If the value in the middle is the key that you’re looking for ❸, you’re done.
    If the middle value is greater than the key you want ❹, search the left portion
    of the array; otherwise, search the right ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Since all of the recursion here is tail recursion, you can easily convert this
    method to an equivalent iterative one. In [Figure 9-6](chapter9.xhtml#fig9-6),
    the l and r (left and right) triangles show the portion of the array that you
    are searching, and the m (middle) triangle indicates the middle point of that
    portion. Once more, the search value is 18.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-6: An iterative version of the algorithm uses two pointers (l and
    r) to keep track of the portion of the array that you’re searching.'
  prefs: []
  type: TYPE_NORMAL
- en: Grayed-out values won’t be considered further in the algorithm. Depending on
    the result of the comparison of the middle value with the key you want, you update
    l or r and loop again until you succeed or fail.
  prefs: []
  type: TYPE_NORMAL
- en: How do you recognize a failed search? If you were searching for 17 instead,
    the search procedure would have continued as shown in [Figure 9-7](chapter9.xhtml#fig9-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-7: If the l and r pointers get “crossed,” you can conclude that the
    search was unsuccessful.'
  prefs: []
  type: TYPE_NORMAL
- en: When the search fails, the l and r pointers become “crossed,” which means the
    value can’t be in the array. (The missing value, 17, should have been to the left
    of l and to the right of r.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement the algorithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Keep searching ❶ as long as the l and r pointers don’t cross. You calculate
    the middle m the same way ❷ as for the recursive binary search. If the middle
    value equals the key you want ❸, you’re done. If the middle key is greater than
    the value you want ❹, update the right pointer r to keep looking in the left portion;
    otherwise, change the l pointer to search on the right ❺. If the loop ends without
    finding the key you want ❻, we return -1 to show the failure.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the performance of this method? We have seen a similar analysis before,
    and it should remind you of quicksort, for example. Each step halves the size
    of the array to search, so the order of the binary search is *O*(log *n*), which
    is a very good improvement on all the previous algorithms you’ve seen. (For math-oriented
    readers, question 9.4 calculates the actual average number of tests.) Let’s consider
    another algorithm that shows a similar performance, which actually uses binary
    search.
  prefs: []
  type: TYPE_NORMAL
- en: Exponential Search
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Exponential search* (also known as *doubling* or *galloping search*) is a
    combination of two methods: first you determine in which range of the array you
    should find the desired key, and then you apply binary search to finish the job.
    For the first step, you want to find a value in the array that’s greater than
    the key you want to find, and you test the value at position 1; then the value
    at position 2; then at positions 4, 8, 16; and so on, always doubling, until you
    decide where to continue searching. [Figure 9-8](chapter9.xhtml#fig9-8) shows
    how the algorithm would search for 42.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-8: An exponential search combines ever-longer jumps with binary search.'
  prefs: []
  type: TYPE_NORMAL
- en: First, the doubling jumps are taken (size 1, 2, 4, and so on) until finding
    the section in which 42, if present, should be. (If you were looking for 22, the
    jumps would have ended after looking at the element in position 8, for instance.)
    After finding the portion of the array to search, binary search completes the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First initialize the series of jumps at 1 ❶, and although you have neither reached
    the end nor found a value greater than the key you want ❷, double the jump size
    ❸ and loop again. If this line looks weird, you could also write it as i = i <<
    1, and the left shift << operator (you’ve already used the right shift operator
    in binary search) makes it equivalent to i = i * 2. After completing all the necessary
    jumps ❹, do a binary search, again using the shift operator to divide i by 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s the order of this algorithm? Let’s start with the worst case, when you
    look for the last value in an array with up to 2*^p* elements. The first loop
    will be executed *p* times, and that will be followed by a binary search in an
    array with a size of less than 2*^p* ^(− 1): that also is *O*(*p*). As *p* is
    approximately log *n*, the total performance is, at worst, *O*(log *n*), but it’ll
    be better the closer the element is to the beginning. In fact, if the key is found
    at position *k*, the search will be *O*(log *k*).'
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation Search
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When searching for a word in the dictionary, no matter how well versed you are
    in binary search, if you are looking for a word starting with the letter *S*,
    you’d open the dictionary near the end, but if you’re looking for a word starting
    with *B*, you’d open the book nearer the beginning. You can apply this idea to
    searching in an ordered array, if you can interpolate and estimate the position
    at which a given value should be, assuming that values in the array are somewhat
    uniformly distributed.
  prefs: []
  type: TYPE_NORMAL
- en: But first some math. If the value at position *l* (for left) is *L* and the
    value at position *r* (for right) is *R* (with *R > L*), the position that would
    correspond to value *V* can be calculated as *l* + (*r – l*)(*V – L*)/(*R – L*).
    We can check this out. If *V* equals *L*, the formula produces *l*, which is correct.
    Similarly, if *V* equals *R*, the formula produces *r*, which is correct again.
    If you are searching an array with values that can be converted to numbers, you
    can apply this interpolation to more quickly find the value you want.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this in practice. [Figure 9-9](chapter9.xhtml#fig9-9) shows a search
    for the value 34.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-9: An interpolation search tries to estimate the position of the searched-for
    value to find it faster.'
  prefs: []
  type: TYPE_NORMAL
- en: To start, the left value (at position 0) is 4 and the right value (at position
    14) is 60, so the estimate is that 34 should be around position 7\. (See [Figure
    9-10](chapter9.xhtml#fig9-10); the dotted line joins the extreme values, and its
    intersection with a horizontal line at height 34 is between 7 and 8.) Since the
    value at that position is smaller than 34, move the left pointer to position 8\.
    Then redo the estimation with 24 at 8 and 60 at 14, so 34 should be at 10\. The
    value there is higher than 34, so now move the right pointer to 9\. The third
    iteration is successful, as 34 is estimated to be (and found at) position 9.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-10: Estimating the position for 42, if 4 is the start of the array
    and 60 is the end'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can directly implement the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Start by setting variables l and r to point to the extremes of the search range
    ❶ as in binary search, and the loop ❷ is the same as in that algorithm. Instead
    of calculating m as the middle point of l and r ❸, use the interpolation formula,
    but check whether the values at the extremes are equal because then you’d be dividing
    by zero. If m ends outside the interval from l to r, the value you want isn’t
    in the array (because the key you want must be smaller than the value at l or
    greater than the value at r), and you return -1 ❹. On the other hand, if m lies
    between l and r inclusive, compare the value at its position to the desired key.
    If the value is equal, you succeeded ❺. If the value is greater, search to the
    left ❻, and if the value is smaller, search to the right ❼. If the key wasn’t
    found, return –1 ❽.
  prefs: []
  type: TYPE_NORMAL
- en: This method performs well, but it has a couple of drawbacks. First, you must
    be working with numeric keys (as in the example) or with keys that can be transformed
    to numbers in order to perform interpolation (one possibility could be transforming
    characters to their ASCII or Unicode equivalents). This challenge needs to be
    solved in order to use interpolation search with more general keys.
  prefs: []
  type: TYPE_NORMAL
- en: The second possible drawback has to do with the algorithm’s performance. Unlike
    binary search that always halves the search range at each stage, interpolation
    might do not so well (quicksort behaved similarly), and the performance would
    be *O*(*n*). (A possible case for bad performance is if values in the array are
    in a geometric progression, which means linear interpolation won’t produce good
    estimates; however, such a distribution isn’t really very likely.) On the other
    hand, if values are uniformly distributed, it can be shown (you won’t see it here)
    that performance will be *O*(log log *n*), which is a great improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter we’ve considered algorithms for searching ordered or unordered
    arrays of values, which is a common function. The methods covered have different
    rates of performance, and several of them are based on previous methods in order
    to illustrate interesting algorithm development techniques.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter ends the second part of the book. In [Part III](part3.xhtml), we’ll
    start our exploration of data structures, beginning with lists, an important dynamic
    structure with plenty of uses.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**9.1  Searching Right?**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a framework to test a given search function and see whether it works
    on every element in the array and on missing elements as well. I used such a test
    on all of my code for this chapter, and I found some bugs!
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2  JavaScript’s Own**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you implement an alternative to JavaScript’s own array.indexOf(...) using
    some other available array methods?
  prefs: []
  type: TYPE_NORMAL
- en: '**9.3  Infinite Jump Levels?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the generalized jump search algorithm, what happens if you want to do the
    search on an infinite number of levels? (Hint: imagine that levels is infinitely
    large, and see how the algorithm behaves.) What’s the resulting algorithm like?'
  prefs: []
  type: TYPE_NORMAL
- en: '**9.4  Exactly How Much?**'
  prefs: []
  type: TYPE_NORMAL
- en: This question is for the mathematically inclined. Calculate the actual average
    of number of tests for a successful search. It may help to assume that the array
    is of length 2*^n* – 1\. In this case 1 element is found in just one question,
    2 elements in two questions, 4 found in three, 8 in four, and so on, up to 2*^n*
    ^(− 1) found in *n* questions.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.5  Three Tops Two?**'
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by binary search, which uses a comparison to split the array to search
    in two, you could think of a ternary search, using comparisons to split the array
    in three, so you’ll have a smaller subarray to work with. How does this compare
    to binary search? Is ternary search really an improvement?
  prefs: []
  type: TYPE_NORMAL
- en: '**9.6  Binary First**'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the sorted input array may have repeated values, modify binary
    search to return the first position of the searched key in the array. If you want
    to find the *last* position instead, what changes would you need?
  prefs: []
  type: TYPE_NORMAL
- en: '**9.7  Count Faster**'
  prefs: []
  type: TYPE_NORMAL
- en: Given an input sorted array and a key, you could find how many times the key
    appears by writing something like count = arr.filter(x => x === key).length, but
    that would run in *O*(*n*) time. Can you find that count in *O*(log *n*) time?
  prefs: []
  type: TYPE_NORMAL
- en: '**9.8  Rotation Finding**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume you have an array that was originally sorted, but later it possibly
    got rotated: for instance [4, 9, 12, 22, 34, 56, 60] might have become [34, 56,
    60, 4, 9, 12, 22]. Write a function that determines the position of the lowest
    value in the rotated array. For instance, in this example, the function should
    return 3\. Make sure your function also works for an array that *isn’t* rotated.'
  prefs: []
  type: TYPE_NORMAL
- en: '**9.9  Special First?**'
  prefs: []
  type: TYPE_NORMAL
- en: I found several implementations of exponential search that specifically tested,
    before any looping, whether the first position of the array had the key. Does
    the version in this book need this?
  prefs: []
  type: TYPE_NORMAL
