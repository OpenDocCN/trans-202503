<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Testing"><div class="titlepage"><div><div><h1 class="title"><a id="testing"/>Chapter 10. Testing</h1></div></div></div><p><a class="indexterm" id="iddle1842"/><a class="indexterm" id="iddle2230"/>So far, you’ve tested your code by typing in the Rails console and
        clicking links in the web browser. As you add more features to your application, however,
        this won’t scale. And even with more effective test methods, you’ll still have
        to remember to retest everything in the application after you add each feature. Otherwise
        you might miss a regression.</p><p>Rather than manually testing your application, you can write automated tests in Ruby to
        ensure your code is correct and meets all of your requirements. Once you have a set of
        automated tests in place, you can run an entire suite of tests to catch regressions, helping
        you to refactor your code with confidence.</p><p>Several different test frameworks are available for Ruby. In this chapter, we focus on
        the default test framework used by Rails: MiniTest.</p><div class="sect1" title="Testing in Rails"><div class="titlepage"><div><div><h1 class="title"><a id="testing_in_rails"/>Testing in Rails</h1></div></div></div><p><a class="indexterm" id="iddle1249"/><a class="indexterm" id="iddle1444"/><a class="indexterm" id="iddle2035"/><a class="indexterm" id="iddle2048"/><a class="indexterm" id="iddle2225"/><a class="indexterm" id="iddle2238"/>Basic test skeletons are automatically created in the
            <span class="emphasis"><em>test</em></span> directory when you generate Rails models and controllers.
          These are just starting points: They don’t really test anything, but having the
          framework in place makes adding your own tests much easier.</p><p>In this chapter, I’ll discuss testing models and controllers. You’ll learn
          how to test individual components and the interactions between components. But first,
          let’s prepare your environment for testing.</p><div class="sect2" title="Preparing to Test"><div class="titlepage"><div><div><h2 class="title"><a id="preparing_to_test"/>Preparing to Test</h2></div></div></div><p>So far you’ve been working in the Rails <code class="literal">development</code>
            environment while building the application. The Rails <code class="literal">test</code>
            environment is preconfigured for testing, but you still must do a few things before
            running your tests.</p><p>The <code class="literal">test</code> environment uses a separate database just for running
            tests. First, make sure your application’s <span class="emphasis"><em>db/schema.rb</em></span> is up
            to date by running database migrations:</p><a id="pro_id00303"/><pre class="programlisting">$ <span class="strong"><strong>bin/rake db:migrate</strong></span></pre><p>The test database is automatically re-created before each test run to ensure that
            tests don’t depend on data already in the database.</p></div><div class="sect2" title="Running Tests"><div class="titlepage"><div><div><h2 class="title"><a id="running_tests"/>Running Tests</h2></div></div></div><p>Now that the test database is set up, you’re ready to run your tests. Rails
            provides several different rake tasks for running the various types of tests
            you’ll create.</p><p>The <code class="literal">bin/rake test</code> command runs all tests by default. If you
            include the name of a test file on the command line, it only runs the tests in that
            file. While working on a particular model or controller, running the tests associated
            with that class is faster.</p><p>This command runs all of the tests in the file
              <span class="emphasis"><em>test/models/user_test.rb</em></span>:</p><a id="pro_id00304"/><pre class="programlisting">$ <span class="strong"><strong>bin/rake test test/models/user_test.rb</strong></span></pre><p>After a short pause, you should see output like this:</p><a id="pro_id00305"/><pre class="programlisting">Run options: --seed 46676

# Running:

Finished in 0.001716s, 0.0000 runs/s, 0.0000 assertions/s.

0 runs, 0 assertions, 0 failures, 0 errors, 0 skips</pre><p>As the last line indicates, no tests have been defined yet. Open
              <span class="emphasis"><em>test/models/user_test.rb</em></span> in your editor and let’s add some
            tests.</p><a id="pro_id00306"/><pre class="programlisting">➊ require 'test_helper'

➋ class UserTest &lt; ActiveSupport::TestCase
➌   # test "the truth" do
    # assert true
    # end
  end</pre><p><a class="indexterm" id="iddle1044"/><a class="indexterm" id="iddle1121"/><a class="indexterm" id="iddle1171"/><a class="indexterm" id="iddle1670"/><a class="indexterm" id="iddle1676"/><a class="indexterm" id="iddle1934"/><a class="indexterm" id="iddle1935"/><a class="indexterm" id="iddle2215"/><a class="indexterm" id="iddle2306"/>This test file first requires the file
              <span class="emphasis"><em>test/test_helper.rb</em></span> ➊, which holds the configuration for
            all tests. The test helper also loads all <span class="emphasis"><em>fixtures</em></span>, or sample data,
            and can include helper methods for tests. Next, the test file defines a <span class="emphasis"><em>test
              case</em></span> named <code class="literal">UserTest</code> by inheriting from
              <code class="literal">ActiveSupport::TestCase</code> ➋. A test case is a set of tests
            related to a class. Inside the test case, a simple example test ➌ is provided in
            the comments.</p><p>The commented-out test doesn’t really test anything even if you uncomment it,
            so you could remove it. But these lines do show the basic structure of all tests, so
            let’s examine them before moving forward:</p><a id="pro_id00307"/><pre class="programlisting">➊ test "the truth" do
➋   assert true
  end</pre><p>The <code class="literal">test</code> method ➊ accepts a test name and a block of code
            to execute. This block contains one or more assertions ➋. An
              <span class="emphasis"><em>assertion</em></span> tests a line of code for an expected result. The
              <code class="literal">assert</code> method shown here expects its argument to evaluate to a true
            value. If the assertion is true, the test passes and a single dot is printed. Otherwise,
            the test fails and an <span class="emphasis"><em>F</em></span> is printed along with a message identifying
            the failing test.</p><p>Now let’s follow this basic test structure to add a real test to this file. I
            find it helpful to open the model I’m testing, in this case,
              <span class="emphasis"><em>app/models/user.rb</em></span>, and the test file at the same time. I usually
            add tests for any custom methods I’ve added to a model and verify that the
            model’s validations are working as expected. Looking at the
              <code class="literal">user</code> model, you see several <code class="literal">has_many</code>
            associations, followed by the Rails <code class="literal">has_secure_password</code> method, a
            validation, and the methods you’ve written.</p><p>First, let’s make sure you can create a valid user. Remember, the
              <code class="literal">has_secure_password</code> method adds validations for attributes named
              <code class="literal">password</code> and <code class="literal">password_confirmation</code>. Users are
            also required to have a unique email address, so to create a valid user, you must
            provide <code class="literal">email</code>, <code class="literal">password</code>, and
              <code class="literal">password_confirmation</code>.</p><a id="pro_id00308"/><pre class="programlisting">  test "saves with valid attributes" do
➊   user = User.new(
      email: "user@example.com",
      password: "password",
      password_confirmation: "password"
     )
➋    assert user.save
   end</pre><p><a class="indexterm" id="iddle1222"/><a class="indexterm" id="iddle1572"/><a class="indexterm" id="iddle2223"/><a class="indexterm" id="iddle2239"/><a class="indexterm" id="iddle2292"/><a class="indexterm" id="iddle2345"/>Here, you instantiate a new <code class="literal">User</code> object with valid
            attributes ➊ and assert that it saves ➋.</p><p>Run the tests in this file again:</p><a id="pro_id00309"/><pre class="programlisting">  $ <span class="strong"><strong>bin/rake test test/models/user_test.rb</strong></span>
  Run options: --seed 40521

  # Running:
➊.

  Finished in 0.067091s, 14.9051 tests/s, 14.9051 assertions/s.

➋ 1 runs, 1 assertions, 0 failures, 0 errors, 0 skips</pre><p>The single dot ➊ represents the single test. The last line of output ➋
            tells you that you ran one test with one assertion and had zero failures.</p><p>You could continue adding tests at this point, but manually creating users for all
            of your tests will get tedious. Luckily, Rails includes the fixtures I mentioned
            earlier, which can automatically create as many model objects with sample data as you
            need.</p></div><div class="sect2" title="Using Fixtures"><div class="titlepage"><div><div><h2 class="title"><a id="using_fixtures"/>Using Fixtures</h2></div></div></div><p><span class="emphasis"><em>Fixtures</em></span> provide sample data for tests, and they are written in
            a format called <span class="emphasis"><em>YAML</em></span>. YAML originally stood for <span class="emphasis"><em>Yet
              Another Markup Language</em></span>, but is now a recursive acronym for <span class="emphasis"><em>YAML
              Ain’t Markup Language</em></span>. Fixtures are automatically loaded into the
              <code class="literal">test</code> database by the file <span class="emphasis"><em>tests/test_helper.rb</em></span>
            and are available to all test cases.</p><div class="sect3" title="User Fixtures"><div class="titlepage"><div><div><h3 class="title"><a id="user_fixtures"/>User Fixtures</h3></div></div></div><p>Open the file <span class="emphasis"><em>test/fixtures/users.yml</em></span>, remove its contents,
              and create two sample users:</p><a id="pro_id00310"/><pre class="programlisting">➊ user1:
➋   email: user1@example.com
➌   password_digest: &lt;%= BCrypt::Password.create "password" %&gt;

  user2:
     email: user2@example.com
     password_digest: &lt;%= BCrypt::Password.create "password" %&gt;</pre><p>This code adds sample data for two users. The YAML file begins with the name of
              the first fixture followed by a colon ➊. In this case, the fixture is named
                <code class="literal">user1</code>. The indented lines under the name specify attributes. The
              first user has an email address of <code class="literal">user1@example.com</code>
              ➋.</p><p>You can even use ERB to help add data to fixtures. Rather than precompute the
              values for the <code class="literal">password_digest</code> field, use the
                <code class="literal">BCrypt::Password.create</code> method to create the
                <code class="literal">password_digest</code> ➌ dynamically. This method is part of the
              bcrypt gem you installed in <a class="xref" href="ch09.html" title="Chapter 9. Authentication">Chapter 9</a>.</p><p><a class="indexterm" id="iddle1713"/><a class="indexterm" id="iddle1807"/><a class="indexterm" id="iddle1964"/><a class="indexterm" id="iddle2222"/><a class="indexterm" id="iddle2226"/><a class="indexterm" id="iddle2240"/><a class="indexterm" id="iddle2247"/>Refer to one of these users in your tests by calling the
                <code class="literal">users</code> method and passing the name of the user you want. For
              example, <code class="literal">users(:user1)</code> returns the first user just defined.</p><p>Go back to the user tests in <span class="emphasis"><em>test/models/user_test.rb</em></span> and
              let’s try the new fixtures:</p><a id="pro_id00311"/><pre class="programlisting">    test "validates email presence" do
➊     @user1 = users(:user1)
➋     @user1.email = nila

➌     assert_not @user1.valid?
    end</pre><p>This test uses a fixture to initialize a user ➊, sets the user’s
                <code class="literal">email</code> to <code class="literal">nil</code> ➋, and ensures the user is
              not valid with the <code class="literal">assert_not</code> method ➌. The
                <code class="literal">assert_not</code> method only passes if its condition is a false
              value.</p><p>This test proves that an email is required; now you’ll add a test for email
              uniqueness.</p><a id="pro_id00312"/><pre class="programlisting">    test "validates email uniqueness" do
➊     @user1 = users(:user1)
      @user2 = users(:user2)

➋     @user1.email = @user2.email

➌     asseart_not @user1.valid?
    end</pre><p>This test uses fixtures to initialize two users ➊, sets the first
              user’s <code class="literal">email</code> equal to the second user’s
                <code class="literal">email</code> ➋, and asserts ➌ that the first user is no
              longer valid. The second user is still valid because the first user can’t be
              saved with invalid data. You can look at the test log in
                <span class="emphasis"><em>log/test.log</em></span> to see the queries being run for each test.</p><p>Fixtures have <code class="literal">id</code> values based on a hash of the fixture name,
              and those values are always the same. For example, the <code class="literal">id</code> for
                <code class="literal">@user1</code> is 206669143. This value never changes. Associations
              between fixtures are created by name because the <code class="literal">id</code> of each fixture
              is based on its name. The <code class="literal">Post</code> fixtures discussed next include
              associations with the <code class="literal">User</code> fixtures you created earlier.</p></div><div class="sect3" title="Post Fixtures"><div class="titlepage"><div><div><h3 class="title"><a id="post_fixtures"/>Post Fixtures</h3></div></div></div><p>Rails automatically created fixture files for the <code class="literal">TextPost</code> and
                <code class="literal">ImagePost</code> types. You’ll include both types of fixtures in
              the <code class="literal">Post</code> file. The fixture files for the other types will cause an
              error, so delete the files <span class="emphasis"><em>test/fixtures/text_posts.yml</em></span> and
                <span class="emphasis"><em>test/fixtures/image_posts.yml</em></span> before moving on.</p><p>Now open the file <span class="emphasis"><em>test/fixtures/posts.yml</em></span> and create some
              sample posts:</p><a id="pro_id00313"/><pre class="programlisting">post1:
  title: Title One
  body: Body One
  type: TextPost
  user: user1

post2:
  title: Title Two
  url: http://i.imgur.com/Y7syDEa.jpg
  type: ImagePost
  user: user1

post3:
  title: Title Three
  body: Body Three
  type: TextPost
  user: user2</pre><p><a class="indexterm" id="iddle1169"/><a class="indexterm" id="iddle1843"/><a class="indexterm" id="iddle1891"/>Here, you have three posts. The first two belong to the
                <code class="literal">User</code> named <span class="emphasis"><em>user1</em></span> and the third belongs to
                <span class="emphasis"><em>user2</em></span>. You’ll put these to good use a little later when
              you add tests for the <code class="literal">Post</code> model.</p></div></div><div class="sect2" title="Putting Assertions to Work"><div class="titlepage"><div><div><h2 class="title"><a id="putting_assertions_to_work"/>Putting Assertions to Work</h2></div></div></div><p>Assertions are the building blocks of tests. You’ve already seen a few
            assertions, such as <code class="literal">assert</code> and <code class="literal">assert_not</code>, in the
            tests you’ve written so far. The MiniTest library contains more, and Rails adds a
            few of its own. Here are some of the most commonly used assertions:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong><code class="literal">assert</code>
                  <span class="emphasis"><em><code class="literal">test</code></em></span></strong></span></span></dt><dd><p>Passes if the <code class="literal">test</code> expression evaluates to true</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">assert_empty</code>
                  <span class="emphasis"><em><code class="literal">obj</code></em></span></strong></span></span></dt><dd><p>Passes if <code class="literal">obj.empty?</code> is true</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">assert_equal</code>
                  <span class="emphasis"><em><code class="literal">expected, actual</code></em></span></strong></span></span></dt><dd><p>Passes if the <code class="literal">expected</code> value equals the
                    <code class="literal">actual</code> value</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">assert_includes</code>
                  <span class="emphasis"><em><code class="literal">collection, obj</code></em></span></strong></span></span></dt><dd><p>Passes if <code class="literal">collection.includes?(obj)</code> returns true</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">assert_instance_of</code>
                  <span class="emphasis"><em><code class="literal">class, obj</code></em></span></strong></span></span></dt><dd><p>Passes if <code class="literal">obj.instance_of?(class)</code> is true</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">assert_match</code>
                  <span class="emphasis"><em><code class="literal">regexp, string</code></em></span></strong></span></span></dt><dd><p>Passes if the given <code class="literal">string</code> matches the regular expression
                    <code class="literal">regexp</code></p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">assert_nil</code>
                  <span class="emphasis"><em>obj</em></span></strong></span></span></dt><dd><p>Passes if <code class="literal">obj.nil?</code> is true</p></dd></dl></div><p>Each of these assertions also comes in a “not” form. For example,
              <code class="literal">assert_not</code> passes if the expression being tested is false and
              <code class="literal">assert_not_equal</code> passes if the expected value is not equal to the
            actual value. Assertions also accept an optional message parameter, which is a string
            that prints if the assertion fails.</p><p><a class="indexterm" id="iddle1289"/><a class="indexterm" id="iddle1517"/><a class="indexterm" id="iddle2154"/><a class="indexterm" id="iddle2213"/>Let’s put our knowledge of assertions to work and add a few more tests
            to the <code class="literal">user</code> model. Here’s the first one:</p><a id="pro_id00314"/><pre class="programlisting">   test "should follow leader" do
➊    @user1 = users(:user1)
     @user2 = users(:user2)

➋    @user1.follow!(@user2)

➌    assert_equal 1, @user1.leaders.count
     assert_equal 1, @user2.followers.count
   end</pre><p>This test creates two users using fixtures ➊ and then calls the
              <code class="literal">follow!</code> method on <code class="literal">@user1</code> with
              <code class="literal">@user2</code> as an argument ➋. It then ensures that
              <code class="literal">@user1</code> has one leader and <code class="literal">@user2</code> has one
            follower ➌.</p><p>This next test verifies the <code class="literal">following?</code> method works
            correctly:</p><a id="pro_id00315"/><pre class="programlisting">test "following? should be true" do
  @user1 = users(:user1)
  @user2 = users(:user2)

  @user1.follow!(@user2)

  assert @user1.following?(@user2)
end</pre><p>It again uses fixtures to create two users and then calls the
              <code class="literal">follow!</code> method on <code class="literal">@user1</code> with
              <code class="literal">@user2</code> as an argument and finally ensures that
              <code class="literal">@user1.following?(@user2)</code> is true.</p></div><div class="sect2" title="Eliminating Duplication with Callbacks"><div class="titlepage"><div><div><h2 class="title"><a id="eliminating_duplication_with_callbacks"/>Eliminating Duplication with Callbacks</h2></div></div></div><p>The tests you’ve made should all work correctly, but I’ve introduced
            some duplication in the code. Almost every test uses fixtures to create users. Remember,
            don’t repeat yourself. Luckily, test cases include two callbacks that can help
            eliminate this duplication. <span class="emphasis"><em>Callbacks</em></span> are methods that are called
            automatically before and after each test.</p><p>The <code class="literal">setup</code> method is called before each test, and the
              <code class="literal">teardown</code> method is called after each test. These methods are
            commonly used to initialize objects that are employed in multiple tests. You can use the
              <code class="literal">setup</code> method to initialize the values of <code class="literal">@user1</code>
            and <code class="literal">@user2</code> automatically.</p><a id="pro_id00316"/><pre class="programlisting">  class UserTest &lt; ActiveSupport::TestCase
➊   def setup
      @user1 = users(:user1)
      @user2 = users(:user2)
    end

    --<span class="emphasis"><em>snip</em></span>--
➋   test "following? should be true" do
      @user1.follow!(@user2)

      assert @user1.following?(@user2)
    end
  end</pre><p><a class="indexterm" id="iddle1850"/><a class="indexterm" id="iddle2237"/><a class="indexterm" id="iddle2276"/>Now that <code class="literal">@user1</code> and <code class="literal">@user2</code> are being
            initialized ➊ in the setup method, you can remove the duplication from each of
            the tests, as shown in the rewritten test for <code class="literal">following?</code>
            ➋.</p></div></div><div class="sect1" title="Model Tests"><div class="titlepage"><div><div><h1 class="title"><a id="model_tests"/>Model Tests</h1></div></div></div><p>The tests you’ve seen so far are model tests. <span class="emphasis"><em>Model tests</em></span>
          verify the behavior of your application’s models. These types of tests were
          previously called <span class="emphasis"><em>unit tests</em></span>. I typically add tests for validations
          and for any custom methods I’ve written.</p><p>I’ve covered both of these for the <code class="literal">User</code> model, so now
          let’s add tests for the <code class="literal">Post</code> model. You may also want to refer to
          the <code class="literal">Post</code> model in <span class="emphasis"><em>app/models/post.rb</em></span> as you write
          tests.</p><a id="pro_id00317"/><pre class="programlisting">class Post &lt; ActiveRecord::Base
  belongs_to :user
  has_many :comments, dependent: :destroy

  validates :user_id, presence: true
  validates :type, presence: true
end</pre><p>The <code class="literal">Post</code> model is still pretty simple. A post belongs to a user and
          can have many comments. It also validates the presence of a <code class="literal">user_id</code> and
          a <code class="literal">type</code>. Let’s add a test to verify that a <code class="literal">Post</code>
          has a <code class="literal">user_id</code>. Open the file
            <span class="emphasis"><em>test/models/post_test.rb</em></span> in your editor:</p><a id="pro_id00318"/><pre class="programlisting">  require 'test_helper'

  class PostTest &lt; ActiveSupport::TestCase
➊   def setup
      @post1 = posts(:post1)
      @post2 = posts(:post2)
    end

➋   test "validates user_id presence" do
      @post1.user_id = nil

      assert_not @post1.valid?
   end
end</pre><p><a class="indexterm" id="iddle1250"/><a class="indexterm" id="iddle1714"/><a class="indexterm" id="iddle2155"/><a class="indexterm" id="iddle2248"/>The <code class="literal">setup</code> method ➊ initializes two posts that you
          can refer to in your tests. The first test ➋ verifies that a
            <code class="literal">Post</code> without a <code class="literal">user_id</code> is not valid.</p><p>Since you have model tests for the users and posts now, you can use the
            <code class="literal">bin/rake test:models</code> command to run all model tests:</p><a id="pro_id00319"/><pre class="programlisting">$ <span class="strong"><strong>bin/rake test:models</strong></span>
Run options: --seed 47072

# Running:

......

Finished in 0.234202s, 25.6189 runs/s, 29.8887 assertions/s.

6 runs, 7 assertions, 0 failures, 0 errors, 0 skips</pre><p>If this command results in an error, delete the unused fixture files for the
            <code class="literal">TextPost</code> and <code class="literal">ImagePost</code> models as mentioned
          earlier. Delete <span class="emphasis"><em>test/fixtures/text_posts.yml</em></span> and
            <span class="emphasis"><em>test/fixtures/image_posts.yml</em></span>.</p><p>The other post types have validations of their own. For example, the
            <code class="literal">TextPost</code> validates the presence of a <code class="literal">body</code>, and the
            <code class="literal">ImagePost</code> validates the presence of a <code class="literal">url</code>. Since
          we already have <code class="literal">TextPost</code> and <code class="literal">ImagePost</code> fixtures,
          let’s add tests for both of those validations:</p><a id="pro_id00320"/><pre class="programlisting">  test "TextPost requires body" do
➊   assert_instance_of TextPost, @post1

➋   @post1.body = nil

➌   assert_not @post1.valid?
  end

  test "ImagePost requires url" do
    assert_instance_of ImagePost, @post2

    @post2.url = nil

    assert_not @post2.valid?
  end</pre><p>Both of these tests follow the same pattern. First, verify that
            <code class="literal">@post1</code> is an instance of <code class="literal">TextPost</code> ➊. Next,
          set the <code class="literal">body</code> of <code class="literal">@post1</code> to <code class="literal">nil</code>
          ➋. Finally, verify that <code class="literal">@post1</code> is no longer valid ➌. The
            <code class="literal">ImagePost</code> assertions do the same, but for
          <code class="literal">@post2</code>.</p></div><div class="sect1" title="Controller Tests"><div class="titlepage"><div><div><h1 class="title"><a id="controller_tests"/>Controller Tests</h1></div></div></div><p><a class="indexterm" id="iddle1170"/><a class="indexterm" id="iddle1182"/><a class="indexterm" id="iddle1383"/><a class="indexterm" id="iddle1388"/><a class="indexterm" id="iddle1474"/><a class="indexterm" id="iddle1575"/><a class="indexterm" id="iddle1599"/><a class="indexterm" id="iddle1621"/><a class="indexterm" id="iddle1678"/><a class="indexterm" id="iddle1685"/><a class="indexterm" id="iddle1939"/><a class="indexterm" id="iddle1970"/><a class="indexterm" id="iddle2019"/><a class="indexterm" id="iddle2150"/><a class="indexterm" id="iddle2233"/><span class="emphasis"><em>Controller tests</em></span> verify the actions of a single
          controller by simulating requests to your application and validating the responses.
          Controller tests ensure that a controller action responds successfully to valid requests,
          and that it renders the correct view or redirects to the correct location. These types of
          tests were previously called <span class="emphasis"><em>functional tests</em></span>.</p><div class="sect2" title="Controller Test Helpers"><div class="titlepage"><div><div><h2 class="title"><a id="controller_test_helpers"/>Controller Test Helpers</h2></div></div></div><p>Rails includes several helper methods and variables that make controller tests
            easier to write.</p><p>The methods <code class="literal">get</code>, <code class="literal">post</code>, <code class="literal">put</code>,
              <code class="literal">patch</code>, <code class="literal">head</code>, and <code class="literal">delete</code>
            simulate a request to a controller action. These methods can take two optional hashes:
            one representing request parameters and another representing the current session.</p><p>After a request has been made with one of those six methods, the following four
            hashes become available:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">assigns</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Contains the instance variables assigned in the
                      controller action</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">cookies</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Contains any cookie values set in the
                    action</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">flash</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Holds the flash values set in the action</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">session</code></strong></span></p></td><td style="" valign="top"><p>Contains any session values set by the
                    action</p></td></tr></tbody></table></div><p>Your tests also have access to three instance variables:
              <code class="literal">@controller</code> contains the controller processing the request;
              <code class="literal">@request</code> is the request being processed; and
              <code class="literal">@response</code> is the controller’s response to the request.</p></div><div class="sect2" title="Controller Test Assertions"><div class="titlepage"><div><div><h2 class="title"><a id="controller_test_assertions"/>Controller Test Assertions</h2></div></div></div><p>Rails adds several assertions specifically for controller tests in addition to those
            you’ve already seen. Controller actions always either render a response or
            redirect to a different URL.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong><code class="literal">assert_response</code>
                  <span class="emphasis"><em><code class="literal">type</code></em></span></strong></span></span></dt><dd><p>Passes if the HTTP response matches a specific status code. Use a status code
                  or one of the symbols <code class="literal">:success</code>, <code class="literal">:redirect</code>,
                    <code class="literal">:missing</code>, or <code class="literal">:error</code> for
                    <code class="literal">type</code>.</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">assert_redirected_to</code>
                  <span class="emphasis"><em><code class="literal">options</code></em></span></strong></span></span></dt><dd><p>Passes if the request causes a redirect to the path given in
                    <code class="literal">options</code>.</p></dd><dt><span class="term"><span class="strong"><strong><code class="literal">assert_template</code>
                  <span class="emphasis"><em>expected</em></span></strong></span></span></dt><dd><p>Passes if the request renders the <code class="literal">expected</code> template.</p></dd></dl></div><p>These assertions verify that a controller action correctly responds to a request.
            For a simple GET request, <code class="literal">assert_response :success</code> might be the only
            test needed. If the controller action assigns an instance variable, you should also
            verify that assignment.</p><p><a class="indexterm" id="iddle1391"/><a class="indexterm" id="iddle1392"/><a class="indexterm" id="iddle1626"/><a class="indexterm" id="iddle1874"/><a class="indexterm" id="iddle2220"/>Let’s add controller tests for the <code class="literal">new</code> and
              <code class="literal">create</code> actions in <code class="literal">UsersController</code>. First, test
            that the <code class="literal">new</code> action successfully renders the sign-up form with a
            newly created instance of the <code class="literal">User</code> model. Open the file
              <span class="emphasis"><em>test/controllers/users_controller_test.rb</em></span> to add the following
            test:</p><a id="pro_id00321"/><pre class="programlisting">   test "should get new with new user" do
➊    get :new

➋    user = assigns(:user)

➌   assert user.new_record?
    assert_response :success
  end</pre><p>This test issues a GET request for the new user page ➊, gets a copy of the
            value assigned to the instance variable <code class="literal">@user</code> ➋ in the
            controller, and verifies that <code class="literal">user</code> is a new record ➌ and the
            response was successful.</p><p>The next test checks the ability to create new users given valid data:</p><a id="pro_id00322"/><pre class="programlisting">   test "should create user" do
➊    params = {
       user: {
         email: "user@example.com",
         password: "password",
         password_confirmation: "password"
       }
      }

➋     post :create, params
➌     assert_redirected_to root_url
    end</pre><p>This test is a bit more complex because the <code class="literal">create</code> action expects
            a hash of values for the new user ➊. This test issues a POST request to the
              <code class="literal">create</code> action using the <code class="literal">params</code> hash ➋ and
            then verifies that the action redirects to the <code class="literal">root_url</code>
            ➌.</p><p>The previous test checks what happens when a <code class="literal">User</code> is successfully
            saved. You should test the other path through the controller action, that is, when the
              <code class="literal">User</code> can’t be saved. You could add a test that attempts to
            create a user with invalid attributes and verifies the new user template is rendered
            again.</p><p>Run the new controller tests with the <code class="literal">bin/rake test:controllers</code>
            command:</p><a id="pro_id00323"/><pre class="programlisting">$ <span class="strong"><strong>bin/rake test:controllers</strong></span></pre><p>The <code class="literal">UsersController</code> tests should pass successfully, so
            let’s move on to the <code class="literal">PostsController</code>. Verify that the
              <code class="literal">before_action</code> method <code class="literal">authenticate_user!</code> is
            working correctly so your application won’t show posts to unauthenticated
            users.</p><p><a class="indexterm" id="iddle1478"/><a class="indexterm" id="iddle1579"/><a class="indexterm" id="iddle1583"/><a class="indexterm" id="iddle1628"/><a class="indexterm" id="iddle1686"/><a class="indexterm" id="iddle1754"/><a class="indexterm" id="iddle1942"/><a class="indexterm" id="iddle1989"/><a class="indexterm" id="iddle2021"/><a class="indexterm" id="iddle2075"/><a class="indexterm" id="iddle2217"/><a class="indexterm" id="iddle2236"/>Open the file <span class="emphasis"><em>test/controllers/posts_controller_test.rb</em></span>
            in your editor and add the following tests:</p><a id="pro_id00324"/><pre class="programlisting">    test "redirects anonymous users to login" do
➊     get :index
➋     assert_redirected_to login_url
    end

    test "get index for authenticated users" do
➌     user1 = users(:user1)

➍     get :index, {}, { user_id: user1.id }
      assert_response :success
    end</pre><p>The first test attempts to GET the post <code class="literal">index</code> page ➊ and
            verifies the action redirects to the login page ➋. The second test initializes a
            user using a fixture ➌ then issues the GET request for the
              <code class="literal">index</code> page with a <code class="literal">user_id</code> in the session
            ➍. Simulating a logged-in user by including a valid <code class="literal">user_id</code> in
            the session should result in a successful response.</p></div></div><div class="sect1" title="Integration Tests"><div class="titlepage"><div><div><h1 class="title"><a id="integration_tests"/>Integration Tests</h1></div></div></div><p><span class="emphasis"><em>Integration tests</em></span> verify the interaction between several
          different controllers. These are commonly used to test the <span class="emphasis"><em>flow</em></span>
          between several pages of your application. An example of a flow would be logging in to the
          application, viewing a page, and then performing some other action. Each of these actions
          could be covered by controller tests. An integration test ensures that they all work
          together.</p><div class="sect2" title="Integration Helpers"><div class="titlepage"><div><div><h2 class="title"><a id="integration_helpers"/>Integration Helpers</h2></div></div></div><p>Because integration tests generally involve moving between pages in the application,
            your tests need not only to make requests to actions but also to follow any redirects.
            The helper methods <code class="literal">redirect?</code> and <code class="literal">follow_redirect!</code>
            check to see if the last request resulted in a redirect and follow a redirect response,
            respectively.</p><p>If you know that a request results in a redirect, more specific methods are
            available. You can use <code class="literal">get_via_redirect</code>,
              <code class="literal">post_via_redirect</code>, <code class="literal">put_via_redirect</code>,
              <code class="literal">patch_via_redirect</code>, or <code class="literal">delete_via_redirect</code> to
            make the appropriate request and also follow the redirect.</p></div><div class="sect2" title="Testing a Flow"><div class="titlepage"><div><div><h2 class="title"><a id="testing_a_flow"/>Testing a Flow</h2></div></div></div><p>Rails doesn’t create integration tests automatically like model and controller
            tests because Rails has no way of knowing which flows you want to test. Although they
            are not created automatically, Rails does include a generator you can use to create
            integration tests.</p><p><a class="indexterm" id="iddle1243"/><a class="indexterm" id="iddle1990"/><a class="indexterm" id="iddle2224"/>Let’s add an integration test to verify that a user can log in to the
            application, see the home page, and then log out. First, use the <code class="literal">bin/rails
              generate</code> command to create a new integration test:</p><a id="pro_id00325"/><pre class="programlisting">$ <span class="strong"><strong>bin/rails g integration_test user_flow</strong></span></pre><p>This command creates a new file named
              <span class="emphasis"><em>test/integration/user_flow_test.rb</em></span>. Open that file in your editor
            and let’s add a test:</p><a id="pro_id00326"/><pre class="programlisting">  require 'test_helper'

  class UserFlowTest &lt; ActionDispatch::IntegrationTest

    test "user login, browse, and logout" do
      user = users(:user1)

➊     get "/login"
a
      assert_response :success

➋     post_via_redirect "/sessions",
        email: user.email,
        password: "password"

      assert_equal "/", path

➌     get_via_redirect "/logout"

      assert_equal "/login", path
    end
 end</pre><p>This test looks like an extended controller test. The test requests a page with
              <code class="literal">get</code> ➊ and then verifies a successful response. You know that
            a user logs in to the application with a POST request to the sessions path and is then
            redirected to the home page, so you use the <code class="literal">post_via_redirect</code> method
            to submit the user’s email address and password and then follow the redirect
            automatically ➋. Finally, the test issues a GET request for the logout page
            ➌ and is redirected back to the login page.</p><p>Enter the following command to run the integration test:</p><a id="pro_id00327"/><pre class="programlisting">$ <span class="strong"><strong>bin/rake test test/integration/user_flow_test.rb</strong></span>
Run options: --seed 51886

# Running:

.

Finished in 1.049118s, 0.9532 runs/s, 2.8595 assertions/s.

1 runs, 3 assertions, 0 failures, 0 errors, 0 skips</pre><p><a class="indexterm" id="iddle2074"/><a class="indexterm" id="iddle2163"/><a class="indexterm" id="iddle2212"/><a class="indexterm" id="iddle2221"/><a class="indexterm" id="iddle2229"/>This test confirms that a user can log in to the application, view the home
            page, and then log out successfully.</p><p>This path is basically the only one a user can take through the application at this
            time. As you add more actions to the application, you can create integration tests to
            verify that other flows work correctly.</p></div></div><div class="sect1" title="Adding Features with Test-Driven Development"><div class="titlepage"><div><div><h1 class="title"><a id="adding_features_with_test-driven_develop"/>Adding Features with Test-Driven Development</h1></div></div></div><p>The tests written so far have all verified existing functionality, but some Rails
          developers use tests to define features before implementing them, a practice called
            <span class="emphasis"><em>test-driven development (TDD)</em></span>. In TDD, you write a test first and
          then add code to make the test pass. Once the test passes, you can refactor the code if
          necessary. If you follow TDD, you won’t have to worry about parsing your code later
          to figure out what functionality to verify.</p><p>TDD is usually a three-step process known as red-green-refactor:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Write a failing test (red).</p></li><li class="listitem"><p>Write code to make the test pass (green).</p></li><li class="listitem"><p>Refactor as needed (refactor).</p></li></ol></div><p>By following this process, you can be confident that new functionality meets the
          requirements specified in the test and that it did not introduce any regressions.</p><p>Let’s use TDD to add features to our social application. Although many features
          are still missing, let’s focus on these:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Add a user <code class="literal">show</code> page showing a user’s posts and a Follow
              button.</p></li><li class="listitem"><p>Give users the ability to create new posts.</p></li></ul></div><p>For each of these features, you’ll first write a failing test and then write
          code to make the test pass.</p><div class="sect2" title="Show User"><div class="titlepage"><div><div><h2 class="title"><a id="show_user"/>Show User</h2></div></div></div><p>The user <code class="literal">show</code> page displays the user’s name and posts. It
            should also include a button to allow other users to follow this user. To add the user
              <code class="literal">show</code> page, you need to add a <code class="literal">show</code> method to the
            user controller and create a corresponding view. You know the controller should assign
            an instance variable named <code class="literal">@user</code> for the view to use and respond with
            success, so let’s add a test for that.</p><p>Open the file <span class="emphasis"><em>test/controllers/users_controller_test.rb</em></span> and add
            this test:</p><a id="pro_id00328"/><pre class="programlisting">test "should show user" do
  user = users(:user1)

  get :show, id: user.id
  assert assigns(:user)
  assert_response :success
end</pre><p><a class="indexterm" id="iddle1161"/>Now, run the test and make sure it fails:</p><a id="pro_id00329"/><pre class="programlisting">$ <span class="strong"><strong>bin/rake test test/controllers/users_controller_test.rb</strong></span></pre><p>Running this test should result in an error. The action <code class="literal">show</code>
            could not be found for <code class="literal">UsersController</code> because you haven’t
            created it yet. So let’s add the <code class="literal">show</code> action to
              <span class="emphasis"><em>app/controllers/users_controller.rb</em></span>:</p><a id="pro_id00330"/><pre class="programlisting">class UsersController &lt; ApplicationController

<span class="strong"><strong>def show</strong></span>
  <span class="strong"><strong>@user = User.find(params[:id])</strong></span>
  <span class="strong"><strong>@posts = @user.posts.order("created_at DESC")</strong></span>
  <span class="strong"><strong>end</strong></span>

--<span class="emphasis"><em>snip</em></span>--</pre><p>Save the file and run the tests again. This time you should see a different error.
            The template is missing. Create a new file named
              <span class="emphasis"><em>app/views/users/show.html.erb</em></span>, and add that template now:</p><a id="pro_id00331"/><pre class="programlisting">&lt;div class="page-header"&gt;
  &lt;h1&gt;User&lt;/h1&gt;
&lt;/div&gt;

&lt;p class="lead"&gt;&lt;%= @user.name %&gt;&lt;/p&gt;

&lt;h2&gt;Posts&lt;/h2&gt;

&lt;%= render @posts %&gt;

&lt;%= link_to "Home", root_path,
      class: "btn btn-default" %&gt;</pre><p>Save this file and run the tests again. All tests should now pass, but you still
            have one problem. This page shows the user’s email address and the user’s
            posts, but no one can follow the user!</p><p>Following a user creates a record in the subscriptions table in the database.
            Because this has to happen on the server, adding the Follow button requires a controller
            action and a new route to that action.</p><p>Add another controller test to
              <span class="emphasis"><em>test/controllers/users_controller_test.rb</em></span> to describe this
            action:</p><a id="pro_id00332"/><pre class="programlisting">   test "should follow user" do
➊    user1 = users(:user1)
     user2 = users(:user2)

➋    get :follow, { id: user2.id }, { user_id: user1.id }
➌    assert user1.following? user2
     assert_redirected_to user_url(user2)
   end</pre><p><a class="indexterm" id="iddle1100"/><a class="indexterm" id="iddle1162"/><a class="indexterm" id="iddle1367"/><a class="indexterm" id="iddle1573"/>This test first creates two users using fixtures ➊. Next, it issues a
            GET request for the <code class="literal">follow</code> action with the second user’s
              <code class="literal">id</code> as a parameter and the first user’s <code class="literal">id</code>
            in the session ➋. This simulates <code class="literal">user1</code> following
              <code class="literal">user2</code>. Finally, it verifies that <code class="literal">user1</code> is now
            following <code class="literal">user2</code> and that the request redirects back to the
              <code class="literal">show</code> page for <code class="literal">user2</code> ➌.</p><p>Now open the file <span class="emphasis"><em>app/controllers/users_controller.rb</em></span>, and add
            the <code class="literal">follow</code> action after the other actions, but before the
              <code class="literal">private</code> methods:</p><a id="pro_id00333"/><pre class="programlisting">   class UsersController &lt; ApplicationController
     --<span class="emphasis"><em>snip</em></span>--

     <span class="strong"><strong>def follow</strong></span>
➊    <span class="strong"><strong>@user = User.find(params[:id])</strong></span>
➋    <span class="strong"><strong>if current_user.follow!(@user)</strong></span>
➌      <span class="strong"><strong>redirect_to @user, notice: "Follow successful!"</strong></span>
     <span class="strong"><strong>else</strong></span>
       <span class="strong"><strong>redirect_to @user, alert: "Error following."</strong></span>
     <span class="strong"><strong>end</strong></span>
   <span class="strong"><strong>end</strong></span>

   private
   --<span class="emphasis"><em>snip</em></span>--</pre><p>This method finds the correct user using the id parameter ➊, calls the
            follow! method on current_user ➋, and then redirects to @user ➌.</p><p>Now open <span class="emphasis"><em>config/routes.rb</em></span> and add a route to the new
              <code class="literal">follow</code> action:</p><a id="pro_id00334"/><pre class="programlisting">Rails.application.routes.draw do
  --<span class="emphasis"><em>snip</em></span>-

  get 'signup', to: 'users#new', as: 'signup'
  <span class="strong"><strong>get 'follow/:id', to: 'users#follow', as: 'follow_user'</strong></span>

  --<span class="emphasis"><em>snip</em></span>-
end</pre><p>I added this under the <code class="literal">signup</code> route because these actions are
            both in the user controller. Now, back in
              <span class="emphasis"><em>app/views/users/show.html.erb,</em></span> you can add the Follow
            button:</p><a id="pro_id00335"/><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>-
&lt;p class="lead"&gt;&lt;%= @user.name %&gt;&lt;/p&gt;

<span class="strong"><strong>&lt;%= link_to "Follow", follow_user_path(@user),</strong></span>
      <span class="strong"><strong>class: "btn btn-default" %&gt;</strong></span>

&lt;h2&gt;Posts&lt;/h2&gt;
--<span class="emphasis"><em>snip</em></span>--</pre><p><a class="indexterm" id="iddle1259"/><a class="indexterm" id="iddle1983"/><a class="indexterm" id="iddle2218"/><a class="indexterm" id="iddle2246"/>The Follow button is similar to the Home button; it’s actually a link
            with Bootstrap’s <code class="literal">btn</code> and <code class="literal">btn-default</code> styles
            applied to make it look like a button.</p><p>You can now run the controller tests again and verify that they all pass. You can
            also start the Rails server if it isn’t already running and go to
              <span class="emphasis"><em>http://localhost:3000/users/1</em></span> in your web browser to see the
              <code class="literal">show</code> page for the first user, as shown in <a class="xref" href="ch10.html#user_show_page" title="Figure 10-1. The user show page">Figure 10-1</a>.</p><div class="figure"><a id="user_show_page"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00020"/><img alt="The user show page" src="httpatomoreillycomsourcenostarchimages2169098.png.jpg"/></div></div><p class="title">Figure 10-1. The user show page</p></div><p><a class="xref" href="ch10.html#user_show_page" title="Figure 10-1. The user show page">Figure 10-1</a> is the <code class="literal">show</code> page with the
            user’s name, a button for following this user, and the user’s posts.</p></div><div class="sect2" title="Create Post"><div class="titlepage"><div><div><h2 class="title"><a id="create_post"/>Create Post</h2></div></div></div><p>Now let’s give users the ability to add posts. Adding posts requires two
            controller actions: <code class="literal">new</code> and <code class="literal">create</code>. The
              <code class="literal">new</code> action also requires a matching view. The
              <code class="literal">create</code> action should redirect to the newly created post, so a view
            isn’t needed.</p><p>Your application has two different types of posts. Start by adding the ability to
            create posts of type <code class="literal">TextPost</code>. The <code class="literal">new</code> action in
              <code class="literal">TextPostsController</code> should instantiate a new
              <code class="literal">TextPost</code> object and render a form for that object. Add a failing
            test to <span class="emphasis"><em>test/controllers/text_posts_controller_test.rb</em></span> and then get
            to work:</p><a id="pro_id00336"/><pre class="programlisting">   test "get new with new post" do
➊    user1 = users(:user1)

➋    get :new, {}, { user_id: user1.id }
     text_post = assigns(:text_post)

     assert text_post.new_record?
     assert_response :success
   end</pre><p><a class="indexterm" id="iddle1096"/><a class="indexterm" id="iddle1153"/><a class="indexterm" id="iddle1200"/><a class="indexterm" id="iddle2087"/>The test first creates a new user using a fixture ➊ and then issues a
            GET request for the <code class="literal">new</code> action with <code class="literal">user_id</code> set in
            the session ➋. This step is necessary because the
              <code class="literal">TextPostsController</code> requires an authenticated user. The test then
            gets the <code class="literal">text_post</code> instance variable, verifies it’s a new
            record, and verifies a successful response. Run the tests and watch this one
            fail:</p><a id="pro_id00337"/><pre class="programlisting">$ <span class="strong"><strong>bin/rake test test/controllers/text_posts_controller_test.rb</strong></span></pre><p>The error message should indicate that the <code class="literal">new</code> action is missing
            from <code class="literal">TextPostsController</code>. Open
              <span class="emphasis"><em>app/controllers/text_posts_controller.rb</em></span>, and add the new
            action:</p><a id="pro_id00338"/><pre class="programlisting">class TextPostsController &lt; ApplicationController
  <span class="strong"><strong>def new</strong></span>
    <span class="strong"><strong>@text_post = TextPost.new</strong></span>
  <span class="strong"><strong>end</strong></span>
end</pre><p>You almost have enough to get the test to pass. The last step is to add the
            corresponding view. Create the file
              <span class="emphasis"><em>app/views/text_posts/new.html.erb</em></span>, and add the following
            content:</p><a id="pro_id00339"/><pre class="programlisting">&lt;div class="page-header"&gt;
  &lt;h1&gt;New Text Post&lt;/h1&gt;
&lt;/div&gt;

&lt;%= render 'form' %&gt;</pre><p>This view is a page header followed by a <code class="literal">render</code> command for the
            form partial. Let’s add the partial now. First, create the file
              <span class="emphasis"><em>app/views/text_posts/_form.html.erb</em></span>, and add this form:</p><a id="pro_id00340"/><pre class="programlisting">&lt;%= form_for @text_post do |f| %&gt; ➊
  &lt;div class="form-group"&gt;
    &lt;%= f.label :title %&gt;
    &lt;%= f.text_field :title, class: "form-control" %&gt; ➋
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;%= f.label :body %&gt;
    &lt;%= f.text_area :body, class: "form-control" %&gt; ➌
  &lt;/div&gt;

  &lt;%= f.submit class: "btn btn-primary" %&gt; ➍
  &lt;%= link_to 'Cancel', :back, class: "btn btn-default" %&gt;
&lt;% end %&gt;</pre><p><a class="indexterm" id="iddle1097"/><a class="indexterm" id="iddle1146"/><a class="indexterm" id="iddle2219"/><a class="indexterm" id="iddle2243"/><a class="indexterm" id="iddle2252"/>This partial creates a form for the new <code class="literal">TextPost</code> assigned
            to <code class="literal">@text_post</code> ➊. The form includes a text field for the post
            title ➋, a text area for the post body ➌, and buttons to submit the form
            or cancel and go back ➍.</p><p>While you’re editing views, add a button for creating a new text post on the
            home page. Open <span class="emphasis"><em>app/views/posts/index.html.erb,</em></span> and then add this
            link under the page header:</p><a id="pro_id00341"/><pre class="programlisting">&lt;p&gt;
  &lt;%= link_to "New Text Post", new_text_post_path,
        class: "btn btn-default" %&gt;
&lt;/p&gt;</pre><p>You should now be able to run the <code class="literal">TextPostController</code> tests
            successfully. Now add another controller test to describe creating a
              <code class="literal">TextPost</code> to
              <span class="emphasis"><em>test/controllers/text_posts_controller_test.rb</em></span>:</p><a id="pro_id00342"/><pre class="programlisting">    test "should create post" do

➊     user = users(:user1)
➋     params = {
        text_post: {
          title: "Test Title",
          body: "Test Body"
        }
      }

➌     post :create, params, { user_id: user.id }

      text_post = assigns(:text_post)

➍     assert text_post.persisted?

      assert_redirected_to post_url(text_post)
    end</pre><p>As with the previous controller test for the <code class="literal">TextPostsController</code>,
            this test first initializes a new user ➊ from a fixture. Next, it sets up the
            necessary parameters ➋ for a new <code class="literal">TextPost</code>, and then issues a
            POST request ➌ to the <code class="literal">create</code> action with the
              <code class="literal">params</code> hash and the <code class="literal">user.id</code> in the session.
            Finally, it ensures ➍ the new text post was persisted to the database and that
            the request redirects to the new post’s URL.</p><p>The first step to making this test pass is to add a <code class="literal">create</code> action
            to the <code class="literal">TextPostsController</code>. Open the file
              <span class="emphasis"><em>app/controllers/text_posts_controller.rb</em></span>, and add the following
            method:</p><a id="pro_id00343"/><pre class="programlisting">   class TextPostsController &lt; ApplicationController
   --<span class="emphasis"><em>snip</em></span>--

   <span class="strong"><strong>def create</strong></span>

     <span class="strong"><strong>@text_post =</strong></span>
➊      <span class="strong"><strong>current_user.text_posts.build(text_post_params)</strong></span>
       <span class="strong"><strong>if @text_post.save</strong></span>
➋       <span class="strong"><strong>redirect_to post_path(@text_post),</strong></span>
                       <span class="strong"><strong>notice: "Post created!"</strong></span>
        <span class="strong"><strong>else</strong></span>
➌         <span class="strong"><strong>render :new, alert: "Error creating post."</strong></span>
        <span class="strong"><strong>end</strong></span>
      <span class="strong"><strong>end</strong></span>
    end</pre><p><a class="indexterm" id="iddle1931"/>The <code class="literal">create</code> method builds a new text post ➊ for the
            current user using the <code class="literal">params</code> from the form. If it is able to save
            this new post, it redirects the user ➋ to the newly created post. Otherwise, it
            renders the new text post form ➌ again with an error message.</p><p>Finally, add the <code class="literal">text_post_params</code> method for Rails strong
              <code class="literal">params.</code> This method is called in the <code class="literal">create</code>
            action to get the permitted parameters for the new <code class="literal">TextPost</code>. Add this
            private method near the bottom of the <code class="literal">TextPostsController</code>
            class:</p><a id="pro_id00344"/><pre class="programlisting">    class TextPostsController &lt; ApplicationController
    --<span class="emphasis"><em>snip</em></span>--
    <span class="strong"><strong>private</strong></span>

    <span class="strong"><strong>def text_post_params</strong></span>
➊     <span class="strong"><strong>params.require(:text_post).permit(:title, :body)</strong></span>
    <span class="strong"><strong>end</strong></span>
  end</pre><p>This method ensures ➊ that the <code class="literal">params</code> hash contains the
              <code class="literal">:text_post</code> key and permits key-value pairs for
              <code class="literal">:title</code> and <code class="literal">:body</code> under the
              <code class="literal">:text_post</code> key. With this change, all of your tests should pass
            again. Click the <span class="strong"><strong>New Text Post</strong></span> button on the home
            page, as shown in <a class="xref" href="ch10.html#new_text_post_form" title="Figure 10-2. The New Text Post form">Figure 10-2</a>, to see the form for creating a
              <code class="literal">TextPost</code>.</p><div class="figure"><a id="new_text_post_form"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00021"/><img alt="The New Text Post form" src="httpatomoreillycomsourcenostarchimages2169100.png.jpg"/></div></div><p class="title">Figure 10-2. The New Text Post form</p></div><p>The process for creating a new <code class="literal">ImagePost</code> is similar. Exercise 3
            at the end of this chapter walks through the necessary steps.</p><p>These new features bring our application much closer to being a fully functioning
            social network.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00023"/>Summary</h1></div></div></div><p>We covered a lot of ground in this chapter. You learned about the MiniTest framework.
          You wrote model, controller, and integration tests. We discussed test-driven development
          and then you used it to add features to your social network.</p><p>You can write the tests either before or after the code, and you can use any test
          framework—what matters is that you write tests. The ability to type a single command
          and verify your application is working correctly is worth the small investment of your
          time. Over the life of an application, the benefits of a comprehensive set of tests for
          your application are immeasurable.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id00024"/>Exercises</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch10qa1"/><table border="0" summary="Q and A Set" width="100%"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch10qa1qe1"/><a id="ch10qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. You currently cannot get to the user <code class="literal">show</code> page without
                typing in the URL. Update the <code class="literal">TextPost</code> and
                  <code class="literal">ImagePost</code> partials so the user’s <code class="literal">name</code>
                is a link to the user’s <code class="literal">show</code> page. Also, add a link called
                  <span class="emphasis"><em>Profile</em></span> that links to the current user’s
                  <code class="literal">show</code> page next to the <span class="emphasis"><em>Log Out</em></span> link near
                the top of the application layout.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch10qa1qe2"/><a id="ch10qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. The <code class="literal">follow</code> action should not be available to anonymous
                users. Add a call in <code class="literal">UsersController</code> to <code class="literal">before_action
                  :authenticate_user!</code> with the <code class="literal">only</code> option to require
                authentication before the <code class="literal">follow</code> action. The following test
                should pass after you update <code class="literal">UsersController</code>:</p><a id="pro_id00345"/><pre class="programlisting">test "follow should require login" do
  user = users(:user1)

  get :follow, { id: user.id }

  assert_redirected_to login_url
end</pre><p>Also, the Follow button on the user <code class="literal">show</code> page should not
                appear for anonymous users or if the current user is already following the user
                being displayed. Update the <code class="literal">show</code> view to fix this.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch10qa1qe3"/><a id="ch10qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. Add <code class="literal">new</code> and <code class="literal">create</code> actions for image
                posts and the private <code class="literal">image_post_params</code> method used by the
                  <code class="literal">create</code> action in
                  <span class="emphasis"><em>app/controllers/image_posts_controller.rb</em></span>. Then create a view
                for the new action at <span class="emphasis"><em>app/views/image_posts/new.html.erb</em></span> and a
                partial for the <code class="literal">ImagePost</code> form at
                  <span class="emphasis"><em>app/views/image_posts/_form.html.erb</em></span>.</p></td></tr></tbody></table></div><p>Add the following controller tests to
            <span class="emphasis"><em>test/controllers/image_posts_controller_test.rb</em></span>. Both tests should
          pass after you add the actions to <code class="literal">ImagePostsController</code> and create the
          associated views.</p><a id="pro_id00346"/><pre class="programlisting">test "get new with new post" do
  user1 = users(:user1)

  get :new, {}, { user_id: user1.id }

  image_post = assigns(:image_post)

  assert image_post.new_record?
  assert_response :success
end

test "should create post" do
  user = users(:user1)
  params = {
    image_post: {
      title: "Test Title",
      url: "http://i.imgur.com/Y7syDEa.jpg"
    }
  }

  post :create, params, { user_id: user.id }

  image_post = assigns(:image_post)

  assert image_post.persisted?
  assert_redirected_to post_url(image_post)
end</pre><p>Your implementation of these actions and views should be similar to the TextPost new
          and create actions and views. If you would like to practice TDD, feel free to add these
          tests and confirm they fail before you start implementing the actions.</p></div></div></body></html>