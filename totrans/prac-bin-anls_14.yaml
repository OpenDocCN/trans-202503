- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: PRACTICAL DYNAMIC TAINT ANALYSIS WITH LIBDFT
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 libdft 进行实用的动态污点分析
- en: 'In [Chapter 10](ch10.xhtml#ch10), you learned the principles of dynamic taint
    analysis. In this chapter, you will learn how to build your own DTA tools with
    `libdft`, a popular open source DTA library. I’ll cover two practical examples:
    a tool that prevents remote control-hijacking attacks and a tool that automatically
    detects information leaks. But first, let’s take a look at the internals and API
    of `libdft`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 10 章](ch10.xhtml#ch10)中，你学习了动态污点分析的原理。在本章中，你将学习如何使用流行的开源 DTA 库 `libdft`
    来构建你自己的 DTA 工具。我将介绍两个实际的例子：一个是防止远程控制劫持攻击的工具，另一个是自动检测信息泄露的工具。但首先，让我们来看看 `libdft`
    的内部结构和 API。
- en: 11.1 Introducing libdft
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1 引入 libdft
- en: Because DTA is the subject of ongoing research, existing binary-level taint
    tracking libraries are research tools; don’t expect production quality from them.
    The same is true for `libdft`, developed at Columbia University, which you’ll
    use in the remainder of this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DTA 是一个正在进行的研究课题，现有的二进制级污点追踪库基本上都是研究工具，不要期望它们有生产级的质量。`libdft` 也不例外，它是在哥伦比亚大学开发的，你将在本章的剩余部分使用它。
- en: A byte-granularity taint-tracking system built on Intel Pin, `libdft` is one
    of the easiest to use DTA libraries available at the moment. In fact, it’s the
    tool of choice of many security researchers because you can use it to easily build
    DTA tools that are both accurate and fast. I’ve preinstalled `libdft` on the VM
    in the directory */home/binary/libdft*. You can also download it at *[https://www.cs.columbia.edu/~vpk/research/libdft/](https://www.cs.columbia.edu/~vpk/research/libdft/)*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`libdft` 是一个基于 Intel Pin 的字节粒度污点追踪系统，它是目前最易于使用的 DTA 库之一。事实上，它是许多安全研究人员的首选工具，因为你可以使用它轻松构建既准确又快速的
    DTA 工具。我已经在虚拟机中预安装了 `libdft`，路径是 */home/binary/libdft*。你也可以在 *[https://www.cs.columbia.edu/~vpk/research/libdft/](https://www.cs.columbia.edu/~vpk/research/libdft/)*
    下载它。'
- en: Like all binary-level DTA libraries available at the time of writing, `libdft`
    has several shortcomings. The most obvious one is that `libdft` supports only
    32-bit x86\. You can still use it on a 64-bit platform, but only to analyze 32-bit
    processes. It also relies on legacy versions of Pin (versions between 2.11 and
    2.14 should work). Another limitation is that `libdft` implements support only
    for “regular” x86 instructions, not extended instruction sets like MMX or SSE.
    This means `libdft` may suffer from undertainting if taint flows through such
    instructions. If you’re building the program you’re analyzing from source, use
    `gcc`’s compilation options `-mno-{mmx, sse, sse2, sse3}` to ensure that the binary
    won’t contain MMX or SSE instructions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 和写作时所有的二进制级 DTA 库一样，`libdft` 有一些不足之处。最明显的一点是，`libdft` 仅支持 32 位 x86 架构。你仍然可以在
    64 位平台上使用它，但只能分析 32 位进程。它还依赖于旧版本的 Pin（版本在 2.11 和 2.14 之间应该是可用的）。另一个限制是，`libdft`
    仅支持“常规”的 x86 指令，不支持像 MMX 或 SSE 这样的扩展指令集。这意味着，如果污点数据通过这些指令流动，`libdft` 可能会发生污点缺失。如果你是从源代码构建你分析的程序，请使用
    `gcc` 的编译选项 `-mno-{mmx, sse, sse2, sse3}` 来确保二进制文件中不包含 MMX 或 SSE 指令。
- en: Despite its limitations, `libdft` is still an excellent DTA library you can
    use to build solid tools. Also, because it’s open source, it’s relatively easy
    to extend it with 64-bit support or support for more instructions. To help you
    get the most out of `libdft`, let’s take a look at its most important implementation
    details.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些限制，`libdft` 仍然是一个优秀的 DTA 库，你可以使用它来构建可靠的工具。而且，由于它是开源的，因此扩展它以支持 64 位或更多指令集相对容易。为了帮助你最大限度地利用
    `libdft`，让我们来看看它最重要的实现细节。
- en: '*11.1.1 Internals of libdft*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.1.1 libdft 的内部结构*'
- en: Because `libdft` is based on Intel Pin, `libdft`-based DTA tools are just Pin
    tools like the ones you saw in [Chapter 9](ch09.xhtml#ch09), except they’re linked
    with `libdft`, which provides the DTA functionality. On the VM, I’ve installed
    a dedicated legacy version of Intel Pin (v2.13) you can use with `libdft`. Pin
    is used by `libdft` to instrument instructions with taint propagation logic. Taint
    itself is stored in shadow memory, which is accessible through the `libdft` API.
    [Figure 11-1](ch11.xhtml#ch11fig1) shows an overview of `libdft`’s most important
    components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `libdft` 基于 Intel Pin，基于 `libdft` 的 DTA 工具实际上就是 Pin 工具，就像你在[第 9 章](ch09.xhtml#ch09)中看到的那些工具，只不过它们与
    `libdft` 链接在一起，后者提供了 DTA 功能。在虚拟机上，我已经安装了一个专用的旧版 Intel Pin（v2.13），你可以与 `libdft`
    一起使用。Pin 被 `libdft` 用来对指令进行插桩，加入污点传播逻辑。污点数据本身存储在阴影内存中，可以通过 `libdft` 的 API 进行访问。[图
    11-1](ch11.xhtml#ch11fig1) 展示了 `libdft` 最重要的组件概览。
- en: Shadow Memory
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阴影内存
- en: As you can see in [Figure 11-1](ch11.xhtml#ch11fig1), `libdft` comes in two
    variants, each with a different kind of shadow memory (called the *tagmap* in
    `libdft` parlance). First, there’s a bitmap-based variant ➊, which supports only
    one taint color but is slightly faster and has less memory overhead than the other
    variant. In the `libdft` source archive available from the Columbia University
    website,^([1](footnote.xhtml#ch11fn_1)) this variant is in the directory called
    *libdft_linux-i386*. The second variant implements an eight-color shadow memory
    ➋, and you can find it in the directory *libdft-ng_linux-i386* in the source archive.
    This second variant is the one I’ve preinstalled on the VM and the one I’ll use
    here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图11-1](ch11.xhtml#ch11fig1)所示，`libdft`有两个变种，每个变种使用不同类型的阴影内存（在`libdft`术语中称为*tagmap*）。首先是基于位图的变种➊，它只支持一个污染颜色，但比另一个变种稍快，且内存开销更小。在从哥伦比亚大学网站下载的`libdft`源代码压缩包中，^([1](footnote.xhtml#ch11fn_1))该变种位于名为*libdft_linux-i386*的目录中。第二个变种实现了一个八色阴影内存➋，你可以在源代码压缩包中的*libdft-ng_linux-i386*目录下找到它。这个第二个变种是我在虚拟机上预安装的，也是我在这里将要使用的版本。
- en: To minimize the memory requirements of the eight-color shadow memory, `libdft`
    implements it using an optimized data structure, called the *segment translation
    table (STAB)*. The STAB contains one entry for every memory page. Each entry contains
    an *addend* value, which is just a 32-bit offset that you add to a virtual memory
    address to obtain the address of the corresponding shadow byte.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化八色阴影内存的内存需求，`libdft`通过一种优化的数据结构实现了它，称为*段转换表（STAB）*。STAB包含每个内存页面的一个条目。每个条目包含一个*加数*值，这是一个32位的偏移量，你可以将它加到虚拟内存地址上，以获取对应阴影字节的地址。
- en: '![image](Images/f281-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f281-01.jpg)'
- en: '*Figure 11-1: Internals of* `libdft` *: shadow memory and virtual CPU implementation,
    instrumentation, and API*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-1：`libdft`的内部：阴影内存和虚拟CPU实现，仪器化和API*'
- en: For example, to read the shadow memory for virtual address `0x1000`, you can
    look up the corresponding addend in the STAB, which turns out to be `438`. That
    means you’ll find the shadow byte containing the taint information for address
    `0x1000` at address `0x1438`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要读取虚拟地址`0x1000`的阴影内存，你可以在STAB中查找对应的加数，结果是`438`。这意味着你将在地址`0x1438`找到包含地址`0x1000`的污染信息的阴影字节。
- en: The STAB provides a level of indirection that allows `libdft` to allocate shadow
    memory on demand, whenever the application allocates a region of virtual memory.
    Shadow memory is allocated in page-sized chunks, keeping memory overhead to a
    minimum. Since each allocated memory page corresponds to exactly one shadow page,
    the same addend can be used for all addresses in a page. For virtual memory regions
    with multiple adjacent pages, `libdft` ensures that the shadow memory pages are
    also adjacent, simplifying shadow memory access. Each chunk of adjacent shadow
    map pages is called a *tagmap segment (tseg)*. As an additional memory usage optimization,
    `libdft` maps all read-only memory pages to the same zeroed-out shadow page.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: STAB提供了一种间接访问机制，使得`libdft`能够根据需要在每次应用程序分配虚拟内存区域时分配阴影内存。阴影内存是按页面大小的块分配的，从而保持最小的内存开销。由于每个分配的内存页面对应着一个阴影页面，所有地址的加数可以使用相同的值。对于包含多个相邻页面的虚拟内存区域，`libdft`确保阴影内存页面也相邻，从而简化阴影内存访问。每个相邻的阴影映射页面块被称为*tagmap段（tseg）*。作为额外的内存使用优化，`libdft`将所有只读内存页面映射到同一个已清零的阴影页面。
- en: Virtual CPU
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟CPU
- en: 'To keep track of the taint status of CPU registers, `libdft` keeps a special
    structure in memory called the *virtual CPU*. The virtual CPU is a sort of mini-shadow
    memory with 4 shadow bytes for each of the 32-bit general-purpose CPU registers
    available on x86: `edi`, `esi`, `ebp`, `esp`, `ebx`, `edx`, `ecx`, and `eax`.
    In addition, there’s a special scratch register on the virtual CPU, which `libdft`
    uses to store taint for any unrecognized register. In the preinstalled `libdft`
    version on the VM, I’ve made some modifications to the virtual CPU so that it
    has room for all registers supported by Intel Pin.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪CPU寄存器的污染状态，`libdft`在内存中保持一个特殊结构，称为*虚拟CPU*。虚拟CPU是一种迷你阴影内存，对于x86上的每个32位通用CPU寄存器（如`edi`、`esi`、`ebp`、`esp`、`ebx`、`edx`、`ecx`和`eax`），虚拟CPU为每个寄存器保留4个阴影字节。此外，虚拟CPU上还有一个特殊的临时寄存器，`libdft`使用它来存储任何未识别寄存器的污染信息。在虚拟机上预安装的`libdft`版本中，我对虚拟CPU做了一些修改，使其可以支持Intel
    Pin所支持的所有寄存器。
- en: Taint-Tracking Engine
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 污染追踪引擎
- en: Recall that `libdft` uses Pin’s API to inspect all instructions in a binary
    and then instruments these instructions with the relevant taint propagation functions.
    If you’re interested, you can find the implementations of `libdft`’s taint propagation
    functions in the file */home/binary/libdft/libdft-ng_linux-i386/src/ libdft_core.c*
    on the VM, but I won’t cover them all here. Together, the taint propagation functions
    implement `libdft`’s taint policy, which I’ll describe in [Section 11.1.2](ch11.xhtml#ch11_1_2).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，`libdft` 使用 Pin 的 API 来检查二进制中的所有指令，并将这些指令与相关的污点传播函数进行插桩。如果你感兴趣的话，可以在虚拟机中的文件
    */home/binary/libdft/libdft-ng_linux-i386/src/libdft_core.c* 找到 `libdft` 的污点传播函数实现，但我在这里不打算详细讲解它们。所有的污点传播函数共同实现了
    `libdft` 的污点策略，我将在[第 11.1.2 节](ch11.xhtml#ch11_1_2)中描述该策略。
- en: The libdft API and I/O Interface
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`libdft` API 和 I/O 接口'
- en: Ultimately, the goal of `libdft` is to function as a library for building your
    own DTA tools. For this purpose, `libdft` provides a taint-tracking API, which
    provides several classes of functions. The two most important classes of functions
    for building DTA tools are those that manipulate the tagmap and those that add
    callbacks and instrumentation code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`libdft` 的目标是作为构建你自己 DTA 工具的库。为此，`libdft` 提供了一个污点跟踪 API，其中包含了几类函数。对于构建 DTA
    工具来说，最重要的两类函数是操作标签映射的函数和添加回调及插桩代码的函数。
- en: The tagmap API is defined in the header file *tagmap.h*. It provides functions
    such as `tagmap_setb` to mark a memory byte as tainted and `tagmap_getb` to retrieve
    the taint information for a memory byte.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 标签映射 API 定义在头文件 *tagmap.h* 中。它提供了诸如 `tagmap_setb`（用于将内存字节标记为污点）和 `tagmap_getb`（用于检索内存字节的污点信息）等函数。
- en: The API for adding callbacks and instrumentation code is split over the header
    files *libdft_api.h* and *syscall_desc.h*. It allows you to register callbacks
    for syscall events using the functions `syscall_set_pre` and `syscall_set_post`.
    To store all these callbacks, `libdft` uses a dedicated array called `syscall_desc`,
    which keeps track of all the syscall pre- and post-handlers you install. Similarly,
    you can register instruction callbacks with `ins_set_pre` and `ins_set_post`.
    You’ll learn about these and other `libdft` API functions in more detail from
    the DTA tools later in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 添加回调和插桩代码的 API 分布在头文件 *libdft_api.h* 和 *syscall_desc.h* 中。它允许你使用 `syscall_set_pre`
    和 `syscall_set_post` 函数注册系统调用事件的回调。为了存储所有这些回调，`libdft` 使用一个专门的数组，名为 `syscall_desc`，用于跟踪你安装的所有系统调用前后处理程序。同样，你可以使用
    `ins_set_pre` 和 `ins_set_post` 注册指令回调。你将在本章后面的 DTA 工具部分更详细地了解这些以及其他 `libdft` API
    函数。
- en: '*11.1.2 Taint Policy*'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.1.2 污点策略*'
- en: The `libdft` taint propagation policy defines the following five classes of
    instructions.^([2](footnote.xhtml#ch11fn_2)) Each of these classes propagates
    and merges taint in a different way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`libdft` 的污点传播策略定义了以下五类指令。^([2](footnote.xhtml#ch11fn_2)) 每一类指令以不同的方式传播和合并污点。'
- en: '**ALU** These are arithmetic and logic instructions with two or three operands,
    such as `add`, `sub`, `and`, `xor`, `div`, and `imul`. For these operations, `libdft`
    merges taint in the same way as the `add` and `xor` examples in [Table 10-1](ch10.xhtml#ch10tab1)
    on page 273—the output taint is the union (∪) of the input operands’ taint. Also
    as in [Table 10-1](ch10.xhtml#ch10tab1), `libdft` considers immediate values untainted
    since there’s no way an attacker can influence them.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**ALU** 这些是具有两个或三个操作数的算术和逻辑指令，例如 `add`、`sub`、`and`、`xor`、`div` 和 `imul`。对于这些操作，`libdft`
    以与 [表 10-1](ch10.xhtml#ch10tab1) 中的 `add` 和 `xor` 示例相同的方式合并污点——输出的污点是输入操作数污点的并集（∪）。正如
    [表 10-1](ch10.xhtml#ch10tab1) 中所示，`libdft` 认为立即数是未污染的，因为攻击者无法影响它们。'
- en: '**XFER** The XFER class contains all the instructions that copy a value to
    another register or memory location, such as the `mov` instruction. Again, it’s
    handled like the `mov` example in [Table 10-1](ch10.xhtml#ch10tab1), using the
    assignment operation (:=). For these instructions, `libdft` simply copies the
    taint from the source operand to the destination.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**XFER** XFER 类包含所有将值复制到另一个寄存器或内存位置的指令，例如 `mov` 指令。与 [表 10-1](ch10.xhtml#ch10tab1)
    中的 `mov` 示例一样，这些指令的处理方式是使用赋值操作 (:=)。对于这些指令，`libdft` 仅仅是将源操作数的污点复制到目标位置。'
- en: '**CLR** As the name implies, instructions in this class always cause their
    output operands to become untainted. In other words, `libdft` sets the output
    taint to the empty set (ø). This class includes some special cases of instructions
    from other classes, such as `xor`-ing an operand with itself or subtracting an
    operand from itself. It also includes instructions such as `cpuid`, where an attacker
    has no control over the outputs.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**CLR** 正如其名，这一类指令总是使它们的输出操作数变得不受污染。换句话说，`libdft` 将输出的污染标记设置为空集（ø）。这一类包括其他类指令的一些特殊情况，例如用自身做异或运算或从自身中减去一个操作数。它还包括像
    `cpuid` 这样的指令，攻击者无法控制输出。'
- en: '**SPECIAL** These are instructions that require special rules for taint propagation
    not covered by other classes. Among others, this class includes `xchg` and `cmpxchg`
    (where the taint of two operands is swapped) and `lea` (where the taint results
    from a memory address computation).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPECIAL** 这些是需要特殊规则来传播污染的指令，这些规则在其他类别中未涉及。包括但不限于 `xchg` 和 `cmpxchg`（其中两个操作数的污染会交换）以及
    `lea`（其中污染源自内存地址的计算）。'
- en: '**FPU, MMX, SSE** This class includes instructions that `libdft` doesn’t currently
    support, such as FPU, MMX, and SSE instructions. When taint flows through such
    instructions, `libdft` cannot track it, so the taint information doesn’t propagate
    to the output operands of the instructions, resulting in undertainting.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**FPU, MMX, SSE** 这一类包含了 `libdft` 当前不支持的指令，如 FPU、MMX 和 SSE 指令。当污染通过这些指令时，`libdft`
    无法追踪，因此污染信息不会传播到指令的输出操作数，导致污染不足。'
- en: Now that you’re acquainted with `libdft`, let’s build some DTA tools with `libdft`!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 `libdft`，让我们用 `libdft` 构建一些 DTA 工具吧！
- en: 11.2 Using DTA to Detect Remote Control-Hijacking
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2 使用 DTA 检测远程控制劫持
- en: The first DTA tool you’ll see is designed to detect some types of remote control-hijacking
    attacks. Specifically, it detects attacks where data received from the network
    is used to control the arguments of an `execve` call. Thus, the taint sources
    will be the network receive functions `recv` and `recvfrom`, while the `execve`
    syscall will be the taint sink. As usual, you can find the complete source code
    on the VM, in *~/code/chapter11*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的第一个 DTA 工具旨在检测一些类型的远程控制劫持攻击。具体来说，它检测的是网络接收的数据被用来控制 `execve` 调用的参数的攻击。因此，污染源将是网络接收函数
    `recv` 和 `recvfrom`，而 `execve` 系统调用将是污染汇。像往常一样，你可以在虚拟机上找到完整的源代码，位于 *~/code/chapter11*
    中。
- en: I tried to make this example tool as simple as possible to keep the discussion
    easy to understand. That means it necessarily makes simplifying assumptions and
    will not catch all types of control-hijacking attacks. In a real, fully fledged
    DTA tool, you’ll want to define additional taint sources and sinks to prevent
    more types of attacks. For instance, in addition to data received with `recv`
    and `recvfrom`, you’ll want to consider data read from the network using the `read`
    syscall. Moreover, to prevent tainting innocent file reads, you’ll need to keep
    track of which file descriptors are reading from the network by hooking network
    calls like `accept`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量将这个示例工具做得尽可能简单，以便让讨论更容易理解。这意味着它必须做一些简化假设，并且不能捕捉所有类型的控制劫持攻击。在一个真正的、功能齐全的 DTA
    工具中，你需要定义额外的污染源和污染汇，以防更多类型的攻击。例如，除了通过 `recv` 和 `recvfrom` 接收的数据，你还需要考虑通过 `read`
    系统调用从网络读取的数据。此外，为了防止无辜的文件读取被污染，你需要跟踪哪些文件描述符正在通过 `accept` 等网络调用从网络读取数据。
- en: When you understand how the following example tool works, you should be able
    to refine it on your own. Additionally, `libdft` comes with a more elaborate example
    DTA tool that implements many of these refinements for reference. You can find
    it in the file *tools/libdft-dta.c* in the *libdft* directory if you’re interested.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你理解下面这个示例工具的工作原理时，你应该能够自行改进它。此外，`libdft` 附带了一个更为复杂的示例 DTA 工具，参考了许多这些改进。如果你感兴趣，可以在
    *libdft* 目录下的文件 *tools/libdft-dta.c* 中找到它。
- en: Many `libdft`-based DTA tools hook syscalls to use as taint sources and sinks.
    On Linux, every syscall has its own *syscall number*, which `libdft` uses to index
    the `syscall_desc` array. For a list of available syscalls and their associated
    syscall numbers, refer to */usr/include/x86_64-linux-gnu/asm/unistd_32.h* for
    x86 (32 bit) or to */usr/include/asm-generic/unistd.h* for x64.^([3](footnote.xhtml#ch11fn_3))
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多基于`libdft`的DTA工具都会挂钩系统调用，作为污点源和污点汇。在Linux中，每个系统调用都有自己独特的*系统调用编号*，`libdft`使用它来索引`syscall_desc`数组。有关可用系统调用及其相关系统调用编号的列表，请参考x86（32位）的*/usr/include/x86_64-linux-gnu/asm/unistd_32.h*或x64的*/usr/include/asm-generic/unistd.h*。^([3](footnote.xhtml#ch11fn_3))
- en: Now, let’s take a look at the example tool called `dta-execve`. [Listing 11-1](ch11.xhtml#ch11list1)
    shows the first part of the source code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下名为`dta-execve`的示例工具。[列表 11-1](ch11.xhtml#ch11list1)展示了源代码的第一部分。
- en: '*Listing 11-1:* dta-execve.cpp'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-1:* dta-execve.cpp'
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, I show only the header files that are specific to `libdft`-based DTA tools,
    but you can see the omitted code in the source on the VM if you’re interested.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我只展示了与`libdft`相关的DTA工具特定的头文件，但如果你感兴趣，可以在虚拟机上的源代码中查看省略的代码。
- en: The first header file is *pin.H* ➊ because all `libdft` tools are just Pin tools
    linked with the `libdft` library. Next, there are several header files that together
    provide access to the `libdft` API ➋. The first of these, *branch_pred.h*, contains
    the macros `likely` and `unlikely`, which you can use to provide the compiler
    with hints for branch prediction, as I’ll explain in a moment. Next, *libdft_api.h*,
    *syscall_desc.h*, and *tagmap.h* provide access to the `libdft` base API, syscall
    hooking interface, and tagmap (shadow memory), respectively.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个头文件是*pin.H* ➊，因为所有`libdft`工具实际上都是链接了`libdft`库的Pin工具。接下来是几个头文件，它们一起提供对`libdft`
    API的访问 ➋。第一个是*branch_pred.h*，包含宏`likely`和`unlikely`，你可以使用它们为编译器提供分支预测的提示，稍后我将解释。接下来，*libdft_api.h*、*syscall_desc.h*和*tagmap.h*分别提供对`libdft`基础API、系统调用钩子接口和tagmap（影像内存）的访问。
- en: After the includes, there’s an `extern` declaration of the `syscall_desc` array
    ➌, which is the data structure `libdft` uses to keep track of syscall hooks. You’ll
    need access to it to hook your taint sources and sinks. The actual definition
    of `syscall_desc` is in `libdft`’s source file *syscall_desc.c*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含文件之后，是`syscall_desc`数组的`extern`声明 ➌，这是`libdft`用来跟踪系统调用钩子的结构体。你将需要访问它来挂钩你的污点源和污点汇。`syscall_desc`的实际定义在`libdft`的源文件*syscall_desc.c*中。
- en: Now let’s take a look at the `main` function of the `dta-execve` tool. It starts
    by initializing Pin’s symbol processing ➍ in case symbols are present in the binary,
    followed by Pin itself ➎. You saw Pin initialization code in [Chapter 9](ch09.xhtml#ch09),
    but this time the return value of `PIN_Init` is checked using an optimized branch,
    marked with the `unlikely` macro to tell the compiler it’s unlikely that `PIN_Init`
    will fail. This knowledge can help the compiler with branch prediction, which
    may allow it to output slightly faster code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`dta-execve`工具的`main`函数。它首先初始化Pin的符号处理 ➍，以防二进制文件中存在符号，然后初始化Pin本身 ➎。你在[第9章](ch09.xhtml#ch09)中已经看到了Pin初始化的代码，但这次使用了优化的分支来检查`PIN_Init`的返回值，使用`unlikely`宏标记它，告诉编译器`PIN_Init`失败的可能性较小。这一知识可以帮助编译器进行分支预测，从而可能生成稍微更快的代码。
- en: Next, the `main` function initializes `libdft` itself using the `libdft_init`
    function ➏, again with an optimized check of the return value. This initialization
    allows `libdft` to set up crucial data structures, such as the tagmap. If this
    setup fails, `libdft_init` returns a nonzero value, in which case you call `libdft_die`
    to deallocate any resources `libdft` may have allocated ➐.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`main`函数使用`libdft_init`函数 ➏ 初始化`libdft`，并再次优化检查返回值。此初始化允许`libdft`设置重要的数据结构，例如tagmap。如果初始化失败，`libdft_init`将返回非零值，在这种情况下，你需要调用`libdft_die`来释放`libdft`可能分配的任何资源
    ➐。
- en: 'Once Pin and `libdft` are both initialized, you can install your syscall hooks,
    which serve as taint sources and taint sinks. Keep in mind that the appropriate
    hook will be called whenever the instrumented application (the program you’re
    protecting with your DTA tool) executes the corresponding syscall. Here, `dta-execve`
    installs two hooks: a post-handler called `post_socketcall_hook` that runs right
    after every `socketcall` syscall ➑ and a pre-handler that runs before `execve`
    syscalls, called `pre_execve_hook` ➒. The `socketcall` syscall captures all socket-related
    events on x86-32 Linux, including `recv` and `recvfrom` events. The `socketcall`
    handler (`post_socketcall_hook`) differentiates between the different types of
    socket events, as I’ll explain in a moment.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Pin和`libdft`都初始化完成，你可以安装系统调用钩子，这些钩子作为污点源和污点接收点。请记住，当被仪器化的应用程序（即你使用DTA工具保护的程序）执行相应的系统调用时，适当的钩子将会被调用。在这里，`dta-execve`安装了两个钩子：一个后处理钩子，名为`post_socketcall_hook`，它在每次执行`socketcall`系统调用后立即运行➑；另一个是前处理钩子，它在执行`execve`系统调用之前运行，名为`pre_execve_hook`➒。`socketcall`系统调用捕获所有与套接字相关的事件（例如`recv`和`recvfrom`事件）在x86-32架构的Linux上。`socketcall`处理程序（`post_socketcall_hook`）区分了不同类型的套接字事件，接下来我会解释。
- en: To install a syscall handler, you call `syscall_set_post` (for post-handlers)
    or `syscall_set_pre` (for pre-handlers). Both of these functions take a pointer
    to the entry in `libdft`’s `syscall_desc` array in which to install the handler,
    and a function pointer to the handler to install. To get the appropriate `syscall_desc`
    entry, you index `syscall_desc` with the syscall number of the syscall you’re
    hooking. In this case, the relevant syscall numbers are represented by the symbolic
    names `__NR_socketcall` and `__NR_execve`, which you can find in */usr/include/i386-linux-gnu/asm/unistd_32.h*
    for x86-32.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装系统调用处理程序，你需要调用`syscall_set_post`（用于后处理钩子）或`syscall_set_pre`（用于前处理钩子）。这两个函数都接受一个指向`libdft`的`syscall_desc`数组条目的指针，用于安装处理程序，以及一个指向要安装的处理程序的函数指针。为了获得适当的`syscall_desc`条目，你需要用你正在钩住的系统调用的系统调用号来索引`syscall_desc`数组。在这个例子中，相关的系统调用号由符号名称`__NR_socketcall`和`__NR_execve`表示，你可以在`/usr/include/i386-linux-gnu/asm/unistd_32.h`中找到这些符号名称（适用于x86-32）。
- en: Finally, you call `PIN_StartProgram` to begin running the instrumented application
    ➓. Recall from [Chapter 9](ch09.xhtml#ch09) that `PIN_StartProgram` never returns,
    so the `return 0` at the end of `main` is never reached.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要调用`PIN_StartProgram`来开始运行仪器化的应用程序➓。回想一下在[第9章](ch09.xhtml#ch09)中提到的，`PIN_StartProgram`永远不会返回，所以`main`函数末尾的`return
    0`永远不会被执行。
- en: 'Although I don’t use it in this example, `libdft` does provide the ability
    to hook instructions in nearly the same way as syscalls, as shown in the following
    listing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个示例中没有使用，`libdft`确实提供了几乎与系统调用相同的方式来钩住指令，如以下代码所示：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To hook instructions, you globally declare the `extern ins_desc` array ➊ (analogous
    to `syscall_desc`) in your DTA tool and then use `ins_set_pre` or `ins_set_post`
    ➋ to install instruction pre- or post-handlers, respectively. Instead of syscall
    numbers, you index the `ins_desc` array using symbolic names provided by Intel’s
    x86 encoder/decoder library (XED), which comes with Pin. XED defines these names
    in an `enum` called `xed_iclass_enum_t`, and each name denotes an instruction
    class such as `X86_ICLASS_RET_NEAR`. The names of the classes correspond to instruction
    mnemonics. You can find a list of all the instruction class names online at *[https://intelxed.github.io/ref-manual/](https://intelxed.github.io/ref-manual/)*
    or in the header file *xed-iclass-enum.h* that ships with Pin.^([4](footnote.xhtml#ch11fn_4))
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了钩住指令，你需要在DTA工具中全局声明`extern ins_desc`数组➊（类似于`syscall_desc`），然后使用`ins_set_pre`或`ins_set_post`➋来分别安装指令的前处理或后处理钩子。与系统调用号不同，你使用由Intel的x86编码/解码库（XED）提供的符号名称来索引`ins_desc`数组，XED库随Pin一起提供。XED在一个名为`xed_iclass_enum_t`的枚举中定义了这些名称，每个名称表示一种指令类别，如`X86_ICLASS_RET_NEAR`。这些类别的名称对应于指令助记符。你可以在线查看所有指令类别名称的列表，网址是*[https://intelxed.github.io/ref-manual/](https://intelxed.github.io/ref-manual/)*，或者在随Pin一起提供的头文件*xed-iclass-enum.h*中找到。
- en: '*11.2.1 Checking Taint Information*'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.2.1 检查污点信息*'
- en: In the previous section, you saw how the `dta-execve` tool’s `main` function
    performs all the necessary initialization, sets up the appropriate syscall hooks
    to serve as taint sources and sinks, and then starts the application. In this
    case, the taint sink is a syscall hook called `pre_execve_hook`, which checks
    whether any of the `execve` arguments are tainted, indicating a control hijacking
    attack. If so, it raises an alert and stops the attack by aborting the application.
    Because the taint checking is done repeatedly for every `execve` argument, I’ve
    implemented it in a separate function called `check_string_taint`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你已经看到`dta-execve`工具的`main`函数执行了所有必要的初始化，设置了适当的系统调用钩子，作为污点源和污点接收点，然后启动了应用程序。在这种情况下，污点接收点是一个叫做`pre_execve_hook`的系统调用钩子，它检查是否有任何`execve`参数被污染，表明可能发生了控制劫持攻击。如果是，它会触发警告并通过终止应用程序来阻止攻击。由于污点检查会对每个`execve`参数重复进行，因此我将其实现为一个名为`check_string_taint`的单独函数。
- en: I’ll discuss `check_string_taint` first, and then I’ll move on to the code for
    `pre_execve_hook` in [Section 11.2.3](ch11.xhtml#ch11_2_3). [Listing 11-2](ch11.xhtml#ch11list2)
    shows the `check_string_taint` function, as well as the `alert` function that
    is called if an attack is detected.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先讨论`check_string_taint`，然后转到[第11.2.3节](ch11.xhtml#ch11_2_3)中的`pre_execve_hook`代码。[列表11-2](ch11.xhtml#ch11list2)展示了`check_string_taint`函数，以及在检测到攻击时调用的`alert`函数。
- en: '*Listing 11-2:* dta-execve.cpp *(continued)*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-2：* dta-execve.cpp *(续)*'
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `alert` function ➊ simply prints an alert message with details about the
    tainted address and then calls `exit` to stop the application and prevent the
    attack. The actual taint-checking logic is implemented in `check_string_taint`
    ➋, which takes two strings as input. The first string (`str`) is the one to check
    for taint, while the second (`source`) is a diagnostic string that’s passed to
    and printed by `alert`, specifying the source of the first string, which is the
    `execve` path, an `execve` parameter, or an environment parameter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert`函数 ➊ 简单地打印包含污点地址详细信息的警告消息，然后调用`exit`停止应用程序并防止攻击。实际的污点检查逻辑在`check_string_taint`
    ➋中实现，该函数接受两个字符串作为输入。第一个字符串（`str`）是要检查污点的字符串，而第二个字符串（`source`）是诊断字符串，它传递给并由`alert`打印，指定第一个字符串的来源，可以是`execve`路径、`execve`参数或环境参数。'
- en: To check the taint of `str`, `check_string_taint` loops over all of `str`’s
    bytes ➌. For each byte, it checks the taint status using `libdft`’s `tagmap_getb`
    function ➍. If the byte is tainted, `alert` is called to print an error and exit
    ➎.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`str`的污点，`check_string_taint`会遍历`str`的所有字节 ➌。对于每个字节，它通过`libdft`的`tagmap_getb`函数检查污点状态
    ➍。如果该字节有污点，则调用`alert`打印错误信息并退出 ➎。
- en: The `tagmap_getb` function takes the memory address of a byte (in the form of
    a `uintptr_t`) as input and returns the shadow byte containing the taint color
    for that address. The taint color (called `tag` in [Listing 11-2](ch11.xhtml#ch11list2))
    is a `uint8_t` since `libdft` keeps one shadow byte per memory byte. If `tag`
    is zero, then the memory byte is untainted. If it’s not zero, the byte is tainted,
    and the `tag` color can be used to find out what the taint source was. Because
    this DTA tool has only one taint source (network receives), it uses only a single
    taint color.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`tagmap_getb`函数接受一个字节的内存地址（以`uintptr_t`形式）作为输入，并返回包含该地址污点颜色的阴影字节。污点颜色（在[列表11-2](ch11.xhtml#ch11list2)中称为`tag`）是一个`uint8_t`类型，因为`libdft`为每个内存字节保留一个阴影字节。如果`tag`为零，则该内存字节无污点。如果不为零，则该字节有污点，`tag`颜色可用于查找污点来源。由于该DTA工具只有一个污点源（网络接收），它仅使用单一的污点颜色。'
- en: Sometimes you may want to fetch the taint tag of multiple memory bytes at once.
    For this purpose, `libdft` provides the `tagmap_getw` and `tagmap_getl` functions,
    which are analogous to `tagmap_getb` but return two or four consecutive shadow
    bytes at once, in the form of a `uint16_t` or a `uint32_t`, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望一次获取多个内存字节的污点标签。为此，`libdft`提供了`tagmap_getw`和`tagmap_getl`函数，它们类似于`tagmap_getb`，但一次返回两个或四个连续的阴影字节，分别以`uint16_t`或`uint32_t`的形式返回。
- en: '*11.2.2 Taint Sources: Tainting Received Bytes*'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.2.2 污点源：接收字节的污点*'
- en: Now that you know how to check the taint color for a given memory address, let’s
    discuss how to taint bytes in the first place. [Listing 11-3](ch11.xhtml#ch11list3)
    shows the code of `post_socketcall_hook`, which is the taint source called right
    after each `socketcall` syscall and that taints bytes received from the network.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你知道了如何检查给定内存地址的污点颜色，让我们来讨论如何在第一时间标记字节。[清单 11-3](ch11.xhtml#ch11list3)展示了`post_socketcall_hook`的代码，它是每次`socketcall`系统调用后被调用的污点源，标记从网络接收到的字节。  '
- en: '*Listing 11-3:* dta-execve.cpp *(continued)*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-3:* dta-execve.cpp *(续)*  '
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In `libdft`, syscall hooks like `post_socketcall_hook` are `void` functions
    that take a `syscall_ctx_t*` as their only input argument. In [Listing 11-3](ch11.xhtml#ch11list3),
    I’ve called that input argument `ctx`, and it acts as a descriptor of the syscall
    that just took place. Among other things, it contains the arguments that were
    passed to the syscall and the return value of the syscall. The hook inspects `ctx`
    to determine which bytes (if any) to taint.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '在`libdft`中，像`post_socketcall_hook`这样的系统调用钩子是`void`函数，唯一的输入参数是`syscall_ctx_t*`类型的指针。在[清单
    11-3](ch11.xhtml#ch11list3)中，我将该输入参数命名为`ctx`，它作为刚刚发生的系统调用的描述符。除了其他内容外，它包含了传递给系统调用的参数以及系统调用的返回值。钩子会检查`ctx`，以确定需要标记哪些字节（如果有的话）。  '
- en: The `socketcall` syscall takes two arguments, which you can verify by reading
    `man socketcall`. The first is an `int` called `call`, and it tells you what kind
    of `socketcall` this is, for example, whether it’s a `recv` or `recvfrom`. The
    second, called `args`, contains a block of arguments for the `socketcall` in the
    form of an `unsigned long*`. The `post_socketcall_hook` begins by parsing `call`
    ➊ and `args` ➋ from the syscall `ctx`. To get an argument from the syscall `ctx`,
    you read the appropriate entry from its `arg` field (for example, `ctx->arg[SYSCALL_ARG0]`)
    and cast it to the correct type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`socketcall`系统调用接受两个参数，你可以通过阅读`man socketcall`来验证这一点。第一个是一个名为`call`的`int`类型，它告诉你这是什么类型的`socketcall`，例如，是否是`recv`或`recvfrom`。第二个参数，名为`args`，包含一个`unsigned
    long*`类型的参数块，用于`socketcall`。`post_socketcall_hook`首先解析`call` ➊和`args` ➋这两个参数，来自系统调用的`ctx`。要从系统调用`ctx`中获取参数，你需要读取其`arg`字段中的相应条目（例如，`ctx->arg[SYSCALL_ARG0]`）并将其转换为正确的类型。  '
- en: Next, `dta-execve` uses a `switch` to differentiate between the different possible
    `call` types. If `call` indicates that this is a `SYS_RECV` or `SYS_RECVFROM`
    event ➌, then `dta-execve` inspects it more closely to find out which bytes were
    received and need to be tainted. It simply ignores any other event in the `default`
    case.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，`dta-execve`使用`switch`语句来区分不同的`call`类型。如果`call`表示这是一个`SYS_RECV`或`SYS_RECVFROM`事件
    ➌，那么`dta-execve`会更仔细地检查它，以找出哪些字节已被接收并需要标记。它会在`default`情况下忽略任何其他事件。  '
- en: If the current event is a receive, then the next thing `dta-execve` does is
    check the return value of the `socketcall` by inspecting `ctx->ret` ➍. If it’s
    less than or equal to zero, then no bytes were received, so nothing is tainted
    and the syscall hook simply returns. Inspecting the return value is possible only
    in a post-handler, since in a pre-handler the syscall you’re hooking hasn’t happened
    yet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前事件是接收操作，那么`dta-execve`接下来的操作是通过检查`ctx->ret` ➍来验证`socketcall`的返回值。如果返回值小于或等于零，表示没有接收到字节，因此不会进行标记，系统调用钩子将直接返回。只有在后处理程序中才能检查返回值，因为在前处理程序中，你所挂钩的系统调用尚未发生。
- en: If bytes were received, then you need to parse the `args` array to access the
    `recv` or `recvfrom` argument and find the address of the receive buffer. The
    `args` array contains the arguments in the same order as the socket function corresponding
    to the `call` type. For `recv` and `recvfrom`, that means `args[0]` contains the
    socket file descriptor number ➎, and `args[1]` contains the receive buffer address
    ➏. The rest of the arguments aren’t needed here, so `post_socketcall_hook` doesn’t
    parse them. Given the receive buffer address and the `socketcall` return value
    (which indicates the number of received bytes ➐), `post_socketcall_hook` can now
    taint all the received bytes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '如果接收到字节，那么你需要解析`args`数组以访问`recv`或`recvfrom`参数，并找到接收缓冲区的地址。`args`数组按照与对应的`call`类型的套接字函数相同的顺序排列。对于`recv`和`recvfrom`来说，这意味着`args[0]`包含套接字文件描述符号
    ➎，而`args[1]`包含接收缓冲区的地址 ➏。其他参数在这里不需要，因此`post_socketcall_hook`不解析它们。根据接收缓冲区的地址和`socketcall`的返回值（它表示接收到的字节数
    ➐），`post_socketcall_hook`现在可以标记所有接收的字节。  '
- en: After some diagnostic prints of the received bytes, `post_socketcall_hook` finally
    taints the received bytes by calling `tagmap_setn` ➑, a `libdft` function that
    can taint an arbitrary number of bytes at once. It takes a `uintptr_t` representing
    a memory address as its first parameter, which is the first address that will
    be tainted. The next parameter is a `size_t` that specifies the number of bytes
    to taint and then a `uint8_t` containing the taint color. In this case, I’ve set
    the taint color to `0x01`. Now, all the received bytes are tainted, so if they
    ever influence any of `execve`’s inputs, `dta-execve` will notice and raise an
    alert.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: To taint only a small fixed number of bytes, `libdft` also provides functions
    called `tagmap_setb`, `tagmap_setw`, and `tagmap_setl`, which taint one, two,
    or four consecutive bytes, respectively. These have arguments equivalent to `tagmap_setn`,
    except that they omit the length parameter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '*11.2.3 Taint Sinks: Checking execve Arguments*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, let’s take a look at `pre_execve_hook`, the syscall hook that runs
    just before every `execve` and makes sure the `execve` inputs aren’t tainted.
    [Listing 11-4](ch11.xhtml#ch11list4) shows the code of `pre_execve_hook`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-4:* dta-execve.cpp *(continued)*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first thing `pre_execve_hook` does is parse the inputs of the `execve` from
    its `ctx` parameter. These inputs are the filename of the program the `execve`
    is about to run ➊ and then the argument array ➋ and environment array ➌ passed
    to `execve`. If any of these inputs are tainted, `pre_execve_hook` will raise
    an alert.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: To check each input for taint, `pre_execve_hook` uses the `check_string_taint`
    function I previously described in [Listing 11-2](ch11.xhtml#ch11list2). First,
    it uses this function to verify that the `execve` filename parameter is untainted
    ➍. Subsequently, it loops over all the `execve` arguments ➎ and checks each of
    these for taint ➏. Finally, `pre_execve_hook` loops over the environment array
    ➐ and checks that each environment parameter is untainted ➑. If none of the inputs
    is tainted, `pre_execve_hook` runs to completion, and the `execve` syscall proceeds
    without any alert. On the other hand, if any tainted input is found, then the
    program is aborted, and an error message is printed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: That’s all of the code in the `dta-execve` tool! As you can see, `libdft` allows
    you to implement DTA tools in a concise way. In this case, the example tool consists
    of only 165 lines of code, including all comments and diagnostic prints. Now that
    you’ve explored all of `dta-execve`’s code, let’s test how well it can detect
    attacks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '*11.2.4 Detecting a Control-Flow Hijacking Attempt*'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To test `dta-execve`’s ability to detect network-borne control-hijacking attacks,
    I’ll use a test program called `execve-test-overflow`. [Listing 11-5](ch11.xhtml#ch11list5)
    shows the first part of its source, containing the `main` function. To save space,
    I omit error-checking code and unimportant functions in the listings of the test
    programs. As usual, you can find the full programs on the VM.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`dta-execve`检测网络控制劫持攻击的能力，我将使用一个名为`execve-test-overflow`的测试程序。[清单 11-5](ch11.xhtml#ch11list5)展示了其源代码的第一部分，其中包含了`main`函数。为了节省空间，我在测试程序的清单中省略了错误检查代码和不重要的函数。和往常一样，完整的程序可以在虚拟机中找到。
- en: '*Listing 11-5:* execve-test-overflow.c'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5:* execve-test-overflow.c'
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `execve-test-overflow` is a simple server program that opens
    a network socket (using the `open_socket` function omitted from the listing) and
    listens on `localhost` at port 9999 ➊. Next, it receives a message from the socket
    ➋ and passes that message to a function called `exec_cmd` ➌. As I’ll explain in
    the next listing, `exec_cmd` is a vulnerable function that executes a command
    using `execv` and can be influenced by an attacker who sends a malicious message
    to the server. When `exec_cmd` completes, it returns a file descriptor that the
    server uses to read the output of the executed command ➍. Finally, the server
    writes the command output to the network socket ➎.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`execve-test-overflow`是一个简单的服务器程序，它打开一个网络套接字（使用清单中省略的`open_socket`函数），并在`localhost`上的9999端口监听➊。接下来，它从套接字接收一条消息➋，并将该消息传递给一个名为`exec_cmd`的函数➌。正如我在下一个清单中将解释的那样，`exec_cmd`是一个脆弱的函数，它使用`execv`执行命令，并且可以受到攻击者通过向服务器发送恶意消息的影响。当`exec_cmd`完成时，它返回一个文件描述符，服务器使用该描述符读取已执行命令的输出➍。最后，服务器将命令输出写入网络套接字➎。
- en: Normally, the `exec_cmd` function executes a program called `date` to get the
    current time and date, and the server then echoes this output over the network,
    prefixing it with the message previously received from the socket. However, `exec_cmd`
    contains a vulnerability that allows attackers to run a command of their choosing,
    as shown in [Listing 11-6](ch11.xhtml#ch11list6).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`exec_cmd`函数会执行一个名为`date`的程序来获取当前的时间和日期，然后服务器会将该输出通过网络回显，并在前面加上之前从套接字接收到的消息。然而，`exec_cmd`存在一个漏洞，允许攻击者执行他们选择的命令，正如[清单
    11-6](ch11.xhtml#ch11list6)所示。
- en: '*Listing 11-6:* execve-test-overflow.c *(continued)*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-6:* execve-test-overflow.c *(续)*'
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The server uses a global `struct` called `cmd` to keep track of the command
    and its associated parameters ➊. It contains a `prefix` for the command output
    (the message previously received from the socket) ➋, as well as a date format
    string and a buffer containing the `date` command itself. While Linux comes with
    a default `date` utility, I’ve implemented my own for this test, which you’ll
    find in *~/code/chapter11/date*. This is necessary because the default `date`
    utility on the VM is 64-bit, which `libdft` does not support.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用一个全局`struct`，名为`cmd`，来跟踪命令及其相关参数➊。它包含一个用于命令输出的`prefix`（之前从套接字接收到的消息）➋，以及一个日期格式字符串和一个包含`date`命令本身的缓冲区。虽然Linux自带默认的`date`工具，但为了测试，我实现了我自己的`date`工具，你可以在*~/code/chapter11/date*中找到它。这是必要的，因为虚拟机上的默认`date`工具是64位的，而`libdft`不支持它。
- en: Now let’s take a look at the `exec_cmd` function, which begins by copying the
    message received from the network (stored in `buf`) into `cmd`’s `prefix` field
    ➌. As you can see, the copy lacks proper bound checks, which means attackers could
    send a malicious message that would overflow `prefix`, allowing them to overwrite
    the adjacent fields in `cmd`, containing the date format and the command path.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看`exec_cmd`函数，该函数首先将从网络接收到的消息（存储在`buf`中）复制到`cmd`的`prefix`字段中➌。正如你所看到的，这个复制操作缺乏适当的边界检查，这意味着攻击者可以发送恶意消息，导致`prefix`溢出，从而覆盖`cmd`中相邻的字段，这些字段包含日期格式和命令路径。
- en: Next, `exec_cmd` copies the command and date format argument from the `cmd`
    structure into an `argv` array to use for the `execv` ➍. Then, it opens a pipe
    ➎ and uses `fork` ➏ to start a child process ➐, which will execute the command
    and report the output to the parent process. The child process redirects `stdout`
    over the pipe ➑ so that the parent process can read the `execv` output from the
    pipe and forward it over the socket. Finally, the child calls the `execv` with
    the possibly attacker-controlled command and arguments as input ➒.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now run `execve-test-overflow` to see how an attacker can abuse the `prefix`
    overflow vulnerability to hijack control in practice. I’ll first run it without
    the protection of the `dta-execve` tool so that you can see the attack succeed.
    After that, I’ll enable `dta-execve` so you can see how it detects and stops the
    attack.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: A Successful Control Hijack Without DTA
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 11-7](ch11.xhtml#ch11list7) shows a benign run of `execve-test-overflow`,
    followed by an example of how to exploit the buffer overflow to execute a command
    of the attacker’s choice instead of `date`. I’ve replaced some repetitive parts
    of the output with “...” to keep the code lines from becoming too wide.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-7: Control hijacking in* execve-test-overflow'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the benign run, I start the `execve-test-overflow` server as a background
    process ➊ and then use `netcat` (`nc`) to connect to the server ➋. In `nc`, I
    enter the string “`foobar:` ” ➌ and send it to the server, which will use it as
    the output prefix. The server runs the `date` command and echoes back the current
    date, prefixed with “`foobar:` ” ➍.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to demonstrate the buffer overflow vulnerability, I restart the server
    ➎ and connect to it again with `nc` ➏. This time, the string I send is much longer
    ➐, long enough to overflow the `prefix` field in the global `cmd` structure. It
    consists of 32 `A`s to fill up the 32-byte `prefix` buffer, followed by 32 `B`s,
    which overflow into the `datefmt` buffer and again fill it up completely. The
    last part of the string overflows into the `cmd` buffer, and it’s a path to the
    program to run instead of `date`, namely, *~/code/chapter11/echo*. At this point,
    the contents of the global `cmd` struct look as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Recall that the server copies the contents of the `cmd` structure into the `argv`
    array used for the `execv`. Thus, as a result of the overflow, the `execv` runs
    the `echo` program instead of `date`! The `datefmt` buffer is passed to `echo`
    as a command line argument, but because it doesn’t contain a terminating `NULL`,
    the real command line argument that `echo` sees is `datefmt` concatenated with
    the `cmd` buffer. Finally, after running `echo`, the server writes the output
    back to the socket ➑, which consists of the concatenation of `prefix`, `datefmt`,
    and `cmd` as the prefix, followed by the output of the `echo` command.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to coax the `execve-test-overflow` program into executing
    an unintended command by supplying it with a malicious input from the network,
    let’s see whether the `dta-execve` tool will succeed in stopping this attack!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Using DTA to Detect the Hijacking Attempt
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test whether `dta-execve` can stop the attack in the previous section, I’ll
    run the same attack again. Only this time, `execve-test-overflow` will be protected
    by the `dta-execve` tool. [Listing 11-8](ch11.xhtml#ch11list8) shows the results.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-8: Detecting an attempted control hijack with* dta-execve'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because `libdft` is based on Pin, you’ll need to run Pin using `dta-execve`
    as the Pin tool ➊ to protect `execve-test-overflow` with `dta-execve`. As you
    can see, I’ve added `-follow_execv` to the Pin options so that Pin will instrument
    all child processes of `execve-test-overflow` the same way as the parent process.
    This is important because the vulnerable `execv` is called in a child process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: After starting the `execve-test-overflow` server protected with `dta-execve`,
    I run `nc` again to connect to the server ➋. Then, I send the same exploit string
    used in the previous section ➌ to overflow the `prefix` buffer and change the
    `cmd`. Keep in mind that `dta-execve` uses network receives as taint sources.
    You can see this in [Listing 11-8](ch11.xhtml#ch11list8) because the `socketcall`
    handler prints a diagnostic message showing that it has intercepted the received
    message ➍. The `socketcall` handler then taints all the bytes received from the
    network ➎.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Next, a diagnostic print from the server tells you that it’s about to execute
    the attacker-controlled `echo` command ➏. Fortunately, this time `dta-execve`
    intercepts the `execv` before it’s too late ➐. It checks the taint on all of the
    `execv` arguments, starting with the `execv` command ➑. Since this command is
    controlled by the attacker via the network-borne buffer overflow, `dta-execve`
    notices that the command is tainted with color `0x01`. It raises an alert and
    then stops the child process that’s about to execute the attacker’s command, thereby
    successfully preventing the attack ➒. The only server output that’s written back
    to the attacker is the prefix string they themselves supplied ➓, since it was
    printed before the `execv` that caused `dta-execve` to abort the child process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Circumventing DTA with Implicit Flows
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far so good: `dta-execve` successfully detected and stopped the control-hijacking
    attack from the previous section. Unfortunately, `dta-execve` is not entirely
    foolproof because practical DTA systems like `libdft` can’t track data propagated
    through *implicit flows*. [Listing 11-9](ch11.xhtml#ch11list9) shows a modified
    version of the `execve-test-overflow` server, which contains an implicit flow
    that prevents `dta-execve` from detecting the attack. For brevity, the listing
    shows only the parts of the code that are different from the original server.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-9:* execve-test-overflow-implicit.c'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only changed parts of the code are in the `exec_cmd` function, which contains
    a vulnerable `for` loop that copies all of the bytes from the receive buffer `buf`
    into the global `prefix` buffer ➊. As before, the loop lacks bounds checking,
    so `prefix` will overflow if the message in `buf` is too long. Now, however, the
    bytes are copied *implicitly* in such a way that the overflow isn’t detected by
    the DTA tool!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [Chapter 10](ch10.xhtml#ch10), implicit flows are the result
    of *control dependencies*, meaning that the data propagation depends on control
    structures instead of explicit data operations. In [Listing 11-9](ch11.xhtml#ch11list9),
    that control structure is a `while` loop. For each byte, the modified `exec_cmd`
    function initializes a `char c` to zero ➋ and then uses the `while` loop to increment
    `c` until it has the same value as `buf[i]` ➌, effectively copying `buf[i]` into
    `c` without ever explicitly copying any data. Finally, `c` is copied into `prefix`
    ➍.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, the effect of this code is the same as in the original version
    of `execve-test-overflow`: `buf` is copied into `prefix`. However, the key is
    that *there’s no explicit data flow between* `*buf*` *and* *`prefix`* because
    the copy from `buf[i]` into `c` is implemented using that `while` loop, avoiding
    an explicit data copy. This introduces a control dependency between `buf[i]` and
    `c` (and thus, transitively, between `buf[i]` and `prefix[i]`), which `libdft`
    cannot track.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: When you retry [Listing 11-8](ch11.xhtml#ch11list8)’s attack by replacing `execve-test-overflow`
    with `execve-test-overflow-implicit`, you’ll see that the attack now succeeds
    despite `dta-execve`’s protection!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: You may remark that if you’re using DTA to prevent attacks against a server
    that you control, you can just write the server in such a way that it doesn’t
    contain implicit flows that confuse `libdft`. While this may be possible (though
    not trivial) in most cases, in malware analysis you’ll find it difficult to get
    around the problem of implicit flows, because you don’t control the malware’s
    code and the malware may contain deliberately crafted implicit flows to confuse
    taint analysis.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 A DTA-Based Data Exfiltration Detector
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous example tool requires only a single taint color because bytes are
    either attacker controlled or not. Now let’s build a tool that uses multiple taint
    colors to detect file-based information leaks so that when a file leaks, you can
    tell *which* file. The idea behind this tool is similar to the taint-based defense
    against the Heartbleed bug you saw in [Chapter 10](ch10.xhtml#ch10), except that
    here the tool uses file reads instead of memory buffers as the taint source.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-10](ch11.xhtml#ch11list10) shows the first part of this new tool,
    which I’ll call `dta -dataleak`. Again, I omit includes of standard C header files
    for brevity.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-10:* dta-dataleak.cpp'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just as in the previous DTA tool, `dta-dataleak` includes *pin.H* and all the
    relevant `libdft` header files ➊. It also includes the now familiar `extern` declaration
    of the `syscall_desc` array ➋ to hook syscalls for the taint sources and sinks.
    In addition, `dta-dataleak` defines some data structures that weren’t there in
    `dta-execve`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The first of these, `fd2color`, is a C++ `map` that maps file descriptors to
    taint colors ➌. The second is also a C++ map, called `color2fname`, and it maps
    taint colors to filenames ➍. You’ll see why these data structures are needed in
    the next few listings.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a `#define` of a constant called `MAX_COLOR` ➎, which is the maximum
    possible taint color value, `0x80`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function of `dta-dataleak` is almost identical to that of `dta-execve`
    in that it initializes Pin and `libdft` and then starts the application. The only
    difference is in which taint sources and sinks `dta-dataleak` defines. It installs
    two post-handlers, called `post_open_hook` ➏ and `post_read_hook` ➐, which run
    just after the `open` and `read` syscalls, respectively. The `open` hook keeps
    track of which file descriptors are open, while the `read` hook is the actual
    taint source, which taints bytes read from open files, as I’ll explain in a moment.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In addition, `dta-dataleak` installs a pre-handler for the `socketcall` syscall,
    called `pre_socketcall_hook` ➑. The `pre_socketcall_hook` is the taint sink, which
    intercepts any data that’s about to be sent over the network so that it can make
    sure the data isn’t tainted before allowing the send. If any tainted data is about
    to be leaked, `pre_socketcall_hook` raises an alert, using a function called `alert`,
    which I’ll explain next.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this example tool is simplified. In a real tool, you’ll want
    to hook additional taint sources (such as the `readv` syscall) and sinks (such
    as `write` syscalls on a socket) for completeness. You’ll also want to implement
    some rules that determine which files are okay to leak over the network and which
    aren’t, rather than assuming all file leaks are malicious.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at the `alert` function, shown in [Listing 11-11](ch11.xhtml#ch11list11),
    which is called if any tainted data is about to leak over the network. Because
    it’s similar to `dta-execve`’s `alert` function, I’ll describe it only briefly
    here.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-11:* dta-dataleak.cpp *(continued)*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `alert` function starts by displaying an alert message, detailing which
    address is tainted and with which colors ➊. It’s possible that the data leaked
    over the network is influenced by multiple files and therefore tainted with multiple
    colors. So, `alert` loops over all possible taint colors ➋ and checks which of
    them are present in the tag of the tainted byte that caused the alert ➌. For each
    color that’s enabled in the tag, `alert` prints the color and the corresponding
    filename ➍, which it reads from the `color2fname` data structure. Finally, `alert`
    calls `exit` to stop the application and prevent the data leak ➎.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s examine the taint sources for the `dta-dataleak` tool.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '*11.4.1 Taint Sources: Tracking Taint for Open Files*'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As I just mentioned, `dta-dataleak` installs two syscall post-handlers: a hook
    for the `open` syscall that keeps track of open files and a hook for `read` that
    taints bytes read from open files. Let’s first look at the code for the `open`
    hook and then look at the `read` handler.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Tracking Open Files
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 11-12](ch11.xhtml#ch11list12) shows the code for `post_open_hook`,
    the post-handler for the `open` syscall.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-12:* dta-dataleak.cpp *(continued)*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Recall that the purpose of `dta-dataleak` is to detect information leak attempts
    that leak data read from a file. For `dta-dataleak` to tell *which* file is being
    leaked, it assigns a different color to each open file. The purpose of the `open`
    syscall handler, `post_open_hook`, is to assign a taint color to each file descriptor
    when it’s opened. It also filters out some uninteresting files, such as shared
    libraries. In a real-world DTA tool, you’ll likely want to implement more filters
    to control which files to protect against information leaks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: To keep track of the next available taint color, `post_open_hook` uses a `static`
    variable called `next_color`, which is initialized to the color `0x01` ➊. Next,
    it parses the syscall context (`ctx`) of the `open` syscall that just occurred
    to obtain the file descriptor `fd` ➋ and the filename `fname` ➌ of the just opened
    file. If the `open` failed ➍ or the opened file is a shared library that’s not
    interesting to track ➎, `post_open_hook` returns without assigning any color to
    the file. To determine whether the file is a shared library, `post_open_hook`
    simply checks whether the filename contains a file extension indicative of a shared
    library, such as *.so*. In a real tool, you’ll want to use more robust checks
    by opening a suspected shared library and verifying that it starts with the ELF
    magic bytes, for instance (see also [Chapter 2](ch02.xhtml#ch02)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'If the file is interesting enough to assign it a taint color, `post_open_hook`
    distinguishes two cases:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: If there is no color assigned to the file descriptor yet (in other words, there
    is no entry for `fd` in the `fd2color` map), then `post_open_hook` assigns `next_color`
    to this file descriptor ➏ and advances `next_color` by shifting it left by 1 bit.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that since `libdft` supports only eight colors, you might run out of colors
    if the application opens too many files. Therefore, `post_open_hook` advances
    `next_color` only until it reaches the maximum color `0x80` ➐. After that, the
    color `0x80` will be used for all subsequently opened files. What this means in
    practice is that the color `0x80` might correspond not just to one file but to
    a whole list of files. Thus, when a byte with color `0x80` leaks, you might not
    know exactly which file the byte came from, only that it’s from one of the files
    in the list. Unfortunately, that’s the price you have to pay for keeping the shadow
    memory small by supporting only eight colors.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sometimes a file descriptor is closed at some point, and then the same file
    descriptor number is reused to open another file. In that case, `fd2color` will
    already contain an assigned color for that file descriptor number ➑. To keep things
    simple, I simply reuse the existing color for the repurposed file descriptor,
    meaning that that color will now correspond to a list of files instead of just
    one, exactly as when you run out of colors.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of `post_open_hook`, the `color2fname` map is updated with the filename
    of the just opened file ➒. This way, when data leaks, you can use the taint color
    of the leaked data to look up the name of the corresponding file, as you just
    saw in the `alert` function. If the taint color was reused for multiple files
    because of one of these reasons, then the `color2fname` entry for that color will
    be a list of filenames separated with a pipe (|) ➓.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Tainting File Reads
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that every opened file is associated with a taint color, let’s look at the
    `post_read_hook` function, which taints bytes read from a file with that file’s
    assigned color. [Listing 11-13](ch11.xhtml#ch11list13) shows the relevant code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-13:* dta-dataleak.cpp *(continued)*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, `post_read_hook` parses the relevant arguments and return value from
    the syscall context to obtain the file descriptor that’s being read (`fd`) ➊,
    the buffer into which bytes are read (`buf`) ➋, and the number of bytes read (`len`)
    ➌. If `len` is less than or equal to zero, no bytes were read, so `post_read_hook`
    returns without tainting anything ➍.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, it obtains `fd`’s taint color by reading it from `fd2color` ➎. If
    `fd` has an associated taint color ➏, `post_read_hook` uses `tagmap_setn` to taint
    all of the read bytes with that color ➐. It may also happen that `fd` has no associated
    color ➑, meaning that it refers to an uninteresting file such as a shared library.
    In that case, we clear any taint from the addresses overwritten by the `read`
    syscall ➒ by using the `libdft` function `tagmap_clrn`. This clears the taint
    from any previously tainted buffer that’s reused to read untainted bytes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '*11.4.2 Taint Sinks: Monitoring Network Sends for Data Exfiltration*'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, [Listing 11-14](ch11.xhtml#ch11list14) shows `dta-dataleak`’s taint
    sink, the `socketcall` handler that intercepts network sends to check them for
    data exfiltration attempts. It’s similar to the `socketcall` handler you saw in
    the `dta-execve` tool, except that it checks sent bytes for taint instead of applying
    taint to received bytes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-14:* dta-dataleak.cpp *(continued)*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, `pre_socketcall_hook` obtains the `call` ➊ and `args` ➋ parameters for
    the `socketcall`. It then uses a switch on `call` just like the one you saw in
    the `socketcall` handler for `dta-execve`, except that this new switch inspects
    `SYS_SEND` and `SYS_SENDTO` ➌ instead of `SYS_RECV` and `SYS_RECVFROM`. If it
    intercepts a send event, it parse the send’s arguments: the socket file descriptor,
    send buffer, and number of bytes to send ➍. After some diagnostic prints, the
    code loops over all of the bytes in the send buffer ➎ and gets each byte’s taint
    status using `tagmap_getb` ➏. If a byte is tainted, `pre_socketcall_hook` calls
    the `alert` function to print an alert and stop the application ➐.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: That covers the entire code for the `dta-dataleak` tool. In the next section,
    you’ll see how `dta-dataleak` detects a data exfiltration attempt and how taint
    colors combine when exfiltrated data depends on multiple taint sources.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '*11.4.3 Detecting a Data Exfiltration Attempt*'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To demonstrate `dta-dataleak`’s ability to detect data leaks, I’ve implemented
    another simple server called `dataleak-test-xor`. For simplicity, this server
    “leaks” tainted files to the socket voluntarily, but `dta-dataleak` can detect
    files leaked through an exploit in the same way. [Listing 11-15](ch11.xhtml#ch11list15)
    shows the relevant code for the server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-15:* dataleak-test-xor.c'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The server opens a socket on `localhost` port 9999 ➊ and uses it to receive
    a message ➋ containing a list of filenames. It splits this list into individual
    filenames using a function called `split_filenames`, which is omitted from the
    listing ➌. Next, it opens all the requested files ➍ and then chooses two of the
    opened files at random ➎. Note that in a realistic use case for `dta-dataleak`,
    the files would be accessed through an exploit rather than released voluntarily
    by the server. For the purposes of this example, the server reads the contents
    of the two randomly chosen files line by line ➏, combining each pair of lines
    (one line from each file) using an XOR operation ➐. Combining the lines will cause
    `dta-dataleak` to merge their taint colors, demonstrating taint merging for the
    purposes of this example. Finally, the result of the two XOR-ed lines is sent
    over the network ➑, providing a “data leak” for `dta-dataleak` to detect.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how `dta-dataleak` detects a data leak attempt and specifically
    how taint colors are merged when the leaked data depends on multiple files. [Listing
    11-16](ch11.xhtml#ch11list16) shows the output of running the `dataleak-test-xor`
    program while protected with `dta-dataleak`. I’ve abbreviated repetitive parts
    of the output with “`...`”.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-16: Detecting a data exfiltration attempt with* dta-dataleak'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example runs the `dataleak-test-xor` server with Pin, using `dta -dataleak`
    as the Pin tool to protect against data leaks ➊. Immediately, there’s a first
    `read` syscall that’s related to the loading process of `dataleak-test-xor` ➋.
    Because these bytes are read from a shared library, which doesn’t have an associated
    taint color, `dta-dataleak` ignores the read.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Next, the example starts a `netcat` session to connect to the server ➌ and send
    it a list of filenames to open ➍. The `dta-dataleak` tool intercepts the `open`
    events for all those files and assigns each of them a taint color ➎. Then, the
    server randomly chooses two files that it’s going to leak. In this case, these
    turn out to be the files with file descriptor 8 ➏ and 5 ➐, respectively.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: For both files, `dta-dataleak` intercepts the `read` events and taints the read
    bytes with the files’ associated taint color (`0x08` and `0x01`, respectively).
    Next, `dta-dataleak` intercepts the server’s attempt to send the file contents,
    which are now XOR-ed together, over the network ➑.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: It checks the taint on the bytes the server is about to send ➒, notices that
    they’re tainted with the tag `0x09` ➓, and therefore prints an alert and aborts
    the program. Tag `0x09` is the combination of the two taint colors `0x01` and
    `0x08`. From the alert, you can see that these colors correspond to the files
    *dta-execve.cpp* and *echo.c*, respectively.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, taint analysis makes it easy to spot information leaks and to
    know exactly which files are leaked. Also, you can use merged taint colors to
    tell which taint sources contributed to a byte’s value. Even with just eight taint
    colors, there are endless ways to build powerful DTA tools!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 Summary
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about the internals of `libdft`, a popular open
    source DTA library. You also saw practical examples of using `libdft` to detect
    two types of common attacks: control hijacking and data exfiltration. You should
    now be ready to start building your own DTA tools!'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Implementing a Format String Exploit Detector
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Use `libdft` to implement the format string exploit detection tool you designed
    in the previous chapter. Create an exploitable program and a format string exploit
    to test your detector. Also, create a program with an implicit flow that allows
    a format string exploit to succeed despite your detection tool.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: You can’t directly hook `printf` with `libdft` because it’s not a syscall.
    Instead, you’ll have to find another way, such as with an instruction-level hook
    (`libdft`’s `ins_set_pre`) that checks for calls to the `printf` PLT stub. For
    the purposes of this exercise, you’re allowed to make simplifying assumptions,
    such as no indirect calls to `printf` and a fixed, hard-coded address for the
    PLT stub.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: If you’re looking for a practical example of instruction-level hooking, check
    out the *libdft-dta.c* tool that ships with `libdft`!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
