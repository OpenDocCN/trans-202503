- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: PRACTICAL DYNAMIC TAINT ANALYSIS WITH LIBDFT
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 libdft 进行实用的动态污点分析
- en: 'In [Chapter 10](ch10.xhtml#ch10), you learned the principles of dynamic taint
    analysis. In this chapter, you will learn how to build your own DTA tools with
    `libdft`, a popular open source DTA library. I’ll cover two practical examples:
    a tool that prevents remote control-hijacking attacks and a tool that automatically
    detects information leaks. But first, let’s take a look at the internals and API
    of `libdft`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 10 章](ch10.xhtml#ch10)中，你学习了动态污点分析的原理。在本章中，你将学习如何使用流行的开源 DTA 库 `libdft`
    来构建你自己的 DTA 工具。我将介绍两个实际的例子：一个是防止远程控制劫持攻击的工具，另一个是自动检测信息泄露的工具。但首先，让我们来看看 `libdft`
    的内部结构和 API。
- en: 11.1 Introducing libdft
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1 引入 libdft
- en: Because DTA is the subject of ongoing research, existing binary-level taint
    tracking libraries are research tools; don’t expect production quality from them.
    The same is true for `libdft`, developed at Columbia University, which you’ll
    use in the remainder of this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DTA 是一个正在进行的研究课题，现有的二进制级污点追踪库基本上都是研究工具，不要期望它们有生产级的质量。`libdft` 也不例外，它是在哥伦比亚大学开发的，你将在本章的剩余部分使用它。
- en: A byte-granularity taint-tracking system built on Intel Pin, `libdft` is one
    of the easiest to use DTA libraries available at the moment. In fact, it’s the
    tool of choice of many security researchers because you can use it to easily build
    DTA tools that are both accurate and fast. I’ve preinstalled `libdft` on the VM
    in the directory */home/binary/libdft*. You can also download it at *[https://www.cs.columbia.edu/~vpk/research/libdft/](https://www.cs.columbia.edu/~vpk/research/libdft/)*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`libdft` 是一个基于 Intel Pin 的字节粒度污点追踪系统，它是目前最易于使用的 DTA 库之一。事实上，它是许多安全研究人员的首选工具，因为你可以使用它轻松构建既准确又快速的
    DTA 工具。我已经在虚拟机中预安装了 `libdft`，路径是 */home/binary/libdft*。你也可以在 *[https://www.cs.columbia.edu/~vpk/research/libdft/](https://www.cs.columbia.edu/~vpk/research/libdft/)*
    下载它。'
- en: Like all binary-level DTA libraries available at the time of writing, `libdft`
    has several shortcomings. The most obvious one is that `libdft` supports only
    32-bit x86\. You can still use it on a 64-bit platform, but only to analyze 32-bit
    processes. It also relies on legacy versions of Pin (versions between 2.11 and
    2.14 should work). Another limitation is that `libdft` implements support only
    for “regular” x86 instructions, not extended instruction sets like MMX or SSE.
    This means `libdft` may suffer from undertainting if taint flows through such
    instructions. If you’re building the program you’re analyzing from source, use
    `gcc`’s compilation options `-mno-{mmx, sse, sse2, sse3}` to ensure that the binary
    won’t contain MMX or SSE instructions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 和写作时所有的二进制级 DTA 库一样，`libdft` 有一些不足之处。最明显的一点是，`libdft` 仅支持 32 位 x86 架构。你仍然可以在
    64 位平台上使用它，但只能分析 32 位进程。它还依赖于旧版本的 Pin（版本在 2.11 和 2.14 之间应该是可用的）。另一个限制是，`libdft`
    仅支持“常规”的 x86 指令，不支持像 MMX 或 SSE 这样的扩展指令集。这意味着，如果污点数据通过这些指令流动，`libdft` 可能会发生污点缺失。如果你是从源代码构建你分析的程序，请使用
    `gcc` 的编译选项 `-mno-{mmx, sse, sse2, sse3}` 来确保二进制文件中不包含 MMX 或 SSE 指令。
- en: Despite its limitations, `libdft` is still an excellent DTA library you can
    use to build solid tools. Also, because it’s open source, it’s relatively easy
    to extend it with 64-bit support or support for more instructions. To help you
    get the most out of `libdft`, let’s take a look at its most important implementation
    details.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些限制，`libdft` 仍然是一个优秀的 DTA 库，你可以使用它来构建可靠的工具。而且，由于它是开源的，因此扩展它以支持 64 位或更多指令集相对容易。为了帮助你最大限度地利用
    `libdft`，让我们来看看它最重要的实现细节。
- en: '*11.1.1 Internals of libdft*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.1.1 libdft 的内部结构*'
- en: Because `libdft` is based on Intel Pin, `libdft`-based DTA tools are just Pin
    tools like the ones you saw in [Chapter 9](ch09.xhtml#ch09), except they’re linked
    with `libdft`, which provides the DTA functionality. On the VM, I’ve installed
    a dedicated legacy version of Intel Pin (v2.13) you can use with `libdft`. Pin
    is used by `libdft` to instrument instructions with taint propagation logic. Taint
    itself is stored in shadow memory, which is accessible through the `libdft` API.
    [Figure 11-1](ch11.xhtml#ch11fig1) shows an overview of `libdft`’s most important
    components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `libdft` 基于 Intel Pin，基于 `libdft` 的 DTA 工具实际上就是 Pin 工具，就像你在[第 9 章](ch09.xhtml#ch09)中看到的那些工具，只不过它们与
    `libdft` 链接在一起，后者提供了 DTA 功能。在虚拟机上，我已经安装了一个专用的旧版 Intel Pin（v2.13），你可以与 `libdft`
    一起使用。Pin 被 `libdft` 用来对指令进行插桩，加入污点传播逻辑。污点数据本身存储在阴影内存中，可以通过 `libdft` 的 API 进行访问。[图
    11-1](ch11.xhtml#ch11fig1) 展示了 `libdft` 最重要的组件概览。
- en: Shadow Memory
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阴影内存
- en: As you can see in [Figure 11-1](ch11.xhtml#ch11fig1), `libdft` comes in two
    variants, each with a different kind of shadow memory (called the *tagmap* in
    `libdft` parlance). First, there’s a bitmap-based variant ➊, which supports only
    one taint color but is slightly faster and has less memory overhead than the other
    variant. In the `libdft` source archive available from the Columbia University
    website,^([1](footnote.xhtml#ch11fn_1)) this variant is in the directory called
    *libdft_linux-i386*. The second variant implements an eight-color shadow memory
    ➋, and you can find it in the directory *libdft-ng_linux-i386* in the source archive.
    This second variant is the one I’ve preinstalled on the VM and the one I’ll use
    here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图11-1](ch11.xhtml#ch11fig1)所示，`libdft`有两个变种，每个变种使用不同类型的阴影内存（在`libdft`术语中称为*tagmap*）。首先是基于位图的变种➊，它只支持一个污染颜色，但比另一个变种稍快，且内存开销更小。在从哥伦比亚大学网站下载的`libdft`源代码压缩包中，^([1](footnote.xhtml#ch11fn_1))该变种位于名为*libdft_linux-i386*的目录中。第二个变种实现了一个八色阴影内存➋，你可以在源代码压缩包中的*libdft-ng_linux-i386*目录下找到它。这个第二个变种是我在虚拟机上预安装的，也是我在这里将要使用的版本。
- en: To minimize the memory requirements of the eight-color shadow memory, `libdft`
    implements it using an optimized data structure, called the *segment translation
    table (STAB)*. The STAB contains one entry for every memory page. Each entry contains
    an *addend* value, which is just a 32-bit offset that you add to a virtual memory
    address to obtain the address of the corresponding shadow byte.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化八色阴影内存的内存需求，`libdft`通过一种优化的数据结构实现了它，称为*段转换表（STAB）*。STAB包含每个内存页面的一个条目。每个条目包含一个*加数*值，这是一个32位的偏移量，你可以将它加到虚拟内存地址上，以获取对应阴影字节的地址。
- en: '![image](Images/f281-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f281-01.jpg)'
- en: '*Figure 11-1: Internals of* `libdft` *: shadow memory and virtual CPU implementation,
    instrumentation, and API*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-1：`libdft`的内部：阴影内存和虚拟CPU实现，仪器化和API*'
- en: For example, to read the shadow memory for virtual address `0x1000`, you can
    look up the corresponding addend in the STAB, which turns out to be `438`. That
    means you’ll find the shadow byte containing the taint information for address
    `0x1000` at address `0x1438`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要读取虚拟地址`0x1000`的阴影内存，你可以在STAB中查找对应的加数，结果是`438`。这意味着你将在地址`0x1438`找到包含地址`0x1000`的污染信息的阴影字节。
- en: The STAB provides a level of indirection that allows `libdft` to allocate shadow
    memory on demand, whenever the application allocates a region of virtual memory.
    Shadow memory is allocated in page-sized chunks, keeping memory overhead to a
    minimum. Since each allocated memory page corresponds to exactly one shadow page,
    the same addend can be used for all addresses in a page. For virtual memory regions
    with multiple adjacent pages, `libdft` ensures that the shadow memory pages are
    also adjacent, simplifying shadow memory access. Each chunk of adjacent shadow
    map pages is called a *tagmap segment (tseg)*. As an additional memory usage optimization,
    `libdft` maps all read-only memory pages to the same zeroed-out shadow page.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: STAB提供了一种间接访问机制，使得`libdft`能够根据需要在每次应用程序分配虚拟内存区域时分配阴影内存。阴影内存是按页面大小的块分配的，从而保持最小的内存开销。由于每个分配的内存页面对应着一个阴影页面，所有地址的加数可以使用相同的值。对于包含多个相邻页面的虚拟内存区域，`libdft`确保阴影内存页面也相邻，从而简化阴影内存访问。每个相邻的阴影映射页面块被称为*tagmap段（tseg）*。作为额外的内存使用优化，`libdft`将所有只读内存页面映射到同一个已清零的阴影页面。
- en: Virtual CPU
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟CPU
- en: 'To keep track of the taint status of CPU registers, `libdft` keeps a special
    structure in memory called the *virtual CPU*. The virtual CPU is a sort of mini-shadow
    memory with 4 shadow bytes for each of the 32-bit general-purpose CPU registers
    available on x86: `edi`, `esi`, `ebp`, `esp`, `ebx`, `edx`, `ecx`, and `eax`.
    In addition, there’s a special scratch register on the virtual CPU, which `libdft`
    uses to store taint for any unrecognized register. In the preinstalled `libdft`
    version on the VM, I’ve made some modifications to the virtual CPU so that it
    has room for all registers supported by Intel Pin.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪CPU寄存器的污染状态，`libdft`在内存中保持一个特殊结构，称为*虚拟CPU*。虚拟CPU是一种迷你阴影内存，对于x86上的每个32位通用CPU寄存器（如`edi`、`esi`、`ebp`、`esp`、`ebx`、`edx`、`ecx`和`eax`），虚拟CPU为每个寄存器保留4个阴影字节。此外，虚拟CPU上还有一个特殊的临时寄存器，`libdft`使用它来存储任何未识别寄存器的污染信息。在虚拟机上预安装的`libdft`版本中，我对虚拟CPU做了一些修改，使其可以支持Intel
    Pin所支持的所有寄存器。
- en: Taint-Tracking Engine
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 污染追踪引擎
- en: Recall that `libdft` uses Pin’s API to inspect all instructions in a binary
    and then instruments these instructions with the relevant taint propagation functions.
    If you’re interested, you can find the implementations of `libdft`’s taint propagation
    functions in the file */home/binary/libdft/libdft-ng_linux-i386/src/ libdft_core.c*
    on the VM, but I won’t cover them all here. Together, the taint propagation functions
    implement `libdft`’s taint policy, which I’ll describe in [Section 11.1.2](ch11.xhtml#ch11_1_2).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，`libdft` 使用 Pin 的 API 来检查二进制中的所有指令，并将这些指令与相关的污点传播函数进行插桩。如果你感兴趣的话，可以在虚拟机中的文件
    */home/binary/libdft/libdft-ng_linux-i386/src/libdft_core.c* 找到 `libdft` 的污点传播函数实现，但我在这里不打算详细讲解它们。所有的污点传播函数共同实现了
    `libdft` 的污点策略，我将在[第 11.1.2 节](ch11.xhtml#ch11_1_2)中描述该策略。
- en: The libdft API and I/O Interface
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`libdft` API 和 I/O 接口'
- en: Ultimately, the goal of `libdft` is to function as a library for building your
    own DTA tools. For this purpose, `libdft` provides a taint-tracking API, which
    provides several classes of functions. The two most important classes of functions
    for building DTA tools are those that manipulate the tagmap and those that add
    callbacks and instrumentation code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`libdft` 的目标是作为构建你自己 DTA 工具的库。为此，`libdft` 提供了一个污点跟踪 API，其中包含了几类函数。对于构建 DTA
    工具来说，最重要的两类函数是操作标签映射的函数和添加回调及插桩代码的函数。
- en: The tagmap API is defined in the header file *tagmap.h*. It provides functions
    such as `tagmap_setb` to mark a memory byte as tainted and `tagmap_getb` to retrieve
    the taint information for a memory byte.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 标签映射 API 定义在头文件 *tagmap.h* 中。它提供了诸如 `tagmap_setb`（用于将内存字节标记为污点）和 `tagmap_getb`（用于检索内存字节的污点信息）等函数。
- en: The API for adding callbacks and instrumentation code is split over the header
    files *libdft_api.h* and *syscall_desc.h*. It allows you to register callbacks
    for syscall events using the functions `syscall_set_pre` and `syscall_set_post`.
    To store all these callbacks, `libdft` uses a dedicated array called `syscall_desc`,
    which keeps track of all the syscall pre- and post-handlers you install. Similarly,
    you can register instruction callbacks with `ins_set_pre` and `ins_set_post`.
    You’ll learn about these and other `libdft` API functions in more detail from
    the DTA tools later in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 添加回调和插桩代码的 API 分布在头文件 *libdft_api.h* 和 *syscall_desc.h* 中。它允许你使用 `syscall_set_pre`
    和 `syscall_set_post` 函数注册系统调用事件的回调。为了存储所有这些回调，`libdft` 使用一个专门的数组，名为 `syscall_desc`，用于跟踪你安装的所有系统调用前后处理程序。同样，你可以使用
    `ins_set_pre` 和 `ins_set_post` 注册指令回调。你将在本章后面的 DTA 工具部分更详细地了解这些以及其他 `libdft` API
    函数。
- en: '*11.1.2 Taint Policy*'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.1.2 污点策略*'
- en: The `libdft` taint propagation policy defines the following five classes of
    instructions.^([2](footnote.xhtml#ch11fn_2)) Each of these classes propagates
    and merges taint in a different way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`libdft` 的污点传播策略定义了以下五类指令。^([2](footnote.xhtml#ch11fn_2)) 每一类指令以不同的方式传播和合并污点。'
- en: '**ALU** These are arithmetic and logic instructions with two or three operands,
    such as `add`, `sub`, `and`, `xor`, `div`, and `imul`. For these operations, `libdft`
    merges taint in the same way as the `add` and `xor` examples in [Table 10-1](ch10.xhtml#ch10tab1)
    on page 273—the output taint is the union (∪) of the input operands’ taint. Also
    as in [Table 10-1](ch10.xhtml#ch10tab1), `libdft` considers immediate values untainted
    since there’s no way an attacker can influence them.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**ALU** 这些是具有两个或三个操作数的算术和逻辑指令，例如 `add`、`sub`、`and`、`xor`、`div` 和 `imul`。对于这些操作，`libdft`
    以与 [表 10-1](ch10.xhtml#ch10tab1) 中的 `add` 和 `xor` 示例相同的方式合并污点——输出的污点是输入操作数污点的并集（∪）。正如
    [表 10-1](ch10.xhtml#ch10tab1) 中所示，`libdft` 认为立即数是未污染的，因为攻击者无法影响它们。'
- en: '**XFER** The XFER class contains all the instructions that copy a value to
    another register or memory location, such as the `mov` instruction. Again, it’s
    handled like the `mov` example in [Table 10-1](ch10.xhtml#ch10tab1), using the
    assignment operation (:=). For these instructions, `libdft` simply copies the
    taint from the source operand to the destination.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**XFER** XFER 类包含所有将值复制到另一个寄存器或内存位置的指令，例如 `mov` 指令。与 [表 10-1](ch10.xhtml#ch10tab1)
    中的 `mov` 示例一样，这些指令的处理方式是使用赋值操作 (:=)。对于这些指令，`libdft` 仅仅是将源操作数的污点复制到目标位置。'
- en: '**CLR** As the name implies, instructions in this class always cause their
    output operands to become untainted. In other words, `libdft` sets the output
    taint to the empty set (ø). This class includes some special cases of instructions
    from other classes, such as `xor`-ing an operand with itself or subtracting an
    operand from itself. It also includes instructions such as `cpuid`, where an attacker
    has no control over the outputs.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**CLR** 正如其名，这一类指令总是使它们的输出操作数变得不受污染。换句话说，`libdft` 将输出的污染标记设置为空集（ø）。这一类包括其他类指令的一些特殊情况，例如用自身做异或运算或从自身中减去一个操作数。它还包括像
    `cpuid` 这样的指令，攻击者无法控制输出。'
- en: '**SPECIAL** These are instructions that require special rules for taint propagation
    not covered by other classes. Among others, this class includes `xchg` and `cmpxchg`
    (where the taint of two operands is swapped) and `lea` (where the taint results
    from a memory address computation).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPECIAL** 这些是需要特殊规则来传播污染的指令，这些规则在其他类别中未涉及。包括但不限于 `xchg` 和 `cmpxchg`（其中两个操作数的污染会交换）以及
    `lea`（其中污染源自内存地址的计算）。'
- en: '**FPU, MMX, SSE** This class includes instructions that `libdft` doesn’t currently
    support, such as FPU, MMX, and SSE instructions. When taint flows through such
    instructions, `libdft` cannot track it, so the taint information doesn’t propagate
    to the output operands of the instructions, resulting in undertainting.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**FPU, MMX, SSE** 这一类包含了 `libdft` 当前不支持的指令，如 FPU、MMX 和 SSE 指令。当污染通过这些指令时，`libdft`
    无法追踪，因此污染信息不会传播到指令的输出操作数，导致污染不足。'
- en: Now that you’re acquainted with `libdft`, let’s build some DTA tools with `libdft`!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 `libdft`，让我们用 `libdft` 构建一些 DTA 工具吧！
- en: 11.2 Using DTA to Detect Remote Control-Hijacking
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2 使用 DTA 检测远程控制劫持
- en: The first DTA tool you’ll see is designed to detect some types of remote control-hijacking
    attacks. Specifically, it detects attacks where data received from the network
    is used to control the arguments of an `execve` call. Thus, the taint sources
    will be the network receive functions `recv` and `recvfrom`, while the `execve`
    syscall will be the taint sink. As usual, you can find the complete source code
    on the VM, in *~/code/chapter11*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的第一个 DTA 工具旨在检测一些类型的远程控制劫持攻击。具体来说，它检测的是网络接收的数据被用来控制 `execve` 调用的参数的攻击。因此，污染源将是网络接收函数
    `recv` 和 `recvfrom`，而 `execve` 系统调用将是污染汇。像往常一样，你可以在虚拟机上找到完整的源代码，位于 *~/code/chapter11*
    中。
- en: I tried to make this example tool as simple as possible to keep the discussion
    easy to understand. That means it necessarily makes simplifying assumptions and
    will not catch all types of control-hijacking attacks. In a real, fully fledged
    DTA tool, you’ll want to define additional taint sources and sinks to prevent
    more types of attacks. For instance, in addition to data received with `recv`
    and `recvfrom`, you’ll want to consider data read from the network using the `read`
    syscall. Moreover, to prevent tainting innocent file reads, you’ll need to keep
    track of which file descriptors are reading from the network by hooking network
    calls like `accept`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量将这个示例工具做得尽可能简单，以便让讨论更容易理解。这意味着它必须做一些简化假设，并且不能捕捉所有类型的控制劫持攻击。在一个真正的、功能齐全的 DTA
    工具中，你需要定义额外的污染源和污染汇，以防更多类型的攻击。例如，除了通过 `recv` 和 `recvfrom` 接收的数据，你还需要考虑通过 `read`
    系统调用从网络读取的数据。此外，为了防止无辜的文件读取被污染，你需要跟踪哪些文件描述符正在通过 `accept` 等网络调用从网络读取数据。
- en: When you understand how the following example tool works, you should be able
    to refine it on your own. Additionally, `libdft` comes with a more elaborate example
    DTA tool that implements many of these refinements for reference. You can find
    it in the file *tools/libdft-dta.c* in the *libdft* directory if you’re interested.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你理解下面这个示例工具的工作原理时，你应该能够自行改进它。此外，`libdft` 附带了一个更为复杂的示例 DTA 工具，参考了许多这些改进。如果你感兴趣，可以在
    *libdft* 目录下的文件 *tools/libdft-dta.c* 中找到它。
- en: Many `libdft`-based DTA tools hook syscalls to use as taint sources and sinks.
    On Linux, every syscall has its own *syscall number*, which `libdft` uses to index
    the `syscall_desc` array. For a list of available syscalls and their associated
    syscall numbers, refer to */usr/include/x86_64-linux-gnu/asm/unistd_32.h* for
    x86 (32 bit) or to */usr/include/asm-generic/unistd.h* for x64.^([3](footnote.xhtml#ch11fn_3))
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多基于`libdft`的DTA工具都会挂钩系统调用，作为污点源和污点汇。在Linux中，每个系统调用都有自己独特的*系统调用编号*，`libdft`使用它来索引`syscall_desc`数组。有关可用系统调用及其相关系统调用编号的列表，请参考x86（32位）的*/usr/include/x86_64-linux-gnu/asm/unistd_32.h*或x64的*/usr/include/asm-generic/unistd.h*。^([3](footnote.xhtml#ch11fn_3))
- en: Now, let’s take a look at the example tool called `dta-execve`. [Listing 11-1](ch11.xhtml#ch11list1)
    shows the first part of the source code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下名为`dta-execve`的示例工具。[列表 11-1](ch11.xhtml#ch11list1)展示了源代码的第一部分。
- en: '*Listing 11-1:* dta-execve.cpp'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-1:* dta-execve.cpp'
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, I show only the header files that are specific to `libdft`-based DTA tools,
    but you can see the omitted code in the source on the VM if you’re interested.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我只展示了与`libdft`相关的DTA工具特定的头文件，但如果你感兴趣，可以在虚拟机上的源代码中查看省略的代码。
- en: The first header file is *pin.H* ➊ because all `libdft` tools are just Pin tools
    linked with the `libdft` library. Next, there are several header files that together
    provide access to the `libdft` API ➋. The first of these, *branch_pred.h*, contains
    the macros `likely` and `unlikely`, which you can use to provide the compiler
    with hints for branch prediction, as I’ll explain in a moment. Next, *libdft_api.h*,
    *syscall_desc.h*, and *tagmap.h* provide access to the `libdft` base API, syscall
    hooking interface, and tagmap (shadow memory), respectively.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个头文件是*pin.H* ➊，因为所有`libdft`工具实际上都是链接了`libdft`库的Pin工具。接下来是几个头文件，它们一起提供对`libdft`
    API的访问 ➋。第一个是*branch_pred.h*，包含宏`likely`和`unlikely`，你可以使用它们为编译器提供分支预测的提示，稍后我将解释。接下来，*libdft_api.h*、*syscall_desc.h*和*tagmap.h*分别提供对`libdft`基础API、系统调用钩子接口和tagmap（影像内存）的访问。
- en: After the includes, there’s an `extern` declaration of the `syscall_desc` array
    ➌, which is the data structure `libdft` uses to keep track of syscall hooks. You’ll
    need access to it to hook your taint sources and sinks. The actual definition
    of `syscall_desc` is in `libdft`’s source file *syscall_desc.c*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含文件之后，是`syscall_desc`数组的`extern`声明 ➌，这是`libdft`用来跟踪系统调用钩子的结构体。你将需要访问它来挂钩你的污点源和污点汇。`syscall_desc`的实际定义在`libdft`的源文件*syscall_desc.c*中。
- en: Now let’s take a look at the `main` function of the `dta-execve` tool. It starts
    by initializing Pin’s symbol processing ➍ in case symbols are present in the binary,
    followed by Pin itself ➎. You saw Pin initialization code in [Chapter 9](ch09.xhtml#ch09),
    but this time the return value of `PIN_Init` is checked using an optimized branch,
    marked with the `unlikely` macro to tell the compiler it’s unlikely that `PIN_Init`
    will fail. This knowledge can help the compiler with branch prediction, which
    may allow it to output slightly faster code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`dta-execve`工具的`main`函数。它首先初始化Pin的符号处理 ➍，以防二进制文件中存在符号，然后初始化Pin本身 ➎。你在[第9章](ch09.xhtml#ch09)中已经看到了Pin初始化的代码，但这次使用了优化的分支来检查`PIN_Init`的返回值，使用`unlikely`宏标记它，告诉编译器`PIN_Init`失败的可能性较小。这一知识可以帮助编译器进行分支预测，从而可能生成稍微更快的代码。
- en: Next, the `main` function initializes `libdft` itself using the `libdft_init`
    function ➏, again with an optimized check of the return value. This initialization
    allows `libdft` to set up crucial data structures, such as the tagmap. If this
    setup fails, `libdft_init` returns a nonzero value, in which case you call `libdft_die`
    to deallocate any resources `libdft` may have allocated ➐.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`main`函数使用`libdft_init`函数 ➏ 初始化`libdft`，并再次优化检查返回值。此初始化允许`libdft`设置重要的数据结构，例如tagmap。如果初始化失败，`libdft_init`将返回非零值，在这种情况下，你需要调用`libdft_die`来释放`libdft`可能分配的任何资源
    ➐。
- en: 'Once Pin and `libdft` are both initialized, you can install your syscall hooks,
    which serve as taint sources and taint sinks. Keep in mind that the appropriate
    hook will be called whenever the instrumented application (the program you’re
    protecting with your DTA tool) executes the corresponding syscall. Here, `dta-execve`
    installs two hooks: a post-handler called `post_socketcall_hook` that runs right
    after every `socketcall` syscall ➑ and a pre-handler that runs before `execve`
    syscalls, called `pre_execve_hook` ➒. The `socketcall` syscall captures all socket-related
    events on x86-32 Linux, including `recv` and `recvfrom` events. The `socketcall`
    handler (`post_socketcall_hook`) differentiates between the different types of
    socket events, as I’ll explain in a moment.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Pin和`libdft`都初始化完成，你可以安装系统调用钩子，这些钩子作为污点源和污点接收点。请记住，当被仪器化的应用程序（即你使用DTA工具保护的程序）执行相应的系统调用时，适当的钩子将会被调用。在这里，`dta-execve`安装了两个钩子：一个后处理钩子，名为`post_socketcall_hook`，它在每次执行`socketcall`系统调用后立即运行➑；另一个是前处理钩子，它在执行`execve`系统调用之前运行，名为`pre_execve_hook`➒。`socketcall`系统调用捕获所有与套接字相关的事件（例如`recv`和`recvfrom`事件）在x86-32架构的Linux上。`socketcall`处理程序（`post_socketcall_hook`）区分了不同类型的套接字事件，接下来我会解释。
- en: To install a syscall handler, you call `syscall_set_post` (for post-handlers)
    or `syscall_set_pre` (for pre-handlers). Both of these functions take a pointer
    to the entry in `libdft`’s `syscall_desc` array in which to install the handler,
    and a function pointer to the handler to install. To get the appropriate `syscall_desc`
    entry, you index `syscall_desc` with the syscall number of the syscall you’re
    hooking. In this case, the relevant syscall numbers are represented by the symbolic
    names `__NR_socketcall` and `__NR_execve`, which you can find in */usr/include/i386-linux-gnu/asm/unistd_32.h*
    for x86-32.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装系统调用处理程序，你需要调用`syscall_set_post`（用于后处理钩子）或`syscall_set_pre`（用于前处理钩子）。这两个函数都接受一个指向`libdft`的`syscall_desc`数组条目的指针，用于安装处理程序，以及一个指向要安装的处理程序的函数指针。为了获得适当的`syscall_desc`条目，你需要用你正在钩住的系统调用的系统调用号来索引`syscall_desc`数组。在这个例子中，相关的系统调用号由符号名称`__NR_socketcall`和`__NR_execve`表示，你可以在`/usr/include/i386-linux-gnu/asm/unistd_32.h`中找到这些符号名称（适用于x86-32）。
- en: Finally, you call `PIN_StartProgram` to begin running the instrumented application
    ➓. Recall from [Chapter 9](ch09.xhtml#ch09) that `PIN_StartProgram` never returns,
    so the `return 0` at the end of `main` is never reached.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要调用`PIN_StartProgram`来开始运行仪器化的应用程序➓。回想一下在[第9章](ch09.xhtml#ch09)中提到的，`PIN_StartProgram`永远不会返回，所以`main`函数末尾的`return
    0`永远不会被执行。
- en: 'Although I don’t use it in this example, `libdft` does provide the ability
    to hook instructions in nearly the same way as syscalls, as shown in the following
    listing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个示例中没有使用，`libdft`确实提供了几乎与系统调用相同的方式来钩住指令，如以下代码所示：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To hook instructions, you globally declare the `extern ins_desc` array ➊ (analogous
    to `syscall_desc`) in your DTA tool and then use `ins_set_pre` or `ins_set_post`
    ➋ to install instruction pre- or post-handlers, respectively. Instead of syscall
    numbers, you index the `ins_desc` array using symbolic names provided by Intel’s
    x86 encoder/decoder library (XED), which comes with Pin. XED defines these names
    in an `enum` called `xed_iclass_enum_t`, and each name denotes an instruction
    class such as `X86_ICLASS_RET_NEAR`. The names of the classes correspond to instruction
    mnemonics. You can find a list of all the instruction class names online at *[https://intelxed.github.io/ref-manual/](https://intelxed.github.io/ref-manual/)*
    or in the header file *xed-iclass-enum.h* that ships with Pin.^([4](footnote.xhtml#ch11fn_4))
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了钩住指令，你需要在DTA工具中全局声明`extern ins_desc`数组➊（类似于`syscall_desc`），然后使用`ins_set_pre`或`ins_set_post`➋来分别安装指令的前处理或后处理钩子。与系统调用号不同，你使用由Intel的x86编码/解码库（XED）提供的符号名称来索引`ins_desc`数组，XED库随Pin一起提供。XED在一个名为`xed_iclass_enum_t`的枚举中定义了这些名称，每个名称表示一种指令类别，如`X86_ICLASS_RET_NEAR`。这些类别的名称对应于指令助记符。你可以在线查看所有指令类别名称的列表，网址是*[https://intelxed.github.io/ref-manual/](https://intelxed.github.io/ref-manual/)*，或者在随Pin一起提供的头文件*xed-iclass-enum.h*中找到。
- en: '*11.2.1 Checking Taint Information*'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.2.1 检查污点信息*'
- en: In the previous section, you saw how the `dta-execve` tool’s `main` function
    performs all the necessary initialization, sets up the appropriate syscall hooks
    to serve as taint sources and sinks, and then starts the application. In this
    case, the taint sink is a syscall hook called `pre_execve_hook`, which checks
    whether any of the `execve` arguments are tainted, indicating a control hijacking
    attack. If so, it raises an alert and stops the attack by aborting the application.
    Because the taint checking is done repeatedly for every `execve` argument, I’ve
    implemented it in a separate function called `check_string_taint`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你已经看到`dta-execve`工具的`main`函数执行了所有必要的初始化，设置了适当的系统调用钩子，作为污点源和污点接收点，然后启动了应用程序。在这种情况下，污点接收点是一个叫做`pre_execve_hook`的系统调用钩子，它检查是否有任何`execve`参数被污染，表明可能发生了控制劫持攻击。如果是，它会触发警告并通过终止应用程序来阻止攻击。由于污点检查会对每个`execve`参数重复进行，因此我将其实现为一个名为`check_string_taint`的单独函数。
- en: I’ll discuss `check_string_taint` first, and then I’ll move on to the code for
    `pre_execve_hook` in [Section 11.2.3](ch11.xhtml#ch11_2_3). [Listing 11-2](ch11.xhtml#ch11list2)
    shows the `check_string_taint` function, as well as the `alert` function that
    is called if an attack is detected.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先讨论`check_string_taint`，然后转到[第11.2.3节](ch11.xhtml#ch11_2_3)中的`pre_execve_hook`代码。[列表11-2](ch11.xhtml#ch11list2)展示了`check_string_taint`函数，以及在检测到攻击时调用的`alert`函数。
- en: '*Listing 11-2:* dta-execve.cpp *(continued)*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-2：* dta-execve.cpp *(续)*'
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `alert` function ➊ simply prints an alert message with details about the
    tainted address and then calls `exit` to stop the application and prevent the
    attack. The actual taint-checking logic is implemented in `check_string_taint`
    ➋, which takes two strings as input. The first string (`str`) is the one to check
    for taint, while the second (`source`) is a diagnostic string that’s passed to
    and printed by `alert`, specifying the source of the first string, which is the
    `execve` path, an `execve` parameter, or an environment parameter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert`函数 ➊ 简单地打印包含污点地址详细信息的警告消息，然后调用`exit`停止应用程序并防止攻击。实际的污点检查逻辑在`check_string_taint`
    ➋中实现，该函数接受两个字符串作为输入。第一个字符串（`str`）是要检查污点的字符串，而第二个字符串（`source`）是诊断字符串，它传递给并由`alert`打印，指定第一个字符串的来源，可以是`execve`路径、`execve`参数或环境参数。'
- en: To check the taint of `str`, `check_string_taint` loops over all of `str`’s
    bytes ➌. For each byte, it checks the taint status using `libdft`’s `tagmap_getb`
    function ➍. If the byte is tainted, `alert` is called to print an error and exit
    ➎.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`str`的污点，`check_string_taint`会遍历`str`的所有字节 ➌。对于每个字节，它通过`libdft`的`tagmap_getb`函数检查污点状态
    ➍。如果该字节有污点，则调用`alert`打印错误信息并退出 ➎。
- en: The `tagmap_getb` function takes the memory address of a byte (in the form of
    a `uintptr_t`) as input and returns the shadow byte containing the taint color
    for that address. The taint color (called `tag` in [Listing 11-2](ch11.xhtml#ch11list2))
    is a `uint8_t` since `libdft` keeps one shadow byte per memory byte. If `tag`
    is zero, then the memory byte is untainted. If it’s not zero, the byte is tainted,
    and the `tag` color can be used to find out what the taint source was. Because
    this DTA tool has only one taint source (network receives), it uses only a single
    taint color.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`tagmap_getb`函数接受一个字节的内存地址（以`uintptr_t`形式）作为输入，并返回包含该地址污点颜色的阴影字节。污点颜色（在[列表11-2](ch11.xhtml#ch11list2)中称为`tag`）是一个`uint8_t`类型，因为`libdft`为每个内存字节保留一个阴影字节。如果`tag`为零，则该内存字节无污点。如果不为零，则该字节有污点，`tag`颜色可用于查找污点来源。由于该DTA工具只有一个污点源（网络接收），它仅使用单一的污点颜色。'
- en: Sometimes you may want to fetch the taint tag of multiple memory bytes at once.
    For this purpose, `libdft` provides the `tagmap_getw` and `tagmap_getl` functions,
    which are analogous to `tagmap_getb` but return two or four consecutive shadow
    bytes at once, in the form of a `uint16_t` or a `uint32_t`, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望一次获取多个内存字节的污点标签。为此，`libdft`提供了`tagmap_getw`和`tagmap_getl`函数，它们类似于`tagmap_getb`，但一次返回两个或四个连续的阴影字节，分别以`uint16_t`或`uint32_t`的形式返回。
- en: '*11.2.2 Taint Sources: Tainting Received Bytes*'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.2.2 污点源：接收字节的污点*'
- en: Now that you know how to check the taint color for a given memory address, let’s
    discuss how to taint bytes in the first place. [Listing 11-3](ch11.xhtml#ch11list3)
    shows the code of `post_socketcall_hook`, which is the taint source called right
    after each `socketcall` syscall and that taints bytes received from the network.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你知道了如何检查给定内存地址的污点颜色，让我们来讨论如何在第一时间标记字节。[清单 11-3](ch11.xhtml#ch11list3)展示了`post_socketcall_hook`的代码，它是每次`socketcall`系统调用后被调用的污点源，标记从网络接收到的字节。  '
- en: '*Listing 11-3:* dta-execve.cpp *(continued)*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-3:* dta-execve.cpp *(续)*  '
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In `libdft`, syscall hooks like `post_socketcall_hook` are `void` functions
    that take a `syscall_ctx_t*` as their only input argument. In [Listing 11-3](ch11.xhtml#ch11list3),
    I’ve called that input argument `ctx`, and it acts as a descriptor of the syscall
    that just took place. Among other things, it contains the arguments that were
    passed to the syscall and the return value of the syscall. The hook inspects `ctx`
    to determine which bytes (if any) to taint.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '在`libdft`中，像`post_socketcall_hook`这样的系统调用钩子是`void`函数，唯一的输入参数是`syscall_ctx_t*`类型的指针。在[清单
    11-3](ch11.xhtml#ch11list3)中，我将该输入参数命名为`ctx`，它作为刚刚发生的系统调用的描述符。除了其他内容外，它包含了传递给系统调用的参数以及系统调用的返回值。钩子会检查`ctx`，以确定需要标记哪些字节（如果有的话）。  '
- en: The `socketcall` syscall takes two arguments, which you can verify by reading
    `man socketcall`. The first is an `int` called `call`, and it tells you what kind
    of `socketcall` this is, for example, whether it’s a `recv` or `recvfrom`. The
    second, called `args`, contains a block of arguments for the `socketcall` in the
    form of an `unsigned long*`. The `post_socketcall_hook` begins by parsing `call`
    ➊ and `args` ➋ from the syscall `ctx`. To get an argument from the syscall `ctx`,
    you read the appropriate entry from its `arg` field (for example, `ctx->arg[SYSCALL_ARG0]`)
    and cast it to the correct type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`socketcall`系统调用接受两个参数，你可以通过阅读`man socketcall`来验证这一点。第一个是一个名为`call`的`int`类型，它告诉你这是什么类型的`socketcall`，例如，是否是`recv`或`recvfrom`。第二个参数，名为`args`，包含一个`unsigned
    long*`类型的参数块，用于`socketcall`。`post_socketcall_hook`首先解析`call` ➊和`args` ➋这两个参数，来自系统调用的`ctx`。要从系统调用`ctx`中获取参数，你需要读取其`arg`字段中的相应条目（例如，`ctx->arg[SYSCALL_ARG0]`）并将其转换为正确的类型。  '
- en: Next, `dta-execve` uses a `switch` to differentiate between the different possible
    `call` types. If `call` indicates that this is a `SYS_RECV` or `SYS_RECVFROM`
    event ➌, then `dta-execve` inspects it more closely to find out which bytes were
    received and need to be tainted. It simply ignores any other event in the `default`
    case.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，`dta-execve`使用`switch`语句来区分不同的`call`类型。如果`call`表示这是一个`SYS_RECV`或`SYS_RECVFROM`事件
    ➌，那么`dta-execve`会更仔细地检查它，以找出哪些字节已被接收并需要标记。它会在`default`情况下忽略任何其他事件。  '
- en: If the current event is a receive, then the next thing `dta-execve` does is
    check the return value of the `socketcall` by inspecting `ctx->ret` ➍. If it’s
    less than or equal to zero, then no bytes were received, so nothing is tainted
    and the syscall hook simply returns. Inspecting the return value is possible only
    in a post-handler, since in a pre-handler the syscall you’re hooking hasn’t happened
    yet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前事件是接收操作，那么`dta-execve`接下来的操作是通过检查`ctx->ret` ➍来验证`socketcall`的返回值。如果返回值小于或等于零，表示没有接收到字节，因此不会进行标记，系统调用钩子将直接返回。只有在后处理程序中才能检查返回值，因为在前处理程序中，你所挂钩的系统调用尚未发生。
- en: If bytes were received, then you need to parse the `args` array to access the
    `recv` or `recvfrom` argument and find the address of the receive buffer. The
    `args` array contains the arguments in the same order as the socket function corresponding
    to the `call` type. For `recv` and `recvfrom`, that means `args[0]` contains the
    socket file descriptor number ➎, and `args[1]` contains the receive buffer address
    ➏. The rest of the arguments aren’t needed here, so `post_socketcall_hook` doesn’t
    parse them. Given the receive buffer address and the `socketcall` return value
    (which indicates the number of received bytes ➐), `post_socketcall_hook` can now
    taint all the received bytes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '如果接收到字节，那么你需要解析`args`数组以访问`recv`或`recvfrom`参数，并找到接收缓冲区的地址。`args`数组按照与对应的`call`类型的套接字函数相同的顺序排列。对于`recv`和`recvfrom`来说，这意味着`args[0]`包含套接字文件描述符号
    ➎，而`args[1]`包含接收缓冲区的地址 ➏。其他参数在这里不需要，因此`post_socketcall_hook`不解析它们。根据接收缓冲区的地址和`socketcall`的返回值（它表示接收到的字节数
    ➐），`post_socketcall_hook`现在可以标记所有接收的字节。  '
- en: After some diagnostic prints of the received bytes, `post_socketcall_hook` finally
    taints the received bytes by calling `tagmap_setn` ➑, a `libdft` function that
    can taint an arbitrary number of bytes at once. It takes a `uintptr_t` representing
    a memory address as its first parameter, which is the first address that will
    be tainted. The next parameter is a `size_t` that specifies the number of bytes
    to taint and then a `uint8_t` containing the taint color. In this case, I’ve set
    the taint color to `0x01`. Now, all the received bytes are tainted, so if they
    ever influence any of `execve`’s inputs, `dta-execve` will notice and raise an
    alert.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些诊断打印接收到的字节后，`post_socketcall_hook`最终通过调用`tagmap_setn` ➑来污染接收到的字节，`tagmap_setn`是一个可以一次污染任意数量字节的`libdft`函数。它的第一个参数是表示内存地址的`uintptr_t`，即将被污染的第一个地址。下一个参数是一个`size_t`，表示要污染的字节数，然后是一个包含污染颜色的`uint8_t`。在这个例子中，我将污染颜色设置为`0x01`。现在，所有接收到的字节都被污染了，因此如果它们影响了`execve`的任何输入，`dta-execve`将会察觉并发出警报。
- en: To taint only a small fixed number of bytes, `libdft` also provides functions
    called `tagmap_setb`, `tagmap_setw`, and `tagmap_setl`, which taint one, two,
    or four consecutive bytes, respectively. These have arguments equivalent to `tagmap_setn`,
    except that they omit the length parameter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了只污染少量固定字节，`libdft`还提供了名为`tagmap_setb`、`tagmap_setw`和`tagmap_setl`的函数，分别污染一个、两个或四个连续字节。这些函数的参数与`tagmap_setn`相同，只是省略了长度参数。
- en: '*11.2.3 Taint Sinks: Checking execve Arguments*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.2.3 污染汇聚点：检查execve参数*'
- en: Finally, let’s take a look at `pre_execve_hook`, the syscall hook that runs
    just before every `execve` and makes sure the `execve` inputs aren’t tainted.
    [Listing 11-4](ch11.xhtml#ch11list4) shows the code of `pre_execve_hook`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看一下`pre_execve_hook`，它是一个系统调用钩子，在每次`execve`调用之前运行，并确保`execve`的输入未被污染。[清单
    11-4](ch11.xhtml#ch11list4)展示了`pre_execve_hook`的代码。
- en: '*Listing 11-4:* dta-execve.cpp *(continued)*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-4:* dta-execve.cpp *(续)*'
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first thing `pre_execve_hook` does is parse the inputs of the `execve` from
    its `ctx` parameter. These inputs are the filename of the program the `execve`
    is about to run ➊ and then the argument array ➋ and environment array ➌ passed
    to `execve`. If any of these inputs are tainted, `pre_execve_hook` will raise
    an alert.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`pre_execve_hook`的第一步是解析来自`ctx`参数的`execve`输入。这些输入包括`execve`即将运行的程序的文件名 ➊，然后是传递给`execve`的参数数组
    ➋ 和环境数组 ➌。如果这些输入中的任何一个被污染，`pre_execve_hook`将会发出警报。'
- en: To check each input for taint, `pre_execve_hook` uses the `check_string_taint`
    function I previously described in [Listing 11-2](ch11.xhtml#ch11list2). First,
    it uses this function to verify that the `execve` filename parameter is untainted
    ➍. Subsequently, it loops over all the `execve` arguments ➎ and checks each of
    these for taint ➏. Finally, `pre_execve_hook` loops over the environment array
    ➐ and checks that each environment parameter is untainted ➑. If none of the inputs
    is tainted, `pre_execve_hook` runs to completion, and the `execve` syscall proceeds
    without any alert. On the other hand, if any tainted input is found, then the
    program is aborted, and an error message is printed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查每个输入是否被污染，`pre_execve_hook`使用了我在[清单 11-2](ch11.xhtml#ch11list2)中之前描述的`check_string_taint`函数。首先，它使用这个函数来验证`execve`的文件名参数是否未被污染
    ➍。随后，它会遍历所有`execve`的参数 ➎，并检查每个参数是否被污染 ➏。最后，`pre_execve_hook`遍历环境数组 ➐，并检查每个环境参数是否未被污染
    ➑。如果没有输入被污染，`pre_execve_hook`将正常执行，`execve`系统调用将继续进行且不触发任何警报。另一方面，如果发现任何污染的输入，程序将被中止，并打印错误信息。
- en: That’s all of the code in the `dta-execve` tool! As you can see, `libdft` allows
    you to implement DTA tools in a concise way. In this case, the example tool consists
    of only 165 lines of code, including all comments and diagnostic prints. Now that
    you’ve explored all of `dta-execve`’s code, let’s test how well it can detect
    attacks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`dta-execve`工具中的全部代码！如你所见，`libdft`使得你能够简洁地实现DTA工具。在这个例子中，该工具仅由165行代码组成，包括所有注释和诊断打印。现在你已经浏览了`dta-execve`的所有代码，让我们测试它检测攻击的能力。
- en: '*11.2.4 Detecting a Control-Flow Hijacking Attempt*'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.2.4 检测控制流劫持尝试*'
- en: To test `dta-execve`’s ability to detect network-borne control-hijacking attacks,
    I’ll use a test program called `execve-test-overflow`. [Listing 11-5](ch11.xhtml#ch11list5)
    shows the first part of its source, containing the `main` function. To save space,
    I omit error-checking code and unimportant functions in the listings of the test
    programs. As usual, you can find the full programs on the VM.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`dta-execve`检测网络控制劫持攻击的能力，我将使用一个名为`execve-test-overflow`的测试程序。[清单 11-5](ch11.xhtml#ch11list5)展示了其源代码的第一部分，其中包含了`main`函数。为了节省空间，我在测试程序的清单中省略了错误检查代码和不重要的函数。和往常一样，完整的程序可以在虚拟机中找到。
- en: '*Listing 11-5:* execve-test-overflow.c'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5:* execve-test-overflow.c'
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `execve-test-overflow` is a simple server program that opens
    a network socket (using the `open_socket` function omitted from the listing) and
    listens on `localhost` at port 9999 ➊. Next, it receives a message from the socket
    ➋ and passes that message to a function called `exec_cmd` ➌. As I’ll explain in
    the next listing, `exec_cmd` is a vulnerable function that executes a command
    using `execv` and can be influenced by an attacker who sends a malicious message
    to the server. When `exec_cmd` completes, it returns a file descriptor that the
    server uses to read the output of the executed command ➍. Finally, the server
    writes the command output to the network socket ➎.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`execve-test-overflow`是一个简单的服务器程序，它打开一个网络套接字（使用清单中省略的`open_socket`函数），并在`localhost`上的9999端口监听➊。接下来，它从套接字接收一条消息➋，并将该消息传递给一个名为`exec_cmd`的函数➌。正如我在下一个清单中将解释的那样，`exec_cmd`是一个脆弱的函数，它使用`execv`执行命令，并且可以受到攻击者通过向服务器发送恶意消息的影响。当`exec_cmd`完成时，它返回一个文件描述符，服务器使用该描述符读取已执行命令的输出➍。最后，服务器将命令输出写入网络套接字➎。
- en: Normally, the `exec_cmd` function executes a program called `date` to get the
    current time and date, and the server then echoes this output over the network,
    prefixing it with the message previously received from the socket. However, `exec_cmd`
    contains a vulnerability that allows attackers to run a command of their choosing,
    as shown in [Listing 11-6](ch11.xhtml#ch11list6).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`exec_cmd`函数会执行一个名为`date`的程序来获取当前的时间和日期，然后服务器会将该输出通过网络回显，并在前面加上之前从套接字接收到的消息。然而，`exec_cmd`存在一个漏洞，允许攻击者执行他们选择的命令，正如[清单
    11-6](ch11.xhtml#ch11list6)所示。
- en: '*Listing 11-6:* execve-test-overflow.c *(continued)*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-6:* execve-test-overflow.c *(续)*'
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The server uses a global `struct` called `cmd` to keep track of the command
    and its associated parameters ➊. It contains a `prefix` for the command output
    (the message previously received from the socket) ➋, as well as a date format
    string and a buffer containing the `date` command itself. While Linux comes with
    a default `date` utility, I’ve implemented my own for this test, which you’ll
    find in *~/code/chapter11/date*. This is necessary because the default `date`
    utility on the VM is 64-bit, which `libdft` does not support.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用一个全局`struct`，名为`cmd`，来跟踪命令及其相关参数➊。它包含一个用于命令输出的`prefix`（之前从套接字接收到的消息）➋，以及一个日期格式字符串和一个包含`date`命令本身的缓冲区。虽然Linux自带默认的`date`工具，但为了测试，我实现了我自己的`date`工具，你可以在*~/code/chapter11/date*中找到它。这是必要的，因为虚拟机上的默认`date`工具是64位的，而`libdft`不支持它。
- en: Now let’s take a look at the `exec_cmd` function, which begins by copying the
    message received from the network (stored in `buf`) into `cmd`’s `prefix` field
    ➌. As you can see, the copy lacks proper bound checks, which means attackers could
    send a malicious message that would overflow `prefix`, allowing them to overwrite
    the adjacent fields in `cmd`, containing the date format and the command path.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看`exec_cmd`函数，该函数首先将从网络接收到的消息（存储在`buf`中）复制到`cmd`的`prefix`字段中➌。正如你所看到的，这个复制操作缺乏适当的边界检查，这意味着攻击者可以发送恶意消息，导致`prefix`溢出，从而覆盖`cmd`中相邻的字段，这些字段包含日期格式和命令路径。
- en: Next, `exec_cmd` copies the command and date format argument from the `cmd`
    structure into an `argv` array to use for the `execv` ➍. Then, it opens a pipe
    ➎ and uses `fork` ➏ to start a child process ➐, which will execute the command
    and report the output to the parent process. The child process redirects `stdout`
    over the pipe ➑ so that the parent process can read the `execv` output from the
    pipe and forward it over the socket. Finally, the child calls the `execv` with
    the possibly attacker-controlled command and arguments as input ➒.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`exec_cmd`将命令和日期格式参数从`cmd`结构体复制到`argv`数组中，以供`execv` ➍使用。然后，它打开一个管道 ➎ 并使用`fork`
    ➏启动一个子进程 ➐，该子进程将执行命令并将输出报告给父进程。子进程通过管道重定向`stdout` ➑，这样父进程就可以从管道中读取`execv`的输出，并通过套接字转发。最后，子进程调用`execv`，将可能由攻击者控制的命令和参数作为输入
    ➒。
- en: Let’s now run `execve-test-overflow` to see how an attacker can abuse the `prefix`
    overflow vulnerability to hijack control in practice. I’ll first run it without
    the protection of the `dta-execve` tool so that you can see the attack succeed.
    After that, I’ll enable `dta-execve` so you can see how it detects and stops the
    attack.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行`execve-test-overflow`，看看攻击者如何利用`prefix`溢出漏洞来劫持控制。我将首先在没有`dta-execve`工具保护的情况下运行它，这样你可以看到攻击的成功。之后，我会启用`dta-execve`，让你看到它如何检测并阻止攻击。
- en: A Successful Control Hijack Without DTA
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无DTA的成功控制劫持
- en: '[Listing 11-7](ch11.xhtml#ch11list7) shows a benign run of `execve-test-overflow`,
    followed by an example of how to exploit the buffer overflow to execute a command
    of the attacker’s choice instead of `date`. I’ve replaced some repetitive parts
    of the output with “...” to keep the code lines from becoming too wide.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-7](ch11.xhtml#ch11list7)展示了`execve-test-overflow`的正常运行，接着是如何利用缓冲区溢出来执行攻击者选择的命令而不是`date`的示例。我已将一些重复的输出部分替换为“...”，以避免代码行过宽。'
- en: '*Listing 11-7: Control hijacking in* execve-test-overflow'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-7：在* execve-test-overflow 中的控制劫持'
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the benign run, I start the `execve-test-overflow` server as a background
    process ➊ and then use `netcat` (`nc`) to connect to the server ➋. In `nc`, I
    enter the string “`foobar:` ” ➌ and send it to the server, which will use it as
    the output prefix. The server runs the `date` command and echoes back the current
    date, prefixed with “`foobar:` ” ➍.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正常运行，我将`execve-test-overflow`服务器作为后台进程启动 ➊，然后使用`netcat`（`nc`）连接到服务器 ➋。在`nc`中，我输入字符串“`foobar:`
    ” ➌ 并将其发送到服务器，服务器将使用它作为输出前缀。服务器运行`date`命令，并将当前日期回显，前缀为“`foobar:` ” ➍。
- en: 'Now to demonstrate the buffer overflow vulnerability, I restart the server
    ➎ and connect to it again with `nc` ➏. This time, the string I send is much longer
    ➐, long enough to overflow the `prefix` field in the global `cmd` structure. It
    consists of 32 `A`s to fill up the 32-byte `prefix` buffer, followed by 32 `B`s,
    which overflow into the `datefmt` buffer and again fill it up completely. The
    last part of the string overflows into the `cmd` buffer, and it’s a path to the
    program to run instead of `date`, namely, *~/code/chapter11/echo*. At this point,
    the contents of the global `cmd` struct look as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了演示缓冲区溢出漏洞，我重新启动服务器 ➎ 并使用`nc` ➏再次连接。此次，我发送的字符串要长得多 ➐，足以溢出全局`cmd`结构中的`prefix`字段。它由32个`A`组成，填满32字节的`prefix`缓冲区，后面跟着32个`B`，溢出到`datefmt`缓冲区并将其填满。字符串的最后一部分溢出到`cmd`缓冲区，并且它是一个程序路径，用来替代`date`执行，即
    *~/code/chapter11/echo*。此时，全局`cmd`结构的内容如下：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Recall that the server copies the contents of the `cmd` structure into the `argv`
    array used for the `execv`. Thus, as a result of the overflow, the `execv` runs
    the `echo` program instead of `date`! The `datefmt` buffer is passed to `echo`
    as a command line argument, but because it doesn’t contain a terminating `NULL`,
    the real command line argument that `echo` sees is `datefmt` concatenated with
    the `cmd` buffer. Finally, after running `echo`, the server writes the output
    back to the socket ➑, which consists of the concatenation of `prefix`, `datefmt`,
    and `cmd` as the prefix, followed by the output of the `echo` command.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，服务器将`cmd`结构的内容复制到`argv`数组中，以供`execv`使用。因此，由于溢出，`execv`运行了`echo`程序，而不是`date`！`datefmt`缓冲区作为命令行参数传递给`echo`，但由于它没有包含终止的`NULL`，`echo`看到的真实命令行参数是`datefmt`与`cmd`缓冲区拼接起来的结果。最后，运行完`echo`后，服务器将输出写回到套接字
    ➑，其内容是`prefix`、`datefmt`和`cmd`的拼接作为前缀，后面跟着`echo`命令的输出。
- en: Now that you know how to coax the `execve-test-overflow` program into executing
    an unintended command by supplying it with a malicious input from the network,
    let’s see whether the `dta-execve` tool will succeed in stopping this attack!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何通过向`execve-test-overflow`程序提供来自网络的恶意输入来诱使它执行一个非预期的命令，让我们看看`dta-execve`工具能否成功阻止这个攻击！
- en: Using DTA to Detect the Hijacking Attempt
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用DTA检测劫持尝试
- en: To test whether `dta-execve` can stop the attack in the previous section, I’ll
    run the same attack again. Only this time, `execve-test-overflow` will be protected
    by the `dta-execve` tool. [Listing 11-8](ch11.xhtml#ch11list8) shows the results.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`dta-execve`是否能阻止上一节中的攻击，我将再次运行相同的攻击。只是这次，`execve-test-overflow`将由`dta-execve`工具保护。[列表
    11-8](ch11.xhtml#ch11list8)显示了结果。
- en: '*Listing 11-8: Detecting an attempted control hijack with* dta-execve'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-8：使用* dta-execve *检测控制劫持尝试*'
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because `libdft` is based on Pin, you’ll need to run Pin using `dta-execve`
    as the Pin tool ➊ to protect `execve-test-overflow` with `dta-execve`. As you
    can see, I’ve added `-follow_execv` to the Pin options so that Pin will instrument
    all child processes of `execve-test-overflow` the same way as the parent process.
    This is important because the vulnerable `execv` is called in a child process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`libdft`是基于Pin的，所以你需要使用`dta-execve`作为Pin工具➊来保护`execve-test-overflow`，并使用`dta-execve`。如你所见，我已经在Pin选项中添加了`-follow_execv`，这样Pin就会像父进程一样对`execve-test-overflow`的所有子进程进行插桩。这一点非常重要，因为易受攻击的`execv`是在子进程中调用的。
- en: After starting the `execve-test-overflow` server protected with `dta-execve`,
    I run `nc` again to connect to the server ➋. Then, I send the same exploit string
    used in the previous section ➌ to overflow the `prefix` buffer and change the
    `cmd`. Keep in mind that `dta-execve` uses network receives as taint sources.
    You can see this in [Listing 11-8](ch11.xhtml#ch11list8) because the `socketcall`
    handler prints a diagnostic message showing that it has intercepted the received
    message ➍. The `socketcall` handler then taints all the bytes received from the
    network ➎.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动了保护的`execve-test-overflow`服务器并使用`dta-execve`后，我再次运行`nc`连接到服务器➋。然后，我发送与上一节中相同的利用字符串➌，溢出`prefix`缓冲区并更改`cmd`。请记住，`dta-execve`使用网络接收作为污点源。你可以在[列表
    11-8](ch11.xhtml#ch11list8)中看到这一点，因为`socketcall`处理程序打印了一个诊断消息，显示它已拦截接收到的消息 ➍。然后，`socketcall`处理程序会将从网络接收到的所有字节标记为污点
    ➎。
- en: Next, a diagnostic print from the server tells you that it’s about to execute
    the attacker-controlled `echo` command ➏. Fortunately, this time `dta-execve`
    intercepts the `execv` before it’s too late ➐. It checks the taint on all of the
    `execv` arguments, starting with the `execv` command ➑. Since this command is
    controlled by the attacker via the network-borne buffer overflow, `dta-execve`
    notices that the command is tainted with color `0x01`. It raises an alert and
    then stops the child process that’s about to execute the attacker’s command, thereby
    successfully preventing the attack ➒. The only server output that’s written back
    to the attacker is the prefix string they themselves supplied ➓, since it was
    printed before the `execv` that caused `dta-execve` to abort the child process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，服务器的诊断打印告诉你，它即将执行攻击者控制的`echo`命令 ➏。幸运的是，这次`dta-execve`在为时已晚之前拦截了`execv` ➐。它检查所有`execv`参数的污点，从`execv`命令开始
    ➑。由于该命令是通过网络传输的缓冲区溢出由攻击者控制的，`dta-execve`注意到该命令被污点标记为颜色`0x01`。它发出警报并停止了即将执行攻击者命令的子进程，从而成功阻止了攻击
    ➒。唯一回写给攻击者的服务器输出是他们自己提供的前缀字符串 ➓，因为它是在`execv`之前打印的，而`execv`导致`dta-execve`中止子进程。
- en: 11.3 Circumventing DTA with Implicit Flows
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3 绕过DTA的隐式流
- en: 'So far so good: `dta-execve` successfully detected and stopped the control-hijacking
    attack from the previous section. Unfortunately, `dta-execve` is not entirely
    foolproof because practical DTA systems like `libdft` can’t track data propagated
    through *implicit flows*. [Listing 11-9](ch11.xhtml#ch11list9) shows a modified
    version of the `execve-test-overflow` server, which contains an implicit flow
    that prevents `dta-execve` from detecting the attack. For brevity, the listing
    shows only the parts of the code that are different from the original server.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利：`dta-execve`成功检测并阻止了上一节中的控制劫持攻击。不幸的是，`dta-execve`并不是万无一失的，因为像`libdft`这样的实际DTA系统无法跟踪通过*隐式流*传播的数据。[列表
    11-9](ch11.xhtml#ch11list9)展示了修改后的`execve-test-overflow`服务器，其中包含一个隐式流，使得`dta-execve`无法检测到攻击。为了简洁起见，列表仅显示与原始服务器不同的代码部分。
- en: '*Listing 11-9:* execve-test-overflow-implicit.c'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-9:* execve-test-overflow-implicit.c'
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only changed parts of the code are in the `exec_cmd` function, which contains
    a vulnerable `for` loop that copies all of the bytes from the receive buffer `buf`
    into the global `prefix` buffer ➊. As before, the loop lacks bounds checking,
    so `prefix` will overflow if the message in `buf` is too long. Now, however, the
    bytes are copied *implicitly* in such a way that the overflow isn’t detected by
    the DTA tool!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中唯一修改的部分是`exec_cmd`函数，它包含一个易受攻击的`for`循环，将接收缓冲区`buf`中的所有字节复制到全局`prefix`缓冲区
    ➊。与之前一样，该循环没有边界检查，因此如果`buf`中的消息过长，`prefix`将溢出。然而，现在字节是*隐式*复制的，以至于溢出没有被DTA工具检测到！
- en: As explained in [Chapter 10](ch10.xhtml#ch10), implicit flows are the result
    of *control dependencies*, meaning that the data propagation depends on control
    structures instead of explicit data operations. In [Listing 11-9](ch11.xhtml#ch11list9),
    that control structure is a `while` loop. For each byte, the modified `exec_cmd`
    function initializes a `char c` to zero ➋ and then uses the `while` loop to increment
    `c` until it has the same value as `buf[i]` ➌, effectively copying `buf[i]` into
    `c` without ever explicitly copying any data. Finally, `c` is copied into `prefix`
    ➍.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第10章](ch10.xhtml#ch10)中所解释的那样，隐式流是*控制依赖性*的结果，这意味着数据传播依赖于控制结构，而不是显式的数据操作。在[清单
    11-9](ch11.xhtml#ch11list9)中，控制结构是一个`while`循环。对于每个字节，修改后的`exec_cmd`函数将`char c`初始化为零
    ➋，然后使用`while`循环递增`c`，直到它的值与`buf[i]`相同 ➌，从而有效地将`buf[i]`复制到`c`中，而从未显式地复制任何数据。最后，`c`被复制到`prefix`中
    ➍。
- en: 'Ultimately, the effect of this code is the same as in the original version
    of `execve-test-overflow`: `buf` is copied into `prefix`. However, the key is
    that *there’s no explicit data flow between* `*buf*` *and* *`prefix`* because
    the copy from `buf[i]` into `c` is implemented using that `while` loop, avoiding
    an explicit data copy. This introduces a control dependency between `buf[i]` and
    `c` (and thus, transitively, between `buf[i]` and `prefix[i]`), which `libdft`
    cannot track.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这段代码的效果与原版的`execve-test-overflow`相同：`buf`被复制到`prefix`中。然而，关键在于*`buf`*与*`prefix`*之间*没有显式的数据流*，因为从`buf[i]`到`c`的复制是通过`while`循环实现的，避免了显式的数据复制。这引入了`buf[i]`和`c`之间的控制依赖关系（因此，传递性地也在`buf[i]`和`prefix[i]`之间），而`libdft`无法追踪这种依赖关系。
- en: When you retry [Listing 11-8](ch11.xhtml#ch11list8)’s attack by replacing `execve-test-overflow`
    with `execve-test-overflow-implicit`, you’ll see that the attack now succeeds
    despite `dta-execve`’s protection!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过将`execve-test-overflow`替换为`execve-test-overflow-implicit`来重试[清单 11-8](ch11.xhtml#ch11list8)中的攻击时，你会发现尽管`dta-execve`提供了保护，攻击现在仍然会成功！
- en: You may remark that if you’re using DTA to prevent attacks against a server
    that you control, you can just write the server in such a way that it doesn’t
    contain implicit flows that confuse `libdft`. While this may be possible (though
    not trivial) in most cases, in malware analysis you’ll find it difficult to get
    around the problem of implicit flows, because you don’t control the malware’s
    code and the malware may contain deliberately crafted implicit flows to confuse
    taint analysis.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，如果你使用DTA来防止针对你控制的服务器的攻击，你可以通过编写服务器代码，避免那些会混淆`libdft`的隐式流。虽然在大多数情况下这可能是可行的（尽管不简单），但在恶意软件分析中，你会发现很难绕过隐式流的问题，因为你无法控制恶意软件的代码，而恶意软件可能故意包含隐式流来混淆污点分析。
- en: 11.4 A DTA-Based Data Exfiltration Detector
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4 基于DTA的数据外泄检测器
- en: The previous example tool requires only a single taint color because bytes are
    either attacker controlled or not. Now let’s build a tool that uses multiple taint
    colors to detect file-based information leaks so that when a file leaks, you can
    tell *which* file. The idea behind this tool is similar to the taint-based defense
    against the Heartbleed bug you saw in [Chapter 10](ch10.xhtml#ch10), except that
    here the tool uses file reads instead of memory buffers as the taint source.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例工具只需要一个污点颜色，因为字节要么由攻击者控制，要么不由攻击者控制。现在让我们构建一个使用多个污点颜色来检测基于文件的信息泄露的工具，这样当文件发生泄漏时，你就能知道*是哪一个*文件。这个工具的思路与[第10章](ch10.xhtml#ch10)中你看到的针对Heartbleed漏洞的污点防御类似，不同之处在于这里的工具使用文件读取而不是内存缓冲区作为污点源。
- en: '[Listing 11-10](ch11.xhtml#ch11list10) shows the first part of this new tool,
    which I’ll call `dta -dataleak`. Again, I omit includes of standard C header files
    for brevity.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-10](ch11.xhtml#ch11list10)展示了这个新工具的第一部分，我将其称为`dta -dataleak`。为了简洁起见，我省略了标准C头文件的包含。'
- en: '*Listing 11-10:* dta-dataleak.cpp'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-10:* dta-dataleak.cpp'
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just as in the previous DTA tool, `dta-dataleak` includes *pin.H* and all the
    relevant `libdft` header files ➊. It also includes the now familiar `extern` declaration
    of the `syscall_desc` array ➋ to hook syscalls for the taint sources and sinks.
    In addition, `dta-dataleak` defines some data structures that weren’t there in
    `dta-execve`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个DTA工具相同，`dta-dataleak`包含了*pin.H*以及所有相关的`libdft`头文件➊。它还包括现在熟悉的`extern`声明的`syscall_desc`数组➋，用于钩住污点源和污点接收点的系统调用。此外，`dta-dataleak`定义了一些在`dta-execve`中没有的数据结构。
- en: The first of these, `fd2color`, is a C++ `map` that maps file descriptors to
    taint colors ➌. The second is also a C++ map, called `color2fname`, and it maps
    taint colors to filenames ➍. You’ll see why these data structures are needed in
    the next few listings.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第一个，`fd2color`，是一个C++ `map`，将文件描述符映射到污点颜色➌。第二个也是一个C++ `map`，名为`color2fname`，它将污点颜色映射到文件名➍。你将在接下来的几个列表中看到为什么需要这些数据结构。
- en: There’s also a `#define` of a constant called `MAX_COLOR` ➎, which is the maximum
    possible taint color value, `0x80`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个常量的`#define`，名为`MAX_COLOR` ➎，它是最大可能的污点颜色值`0x80`。
- en: The `main` function of `dta-dataleak` is almost identical to that of `dta-execve`
    in that it initializes Pin and `libdft` and then starts the application. The only
    difference is in which taint sources and sinks `dta-dataleak` defines. It installs
    two post-handlers, called `post_open_hook` ➏ and `post_read_hook` ➐, which run
    just after the `open` and `read` syscalls, respectively. The `open` hook keeps
    track of which file descriptors are open, while the `read` hook is the actual
    taint source, which taints bytes read from open files, as I’ll explain in a moment.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`dta-dataleak`的`main`函数几乎与`dta-execve`的`main`函数完全相同，它初始化了Pin和`libdft`，然后启动应用程序。唯一的区别是`dta-dataleak`定义了哪些污点源和污点接收点。它安装了两个后处理钩子，分别是`post_open_hook`
    ➏和`post_read_hook` ➐，它们分别在`open`和`read`系统调用后运行。`open`钩子跟踪哪些文件描述符被打开，而`read`钩子则是实际的污点源，它会污点化从打开文件中读取的字节，稍后我将解释。'
- en: In addition, `dta-dataleak` installs a pre-handler for the `socketcall` syscall,
    called `pre_socketcall_hook` ➑. The `pre_socketcall_hook` is the taint sink, which
    intercepts any data that’s about to be sent over the network so that it can make
    sure the data isn’t tainted before allowing the send. If any tainted data is about
    to be leaked, `pre_socketcall_hook` raises an alert, using a function called `alert`,
    which I’ll explain next.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`dta-dataleak`还为`socketcall`系统调用安装了一个预处理钩子，名为`pre_socketcall_hook` ➑。`pre_socketcall_hook`是污点接收点，它拦截即将通过网络发送的任何数据，以确保在发送之前数据没有被污点化。如果任何污点数据即将泄露，`pre_socketcall_hook`会通过一个名为`alert`的函数触发警报，接下来我会解释该函数。
- en: Keep in mind that this example tool is simplified. In a real tool, you’ll want
    to hook additional taint sources (such as the `readv` syscall) and sinks (such
    as `write` syscalls on a socket) for completeness. You’ll also want to implement
    some rules that determine which files are okay to leak over the network and which
    aren’t, rather than assuming all file leaks are malicious.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个示例工具是简化的。在实际工具中，你可能需要钩住额外的污点源（如`readv`系统调用）和污点接收点（如在套接字上的`write`系统调用）以确保完整性。你还需要实现一些规则，来确定哪些文件可以通过网络泄露，哪些不能，而不是假设所有文件泄露都是恶意的。
- en: Now let’s take a look at the `alert` function, shown in [Listing 11-11](ch11.xhtml#ch11list11),
    which is called if any tainted data is about to leak over the network. Because
    it’s similar to `dta-execve`’s `alert` function, I’ll describe it only briefly
    here.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`alert`函数，它在[Listing 11-11](ch11.xhtml#ch11list11)中展示，当任何污点数据即将通过网络泄露时会调用该函数。由于它与`dta-execve`中的`alert`函数相似，我将在这里简要描述。
- en: '*Listing 11-11:* dta-dataleak.cpp *(continued)*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-11:* dta-dataleak.cpp *(续)*'
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `alert` function starts by displaying an alert message, detailing which
    address is tainted and with which colors ➊. It’s possible that the data leaked
    over the network is influenced by multiple files and therefore tainted with multiple
    colors. So, `alert` loops over all possible taint colors ➋ and checks which of
    them are present in the tag of the tainted byte that caused the alert ➌. For each
    color that’s enabled in the tag, `alert` prints the color and the corresponding
    filename ➍, which it reads from the `color2fname` data structure. Finally, `alert`
    calls `exit` to stop the application and prevent the data leak ➎.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert` 函数通过显示警告信息开始，详细说明哪个地址被污染，以及使用了哪些颜色 ➊。有可能通过网络泄漏的数据受到多个文件的影响，因此被多个颜色污染。因此，`alert`
    会遍历所有可能的污染颜色 ➋，并检查哪些颜色存在于导致警告的被污染字节的标签中 ➌。对于标签中启用的每个颜色，`alert` 会打印颜色和相应的文件名 ➍，这些信息是从
    `color2fname` 数据结构中读取的。最后，`alert` 调用 `exit` 以停止应用程序并防止数据泄漏 ➎。'
- en: Next, let’s examine the taint sources for the `dta-dataleak` tool.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来查看 `dta-dataleak` 工具的污染源。
- en: '*11.4.1 Taint Sources: Tracking Taint for Open Files*'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.4.1 污染源：跟踪已打开文件的污染*'
- en: 'As I just mentioned, `dta-dataleak` installs two syscall post-handlers: a hook
    for the `open` syscall that keeps track of open files and a hook for `read` that
    taints bytes read from open files. Let’s first look at the code for the `open`
    hook and then look at the `read` handler.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我刚刚提到的，`dta-dataleak` 安装了两个系统调用后处理程序：一个用于 `open` 系统调用的钩子，用于跟踪已打开的文件，另一个用于
    `read` 系统调用的钩子，用于污染从打开的文件中读取的字节。我们首先来看 `open` 钩子的代码，然后再看 `read` 处理程序。
- en: Tracking Open Files
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪已打开的文件
- en: '[Listing 11-12](ch11.xhtml#ch11list12) shows the code for `post_open_hook`,
    the post-handler for the `open` syscall.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-12](ch11.xhtml#ch11list12) 显示了 `post_open_hook` 的代码，这是 `open` 系统调用的后处理函数。'
- en: '*Listing 11-12:* dta-dataleak.cpp *(continued)*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-12:* dta-dataleak.cpp *(续)*'
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Recall that the purpose of `dta-dataleak` is to detect information leak attempts
    that leak data read from a file. For `dta-dataleak` to tell *which* file is being
    leaked, it assigns a different color to each open file. The purpose of the `open`
    syscall handler, `post_open_hook`, is to assign a taint color to each file descriptor
    when it’s opened. It also filters out some uninteresting files, such as shared
    libraries. In a real-world DTA tool, you’ll likely want to implement more filters
    to control which files to protect against information leaks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，`dta-dataleak` 的目的是检测泄漏从文件中读取的数据的泄漏尝试。为了让 `dta-dataleak` 能够告诉 *哪个* 文件正在泄漏，它为每个已打开的文件分配一个不同的颜色。`open`
    系统调用处理程序 `post_open_hook` 的目的是在文件打开时为每个文件描述符分配一个污染颜色。它还会过滤掉一些不感兴趣的文件，例如共享库。在实际的
    DTA 工具中，你可能需要实现更多的过滤器来控制保护哪些文件免受信息泄漏。
- en: To keep track of the next available taint color, `post_open_hook` uses a `static`
    variable called `next_color`, which is initialized to the color `0x01` ➊. Next,
    it parses the syscall context (`ctx`) of the `open` syscall that just occurred
    to obtain the file descriptor `fd` ➋ and the filename `fname` ➌ of the just opened
    file. If the `open` failed ➍ or the opened file is a shared library that’s not
    interesting to track ➎, `post_open_hook` returns without assigning any color to
    the file. To determine whether the file is a shared library, `post_open_hook`
    simply checks whether the filename contains a file extension indicative of a shared
    library, such as *.so*. In a real tool, you’ll want to use more robust checks
    by opening a suspected shared library and verifying that it starts with the ELF
    magic bytes, for instance (see also [Chapter 2](ch02.xhtml#ch02)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪下一个可用的污染颜色，`post_open_hook` 使用一个名为 `next_color` 的 `static` 变量，该变量初始化为颜色
    `0x01` ➊。接下来，它解析刚刚发生的 `open` 系统调用的系统调用上下文（`ctx`），以获取文件描述符 `fd` ➋ 和刚打开文件的文件名 `fname`
    ➌。 如果 `open` 失败 ➍ 或者打开的文件是一个不需要跟踪的共享库 ➎，`post_open_hook` 会返回并且不会为该文件分配任何颜色。要确定文件是否是共享库，`post_open_hook`
    会检查文件名是否包含表示共享库的文件扩展名，如 *.so*。在实际工具中，你可能需要使用更强大的检查方式，比如打开一个疑似共享库并验证它是否以 ELF 魔术字节开头（参见
    [第 2 章](ch02.xhtml#ch02)）。
- en: 'If the file is interesting enough to assign it a taint color, `post_open_hook`
    distinguishes two cases:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件足够重要以分配污染颜色，`post_open_hook` 会区分两种情况：
- en: If there is no color assigned to the file descriptor yet (in other words, there
    is no entry for `fd` in the `fd2color` map), then `post_open_hook` assigns `next_color`
    to this file descriptor ➏ and advances `next_color` by shifting it left by 1 bit.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件描述符尚未分配颜色（换句话说，`fd` 在 `fd2color` 映射中没有条目），则 `post_open_hook` 会将 `next_color`
    分配给该文件描述符 ➏，并通过将其左移 1 位来推进 `next_color`。
- en: Note that since `libdft` supports only eight colors, you might run out of colors
    if the application opens too many files. Therefore, `post_open_hook` advances
    `next_color` only until it reaches the maximum color `0x80` ➐. After that, the
    color `0x80` will be used for all subsequently opened files. What this means in
    practice is that the color `0x80` might correspond not just to one file but to
    a whole list of files. Thus, when a byte with color `0x80` leaks, you might not
    know exactly which file the byte came from, only that it’s from one of the files
    in the list. Unfortunately, that’s the price you have to pay for keeping the shadow
    memory small by supporting only eight colors.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，由于`libdft`仅支持八种颜色，如果应用程序打开了过多文件，可能会用完所有颜色。因此，`post_open_hook`仅在`next_color`达到最大颜色`0x80`
    ➐之前推进颜色的使用。之后，颜色`0x80`将用于所有随后打开的文件。实际上，这意味着颜色`0x80`可能不仅仅对应一个文件，而是对应一个文件列表。因此，当一个带有颜色`0x80`的字节泄露时，你可能无法确切知道该字节来自哪个文件，只知道它来自列表中的某个文件。不幸的是，这是为了通过仅支持八种颜色来保持影子内存小而必须付出的代价。
- en: Sometimes a file descriptor is closed at some point, and then the same file
    descriptor number is reused to open another file. In that case, `fd2color` will
    already contain an assigned color for that file descriptor number ➑. To keep things
    simple, I simply reuse the existing color for the repurposed file descriptor,
    meaning that that color will now correspond to a list of files instead of just
    one, exactly as when you run out of colors.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，一个文件描述符会在某个时刻被关闭，然后同样的文件描述符编号会被重用来打开另一个文件。在这种情况下，`fd2color`已经包含了该文件描述符编号的颜色
    ➑。为了简化处理，我直接重用已存在的颜色来表示重用的文件描述符，这意味着该颜色现在将对应一个文件列表，而不仅仅是一个文件，正如你用完颜色时的情况一样。
- en: At the end of `post_open_hook`, the `color2fname` map is updated with the filename
    of the just opened file ➒. This way, when data leaks, you can use the taint color
    of the leaked data to look up the name of the corresponding file, as you just
    saw in the `alert` function. If the taint color was reused for multiple files
    because of one of these reasons, then the `color2fname` entry for that color will
    be a list of filenames separated with a pipe (|) ➓.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`post_open_hook`的末尾，`color2fname`映射会更新为刚刚打开文件的文件名 ➒。这样，当数据泄露时，你可以使用泄露数据的污点颜色查找相应文件的名称，正如你在`alert`函数中看到的那样。如果由于某些原因，污点颜色被重用于多个文件，那么该颜色在`color2fname`中的条目将是一个由管道符（|）分隔的文件名列表
    ➓。
- en: Tainting File Reads
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 污点文件读取
- en: Now that every opened file is associated with a taint color, let’s look at the
    `post_read_hook` function, which taints bytes read from a file with that file’s
    assigned color. [Listing 11-13](ch11.xhtml#ch11list13) shows the relevant code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个打开的文件都与一个污点颜色相关联，让我们来看一下`post_read_hook`函数，该函数会将从文件中读取的字节标记为该文件的颜色。[列表11-13](ch11.xhtml#ch11list13)展示了相关的代码。
- en: '*Listing 11-13:* dta-dataleak.cpp *(continued)*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-13:* dta-dataleak.cpp *(续)*'
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, `post_read_hook` parses the relevant arguments and return value from
    the syscall context to obtain the file descriptor that’s being read (`fd`) ➊,
    the buffer into which bytes are read (`buf`) ➋, and the number of bytes read (`len`)
    ➌. If `len` is less than or equal to zero, no bytes were read, so `post_read_hook`
    returns without tainting anything ➍.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`post_read_hook`解析系统调用上下文中的相关参数和返回值，以获得正在读取的文件描述符（`fd`） ➊，读取字节的缓冲区（`buf`）
    ➋，以及读取的字节数（`len`） ➌。如果`len`小于或等于零，则表示没有读取任何字节，因此`post_read_hook`将不做任何污点标记 ➍。
- en: Otherwise, it obtains `fd`’s taint color by reading it from `fd2color` ➎. If
    `fd` has an associated taint color ➏, `post_read_hook` uses `tagmap_setn` to taint
    all of the read bytes with that color ➐. It may also happen that `fd` has no associated
    color ➑, meaning that it refers to an uninteresting file such as a shared library.
    In that case, we clear any taint from the addresses overwritten by the `read`
    syscall ➒ by using the `libdft` function `tagmap_clrn`. This clears the taint
    from any previously tainted buffer that’s reused to read untainted bytes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它通过从`fd2color` ➎读取来获取`fd`的污点颜色。如果`fd`有一个关联的污点颜色 ➏，`post_read_hook`使用`tagmap_setn`将所有读取的字节标记为该颜色
    ➐。也可能发生`fd`没有关联颜色 ➑，这意味着它指向一个无关紧要的文件，如共享库。在这种情况下，我们通过使用`libdft`函数`tagmap_clrn`来清除`read`系统调用覆盖的地址上的任何污点
    ➒。这会清除任何先前被标记的缓冲区的污点，该缓冲区被重新用于读取未被标记的字节。
- en: '*11.4.2 Taint Sinks: Monitoring Network Sends for Data Exfiltration*'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.4.2 污点汇聚点：监控网络发送以防止数据外泄*'
- en: Finally, [Listing 11-14](ch11.xhtml#ch11list14) shows `dta-dataleak`’s taint
    sink, the `socketcall` handler that intercepts network sends to check them for
    data exfiltration attempts. It’s similar to the `socketcall` handler you saw in
    the `dta-execve` tool, except that it checks sent bytes for taint instead of applying
    taint to received bytes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[清单 11-14](ch11.xhtml#ch11list14) 展示了 `dta-dataleak` 的污点处理器，即拦截网络发送并检查是否有数据外泄尝试的
    `socketcall` 处理程序。它与你在 `dta-execve` 工具中看到的 `socketcall` 处理程序类似，只是它检查的是发送字节的污点，而不是对接收字节应用污点。
- en: '*Listing 11-14:* dta-dataleak.cpp *(continued)*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-14:* dta-dataleak.cpp *(续)*'
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, `pre_socketcall_hook` obtains the `call` ➊ and `args` ➋ parameters for
    the `socketcall`. It then uses a switch on `call` just like the one you saw in
    the `socketcall` handler for `dta-execve`, except that this new switch inspects
    `SYS_SEND` and `SYS_SENDTO` ➌ instead of `SYS_RECV` and `SYS_RECVFROM`. If it
    intercepts a send event, it parse the send’s arguments: the socket file descriptor,
    send buffer, and number of bytes to send ➍. After some diagnostic prints, the
    code loops over all of the bytes in the send buffer ➎ and gets each byte’s taint
    status using `tagmap_getb` ➏. If a byte is tainted, `pre_socketcall_hook` calls
    the `alert` function to print an alert and stop the application ➐.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`pre_socketcall_hook` 获取 `call` ➊ 和 `args` ➋ 参数用于 `socketcall`。然后，它对 `call`
    使用一个 switch，类似于你在 `dta-execve` 的 `socketcall` 处理程序中看到的那个，区别在于这个新的 switch 检查的是
    `SYS_SEND` 和 `SYS_SENDTO` ➌，而不是 `SYS_RECV` 和 `SYS_RECVFROM`。如果它拦截到一个发送事件，它会解析发送的参数：套接字文件描述符、发送缓冲区和要发送的字节数
    ➍。在进行一些诊断打印后，代码会遍历发送缓冲区中的所有字节 ➎，并通过 `tagmap_getb` 获取每个字节的污点状态 ➏。如果某个字节被污染，`pre_socketcall_hook`
    会调用 `alert` 函数来打印警告并停止应用程序 ➐。
- en: That covers the entire code for the `dta-dataleak` tool. In the next section,
    you’ll see how `dta-dataleak` detects a data exfiltration attempt and how taint
    colors combine when exfiltrated data depends on multiple taint sources.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了 `dta-dataleak` 工具的全部代码。在下一节中，你将看到 `dta-dataleak` 如何检测数据外泄尝试，以及当外泄数据依赖于多个污点源时，污点颜色是如何结合的。
- en: '*11.4.3 Detecting a Data Exfiltration Attempt*'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*11.4.3 检测数据外泄尝试*'
- en: To demonstrate `dta-dataleak`’s ability to detect data leaks, I’ve implemented
    another simple server called `dataleak-test-xor`. For simplicity, this server
    “leaks” tainted files to the socket voluntarily, but `dta-dataleak` can detect
    files leaked through an exploit in the same way. [Listing 11-15](ch11.xhtml#ch11list15)
    shows the relevant code for the server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 `dta-dataleak` 检测数据泄漏的能力，我实现了另一个简单的服务器，名为 `dataleak-test-xor`。为了简化起见，这个服务器“泄漏”被污染的文件到套接字，但
    `dta-dataleak` 可以以相同的方式检测通过漏洞泄漏的文件。[清单 11-15](ch11.xhtml#ch11list15) 显示了该服务器的相关代码。
- en: '*Listing 11-15:* dataleak-test-xor.c'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-15:* dataleak-test-xor.c'
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The server opens a socket on `localhost` port 9999 ➊ and uses it to receive
    a message ➋ containing a list of filenames. It splits this list into individual
    filenames using a function called `split_filenames`, which is omitted from the
    listing ➌. Next, it opens all the requested files ➍ and then chooses two of the
    opened files at random ➎. Note that in a realistic use case for `dta-dataleak`,
    the files would be accessed through an exploit rather than released voluntarily
    by the server. For the purposes of this example, the server reads the contents
    of the two randomly chosen files line by line ➏, combining each pair of lines
    (one line from each file) using an XOR operation ➐. Combining the lines will cause
    `dta-dataleak` to merge their taint colors, demonstrating taint merging for the
    purposes of this example. Finally, the result of the two XOR-ed lines is sent
    over the network ➑, providing a “data leak” for `dta-dataleak` to detect.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在 `localhost` 9999 端口上打开一个套接字 ➊ 并用它接收一个包含文件名列表的消息 ➋。它使用一个名为 `split_filenames`
    的函数将此列表分割成单个文件名，这个函数在清单中省略 ➌。接下来，它打开所有请求的文件 ➍，然后随机选择两个已打开的文件 ➎。请注意，在 `dta-dataleak`
    的实际使用场景中，文件会通过漏洞访问，而不是由服务器主动释放。为了演示这个例子，服务器逐行读取两个随机选择的文件的内容 ➏，将每对行（每个文件中的一行）通过
    XOR 操作结合起来 ➐。结合这些行会导致 `dta-dataleak` 合并它们的污点颜色，从而演示污点合并的过程。最后，两个 XOR 后的行结果通过网络发送
    ➑，提供一个“数据泄漏”，供 `dta-dataleak` 检测。
- en: Now, let’s see how `dta-dataleak` detects a data leak attempt and specifically
    how taint colors are merged when the leaked data depends on multiple files. [Listing
    11-16](ch11.xhtml#ch11list16) shows the output of running the `dataleak-test-xor`
    program while protected with `dta-dataleak`. I’ve abbreviated repetitive parts
    of the output with “`...`”.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `dta-dataleak` 是如何检测数据泄漏尝试的，特别是当泄漏数据依赖于多个文件时，污点颜色是如何合并的。[清单 11-16](ch11.xhtml#ch11list16)
    显示了运行 `dataleak-test-xor` 程序时在 `dta-dataleak` 保护下的输出。我已经将重复部分的输出缩略为“`...`”。
- en: '*Listing 11-16: Detecting a data exfiltration attempt with* dta-dataleak'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-16：使用* dta-dataleak 检测数据外泄尝试'
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example runs the `dataleak-test-xor` server with Pin, using `dta -dataleak`
    as the Pin tool to protect against data leaks ➊. Immediately, there’s a first
    `read` syscall that’s related to the loading process of `dataleak-test-xor` ➋.
    Because these bytes are read from a shared library, which doesn’t have an associated
    taint color, `dta-dataleak` ignores the read.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用 Pin 运行 `dataleak-test-xor` 服务器，使用 `dta-dataleak` 作为 Pin 工具来防止数据泄漏 ➊。立即出现了第一次与
    `dataleak-test-xor` 加载过程相关的 `read` 系统调用 ➋。由于这些字节是从共享库中读取的，而共享库没有关联的污点颜色，`dta-dataleak`
    会忽略该读取。
- en: Next, the example starts a `netcat` session to connect to the server ➌ and send
    it a list of filenames to open ➍. The `dta-dataleak` tool intercepts the `open`
    events for all those files and assigns each of them a taint color ➎. Then, the
    server randomly chooses two files that it’s going to leak. In this case, these
    turn out to be the files with file descriptor 8 ➏ and 5 ➐, respectively.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，示例启动一个 `netcat` 会话，连接到服务器 ➌，并发送一个文件名列表以便打开 ➍。`dta-dataleak` 工具拦截所有这些文件的
    `open` 事件，并为每个文件分配一个污点颜色 ➎。然后，服务器随机选择两个将要泄漏的文件。在本例中，这两个文件分别是文件描述符 8 ➏ 和 5 ➐。
- en: For both files, `dta-dataleak` intercepts the `read` events and taints the read
    bytes with the files’ associated taint color (`0x08` and `0x01`, respectively).
    Next, `dta-dataleak` intercepts the server’s attempt to send the file contents,
    which are now XOR-ed together, over the network ➑.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个文件，`dta-dataleak` 拦截了 `read` 事件，并使用文件的关联污点颜色（分别为 `0x08` 和 `0x01`）标记读取的字节。接着，`dta-dataleak`
    拦截了服务器发送文件内容的尝试，这些内容现在已经通过 XOR 运算结合在一起，并通过网络传输 ➑。
- en: It checks the taint on the bytes the server is about to send ➒, notices that
    they’re tainted with the tag `0x09` ➓, and therefore prints an alert and aborts
    the program. Tag `0x09` is the combination of the two taint colors `0x01` and
    `0x08`. From the alert, you can see that these colors correspond to the files
    *dta-execve.cpp* and *echo.c*, respectively.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查服务器即将发送的字节上的污点 ➒，发现这些字节被标签 `0x09` ➓ 污染，因此打印警告并终止程序。标签 `0x09` 是两个污点颜色 `0x01`
    和 `0x08` 的组合。从警告中可以看出，这些颜色分别对应于文件 *dta-execve.cpp* 和 *echo.c*。
- en: As you can see, taint analysis makes it easy to spot information leaks and to
    know exactly which files are leaked. Also, you can use merged taint colors to
    tell which taint sources contributed to a byte’s value. Even with just eight taint
    colors, there are endless ways to build powerful DTA tools!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，污点分析使得识别信息泄漏变得简单，并且能够准确知道哪些文件被泄漏了。此外，您可以使用合并后的污点颜色来判断哪些污点源对字节的值做出了贡献。即使只有八种污点颜色，仍然有无数种方法可以构建强大的
    DTA 工具！
- en: 11.5 Summary
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5 小结
- en: 'In this chapter, you learned about the internals of `libdft`, a popular open
    source DTA library. You also saw practical examples of using `libdft` to detect
    two types of common attacks: control hijacking and data exfiltration. You should
    now be ready to start building your own DTA tools!'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了 `libdft` 的内部结构，这是一个流行的开源 DTA 库。您还看到了使用 `libdft` 检测两种常见攻击的实际示例：控制劫持和数据外泄。现在，您应该已经准备好开始构建自己的
    DTA 工具了！
- en: Exercise
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 1\. Implementing a Format String Exploit Detector
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 实现格式化字符串漏洞检测器
- en: Use `libdft` to implement the format string exploit detection tool you designed
    in the previous chapter. Create an exploitable program and a format string exploit
    to test your detector. Also, create a program with an implicit flow that allows
    a format string exploit to succeed despite your detection tool.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `libdft` 实现您在上一章中设计的格式化字符串漏洞检测工具。创建一个可利用的程序和一个格式化字符串漏洞来测试您的检测器。同时，创建一个具有隐式流的程序，允许格式化字符串漏洞在您的检测工具下仍然成功。
- en: 'Hint: You can’t directly hook `printf` with `libdft` because it’s not a syscall.
    Instead, you’ll have to find another way, such as with an instruction-level hook
    (`libdft`’s `ins_set_pre`) that checks for calls to the `printf` PLT stub. For
    the purposes of this exercise, you’re allowed to make simplifying assumptions,
    such as no indirect calls to `printf` and a fixed, hard-coded address for the
    PLT stub.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你不能直接使用`libdft`钩取`printf`，因为它不是系统调用（syscall）。相反，你需要找到其他方法，例如使用指令级钩子（`libdft`的`ins_set_pre`），检查对`printf`
    PLT存根的调用。为了本练习的目的，你可以做一些简化假设，例如没有间接调用`printf`，并且PLT存根的地址是固定且硬编码的。
- en: If you’re looking for a practical example of instruction-level hooking, check
    out the *libdft-dta.c* tool that ships with `libdft`!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在寻找一个关于指令级钩子（instruction-level hooking）的实际示例，可以查看随`libdft`一起提供的*libdft-dta.c*工具！
