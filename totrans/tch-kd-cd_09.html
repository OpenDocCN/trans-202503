<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;User Interaction: Get into the Game"><div class="titlepage"><div><div><h1 class="title"><a id="user_interaction_get_into_the_game"/>Chapter 9. User Interaction: Get into the Game</h1></div></div></div><p><a id="iddle1741" class="indexterm"/><a id="iddle1464" class="indexterm"/>In <a class="xref" href="ch08.html" title="Chapter 8. Timers and Animation: What Would Disney Do?">Chapter 8</a>, we used some of the Pygame library’s features to draw shapes and images on the screen. We were also able to create animation by drawing shapes in different locations over time. Unfortunately, we weren’t able to <span class="emphasis"><em>interact</em></span> with our animated objects like we might in a game; we expect to be able to click, drag, move, hit, or pop objects on the screen to affect or control the elements of a game while it runs.</p><p><a id="iddle1159" class="indexterm"/><a id="iddle1439" class="indexterm"/><a id="iddle1466" class="indexterm"/><a id="iddle1847" class="indexterm"/>Interactive programs give us this sense of control in an app or game, because we can move or interact with a character or other object in the program. That’s exactly what you’ll learn to do in this chapter: we’ll use Pygame’s ability to handle user interaction from the mouse to make our programs more interactive and more engaging for the user.</p><div class="sect1" title="Adding Interaction: Click and Drag"><div class="titlepage"><div><div><h1 class="title"><a id="adding_interaction_click_and_drag"/>Adding Interaction: Click and Drag</h1></div></div></div><p>Let’s add user interaction by developing two programs that will allow the user to draw interactively on the screen. First, we’ll build on our Pygame foundation to handle events like mouse-button clicks and to enable the user to draw dots on the screen. Then, we’ll add logic to handle mouse-button presses and releases separately and let the user drag the mouse with the button pressed to draw, like in a paint program.</p><div class="sect2" title="Clicking for Dots"><div class="titlepage"><div><div><h2 class="title"><a id="clicking_for_dots"/>Clicking for Dots</h2></div></div></div><p>We’ll build our <span class="emphasis"><em>ClickDots.py</em></span> program using the same steps as in <span class="emphasis"><em>ShowPic.py</em></span> (<a class="xref" href="ch08.html#exiting_the_program" title="Exiting the Program">Exiting the Program</a>) with a setup, a game loop, and an exit. Pay extra attention to the event-handling portion of the game loop, since that’s where we’ll add the <code class="literal">if</code> statement that will process mouse clicks.</p><div class="sect3" title="Setup"><div class="titlepage"><div><div><h3 class="title"><a id="setup"/>Setup</h3></div></div></div><p>Here are our first few lines of setup. Start a new file and save it as <span class="emphasis"><em>ClickDots.py</em></span> (the final program is shown in <a class="xref" href="ch09.html#putting_it_all_together-id00022" title="Putting It All Together">Putting It All Together</a>).</p><a id="pro_id00151"/><pre class="programlisting"><span class="orange">import</span> pygame                           <span class="red"># Setup</span>
pygame.init()
screen = pygame.display.set_mode([800,600])
pygame.display.set_caption(<span class="green">"Click to draw"</span>)</pre><p>Our setup begins with <code class="literal">import pygame</code> and <code class="literal">pygame.init()</code> as usual, and then we create a <code class="literal">screen</code> object as our drawing window display. This time, though, we’ve added a title, or <span class="emphasis"><em>caption</em></span>, to the window with <code class="literal">pygame.display.set_caption()</code>. This lets the user know what the program is. The argument we pass to <code class="literal">set_caption()</code> is a string of text that will appear on the title bar of the window, as shown at the top of <a class="xref" href="ch09.html#title_bar_at_the_top_of_clickdotsdotpy_t" title="Figure 9-1. The title bar at the top of ClickDots.py tells the user, “Click to draw.”">Figure 9-1</a>.</p><div class="figure"><a id="title_bar_at_the_top_of_clickdotsdotpy_t"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00120"/><img src="httpatomoreillycomsourcenostarchimages2189011.png.jpg" alt="The title bar at the top of ClickDots.py tells the user, “Click to draw.”"/></div></div><p class="title">Figure 9-1. The title bar at the top of <span class="emphasis"><em>ClickDots.py</em></span> tells the user, “Click to draw.”</p></div><p><a id="iddle1160" class="indexterm"/><a id="iddle1300" class="indexterm"/><a id="iddle1361" class="indexterm"/><a id="iddle1490" class="indexterm"/><a id="iddle1578" class="indexterm"/>The rest of our setup creates our game loop variable, <code class="literal">keep_going</code>; sets a color constant (we’ll draw in red for this program); and creates a radius for our drawing dots:</p><a id="pro_id00152"/><pre class="programlisting">keep_going = <span class="orange">True</span>
RED = (255,0,0)                     <span class="red"># RGB color triplet for RED</span>
radius = 15</pre><p>Now let’s move on to our game loop.</p></div><div class="sect3" title="Game Loop: Handling Mouse Clicks"><div class="titlepage"><div><div><h3 class="title"><a id="game_loop_handling_mouse_clicks"/>Game Loop: Handling Mouse Clicks</h3></div></div></div><p>In our game loop, we need to tell the program when to quit and how to handle mouse-button presses:</p><a id="pro_id00153"/><pre class="programlisting">   <span class="orange">while</span> keep_going:                      <span class="red"># Game loop</span>
       <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():   <span class="red"># Handling events</span>
➊         <span class="orange">if</span> event.type == pygame.QUIT:
               keep_going = <span class="orange">False</span>
➋         <span class="orange">if</span> event.type == pygame.MOUSEBUTTONDOWN:
➌             spot = event.pos
➍             pygame.draw.circle(screen, RED, spot, radius)</pre><p><a id="iddle1377" class="indexterm"/><a id="iddle1573" class="indexterm"/><a id="iddle1734" class="indexterm"/><a id="iddle1920" class="indexterm"/>At ➊, we handle the <code class="literal">pygame.QUIT</code> event by setting our loop variable <code class="literal">keep_going</code> to <code class="literal">False</code>.</p><p>The second <code class="literal">if</code> statement, at ➋, handles a new event type: the <code class="literal">pygame.MOUSEBUTTONDOWN</code> event that tells us that the user has pressed one of the mouse buttons. Whenever the user presses a mouse button, this event will appear in the list of events that our program gets from <code class="literal">pygame.event.get()</code>, and we can use an <code class="literal">if</code> statement both to check for the event and to tell the program what to do when the event occurs. At ➌, we create a variable called <code class="literal">spot</code> to hold the x- and y-coordinates of the mouse’s position. We can get the location of the mouse-click event with <code class="literal">event.pos</code>; <code class="literal">event</code> is the current event in our <code class="literal">for</code> loop. Our <code class="literal">if</code> statement has just verified that this particular <code class="literal">event</code> is of type <code class="literal">pygame.MOUSEBUTTONDOWN</code>, and mouse events have a <code class="literal">pos</code> attribute (in this case, <code class="literal">event.pos</code>) that stores the (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinate pair telling us where the mouse event occurred.</p><p>Once we know the location on the screen where the user clicked the mouse button, at ➍ we tell the program to draw a filled circle on the <code class="literal">screen</code> surface, in the <code class="literal">RED</code> color from our setup, at the location <code class="literal">spot</code>, with the <code class="literal">radius</code> of 15 we specified in our setup.</p><div class="informalfigure"><a id="med_id00121a"/><div class="mediaobject"><a id="med_id00121"/><img src="httpatomoreillycomsourcenostarchimages2189013.png.jpg" alt="image with no caption"/></div></div></div><div class="sect3" title="Putting It All Together"><div class="titlepage"><div><div><h3 class="title"><a id="putting_it_all_together-id00022"/>Putting It All Together</h3></div></div></div><p>The only thing left to do is update the display and tell our program what to do when it’s time to exit. Here’s the full program for <span class="emphasis"><em>ClickDots.py</em></span>.</p><div class="sect4" title="ClickDots.py"><div class="titlepage"><div><div><h4 class="title"><a id="clickdotsdotpy"/>ClickDots.py</h4></div></div></div><a id="pro_id00154"/><pre class="programlisting"><span class="orange">import</span> pygame                           <span class="red"># Setup</span>
pygame.init()
screen = pygame.display.set_mode([800,600])
pygame.display.set_caption(<span class="green">"Click to draw"</span>)
keep_going = <span class="orange">True</span>
RED = (255,0,0)                         <span class="red"># RGB color triplet for RED</span> radius = 15

<span class="orange">while</span> keep_going:                       <span class="red"># Game loop</span>
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():    <span class="red"># Handling events</span>
        <span class="orange">if</span> event.type == pygame.QUIT:
            keep_going = <span class="orange">False</span>
        <span class="orange">if</span> event.type == pygame.MOUSEBUTTONDOWN:
            spot = event.pos
            pygame.draw.circle(screen, RED, spot, radius)
    pygame.display.update()             <span class="red"># Update display</span>

pygame.quit()                           <span class="red"># Exit</span></pre><p><a id="iddle1251" class="indexterm"/><a id="iddle1252" class="indexterm"/><a id="iddle1468" class="indexterm"/>This program is short but enables the user to draw pictures one dot at a time, as shown back in <a class="xref" href="ch09.html#title_bar_at_the_top_of_clickdotsdotpy_t" title="Figure 9-1. The title bar at the top of ClickDots.py tells the user, “Click to draw.”">Figure 9-1</a>. If we want to draw continuously as we drag the mouse with the button pressed, we just need to handle one more type of mouse event, <code class="literal">pygame.MOUSEBUTTONUP</code>. Let’s give that a try.</p></div></div></div><div class="sect2" title="Dragging to Paint"><div class="titlepage"><div><div><h2 class="title"><a id="dragging_to_paint"/>Dragging to Paint</h2></div></div></div><p>Now let’s create a more natural drawing program, <span class="emphasis"><em>DragDots.py</em></span>, that lets the user click and drag to draw smoothly, as with a paintbrush. We’ll get a smooth, interactive drawing app, as shown in <a class="xref" href="ch09.html#our_dragdotsdotpy_program_is_a_fun_way_t" title="Figure 9-2. Our DragDots.py program is a fun way to paint!">Figure 9-2</a>.</p><div class="figure"><a id="our_dragdotsdotpy_program_is_a_fun_way_t"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00122"/><img src="httpatomoreillycomsourcenostarchimages2189015.png.jpg" alt="Our DragDots.py program is a fun way to paint!"/></div></div><p class="title">Figure 9-2. Our <span class="emphasis"><em>DragDots.py</em></span> program is a fun way to paint!</p></div><p>To create this effect, we need to change the logic of our program. In <span class="emphasis"><em>ClickDots.py</em></span>, we handled <code class="literal">MOUSEBUTTONDOWN</code> events by just drawing a circle at the location of the mouse button click event. To draw continuously, we need to recognize both the <code class="literal">MOUSEBUTTONDOWN</code> <a id="iddle1320" class="indexterm"/><a id="iddle1575" class="indexterm"/>and <code class="literal">MOUSEBUTTONUP</code> events; in other words, we want to separate mouse button clicks into <span class="emphasis"><em>presses</em></span> and <span class="emphasis"><em>releases</em></span> so that we know when the mouse is being <span class="emphasis"><em>dragged</em></span> (with the button down) versus just being moved with the button up.</p><p>One way to accomplish this is with another Boolean flag variable. We can set a Boolean called <code class="literal">mousedown</code> to <code class="literal">True</code> whenever the user presses the mouse button and to <code class="literal">False</code> whenever the user releases the mouse button. In our game loop, if the mouse button is down (in other words, when <code class="literal">mousedown</code> is <code class="literal">True</code>), we can get the mouse’s location and draw a circle on the screen. If the program is fast enough, the drawing should be smooth like in a paintbrush app.</p><div class="informalfigure"><a id="med_id00123a"/><div class="mediaobject"><a id="med_id00123"/><img src="httpatomoreillycomsourcenostarchimages2189017.png.jpg" alt="image with no caption"/></div></div><div class="sect3" title="Setup"><div class="titlepage"><div><div><h3 class="title"><a id="setup-id00023"/>Setup</h3></div></div></div><p>Make the setup section of your code look like this:</p><a id="pro_id00155"/><pre class="programlisting">   <span class="orange">import</span> pygame                           <span class="red"># Setup</span>
   pygame.init()
   screen = pygame.display.set_mode([800,600])
➊ pygame.display.set_caption(<span class="green">"Click and drag to draw"</span>)
   keep_going = <span class="orange">True</span>
➋ YELLOW = (255,255,0)                    <span class="red"># RGB color triplet for YELLOW</span>
   radius = 15
➌ mousedown = <span class="orange">False</span></pre><p>The setup portion of our app looks like <span class="emphasis"><em>ClickDots.py</em></span>, except for the different window caption ➊, the <code class="literal">YELLOW</code> color we’ll be drawing with ➋, and the very last line ➌. The Boolean variable <code class="literal">mousedown</code> will be our flag variable to signal to the program that the mouse button is down, or pressed.</p><p><a id="iddle1301" class="indexterm"/><a id="iddle1362" class="indexterm"/><a id="iddle1381" class="indexterm"/><a id="iddle1579" class="indexterm"/><a id="iddle2011" class="indexterm"/>Next, we’ll add event handlers to our game loop. These event handlers will set <code class="literal">mousedown</code> to <code class="literal">True</code> if the user is holding down the mouse and <code class="literal">False</code> if not.</p></div><div class="sect3" title="Game Loop: Handling Mouse Presses and Releases"><div class="titlepage"><div><div><h3 class="title"><a id="game_loop_handling_mouse_presses_and_rel"/>Game Loop: Handling Mouse Presses and Releases</h3></div></div></div><p>Make your game loop look like this:</p><a id="pro_id00156"/><pre class="programlisting">   <span class="orange">while</span> keep_going:                        <span class="red"># Game loop</span>
       <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():     <span class="red"># Handling events</span>
           <span class="orange">if</span> event.type == pygame.QUIT:
               keep_going = <span class="orange">False</span>
➊         <span class="orange">if</span> event.type == pygame.MOUSEBUTTONDOWN:
➋             mousedown = <span class="orange">True</span>
➌         <span class="orange">if</span> event.type == pygame.MOUSEBUTTONUP:
➍             mousedown = <span class="orange">False</span>
➎     <span class="orange">if</span> mousedown:                         <span class="red"># Draw/update graphics</span>
➏         spot = pygame.mouse.get_pos()
➐         pygame.draw.circle(screen, YELLOW, spot, radius)
➑     pygame.display.update()               <span class="red"># Update display</span></pre><p>The game loop starts just like our other Pygame apps, but at ➊, when we check to see whether the user has pressed one of the mouse buttons, instead of drawing immediately, we set our <code class="literal">mousedown</code> variable to <code class="literal">True</code> ➋. This will be the signal our program needs to begin drawing.</p><p>The next <code class="literal">if</code> statement at ➌ checks whether the user has <span class="emphasis"><em>released</em></span> the mouse button. If so, the line at ➍ changes <code class="literal">mousedown</code> back to <code class="literal">False</code>. This will let our game loop know to stop drawing whenever the mouse button is up.</p><p>At ➎, our <code class="literal">for</code> loop is over (as we can see by the indentation), and our game loop continues by checking whether the mouse button is currently pressed (that is, if <code class="literal">mousedown</code> is <code class="literal">True</code>). If the mouse button is down, the mouse is currently being dragged, so we want to allow the user to draw on the <code class="literal">screen</code>.</p><p>At ➏, we get the current location of the mouse directly, with <code class="literal">spot = pygame.mouse.get_pos()</code>, rather than pulling the position of the last click, because we want to draw wherever the user is dragging the mouse, not just at the location where they first pressed the button. At ➐, we draw the current circle on the <code class="literal">screen</code> surface, in the color specified by <code class="literal">YELLOW</code>, at the (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location <code class="literal">spot</code> where the mouse is currently being dragged, with the <code class="literal">radius</code> of 15 that we specified in the setup section of our code. Finally, we finish the game loop at ➑ by updating the display window with <code class="literal">pygame.display.update()</code>.</p></div><div class="sect3" title="Putting It All Together"><div class="titlepage"><div><div><h3 class="title"><a id="putting_it_all_together-id00024"/>Putting It All Together</h3></div></div></div><p><a id="iddle1333" class="indexterm"/><a id="iddle1537" class="indexterm"/><a id="iddle1552" class="indexterm"/><a id="iddle1715" class="indexterm"/><a id="iddle1737" class="indexterm"/><a id="iddle2049" class="indexterm"/>The last step is to end the program with <code class="literal">pygame.quit()</code> as usual. Here’s the full program.</p><div class="sect4" title="DragDots.py"><div class="titlepage"><div><div><h4 class="title"><a id="dragdotsdotpy"/>DragDots.py</h4></div></div></div><a id="pro_id00157"/><pre class="programlisting"><span class="orange">import</span> pygame                           <span class="red"># Setup</span>
pygame.init()
screen = pygame.display.set_mode([800,600])
pygame.display.set_caption(<span class="green">"Click and drag to draw"</span>)
keep_going = <span class="orange">True</span>
YELLOW = (255,255,0)                    <span class="red"># RGB color triplet for YELLOW</span>
radius = 15
mousedown = <span class="orange">False</span>

<span class="orange">while</span> keep_going:                       <span class="red"># Game loop</span>
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():    <span class="red"># Handling events</span>
        <span class="orange">if</span> event.type == pygame.QUIT:
            keep_going = <span class="orange">False</span>
        <span class="orange">if</span> event.type == pygame.MOUSEBUTTONDOWN:
            mousedown = <span class="orange">True</span>
        <span class="orange">if</span> event.type == pygame.MOUSEBUTTONUP:
            mousedown = <span class="orange">False</span>
    <span class="orange">if</span> mousedown:                       <span class="red"># Draw/update graphics</span>
        spot = pygame.mouse.get_pos()
        pygame.draw.circle(screen, YELLOW, spot, radius)
    pygame.display.update()             <span class="red"># Update display</span>

pygame.quit()                           <span class="red"># Exit</span></pre><p>The <span class="emphasis"><em>DragDots.py</em></span> app is so fast and responsive that it almost feels like we’re painting with a continuous brush instead of a series of dots; we have to drag the mouse pretty quickly to see the dots drawn separately. Pygame allows us to build much faster and more fluid games and animation than the turtle graphics we drew in previous chapters.</p><p>Even though the <code class="literal">for</code> loop handles every event during every pass through the <code class="literal">while</code> loop that keeps our app open, Pygame is efficient enough to do this dozens or even hundreds of times per second. This gives the illusion of instantaneous motion and reaction to our every movement and command—an important consideration as we build animations and interactive games. Pygame is up to the challenge and is the right toolkit for our graphics-intensive needs.</p></div></div></div></div><div class="sect1" title="Advanced Interaction: Smiley Explosion"><div class="titlepage"><div><div><h1 class="title"><a id="advanced_interaction_smiley_explosion"/>Advanced Interaction: Smiley Explosion</h1></div></div></div><p><a id="iddle1469" class="indexterm"/><a id="iddle1888" class="indexterm"/><a id="iddle1889" class="indexterm"/><a id="iddle1922" class="indexterm"/>One fun animation that my students and my sons enjoy building is a scaled-up version of <span class="emphasis"><em>SmileyBounce2.py</em></span> called <span class="emphasis"><em>SmileyExplosion.py</em></span>. It takes the bouncing smiley to a fun new level by allowing the user to click and drag to create hundreds of bouncing smiley faces of random sizes that travel in random directions at random speeds. The effect looks like <a class="xref" href="ch09.html#our_next_app_looks_like_an_explosion_of" title="Figure 9-3. Our next app looks like an explosion of smiley face balloons bouncing all over the screen.">Figure 9-3</a>. We’ll build this program step by step; the final version is in <a class="xref" href="ch09.html#putting_it_all_together-id00025" title="Putting It All Together">Putting It All Together</a>.</p><div class="figure"><a id="our_next_app_looks_like_an_explosion_of"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00124"/><img src="httpatomoreillycomsourcenostarchimages2189019.png.jpg" alt="Our next app looks like an explosion of smiley face balloons bouncing all over the screen."/></div></div><p class="title">Figure 9-3. Our next app looks like an explosion of smiley face balloons bouncing all over the screen.</p></div><p>As you can see, we will have dozens to hundreds of smiley balloons bouncing all over the screen at any given time, so we’re going to need to draw graphics quickly and smoothly for hundreds of objects per frame. To achieve this, we’re going to add one more tool to our toolkit: sprite graphics.</p><div class="sect2" title="Smiley Sprites"><div class="titlepage"><div><div><h2 class="title"><a id="smiley_sprites"/>Smiley Sprites</h2></div></div></div><p>The term <span class="emphasis"><em>sprite</em></span> goes back to the early days of video games. Moving graphical objects on the screen were called sprites because they floated over the background, like the imaginary fairy sprites they were named after. These light, fast sprite graphics enabled the quick, smooth animation that made video games so popular.</p><p><a id="iddle1101" class="indexterm"/><a id="iddle1150" class="indexterm"/><a id="iddle1465" class="indexterm"/><a id="iddle1563" class="indexterm"/><a id="iddle1611" class="indexterm"/><a id="iddle1689" class="indexterm"/><a id="iddle1711" class="indexterm"/><a id="iddle1808" class="indexterm"/><a id="iddle1921" class="indexterm"/><a id="iddle1963" class="indexterm"/>Pygame includes support for sprite graphics through its <code class="literal">pygame.sprite.Sprite</code> class. Remember from <a class="xref" href="ch08.html" title="Chapter 8. Timers and Animation: What Would Disney Do?">Chapter 8</a> that a class is like a template that can be used to create reusable objects, each with its own full set of functions and properties. In <a class="xref" href="ch08.html#smileymovedotpy" title="SmileyMove.py">SmileyMove.py</a>, we used the <code class="literal">Clock</code> class, along with its <code class="literal">tick()</code> method, to make our animations smooth and predictable. In the smiley explosion app, we’ll use a few handy Pygame classes, and we’ll build a class of our own to keep track of each individual smiley face as it moves around the screen.</p><div class="informalfigure"><a id="med_id00125a"/><div class="mediaobject"><a id="med_id00125"/><img src="httpatomoreillycomsourcenostarchimages2189021.png.jpg" alt="image with no caption"/></div></div><div class="sect3" title="More on Classes and Objects"><div class="titlepage"><div><div><h3 class="title"><a id="more_on_classes_and_objects"/>More on Classes and Objects</h3></div></div></div><p>In <a class="xref" href="ch08.html" title="Chapter 8. Timers and Animation: What Would Disney Do?">Chapter 8</a> you learned that classes are like cookie cutters, and objects are like the cookies we create using a particular cookie cutter. Whenever we need several items with similar functions and characteristics (like moving smiley face images with various sizes and locations), and especially when we need each item to contain different information (like the size, location, and speed of each smiley), a class can provide the template to create as many objects of that type as we need. We say that objects are <span class="emphasis"><em>instances</em></span> of a particular class.</p><p>The Pygame library has dozens of reusable classes, and each class has its own <span class="emphasis"><em>methods</em></span> (what we call a class’s functions) and <span class="emphasis"><em>attributes</em></span> or <span class="emphasis"><em>data</em></span>, the variables and values stored in each object. In the <code class="literal">Clock</code> class in <a class="xref" href="ch08.html" title="Chapter 8. Timers and Animation: What Would Disney Do?">Chapter 8</a>, the <code class="literal">tick()</code> method was our function for making animation happen at a certain frame rate. For the floating smiley <code class="literal">Sprite</code> objects in this app, the attributes we care about are each smiley’s location on the screen, its size, and the speed it’s moving in the x- and y-directions, so we’ll create a <code class="literal">Smiley</code> class with those attributes. We can create our own classes whenever we need a reusable template.</p><p>Breaking a problem or program down into objects, and then building classes that create those objects, is the foundation of <span class="emphasis"><em>object-oriented programming</em></span>. Object-oriented programming is a way of solving problems using objects. It is one of the most popular approaches used in software development, and one reason for that popularity is the concept of code reuse. <span class="emphasis"><em>Reusability</em></span> means that <a id="iddle1152" class="indexterm"/><a id="iddle1233" class="indexterm"/><a id="iddle1396" class="indexterm"/><a id="iddle1701" class="indexterm"/>once we write a useful class for one programming project, we can often reuse that class in another program instead of starting from scratch. For example, a game company can write a <code class="literal">Card</code> class to represent the cards in a standard deck. Then, every time the company programs a new game—like Blackjack, War, Poker, Go Fish, and so on—it can reuse that <code class="literal">Card</code> class, saving time and money by using the same code in future apps.</p><p>The <code class="literal">Sprite</code> class in Pygame is a great example. The Pygame team wrote the <code class="literal">Sprite</code> class to contain many of the features we need when we program a game object, from a running character to a spaceship to a floating smiley face. By using the <code class="literal">Sprite</code> class, programmers like us no longer need to write all the basic code to draw an object on the screen, detect when objects collide with one another, and so on. The <code class="literal">Sprite</code> class handles many of those functions for us, and we can focus on building the unique qualities of our app on top of that foundation.</p><p>Another handy Pygame class we’ll use is the <code class="literal">Group</code> class. <code class="literal">Group</code> is a <span class="emphasis"><em>container</em></span> class that lets us store <code class="literal">Sprite</code> objects together as a group. The <code class="literal">Group</code> class helps us keep all our sprites together in one place (accessible through a single <code class="literal">Group</code> object), and that’s important when we have dozens or possibly hundreds of sprites floating around the screen. The <code class="literal">Group</code> class also has convenient methods for updating all the sprites in a group (such as moving the <code class="literal">Sprite</code> objects to each of their new locations each frame), adding new <code class="literal">Sprite</code> objects, removing <code class="literal">Sprite</code> objects from the <code class="literal">Group</code>, and so on. Let’s see how we can use these classes to build our smiley explosion app.</p></div><div class="sect3" title="Using classes to Build our app"><div class="titlepage"><div><div><h3 class="title"><a id="using_classes_to_build_our_app"/>Using classes to Build our app</h3></div></div></div><p>We’re going to create <code class="literal">Sprite</code> objects for our smiley face balloons that take advantage of the <code class="literal">Sprite</code> class’s properties to produce quick animation around the screen, even when hundreds of sprites are being moved in the same frame. I mentioned that Pygame also has support for groups of sprites that can all be drawn and handled as a collection; this group of sprites will be of type <code class="literal">pygame.sprite.Group()</code>. Let’s look at the setup section of our app:</p><a id="pro_id00158"/><pre class="programlisting">   <span class="orange">import</span> pygame
   <span class="orange">import</span> random

   BLACK = (0,0,0)
   pygame.init()
   screen = pygame.display.set_mode([800,600])
   pygame.display.set_caption(<span class="green">"Smiley Explosion"</span>)
   mousedown = <span class="orange">False</span>
   keep_going = <span class="orange">True</span>
   clock = pygame.time.Clock()
   pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
   colorkey = pic.get_at((0,0))
   pic.set_colorkey(colorkey)
➊ sprite_list = pygame.sprite.Group()</pre><p><a id="iddle1151" class="indexterm"/><a id="iddle1155" class="indexterm"/><a id="iddle1232" class="indexterm"/><a id="iddle1312" class="indexterm"/><a id="iddle1441" class="indexterm"/><a id="iddle1444" class="indexterm"/><a id="iddle1472" class="indexterm"/><a id="iddle1887" class="indexterm"/><a id="iddle1925" class="indexterm"/>The setup looks like <span class="emphasis"><em>SmileyBounce2.py</em></span>, but we’re adding a variable called <code class="literal">sprite_list</code> at ➊ that will contain our group of smiley face sprites. Storing the sprites in a <code class="literal">Group</code> will make it faster and easier to do things like draw all the smileys on the screen every frame, move all the smileys for each step of the animation, and even check to see if the smiley sprites are colliding with objects or with one another.</p><p>To create sprite objects for complex animations and games, we will create our own <code class="literal">Sprite</code> class that <span class="emphasis"><em>extends</em></span>, or builds on, Pygame’s <code class="literal">Sprite</code> class, adding the variables and functions that we want for our custom sprites. We’ll name our sprite class <code class="literal">Smiley</code>, and we’ll add variables for the position of each smiley (<code class="literal">pos</code>), its x- and y-velocity (<code class="literal">xvel</code> and <code class="literal">yvel</code>; remember <span class="emphasis"><em>velocity</em></span> is another word for speed), and its <span class="emphasis"><em>scale</em></span>, or how big each smiley will be (<code class="literal">scale</code>):</p><a id="pro_id00159"/><pre class="programlisting"><span class="orange">class</span> <span class="blue">Smiley</span>(pygame.sprite.Sprite):
    pos = (0,0)
    xvel = 1
    yvel = 1
    scale = 100</pre><p>Our <code class="literal">Smiley</code> class definition starts with the keyword <code class="literal">class</code>, followed by the name we want for our class, plus the type we’re extending (<code class="literal">pygame.sprite.Sprite</code>).</p></div></div><div class="sect2" title="Setting Up Sprites"><div class="titlepage"><div><div><h2 class="title"><a id="setting_up_sprites"/>Setting Up Sprites</h2></div></div></div><p>The next step after starting our <code class="literal">Smiley</code> class and listing the data variables that we’d like each smiley sprite object to remember is called <span class="emphasis"><em>initialization</em></span>, sometimes also referred to as the <span class="emphasis"><em>constructor</em></span> for our class. This will be a special function that is called every time a new object of our <code class="literal">Smiley</code> class is created, or <span class="emphasis"><em>constructed</em></span>, in our program. Just like initializing a variable gives it a starting value, the <span class="emphasis"><em>initialization function</em></span>, <code class="literal">__init__()</code>, in our <code class="literal">Smiley</code> class will <a id="iddle1672" class="indexterm"/><a id="iddle1846" class="indexterm"/><a id="iddle2068" class="indexterm"/><a id="iddle2085" class="indexterm"/>set up all the starting values we need in our sprite object. The two underscores on either side of the <code class="literal">__init__()</code> function name have special meaning in Python. In this case, <code class="literal">__init__()</code> is the special function name that is used to initialize a class. We tell Python how each <code class="literal">Smiley</code> object should be initialized in this function, and every time we create a <code class="literal">Smiley</code>, this special <code class="literal">__init__()</code> function does its job behind the scenes, setting up variables and more for each <code class="literal">Smiley</code> object.</p><div class="informalfigure"><a id="med_id00126a"/><div class="mediaobject"><a id="med_id00126"/><img src="httpatomoreillycomsourcenostarchimages2189023.png.jpg" alt="image with no caption"/></div></div><p>There are a number of items we need to set up in our <code class="literal">__init__()</code> function. First, we’ll determine what parameters we need to pass to our <code class="literal">__init__()</code> function. For our random smiley faces, we might pass in a position and the starting x- and y-velocities. Because our <code class="literal">Smiley</code> is a class and all our smiley face sprites will be objects of the <code class="literal">Smiley</code> type, the first parameter in all the functions in the class will be the smiley sprite object itself. We label this parameter <code class="literal">self</code>, because it connects <code class="literal">__init__()</code> and the other functions to the object’s own data. Look at the code for our <code class="literal">__init__()</code> function:</p><a id="pro_id00160"/><pre class="programlisting">   <span class="orange">def</span> <span class="blue">__init__</span>(self, pos, xvel, yvel):
➊     pygame.sprite.Sprite.__init__(self)
➋     self.image = pic
      self.rect = self.image.get_rect()
➌    self.pos = pos
➍    self.rect.x = pos[0] - self.scale/2
      self.rect.y = pos[1] - self.scale/2
➎    self.xvel = xvel
      self.yvel = yvel</pre><p>The four parameters for our <code class="literal">__init__()</code> function are the object itself, <code class="literal">self</code>; the position where we want the smiley to appear, <code class="literal">pos</code>; and <code class="literal">xvel</code> and <code class="literal">yvel</code>, its horizontal and vertical speed values. Next, at ➊, we call the initialization function for the main <code class="literal">Sprite</code> class so that our object can take advantage of the properties of sprite <a id="iddle1473" class="indexterm"/><a id="iddle1716" class="indexterm"/><a id="iddle1926" class="indexterm"/><a id="iddle2012" class="indexterm"/>graphics without coding them from scratch. At ➋, we set the image of the sprite object (<code class="literal">self.image</code>) to the <code class="literal">pic</code> graphic that we loaded from disk (<span class="emphasis"><em>CrazySmile.bmp</em></span>—you’ll need to make sure that file is still in the same folder as this new program), and we get the dimensions of the rectangle that contains the 100×100 picture.</p><p>At ➌, the statement <code class="literal">self.pos = pos</code> stores the position that was passed into the <code class="literal">__init__()</code> function in the object’s own <code class="literal">pos</code> variable. Then, at ➍, we set the x- and y-coordinates of the sprite’s drawing rectangle to the x- and y-coordinates stored in <code class="literal">pos</code>, shifted by half the size of the image (<code class="literal">self.scale/2</code>) so that the smiley is centered on the spot the user clicked with the mouse. Finally, we store the x- and y-velocities that were passed to the <code class="literal">__init__()</code> function in the object’s <code class="literal">xvel</code> and <code class="literal">yvel</code> variables (<code class="literal">self.xvel</code> and <code class="literal">self.yvel</code>) at ➎.</p><p>This <code class="literal">__init__()</code> constructor function will set up everything we need for drawing each smiley face on the screen, but it doesn’t handle the animation needed to move our sprites around the screen. For that, we’ll add another handy function for our sprites, <code class="literal">update()</code>.</p></div><div class="sect2" title="Updating Sprites"><div class="titlepage"><div><div><h2 class="title"><a id="updating_sprites"/>Updating Sprites</h2></div></div></div><p>Sprites are built for animation, and we’ve learned that animation means updating the location of a graphic each frame (each time we pass through the game loop). Pygame sprites have an <code class="literal">update()</code> function built in, and we can <span class="emphasis"><em>override</em></span>, or customize, this function to program the behavior that we want from our custom sprites.</p><p>Our <code class="literal">update()</code> function is pretty simple; the only updates to our bouncing smiley sprites for each frame are changing the position of each sprite according to its speed and checking to see whether it has collided with the edge of the screen:</p><a id="pro_id00161"/><pre class="programlisting"><span class="orange">def</span> <span class="blue">update</span>(self):
    self.rect.x += self.xvel
    self.rect.y += self.yvel
    <span class="orange">if</span> self.rect.x &lt;= 0 <span class="orange">or</span> self.rect.x &gt; screen.get_width() - self.scale:
        self.xvel = -self.xvel
    <span class="orange">if</span> self.rect.y &lt;= 0 <span class="orange">or</span> self.rect.y &gt; screen.get_height() - self.scale:
        self.yvel = -self.yvel</pre><p><a id="iddle1067" class="indexterm"/><a id="iddle1176" class="indexterm"/><a id="iddle1380" class="indexterm"/><a id="iddle1388" class="indexterm"/><a id="iddle1471" class="indexterm"/><a id="iddle1697" class="indexterm"/><a id="iddle1700" class="indexterm"/><a id="iddle1708" class="indexterm"/><a id="iddle1841" class="indexterm"/><a id="iddle1924" class="indexterm"/><a id="iddle1965" class="indexterm"/>The <code class="literal">update()</code> function takes one parameter—the sprite object itself, <code class="literal">self</code>—and the code for moving the sprite looks a lot like our animation code from <span class="emphasis"><em>SmileyBounce2.py</em></span>. The only real difference is that we refer to the sprite’s (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location with <code class="literal">self.rect.x</code> and <code class="literal">self.rect.y</code>, and the x- and y-velocities as <code class="literal">self.xvel</code> and <code class="literal">self.yvel</code>. Our collision detections for the boundaries of the screen also make use of <code class="literal">screen.get_width()</code> and <code class="literal">screen.get_height()</code> so they can function for any size window.</p></div><div class="sect2" title="Bigger and Smaller Smileys"><div class="titlepage"><div><div><h2 class="title"><a id="bigger_and_smaller_smileys"/>Bigger and Smaller Smileys</h2></div></div></div><p>The last feature we’ll add to this first version of the app is changing the <span class="emphasis"><em>scale</em></span>, or size, of the image. We’ll make this modification to our <code class="literal">__init__()</code> function right after setting <code class="literal">self.image</code> to <code class="literal">pic</code>. First, we’ll change our object’s <code class="literal">scale</code> variable to a random number between 10 and 100 (for a finished smiley sprite that measures between 10×10 and 100×100 pixels in size). We’ll apply this change in scale, also known as a <span class="emphasis"><em>transformation</em></span>, by using the <code class="literal">pygame.transform.scale()</code> function, as follows:</p><a id="pro_id00162"/><pre class="programlisting">self.scale = random.randrange(10,100)
self.image = pygame.transform.scale(self.image, (self.scale,self.scale))</pre><p>Pygame’s <code class="literal">transform.scale()</code> function takes an image (our <code class="literal">self.image</code> of the smiley graphic) and the new dimensions (our new random <code class="literal">self.scale</code> value as the width and height of the transformed image), and it returns the scaled (up or down, bigger or smaller) image, which we’re storing as the new <code class="literal">self.image</code>.</p><p>With this last change, we should now be able to use our <code class="literal">Smiley</code> sprite class to draw smiley faces of random sizes and speeds all over our screen with drawing code similar to our <span class="emphasis"><em>DragDots.py</em></span> drawing app, plus a few changes.</p><div class="informalfigure"><a id="med_id00127a"/><div class="mediaobject"><a id="med_id00127"/><img src="httpatomoreillycomsourcenostarchimages2189025.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="Putting It All Together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together-id00025"/>Putting It All Together</h2></div></div></div><p>Here’s our full <span class="emphasis"><em>SmileyExplosion.py</em></span> app:</p><div class="sect3" title="SmileyExplosion.py"><div class="titlepage"><div><div><h3 class="title"><a id="smileyexplosiondotpy"/>SmileyExplosion.py</h3></div></div></div><a id="pro_id00163"/><pre class="programlisting">   <span class="orange">import</span> pygame
   <span class="orange">import</span> random

   BLACK = (0,0,0)
   pygame.init()
   screen = pygame.display.set_mode([800,600])
   pygame.display.set_caption(<span class="green">"Smiley Explosion"</span>)
   mousedown = <span class="orange">False</span>
   keep_going = <span class="orange">True</span>
   clock = pygame.time.Clock()
   pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
   colorkey = pic.get_at((0,0))
   pic.set_colorkey(colorkey)
   sprite_list = pygame.sprite.Group()

   <span class="orange">class</span> <span class="blue">Smiley</span>(pygame.sprite.Sprite):
       pos = (0,0)
       xvel = 1
       yvel = 1
       scale = 100

       <span class="orange">def</span> <span class="blue">__init__</span>(self, pos, xvel, yvel):
           pygame.sprite.Sprite.__init__(self)
           self.image = pic
           self.scale = random.randrange(10,100)
           self.image = pygame.transform.scale(self.image, (self.scale,self.scale))
           self.rect = self.image.get_rect()
           self.pos = pos
           self.rect.x = pos[0] - self.scale/2
           self.rect.y = pos[1] - self.scale/2
           self.xvel = xvel
           self.yvel = yvel

      <span class="orange">def</span> <span class="blue">update</span>(self):
          self.rect.x += self.xvel
          self.rect.y += self.yvel
          <span class="orange">if</span> self.rect.x &lt;= 0 <span class="orange">or</span> self.rect.x &gt; screen.get_width() - self.scale:
              self.xvel = -self.xvel
          <span class="orange">if</span> self.rect.y &lt;= 0 <span class="orange">or</span> self.rect.y &gt; screen.get_height() - self.scale:
              self.yvel = -self.yvel
   <span class="orange">while</span> keep_going:
       <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
           <span class="orange">if</span> event.type == pygame.QUIT:
               keep_going = <span class="orange">False</span>
           <span class="orange">if</span> event.type == pygame.MOUSEBUTTONDOWN:
               mousedown = <span class="orange">True</span>
           <span class="orange">if</span> event.type == pygame.MOUSEBUTTONUP:
               mousedown = <span class="orange">False</span>
       screen.fill(BLACK)
➊     sprite_list.update()
➋     sprite_list.draw(screen)
       clock.tick(60)
       pygame.display.update()
       <span class="orange">if</span> mousedown:
           speedx = random.randint(-5, 5)
           speedy = random.randint(-5, 5)
➌         newSmiley = Smiley(pygame.mouse.get_pos(),speedx,speedy)
➍         sprite_list.add(newSmiley)

pygame.quit()</pre><p><a id="iddle1442" class="indexterm"/><a id="iddle2013" class="indexterm"/>The code for the game loop in <span class="emphasis"><em>SmileyExplosion.py</em></span> is similar to our drawing app <span class="emphasis"><em>DragDots.py</em></span>, with a few notable changes. At ➊, we’re calling the <code class="literal">update()</code> function on the list of smiley sprites stored in <code class="literal">sprite_list</code>; this single line will call the update function to move every smiley face on the screen and check for edge bounces. Similarly, the code at ➋ will draw every smiley face on the screen in its proper location. It takes only two lines of code to animate and draw potentially hundreds of sprites—that’s a huge time savings, and it’s just part of the power of sprite graphics in Pygame.</p><p>In our <code class="literal">mousedown</code> drawing code, we generate a random <code class="literal">speedx</code> and <code class="literal">speedy</code> for the horizontal and vertical speed of each new smiley face, and at ➌, we create a new smiley face, <code class="literal">newSmiley</code>, by calling the constructor for our class <code class="literal">Smiley</code>. Notice that we don’t have to use the function name <code class="literal">__init__()</code>; rather, we use the name of the class, <code class="literal">Smiley</code>, whenever we’re constructing or creating a new object of the <code class="literal">Smiley</code> class or type. We pass the constructor function the position of the mouse, along with the random speed we just created. Finally, at ➍, we take our newly created smiley face sprite, <code class="literal">newSmiley</code>, and add it to our <code class="literal">Group</code> of sprites called <code class="literal">sprite_list</code>.</p><p>We’ve just created a fast, fluid, interactive animation for dozens or even hundreds of smiley face sprite graphics, floating around the screen like balloons of various sizes, traveling at random speeds <a id="iddle1068" class="indexterm"/><a id="iddle1169" class="indexterm"/><a id="iddle1170" class="indexterm"/><a id="iddle1171" class="indexterm"/><a id="iddle1177" class="indexterm"/><a id="iddle1467" class="indexterm"/><a id="iddle1470" class="indexterm"/><a id="iddle1574" class="indexterm"/><a id="iddle1691" class="indexterm"/><a id="iddle1712" class="indexterm"/><a id="iddle1798" class="indexterm"/><a id="iddle1902" class="indexterm"/><a id="iddle1923" class="indexterm"/>in every direction. In the final upgrade to this app, we’ll see an even more impressive and powerful feature of sprite graphics that handles detecting collisions.</p></div></div></div><div class="sect1" title="SmileyPop, Version 1.0"><div class="titlepage"><div><div><h1 class="title"><a id="smileypopcomma_version_1dot0"/>SmileyPop, Version 1.0</h1></div></div></div><p>For our closing example, we’ll add one crucial bit of fun to the <span class="emphasis"><em>SmileyExplosion.py</em></span> program: the ability to “pop” the smiley balloons/bubbles by clicking the right mouse button (or by pressing the CONTROL key and clicking on a Mac). The effect is like a balloonpopping game or Ant Smasher, Whack-a-Mole, and so on. We’ll be able to create smiley balloons by dragging the left mouse button, and we’ll pop them (that is, remove them from the screen) by clicking the right mouse button over one or more of the smiley sprites.</p><div class="sect2" title="Detecting Collisions and Removing Sprites"><div class="titlepage"><div><div><h2 class="title"><a id="detecting_collisions_and_removing_sprite"/>Detecting Collisions and Removing Sprites</h2></div></div></div><p>The great news is that the <code class="literal">Sprite</code> class in Pygame comes with collision detection built in. We can use the function <code class="literal">pygame.sprite.collide_rect()</code> to check whether the rectangles holding two sprites have collided; we can use the <code class="literal">collide_circle()</code> function to check whether two round sprites are touching; and if we’re just checking to see whether a sprite has collided with a single point (like the pixel where the user just clicked the mouse), we can use a sprite’s <code class="literal">rect.collidepoint()</code> function to check whether a sprite overlaps, or collides with, that point on the screen.</p><p>If we’ve determined that the user clicked a point that touches one or more sprites, we can remove each of those sprites from our <code class="literal">sprite_list</code> group by calling the <code class="literal">remove()</code> function. We can handle all the logic for popping smiley balloons in our <code class="literal">MOUSEBUTTONDOWN</code> event handler code. To turn <span class="emphasis"><em>SmileyExplosion.py</em></span> into <span class="emphasis"><em>SmileyPop.py</em></span>, we’ll just replace these two lines:</p><a id="pro_id00164"/><pre class="programlisting"><span class="orange">if</span> event.type == pygame.MOUSEBUTTONDOWN:
    mousedown = <span class="orange">True</span></pre><p>with the following seven lines of code:</p><a id="pro_id00165"/><pre class="programlisting">         <span class="orange">if</span> event.type == pygame.MOUSEBUTTONDOWN:
➊           <span class="orange">if</span> pygame.mouse.get_pressed()[0]:    <span class="red"># Regular left mouse button, draw</span>
                 mousedown = <span class="orange">True</span>
➋       <span class="orange">elif</span> pygame.mouse.get_pressed()[2]:  <span class="red"># Right mouse button, pop</span>
➌           pos = pygame.mouse.get_pos()
➍           clicked_smileys = [s <span class="orange">for</span> s <span class="orange">in</span> sprite_list <span class="orange">if</span> s.rect.collidepoint(pos)]
➎           sprite_list.remove(clicked_smileys)</pre><p><a id="iddle1321" class="indexterm"/><a id="iddle1673" class="indexterm"/>The <code class="literal">if</code> statement for <code class="literal">MOUSEBUTTONDOWN</code> events remains the same, but now, we’re interested in <span class="emphasis"><em>which</em></span> button was pressed. At ➊, we check to see if the <span class="emphasis"><em>left</em></span> mouse button was pressed (the first button, at index <code class="literal">[0]</code>); if so, we turn on the <code class="literal">mousedown</code> Boolean flag, and the game loop will draw new smiley faces. At ➋, we see if the <span class="emphasis"><em>right</em></span> mouse button is pressed, beginning the logic to check whether the mouse was clicked over one or more smileys in our <code class="literal">sprite_list</code>.</p><p>First, at ➌, we get the mouse’s location and store it in the variable <code class="literal">pos</code>. At ➍, we use a programming shortcut to generate a list of sprites from <code class="literal">sprite_list</code> that collide with, or overlap, the point the user clicked at <code class="literal">pos</code>. If a sprite <code class="literal">s</code> in the group <code class="literal">sprite_list</code> has a rectangle that collides with the point <code class="literal">pos</code>, group it together as a list <code class="literal">[s]</code> and store the list as <code class="literal">clicked_smileys</code>. That ability to create one list, collection, or array from another based on an <code class="literal">if</code> condition is a powerful feature of Python, and it makes our code much shorter for this app.</p><p>Finally, at ➎, we call the handy <code class="literal">remove()</code> function on our <code class="literal">Group</code> of sprites called <code class="literal">sprite_list</code>. This <code class="literal">remove()</code> function is different from Python’s regular <code class="literal">remove()</code> function, which removes a single item from a list or collection. The <code class="literal">pygame.sprite.Group.remove()</code> function will remove any number of sprites from a list. In this case, it will remove all the sprites from our <code class="literal">sprite_list</code> that collide with the point the user clicked on the screen. Once these sprites are removed from <code class="literal">sprite_list</code>, when <code class="literal">sprite_list</code> is drawn to the screen in our game loop, the clicked sprites are no longer in the list, so they don’t get drawn. It’s like they’ve disappeared—or we’ve popped them like balloons or bubbles!</p><div class="informalfigure"><a id="med_id00128a"/><div class="mediaobject"><a id="med_id00128"/><img src="httpatomoreillycomsourcenostarchimages2189027.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="Putting It All Together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together-id00026"/>Putting It All Together</h2></div></div></div><p>Here’s the complete <span class="emphasis"><em>SmileyPop.py</em></span> code.</p><div class="sect3" title="SmileyPop.py"><div class="titlepage"><div><div><h3 class="title"><a id="smileypopdotpy"/>SmileyPop.py</h3></div></div></div><a id="pro_id00166"/><pre class="programlisting"><span class="orange">import</span> pygame
<span class="orange">import</span> random

BLACK = (0,0,0)
pygame.init()
screen = pygame.display.set_mode([800,600])
pygame.display.set_caption(<span class="green">"Pop a Smiley"</span>)
mousedown = <span class="orange">False</span>
keep_going = <span class="orange">True</span>
clock = pygame.time.Clock()
pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
colorkey = pic.get_at((0,0))
pic.set_colorkey(colorkey)
sprite_list = pygame.sprite.Group()

<span class="orange">class</span> <span class="blue">Smiley</span>(pygame.sprite.Sprite):
    pos = (0,0)
    xvel = 1
    yvel = 1
    scale = 100

    <span class="orange">def</span> <span class="blue">__init__</span>(self, pos, xvel, yvel):
        pygame.sprite.Sprite.__init__(self)
        self.image = pic
        self.scale = random.randrange(10,100)
        self.image = pygame.transform.scale(self.image, (self.scale,self.scale))
        self.rect = self.image.get_rect()
        self.pos = pos
        self.rect.x = pos[0] - self.scale/2
        self.rect.y = pos[1] - self.scale/2
        self.xvel = xvel
        self.yvel = yvel

    <span class="orange">def</span> <span class="blue">update</span>(self):
        self.rect.x += self.xvel
        self.rect.y += self.yvel
        <span class="orange">if</span> self.rect.x &lt;= 0 <span class="orange">or</span> self.rect.x &gt; screen.get_width() - self.scale:
            self.xvel = -self.xvel
        <span class="orange">if</span> self.rect.y &lt;= 0 <span class="orange">or</span> self.rect.y &gt; screen.get_height() - self.scale:
            self.yvel = -self.yvel
<span class="orange">while</span> keep_going:
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
        <span class="orange">if</span> event.type == pygame.QUIT:
            keep_going = <span class="orange">False</span>
        <span class="orange">if</span> event.type == pygame.MOUSEBUTTONDOWN:
            <span class="orange">if</span> pygame.mouse.get_pressed()[0]:   <span class="red"># Regular left mouse button, draw</span>
                mousedown = <span class="orange">True</span>
            <span class="orange">elif</span> pygame.mouse.get_pressed()[2]: <span class="red"># Right mouse button, pop</span>
                pos = pygame.mouse.get_pos()
                clicked_smileys = [s <span class="orange">for</span> s <span class="orange">in</span> sprite_list <span class="orange">if</span> s.rect.collidepoint(pos)]
                sprite_list.remove(clicked_smileys)
        <span class="orange">if</span> event.type == pygame.MOUSEBUTTONUP:
            mousedown = <span class="orange">False</span>
    screen.fill(BLACK)
    sprite_list.update()
    sprite_list.draw(screen)
    clock.tick(60)
    pygame.display.update()
    <span class="orange">if</span> mousedown:
        speedx = random.randint(-5, 5)
        speedy = random.randint(-5, 5)
        newSmiley = Smiley(pygame.mouse.get_pos(),speedx,speedy)
        sprite_list.add(newSmiley)

pygame.quit()</pre><p>Remember that you’ll have to have the <span class="emphasis"><em>CrazySmile.bmp</em></span> image file stored in the same folder or directory as the code to make it work. Once it does work, this program is so much fun to play with, it’s almost addictive! In the next chapter, we’ll learn about the elements of game design that make games fun, and we’ll build a complete game from scratch!</p></div></div></div><div class="sect1" title="What You Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_learned-id00027"/>What You Learned</h1></div></div></div><p>In this chapter, we combined user interaction with animation to create an explosion of smileys on the screen, and we used sprite graphics to make even hundreds of smiley images easy and fast to animate. We learned how to build our own <code class="literal">Sprite</code> class so that we could customize sprites with the features and behaviors we wanted, including data variables, an initialization function, and a custom update function. We also learned how to scale images in Pygame so that our smileys could come in all different shapes and sizes, and we learned the advantages of using <code class="literal">pygame.sprite.Group()</code> to store all our sprites for quick updating and drawing on the screen.</p><p><a id="iddle1253" class="indexterm"/><a id="iddle1776" class="indexterm"/>In our closing example, we added sprite-based collision detection to see whether the user right-clicked the mouse over one or more smiley sprites. We saw how to check for events on the left mouse button separately from the right mouse button. We learned that Python has powerful features for selecting items out of a list based on an <code class="literal">if</code> condition, and we saw how to remove sprites from a <code class="literal">Group</code> using the <code class="literal">remove()</code> function.</p><p>We created fun apps in this chapter, topped off by a SmileyPop app that we’ll make even more game-like in <a class="xref" href="ch10.html" title="Chapter 10. Game Programming: Coding for Fun">Chapter 10</a>. Pygame has given us the final skills we need to program awesome games!</p><p>Programming the cool apps in this chapter has given us the skills to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Use sprite graphics by customizing the <code class="literal">pygame.sprite.Sprite()</code> class.</p></li><li class="listitem"><p>Access, modify, update, and draw a list of sprites using <code class="literal">pygame.sprite.Group()</code> and its functions.</p></li><li class="listitem"><p>Transform an image by applying the <code class="literal">pygame.trasform.scale()</code> function to increase or decrease the image’s size in pixels.</p></li><li class="listitem"><p>Detect sprite collisions using <code class="literal">rect.collidepoint()</code> and similar functions from the <code class="literal">Sprite</code> class.</p></li><li class="listitem"><p>Remove sprites from a <code class="literal">Group</code> using the <code class="literal">remove()</code> function.</p></li></ul></div><div class="sidebar"><a id="programming_challenges-id00028"/><p class="title">Programming Challenges</p><p>Here are three challenge problems to extend the skills developed in this chapter. For sample answers to these challenges, go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span>.</p><p><span class="strong"><strong><span class="orange">#1: RANDOMLY COLORED DOTS</span></strong></span></p><p>Start by choosing your own color triplet to use in the <span class="emphasis"><em>DragDots.py</em></span> program. Then modify the program to draw randomly colored dots by creating a triplet of three random numbers between 0 and 255 to use as your colors. Call your new creation <span class="emphasis"><em>RandomPaint.py</em></span>.</p><p><a id="iddle1185" class="indexterm"/><a id="iddle1385" class="indexterm"/><a id="iddle1890" class="indexterm"/><a id="iddle1904" class="indexterm"/><span class="strong"><strong><span class="orange">#2: PAINTING IN COLORS</span></strong></span></p><p>Let the user draw in two or more consistent colors using any of the following options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Change the current drawing color each time the user presses a key, either to a random color each time or to a specific color for certain keys (like red for R, blue for B, and so on).</p></li><li class="listitem"><p>Draw with different colors for each of the mouse buttons (red for the left mouse button, green for the middle button, and blue for the right mouse button, for example).</p></li><li class="listitem"><p>Add some colored rectangles to the bottom or side of the screen, and modify the program so that if the user clicks in a rectangle, the drawing color changes to the same color as the rectangle.</p></li></ul></div><p>Try one approach, or all three, and save your new file as <span class="emphasis"><em>ColorPaint.py</em></span>.</p><p><span class="strong"><strong><span class="orange">#3: THROWING SMILEYS</span></strong></span></p><p>Pygame has a function called <code class="literal">pygame.mouse.get_rel()</code> that will return the amount of <span class="emphasis"><em>relative</em></span> motion, or how much the mouse’s position has changed in pixels since the last call to <code class="literal">get_rel()</code>, in the x- and y-directions. Modify your <span class="emphasis"><em>SmileyExplosion.py</em></span> file to use the amount of relative mouse motion in the x- and y-directions as the horizontal and vertical speeds of each smiley (instead of generating a pair of random <code class="literal">speedx</code> and <code class="literal">speedy</code> values). This will look like the user is throwing smileys because they will speed off in the direction the user is dragging the mouse!</p><p>To add another realistic effect, slow the smileys slightly by multiplying <code class="literal">xvel</code> and <code class="literal">yvel</code> by a number smaller than 1.0 (like 0.95) in the <code class="literal">update(self)</code> section every time the smileys bounce off an edge of the screen. The smileys will slow down over time, as if friction from each wall bounce is making them move slower and slower. Save your new app as <span class="emphasis"><em>SmileyThrow.py</em></span>.</p></div></div></div></body></html>