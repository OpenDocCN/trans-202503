- en: '**19'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**19'
- en: 'BIOS/UEFI FORENSICS: FIRMWARE ACQUISITION AND ANALYSIS APPROACHES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**BIOS/UEFI取证：固件获取与分析方法**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Recent rootkits targeting UEFI firmware have renewed interest in UEFI firmware
    forensics. Leaks of classified information on state-sponsored BIOS implants, as
    well as the security breach at Hacking Team mentioned in [Chapter 15](ch15.xhtml#ch15),
    have demonstrated the increasingly stealthy and powerful capabilities of malware
    that targets the BIOS and prompted the research community to dig deeper into firmware.
    We’ve already discussed some technical details of these BIOS threats in previous
    chapters. If you haven’t read [Chapters 15](ch15.xhtml#ch15) and [16](ch16.xhtml#ch16),
    we highly recommend doing so before continuing; those chapters cover important
    firmware security concepts that we assume you understand for this discussion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最近针对UEFI固件的rootkit攻击重新激起了人们对UEFI固件取证的兴趣。有关国家支持的BIOS植入程序的机密信息泄露，以及在[第15章](ch15.xhtml#ch15)中提到的Hacking
    Team的安全泄露事件，展示了针对BIOS的恶意软件越来越隐蔽和强大的能力，并促使研究界深入探讨固件领域。我们在前几章中已经讨论了一些关于这些BIOS威胁的技术细节。如果你还没读过[第15章](ch15.xhtml#ch15)和[第16章](ch16.xhtml#ch16)，强烈建议你在继续之前阅读这两章；这两章涉及了固件安全的关键概念，我们假设你已经理解这些概念。
- en: '**NOTE**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this chapter, we use the terms* BIOS *and* UEFI firmware *interchangeably.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们将* BIOS *和* UEFI固件 *交替使用。*'
- en: UEFI firmware forensics is currently an emerging area of research, so security
    researchers working in this field lack conventional tools and approaches. In this
    chapter, we’ll cover some firmware analysis techniques, including various approaches
    to firmware acquisition and methods of parsing and extracting useful information.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，UEFI固件取证是一个新兴的研究领域，因此从事该领域的安全研究人员缺乏传统的工具和方法。在本章中，我们将介绍一些固件分析技术，包括固件获取的不同方法以及解析和提取有用信息的技术。
- en: We first focus on acquiring firmware, which is usually the first step of a forensic
    analysis. We cover both a software and a hardware approach to obtaining a UEFI
    firmware image. Next, we compare these approaches and discuss the advantages and
    disadvantages of each. We then discuss the internal structure of the UEFI firmware
    image and how to parse it in order to extract forensic artifacts. In the context
    of this discussion, we show you how to use UEFITool, an indispensable open source
    firmware analysis tool for browsing and modifying UEFI firmware images. Finally,
    we discuss Chipsec, a tool with very extensive and powerful functionality, and
    consider its applications for forensics analysis. Both tools were introduced in
    [Chapter 15](ch15.xhtml#ch15).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先关注固件获取，这是取证分析的第一步。我们将介绍软件和硬件两种方法来获取UEFI固件镜像。接下来，我们将比较这些方法，并讨论每种方法的优缺点。然后，我们讨论UEFI固件镜像的内部结构，以及如何解析它以提取取证证据。在本次讨论中，我们将展示如何使用UEFITool，这是一款不可或缺的开源固件分析工具，用于浏览和修改UEFI固件镜像。最后，我们讨论Chipsec，这是一款功能非常强大且广泛的工具，并考虑它在取证分析中的应用。两款工具在[第15章](ch15.xhtml#ch15)中已有介绍。
- en: '**Limitations of Our Forensic Techniques**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我们取证技术的局限性**'
- en: 'The material we present here does have some limitations. In modern platforms,
    there are many types of firmware: UEFI firmware, Intel ME firmware, hard drive
    controller firmware, and so on. This chapter is dedicated specifically to the
    analysis of UEFI firmware, which constitutes one of the largest parts of platform
    firmware.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里呈现的材料确实存在一些局限性。在现代平台上，固件种类繁多：UEFI固件、Intel ME固件、硬盘控制器固件等等。本章专门致力于UEFI固件的分析，它是平台固件中最大的一部分。
- en: Note also that firmware is very platform specific; that is, each platform has
    its own peculiarities. In this chapter, we’ll focus on UEFI firmware for Intel
    x86 systems, which constitute the majority of desktop, laptop, and server market
    segments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，固件非常具有平台特性；也就是说，每个平台都有其独特性。在本章中，我们将重点讨论针对Intel x86系统的UEFI固件，这些系统占据了大多数桌面、笔记本和服务器市场份额。
- en: '**Why Firmware Forensics Matter**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为什么固件取证很重要**'
- en: In [Chapter 15](ch15.xhtml#ch15), we saw that modern firmware is a convenient
    place for embedding very powerful backdoors or rootkits, specifically in the BIOS.
    This type of malware is capable of surviving OS reinstallation or hard drive replacement,
    and it gives an attacker control over an entire platform. At the time of this
    writing, most state-of-the-art security software doesn’t take into account UEFI
    firmware threats at all, making them even more dangerous. This gives an attacker
    a big opportunity to implant malware that persists undetected on the target system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 15 章](ch15.xhtml#ch15)中，我们看到现代固件是嵌入非常强大的后门或 rootkit 的便捷位置，尤其是在 BIOS 中。这种类型的恶意软件能够在操作系统重装或硬盘更换后存活，并且使攻击者能够控制整个平台。在写作本文时，大多数最先进的安全软件根本没有考虑到
    UEFI 固件威胁，这使得它们更加危险。这为攻击者提供了一个重要机会，可以在目标系统上植入持久存在且未被检测到的恶意软件。
- en: Next, we outline a couple of specific ways attackers might use firmware rootkits.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们概述了攻击者可能利用固件 rootkit 的几种具体方式。
- en: '***Attacking the Supply Chain***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***攻击供应链***'
- en: Threats targeting UEFI firmware increase the risk of supply chain attacks, because
    attackers can install a malicious implant on a server before it is delivered to
    the data center or to a laptop before it gets to the IT department. And because
    these threats can impact a large number of a service provider’s clients by exposing
    all their secrets, big cloud-computing players like Google have recently started
    to use firmware forensic analysis techniques to ensure that their firmware isn’t
    compromised.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 针对 UEFI 固件的威胁增加了供应链攻击的风险，因为攻击者可以在服务器送往数据中心之前，或者在笔记本电脑送到 IT 部门之前，安装恶意植入物。而且，由于这些威胁可能通过暴露所有秘密影响大量服务提供商的客户，一些大型云计算公司，如
    Google，最近开始使用固件取证分析技术，以确保其固件没有被破坏。
- en: '**GOOGLE TITAN CHIP**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**GOOGLE TITAN 芯片**'
- en: In 2017, Google publicly introduced Titan, a chip that protects platform firmware
    by establishing a hardware root of trust. Trusting your hardware configuration
    is important, especially when it comes to cloud security, where the impact of
    an attack is multiplied by the number of affected clients.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2017 年，Google 公布了 Titan 芯片，这是一款通过建立硬件信任根来保护平台固件的芯片。信任硬件配置至关重要，尤其是在云安全领域，因为攻击的影响会因受影响的客户数量而成倍增加。
- en: Companies that work with big clouds and data, like Amazon, Google, Microsoft,
    Facebook, and Apple, are working on developing (or have developed) hardware to
    control the platform root of trust. Even if attackers use a firmware rootkit to
    compromise a platform, having an isolated root of trust will prevent Secure Boot
    attacks and firmware update attacks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与大型云和数据相关的公司，如 Amazon、Google、Microsoft、Facebook 和 Apple，正在开发（或已经开发）用于控制平台信任根的硬件。即使攻击者利用固件
    rootkit 攻击平台，拥有一个隔离的信任根也能防止 Secure Boot 攻击和固件更新攻击。
- en: '***Compromising BIOS Through Firmware Vulnerability***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过固件漏洞攻破 BIOS***'
- en: Attackers can compromise the platform firmware by exploiting a vulnerability
    in it to bypass BIOS write protection or authentication. For a refresher on this
    attack, return to [Chapter 16](ch16.xhtml#ch16), where we discuss different classes
    of vulnerabilities used to attack the BIOS. To detect these attacks, you could
    use the firmware forensic approaches discussed in this chapter to verify the integrity
    of a platform’s firmware or to help detect malicious firmware modules.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过利用固件中的漏洞，绕过 BIOS 写保护或认证，从而破坏平台固件。如需了解这种攻击，请参阅[第 16 章](ch16.xhtml#ch16)，我们在其中讨论了用于攻击
    BIOS 的不同类型的漏洞。为了检测这些攻击，可以使用本章讨论的固件取证方法来验证平台固件的完整性，或帮助检测恶意固件模块。
- en: '**Understanding Firmware Acquisition**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解固件获取**'
- en: The very first step in BIOS forensic analysis is the process of obtaining an
    image of the BIOS firmware to analyze. To better understand the location of BIOS
    firmware on modern platforms, refer to [Figure 19-1](ch19.xhtml#ch19fig01), which
    demonstrates the architecture of a typical PC system’s chipset.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS 取证分析的第一步是获取 BIOS 固件的映像进行分析。要更好地了解现代平台上 BIOS 固件的位置，请参阅[图 19-1](ch19.xhtml#ch19fig01)，该图展示了典型
    PC 系统芯片组的架构。
- en: 'There are two main components in the chipset: a CPU and a Platform Controller
    Hub (PCH) or South Bridge. The PCH provides a connection between the controllers
    of peripheral devices available on the platform and the CPU. In most modern systems
    based on Intel x86 architecture (including 64-bit platforms), the system firmware
    is located on a flash memory in the Serial Peripheral Interface (SPI) bus ➊, which
    is physically connected to the PCH. The SPI flash constitutes the main target
    for forensic analysis because it stores the firmware we want to analyze.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片组中有两个主要组件：一个CPU和一个平台控制器集线器（PCH）或南桥。PCH提供了平台上外设设备控制器与CPU之间的连接。在大多数基于Intel x86架构（包括64位平台）的现代系统中，系统固件位于串行外设接口（SPI）总线上的闪存中➊，该总线物理上与PCH连接。SPI闪存是法医分析的主要目标，因为它存储了我们想要分析的固件。
- en: '![image](../images/19fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig01.jpg)'
- en: '*Figure 19-1: A block diagram of a modern Intel chipset*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-1：现代Intel芯片组的框图*'
- en: The motherboard of a PC typically has one discrete physical SPI flash chip soldered
    onto it, but you might occasionally encounter systems with multiple SPI flash
    chips. This happens when a single chip doesn’t have enough capacity to store all
    the system firmware; in that case, the platform vendor uses two chips. We discuss
    this situation later in this chapter, in “[Locating the SPI Flash Memory Chip](ch19.xhtml#ch19lev2sec9)”
    on [page 376](ch19.xhtml#page_376).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一块PC主板通常有一个单独的物理SPI闪存芯片焊接在其上，但你可能偶尔会遇到有多个SPI闪存芯片的系统。这种情况发生在单个芯片没有足够的容量来存储所有系统固件时；在这种情况下，平台厂商使用两个芯片。我们将在本章稍后的“[定位SPI闪存芯片](ch19.xhtml#ch19lev2sec9)”中讨论这种情况，见[第376页](ch19.xhtml#page_376)。
- en: '**DUALBIOS TECHNOLOGY**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**双BIOS技术**'
- en: DualBIOS technology also uses multiple SPI flash chips on the motherboard of
    a computer. But unlike the approach just discussed, where multiple SPI flash chips
    store a single firmware image, DualBIOS technology uses multiple chips to store
    different firmware images or multiples of the same firmware image. This technology
    provides additional protection against firmware corruption, because if the firmware
    in one chip is corrupted, the system could boot from a second chip containing
    an identical firmware image.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 双BIOS技术也使用计算机主板上的多个SPI闪存芯片。但与刚才讨论的使用多个SPI闪存芯片存储单一固件镜像的方式不同，双BIOS技术使用多个芯片存储不同的固件镜像或相同固件镜像的多个副本。这项技术提供了额外的固件损坏保护，因为如果一个芯片中的固件损坏，系统可以从第二个包含相同固件镜像的芯片启动。
- en: To acquire the firmware image stored on the SPI flash, you need to be able to
    read the contents of the flash. Generally speaking, you can read the firmware
    using either a software or a hardware approach. In the software approach, you
    attempt to read the firmware image by communicating with the SPI controller using
    software running on the host CPU. In the hardware approach, you physically attach
    a special device called an SPI programmer to the SPI flash, then read the firmware
    image directly from the SPI flash. We’ll cover both approaches, starting with
    the software method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取存储在SPI闪存中的固件镜像，你需要能够读取闪存的内容。一般来说，你可以通过软件方法或硬件方法来读取固件。在软件方法中，你尝试通过与SPI控制器通信来读取固件镜像，通信是通过在主机CPU上运行的软件实现的。在硬件方法中，你物理连接一个叫做SPI编程器的特殊设备到SPI闪存，然后直接从SPI闪存读取固件镜像。我们将介绍这两种方法，首先从软件方法开始。
- en: 'Before we go into the description of the software approach, however, you should
    understand that each approach has its advantages and limitations. One of the benefits
    of dumping UEFI firmware using the software method is that you can do it remotely.
    A user of the target system can run an application to dump the contents of the
    SPI flash and send it to a forensic analyst. But this approach also has a major
    drawback: if an attacker has already compromised the system firmware, he or she
    could interfere with the process of firmware acquisition by forging the data read
    from the SPI flash. This makes the software approach somewhat unreliable.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们进入软件方法的描述之前，你应该明白每种方法都有其优缺点。使用软件方法转储UEFI固件的一个好处是可以远程操作。目标系统的用户可以运行一个应用程序，将SPI闪存的内容转储并发送给法医分析师。但这种方法也有一个主要缺点：如果攻击者已经妥协了系统固件，他或她可能通过伪造从SPI闪存读取的数据来干扰固件获取过程。这使得软件方法在一定程度上不可靠。
- en: The hardware approach doesn’t have the same drawback. Even though you must be
    physically present and it requires you to open the target system’s chassis, this
    method directly reads the contents of the powered-off system’s SPI flash without
    giving the attacker any opportunity to counterfeit the data (unless you’re dealing
    with a hardware implant, which we don’t cover in this book).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件方法没有这种缺点。尽管你必须亲自到场并且需要打开目标系统的机箱，但此方法直接读取关闭电源系统的 SPI 闪存内容，而不会给攻击者任何伪造数据的机会（除非你面对的是硬件植入物，但本书不讨论这一内容）。
- en: '**The Software Approach to Firmware Acquisition**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**固件获取的软方法**'
- en: In the software approach to dumping UEFI firmware from the target system, you
    read the contents of the SPI flash from the operating system. You can access modern
    systems’ SPI controllers through registers in the *PCI configuration space* (a
    block of registers that specify device configuration on the PCI bus). These registers
    are memory mapped, and you can read and write to them using regular memory read
    and write operations. In this section, we’ll demonstrate how to locate these registers
    and communicate with the SPI controller.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在从目标系统转储 UEFI 固件的软件方法中，你通过操作系统读取 SPI 闪存的内容。你可以通过 *PCI 配置空间*（指定 PCI 总线上设备配置的一组寄存器）中的寄存器访问现代系统的
    SPI 控制器。这些寄存器是内存映射的，你可以使用常规的内存读写操作对它们进行读写。在本节中，我们将演示如何定位这些寄存器并与 SPI 控制器进行通信。
- en: Before we proceed, you should know that the location of an SPI register is chipset
    specific, so in order to communicate with an SPI controller, we need to refer
    to the chipset dedicated to the platform we’re targeting. In this chapter, we’ll
    demonstrate how to read the SPI flash on chipsets in Intel’s 200 Series (the location
    of SPI registers can be found at *[https://www.intel.com/content/www/us/en/chipsets/200-series-chipset-pch-datasheet-vol-2.html](https://www.intel.com/content/www/us/en/chipsets/200-series-chipset-pch-datasheet-vol-2.html)*),
    which are the latest chipsets for desktop systems at the time of this writing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，你需要知道 SPI 寄存器的位置是芯片组特定的，因此为了与 SPI 控制器进行通信，我们需要参考专为我们目标平台设计的芯片组。在本章中，我们将演示如何读取英特尔
    200 系列芯片组（SPI 寄存器的位置可以在 *[https://www.intel.com/content/www/us/en/chipsets/200-series-chipset-pch-datasheet-vol-2.html](https://www.intel.com/content/www/us/en/chipsets/200-series-chipset-pch-datasheet-vol-2.html)*）的
    SPI 闪存，这些芯片组是本文写作时最新的桌面系统芯片组。
- en: It’s also worth mentioning that the memory locations that correspond to the
    registers exposed via the PCI configuration space are mapped in the kernel-mode
    address space and, as a result, aren’t accessible to code running in the user-mode
    address space. You would need to develop a kernel-mode driver to access the address
    range. The Chipsec tool discussed later in this chapter provides its own kernel-mode
    driver for accessing the PCI configuration space.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，通过 PCI 配置空间暴露的寄存器对应的内存位置被映射到内核模式地址空间，因此无法访问在用户模式地址空间中运行的代码。你需要开发一个内核模式驱动程序来访问该地址范围。本章稍后讨论的
    Chipsec 工具提供了自己的内核模式驱动程序，用于访问 PCI 配置空间。
- en: '***Locating PCI Configuration Space Registers***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定位 PCI 配置空间寄存器***'
- en: First we need to locate the memory range where the SPI controller’s registers
    are mapped. This memory range is called the *Root Complex Register Block (RCRB)*.
    At offset 3800h in the RCRB, you’ll find the *SPI Base Address Register (SPIBAR)*,
    which holds the base address of memory-mapped SPI registers (see [Figure 19-2](ch19.xhtml#ch19fig02)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定位 SPI 控制器寄存器映射的内存范围。这个内存范围被称为 *根复合寄存器块（RCRB）*。在 RCRB 的 3800h 偏移处，你会找到
    *SPI 基地址寄存器（SPIBAR）*，它保存了内存映射 SPI 寄存器的基地址（参见 [图 19-2](ch19.xhtml#ch19fig02)）。
- en: '![image](../images/19fig02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig02.jpg)'
- en: '*Figure 19-2: The location of SPI control and status registers in system memory*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-2：系统内存中 SPI 控制和状态寄存器的位置*'
- en: '**PCIE BUS**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**PCIE 总线**'
- en: 'The PCI Express (PCIe) bus is a high-speed serial bus standard used on virtually
    all modern PCs across different market segments: consumer laptops and desktops,
    data center servers, and so on. The PCIe bus serves as an interconnection between
    various components and peripheral devices in the computer. Many integrated chipset
    devices (SPI flash, memory controller, and so forth) are represented as PCIe endpoints
    on the bus.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Express（PCIe）总线是一种高速串行总线标准，几乎在所有现代 PC 中都有使用，包括消费类笔记本电脑和台式机、数据中心服务器等。PCIe
    总线作为计算机内部各个组件和外部设备之间的互连。许多集成的芯片组设备（如 SPI 闪存、内存控制器等）作为 PCIe 总线上的端点设备存在。
- en: The RCRB address is stored in the *Root Complex Base Address (RCBA)* PCI register,
    which is located on bus 0, device 31h, function 0\. This is a 32-bit register,
    and the address of the RCRB is provided in bits 31:14\. We assume that the lower
    14 bits of the RCRB’s address are zeros, since RCRB is aligned at the boundary
    of 16Kb. Once we get the RCRB’s address, we can obtain the SPIBAR value by reading
    memory at the 3800h offset. In the next section, we discuss the SPI registers
    in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: RCRB 地址存储在 *根复合基址（RCBA）* PCI 寄存器中，该寄存器位于总线 0，设备 31h，功能 0。这是一个 32 位寄存器，RCRB 的地址存储在第
    31 位到第 14 位中。我们假设 RCRB 地址的低 14 位为零，因为 RCRB 按照 16Kb 边界对齐。一旦我们获得 RCRB 的地址，我们可以通过读取
    3800h 偏移量处的内存来获取 SPIBAR 值。在下一节中，我们将更详细地讨论 SPI 寄存器。
- en: '**SPI FLASH FIRMWARE**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPI FLASH 固件**'
- en: The SPI flash contains not only BIOS firmware but also other types of platform
    firmware, like Intel ME (Manageability Engine), Ethernet controller firmware,
    and vendor-specific firmware and data. The various types of firmware differ in
    their locations and access control permissions. For instance, the host OS can’t
    access Intel ME firmware, so the software approach for acquiring firmware won’t
    work for Intel ME.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 闪存不仅包含 BIOS 固件，还包括其他类型的平台固件，如 Intel ME（管理引擎）、以太网控制器固件以及供应商特定的固件和数据。不同类型的固件在其位置和访问控制权限上有所不同。例如，主机操作系统无法访问
    Intel ME 固件，因此获取固件的软件方法对于 Intel ME 不适用。
- en: '***Calculating SPI Configuration Register Addresses***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算 SPI 配置寄存器地址***'
- en: Once we’ve obtained the SPIBAR value, which provides us with the location of
    the SPI registers in memory, we can program the registers to read the contents
    of an SPI flash. The offsets of the SPI registers may vary depending on the platform,
    so the best way to determine the actual values for a given hardware configuration
    is to look up the values in the platform chipset documentation. For instance,
    for platforms supporting Intel’s latest CPU at the time of this writing (Kaby
    Lake), we can consult the Intel 200 Series Chipset Family Platform Controller
    Hub datasheet to find the location of the SPI memory-mapped registers. The information
    is in the section called “Serial Peripheral Interface.” For each SPI register,
    the datasheet provides its offset from the SPIBAR value, register name, and the
    register default value at the platform reset. We’ll use this datasheet as a reference
    in this section to determine the addresses of the SPI registers we’re interested
    in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了 SPIBAR 值，该值为我们提供了 SPI 寄存器在内存中的位置，我们就可以编程寄存器来读取 SPI 闪存的内容。SPI 寄存器的偏移量可能会根据平台有所不同，因此确定给定硬件配置的实际值的最佳方法是查阅平台芯片组文档。例如，对于本文写作时支持
    Intel 最新 CPU（Kaby Lake）的平台，我们可以查阅 Intel 200 系列芯片组家族平台控制器集线器数据手册，以查找 SPI 内存映射寄存器的位置。相关信息位于名为“串行外设接口”的章节中。对于每个
    SPI 寄存器，数据手册提供了从 SPIBAR 值的偏移量、寄存器名称以及平台重置时寄存器的默认值。我们将在本节中使用该数据手册作为参考，来确定我们感兴趣的
    SPI 寄存器的地址。
- en: '***Using the SPI Registers***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 SPI 寄存器***'
- en: Now that you know how to find the addresses of SPI registers, you can figure
    out which one you’ll use to read the contents of the SPI flash. [Table 19-1](ch19.xhtml#ch19tab01)
    lists all the registers we’ll need to obtain an image of the SPI flash.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何查找 SPI 寄存器的地址，你可以确定使用哪个寄存器来读取 SPI 闪存的内容。[表 19-1](ch19.xhtml#ch19tab01)
    列出了我们需要用来获取 SPI 闪存镜像的所有寄存器。
- en: '**Table 19-1:** SPI Registers for Firmware Acquisition'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 19-1：** 固件获取的 SPI 寄存器'
- en: '| **Offset from SPIBAR** | **Register name** | **Register description** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **从 SPIBAR 的偏移量** | **寄存器名称** | **寄存器描述** |'
- en: '| --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 04h–05h | HSFS | Hardware sequencing flash status |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 04h–05h | HSFS | 硬件排序闪存状态 |'
- en: '| 06h–07h | HSFC | Hardware sequencing flash control register |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 06h–07h | HSFC | 硬件排序闪存控制寄存器 |'
- en: '| 08h–0Bh | FADDR | Flash address |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 08h–0Bh | FADDR | 闪存地址 |'
- en: '| 10h–4Fh | FDATAX | Array of flash data |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 10h–4Fh | FDATAX | 闪存数据数组 |'
- en: '| 58h–5Bh | FREG1 | Flash region 1 (BIOS descriptor) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 58h–5Bh | FREG1 | 闪存区域 1（BIOS 描述符） |'
- en: We’ll discuss each of these registers in the following sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论这些寄存器。
- en: '**The FREG1 Register**'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**FREG1 寄存器**'
- en: The register we’ll start with is *flash region 1 (FREG1)*. It provides the location
    of the BIOS region on the SPI flash. The layout of this 32-bit-length register
    is presented in [Figure 19-3](ch19.xhtml#ch19fig03).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要介绍的寄存器是 *闪存区域 1（FREG1）*。它提供了 BIOS 区域在 SPI 闪存中的位置。此 32 位长度寄存器的布局见 [图 19-3](ch19.xhtml#ch19fig03)。
- en: '![image](../images/19fig03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig03.jpg)'
- en: '*Figure 19-3: The layout of FREG1 SPI register*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-3：FREG1 SPI 寄存器布局*'
- en: The Region Base field ➋ provides 24:12 bits of the base address for the BIOS
    region in the SPI flash. Since the BIOS region is aligned at 4Kb, the lowest 12
    bits of the region’s base address start at 0\. The Region Limit field ➊ provides
    24:12 bits for the BIOS region in the SPI flash. For instance, if the Region Base
    field contains a value of 0xaaa and Region Limit contains a value of 0xbbb, then
    the BIOS regions spans from 0xaaa000 to 0xbbbfff on the SPI flash.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Region Base 字段 ➋ 提供了 BIOS 区域在 SPI 闪存中的基地址的 24:12 位。由于 BIOS 区域是按 4KB 对齐的，因此该区域基地址的最低
    12 位从 0 开始。Region Limit 字段 ➊ 提供了 BIOS 区域在 SPI 闪存中的 24:12 位。例如，如果 Region Base 字段的值为
    0xaaa，Region Limit 字段的值为 0xbbb，则 BIOS 区域从 0xaaa000 到 0xbbbfff 之间。
- en: '**The HSFC Register**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**HSFC 寄存器**'
- en: The *hardware sequencing flash control (HSFC)* register allows us to send commands
    to the SPI controller. (In the specification, these commands are referred to as
    *cycles*.) You can see the layout of the HSFC register in [Figure 19-4](ch19.xhtml#ch19fig04).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*硬件顺序闪存控制 (HSFC)* 寄存器允许我们向 SPI 控制器发送命令。（在规格说明中，这些命令被称为 *周期*。）您可以在 [图19-4](ch19.xhtml#ch19fig04)
    中看到 HSFC 寄存器的布局。'
- en: '![image](../images/19fig04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig04.jpg)'
- en: '*Figure 19-4: The layout of HSFC SPI register*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-4：HSFC SPI 寄存器布局*'
- en: 'We use the HSFC register to send a read/write/delete cycle to the SPI flash.
    The 2-bit FCYCLE field ➌ encodes the operation to perform the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 HSFC 寄存器向 SPI 闪存发送读/写/删除周期。2 位的 FCYCLE 字段 ➌ 编码了要执行的操作：
- en: '**00** Read a block of data from the SPI flash'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**00** 从 SPI 闪存读取数据块'
- en: '**01** Write a block of data to the SPI flash'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**01** 向 SPI 闪存写入数据块'
- en: '**11** Erase a block of data on the SPI flash'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**11** 擦除 SPI 闪存中的数据块'
- en: '**10** Reserved'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**10** 保留'
- en: For read and write cycles, the FDBC field ➋ indicates the number of bytes that
    should be transferred to and from the SPI flash. The content of this field is
    zero based; a value of 000000b represents 1 byte, and a value of 111111b represents
    64 bytes. As a result, the number of bytes to transfer is the value of this field
    plus 1.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读写周期，FDBC 字段 ➋ 表示应传输到 SPI 闪存的字节数。此字段的内容是以零为基准的；000000b 表示 1 字节，111111b 表示
    64 字节。因此，要传输的字节数为该字段的值加 1。
- en: The FGO field ➍ is used to initiate the SPI flash operation. When the value
    of this field is 1b, the SPI controller will read, write, and erase the data based
    on the values written to the FCYCLE and FDBC fields. Before setting the FGO field,
    the software needs to have specified all the registers that indicate the type
    of the operation, the amount of data, and the SPI flash address.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: FGO 字段 ➍ 用于启动 SPI 闪存操作。当此字段的值为 1b 时，SPI 控制器将根据写入 FCYCLE 和 FDBC 字段的值进行读、写和擦除操作。在设置
    FGO 字段之前，软件需要指定所有指示操作类型、数据量和 SPI 闪存地址的寄存器。
- en: The final HSFC field that deserves our attention is *flash SPI SMI# enable (FSMIE)*
    ➊. When this field is set, the chipset generates a System Management Interrupt
    (SMI), which leads to the execution of the SMM code. As we’ll see in “[Considering
    the Drawbacks of the Software Approach](ch19.xhtml#ch19lev2sec7)” on [page 373](ch19.xhtml#page_373),
    you could use FSMIE to counteract the firmware image acquisition.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注的最后一个 HSFC 字段是 *闪存 SPI SMI# 启用 (FSMIE)* ➊。当该字段被设置时，芯片组会生成系统管理中断（SMI），从而触发
    SMM 代码的执行。正如我们在 “[考虑软件方法的缺点](ch19.xhtml#ch19lev2sec7)” 的 [第373页](ch19.xhtml#page_373)
    中所看到的，您可以使用 FSMIE 来对抗固件映像获取。
- en: '**COMMUNICATING WITH THE SPI CONTROLLER**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**与 SPI 控制器通信**'
- en: 'Using the HSFC register isn’t the only way to send commands to the SPI controller.
    Generally, there are two ways to communicate with the SPI flash: hardware sequencing
    and software sequencing. With the hardware-sequencing method we’re showing here,
    we let the hardware pick the SPI commands that get sent for read/write operations
    (which is exactly what the HSFC register is used for). Software sequencing offers
    us more power to choose which specific commands get sent to read/write operations.
    In this section, we use hardware sequencing through the HSFC register because
    it’s easy and it provides us with the functionality we need to read the BIOS firmware.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HSFC寄存器并不是向SPI控制器发送命令的唯一方式。通常，与SPI闪存通信有两种方式：硬件序列和软件序列。在这里我们展示的硬件序列方法是通过让硬件选择发送用于读/写操作的SPI命令（这正是HSFC寄存器的作用）。软件序列则让我们有更多的选择，可以指定具体的命令来执行读/写操作。在本节中，我们通过HSFC寄存器使用硬件序列，因为它简单且能提供读取BIOS固件所需的功能。
- en: '**The FADDR Register**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**FADDR寄存器**'
- en: We use the *flash address (FADDR)* register to specify the SPI flash linear
    address for read, write, and erase operations. This register is 32 bits, but we
    use only the lower 24 bits to specify a linear address for the operation. The
    upper 8 bits of this register are reserved and unused.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*闪存地址(FADDR)*寄存器来指定用于读、写和擦除操作的SPI闪存线性地址。该寄存器为32位，但我们只使用低24位来指定操作的线性地址。该寄存器的高8位是保留的且未使用。
- en: '**The HSFS Register**'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**HSFS寄存器**'
- en: Once we’ve initiated the SPI cycle by setting the FGO field of the HSFC register,
    we can determine when the cycle has finished by looking at the *hardware sequencing
    flash status (HSFS)* register. This register is composed of multiple fields that
    provide information on the status of the requested operation. In [Table 19-2](ch19.xhtml#ch19tab02),
    you can see the HSFS fields used to read the SPI image.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过设置HSFC寄存器的FGO字段启动了SPI周期，就可以通过查看*硬件序列闪存状态（HSFS）*寄存器来确定周期是否已完成。该寄存器由多个字段组成，这些字段提供有关请求操作状态的信息。在[表19-2](ch19.xhtml#ch19tab02)中，您可以看到用于读取SPI映像的HSFS字段。
- en: '**Table 19-2:** The SPI Register HSFS Fields'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**表19-2：** SPI寄存器HSFS字段'
- en: '| **Field offset** | **Field size** | **Field name** | **Field description**
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **字段偏移** | **字段大小** | **字段名称** | **字段描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0h | 1 | FDONE | Flash cycle done |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 0h | 1 | FDONE | 闪存周期完成 |'
- en: '| 1h | 1 | FCERR | Flash cycle error |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 1h | 1 | FCERR | 闪存周期错误 |'
- en: '| 2h | 1 | AEL | Access error log |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 2h | 1 | AEL | 访问错误日志 |'
- en: '| 5h | 1 | SCIP | SPI cycle in progress |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 5h | 1 | SCIP | SPI周期进行中 |'
- en: 'The FDONE bit is set by the chipset when the previous flash cycle (initiated
    by the HSFC register’s FGO field) is complete. The FCERR and AEL bits indicate
    that an error has occurred during the SPI flash cycle and that the returned data
    may not contain valid values, respectively. The SCIP bit indicates that the flash
    cycle is in progress. We set the SCIP by setting the FGO bit, and the SCIP clears
    when the value of FDONE is 1\. Based on this information, we can determine that
    the operation we initiated has completed successfully when the following expression
    is true:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当上一个闪存周期（由HSFC寄存器的FGO字段启动）完成时，芯片组会设置FDONE位。FCERR和AEL位指示在SPI闪存周期中发生了错误，返回的数据可能不包含有效值。SCIP位指示闪存周期正在进行中。我们通过设置FGO位来设置SCIP，且当FDONE的值为1时，SCIP会被清除。根据这些信息，我们可以确定当以下表达式为真时，我们启动的操作已成功完成：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**The FDATAX Registers**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**FDATAX寄存器**'
- en: The *array of flash data (FDATAX)* registers hold the data to be read from or
    written to the SPI flash. Each register is 32 bits, and the total number of FDATAX
    registers in use depends on the amount of bytes to transfer, which is specified
    in the HSFC register’s FDBC field.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*闪存数据数组(FDATAX)*寄存器保存着从SPI闪存读取或写入的数据。每个寄存器是32位的，使用的FDATAX寄存器总数取决于要传输的字节数，这个字节数由HSFC寄存器的FDBC字段指定。'
- en: '***Reading Data from the SPI Flash***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从SPI闪存读取数据***'
- en: Now let’s put together all this information and see how to read data from the
    SPI flash using these registers. First, we locate the Root Complex Registers Block,
    from which we can determine the base address of SPI memory-mapped registers and
    get access to those registers. By reading the FREG1 SPI register, we can determine
    the location of the BIOS region on the flash—that is, the BIOS starting address
    and BIOS limit.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将所有这些信息汇总起来，看看如何使用这些寄存器从SPI闪存中读取数据。首先，我们定位根复合寄存器块，从中可以确定SPI内存映射寄存器的基地址，并获取对这些寄存器的访问权限。通过读取FREG1
    SPI寄存器，我们可以确定BIOS区域在闪存中的位置——即BIOS的起始地址和BIOS限制。
- en: Next, we read the BIOS region using the SPI registers just described. This step
    is demonstrated in [Figure 19-5](ch19.xhtml#ch19fig05).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用刚才描述的SPI寄存器读取BIOS区域。此步骤在[图19-5](ch19.xhtml#ch19fig05)中进行了演示。
- en: '![image](../images/19fig05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig05.jpg)'
- en: '*Figure 19-5: Reading data from the SPI flash*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-5：从SPI闪存读取数据*'
- en: First, we set FADDR to the linear address of the flash memory region that we
    want to read ➊. Then we specify the total number of bytes to read from flash memory
    by setting the FDBC field ➋ of the flash control register. (A value of 111111b
    would read 64 bytes per cycle.) Next we set the FCYCLE field ➌ with the 00b value,
    which indicates the read cycle and sets the FGO bit ➍ that starts our flash reading
    operation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将FADDR设置为我们要读取的闪存区域的线性地址 ➊。然后，我们通过设置闪存控制寄存器的FDBC字段 ➋ 来指定从闪存读取的总字节数。（111111b的值表示每次读取64字节。）接着，我们用00b值设置FCYCLE字段
    ➌，该值表示读取周期并设置启动我们闪存读取操作的FGO位 ➍。
- en: Once we set the FGO bit, we need to monitor the flash status register to know
    when the operation is complete. We can do this by checking the FDONE, FCERR, AEL,
    and SCIP fields ➎. Once the read operation is finished, we read flash data from
    the FDATAX registers ➏. The FDATAX[1] register provides us with the first 4 bytes
    of flash memory at the target address specified in the FADDR register; FDATAX[2]
    provides us with the second 4 bytes of flash memory, and so on. By repeating these
    steps and incrementing the FADDR value by 64 bytes in each iteration, we read
    the whole BIOS region from the SPI flash.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了FGO位，我们需要监控闪存状态寄存器，以了解操作何时完成。我们可以通过检查FDONE、FCERR、AEL和SCIP字段 ➎ 来做到这一点。读取操作完成后，我们从FDATAX寄存器
    ➏ 中读取闪存数据。FDATAX[1]寄存器提供我们目标地址（由FADDR寄存器指定）处的前4个字节闪存；FDATAX[2]提供第二组4个字节闪存，以此类推。通过重复这些步骤，并在每次迭代时将FADDR值增加64字节，我们可以从SPI闪存中读取整个BIOS区域。
- en: '***Considering the Drawbacks of the Software Approach***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***考虑到软件方法的缺点***'
- en: The software approach to BIOS firmware dumping is convenient because it doesn’t
    require you to be physically present; with this method, you can read the contents
    of the SPI flash remotely. But it isn’t robust against an attacker who has already
    compromised the system firmware and can execute malicious code in SMM.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS固件转储的软件方法很方便，因为它不需要你在场；通过这种方法，你可以远程读取SPI闪存的内容。但它对已经破坏了系统固件并能在SMM中执行恶意代码的攻击者来说并不稳健。
- en: As we’ve noted, the HSFC register has an FSMIE bit that triggers an SMI when
    the flash cycle completes. If an attacker has already compromised SMM and is able
    to set the FSMIE bit before the firmware acquisition software sets the FGO bit,
    then the attacker will receive control once the SMI is generated and will be able
    to modify the contents of the FDATAX registers. As a result, the firmware acquisition
    software will read forged values from FDATAX and won’t be able to get an original
    image of the BIOS region. [Figure 19-6](ch19.xhtml#ch19fig06) demonstrates this
    attack.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所注意到的，HSFC寄存器有一个FSMIE位，当闪存周期完成时，它会触发SMI。如果攻击者已经破坏了SMM并且能够在固件获取软件设置FGO位之前设置FSMIE位，那么攻击者将在SMI生成后控制系统，并能够修改FDATAX寄存器的内容。因此，固件获取软件将从FDATAX中读取伪造的值，无法获得BIOS区域的原始镜像。[图19-6](ch19.xhtml#ch19fig06)演示了这种攻击。
- en: '![image](../images/19fig06.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig06.jpg)'
- en: '*Figure 19-6: Subverting a software BIOS acquisition via SMI*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-6：通过SMI破坏软件BIOS获取*'
- en: Before the reader sets the FGO bit ➋ in the flash control register, the attacker
    writes 1 to the register’s FSMIE bit ➊. Once the cycle is finished and data is
    written back to the FDATAX registers, an SMI is triggered and the attacker receives
    control ➌. Then the attacker modifies the contents of the FDATAX registers ➍ to
    conceal the attack on the BIOS firmware. After regaining control, the reader will
    receive fake data ➎ and won’t detect the compromised firmware.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: This attack demonstrates that the software approach doesn’t provide a 100 percent
    reliable solution for firmware acquisition. In the following section, we’ll discuss
    the hardware approach to obtaining system firmware for forensic analysis. Conducting
    forensic analysis by physically attaching a device to the SPI flash avoids the
    possibility of the attack depicted in [Figure 19-6](ch19.xhtml#ch19fig06).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**The Hardware Approach to Firmware Acquisition**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To guarantee we have acquired the actual BIOS image stored on the SPI flash
    and not one already compromised by an attacker, we can use the hardware approach.
    With this approach, we physically attach a device to the SPI flash memory and
    read its contents directly. This is the best solution because it’s more trustworthy
    than the software approach. As an extra benefit, this approach allows us to obtain
    other firmware stored on the SPI flash, like ME and GBE firmware, which might
    not be accessible with the software approach due to restrictions enforced by the
    SPI controller.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The SPI bus on modern systems allows multiple masters to communicate with the
    SPI flash. For instance, on systems based on the Intel chipset, there are generally
    three masters: the host CPU, the Intel ME, and GBE. These three masters have different
    access rights to different regions of the SPI flash. On most modern platforms,
    the host CPU can’t read and write to the SPI flash region containing the Intel
    ME and GBE firmware.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19-7](ch19.xhtml#ch19fig07) demonstrates a typical setup for obtaining
    the BIOS firmware image by reading the SPI flash.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-7: A typical setup for dumping the SPI flash image*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In order to read data from the flash memory, we need an additional device, called
    an *SPI programmer*, which we physically attach to the SPI flash memory chip on
    the target system. We also connect the SPI programmer via a USB or UART interface
    to a host that we use to obtain the BIOS firmware image. We would then run some
    particular software on the programmer to make it read data from the flash memory
    chip and transfer the data to the analyst’s computer. This might be proprietary
    software provided with a particular SPI programmer, or it could be an open source
    solution such as the Flashrom tool, which is discussed later in “[Reading the
    SPI Flash with the FT2232 Mini Module](ch19.xhtml#ch19lev2sec10)” on [page 377](ch19.xhtml#page_377).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '***Reviewing a Lenovo ThinkPad T540p Case Study***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The hardware approach is even more specific than the software approach. It requires
    you to consult platform documentation in order to learn what kind of flash memory
    the platform uses to store the firmware and where the firmware is physically located
    in the system. In addition, there are numerous flash programming devices for specific
    hardware we could use to read the contents of the flash memory. We won’t discuss
    the various hardware and software options available for system firmware acquisition,
    because there are simply too many. Instead, we’ll go over one of the possible
    ways to dump firmware from the Lenovo ThinkPad T540p using the FT2232 SPI programmer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We chose this SPI programmer because of its relatively low price (about $30)
    and flexibility, as well as our prior experience of working with it. As we’ve
    mentioned, there are many solutions, and each has its unique features, advantages,
    and drawbacks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**DEDIPROG SF100 ISP IC PROGRAMMER**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Another device we’d like to mention is the Dediprog SF100 ISP IC Programmer
    (shown in [Figure 19-8](ch19.xhtml#ch19fig08)). It’s popular in the security research
    community, supports many SPI flashes, and offers extensive functionality. Minnowboard,
    an open source reference board for hardware and firmware developers, has a good
    tutorial on using Dediprog for updating firmware at *[https://minnowboard.org/tutorials/updating-firmware-via-spi-flash-programmer/](https://minnowboard.org/tutorials/updating-firmware-via-spi-flash-programmer/).*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-8: A Dediprog SF100 ISP IC Programmer*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '***Locating the SPI Flash Memory Chip***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by physically reading the firmware image from the Lenovo ThinkPad
    T540p platform. First, to dump the system firmware from the target system, we
    need to find where, on the main board, the SPI flash memory chips are located.
    To do this, we consulted the Hardware Maintenance Manual (*[https://thinkpads.com/support/hmm/hmm_pdf/t540p_w540_hmm_en_sp40a26003_01.pdf](https://thinkpads.com/support/hmm/hmm_pdf/t540p_w540_hmm_en_sp40a26003_01.pdf)*)
    for this laptop model and took apart the target system’s hardware. In [Figures
    19-9](ch19.xhtml#ch19fig09) and [19-10](ch19.xhtml#ch19fig10), you can see the
    locations of the two flash memory chips. [Figure 19-9](ch19.xhtml#ch19fig09) shows
    a complete image of the system board. The SPI flash chips are located in the highlighted
    area.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t repeat the actions described in this section unless you are 100 percent
    sure of what you’re doing. An invalid or incorrect configuration of the tools
    may brick the target system.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig09.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-9: The Lenovo ThinkPad T540p mainboard with SPI flash modules*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19-10](ch19.xhtml#ch19fig10) zooms in on the region highlighted in
    [Figure 19-9](ch19.xhtml#ch19fig09) so you can see the SPI flash chips more clearly.
    This laptop model uses two SOIC-8 flash memory modules to store the firmware—a
    64Mb (8MB) one and a 32Mb (4MB) one. This is a very popular solution on many modern
    desktops and laptops.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-10: The location of the SPI flash modules on the mainboard of the
    laptop*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Since two separate chips are used to store the system firmware, we’ll need to
    dump the contents of both. We’ll obtain the final firmware image by concatenating
    the images from the two flash memory chips into a single file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '***Reading the SPI Flash with the FT2232 Mini Module***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we’ve identified the physical location of the chips, we can connect the
    SPI programmer’s pins to the flash module on the system board. The datasheet (*[http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf](http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf)*)
    for the FT2232H Mini Module shows us which pins we should use to attach the device
    to the memory chip. [Figure 19-11](ch19.xhtml#ch19fig11) demonstrates the layout
    of the pins for both the FT2232H Mini Module and the SPI flash chip.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The FT2232H has two sets of pins, corresponding to two channels: Channel 2
    and Channel 3\. You may use either channel to read the contents of the SPI flash
    memory. In our experiment, we use Channel 3 to attach the FT2232H to the SPI memory
    chip. [Figure 19-11](ch19.xhtml#ch19fig11) shows which of the FT2232H pins we
    connected to the corresponding pins of the SPI flash memory chip.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to connecting the FT2232H to the memory chip, we need to configure
    it to operate in USB bus-powered mode. The FT2232H Mini Module supports two modes
    of operating: *USB bus-powered* and *self-powered*. In the bus-powered mode, the
    mini module takes power from the USB bus it is attached to, and in self-powered
    mode, the power is provided independently of the USB bus connection.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig11.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-11: The layout of the pins for the FT2232H Mini Module and SPI flash
    chip*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: To help us attach our SPI programmer to the SPI chip module, we use a SOIC-8
    clip, as shown in [Figure 19-12](ch19.xhtml#ch19fig12). This clip allows us to
    easily connect the mini module’s pins to the corresponding pins of the flash memory
    chip.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig12.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-12: Attaching the FT2232H Mini Module to the SPI flash chip*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Once we connect all the components, we can read the contents of the SPI flash
    chip. To do this, we use an open source tool called *Flashrom* (*[https://www.flashrom.org/Flashrom](https://www.flashrom.org/Flashrom)*).
    This tool was developed specifically for identifying, reading, writing, verifying,
    and erasing flash chips. It supports a large number of flash chips and works with
    many different SPI programmers, including the FT2232H Mini Module.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-1](ch19.xhtml#ch19list01) shows the results of running Flashrom
    to read the contents of both SPI flash chips on the Lenovo ThinkPad T540p platform.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 19-1: Dumping SPI flash images with the Flashrom tool*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: First, we run Flashrom to dump the contents of the first SPI flash chip, passing
    it a programmer type and port number as parameters ➊. The type we specify, 2232H,
    corresponds to our FT2232H Mini Module, and port B corresponds to Channel 3, the
    one we’re using to connect to the SPI flash chip. The `--read` parameter tells
    Flashrom to read the contents of the SPI flash memory into the *dump_1.bin* file.
    Once we run the tool, it displays the type of the detected SPI flash chip—in our
    case, Macronix MX25L6473E ➋. Once Flashrom finishes reading the flash memory,
    it outputs a confirmation ➌.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: After reading the first flash chip, we reconnect the clip to the second chip
    and run Flashrom again to dump the second chip’s contents into the *dump_2.bin*
    file. Once this operation is done, we create a complete image of the firmware
    by concatenating the two dumped images ➍.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: We have now dumped a complete, trustworthy image of the firmware. Even if the
    BIOS is already infected and an attacker attempts to thwart our firmware acquisition,
    we’ll still obtain the actual firmware code and data. Next, we’ll analyze it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing the Firmware Image with UEFITool**'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we obtain a firmware image from the target system’s SPI flash, we can analyze
    it. In this section, we’ll cover the basic components of platform firmware, such
    as firmware volumes, volume files, and the sections necessary for understanding
    the layout of the UEFI firmware in the flash image. Then we’ll focus on the most
    important steps in the forensic analysis of firmware.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '*In this section, we’ll provide high-level descriptions rather than detailed
    definitions of the data structures used, since this is too large a subject and
    in-depth coverage is beyond the scope of this chapter. We will, however, provide
    references to documentation containing definitions and the layout of the data
    structures if you’d like further information.*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to revisit UEFITool (*[https://github.com/LongSoft/UEFITool/](https://github.com/LongSoft/UEFITool/)*),
    the open source tool for parsing, extracting, and modifying UEFI firmware images
    that was introduced in [Chapter 15](ch15.xhtml#ch15), to demonstrate theoretical
    concepts with the real firmware image we acquired in the previous section. The
    ability to look inside the firmware image to browse and extract various components
    is incredibly useful for forensic analysis. This tool doesn’t require installation;
    once downloaded, the application is ready to be executed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '***Getting to Know the SPI Flash Regions***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we look at the firmware image, we need to go over how the information
    stored on the SPI flash is organized. Generally, modern platforms based on the
    Intel chipset SPI flash consist of several regions. Each region is dedicated to
    storing firmware for a specific device available in the platform; for instance,
    UEFI BIOS firmware, Intel ME firmware, and Intel GBE (integrated LAN device) firmware
    are each stored in their own region. [Figure 19-13](ch19.xhtml#ch19fig13) demonstrates
    the layout of several regions of the SPI flash.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig13.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-13: Regions of the SPI flash image*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The SPI flash in modern systems supports up to six regions, including the *descriptor*
    region, where flash images always start. The descriptor region contains information
    about the SPI flash’s layout; that is, it provides the chipset with information
    about the other regions present on the SPI flash, such as their location and access
    rights. The descriptor region also dictates the access rights of each master in
    the system that can communicate with the SPI flash controller. Multiple masters
    are able to communicate with the controller at the same time. We can find the
    complete layout of the descriptor region, including definitions of all the data
    structures located in it, in the chipset specification for the target platform.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re primarily interested in the BIOS region, which contains
    firmware executed by the CPU at the reset vector. We can extract the location
    of the BIOS region from the descriptor region. Normally, BIOS is the last region
    on the SPI flash, and it constitutes the main target for forensic analysis.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the different regions of the SPI image that we acquired
    with the hardware approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '***Viewing SPI Flash Regions with UEFITool***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, launch UEFITool and select **File**▸**Open image file**. Then select
    the file with the SPI image you want to analyze—we’ve supplied one you can use
    with the book’s resources at *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.
    [Figure 19-14](ch19.xhtml#ch19fig14) shows the result of this operation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig14.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-14: Browsing SPI flash regions in UEFITool*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'When the firmware image loads, UEFITool automatically parses it and provides
    this information in a tree-like structure. In [Figure 19-14](ch19.xhtml#ch19fig14),
    the tool identified that the firmware image is from a system based on the Intel
    chipset ➊ with only four SPI regions: descriptor, ME, GbE, and BIOS. If we select
    the BIOS region in the Structure window, we can see information about it in the
    Information window. UEFITool shows the following items describing the region:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**Offset** ➋ The offset of the region from the beginning of the SPI flash image'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**Full size** ➌ The size of the region in bytes'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory address** ➍ The address of the region mapped into the physical memory'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '**Compressed** ➎ Whether the region contains compressed data'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The tool provides a convenient method for extracting individual regions (and
    any other object shown in the structure window) from the SPI image and saving
    them in a separate file, as shown in [Figure 19-15](ch19.xhtml#ch19fig15).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig15.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-15: Extracting a BIOS region and saving it as a separate file*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: To extract and save a region, right-click the region and select **Extract as
    is . . .** in the context menu. The tool will then show a regular dialog that
    lets you choose where you want to save your new file. Once you’ve done this, check
    the location you chose to confirm that the operation was successful.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing the BIOS Region***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we’ve identified the location of the BIOS region, we can proceed with our
    analysis. At a high level, the BIOS region is organized into *firmware volumes*,
    which are basic storage repositories for data and code. The exact definition of
    the firmware volume is provided in the EFI Firmware Volume Specification (*[https://www.intel.com/content/www/us/en/architecture-and-technology/unified-extensible-firmware-interface/efi-firmware-file-volume-specification.html](https://www.intel.com/content/www/us/en/architecture-and-technology/unified-extensible-firmware-interface/efi-firmware-file-volume-specification.html)*).
    Every volume starts with a header that provides the necessary volume attributes,
    such as the type of the volume filesystem, the volume size, and the checksum.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the firmware volumes available in the BIOS we’ve acquired. If
    we double-left-click the BIOS region in the UEFITool window (as in [Figure 19-15](ch19.xhtml#ch19fig15)),
    we get a list of firmware volumes available, as shown in [Figure 19-16](ch19.xhtml#ch19fig16).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig16.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-16: Browsing the firmware volumes available in the BIOS region*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: There are four firmware volumes available in our BIOS region, and you’ll also
    notice two regions marked *Padding*. The padding regions don’t belong to any of
    the firmware volumes but rather represent empty space between them, filled with
    either 0x00 or 0xff values depending on the erase polarity of the SPI flash. Erase
    polarity determines values written to flash memory for erase operation. If erase
    polarity is 1, then erased bytes of the flash memory are set to the values of
    0xff; if erase polarity is 0, then erased bytes are set to 0x00\. As a result,
    when erase polarity is 1, the padding regions (the empty space) consists of 0xff
    values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'In the information tab to the right of the volumes in [Figure 19-16](ch19.xhtml#ch19fig16),
    we can see the attributes of the selected volume. Here are some of the important
    fields:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Offset** ➊ The offset of the firmware volume from the beginning of the SPI
    image.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature** ➋ The signature of the firmware volume in the header. This field
    is used to identify volumes in the BIOS regions.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**Filesystem GUID** ➌ The identifier of the filesystem used in the firmware
    volume. This Globally Unique Identifier (GUID) is displayed as the name of the
    volume in the structure window. If the GUID is documented, UEFITool displays its
    human-readable name (such as EfiFirmwareFileSystemGuid in [Figure 19-16](ch19.xhtml#ch19fig16))
    instead of the hexadecimal value.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**Header size** ➍ The size of the firmware volume header. The volume data follows
    the header.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**Body size** ➎ The size of the firmware volume body—that is, the size of the
    data stored in the volume.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting to Know the Firmware Filesystem**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The firmware volumes are organized as a filesystem, the type of which is indicated
    in a filesystem GUID in the firmware header. The filesystem most frequently used
    in firmware volumes is the *firmware filesystem (FFS)*, defined in the EFI FFS
    specification, but firmware volumes also use other filesystems, such as FAT32
    or NTFS. We’ll focus on the FFS as it is the most common.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The FFS stores all the files in the root directory and contains no provision
    for any directory hierarchy. According to the EFI FFS specification, each file
    has an associated type, located in that file’s header, that describes the data
    stored in that file. Here is a list of some frequently encountered file types
    that may be useful in forensic analysis:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_FV_FILETYPE_RAW*** A raw file—no assumptions should be made about the
    data stored in the file.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE*** A file that contains an encapsulated
    firmware volume. Even though FFS has no provision for directory hierarchy, we
    can use this file type to create a tree-like structure by encapsulating firmware
    modules in files.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_FV_FILETYPE_SECURITY_CORE*** A file with code and data that is executed
    at the Security (SEC) phase of the boot process. The SEC phase is the very first
    phase of the UEFI boot process.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_FV_FILETYPE_PEI_CORE*** An executable file that initiates the Pre-EFI
    Initialization (PEI) phase of the boot process. The PEI phase follows the SEC
    phase.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_FV_FILETYPE_PEIM*** The PEI modules, which are files with code and data
    executed at the PEI phase.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_FV_FILETYPE_DXE_CORE*** An executable file that initiates the *Driver
    Execution Environment* (*DXE)* phase of the boot process. The DXE phase follows
    the PEI phase.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_FV_FILETYPE_DRIVER*** An executable file launched at the DXE phase.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER*** A file with code and data that can
    be executed at both the PEI and DXE phases.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_FV_FILETYPE_APPLICATION*** A UEFI application, which is an executable
    that can be launched at the DXE phase.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_FV_FILETYPE_FFS_PAD*** A padding file.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the typical filesystems used in operating systems, where files have human-readable
    filenames, FFS files are identified by GUIDs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting to Know File Sections**'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Most firmware files stored in the FFS consist of a single part or multiple discrete
    parts, called *sections* (although some files, such as *EFI_FV_FILETYPE_RAW* files,
    don’t contain any sections).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of sections: leaf sections and encapsulation sections.
    *Leaf sections* directly contain data, the type of which is determined by a section
    type attribute in the section header. *Encapsulation sections* contain file sections,
    which may contain either leaf sections or encapsulation sections. This means that
    one encapsulation section can contain a nested encapsulation section.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list describes some types of leaf sections:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_SECTION_PE32*** Contains a PE image.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_SECTION_PIC*** Contains position-independent code (PIC).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_SECTION_TE*** Contains a Terse Executable (TE) image.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_SECTION_USER_INTERFACE*** Contains a user interface string. It is typically
    used to store a human-readable name for the file, in addition to the file GUID.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_SECTION_FIRMWARE_VOLUME_IMAGE*** Contains an encapsulated firmware image.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'And here are a couple of the encapsulation sections defined in the FFS specification:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_SECTION_COMPRESSION*** Contains compressed file sections.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '***EFI_SECTION_GUID_DEFINED*** Encapsulates other sections with respect to
    an algorithm that is identified by the section GUID. This type is used for signed
    sections, for example.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: These objects constitute the contents of the UEFI firmware on modern platforms.
    A forensic analyst must account for every component of the firmware, whether it
    is a section with executable code, like PE32, TE or PIC, or a data file with nonvolatile
    variables.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the concepts presented here, see [Figure 19-17](ch19.xhtml#ch19fig17),
    which demonstrates the location of the `CpuInitDxe` driver in the firmware volume.
    This driver is responsible for CPU initialization at the DXE phase. We’ll go from
    the bottom to the top in the FFS hierarchy in order to describe its location in
    the firmware image.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig17.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-17: The location of the `CpuInitDxe` driver in the BIOS region*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The driver’s executable image is located in the PE32 image section ➐. This section,
    along with other sections that contain the driver name ➑, version ➒, and dependencies
    ➏, are located in the file with the GUID `{62D171CB-78CD-4480-8678-C6A2A797A8DE}`
    ➎. The file is part of the encapsulated firmware volume ➍ stored in the compressed
    section ➌. The compressed section is located in the `{9E21FD93-9C72-4C15-8C4B-E77F1DB2D792}`
    file ➋ of the firmware volume image type, which is stored in the top-level firmware
    volume ➊.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: This example is primarily intended to demonstrate the hierarchy of objects that
    constitute the UEFI firmware, but this is just one possible approach to parsing
    it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how the BIOS region is organized, we’ll be able to navigate
    its hierarchy and search for various objects stored in the BIOS firmware.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing the Firmware Image with Chipsec**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll discuss firmware forensic analysis with the platform
    security assessment framework Chipsec (*[https://github.com/chipsec/](https://github.com/chipsec/)*),
    introduced in [Chapter 15](ch15.xhtml#ch15). In this section, we’ll explore the
    tool’s architecture in more detail; then, we’ll analyze some firmware, providing
    a few examples that demonstrate Chipsec’s functionality and utility.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The tool provides a number of interfaces for accessing platform hardware resources,
    like physical memory, PCI registers, NVRAM variables, and the SPI flash. These
    interfaces are very useful to forensic analysts, and we’ll look at them more seriously
    later in this section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Follow the installation guide in the Chipsec manual (*[https://github.com/chipsec/chipsec/blob/master/chipsec-manual.pdf](https://github.com/chipsec/chipsec/blob/master/chipsec-manual.pdf)*)
    to install and set up the tool. The manual also covers a multitude of functionality
    that you can use, but in this section, we’re focusing only on Chipsec’s forensic
    analysis capabilities.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '***Getting to Know the Chipsec Architecture***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 19-18](ch19.xhtml#ch19fig18) shows the tool’s high-level architecture.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/19fig18.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-18: The Chipsec tool’s architecture*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom, we can see modules that provide access to system resources, such
    as memory-mapped IO address ranges, PCI configuration space registers, and physical
    memory. These are platform-dependent modules implemented as kernel-mode drivers
    and EFI native code. (Currently, Chipsec provides kernel-mode drivers for Windows,
    Linux, and macOS.) Most of the modules are written in C and are intended to execute
    in kernel mode or in the EFI shell.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '*The UEFI Shell is a UEFI application that provides a command line interface
    for firmware, allowing us to launch UEFI applications and execute commands. We
    can use the UEFI Shell to retrieve information on the platform, view and modify
    boot manager variables, load UEFI drivers, and more.*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: On top of these low-level OS-dependent components is an OS-independent abstraction
    layer called OS Helper, comprising a number of modules that hide an OS-specific
    API for communicating with kernel-mode components from the rest of the application.
    The modules located at this level are implemented in Python. At the bottom, these
    modules interface with the kernel-mode components; at the top, they provide an
    OS-independent interface for another component, the hardware abstraction layer
    (HAL).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The HAL further abstracts the platform’s low-level concepts, like the PCI configuration
    registers and model-specific registers (MSRs), and it provides an interface for
    the Chipsec components located at the levels immediately above it: *Chipsec Main*
    and *Chipsec Util*. The HAL is also written in Python and relies on OSHelper to
    access the platform-specific hardware resources.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The two remaining components, located at the top of the architecture, provide
    the main functionality available to users. The first interface, Chipsec Main,
    is available through the *chipsec_main.py* Python script in the tool’s root folder.
    It allows us to execute tests that check the security configuration of certain
    platform aspects, run PoCs to test for the presence of vulnerabilities in system
    firmware, and more. The second interface, Chipsec Util, is available through the
    *chipsec_util.py* script. We can use it to run individual commands and access
    platform hardware resources to read the SPI flash image, dump the UEFI NVRAM variables,
    and so on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: We’re primarily interested in the Chipsec Util interface because it provides
    rich functionality for working with UEFI firmware.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing Firmware with Chipsec Util***'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can find out the commands provided by Chipsec Util by running the *chipsec_util.py*
    script, located in the root directory of the tool’s repository, without specifying
    any arguments. Generally, commands are grouped into modules based on the platform
    hardware resources they work with. Here are some of the most useful modules:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: acpi Implements commands for working with *Advanced Configuration and Power
    Interface* tables.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: cpu Implements commands related to the CPU, such as reading configuration registers
    and obtaining information about the CPU.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: spi Implements a number of commands for working with the SPI flash, like reading,
    writing, and erasing data. There is also an option for disabling BIOS write protection
    on systems with unlocked write protection (as discussed in [Chapter 16](ch16.xhtml#ch16)).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: uefi Implements commands for parsing UEFI firmware (the SPI flash BIOS region)
    to extract executables, NVRAM variables, and the like.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: We can run `chipsec_util.py` command_name, where command_name is the name of
    the command we want to learn about, to output a description and usage information
    for that command. For instance, [Listing 19-2](ch19.xhtml#ch19list02) displays
    the output of `chipsec_util.py spi`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 19-2: Description of and usage information for the `spi` module*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This is useful when we want to know the supported options for commands with
    self-describing names, like `info`, `read`, `write`, `erase`, or `disable-wp`
    ➊. In the upcoming examples, we’ll primarily use the `spi` and `uefi` commands
    to acquire and unpack a firmware image.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**Dumping and Parsing the SPI Flash Image**'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First we’ll look at `spi`, which allows us to perform firmware acquisition.
    This command uses the software approach to dumping the contents of an SPI flash.
    To obtain an image of the SPI flash, we can run the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: where path_to_file is a path to the location where we want to save the SPI image.
    Upon successful execution of this command, this file will contain the flash image.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the SPI flash image, we can parse it and extract useful information
    using the `decode` command (it’s worth mentioning that the `decode` command by
    itself may be used to parse an SPI flash image obtained through the hardware method
    of firmware acquisition), like so:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'where path_to_file points to a file with an SPI flash image. Chipsec will parse
    and extract data stored in the flash image and store it in a directory. We can
    also perform this task with the `uefi` command and `decode` option, like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once we successfully execute the command, we obtain a set of objects extracted
    from the image, such as executable files, data files with NVRAM variables, and
    file sections.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**Dumping UEFI NVRAM Variables**'
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now we’ll use Chipsec to enumerate and extract UEFI variables from the SPI flash
    image. In [Chapter 17](ch17.xhtml#ch17), we briefly covered how to use `chipsec
    uefi var-list` to extract NVRAM variables. UEFI Secure Boot relies on NVRAM variables
    to store configuration data like its Secure Boot policy value, platform key, key
    exchange keys, and `db` and `dbx` data. Running this command will produce a list
    of all the UEFI NVRAM variables stored in the firmware image, along with their
    content and attributes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few commands out of the Chipsec tool’s rich arsenal. A comprehensive
    list of all Chipsec use cases would require a book of its own, but if you’re interested
    in the tool, we suggest checking out its documentation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our analysis of a firmware image with Chipsec. After executing
    these commands, we get the extracted contents of the firmware image. The next
    step in forensic analysis would be to analyze the extracted components individually,
    using tools specific to the type of extracted object. For instance, you can analyze
    PEI and DXE modules using IDA Pro disassembler, while you can browse UEFI NVRAM
    variables in a hex editor.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: This list of Chipsec commands serves as a good starting point for further exploration
    of UEFI firmware. We encourage you to play with this tool and refer to the manual
    to learn its other capabilities and features in order to deepen your knowledge
    of firmware forensic analysis.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed important approaches to UEFI firmware forensic
    analysis: acquiring firmware, and parsing and extracting information from a UEFI
    firmware image.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: We discussed two different ways to acquire firmware—the software approach and
    the hardware approach. The software approach is convenient, but it doesn’t provide
    a completely trustworthy way of obtaining a firmware image from the target system.
    For this reason, we recommend the hardware approach, despite its higher difficulty.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'We also demonstrated how to use two open source tools indispensable to analyzing
    and reverse engineering SPI flash images: UEFITool and Chipsec. UEFITool provides
    functionality for browsing, modifying, and extracting forensic data from an SPI
    flash image, and Chipsec is useful for performing many operations required in
    forensic analysis. The use of Chipsec also reveals how easily an attacker can
    modify the firmware image with a malicious payload, and so we expect interest
    in firmware forensics to significantly increase in the security industry.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
