["```\n{-# OPTIONS -Wall #-}\n\nmodule Charge where\n\nimport SimpleVec ( R, Vec, vec, sumV, (*^), (^/), (<.>), magnitude, negateV )\nimport Electricity ( elementaryCharge )\nimport CoordinateSystems ( Position, ScalarField, origin, cart, sph\n                         , rVF, displacement, shiftPosition )\nimport Geometry ( Curve(..), Surface(..), Volume(..)\n                , straightLine, shiftSurface, disk )\nimport Integrals\n    ( scalarLineIntegral, scalarSurfaceIntegral, scalarVolumeIntegral\n    , vectorLineIntegral, vectorSurfaceIntegral, vectorVolumeIntegral\n    , curveSample, surfaceSample, volumeSample )\n```", "```\ntype Charge = R\n```", "```\neField :: ChargeDistribution -> VectorField\n```", "```\ndata ChargeDistribution\n    = PointCharge   Charge      Position\n    | LineCharge    ScalarField Curve\n    | SurfaceCharge ScalarField Surface\n    | VolumeCharge  ScalarField Volume\n    | MultipleCharges [ChargeDistribution]\n```", "```\nprotonOrigin :: ChargeDistribution\nprotonOrigin = PointCharge elementaryCharge origin\n```", "```\nchargedLine :: Charge -> R -> ChargeDistribution\nchargedLine q len\n    = LineCharge (const $ q / len) $\n      Curve (\\z -> cart 0 0 z) (-len/2) (len/2)\n```", "```\nchargedBall :: Charge -> R -> ChargeDistribution\nchargedBall q radius\n    = VolumeCharge (const $ q / (4/3*pi*radius**3)) $\n      Volume (\\(r,theta,phi) -> sph r theta phi)\n                 0 radius (const 0) (const pi) (\\_ _ -> 0) (\\_ _ -> 2*pi)\n```", "```\ndiskCap :: R -> R -> R -> ChargeDistribution\ndiskCap radius plateSep sigma\n     = MultipleCharges\n       [SurfaceCharge (const sigma) $ shiftSurface (vec 0 0 (plateSep/2)) (disk radius)\n       ,SurfaceCharge (const $ -sigma) $\n        shiftSurface (vec 0 0 (-plateSep/2)) (disk radius)\n       ]\n```", "```\ntotalCharge :: ChargeDistribution -> Charge\ntotalCharge (PointCharge   q      _)\n    = q\ntotalCharge (LineCharge    lambda c)\n    = scalarLineIntegral    (curveSample  1000) lambda c\ntotalCharge (SurfaceCharge sigma  s)\n    = scalarSurfaceIntegral (surfaceSample 200) sigma s\ntotalCharge (VolumeCharge  rho    v)\n    = scalarVolumeIntegral  (volumeSample   50) rho v\ntotalCharge (MultipleCharges ds    )\n    = sum [totalCharge d | d <- ds]\n```", "```\nPrelude> :l Charge\n[ 1 of 11] Compiling Newton2          ( Newton2.hs, interpreted )\n[ 2 of 11] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )\n[ 3 of 11] Compiling SimpleVec        ( SimpleVec.hs, interpreted )\n[ 4 of 11] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )\n[ 5 of 11] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )\n[ 6 of 11] Compiling MOExamples       ( MOExamples.hs, interpreted )\n[ 7 of 11] Compiling Electricity      ( Electricity.hs, interpreted )\n[ 8 of 11] Compiling CoordinateSystems ( CoordinateSystems.hs, interpreted )\n[ 9 of 11] Compiling Geometry         ( Geometry.hs, interpreted )\n[10 of 11] Compiling VectorIntegrals  ( VectorIntegrals.hs, interpreted )\n[11 of 11] Compiling Charge           ( Charge.hs, interpreted )\nOk, 11 modules loaded.\n*Charge> totalCharge protonOrigin\n1.602176634e-19\n*Charge> totalCharge $ chargedLine 0.25 2\n0.2500000000000002\n```", "```\nsimpleDipole :: Vec  -- electric dipole moment\n             -> R    -- charge separation\n             -> ChargeDistribution\nsimpleDipole p sep\n    = let q    = magnitude p / sep\n          disp = (sep/2) *^ (p ^/ magnitude p)\n      in MultipleCharges\n             [PointCharge   q  (shiftPosition          disp  origin)\n             ,PointCharge (-q) (shiftPosition (negateV disp) origin)\n             ]\n```", "```\nelectricDipoleMoment :: ChargeDistribution -> Vec\nelectricDipoleMoment (PointCharge   q     r)\n    = q *^ displacement origin r\nelectricDipoleMoment (LineCharge    lambda c)\n    = vectorLineIntegral    (curveSample  1000) (\\r -> lambda r *^ rVF r) c\nelectricDipoleMoment (SurfaceCharge sigma  s)\n    = vectorSurfaceIntegral (surfaceSample 200) (\\r -> sigma  r *^ rVF r) s\nelectricDipoleMoment (VolumeCharge  rho    v)\n    = vectorVolumeIntegral  (volumeSample   50) (\\r -> rho    r *^ rVF r) v\nelectricDipoleMoment (MultipleCharges ds    )\n    = sumV [electricDipoleMoment d | d <- ds]\n```", "```\nlineDipole :: Vec  -- dipole moment\n           -> R    -- charge separation\n           -> ChargeDistribution\nlineDipole p sep\n    = let disp = (sep/2) *^ (p ^/ magnitude p)\n          curve = straightLine (shiftPosition (negateV disp) origin)\n                               (shiftPosition          disp  origin)\n          coeff = 12 / sep**3\n          lambda r = coeff * (displacement origin r <.> p)\n      in LineCharge lambda curve\n```", "```\nchargedDisk :: Charge -> R -> ChargeDistribution\nchargedDisk q radius = undefined q radius\n```", "```\ncircularLineCharge :: Charge -> R -> ChargeDistribution\ncircularLineCharge q radius = undefined q radius\n```", "```\nchargedSquarePlate :: Charge -> R -> ChargeDistribution\nchargedSquarePlate q side = undefined q side\n```", "```\nchargedSphericalShell :: Charge -> R -> ChargeDistribution\nchargedSphericalShell q radius = undefined q radius\n```", "```\nchargedCube :: Charge -> R -> ChargeDistribution\nchargedCube q side = undefined q side\n```", "```\nsquareCap :: R -> R -> R -> ChargeDistribution\nsquareCap side plateSep sigma = undefined side plateSep sigma\n```", "```\nhydrogen :: ChargeDistribution\nhydrogen = undefined\n```"]