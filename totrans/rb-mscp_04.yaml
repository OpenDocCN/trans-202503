- en: Chapter 4. Control Structures and Method Dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*YARV uses its own internal set of control structures, like the structures
    you use in Ruby.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code") I explained
    how YARV uses a stack while executing its instruction set and how it can access
    variables locally or dynamically. Controlling the flow of execution is another
    fundamental requirement for any programming language, and Ruby has a rich set
    of control structures, too. How does YARV implement control structures?
  prefs: []
  type: TYPE_NORMAL
- en: Like Ruby, YARV has its own control structures, albeit at a much lower level.
    Instead of `if` or `unless` statements, YARV uses two low-level instructions called
    `branchif` and `branchunless`. Instead of using control structures such as `while...end`
    or `until...end` loops, YARV has a single low-level function called `jump` that
    allows it to change the program counter and move through your compiled program.
    By combining the `branchif` or `branchunless` instruction with the `jump` instruction,
    YARV can execute most of Ruby’s simple control structures.
  prefs: []
  type: TYPE_NORMAL
- en: When your code calls a method, YARV uses the `send` instruction. This process
    is known as *method dispatch*. You can consider `send` to be another one of Ruby’s
    control structures—the most complex and sophisticated one of all.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll learn more about YARV by exploring how it controls execution
    flow in your program. We’ll also look at the method dispatch process as we learn
    how Ruby categorizes methods into types, calling each method type differently.
  prefs: []
  type: TYPE_NORMAL
- en: Roadmap
  prefs: []
  type: TYPE_NORMAL
- en: '[How Ruby Executes an if Statement](ch04.html#how_ruby_executes_an_if_statement
    "How Ruby Executes an if Statement")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Jumping from One Scope to Another](ch04.html#jumping_from_one_scope_to_another
    "Jumping from One Scope to Another")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catch Tables](ch04.html#catch_tables "Catch Tables")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Other Uses for Catch Tables](ch04.html#other_uses_for_catch_tables "Other
    Uses for Catch Tables")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Experiment 4-1: Testing How Ruby Implements for Loops Internally](ch04.html#experiment_4-1_testing_how_ruby_implemen
    "Experiment 4-1: Testing How Ruby Implements for Loops Internally")**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The send Instruction: Ruby’s Most Complex Control Structure](ch04.html#send_instruction_rubyapostrophes_mos
    "The send Instruction: Ruby’s Most Complex Control Structure")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method Lookup and Method Dispatch](ch04.html#method_lookup_and_method_dispatch
    "Method Lookup and Method Dispatch")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eleven Types of Ruby Methods](ch04.html#eleven_types_of_ruby_methods "Eleven
    Types of Ruby Methods")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Calling Normal Ruby Methods](ch04.html#calling_normal_ruby_methods "Calling
    Normal Ruby Methods")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preparing Arguments for Normal Ruby Methods](ch04.html#preparing_arguments_for_normal_ruby_meth
    "Preparing Arguments for Normal Ruby Methods")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Calling Built-In Ruby Methods](ch04.html#calling_built-in_ruby_methods "Calling
    Built-In Ruby Methods")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Calling attr_reader and attr_writer](ch04.html#calling_attrunderscorereader_and_attrund
    "Calling attr_reader and attr_writer")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method Dispatch Optimizes attr_reader and attr_writer](ch04.html#method_dispatch_optimizes_attrunderscore
    "Method Dispatch Optimizes attr_reader and attr_writer")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Experiment 4-2: Exploring How Ruby Implements Keyword Arguments](ch04.html#experiment_4-2_exploring_how_ruby_implem
    "Experiment 4-2: Exploring How Ruby Implements Keyword Arguments")**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](ch04.html#summary-id00014 "Summary")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Ruby Executes an if Statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to understand how YARV controls execution flow, let’s see how the
    `if...else` statement works. The left side of [Figure 4-1](ch04.html#how_ruby_compiles_an_ifhellipelse_statem
    "Figure 4-1. How Ruby compiles an if...else statement") shows a simple Ruby script
    that uses both `if` and `else`. On the right side of the figure, you can see the
    corresponding snippet of compiled YARV instructions. Reading the YARV instructions,
    you see that Ruby follows a pattern for implementing the `if...else` statement.
    It goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate condition
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jump to false code if condition is false
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True code; jump past false code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How Ruby compiles an if...else statement](httpatomoreillycomsourcenostarchimages1853995.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1. How Ruby compiles an `if...else` statement
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern should be a bit easier to follow in the flowchart shown in [Figure 4-2](ch04.html#this_flowchart_shows_the_pattern_ruby_us
    "Figure 4-2. This flowchart shows the pattern Ruby uses to compile if...else statements.")
    on the next page. The `branchunless` instruction in the center of the figure is
    the key to how Ruby implements `if` statements. It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ruby evaluates the condition of the `if` statement, `i < 10`, using the `opt_lt`
    (optimized less-than) instruction. This evaluation leaves either a true or false
    value on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`branchunless` jumps down to the `else` code if the condition is false. That
    is, it “branches unless” the condition is true. Ruby uses `branchunless`, not
    `branchif`, for `if...else` conditions because the positive case is compiled to
    appear right after the condition code. Therefore, YARV needs to jump if the condition
    is false.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the condition is true, Ruby does not branch and just continues to execute
    the positive case code. Once it’s finished, it jumps down to the instructions
    following the `if...else` statement using the `jump` instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whether or not it branches, Ruby continues to execute the subsequent code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'YARV implements the `unless` statement similarly to how it implements `if`,
    except that the positive and negative code snippets are in reverse order. For
    looping control structures like `while...end` and `until...end`, YARV uses the
    `branchif` instruction instead, but the idea is the same: Calculate the loop condition,
    execute `branchif` to jump as necessary, and then use `jump` statements to implement
    the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '![This flowchart shows the pattern Ruby uses to compile if...else statements.](httpatomoreillycomsourcenostarchimages1853997.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2. This flowchart shows the pattern Ruby uses to compile `if...else`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: Jumping from One Scope to Another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the challenges YARV has in implementing some control structures is that,
    as with dynamic variable access, Ruby can jump from one scope to another. For
    example, `break` can be used to exit a simple loop like the one in [Example 4-1](ch04.html#break_used_to_exit_a_simple_loop
    "Example 4-1. break used to exit a simple loop").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1. `break` used to exit a simple loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And it can also be used to exit a block iteration, like the one in [Example 4-2](ch04.html#break_used_to_exit_a_block
    "Example 4-2. break used to exit a block").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2. `break` used to exit a block
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first listing, YARV can exit the `while` loop using simple `jump` instructions.
    But exiting a block like the one in the second listing is not so simple: In this
    case, YARV needs to jump to the parent scope and continue execution after the
    call to `10.times`. How does YARV know where to jump to? And how does it adjust
    both its internal stack and your Ruby call stack in order to continue execution
    properly in the parent scope?'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement jumping from one place to another in the Ruby call stack (that
    is, outside the current scope), Ruby uses the `throw` YARV instruction. This instruction
    resembles the Ruby `throw` keyword: It sends, or throws, the execution path back
    up to a higher scope. For example, [Figure 4-3](ch04.html#how_ruby_compiles_a_break_statement_used
    "Figure 4-3. How Ruby compiles a break statement used inside a block") shows how
    Ruby compiles [Example 4-2](ch04.html#break_used_to_exit_a_block "Example 4-2. break
    used to exit a block"), with the block containing a `break` statement. The Ruby
    code is on the left, and the compiled version is on the right.'
  prefs: []
  type: TYPE_NORMAL
- en: '![How Ruby compiles a break statement used inside a block](httpatomoreillycomsourcenostarchimages1853999.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3. How Ruby compiles a `break` statement used inside a block
  prefs: []
  type: TYPE_NORMAL
- en: Catch Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the top right of [Figure 4-3](ch04.html#how_ruby_compiles_a_break_statement_used
    "Figure 4-3. How Ruby compiles a break statement used inside a block"), the `throw
    2` in the compiled code for the block throws an exception at the YARV instruction
    level using a *catch table*, or a table of pointers that may be attached to any
    YARV code snippet. Conceptually, a catch table might look like [Figure 4-4](ch04.html#each_snippet_of_yarv_code_can_contain_a
    "Figure 4-4. Each snippet of YARV code can contain a catch table.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Each snippet of YARV code can contain a catch table.](httpatomoreillycomsourcenostarchimages1854001.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4. Each snippet of YARV code can contain a catch table.
  prefs: []
  type: TYPE_NORMAL
- en: This catch table contains just a single pointer to the `pop` statement, where
    execution would continue after an exception. Whenever you use a `break` statement
    in a block, Ruby compiles the `throw` instruction into the block’s code and adds
    the `BREAK` entry into the parent scope’s catch table. For a `break` within a
    series of nested blocks, Ruby would add the `BREAK` entry to a catch table even
    farther down the `rb_control_frame_t` stack.
  prefs: []
  type: TYPE_NORMAL
- en: Later, when YARV executes the `throw` instruction, it checks to see whether
    there’s a catch table containing a break pointer for the current YARV instruction
    sequence, as shown in [Figure 4-5](ch04.html#while_executing_a_throw_instructioncomma
    "Figure 4-5. While executing a throw instruction, YARV starts iterating down the
    Ruby call stack.").
  prefs: []
  type: TYPE_NORMAL
- en: '![While executing a throw instruction, YARV starts iterating down the Ruby
    call stack.](httpatomoreillycomsourcenostarchimages1854003.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5. While executing a `throw` instruction, YARV starts iterating down
    the Ruby call stack.
  prefs: []
  type: TYPE_NORMAL
- en: If it doesn’t find a catch table, Ruby starts to iterate down through the stack
    of `rb_control_frame_t` structures in search of a catch table containing a break
    pointer, as shown in [Figure 4-6](ch04.html#ruby_continues_to_iterate_down_the_call
    "Figure 4-6. Ruby continues to iterate down the call stack looking for a catch
    table with a break pointer.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby continues to iterate down the call stack looking for a catch table with
    a break pointer.](httpatomoreillycomsourcenostarchimages1854005.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6. Ruby continues to iterate down the call stack looking for a catch
    table with a break pointer.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 4-7](ch04.html#ruby_keeps_iterating_until_it_finds_a_ca
    "Figure 4-7. Ruby keeps iterating until it finds a catch table with a break pointer
    or reaches the end of the call stack."), Ruby continues to iterate until it finds
    a catch table with a break pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby keeps iterating until it finds a catch table with a break pointer or
    reaches the end of the call stack.](httpatomoreillycomsourcenostarchimages1854007.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7. Ruby keeps iterating until it finds a catch table with a break pointer
    or reaches the end of the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: In this simple example, there is only one level of block nesting, so Ruby finds
    the catch table and break pointer after just one iteration, as shown in [Figure 4-8](ch04.html#ruby_finds_a_catch_table_with_a_break_po
    "Figure 4-8. Ruby finds a catch table with a break pointer.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby finds a catch table with a break pointer.](httpatomoreillycomsourcenostarchimages1854009.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8. Ruby finds a catch table with a break pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Once Ruby finds the catch table pointer, it resets both the Ruby call stack
    (the `CFP` pointer) and the internal YARV stack to reflect the new program execution
    point. YARV continues to execute your code from there—that is, it resets the internal
    `PC` and `SP` pointers as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Ruby uses a process similar to raising and rescuing an exception internally
    in order to implement a very commonly used control structure: the `break` keyword.
    In other words, what in more verbose languages is an exceptional occurrence becomes
    in Ruby a common, everyday action. Ruby has wrapped up a confusing, unusual syntax—the
    raising/rescuing of exceptions—into a simple keyword, `break`, and made it very
    easy to understand and use. (Of course, Ruby needs to use exceptions because of
    the way blocks work. On the one hand, they’re like separate functions or subroutines,
    but on the other, they’re just part of the surrounding code.)*'
  prefs: []
  type: TYPE_NORMAL
- en: Other Uses for Catch Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `return` keyword is another ordinary Ruby control structure that also uses
    catch tables. Whenever you call `return` from inside a block, Ruby raises an internal
    exception that it rescues with a catch table pointer in the same way it does when
    you call `break`. In fact, `break` and `return` are implemented with the same
    YARV instructions with one exception: For `return`, Ruby passes a 1 to the `throw`
    instruction (for example, `throw 1`), while for `break`, it passes a 2 (`throw
    2`). The `return` and `break` keywords are really two sides of the same coin.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides `break`, Ruby uses the catch table to implement the control structures
    `rescue`, `ensure`, `retry`, `redo`, and `next`. For example, when you explicitly
    raise an exception in your Ruby code using the `raise` keyword, Ruby implements
    the `rescue` block using the catch table, but with a `rescue` pointer. The catch
    table is simply a list of event types that can be caught and handled by that sequence
    of YARV instructions, just as you would use a `rescue` block in your Ruby code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 4-1: Testing How Ruby Implements for Loops Internally'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I had always known that Ruby’s `for` loop control structure worked essentially
    the same way as a block with the `each` method of the `Enumerable` module. That
    is, I knew that this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'worked like this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But I never suspected that internally Ruby actually implements `for` loops using
    `each`! In other words, Ruby has no `for` loop control structure. Instead, the
    `for` keyword is really just syntactical sugar for calling `each` with a range.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove this, simply inspect the YARV instructions produced by Ruby when you
    compile a `for` loop. In [Example 4-3](ch04.html#this_code_will_display_how_ruby_compiles
    "Example 4-3. This code will display how Ruby compiles a for loop."), let’s use
    the same `RubyVM:: InstructionSequence.compile` method to display the YARV instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3. This code will display how Ruby compiles a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Running this code gives the output shown in [Example 4-4](ch04.html#output_generated_by_listing_4-3
    "Example 4-4. The output generated by Example 4-3").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4. The output generated by [Example 4-3](ch04.html#this_code_will_display_how_ruby_compiles
    "Example 4-3. This code will display how Ruby compiles a for loop.")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-9](ch04.html#simplified_display_of_the_yarv_instruc "Figure 4-9. A
    simplified display of the YARV instructions in Example 4-4") shows the Ruby code
    on the left and YARV instructions on the right. (I’ve removed some of the technical
    details, like the `trace` statements, in order to simplify things a bit.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simplified display of the YARV instructions in](httpatomoreillycomsourcenostarchimages1854011.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9. A simplified display of the YARV instructions in [Example 4-4](ch04.html#output_generated_by_listing_4-3
    "Example 4-4. The output generated by Example 4-3")
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that there are two separate YARV code blocks: The outer scope calls
    `each` on the range `0..5`, and an inner block makes the `puts i` call. The `getlocal
    2, 0` instruction in the inner block loads the implied block parameter value (`i`
    in my Ruby code), and the `setlocal` instruction that follows saves it into the
    local variable `i`, located back in the parent scope using dynamic variable access.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In effect, Ruby has automatically done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Converted the `for i in 0..5` code into `(0..5).each do`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created a block parameter to hold each value in the range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copied the block parameter, or the iteration counter, back into the local variable
    `i` each time around the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The send Instruction: Ruby’s Most Complex Control Structure'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve seen how YARV controls the execution flow of our Ruby program using low-level
    instructions such as `branchunless` and `jump`. However, the most commonly used
    and important YARV instruction for controlling Ruby program execution flow is
    the `send` instruction. The `send` instruction tells YARV to jump to another method
    and start executing it.
  prefs: []
  type: TYPE_NORMAL
- en: Method Lookup and Method Dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does `send` work? How does YARV know which method to call, and how does
    it actually call the method? [Figure 4-10](ch04.html#ruby_uses_method_lookup_to_find_which_me
    "Figure 4-10. Ruby uses method lookup to find which method to call and which method
    dispatch to call it.") shows a high-level overview of the process.
  prefs: []
  type: TYPE_NORMAL
- en: This seems very simple, but the algorithm Ruby uses to find and call the target
    method is actually very complex. First, in *method lookup*, Ruby searches for
    the method your code actually should call. This involves looping through the classes
    and modules that make up the receiver object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby uses method lookup to find which method to call and which method dispatch
    to call it.](httpatomoreillycomsourcenostarchimages1854013.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10. Ruby uses method lookup to find which method to call and which
    method dispatch to call it.
  prefs: []
  type: TYPE_NORMAL
- en: Once Ruby finds the method your code is trying to call, it uses *method dispatch*
    to actually execute the method call. This involves preparing the arguments to
    the method, pushing a new frame onto YARV’s internal stack, and changing YARV’s
    internal registers in order to actually start executing the target method. Like
    method lookup, method dispatch is a complex process because of the way Ruby categorizes
    your methods.
  prefs: []
  type: TYPE_NORMAL
- en: During the rest of this chapter I’ll discuss the method dispatch process. We’ll
    see how method lookup works in [Chapter 6](ch06.html "Chapter 6. Method Lookup
    and Constant Lookup"), once we have learned more about how Ruby implements objects,
    classes, and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Eleven Types of Ruby Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internally, Ruby categorizes your methods into 11 different types! During the
    method dispatch process, Ruby determines which type of method your code is trying
    to call. It then calls each type of method differently depending on its type,
    as shown in [Figure 4-11](ch04.html#while_executing_sendcomma_yarv_switches "Figure 4-11. While
    executing send, YARV switches on the type of the target method.").
  prefs: []
  type: TYPE_NORMAL
- en: Most methods—including all methods you write with Ruby code in your program—are
    referred to as ISEQ, or *instruction sequence* methods, by YARV’s internal source
    code because Ruby compiles your code into a series of YARV bytecode instructions.
    But internally, YARV uses 10 other method types as well. These other method types
    are required because Ruby needs to call certain methods in a special way in order
    to speed up method dispatch, because these methods are implemented with C code
    or for various internal, technical reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '![While executing send, YARV switches on the type of the target method.](httpatomoreillycomsourcenostarchimages1854015.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11. While executing `send`, YARV switches on the type of the target
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a quick description of all 11 method types. We’ll explore some of these
    in more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: '****ISEQ****. A normal method that you write using Ruby code, this is the most
    common method type. ISEQ stands for *instruction sequence*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****CFUNC****. Using C code included directly inside the Ruby executable, these
    are the methods that Ruby implements rather than you. CFUNC stands for *C function*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****ATTRSET****. A method of this type is created by the `attr_writer` method.
    ATTRSET stands for *attribute set*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****IVAR****. Ruby uses this method type when you call `attr_reader`. IVAR
    stands for *instance variable*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****BMETHOD****. Ruby uses this method type when you call `define_method` and
    pass in a proc object. Because the method is represented internally by a proc,
    Ruby needs to handle this method type in a special way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****ZSUPER****. Ruby uses this method type when you set a method to be public
    or private in a particular class or module when it was actually defined in some
    superclass. This method is not commonly used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****UNDEF****. Ruby uses this method type internally when it needs to remove
    a method from a class. Also, if you remove a method using `undef_method`, Ruby
    creates a new method of the same name using the UNDEF method type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****NOTIMPLEMENTED****. Like UNDEF, Ruby uses this method type to mark certain
    methods as not implemented. This is necessary, for example, when you run Ruby
    on a platform that doesn’t support a particular operating system call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****OPTIMIZED****. Ruby speeds up some important methods using this type, like
    the `Kernel#send` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****MISSING****. Ruby uses this method type if you ask for a method object
    from a module or class using `Kernel#method` and the method is missing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****REFINED****. Ruby uses this method type in its implementation of refinements,
    a new feature introduced in version 2.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let’s focus on the most important and frequently used method types: ISEQ,
    CFUNC, ATTRSET, and IVAR.'
  prefs: []
  type: TYPE_NORMAL
- en: Calling Normal Ruby Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most methods in your Ruby code are identified by the constant `VM_METHOD_TYPE_ISEQ`
    inside Ruby’s source code. This means that they consist of a sequence of YARV
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: You define standard Ruby methods in your code with the `def` keyword, as shown
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`display_message` is a standard method because it’s created using the `def`
    keyword followed by normal Ruby code. [Figure 4-12](ch04.html#normal_method_is_comprised_of_yarv_ins
    "Figure 4-12. A normal method is comprised of YARV instructions.") shows how Ruby
    calls the `display_message` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A normal method is comprised of YARV instructions.](httpatomoreillycomsourcenostarchimages1854017.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-12. A normal method is comprised of YARV instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left are two snippets of YARV code: the calling code at the bottom and
    the target method at the top. On the right you can see that Ruby created a new
    stack frame using a new `rb_control_frame_t` structure, set to type METHOD.'
  prefs: []
  type: TYPE_NORMAL
- en: The key idea in [Figure 4-12](ch04.html#normal_method_is_comprised_of_yarv_ins
    "Figure 4-12. A normal method is comprised of YARV instructions.") is that both
    the calling code and the target method are comprised of YARV instructions. When
    you call a standard method, YARV creates a new stack frame and then starts executing
    the instructions in the target method.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Arguments for Normal Ruby Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Ruby compiles your code, it creates a table of local variables and arguments
    for each method. Each argument listed in the local table is labeled as standard
    (`<Arg>`) or as one of a few different special types, such as block, optional,
    and so on. Ruby records the type of each method’s arguments in this way so it
    can tell whether any additional work is required when your code calls the method.
    [Example 4-5](ch04.html#rubyapostrophes_argument_types_left_pare "Example 4-5. Ruby’s
    argument types (argument_types.rb)") shows a single Ruby method that uses each
    type of argument.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5. Ruby’s argument types *(argument_types.rb)*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 4-6](ch04.html#output_generated_by_listing_4-5 "Example 4-6. The output
    generated by Example 4-5") shows the result when we call the example method with
    the numbers 1 through 6 and a block.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6. The output generated by [Example 4-5](ch04.html#rubyapostrophes_argument_types_left_pare
    "Example 4-5. Ruby’s argument types (argument_types.rb)")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this behavior possible, YARV does some additional processing on each
    type of argument when you call a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '****Block arguments****. When you use the `&` operator in an argument list,
    Ruby needs to convert the provided block into a proc object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Optional arguments****. Ruby adds additional code to the target method
    when you use an optional argument with a default value. This code sets the default
    value into the argument. When you later call a method with an optional argument,
    YARV resets the program counter or PC register to skip this added code when a
    value is provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Splat argument array****. For these, YARV creates a new array object and
    collects the provided argument values into it. (See the array `[3, 4, 5]` in [Example 4-6](ch04.html#output_generated_by_listing_4-5
    "Example 4-6. The output generated by Example 4-5").)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Standard and post arguments****. Because these are simple values, YARV
    has no additional work to do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then there are keyword arguments. Whenever Ruby calls a method that uses keyword
    arguments, YARV has even more work to do. ([Experiment 4-2: Exploring How Ruby
    Implements Keyword Arguments](ch04.html#experiment_4-2_exploring_how_ruby_implem
    "Experiment 4-2: Exploring How Ruby Implements Keyword Arguments") explores this
    in more detail.)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling Built-In Ruby Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the methods built into the Ruby language are CFUNC methods (`VM_METHOD_TYPE_CFUNC`
    in Ruby’s C source code). Ruby implements these using C code rather than Ruby
    code. For example, consider the `Integer#times` method from [Executing a Call
    to a Block](ch03.html#executing_a_call_to_a_block "Executing a Call to a Block").
    The `Integer` class is included in Ruby, and the `times` method is implemented
    by C code in the file *numeric.c*.
  prefs: []
  type: TYPE_NORMAL
- en: The classes you use every day have many examples of CFUNC methods, such as `String`,
    `Array`, `Object`, `Kernel`, and so on. For example, the `String#upcase` method
    is implemented by C code in *string.c*, and `Struct#each` is implemented by C
    code in *struct.c*.
  prefs: []
  type: TYPE_NORMAL
- en: When Ruby calls a built-in CFUNC method, it doesn’t need to prepare the method
    arguments in the same way it does with normal ISEQ methods; it simply creates
    a new stack frame and calls the target method, as shown in [Figure 4-13](ch04.html#ruby_implements_cfunc_methods_using_c_co
    "Figure 4-13. Ruby implements CFUNC methods using C code in one of Ruby’s C source
    files.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby implements CFUNC methods using C code in one of Ruby’s C source files.](httpatomoreillycomsourcenostarchimages1854019.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-13. Ruby implements CFUNC methods using C code in one of Ruby’s C source
    files.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw with ISEQ methods in [Figure 4-12](ch04.html#normal_method_is_comprised_of_yarv_ins
    "Figure 4-12. A normal method is comprised of YARV instructions."), calling a
    CFUNC method involves creating a new stack frame. This time, however, Ruby uses
    a `rb_control_frame_t` structure with type CFUNC instead.
  prefs: []
  type: TYPE_NORMAL
- en: Calling attr_reader and attr_writer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ruby uses two special method types, IVAR and ATTRSET, to speed up the process
    of accessing and setting instance variables in your code. Before I explain what
    these method types mean and how method dispatch works with them, have a look at
    [Example 4-7](ch04.html#ruby_class_with_an_instance_variable_a "Example 4-7. A
    Ruby class with an instance variable and accessor methods"), which retrieves and
    sets the value of an instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-7. A Ruby class with an instance variable and accessor methods
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, the class `InstanceVariableTest` contains an instance variable,
    `@var`, and two methods, `var` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and `var=` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). Because
    I wrote these methods using Ruby code, both will be standard Ruby methods with
    the type set to `VM_METHOD_TYPE_ISEQ`. As you can see, they allow you to get or
    set the value of `@var`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby actually provides a shortcut for creating these methods: `attr_reader`
    and `attr_writer`. The following code shows a shorter way of writing the same
    class, using these shortcuts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `attr_reader` automatically defines the same `var` method, and `attr_writer`
    automatically defines the `var=` method, both from [Example 4-7](ch04.html#ruby_class_with_an_instance_variable_a
    "Example 4-7. A Ruby class with an instance variable and accessor methods").
  prefs: []
  type: TYPE_NORMAL
- en: And here’s an even simpler, more concise way of defining the same two methods
    using `attr_accessor`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `attr_accessor` is shorthand for calling `attr_reader` and `attr_writer`
    together for the same variable.
  prefs: []
  type: TYPE_NORMAL
- en: Method Dispatch Optimizes attr_reader and attr_writer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Ruby developers use `attr_reader` and `attr_writer` so often, YARV uses
    two special method types, IVAR and ATTRSET, to speed up method dispatch and make
    your program run faster.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with the ATTRSET method type. Whenever you define a method using
    `attr_writer` or `attr_accessor`, Ruby marks the generated method with the `VM_METHOD_TYPE_ATTRSET`
    method type internally. When Ruby executes the code and calls the method, it uses
    a C function, `vm_setivar`, to set the instance variable in a fast, optimized
    manner. [Figure 4-14](ch04.html#vmunderscoremethodunderscoretypeundersco "Figure 4-14. VM_METHOD_TYPE_ATTRSET
    methods call vm_setivar directly.") shows how YARV calls the generated `var=`
    method to set `var`.
  prefs: []
  type: TYPE_NORMAL
- en: '![VM_METHOD_TYPE_ATTRSET methods call vm_setivar directly.](httpatomoreillycomsourcenostarchimages1854021.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-14. `VM_METHOD_TYPE_ATTRSET` methods call `vm_setivar` directly.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this figure is similar to [Figure 4-13](ch04.html#ruby_implements_cfunc_methods_using_c_co
    "Figure 4-13. Ruby implements CFUNC methods using C code in one of Ruby’s C source
    files."). In both cases, Ruby calls an internal C function when executing our
    code. But notice in [Figure 4-14](ch04.html#vmunderscoremethodunderscoretypeundersco
    "Figure 4-14. VM_METHOD_TYPE_ATTRSET methods call vm_setivar directly.") that
    when executing an ATTRSET method, Ruby doesn’t even create a new stack frame.
    It doesn’t need to because the method is so short and simple. Also, because the
    generated `var=` method will never raise an exception, Ruby doesn’t need a new
    stack frame to display in error messages. The `vm_setivar` C function can very
    quickly set the value and return.
  prefs: []
  type: TYPE_NORMAL
- en: The IVAR method type works similarly. When you define a method using `attr_reader`
    or `attr_accessor`, Ruby marks the generated method with the `VM_METHOD_TYPE_IVAR`
    method type internally. When it executes IVAR methods, Ruby calls an internal
    C function called `vm_getivar` to get and return the instance variable’s value
    quickly, as shown in [Figure 4-15](ch04.html#vmunderscoremethodunderscoretype-id00013
    "Figure 4-15. VM_METHOD_TYPE_IVAR methods call vm_getivar directly.").
  prefs: []
  type: TYPE_NORMAL
- en: '![VM_METHOD_TYPE_IVAR methods call vm_getivar directly.](httpatomoreillycomsourcenostarchimages1854023.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-15. `VM_METHOD_TYPE_IVAR` methods call `vm_getivar` directly.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `opt_send_simple` YARV instruction on the left calls the `vm_getivar`
    C function on the right. As in [Figure 4-14](ch04.html#vmunderscoremethodunderscoretypeundersco
    "Figure 4-14. VM_METHOD_TYPE_ATTRSET methods call vm_setivar directly."), when
    calling `vm_setivar`, Ruby doesn’t need to create a new stack frame or execute
    YARV instructions. It simply returns the value of `var` immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 4-2: Exploring How Ruby Implements Keyword Arguments'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beginning with Ruby 2.0, you can specify labels for method arguments. [Example 4-8](ch04.html#simple_example_of_using_keyword_argume
    "Example 4-8. A simple example of using keyword arguments") shows a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8. A simple example of using keyword arguments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We use the labels `a` and `b` for the keyword arguments to `add_two` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    When we call the function ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg),
    we get the result 2\. I hinted in [Chapter 2](ch02.html "Chapter 2. Compilation")
    that Ruby uses a hash to implement keyword arguments. Let’s prove this is the
    case using [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i "Example 4-9. Demonstrating
    that Ruby uses a hash to implement keyword arguments").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9. Demonstrating that Ruby uses a hash to implement keyword arguments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We override the `key?` method ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    of the `Hash` class, which displays a message ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    and then returns `false`. Here’s the output we get when we run [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "Example 4-9. Demonstrating that Ruby uses a hash to implement keyword arguments").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Ruby is calling `Hash#key?` twice: once to find the key `a`
    and a second time to find the key `b`. For some reason, Ruby has created a hash
    even though we never used a hash in the code. Also, Ruby is now ignoring the values
    we pass into `add_two`. Instead of 2, we get 5\. It looks like Ruby is using the
    default values for `a` and `b`, not the values we provided. Why did Ruby create
    a hash, and what does it contain? And why did Ruby ignore my parameter values
    when I overrode `Hash#key?`?'
  prefs: []
  type: TYPE_NORMAL
- en: To learn how Ruby implements keyword arguments and to explain the results we
    see running [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i "Example 4-9. Demonstrating
    that Ruby uses a hash to implement keyword arguments"), we can examine the YARV
    instructions generated by Ruby’s compiler for `add_two`. Running [Example 4-10](ch04.html#displaying_the_yarv_instructions_for_the
    "Example 4-10. Displaying the YARV instructions for the code in Example 4-9")
    displays the YARV instructions that correspond to [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "Example 4-9. Demonstrating that Ruby uses a hash to implement keyword arguments").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10. Displaying the YARV instructions for the code in [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "Example 4-9. Demonstrating that Ruby uses a hash to implement keyword arguments")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-16](ch04.html#part_of_the_output_generated_by_listing "Figure 4-16. Part
    of the output generated by Example 4-10") shows a simplified version of the output
    generated by [Example 4-10](ch04.html#displaying_the_yarv_instructions_for_the
    "Example 4-10. Displaying the YARV instructions for the code in Example 4-9").'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part of the output generated by](httpatomoreillycomsourcenostarchimages1854025.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-16. Part of the output generated by [Example 4-10](ch04.html#displaying_the_yarv_instructions_for_the
    "Example 4-10. Displaying the YARV instructions for the code in Example 4-9")
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right of [Figure 4-16](ch04.html#part_of_the_output_generated_by_listing
    "Figure 4-16. Part of the output generated by Example 4-10"), you can see that
    Ruby first pushes an array onto the stack: `[:a, 1, :b, 1]`. Next, it calls the
    internal C function `hash_from_ary`, which we can guess will convert the `[:a,
    1, :b, 1]` array into a hash. Finally, Ruby calls the `add_two` method to add
    the numbers and the `puts` method to display the result.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the YARV instructions for the `add_two` method itself, shown
    in [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the "Figure 4-17. The
    YARV instructions compiled from the beginning of the add_two method").
  prefs: []
  type: TYPE_NORMAL
- en: '![The YARV instructions compiled from the beginning of the add_two method](httpatomoreillycomsourcenostarchimages1854027.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-17. The YARV instructions compiled from the beginning of the `add_two`
    method
  prefs: []
  type: TYPE_NORMAL
- en: What are these YARV instructions doing? The Ruby method `add_two` didn’t contain
    any code similar to this! (All `add_two` does is add `a` and `b` together and
    return the sum.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out, let’s walk through [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the
    "Figure 4-17. The YARV instructions compiled from the beginning of the add_two
    method"). On the left side, we see the Ruby `add_two` method, and on the right,
    the YARV instructions for `add_two`. On the far right, you see the local table
    for `add_two`. Notice that there are three values listed there: `[ 2] ?`, `[ 3]
    b`, and `[ 4] a`. It should be clear that `a` and `b` correspond to the two arguments
    to `add_two`, but what does `[ 2] ?` mean? This appears to be some sort of mystery
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: The mystery value is the hash we saw created in [Figure 4-16](ch04.html#part_of_the_output_generated_by_listing
    "Figure 4-16. Part of the output generated by Example 4-10")! In order to implement
    keyword arguments, Ruby has created this third, hidden argument to `add_two`.
  prefs: []
  type: TYPE_NORMAL
- en: The YARV instructions in [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the
    "Figure 4-17. The YARV instructions compiled from the beginning of the add_two
    method") show that `getlocal 2, 0` followed by `dup` places this hash onto the
    stack as a receiver. Next, `putobject :a` puts the symbol `:a` onto the stack
    as a method parameter, and `opt_send_simple <callinfo!mid:key?` calls the `key?`
    method on the receiver, which is the hash.
  prefs: []
  type: TYPE_NORMAL
- en: These YARV instructions are equivalent to the following line of Ruby code. Ruby
    is querying the hidden hash object to see whether it contains the key `:a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Reading the rest of the YARV instructions from [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the
    "Figure 4-17. The YARV instructions compiled from the beginning of the add_two
    method"), we see that if the hash contains the key, Ruby calls the `delete` method,
    which removes the key from the hash and returns the corresponding value. Next,
    `setlocal 4, 0` saves this value into the `a` argument. If the hash didn’t contain
    the key `:a`, Ruby would call `putobject 2` and `setlocal 4, 0` to save the default
    value 2 into the argument.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, all of the YARV instructions shown in [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the
    "Figure 4-17. The YARV instructions compiled from the beginning of the add_two
    method") implement the snippet of Ruby code shown in [Example 4-11](ch04.html#yarv_instructions_shown_in_figure_4
    "Example 4-11. The YARV instructions shown in Figure 4-17 are equivalent to this
    Ruby code.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11. The YARV instructions shown in [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the
    "Figure 4-17. The YARV instructions compiled from the beginning of the add_two
    method") are equivalent to this Ruby code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we can see that Ruby stores the keyword arguments and their values in the
    hidden hash argument. When the method starts, it first loads each argument’s value
    from the hash or uses the default value if there is none. The behavior indicated
    by the Ruby code in [Figure 4-14](ch04.html#vmunderscoremethodunderscoretypeundersco
    "Figure 4-14. VM_METHOD_TYPE_ATTRSET methods call vm_setivar directly.") explains
    the results we saw when running [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "Example 4-9. Demonstrating that Ruby uses a hash to implement keyword arguments").
    Remember that we changed the `Hash#key?` method to always return `false`. If `hidden_hash.key?`
    always returns `false`, Ruby will ignore the value of each argument and use the
    default value instead, even if a value was provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last detail about keyword arguments: Whenever you call any method and use
    keyword arguments, YARV checks to see whether the keyword arguments you provide
    are expected by the target method. Ruby raises an exception if there is an unexpected
    argument, as shown in [Example 4-12](ch04.html#ruby_throws_an_exception_if_you_pass_an
    "Example 4-12. Ruby throws an exception if you pass an unexpected keyword argument.").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12. Ruby throws an exception if you pass an unexpected keyword argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because the argument list for `add_two` didn’t include the letter `c`, Ruby
    throws an exception when we try to call the method with `c`. This special check
    happens during the method dispatch process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter began with a look at how YARV controls the execution flow of your
    Ruby program using a series of low-level control structures. By displaying the
    YARV instructions produced by Ruby’s compiler, we saw some of YARV’s control structures
    and learned how they work. In [Experiment 4-1: Testing How Ruby Implements for
    Loops Internally](ch04.html#experiment_4-1_testing_how_ruby_implemen "Experiment
    4-1: Testing How Ruby Implements for Loops Internally"), we discovered that Ruby
    implements `for` loops internally using the `each` method with a block.'
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that internally Ruby categorizes methods into 11 types. We saw
    that Ruby creates a standard ISEQ method when you write a method using the `def`
    keyword and that Ruby labels its own built-in methods as CFUNC methods because
    they are implemented using C code. We learned about the ATTRSET and IVAR method
    types and saw how Ruby switches on the type of the target method during the method
    dispatch process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in [Experiment 4-2: Exploring How Ruby Implements Keyword Arguments](ch04.html#experiment_4-2_exploring_how_ruby_implem
    "Experiment 4-2: Exploring How Ruby Implements Keyword Arguments"), we looked
    at how Ruby implements keyword arguments, and we discovered along the way that
    Ruby uses a hash to track the argument labels and default values.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Objects and Classes") we’ll switch gears
    and explore objects and classes. We’ll return to YARV internals again in [Chapter 6](ch06.html
    "Chapter 6. Method Lookup and Constant Lookup") when we look at how the method
    lookup process works and discuss the concept of lexical scope.
  prefs: []
  type: TYPE_NORMAL
