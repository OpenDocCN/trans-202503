- en: Chapter 4. Control Structures and Method Dispatch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章 控制结构与方法调度
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*YARV uses its own internal set of control structures, like the structures
    you use in Ruby.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*YARV 使用它自己的一套控制结构，就像你在 Ruby 中使用的那些结构一样。*'
- en: In [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code") I explained
    how YARV uses a stack while executing its instruction set and how it can access
    variables locally or dynamically. Controlling the flow of execution is another
    fundamental requirement for any programming language, and Ruby has a rich set
    of control structures, too. How does YARV implement control structures?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.html "第 3 章：Ruby 如何执行你的代码")中，我解释了 YARV 如何在执行其指令集时使用栈，以及它如何本地或动态地访问变量。控制执行流程是任何编程语言的基本要求之一，Ruby
    也有一套丰富的控制结构。那么 YARV 是如何实现控制结构的呢？
- en: Like Ruby, YARV has its own control structures, albeit at a much lower level.
    Instead of `if` or `unless` statements, YARV uses two low-level instructions called
    `branchif` and `branchunless`. Instead of using control structures such as `while...end`
    or `until...end` loops, YARV has a single low-level function called `jump` that
    allows it to change the program counter and move through your compiled program.
    By combining the `branchif` or `branchunless` instruction with the `jump` instruction,
    YARV can execute most of Ruby’s simple control structures.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Ruby 一样，YARV 也有自己的控制结构，尽管它们位于更低的层次。YARV 使用两个低级指令 `branchif` 和 `branchunless`
    来代替 `if` 或 `unless` 语句。YARV 使用一个叫做 `jump` 的低级函数来代替控制结构，如 `while...end` 或 `until...end`
    循环，`jump` 允许它改变程序计数器并在已编译的程序中跳转。通过将 `branchif` 或 `branchunless` 指令与 `jump` 指令结合，YARV
    可以执行大多数 Ruby 的简单控制结构。
- en: When your code calls a method, YARV uses the `send` instruction. This process
    is known as *method dispatch*. You can consider `send` to be another one of Ruby’s
    control structures—the most complex and sophisticated one of all.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码调用方法时，YARV 使用 `send` 指令。这一过程被称为 *方法调度*。你可以把 `send` 看作 Ruby 的另一种控制结构——最复杂和最精密的控制结构。
- en: In this chapter we’ll learn more about YARV by exploring how it controls execution
    flow in your program. We’ll also look at the method dispatch process as we learn
    how Ruby categorizes methods into types, calling each method type differently.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将通过探索 YARV 如何控制程序的执行流程，进一步了解 YARV。我们还将研究方法调度过程，了解 Ruby 如何将方法分类为不同的类型，并分别调用每种方法类型。
- en: Roadmap
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[How Ruby Executes an if Statement](ch04.html#how_ruby_executes_an_if_statement
    "How Ruby Executes an if Statement")'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 如何执行 if 语句](ch04.html#how_ruby_executes_an_if_statement "Ruby 如何执行 if
    语句")'
- en: '[Jumping from One Scope to Another](ch04.html#jumping_from_one_scope_to_another
    "Jumping from One Scope to Another")'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从一个作用域跳转到另一个作用域](ch04.html#jumping_from_one_scope_to_another "从一个作用域跳转到另一个作用域")'
- en: '[Catch Tables](ch04.html#catch_tables "Catch Tables")'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[捕获表](ch04.html#catch_tables "捕获表")'
- en: '[Other Uses for Catch Tables](ch04.html#other_uses_for_catch_tables "Other
    Uses for Catch Tables")'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[捕获表的其他用途](ch04.html#other_uses_for_catch_tables "捕获表的其他用途")'
- en: '**[Experiment 4-1: Testing How Ruby Implements for Loops Internally](ch04.html#experiment_4-1_testing_how_ruby_implemen
    "Experiment 4-1: Testing How Ruby Implements for Loops Internally")**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 4-1：测试 Ruby 如何内部实现 for 循环](ch04.html#experiment_4-1_testing_how_ruby_implemen
    "实验 4-1：测试 Ruby 如何内部实现 for 循环")**'
- en: '[The send Instruction: Ruby’s Most Complex Control Structure](ch04.html#send_instruction_rubyapostrophes_mos
    "The send Instruction: Ruby’s Most Complex Control Structure")'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[send 指令：Ruby 最复杂的控制结构](ch04.html#send_instruction_rubyapostrophes_mos "send
    指令：Ruby 最复杂的控制结构")'
- en: '[Method Lookup and Method Dispatch](ch04.html#method_lookup_and_method_dispatch
    "Method Lookup and Method Dispatch")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方法查找与方法调度](ch04.html#method_lookup_and_method_dispatch "方法查找与方法调度")'
- en: '[Eleven Types of Ruby Methods](ch04.html#eleven_types_of_ruby_methods "Eleven
    Types of Ruby Methods")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 方法的 11 种类型](ch04.html#eleven_types_of_ruby_methods "Ruby 方法的 11 种类型")'
- en: '[Calling Normal Ruby Methods](ch04.html#calling_normal_ruby_methods "Calling
    Normal Ruby Methods")'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[调用普通 Ruby 方法](ch04.html#calling_normal_ruby_methods "调用普通 Ruby 方法")'
- en: '[Preparing Arguments for Normal Ruby Methods](ch04.html#preparing_arguments_for_normal_ruby_meth
    "Preparing Arguments for Normal Ruby Methods")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为普通 Ruby 方法准备参数](ch04.html#preparing_arguments_for_normal_ruby_meth "为普通 Ruby
    方法准备参数")'
- en: '[Calling Built-In Ruby Methods](ch04.html#calling_built-in_ruby_methods "Calling
    Built-In Ruby Methods")'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[调用内建 Ruby 方法](ch04.html#calling_built-in_ruby_methods "调用内建 Ruby 方法")'
- en: '[Calling attr_reader and attr_writer](ch04.html#calling_attrunderscorereader_and_attrund
    "Calling attr_reader and attr_writer")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[调用 attr_reader 和 attr_writer](ch04.html#calling_attrunderscorereader_and_attrund
    "调用 attr_reader 和 attr_writer")'
- en: '[Method Dispatch Optimizes attr_reader and attr_writer](ch04.html#method_dispatch_optimizes_attrunderscore
    "Method Dispatch Optimizes attr_reader and attr_writer")'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方法调度优化 attr_reader 和 attr_writer](ch04.html#method_dispatch_optimizes_attrunderscore
    "方法调度优化 attr_reader 和 attr_writer")'
- en: '**[Experiment 4-2: Exploring How Ruby Implements Keyword Arguments](ch04.html#experiment_4-2_exploring_how_ruby_implem
    "Experiment 4-2: Exploring How Ruby Implements Keyword Arguments")**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 4-2: 探索 Ruby 如何实现关键字参数](ch04.html#experiment_4-2_exploring_how_ruby_implem
    "实验 4-2: 探索 Ruby 如何实现关键字参数")**'
- en: '[Summary](ch04.html#summary-id00014 "Summary")'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch04.html#summary-id00014 "总结")'
- en: How Ruby Executes an if Statement
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 如何执行 if 语句
- en: 'In order to understand how YARV controls execution flow, let’s see how the
    `if...else` statement works. The left side of [Figure 4-1](ch04.html#how_ruby_compiles_an_ifhellipelse_statem
    "Figure 4-1. How Ruby compiles an if...else statement") shows a simple Ruby script
    that uses both `if` and `else`. On the right side of the figure, you can see the
    corresponding snippet of compiled YARV instructions. Reading the YARV instructions,
    you see that Ruby follows a pattern for implementing the `if...else` statement.
    It goes like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 YARV 如何控制执行流，我们来看一下 `if...else` 语句的工作原理。图 [4-1](ch04.html#how_ruby_compiles_an_ifhellipelse_statem
    "图 4-1. Ruby 如何编译 if...else 语句") 左侧展示了一个简单的 Ruby 脚本，其中使用了 `if` 和 `else`。右侧则展示了对应的
    YARV 编译指令片段。通过阅读 YARV 指令，你会发现 Ruby 实现 `if...else` 语句的模式如下：
- en: Evaluate condition
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估条件
- en: Jump to false code if condition is false
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果条件为假，跳转到假代码
- en: True code; jump past false code
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真代码；跳过假代码
- en: False code
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假代码
- en: '![How Ruby compiles an if...else statement](httpatomoreillycomsourcenostarchimages1853995.png.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 如何编译 if...else 语句](httpatomoreillycomsourcenostarchimages1853995.png.jpg)'
- en: Figure 4-1. How Ruby compiles an `if...else` statement
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1. Ruby 如何编译 `if...else` 语句
- en: 'This pattern should be a bit easier to follow in the flowchart shown in [Figure 4-2](ch04.html#this_flowchart_shows_the_pattern_ruby_us
    "Figure 4-2. This flowchart shows the pattern Ruby uses to compile if...else statements.")
    on the next page. The `branchunless` instruction in the center of the figure is
    the key to how Ruby implements `if` statements. It works as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的页面中，[图 4-2](ch04.html#this_flowchart_shows_the_pattern_ruby_us "图 4-2.
    该流程图展示了 Ruby 编译 `if...else` 语句的模式") 中的流程图会让这个模式更容易理解。图中的 `branchunless` 指令是 Ruby
    实现 `if` 语句的关键。它的工作原理如下：
- en: Ruby evaluates the condition of the `if` statement, `i < 10`, using the `opt_lt`
    (optimized less-than) instruction. This evaluation leaves either a true or false
    value on the stack.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ruby 使用 `opt_lt`（优化版小于）指令来评估 `if` 语句的条件 `i < 10`。这一评估将结果（真或假）留在栈上。
- en: '`branchunless` jumps down to the `else` code if the condition is false. That
    is, it “branches unless” the condition is true. Ruby uses `branchunless`, not
    `branchif`, for `if...else` conditions because the positive case is compiled to
    appear right after the condition code. Therefore, YARV needs to jump if the condition
    is false.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`branchunless` 指令会在条件为假时跳转到 `else` 代码块，也就是说，除非条件为真，否则它会“分支”。Ruby 使用 `branchunless`
    而非 `branchif` 来处理 `if...else` 条件，因为正向代码会编译在条件代码之后。因此，当条件为假时，YARV 需要进行跳转。'
- en: If the condition is true, Ruby does not branch and just continues to execute
    the positive case code. Once it’s finished, it jumps down to the instructions
    following the `if...else` statement using the `jump` instruction.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果条件为真，Ruby 不会进行分支，而是继续执行正向的代码。执行完毕后，它通过 `jump` 指令跳转到 `if...else` 语句后的指令。
- en: Whether or not it branches, Ruby continues to execute the subsequent code.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论是否分支，Ruby 都会继续执行后续代码。
- en: 'YARV implements the `unless` statement similarly to how it implements `if`,
    except that the positive and negative code snippets are in reverse order. For
    looping control structures like `while...end` and `until...end`, YARV uses the
    `branchif` instruction instead, but the idea is the same: Calculate the loop condition,
    execute `branchif` to jump as necessary, and then use `jump` statements to implement
    the loop.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: YARV 实现 `unless` 语句的方式与 `if` 类似，只是正向和反向代码片段的顺序相反。对于类似 `while...end` 和 `until...end`
    这样的循环控制结构，YARV 使用 `branchif` 指令，原理是一样的：计算循环条件，执行 `branchif` 进行跳转，然后使用 `jump` 指令来实现循环。
- en: '![This flowchart shows the pattern Ruby uses to compile if...else statements.](httpatomoreillycomsourcenostarchimages1853997.png.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![这个流程图展示了 Ruby 编译 if...else 语句的模式。](httpatomoreillycomsourcenostarchimages1853997.png.jpg)'
- en: Figure 4-2. This flowchart shows the pattern Ruby uses to compile `if...else`
    statements.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2. 这个流程图展示了 Ruby 编译 `if...else` 语句的模式。
- en: Jumping from One Scope to Another
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个作用域跳转到另一个作用域
- en: One of the challenges YARV has in implementing some control structures is that,
    as with dynamic variable access, Ruby can jump from one scope to another. For
    example, `break` can be used to exit a simple loop like the one in [Example 4-1](ch04.html#break_used_to_exit_a_simple_loop
    "Example 4-1. break used to exit a simple loop").
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: YARV 在实现一些控制结构时面临的挑战之一是，和动态变量访问一样，Ruby 可以从一个作用域跳到另一个作用域。例如，`break` 可以用于退出像[示例
    4-1](ch04.html#break_used_to_exit_a_simple_loop "示例 4-1. 使用 break 退出一个简单的循环")中的简单循环。
- en: Example 4-1. `break` used to exit a simple loop
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-1. 使用 `break` 退出一个简单的循环
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And it can also be used to exit a block iteration, like the one in [Example 4-2](ch04.html#break_used_to_exit_a_block
    "Example 4-2. break used to exit a block").
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以用于退出一个块迭代，比如在[示例 4-2](ch04.html#break_used_to_exit_a_block "示例 4-2. 使用 break
    退出块")中的那个。
- en: Example 4-2. `break` used to exit a block
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-2. 使用 `break` 退出一个块
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the first listing, YARV can exit the `while` loop using simple `jump` instructions.
    But exiting a block like the one in the second listing is not so simple: In this
    case, YARV needs to jump to the parent scope and continue execution after the
    call to `10.times`. How does YARV know where to jump to? And how does it adjust
    both its internal stack and your Ruby call stack in order to continue execution
    properly in the parent scope?'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个列表中，YARV 可以通过简单的 `jump` 指令退出 `while` 循环。但退出像第二个列表中的块就不那么简单了：在这种情况下，YARV
    需要跳转到父作用域，并在调用 `10.times` 后继续执行。YARV是如何知道跳转到哪里去的？它又是如何调整其内部栈和你的 Ruby 调用栈，以确保在父作用域中正确继续执行的呢？
- en: 'To implement jumping from one place to another in the Ruby call stack (that
    is, outside the current scope), Ruby uses the `throw` YARV instruction. This instruction
    resembles the Ruby `throw` keyword: It sends, or throws, the execution path back
    up to a higher scope. For example, [Figure 4-3](ch04.html#how_ruby_compiles_a_break_statement_used
    "Figure 4-3. How Ruby compiles a break statement used inside a block") shows how
    Ruby compiles [Example 4-2](ch04.html#break_used_to_exit_a_block "Example 4-2. break
    used to exit a block"), with the block containing a `break` statement. The Ruby
    code is on the left, and the compiled version is on the right.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 Ruby 调用栈中从一个地方跳转到另一个地方（也就是说，跳出当前作用域），Ruby 使用 `throw` YARV 指令。该指令类似于 Ruby
    的 `throw` 关键字：它将执行路径抛回到更高的作用域。例如，[图 4-3](ch04.html#how_ruby_compiles_a_break_statement_used
    "图 4-3. Ruby 如何编译在块中使用的 break 语句")展示了 Ruby 如何编译[示例 4-2](ch04.html#break_used_to_exit_a_block
    "示例 4-2. 使用 break 退出一个块")，其中块内包含一个 `break` 语句。左边是 Ruby 代码，右边是编译后的版本。
- en: '![How Ruby compiles a break statement used inside a block](httpatomoreillycomsourcenostarchimages1853999.png.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 如何编译在块中使用的 break 语句](httpatomoreillycomsourcenostarchimages1853999.png.jpg)'
- en: Figure 4-3. How Ruby compiles a `break` statement used inside a block
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3. Ruby 如何编译在块中使用的 `break` 语句
- en: Catch Tables
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Catch 表
- en: At the top right of [Figure 4-3](ch04.html#how_ruby_compiles_a_break_statement_used
    "Figure 4-3. How Ruby compiles a break statement used inside a block"), the `throw
    2` in the compiled code for the block throws an exception at the YARV instruction
    level using a *catch table*, or a table of pointers that may be attached to any
    YARV code snippet. Conceptually, a catch table might look like [Figure 4-4](ch04.html#each_snippet_of_yarv_code_can_contain_a
    "Figure 4-4. Each snippet of YARV code can contain a catch table.").
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4-3](ch04.html#how_ruby_compiles_a_break_statement_used "图 4-3. Ruby 如何编译在块中使用的
    break 语句")的右上角，编译后的代码中的 `throw 2` 在 YARV 指令级别通过使用 *catch 表*（或可以附加到任何 YARV 代码片段的指针表）抛出一个异常。从概念上讲，一个
    catch 表可能像[图 4-4](ch04.html#each_snippet_of_yarv_code_can_contain_a "图 4-4. 每段
    YARV 代码可以包含一个 catch 表")一样。
- en: '![Each snippet of YARV code can contain a catch table.](httpatomoreillycomsourcenostarchimages1854001.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![每段 YARV 代码可以包含一个 catch 表。](httpatomoreillycomsourcenostarchimages1854001.png.jpg)'
- en: Figure 4-4. Each snippet of YARV code can contain a catch table.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-4. 每段 YARV 代码可以包含一个 catch 表。
- en: This catch table contains just a single pointer to the `pop` statement, where
    execution would continue after an exception. Whenever you use a `break` statement
    in a block, Ruby compiles the `throw` instruction into the block’s code and adds
    the `BREAK` entry into the parent scope’s catch table. For a `break` within a
    series of nested blocks, Ruby would add the `BREAK` entry to a catch table even
    farther down the `rb_control_frame_t` stack.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该捕获表只包含指向 `pop` 语句的一个指针，执行将在捕获到异常后从该语句继续。每当你在代码块中使用 `break` 语句时，Ruby 会将 `throw`
    指令编译进代码块的代码，并在父作用域的捕获表中添加 `BREAK` 条目。对于一系列嵌套的代码块中的 `break`，Ruby 会将 `BREAK` 条目添加到更深层的
    `rb_control_frame_t` 栈的捕获表中。
- en: Later, when YARV executes the `throw` instruction, it checks to see whether
    there’s a catch table containing a break pointer for the current YARV instruction
    sequence, as shown in [Figure 4-5](ch04.html#while_executing_a_throw_instructioncomma
    "Figure 4-5. While executing a throw instruction, YARV starts iterating down the
    Ruby call stack.").
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，当 YARV 执行 `throw` 指令时，它会检查是否存在一个包含中断指针的捕获表，适用于当前的 YARV 指令序列，如 [图 4-5](ch04.html#while_executing_a_throw_instructioncomma
    "图 4-5. 在执行 `throw` 指令时，YARV 开始向下遍历 Ruby 调用栈。") 所示。
- en: '![While executing a throw instruction, YARV starts iterating down the Ruby
    call stack.](httpatomoreillycomsourcenostarchimages1854003.png.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![在执行 `throw` 指令时，YARV 开始向下遍历 Ruby 调用栈。](httpatomoreillycomsourcenostarchimages1854003.png.jpg)'
- en: Figure 4-5. While executing a `throw` instruction, YARV starts iterating down
    the Ruby call stack.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5. 在执行 `throw` 指令时，YARV 开始向下遍历 Ruby 调用栈。
- en: If it doesn’t find a catch table, Ruby starts to iterate down through the stack
    of `rb_control_frame_t` structures in search of a catch table containing a break
    pointer, as shown in [Figure 4-6](ch04.html#ruby_continues_to_iterate_down_the_call
    "Figure 4-6. Ruby continues to iterate down the call stack looking for a catch
    table with a break pointer.").
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到捕获表，Ruby 会开始通过 `rb_control_frame_t` 结构的栈向下遍历，寻找一个包含中断指针的捕获表，如 [图 4-6](ch04.html#ruby_continues_to_iterate_down_the_call
    "图 4-6. Ruby 会继续向下遍历调用栈，寻找带有中断指针的捕获表。") 所示。
- en: '![Ruby continues to iterate down the call stack looking for a catch table with
    a break pointer.](httpatomoreillycomsourcenostarchimages1854005.png.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 会继续向下遍历调用栈，寻找带有中断指针的捕获表。](httpatomoreillycomsourcenostarchimages1854005.png.jpg)'
- en: Figure 4-6. Ruby continues to iterate down the call stack looking for a catch
    table with a break pointer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6. Ruby 会继续向下遍历调用栈，寻找带有中断指针的捕获表。
- en: As you can see in [Figure 4-7](ch04.html#ruby_keeps_iterating_until_it_finds_a_ca
    "Figure 4-7. Ruby keeps iterating until it finds a catch table with a break pointer
    or reaches the end of the call stack."), Ruby continues to iterate until it finds
    a catch table with a break pointer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '如你在 [图 4-7](ch04.html#ruby_keeps_iterating_until_it_finds_a_ca "图 4-7. Ruby
    会继续遍历，直到找到带有中断指针的捕获表或到达调用栈的末尾。") 所见，Ruby 会继续遍历，直到找到带有中断指针的捕获表。  '
- en: '![Ruby keeps iterating until it finds a catch table with a break pointer or
    reaches the end of the call stack.](httpatomoreillycomsourcenostarchimages1854007.png.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 会继续遍历，直到找到带有中断指针的捕获表或到达调用栈的末尾。](httpatomoreillycomsourcenostarchimages1854007.png.jpg)'
- en: Figure 4-7. Ruby keeps iterating until it finds a catch table with a break pointer
    or reaches the end of the call stack.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-7. Ruby 会继续遍历，直到找到带有中断指针的捕获表或到达调用栈的末尾。
- en: In this simple example, there is only one level of block nesting, so Ruby finds
    the catch table and break pointer after just one iteration, as shown in [Figure 4-8](ch04.html#ruby_finds_a_catch_table_with_a_break_po
    "Figure 4-8. Ruby finds a catch table with a break pointer.").
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，只有一层代码块嵌套，因此 Ruby 在一次遍历后就找到了捕获表和中断指针，如 [图 4-8](ch04.html#ruby_finds_a_catch_table_with_a_break_po
    "图 4-8. Ruby 找到了带有中断指针的捕获表。") 所示。
- en: '![Ruby finds a catch table with a break pointer.](httpatomoreillycomsourcenostarchimages1854009.png.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 找到了带有中断指针的捕获表。](httpatomoreillycomsourcenostarchimages1854009.png.jpg)'
- en: Figure 4-8. Ruby finds a catch table with a break pointer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-8. Ruby 找到了一个带有中断指针的捕获表。
- en: Once Ruby finds the catch table pointer, it resets both the Ruby call stack
    (the `CFP` pointer) and the internal YARV stack to reflect the new program execution
    point. YARV continues to execute your code from there—that is, it resets the internal
    `PC` and `SP` pointers as needed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Ruby 找到捕获表指针，它会重置 Ruby 调用栈（即 `CFP` 指针）和内部的 YARV 栈，以反映新的程序执行点。YARV 会从该位置继续执行你的代码——即根据需要重置内部的
    `PC` 和 `SP` 指针。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Ruby uses a process similar to raising and rescuing an exception internally
    in order to implement a very commonly used control structure: the `break` keyword.
    In other words, what in more verbose languages is an exceptional occurrence becomes
    in Ruby a common, everyday action. Ruby has wrapped up a confusing, unusual syntax—the
    raising/rescuing of exceptions—into a simple keyword, `break`, and made it very
    easy to understand and use. (Of course, Ruby needs to use exceptions because of
    the way blocks work. On the one hand, they’re like separate functions or subroutines,
    but on the other, they’re just part of the surrounding code.)*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ruby 在内部使用类似于引发和捕获异常的过程来实现一个非常常用的控制结构：`break`关键字。换句话说，在其他更冗长的语言中是异常情况，在 Ruby
    中却是一种常见的、每天都会发生的行为。Ruby 将一个令人困惑、不寻常的语法——引发/捕获异常——封装成一个简单的关键字`break`，使其易于理解和使用。（当然，由于块的工作方式，Ruby
    需要使用异常。一方面，它们像是独立的函数或子程序，但另一方面，它们只是周围代码的一部分。）*'
- en: Other Uses for Catch Tables
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获表的其他用途
- en: 'The `return` keyword is another ordinary Ruby control structure that also uses
    catch tables. Whenever you call `return` from inside a block, Ruby raises an internal
    exception that it rescues with a catch table pointer in the same way it does when
    you call `break`. In fact, `break` and `return` are implemented with the same
    YARV instructions with one exception: For `return`, Ruby passes a 1 to the `throw`
    instruction (for example, `throw 1`), while for `break`, it passes a 2 (`throw
    2`). The `return` and `break` keywords are really two sides of the same coin.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`关键字是另一个普通的 Ruby 控制结构，也使用捕获表。每当你在块内部调用`return`时，Ruby 会引发一个内部异常，然后通过捕获表指针来捕获它，就像你调用`break`时一样。实际上，`break`和`return`使用相同的
    YARV 指令实现，只有一个例外：对于`return`，Ruby 传递一个 1 给`throw`指令（例如，`throw 1`），而对于`break`，它传递一个
    2（`throw 2`）。`return`和`break`关键字实际上是同一个硬币的两面。'
- en: Besides `break`, Ruby uses the catch table to implement the control structures
    `rescue`, `ensure`, `retry`, `redo`, and `next`. For example, when you explicitly
    raise an exception in your Ruby code using the `raise` keyword, Ruby implements
    the `rescue` block using the catch table, but with a `rescue` pointer. The catch
    table is simply a list of event types that can be caught and handled by that sequence
    of YARV instructions, just as you would use a `rescue` block in your Ruby code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`break`，Ruby 还使用捕获表来实现控制结构`rescue`、`ensure`、`retry`、`redo`和`next`。例如，当你在 Ruby
    代码中使用`raise`关键字明确引发异常时，Ruby 使用捕获表来实现`rescue`块，但使用一个`rescue`指针。捕获表只是一个可以被那些 YARV
    指令序列捕获和处理的事件类型列表，就像你在 Ruby 代码中使用`rescue`块一样。
- en: 'Experiment 4-1: Testing How Ruby Implements for Loops Internally'
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 4-1：测试 Ruby 如何在内部实现`for`循环
- en: 'I had always known that Ruby’s `for` loop control structure worked essentially
    the same way as a block with the `each` method of the `Enumerable` module. That
    is, I knew that this code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直知道 Ruby 的`for`循环控制结构本质上与`Enumerable`模块的`each`方法的块相同。也就是说，我知道这段代码：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'worked like this code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 的工作方式类似于这段代码：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But I never suspected that internally Ruby actually implements `for` loops using
    `each`! In other words, Ruby has no `for` loop control structure. Instead, the
    `for` keyword is really just syntactical sugar for calling `each` with a range.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但我从未怀疑过 Ruby 在内部实际上是使用`each`来实现`for`循环的！换句话说，Ruby 没有`for`循环控制结构。相反，`for`关键字实际上只是调用一个范围的`each`的语法糖。
- en: 'To prove this, simply inspect the YARV instructions produced by Ruby when you
    compile a `for` loop. In [Example 4-3](ch04.html#this_code_will_display_how_ruby_compiles
    "Example 4-3. This code will display how Ruby compiles a for loop."), let’s use
    the same `RubyVM:: InstructionSequence.compile` method to display the YARV instructions.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '要证明这一点，只需检查 Ruby 在编译`for`循环时生成的 YARV 指令。在[示例 4-3](ch04.html#this_code_will_display_how_ruby_compiles
    "示例 4-3. 这段代码将展示 Ruby 如何编译一个`for`循环。")中，让我们使用相同的`RubyVM:: InstructionSequence.compile`方法来显示
    YARV 指令。'
- en: Example 4-3. This code will display how Ruby compiles a `for` loop.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-3. 这段代码将展示 Ruby 如何编译一个`for`循环。
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running this code gives the output shown in [Example 4-4](ch04.html#output_generated_by_listing_4-3
    "Example 4-4. The output generated by Example 4-3").
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会得到[示例 4-4](ch04.html#output_generated_by_listing_4-3 "示例 4-4. 示例 4-3
    生成的输出")中显示的输出。
- en: Example 4-4. The output generated by [Example 4-3](ch04.html#this_code_will_display_how_ruby_compiles
    "Example 4-3. This code will display how Ruby compiles a for loop.")
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-4. [示例 4-3](ch04.html#this_code_will_display_how_ruby_compiles "示例 4-3. 这段代码将展示
    Ruby 如何编译一个`for`循环。")生成的输出
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Figure 4-9](ch04.html#simplified_display_of_the_yarv_instruc "Figure 4-9. A
    simplified display of the YARV instructions in Example 4-4") shows the Ruby code
    on the left and YARV instructions on the right. (I’ve removed some of the technical
    details, like the `trace` statements, in order to simplify things a bit.)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-9](ch04.html#simplified_display_of_the_yarv_instruc "图 4-9. 简化显示 Example
    4-4 中的 YARV 指令") 显示了左侧的 Ruby 代码和右侧的 YARV 指令。（我已去除一些技术细节，例如 `trace` 语句，以简化内容。）'
- en: '![A simplified display of the YARV instructions in](httpatomoreillycomsourcenostarchimages1854011.png.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![简化显示 YARV 指令](httpatomoreillycomsourcenostarchimages1854011.png.jpg)'
- en: Figure 4-9. A simplified display of the YARV instructions in [Example 4-4](ch04.html#output_generated_by_listing_4-3
    "Example 4-4. The output generated by Example 4-3")
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-9. [示例 4-4](ch04.html#output_generated_by_listing_4-3 "示例 4-4. 示例 4-3 生成的输出")
    中简化显示的 YARV 指令
- en: 'Notice that there are two separate YARV code blocks: The outer scope calls
    `each` on the range `0..5`, and an inner block makes the `puts i` call. The `getlocal
    2, 0` instruction in the inner block loads the implied block parameter value (`i`
    in my Ruby code), and the `setlocal` instruction that follows saves it into the
    local variable `i`, located back in the parent scope using dynamic variable access.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，存在两个独立的 YARV 代码块：外部作用域对范围 `0..5` 调用 `each`，而内部块则执行 `puts i` 调用。内部块中的 `getlocal
    2, 0` 指令加载了隐式的块参数值（在我的 Ruby 代码中是 `i`），紧随其后的 `setlocal` 指令将其保存到局部变量 `i` 中，该变量通过动态变量访问在父作用域中被使用。
- en: 'In effect, Ruby has automatically done the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Ruby 已自动执行了以下操作：
- en: Converted the `for i in 0..5` code into `(0..5).each do`
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `for i in 0..5` 代码转换为 `(0..5).each do`
- en: Created a block parameter to hold each value in the range
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个块参数来保存范围内的每个值
- en: Copied the block parameter, or the iteration counter, back into the local variable
    `i` each time around the loop
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次循环时，都将块参数或迭代计数器复制回局部变量 `i`
- en: 'The send Instruction: Ruby’s Most Complex Control Structure'
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送指令：Ruby 最复杂的控制结构
- en: We’ve seen how YARV controls the execution flow of our Ruby program using low-level
    instructions such as `branchunless` and `jump`. However, the most commonly used
    and important YARV instruction for controlling Ruby program execution flow is
    the `send` instruction. The `send` instruction tells YARV to jump to another method
    and start executing it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 YARV 如何通过低级指令如 `branchunless` 和 `jump` 控制 Ruby 程序的执行流。然而，最常用和最重要的 YARV
    指令是 `send` 指令。`send` 指令告诉 YARV 跳转到另一个方法并开始执行它。
- en: Method Lookup and Method Dispatch
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法查找和方法调度
- en: How does `send` work? How does YARV know which method to call, and how does
    it actually call the method? [Figure 4-10](ch04.html#ruby_uses_method_lookup_to_find_which_me
    "Figure 4-10. Ruby uses method lookup to find which method to call and which method
    dispatch to call it.") shows a high-level overview of the process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`send` 如何工作？YARV 如何知道调用哪个方法，并且它如何实际调用方法？[图 4-10](ch04.html#ruby_uses_method_lookup_to_find_which_me
    "图 4-10. Ruby 使用方法查找来确定调用哪个方法以及调用哪个方法调度") 展示了这一过程的概述。'
- en: This seems very simple, but the algorithm Ruby uses to find and call the target
    method is actually very complex. First, in *method lookup*, Ruby searches for
    the method your code actually should call. This involves looping through the classes
    and modules that make up the receiver object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常简单，但 Ruby 用来查找并调用目标方法的算法实际上非常复杂。首先，在*方法查找*过程中，Ruby 会搜索您的代码应该调用的实际方法。这涉及到循环遍历组成接收者对象的类和模块。
- en: '![Ruby uses method lookup to find which method to call and which method dispatch
    to call it.](httpatomoreillycomsourcenostarchimages1854013.png.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 使用方法查找来确定调用哪个方法以及调用哪个方法调度。](httpatomoreillycomsourcenostarchimages1854013.png.jpg)'
- en: Figure 4-10. Ruby uses method lookup to find which method to call and which
    method dispatch to call it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-10. Ruby 使用方法查找来确定调用哪个方法以及调用哪个方法调度。
- en: Once Ruby finds the method your code is trying to call, it uses *method dispatch*
    to actually execute the method call. This involves preparing the arguments to
    the method, pushing a new frame onto YARV’s internal stack, and changing YARV’s
    internal registers in order to actually start executing the target method. Like
    method lookup, method dispatch is a complex process because of the way Ruby categorizes
    your methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Ruby 找到代码中试图调用的方法，它就会使用*方法调度*来实际执行该方法调用。这涉及准备方法的参数，推送一个新的帧到 YARV 的内部栈中，并更改
    YARV 的内部寄存器，从而开始执行目标方法。与方法查找类似，方法调度是一个复杂的过程，因为 Ruby 对方法进行分类的方式。
- en: During the rest of this chapter I’ll discuss the method dispatch process. We’ll
    see how method lookup works in [Chapter 6](ch06.html "Chapter 6. Method Lookup
    and Constant Lookup"), once we have learned more about how Ruby implements objects,
    classes, and modules.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我将讨论方法调度过程。我们将在 [第六章](ch06.html "第六章. 方法查找与常量查找") 中进一步了解方法查找的工作原理，届时我们将深入学习
    Ruby 如何实现对象、类和模块。
- en: Eleven Types of Ruby Methods
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十一种 Ruby 方法类型
- en: Internally, Ruby categorizes your methods into 11 different types! During the
    method dispatch process, Ruby determines which type of method your code is trying
    to call. It then calls each type of method differently depending on its type,
    as shown in [Figure 4-11](ch04.html#while_executing_sendcomma_yarv_switches "Figure 4-11. While
    executing send, YARV switches on the type of the target method.").
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Ruby 将方法分为 11 种不同的类型！在方法调度过程中，Ruby 会确定你的代码试图调用的是哪种类型的方法。然后，它会根据方法类型的不同，以不同的方式调用每种类型的方法，如
    [图 4-11](ch04.html#while_executing_sendcomma_yarv_switches "图 4-11. 在执行 send 时，YARV
    根据目标方法的类型进行切换。") 所示。
- en: Most methods—including all methods you write with Ruby code in your program—are
    referred to as ISEQ, or *instruction sequence* methods, by YARV’s internal source
    code because Ruby compiles your code into a series of YARV bytecode instructions.
    But internally, YARV uses 10 other method types as well. These other method types
    are required because Ruby needs to call certain methods in a special way in order
    to speed up method dispatch, because these methods are implemented with C code
    or for various internal, technical reasons.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数方法——包括你在程序中用 Ruby 代码编写的所有方法——都被 YARV 的内部源代码称为 ISEQ，或*指令序列*方法，因为 Ruby 会将你的代码编译成一系列的
    YARV 字节码指令。但在内部，YARV 还使用其他 10 种方法类型。这些其他方法类型是必要的，因为 Ruby 需要以特殊方式调用某些方法，以加速方法调度，因为这些方法是通过
    C 代码实现的，或出于各种内部技术原因。
- en: '![While executing send, YARV switches on the type of the target method.](httpatomoreillycomsourcenostarchimages1854015.png.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![在执行 send 时，YARV 根据目标方法的类型进行切换。](httpatomoreillycomsourcenostarchimages1854015.png.jpg)'
- en: Figure 4-11. While executing `send`, YARV switches on the type of the target
    method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-11。执行 `send` 时，YARV 根据目标方法的类型进行切换。
- en: Here’s a quick description of all 11 method types. We’ll explore some of these
    in more detail in the following sections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有 11 种方法类型的简要描述。我们将在接下来的章节中详细探讨其中一些。
- en: '****ISEQ****. A normal method that you write using Ruby code, this is the most
    common method type. ISEQ stands for *instruction sequence*.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****ISEQ****。你用 Ruby 代码编写的普通方法，这是最常见的类型。ISEQ 代表*指令序列*。'
- en: '****CFUNC****. Using C code included directly inside the Ruby executable, these
    are the methods that Ruby implements rather than you. CFUNC stands for *C function*.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****CFUNC****。使用直接包含在 Ruby 可执行文件中的 C 代码，这些是 Ruby 实现的方法，而非你自己实现的。CFUNC 代表*C
    函数*。'
- en: '****ATTRSET****. A method of this type is created by the `attr_writer` method.
    ATTRSET stands for *attribute set*.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****ATTRSET****。这种类型的方法是通过 `attr_writer` 方法创建的。ATTRSET 代表*属性集*。'
- en: '****IVAR****. Ruby uses this method type when you call `attr_reader`. IVAR
    stands for *instance variable*.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****IVAR****。当你调用 `attr_reader` 时，Ruby 使用这种方法类型。IVAR 代表*实例变量*。'
- en: '****BMETHOD****. Ruby uses this method type when you call `define_method` and
    pass in a proc object. Because the method is represented internally by a proc,
    Ruby needs to handle this method type in a special way.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****BMETHOD****。当你调用 `define_method` 并传入一个 proc 对象时，Ruby 使用这种方法类型。由于该方法在内部由
    proc 表示，Ruby 需要以特殊的方式处理这种方法类型。'
- en: '****ZSUPER****. Ruby uses this method type when you set a method to be public
    or private in a particular class or module when it was actually defined in some
    superclass. This method is not commonly used.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****ZSUPER****。Ruby 使用这种方法类型来设置方法的访问权限（如 public 或 private），当该方法实际上在某个超类中定义时。这种方法不常用。'
- en: '****UNDEF****. Ruby uses this method type internally when it needs to remove
    a method from a class. Also, if you remove a method using `undef_method`, Ruby
    creates a new method of the same name using the UNDEF method type.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****UNDEF****. Ruby 在内部使用这种方法类型，当它需要从类中移除一个方法时。另外，如果你使用 `undef_method` 删除一个方法，Ruby
    会使用 UNDEF 方法类型创建一个同名的新方法。'
- en: '****NOTIMPLEMENTED****. Like UNDEF, Ruby uses this method type to mark certain
    methods as not implemented. This is necessary, for example, when you run Ruby
    on a platform that doesn’t support a particular operating system call.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****NOTIMPLEMENTED****. 和 UNDEF 一样，Ruby 使用这种方法类型标记某些方法为未实现。这在你在一个不支持特定操作系统调用的平台上运行
    Ruby 时是必要的。'
- en: '****OPTIMIZED****. Ruby speeds up some important methods using this type, like
    the `Kernel#send` method.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****OPTIMIZED****. Ruby 使用这种类型加速一些重要方法，如 `Kernel#send` 方法。'
- en: '****MISSING****. Ruby uses this method type if you ask for a method object
    from a module or class using `Kernel#method` and the method is missing.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****MISSING****. 如果你通过 `Kernel#method` 从模块或类中请求方法对象，而该方法缺失，Ruby 会使用这种方法类型。'
- en: '****REFINED****. Ruby uses this method type in its implementation of refinements,
    a new feature introduced in version 2.0.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****REFINED****. Ruby 在其实现的精炼（refinements）中使用这种方法类型，这是 2.0 版本中引入的新特性。'
- en: 'Now let’s focus on the most important and frequently used method types: ISEQ,
    CFUNC, ATTRSET, and IVAR.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们关注最重要和最常用的方法类型：ISEQ、CFUNC、ATTRSET 和 IVAR。
- en: Calling Normal Ruby Methods
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用普通 Ruby 方法
- en: Most methods in your Ruby code are identified by the constant `VM_METHOD_TYPE_ISEQ`
    inside Ruby’s source code. This means that they consist of a sequence of YARV
    instructions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 源代码中，大多数方法通过常量 `VM_METHOD_TYPE_ISEQ` 来标识。这意味着它们由一系列 YARV 指令组成。
- en: You define standard Ruby methods in your code with the `def` keyword, as shown
    here.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你在代码中使用 `def` 关键字定义标准的 Ruby 方法，如下所示。
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`display_message` is a standard method because it’s created using the `def`
    keyword followed by normal Ruby code. [Figure 4-12](ch04.html#normal_method_is_comprised_of_yarv_ins
    "Figure 4-12. A normal method is comprised of YARV instructions.") shows how Ruby
    calls the `display_message` method.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`display_message` 是一个标准方法，因为它是使用 `def` 关键字创建的，后面跟着普通的 Ruby 代码。[图 4-12](ch04.html#normal_method_is_comprised_of_yarv_ins
    "图 4-12. 一个普通方法由 YARV 指令组成.") 展示了 Ruby 如何调用 `display_message` 方法。'
- en: '![A normal method is comprised of YARV instructions.](httpatomoreillycomsourcenostarchimages1854017.png.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![一个普通方法由 YARV 指令组成.](httpatomoreillycomsourcenostarchimages1854017.png.jpg)'
- en: Figure 4-12. A normal method is comprised of YARV instructions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-12. 一个普通方法由 YARV 指令组成。
- en: 'On the left are two snippets of YARV code: the calling code at the bottom and
    the target method at the top. On the right you can see that Ruby created a new
    stack frame using a new `rb_control_frame_t` structure, set to type METHOD.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是两段 YARV 代码：底部是调用代码，顶部是目标方法。右侧可以看到 Ruby 使用新的 `rb_control_frame_t` 结构创建了一个新的堆栈帧，并将其类型设置为
    METHOD。
- en: The key idea in [Figure 4-12](ch04.html#normal_method_is_comprised_of_yarv_ins
    "Figure 4-12. A normal method is comprised of YARV instructions.") is that both
    the calling code and the target method are comprised of YARV instructions. When
    you call a standard method, YARV creates a new stack frame and then starts executing
    the instructions in the target method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-12](ch04.html#normal_method_is_comprised_of_yarv_ins "图 4-12. 一个普通方法由
    YARV 指令组成.") 中的关键概念是，调用代码和目标方法都是由 YARV 指令组成的。当你调用一个标准方法时，YARV 会创建一个新的堆栈帧，然后开始执行目标方法中的指令。'
- en: Preparing Arguments for Normal Ruby Methods
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备普通 Ruby 方法的参数
- en: When Ruby compiles your code, it creates a table of local variables and arguments
    for each method. Each argument listed in the local table is labeled as standard
    (`<Arg>`) or as one of a few different special types, such as block, optional,
    and so on. Ruby records the type of each method’s arguments in this way so it
    can tell whether any additional work is required when your code calls the method.
    [Example 4-5](ch04.html#rubyapostrophes_argument_types_left_pare "Example 4-5. Ruby’s
    argument types (argument_types.rb)") shows a single Ruby method that uses each
    type of argument.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ruby 编译你的代码时，它会为每个方法创建一个局部变量和参数表。局部表中列出的每个参数都会标记为标准的（`<Arg>`）或是几种特殊类型之一，比如块、可选参数等。Ruby
    通过这种方式记录每个方法参数的类型，以便在代码调用该方法时判断是否需要额外的工作。[示例 4-5](ch04.html#rubyapostrophes_argument_types_left_pare
    "示例 4-5. Ruby 的参数类型（argument_types.rb）") 展示了一个使用每种类型参数的 Ruby 方法。
- en: Example 4-5. Ruby’s argument types *(argument_types.rb)*
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-5. Ruby 的参数类型 *(argument_types.rb)*
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 4-6](ch04.html#output_generated_by_listing_4-5 "Example 4-6. The output
    generated by Example 4-5") shows the result when we call the example method with
    the numbers 1 through 6 and a block.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例4-6](ch04.html#output_generated_by_listing_4-5 "示例4-6. 示例4-5生成的输出")显示了我们在调用示例方法时，使用数字1到6和一个块的结果。'
- en: Example 4-6. The output generated by [Example 4-5](ch04.html#rubyapostrophes_argument_types_left_pare
    "Example 4-5. Ruby’s argument types (argument_types.rb)")
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-6。[示例4-5](ch04.html#rubyapostrophes_argument_types_left_pare "示例4-5. Ruby的参数类型（argument_types.rb）")生成的输出。
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To make this behavior possible, YARV does some additional processing on each
    type of argument when you call a method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种行为成为可能，当你调用一个方法时，YARV会对每种类型的参数进行一些额外处理：
- en: '****Block arguments****. When you use the `&` operator in an argument list,
    Ruby needs to convert the provided block into a proc object.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****块参数****。当你在参数列表中使用`&`运算符时，Ruby需要将提供的块转换为一个proc对象。'
- en: '****Optional arguments****. Ruby adds additional code to the target method
    when you use an optional argument with a default value. This code sets the default
    value into the argument. When you later call a method with an optional argument,
    YARV resets the program counter or PC register to skip this added code when a
    value is provided.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****可选参数****。当你使用具有默认值的可选参数时，Ruby会在目标方法中添加额外的代码。这段代码将默认值设置为参数值。当你稍后调用一个带有可选参数的方法时，如果提供了值，YARV会重置程序计数器（PC寄存器），以跳过这段添加的代码。'
- en: '****Splat argument array****. For these, YARV creates a new array object and
    collects the provided argument values into it. (See the array `[3, 4, 5]` in [Example 4-6](ch04.html#output_generated_by_listing_4-5
    "Example 4-6. The output generated by Example 4-5").)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****Splat参数数组****。对于这些，YARV会创建一个新的数组对象，并将提供的参数值收集到其中。（参见[示例4-6](ch04.html#output_generated_by_listing_4-5
    "示例4-6. 示例4-5生成的输出")中的数组`[3, 4, 5]`。）'
- en: '****Standard and post arguments****. Because these are simple values, YARV
    has no additional work to do.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****标准和后续参数****。由于这些是简单的值，YARV不需要做额外的工作。'
- en: 'Then there are keyword arguments. Whenever Ruby calls a method that uses keyword
    arguments, YARV has even more work to do. ([Experiment 4-2: Exploring How Ruby
    Implements Keyword Arguments](ch04.html#experiment_4-2_exploring_how_ruby_implem
    "Experiment 4-2: Exploring How Ruby Implements Keyword Arguments") explores this
    in more detail.)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是关键字参数。每当Ruby调用一个使用关键字参数的方法时，YARV需要做更多的工作。（[实验4-2：探索Ruby如何实现关键字参数](ch04.html#experiment_4-2_exploring_how_ruby_implem
    "实验4-2：探索Ruby如何实现关键字参数")将更详细地探讨这一点。）
- en: Calling Built-In Ruby Methods
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用内置的Ruby方法
- en: Many of the methods built into the Ruby language are CFUNC methods (`VM_METHOD_TYPE_CFUNC`
    in Ruby’s C source code). Ruby implements these using C code rather than Ruby
    code. For example, consider the `Integer#times` method from [Executing a Call
    to a Block](ch03.html#executing_a_call_to_a_block "Executing a Call to a Block").
    The `Integer` class is included in Ruby, and the `times` method is implemented
    by C code in the file *numeric.c*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby语言中许多内置方法是CFUNC方法（在Ruby的C源代码中是`VM_METHOD_TYPE_CFUNC`）。Ruby通过C代码而不是Ruby代码实现这些方法。例如，考虑[执行对块的调用](ch03.html#executing_a_call_to_a_block
    "执行对块的调用")中的`Integer#times`方法。`Integer`类是Ruby的一部分，而`times`方法由*C代码*在文件*numeric.c*中实现。
- en: The classes you use every day have many examples of CFUNC methods, such as `String`,
    `Array`, `Object`, `Kernel`, and so on. For example, the `String#upcase` method
    is implemented by C code in *string.c*, and `Struct#each` is implemented by C
    code in *struct.c*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天使用的类有许多CFUNC方法的示例，如`String`、`Array`、`Object`、`Kernel`等。例如，`String#upcase`方法由*string.c*中的C代码实现，而`Struct#each`方法由*struct.c*中的C代码实现。
- en: When Ruby calls a built-in CFUNC method, it doesn’t need to prepare the method
    arguments in the same way it does with normal ISEQ methods; it simply creates
    a new stack frame and calls the target method, as shown in [Figure 4-13](ch04.html#ruby_implements_cfunc_methods_using_c_co
    "Figure 4-13. Ruby implements CFUNC methods using C code in one of Ruby’s C source
    files.").
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当Ruby调用一个内置的CFUNC方法时，它不需要像处理普通ISEQ方法那样准备方法参数；它只需创建一个新的栈帧并调用目标方法，如[图4-13](ch04.html#ruby_implements_cfunc_methods_using_c_co
    "图4-13. Ruby通过C代码在Ruby的C源文件中实现CFUNC方法")所示。
- en: '![Ruby implements CFUNC methods using C code in one of Ruby’s C source files.](httpatomoreillycomsourcenostarchimages1854019.png.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby通过C代码在Ruby的C源文件中实现CFUNC方法。](httpatomoreillycomsourcenostarchimages1854019.png.jpg)'
- en: Figure 4-13. Ruby implements CFUNC methods using C code in one of Ruby’s C source
    files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-13. Ruby通过C代码在Ruby的C源文件中实现CFUNC方法。
- en: As we saw with ISEQ methods in [Figure 4-12](ch04.html#normal_method_is_comprised_of_yarv_ins
    "Figure 4-12. A normal method is comprised of YARV instructions."), calling a
    CFUNC method involves creating a new stack frame. This time, however, Ruby uses
    a `rb_control_frame_t` structure with type CFUNC instead.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[图 4-12](ch04.html#normal_method_is_comprised_of_yarv_ins "图 4-12. 一个普通方法由YARV指令组成")中看到的，调用CFUNC方法涉及创建一个新的栈帧。然而，这一次，Ruby使用的是`rb_control_frame_t`结构，类型为CFUNC。
- en: Calling attr_reader and attr_writer
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用`attr_reader`和`attr_writer`
- en: Ruby uses two special method types, IVAR and ATTRSET, to speed up the process
    of accessing and setting instance variables in your code. Before I explain what
    these method types mean and how method dispatch works with them, have a look at
    [Example 4-7](ch04.html#ruby_class_with_an_instance_variable_a "Example 4-7. A
    Ruby class with an instance variable and accessor methods"), which retrieves and
    sets the value of an instance variable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby使用两种特殊的方法类型，IVAR和ATTRSET，加速了在代码中访问和设置实例变量的过程。在我解释这些方法类型的含义以及方法分发如何与它们一起工作之前，请先看一下[示例
    4-7](ch04.html#ruby_class_with_an_instance_variable_a "示例 4-7. 一个包含实例变量和访问器方法的Ruby类")，它演示了如何检索和设置实例变量的值。
- en: Example 4-7. A Ruby class with an instance variable and accessor methods
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-7. 一个包含实例变量和访问器方法的Ruby类
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this listing, the class `InstanceVariableTest` contains an instance variable,
    `@var`, and two methods, `var` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and `var=` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). Because
    I wrote these methods using Ruby code, both will be standard Ruby methods with
    the type set to `VM_METHOD_TYPE_ISEQ`. As you can see, they allow you to get or
    set the value of `@var`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，类`InstanceVariableTest`包含一个实例变量`@var`，以及两个方法`var` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    和 `var=` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。由于我使用Ruby代码编写了这些方法，它们都会是标准的Ruby方法，并且类型设置为`VM_METHOD_TYPE_ISEQ`。如你所见，它们允许你获取或设置`@var`的值。
- en: 'Ruby actually provides a shortcut for creating these methods: `attr_reader`
    and `attr_writer`. The following code shows a shorter way of writing the same
    class, using these shortcuts.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby实际上提供了创建这些方法的快捷方式：`attr_reader`和`attr_writer`。以下代码展示了使用这些快捷方式编写相同类的更简洁方式。
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `attr_reader` automatically defines the same `var` method, and `attr_writer`
    automatically defines the `var=` method, both from [Example 4-7](ch04.html#ruby_class_with_an_instance_variable_a
    "Example 4-7. A Ruby class with an instance variable and accessor methods").
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`attr_reader`自动定义了相同的`var`方法，而`attr_writer`自动定义了`var=`方法，二者都来自[示例 4-7](ch04.html#ruby_class_with_an_instance_variable_a
    "示例 4-7. 一个包含实例变量和访问器方法的Ruby类")。
- en: And here’s an even simpler, more concise way of defining the same two methods
    using `attr_accessor`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种更简单、更简洁的方式，通过使用`attr_accessor`定义相同的两个方法。
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, `attr_accessor` is shorthand for calling `attr_reader` and `attr_writer`
    together for the same variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`attr_accessor`是同时调用`attr_reader`和`attr_writer`以处理相同变量的简写方式。
- en: Method Dispatch Optimizes attr_reader and attr_writer
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法分发优化了`attr_reader`和`attr_writer`
- en: Since Ruby developers use `attr_reader` and `attr_writer` so often, YARV uses
    two special method types, IVAR and ATTRSET, to speed up method dispatch and make
    your program run faster.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ruby开发者经常使用`attr_reader`和`attr_writer`，YARV使用两种特殊的方法类型，IVAR和ATTRSET，来加速方法分发并提高程序运行速度。
- en: Let’s begin with the ATTRSET method type. Whenever you define a method using
    `attr_writer` or `attr_accessor`, Ruby marks the generated method with the `VM_METHOD_TYPE_ATTRSET`
    method type internally. When Ruby executes the code and calls the method, it uses
    a C function, `vm_setivar`, to set the instance variable in a fast, optimized
    manner. [Figure 4-14](ch04.html#vmunderscoremethodunderscoretypeundersco "Figure 4-14. VM_METHOD_TYPE_ATTRSET
    methods call vm_setivar directly.") shows how YARV calls the generated `var=`
    method to set `var`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从ATTRSET方法类型开始。每当你使用`attr_writer`或`attr_accessor`定义方法时，Ruby会在内部将生成的方法标记为`VM_METHOD_TYPE_ATTRSET`方法类型。当Ruby执行代码并调用方法时，它会使用C函数`vm_setivar`以快速优化的方式设置实例变量。[图
    4-14](ch04.html#vmunderscoremethodunderscoretypeundersco "图 4-14. `VM_METHOD_TYPE_ATTRSET`方法直接调用`vm_setivar`。")展示了YARV如何调用生成的`var=`方法来设置`var`。
- en: '![VM_METHOD_TYPE_ATTRSET methods call vm_setivar directly.](httpatomoreillycomsourcenostarchimages1854021.png.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![VM_METHOD_TYPE_ATTRSET方法直接调用vm_setivar。](httpatomoreillycomsourcenostarchimages1854021.png.jpg)'
- en: Figure 4-14. `VM_METHOD_TYPE_ATTRSET` methods call `vm_setivar` directly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-14. `VM_METHOD_TYPE_ATTRSET`方法直接调用`vm_setivar`。
- en: Notice that this figure is similar to [Figure 4-13](ch04.html#ruby_implements_cfunc_methods_using_c_co
    "Figure 4-13. Ruby implements CFUNC methods using C code in one of Ruby’s C source
    files."). In both cases, Ruby calls an internal C function when executing our
    code. But notice in [Figure 4-14](ch04.html#vmunderscoremethodunderscoretypeundersco
    "Figure 4-14. VM_METHOD_TYPE_ATTRSET methods call vm_setivar directly.") that
    when executing an ATTRSET method, Ruby doesn’t even create a new stack frame.
    It doesn’t need to because the method is so short and simple. Also, because the
    generated `var=` method will never raise an exception, Ruby doesn’t need a new
    stack frame to display in error messages. The `vm_setivar` C function can very
    quickly set the value and return.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这张图与[图4-13](ch04.html#ruby_implements_cfunc_methods_using_c_co "图4-13. Ruby通过Ruby的C源文件中的C代码实现CFUNC方法")非常相似。在这两种情况下，Ruby在执行代码时都会调用一个内部的C函数。但请注意，在[图4-14](ch04.html#vmunderscoremethodunderscoretypeundersco
    "图4-14. VM_METHOD_TYPE_ATTRSET方法直接调用vm_setivar")中，当执行ATTRSET方法时，Ruby甚至不会创建新的栈帧。因为方法非常简短简单，所以不需要栈帧。而且，由于生成的`var=`方法永远不会抛出异常，Ruby也不需要新的栈帧来显示错误信息。`vm_setivar`
    C函数可以非常快速地设置值并返回。
- en: The IVAR method type works similarly. When you define a method using `attr_reader`
    or `attr_accessor`, Ruby marks the generated method with the `VM_METHOD_TYPE_IVAR`
    method type internally. When it executes IVAR methods, Ruby calls an internal
    C function called `vm_getivar` to get and return the instance variable’s value
    quickly, as shown in [Figure 4-15](ch04.html#vmunderscoremethodunderscoretype-id00013
    "Figure 4-15. VM_METHOD_TYPE_IVAR methods call vm_getivar directly.").
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: IVAR方法类型的工作原理类似。当你使用`attr_reader`或`attr_accessor`定义方法时，Ruby会在内部标记生成的方法为`VM_METHOD_TYPE_IVAR`方法类型。当执行IVAR方法时，Ruby会调用一个名为`vm_getivar`的内部C函数，快速获取并返回实例变量的值，如[图4-15](ch04.html#vmunderscoremethodunderscoretype-id00013
    "图4-15. VM_METHOD_TYPE_IVAR方法直接调用vm_getivar")所示。
- en: '![VM_METHOD_TYPE_IVAR methods call vm_getivar directly.](httpatomoreillycomsourcenostarchimages1854023.png.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![VM_METHOD_TYPE_IVAR方法直接调用vm_getivar。](httpatomoreillycomsourcenostarchimages1854023.png.jpg)'
- en: Figure 4-15. `VM_METHOD_TYPE_IVAR` methods call `vm_getivar` directly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-15. `VM_METHOD_TYPE_IVAR`方法直接调用`vm_getivar`。
- en: Here, the `opt_send_simple` YARV instruction on the left calls the `vm_getivar`
    C function on the right. As in [Figure 4-14](ch04.html#vmunderscoremethodunderscoretypeundersco
    "Figure 4-14. VM_METHOD_TYPE_ATTRSET methods call vm_setivar directly."), when
    calling `vm_setivar`, Ruby doesn’t need to create a new stack frame or execute
    YARV instructions. It simply returns the value of `var` immediately.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，左侧的`opt_send_simple` YARV指令调用右侧的`vm_getivar` C函数。如同在[图4-14](ch04.html#vmunderscoremethodunderscoretypeundersco
    "图4-14. VM_METHOD_TYPE_ATTRSET方法直接调用vm_setivar")中所示，当调用`vm_setivar`时，Ruby不需要创建新的栈帧或执行YARV指令。它只需立即返回`var`的值。
- en: 'Experiment 4-2: Exploring How Ruby Implements Keyword Arguments'
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验4-2：探索Ruby如何实现关键字参数
- en: Beginning with Ruby 2.0, you can specify labels for method arguments. [Example 4-8](ch04.html#simple_example_of_using_keyword_argume
    "Example 4-8. A simple example of using keyword arguments") shows a simple example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ruby 2.0开始，你可以为方法参数指定标签。[示例4-8](ch04.html#simple_example_of_using_keyword_argume
    "示例4-8. 使用关键字参数的简单示例")展示了一个简单的例子。
- en: Example 4-8. A simple example of using keyword arguments
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-8. 使用关键字参数的简单示例
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We use the labels `a` and `b` for the keyword arguments to `add_two` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    When we call the function ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg),
    we get the result 2\. I hinted in [Chapter 2](ch02.html "Chapter 2. Compilation")
    that Ruby uses a hash to implement keyword arguments. Let’s prove this is the
    case using [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i "Example 4-9. Demonstrating
    that Ruby uses a hash to implement keyword arguments").
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`a`和`b`作为传递给`add_two`函数的关键字参数标签 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。当我们调用函数时
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)，得到结果2。我在[第二章](ch02.html
    "第二章. 编译")中提到过，Ruby使用哈希来实现关键字参数。我们可以通过[示例4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "示例4-9. 证明Ruby使用哈希来实现关键字参数")来证明这一点。
- en: Example 4-9. Demonstrating that Ruby uses a hash to implement keyword arguments
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-9. 证明Ruby使用哈希来实现关键字参数
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We override the `key?` method ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    of the `Hash` class, which displays a message ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    and then returns `false`. Here’s the output we get when we run [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "Example 4-9. Demonstrating that Ruby uses a hash to implement keyword arguments").
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了 `Hash` 类的 `key?` 方法 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，该方法会显示一条消息
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)，然后返回 `false`。当我们运行
    [示例 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i "示例 4-9. 演示 Ruby 如何使用哈希来实现关键字参数")
    时，输出结果如下。
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, Ruby is calling `Hash#key?` twice: once to find the key `a`
    and a second time to find the key `b`. For some reason, Ruby has created a hash
    even though we never used a hash in the code. Also, Ruby is now ignoring the values
    we pass into `add_two`. Instead of 2, we get 5\. It looks like Ruby is using the
    default values for `a` and `b`, not the values we provided. Why did Ruby create
    a hash, and what does it contain? And why did Ruby ignore my parameter values
    when I overrode `Hash#key?`?'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Ruby 调用了 `Hash#key?` 两次：第一次查找键 `a`，第二次查找键 `b`。由于某些原因，Ruby 创建了一个哈希，即使我们在代码中从未使用哈希。而且，Ruby
    现在忽略了我们传递给 `add_two` 的值。我们得到的结果是 5 而不是 2。看起来 Ruby 使用了 `a` 和 `b` 的默认值，而不是我们提供的值。为什么
    Ruby 创建了一个哈希，它包含了什么？为什么在重写了 `Hash#key?` 方法后，Ruby 忽略了我的参数值？
- en: To learn how Ruby implements keyword arguments and to explain the results we
    see running [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i "Example 4-9. Demonstrating
    that Ruby uses a hash to implement keyword arguments"), we can examine the YARV
    instructions generated by Ruby’s compiler for `add_two`. Running [Example 4-10](ch04.html#displaying_the_yarv_instructions_for_the
    "Example 4-10. Displaying the YARV instructions for the code in Example 4-9")
    displays the YARV instructions that correspond to [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "Example 4-9. Demonstrating that Ruby uses a hash to implement keyword arguments").
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 Ruby 如何实现关键字参数，并解释我们运行 [示例 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "示例 4-9. 演示 Ruby 如何使用哈希来实现关键字参数") 时看到的结果，我们可以检查 Ruby 编译器为 `add_two` 生成的 YARV 指令。运行
    [示例 4-10](ch04.html#displaying_the_yarv_instructions_for_the "示例 4-10. 显示示例 4-9
    代码的 YARV 指令") 将显示与 [示例 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "示例 4-9. 演示 Ruby 如何使用哈希来实现关键字参数") 对应的 YARV 指令。
- en: Example 4-10. Displaying the YARV instructions for the code in [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "Example 4-9. Demonstrating that Ruby uses a hash to implement keyword arguments")
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-10. 显示 [示例 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i "示例
    4-9. 演示 Ruby 如何使用哈希来实现关键字参数") 代码的 YARV 指令
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figure 4-16](ch04.html#part_of_the_output_generated_by_listing "Figure 4-16. Part
    of the output generated by Example 4-10") shows a simplified version of the output
    generated by [Example 4-10](ch04.html#displaying_the_yarv_instructions_for_the
    "Example 4-10. Displaying the YARV instructions for the code in Example 4-9").'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-16](ch04.html#part_of_the_output_generated_by_listing "图 4-16. 示例 4-10
    生成的部分输出") 显示了 [示例 4-10](ch04.html#displaying_the_yarv_instructions_for_the "示例
    4-10. 显示示例 4-9 代码的 YARV 指令") 生成的输出的简化版本。'
- en: '![Part of the output generated by](httpatomoreillycomsourcenostarchimages1854025.png.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![部分输出，由](httpatomoreillycomsourcenostarchimages1854025.png.jpg)'
- en: Figure 4-16. Part of the output generated by [Example 4-10](ch04.html#displaying_the_yarv_instructions_for_the
    "Example 4-10. Displaying the YARV instructions for the code in Example 4-9")
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-16. [示例 4-10](ch04.html#displaying_the_yarv_instructions_for_the "示例 4-10.
    显示示例 4-9 代码的 YARV 指令") 生成的部分输出
- en: 'On the right of [Figure 4-16](ch04.html#part_of_the_output_generated_by_listing
    "Figure 4-16. Part of the output generated by Example 4-10"), you can see that
    Ruby first pushes an array onto the stack: `[:a, 1, :b, 1]`. Next, it calls the
    internal C function `hash_from_ary`, which we can guess will convert the `[:a,
    1, :b, 1]` array into a hash. Finally, Ruby calls the `add_two` method to add
    the numbers and the `puts` method to display the result.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 4-16](ch04.html#part_of_the_output_generated_by_listing "图 4-16. 示例 4-10
    生成的部分输出") 的右侧，您可以看到 Ruby 首先将一个数组推送到栈中：`[:a, 1, :b, 1]`。接下来，它调用内部的 C 函数 `hash_from_ary`，我们可以推测它会将
    `[:a, 1, :b, 1]` 数组转换为一个哈希。最后，Ruby 调用 `add_two` 方法进行加法运算，并调用 `puts` 方法来显示结果。
- en: Now let’s look at the YARV instructions for the `add_two` method itself, shown
    in [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the "Figure 4-17. The
    YARV instructions compiled from the beginning of the add_two method").
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下 `add_two` 方法本身的 YARV 指令，见于 [图 4-17](ch04.html#yarv_instructions_compiled_from_the
    "图 4-17. 从 add_two 方法开头编译得到的 YARV 指令")。
- en: '![The YARV instructions compiled from the beginning of the add_two method](httpatomoreillycomsourcenostarchimages1854027.png.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![从 add_two 方法开头编译得到的 YARV 指令](httpatomoreillycomsourcenostarchimages1854027.png.jpg)'
- en: Figure 4-17. The YARV instructions compiled from the beginning of the `add_two`
    method
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-17. 从 `add_two` 方法开头编译得到的 YARV 指令
- en: What are these YARV instructions doing? The Ruby method `add_two` didn’t contain
    any code similar to this! (All `add_two` does is add `a` and `b` together and
    return the sum.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 YARV 指令在做什么？Ruby 方法 `add_two` 并没有包含类似的代码！(`add_two` 只是将 `a` 和 `b` 相加并返回它们的和。)
- en: 'To find out, let’s walk through [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the
    "Figure 4-17. The YARV instructions compiled from the beginning of the add_two
    method"). On the left side, we see the Ruby `add_two` method, and on the right,
    the YARV instructions for `add_two`. On the far right, you see the local table
    for `add_two`. Notice that there are three values listed there: `[ 2] ?`, `[ 3]
    b`, and `[ 4] a`. It should be clear that `a` and `b` correspond to the two arguments
    to `add_two`, but what does `[ 2] ?` mean? This appears to be some sort of mystery
    value.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出答案，让我们逐步分析 [图 4-17](ch04.html#yarv_instructions_compiled_from_the "图 4-17.
    从 add_two 方法开头编译得到的 YARV 指令")。左侧是 Ruby 的 `add_two` 方法，右侧是 `add_two` 的 YARV 指令。在最右边，你可以看到
    `add_two` 的局部变量表。注意这里列出了三个值：`[ 2] ?`，`[ 3] b` 和 `[ 4] a`。显然，`a` 和 `b` 对应着 `add_two`
    的两个参数，但 `[ 2] ?` 是什么意思呢？这似乎是某种神秘的值。
- en: The mystery value is the hash we saw created in [Figure 4-16](ch04.html#part_of_the_output_generated_by_listing
    "Figure 4-16. Part of the output generated by Example 4-10")! In order to implement
    keyword arguments, Ruby has created this third, hidden argument to `add_two`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个神秘的值就是我们在 [图 4-16](ch04.html#part_of_the_output_generated_by_listing "图 4-16.
    Example 4-10 生成的部分输出") 中看到的哈希！为了实现关键字参数，Ruby 创建了这个第三个隐藏的参数，用于 `add_two` 方法。
- en: The YARV instructions in [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the
    "Figure 4-17. The YARV instructions compiled from the beginning of the add_two
    method") show that `getlocal 2, 0` followed by `dup` places this hash onto the
    stack as a receiver. Next, `putobject :a` puts the symbol `:a` onto the stack
    as a method parameter, and `opt_send_simple <callinfo!mid:key?` calls the `key?`
    method on the receiver, which is the hash.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-17](ch04.html#yarv_instructions_compiled_from_the "图 4-17. 从 add_two 方法开头编译得到的
    YARV 指令") 中的 YARV 指令显示，`getlocal 2, 0` 紧接着 `dup` 将这个哈希放到栈上作为接收者。接下来，`putobject
    :a` 将符号 `:a` 放到栈上作为方法参数，`opt_send_simple <callinfo!mid:key?` 在接收者（即哈希）上调用 `key?`
    方法。'
- en: These YARV instructions are equivalent to the following line of Ruby code. Ruby
    is querying the hidden hash object to see whether it contains the key `:a`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 YARV 指令等价于以下这行 Ruby 代码。Ruby 正在查询隐藏的哈希对象，看它是否包含键 `:a`。
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Reading the rest of the YARV instructions from [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the
    "Figure 4-17. The YARV instructions compiled from the beginning of the add_two
    method"), we see that if the hash contains the key, Ruby calls the `delete` method,
    which removes the key from the hash and returns the corresponding value. Next,
    `setlocal 4, 0` saves this value into the `a` argument. If the hash didn’t contain
    the key `:a`, Ruby would call `putobject 2` and `setlocal 4, 0` to save the default
    value 2 into the argument.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [图 4-17](ch04.html#yarv_instructions_compiled_from_the "图 4-17. 从 add_two
    方法开头编译得到的 YARV 指令") 继续阅读其余的 YARV 指令，我们看到如果哈希包含该键，Ruby 会调用 `delete` 方法，移除该键并返回对应的值。接着，`setlocal
    4, 0` 会将这个值保存在 `a` 参数中。如果哈希不包含键 `:a`，Ruby 会调用 `putobject 2` 并使用 `setlocal 4, 0`
    将默认值 2 保存到参数中。
- en: To summarize, all of the YARV instructions shown in [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the
    "Figure 4-17. The YARV instructions compiled from the beginning of the add_two
    method") implement the snippet of Ruby code shown in [Example 4-11](ch04.html#yarv_instructions_shown_in_figure_4
    "Example 4-11. The YARV instructions shown in Figure 4-17 are equivalent to this
    Ruby code.").
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，[图4-17](ch04.html#yarv_instructions_compiled_from_the "图4-17. 从add_two方法开始编译的YARV指令")中显示的所有YARV指令实现了[示例4-11](ch04.html#yarv_instructions_shown_in_figure_4
    "示例4-11. 图4-17中的YARV指令与这段Ruby代码等价。")中展示的Ruby代码片段。
- en: Example 4-11. The YARV instructions shown in [Figure 4-17](ch04.html#yarv_instructions_compiled_from_the
    "Figure 4-17. The YARV instructions compiled from the beginning of the add_two
    method") are equivalent to this Ruby code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-11。 在[图4-17](ch04.html#yarv_instructions_compiled_from_the "图4-17. 从add_two方法开始编译的YARV指令")中显示的YARV指令与这段Ruby代码等价。
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we can see that Ruby stores the keyword arguments and their values in the
    hidden hash argument. When the method starts, it first loads each argument’s value
    from the hash or uses the default value if there is none. The behavior indicated
    by the Ruby code in [Figure 4-14](ch04.html#vmunderscoremethodunderscoretypeundersco
    "Figure 4-14. VM_METHOD_TYPE_ATTRSET methods call vm_setivar directly.") explains
    the results we saw when running [Example 4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "Example 4-9. Demonstrating that Ruby uses a hash to implement keyword arguments").
    Remember that we changed the `Hash#key?` method to always return `false`. If `hidden_hash.key?`
    always returns `false`, Ruby will ignore the value of each argument and use the
    default value instead, even if a value was provided.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到，Ruby将关键字参数及其值存储在隐藏的哈希参数中。当方法开始时，它首先从哈希中加载每个参数的值，如果没有值，则使用默认值。[图4-14](ch04.html#vmunderscoremethodunderscoretypeundersco
    "图4-14. VM_METHOD_TYPE_ATTRSET方法直接调用vm_setivar.")中显示的Ruby代码所表示的行为解释了我们在运行[示例4-9](ch04.html#demonstrating_that_ruby_uses_a_hash_to_i
    "示例4-9. 演示Ruby如何使用哈希来实现关键字参数")时看到的结果。记住我们将`Hash#key?`方法修改为始终返回`false`。如果`hidden_hash.key?`始终返回`false`，Ruby将忽略每个参数的值，并使用默认值，即使提供了值。
- en: 'One last detail about keyword arguments: Whenever you call any method and use
    keyword arguments, YARV checks to see whether the keyword arguments you provide
    are expected by the target method. Ruby raises an exception if there is an unexpected
    argument, as shown in [Example 4-12](ch04.html#ruby_throws_an_exception_if_you_pass_an
    "Example 4-12. Ruby throws an exception if you pass an unexpected keyword argument.").'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数的最后一个细节是：每当你调用任何方法并使用关键字参数时，YARV会检查你提供的关键字参数是否是目标方法所期望的。如果有意外的参数，Ruby会抛出异常，如[示例4-12](ch04.html#ruby_throws_an_exception_if_you_pass_an
    "示例4-12. 如果传递了意外的关键字参数，Ruby会抛出异常。")所示。
- en: Example 4-12. Ruby throws an exception if you pass an unexpected keyword argument.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-12。如果传递了一个意外的关键字参数，Ruby会抛出异常。
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because the argument list for `add_two` didn’t include the letter `c`, Ruby
    throws an exception when we try to call the method with `c`. This special check
    happens during the method dispatch process.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`add_two`的参数列表中没有包含字母`c`，所以当我们尝试使用`c`调用该方法时，Ruby会抛出一个异常。这个特殊的检查是在方法调度过程中发生的。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter began with a look at how YARV controls the execution flow of your
    Ruby program using a series of low-level control structures. By displaying the
    YARV instructions produced by Ruby’s compiler, we saw some of YARV’s control structures
    and learned how they work. In [Experiment 4-1: Testing How Ruby Implements for
    Loops Internally](ch04.html#experiment_4-1_testing_how_ruby_implemen "Experiment
    4-1: Testing How Ruby Implements for Loops Internally"), we discovered that Ruby
    implements `for` loops internally using the `each` method with a block.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，我们探讨了YARV如何使用一系列低级控制结构控制Ruby程序的执行流程。通过展示Ruby编译器生成的YARV指令，我们看到了一些YARV的控制结构，并学习了它们的工作原理。在[实验4-1：测试Ruby如何在内部实现for循环](ch04.html#experiment_4-1_testing_how_ruby_implemen
    "实验4-1：测试Ruby如何在内部实现for循环")中，我们发现Ruby通过`each`方法和块来实现`for`循环。
- en: We also learned that internally Ruby categorizes methods into 11 types. We saw
    that Ruby creates a standard ISEQ method when you write a method using the `def`
    keyword and that Ruby labels its own built-in methods as CFUNC methods because
    they are implemented using C code. We learned about the ATTRSET and IVAR method
    types and saw how Ruby switches on the type of the target method during the method
    dispatch process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，Ruby 内部将方法分为 11 种类型。我们看到，当你使用`def`关键字编写方法时，Ruby 会创建一个标准的 ISEQ 方法，而且 Ruby
    将自己内置的方法标记为 CFUNC 方法，因为它们是使用 C 代码实现的。我们了解了 ATTRSET 和 IVAR 方法类型，并看到 Ruby 如何在方法调度过程中根据目标方法的类型进行切换。
- en: 'Finally, in [Experiment 4-2: Exploring How Ruby Implements Keyword Arguments](ch04.html#experiment_4-2_exploring_how_ruby_implem
    "Experiment 4-2: Exploring How Ruby Implements Keyword Arguments"), we looked
    at how Ruby implements keyword arguments, and we discovered along the way that
    Ruby uses a hash to track the argument labels and default values.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[实验 4-2：探索 Ruby 如何实现关键字参数](ch04.html#experiment_4-2_exploring_how_ruby_implem
    "实验 4-2：探索 Ruby 如何实现关键字参数")中，我们研究了 Ruby 如何实现关键字参数，并在过程中发现 Ruby 使用哈希来跟踪参数标签和默认值。
- en: In [Chapter 5](ch05.html "Chapter 5. Objects and Classes") we’ll switch gears
    and explore objects and classes. We’ll return to YARV internals again in [Chapter 6](ch06.html
    "Chapter 6. Method Lookup and Constant Lookup") when we look at how the method
    lookup process works and discuss the concept of lexical scope.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](ch05.html "第 5 章。对象与类")中，我们将转变方向，探讨对象和类的内容。我们将在[第 6 章](ch06.html "第
    6 章。方法查找与常量查找")中再次回到 YARV 内部，研究方法查找过程的工作原理，并讨论词法作用域的概念。
