<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_217"/><strong><span class="big">8</span><br/>TWO BALLISTIC CHRONOGRAPHS</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common-01.jpg"/></div>&#13;
<p class="noindent">This project is a device for measuring the velocity of a projectile. It originally measured the velocity of pellets from air-soft and paintball guns, and it evolved to be capable of measuring projectile velocities from BB and pellet guns before finally measuring velocities of over 3,000 feet per second (fps) from higher-powered weapons. The main intention of this project is not to measure the velocities of traditional fire-arms, but this project does have that capability, and the end of this chapter describes how to use it to measure the velocity of a 9 mm bullet.</p>&#13;
<p class="indent">The Ballistic Chronograph was meant to be simple, but it turned out a little more complex than originally planned. The result is two projects: the Full Ballistic Chronograph and a more diminutive and simpler device I call the Chronograph Lite (see <a href="ch08.xhtml#ch08fig8-1">Figure 8-1</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_1.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-1"><em>Figure 8-1: The Chronograph Lite with a projectile-acceleration channel attached to a 0.177 caliber pellet gun</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_218"/>I’ve attempted to make each Ballistic Chronograph system both flexible and accurate. The flexibility comes from separating the sensor elements from the readout and permitting different types of sensors to measure different devices—and producing different readouts with the same acceleration channel.</p>&#13;
<p class="indent">In this project, you will use some components not too frequently encountered in Arduino projects, such as a crystal oscillator to provide precise timing (outside of the crystal oscillator used in the Nano), infrared LEDs, phototransistors, logic gates, a 12-stage digital counter, and a digital-to-analog converter (DAC) to help perform the counting function.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>A WORD OF WARNING</strong></p>&#13;
<p class="noindent">With deference to Jean Shepherd’s <em>A Christmas Story</em> (in which everyone warns Ralphie, “You’re going to shoot your eye out!”), remember that any firearm is inherently dangerous, and many air-powered weapons can fire at lethal force. Whether you test an air-powered device or a weapon using high-powered bullets, use extreme caution. The Full Ballistic Chronograph and the Lite version were developed, tested, and made primarily for lower-powered weapons using CO<sub>2</sub> and air power to accelerate projectiles. Though the device is capable of measuring bullets from traditional firearms, such as the 9 mm pistol mentioned earlier, it was not developed or tested for that application. I strongly recommend that you not attempt to use the device you build in this chapter in such applications.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev1sec1"><span epub:type="pagebreak" id="page_219"/><strong>What Is a Ballistic Chronograph?</strong></h3>&#13;
<p class="noindent">A device for measuring the velocity of a high-speed projectile exiting a firearm is generally known as a <em>ballistic chronograph</em>. The term <em>chronograph</em> was co-opted from the horological community and is now widely used to describe instruments for measuring the speed of bullets, arrows, darts, and so on.</p>&#13;
<p class="indent">This chapter proposes two versions of the Ballistic Chronograph: one offering the ability to accurately measure very high-speed projectiles and a Lite version offering a little less precision but a far simpler implementation. Though I refer to the simpler build as the “Lite” version, it is by no means unsophisticated.</p>&#13;
<h4 class="h4" id="ch08lev2sec1"><em><strong>Commercial Chronographs</strong></em></h4>&#13;
<p class="noindent">There are several commercially available chronographs, most of which are intended for high-powered pistols and rifles. Chronographs are usually placed on the ground or a table in front of the shooter. Most of the popular commercial devices depend on ambient sunlight for operation and, therefore, don’t work indoors or on overcast days. And while they are modestly priced, they are not really cheap.</p>&#13;
<p class="indent">Chronographs vary from simple two-wire devices (still in use and believed by some to be the most accurate) to relatively elaborate units with digital memory, average velocity calculations, and other features. The two-wire approach simply uses two thin strands of wire (36- or 40-gauge wire will do) stretched between two pairs of contacts accurately spaced apart. The projectile is shot and breaks the first wire to start a timer, and then, if you have good aim, breaks the second wire to stop the timer. The time between breakages is calculated to provide a speed value in feet or meters per second. The very early chronographs were built with a clock, which had readouts of ones and zeros displayed in a bank of LEDs. The binary number had to be translated to a decimal number and then calculated with the distance between the wires to get the velocity.</p>&#13;
<h4 class="h4" id="ch08lev2sec2"><em><strong>Measuring Muzzle Velocity</strong></em></h4>&#13;
<p class="noindent">Now that you know what types of prebuilt chronographs are out there, let’s take a look at the physics of the device. A projectile leaving the muzzle of a weapon has a velocity imparted to it by some propellant, such as air, CO<sub>2</sub>, or the gas created by the rapid oxidation of the fuel in gunpowder. The projectile travels down the barrel and exits the muzzle. The speed of the projectile as it exits is called <em>muzzle velocity</em>.</p>&#13;
<p class="indent">The muzzle velocity of air-powered guns tends to vary depending on several factors, including the charge of the propellant, cleanliness of the barrel, and projectile-to-barrel matchup. Some air rifles can be pumped to almost 3,000 psi (pounds per square inch) to fire larger projectiles at relatively significant velocities. These larger air guns have relatively low muzzle velocities in the sub-1,000 fps range, but they pack a real punch. Compared <span epub:type="pagebreak" id="page_220"/>to conventional air rifles, which shoot 0.177-inch pellets that pack between 15 and 25 ft-lbs (foot-pounds) of power, these larger-bore rifles offer between 500 and 700 ft-lbs of power.</p>&#13;
<p class="indent">Ideally, you would want to measure the velocity as close to the end of the barrel as possible. However, this can be difficult, and some chronograph makers claim that the velocity is not attenuated much in the first several feet (or even yards) of travel. On the other hand, there is little doubt that air resistance is a significant factor, and the projectile will slow at least somewhat in the first few feet—especially in the case of larger projectiles.</p>&#13;
<h4 class="h4" id="ch08lev2sec3"><em><strong>This Project’s Approach</strong></em></h4>&#13;
<p class="noindent">As in the two-wire ballistic chronograph systems, we’re trying to measure the time it takes for a projectile to travel a fixed distance. But instead of breaking thin wires, this project takes advantage of an infrared light source and light-sensitive receiver, as illustrated in <a href="ch08.xhtml#ch08fig8-2">Figure 8-2</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_2.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-2"><em>Figure 8-2: The basic principle in measuring the speed of the projectile is to have it break a beam of light to start a clock and then break another beam of light to stop the clock</em>.</p>&#13;
<p class="indent">Two pairs of LEDs and IR sensors are arranged so that the IR sensor normally detects the light source. But when the projectile breaks the light beam of the first pair, the sensor goes dark and changes its electrical state. The processor senses this change and starts a timer. When the projectile interrupts a second source/receiver pair, the timer stops. The two sets of light sources and receivers are set an accurate distance apart so the time of travel can be relatively easily calculated into projectile speed.</p>&#13;
<p class="indent">For a simple example, say the beams of light are set a foot apart. A projectile interrupts a beam of light and starts the clock; when the projectile interrupts the second beam of light, the clock stops. If the microcontroller’s timer measured 1 second, the velocity would be 1 foot in 1 second, or 1 fps.</p>&#13;
<p class="indent">This system can be used with a variety of projectiles and provide a digital readout on an LCD. Unlike other approaches, this device separates out the sensor bank from the electronics such that, if desired, different sensors can be swapped in and out for different firearms or even different applications. For instance, you could set up a sensor channel and do some basic physics experiments by dropping small objects through it and recording their velocity.</p>&#13;
<h3 class="h3" id="ch08lev1sec2"><span epub:type="pagebreak" id="page_221"/><strong>The Chronograph Lite</strong></h3>&#13;
<p class="noindent">First, we’ll take a look at the Chronograph Lite, which is simple to construct and has only a handful of parts.</p>&#13;
<h4 class="h4" id="ch08lev2sec4"><em><strong>Required Tools</strong></em></h4>&#13;
<p class="noindenti">Soldering iron and solder</p>&#13;
<p class="noindenti">Drill and drill bits (1/2, 1/4, and 1/8 inches)</p>&#13;
<p class="noindenti">Philips head and slotted screwdrivers</p>&#13;
<p class="noindenti">Saw (keyhole or saber saw)</p>&#13;
<h4 class="h4" id="ch08lev2sec5"><em><strong>Parts List</strong></em></h4>&#13;
<p class="noindenti">One Arduino Pro Mini or clone</p>&#13;
<p class="noindenti">Two IR LEDs, about 650–850 nm Two IR photosensors (I used the Honeywell Optoschmitt SA5600.)</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>Some users have had trouble matching the IR LEDs with the Optoschmitt photosensors. If you run into this problem, try the Honeywell SE3450/5450 or equivalent. Another option is to use two Adafruit IR Break Beams (part #2167) instead of the separate LEDs and sensors. The IR Break Beams will work for the Chronograph Lite, but the output must be inverted for the full version.)</em></p>&#13;
</div>&#13;
<p class="noindenti">One 270-ohm, 1/8 W resistor (Optional) Two 10-kilohm, 1/8 W resistors (if using phototransistors rather than Optoschmitt photosensors)</p>&#13;
<p class="noindenti">One channel holding two LED/sensor pairs One 16×2 LCD</p>&#13;
<p class="noindenti">One I<sup>2</sup>C adapter, if not included with the LCD One x4 adapter housing (see “<a href="ch00.xhtml#ch00lev1sec6">Connectors Used in This Book</a>” on <a href="ch00.xhtml#page_18">page 18</a>)</p>&#13;
<p class="noindenti">Four female pins for housing (see “<a href="ch00.xhtml#ch00lev1sec6">Connectors Used in This Book</a>” on <a href="ch00.xhtml#page_18">page 18</a>)</p>&#13;
<p class="noindenti">One SPST switch One momentary NO switch</p>&#13;
<p class="noindenti">One 9V battery connector</p>&#13;
<p class="noindenti">One 9V battery</p>&#13;
<p class="noindenti">One Hammond 1591 BTCL enclosure or equivalent</p>&#13;
<p class="noindenti">Two 7 1/2 × 1 1/2 × 0.06–inch aluminum pieces</p>&#13;
<p class="noindenti">One 1 3/8 × 7 1/2–inch piece of 1 3/8-inch acrylic sheet</p>&#13;
<p class="noindenti">Two #10-24×1-inch nylon screws</p>&#13;
<p class="noindenti">Two #10×24 nylon nuts</p>&#13;
<p class="noindenti"><span epub:type="pagebreak" id="page_222"/>Four 4-40×1/2-inch screws</p>&#13;
<p class="noindenti">Eight 4-40 nuts</p>&#13;
<p class="noindenti">Four 4-40 washers</p>&#13;
<p class="noindenti">Assorted 28-gauge hookup wire</p>&#13;
<h4 class="h4" id="ch08lev2sec6"><em><strong>Downloads</strong></em></h4>&#13;
<p class="indenth"><strong>Sketch</strong> <em>ChronographLite.ino</em></p>&#13;
<p class="indenth"><strong>Templates</strong> <em>PanelCutoutLite.pdf, PanelCutout.pdf, AccelerationChannel.pdf</em></p>&#13;
<h4 class="h4" id="ch08lev2sec7"><em><strong>The Schematic</strong></em></h4>&#13;
<p class="noindent">Outside the Arduino board, the circuitry for this project is not very complex. The schematic in <a href="ch08.xhtml#ch08fig8-3">Figure 8-3</a> uses the I<sup>2</sup>C bus to power the LCD, two connections for the photosensors, and two connections for the clear switch.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_3.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-3"><em>Figure 8-3: The schematic of the Chronograph Lite. The primary schematic shows the phototransistors and the alternate section shows the Honeywell Optoschmitt sensors (bottom left)</em>.</p>&#13;
<h4 class="h4" id="ch08lev2sec8"><em><strong>Building a Test Bed</strong></em></h4>&#13;
<p class="noindent"><a href="ch08.xhtml#ch08fig8-4">Figure 8-4</a> shows the test bed that was used to prove the concept and develop the sketch. I suggest you build your own and install your LEDs and photosensors into it before building the breadboard.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_223"/>For this test bed, I cut two pieces of cardboard approximately 2×6 inches and punched them to fit two pairs of IR LEDs and phototransistors that were spaced 3 inches apart. I then screwed the cardboard to a 1-inch-thick piece of wood, though you could glue or staple it if you prefer. When you build yours, be sure that each phototransistor is directly opposite an IR LED in the channel.</p>&#13;
<p class="indentb">After installing the IR LEDs and phototransistors into the test bed, I recommend preparing them for the breadboard as follows:</p>&#13;
<ol>&#13;
<li><p class="order">Connect the two IR LED anodes with a piece of wire by soldering or wire-wrapping.</p></li>&#13;
<li><p class="order">Solder one 24-inch length of wire to the combined LED anodes. If you’re using solid-core wire that fits in a breadboard, you can just strip the other end of the 24-inch wire. If you’re using stranded-core wire, attach a male crimp pin to the end of the wire.</p></li>&#13;
<li><p class="order">Connect the two IR LED cathodes with a piece of wire by soldering or wire-wrapping.</p></li>&#13;
<li><p class="order">Connect the two phototransistor emitters with a wire by soldering or wire-wrapping.</p></li>&#13;
<li><p class="order">Connect the combined IR LED cathodes to the combined phototransistor emitters; I suggest soldering a long wire.</p></li>&#13;
<li><p class="order">Solder a 24-inch length of wire to the combined LED cathodes and phototransistor emitters, and finish the other end of the wire with a male crimp pin, as you did in step 2.</p></li>&#13;
<li><p class="order">Solder a 24-inch length of wire to each phototransistor’s collector, and finish the other end of the wire with a male crimp pin, as you did in step 2.</p></li>&#13;
</ol>&#13;
<p class="indent">In <a href="ch08.xhtml#ch08fig8-4">Figure 8-4</a>, the LEDs and light sensors (these will be phototransistors or Honeywell Optoschmitt sensors depending on your choice) are placed in holes punched in the cardboard of the acceleration channel.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_4.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-4"><em>Figure 8-4: The test bed I initially used to check out the chronograph concept</em></p>&#13;
<p class="indent">I used a relatively small hole punch so that friction would hold them in <span epub:type="pagebreak" id="page_224"/>place. You could instead glue them with hot glue or contact cement. I used a 24-inch length of four-conductor telephone wire to connect the channel to the breadboard, but any wire will do. In the completed version and in other prototypes, I just used four lengths of 30-gauge twisted wire because it was more flexible. Alternatively, you could build the final sensor channel now.</p>&#13;
<p class="indent">The LEDs and phototransistors will need to be wired to the Arduino, as indicated in the schematic diagram in <a href="ch08.xhtml#ch08fig8-3">Figure 8-3</a>. I wired the LED anodes to the power supply through a 270-ohm resistor (R3). In the case of the phototransistors, I set them up so that the emitters were grounded and each collector went through a 10-kilohm resistor (R1 and R2) to the positive of the power supply for an open-collector configuration. Thus, if the beam of light were interrupted, the phototransistor would conduct, and the voltage at the collector would drop.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack"><strong>NOTE</strong></span></strong></p>&#13;
<p class="notep"><em>If you use the Honeywell Optoschmitt SA5600/5610, the 10-kilohm resistors (R1 and R2) are not required, as they are included in the SA5600/5610 chip. The wiring of the Optoschmitt sensors is shown in the lower left of the schematic in <a href="ch08.xhtml#ch08fig8-3">Figure 8-3</a></em>.</p>&#13;
</div>&#13;
<p class="indent">Rather than shooting up the office with live paintballs, BBs, or pellets, I set up the gig vertically so a projectile could be dropped through the light beams to test the system. This method meant that the velocities measured didn’t approach those of a projectile leaving a weapon’s barrel, but it was good enough for an initial proof-of-concept experiment. The higher the target was dropped from, the higher the recorded velocity—that is, if your aim is good. (Remember <em>s</em> = (1/2)<em>at</em><sup>2</sup>, where <em>s</em> is displacement or distance, <em>a</em> is acceleration due to gravity, <em>t</em> is time, and initial velocity is zero.)</p>&#13;
<p class="indent">If ambient light causes problems in testing, an additional piece of cardboard can be taped to the top (side) of the two pieces of cardboard to shade the sensor, though I didn’t find this was a problem in any of the experiments I conducted.</p>&#13;
<h4 class="h4" id="ch08lev2sec9"><em><strong>The Breadboard</strong></em></h4>&#13;
<p class="noindent">The next step is to build a breadboard, as shown in <a href="ch08.xhtml#ch08fig8-5">Figure 8-5</a>. For this, we’ll use the Chronograph Lite schematic in <a href="ch08.xhtml#ch08fig8-3">Figure 8-3</a>. The most complicated part of the circuit is wiring up the photosensors and LEDs, which are not plugged directly into the breadboard but rather need to be installed in the sensor channel, as described in the previous section.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_5.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-5"><em>Figure 8-5: Photosensors and LEDs in the early prototype attached to the breadboard via discrete wires. To test the unit, a coin was dropped through the channel</em>.</p>&#13;
<p class="indent">Whether you have already made the finished channel or are using the cardboard prototype, you will need to connect the sensors and LEDs in the channel to the breadboard—or, for that matter, to the completed unit—with four wires: positive, ground, first sensor, and second sensor.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_225"/>Here’s how to wire the breadboard:</p>&#13;
<ol>&#13;
<li><p class="order">Connect the red positive rails together and the blue negative rails together. Do not connect the red positive rail and blue negative rail to each other under any circumstances—it will result in a short circuit and damage to components.</p></li>&#13;
<li><p class="order">Insert the Arduino Pro Mini or clone in the breadboard, leaving a fair amount of room—about four or five rows—at one end.</p></li>&#13;
<li><p class="order"><span epub:type="pagebreak" id="page_226"/>Connect the VCC pin on the Mini to the red positive rail.</p></li>&#13;
<li><p class="order">Connect the GND pin on the Mini to the blue negative rail.</p></li>&#13;
<li><p class="order">Take two 10-kilohm resistors (R1 and R2) and connect one end of each to the red positive rail. (Note that these are not required if you are using the Optoschmitt SA5600 photosensor.)</p></li>&#13;
<li><p class="order">Connect the other end of resistor R1 to pin D4 on the Mini via a jumper wire.</p></li>&#13;
<li><p class="order">Connect the other end of resistor R2 to pin D2 on the Mini via a jumper wire. (If you use the Optoschmitt photosensor, you can connect pins D2 and D4 directly to the output pins on the photosensors, as shown in the bottom left of <a href="ch08.xhtml#ch08fig8-3">Figure 8-3</a>.)</p></li>&#13;
<li><p class="order">Connect the collector pin of phototransistor Q1 to pin D2 on the Nano using the attached 24-inch wire.</p></li>&#13;
<li><p class="order">Connect the collector pin of phototransistor Q2 to pin D4 on the Nano using the attached 24-inch wire.</p></li>&#13;
<li><p class="order1">Connect one end of the 270-ohm resistor R3 to the red positive rail.</p></li>&#13;
<li><p class="order1">Connect the other end of resistor R3 through one of the 24-inch lengths of wire to an empty row on the breadboard.</p></li>&#13;
<li><p class="order1">Connect the combined anodes of LED 1 and LED 2 to the row where you connected resistor R3 in step 9 via the attached 24-inch wire. Refer to <a href="ch08.xhtml#ch08fig8-3">Figure 8-3</a> to see how the LEDs are wired together and to the breadboard.</p></li>&#13;
<li><p class="order1">Connect the 5V pin and the GND pin on the Mini to VCC and GND on the LCD, respectively.</p></li>&#13;
<li><p class="order1">Connect pin A4 on the Mini to the SDA connection on the LCD.</p></li>&#13;
<li><p class="order1">Connect pin A5 on the Mini to the SCL connection on the LCD.</p></li>&#13;
</ol>&#13;
<p class="indent">Now you’re ready to enter the sketch.</p>&#13;
<h4 class="h4" id="ch08lev2sec10"><em><strong>The Sketch</strong></em></h4>&#13;
<p class="noindent">Now to write the sketch to make things work. Here is the sketch for the Chronograph Lite:</p>&#13;
<p class="programs"><br/>     //Lite version of chronograph, using Optoschmitt sensors<br/>     <br/>     #include &lt;Wire.h&gt;<br/>     #include &lt;LiquidCrystal_I2C.h&gt;<br/>     <br/>     unsigned long start_time = 0;<br/>     unsigned long stop_time = 0;<br/>     unsigned long time_of_flight = 0;<br/>     float velocity = 0;<br/>     LiquidCrystal_I2C lcd(0x3F, 20, 4);<br/>     <span epub:type="pagebreak" id="page_227"/><br/>     void setup() {<br/>       Serial.begin(9600);<br/>       pinMode(2, INPUT);<br/>       pinMode(4, INPUT);<br/>       lcd.init();<br/>       lcd.backlight();<br/>     }<br/>     void loop() {<br/><br/><span class="ent">➊</span>   while(digitalRead(2) == 1) {<br/>         //Waiting for first sensor to trip<br/>     }<br/><br/><span class="ent">➋</span>   start_time = micros();<br/><br/><span class="ent">➌</span>   while(digitalRead(4) == 1) {<br/>     }<br/><br/><span class="ent">➍</span>   stop_time = micros();<br/><br/><span class="ent">➎</span>   time_of_flight = stop_time - start_time;<br/><br/>     Serial.print(" time of flight        ");<br/>     Serial.println(time_of_flight);<br/><br/>     velocity = 1000000*.25/(time_of_flight);<br/><br/><br/>     lcd.clear();<br/>     lcd.print("tm of flt  ");<br/>     lcd.print(time_of_flight);<br/>     lcd.print(" us");<br/>     lcd.setCursor(0, 2);<br/>     lcd.print("Speed FPS    ");<br/>     lcd.print(velocity);<br/>  }<br/></p>&#13;
<p class="indent">The sketch is pretty straightforward. After setting up the variables and inputs, a <span class="literal">while</span> loop waits for the first sensor to be interrupted by checking the condition <span class="literal">digitalRead(2) == 1</span> <span class="ent">➊</span>. When tripped, the clock is started with <span class="literal">start_time = micros();</span> <span class="ent">➋</span>, and another <span class="literal">while</span> loop counts until the second sensor is activated (because the second sensor is plugged into pin D4, this <span class="literal">while</span> loop checks whether <span class="literal">digitalRead(4) == 1</span> <span class="ent">➌</span>). When the second sensor is activated, the clock is stopped with <span class="literal">stop_time = micros()</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">The sketch then calculates the time that lapsed between the first sensor and the second with <span class="literal">time_of_flight = stop_time – start_time</span> at <span class="ent">➎</span>. Once the sketch makes its calculations, it provides instructions to display the results on the LCD screen.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_228"/>All you need to do now is load the sketch, stand the test channel up as in <a href="ch08.xhtml#ch08fig8-4">Figure 8-4</a>, and drop a projectile like a marble through the cardboard channel. To begin, power the Mini with the programmer. Alternatively, you can use a separate regulated 5V power supply connected to the 5V terminal on the Mini, or you can connect a battery to the VIN port of the Mini and use the Mini’s on-board regulator. Do <em>not</em> connect a 9V battery to the 5V supply rails—it could burn everything out.</p>&#13;
<p class="indent">When you’re satisfied that the sensors are working, you can attach your temporary sensor channel to a real air pistol if you’d like to test the circuit further (see <a href="ch08.xhtml#ch08fig8-6">Figure 8-6</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_6.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-6"><em>Figure 8-6: Photoelectric sensors in an early prototype, attached to a Crossman 0.177 caliber air pistol. The setup was obviously primitive, using a C-clamp to hold the channel to the weapon. Because the test channel was so simple, I set it up on my desk</em>.</p>&#13;
<p class="indent">If this is enough for your needs, you can package this up and skip everything in “<a href="ch08.xhtml#ch08lev1sec3">The Full Ballistic Chronograph</a>” on <a href="ch08.xhtml#page_233">page 233</a>. The Chronograph Lite should work well for games and low- and medium-velocity weapons (less than 600 fps), such as pellet guns, BB guns, airsoft weapons, and so on.</p>&#13;
<p class="indent">Despite satisfactory performance, however, I was bothered by the fact that, while the Arduino can count microseconds, it can deliver results only as multiples of four, so in reality the resolution is only 4 microseconds. That is why I developed the Full Ballistic Chronograph project. If this bothers you, too, and you don’t plan to package up the Chronograph Lite, you can skip to “<a href="ch08.xhtml#ch08lev1sec3">The Full Ballistic Chronograph</a>” on <a href="ch08.xhtml#page_233">page 233</a> now.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><span epub:type="pagebreak" id="page_229"/><strong>TESTING THE CHRONOGR APH LITE WITH A PROJECTILE SIMUL ATOR</strong></p>&#13;
<p class="noindent">To test the Chronograph Lite or Full Ballistic Chronograph for errors, I made a simulator to simulate the effect of a projectile traveling through the two sensors rather than shooting up my work area with pellets or paintballs. I primarily used the simulator in development—it is not necessary for the completion or use of either chronograph in this chapter—but it provides some insight into how to turn on and off relatively high-speed signals.</p>&#13;
<p class="indent">I used a square-wave generator (see <a href="ch09.xhtml#ch09">Chapter 9</a> if you want to create your own) and made a very simple breadboard simulator. The schematic of the simulator, shown in <a href="ch08.xhtml#ch08fig8-7">Figure 8-7</a>, includes only the turn-on and turn-off functions and is driven by the square-wave generator.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_7.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-7"><em>Figure 8-7: Schematic of the simulator used to simulate the sequential firing of the Optoschmitt sensors. It is used in conjunction with a square-wave generator. Resistor R1 and capacitor C1 can be adjusted for satisfactory debounce, but the values shown worked well. (continued)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_230"/>The simulator receives a clock signal from the square-wave generator. On initiation, depressing the switch (labeled SW in <a href="ch08.xhtml#ch08fig8-7">Figure 8-7</a>) on the simulator begins the sequence of start and stop signals from the CD4017 decade counter. A manual switch (SW) fires the simulator after a debounce from a NE 555 timer. The function of the simulator is to turn the connections to the photosensors on and off just as if a projectile were traveling through the start and stop LED/photosensor pair. <a href="ch08.xhtml#ch08fig8-8">Figure 8-8</a> shows a breadboard for the simulator with the finished board and square-wave generator.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_8.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-8"><em>Figure 8-8: The simulator breadboard and the square-wave generator hooked up to the finished prototype board for the Full Ballistic Chronograph. The simulator works equally well with either the Chronograph Lite or the Full Ballistic Chronograph</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec11"><em><strong>Construction</strong></em></h4>&#13;
<p class="noindent">To complete the Chronograph Lite project, all you have left to do is to package the Mini, display, battery, and appropriate switches in an enclosure, leaving a connector exposed to connect the unit to the sensor channel. Unlike most of the other projects in this book, I did not use a shield for the Chronograph Lite, because the wiring to the Mini was sufficiently</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_231"/>straightforward that it did not require one. I used a Hammond ABS plastic enclosure 1591 BTCL, as indicated in the parts list. See <a href="ch08.xhtml#ch08fig8-9">Figure 8-9</a> for the completed Chronograph Lite.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_9.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-9"><em>Figure 8-9: Front view of completed Chronograph Lite. A hole is cut into the enclosure to the right of the screen to allow space for the backlight protrusion</em>.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08fig8-10">Figure 8-10</a> shows the template for the enclosure. You can download a PDF of this drawing from <em><a href="https://www.nostarch.com/arduinoplayground/">https://www.nostarch.com/arduinoplayground/</a></em> and use it to mark and center punch the enclosure for the holes.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_10.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-10"><em>Figure 8-10: Template for holes and display for the Chronograph Lite</em></p>&#13;
<p class="indentb"><span epub:type="pagebreak" id="page_232"/>I prepared the enclosure for the Chronograph Lite as follows:</p>&#13;
<ol>&#13;
<li><p class="order">Carefully mark, center punch, and drill 1/2-inch holes for the corners of the display (A), 1/8-inch holes for the mounting holes for the display (B), 1/4-inch holes for the on/off switch (C), and 1/4-inch holes for the clear switch (D).</p></li>&#13;
<li><p class="order">For the LCD screen, mark the edges of the 1/2-inch holes (A). Draw lines connecting the edges so you have a rectangle to cut out. (You can use a Sharpie marker and clean excess markings later with alcohol.) Drill the holes and cut the opening along those lines using a keyhole or saber saw.</p></li>&#13;
<li><p class="order">There’s a slight protrusion in the middle of the LCD on the right-hand side (facing up); this is part of the backlight assembly. You can cut a hole to accommodate for this, as I did in <a href="ch08.xhtml#ch08fig8-10">Figure 8-10</a>, or you can leave the edge straight and use spacers to keep the protrusion from hitting the enclosure.</p></li>&#13;
<li><p class="order">Mount the display and fasten it in with 1/2-inch-long 4-40 mounting screws and nuts. If you made a cut out for the LCD backlight protrusion, you can mount the display directly. If you did not, use extra 4-40 nuts to space the display back from the face of the enclosure. If needed, add additional washers; 4-40 nuts can vary in thickness.</p></li>&#13;
<li><p class="order">Mount the <em>on</em> and <em>clr</em> switches as indicated in <a href="ch08.xhtml#ch08fig8-9">Figure 8-9</a>.</p></li>&#13;
</ol>&#13;
<p class="indent">Now to wire up the Pro Mini. There is no shield, so we will solder directly to the Pro Mini board as follows:</p>&#13;
<ol>&#13;
<li><p class="order">Solder the wires for the I<sup>2</sup>C connection. To make your life easier, use colored wire and create a code for yourself. Solder connections to the 5V (some clone boards may say VCC) and GND pins on the Nano. Then, solder 3-inch wires to pins A4 and A5 on the Nano. Connect the other end of these wires to a four-pin female connector. (See “<a href="ch00.xhtml#ch00lev1sec6">Connectors Used in This Book</a>” on <a href="ch00.xhtml#page_18">page 18</a> for details on making Pololu connectors.) Connect the 5V and GND pins on the Nano to 5V and GND on the LCD. Connect pin A4 on the Nano to SDA on the I<sup>2</sup>C board, and A5 on the Nano to SDL on the I<sup>2</sup>C.</p></li>&#13;
<li><p class="order">Connect the positive (red) wire of the battery connector to one side of the SPST switch. Connect the other side of the switch to the VIN terminal on the Nano (some clone boards may say RAW).</p></li>&#13;
<li><p class="order">Solder the black (negative) wire from the battery connector to the GND pin on the Nano.</p>&#13;
<p class="indenti">Finally, connect the Nano to the sensor channel as follows:</p></li>&#13;
</ol>&#13;
<ol>&#13;
<li><p class="order">Prepare a four-conductor female Pololu connector with four color-coded wires approximately 3.5 inches long. Attach two wires (I suggest red and black) from this connector to the VCC and GND pins on the Nano.</p></li>&#13;
<li><p class="order"><span epub:type="pagebreak" id="page_233"/>Connect the remaining two connectors to pins 2 (D2) and 4 (D4) on the Nano.</p></li>&#13;
<li><p class="order">Make a slot or hole in the side of the enclosure, and run the Pololu connector with the sensor channel connections through it (see <a href="ch08.xhtml#ch08fig8-11">Figure 8-11</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_11.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-11"><em>Figure 8-11: A slot in the enclosure for threading the four-pin sensor channel connector through. The connector is mounted with double-sided adhesive</em></p></li>&#13;
<li><p class="order">Connect one side of the <em>clr</em> pushbutton to GND and the other side to the RST (reset) pin on the Nano.</p></li>&#13;
<li><p class="order">Finally, connect the battery, screw on the top of the enclosure, plug in the sensor channel, and flip the switch to turn on the device.</p></li>&#13;
</ol>&#13;
<p class="indent">You should be all set to use your Chronograph Lite. Go to “<a href="ch08.xhtml#ch08lev1sec5">Final Setup and Operation</a>” on <a href="ch08.xhtml#page_252">page 252</a> for instructions on using the Chronograph Lite.</p>&#13;
<h3 class="h3" id="ch08lev1sec3"><strong>The Full Ballistic Chronograph</strong></h3>&#13;
<p class="noindent">While the Chronograph Lite worked well and I used it to successfully measure projectile speeds, I had a nagging feeling that it could be better. If you’re using the device for slow-speed projectiles—that is, 600 fps or less—the accuracy of the Chronograph Lite is more than enough. But the restriction to 4 microseconds of resolution resulted in what I perceived to be a fair amount of error in feet-per-second (fps) at higher speeds, so I decided to construct the Full Ballistic Chronograph.</p>&#13;
<h4 class="h4" id="ch08lev2sec12"><em><strong>Required Tools</strong></em></h4>&#13;
<p class="noindenti"><span epub:type="pagebreak" id="page_234"/>Soldering iron and solder</p>&#13;
<p class="noindenti">Drill and drill bits (1/2, 1/4, and 1/8 inches) Philips head and slotted screwdrivers Saw (keyhole or saber saw)</p>&#13;
<h4 class="h4" id="ch08lev2sec13"><em><strong>Parts List</strong></em></h4>&#13;
<p class="noindenti">Assembling the Full Ballistic Chronograph is relatively simple. Here’s what you’ll need:</p>&#13;
<p class="noindenti">One Arduino Nano or clone</p>&#13;
<p class="noindenti">One 16×4 LCD</p>&#13;
<p class="noindenti">One I<sup>2</sup>C adapter, if not included with the LCD One PCB shield</p>&#13;
<p class="noindenti">One enclosure (Hammond 1591 BTCL)</p>&#13;
<p class="noindenti">Four 1/2-inch×4-40 screws Four 4-40 nuts</p>&#13;
<p class="noindenti">One 3PDT toggle switch</p>&#13;
<p class="noindenti">Two momentary pushbutton switches Four 0.100×4 female headers</p>&#13;
<p class="noindenti">Four female X4 shells</p>&#13;
<p class="noindenti">Sixteen (eight male, eight female) adapter pins One 4 MHz crystal</p>&#13;
<p class="noindenti">One TI SN 74LVC1GX04 crystal-oscillator driver One SOT23 adapter board</p>&#13;
<p class="noindenti">One HCT 4011 4-input NAND gate One CD4013 dual D flip-flop</p>&#13;
<p class="noindenti">One CD4040 12-stage binary counter One ADC DAC8562 digital-to-analog converter One LM7805 voltage regulator</p>&#13;
<p class="noindenti">One NPN transistor 2N5172 (or equivalent) Four 5-kilohm, 1/8 W resistors</p>&#13;
<p class="noindenti">One 1-megaohm, 1/8 W resistor</p>&#13;
<p class="noindenti">One 1-kilohm, 1/8 W resistor</p>&#13;
<p class="noindenti">One 1.5-kilohm, 1/8 W resistor</p>&#13;
<p class="noindenti">One 270-kilohm, 1/8 W resistor</p>&#13;
<p class="noindenti">One 4.7 MFD tantalum capacitor Two 33 pF capacitors</p>&#13;
<p class="noindenti"><span epub:type="pagebreak" id="page_235"/>One 0.01 μF capacitor</p>&#13;
<p class="noindenti">One 5 mm LED</p>&#13;
<p class="noindenti">Two IR detectors (I used the Honeywell Optoschmitt SD5610.) Two IR LEDS, about 850–950 nm 28- or 30-gauge hookup wire</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>For the Full Ballistic Chronograph, you will have to use the inverted version of the chip, the SA5610, or externally invert the signals. See the note at the bottom of <a href="ch08.xhtml#ch08fig8-3">Figure 8-3</a></em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec14"><em><strong>Downloads</strong></em></h4>&#13;
<p class="indenth"><strong>Sketch</strong> <em>FullBallisticChronograph.ino</em></p>&#13;
<p class="indenth"><strong>Templates</strong> <em>ChronoCover.pdf, AccelerationChannel.pdf</em></p>&#13;
<p class="indenth"><strong>PCBs</strong> <em>ChronoPCB.pcb, LEDHolder.pcb, SensorHolder.pcb</em></p>&#13;
<h4 class="h4" id="ch08lev2sec15"><em><strong>Improving the Accuracy</strong></em></h4>&#13;
<p class="noindent">There are several possible solutions for improving the accuracy of the chronograph. The Arduino Nano uses a 16 MHz clock, yet when configured using the Arduino Nano platform and IDE, it results in a 1 microsecond resolution (±2 microseconds), even though the period—the time between cycles—of a 16 MHz clock is 1/16,000,000 of a second, or 0.063 micro seconds. While a processor could never resolve down to its own clock speed, it’s probably capable of much better than 1 microsecond. Clearly there is some overhead in the current project—perhaps part hardware (the components in the Arduino board) and part software (the compiler and firmware part of the IDE)—that limits performance. Here are some ideas I had to improve accuracy, starting with one that didn’t make it into the final project but that I think is educational.</p>&#13;
<h5 class="h5"><strong>Digging into Machine Code</strong></h5>&#13;
<p class="noindent">One possible solution is to dig into the basic Atmel machine and AVR code. Without going into excruciating detail, AVR assembly is the functional language of the Atmel chip. The Arduino community has surrounded that with special code that lets the AVR run in the Arduino environment.</p>&#13;
<p class="indent">According to the ATmega328 data sheets, it’s possible to directly address the individual timers on the ATmega328 and get the resolution required. However, looking into it, I saw that this method could prove overly complex and figured there had to be another way.</p>&#13;
<h5 class="h5"><strong>Creating a High-Speed Window</strong></h5>&#13;
<p class="noindent">The time of flight of a projectile that we want to look at covers a range of roughly 90 microseconds (about 3,000 fps in a 3-inch distance) to <span epub:type="pagebreak" id="page_236"/>950 microseconds (about 260 fps in the same 3-inch distance) from fastest to slowest. Relative to the higher frequencies of some clocks, such as the 16 MHz clock of the processor, 90 microseconds is a fair amount of time.</p>&#13;
<p class="indent">One method for measuring the velocity is to open a timing window when the first beam of light is interrupted that lets a stream of high-speed signal through until the second beam is interrupted. While the window is open, the pulses in that signal will be counted; when the window is closed, the count will represent the time the window was open.</p>&#13;
<p class="indent">As an example, say the window opens and a signal of 10 cycles per second (cps) passes through until the window closes; 100 cycles are counted. For this illustration, the Arduino’s clock is the high-speed signal. When you know the distance the projectile traveled, you can use some simple arithmetic to determine the time of travel and the speed: 100 cycles at 10 cps gives us 10 seconds. If the distance were 1 meter and 100 cycles were counted while the window was open, the speed would be 1 meter per 10 seconds or 0.1 m/s.</p>&#13;
<p class="indent">A single NAND logic gate can be used to make a window that can be opened and closed. A <em>logic gate</em> is simply an electronically controlled switch that outputs a voltage only under certain conditions, corresponding to a Boolean logic equation. <em>NAND</em> is the Boolean expression for “not AND,” and a <em>NAND gate</em> outputs a voltage when its two inputs are not the same.</p>&#13;
<p class="indent">I sampled both a 74HC00 high-speed NAND gate and a standard CD4011BC gate, and the standard part works fine. There are several other parts that will work, too—what you’re looking for is a part with a propagation delay (T<sub>PD</sub>) under 100 nanoseconds.</p>&#13;
<h5 class="h5"><strong>Selecting a Counter</strong></h5>&#13;
<p class="noindent">After deciding to take the window approach, the next thing to consider is how high you need to count. If you were to count in integers from 1 to 100, for example, you would need a counter that could count to 100, which would provide a resolution of 100. If you scaled that up, the counter could provide a range from 10 to 1,000 or from 100 to 10,000. If that range were the result of the calculation for fps, you would then have a resolution of only 1,000 fps (each increment would equal 100 fps) plus any included error, which we’ll go into later.</p>&#13;
<p class="indent">So where should you go from here? To the parts bin, of course, to see what counters are available to count the signal passing through that window. When selecting a counter, you need to consider how fast it needs to be and how many pulses you want it to count. The tried-and-true CD4040, 12-bit, serial-in, parallel-out, digital counter seemed capable of doing the job. (The CD4040 worked at the 4 MHz frequency, but you could always use a faster one, like the 74HC4040 or 74HCT4040.) The CD4040 will provide a digital count from 0 to 4095, or 2<sup>12</sup>.</p>&#13;
<h5 class="h5"><strong>Selecting a Clock Speed</strong></h5>&#13;
<p class="noindent">Next, consider what signal frequency is needed in order to suit the range of projectile speeds. I started with the assumption that I wanted to achieve a</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_237"/>range of roughly 300 fps to 2,500 fps with as much latitude on both ends as possible.</p>&#13;
<p class="indent">Further, while the counter will ideally count from zero to the maximum 4,095 counts, there is the possibility of some error. So rather arbitrarily, I chose to look at the total digital count between 400 and 4,000 to account for the possibility of error.</p>&#13;
<p class="indent">Given the number of cycles counted, the signal frequency, and the distance traveled, the velocity of a projectile can be found with the following calculations:</p>&#13;
<div class="imageo"><img alt="image" src="../images/f0237-01.jpg"/></div>&#13;
<p class="indent">Let’s go through the arithmetic for a projectile that travels 0.25 feet (3 inches) within 4,000 cycles of a 2 MHz signal:</p>&#13;
<div class="imageo"><img alt="image" src="../images/f0237-02.jpg"/></div>&#13;
<p class="indent">For a 4 MHz clock, a full 4,000 cycle count will amount to about 281 fps for the low end of the speed range. At the high end, given 400 cycles counted and a 2 MHz clock signal, you will measure 1,250 fps, and at 4 MHz, you can measure up to 2,500 fps.</p>&#13;
<p class="indent">You can be creative with your frequency. If you elect to use a 2 MHz clock, it will provide maximum resolution in the very low-speed range. If, on the other hand, you select a 4 MHz clock, you will be in the middle of the resolution range. An 8 MHz clock will provide a very good resolution in the fast range (faster than any conventional weapon) but will curtail performance at the lower-speed range.</p>&#13;
<p class="indent">Because I anticipated that the bulk of speeds I needed to measure would fall in the middle of the counting range, a clock around 4 MHz sounded good. I was not anticipating many occasions when velocities would be in the sub-300 fps range, and at the high end, it looked like accuracy could be maintained to well over 5,000 fps (a digital count of <span epub:type="pagebreak" id="page_238"/>just under 200, which might be stretching it a little but seemed to work well in simulations).</p>&#13;
<p class="indent">If your projectiles remain in the sub-300 fps range, I suggest revisiting the Chronograph Lite. If, for some reason, you want to stay in the lower fps range but require maximum accuracy with perhaps multiple digits, build the Full Ballistic Chronograph with the slower clock rate. You can simply swap out the 4 MHz crystal for a 2 MHz crystal and adjust the sketch to slide the range down to the lower area.</p>&#13;
<h5 class="h5"><strong>Adjusting the Clock Speed</strong></h5>&#13;
<p class="noindent">To address the speed of the clock (the signal that is gated to the counter), the most accurate method by far is to use a crystal-controlled oscillator, which generally has errors only in the sub-50 parts per million range. I configured a 4 MHz crystal with the TI SN 74LVC1GX04 crystal-oscillator driver experimentally and it worked well, so I used one in the final project.</p>&#13;
<p class="indent">While I did look at, review, and test single-chip oscillators, such as the Maximum stand-alone oscillator (7375), it was not quite as stable as the crystal-controlled version.</p>&#13;
<h4 class="h4" id="ch08lev2sec16"><em><strong>Designing the Full Ballistic Chronograph</strong></em></h4>&#13;
<p class="noindent">Now, we have the means to clock the signal into the 4040 counter, but we need to figure out how to display the velocity on the LCD. One method would be to use a different counter with a serial output that would be clocked directly into the Nano. Another possibility would be to take the parallel data from the CD4040, serialize it with a shift register, and feed the result to the Nano.</p>&#13;
<p class="indent">However, I took a different direction, as illustrated in the block diagram in <a href="ch08.xhtml#ch08fig8-12">Figure 8-12</a>. I decided to use a 12-bit digital-to-analog converter (DAC) to accept the parallel digital signals and convert them to a single analog value. DACs and their counterpart, analog-to-digital converters (ADCs), are used in digital music, TVs, and a host of other areas where an analog input needs to be digitized, manipulated, transferred, stored, and eventually output to return an analog signal. I thought this would be a good opportunity to introduce the capabilities of digital-to-analog converters.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_12.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-12"><em>Figure 8-12: Block diagram of the Full Ballistic Chronograph</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_239"/>The process in <a href="ch08.xhtml#ch08fig8-12">Figure 8-12</a> depicts the operation of the chronograph using a simulator. In actual operation, the simulator would be replaced with the two LED-sensor pairs. The simulator, under control of the firing switch, initiates a start signal that remains active until the second stop switch is activated after a period determined by the square-wave generator. This essentially simulates the projectile passing through the first and then the second pair of sensors.</p>&#13;
<p class="indent">When the start switch is activated initially, it turns on the <em>flip-flop</em>—a bistate device that turns on with the activation of the start switch and remains on until the stop switch is activated. The flip-flop feeds the trigger of the gate. When the trigger (T) is inactive—that is, when it’s set to a logical 0—the signal from the oscillator at input (A) cannot go through the gate to output (B). When the trigger is activated (set to a logical 1), the gate allows the signal from the oscillator (A) to travel through the gate to output (B) and eventually to the input of the binary counter. The binary counter counts the number of pulses that pass from the oscillator through the gate and stops counting when the gate closes.</p>&#13;
<p class="indent">The outputs of the binary counter are fed to the DAC. They represent binary numbers from 0 through 4,095—that is, 0 through 2<sup>12</sup> – 1. The DAC converts these digital values to a single analog value. The technique of this conversion depends on the type of DAC used; for example, in the DAC8562 used here, an R-2R resistor ladder is switched, and a transistor is used to yield the output. (For complete information, look up the data sheet from Analog Devices on the DAC8562.)</p>&#13;
<p class="indent">The output of the DAC has a scale of 0V to 4.095V corresponding to the digital inputs. This output is then directed to one of the analog inputs on the Arduino Nano, which provides the inverse function of the DAC and converts the analog signal back into a digital format that the Nano can handle. The Nano takes that signal and, following instruction from the sketch, adjusts the value to represent the velocity in fps for the time it takes the projectile to travel the 3 inches. The Nano finally sends that data to the LCD, which displays the velocity of the projectile and travel time.</p>&#13;
<h4 class="h4" id="ch08lev2sec17"><em><strong>The Schematic</strong></em></h4>&#13;
<p class="noindent">Figures 8-13 and 8-14 show the schematic diagrams for the completed Full Ballistic Chronograph. Note the extra gates at the bottom. I included these in the schematic because they are available to you in the NAND gate and flip-flop IC packages suggested for this project, but my design does not use them. If you want to add functionality, they are available.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_13.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-13"><em>Figure 8-13: Schematic of the Full Ballistic Chronograph</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_240"/>Another thing included in the schematic that we haven’t covered is the reset button. In the Full Ballistic Chronograph, I included a button to trigger the reset rather than having it reset automatically. I could have set it so that the result was displayed on the LCD for a fixed period of time before the system reset, but it might have turned out that the number was erased before users had time to record it, or users may have found themselves sitting idle while it timed out. I decided a reset button would be more convenient.</p>&#13;
<p class="indent">Because resetting the microcontroller wasn’t going to upset the sequence of things, I chose to use a hard reset on the controller through transistor Q1. To reset the CD4040 and the DAC, I used the reset signal and then inverted it using one of the CD4011’s four NAND gates with the two inputs tied together. SW2 manually closes the second set of sensors in case the first pair of sensors fires and not the second, and SW3 is the power and battery switch.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_241"/><img alt="image" src="../images/fig8_14.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-14"><em>Figure 8-14: Inverters for Optoschmitt or Adafruit sensors if you use the SA5600 instead of the SA5610. This circuit uses the previously unused gates of the CD4011 NAND gate as logic inverters. They are not accommodated for in the PCB, so you will have to wire them by hand</em>.</p>&#13;
<h4 class="h4" id="ch08lev2sec18"><em><strong>The Sketch</strong></em></h4>&#13;
<p class="noindent">The sketch for the Full Ballistic Chronograph is relatively straightforward:</p>&#13;
<p class="programs"><br/>      //Full Ballistic Chronograph <br/>      <br/>      #include &lt;Wire.h&gt;<br/>      #include &lt;LiquidCrystal_I2C.h&gt; <br/>      LiquidCrystal_I2C lcd(0x27, 16, 2); <br/>      int DACpin = A0; <br/>      float DACvalue = 0; <br/>      float FPS; <br/>      float Time; <br/>      <br/>      void setup() {<br/>        lcd.init();<br/>        lcd.backlight();<br/>      }<br/><br/><span epub:type="pagebreak" id="page_242"/><br/>   void loop() {<br/><span class="ent">➊</span>   DACvalue = analogRead(DACpin);<br/>      Time = DACvalue*5/1023/4*1000;<br/>      FPS = .25/Time*1000000;<br/>      lcd.setCursor(0,0);<br/>      lcd.print("Speed  ");<br/>      lcd.print(FPS,0);<br/>      lcd.setCursor(11,0);<br/>      lcd.setCursor(0,1);<br/>      lcd.print("Time  ");<br/>      lcd.print(Time); <br/><br/>      lcd.setCursor(11,1);  <br/>      lcd.print(char(0XE4)); //To display the mu symbol, use 228 or 0XE4<br/>      lcd.print("s");<br/>  }</p>&#13;
<p class="indent">In this sketch, the software receives an analog signal from the DAC at X and converts it to a digital value. It then goes through a couple of quick mathematical operations to come up with the time of flight (<span class="literal">Time</span>), calculates the speed in feet per second (<span class="literal">FPS</span>), and finally exports those values to the LCD.</p>&#13;
<p class="indent">In designing electronic circuits, there are always tradeoffs between hardware and software. Many of these have to do with timing issues and built-in latencies in software-based approaches. In this instance, the tradeoff is the need for greater accuracy not available with the straight Arduino IDE approach without dropping to some level of native code. To avoid native code, the Full Ballistic Chronograph has more complex hardware than the Chronograph Lite.</p>&#13;
<h4 class="h4" id="ch08lev2sec19"><em><strong>The Shield</strong></em></h4>&#13;
<p class="noindent">Unlike the Chronograph Lite, the Full Ballistic Chronograph is best built on a shield. The shield is a little more involved than some of the others in this book, but don’t be intimidated. <a href="ch08.xhtml#ch08fig8-15">Figure 8-15</a> shows the actual traces of the shield, while <a href="ch08.xhtml#ch08fig8-16">Figure 8-16</a> shows the silkscreen image with the part placements and hole configuration. For this project, I opted for a double-sided board because the circuit was a little more complex than some of the others and because it allowed me to minimize the space required. The complete PCB file is available for download at <em><a href="https://www.nostarch.com/arduinoplayground/">https://www.nostarch.com/arduinoplayground/</a></em>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_243"/><img alt="image" src="../images/fig8_15.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-15"><em>Figure 8-15: Trace patterns for the shield. The darker gray is the upper copper layer, and lighter gray is the lower layer</em>.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_16.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-16"><em>Figure 8-16: The component placement on the shield</em></p>&#13;
<p class="indent">I attempted to keep the shield footprint to a minimum to make it possible for the user to squeeze the system into a small portable enclosure. As is, the finished Full Ballistic Chronograph fits easily in a 11×8×4 cm box.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_244"/>This is another case where I opted to outsource the PCB construction after I had made and refined the first sample myself and made sure all critical connections could be soldered on both sides of the board. <a href="ch08.xhtml#ch08fig8-17">Figure 8-17</a> shows the raw board as it was received from the service bureau.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_17.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-17"><em>Figure 8-17: The Full Ballistic Chronograph circuit board before population</em></p>&#13;
<h4 class="h4" id="ch08lev2sec20"><em><strong>Soldering the Full Ballistic Chronograph</strong></em></h4>&#13;
<p class="noindentb">Once you have all your parts, follow this guide to build the Full Ballistic Chronograph:</p>&#13;
<ol>&#13;
<li><p class="order">Prepare the oscillator adapter board by soldering the headers in place. Solder the chip to the adapter using one of the approaches suggested in “<a href="ch00.xhtml#ch00lev1sec7">Using SOICs</a>” on <a href="ch00.xhtml#page_20">page 20</a>.</p></li>&#13;
<li><p class="order">Begin populating the PCB. I usually like to start with the components that go under the Nano—in this case, the oscillator adapter board, resistors, crystal, and CD4011. Place them in the PCB, as indicated in <a href="ch08.xhtml#ch08fig8-15">Figure 8-15</a>. Next, I like to include the headers that the Nano plugs into. Once again, it’s not necessary to fully populate all the headers for the Nano. While on occasion I do use a full complement of headers, I tend to populate only those with connections, as well as a pair at the very top, in order to simplify alignment when plugging in the Nano. Additionally, there should be enough to mechanically support the Nano. Solder these headers in place now.</p></li>&#13;
<li><p class="order"><span epub:type="pagebreak" id="page_245"/>Populate the balance of the board, including the headers for the I<sup>2</sup>C display and the sensor channel. Solder wire pigtails to the connections on the board for the reset and clear switches, LED, and positive and negative power supply. The lead sensor—the one that is interrupted by the projectile first—should be the one wired to pin 6 of the 4013, with or without the inverter circuit; the other sensor should be connected to pin 4.</p></li>&#13;
</ol>&#13;
<h4 class="h4" id="ch08lev2sec21"><em><strong>Construction</strong></em></h4>&#13;
<p class="noindent"><a href="ch08.xhtml#ch08fig8-18">Figure 8-18</a> shows the positions for the holes and cutout in the enclosure. You can download a copy of <a href="ch08.xhtml#ch08fig8-18">Figure 8-18</a> from <em><a href="https://www.nostarch.com/arduinoplayground/">https://www.nostarch.com/arduinoplayground/</a></em> and use it as a template.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_18.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-18"><em>Figure 8-18: The holes and LCD cutout on the cover of the enclosure</em></p>&#13;
<p class="indentb">Prepare the enclosure for the Full Ballistic Chronograph as follows:</p>&#13;
<ol>&#13;
<li><p class="order">Prepare the cover of the enclosure, as shown in <a href="ch08.xhtml#ch08fig8-18">Figure 8-18</a>, by drilling 1/2-inch holes for cutting out the LCD (A); 1/8-inch holes for mounting the LCD (B); 1/8-inch holes enlarged with a reamer for a tight fit for the 5 mm LED (F); and 1/4-inch holes for the momentary clear switch (D), momentary reset switch (E), and on/off switch (C).</p></li>&#13;
<li><p class="order">Mark the edges of the 1/2-inch holes (A) and connect lines tangent to the holes—you can use a Sharpie marker and clean excess marks later with alcohol.</p></li>&#13;
<li><p class="order">Cut the opening for the display using a keyhole or saber saw.</p></li>&#13;
<li><p class="order">There’s a <span epub:type="pagebreak" id="page_246"/>slight protrusion in the middle of the LCD on the right-hand side (facing up). This is part of the backlight assembly. You can cut a hole to accommodate this, as I did on both the Full Ballistic Chronograph and Chronograph Lite, or you can leave the edge straight and use spacers to keep the protrusion from hitting the enclosure. Even though I cut a space for the protrusion, I used a one-nut spacer anyway to space the connections on the top of the screen away from the front of the enclosure (see <a href="ch08.xhtml#ch08fig8-19">Figure 8-19</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_19.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-19"><em>Figure 8-19: The four-conductor female connector is mounted to the side of the enclosure using double-sided adhesive</em>.</p></li>&#13;
<li><p class="order">Mount the LCD’s I<sup>2</sup>C assembly to the front of the enclosure.</p></li>&#13;
<li><p class="order">Mount the switches to the enclosure. Connect the switches and LED as shown in the schematic in <a href="ch08.xhtml#ch08fig8-13">Figure 8-13</a>. Use pigtailed wires as indicated in step 3 of “<a href="ch08.xhtml#ch08lev2sec20">Soldering the Full Ballistic Chronograph</a>” on <a href="ch08.xhtml#page_244">page 244</a>.</p></li>&#13;
<li><p class="order">Prepare cable assemblies to connect the shield to the I<sup>2</sup>C adapter and the 4-pin female connector that connects the Full Ballistic Chronograph to the sensor channel. (See “<a href="ch00.xhtml#ch00lev1sec6">Connectors Used in This Book</a>” on <a href="ch00.xhtml#page_18">page 18</a> if you’ve never built a connector yourself.)</p></li>&#13;
<li><p class="order">Stick the shield to the bottom of the enclosure using double-sided adhesive.</p></li>&#13;
<li><p class="order">Mount the battery holder using a 4-40 flathead screw or double-sided adhesive.</p></li>&#13;
<li><p class="order1"><span epub:type="pagebreak" id="page_247"/>Make a cut in the side of the enclosure to feed the wires through to the connector for the sensor channel connection. The width of a single hacksaw blade is sufficient for 28-gauge wire.</p></li>&#13;
<li><p class="order1">Mount the connector for the sensor channel to the enclosure with double-sided adhesive, as shown in <a href="ch08.xhtml#ch08fig8-19">Figure 8-19</a>.</p></li>&#13;
</ol>&#13;
<h3 class="h3" id="ch08lev1sec4"><strong>The Sensor Channel</strong></h3>&#13;
<p class="noindent">We built a sensor channel test bed earlier in the chapter, but now we’ll build a more permanent sensor channel and look at the sensor and LED pair we’ll use inside.</p>&#13;
<h4 class="h4" id="ch08lev2sec22"><em><strong>Building the Sensor Channel</strong></em></h4>&#13;
<p class="noindent">The sensor channel is a U-shaped tunnel that fastens to the muzzle of a weapon and holds the photo detector/LED pairs that handle the switching. This channel can be constructed out of a variety of materials. I used a 3/8-inch section of acrylic and two pieces of 0.060-inch thick aluminum (see <a href="ch08.xhtml#ch08fig8-20">Figure 8-20</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_20.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-20"><em>Figure 8-20: The completed sensor channel shown from the top (right side up). Note the feed-through holes in the acrylic for the positive and negative power supply connections to the LEDs (boxed). Also note the current-limiting resistor on the PCB holding the LEDs (circled). The cross-hatch area is foam taped to protect the weapon’s slide from being scratched</em>.</p>&#13;
<p class="indent">You could just as easily use mild sheet steel for the side pieces. The top piece, shown in <a href="ch08.xhtml#ch08fig8-20">Figure 8-20</a>, could be any lightweight material, such as phenolic, Lexan, or another plastic to support the side pieces. I chose clear acrylic because it allowed me to see the gun without having to look down the barrel. You can get a wider look at the whole channel, including the sensor cable, in <a href="ch08.xhtml#ch08fig8-21">Figure 8-21</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_21.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-21"><em>Figure 8-21: The channel with the cable attached and the PCB mounted so that the connector faces toward the back (where the weapon attaches)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_248"/>There are two PCBs, attached to either side of the channel with double-sided tape, to hold the LEDs and photosensors. These PCBs are slightly different from each other, as shown in <a href="ch08.xhtml#ch08fig8-22">Figures 8-22</a> and <a href="ch08.xhtml#ch08fig8-23">8-23</a>. PCB files for these boards are available to download at <em><a href="https://www.nostarch.com/arduinoplayground/">https://www.nostarch.com/arduinoplayground/</a></em>.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_22.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-22"><em>Figure 8-22: The pattern for the PCB that holds the LEDs and mounts to the sensor channel. Note the current-limiting resistor</em>.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_23.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-23"><em>Figure 8-23: The PCB pattern for the phototransistor side of the sensor channel. Note the three pins for each phototransistor. The edge fingers are for soldering to headers that connect to the main processing and display board via an umbilical cable</em>.</p>&#13;
<p class="indent">The acrylic top of the sensor channel measured 1 3/8 × 7 5/8 inches. I used a straight wooden dowel to line the barrel up with the sensors/LEDs. Note that there is a slight indentation, made with a 1/2-inch drill bit, in the top of the acrylic to allow for the optical sight of the Crossman T4 air pistol.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_249"/>The aluminum sheets used for the sides measured 1 3/8 × 7 5/8 inches. I drilled the holes to fasten the aluminum sides to the acrylic top with a #30 drill bit and spaced the holes 1 inch apart. The acrylic was drilled with a #43 drill bit and tapped for 4-40 screws. See <a href="ch08.xhtml#ch08fig8-24">Figure 8-24</a> for drilling specifications for both the acrylic and aluminum pieces. The holes for the acrylic are drilled through the width.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_24.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-24"><em>Figure 8-24: Dimensions for holes in the acrylic top and aluminum sides of the sensor channel. This template can be downloaded and used as a stencil for marking and center-punching holes</em>.</p>&#13;
<p class="indent">In addition, as a feed-through for the wires from the LED side to the photo detector side, I drilled two #43 holes on either side of the fourth mounting holes on both the acrylic and aluminum pieces. The exact location of these holes is not critical.</p>&#13;
<p class="indent">In addition to the holes for fastening the acrylic, the aluminum required two holes on each side for the LEDs and photo detector pairs, and another two holes on one side for mounting to the barrel (slide) of the gun (A and B in <a href="ch08.xhtml#ch08fig8-24">Figure 8-24</a>), drilled with a #25 drill and tapped for a 10-24 screw. Check out how big the IR LEDs are. Most are 5 mm, and a 3/16-inch hole is generally a close fit. The Optoschmitt sensor also fits snugly in a 3/16-inch hole. The holes for the LEDs and photosensors can be measured exactly 3 inches apart, or you can measure them yourself to match with the PCBs mounted on the side.</p>&#13;
<p class="indent">Depending on the weapon(s) you intend to use, you may want to adjust the positioning of holes A and B in <a href="ch08.xhtml#ch08fig8-24">Figure 8-24</a>. The sensor channel can also accommodate more tapped holes for multiple weapons. To mount the sensor channel to the top of the gun, I used nylon screws with locking nuts. The nylon screws were able to tighten against the blued-steel finish of the pistol without marring it.</p>&#13;
<p class="indent">The screws for mounting the gun worked well with the Crossman T4 as well as on an older Crossman pellet gun (see <a href="ch08.xhtml#ch08fig8-25">Figure 8-25</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_25.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-25"><em>Figure 8-25: The sensor channel mounted on an older Crossman pellet gun. This angle shows the top (acrylic) side of the channel</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_250"/>On the inside of the channel, I placed some double-sided adhesive foam tape (if you can find a single-sided adhesive foam tape, all the better) to give it a more snug fit and protect the weapon from damage. I left the protective covering on the other side of the foam so it would not adhere to the weapon or mar the finish.</p>&#13;
<p class="indent">Depending on the weapon you are using, you might want to add an extra layer of foam to pad the channel so the center of the barrel is closer to the center of the channel. But as long as the barrel is not so far on either side that the projectile could strike either the LED or photo detector, centering the barrel perfectly is not critical.</p>&#13;
<p class="indent">It is critical, however, to center the vertical adjustment so the LED/detector pairs line up with the trajectory of the projectile. To set this alignment, I used a straight wooden dowel of the same diameter as the bore of the barrel, inserted it partially into the barrel of the weapon, and then adjusted the position so it lined up with the LED/detector pairs. Once it’s aligned, tighten the nylon screws to secure the channel to the weapon.</p>&#13;
<h4 class="h4" id="ch08lev2sec23"><em><strong>Optoschmitt Light Sensors and UV LEDs</strong></em></h4>&#13;
<p class="noindent">In preparing the sensor channel, I sampled several different types of LEDs and detectors to see which offered the best price and performance. Units purchased on eBay (UV LED and phototransistor pairs) worked well, and I used them in early prototype versions. However, I continued to search for a sensor that I was sure would be fast enough and provide good sensitivity in a narrow field, which helps to exclude ambient light. After reviewing several samples, I chose the Optoschmitt SD5610 detector from Honeywell—so named, I guess, because it includes Schmitt-trigger circuitry (see <a href="ch08.xhtml#ch08fig8-26">Figure 8-26</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_26.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-26"><em>Figure 8-26: Schematic for the Optoschmitt SD5610 detector I used in the chronograph. Note that the 10-kilohm pull-up resistor is included, but the inverter function is not included in the schematic</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_251"/>The Optoschmitt SD5610 sensor is a little pricey, but it features a 6-degree acceptance angle, which worked well for projectiles of all sizes, including very small and large ones. It also reduced the effects of ambient light.</p>&#13;
<p class="indent">According to the manufacturer, the photodetector consists of a photodiode, amplifier, voltage regulator, Schmitt trigger, and an NPN output transistor with a 10-kilohm (nominal) pull-up resistor (see <a href="ch08.xhtml#ch08fig8-26">Figure 8-26</a>). The internal pull-up resistor eliminates the need for an external resistor in the circuit. Note that there are two versions of this device: the SD5600 and the SD5610. The SD5610 includes an inverter so that the output is low when the ambient light is above the turn-on threshold. Because I required the inverted output, I used the SD5610. The spectral sensitivity is greatest in the 800 to 850 nm wavelength—the area of most common IR LEDs. Additional information on the SD5600 series can be obtained at Honeywell’s website.</p>&#13;
<p class="indent">For the LEDs, I just used regular IR LEDs that claimed output in the 850–950 nm range. I simply bought a bag of 50 units on eBay, and they work fine. Alternatively, SparkFun offers single units very cheaply.</p>&#13;
<p class="indent">The LEDs and photosensors should be soldered on the PCBs made for them and should fit snuggly into the holes. I fastened the PCB to the sides of the acceleration channel using some standard 3M double-sided adhesive tape.</p>&#13;
<h4 class="h4" id="ch08lev2sec24"><em><strong>Sensor Umbilical Cable</strong></em></h4>&#13;
<p class="noindent">The cable I used to connect the sensor channel to the Full Ballistic Chronograph’s PCB is made from four lengths of 30-gauge wire twisted together, fastened with masking tape, and connected to a female <span epub:type="pagebreak" id="page_252"/>four-conductor Pololu connector at each end. These connectors are not polarized and do not have a detent, so they can be relatively easily unplugged or plugged in the other way. Before you plug them in, make sure to line up the color-coded wire.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>I initially attempted to use a length of four-conductor telephone cable, but it was too stiff and caused problems</em>.</p>&#13;
</div>&#13;
<p class="indent">The channel and completed chronograph can be connected easily. If you used colored wire, you’ll know that the plug is connected correctly because it is not polarized.</p>&#13;
<h3 class="h3" id="ch08lev1sec5"><strong>Final Setup and Operation</strong></h3>&#13;
<p class="noindent">Once you’ve finished assembling the unit and sensor channel, it’s time to take it out on the range and give it a try. Both the Chronograph Lite and the Full Ballistic Chronograph have been designed to operate from battery power, so you don’t need to plug them in. Set up the umbilical cable to connect the sensor channel to the chronograph unit, and then mount the channel to the weapon securely (see <a href="ch08.xhtml#ch08fig8-27">Figure 8-27</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_27.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-27"><em>Figure 8-27: The completed Full Ballistic Chronograph with the acceleration channel mounted to a Crossman 0.177 caliber pellet gun</em></p>&#13;
<p class="indent">Once the channel is attached to the weapon, carefully align the barrel of the weapon with the LED/detectors in the channel by using a straight dowel the same diameter as the bore of the barrel or by making a simple adapter that uses a straight length of tubing (see <a href="ch08.xhtml#ch08fig8-28">Figure 8-28</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_253"/><img alt="image" src="../images/fig8_28.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-28"><em>Figure 8-28: Using a small diameter brass rod with a Teflon end to set up proper alignment between the barrel of a Crossman T-4 CO<sub>2</sub> pistol and the sensor/detectors in the sensor channel</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">WARNING</span></strong></p>&#13;
<p class="notep">Always use caution when handling a weapon. <em>Do not look down the length of the barrel to align it. Look through the clear acrylic top of the sensor channel</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch08lev2sec25"><em><strong>Using the Full Ballistic Chronograph</strong></em></h4>&#13;
<p class="noindent">After aligning the barrel as best as possible, turn on the Full Ballistic Chronograph and press the reset button. Aim carefully at your target and fire the weapon. The velocity of the projectile in feet per second and the time it took to travel the 3 inches between sensors should appear on the LCD screen. To make another measurement, simply press the reset switch and fire again.</p>&#13;
<p class="indent">If by any chance you fail to align the weapon in the channel correctly, there is a possibility that the projectile will interrupt the first set of photosensors and not the second. In this case, you can press the clear switch and then the reset switch to try again. The clear switch simply closes the connection for the second photosensor set.</p>&#13;
<p class="indent">The Full Ballistic Chronograph should give accurate readings from about 300 fps to well over 2,000 fps.</p>&#13;
<h4 class="h4" id="ch08lev2sec26"><em><strong>Using the Chronograph Lite</strong></em></h4>&#13;
<p class="noindent">The Chronograph Lite operates in much the same way, only it automatically resets so no reset button is required. However, should the projectile fail to interrupt the second set of sensors/detectors, it will be necessary to clear the display by pressing the clear button. Essentially, this does the same thing as interrupting the second sensor/LED pair, but you should always use the clear button and never attempt to interrupt the second sensor/detector pair with an external object—especially your finger. Should the weapon <span epub:type="pagebreak" id="page_254"/>accidentally fire, you could sustain a severe injury. The Chronograph Lite will provide accurate measurements from about 200 fps to well over 1,000 fps, but its accuracy tends to roll off as it approaches 700 fps.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>HIGH-POWERED WEAPON TESTING</strong></p>&#13;
<p class="noindent">Unless you are experienced with firearms, I strongly recommend against using the Chronograph to measure high-powered weapons. That said, I did test the Full Ballistic Chronograph on a few of them.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08fig8-29">Figure 8-29</a> shows the sensor channel mounted to a Smithfield XP/M 9 mm semiautomatic pistol. I tested the Chronograph with a number of cartridges, and the measurements came within a couple fps of the manufacturer’s specification of the bullet. For example, the Remington JHP claims the bullet travels at 1,155 fps, and I measured about 1,152 fps. Other weapons also measured close to the published velocities.</p>&#13;
<div class="image"><img alt="image" src="../images/fig8_29.jpg"/></div>&#13;
<p class="figcap" id="ch08fig8-29"><em>Figure 8-29: A Smithfield XP/M 9 mm pistol set up with the sensor channel for the Full Ballistic Chronograph. The magazine is intentionally inserted backward for safety reasons</em>.</p>&#13;
</div>&#13;
</body></html>