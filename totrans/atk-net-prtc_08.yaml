- en: '**8**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IMPLEMENTING THE NETWORK PROTOCOL**'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing a network protocol can be an end in itself; however, most likely you’ll
    want to implement the protocol so you can actually test it for security vulnerabilities.
    In this chapter, you’ll learn ways to implement a protocol for testing purposes.
    I’ll cover techniques to repurpose as much existing code as possible to reduce
    the amount of development effort you’ll need to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter uses my SuperFunkyChat application, which provides testing data
    and clients and servers to test against. Of course, you can use any protocol you
    like: the fundamentals should be the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Replaying Existing Captured Network Traffic**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ideally, we want to do only the minimum necessary to implement a client or
    server for security testing. One way to reduce the amount of effort required is
    to capture example network protocol traffic and replay it to real clients or servers.
    We’ll look at three ways to achieve this goal: using Netcat to send raw binary
    data, using Python to send UDP packets, and repurposing our analysis code in [Chapter
    5](../Text/ch05.xhtml#ch05) to implement a client and a server.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Capturing Traffic with Netcat***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Netcat is the simplest way to implement a network client or server. The basic
    Netcat tool is available on most platforms, although there are multiple versions
    with different command line options. (Netcat is sometimes called `nc` or `netcat`.)
    We’ll use the BSD version of Netcat, which is used on macOS and is the default
    on most Linux systems. You might need to adapt commands if you’re on a different
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The first step when using Netcat is to capture some traffic you want to replay.
    We’ll use the Tshark command line version of Wireshark to capture traffic generated
    by SuperFunkyChat. (You may need to install Tshark on your platform.)
  prefs: []
  type: TYPE_NORMAL
- en: To limit our capture to packets sent to and received by our ChatServer running
    on TCP port 12345, we’ll use a *Berkeley Packet Filter (BPF)* expression to restrict
    the capture to a very specific set of packets. BPF expressions limit the packets
    captured, whereas Wireshark’s display filter limits only the display of a much
    larger set of capture packets.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command at the console to begin capturing port 12345 traffic
    and writing the output to the file *capture.pcap*. Replace `INTNAME` with the
    name of the interface you’re capturing from, such as `eth0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Make a client connection to the server to start the packet capture and then
    stop the capture by pressing CTRL+C in the console running Tshark. Make sure you’ve
    captured the correct traffic into the output file by running Tshark with the `-r`
    parameter and specifying the *capture.pcap* file. [Listing 8-1](../Text/ch08.xhtml#ch8list1)
    shows example output from Tshark with the addition of the parameters `-z conv,tcp`
    to print the list of capture conversations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: Verifying the capture of the chat protocol traffic*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Listing 8-1](../Text/ch08.xhtml#ch8list1), Tshark prints
    the list of raw packets at ➊ and then displays the conversation summary ➋, which
    shows that we have a connection going from 192.168.56.1 port 26082 to 192.168.56.100
    port 12345\. The client on 192.168.56.1 has received 17 frames or 1020 bytes of
    data ➌, and the server received 28 frames or 1733 bytes of data ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we use Tshark to export just the raw bytes for one direction of the conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command reads the packet capture and outputs the data from each packet;
    it doesn’t filter out items like duplicate or out-of-order packets. There are
    a couple of details to note about this command. First, you should use this command
    only on captures produced on a reliable network, such as via localhost or a local
    network connection, or you might see erroneous packets in the output. Second,
    the `data` field is only available if the protocol isn’t decoded by a dissector.
    This is not an issue with the TCP capture, but when we move to UDP, we’ll need
    to disable dissectors for this command to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that at ➋ in Listing 8-1, the client session was using port 26082\. The
    display filter `tcp.srcport==26082` removes all traffic from the output that doesn’t
    have a TCP source port of 26082\. This limits the output to traffic from the client
    to the server. The result is the data in hex format, similar to Listing 8-2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Example output from dumping raw traffic*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we convert this hex output to raw binary. The simplest way to do so is
    with the xxd tool, which is installed by default on most Unix-like systems. Run
    the `xxd` command, as shown in [Listing 8-3](../Text/ch08.xhtml#ch8list3), to
    convert the hex dump to a binary file. (The `-p` parameter converts raw hex dumps
    rather than the default `xxd` format of a numbered hex dump.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: Converting the hex dump to binary data*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can use Netcat with the binary data file. Run the following `netcat`
    command to send the client traffic in *outbound.bin* to a server at `HOSTNAME`
    port 12345\. Any traffic sent from the server back to the client will be captured
    in *inbound.bin*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can edit *outbound.bin* with a hex editor to change the session data you’re
    replaying. You can also use the *inbound.bin* file (or extract it from a PCAP)
    to send traffic back to a client by pretending to be the server using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '***Using Python to Resend Captured UDP Traffic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One limitation of using Netcat is that although it’s easy to replay a streaming
    protocol such as TCP, it’s not as easy to replay UDP traffic. The reason is that
    UDP traffic needs to maintain packet boundaries, as you saw when we tried to analyze
    the Chat Application protocol in [Chapter 5](../Text/ch05.xhtml#ch05). However,
    Netcat will just try to send as much data as it can when sending data from a file
    or a shell pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we’ll write a very simple Python script that will replay the UDP packets
    to the server and capture any results. First, we need to capture some UDP example
    chat protocol traffic using the ChatClient’s `--udp` command line parameter. Then
    we’ll use Tshark to save the packets to the file `udp_capture.pcap`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll again convert all client-to-server packets to hex strings so we
    can process them in the Python client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One difference in extracting the data from the UDP capture is that Tshark automatically
    tries to parse the traffic as the GVSP protocol. This results in the `data` field
    not being available. Therefore, we need to disable the GVSP dissector to create
    the correct output.
  prefs: []
  type: TYPE_NORMAL
- en: With a hex dump of the packets, we can finally create a very simple Python script
    to send the UDP packets and capture the response. Copy Listing 8-4 into *udp_client.py*.
  prefs: []
  type: TYPE_NORMAL
- en: udp_client.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: A simple UDP client to send network traffic capture*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Python script using following command line (it should work in Python
    2 and 3), replacing `HOSTNAME` with the appropriate host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The server should receive the packets, and any received packets in the client
    should be printed to the console as binary strings.
  prefs: []
  type: TYPE_NORMAL
- en: '***Repurposing Our Analysis Proxy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 5](../Text/ch05.xhtml#ch05), we implemented a simple proxy for SuperFunkyChat
    that captured traffic and implemented some basic traffic parsing. We can use the
    results of that analysis to implement a network client and a network server to
    replay and modify traffic, allowing us to reuse much of our existing work developing
    parsers and associated code rather than having to rewrite it for a different framework
    or language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Capturing Example Traffic**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before we can implement a client or a server, we need to capture some traffic.
    We’ll use the *parser.csx* script we developed in [Chapter 5](../Text/ch05.xhtml#ch05)
    and the code in [Listing 8-5](../Text/ch08.xhtml#ch8list5) to create a proxy to
    capture the traffic from a connection.
  prefs: []
  type: TYPE_NORMAL
- en: chapter8_capture
  prefs: []
  type: TYPE_NORMAL
- en: _proxy.csx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: The proxy to capture chat traffic to a file*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-5](../Text/ch08.xhtml#ch8list5) sets up a TCP listener on port 4444,
    forwards new connections to 127.0.0.1 port 12345, and captures the traffic. Notice
    that we still add our parsing code to the proxy at ➊ to ensure that the captured
    data has the data portion of the packet, not the length or checksum information.
    Also notice that at ➋, we write the packets to a file, which will include all
    outbound and inbound packets. We’ll need to filter out a specific direction of
    traffic later to send the capture over the network.'
  prefs: []
  type: TYPE_NORMAL
- en: Run a single client connection through this proxy and exercise the client a
    good bit. Then close the connection in the client and press ENTER in the console
    to exit the proxy and write the packet data to *packets.bin*. (Keep a copy of
    this file; we’ll need it for our client and server.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing a Simple Network Client**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll use the captured traffic to implement a simple network client. To
    do so, we’ll use the `NetClientTemplate` class to establish a new connection to
    the server and provide us with an interface to read and write network packets.
    Copy [Listing 8-6](../Text/ch08.xhtml#ch8list6) into a file named *chapter8_client.csx*.
  prefs: []
  type: TYPE_NORMAL
- en: chapter8
  prefs: []
  type: TYPE_NORMAL
- en: _client.csx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: A simple client to replace SuperFunkyChat traffic*'
  prefs: []
  type: TYPE_NORMAL
- en: One new bit in this code is that each script gets a list of command line arguments
    in the `args` variable ➊. By using command line arguments, we can specify different
    packet capture files without having to modify the script.
  prefs: []
  type: TYPE_NORMAL
- en: The `NetClientTemplate` is configured ➋ similarly to our proxy, making connections
    to 127.0.0.1:12345 but with a few differences to support the client. For example,
    because we parse the initial network traffic inside the `Parser` class, our capture
    file doesn’t contain the initial magic value that the client sends to the server.
    We add an `InitialData` array to the template with the magic bytes ➌ to correctly
    establish the connection.
  prefs: []
  type: TYPE_NORMAL
- en: We then read the packets from the file ➍ into a packet collection. When everything
    is configured, we call `Connect()` to establish a new connection to the server
    ➎. The `Connect()` method returns a `Data Adapter` that allows us to read and
    write parsed packets on the connection. Any packet we read will also go through
    the `Parser` and remove the length and checksum fields.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we filter the loaded packets to only outbound and write them to the network
    connection ➏. The `Parser` class again ensures that any data packets we write
    have the appropriate headers attached before being sent to the server. Finally,
    we read out packets and print them to the console until the connection is closed
    or the read times out ➐.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this script, passing the path to the packets we captured earlier,
    it should connect to the server and replay your session. For example, any message
    sent in the original capture should be re-sent.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just replaying the original traffic isn’t necessarily that useful.
    It would be more useful to modify traffic to test features of the protocol, and
    now that we have a very simple client, we can modify the traffic by adding some
    code to our send loop. For example, we might simply change our username in all
    packets to something else—say from `user1` to `bobsmith`—by replacing the inner
    code of the send loop (at ➏ in Listing 8-6) with the code shown in Listing 8-7.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: A simple packet editor for the client*'
  prefs: []
  type: TYPE_NORMAL
- en: To edit the username, we first convert the packet into a format we can work
    with easily. In this case, we convert it to a binary string using the `ToDataString()`
    method ➊, which results in a C# string where each byte is converted directly to
    the same character value. Because the strings in SuperFunkyChat are prefixed with
    their length, at ➋ we use the `\uXXXX` escape sequence to replace the byte 5 with
    8 for the new length of the username. You can replace any nonprintable binary
    character in the same way, using the escape sequence for the byte values.
  prefs: []
  type: TYPE_NORMAL
- en: When you rerun the client, all instances of `user1` should be replaced with
    `bobsmith`. (Of course, you can do far more complicated packet modification at
    this point, but I’ll leave that for you to experiment with.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing a Simple Server**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve implemented a simple client, but security issues can occur in both the
    client and server applications. So now we’ll implement a custom server similar
    to what we’ve done for the client.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll implement a small class to act as our server code. This class will
    be created for every new connection. A `Run()` method in the class will get a
    `Data Adapter` object, essentially the same as the one we used for the client.
    Copy [Listing 8-8](../Text/ch08.xhtml#ch8list8) into a file called *chat_server.csx*.
  prefs: []
  type: TYPE_NORMAL
- en: chat_server.csx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: A simple server class for chat protocol*'
  prefs: []
  type: TYPE_NORMAL
- en: The code at ➊ is a configuration class that simply contains a log packet collection.
    We could have simplified the code by just specifying `LogPacketCollection` as
    the configuration type, but doing so with a distinct class demonstrates how you
    might add your own configuration more easily.
  prefs: []
  type: TYPE_NORMAL
- en: The code at ➋ defines the server class. It contains the `Run()` function, which
    takes a data adapter and the server configuration, and allows us to read and write
    to the data adapter after waiting for the client to send us a packet ➌. Once we’ve
    received a packet, we immediately send our entire packet list to the client ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don’t filter the packets at ➍, and we don’t specify that we’re
    using any particular parser for the network traffic. In fact, this entire class
    is completely agnostic to the SuperFunkyChat protocol. We configure much of the
    behavior for the network server inside a template, as shown in Listing 8-9.
  prefs: []
  type: TYPE_NORMAL
- en: chapter8
  prefs: []
  type: TYPE_NORMAL
- en: _example
  prefs: []
  type: TYPE_NORMAL
- en: _server.csx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-9: A simple example ChatServer*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-9](../Text/ch08.xhtml#ch8list9) might look familiar because it’s
    very similar to the script we used for the DNS server in [Listing 2-11](../Text/ch02.xhtml#ch2list11).
    We begin by loading in the *chat_server.csx* script to define our ChatServer class
    ➊. Next, we create a server template at ➋ by specifying the type of the server
    and the configuration type. Then we load the packets from the file passed on the
    command line, filtering to capture only inbound packets and adding them to the
    packet collection in the configuration ➌. Finally, we create a service and start
    it ➍, just as we do proxies. The server is now listening for new connections on
    TCP port 12345.'
  prefs: []
  type: TYPE_NORMAL
- en: Try the server with the ChatClient application; the captured traffic should
    be sent back to the client. After all the data has been sent to the client, the
    server will automatically close the connection. As long as you observe the message
    we re-sent, don’t worry if you see an error in the ChatClient’s output. Of course,
    you can add functionality to the server, such as modifying traffic or generating
    new packets.
  prefs: []
  type: TYPE_NORMAL
- en: '**Repurposing Existing Executable Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll explore various ways to repurpose existing binary executable
    code to reduce the amount of work involved in implementing a protocol. Once you’ve
    determined a protocol’s details by reverse engineering the executable (perhaps
    using some tips from [Chapter 6](../Text/ch06.xhtml#ch06)), you’ll quickly realize
    that if you can reuse the executable code, you’ll avoid having to implement the
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you’ll have the source code you’ll need to implement a particular protocol,
    either because it’s open source or the implementation is in a scripting language
    like Python. If you do have the source code, you should be able to recompile or
    directly reuse the code in your own application. However, when the code has been
    compiled into a binary executable, your options can be more limited. We’ll look
    at each scenario now.
  prefs: []
  type: TYPE_NORMAL
- en: Managed language platforms, such as .NET and Java, are by far the easiest in
    which to reuse existing executable code, because they have a well-defined metadata
    structure in compiled code that allows a new application to be compiled against
    internal classes and methods. In contrast, in many unmanaged platforms, such as
    C/C++, the compiler will make no guarantees that any component inside a binary
    executable can be easily called externally.
  prefs: []
  type: TYPE_NORMAL
- en: Well-defined metadata also supports *reflection*, which is the ability of an
    application to support late binding of executable code to inspect data at runtime
    and to execute arbitrary methods. Although you can easily decompile many managed
    languages, it may not always be convenient to do so, especially when dealing with
    obfuscated applications. This is because the obfuscation can prevent reliable
    decompilation to usable source code.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the parts of the executable code you’ll need to execute will depend
    on the application you’re analyzing. In the sections that follow, I’ll detail
    some coding patterns and techniques to use to call the appropriate parts of the
    code in .NET and Java applications, the platforms you’re most likely to encounter.
  prefs: []
  type: TYPE_NORMAL
- en: '***Repurposing Code in .NET Applications***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed in [Chapter 6](../Text/ch06.xhtml#ch06), .NET applications are
    made up of one or more assemblies, which can be either an executable (with an
    .*exe* extension) or a library (.*dll*). When it comes to repurposing existing
    code, the form of the assembly doesn’t matter because we can call methods in both
    equally.
  prefs: []
  type: TYPE_NORMAL
- en: Whether we can just compile our code against the assembly’s code will depend
    on the visibility of the types we’re trying to use. The .NET platform supports
    different visibility scopes for types and members. The three most important forms
    of visibility scope are public, private, and internal. Public types or members
    are available to all callers outside the assembly. Private types or members are
    limited in scope to the current type (for example, you can have a private class
    inside a public class). Internal visibility scopes the types or members to only
    callers inside the same assembly, where they act as if they were public (although
    an external call cannot compile against them). For example, consider the C# code
    in Listing 8-10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-10: Examples of .NET visibility scopes*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-10](../Text/ch08.xhtml#ch8list10) defines a total of three classes:
    one public, one private, and one internal. When you compile against the assembly
    containing these types, only `PublicClass` can be directly accessed along with
    the class’s `PublicMethod()` (indicated by ➊ and ➍); attempting to access any
    other type or member will generate an error in the compiler. But notice at ➋ and
    ➌ that public members are defined. Can’t we also access those members? Unfortunately,
    no, because these members are contained inside the scope of a `PrivateClass` or
    `InternalClass`. The class’s scope takes precedence over the members’ visibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve determined whether all the types and members you want to use are
    public, you can add a reference to the assembly when compiling. If you’re using
    an IDE, you should find a method that allows you to add this reference to your
    project. But if you’re compiling on the command line using Mono or the Windows
    .NET framework, you’ll need to specify the `-reference:<FILEPATH`> option to the
    appropriate C# compiler, CSC or MCS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the Reflection APIs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If all the types and members are not public, you’ll need to use the .NET framework’s
    Reflection APIs. You’ll find most of these in the `System.Reflection` namespace,
    except for the `Type` class, which is under the `System` namespace. [Table 8-1](../Text/ch08.xhtml#ch8tab1)
    lists the most important classes with respect to reflection functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** .NET Reflection Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Type` | Represents a single type in an assembly and allows access
    to information about its members |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Reflection.Assembly` | Allows access to loading and inspecting an
    assembly as well as enumerating available types |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Reflection.MethodInfo` | Represents a method in a type |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Reflection.FieldInfo` | Represents a field in a type |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Reflection.PropertyInfo` | Represents a property in a type |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Reflection.ConstructorInfo` | Represents a class’s constructor |'
  prefs: []
  type: TYPE_TB
- en: '**Loading the Assembly**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before you can do anything with the types and members, you’ll need to load the
    assembly using the `Load()` or the `LoadFrom()` method on the `Assembly` class.
    The `Load()` method takes an *assembly name*, which is an identifier for the assembly
    that assumes the assembly file can be found in the same location as the calling
    application. The `LoadFrom()` method takes the path to the assembly file.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we’ll use `LoadFrom()`, which you can use in most
    cases. [Listing 8-11](../Text/ch08.xhtml#ch8list11) shows a simple example of
    how you might load an assembly from a file and extract a type by name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-11: A simple assembly loading example*'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the type is always the fully qualified name including its namespace.
    For example, in [Listing 8-11](../Text/ch08.xhtml#ch8list11), the name of the
    type being accessed is `Connection` inside the `ChatProgram` namespace. Each part
    of the type name is separated by periods.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you access classes that are declared inside other classes, such as those
    shown in [Listing 8-10](../Text/ch08.xhtml#ch8list10)? In C#, you access these
    by specifying the parent class name and the child class name separated by periods.
    The framework is able to differentiate between `ChatProgram.Connection`, where
    we want the class `Connection` in namespace `ChatProgram`, and the child class
    `Connection` inside the class `ChatProgram` by using a plus (`+`) symbol: `ChatProgram+Connection`
    represents a parent/child class relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-12](../Text/ch08.xhtml#ch8list12) shows a simple example of how
    we might create an instance of an internal class and call methods on it. We’ll
    assume that the class is already compiled into its own assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-12: A simple C# example class*'
  prefs: []
  type: TYPE_NORMAL
- en: The first step we need to take is to create an instance of this `Connection`
    class. We could do this by calling `GetConstructor` on the type and calling it
    manually, but sometimes there’s an easier way. One way would be to use the built-in
    `System.Activator` class to handle creating instances of types for us, at least
    in very simple scenarios. In such a scenario, we call the method `CreateInstance()`,
    which takes an instance of the type to create and a Boolean value that indicates
    whether the constructor is public or not. Because the constructor is not public
    (it’s internal), we need to pass `true` to get the activator to find the right
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-13](../Text/ch08.xhtml#ch8list13) shows how to create a new instance,
    assuming a nonpublic parameterless constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-13: Constructing a new instance of the `Connection` object*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we would call the public `Connect()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the possible methods of the `Type` class, you’ll find the `GetMethod()` method,
    which just takes the name of the method to look up and returns an instance of
    a `MethodInfo` type. If the method cannot be found, null is returned. Listing
    8-14 shows how to execute the method by calling the `Invoke()` method on `MethodInfo`,
    passing the instance of the object to execute it on and the parameters to pass
    to the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-14: Executing a method on a `Connection` object*'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest form of `GetMethod()` takes as a parameter the name of the method
    to find, but it will look for only public methods. If instead you want to call
    the private `Connect()` method to be able to specify an arbitrary TCP port, use
    one of the various overloads of `GetMethod()`. These overloads take a `BindingFlags`
    enumeration value, which is a set of flags you can pass to reflection functions
    to determine what sort of information you want to look up. [Table 8-2](../Text/ch08.xhtml#ch8tab2)
    shows some important flags.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-2:** Important .NET Reflection Binding Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BindingFlags.Public` | Look up public members |'
  prefs: []
  type: TYPE_TB
- en: '| `BindingFlags.NonPublic` | Look up nonpublic members (internal or private)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `BindingFlags.Instance` | Look up members that can only be used on an instance
    of the class |'
  prefs: []
  type: TYPE_TB
- en: '| `BindingFlags.Static` | Look up members that can be accessed statically without
    an instance |'
  prefs: []
  type: TYPE_TB
- en: To get a `MethodInfo` for the private method, we can use the overload of `GetMethod()`,
    as shown in [Listing 8-15](../Text/ch08.xhtml#ch8list15), which takes a name and
    the binding flags. We’ll need to specify both `NonPublic` and `Instance` in the
    flags because we want a nonpublic method that can be called on instances of the
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-15: Calling a nonpublic `Connect()` method*'
  prefs: []
  type: TYPE_NORMAL
- en: So far so good. Now we need to call the `Send()` method. Because this method
    is public, we should be able to call the basic `GetMethod()` method. But calling
    the basic method generates the exception shown in Listing 8-16, indicating an
    ambiguous match. What’s gone wrong?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-16: An exception thrown for the `Send()` method*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice in [Listing 8-12](../Text/ch08.xhtml#ch8list12) the `Connection` class
    has two `Send()` methods: one takes an array of bytes and the other takes a string.
    Because the reflection API doesn’t know which method you want, it doesn’t return
    a reference to either; instead, it just throws an exception. Contrast this with
    the `Connect()` method, which worked because the binding flags disambiguate the
    call. If you’re looking up a public method with the name `Connect()`, the reflection
    APIs will not even inspect the nonpublic overload.'
  prefs: []
  type: TYPE_NORMAL
- en: We can get around this error by using yet another overload of `GetMethod()`
    that specifies exactly the types we want the method to support. We’ll choose the
    method that takes a string, as shown in [Listing 8-17](../Text/ch08.xhtml#ch8list17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-17: Calling the `Send(string)` method*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can call the `Receive()` method. It’s public, so there are no additional
    overloads and it should be simple. Because `Receive()` takes no parameters, we
    can either pass an empty array or null to `Invoke()`. Because `Invoke()` returns
    an *object*, we need to cast the return value to a byte array to access the bytes
    directly. [Listing 8-18](../Text/ch08.xhtml#ch8list18) shows the final implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-18: Calling the `Receive()` method*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Repurposing Code in Java Applications***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Java is fairly similar to .NET, so I’ll just focus on the difference between
    them, which is that Java does not have the concept of an assembly. Instead, each
    class is represented by a separate *.class* file. Although you can combine class
    files into a Java Archive (JAR) file, it is just a convenience feature. For that
    reason, Java does not have internal classes that can only be accessed by other
    classes in the same assembly. However, Java does have a somewhat similar feature
    called *package-private* scoped classes, which can only be accessed by classes
    in the same package. (.NET refers to packages as a *namespace*.)
  prefs: []
  type: TYPE_NORMAL
- en: The upshot of this feature is that if you want to access classes marked as package
    scoped, you can write some Java code that defines itself in the same package,
    which can then access the package-scoped classes and members at will. For example,
    [Listing 8-19](../Text/ch08.xhtml#ch8list19) shows a package-private class that
    would be defined in the library you want to call and a simple bridge class you
    can compile into your own application to create an instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-19: Implementing a bridge class to access a package-private class*'
  prefs: []
  type: TYPE_NORMAL
- en: You specify the existing class or JAR files by adding their locations to the
    Java classpath, typically by specifying the `-classpath` parameter to the Java
    compiler or Java runtime executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to call Java classes by reflection, the core Java reflection types
    are very similar to those described in the preceding .NET section: *Type* in .NET
    is *class* in Java, `MethodInfo` is `Method`, and so on. [Table 8-3](../Text/ch08.xhtml#ch8tab3)
    contains a short list of Java reflection types.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-3:** Java Reflection Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `java.lang.Class` | Represents a single class and allows access to its members
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.lang.reflect.Method` | Represents a method in a type |'
  prefs: []
  type: TYPE_TB
- en: '| `java.lang.reflect.Field` | Represents a field in a type |'
  prefs: []
  type: TYPE_TB
- en: '| `java.lang.reflect.Constructor` | Represents a class’s constructor |'
  prefs: []
  type: TYPE_TB
- en: You can access a class object by name by calling the `Class.forName()` method.
    For example, [Listing 8-20](../Text/ch08.xhtml#ch8list20) shows how we would get
    the `PackageClass`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-20: Getting a class in Java*'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to create an instance of a public class with a parameterless constructor,
    the `Class` instance has a `newInstance()` method. This won’t work for our package-private
    class, so instead we’ll get an instance of the `Constructor` by calling `getDeclaredConstructor()`
    on the `Class` instance. We need to pass a list of `Class` objects to `getDeclaredConstructor()`
    to select the correct Constructor based on the types of parameters the constructor
    accepts. [Listing 8-21](../Text/ch08.xhtml#ch8list21) shows how we would choose
    the constructor, which takes a string, and then create a new instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-21: Creating a new instance from a private constructor*'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 8-21](../Text/ch08.xhtml#ch8list21) should be fairly self-explanatory
    except perhaps for the line at ➊. In Java, any nonpublic member, whether a constructor,
    field, or method, must be set as accessible before you use it. If you don’t call
    `setAccessible()` with the value `true`, then calling `newInstance()` will throw
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '***Unmanaged Executables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Calling arbitrary code in most unmanaged executables is much more difficult
    than in managed platforms. Although you can call a pointer to an internal function,
    there’s a reasonable chance that doing so could crash your application. However,
    you can reasonably call the unmanaged implementation when it’s explicitly exposed
    through a dynamic library. This section offers a brief overview of using the built-in
    Python library ctypes to call an unmanaged library on a Unix-like platform and
    Microsoft Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There are many complicated scenarios that involve calling into unmanaged code
    using the Python ctypes library, such as passing string values or calling C++
    functions. You can find several detailed resources online, but this section should
    give you enough basics to interest you in learning more about how to use Python
    to call unmanaged libraries.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling Dynamic Libraries**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Linux, macOS, and Windows support dynamic libraries. Linux calls them object
    files (.*so*), macOS calls them dynamic libraries (.*dylib*), and Windows calls
    them dynamic link libraries (.*dll*). The Python ctypes library provides a mostly
    generic way to load all of these libraries into memory and a consistent syntax
    for defining how to call the exported function. Listing 8-22 shows a simple library
    written in C, which we’ll use as an example throughout the rest of the section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-22: The example C library* lib.c'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compile the code in [Listing 8-22](../Text/ch08.xhtml#ch8list22) into
    an appropriate dynamic library for the platform you’re testing. For example, on
    Linux you can compile the library by installing a C compiler, such as GCC, and
    executing the following command in the shell, which will generate a shared library
    *lib.so*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Loading a Library with Python**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Moving to Python, we can load our library using the `ctypes.cdll.LoadLibrary()`
    method, which returns an instance of a loaded library with the exported functions
    attached to the instance as named methods. For example, Listing 8-23 shows how
    to call the `say_hello()` method from the library compiled in Listing 8-22.
  prefs: []
  type: TYPE_NORMAL
- en: listing8-23.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-23: A simple Python example for calling a dynamic library*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that in order to load the library on Linux, you need to specify a path.
    Linux by default does not include the current directory in the library search
    order, so loading *lib.so* would fail. That is not the case on macOS or on Windows.
    On Windows, you can simply specify the name of the library after *cdll* and it
    will automatically add the *.dll* extension and load the library.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do some exploring. Load [Listing 8-23](../Text/ch08.xhtml#ch8list23) into
    a Python shell, for example, by running `execfile("listing8-23.py")`, and you’ll
    see that `Hello` is returned. Keep the interactive session open for the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling More Complicated Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s easy enough to call a simple method, such as `say_hello()`, as in Listing
    8-23\. But in this section, we’ll look at how to call slightly more complicated
    functions including unmanaged functions, which take multiple different arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever possible, ctypes will attempt to determine what parameters are passed
    to the function automatically based on the parameters you pass in the Python script.
    Also, the library will always assume that the return type of a method is a C integer.
    For example, [Listing 8-24](../Text/ch08.xhtml#ch8list24) shows how to call the
    `add_numbers()` or `say_string()` methods along with the expected output from
    the interactive session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-24: Calling simple methods*'
  prefs: []
  type: TYPE_NORMAL
- en: More complex methods require the use of ctypes data types to explicitly specify
    what types we want to use as defined in the ctypes namespace. [Table 8-4](../Text/ch08.xhtml#ch8tab4)
    shows some of the more common data types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-4:** Python ctypes and Their Native C Type Equivalent'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python ctypes** | **Native C types** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `c_char`, `c_wchar` | char, wchar_t |'
  prefs: []
  type: TYPE_TB
- en: '| `c_byte`, `c_ubyte` | char, unsigned char |'
  prefs: []
  type: TYPE_TB
- en: '| `c_short`, `c_ushort` | short, unsigned short |'
  prefs: []
  type: TYPE_TB
- en: '| `c_int`, `c_uint` | int, unsigned int |'
  prefs: []
  type: TYPE_TB
- en: '| `c_long`, `c_ulong` | long, unsigned long |'
  prefs: []
  type: TYPE_TB
- en: '| `c_longlong`, `c_ulonglong` | long long, unsigned long long (typically 64
    bit) |'
  prefs: []
  type: TYPE_TB
- en: '| `c_float`, `c_double` | float, double |'
  prefs: []
  type: TYPE_TB
- en: '| `c_char_p`, `c_wchar_p` | char*, wchar_t* (NUL terminated strings) |'
  prefs: []
  type: TYPE_TB
- en: '| `c_void_p` | void* (generic pointer) |'
  prefs: []
  type: TYPE_TB
- en: To specify the return type, we can assign a data type to the `lib.name.restype`
    property. For example, [Listing 8-25](../Text/ch08.xhtml#ch8list25) shows how
    to call `get_hello()`, which returns a pointer to a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-25: Calling a method that returns a C string*'
  prefs: []
  type: TYPE_NORMAL
- en: If instead you want to specify the arguments to be passed to a method, you can
    set an array of data types to the `argtypes` property. For example, [Listing 8-26](../Text/ch08.xhtml#ch8list26)
    shows how to call `add_longs()` correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-26: Specifying `argtypes` for a method call*'
  prefs: []
  type: TYPE_NORMAL
- en: To pass a parameter via a pointer, use the `byref` helper. For example, `add_numbers_result()`
    returns the value as a pointer to an integer, as shown in [Listing 8-27](../Text/ch08.xhtml#ch8list27).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-27: Calling a method with a reference parameter*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling a Function with a Structure Parameter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can define a structure for ctypes by creating a class derived from the `Structure`
    class and assigning the `_fields_ property`, and then pass the structure to the
    imported method. [Listing 8-28](../Text/ch08.xhtml#ch8list28) shows how to do
    this for the `say_struct()` function, which takes a pointer to a structure containing
    a string and a number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-28: Calling a method taking a structure*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling Functions with Python on Microsoft Windows**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this section, information on calling unmanaged libraries on Windows is specific
    to 32-bit Windows. As discussed in [Chapter 6](../Text/ch06.xhtml#ch06), Windows
    API calls can specify a number of different calling conventions, the most common
    being *stdcall* and *cdecl*. By using *cdll*, all calls assume that the function
    is *cdecl*, but the property *windll* defaults instead to *stdcall*. If a DLL
    exports both *cdecl* and *stdcall* methods, you can mix calls through *cdll* and
    *windll* as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll need to consider more calling scenarios using the Python ctypes library,
    such as how to pass back strings or call C++ functions. You can find many detailed
    resources online, but this section should have given you enough basics to interest
    you in learning more about how to use Python to call unmanaged libraries.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption and Dealing with TLS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Encryption on network protocols can make it difficult for you to perform protocol
    analysis and reimplement the protocol to test for security issues. Fortunately,
    most applications don’t roll their own cryptography. Instead, they utilize a version
    of TLS, as described at the end of [Chapter 7](../Text/ch07.xhtml#ch07). Because
    TLS is a known quantity, we can often remove it from a protocol or reimplement
    it using standard tools and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '***Learning About the Encryption In Use***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Perhaps unsurprisingly, SuperFunkyChat has support for a TLS endpoint, although
    you need to configure it by passing the path to a server certificate. The binary
    distribution of SuperFunkyChat comes with a *server.pfx* for this purpose. Restart
    the `ChatServer` application with the `--server_cert` parameter, as shown in [Listing
    8-29](../Text/ch08.xhtml#ch8list29), and observe the output to ensure that TLS
    has been enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-29: Running ChatServer with a TLS certificate*'
  prefs: []
  type: TYPE_NORMAL
- en: Two indications in the output of [Listing 8-29](../Text/ch08.xhtml#ch8list29)
    show that TLS has been enabled. First, the subject name of the server certificate
    is shown at ➊. Second, you can see that TLS server is listening on port 12346
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s no need to specify the port number when connecting the client using
    TLS with the `--tls` parameter: the client will automatically increment the port
    number to match. [Listing 8-30](../Text/ch08.xhtml#ch8list30) shows how when you
    add the `--tls` command line parameter to the client, it displays basic information
    about the connection to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-30: A normal client connection*'
  prefs: []
  type: TYPE_NORMAL
- en: In this output, the TLS protocol in use is shown at ➊ as TLS 1.2\. We can also
    see the key exchange ➋, cipher ➌, and hash algorithms ➍ negotiated. At ➎, we see
    some information about the server certificate, including the name of the Cert
    Subject, which typically represents the certificate owner. The Cert Issuer ➏ is
    the authority that signed the server’s certificate, and it’s the next certificate
    in the chain, as described in “[Public Key Infrastructure](../Text/ch07.xhtml#ch00lev1sec205)”
    on [page 169](../Text/ch07.xhtml#page_169). In this case, the Cert Subject and
    Cert Issuer are the same, which typically means the certificate is self-signed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Decrypting the TLS Traffic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common technique to decrypt the TLS traffic is to actively use a man-in-the-middle
    attack on the network traffic so you can decrypt the TLS from the client and reencrypt
    it when sending it to the server. Of course, in the middle, you can manipulate
    and observe the traffic all you like. But aren’t man-in-the-middle attacks exactly
    what TLS is supposed to protect against? Yes, but as long as we control the client
    application sufficiently well, we can usually perform this attack for testing
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding TLS support to a proxy (and therefore to servers and clients, as discussed
    earlier in this chapter) can be a simple matter of adding a single line or two
    to the proxy script to add a TLS decryption and encryption layer. [Figure 8-1](../Text/ch08.xhtml#ch8fig1)
    shows a simple example of such a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f08-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: An example MITM TLS proxy*'
  prefs: []
  type: TYPE_NORMAL
- en: We can implement the attack shown in [Figure 8-1](../Text/ch08.xhtml#ch8fig1)
    by replacing the template initialization in [Listing 8-5](../Text/ch08.xhtml#ch8list5)
    with the code in [Listing 8-31](../Text/ch08.xhtml#ch8list31).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-31: Adding TLS support to capture a proxy*'
  prefs: []
  type: TYPE_NORMAL
- en: We make two important changes to the template initialization. At ➊, we increment
    port numbers because the client automatically adds 1 to the port when trying to
    connect over TLS. Then at ➋, we add a TLS network layer to the proxy template.
    (Be sure to add the TLS layer before the parser layer, or the parser layer will
    try to parse the TLS network traffic, which won’t work so well.)
  prefs: []
  type: TYPE_NORMAL
- en: With the proxy in place, let’s repeat our test with the client from Listing
    8-31 to see the differences. [Listing 8-32](../Text/ch08.xhtml#ch8list32) shows
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-32: ChatClient connecting through a proxy*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice some clear changes in [Listing 8-32](../Text/ch08.xhtml#ch8list32). One
    is that the TLS protocol is now TLS v1.0 ➊ instead of TLS v1.2\. Another is that
    the Cipher and Hash algorithms differ from those in [Listing 8-30](../Text/ch08.xhtml#ch8list30),
    although the key exchange algorithm is using Elliptic Curve Diffie–Hellman (ECDH)
    for forward secrecy ➋. The final change is shown in the Cert Issuer ➌. The proxy
    libraries will autogenerate a valid certificate based on the original one from
    the server, but it will be signed with the library’s Certificate Authority (CA)
    certificate. If a CA certificate isn’t configured, one will be generated on first
    use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Forcing TLS 1.2**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The changes to the negotiated encryption settings shown in [Listing 8-32](../Text/ch08.xhtml#ch8list32)
    can interfere with your successfully proxying applications because some applications
    will check the version of TLS negotiated. If the client will only connect to a
    TLS 1.2 service, you can force that version by adding this line to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Replacing the Certificate with Our Own**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Replacing the certificate chain involves ensuring that the client accepts the
    certificate that you generate as a valid root CA. Run the script in Listing 8-33
    in *CANAPE.Cli* to generate a new CA certificate, output it and key to a PFX file,
    and output the public certificate in PEM format.
  prefs: []
  type: TYPE_NORMAL
- en: generate_ca
  prefs: []
  type: TYPE_NORMAL
- en: _cert.csx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-33: Generating a new root CA certificate for a proxy*'
  prefs: []
  type: TYPE_NORMAL
- en: On disk, you should now find a *ca.pfx* file and a *ca.crt* file. Copy the *ca.pfx*
    file into the same directory where your proxy script files are located, and add
    the following line before initializing the TLS layer as in [Listing 8-31](../Text/ch08.xhtml#ch8list31).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: All generated certificates should now use your CA certificate as the root certificate.
  prefs: []
  type: TYPE_NORMAL
- en: You can now import *ca.crt* as a trusted root for your application. The method
    you use to import the certificate will depend on many factors, for example, the
    type of device the client application is running on (mobile devices are typically
    more difficult to compromise). Then there’s the question of where the application’s
    trusted root is stored. For example, is it in an application binary? I’ll show
    just one example of importing the certificate on Microsoft Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Because it’s common for Windows applications to refer to the system trusted
    root store to get their root CAs, we can import our own certificate into this
    store and SuperFunkyChat will trust it. To do so, first run `certmgr.msc` either
    from the Run dialog or a command prompt. You should see the application window
    shown in [Figure 8-2](../Text/ch08.xhtml#ch8fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f08-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: The Windows certificate manager*'
  prefs: []
  type: TYPE_NORMAL
- en: Choose **Trusted Root Certification Authorities** ▸ **Certificates** and then
    select **Action** ▸ **All Tasks** ▸ **Import**. An import Wizard should appear.
    Click **Next** and you should see a dialog similar to [Figure 8-3](../Text/ch08.xhtml#ch8fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f08-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: Using the Certificate Import Wizard file import*'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the path to *ca.crt* or browse to it and click **Next** again.
  prefs: []
  type: TYPE_NORMAL
- en: Next, make sure that Trusted Root Certification Authorities is shown in the
    Certificate Store box (see [Figure 8-4](../Text/ch08.xhtml#ch8fig4)) and click
    **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f08-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: The certificate store location*'
  prefs: []
  type: TYPE_NORMAL
- en: On the final screen, click **Finish**; you should see the warning dialog box
    shown in [Figure 8-5](../Text/ch08.xhtml#ch8fig5). Obviously, heed its warning,
    but click **Yes** all the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be very careful when importing arbitrary root CA certificates into your trusted
    root store. If someone gains access to your private key, even if you were only
    planning to test a single application, they could man-in-the-middle any TLS connection
    you make. Never install arbitrary certificates on any device you use or care about.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f08-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: A warning about importing a root CA certificate*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as your application uses the system root store, your TLS proxy connection
    will be trusted. We can test this quickly with SuperFunkyChat using `--verify`
    with the ChatClient to enable server certificate verification. Verification is
    off by default to allow you to use a self-signed certificate for the server. But
    when you run the client against the proxy server with `--verify`, the connection
    should fail, and you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that although we added the CA certificate as a trusted root,
    the server name, which is in many cases specified as the subject of the certificate,
    is invalid for the target. As we’re proxying the connection, the server hostname
    is, for example, 127.0.0.1, but the generated certificate is based on the original
    server’s certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, add the following lines to specify the subject name for the generated
    certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When you retry the client, it should successfully connect to the proxy and then
    on to the real server, and all traffic should be unencrypted inside the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply the same code changes to the network client and server code in
    [Listing 8-6](../Text/ch08.xhtml#ch8list6) and [Listing 8-8](../Text/ch08.xhtml#ch8list8).
    The framework will take care of ensuring that only specific TLS connections are
    established. (You can even specify TLS client certificates in the configuration
    for use in performing mutual authentication, but that’s an advanced topic that’s
    beyond the scope of this book.)
  prefs: []
  type: TYPE_NORMAL
- en: You should now have some ideas about how to man-in-the-middle TLS connections.
    The techniques you’ve learned will enable you to decrypt and encrypt the traffic
    from many applications to perform analysis and security testing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Final Words**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter demonstrated some approaches you can take to reimplement your application
    protocol based on the results of either doing on-the-wire inspection or reverse
    engineering the implementation. I’ve only scratched the surface of this complex
    topic—many interesting challenges await you as you investigate security issues
    in network protocols.
  prefs: []
  type: TYPE_NORMAL
