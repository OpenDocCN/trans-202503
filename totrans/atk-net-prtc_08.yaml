- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**IMPLEMENTING THE NETWORK PROTOCOL**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现网络协议**'
- en: Analyzing a network protocol can be an end in itself; however, most likely you’ll
    want to implement the protocol so you can actually test it for security vulnerabilities.
    In this chapter, you’ll learn ways to implement a protocol for testing purposes.
    I’ll cover techniques to repurpose as much existing code as possible to reduce
    the amount of development effort you’ll need to do.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 分析网络协议本身可能是一个目的；然而，更可能的是，你会希望实现该协议，以便实际测试它的安全漏洞。在本章中，你将学习一些实现协议用于测试的方法。我将介绍一些技术，尽可能地重新利用现有的代码，以减少你需要开发的工作量。
- en: 'This chapter uses my SuperFunkyChat application, which provides testing data
    and clients and servers to test against. Of course, you can use any protocol you
    like: the fundamentals should be the same.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了我的 SuperFunkyChat 应用程序，它提供了测试数据和客户端、服务器来进行测试。当然，你可以使用任何你喜欢的协议：基本原则应该是相同的。
- en: '**Replaying Existing Captured Network Traffic**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**重放已捕获的网络流量**'
- en: 'Ideally, we want to do only the minimum necessary to implement a client or
    server for security testing. One way to reduce the amount of effort required is
    to capture example network protocol traffic and replay it to real clients or servers.
    We’ll look at three ways to achieve this goal: using Netcat to send raw binary
    data, using Python to send UDP packets, and repurposing our analysis code in [Chapter
    5](../Text/ch05.xhtml#ch05) to implement a client and a server.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望只做最少的工作来实现一个客户端或服务器以进行安全性测试。减少所需工作量的一种方法是捕获示例网络协议流量并将其重放到实际的客户端或服务器上。我们将探讨三种实现此目标的方法：使用
    Netcat 发送原始二进制数据、使用 Python 发送 UDP 数据包，以及重新利用我们在[第 5 章](../Text/ch05.xhtml#ch05)中的分析代码来实现客户端和服务器。
- en: '***Capturing Traffic with Netcat***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Netcat 捕获流量***'
- en: Netcat is the simplest way to implement a network client or server. The basic
    Netcat tool is available on most platforms, although there are multiple versions
    with different command line options. (Netcat is sometimes called `nc` or `netcat`.)
    We’ll use the BSD version of Netcat, which is used on macOS and is the default
    on most Linux systems. You might need to adapt commands if you’re on a different
    operating system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat 是实现网络客户端或服务器的最简单方式。基本的 Netcat 工具在大多数平台上都有提供，尽管有多个版本具有不同的命令行选项。（Netcat
    有时也叫做 `nc` 或 `netcat`。）我们将使用 BSD 版本的 Netcat，它在 macOS 上使用，并且在大多数 Linux 系统上是默认版本。如果你使用的是不同的操作系统，可能需要调整命令。
- en: The first step when using Netcat is to capture some traffic you want to replay.
    We’ll use the Tshark command line version of Wireshark to capture traffic generated
    by SuperFunkyChat. (You may need to install Tshark on your platform.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Netcat 的第一步是捕获你希望重放的一些流量。我们将使用 Wireshark 的命令行版本 Tshark 来捕获 SuperFunkyChat
    生成的流量。（你可能需要在你的平台上安装 Tshark。）
- en: To limit our capture to packets sent to and received by our ChatServer running
    on TCP port 12345, we’ll use a *Berkeley Packet Filter (BPF)* expression to restrict
    the capture to a very specific set of packets. BPF expressions limit the packets
    captured, whereas Wireshark’s display filter limits only the display of a much
    larger set of capture packets.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的捕获范围限制在发送到并由我们在 TCP 端口 12345 上运行的 ChatServer 接收的包，我们将使用 *伯克利数据包过滤器（BPF）*
    表达式来限制捕获到一个非常特定的数据包集合。BPF 表达式限制了捕获的数据包，而 Wireshark 的显示过滤器仅限制了显示的大量捕获数据包。
- en: Run the following command at the console to begin capturing port 12345 traffic
    and writing the output to the file *capture.pcap*. Replace `INTNAME` with the
    name of the interface you’re capturing from, such as `eth0`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台运行以下命令以开始捕获 12345 端口的流量并将输出写入文件 *capture.pcap*。将 `INTNAME` 替换为你正在捕获流量的接口名称，例如
    `eth0`。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make a client connection to the server to start the packet capture and then
    stop the capture by pressing CTRL+C in the console running Tshark. Make sure you’ve
    captured the correct traffic into the output file by running Tshark with the `-r`
    parameter and specifying the *capture.pcap* file. [Listing 8-1](../Text/ch08.xhtml#ch8list1)
    shows example output from Tshark with the addition of the parameters `-z conv,tcp`
    to print the list of capture conversations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 启动客户端与服务器的连接以开始数据包捕获，然后通过在运行 Tshark 的控制台中按 CTRL+C 停止捕获。通过使用 `-r` 参数并指定 *capture.pcap*
    文件来运行 Tshark，确保你已经捕获到正确的流量到输出文件中。[清单 8-1](../Text/ch08.xhtml#ch8list1) 显示了 Tshark
    的示例输出，增加了 `-z conv,tcp` 参数以打印捕获对话的列表。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 8-1: Verifying the capture of the chat protocol traffic*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：验证聊天协议流量的捕获*'
- en: As you can see in [Listing 8-1](../Text/ch08.xhtml#ch8list1), Tshark prints
    the list of raw packets at ➊ and then displays the conversation summary ➋, which
    shows that we have a connection going from 192.168.56.1 port 26082 to 192.168.56.100
    port 12345\. The client on 192.168.56.1 has received 17 frames or 1020 bytes of
    data ➌, and the server received 28 frames or 1733 bytes of data ➍.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[清单 8-1](../Text/ch08.xhtml#ch8list1)中看到的，Tshark 会在 ➊ 打印原始数据包列表，然后显示会话摘要
    ➋，显示我们从 192.168.56.1 端口 26082 到 192.168.56.100 端口 12345 的连接。客户端 192.168.56.1 已接收
    17 帧或 1020 字节的数据 ➌，服务器接收到 28 帧或 1733 字节的数据 ➍。
- en: 'Now we use Tshark to export just the raw bytes for one direction of the conversation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 Tshark 导出一个方向的原始字节数据：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command reads the packet capture and outputs the data from each packet;
    it doesn’t filter out items like duplicate or out-of-order packets. There are
    a couple of details to note about this command. First, you should use this command
    only on captures produced on a reliable network, such as via localhost or a local
    network connection, or you might see erroneous packets in the output. Second,
    the `data` field is only available if the protocol isn’t decoded by a dissector.
    This is not an issue with the TCP capture, but when we move to UDP, we’ll need
    to disable dissectors for this command to work correctly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令读取数据包捕获并输出每个数据包中的数据；它不会过滤掉重复数据包或乱序数据包等项。有几个细节需要注意。首先，您应仅在可靠网络上使用此命令，例如通过本地主机或本地网络连接生成的捕获文件，否则您可能会在输出中看到错误的数据包。其次，只有当协议没有被解码器解码时，`data`
    字段才会可用。对于 TCP 捕获来说这不是问题，但当我们处理 UDP 时，必须禁用解码器才能使此命令正确工作。
- en: Recall that at ➋ in Listing 8-1, the client session was using port 26082\. The
    display filter `tcp.srcport==26082` removes all traffic from the output that doesn’t
    have a TCP source port of 26082\. This limits the output to traffic from the client
    to the server. The result is the data in hex format, similar to Listing 8-2.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾在清单 8-1 的 ➋ 处，客户端会话使用了 26082 端口。显示过滤器 `tcp.srcport==26082` 会移除输出中不包含 TCP 源端口
    26082 的所有流量。这样，输出只会包含从客户端到服务器的流量。结果是以十六进制格式呈现的数据，类似于清单 8-2。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 8-2: Example output from dumping raw traffic*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-2：转储原始流量的示例输出*'
- en: Next, we convert this hex output to raw binary. The simplest way to do so is
    with the xxd tool, which is installed by default on most Unix-like systems. Run
    the `xxd` command, as shown in [Listing 8-3](../Text/ch08.xhtml#ch8list3), to
    convert the hex dump to a binary file. (The `-p` parameter converts raw hex dumps
    rather than the default `xxd` format of a numbered hex dump.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将此十六进制输出转换为原始二进制数据。最简单的方法是使用 xxd 工具，它在大多数类 Unix 系统上默认安装。运行 `xxd` 命令，如[清单
    8-3](../Text/ch08.xhtml#ch8list3)所示，将十六进制转储转换为二进制文件。（`-p` 参数会转换原始十六进制转储，而不是默认的带编号的十六进制转储格式。）
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-3: Converting the hex dump to binary data*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-3：将十六进制转储转换为二进制数据*'
- en: Finally, we can use Netcat with the binary data file. Run the following `netcat`
    command to send the client traffic in *outbound.bin* to a server at `HOSTNAME`
    port 12345\. Any traffic sent from the server back to the client will be captured
    in *inbound.bin*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 Netcat 和二进制数据文件。运行以下 `netcat` 命令，将 *outbound.bin* 中的客户端流量发送到 `HOSTNAME`
    服务器的 12345 端口。任何从服务器返回客户端的流量将被捕获到 *inbound.bin* 文件中。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can edit *outbound.bin* with a hex editor to change the session data you’re
    replaying. You can also use the *inbound.bin* file (or extract it from a PCAP)
    to send traffic back to a client by pretending to be the server using the following
    command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用十六进制编辑器编辑 *outbound.bin* 来更改您正在重放的会话数据。您还可以使用 *inbound.bin* 文件（或从 PCAP
    中提取它）通过伪装成服务器的方式向客户端发送流量，使用以下命令：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***Using Python to Resend Captured UDP Traffic***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Python 重新发送捕获的 UDP 流量***'
- en: One limitation of using Netcat is that although it’s easy to replay a streaming
    protocol such as TCP, it’s not as easy to replay UDP traffic. The reason is that
    UDP traffic needs to maintain packet boundaries, as you saw when we tried to analyze
    the Chat Application protocol in [Chapter 5](../Text/ch05.xhtml#ch05). However,
    Netcat will just try to send as much data as it can when sending data from a file
    or a shell pipeline.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Netcat 的一个限制是，尽管重放像 TCP 这样的流协议很容易，但重放 UDP 流量就没那么简单了。原因是 UDP 流量需要保持数据包边界，就像我们在[第
    5 章](../Text/ch05.xhtml#ch05)分析聊天应用协议时所看到的那样。然而，Netcat 在从文件或 shell 管道发送数据时，会尽量发送它能发送的所有数据。
- en: 'Instead, we’ll write a very simple Python script that will replay the UDP packets
    to the server and capture any results. First, we need to capture some UDP example
    chat protocol traffic using the ChatClient’s `--udp` command line parameter. Then
    we’ll use Tshark to save the packets to the file `udp_capture.pcap`, as shown
    here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将编写一个非常简单的 Python 脚本，用于将 UDP 数据包转发到服务器并捕获任何结果。首先，我们需要使用 ChatClient 的 `--udp`
    命令行参数来捕获一些 UDP 示例聊天协议流量。然后，我们将使用 Tshark 将数据包保存到文件 `udp_capture.pcap` 中，如下所示：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we’ll again convert all client-to-server packets to hex strings so we
    can process them in the Python client:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将再次将所有客户端到服务器的数据包转换为十六进制字符串，以便在 Python 客户端中进行处理：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One difference in extracting the data from the UDP capture is that Tshark automatically
    tries to parse the traffic as the GVSP protocol. This results in the `data` field
    not being available. Therefore, we need to disable the GVSP dissector to create
    the correct output.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从 UDP 捕获中提取数据的一个区别是，Tshark 会自动尝试将流量解析为 GVSP 协议。这导致 `data` 字段无法使用。因此，我们需要禁用 GVSP
    解码器，以生成正确的输出。
- en: With a hex dump of the packets, we can finally create a very simple Python script
    to send the UDP packets and capture the response. Copy Listing 8-4 into *udp_client.py*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有了数据包的十六进制转储，我们终于可以创建一个非常简单的 Python 脚本来发送 UDP 数据包并捕获响应。将清单 8-4 复制到 *udp_client.py*
    中。
- en: udp_client.py
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: udp_client.py
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-4: A simple UDP client to send network traffic capture*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-4：一个简单的 UDP 客户端，用于发送网络流量捕获*'
- en: 'Run the Python script using following command line (it should work in Python
    2 and 3), replacing `HOSTNAME` with the appropriate host:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令行运行 Python 脚本（它应适用于 Python 2 和 3），将 `HOSTNAME` 替换为适当的主机：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The server should receive the packets, and any received packets in the client
    should be printed to the console as binary strings.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应接收数据包，客户端接收到的任何数据包应作为二进制字符串打印到控制台。
- en: '***Repurposing Our Analysis Proxy***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重新利用我们的分析代理***'
- en: In [Chapter 5](../Text/ch05.xhtml#ch05), we implemented a simple proxy for SuperFunkyChat
    that captured traffic and implemented some basic traffic parsing. We can use the
    results of that analysis to implement a network client and a network server to
    replay and modify traffic, allowing us to reuse much of our existing work developing
    parsers and associated code rather than having to rewrite it for a different framework
    or language.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](../Text/ch05.xhtml#ch05)中，我们实现了一个简单的 SuperFunkyChat 代理，用于捕获流量并实现一些基本的流量解析。我们可以使用该分析的结果来实现一个网络客户端和网络服务器，用于重放和修改流量，这样我们就可以重用大部分现有的解析器和相关代码，而无需为不同的框架或语言重新编写。
- en: '**Capturing Example Traffic**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**捕获示例流量**'
- en: Before we can implement a client or a server, we need to capture some traffic.
    We’ll use the *parser.csx* script we developed in [Chapter 5](../Text/ch05.xhtml#ch05)
    and the code in [Listing 8-5](../Text/ch08.xhtml#ch8list5) to create a proxy to
    capture the traffic from a connection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现客户端或服务器之前，我们需要捕获一些流量。我们将使用在[第五章](../Text/ch05.xhtml#ch05)中开发的 *parser.csx*
    脚本和[清单 8-5](../Text/ch08.xhtml#ch8list5)中的代码来创建一个代理，捕获连接的流量。
- en: chapter8_capture
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: chapter8_capture
- en: _proxy.csx
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: _proxy.csx
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 8-5: The proxy to capture chat traffic to a file*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-5：捕获聊天流量到文件的代理*'
- en: '[Listing 8-5](../Text/ch08.xhtml#ch8list5) sets up a TCP listener on port 4444,
    forwards new connections to 127.0.0.1 port 12345, and captures the traffic. Notice
    that we still add our parsing code to the proxy at ➊ to ensure that the captured
    data has the data portion of the packet, not the length or checksum information.
    Also notice that at ➋, we write the packets to a file, which will include all
    outbound and inbound packets. We’ll need to filter out a specific direction of
    traffic later to send the capture over the network.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-5](../Text/ch08.xhtml#ch8list5) 在端口 4444 上设置了一个 TCP 监听器，将新的连接转发到 127.0.0.1
    的 12345 端口，并捕获流量。请注意，我们仍然在代理的 ➊ 处添加了解析代码，以确保捕获的数据包含数据部分，而不是长度或校验和信息。还要注意，在 ➋ 处，我们将数据包写入文件，这将包括所有出站和入站的数据包。稍后我们需要过滤掉特定方向的流量，以便将捕获的数据通过网络发送。'
- en: Run a single client connection through this proxy and exercise the client a
    good bit. Then close the connection in the client and press ENTER in the console
    to exit the proxy and write the packet data to *packets.bin*. (Keep a copy of
    this file; we’ll need it for our client and server.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个代理运行一次客户端连接，并适当操作客户端。然后关闭客户端中的连接，并在控制台按 ENTER 键退出代理，并将数据包数据写入 *packets.bin*
    文件。（保留此文件的副本，我们稍后在客户端和服务器中会需要它。）
- en: '**Implementing a Simple Network Client**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实现一个简单的网络客户端**'
- en: Next, we’ll use the captured traffic to implement a simple network client. To
    do so, we’ll use the `NetClientTemplate` class to establish a new connection to
    the server and provide us with an interface to read and write network packets.
    Copy [Listing 8-6](../Text/ch08.xhtml#ch8list6) into a file named *chapter8_client.csx*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用捕获的流量实现一个简单的网络客户端。为此，我们将使用`NetClientTemplate`类来建立与服务器的新连接，并提供一个接口来读取和写入网络数据包。将[列表
    8-6](../Text/ch08.xhtml#ch8list6)复制到一个名为*chapter8_client.csx*的文件中。
- en: chapter8
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: chapter8
- en: _client.csx
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: _client.csx
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 8-6: A simple client to replace SuperFunkyChat traffic*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-6：一个简单的客户端，用于替换SuperFunkyChat流量*'
- en: One new bit in this code is that each script gets a list of command line arguments
    in the `args` variable ➊. By using command line arguments, we can specify different
    packet capture files without having to modify the script.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的一个新内容是，每个脚本都会在`args`变量中获取一个命令行参数列表➊。通过使用命令行参数，我们可以指定不同的数据包捕获文件，而无需修改脚本。
- en: The `NetClientTemplate` is configured ➋ similarly to our proxy, making connections
    to 127.0.0.1:12345 but with a few differences to support the client. For example,
    because we parse the initial network traffic inside the `Parser` class, our capture
    file doesn’t contain the initial magic value that the client sends to the server.
    We add an `InitialData` array to the template with the magic bytes ➌ to correctly
    establish the connection.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetClientTemplate`的配置方式➋与我们的代理类似，连接到127.0.0.1:12345，但有一些区别以支持客户端。例如，由于我们在`Parser`类中解析初始网络流量，我们的捕获文件不包含客户端发送给服务器的初始魔术值。我们向模板中添加了一个包含魔术字节➌的`InitialData`数组，以正确建立连接。'
- en: We then read the packets from the file ➍ into a packet collection. When everything
    is configured, we call `Connect()` to establish a new connection to the server
    ➎. The `Connect()` method returns a `Data Adapter` that allows us to read and
    write parsed packets on the connection. Any packet we read will also go through
    the `Parser` and remove the length and checksum fields.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从文件中读取数据包➍到一个数据包集合中。当一切配置完成后，我们调用`Connect()`方法来与服务器建立新连接➎。`Connect()`方法返回一个`Data
    Adapter`，允许我们在连接上读取和写入解析后的数据包。我们读取的任何数据包也将经过`Parser`处理，并移除长度和校验和字段。
- en: Next, we filter the loaded packets to only outbound and write them to the network
    connection ➏. The `Parser` class again ensures that any data packets we write
    have the appropriate headers attached before being sent to the server. Finally,
    we read out packets and print them to the console until the connection is closed
    or the read times out ➐.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们筛选加载的包，只保留出站包，并将其写入网络连接➏。`Parser`类再次确保我们写入的任何数据包都附带适当的头信息，然后才会发送到服务器。最后，我们读取包并将其打印到控制台，直到连接关闭或读取超时➐。
- en: When you run this script, passing the path to the packets we captured earlier,
    it should connect to the server and replay your session. For example, any message
    sent in the original capture should be re-sent.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个脚本并传入我们之前捕获的数据包路径时，它应该能够连接到服务器并重放你的会话。例如，原始捕获中发送的任何消息应该会被重新发送。
- en: Of course, just replaying the original traffic isn’t necessarily that useful.
    It would be more useful to modify traffic to test features of the protocol, and
    now that we have a very simple client, we can modify the traffic by adding some
    code to our send loop. For example, we might simply change our username in all
    packets to something else—say from `user1` to `bobsmith`—by replacing the inner
    code of the send loop (at ➏ in Listing 8-6) with the code shown in Listing 8-7.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅回放原始流量并不一定那么有用。更有用的做法是修改流量来测试协议的特性，既然我们已经有了一个非常简单的客户端，我们可以通过向发送循环中添加一些代码来修改流量。例如，我们可能会简单地将所有数据包中的用户名更改为其他名称——比如从`user1`改为`bobsmith`——通过将发送循环（在列表
    8-6中的➏处）的内部代码替换为列表 8-7中显示的代码。
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-7: A simple packet editor for the client*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7：一个简单的客户端数据包编辑器*'
- en: To edit the username, we first convert the packet into a format we can work
    with easily. In this case, we convert it to a binary string using the `ToDataString()`
    method ➊, which results in a C# string where each byte is converted directly to
    the same character value. Because the strings in SuperFunkyChat are prefixed with
    their length, at ➋ we use the `\uXXXX` escape sequence to replace the byte 5 with
    8 for the new length of the username. You can replace any nonprintable binary
    character in the same way, using the escape sequence for the byte values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑用户名，我们首先将数据包转换为一种便于处理的格式。在这种情况下，我们使用 `ToDataString()` 方法 ➊ 将其转换为二进制字符串，这样就得到了一个
    C# 字符串，其中每个字节直接转换为相同的字符值。由于 SuperFunkyChat 中的字符串以它们的长度为前缀，因此在 ➋ 处我们使用 `\uXXXX`
    转义序列将字节 5 替换为 8，以表示新用户名的长度。你可以通过相同的方式替换任何不可打印的二进制字符，使用字节值的转义序列。
- en: When you rerun the client, all instances of `user1` should be replaced with
    `bobsmith`. (Of course, you can do far more complicated packet modification at
    this point, but I’ll leave that for you to experiment with.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新运行客户端时，所有的 `user1` 实例应该都被替换为 `bobsmith`。（当然，你此时可以做更复杂的数据包修改，但我会留给你去实验。）
- en: '**Implementing a Simple Server**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实现一个简单的服务器**'
- en: We’ve implemented a simple client, but security issues can occur in both the
    client and server applications. So now we’ll implement a custom server similar
    to what we’ve done for the client.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了一个简单的客户端，但在客户端和服务器应用程序中都可能出现安全问题。所以现在我们将实现一个自定义服务器，类似于我们为客户端所做的。
- en: First, we’ll implement a small class to act as our server code. This class will
    be created for every new connection. A `Run()` method in the class will get a
    `Data Adapter` object, essentially the same as the one we used for the client.
    Copy [Listing 8-8](../Text/ch08.xhtml#ch8list8) into a file called *chat_server.csx*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现一个小类来充当我们的服务器代码。每当有新的连接时，该类都会被创建。类中的 `Run()` 方法将获取一个 `Data Adapter`
    对象，基本上与我们为客户端使用的相同。将 [列表 8-8](../Text/ch08.xhtml#ch8list8) 复制到一个名为 *chat_server.csx*
    的文件中。
- en: chat_server.csx
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: chat_server.csx
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 8-8: A simple server class for chat protocol*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-8：一个简单的聊天协议服务器类*'
- en: The code at ➊ is a configuration class that simply contains a log packet collection.
    We could have simplified the code by just specifying `LogPacketCollection` as
    the configuration type, but doing so with a distinct class demonstrates how you
    might add your own configuration more easily.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 ➊ 是一个配置类，简单地包含一个日志数据包集合。我们本可以通过直接指定 `LogPacketCollection` 作为配置类型来简化代码，但通过使用一个单独的类来演示如何更轻松地添加自定义配置。
- en: The code at ➋ defines the server class. It contains the `Run()` function, which
    takes a data adapter and the server configuration, and allows us to read and write
    to the data adapter after waiting for the client to send us a packet ➌. Once we’ve
    received a packet, we immediately send our entire packet list to the client ➍.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 ➋ 定义了服务器类。它包含 `Run()` 函数，该函数接收一个数据适配器和服务器配置，并允许我们在等待客户端发送数据包 ➌ 后，读写数据适配器。一旦接收到数据包，我们会立即将整个数据包列表发送给客户端
    ➍。
- en: Note that we don’t filter the packets at ➍, and we don’t specify that we’re
    using any particular parser for the network traffic. In fact, this entire class
    is completely agnostic to the SuperFunkyChat protocol. We configure much of the
    behavior for the network server inside a template, as shown in Listing 8-9.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在 ➍ 处并没有过滤数据包，也没有指定使用任何特定的解析器来处理网络流量。事实上，这整个类对于 SuperFunkyChat 协议完全是独立的。我们在模板中配置了大部分网络服务器的行为，如列表
    8-9 所示。
- en: chapter8
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: chapter8
- en: _example
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: _example
- en: _server.csx
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: _server.csx
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 8-9: A simple example ChatServer*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-9：一个简单的 ChatServer 示例*'
- en: '[Listing 8-9](../Text/ch08.xhtml#ch8list9) might look familiar because it’s
    very similar to the script we used for the DNS server in [Listing 2-11](../Text/ch02.xhtml#ch2list11).
    We begin by loading in the *chat_server.csx* script to define our ChatServer class
    ➊. Next, we create a server template at ➋ by specifying the type of the server
    and the configuration type. Then we load the packets from the file passed on the
    command line, filtering to capture only inbound packets and adding them to the
    packet collection in the configuration ➌. Finally, we create a service and start
    it ➍, just as we do proxies. The server is now listening for new connections on
    TCP port 12345.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8-9](../Text/ch08.xhtml#ch8list9)可能看起来很熟悉，因为它与我们在[列表2-11](../Text/ch02.xhtml#ch2list11)中使用的DNS服务器脚本非常相似。我们首先加载*chat_server.csx*脚本来定义我们的ChatServer类
    ➊。接着，我们在 ➋ 处创建服务器模板，通过指定服务器类型和配置类型。然后，我们从命令行传递的文件中加载数据包，过滤以捕获仅入站数据包并将其添加到配置中的数据包集合
    ➌。最后，我们创建服务并启动它 ➍，就像我们做代理一样。服务器现在在TCP端口12345上监听新的连接。'
- en: Try the server with the ChatClient application; the captured traffic should
    be sent back to the client. After all the data has been sent to the client, the
    server will automatically close the connection. As long as you observe the message
    we re-sent, don’t worry if you see an error in the ChatClient’s output. Of course,
    you can add functionality to the server, such as modifying traffic or generating
    new packets.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用ChatClient应用程序连接服务器；捕获的流量应被发送回客户端。当所有数据发送到客户端后，服务器将自动关闭连接。只要你观察我们重新发送的消息，不必担心在ChatClient的输出中看到错误。当然，你可以向服务器添加功能，比如修改流量或生成新数据包。
- en: '**Repurposing Existing Executable Code**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**重用现有可执行代码**'
- en: In this section, we’ll explore various ways to repurpose existing binary executable
    code to reduce the amount of work involved in implementing a protocol. Once you’ve
    determined a protocol’s details by reverse engineering the executable (perhaps
    using some tips from [Chapter 6](../Text/ch06.xhtml#ch06)), you’ll quickly realize
    that if you can reuse the executable code, you’ll avoid having to implement the
    protocol.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨多种方法，利用现有的二进制可执行代码来减少实现协议所需的工作量。一旦你通过反向工程（可能参考了[第6章](../Text/ch06.xhtml#ch06)的一些技巧）确定了协议的详细信息，你会很快意识到，如果你能重用可执行代码，就能避免重新实现协议。
- en: Ideally, you’ll have the source code you’ll need to implement a particular protocol,
    either because it’s open source or the implementation is in a scripting language
    like Python. If you do have the source code, you should be able to recompile or
    directly reuse the code in your own application. However, when the code has been
    compiled into a binary executable, your options can be more limited. We’ll look
    at each scenario now.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你会拥有实现特定协议所需的源代码，要么是因为它是开源的，要么是因为实现使用像Python这样的脚本语言。如果你确实拥有源代码，你应该能够重新编译或直接在自己的应用程序中重用这些代码。然而，当代码已经编译成二进制可执行文件时，你的选择可能会更有限。现在我们来看一下每种情况。
- en: Managed language platforms, such as .NET and Java, are by far the easiest in
    which to reuse existing executable code, because they have a well-defined metadata
    structure in compiled code that allows a new application to be compiled against
    internal classes and methods. In contrast, in many unmanaged platforms, such as
    C/C++, the compiler will make no guarantees that any component inside a binary
    executable can be easily called externally.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 管理语言平台，如.NET和Java，是最容易重用现有可执行代码的平台，因为它们的编译代码中有明确定义的元数据结构，允许新的应用程序针对内部类和方法进行编译。相比之下，在许多非托管平台中，比如C/C++，编译器无法保证二进制可执行文件中的任何组件可以轻松地从外部调用。
- en: Well-defined metadata also supports *reflection*, which is the ability of an
    application to support late binding of executable code to inspect data at runtime
    and to execute arbitrary methods. Although you can easily decompile many managed
    languages, it may not always be convenient to do so, especially when dealing with
    obfuscated applications. This is because the obfuscation can prevent reliable
    decompilation to usable source code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 明确定义的元数据还支持*反射*，即应用程序能够支持执行代码的延迟绑定，检查运行时数据并执行任意方法。虽然你可以轻松地反编译许多托管语言，但这并不总是方便，尤其是在处理混淆过的应用程序时。因为混淆可能会阻止可靠地反编译为可用的源代码。
- en: Of course, the parts of the executable code you’ll need to execute will depend
    on the application you’re analyzing. In the sections that follow, I’ll detail
    some coding patterns and techniques to use to call the appropriate parts of the
    code in .NET and Java applications, the platforms you’re most likely to encounter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要执行的可执行代码部分将取决于你正在分析的应用程序。在接下来的章节中，我将详细介绍一些编码模式和技巧，如何在 .NET 和 Java 应用程序中调用代码的适当部分，这些平台是你最有可能遇到的。
- en: '***Repurposing Code in .NET Applications***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在 .NET 应用程序中重用代码***'
- en: As discussed in [Chapter 6](../Text/ch06.xhtml#ch06), .NET applications are
    made up of one or more assemblies, which can be either an executable (with an
    .*exe* extension) or a library (.*dll*). When it comes to repurposing existing
    code, the form of the assembly doesn’t matter because we can call methods in both
    equally.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第 6 章](../Text/ch06.xhtml#ch06)中讨论的，.NET 应用程序由一个或多个程序集组成，这些程序集可以是可执行文件（扩展名为
    .*exe*）或库（扩展名为 .*dll*）。当涉及到重用现有代码时，程序集的形式并不重要，因为我们可以同样调用两者中的方法。
- en: Whether we can just compile our code against the assembly’s code will depend
    on the visibility of the types we’re trying to use. The .NET platform supports
    different visibility scopes for types and members. The three most important forms
    of visibility scope are public, private, and internal. Public types or members
    are available to all callers outside the assembly. Private types or members are
    limited in scope to the current type (for example, you can have a private class
    inside a public class). Internal visibility scopes the types or members to only
    callers inside the same assembly, where they act as if they were public (although
    an external call cannot compile against them). For example, consider the C# code
    in Listing 8-10.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 是否能够直接编译我们的代码与程序集的代码，取决于我们尝试使用的类型的可见性。 .NET 平台支持不同的类型和成员可见性范围。三种最重要的可见性范围是 public、private
    和 internal。公共类型或成员对程序集外部的所有调用者可用。私有类型或成员的作用范围仅限于当前类型（例如，你可以在一个公共类中包含一个私有类）。内部可见性将类型或成员的范围限定为同一程序集中的调用者，在此范围内，它们的作用类似于公共类型（尽管外部调用无法编译使用它们）。例如，考虑清单
    8-10 中的 C# 代码。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-10: Examples of .NET visibility scopes*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-10：.NET 可见性范围示例*'
- en: '[Listing 8-10](../Text/ch08.xhtml#ch8list10) defines a total of three classes:
    one public, one private, and one internal. When you compile against the assembly
    containing these types, only `PublicClass` can be directly accessed along with
    the class’s `PublicMethod()` (indicated by ➊ and ➍); attempting to access any
    other type or member will generate an error in the compiler. But notice at ➋ and
    ➌ that public members are defined. Can’t we also access those members? Unfortunately,
    no, because these members are contained inside the scope of a `PrivateClass` or
    `InternalClass`. The class’s scope takes precedence over the members’ visibility.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-10](../Text/ch08.xhtml#ch8list10) 定义了三种类型：一个公共的、一个私有的和一个内部的。当你对包含这些类型的程序集进行编译时，只有
    `PublicClass` 及其类的 `PublicMethod()`（由 ➊ 和 ➍ 指示）可以直接访问；尝试访问任何其他类型或成员将导致编译器错误。但注意在
    ➋ 和 ➌ 处定义了公共成员。难道我们不能访问这些成员吗？不幸的是，不能，因为这些成员包含在 `PrivateClass` 或 `InternalClass`
    的作用范围内。类的作用范围优先于成员的可见性。'
- en: Once you’ve determined whether all the types and members you want to use are
    public, you can add a reference to the assembly when compiling. If you’re using
    an IDE, you should find a method that allows you to add this reference to your
    project. But if you’re compiling on the command line using Mono or the Windows
    .NET framework, you’ll need to specify the `-reference:<FILEPATH`> option to the
    appropriate C# compiler, CSC or MCS.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了所有你想使用的类型和成员是否为公共的，你就可以在编译时添加对该程序集的引用。如果你正在使用 IDE，你应该能找到一种方法来将此引用添加到你的项目中。但如果你在命令行上使用
    Mono 或 Windows .NET 框架进行编译，你将需要向适当的 C# 编译器（CSC 或 MCS）指定 `-reference:<FILEPATH>`
    选项。
- en: '**Using the Reflection APIs**'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用反射 API**'
- en: If all the types and members are not public, you’ll need to use the .NET framework’s
    Reflection APIs. You’ll find most of these in the `System.Reflection` namespace,
    except for the `Type` class, which is under the `System` namespace. [Table 8-1](../Text/ch08.xhtml#ch8tab1)
    lists the most important classes with respect to reflection functionality.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有类型和成员都不是公开的，你将需要使用 .NET 框架的反射 API。你会在 `System.Reflection` 命名空间中找到大多数这些 API，除了
    `Type` 类，它位于 `System` 命名空间中。[表 8-1](../Text/ch08.xhtml#ch8tab1) 列出了与反射功能相关的最重要的类。
- en: '**Table 8-1:** .NET Reflection Types'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** .NET 反射类型'
- en: '| **Class name** | **Description** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **类名** | **描述** |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `System.Type` | Represents a single type in an assembly and allows access
    to information about its members |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `System.Type` | 代表程序集中的单个类型，并允许访问其成员的信息 |'
- en: '| `System.Reflection.Assembly` | Allows access to loading and inspecting an
    assembly as well as enumerating available types |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `System.Reflection.Assembly` | 允许访问加载和检查程序集，以及枚举可用类型 |'
- en: '| `System.Reflection.MethodInfo` | Represents a method in a type |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `System.Reflection.MethodInfo` | 代表类型中的一个方法 |'
- en: '| `System.Reflection.FieldInfo` | Represents a field in a type |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `System.Reflection.FieldInfo` | 代表类型中的一个字段 |'
- en: '| `System.Reflection.PropertyInfo` | Represents a property in a type |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `System.Reflection.PropertyInfo` | 代表类型中的一个属性 |'
- en: '| `System.Reflection.ConstructorInfo` | Represents a class’s constructor |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `System.Reflection.ConstructorInfo` | 代表一个类的构造函数 |'
- en: '**Loading the Assembly**'
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加载程序集**'
- en: Before you can do anything with the types and members, you’ll need to load the
    assembly using the `Load()` or the `LoadFrom()` method on the `Assembly` class.
    The `Load()` method takes an *assembly name*, which is an identifier for the assembly
    that assumes the assembly file can be found in the same location as the calling
    application. The `LoadFrom()` method takes the path to the assembly file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以对类型和成员进行任何操作之前，您需要使用`Assembly`类中的`Load()`或`LoadFrom()`方法加载程序集。`Load()`方法接受一个*程序集名称*，它是程序集的标识符，假设程序集文件可以在与调用应用程序相同的位置找到。`LoadFrom()`方法接受程序集文件的路径。
- en: For the sake of simplicity, we’ll use `LoadFrom()`, which you can use in most
    cases. [Listing 8-11](../Text/ch08.xhtml#ch8list11) shows a simple example of
    how you might load an assembly from a file and extract a type by name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将使用`LoadFrom()`方法，这在大多数情况下都可以使用。[清单 8-11](../Text/ch08.xhtml#ch8list11)展示了如何从文件加载程序集并通过名称提取类型的简单示例。
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 8-11: A simple assembly loading example*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-11：一个简单的程序集加载示例*'
- en: The name of the type is always the fully qualified name including its namespace.
    For example, in [Listing 8-11](../Text/ch08.xhtml#ch8list11), the name of the
    type being accessed is `Connection` inside the `ChatProgram` namespace. Each part
    of the type name is separated by periods.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类型的名称始终是完全限定名称，包括其命名空间。例如，在[清单 8-11](../Text/ch08.xhtml#ch8list11)中，被访问的类型的名称是`ChatProgram`命名空间中的`Connection`。类型名称的每个部分之间由句点分隔。
- en: 'How do you access classes that are declared inside other classes, such as those
    shown in [Listing 8-10](../Text/ch08.xhtml#ch8list10)? In C#, you access these
    by specifying the parent class name and the child class name separated by periods.
    The framework is able to differentiate between `ChatProgram.Connection`, where
    we want the class `Connection` in namespace `ChatProgram`, and the child class
    `Connection` inside the class `ChatProgram` by using a plus (`+`) symbol: `ChatProgram+Connection`
    represents a parent/child class relationship.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如何访问声明在其他类内部的类，例如在[清单 8-10](../Text/ch08.xhtml#ch8list10)中所示的那些类？在 C# 中，您可以通过指定父类名称和子类名称，并用句点分隔来访问它们。框架能够区分`ChatProgram.Connection`，其中我们想要在`ChatProgram`命名空间中获取`Connection`类，和类`ChatProgram`内部的子类`Connection`，通过使用加号（`+`）符号：`ChatProgram+Connection`表示父类/子类关系。
- en: '[Listing 8-12](../Text/ch08.xhtml#ch8list12) shows a simple example of how
    we might create an instance of an internal class and call methods on it. We’ll
    assume that the class is already compiled into its own assembly.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-12](../Text/ch08.xhtml#ch8list12)展示了如何创建一个内部类的实例并调用它的方法的简单示例。我们假设该类已经编译到自己的程序集里。'
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 8-12: A simple C# example class*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-12：一个简单的 C# 示例类*'
- en: The first step we need to take is to create an instance of this `Connection`
    class. We could do this by calling `GetConstructor` on the type and calling it
    manually, but sometimes there’s an easier way. One way would be to use the built-in
    `System.Activator` class to handle creating instances of types for us, at least
    in very simple scenarios. In such a scenario, we call the method `CreateInstance()`,
    which takes an instance of the type to create and a Boolean value that indicates
    whether the constructor is public or not. Because the constructor is not public
    (it’s internal), we need to pass `true` to get the activator to find the right
    constructor.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的第一步是创建一个`Connection`类的实例。我们可以通过在类型上调用`GetConstructor`并手动调用它来实现，但有时候有更简单的方法。一个方法是使用内置的`System.Activator`类来处理类型实例的创建，至少在非常简单的场景下是这样。在这种情况下，我们调用`CreateInstance()`方法，它接受要创建的类型实例和一个布尔值，表示构造函数是否公开。由于构造函数是非公开的（它是内部的），我们需要传递`true`来让激活器找到正确的构造函数。
- en: '[Listing 8-13](../Text/ch08.xhtml#ch8list13) shows how to create a new instance,
    assuming a nonpublic parameterless constructor.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-13](../Text/ch08.xhtml#ch8list13)展示了如何创建一个新的实例，假设有一个非公开的无参构造函数。'
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 8-13: Constructing a new instance of the `Connection` object*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-13：构造一个新的`Connection`对象实例*'
- en: At this point, we would call the public `Connect()` method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，我们会调用公开的`Connect()`方法。
- en: In the possible methods of the `Type` class, you’ll find the `GetMethod()` method,
    which just takes the name of the method to look up and returns an instance of
    a `MethodInfo` type. If the method cannot be found, null is returned. Listing
    8-14 shows how to execute the method by calling the `Invoke()` method on `MethodInfo`,
    passing the instance of the object to execute it on and the parameters to pass
    to the method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Type`类的可用方法中，你会找到`GetMethod()`方法，该方法只接受要查找的方法名，并返回一个`MethodInfo`类型的实例。如果找不到该方法，则返回null。示例
    8-14展示了如何通过调用`MethodInfo`的`Invoke()`方法来执行该方法，传入要执行的方法实例及其参数。
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 8-14: Executing a method on a `Connection` object*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-14：在`Connection`对象上执行方法*'
- en: The simplest form of `GetMethod()` takes as a parameter the name of the method
    to find, but it will look for only public methods. If instead you want to call
    the private `Connect()` method to be able to specify an arbitrary TCP port, use
    one of the various overloads of `GetMethod()`. These overloads take a `BindingFlags`
    enumeration value, which is a set of flags you can pass to reflection functions
    to determine what sort of information you want to look up. [Table 8-2](../Text/ch08.xhtml#ch8tab2)
    shows some important flags.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetMethod()`的最简单形式接受一个参数——要查找的方法名称，但它只会查找公开方法。如果你想调用私有的`Connect()`方法，以便能够指定任意的TCP端口，可以使用`GetMethod()`的各种重载之一。这些重载接受一个`BindingFlags`枚举值，这是一个你可以传递给反射函数的标志集合，用于确定你想查找的信息种类。[表
    8-2](../Text/ch08.xhtml#ch8tab2)展示了一些重要的标志。'
- en: '**Table 8-2:** Important .NET Reflection Binding Flags'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-2：** 重要的 .NET 反射绑定标志'
- en: '| **Flag name** | **Description** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **标志名称** | **描述** |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `BindingFlags.Public` | Look up public members |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `BindingFlags.Public` | 查找公开成员 |'
- en: '| `BindingFlags.NonPublic` | Look up nonpublic members (internal or private)
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `BindingFlags.NonPublic` | 查找非公开成员（内部或私有） |'
- en: '| `BindingFlags.Instance` | Look up members that can only be used on an instance
    of the class |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `BindingFlags.Instance` | 查找只能在类的实例上使用的成员 |'
- en: '| `BindingFlags.Static` | Look up members that can be accessed statically without
    an instance |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `BindingFlags.Static` | 查找可以静态访问的成员，无需实例 |'
- en: To get a `MethodInfo` for the private method, we can use the overload of `GetMethod()`,
    as shown in [Listing 8-15](../Text/ch08.xhtml#ch8list15), which takes a name and
    the binding flags. We’ll need to specify both `NonPublic` and `Instance` in the
    flags because we want a nonpublic method that can be called on instances of the
    type.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取私有方法的`MethodInfo`，我们可以使用`GetMethod()`的重载，如[示例 8-15](../Text/ch08.xhtml#ch8list15)所示，该方法接受方法名和绑定标志。我们需要在标志中指定`NonPublic`和`Instance`，因为我们想要一个可以在类型实例上调用的非公开方法。
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 8-15: Calling a nonpublic `Connect()` method*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-15：调用一个非公开的`Connect()`方法*'
- en: So far so good. Now we need to call the `Send()` method. Because this method
    is public, we should be able to call the basic `GetMethod()` method. But calling
    the basic method generates the exception shown in Listing 8-16, indicating an
    ambiguous match. What’s gone wrong?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在我们需要调用`Send()`方法。由于这个方法是公共的，我们应该能够调用基本的`GetMethod()`方法。但调用基本方法会生成清单
    8-16中显示的异常，表明匹配存在歧义。出了什么问题？
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 8-16: An exception thrown for the `Send()` method*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-16：`Send()`方法抛出的异常*'
- en: 'Notice in [Listing 8-12](../Text/ch08.xhtml#ch8list12) the `Connection` class
    has two `Send()` methods: one takes an array of bytes and the other takes a string.
    Because the reflection API doesn’t know which method you want, it doesn’t return
    a reference to either; instead, it just throws an exception. Contrast this with
    the `Connect()` method, which worked because the binding flags disambiguate the
    call. If you’re looking up a public method with the name `Connect()`, the reflection
    APIs will not even inspect the nonpublic overload.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[清单 8-12](../Text/ch08.xhtml#ch8list12)中，`Connection`类有两个`Send()`方法：一个接受字节数组，另一个接受字符串。由于反射API不知道你想要哪个方法，它不会返回任何一个方法的引用；相反，它会抛出异常。与此对比，`Connect()`方法之所以能正常工作，是因为绑定标志消除了调用的歧义。如果你正在查找名为`Connect()`的公共方法，反射API甚至不会检查非公共的重载。
- en: We can get around this error by using yet another overload of `GetMethod()`
    that specifies exactly the types we want the method to support. We’ll choose the
    method that takes a string, as shown in [Listing 8-17](../Text/ch08.xhtml#ch8list17).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用另一个重载的`GetMethod()`来解决这个错误，该重载明确指定了我们希望方法支持的类型。我们将选择接受字符串的那个方法，如[清单
    8-17](../Text/ch08.xhtml#ch8list17)所示。
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 8-17: Calling the `Send(string)` method*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-17：调用`Send(string)`方法*'
- en: Finally, we can call the `Receive()` method. It’s public, so there are no additional
    overloads and it should be simple. Because `Receive()` takes no parameters, we
    can either pass an empty array or null to `Invoke()`. Because `Invoke()` returns
    an *object*, we need to cast the return value to a byte array to access the bytes
    directly. [Listing 8-18](../Text/ch08.xhtml#ch8list18) shows the final implementation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以调用`Receive()`方法。它是公共的，因此没有额外的重载，应该很简单。由于`Receive()`不接受任何参数，我们可以向`Invoke()`传递一个空数组或null。由于`Invoke()`返回一个*对象*，我们需要将返回值强制转换为字节数组，以便直接访问字节。[清单
    8-18](../Text/ch08.xhtml#ch8list18)展示了最终的实现。
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 8-18: Calling the `Receive()` method*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-18：调用`Receive()`方法*'
- en: '***Repurposing Code in Java Applications***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在Java应用中重新利用代码***'
- en: Java is fairly similar to .NET, so I’ll just focus on the difference between
    them, which is that Java does not have the concept of an assembly. Instead, each
    class is represented by a separate *.class* file. Although you can combine class
    files into a Java Archive (JAR) file, it is just a convenience feature. For that
    reason, Java does not have internal classes that can only be accessed by other
    classes in the same assembly. However, Java does have a somewhat similar feature
    called *package-private* scoped classes, which can only be accessed by classes
    in the same package. (.NET refers to packages as a *namespace*.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Java与.NET非常相似，因此我将专注于它们之间的区别，即Java没有程序集的概念。相反，每个类都由单独的*.class*文件表示。虽然你可以将类文件合并为一个Java归档（JAR）文件，但这仅仅是一个便利功能。由于这个原因，Java没有只能由同一程序集中的其他类访问的内部类。然而，Java有一个类似的功能，称为*包私有*作用域类，只能被同一包中的类访问。（.NET将包称为*命名空间*。）
- en: The upshot of this feature is that if you want to access classes marked as package
    scoped, you can write some Java code that defines itself in the same package,
    which can then access the package-scoped classes and members at will. For example,
    [Listing 8-19](../Text/ch08.xhtml#ch8list19) shows a package-private class that
    would be defined in the library you want to call and a simple bridge class you
    can compile into your own application to create an instance of the class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这一特性的结果是，如果你想访问标记为包作用域的类，你可以编写一些Java代码，将其定义在同一个包中，然后它就能随意访问包作用域的类和成员。例如，[清单
    8-19](../Text/ch08.xhtml#ch8list19)展示了一个包私有类，这个类会在你想要调用的库中定义，并且你可以编写一个简单的桥接类，将其编译到你自己的应用程序中，以创建该类的实例。
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 8-19: Implementing a bridge class to access a package-private class*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-19：实现一个桥接类以访问包私有类*'
- en: You specify the existing class or JAR files by adding their locations to the
    Java classpath, typically by specifying the `-classpath` parameter to the Java
    compiler or Java runtime executable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将现有的类或 JAR 文件的路径添加到 Java 类路径中来指定它们，通常是通过为 Java 编译器或 Java 运行时可执行文件指定 `-classpath`
    参数来完成的。
- en: 'If you need to call Java classes by reflection, the core Java reflection types
    are very similar to those described in the preceding .NET section: *Type* in .NET
    is *class* in Java, `MethodInfo` is `Method`, and so on. [Table 8-3](../Text/ch08.xhtml#ch8tab3)
    contains a short list of Java reflection types.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要通过反射调用 Java 类，核心的 Java 反射类型与前面 .NET 部分描述的类型非常相似：在 .NET 中的 *Type* 在 Java
    中对应 *class*，`MethodInfo` 对应 `Method`，以此类推。[表 8-3](../Text/ch08.xhtml#ch8tab3)
    包含了一个简短的 Java 反射类型列表。
- en: '**Table 8-3:** Java Reflection Types'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-3:** Java 反射类型'
- en: '| **Class name** | **Description** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **类名** | **描述** |'
- en: '| --- | --- |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `java.lang.Class` | Represents a single class and allows access to its members
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `java.lang.Class` | 表示单个类并允许访问其成员 |'
- en: '| `java.lang.reflect.Method` | Represents a method in a type |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `java.lang.reflect.Method` | 表示类型中的方法 |'
- en: '| `java.lang.reflect.Field` | Represents a field in a type |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `java.lang.reflect.Field` | 表示类型中的字段 |'
- en: '| `java.lang.reflect.Constructor` | Represents a class’s constructor |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `java.lang.reflect.Constructor` | 表示类的构造函数 |'
- en: You can access a class object by name by calling the `Class.forName()` method.
    For example, [Listing 8-20](../Text/ch08.xhtml#ch8list20) shows how we would get
    the `PackageClass`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `Class.forName()` 方法按名称访问类对象。例如，[清单 8-20](../Text/ch08.xhtml#ch8list20)
    展示了我们如何获取 `PackageClass`。
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 8-20: Getting a class in Java*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-20：在 Java 中获取类*'
- en: If we want to create an instance of a public class with a parameterless constructor,
    the `Class` instance has a `newInstance()` method. This won’t work for our package-private
    class, so instead we’ll get an instance of the `Constructor` by calling `getDeclaredConstructor()`
    on the `Class` instance. We need to pass a list of `Class` objects to `getDeclaredConstructor()`
    to select the correct Constructor based on the types of parameters the constructor
    accepts. [Listing 8-21](../Text/ch08.xhtml#ch8list21) shows how we would choose
    the constructor, which takes a string, and then create a new instance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个具有无参数构造函数的公共类实例，`Class` 实例有一个 `newInstance()` 方法。这个方法对于我们的包私有类不起作用，因此我们将通过调用
    `Class` 实例上的 `getDeclaredConstructor()` 来获取 `Constructor` 实例。我们需要将一组 `Class` 对象传递给
    `getDeclaredConstructor()`，以根据构造函数接受的参数类型选择正确的构造函数。[清单 8-21](../Text/ch08.xhtml#ch8list21)
    展示了我们如何选择一个接受字符串的构造函数，并创建一个新实例。
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 8-21: Creating a new instance from a private constructor*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-21：从私有构造函数创建新实例*'
- en: The code in [Listing 8-21](../Text/ch08.xhtml#ch8list21) should be fairly self-explanatory
    except perhaps for the line at ➊. In Java, any nonpublic member, whether a constructor,
    field, or method, must be set as accessible before you use it. If you don’t call
    `setAccessible()` with the value `true`, then calling `newInstance()` will throw
    an exception.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-21](../Text/ch08.xhtml#ch8list21) 中的代码应该相当容易理解，除了可能是 ➊ 处的那一行。在 Java 中，任何非公共成员，无论是构造函数、字段还是方法，都必须在使用前设置为可访问。如果没有调用
    `setAccessible()` 并将其值设置为 `true`，那么调用 `newInstance()` 将抛出异常。'
- en: '***Unmanaged Executables***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***未托管可执行文件***'
- en: Calling arbitrary code in most unmanaged executables is much more difficult
    than in managed platforms. Although you can call a pointer to an internal function,
    there’s a reasonable chance that doing so could crash your application. However,
    you can reasonably call the unmanaged implementation when it’s explicitly exposed
    through a dynamic library. This section offers a brief overview of using the built-in
    Python library ctypes to call an unmanaged library on a Unix-like platform and
    Microsoft Windows.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数未托管可执行文件中调用任意代码比在托管平台上要困难得多。尽管你可以调用指向内部函数的指针，但这样做有可能导致应用程序崩溃。然而，当通过动态库显式暴露未托管实现时，你可以合理地调用它。本节简要概述了如何在类
    Unix 平台和 Microsoft Windows 上使用内置的 Python 库 ctypes 调用未托管库。
- en: '**NOTE**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are many complicated scenarios that involve calling into unmanaged code
    using the Python ctypes library, such as passing string values or calling C++
    functions. You can find several detailed resources online, but this section should
    give you enough basics to interest you in learning more about how to use Python
    to call unmanaged libraries.*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*有许多复杂的场景涉及使用 Python ctypes 库调用未管理的代码，如传递字符串值或调用 C++ 函数。你可以在网上找到几个详细的资源，但这一部分应该能为你提供足够的基础，激发你进一步了解如何使用
    Python 调用未管理的库。*'
- en: '**Calling Dynamic Libraries**'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调用动态库**  '
- en: Linux, macOS, and Windows support dynamic libraries. Linux calls them object
    files (.*so*), macOS calls them dynamic libraries (.*dylib*), and Windows calls
    them dynamic link libraries (.*dll*). The Python ctypes library provides a mostly
    generic way to load all of these libraries into memory and a consistent syntax
    for defining how to call the exported function. Listing 8-22 shows a simple library
    written in C, which we’ll use as an example throughout the rest of the section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'Linux、macOS 和 Windows 都支持动态库。Linux 称其为目标文件（.*so*），macOS 称其为动态库（.*dylib*），而
    Windows 称其为动态链接库（.*dll*）。Python 的 ctypes 库提供了一种大多数通用的方式来加载所有这些库到内存中，并为定义如何调用导出函数提供一致的语法。Listing
    8-22展示了一个简单的用 C 编写的库，我们将用它作为接下来部分的示例。  '
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 8-22: The example C library* lib.c'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-22: 示例 C 库* lib.c  '
- en: 'You can compile the code in [Listing 8-22](../Text/ch08.xhtml#ch8list22) into
    an appropriate dynamic library for the platform you’re testing. For example, on
    Linux you can compile the library by installing a C compiler, such as GCC, and
    executing the following command in the shell, which will generate a shared library
    *lib.so*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以将[Listing 8-22](../Text/ch08.xhtml#ch8list22)中的代码编译成适合你测试平台的动态库。例如，在 Linux
    上，你可以通过安装 C 编译器（如 GCC），并在 shell 中执行以下命令，生成共享库*lib.so*：  '
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Loading a Library with Python**'
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Python 加载库**  '
- en: Moving to Python, we can load our library using the `ctypes.cdll.LoadLibrary()`
    method, which returns an instance of a loaded library with the exported functions
    attached to the instance as named methods. For example, Listing 8-23 shows how
    to call the `say_hello()` method from the library compiled in Listing 8-22.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '转到 Python，我们可以使用`ctypes.cdll.LoadLibrary()`方法加载我们的库，该方法返回一个已加载库的实例，并将导出的函数作为命名方法附加到实例上。例如，Listing
    8-23展示了如何调用在Listing 8-22中编译的库中的`say_hello()`方法。  '
- en: listing8-23.py
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'listing8-23.py  '
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 8-23: A simple Python example for calling a dynamic library*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-23: 一个简单的 Python 示例，用于调用动态库*  '
- en: Note that in order to load the library on Linux, you need to specify a path.
    Linux by default does not include the current directory in the library search
    order, so loading *lib.so* would fail. That is not the case on macOS or on Windows.
    On Windows, you can simply specify the name of the library after *cdll* and it
    will automatically add the *.dll* extension and load the library.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，为了在 Linux 上加载库，你需要指定路径。默认情况下，Linux 不会将当前目录包含在库搜索路径中，因此加载*lib.so*会失败。而在
    macOS 或 Windows 上则不是这样。在 Windows 上，你只需在*cdll*后指定库的名称，它会自动添加*.dll*扩展名并加载库。  '
- en: Let’s do some exploring. Load [Listing 8-23](../Text/ch08.xhtml#ch8list23) into
    a Python shell, for example, by running `execfile("listing8-23.py")`, and you’ll
    see that `Hello` is returned. Keep the interactive session open for the next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们来做些探索。例如，将[Listing 8-23](../Text/ch08.xhtml#ch8list23)加载到 Python shell 中，通过运行`execfile("listing8-23.py")`，你会看到返回`Hello`。保持交互式会话打开，进入下一部分。  '
- en: '**Calling More Complicated Functions**'
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调用更复杂的函数**  '
- en: It’s easy enough to call a simple method, such as `say_hello()`, as in Listing
    8-23\. But in this section, we’ll look at how to call slightly more complicated
    functions including unmanaged functions, which take multiple different arguments.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '调用简单方法（如`say_hello()`）非常容易，如Listing 8-23所示。但在这一部分，我们将探讨如何调用稍微复杂一些的函数，包括未管理的函数，这些函数接受多个不同的参数。  '
- en: Wherever possible, ctypes will attempt to determine what parameters are passed
    to the function automatically based on the parameters you pass in the Python script.
    Also, the library will always assume that the return type of a method is a C integer.
    For example, [Listing 8-24](../Text/ch08.xhtml#ch8list24) shows how to call the
    `add_numbers()` or `say_string()` methods along with the expected output from
    the interactive session.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，ctypes将尝试根据您在Python脚本中传递的参数确定自动传递给函数的参数。此外，该库始终假定方法的返回类型是C整数。例如，[清单
    8-24](../Text/ch08.xhtml#ch8list24)展示了如何调用`add_numbers()`或`say_string()`方法以及交互会话的预期输出。
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 8-24: Calling simple methods*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-24：调用简单方法*'
- en: More complex methods require the use of ctypes data types to explicitly specify
    what types we want to use as defined in the ctypes namespace. [Table 8-4](../Text/ch08.xhtml#ch8tab4)
    shows some of the more common data types.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的方法需要使用ctypes数据类型来明确指定我们希望在ctypes命名空间中使用的类型。[表 8-4](../Text/ch08.xhtml#ch8tab4)
    展示了一些常见的数据类型。
- en: '**Table 8-4:** Python ctypes and Their Native C Type Equivalent'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-4：Python ctypes及其本地C类型等效**'
- en: '| **Python ctypes** | **Native C types** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **Python ctypes** | **本地C类型** |'
- en: '| --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `c_char`, `c_wchar` | char, wchar_t |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `c_char`, `c_wchar` | char，wchar_t |'
- en: '| `c_byte`, `c_ubyte` | char, unsigned char |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `c_byte`, `c_ubyte` | char，无符号字符 |'
- en: '| `c_short`, `c_ushort` | short, unsigned short |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `c_short`, `c_ushort` | 短整型，无符号短整型 |'
- en: '| `c_int`, `c_uint` | int, unsigned int |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `c_int`, `c_uint` | 整型，无符号整型 |'
- en: '| `c_long`, `c_ulong` | long, unsigned long |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `c_long`, `c_ulong` | 长整型，无符号长整型 |'
- en: '| `c_longlong`, `c_ulonglong` | long long, unsigned long long (typically 64
    bit) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `c_longlong`, `c_ulonglong` | 长长整型，无符号长长整型（通常为64位） |'
- en: '| `c_float`, `c_double` | float, double |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `c_float`, `c_double` | 浮点型，双精度型 |'
- en: '| `c_char_p`, `c_wchar_p` | char*, wchar_t* (NUL terminated strings) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `c_char_p`, `c_wchar_p` | char*，wchar_t*（以NUL结尾的字符串） |'
- en: '| `c_void_p` | void* (generic pointer) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `c_void_p` | void*（通用指针） |'
- en: To specify the return type, we can assign a data type to the `lib.name.restype`
    property. For example, [Listing 8-25](../Text/ch08.xhtml#ch8list25) shows how
    to call `get_hello()`, which returns a pointer to a string.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定返回类型，我们可以将数据类型分配给`lib.name.restype`属性。例如，[清单 8-25](../Text/ch08.xhtml#ch8list25)展示了如何调用`get_hello()`，它返回一个指向字符串的指针。
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 8-25: Calling a method that returns a C string*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-25：调用返回C字符串的方法*'
- en: If instead you want to specify the arguments to be passed to a method, you can
    set an array of data types to the `argtypes` property. For example, [Listing 8-26](../Text/ch08.xhtml#ch8list26)
    shows how to call `add_longs()` correctly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您希望指定要传递给方法的参数，可以将数据类型数组设置为`argtypes`属性。例如，[清单 8-26](../Text/ch08.xhtml#ch8list26)展示了如何正确调用`add_longs()`。 '
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 8-26: Specifying `argtypes` for a method call*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-26：为方法调用指定`argtypes`*'
- en: To pass a parameter via a pointer, use the `byref` helper. For example, `add_numbers_result()`
    returns the value as a pointer to an integer, as shown in [Listing 8-27](../Text/ch08.xhtml#ch8list27).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过指针传递参数，请使用`byref`助手。例如，`add_numbers_result()`将值作为整数指针返回，如[清单 8-27](../Text/ch08.xhtml#ch8list27)所示。
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 8-27: Calling a method with a reference parameter*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-27：调用带引用参数的方法*'
- en: '**Calling a Function with a Structure Parameter**'
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用结构参数调用函数**'
- en: We can define a structure for ctypes by creating a class derived from the `Structure`
    class and assigning the `_fields_ property`, and then pass the structure to the
    imported method. [Listing 8-28](../Text/ch08.xhtml#ch8list28) shows how to do
    this for the `say_struct()` function, which takes a pointer to a structure containing
    a string and a number.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建从`Structure`类派生的类并分配`_fields_`属性来为ctypes定义结构，然后将结构传递给导入方法。[清单 8-28](../Text/ch08.xhtml#ch8list28)展示了如何为接受包含字符串和数字的结构体指针的`say_struct()`函数执行此操作。
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 8-28: Calling a method taking a structure*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-28：调用接受结构体的方法*'
- en: '**Calling Functions with Python on Microsoft Windows**'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在Microsoft Windows上使用Python调用函数**'
- en: In this section, information on calling unmanaged libraries on Windows is specific
    to 32-bit Windows. As discussed in [Chapter 6](../Text/ch06.xhtml#ch06), Windows
    API calls can specify a number of different calling conventions, the most common
    being *stdcall* and *cdecl*. By using *cdll*, all calls assume that the function
    is *cdecl*, but the property *windll* defaults instead to *stdcall*. If a DLL
    exports both *cdecl* and *stdcall* methods, you can mix calls through *cdll* and
    *windll* as necessary.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，关于在 Windows 上调用非托管库的信息特指 32 位 Windows。如 [第 6 章](../Text/ch06.xhtml#ch06)
    中讨论的，Windows API 调用可以指定多种不同的调用约定，最常见的是 *stdcall* 和 *cdecl*。通过使用 *cdll*，所有调用都假定函数是
    *cdecl*，而 *windll* 属性则默认为 *stdcall*。如果一个 DLL 同时导出 *cdecl* 和 *stdcall* 方法，你可以根据需要通过
    *cdll* 和 *windll* 混合调用。
- en: '**NOTE**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll need to consider more calling scenarios using the Python ctypes library,
    such as how to pass back strings or call C++ functions. You can find many detailed
    resources online, but this section should have given you enough basics to interest
    you in learning more about how to use Python to call unmanaged libraries.*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*你需要考虑使用 Python ctypes 库时的更多调用场景，例如如何传回字符串或调用 C++ 函数。你可以在线找到许多详细资源，但这一部分应该已经为你提供了足够的基础，足以激发你进一步了解如何使用
    Python 调用非托管库的兴趣。*'
- en: '**Encryption and Dealing with TLS**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加密与处理 TLS**'
- en: Encryption on network protocols can make it difficult for you to perform protocol
    analysis and reimplement the protocol to test for security issues. Fortunately,
    most applications don’t roll their own cryptography. Instead, they utilize a version
    of TLS, as described at the end of [Chapter 7](../Text/ch07.xhtml#ch07). Because
    TLS is a known quantity, we can often remove it from a protocol or reimplement
    it using standard tools and libraries.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议中的加密可能会让你很难进行协议分析并重新实现协议以测试安全性问题。幸运的是，大多数应用程序并没有自行开发加密技术，而是使用了 TLS 的一个版本，如
    [第 7 章](../Text/ch07.xhtml#ch07) 结尾所描述的那样。由于 TLS 是一个已知的标准，我们通常可以将其从协议中去除，或者使用标准工具和库重新实现它。
- en: '***Learning About the Encryption In Use***'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***了解正在使用的加密方式***'
- en: Perhaps unsurprisingly, SuperFunkyChat has support for a TLS endpoint, although
    you need to configure it by passing the path to a server certificate. The binary
    distribution of SuperFunkyChat comes with a *server.pfx* for this purpose. Restart
    the `ChatServer` application with the `--server_cert` parameter, as shown in [Listing
    8-29](../Text/ch08.xhtml#ch8list29), and observe the output to ensure that TLS
    has been enabled.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 或许不足为奇，SuperFunkyChat 支持 TLS 端点，尽管你需要通过传递服务器证书的路径来进行配置。SuperFunkyChat 的二进制分发包自带了一个
    *server.pfx* 文件用于此目的。按照 [列表 8-29](../Text/ch08.xhtml#ch8list29) 中所示，使用 `--server_cert`
    参数重启 `ChatServer` 应用程序，并观察输出以确保 TLS 已启用。
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 8-29: Running ChatServer with a TLS certificate*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-29：使用 TLS 证书运行 ChatServer*'
- en: Two indications in the output of [Listing 8-29](../Text/ch08.xhtml#ch8list29)
    show that TLS has been enabled. First, the subject name of the server certificate
    is shown at ➊. Second, you can see that TLS server is listening on port 12346
    ➋.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-29](../Text/ch08.xhtml#ch8list29) 输出中的两个指示表明已经启用了 TLS。首先，服务器证书的主题名称显示在
    ➊ 位置。其次，你可以看到 TLS 服务器正在端口 12346 上监听 ➋。'
- en: 'There’s no need to specify the port number when connecting the client using
    TLS with the `--tls` parameter: the client will automatically increment the port
    number to match. [Listing 8-30](../Text/ch08.xhtml#ch8list30) shows how when you
    add the `--tls` command line parameter to the client, it displays basic information
    about the connection to the console.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 连接客户端时使用 `--tls` 参数不需要指定端口号：客户端会自动递增端口号以匹配。 [列表 8-30](../Text/ch08.xhtml#ch8list30)
    显示了当你在客户端添加 `--tls` 命令行参数时，如何在控制台显示关于连接的基本信息。
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 8-30: A normal client connection*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-30：正常的客户端连接*'
- en: In this output, the TLS protocol in use is shown at ➊ as TLS 1.2\. We can also
    see the key exchange ➋, cipher ➌, and hash algorithms ➍ negotiated. At ➎, we see
    some information about the server certificate, including the name of the Cert
    Subject, which typically represents the certificate owner. The Cert Issuer ➏ is
    the authority that signed the server’s certificate, and it’s the next certificate
    in the chain, as described in “[Public Key Infrastructure](../Text/ch07.xhtml#ch00lev1sec205)”
    on [page 169](../Text/ch07.xhtml#page_169). In this case, the Cert Subject and
    Cert Issuer are the same, which typically means the certificate is self-signed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，使用的 TLS 协议在 ➊ 处显示为 TLS 1.2。我们还可以看到 ➋ 处协商的密钥交换、➌ 处的加密算法和 ➍ 处的哈希算法。在 ➎ 处，我们看到了有关服务器证书的一些信息，包括证书主题的名称，通常表示证书所有者。证书颁发者
    ➏ 是签署服务器证书的权威机构，它是链中的下一个证书，详细描述见 “[公钥基础设施](../Text/ch07.xhtml#ch00lev1sec205)”
    第 169 页。在这种情况下，证书主题和证书颁发者是相同的，这通常意味着证书是自签名的。
- en: '***Decrypting the TLS Traffic***'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解密 TLS 流量***'
- en: A common technique to decrypt the TLS traffic is to actively use a man-in-the-middle
    attack on the network traffic so you can decrypt the TLS from the client and reencrypt
    it when sending it to the server. Of course, in the middle, you can manipulate
    and observe the traffic all you like. But aren’t man-in-the-middle attacks exactly
    what TLS is supposed to protect against? Yes, but as long as we control the client
    application sufficiently well, we can usually perform this attack for testing
    purposes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 解密 TLS 流量的常见方法是通过主动进行中间人攻击来拦截网络流量，这样你就可以解密来自客户端的 TLS 流量，并在将其发送到服务器时重新加密。当然，在此过程中，你可以随意操作和观察流量。但难道中间人攻击不正是
    TLS 所要防范的吗？是的，但只要我们足够控制客户端应用程序，通常可以为了测试目的执行这种攻击。
- en: Adding TLS support to a proxy (and therefore to servers and clients, as discussed
    earlier in this chapter) can be a simple matter of adding a single line or two
    to the proxy script to add a TLS decryption and encryption layer. [Figure 8-1](../Text/ch08.xhtml#ch8fig1)
    shows a simple example of such a proxy.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 向代理添加 TLS 支持（因此也支持服务器和客户端，如本章前面讨论的那样）通常只是向代理脚本中添加一两行代码，从而增加一个 TLS 解密和加密层。[图
    8-1](../Text/ch08.xhtml#ch8fig1) 显示了这样一个简单的代理示例。
- en: '![image](../Images/f08-01.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f08-01.jpg)'
- en: '*Figure 8-1: An example MITM TLS proxy*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：一个 MITM TLS 代理示例*'
- en: We can implement the attack shown in [Figure 8-1](../Text/ch08.xhtml#ch8fig1)
    by replacing the template initialization in [Listing 8-5](../Text/ch08.xhtml#ch8list5)
    with the code in [Listing 8-31](../Text/ch08.xhtml#ch8list31).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用[清单 8-31](../Text/ch08.xhtml#ch8list31)中的代码替换[清单 8-5](../Text/ch08.xhtml#ch8list5)中的模板初始化，来实现[图
    8-1](../Text/ch08.xhtml#ch8fig1)中展示的攻击。
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 8-31: Adding TLS support to capture a proxy*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-31：为捕获代理添加 TLS 支持*'
- en: We make two important changes to the template initialization. At ➊, we increment
    port numbers because the client automatically adds 1 to the port when trying to
    connect over TLS. Then at ➋, we add a TLS network layer to the proxy template.
    (Be sure to add the TLS layer before the parser layer, or the parser layer will
    try to parse the TLS network traffic, which won’t work so well.)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对模板初始化做了两个重要更改。在 ➊ 处，我们增加了端口号，因为客户端在尝试通过 TLS 连接时会自动将端口号加 1。然后在 ➋ 处，我们为代理模板添加了
    TLS 网络层。（确保在解析器层之前添加 TLS 层，否则解析器层会尝试解析 TLS 网络流量，这样会出问题。）
- en: With the proxy in place, let’s repeat our test with the client from Listing
    8-31 to see the differences. [Listing 8-32](../Text/ch08.xhtml#ch8list32) shows
    the output.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了代理之后，让我们使用清单 8-31 中的客户端重复测试，以查看差异。[清单 8-32](../Text/ch08.xhtml#ch8list32)
    显示了输出结果。
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 8-32: ChatClient connecting through a proxy*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-32：通过代理连接的 ChatClient*'
- en: Notice some clear changes in [Listing 8-32](../Text/ch08.xhtml#ch8list32). One
    is that the TLS protocol is now TLS v1.0 ➊ instead of TLS v1.2\. Another is that
    the Cipher and Hash algorithms differ from those in [Listing 8-30](../Text/ch08.xhtml#ch8list30),
    although the key exchange algorithm is using Elliptic Curve Diffie–Hellman (ECDH)
    for forward secrecy ➋. The final change is shown in the Cert Issuer ➌. The proxy
    libraries will autogenerate a valid certificate based on the original one from
    the server, but it will be signed with the library’s Certificate Authority (CA)
    certificate. If a CA certificate isn’t configured, one will be generated on first
    use.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在[列表 8-32](../Text/ch08.xhtml#ch8list32)中的一些明显变化。其中之一是 TLS 协议现在是 TLS v1.0
    ➊，而不是 TLS v1.2\。另一个变化是加密算法和哈希算法与[列表 8-30](../Text/ch08.xhtml#ch8list30)中的不同，尽管密钥交换算法仍然使用椭圆曲线
    Diffie-Hellman (ECDH) 以实现前向保密 ➋。最后一个变化体现在证书颁发者 ➌ 中。代理库将根据服务器的原始证书自动生成一个有效证书，但它会使用库的证书颁发机构
    (CA) 证书签名。如果没有配置 CA 证书，将在首次使用时生成一个。
- en: '**Forcing TLS 1.2**'
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**强制使用 TLS 1.2**'
- en: 'The changes to the negotiated encryption settings shown in [Listing 8-32](../Text/ch08.xhtml#ch8list32)
    can interfere with your successfully proxying applications because some applications
    will check the version of TLS negotiated. If the client will only connect to a
    TLS 1.2 service, you can force that version by adding this line to the script:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-32](../Text/ch08.xhtml#ch8list32)中显示的加密设置协商更改可能会干扰你成功代理应用程序，因为一些应用程序会检查协商的
    TLS 版本。如果客户端只会连接到 TLS 1.2 服务，你可以通过在脚本中添加以下行来强制使用该版本：'
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Replacing the Certificate with Our Own**'
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用我们自己的证书替换证书**'
- en: Replacing the certificate chain involves ensuring that the client accepts the
    certificate that you generate as a valid root CA. Run the script in Listing 8-33
    in *CANAPE.Cli* to generate a new CA certificate, output it and key to a PFX file,
    and output the public certificate in PEM format.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 替换证书链涉及确保客户端接受你生成的证书作为有效的根 CA。运行[列表 8-33](../Text/ch08.xhtml#ch8list33)中的脚本，使用*CANAPE.Cli*生成一个新的
    CA 证书，将其输出到 PFX 文件，并以 PEM 格式输出公钥证书。
- en: generate_ca
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: generate_ca
- en: _cert.csx
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: _cert.csx
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 8-33: Generating a new root CA certificate for a proxy*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-33：为代理生成新的根 CA 证书*'
- en: On disk, you should now find a *ca.pfx* file and a *ca.crt* file. Copy the *ca.pfx*
    file into the same directory where your proxy script files are located, and add
    the following line before initializing the TLS layer as in [Listing 8-31](../Text/ch08.xhtml#ch8list31).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在磁盘上，你现在应该能找到一个*ca.pfx*文件和一个*ca.crt*文件。将*ca.pfx*文件复制到与你的代理脚本文件所在的相同目录，并在初始化
    TLS 层之前添加以下行，如[列表 8-31](../Text/ch08.xhtml#ch8list31)所示。
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: All generated certificates should now use your CA certificate as the root certificate.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有生成的证书现在应该使用你的 CA 证书作为根证书。
- en: You can now import *ca.crt* as a trusted root for your application. The method
    you use to import the certificate will depend on many factors, for example, the
    type of device the client application is running on (mobile devices are typically
    more difficult to compromise). Then there’s the question of where the application’s
    trusted root is stored. For example, is it in an application binary? I’ll show
    just one example of importing the certificate on Microsoft Windows.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将*ca.crt*导入为应用程序的受信根证书。导入证书的方法将取决于许多因素，例如，客户端应用程序运行的设备类型（移动设备通常更难被攻破）。然后还有一个问题是应用程序的受信根证书存储的位置。例如，它是存储在应用程序二进制文件中吗？我将展示一个在微软
    Windows 上导入证书的示例。
- en: Because it’s common for Windows applications to refer to the system trusted
    root store to get their root CAs, we can import our own certificate into this
    store and SuperFunkyChat will trust it. To do so, first run `certmgr.msc` either
    from the Run dialog or a command prompt. You should see the application window
    shown in [Figure 8-2](../Text/ch08.xhtml#ch8fig2).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Windows 应用程序通常会引用系统受信根存储来获取其根 CA，我们可以将自己的证书导入此存储，SuperFunkyChat 就会信任它。为此，首先运行`certmgr.msc`，可以通过运行对话框或命令提示符来启动。你应该会看到[图
    8-2](../Text/ch08.xhtml#ch8fig2)所示的应用程序窗口。
- en: '![image](../Images/f08-02.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f08-02.jpg)'
- en: '*Figure 8-2: The Windows certificate manager*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：Windows 证书管理器*'
- en: Choose **Trusted Root Certification Authorities** ▸ **Certificates** and then
    select **Action** ▸ **All Tasks** ▸ **Import**. An import Wizard should appear.
    Click **Next** and you should see a dialog similar to [Figure 8-3](../Text/ch08.xhtml#ch8fig3).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**受信根证书颁发机构** ▸ **证书**，然后选择**操作** ▸ **所有任务** ▸ **导入**。应该会出现一个导入向导。点击**下一步**，你应该看到一个类似于[图
    8-3](../Text/ch08.xhtml#ch8fig3)的对话框。
- en: '![image](../Images/f08-03.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f08-03.jpg)'
- en: '*Figure 8-3: Using the Certificate Import Wizard file import*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：使用证书导入向导文件导入*'
- en: Enter the path to *ca.crt* or browse to it and click **Next** again.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 输入*ca.crt*的路径或浏览到该文件，然后再次点击**下一步**。
- en: Next, make sure that Trusted Root Certification Authorities is shown in the
    Certificate Store box (see [Figure 8-4](../Text/ch08.xhtml#ch8fig4)) and click
    **Next**.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保在证书存储框中显示受信任的根证书颁发机构（参见[图 8-4](../Text/ch08.xhtml#ch8fig4)），然后点击**下一步**。
- en: '![image](../Images/f08-04.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f08-04.jpg)'
- en: '*Figure 8-4: The certificate store location*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：证书存储位置*'
- en: On the final screen, click **Finish**; you should see the warning dialog box
    shown in [Figure 8-5](../Text/ch08.xhtml#ch8fig5). Obviously, heed its warning,
    but click **Yes** all the same.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个屏幕上，点击**完成**；你应该看到[图 8-5](../Text/ch08.xhtml#ch8fig5)中显示的警告对话框。显然，要注意它的警告，但仍然点击**是**。
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Be very careful when importing arbitrary root CA certificates into your trusted
    root store. If someone gains access to your private key, even if you were only
    planning to test a single application, they could man-in-the-middle any TLS connection
    you make. Never install arbitrary certificates on any device you use or care about.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*在将任意根 CA 证书导入到受信任的根证书存储区时要非常小心。如果有人获得了你的私钥，即使你只打算测试单个应用程序，他们也可以对你进行任何 TLS
    连接的中间人攻击。切勿在任何你使用或关心的设备上安装任意证书。*'
- en: '![image](../Images/f08-05.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f08-05.jpg)'
- en: '*Figure 8-5: A warning about importing a root CA certificate*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：导入根 CA 证书时的警告*'
- en: 'As long as your application uses the system root store, your TLS proxy connection
    will be trusted. We can test this quickly with SuperFunkyChat using `--verify`
    with the ChatClient to enable server certificate verification. Verification is
    off by default to allow you to use a self-signed certificate for the server. But
    when you run the client against the proxy server with `--verify`, the connection
    should fail, and you should see the following output:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你的应用程序使用系统根存储区，你的 TLS 代理连接将会被信任。我们可以通过使用 `--verify` 启用服务器证书验证，快速用 SuperFunkyChat
    测试这个功能。默认情况下，验证是关闭的，以便你可以为服务器使用自签名证书。但当你使用 `--verify` 在客户端和代理服务器之间运行时，连接应该会失败，你应该看到如下输出：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The problem is that although we added the CA certificate as a trusted root,
    the server name, which is in many cases specified as the subject of the certificate,
    is invalid for the target. As we’re proxying the connection, the server hostname
    is, for example, 127.0.0.1, but the generated certificate is based on the original
    server’s certificate.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，尽管我们将 CA 证书添加为受信任的根证书，但服务器名称（在许多情况下是证书的主题）对于目标无效。由于我们正在代理连接，服务器主机名例如是 127.0.0.1，但生成的证书是基于原始服务器的证书。
- en: 'To fix this, add the following lines to specify the subject name for the generated
    certificate:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决此问题，请添加以下行来指定生成证书的主题名称：
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When you retry the client, it should successfully connect to the proxy and then
    on to the real server, and all traffic should be unencrypted inside the proxy.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新尝试客户端时，它应该能够成功连接到代理，然后再连接到真实的服务器，所有流量应该在代理内部是未加密的。
- en: We can apply the same code changes to the network client and server code in
    [Listing 8-6](../Text/ch08.xhtml#ch8list6) and [Listing 8-8](../Text/ch08.xhtml#ch8list8).
    The framework will take care of ensuring that only specific TLS connections are
    established. (You can even specify TLS client certificates in the configuration
    for use in performing mutual authentication, but that’s an advanced topic that’s
    beyond the scope of this book.)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相同的代码更改应用于[示例 8-6](../Text/ch08.xhtml#ch8list6)和[示例 8-8](../Text/ch08.xhtml#ch8list8)中的网络客户端和服务器代码。框架将确保仅建立特定的
    TLS 连接。（你甚至可以在配置中指定 TLS 客户端证书，用于执行互认证，但这是一个高级话题，超出了本书的范围。）
- en: You should now have some ideas about how to man-in-the-middle TLS connections.
    The techniques you’ve learned will enable you to decrypt and encrypt the traffic
    from many applications to perform analysis and security testing.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该对如何进行 TLS 连接的中间人攻击有了一些了解。你所学到的技术将使你能够解密和加密来自许多应用程序的流量，以进行分析和安全测试。
- en: '**Final Words**'
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter demonstrated some approaches you can take to reimplement your application
    protocol based on the results of either doing on-the-wire inspection or reverse
    engineering the implementation. I’ve only scratched the surface of this complex
    topic—many interesting challenges await you as you investigate security issues
    in network protocols.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了你可以采取的一些方法，以根据进行链路监测或逆向工程实现的结果重新实现你的应用协议。我只是触及了这一复杂话题的表面——在你调查网络协议中的安全问题时，许多有趣的挑战在等着你。
