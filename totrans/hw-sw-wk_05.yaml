- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**Game Graphics**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏图形**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: A modern video game is like a modern movie—a big production that requires expertise
    in many different technical areas. Teams of programmers develop code for audio,
    artificial intelligence, network connectivity, and so on. Still, the first thing
    you notice about a video game is the graphics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现代视频游戏就像现代电影一样——一项大型制作，涉及许多不同技术领域的专业知识。程序员团队开发音频、人工智能、网络连接等方面的代码。不过，您在玩视频游戏时首先注意到的还是图形。
- en: Early video game systems like the Atari 2600 and Sega Genesis relied on premade
    bitmap graphics; that is, there was no rendering, not even the 2D rendering described
    in the previous chapter. Instead, if a video game needed to show the game’s hero
    walking, an artist would draw several bitmaps to be shown in a repeating sequence.
    Backgrounds, too, were hand-drawn. Displays were low resolution and offered only
    a few choices for pixel colors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的视频游戏系统，如雅达利2600和世嘉Genesis，依赖于预制的位图图形；也就是说，没有渲染，甚至没有上一章中提到的2D渲染。相反，如果一款视频游戏需要展示游戏中的英雄走路，艺术家会绘制几个位图，并按顺序重复显示。背景也是手绘的。显示分辨率低，且仅提供少量像素颜色选择。
- en: As the quality of displays improved, game developers turned to other techniques
    to produce their bitmaps. Fighting games like *Mortal Kombat* would scan photographs
    of stunt actors in costume or at least use them for reference. Some games in this
    era would actually use rendered graphics, but not real-time rendering; instead
    they would prerender the bitmaps on more powerful systems over a longer period
    of time. The 3D game as we know it today was unknown outside of a few early experiments.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着显示质量的提高，游戏开发者转向其他技术来生成位图。像*真人快打*这样的格斗游戏会扫描特技演员的服装照，或至少使用这些照片作为参考。在这一时期，一些游戏确实使用了渲染图形，但并非实时渲染；相反，它们会在更强大的系统上花费较长时间预渲染这些位图。我们今天所知道的3D游戏在当时是鲜为人知的，只在少数早期实验中存在。
- en: That started to change in the mid-1990s. Game consoles like the Sony PlayStation
    were built around 3D graphics capabilities instead of bitmaps. PC gamers began
    to purchase what were then called *graphics accelerators*— plug-in hardware to
    assist in the creation of 3D graphics. Those early 3D games were crude, both graphically
    and otherwise, compared to games today. Also, few 3D games were made for the PC
    because Microsoft had yet to build DirectX, a standardized interface between game
    software and graphics hardware, which meant that games had to include different
    code to match each manufacturer’s graphics accelerator.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在1990年代中期开始发生变化。像索尼PlayStation这样的游戏主机是围绕3D图形能力而非位图构建的。PC玩家开始购买当时被称为*图形加速器*的插件硬件，帮助创建3D图形。与今天的游戏相比，那些早期的3D游戏在图形和其他方面都显得粗糙。此外，由于微软尚未构建DirectX——游戏软件和图形硬件之间的标准化接口——这意味着游戏必须包含不同的代码，以适配每个制造商的图形加速器，因此很少有3D游戏会为PC制作。
- en: Even so, gamers were hooked on the new 3D gaming, and each succeeding generation
    of graphics hardware blew away the capabilities of the previous one. Nowhere was
    this generational leap more apparent than in *cut scenes*—short, prerendered videos
    shown at the beginning of the game to set the scene, or at critical points during
    the game to advance the plot. Because these videos were prerendered on expensive
    hardware, just like the movie CGI we discussed in [Chapter 4](ch04.html#ch04),
    early cut scenes were much more impressive than the graphics during actual gameplay.
    As the hardware advanced, though, gameplay visuals began to match or even exceed
    the cut scenes of earlier games.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，玩家们对新兴的3D游戏着迷，每一代图形硬件的性能都远远超越了前一代。在*过场动画*——短小的预渲染视频，通常在游戏开始时设置场景，或者在游戏中的关键时刻推动情节发展——这一代际飞跃中，这种变化尤为明显。由于这些视频是在昂贵硬件上预渲染的，就像我们在[第4章](ch04.html#ch04)中讨论的电影CGI一样，早期的过场动画比实际游戏中的图形要令人印象深刻得多。然而，随着硬件的进步，游戏画面开始与甚至超越早期游戏的过场动画效果。
- en: These days, few games use prerendered cut scenes. Although the game may still
    include noninteractive “movie” sequences to set up or advance the plot, they’re
    much more likely to be rendered in real time, just like the rest of the game.
    That’s because the real-time rendering looks so good, it’s not worth it for game
    developers to do anything else.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，很少有游戏使用预渲染的过场动画。虽然游戏仍然可能包含非互动的“电影”场景来设置或推动情节发展，但这些场景更可能是实时渲染的，就像游戏的其余部分一样。这是因为实时渲染效果已经非常好，游戏开发者不再认为做其他处理是值得的。
- en: 'And that, I think, is why I find video game graphics so amazing. They look
    as good as or better than the prerendered graphics I saw in earlier video games,
    or even in early CGI movies, and they’re being produced in real time. Those two
    words—*real time*—look innocent enough, but they encapsulate an enormous challenge
    for a game renderer. To put it into numbers: if your typical gamer wants a refresh
    rate of 60 frames per second, each image must be rendered in a mere ¹/[60] of
    a second.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，这就是为什么我觉得电子游戏图形如此令人惊叹的原因。它们看起来和我在早期视频游戏中看到的预渲染图形一样好，甚至更好，或者说像早期的 CGI 电影一样，而且它们是在实时生成的。这两个词——*实时*——看起来无害，但它们包含了游戏渲染器面临的巨大挑战。用数字来说：如果你的典型玩家希望获得
    60 帧每秒的刷新率，那么每一帧图像必须在仅仅¹/[60]秒内渲染完成。
- en: '**Hardware for Real-Time Graphics**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实时图形的硬件**'
- en: The increasing quality of real-time graphics is tied to advancements in graphics
    hardware. Today’s graphics hardware is powerful and optimized for the tasks involved
    in 3D graphical rendering. Although this book is about software, a brief discussion
    of hardware is necessary to understand why game graphics work the way they do.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实时图形质量的提升与图形硬件的进步密切相关。今天的图形硬件非常强大，并且针对 3D 图形渲染中的任务进行了优化。尽管本书是关于软件的，但简要讨论硬件是必要的，因为这有助于理解为什么游戏图形是以这种方式运作的。
- en: The main processor inside a computer or video game console is the *central processing
    unit (CPU)*. These processors might have multiple *cores*, or independent processing
    subunits. Think of a core as an office worker. The cores inside a CPU are like
    fast, widely trained workers. They are good at doing just about any task, and
    doing it very quickly. However, they are so expensive that you can afford to have
    only a few of them, usually eight or fewer in a typical desktop processor, although
    this number will continue to rise.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机或视频游戏主机中的主要处理器是*中央处理单元（CPU）*。这些处理器可能有多个*核心*，即独立的处理子单元。可以把一个核心想象成一个办公室工作人员。CPU
    内部的核心就像是快速且受过广泛训练的工人。它们擅长做几乎任何任务，并且非常迅速。然而，它们的成本太高，因此通常只能拥有少数几个核心，通常是八个或更少，尽管这个数字会继续增加。
- en: By contrast, a *graphics processing unit (GPU)* will have hundreds or even thousands
    of cores. These cores are much simpler, and individually slower, than the cores
    in a CPU. Think of them as workers who can do only a few tasks well, and don’t
    do those tasks especially fast, but they are so affordable that you can have an
    army of them. This hardware approach for GPUs was adopted because there’s only
    so much improvement that can be made to the speed of individual cores. Even though
    the raw speed of cores increased with each generation, that wasn’t nearly enough
    to close the performance gap to allow high-quality real-time rendering; the only
    solution was more cores.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，*图形处理单元（GPU）*会拥有数百个甚至上千个核心。这些核心比 CPU 内的核心更简单，每个核心的速度也更慢。可以把它们看作是只能做少数几项任务并且完成得不特别快的工人，但它们的成本非常低廉，以至于可以拥有大量的它们。这种硬件设计方法被采用，是因为单个核心的速度提升已经有限。尽管每一代核心的原始速度有所提升，但仍然远不足以缩小性能差距，无法支持高质量的实时渲染；唯一的解决方案就是更多的核心。
- en: CPUs, then, are great at tasks with steps that have to be completed in a specified
    order, like filling in a tax form. GPUs, though, are better at tasks that can
    be easily divided among many workers, like painting the outside of a house. Game
    renderers are designed to keep all of the GPU cores as busy as possible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，CPU 擅长那些必须按特定顺序完成的任务，就像填报税表一样。而 GPU 则更适合那些可以轻松分配给许多工人的任务，就像粉刷房子的外墙一样。游戏渲染器的设计就是要尽可能让所有
    GPU 核心保持忙碌。
- en: '**Why Games Don’t Ray Trace**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为什么游戏不使用光线追踪**'
- en: We saw in the preceding chapter how ray tracing can produce amazing graphics.
    But games don’t ray trace, because it’s too slow for real-time rendering. There
    are several reasons for this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章中看到，光线追踪可以产生惊人的图形。但游戏不会使用光线追踪，因为它对于实时渲染来说太慢了。其原因有很多。
- en: One reason is that ray tracing doesn’t match up well with the “army of workers”
    GPU design. For example, ray tracing sends out a beam of light for each pixel,
    determines where that beam strikes, and from that point of impact, sends out a
    bunch more light beams, determines where they strike, and so on. This job is better
    suited for a CPU, because the renderer must determine each point of impact before
    it knows what beams to check next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个原因是光线追踪与“工人军团”GPU设计不太匹配。例如，光线追踪为每个像素发射一束光线，确定光线的撞击点，然后从撞击点发射更多的光线，继续确定它们的撞击点，依此类推。这个过程更适合由CPU来处理，因为渲染器必须在知道接下来要检查哪些光线之前，先确定每个撞击点的位置。
- en: More broadly, realtime renders should expend computational effort where the
    result makes a difference to the viewer. Consider a computer-generated scene in
    which you face a chair in the middle of a polished wooden floor. A ray tracer,
    pinballing light around the room, would still indirectly determine the color of
    every point on the back of the chair, because that data is necessary for proper
    global illumination of the floor. A game renderer, though, could never afford
    the luxury of coloring a surface that won’t be directly seen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛来说，实时渲染应该把计算资源集中在那些对观众有显著影响的地方。试想一个计算机生成的场景，你站在一个抛光木地板上的椅子前面。一种光线追踪技术会让光线在房间里反弹，从而间接确定椅子背面的每个点的颜色，因为这些数据对于地板的全局光照是必要的。然而，游戏渲染器不可能有这种奢侈，去为一个不会被直接看到的表面上色。
- en: '**All Lines and No Curves**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**只有线条，没有曲线**'
- en: 'To understand how a video game renders without ray tracing, we start with the
    basic building block of game graphics: the triangle. In the previous chapter we
    learned how CGI models in movies are made of lines and curves. In game rendering,
    models are normally made exclusively of lines. If you remember graphing parabolas
    in high school algebra, you’ll recall that the math for describing curves is a
    lot more complicated than the math for describing lines, and there’s just not
    enough time to deal with curves in a game. That’s why game renderers use lines,
    and this means that the surfaces defined by the control points are flat. The simplest
    flat surface is a triangle, defined by three points in space.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解视频游戏是如何在没有光线追踪的情况下进行渲染的，我们从游戏图形的基本构建块——三角形开始。在上一章中，我们了解了电影中的CGI模型是由线条和曲线构成的。在游戏渲染中，模型通常完全由线条构成。如果你记得高中代数中画抛物线的情景，你会意识到，描述曲线的数学比描述线条的数学复杂得多，而在游戏中根本没有足够的时间来处理曲线。这就是为什么游戏渲染器使用线条，而这意味着由控制点定义的表面是平坦的。最简单的平面表面是三角形，它由空间中的三个点定义。
- en: Triangles are ubiquitous in games. In a game, whatever you think you’re looking
    at, you’re actually looking at millions of triangles, joined at angles to create
    surfaces and shapes. Triangles used in rendering are often generically called
    *polygons*, even though almost all the polygons are simple triangles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形在游戏中无处不在。在一款游戏中，无论你以为自己看到的是什么，实际上你看到的都是成千上万的三角形，这些三角形通过角度连接在一起，形成表面和形状。渲染中使用的三角形通常被统称为*多边形*，尽管几乎所有的多边形都是简单的三角形。
- en: Games simulate curved surfaces by using lots and lots of triangles. A round
    tumbler, for example, can be approximated as a ring of interlocking triangles,
    as shown in [Figure 5-1](ch05.html#ch5fig1). On the right, the outlines of each
    triangle are shown for clarity.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通过使用大量的三角形来模拟曲面。例如，一个圆形的玻璃杯可以被近似为一个由相互连接的三角形组成的环形，如[图 5-1](ch05.html#ch5fig1)所示。右侧显示了每个三角形的轮廓，以便更清晰地展示。
- en: '![image](graphics/f05-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-01.jpg)'
- en: '*Figure 5-1: A curved tumbler approximated with triangles*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：用三角形近似的圆形玻璃杯*'
- en: '**Projection Without Ray Tracing**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**没有光线追踪的投影**'
- en: To render the triangles in the scene models, the renderer must project the control
    points that define the triangle to locate these points on the screen. Ray tracing
    projects by following an imaginary beam of light through the center of each pixel,
    but in this case we have to do something different.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染场景模型中的三角形，渲染器必须将定义三角形的控制点投影到屏幕上。光线追踪通过沿着每个像素中心的虚拟光束进行投影，但在这种情况下，我们必须采取不同的方式。
- en: The good news is that a direct mathematical relationship exists between world
    coordinates and screen coordinates, and this makes mapping the points fairly straightforward.
    We know the location—the x, y, and z world coordinates—of the viewpoint and of
    the point on the model we want to project. We also know the location of the virtual
    projection screen. [Figure 5-2](ch05.html#ch5fig2) shows how we use these locations
    to determine the exact y-coordinate where the line aimed at the model point crosses
    the projection screen. In this example, the depth (the distance from the viewpoint
    along the z-coordinate) of the projection screen is four-tenths of the depth from
    the viewpoint to the point on the model, as shown by the large blocks along the
    bottom. Knowing this proportion, we can calculate the x- and y-coordinates of
    the projected point. The y-coordinate of the projected point is four-tenths of
    the distance between the y-coordinate of the viewpoint and the y-coordinate of
    the point on the model, as shown by the shaded boxes on the projection screen.
    Also, though we can’t see this from the perspective of [Figure 5-2](ch05.html#ch5fig2),
    the x-coordinate of the projected point will be four-tenths of the distance between
    the x-coordinates of the viewpoint and model point.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，世界坐标和屏幕坐标之间存在直接的数学关系，这使得映射点变得相当简单。我们知道视点的位置信息——x、y 和 z 的世界坐标——以及我们想要投影的模型点的位置。我们还知道虚拟投影屏幕的位置。[图
    5-2](ch05.html#ch5fig2)展示了我们如何利用这些位置信息来确定视线与模型点对准的线穿过投影屏幕时的确切 y 坐标。在这个例子中，投影屏幕的深度（即视点沿
    z 坐标的距离）是视点到模型点的深度的四分之三，底部的大块区域就是这种比例的体现。知道这个比例后，我们就能计算出投影点的 x 和 y 坐标。投影点的 y 坐标是视点的
    y 坐标与模型点的 y 坐标之间距离的四分之一，如投影屏幕上的阴影框所示。此外，尽管从[图 5-2](ch05.html#ch5fig2)的角度看不出来，投影点的
    x 坐标将是视点和模型点的 x 坐标之间距离的四分之一。
- en: '![image](graphics/f05-02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-02.jpg)'
- en: '*Figure 5-2: Projecting a point in the virtual world to the screen*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：将虚拟世界中的点投影到屏幕上*'
- en: Note that the position of the imaginary projection screen in the virtual world
    affects the resulting projection. To see this effect, make a rectangle using the
    forefinger and thumb of both hands and look through it while moving your hands
    close and then farther away. The farther away your hands are from your eyes, the
    narrower your *field of view*. In the same way, games can adjust field of view
    by altering the distance between the viewpoint and the projection screen in the
    virtual world. For example, games that let you look through binoculars or a gun
    scope accomplish the zoom effect by moving the projection screen deeper into the
    scene.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虚拟世界中假想的投影屏幕的位置会影响最终的投影效果。为了观察这种效果，可以用双手的食指和拇指做一个矩形框，然后看着它，双手靠近眼睛再逐渐远离。双手离眼睛越远，*视野越狭窄*。同理，游戏可以通过改变虚拟世界中视点和投影屏幕之间的距离来调整视野。例如，允许玩家通过望远镜或瞄准镜查看的游戏，通过将投影屏幕移得更深来实现缩放效果。
- en: '**Rendering Triangles**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**渲染三角形**'
- en: With all three points of a triangle located in screen space, rendering a triangle
    follows the same rasterization process we saw in [Chapter 4](ch04.html#ch04) to
    make a bitmap out of a 2D model. In [Figure 5-3](ch05.html#ch5fig3), the pixel
    centers inside the triangle boundaries are colored gray.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当三角形的三个顶点都位于屏幕空间时，渲染三角形遵循我们在[第 4 章](ch04.html#ch04)中看到的相同光栅化过程，将 2D 模型转换为位图。在[图
    5-3](ch05.html#ch5fig3)中，三角形边界内的像素中心被填充为灰色。
- en: From reading the previous chapter, you probably have some objections to this
    simple method of triangle rendering. First, how can we just color every pixel
    the same—what about all those lighting effects? And second, look at those jaggies—
    how do we get rid of them?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从阅读上一章，你可能会对这种简单的三角形渲染方法提出一些异议。首先，为什么我们仅仅把每个像素都填充相同的颜色——那所有的光照效果怎么办？其次，看看那些锯齿状的边缘——我们该如何去除它们？
- en: '![image](graphics/f05-03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-03.jpg)'
- en: '*Figure 5-3: With the vertices of a triangle located on the screen, the triangle
    can be rendered.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：通过定位三角形的顶点，可以渲染该三角形。*'
- en: 'These questions will be answered, but first we have to deal with a more fundamental
    problem. Simply determining where every triangle is located on the screen and
    coloring its pixels doesn’t work because every pixel on the screen will probably
    be inside more than one triangle. Consider the image shown in [Figure 5-4](ch05.html#ch5fig4).
    The flowerpot is behind a cube, which is behind a tall cup. Pixel A lies within
    four different triangles: one on the front of the cup, one on the back of the
    cup, one on the front of the cube, and one on the side of the cube. Likewise,
    four triangles enclose pixel B. In each case, only one triangle should actually
    determine the color of the pixel. In order to render the image correctly, the
    renderer must always map each pixel to the model surface in the scene that is
    closest to the viewpoint. Ray tracing already finds the closest intersection point
    between the light beam and a model in the scene, so this problem is handled without
    any additional effort. Without ray tracing, though, what should the renderer do?'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题将会得到解答，但首先我们必须处理一个更基本的问题。仅仅确定每个三角形在屏幕上的位置并给它的像素上色是行不通的，因为屏幕上的每个像素可能会位于多个三角形之内。考虑[图
    5-4](ch05.html#ch5fig4)所示的图像。花盆位于一个立方体后面，而立方体又位于一个高杯子后面。像素 A 位于四个不同的三角形内：杯子前面一个、杯子背面一个、立方体前面一个和立方体侧面一个。同样，四个三角形也包围着像素
    B。在每种情况下，实际上只有一个三角形应该决定该像素的颜色。为了正确渲染图像，渲染器必须始终将每个像素映射到场景中距离视点最近的模型表面。光线追踪已经找到了光束与场景中模型之间最近的交点，因此这个问题无需额外努力就能处理。然而，如果没有光线追踪，渲染器应该怎么办呢？
- en: '![image](graphics/f05-04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-04.jpg)'
- en: '*Figure 5-4: Three overlapping models in a scene*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：场景中三个重叠的模型*'
- en: '***The Painter’s Algorithm***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***画家算法***'
- en: A simple solution is known as the *painter’s algorithm*. First, all of the triangles
    in the scene are ordered according to their distance from the viewpoint. Then
    the models are “painted” back to front, the way Bob Ross would paint a landscape
    on *The Joy of Painting*. This algorithm is easy for the programmer to implement,
    but it has several problems.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的解决方案被称为*画家算法*。首先，按照距离视点的远近顺序对场景中的所有三角形进行排序。然后，模型按从后到前的顺序“绘制”，就像 Bob Ross
    在*《绘画的乐趣》*中绘制风景一样。这个算法对程序员来说很容易实现，但它也有几个问题。
- en: 'First, it’s highly inefficient: the renderer will wind up coloring the same
    pixel over and over again as foreground models are rendered over previous background
    models, which is a huge waste of effort.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它非常低效：渲染器会一遍又一遍地给相同的像素上色，因为前景模型会覆盖在之前的背景模型之上，这浪费了大量的计算资源。
- en: Second, it doesn’t allow for easy subdivision to keep the army of workers busy
    on the GPU. The painter’s algorithm requires the models to be drawn in a certain
    order, so it’s difficult to effectively divide the work among separate processing
    units.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它不容易进行细分以保持 GPU 上的工作单元忙碌。画家算法要求模型按特定顺序绘制，因此很难将工作有效地分配给不同的处理单元。
- en: Third, there’s not always an easy way to determine which of two triangles is
    farther way from the viewpoint. [Figure 5-5](ch05.html#ch5fig5) shows a perspective
    view of two triangles, with numbers indicating the depth of each vertex. The top
    view makes it clear which triangle is in front, but because the depths of one
    triangle’s vertices are between those of the other triangle, there’s no easy way
    to figure out which triangle is closer by direct comparison of the vertex depths.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，通常没有简单的方法来确定两个三角形中哪个离视点更远。[图 5-5](ch05.html#ch5fig5)显示了两个三角形的透视图，数字表示每个顶点的深度。顶视图清楚地显示了哪个三角形位于前面，但由于一个三角形的顶点深度介于另一个三角形的顶点之间，通过直接比较顶点深度无法轻松确定哪个三角形更接近。
- en: '![image](graphics/f05-05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-05.jpg)'
- en: '*Figure 5-5: Perspective and top views of two triangles*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：两个三角形的透视图和顶视图*'
- en: '***Depth Buffering***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***深度缓冲***'
- en: Because of all the deficiencies of the painter’s algorithm, the most common
    solution to projection in games is a method known as *depth buffering*. As introduced
    in the previous chapter, computer graphics require a bitmap called a display buffer
    to store the color of each pixel in a display. This technique also uses a corresponding
    *depth buffer* to track the depth of each pixel—how far away it is from the viewpoint.
    Of course, a screen is flat, so pixels don’t really have depth. What the depth
    buffer actually stores is the depth of the point in the scene that was used to
    determine the color of that pixel. This allows the renderer to process the objects
    in the scene in any order.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于画家算法的种种不足，游戏中最常见的投影解决方案是称为*深度缓冲*的方法。如前一章所介绍，计算机图形需要一个位图，称为显示缓冲，用来存储显示中每个像素的颜色。此技术还使用一个相应的*深度缓冲*来跟踪每个像素的深度——即它离视点的远近。当然，屏幕是平的，所以像素实际上没有深度。深度缓冲实际存储的是用于确定该像素颜色的场景中某一点的深度。这使得渲染器可以按任何顺序处理场景中的物体。
- en: Here’s how depth buffering would work with the example scene from [Figure 5-4](ch05.html#ch5fig4).
    Initially, the depth of each pixel would be set to some maximal value that’s greater
    than the depth of any actual object in the scene—let’s say 100,000 virtual feet.
    If the cup is drawn first, the depth of those pixels in the depth buffer is set
    to the corresponding distances from the viewpoint. Suppose the flowerpot is drawn
    next; the renderer then sets the depth of its pixels. We can picture the depth
    buffer as a grayscale image, where pixels are darker the closer they are to the
    viewpoint. The depth buffer at this stage is shown in [Figure 5-6](ch05.html#ch5fig6).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是深度缓冲如何在[图 5-4](ch05.html#ch5fig4)的示例场景中工作的。最初，每个像素的深度会被设置为一个大于场景中任何实际物体深度的最大值——假设为
    100,000 虚拟英尺。如果杯子首先被绘制，则该像素在深度缓冲中的深度会设置为对应的视点距离。假设花盆接着被绘制，渲染器则设置其像素的深度。我们可以将深度缓冲想象为一幅灰度图像，其中像素离视点越近，颜色越深。此时的深度缓冲如[图
    5-6](ch05.html#ch5fig6)所示。
- en: The depth buffer solves the problem of projecting the right point onto the pixel.
    Before rendering a pixel, the renderer checks the depth buffer value for that
    pixel’s location to see if the new pixel would be in front of or behind the pixel
    that’s already in the display buffer. When a new pixel appears behind the pixel
    in that location in the display buffer, the renderer skips it and moves on. Continuing
    with our example, when the cube is drawn, the pixels on the left side of the cube
    that overlap with the cup are not drawn, because the values in the depth buffer
    show that the cup’s pixels are in front of the cube. The cube would overwrite
    the pixels of the flowerpot, because the depth of the flowerpot pixels is greater
    than those of the cube.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 深度缓冲解决了将正确的点投影到像素上的问题。在渲染一个像素之前，渲染器会检查该像素位置的深度缓冲值，以确定新像素是否在已经显示缓冲中的像素之前或之后。当新像素出现在显示缓冲中的该位置并且位于现有像素后面时，渲染器会跳过该像素并继续处理。继续我们的示例，当立方体被绘制时，立方体左侧与杯子重叠的像素不会被绘制，因为深度缓冲中的值显示杯子的像素在立方体前面。立方体会覆盖花盆的像素，因为花盆像素的深度大于立方体的深度。
- en: '![image](graphics/f05-06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-06.jpg)'
- en: '*Figure 5-6: A depth buffer with two objects drawn. Darker colors are closer
    to the viewpoint.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：一个绘制了两个物体的深度缓冲。颜色越深表示离视点越近。*'
- en: Depth buffering is an efficient solution to projection because less work is
    thrown away. Models can be roughly preordered so that they are painted approximately
    front to back, to minimize overwritten pixels. Also, because depth buffers allow
    for rendering models in any order, work can more easily be divided among the cores
    of the graphics processor. In our example, different cores can be working on the
    cup, cube, and flowerpot at the same time, and the right model will be projected
    to each pixel in the final rendered image.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 深度缓冲是一种高效的投影解决方案，因为它减少了不必要的工作。模型可以大致按顺序预排序，使它们大致按照从前到后的顺序进行绘制，以最小化被覆盖的像素。此外，由于深度缓冲允许以任何顺序渲染模型，因此工作可以更容易地在图形处理器的各个核心之间分配。在我们的示例中，不同的核心可以同时处理杯子、立方体和花盆，而最终渲染的图像中每个像素都会正确地投影到相应的模型上。
- en: '**Real-Time Lighting**'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实时光照**'
- en: Now that the renderer knows which triangle each pixel belongs to, the pixel
    must be colored. In real-time rendering this is known as *pixel shading*. Once
    a particular pixel has passed the depth buffer test, all the data needed to color
    the pixel is processed by an algorithm called a pixel shader. Because each pixel
    can be independently colored, pixel shading is a great way to keep the army of
    workers busy inside the GPU.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在渲染器已经知道每个像素属于哪个三角形，接下来必须给像素上色。在实时渲染中，这个过程被称为*像素着色*。一旦某个像素通过深度缓冲测试，所有用于给像素上色的数据都会通过一种叫做像素着色器的算法进行处理。因为每个像素都可以独立上色，所以像素着色是保持GPU内部大量处理单元忙碌的一个好方法。
- en: The data needed by the shader will vary based on the complexity of the lighting
    model, including the location, direction, and color of the lights in the scene.
    Without a method like ray tracing, a full global illumination model, in which
    reflections from near surfaces color each other, isn’t possible. However, shaders
    can include the basic effects of distance, diffuse reflections, and specular reflections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器所需的数据会根据光照模型的复杂度而有所不同，包括场景中光源的位置、方向和颜色。没有像光线追踪这样的技术，就无法实现完整的全局光照模型，其中近距离表面之间的反射会相互影响。然而，着色器可以包含距离、漫反射和镜面反射的基本效果。
- en: In [Figure 5-7](ch05.html#ch5fig7), a beam of light represented by the solid
    arrow reflects from a triangle. The dashed arrow represents the *normal* (or *surface
    normal*) of the triangle in that location; a normal is simply a perpendicular
    line pointing away from the surface. In [Chapter 4](ch04.html#ch04) we learned
    how the angles between light beams, surfaces, and viewpoints affect diffuse and
    specular reflections. The normal is used by the pixel shader for these calculations;
    so, for example, in [Figure 5-7](ch05.html#ch5fig7), if the dark arrow represents
    a light beam, this would have high diffuse reflection because the angle between
    the light and the normal is small.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 5-7](ch05.html#ch5fig7)中，代表光线的实线箭头从三角形上反射。虚线箭头表示该位置的*法线*（或*表面法线*）；法线只是一个指向远离表面的垂直线。在[第
    4 章](ch04.html#ch04)中，我们学到了光线、表面和视点之间的角度如何影响漫反射和镜面反射。像素着色器使用法线进行这些计算；因此，例如，在[图
    5-7](ch05.html#ch5fig7)中，如果深色箭头表示光线，那么由于光线与法线之间的角度较小，它将有较高的漫反射。
- en: '![image](graphics/f05-07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-07.jpg)'
- en: '*Figure 5-7: A triangle with a surface normal (dashed arrow) perpendicular
    to the triangle surface, and a light beam (dark arrow) striking the surface.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：三角形的表面法线（虚线箭头）与三角形表面垂直，光线（实线箭头）照射到表面。*'
- en: In [Figure 5-7](ch05.html#ch5fig7), the normal points straight up, meaning it
    is perpendicular to the plane of the triangle. Triangles with straight-up normals
    for every point on the surface are completely flat, which makes the individual
    triangles clearly visible in the rendering. For example, with straight-up normals,
    the tumbler in [Figure 5-8](ch05.html#ch5fig8) appears faceted like a gemstone.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 5-7](ch05.html#ch5fig7)中，法线方向垂直向上，意味着它与三角形平面垂直。每个表面点的法线都垂直向上的三角形是完全平坦的，这使得每个三角形在渲染时都清晰可见。例如，在[图
    5-8](ch05.html#ch5fig8)中，带有垂直向上法线的酒杯看起来像一颗宝石一样棱角分明。
- en: For a more rounded appearance, the normals are bent as shown in [Figure 5-9](ch05.html#ch5fig9).
    Here, the normals at the corners are bent outward, and the normal at any location
    inside the triangle is a weighted average of the normals at the corner. Because
    the normal at the point of impact for the light beam no longer points straight
    up, the light beam reflects more sharply. If this were part of a diffuse lighting
    calculation, the resulting color would be brighter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更圆滑的外观，法线如[图 5-9](ch05.html#ch5fig9)所示被弯曲。这里，角落处的法线向外弯曲，三角形内部任意位置的法线是角落法线的加权平均。由于光线照射点的法线不再垂直向上，光线的反射变得更加尖锐。如果这属于漫反射光照计算，最终的颜色将会更亮。
- en: '![image](graphics/f05-08.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-08.jpg)'
- en: '*Figure 5-8: If the normals for each location on a triangle point the same
    way, this model will be rendered as a series of flat triangles.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：如果三角形上每个位置的法线方向相同，那么该模型将被渲染为一系列平坦的三角形。*'
- en: '![image](graphics/f05-09.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-09.jpg)'
- en: '*Figure 5-9: The normal at the point of light impact is affected by the bent
    corner normals, which changes the angle of reflection.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：光照影响点的法线会受到弯曲角法线的影响，从而改变反射角度。*'
- en: Bending normals allows the flat triangle to reflect light as though it were
    the bent triangle shown in [Figure 5-10](ch05.html#ch5fig10).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 弯曲法线允许平面三角形像图 [5-10](ch05.html#ch5fig10) 中的弯曲三角形那样反射光线。
- en: '![image](graphics/f05-10.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-10.jpg)'
- en: '*Figure 5-10: Bending the normals gives the triangle a bent shape so far as
    the lighting calculations are concerned.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-10：弯曲法线使得三角形在光照计算中呈现弯曲的形状。*'
- en: This goes only so far in fixing the problem, though, because the underlying
    shape is unchanged. Bending normals doesn’t affect which pixels are matched to
    which triangle; it affects only the lighting calculations in the pixel shader.
    Therefore, the illusion breaks down along the edges of a model. With our tumbler,
    bending normals helps the sides of the tumbler to appear smooth, but it doesn’t
    affect the tumbler’s silhouette, and the rim is still a series of straight lines.
    Smoother model renderings require additional techniques that we’ll see later in
    this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法仅仅解决了一部分问题，因为底层形状没有改变。弯曲法线并不会影响哪些像素与哪个三角形匹配；它仅影响像素着色器中的光照计算。因此，幻觉会在模型的边缘处崩溃。在我们的杯子模型中，弯曲法线帮助杯子的侧面看起来平滑，但它并不影响杯子的轮廓，杯口依然是由一系列直线组成的。更平滑的模型渲染需要额外的技术，我们将在本章后面看到这些技术。
- en: '**Shadows**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**阴影**'
- en: Shadowing plays an important part in convincing the viewer to accept the reality
    of an image by giving models weight and realism. Producing shadows requires tracing
    beams of light; a shadow is, after all, the outline of an object between a light
    source and a surface. Game renderers don’t have time for full ray tracing, so
    they use clever shortcuts to produce convincing shadow effects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影在通过赋予模型重量和现实感来说服观众接受图像的真实性方面发挥着重要作用。产生阴影需要追踪光线束；毕竟，阴影是位于光源和表面之间的物体轮廓。游戏渲染器没有时间进行完整的光线追踪，因此它们使用巧妙的捷径来产生令人信服的阴影效果。
- en: Consider the scene outline shown in [Figure 5-11](ch05.html#ch5fig11). This
    scene will be rendered in a nighttime environment, so the lamppost on the left
    will cast strong shadows. To render the shadows properly, the renderer must determine
    which pixels visible from this viewpoint would be illuminated by the lamppost
    and which will be lit only by other light sources. In this example, the renderer
    must determine that the point labeled Scene-A is not visible from the lamppost,
    but Scene-B is.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑图 [5-11](ch05.html#ch5fig11) 中显示的场景轮廓。这个场景将在夜间环境中渲染，因此左侧的路灯将投下强烈的阴影。为了正确渲染阴影，渲染器必须确定从这个视角可见的哪些像素会被路灯照亮，哪些则只会被其他光源照亮。在这个例子中，渲染器必须确定标记为
    Scene-A 的点不可见于路灯，但 Scene-B 是可见的。
- en: '![image](graphics/f05-11.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-11.jpg)'
- en: '*Figure 5-11: The light from the lamppost should cast shadows in this scene.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11：路灯的光线应该在这个场景中投下阴影。*'
- en: A common solution to this problem in games is a *shadow map*, a quickly rendered
    image from the point of view of a light source looking into the scene that calculates
    only the depth buffer, not the display buffer. [Figure 5-12](ch05.html#ch5fig12)
    is a shadow map for the lamppost in [Figure 5-11](ch05.html#ch5fig11), showing
    the distance from the lamppost to every point in the scene; as with the depth
    buffer, this is shown in grayscale with closer pixels colored darker.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中常见的解决方案是*阴影贴图*，这是一种从光源视角快速渲染的图像，仅计算深度缓冲区，而不计算显示缓冲区。[图 5-12](ch05.html#ch5fig12)
    是图 [5-11](ch05.html#ch5fig11) 中路灯的阴影贴图，显示了路灯与场景中每个点之间的距离；与深度缓冲区一样，这以灰度显示，距离较近的像素颜色较暗。
- en: '![image](graphics/f05-12.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-12.jpg)'
- en: '*Figure 5-12: The depth buffer from a rendering of the viewpoint of the lamppost*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-12：来自路灯视角的深度缓冲区渲染图*'
- en: Shadow maps are created for each light source before scene pixels are colored.
    When coloring a pixel, the pixel shader checks each light’s shadow map to determine
    if the point being rendered is visible from that light. Consider the points Scene-A
    and Scene-B in [Figure 5-11](ch05.html#ch5fig11). The shader computes the distance
    from each of these points to the top of the lamppost and compares this distance
    to the depth of the same points projected onto the shadow map, labeled Shadow-A
    and Shadow-B in [Figure 5-12](ch05.html#ch5fig12). In this case, the depth of
    Shadow-A in [Figure 5-12](ch05.html#ch5fig12) is less than the distance between
    Scene-A and the lamppost in [Figure 5-11](ch05.html#ch5fig11), which means something
    is blocking that light from reaching Scene-A. In contrast, the depth of Shadow-B
    matches the distance from Scene-B to the lamppost. So Scene-A is in shadow, but
    Scene-B is not.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影贴图会为每个光源在场景像素上色之前生成。当为像素上色时，像素着色器会检查每个光源的阴影贴图，以确定被渲染的点是否从该光源可见。考虑[图 5-11](ch05.html#ch5fig11)中的场景A和场景B的点。着色器计算每个点到路灯顶部的距离，并将这个距离与投影到阴影贴图上的同一位置的深度进行比较，在[图
    5-12](ch05.html#ch5fig12)中分别标记为阴影A和阴影B。在这个例子中，[图 5-12](ch05.html#ch5fig12)中阴影A的深度小于[图
    5-11](ch05.html#ch5fig11)中场景A到路灯的距离，这意味着有东西挡住了光线，光线无法到达场景A。相比之下，阴影B的深度与场景B到路灯的距离一致。因此，场景A处于阴影中，而场景B则没有。
- en: I deliberately gave the shadow map in [Figure 5-12](ch05.html#ch5fig12) a blocky
    appearance; to improve performance, shadow maps are often created at lower resolutions,
    making blocky shadows. If a game offers a “shadow quality” setting, this setting
    most likely controls the resolution of the shadow maps.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意让[图 5-12](ch05.html#ch5fig12)中的阴影贴图呈现块状外观；为了提高性能，阴影贴图通常会以较低的分辨率生成，从而产生块状阴影。如果一款游戏提供了“阴影质量”设置，这个设置很可能控制阴影贴图的分辨率。
- en: '**Ambient Light and Ambient Occlusion**'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**环境光与环境遮蔽**'
- en: The simpler lighting model in real-time rendering tends to produce images that
    are too dark. It’s easy to overlook the effect of indirect lighting in the world
    around us. For example, standing outside in the daytime, you’ll have enough light
    to read even if you stand in a solid shadow, because of indirect sunlight bouncing
    off nearby surfaces.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实时渲染中的简单光照模型通常会产生过于昏暗的图像。我们很容易忽视周围环境中间接光照的影响。例如，站在白天的户外，即使站在完全的阴影中，你也有足够的光线阅读，因为间接阳光会从附近的表面反射过来。
- en: To produce images with natural-looking light levels, a game renderer will typically
    apply a simple *ambient light* model. This lighting is omnipresent, illuminating
    the surface of every model without regard to light beams or angles of incidence,
    so that even surfaces missed by in-scene lighting are not totally dark. Ambient
    lighting is used throughout games, even for indoor scenes. This is a situation
    where a little fakery produces a more realistic result.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了产生自然光照效果，游戏渲染器通常会应用一个简单的*环境光*模型。这种光照是无处不在的，它照亮每个模型的表面，而不考虑光束或入射角度，因此即使是被场景光照遗漏的表面也不会完全黑暗。环境光在游戏中广泛使用，即使是在室内场景中也是如此。这是一种小小的“伪造”能够产生更真实效果的情况。
- en: Ambient lighting can also be used to adjust the mood of a scene. When you leave
    behind a golden, autumnal field to enter a dusky forest in an open-world game
    like *World of Warcraft*, a large part of the effect is the ambient lighting changing
    from bright yellow to dim blue.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 环境光还可以用来调整场景的氛围。在像*魔兽世界*这样的开放世界游戏中，当你从金黄的秋日田野进入昏暗的森林时，一个重要的效果就是环境光从明亮的黄色变为昏暗的蓝色。
- en: Although the simple ambient lighting model keeps the rendering from being too
    dark, the method doesn’t produce any shadows, which hurts a scene’s realism. *Ambient
    occlusion* methods fake shadows from ambient light by following the observation
    that such shadows should occur in crevices, cracks, holes, and the like. [Figure
    5-13](ch05.html#ch5fig13) shows the key idea. Point A is much less occluded than
    point B because the angle through which light can reach the point is much larger,
    letting more light through. Therefore, ambient light should have a greater influence
    on point A than point B.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管简单的环境光模型使得渲染效果不会太暗，但这种方法并不产生阴影，损害了场景的真实感。*环境遮蔽*方法通过模拟阴影的形成位置来伪造来自环境光的阴影，基于这样的观察：这些阴影应该出现在缝隙、裂缝、洞口等地方。[图
    5-13](ch05.html#ch5fig13)展示了这一关键思路。点A的遮蔽程度远低于点B，因为光线能够照射到该点的角度更大，从而让更多的光线通过。因此，环境光应该对点A的影响大于点B。
- en: For a renderer to measure the occlusion precisely, though, it would have to
    send out light beams in every direction, much like the scattering of light from
    diffuse lighting, but we already know that tracing light beams is not an option
    for real-time rendering. Instead, a technique called *screen space ambient occlusion
    (SSAO)* approximates the amount of occlusion for each pixel after the main rendering
    is over, using data that was already computed earlier in the rendering process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了让渲染器精确测量遮挡，它必须向每个方向发射光线，类似于漫反射光照中的光散射，但我们已经知道，对于实时渲染来说，追踪光线并不是一种可行的选择。相反，一种叫做*屏幕空间环境遮挡（SSAO）*的技术，在主要渲染完成后，利用渲染过程中已计算的数据近似每个像素的遮挡量。
- en: In [Figure 5-14](ch05.html#ch5fig14) we see SSAO approximation in action. Note
    that the viewpoint is looking straight down at the surface. The dashed arrow is
    the normal for the point on the surface. The gray area is a hemisphere aligned
    with that normal, shown as a semicircle in this 2D representation. The shader
    examines a scattering of points inside the hemisphere. Each point is projected
    into screen coordinates, just like the projection of the model point shown back
    in [Figure 5-2](ch05.html#ch5fig2). Then the depth of the point is compared to
    he depth buffer for the pixel location, which tells the shader whether the point
    is in front of (shown in white) or behind (black) the model surface. The percentage
    of points behind the surface is a good approximation of the amount of ambient
    occlusion.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 5-14](ch05.html#ch5fig14)中，我们可以看到 SSAO 近似的实际应用。请注意，视点是直接向下看表面。虚线箭头表示表面某一点的法线。灰色区域是与该法线对齐的半球，在此二维表示中呈半圆形。着色器检查半球内散布的点。每个点都被投影到屏幕坐标中，就像[图
    5-2](ch05.html#ch5fig2)中所示的模型点投影一样。然后，点的深度与该像素位置的深度缓冲进行比较，这告诉着色器该点是位于模型表面前面（白色）还是后面（黑色）。位于表面后面的点的百分比是环境遮挡量的一个良好近似。
- en: '![image](graphics/f05-13.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-13.jpg)'
- en: '*Figure 5-13: Measuring the occlusion at given points*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-13：在给定点测量遮挡情况*'
- en: '![image](graphics/f05-14.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-14.jpg)'
- en: '*Figure 5-14: Screen space ambient occlusion approximates the degree of occlusion
    by the percentage of points behind the model surface.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-14：屏幕空间环境遮挡通过表面后方点的百分比近似遮挡程度*'
- en: SSAO is heavy work for the renderer because it requires projecting and examining
    a lot of extra points—at least 16 per pixel for acceptable results. However, the
    calculations for each pixel are independent, which allows the work to be easily
    divided among the army of worker cores. If a gamer has the hardware to handle
    it, SSAO produces believable ambient shadowing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: SSAO 对渲染器来说是一项繁重的工作，因为它需要投影和检查大量额外的点——每个像素至少需要 16 个点才能获得可接受的结果。然而，每个像素的计算是独立的，这使得这些工作能够轻松地分配给大量的工作核心。如果玩家的硬件足够强大，SSAO
    可以产生可信的环境阴影效果。
- en: '**Texture Mapping**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**纹理映射**'
- en: Throughout these discussions of graphics, we have discussed models as though
    their surfaces were one solid color, but that describes few surfaces in the actual
    world. Tigers have stripes, rugs have patterns, wood has grain, and so on. To
    reproduce surfaces with complex coloring, pixel shaders employ *texture mapping*,
    which conceptually wraps a flat image onto the surface of a model, much like an
    advertising wrap on the side of a city bus. To be clear, texture mapping is not
    just for game rendering; movie CGI employs it extensively, too. But texture mapping
    is a special problem for games, in which textures have to be applied in milliseconds.
    The sheer number of textures and texture operations needed for a single frame
    presents one of the greatest challenges of game rendering.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些关于图形的讨论中，我们一直假设模型的表面是单一的颜色，但实际上这种情况在真实世界中很少见。老虎有条纹，地毯有图案，木材有纹理，等等。为了重现复杂颜色的表面，像素着色器使用*纹理映射*，它从概念上将一张平面图像包裹到模型的表面上，就像城市公交车侧面的广告覆盖一样。需要明确的是，纹理映射不仅仅用于游戏渲染；电影
    CGI 也广泛使用它。但纹理映射对于游戏来说是一个特殊的问题，因为纹理必须在毫秒级别内应用。为了渲染一个帧所需的纹理和纹理操作的数量，构成了游戏渲染中的最大挑战之一。
- en: '[Figure 5-15](ch05.html#ch5fig15) shows a texture bitmap (an image of a zigzag
    pattern) and a scene in which the pattern has been applied. Bitmap images used
    for texture mapping are called *textures*. In this case, the surface of the rug
    rectangle is covered by a single large texture, although for regular patterns
    like the one on this rug, a smaller texture can be applied repeatedly to tile
    the surface.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-15](ch05.html#ch5fig15)展示了一幅纹理位图（一个锯齿形图案的图像）和一个应用了该图案的场景。用于纹理映射的位图图像称为*纹理*。在这个案例中，地毯矩形的表面覆盖了一个大纹理，尽管对于像地毯上这种规则图案的纹理，也可以使用较小的纹理并重复应用，铺满整个表面。'
- en: The pixel shader is responsible for choosing the base color of the pixel using
    the associated texture; this base color is later modified by the lighting model.
    Because the textured surface is an arbitrary distance from the viewpoint, and
    at an arbitrary orientation, there’s not a one-to-one correspondence between pixels
    in the texture and pixels on the model’s surface. Choosing pixel colors in a textured
    area based on the applied texture is known as *sampling*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 像素着色器负责使用相关纹理选择像素的基础颜色；这个基础颜色之后会被光照模型修改。由于纹理表面与视点之间的距离和方向是任意的，因此纹理中的像素与模型表面上的像素之间并没有一一对应关系。在纹理区域内根据应用的纹理选择像素颜色的过程被称为*采样*。
- en: '![image](graphics/f05-15.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-15.jpg)'
- en: '*Figure 5-15: Texture mapping. The zigzag texture on top is applied to the
    rug object under the chair.*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-15：纹理映射。顶部的锯齿形纹理应用于椅子下的地毯对象。*'
- en: To illustrate the decisions involved in sampling, let’s start with a bitmap
    of a robot with a hat, shown in [Figure 5-16](ch05.html#ch5fig16). The pixels
    in a texture are called *texels*. This 20×20 texture has 400 texels.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明采样过程中涉及的决策，让我们从[图5-16](ch05.html#ch5fig16)中显示的戴帽子机器人的位图开始。纹理中的像素称为*纹理元素（texels）*。这个20×20的纹理包含400个纹理元素。
- en: In this example, this texture will appear as a painting in the frame on the
    wall in [Figure 5-17](ch05.html#ch5fig17).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这个纹理将作为墙上画框中的一幅画出现，见[图5-17](ch05.html#ch5fig17)。
- en: Suppose that the area inside the frame fills a 10×10 block of pixels in the
    rendered image. The texture will be applied head-on without any adjustment for
    perspective, which means all the renderer has to do is shrink the 20×20 block
    of texels to fit the 10×10 block of pixels in the final image.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设框架内的区域填充了渲染图像中的一个10×10像素块。纹理将直接应用于图像上，而不进行透视调整，这意味着渲染器只需将20×20的纹理元素块缩小到适应最终图像中的10×10像素块。
- en: '![image](graphics/f05-16.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-16.jpg)'
- en: '*Figure 5-16: A texture of a robot wearing a hat*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-16：一个戴帽子的机器人纹理*'
- en: '![image](graphics/f05-17.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-17.jpg)'
- en: '*Figure 5-17: In this scene, the texture of [Figure 5-16](ch05.html#ch5fig16)
    will be applied inside the picture frame on the wall.*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-17：在这个场景中，[图5-16](ch05.html#ch5fig16)中的纹理将应用于墙上画框内。*'
- en: '***Nearest-Neighbor Sampling***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最近邻采样***'
- en: Because 10×10 pixels are needed to fill the textured area, let’s imagine a grid
    of 100 sample points overlaying the texture. [Figure 5-18](ch05.html#ch5fig18)
    shows a closeup section of the original robot texture from [Figure 5-16](ch05.html#ch5fig16).
    Here, the centers of the texels are shown as squares, and the crosses represent
    the sample points for the pixels in the scene. Sampling resolves this mismatch
    of pixels to texels.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要10×10个像素来填充纹理区域，我们可以想象在纹理上覆盖了一张100个采样点的网格。[图5-18](ch05.html#ch5fig18)展示了[图5-16](ch05.html#ch5fig16)中原始机器人纹理的局部放大部分。这里，纹理元素的中心被显示为方块，而十字标记表示场景中像素的采样点。采样解决了纹理元素与像素之间的这种不匹配问题。
- en: The simplest method of sampling is choosing the color of the nearest texel,
    an approach known as *nearest-neighbor sampling*. This approach is easy to implement
    and fast to compute, but tends to look horrible. In this example, each of four
    texels is equally close to the pixel centers, so I’ve arbitrarily chosen the texel
    in the lower right of each pixel center. [Figure 5-19](ch05.html#ch5fig19) shows
    the texels chosen by this sampling method, and the 10×10-pixel block that would
    appear in the final image.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的采样方法是选择最近的纹理元素（texel）的颜色，这种方法被称为*最近邻采样*。这种方法易于实现且计算速度快，但效果通常很差。在这个例子中，四个纹理元素到像素中心的距离相等，因此我任意选择了每个像素中心右下角的纹理元素。[图5-19](ch05.html#ch5fig19)展示了这种采样方法选择的纹理元素，以及最终图像中将出现的10×10像素块。
- en: As you can see, the result looks more like a skeletal aerobics instructor than
    a robot with a hat. If you’ve ever looked closely at an oil painting, you may
    guess why the nearest-neighbor technique produces such an unattractive result.
    Up close, an oil painting reveals a wealth of detail, a multitude of individual
    brushstrokes. Take a few steps back, though, and the strokes vanish as the colors
    blend together in the eye. In the same way, when a texture is represented with
    fewer pixels, the colors of neighboring texels should blend. Nearest-neighbor
    sampling, though, simply picks the color of one texel with no blending; in our
    example, three out of four texels have no influence on the result at all.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，结果看起来更像是一个骨瘦如柴的有氧操教练，而不是一个戴帽子的机器人。如果你曾经仔细观察过油画，你可能猜到为什么最近邻技术会产生如此不吸引人的结果。近距离观察时，油画展示了丰富的细节，成千上万的笔触。但稍微后退几步，这些笔触就消失了，颜色在眼中融合在一起。同样地，当纹理用更少的像素表示时，邻近纹理元素的颜色应该是混合的。然而，最近邻采样只是简单地选取一个纹理元素的颜色，没有任何混合；在我们的例子中，四个纹理元素中有三个对结果完全没有影响。
- en: '![image](graphics/f05-18.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-18.jpg)'
- en: '*Figure 5-18: A close-up section of the [Figure 5-16](ch05.html#ch5fig16) texture.
    Squares are texel centers; crosses are sample points.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-18： [图5-16](ch05.html#ch5fig16)纹理的特写部分。方框是纹理元素的中心；十字是采样点。*'
- en: '![image](graphics/f05-19.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-19.jpg)'
- en: '*Figure 5-19: The result of 10×10 nearest-neighbor sampling on [Figure 5-16](ch05.html#ch5fig16).
    On the left are the selected texels of the original texture, and on the right
    is the resulting bitmap.*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-19：对[图5-16](ch05.html#ch5fig16)进行10×10最近邻采样的结果。左侧是原始纹理的选择纹理元素，右侧是结果位图。*'
- en: When a texture is expanded to fill a larger area, the results are just as ugly.
    In this case, some of the texels will simply be repeated in the textured area,
    producing a blocky result. To see the problem, let’s start with a triangle and
    its representation as a 16×16 anti-aliased texture, as shown in [Figure 5-20](ch05.html#ch5fig20).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当纹理被扩展到填充更大区域时，结果同样是丑陋的。在这种情况下，一些纹理元素（texel）将简单地在纹理区域内重复，从而产生块状效果。为了看清这个问题，我们从一个三角形和它作为16×16反走样纹理的表示开始，如[图5-20](ch05.html#ch5fig20)所示。
- en: '![image](graphics/f05-20.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-20.jpg)'
- en: '*Figure 5-20: A triangle and its representation as an anti-aliased 16×16-pixel
    texture.*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-20：三角形及其作为16×16像素反走样纹理的表示。*'
- en: Now suppose this texture is applied over a 32×32 area. Ideally, it should look
    smoother than the original, smaller texture; the greater resolution offers the
    opportunity for a finer edge. As shown in [Figure 5-21](ch05.html#ch5fig21), though,
    nearest-neighbor sampling puts four sample points in each texel, so every texel
    in the original 16×16 texture simply becomes four identically colored pixels at
    the larger size.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设这个纹理应用在一个32×32的区域上。理想情况下，它应该看起来比原来的小纹理更平滑；更高的分辨率提供了更精细边缘的机会。然而，正如[图5-21](ch05.html#ch5fig21)所示，最近邻采样将每个纹理元素放置在四个采样点上，因此原始的16×16纹理中的每个纹理元素在放大后都变成了四个相同颜色的像素。
- en: '![image](graphics/f05-21.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-21.jpg)'
- en: '*Figure 5-21: When used to enlarge textures, nearest-neighbor sampling merely
    duplicates pixels.*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-21：当用来放大纹理时，最近邻采样仅仅是重复像素。*'
- en: '***Bilinear Filtering***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***双线性过滤***'
- en: A better-looking sampling method is *bilinear filtering*. Instead of taking
    the color of the nearest texel, each texture sample is a proportional blend of
    the four nearest texels. The method is called bilinear because it uses the position
    of the sample point along two axes within the square formed by the four nearest
    texels. For example, in [Figure 5-22](ch05.html#ch5fig22), the sample point toward
    the bottom and just left of center results in the mixing percentages shown. The
    final color of this sample is computed from the colors of the texels at the given
    percentages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好看的采样方法是*双线性过滤*。它不是简单地取最近纹理元素的颜色，而是每个纹理样本是四个最近纹理元素的按比例混合。该方法称为双线性，是因为它利用了采样点在由四个最近纹理元素形成的正方形内沿两个轴的位置。例如，在[图5-22](ch05.html#ch5fig22)中，采样点位于底部并稍微偏左，产生了所示的混合百分比。该样本的最终颜色是根据给定百分比从纹理元素的颜色中计算得出的。
- en: '[Figure 5-23](ch05.html#ch5fig23) shows the robot texture after reduction via
    bilinear filtering. With only a fourth of the original pixels, the reduced version
    necessarily lacks detail, but if you hold the original at arm’s length and compare
    to the reduced version held close, you’ll see the reduction is a good representation,
    and much better than the nearest-neighbor result.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-23](ch05.html#ch5fig23) 显示了经过双线性过滤缩小后的机器人纹理。缩小后的版本只有原始像素的四分之一，必然缺乏细节，但如果将原始纹理置于手臂长度处，并将缩小版置于近处进行对比，你会发现缩小效果非常好，比最近邻结果要好得多。'
- en: '![image](graphics/f05-22.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-22.jpg)'
- en: '*Figure 5-22: Bilinear filtering measures the position of a sample point vertically
    and horizontally within the square of neighboring texels, and uses these positions
    to determine the percentage that each texel influences the sample color.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-22：双线性过滤测量样本点在相邻纹素的正方形内的垂直和水平方向的位置，并利用这些位置来确定每个纹素对样本颜色的影响百分比。*'
- en: '![image](graphics/f05-23.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-23.jpg)'
- en: '*Figure 5-23: The robot texture reduced through bilinear filtering*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-23：通过双线性过滤缩小的机器人纹理*'
- en: '[Figure 5-24](ch05.html#ch5fig24) shows a 32×32 area blown up from the 16×16
    triangle texture using bilinear filtering—a clear improvement over the chunky
    nearest-neighbor sampling.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-24](ch05.html#ch5fig24) 显示了通过双线性过滤放大的 32×32 区域，这是从 16×16 三角形纹理中获取的—相比块状的最近邻采样，这是一个明显的改进。'
- en: '![image](graphics/f05-24.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-24.jpg)'
- en: '*Figure 5-24: The triangle texture expanded through bilinear filtering*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-24：通过双线性过滤扩展的三角形纹理*'
- en: '***Mipmaps***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Mipmap***'
- en: The examples in the previous section show the limit of what is possible with
    bilinear filtering. For bilinear filtering to look good, the texture needs to
    be at least half, but no more than twice, the resolution of the textured area.
    If the texture is any smaller, bilinear filtering still produces blocky results.
    If the texture is too large, even though four texels are used per sample, some
    texels won’t contribute to any samples.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中的示例展示了双线性过滤的局限性。为了使双线性过滤效果良好，纹理的分辨率需要至少是纹理区域的一半，但不能超过两倍。如果纹理太小，双线性过滤仍然会产生块状效果。如果纹理太大，尽管每个采样使用了四个纹素，但有些纹素不会对任何样本产生影响。
- en: 'Avoiding these problems requires a set of different-sized bitmaps for each
    texture: a large, full-resolution version for viewing up close, and smaller versions
    for when the textured area is also small. This collection of progressively smaller
    textures is known as a *mipmap*. An example is shown in [Figure 5-25](ch05.html#ch5fig25).
    Each texture in the mipmap is one-quarter of the area of the next larger texture.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这些问题需要为每个纹理准备一组不同大小的位图：一个用于近距离查看的全分辨率版本，以及在纹理区域较小时使用的小版本。这些逐渐变小的纹理集合称为 *mipmap*。一个示例见于
    [图 5-25](ch05.html#ch5fig25)。mipmap 中的每个纹理都是下一个较大纹理面积的四分之一。
- en: '![image](graphics/f05-25.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-25.jpg)'
- en: '*Figure 5-25: A mipmap is a collection of textures, each one-quarter the size
    of the previous.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-25：mipmap 是一个纹理集合，每个纹理的大小是前一个的四分之一。*'
- en: With a mipmap, the renderer can always find a texture that will produce good
    results with bilinear filtering. If a 110×110 texture is needed, for example,
    the 128×128 texture is shrunk. If a 70×70 texture is required, the 64×64 texture
    is magnified.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 mipmap，渲染器总是能够找到一个合适的纹理，通过双线性过滤产生良好的效果。例如，如果需要 110×110 的纹理，就将 128×128 的纹理缩小。如果需要
    70×70 的纹理，就将 64×64 的纹理放大。
- en: '***Trilinear Filtering***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***三线性过滤***'
- en: While bilinear filtering and mipmaps work reasonably well, they introduce a
    distracting visual anomaly when transitioning from one mipmap texture to another.
    Suppose, in a first-person game, you’re running toward a brick wall that uses
    a mipmapped texture. As you get closer to the wall, the smaller texture will get
    blown up more and more until you reach the point where you get a shrunk-down version
    of the next larger texture in the mipmap. Unfortunately, a larger texture that
    has been reduced through bilinear filtering doesn’t quite match a smaller version
    of the same texture that has been expanded, so at the moment of this transition
    the texture will “pop.” The problem can also occur with no movement at all on
    a surface that stretches out to the distance, such as a long rug in a corridor,
    that has been tiled with a repeating texture; because the parts of rug at different
    distances are covered by different textures in the mipmap, seams will be clearly
    visible where the textures touch.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然双线性过滤和各级贴图（mipmap）通常能很好地工作，但在从一个 mipmap 贴图过渡到另一个 mipmap 贴图时，它们会引入一种令人分心的视觉异常。假设在一款第一人称游戏中，你正在朝着一堵使用
    mipmap 贴图的砖墙跑去。当你靠近墙壁时，较小的贴图会越来越被放大，直到你到达那个点，下一层较大贴图的缩小版本会出现在你面前。不幸的是，通过双线性过滤缩小的较大贴图并不完全与扩展的较小贴图匹配，因此在过渡的那一刻，贴图会“跳动”。这个问题也可能发生在没有任何运动的情况下，比如走廊中铺设的长地毯，地毯上使用了重复的贴图；因为不同距离处的地毯部分被
    mipmap 中不同的贴图覆盖，所以在贴图接触的地方会明显看到接缝。
- en: 'To smooth over the texture transition, the renderer can blend samples from
    different textures in addition to blending between texels in a texture. Suppose
    the area to be textured is 70×70, a size that falls between the 64×64 and 128×128
    textures in a mipmap. Instead of just using bilinear filtering on the nearer-sized
    64×64 texture, the renderer can use bilinear filtering on both the larger and
    smaller textures, then blend the two resulting samples. As with the bilinear filtering
    itself, this final step is proportional: in our example, the color would be mostly
    determined by the result from the 64×64 texture, with a little of the 128×128
    result mixed in. Because we are filtering in two dimensions on each texture, then
    blending the results, this technique is known as *trilinear filtering*. It is
    demonstrated in [Figure 5-26](ch05.html#ch5fig26).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了平滑贴图过渡，渲染器可以在贴图之间进行混合，除了混合贴图中的纹素外，还可以混合来自不同贴图的样本。假设需要贴图的区域是70×70，这个尺寸介于 mipmap
    中的64×64和128×128贴图之间。渲染器不仅仅对较近的64×64贴图进行双线性过滤，它可以对较大和较小的贴图同时进行双线性过滤，然后混合这两个结果样本。就像双线性过滤本身一样，这一步也是按比例进行的：在我们的例子中，颜色大部分由64×64贴图的结果决定，少量128×128贴图的结果混合其中。由于我们在每个贴图上都进行了二维过滤，然后再混合结果，这种技术被称为*三线性过滤*。它在[图
    5-26](ch05.html#ch5fig26)中展示。
- en: Trilinear filtering eliminates popping and seaming between textures in a mipmap,
    but because it requires two bilinear samples and then a final blend, it does over
    twice as much work as bilinear filtering.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 三线性过滤消除了 mipmap 贴图之间的跳动和接缝，但由于它需要两个双线性样本，然后进行最终的混合，它的工作量是双线性过滤的两倍多。
- en: '![image](graphics/f05-26.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-26.jpg)'
- en: '*Figure 5-26: Trilinear filtering takes bilinear samples from the larger and
    smaller textures in a mipmap and blends the results.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-26：三线性过滤从 mipmap 中较大和较小的贴图中获取双线性样本，并混合这些结果。*'
- en: '**Reflections**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**反射**'
- en: 'As discussed in [Chapter 4](ch04.html#ch04), ray tracing naturally captures
    all the effects of light reflecting from one surface to another. Unfortunately,
    the subtle influence of colors of nearby surfaces is nearly impossible to capture
    without ray tracing, but game renderers do have a way to fake what I’ll call *clear
    reflections*: the more obvious, mirror-like reflections on such surfaces as polished
    countertops, windows, and of course mirrors themselves.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第 4 章](ch04.html#ch04)中讨论的，光线追踪自然能够捕捉到光从一个表面反射到另一个表面的所有效果。不幸的是，附近表面颜色的微妙影响几乎无法在没有光线追踪的情况下捕捉到，但游戏渲染器确实有办法伪造我所称之为*清晰反射*的效果：即在抛光的台面、窗户，当然还有镜子本身等表面上，明显的、镜面般的反射。
- en: Games limit which surfaces produce clear reflections. Having just a few objects
    with such reflections maintains the realism of the scene at a much lower computational
    cost. To reduce the workload further, renderers use *environment mapping*, in
    which shiny objects are conceptually placed inside cubes that are texture-mapped
    with a previously rendered image of the object’s surroundings.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏限制了哪些表面能产生清晰的反射。仅有少数物体具有这种反射能保持场景的真实感，并大大降低计算成本。为了进一步减少工作量，渲染器使用*环境映射*，将光亮物体概念性地放置在立方体内部，并用事先渲染的物体周围环境图像进行纹理映射。
- en: '[Figure 5-27](ch05.html#ch5fig27) shows a sample situation: a shiny sports
    car on a showroom turntable. To compute the effect of clear reflections, the renderer
    conceptually places the car in a cube; the cube itself is not rendered, but used
    only to map reflections. The inside of the cube is texture-mapped with an image
    of the showroom interior, as shown in [Figure 5-28](ch05.html#ch5fig28). Because
    the reflected images will be somewhat distorted anyway by the surface of the car
    body, viewers won’t notice that the reflections don’t perfectly match the rendered
    world in which the car is placed.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-27](ch05.html#ch5fig27) 显示了一个示例场景：一辆光亮的跑车在展厅的旋转台上。为了计算清晰反射的效果，渲染器在概念上将汽车放置在一个立方体中；该立方体本身并不被渲染，只是用于映射反射。立方体内部使用展厅内景的图像进行纹理映射，如[图
    5-28](ch05.html#ch5fig28)所示。由于反射图像会因车身表面而有所扭曲，观众不会注意到反射图像与渲染世界中的汽车位置不完全匹配。'
- en: '![image](graphics/f05-27.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-27.jpg)'
- en: '*Figure 5-27: For realism, the shiny car body should reflect the showroom.*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-27：为了逼真，光亮的汽车车身应该反射展厅的景象。*'
- en: '![image](graphics/f05-28.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-28.jpg)'
- en: '*Figure 5-28: For the purpose of mapping reflections, the car is considered
    to be in a cube, the insides of which are covered by a bitmap image of the showroom.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-28：为了映射反射，汽车被视为处于一个立方体内，立方体内部覆盖着展厅的位图图像。*'
- en: Instead of tracing light as it pinballs around the scene, mapping reflections
    becomes an indirect texture-map reference, a relatively simple calculation. Of
    course, the surface of the car is probably also texture-mapped, which means that
    adding reflections is at least doubling the per-pixel effort, but the gain in
    realism is usually worth the extra work.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与其追踪光线在场景中四处反弹，映射反射变成了一种间接的纹理映射引用，这是一种相对简单的计算。当然，汽车表面可能也已经进行了纹理映射，这意味着增加反射至少是加倍了每个像素的计算工作量，但通常这种真实感的提升是值得额外工作量的。
- en: The job becomes harder when a reflecting model is moving, as would happen if
    our car were racing down a desert road in a driving game. The renderer can’t simply
    paste a static image of a desert inside a cube and expect this to fool the viewer.
    Because the viewpoint will be moving with the car as the car travels down the
    road, the reflections must likewise travel— or at least give that appearance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当反射模型在移动时，工作变得更加困难，例如，如果我们的汽车在驾驶游戏中沿沙漠公路行驶。渲染器不能仅仅将一张静态的沙漠图像粘贴到立方体内部并期望能够欺骗观众。由于视点将随着汽车移动，当汽车沿公路行驶时，反射也必须随之移动——或者至少看起来是这样。
- en: There’s an old Hollywood trick that was used to convey the illusion of sideways
    movement in relation to the camera. An actor would stand on a treadmill so he
    could walk without going anywhere. Behind him an illustration of scenery on a
    continuous roll would slide past at the same speed as the treadmill. As long as
    the audience didn’t notice the same trees going by, it looked as though the actor
    was actually moving sideways.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个古老的好莱坞技巧，用来传达与相机相关的横向移动假象。演员会站在跑步机上，这样他就可以走路而不离开原地。在他身后，一幅连续卷轴上的景物插图会与跑步机保持相同的速度滑过。只要观众没有注意到相同的树木不断出现，看起来就像演员正在横向移动。
- en: The same idea can be applied inside the cube around the shiny car. A portion
    of a wide continuous image is selected, as shown in [Figure 5-29](ch05.html#ch5fig29).
    Sliding the selection “window” across the wide image to match the movement of
    the car creates the illusion that the car is reflecting the arid mountains depicted
    in the scene.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的思路可以应用于包围光亮汽车的立方体内部。选择一部分宽广的连续图像，如[图 5-29](ch05.html#ch5fig29)所示。通过将选定的“窗口”滑动在宽图像上，以匹配汽车的运动，产生出汽车反射场景中干旱山脉的假象。
- en: '![image](graphics/f05-29.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-29.jpg)'
- en: '*Figure 5-29: Sliding a window down a wide, continuous image creates the effect
    of movement in mapped reflections.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-29：将一个窗口滑动到一幅宽广的连续图像上，会在映射的反射中创造出运动的效果。*'
- en: '**Faking Curves**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**伪造曲线**'
- en: Nothing in a video game destroys realism faster than a model with easily recognizable
    triangles trying to represent a rounded shape. Early 3D games were filled with
    car tires shaped like octagons and human characters that looked like they were
    made of toy bricks. We’ve already seen one part of the solution to this problem—bending
    the normals of triangle vertices—but producing smooth models requires a whole
    set of techniques.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么能比一个明显可以辨认出三角形的模型更快地破坏视频游戏的真实感了，尤其是当这个模型试图表现一个圆形物体时。早期的3D游戏中，汽车轮胎像八边形一样，人物角色看起来像是由玩具积木做成的。我们已经看到了解决这个问题的部分方法——弯曲三角形顶点的法线——但要生产光滑的模型，还需要一整套技巧。
- en: '***Distant Impostors***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***远距离替代模型***'
- en: An obvious solution to the problem of flat triangles is to break models down
    into so many small triangles that the individual facets are too small to be recognized.
    That works in theory, but even though triangles are simple shapes, there’s still
    a limit to how many can be rendered in the time allowed. Trying to design each
    model at the highest possible detail would slow rendering to a crawl.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 解决平面三角形问题的一个显而易见的方案是将模型拆分为许多小三角形，以至于单独的面无法被识别。理论上是可行的，但即使三角形是简单的形状，渲染的数量仍然受到时间的限制。试图以最高的细节设计每个模型会使渲染速度变得极其缓慢。
- en: A renderer could, however, use lots of extra triangles to smooth out just those
    models closest to the viewpoint. This is the idea behind *distant impostors*.
    Here, each object in a game is modeled twice—a fully detailed high-triangle model
    and a simplified model with relatively few triangles. This simplified model is
    the “impostor” of the original, and is swapped in for the high-quality model whenever
    the model gets beyond a certain distance from the viewpoint.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，渲染器可以使用大量额外的三角形，仅仅平滑那些靠近视点的模型。这就是*远距离替代模型*的思路。在这种方式下，游戏中的每个物体都有两个模型——一个是高度详细的高三角形模型，另一个是简化的低三角形模型。这个简化的模型是原始模型的“替代品”，当模型超出视点的某个距离时，低质量的模型就会替代高质量的模型。
- en: Distant impostors make effective use of rendering time, but because the two
    models are so dissimilar, if a player is watching a particular model while moving
    closer to it, the transition between the models can be visually jarring. Ideally,
    you’d like to give the viewer the feeling that the distant object is revealing
    greater detail as it comes closer, but in practice the two models are so different
    that the replacement looks like one object magically transforming into another.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 远距离替代模型有效利用了渲染时间，但由于这两种模型差异太大，如果玩家在靠近某个特定模型时进行观察，模型之间的过渡可能会显得视觉上很突兀。理想情况下，你希望让观众感觉到远处的物体在靠近时展现出更大的细节，但实际上这两种模型差异太大，以至于替换的效果看起来像是一个物体神奇地变成了另一个物体。
- en: '***Bump Mapping***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***凸凹贴图***'
- en: Another technique for smoothing models keeps the triangle count the same, but
    alters the lighting calculations at each pixel to give the appearance of an irregular
    surface.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种平滑模型的技术是保持三角形数量不变，但在每个像素的光照计算中进行调整，以呈现不规则的表面外观。
- en: To understand why this *bump mapping* method can be so effective, imagine a
    game featuring a hacienda with stucco walls. To get the appearance of stucco,
    the renderer can apply a texture made from an image of an actual stucco wall to
    the walls of the hacienda model. Because stucco is wavy, its undulations should
    be visible under the scene lighting. Merely applying a texture to a flat wall
    wouldn’t convince the eye; it would look like a flat wall with a picture of stucco
    on it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这种*bump mapping*方法如此有效，可以想象一款游戏中有一座带有石膏墙的庄园。为了获得石膏的外观，渲染器可以将一个实际石膏墙的图像作为纹理，应用到庄园模型的墙面上。由于石膏墙是波浪形的，它的起伏应当在场景光照下可见。仅仅将纹理应用到平坦的墙面上并不能让人信服；那看起来就像是一个平坦的墙壁上贴了石膏的图片。
- en: Bump mapping allows flat surfaces to react to light as though they were wavy
    like stucco, bumpy like popcorn ceilings, crumpled, louvered, or anything else.
    The process starts with a grayscale bitmap the same size as the texture that will
    be applied to the model surface. This bitmap is known as a *height map*, because
    the brightness of each pixel indicates the height of the surface.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 凸凹贴图使得平面表面能够像石膏墙那样呈现波浪状，像爆米花天花板那样颠簸，或者像皱褶、百叶窗等其他形态那样反应光照。该过程从一个与将要应用到模型表面的纹理相同大小的灰度位图开始。这个位图被称为*高度图*，因为每个像素的亮度表示表面的高度。
- en: The height map allows a pixel shader to approximate the surface normal at each
    pixel location. This is easiest to understand in 2D. [Figure 5-30](ch05.html#ch5fig30)
    shows a row of 10 pixels. The numbers at the bottom represent the height of each
    pixel. The 10 points are shown at proportionate heights, along with the surface
    normals. I’ve added gray lines to show how the normals for the fourth and seventh
    points are computed. An imaginary line is drawn between the two points on either
    side of a chosen point; then, the normal for the chosen point is set perpendicular
    to this line.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 高度图允许像素着色器在每个像素位置近似表面法线。最容易理解的是在2D中。[图 5-30](ch05.html#ch5fig30)显示了一排10个像素。底部的数字表示每个像素的高度。10个点按比例显示，并附有表面法线。我添加了灰色线条以显示如何计算第4和第7个点的法线。通过两侧的两个点画一条假想线，然后，选择的点的法线设置为垂直于这条线。
- en: '![image](graphics/f05-30.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-30.jpg)'
- en: '*Figure 5-30: A row of pixels with light calculations altered by bump mapping.
    The numbers indicate the artificial height of each pixel. The renderer determines
    the normal at each pixel based on the heights of neighboring pixels.*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-30：一排像素，通过凹凸贴图改变了光照计算。数字表示每个像素的人工高度。渲染器根据相邻像素的高度来确定每个像素的法线。*'
- en: These bent normals affect the calculations for both diffuse and specular lighting,
    allowing a flat surface to react to light as though it were rough or wavy. As
    with previous tricks that involved bending normals, though, a surface with a bump
    map is still a flat surface. The points on the surface are not actually raised
    or lowered, but merely react to light as though they were pointing in different
    directions. As a player moving through a 3D scene passes a bump-mapped model,
    the lighting on the surface will change in a realistic manner, but the edges of
    the model will still be straight, possibly giving the game away. Just as the rim
    of the tumbler back in [Figure 5-8](ch05.html#ch5fig8) betrayed the straight lines
    on the model, the outside corners of our bump-mapped hacienda will be perfectly
    straight when they should be wavy, because bump mapping doesn’t alter the shape
    of the flat wall.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些弯曲的法线会影响漫反射和镜面反射光照的计算，使得平面表面能够像粗糙或波动的表面一样响应光线。然而，正如之前涉及弯曲法线的技巧一样，带有凹凸贴图的表面仍然是平面表面。表面上的点实际上并没有被抬高或降低，它们仅仅是以不同的方向响应光线。当玩家在3D场景中经过一个带有凹凸贴图的模型时，表面的光照会以逼真的方式变化，但模型的边缘仍然是直的，这可能会暴露出游戏的痕迹。就像[图
    5-8](ch05.html#ch5fig8)中杯缘暴露出模型上的直线一样，我们的凹凸贴图哈西恩达模型的外角将是完全直的，而应该是波浪形的，因为凹凸贴图并没有改变平面墙面的形状。
- en: '***Tessellation***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***细分***'
- en: Suppose you’re playing a fantasy game, and all your attention is focused on
    a huge ogre slowly approaching with an axe in his hands. As a gamer, you want
    this ogre to look as good as possible even as he gets close enough to nearly fill
    the screen, but you don’t want him made out of so many triangles that the frame
    rate is too low for you to effectively fight him.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在玩一个幻想游戏，所有注意力都集中在一只慢慢接近的巨大巨魔身上，手里拿着一把斧头。作为玩家，你希望这只巨魔看起来尽可能好，即使它接近到几乎填满整个屏幕，但你不希望它由太多三角形构成，以至于帧率太低，无法有效地与它战斗。
- en: If the renderer uses a distant impostor, though, there will be a jarring transition
    that will remind you that you’re just playing a game. If the renderer bump-maps
    the ogre model, the light will reflect realistically off the rivets in his armor,
    but the neat lighting effect won’t hide the fact that the model just has too few
    triangles to be viewed up close.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果渲染器使用远距离替代物（impostor），就会出现突兀的过渡，提醒你这只是一个游戏。如果渲染器对巨魔模型进行凹凸贴图处理，光照会从他的盔甲上的铆钉反射出来，但这种精细的光照效果掩盖不住模型由于三角形数量太少而无法近距离观察的事实。
- en: A process known as *tessellation* solves this problem. First, each triangle
    in the ogre model is subdivided into more triangles. The corners of these new
    triangles are then manipulated independently inward or outward (that is, up or
    down in relation to the original triangle) using a height map. Instead of merely
    bending normals to trick the lighting model as bump mapping does, tessellation
    actually produces a model with more detail. [Figure 5-31](ch05.html#ch5fig31)
    demonstrates the process for a single triangle.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一种称为*细分*的过程解决了这个问题。首先，哥布林模型中的每个三角形被细分为更多的三角形。这些新三角形的角被独立地向内或向外（即相对于原始三角形向上或向下）使用高度图进行操作。与凹凸贴图仅通过弯曲法线来欺骗光照模型不同，细分实际上生成了一个更复杂、细节更多的模型。[图
    5-31](ch05.html#ch5fig31)展示了单个三角形的过程。
- en: This method is a great way to cover up the straight lines of triangles and is
    a clear improvement in appearance over bump mapping and distant impostors. Because
    the model is actually deformed into a new, more complicated shape, even the edges
    of the model are properly affected, unlike with bump mapping. Also, unlike the
    distant impostor technique, the model improves gradually as the distance from
    the viewpoint decreases, avoiding the sharp transition when models are swapped.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是掩盖三角形直线的好方法，并且在外观上明显优于凹凸贴图和远程替代模型技术。因为模型实际上被变形为一个新的、更复杂的形状，即使是模型的边缘也会受到适当影响，这不同于凹凸贴图的情况。此外，与远程替代技术不同，模型随着视点距离的减小而逐渐改善，避免了模型切换时的剧烈过渡。
- en: '![image](graphics/f05-31.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-31.jpg)'
- en: '*Figure 5-31: A triangle is tessellated, producing a web of smaller triangles.
    These new triangle vertices are then manipulated using a height map to produce
    the more complex surface on the bottom.*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-31：一个三角形被细分，形成一个由更小的三角形组成的网格。这些新三角形的顶点随后通过高度图进行操作，产生底部的更复杂表面。*'
- en: Though you might think that tessellation is used extensively in games, it’s
    not, because it inflicts a much larger performance hit than the simpler methods
    discussed earlier. Creating more complex models on the fly is a lot more work
    than accessing one of several premade models as in the distant impostor method,
    or adjusting normals in bump mapping.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能认为细分技术在游戏中被广泛使用，但事实并非如此，因为它带来的性能影响远远大于之前讨论的更简单的方法。实时创建更复杂的模型比访问几个预制的模型（如远程替代模型方法）或调整法线（如凹凸贴图）要费力得多。
- en: Tessellation is therefore used where the results are most obvious. For example,
    in a game set outdoors, the ground beneath the avatar’s feet may stretch far into
    the distance. Modeling the ground in great detail would require a huge number
    of triangles, creating a performance bottleneck, but if the ground model has a
    low triangle count, the ground closest to the viewer will have an unrealistic,
    angular appearance. Tessellation can smooth out just the closest part of the ground.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，细分技术通常用于效果最为显著的地方。例如，在一个设定在户外的游戏中，角色脚下的地面可能延伸得非常远。若要对地面进行精细建模，将需要大量的三角形，这会成为性能瓶颈；但如果地面模型的三角形数量较少，离观众最近的地面将呈现出不真实的棱角感。细分技术能够平滑地面中最接近观众的部分。
- en: '**Anti-Aliasing in Real Time**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实时抗锯齿**'
- en: 'All of the renderer’s hard work can go down the drain if individual pixels
    become clearly visible through aliasing. As with movie CGI, games need some form
    of full-screen anti-aliasing to smooth over the edges of models and surfaces.
    With ray tracing, anti-aliasing is conceptually simple: send out more beams than
    pixels and blend the results. Game renderers, though, must use more efficient
    techniques.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单个像素因锯齿而变得明显可见，渲染器的辛勤工作将毫无意义。与电影 CGI 相似，游戏需要某种形式的全屏抗锯齿来平滑模型和表面的边缘。对于光线追踪，抗锯齿在概念上是简单的：发射比像素更多的光束并融合结果。然而，游戏渲染器必须使用更高效的技术。
- en: '***Supersampling***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***超采样***'
- en: The most direct approximation to casting multiple beams is known as *supersampling
    anti-aliasing (SSAA)*. Instead of casting multiple beams per pixel, supersampling
    renders an intermediate image that is much larger than the desired final image.
    The color of each pixel in the final image is a blend of a sample of pixels from
    the larger image.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与发射多束光线的最直接近似方法被称为*超采样抗锯齿（SSAA）*。与其每个像素发射多束光线，超采样会渲染一个比目标最终图像大得多的中间图像。最终图像中每个像素的颜色是来自更大图像中多个像素样本的混合。
- en: Consider the two white triangles covered by a gray triangle shown in [Figure
    5-32](ch05.html#ch5fig32). Note that the edges of the white triangles won’t be
    visible in the rendered image but are shown here for clarity.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请看[图 5-32](ch05.html#ch5fig32)中被灰色三角形覆盖的两个白色三角形。注意，白色三角形的边缘在渲染图像中不可见，但这里为了清晰起见展示了它们。
- en: '![image](graphics/f05-32.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-32.jpg)'
- en: '*Figure 5-32: An arrangement of three triangles*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-32：三个三角形的排列*'
- en: '[Figure 5-33](ch05.html#ch5fig33) demonstrates a basic rendering of these triangles
    at an 8×4 resolution. Each pixel is colored gray or white depending on whether
    the pixel center lies within the area of the gray triangle in the foreground.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-33](ch05.html#ch5fig33)展示了这些三角形在 8×4 分辨率下的基本渲染。每个像素根据像素中心是否位于前景中的灰色三角形区域内，分别被着色为灰色或白色。'
- en: '![image](graphics/f05-33.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-33.jpg)'
- en: '*Figure 5-33: Coloring pixels without anti-aliasing*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-33：没有抗锯齿的像素着色*'
- en: To produce an 8×4 supersampled image, the triangles are first rendered at a
    16×8 resolution as shown in [Figure 5-34](ch05.html#ch5fig34).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成 8×4 的超采样图像，首先将三角形以 16×8 分辨率渲染，如[图 5-34](ch05.html#ch5fig34)所示。
- en: '![image](graphics/f05-34.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-34.jpg)'
- en: '*Figure 5-34: Supersampling the three triangles. Here, each pixel in the final
    bitmap is represented by four subpixels with scattered sample points.*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-34：对三个三角形进行超采样。在这里，最终位图中的每个像素由四个具有分散采样点的子像素表示。*'
- en: As you can see, each pixel in [Figure 5-33](ch05.html#ch5fig33) has become four
    smaller pixels in [Figure 5-34](ch05.html#ch5fig34). These smaller pixels are
    called *subpixels*. Using this higher-resolution rendering, the color of each
    pixel in the final rendering is a proportional blend of the colors of its four
    subpixels, as shown in [Figure 5-35](ch05.html#ch5fig35).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，[图 5-33](ch05.html#ch5fig33)中的每个像素在[图 5-34](ch05.html#ch5fig34)中变成了四个更小的像素。这些更小的像素称为*子像素*。通过这种高分辨率的渲染，最终渲染中每个像素的颜色是其四个子像素颜色的按比例混合，如[图
    5-35](ch05.html#ch5fig35)所示。
- en: '![image](graphics/f05-35.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-35.jpg)'
- en: '*Figure 5-35: Coloring each pixel by blending subpixels*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-35：通过混合子像素来着色每个像素*'
- en: Supersampling does a nice job of smoothing out the jaggies, but as you might
    expect, rendering the image at a much higher resolution incurs a large performance
    penalty. Sampling four pixels to make one pixel in the final image is four times
    as much work for the pixel shader. In this example, I’ve kept things simple by
    assigning a flat color to each triangle, but in a typical game render each subpixel
    represents, at a minimum, a texture map sample followed by lighting calculations.
    Although earlier generations of video games commonly used SSAA, it’s rare to see
    this method now.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 超采样能很好地平滑锯齿，但正如你所预料的，使用更高的分辨率渲染图像会带来较大的性能开销。为了在最终图像中生成一个像素，需要对四个像素进行采样，这意味着像素着色器要处理四倍的工作量。在这个例子中，我通过给每个三角形分配一个平面颜色来简化问题，但在典型的游戏渲染中，每个子像素至少代表一个纹理映射样本，接着进行光照计算。尽管早期的电子游戏常常使用
    SSAA，但如今这种方法已经很少见了。
- en: '***Multisampling***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多重采样***'
- en: In the previous example you can see that when all four subpixels are inside
    the same triangle, supersampling doesn’t accomplish anything. To reduce the performance
    hit of anti-aliasing, the subpixel work can be limited to the edges of triangles
    where the jaggies occur, a technique known as *multisample anti-aliasing (MSAA)*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你可以看到，当所有四个子像素都在同一个三角形内时，超采样并没有起到任何作用。为了减少抗锯齿带来的性能损耗，可以将子像素的处理限制在三角形的边缘，这些边缘正是锯齿出现的地方，这就是一种叫做*多重采样抗锯齿（MSAA）*的技术。
- en: '[Figure 5-36](ch05.html#ch5fig36) demonstrates one version of this concept.
    Two pixels lie across the edge between two triangles. With supersampling, each
    of the eight subpixels is texture-sampled and individually colored by scene lighting.
    With multisampling, there are still eight subpixels for the two pixels, but not
    eight samples. Instead, the renderer first determines which triangle contains
    each subpixel. Each of the four subpixels that lie within the same triangle is
    given the same color, which has been sampled from a point midway between the subpixel
    sample points. So while supersampling colors eight subpixels A through H, multisampling
    colors only four subpixels A through D, which means substantially less work in
    texture mapping and lighting.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-36](ch05.html#ch5fig36)展示了这一概念的一个版本。两个像素位于两个三角形的边缘上。使用超采样时，每个八个子像素都进行纹理采样，并根据场景光照单独着色。使用多重采样时，两个像素仍然有八个子像素，但不是八个样本。相反，渲染器首先确定每个子像素所属的三角形。每个位于同一三角形内的四个子像素被赋予相同的颜色，这个颜色是从子像素采样点之间的中间点采样得到的。因此，虽然超采样为八个子像素A到H着色，但多重采样只为四个子像素A到D着色，这意味着在纹理映射和光照方面的工作量大大减少。'
- en: '![image](graphics/f05-36.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-36.jpg)'
- en: '*Figure 5-36: Comparing supersampling and multisampling*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-36: 比较超采样和多重采样*'
- en: When all four subpixels lie within the interior of the same triangle, multisampling
    colors only one subpixel per final pixel, introducing little computational overhead.
    Multisampling puts in extra effort where it is most needed—reducing jaggies at
    edges—and thus is an efficient use of rendering time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有四个子像素都位于同一个三角形内部时，多重采样每个最终像素仅对一个子像素进行采样，从而引入很小的计算开销。多重采样将额外的计算资源集中在最需要的地方——减少边缘的锯齿——因此，它是渲染时间的高效利用。
- en: '***Post-Process Anti-Aliasing***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***后处理抗锯齿***'
- en: Performance can be improved even further by delaying anti-aliasing until the
    image is rendered, an idea known as *post-process anti-aliasing*. That is, the
    image is first rendered normally at the desired final resolution, and then the
    jaggies are identified and smoothed over. In essence, a post-process anti-aliasing
    technique decides that some of the pixels in an image are colored incorrectly
    based on nothing more than the colors of the pixels themselves.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将抗锯齿延迟到图像渲染完成后再进行处理，可以进一步提高性能，这种方法被称为*后处理抗锯齿*。也就是说，图像首先以所需的最终分辨率正常渲染，然后识别并平滑锯齿。实质上，后处理抗锯齿技术认为图像中的某些像素颜色是错误的，这一判断仅仅基于这些像素自身的颜色。
- en: One such method is called *fast approximate anti-aliasing*, or *FXAA*. (Why
    that wouldn’t be F*A*AA is perhaps a question we’re not supposed to ask.) The
    idea behind FXAA is to find pixels that are likely to be along the edge between
    overlapping triangles, and then blend neighboring pixel colors to smooth the jarring
    transition.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一种这样的技术叫做*快速近似抗锯齿*，或*FXAA*。（为什么它不是F*A*AA，也许是一个我们不应该问的问题。）FXAA的理念是找出可能位于重叠三角形边缘上的像素，然后混合相邻像素的颜色，以平滑突兀的过渡。
- en: FXAA examines each pixel in the image separately—let’s call the pixel under
    examination the *current* pixel. The process starts by computing the perceived
    brightness of the current pixel and its four immediate neighbors, similar to examining
    a black-and-white version of the image. The brightest and dimmest pixels in the
    neighborhood are selected, as shown in [Figure 5-37](ch05.html#ch5fig37), and
    their difference is compared to a cut-off value. This test ensures that the anti-aliasing
    is applied only to pixel neighborhoods of high contrast—areas where the difference
    between the brightest and dimmest pixels is large.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: FXAA会单独检查图像中的每个像素——我们将正在检查的像素称为*当前*像素。该过程首先计算当前像素及其四个直接邻居的感知亮度，类似于检查图像的黑白版本。选择邻域中最亮和最暗的像素，如[图
    5-37](ch05.html#ch5fig37)所示，然后将它们的差异与设定的阈值进行比较。此测试确保抗锯齿仅应用于高对比度的像素邻域——即最亮和最暗像素之间差异较大的区域。
- en: '![image](graphics/f05-37.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-37.jpg)'
- en: '*Figure 5-37: Checking the level of contrast in a pixel’s neighborhood*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-37: 检查像素邻域的对比度水平*'
- en: These high-contrast areas likely represent jagged edges that need to be smoothed,
    and each such area is further examined as shown in [Figure 5-38](ch05.html#ch5fig38).
    The 3×3 block of pixels centered on the current pixel is considered both as a
    set of three columns and a set of three rows to determine whether this is a horizontal
    or vertical edge. In this example, because the columns are similar to each other
    but one row strongly contrasts with the other two, this would be classified as
    a horizontal edge.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高对比度区域很可能表示需要平滑的锯齿边缘，每个这样的区域会进一步检查，如[图 5-38](ch05.html#ch5fig38)所示。以当前像素为中心的
    3×3 像素块，既被视为三列像素，也被视为三行像素，从而确定这是水平边缘还是垂直边缘。在这个例子中，因为列之间比较相似，而其中一行与其他两行有较强的对比度，因此这将被归类为水平边缘。
- en: '![image](graphics/f05-38.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-38.jpg)'
- en: '*Figure 5-38: Looking for contrast in the columns and rows of a pixel neighborhood*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-38：在像素邻域的列和行中寻找对比度*'
- en: Because this is a horizontal edge, the next step is to compare the pixels above
    and below the current pixel to find which contrasts the most with the current
    pixel. In this case, the pixel above is much brighter than the current pixel,
    while the pixel below is quite similar. This means the detected edge is between
    the current pixel and its topside neighbor. To anti-alias this edge, the current
    pixel will be replaced by a bilinear sample between the pixel centers, shown as
    the white circle in [Figure 5-39](ch05.html#ch5fig39). FXAA examines other pixels
    along the edge to determine how jagged the edge is, adjusting the degree of blending
    by placing the sample point farther from the center of the current pixel.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个水平边缘，下一步是比较当前像素上下方的像素，找出哪个与当前像素的对比度最大。在这种情况下，位于上方的像素比当前像素亮得多，而下方的像素则相似。这意味着检测到的边缘位于当前像素与其上方邻居之间。为了抗锯齿处理这一边缘，当前像素将被替换为两个像素中心之间的双线性采样，显示为[图
    5-39](ch05.html#ch5fig39)中的白色圆圈。FXAA 会检查边缘上其他像素，以确定边缘的锯齿程度，并通过将采样点远离当前像素中心来调整混合的程度。
- en: '![image](graphics/f05-39.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-39.jpg)'
- en: '*Figure 5-39: To smooth this edge, FXAA will replace the color of the center
    pixel with a bilinear sample at the circle point.*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-39：为了平滑这个边缘，FXAA 会将中心像素的颜色替换为圆点处的双线性采样。*'
- en: A post-process anti-aliasing method like FXAA is very fast compared to supersampling
    or even multisampling because it doesn’t create any sub-pixels at all. However,
    the results of FXAA are not always as impressive as other methods. In particular,
    FXAA can sometimes blur areas that weren’t actually aliased; unlike supersampling,
    post-process methods like FXAA are only guessing where the edges are, so areas
    of high contrast within textures may fool the algorithm.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 像 FXAA 这样的后处理抗锯齿方法比超采样甚至多重采样快得多，因为它完全不创建任何子像素。然而，FXAA 的结果并不总是像其他方法那样令人印象深刻。特别是，FXAA
    有时会模糊那些实际上并没有锯齿的区域；与超采样不同，像 FXAA 这样的后处理方法只是猜测边缘的位置，因此纹理中的高对比度区域可能会欺骗算法。
- en: '**The Rendering Budget**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**渲染预算**'
- en: The trade-offs that accompany different anti-aliasing techniques mean that developers
    of real-time graphics applications must choose between best quality and best performance.
    Is FXAA good enough for this situation? Or is MSAA necessary? This choice, though,
    is not made in isolation. More broadly, game developers must review all the techniques
    available for real-time rendering—lighting and shadows and anti-aliasing, and
    lots of other possibilities we don’t have the space to discuss, like motion blur
    and particle systems—and select a set that maximizes the quality of the images
    without exceeding the time allowed for rendering. Within that ¹/[60] of a second,
    a surprising amount of work can be done, but all of the best-looking techniques
    can’t be used, so sacrifices have to be made somewhere.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不同抗锯齿技术的权衡意味着实时图形应用程序的开发人员必须在最佳质量和最佳性能之间做出选择。FXAA 对这种情况足够好吗？还是必须使用 MSAA？然而，这个选择并不是孤立做出的。从更广泛的角度来看，游戏开发人员必须审视所有实时渲染可用的技术——光照、阴影、抗锯齿，还有许多其他我们没有空间讨论的可能性，比如运动模糊和粒子系统——并选择一套最大化图像质量而不超出渲染时间限制的技术。在那
    ¹/[60] 秒内，可以完成大量的工作，但并不能使用所有最漂亮的技术，因此必须在某些地方做出妥协。
- en: On a console or in a mobile game, these choices are usually all made by the
    game designer. On PCs, a degree of choice is usually afforded to the user, who
    is given controls to raise or lower the resolution of textures, select the method
    of texture filtering, choose among anti-aliasing methods, turn shadows and reflections
    on or off, and tweak the renderer in a host of other ways. In part, this control
    is given so the user can adjust the render workload to match the performance of
    the particular system, since the PC in question might be top of the line, or an
    aging clunker.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台或移动游戏中，这些选择通常由游戏设计师做出。在PC上，通常会提供一定的选择余地，用户可以调整纹理分辨率，选择纹理过滤方法，选择抗锯齿方法，开启或关闭阴影和反射，甚至可以在多种方式中微调渲染器。部分原因是，给予用户这些控制选项是为了让他们根据系统的性能调整渲染工作负载，因为这台PC可能是顶级的，也可能是一台老旧的电脑。
- en: 'Beyond that, though, detailed rendering options reflect the truth that beauty
    is subjective: what impresses one viewer might have no effect on another. Some
    gamers are horrified by jagged edges, for example, and always crank up anti-aliasing
    to the maximum, while others wouldn’t dream of devoting precious processor cycles
    to removing jaggies when there are more realistic shadows to be had instead. In
    a sense, video games are all about placing ourselves inside believable illusions,
    and what we believe is up to us.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，详细的渲染选项体现了一个事实：美丽是主观的——某些视觉效果令一个观众印象深刻，而另一个观众可能毫无感觉。例如，有些玩家对锯齿状的边缘感到恐惧，通常会将抗锯齿调整到最大，而另一些玩家则不愿将宝贵的处理器周期浪费在去除锯齿上，而更愿意去优化更具现实感的阴影。某种程度上，视频游戏的核心就是让我们置身于可信的虚拟世界，而我们相信的内容，完全取决于我们自己。
- en: '**What’s Next for Game Graphics**'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏图形的未来**'
- en: So where do game graphics go from here? We can expect game programmers to continue
    to be challenged by advancements in displays. Monitors keep increasing in resolution,
    eating away some of the benefit of each new GPU generation. A special challenge
    will come from virtual reality (VR) headsets, which combine displays mounted inside
    helmets with sensors to track the gamer’s head movements. VR headsets can be trouble
    if the display lags behind the movement—our brains don’t like conflicting information,
    and when our eyes are saying one thing, and our inner ear something else, the
    result for many people is nausea. In a game played on a normal flat screen, gamers
    would prefer a consistently high frame rate but don’t get too bent out of shape
    by sporadic dips in the number; with VR devices, an absolutely rock-steady frame
    rate is imperative.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，游戏图形未来将会如何发展呢？我们可以预见，游戏程序员将继续面临显示技术进步带来的挑战。显示器的分辨率不断提高，逐渐削弱了每一代GPU的优势。虚拟现实（VR）头盔将带来一个特殊的挑战，它结合了头盔内置的显示屏和传感器，用于追踪玩家的头部动作。如果显示延迟了运动，VR头盔可能会带来麻烦——我们的脑袋不喜欢冲突的信息，当我们的眼睛看到一个东西，而内耳感受到另一个时，很多人会感到恶心。在普通平面屏幕上玩游戏时，玩家希望能获得稳定的高帧率，但如果偶尔出现帧率下降，他们通常不会太过在意；而使用VR设备时，帧率的稳定性至关重要。
- en: Beyond matching the needs of displays, it’s difficult to predict exactly how
    game graphics will progress. Over the past decade, every time I’ve played a new
    AAA game (as the industry calls the biggest-budget titles), I find myself thinking
    the graphics can’t get any better, that whatever improvements the next generation
    of hardware brings will be insignificant. And every time, I’ve been proven wrong.
    So I’m confident that I’ll continue to be blown away by the advances in game graphics,
    even if I can’t be sure what those advances will be.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 超越满足显示需求，确切预测游戏图形如何发展是困难的。在过去的十年里，每当我玩一个新的AAA游戏（业内对最高预算游戏的称呼），我都会认为图形不可能再做得更好了，认为下一代硬件带来的任何改进都将微不足道。而每次，我都被证明是错的。所以我相信，即使我无法确定这些进展会是什么，我仍然会继续为游戏图形的进步感到震撼。
- en: Raw hardware power is only part of the equation. Buying a new GPU with twice
    as many cores as an older GPU means the hardware can process twice as many triangles
    in the same allotment of time, but once triangle counts get high enough, doubling
    them doesn’t improve the resulting images very much. Indeed, at some point, models
    may get so detailed and triangle counts so high that the average triangle will
    occupy less than a one-pixel area on the screen. When that happens, it will call
    into question the whole idea of rendering the scene as a series of triangles.
    Rather than projecting three triangle vertices to determine the color of one pixel,
    renderers may replace triangles with single points of fixed volume—imagine building
    a sculpture out of tiny marshmallows.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 原始硬件性能只是问题的一部分。购买一款核心数量是旧款GPU两倍的新GPU意味着硬件在相同的时间分配内可以处理两倍的三角形，但一旦三角形的数量足够多，简单地将数量加倍并不会显著改善最终的图像质量。事实上，在某些时候，模型的细节可能会变得非常复杂，三角形的数量如此之高，以至于每个三角形占据的屏幕面积不到一个像素。当这种情况发生时，整个将场景渲染为三角形的概念就会受到质疑。渲染器可能不再使用三角形来确定一个像素的颜色，而是用体积固定的单个点来代替三角形——可以想象用小巧的棉花糖来雕刻一座雕塑。
- en: What ultimately drives advancements in game graphics, though, isn’t hardware,
    but the creativity of graphics programmers. Many of the techniques in [Chapter
    4](ch04.html#ch04) are about making accurate, or at least plausible, simulations
    of how light and vision work in the real world. Game graphics are just about making
    results that look good. That gives programmers enormous leeway to experiment,
    to find new ways to spend part of the precious rendering budget, to find new tricks
    to put silly grins on the faces of gamers. I don’t know for sure what game developers
    are cooking up for the next generation of games, but I’m sure that they’ll continue
    to put my GPU to work in ways that will thrill and amaze.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，推动游戏图形发展的最终动力并不是硬件，而是图形程序员的创造力。[第4章](ch04.html#ch04)中介绍的许多技术，都是关于如何精确地，或者至少合理地模拟现实世界中光线和视觉的工作原理。游戏图形的目标仅仅是产生看起来不错的效果。这给程序员提供了极大的发挥空间，去尝试新的方法，找出如何在有限的渲染预算中找到新花样，去为玩家脸上带来傻乎乎的笑容。我不确定游戏开发者们为下一代游戏准备了什么，但我相信他们一定会继续让我的GPU在令人激动和惊叹的方式下工作。
