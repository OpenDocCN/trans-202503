- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: BINARY SEARCH
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common1.jpg)'
- en: This chapter is all about binary search. If you don’t know what binary search
    is— excellent! I’m excited for the opportunity to teach you a systematic, performant
    technique for isolating an optimal solution from among zillions of possible solutions.
    And if you do know what binary search is and think that it’s just for searching
    a sorted array—excellent! You’ll learn that binary search is for so much more
    than that. To keep things fresh, we will not search a sorted array in this entire
    chapter, not even once.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容完全是关于二分查找的。如果你不知道二分查找是什么——太棒了！我很高兴有机会教你一种系统的、高效的技术，用来在成千上万的可能解中找到最佳解。如果你知道二分查找是什么，并且认为它只是用来搜索已排序的数组——也太棒了！你将会学到，二分查找不仅仅是为了这个。在本章中，我们将不会搜索已排序的数组，甚至一次也不做。
- en: What do minimizing the amount of liquid needed to feed ants, maximizing the
    minimum jump distance between rocks, finding the best living area in a city, and
    flipping switches to open cave doors have in common? Let’s find out.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化喂养蚂蚁所需的液体量、最大化岩石之间最小跳跃距离、寻找城市中最佳的居住区域以及通过切换开关打开洞穴门，这些问题有什么共同点？让我们一探究竟。
- en: 'Problem 1: Feeding Ants'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 1：喂蚂蚁
- en: This is DMOJ problem `coci14c4p4`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `coci14c4p4`。
- en: '#### *The Problem*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *问题*'
- en: Bobi has a terrarium in the shape of a tree. Each edge of the tree is a pipe
    in which liquid flows down. Some pipes are superpipes that increase the amount
    of liquid that flows through them. Bobi keeps one of his pet ants in each of the
    tree’s leaves. (Yes, this context is a reach. I won’t pretend otherwise, but this
    problem is otherwise ace.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Bobi 有一个形状像树的玻璃箱。树的每一条边都是一根管道，液体沿着这些管道流下。某些管道是超级管道，可以增加通过它们的液体量。Bobi 在树的每一片叶子上放置了一只他的宠物蚂蚁。（是的，这个背景设定有点牵强，我不会装作没有意识到，但这个问题本身是非常棒的。）
- en: Each pipe has a percentage value that indicates the percentage of the available
    liquid that flows through it. For example, suppose that a node *n* has three downward
    pipes, where those pipes have percentage values of 20 percent, 50 percent, and
    30 percent, respectively. If 20 liters of liquid arrive at Node *n*, then the
    20 percent pipe gets 20 × 0.2 = 4 liters, the 50 percent pipe gets 20 × 0.5 =
    10 liters, and the 30 percent pipe gets 20 × 0.3 = 6 liters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每根管道都有一个百分比值，表示通过它的液体占总液体的百分比。例如，假设某个节点 *n* 有三根向下的管道，这些管道的百分比值分别是 20%、50% 和
    30%。如果 20 升液体到达节点 *n*，那么 20% 的管道会得到 20 × 0.2 = 4 升，50% 的管道会得到 20 × 0.5 = 10 升，30%
    的管道会得到 20 × 0.3 = 6 升。
- en: Now consider the superpipes. For each superpipe, Bobi decides whether its special
    behavior is off or on. If it is off, then it behaves like a regular pipe. If it
    is on, then it squares the amount of liquid that it receives.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑超级管道。对于每个超级管道，Bobi 决定它的特殊行为是开启还是关闭。如果它关闭，那么它像普通管道一样工作。如果它开启，那么它会将接收到的液体量平方。
- en: Bobi pours liquid into the root of the tree. His goal is to give each ant at
    least the amount of liquid that it requires and to do so by pouring as little
    liquid as possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Bobi 将液体倒入树的根部。他的目标是给每只蚂蚁至少提供它所需的液体，并且尽可能少地倒入液体。
- en: Let’s make this description concrete by studying a sample terrarium; see [Figure
    7-1](ch07.xhtml#ch07fig01).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过研究一个样本玻璃箱来具体化这个描述；见 [图 7-1](ch07.xhtml#ch07fig01)。
- en: '![Image](../images/ch07fig01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch07fig01.jpg)'
- en: '*Figure 7-1: A sample terrarium*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：一个样本玻璃箱*'
- en: I’ve numbered the nodes from 1 to 6; the leaf nodes (2, 3, 5, and 6) have an
    additional annotation giving the amount of liquid required by each ant. I’ve also
    annotated each edge with its percentage value. Notice that the percentage values
    of the downward pipes leaving a given node always add up to 100 percent.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将节点编号为 1 到 6；叶子节点（2、3、5 和 6）有一个额外的注释，标明了每只蚂蚁所需的液体量。我还在每条边上标注了它的百分比值。注意，从给定节点出发的向下管道的百分比值总和总是
    100%。
- en: There’s one superpipe in the tree, from Node 1 to Node 4; I’ve drawn that with
    a thicker edge. Suppose that 20 liters of liquid are poured into the root. The
    superpipe gets 30 percent of the 20 liters, which is 6 liters. If the superpipe’s
    special behavior is off, then 6 liters flow through it. However, if the superpipe’s
    special behavior is on, then, instead of 6 liters of liquid flowing through it,
    6² = 36 liters of liquid flow through it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of nodes in the tree. *n* is between 1 and
    1,000\. The tree nodes are numbered from 1 to *n*, and the root of the tree is
    node 1.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* – 1 lines used to build the tree. Each of these lines represents one pipe
    and consists of four integers: the two nodes connected by the pipe, the pipe’s
    percentage value (between 1 and 100), and whether the pipe is a superpipe (with
    0 meaning no and 1 meaning yes).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *n* integers, one for each node, giving the number of liters
    of liquid needed by the ant in that node. Each ant requires between 1 and 10 liters
    of liquid. For any nonleaf node (where there is no ant), a value of –1 is given.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an input that could generate the sample terrarium in [Figure 7-1](ch07.xhtml#ch07fig01):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note how the first line (integer 6 here) indicates the number of nodes in the
    tree, not the number of lines that build the tree. The number of lines that build
    the tree (in this case five lines) is always one less than the number of nodes.
    (Why is it always one less? Each line that builds the tree effectively tells us
    the parent of one of the *n* nodes. Each node except for the root has a parent,
    so we need *n* – 1 lines to tell us about all of the *n* – 1 parents.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Output
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the minimum number of liters of liquid that Bobi must pour into the tree’s
    root to feed all the ants. Include four digits of accuracy after the decimal point.
    The correct output is guaranteed to be at most 2,000,000,000 (two billion).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 0.6 seconds.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '*A New Flavor of Tree Problem*'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As in [Chapter 2](ch02.xhtml), we’re in the domain of trees here. If we want
    to explore a terrarium tree, then we can use recursion. (A full graph-search algorithm
    such as BFS is overkill because there are no cycles.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'For the two problems in [Chapter 2](ch02.xhtml), our solutions were based on
    the structure of the tree and the values stored in nodes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In Halloween Haul, we calculated the total candy by adding up the values in
    the leaves, and we calculated the total street-walks using the height and shape
    of the tree.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Descendant Distance, we calculated the number of descendants at the desired
    distance by using the number of children of each node.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is, what we needed—candy values, height, tree shape—were right there, encoded
    for us in the tree itself. In the present problem, we’re asked to find the minimum
    number of liters that Bobi must pour—but the tree doesn’t contain any values like
    that! The tree has information on pipe percentage, superpipe status, and ant appetite,
    but it has nothing directly informing us of the amount of liquid that should be
    poured into the root. In particular, the superpipes, with their liquid-squaring
    behavior, make unclear the relationship between the amount of liquid needed by
    the ants and the amount of liquid that should be poured.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Because the tree won’t readily give us what we need, I’ll just pick a value
    out of thin air—say, 10\. There you go, Bobi. Pour 10 liters in there.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: I hope you’re very suspicious of what I just did, recklessly choosing a number
    like that. You should be surprised if 10 were the answer. I pulled 10 out of thin
    air, after all. You may also be surprised that we can in fact learn a lot by trying
    out the value 10 and seeing what happens.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use [Figure 7-1](ch07.xhtml#ch07fig01) again. Suppose that we pour 10
    liters of liquid into the root. Twenty percent of 10 is 2, so 2 liters of liquid
    will make it to the ant in Node 2\. Perfect: that ant needs 2 liters of liquid,
    so we’re sending just enough liquid. Let’s continue.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Since 50 percent of 10 is 5, the ant in Node 3 gets 5 liters of liquid. Now
    we’re in trouble: that ant needs 9 liters of liquid, and 5 liters is not enough.
    More bad news: the pipe between Nodes 1 and 3 is not a superpipe, so there’s nothing
    we can do except declare that 10 is not in fact the solution.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We could proceed by picking another number of liters out of thin air and similarly
    simulating the flow of liquid on that new number. However, because 10 liters was
    insufficient, now we should restrict our thin-air range to only values *greater
    than 10*. Since 10 liters was insufficient, any smaller value will be insufficient,
    too. There’s no point trying 2 liters or 7 liters or 9.5 liters or anything less
    than 10\. They’re all too small.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Let’s next try 20 liters. This time, the ant at Node 2 gets 4 liters, which
    is just fine because that ant only needs 2 liters. The ant at Node 3 gets 10 liters,
    which again is fine because that ant only needs 9 liters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipe between Nodes 1 and 4 takes 30 percent of the liquid, so that’s 6
    liters of the total 20 liters. However, this pipe is a superpipe! If we use its
    special behavior, the pipe cranks up the 6 liters to 6² = 36 liters, so 36 liters
    arrives at Node 4\. Now the ants at Nodes 5 and 6 are fine: each ant gets 18 liters,
    and they only need 7 liters (Node 5) and 8 liters (Node 6).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Unlike 10 liters, then, 20 liters is a feasible solution, but is it the optimal
    (that is, minimal) solution? Maybe, maybe not. What we know for sure is that there’s
    no point testing any number of liters greater than 20\. We already have 20 as
    a feasible solution; why try values, such as 25 or 30, that are worse?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与10升不同，20升是一个可行的解，但它是最优（即最小）解吗？也许是，也许不是。我们可以确定的是，测试任何大于20升的液体量没有意义。我们已经得到了20升作为一个可行的解；为什么要尝试更差的值，比如25或30呢？
- en: We’ve now reduced the problem to finding an optimal solution between 10 and
    20 liters. We could keep choosing numbers, reducing the range at each step, until
    our range is so small that one of its endpoints serves as an accurate solution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将问题简化为在10到20升之间找到最优解。我们可以不断选择数字，在每一步缩小范围，直到范围足够小，以至于其中一个端点可以作为准确的解。
- en: In the general case, what number of liters should we choose first? The optimal
    solution could be up to 2 billion, so starting with 10 may be way, way off. And,
    once we test a number of liters, where should we go next? The optimal solution
    might be considerably larger or smaller than our current guess, so adding or subtracting
    10 at a time may not help us make much progress.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，我们应该先选择多少升液体？最优解可能高达20亿，因此从10开始可能会相差甚远。而且，一旦我们测试了一个液体数量，接下来应该选择多少呢？最优解可能比我们当前的猜测要大得多或小得多，所以每次增加或减少10可能无法帮助我们取得多大进展。
- en: These are good questions, good questions that we will answer . . . but not yet.
    Let’s first tackle how to read the input (so that we can explore a tree) and how
    to determine whether a number of liters is a feasible solution. Then, we’ll see
    a super-fast algorithm for searching massive ranges. A range of two billion? We’ll
    eat that for breakfast.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是好问题，值得回答……但还不到时候。让我们首先处理如何读取输入（以便可以探索树结构），以及如何判断一个液体数量是否是可行的解决方案。然后，我们将看到一个超快的算法，用于搜索巨大的范围。20亿的范围？我们吃得了这个早餐。
- en: '*Reading the Input*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*读取输入*'
- en: In [Chapter 2](ch02.xhtml), we used a `node` struct at the core of how trees
    were represented. Then, in [Chapter 5](ch05.xhtml), Book Translation, we used
    the adjacency list representation of a graph with an `edge` struct. There we learned
    that whether we use a `node` or `edge` struct comes down to whether it’s the nodes
    or the edges that carry additional attributes. In the present problem, the edges
    carry information (a percentage and a superpipe status), but so do the leaf nodes
    (the amount of liquid required by each ant). It’s therefore tempting and reasonable
    to use *both* an `edge` struct and a `node` struct. Instead, to closely parallel
    the use of adjacency lists, I’ve chosen to stick with only an `edge` struct. As
    in the problem description, we number nodes starting at 1, but, with no `node`
    struct, we have nowhere to store the amount of liquid required by each ant. For
    that reason, we augment the adjacency list with a `liquid_needed` array, where
    `liquid_needed[i]` gives the amount of liquid required by the ant in Node `i`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.xhtml)中，我们使用了一个`node`结构体来表示树的核心结构。然后，在[第五章](ch05.xhtml)《书籍翻译》中，我们使用了图的邻接表表示法，并使用了一个`edge`结构体。在那里，我们学到了使用`node`结构体还是`edge`结构体取决于是节点还是边缘承载额外的属性。在当前的问题中，边缘承载了信息（一个百分比和一个超管道状态），但叶节点也承载信息（每只蚂蚁所需的液体量）。因此，使用*两者*的`edge`结构体和`node`结构体既合理又具有吸引力。然而，为了更好地模拟邻接表的使用，我选择仅使用`edge`结构体。如同问题描述所说，我们从1开始对节点进行编号，但由于没有`node`结构体，我们没有地方存储每只蚂蚁所需的液体量。因此，我们通过一个`liquid_needed`数组来扩展邻接表，其中`liquid_needed[i]`给出了节点`i`中蚂蚁所需的液体量。
- en: 'Here’s the constant and `typedef` that we’ll use throughout the code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在代码中使用的常量和`typedef`：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As in Book Translation ([Chapter 5](ch05.xhtml)) and the two problems in [Chapter
    6](ch06.xhtml), we can chain these `edge` structs together through `next` pointers
    to form a linked list of edges. If an edge is in the linked list for nNde `i`,
    then we know that the parent node of the edge is `i`. The `to_node` member tells
    us the child node at which this edge connects with the parent node; `percentage`
    is an integer between 1 and 100 that gives the percentage value for the pipe (edge);
    and `superpipe` is a flag whose value is `1` if the pipe is a superpipe and `0`
    if it’s a regular pipe.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在《书籍翻译》（[第5章](ch05.xhtml)）和[第6章](ch06.xhtml)中的两个问题一样，我们可以通过`next`指针将这些`edge`结构体连接在一起，形成一个边的链表。如果一个边在节点`i`的链表中，那么我们就知道该边的父节点是`i`。`to_node`成员告诉我们该边与父节点连接的子节点；`percentage`是一个介于1到100之间的整数，表示该管道（边）的百分比值；`superpipe`是一个标志位，如果该管道是超级管道则其值为`1`，如果是普通管道则为`0`。
- en: Now we can read the tree from the input, as shown in [Listing 7-1](ch07.xhtml#ch07ex01).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从输入中读取树，如[列表7-1](ch07.xhtml#ch07ex01)所示。
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-1: The* main *function for building the tree*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-1：构建树的*主函数*'
- en: 'The code is similar to, but simpler than, [Listing 5-16](ch05.xhtml#ch05ex016)
    (Book Translation). In particular, each edge is read from the input, its members
    are set, and then it’s added to the list of edges for `from_node` ➊. You may expect
    a corresponding edge to be added for `to_node`, since the graph is undirected,
    but I’ve left out such edges: liquid moves down the tree, not up, so adding backward
    edges would needlessly complicate the code that explores a tree.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码类似于[列表5-16](ch05.xhtml#ch05ex016)（书籍翻译）中的代码，但更简洁。具体来说，每条边都是从输入中读取的，成员被设置好后，再将其添加到`from_node`的边列表中➊。你可能会期望会为`to_node`添加对应的边，因为图是无向的，但我省略了这些边：液体沿树向下流动，而不是向上流动，因此添加反向边会不必要地复杂化探索树的代码。
- en: Once the edge information is read in, all that’s left is to read the values
    for the amount of liquid required by each ant. We’ll use the `liquid_needed` array
    for that ➋. The combination of `adj_list` and `liquid_needed` captures everything
    we need to know about the test case.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取了边的信息，剩下的就是读取每个蚂蚁所需的液体量。我们将使用`liquid_needed`数组来存储这些信息➋。`adj_list`和`liquid_needed`的组合包含了我们需要了解的测试用例的所有信息。
- en: '#### *Testing Feasibility*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *测试可行性*'
- en: 'Our next milestone is this: determine whether a given amount of liquid is a
    feasible solution. This is a crucial step, because once we have a function that
    can test a value for feasibility, we’ll be able to use it to progressively narrow
    the search space until we find the optimal solution. Here’s the signature for
    the function that we’ll write:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个里程碑是：确定给定的液体量是否为可行解。这是一个关键步骤，因为一旦我们有了一个可以测试可行性的函数，我们就能够利用它逐步缩小搜索范围，直到找到最优解。以下是我们将要编写的函数签名：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `node` is the root node of the tree, `liquid` is the amount of liquid
    that we pour into the root of the tree, `adj_list` is the adjacency list for the
    tree, and `liquid_needed` is the amount of liquid required by each ant. We’ll
    return `1` if `liquid` is enough to feed the ants (that is, if `liquid` is a feasible
    solution) and `0` if it is not.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`node`是树的根节点，`liquid`是我们倒入树根的液体量，`adj_list`是树的邻接表，`liquid_needed`是每个蚂蚁所需的液体量。如果`liquid`足够喂养蚂蚁（即，`liquid`是可行的解决方案），我们将返回`1`，否则返回`0`。
- en: We spent a whole chapter ([Chapter 2](ch02.xhtml)) writing recursive functions
    on trees. Let’s think about whether we can use recursion again.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整个章节中（[第2章](ch02.xhtml)）都在编写树的递归函数。让我们思考一下，是否还能再次使用递归。
- en: Remember that, to use recursion, we need a base case—a case that can be solved
    with no recursion. Luckily, we have one! If the tree is a single leaf node, then
    we can determine right away whether `liquid` is sufficient. If `liquid` is greater
    than or equal to the amount of liquid needed by the ant in this leaf, then we
    have a feasible solution; otherwise, we don’t.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要使用递归，我们需要一个基准情况——一个可以不通过递归解决的情况。幸运的是，我们有一个！如果树只有一个叶子节点，我们就可以立即判断`liquid`是否足够。如果`liquid`大于或等于该叶子节点中蚂蚁所需的液体量，那么我们就有一个可行的解决方案；否则，我们就没有。
- en: 'We can tell whether a node is a leaf by checking the corresponding value in
    `liquid_needed`: if it’s `-1`, then it isn’t a leaf; otherwise, it is. (We could
    have also used the adjacency list to check whether or not the linked list for
    the node was empty.) Here’s what we’ve got:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, consider the recursive case. Imagine that the root node of some tree has
    *p* downward pipes (that is, *p* children). We’re given the amount of liquid that’s
    poured into the root. Using the pipe percentage values, we can determine the amount
    of liquid that goes into each pipe; using the superpipe statuses, we can determine
    the amount of liquid that reaches the bottom end of each pipe. If enough liquid
    reaches the bottom end of each pipe, then the liquid poured into the root was
    sufficient and we should return `1`. Otherwise, the amount of liquid that reaches
    the bottom end of some pipe isn’t sufficient, and we should return `0`. This suggests
    that we should make *p* recursive calls, one for each pipe that leaves the root.
    We’ll do that in a loop that uses the adjacency list to go through each such pipe.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The full code for the function is given in [Listing 7-2](ch07.xhtml#ch07ex02).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-2: Testing the feasibility of the amount of liquid*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The `ok` variable tracks whether `liquid` is a feasible solution for the tree.
    If `ok` is `1`, then the solution is still feasible; if `ok` is `0`, then it’s
    definitely not. We initialize `ok` to `1` ➊, and we set it to `0` if the amount
    of liquid through one of the pipes isn’t sufficient ➌. If `ok` is still `1` at
    the bottom of the function, then we’ve satisfied all pipes and we conclude that
    `liquid` is feasible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: We determine the amount of liquid that enters each pipe by using that pipe’s
    percentage value. Then, if the pipe is a superpipe, we square that value ➋ . .
    . but hey, wait! The problem description says that Bobi gets to decide whether
    or not to use the special behavior of each superpipe. However, here we’re just
    indiscriminately squaring the amount of liquid, thereby always using the special
    behavior.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we can get away with this is that squaring makes values bigger:
    compare 2 to 2² = 4, 3 to 3² = 9, and so on. Since we want to know whether the
    given amount of liquid is feasible and there’s no penalty for using the special
    behavior of a superpipe, we may as well generate as much liquid as possible. Maybe
    we could have gotten away without using some superpipe special behavior, but no
    one’s asking us to be economical.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry that squaring makes positive values less than one, such as 0.5,
    smaller. 0.5² = 0.25, so indeed we wouldn’t want to activate superpipe behavior
    in such cases. Each ant requires at least 1 liter of liquid, though. So, if we’re
    down to 0.5 liters of liquid at some node, then nothing we do is going to feed
    the ants in the node’s subtree anyway. We’d eventually return `0` whether or not
    we squared the value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s show how useful this `can_feed` function is by continuing the work we
    did in “A New Flavor of Tree Problem” on [page 233](ch07.xhtml#sec97). We showed
    there that 10 liters was not sufficient for the sample instance from the problem
    description. Comment out the `solve` call at the bottom of [Listing 7-1](ch07.xhtml#ch07ex01)
    (don’t worry: we’ll write that `solve` function soon), and add a call to `can_feed`
    to test 10 liters of liquid:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过继续在[第233页](ch07.xhtml#sec97)的《一种新的树问题》中的工作，展示`can_feed`函数有多么有用。我们在那里展示了10升对问题描述中的示例实例来说是不够的。将[列表7-1](ch07.xhtml#ch07ex01)底部的`solve`调用注释掉（别担心，我们很快会编写那个`solve`函数），然后添加一个`can_feed`的调用来测试10升的液体：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see a result of `0`, which means that 10 liters isn’t sufficient.
    We also showed that 20 liters was sufficient. Change the `can_feed` call to test
    20 liters instead of 10:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`0`的结果，这意味着10升不够。我们也展示了20升是足够的。将`can_feed`的调用修改为测试20升而不是10升：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should see a result of `1`, which means that 20 liters is sufficient.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`1`的结果，这意味着20升足够。
- en: Now, we know that 10 is not enough but 20 is. Let’s squeeze this range down
    further. Try 15, and you should see an output of `0`. So, it seems 15 is not enough.
    Our optimal answer is now greater than 15 and at most 20.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道10不够，但20够。让我们进一步缩小这个范围。试试15，你应该看到`0`的输出。所以，似乎15还不够。我们的最优答案现在大于15，最多为20。
- en: 'Try 18 next: you should see that 18 is enough. How about 17? No, 17 is not
    enough, nor is 17.5 or 17.9\. It turns out that the optimal solution is indeed
    18.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来试试18：你应该看到18是足够的。那17呢？不，17不够，17.5和17.9也不行。事实证明，最优解确实是18。
- en: That’s enough of the ad hoc searching. Let’s systematize this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 够了，不再进行这种临时搜索了。让我们将其系统化。
- en: '*Searching for a Solution*'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*寻找解决方案*'
- en: From the problem description, we know that the optimal solution is at most two
    billion. There’s therefore a massive search space in which the optimal solution
    lies. Our goal is to cut down this space as quickly as possible by never wasting
    a guess.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从问题描述中，我们知道最优解最多是20亿。因此，存在一个庞大的搜索空间，最优解就在其中。我们的目标是尽可能快地缩小这个空间，通过避免浪费任何一次猜测来实现。
- en: 'It’s easy to waste a guess. For example, if we start with a guess of 10, and
    the optimal solution is in fact two billion, then we’ve essentially wasted that
    guess: all we’ve done is eliminate the numbers between 0 and 10\. It’s true that
    a guess of 10 would be fantastic if the optimal solution were, say, 8, because
    that one step would cut the range down to 0 to 10 and we’d find 8 soon after.
    Nonetheless, taking shots like this isn’t worth it, because getting lucky once
    in a while won’t offset the very likely case that our guess tells us almost nothing.
    It’s for this reason that you don’t guess 10 as your first guess when someone
    asks you to guess their number between 1 and 1,000\. Sure, if they say “lower,”
    you look like a full-on rock star, but if they say “higher,” as they most likely
    will, you’ve all but wasted that first guess.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易浪费一次猜测。例如，如果我们从10开始猜测，而最优解实际上是20亿，那么我们基本上浪费了那次猜测：我们做的只是排除了0到10之间的数字。确实，如果最优解是8的话，猜10会很棒，因为那一步可以将范围缩小到0到10，我们很快就能找到8。然而，像这样随意猜测并不值得，因为偶尔运气好一次也无法弥补我们猜测几乎没有用的高概率情况。正因为如此，当有人让你猜测1到1000之间的数字时，你不会选择从10开始猜。没错，如果他们说“更低”，你看起来像个明星，但如果他们说“更高”，也就是最有可能的情况，那你基本上就浪费了第一次猜测。
- en: To guarantee that we learn as much as possible with each guess, we’ll always
    guess the middle of the range. To do so, we maintain two variables, `low` and
    `high`, holding the low end and high end, respectively, of our current range.
    We then calculate the middle of the range, `mid`, test the feasibility of `mid`,
    and update `low` or `high` based on what we learn. We’ll implement this strategy
    in [Listing 7-3](ch07.xhtml#ch07ex03).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每次猜测都能获得尽可能多的信息，我们总是猜测范围的中间值。为此，我们维护两个变量，`low`和`high`，分别表示当前范围的低端和高端。然后，我们计算范围的中间值`mid`，测试`mid`的可行性，并根据我们的发现更新`low`或`high`。我们将在[列表7-3](ch07.xhtml#ch07ex03)中实现这一策略。
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-3: Searching for the optimal solution*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-3：寻找最优解*'
- en: It’s important to initialize `low` and `high` so that their range is guaranteed
    to contain the optimal solution. At all times, we’ll maintain that `low` is less
    than or equal to the optimal solution and that `high` is greater than or equal
    to the optimal solution. We start `low` off with a value of 0; as each ant requires
    at least 1 liter, 0 liters is definitely less than or equal to the optimal solution.
    We start `high` off with a value of 2 billion, because it’s guaranteed by the
    problem description that 2 billion is the maximum value of the optimal solution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop condition forces the range between `low` and `high` to be very
    small by the time the loop ends ➊. We need four digits of accuracy, hence the
    four 0s after the decimal point in `0.00001`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do in the loop body is to calculate the middle of the range.
    We’ll do that by taking the average of `low` and `high`, storing that result in
    `mid` ➋.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to test `mid` liters for feasibility, using `can_feed` ➌. If `mid`
    is feasible, we have learned that guessing anything larger than `mid` would be
    a waste. We therefore set `high = mid` to cut the range off at a maximum of `mid`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: If `mid` is not feasible, then guessing anything smaller than `mid` would be
    a waste. We therefore set `low = mid` to cut the range off at a minimum of `mid`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Once the loop terminates, `low` and `high` are very close together. We’re printing
    `high` ➍, but printing `low` would work just as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: This technique, where we keep dividing the range in half until it’s very small,
    is called *binary search*. It’s a surprisingly subtle and powerful algorithm,
    further evidence of which will come from the remaining problems in this chapter.
    It’s also very fast, able to handle ranges of billions or trillions with ease.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Submit the solution to the judge, and then let’s keep going. There’s a lot more
    to know about binary search.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Binary Search
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feeding Ants is an exemplar of the types of problems where binary search thrives.
    There are two ingredients to such problems; if you see these ingredients in a
    new problem you’re facing, it’s worth your time to try binary search.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingredient 1: Hard optimality and easy feasibility**   For some problems,
    it’s hard to come up with a way to find an optimal solution. Fortunately, in many
    such cases, it’s considerably easier to determine whether or not some proposed
    solution is feasible. This was the situation in the Feeding Ants problem: we didn’t
    know how to find an optimal solution directly, but we did see how to determine
    whether some number of liters was feasible.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingredient 2: Infeasible–feasible split**   We need the problem to exhibit
    the property that there is a border between infeasible and feasible solutions.
    All solutions on one side of the border must be infeasible, and all solutions
    on the other side must be feasible. In Feeding Ants, small values were infeasible
    and large values were feasible. Imagine considering values from small to large
    and asking whether each is infeasible or feasible. In doing so, we’ll see a bunch
    of infeasible values and then a feasible value; after our first feasible value,
    we won’t see infeasible values again. Suppose we try a value of 20 liters and
    find that it’s infeasible. This means that we’re still in the infeasible part
    of the search space, and we must search larger values. If 20 liters is feasible,
    then we’re in the feasible part of the search space, and we should search smaller
    values. (Not meeting Ingredient 2 renders binary search useless. For example,
    suppose we have a problem where small values are infeasible, larger values are
    feasible, and even-larger values are infeasible again. We try a value of 20 and
    find that it is infeasible. Don’t even think about focusing on values greater
    than 20: for all we know, values less than 10 could be infeasible and 10 to 15
    could be feasible, giving 10 as the optimal solution here.) It’s also okay if
    the search space transitions from feasible to infeasible, rather than from infeasible
    to feasible. Our next problem will offer such an example.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '*Runtime of Binary Search*'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The reason why binary search is so powerful is that it makes a huge amount
    of progress with just a single iteration. For example, suppose that we’re searching
    for an optimal solution in a range of two billion. A single iteration of binary
    search throws out half of this range, leaving a range of only one billion. Let
    that sink in: with just a single `if` statement and one variable update to `mid`,
    we make one billion units of progress! If binary search takes *q* iterations to
    search a range of one billion, then it takes only one more iteration, *q* + 1,
    to search a range of two billion. The number of iterations grows very slowly compared
    to the width of the range.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of iterations taken by binary search to cut a range *n* to range
    1 is roughly the number of times that *n* must be divided by 2 to get down to
    1\. For example, say that we start with a range of 8\. After one iteration, we’ll
    have reduced the range to at most 4\. After two iterations, we’ll have reduced
    the range to at most 2\. After three iterations, we’ll have reduced the range
    to 1\. Moreover, if we don’t care about decimal digits of accuracy, then that’s
    it: three iterations.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: There’s a mathematical function called the *base-2 logarithm*, which, given
    value *n*, tells you how many times you have to divide *n* by 2 to get 1 or less.
    It’s written log[2] *n* or, when the discussion makes it clear that two is the
    base, as just log *n*. For example, log[2] 8 is 3 and log[2] 16 is 4\. log[2]
    2,000,000,000 (that’s two billion) is 30.9, so it takes about 31 iterations to
    knock this range down to 1.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Binary search is an example of a *logarithmic-time* algorithm. We therefore
    say that it’s *O*(log *m*). (You’d ordinarily use *n* here instead of *m*, but
    we’re going to use *n* for something else later in this section.) To reduce a
    range to 1, *m* is the initial width of the range. However, in Feeding Ants, we
    needed to go further, obtaining four decimal digits of accuracy. What is *m* there?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to come clean on how we used binary search in Feeding Ants: we do
    more than log[2] 2,000,000,000 iterations of binary search, because we don’t stop
    when the width of the range is 1\. Instead, we stop once we’ve achieved four digits
    of accuracy after the decimal point. Adding five zeros gives us the number of
    iterations that we do: log[2] 200,000,000,000,000 rounds up to 48\. Only 48 iterations
    are needed to pull a solution with four decimal digits of accuracy from a bewildering
    range of trillions. That’s what binary search is made of.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: On a tree of *n* nodes, the `can_feed` function in [Listing 7-2](ch07.xhtml#ch07ex02)
    (Feeding Ants) takes linear time; that is, time proportional to *n*. We call that
    function log[2] *m* × 10⁴ times, where *m* is the width of the range (two billion
    in the test cases). This is proportional to log *m* work. In total, then, we do
    *n* work a total of log *m* times. This is an *O*(*n* log *m*) algorithm. It is
    not quite linear, because of that extra log *m* factor, but still very fast.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '*Determining Feasibility*'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What I like most about binary search algorithms is that determining whether
    a value is feasible often requires the use of some other type of algorithm. That
    is, on the outside we have binary search, but on the inside—to test if each value
    is feasible—we have something else. That something else could be anything. In
    Feeding Ants, it was a tree search. In our next problem, it will be a greedy algorithm.
    In our third problem, it will be a dynamic-programming algorithm. We won’t see
    one in this book, but there are problems where checking feasibility requires running
    a graph algorithm. That stuff you’ve learned in the previous chapters will all
    be in play again.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Determining feasibility often requires considerable creativity (just hopefully
    not as much creativity as needed for finding optimality!).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '*Searching a Sorted Array*'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you were familiar with binary search prior to reading this chapter, odds
    are that it was in the context of searching a sorted array. A typical scenario
    is that we are given an array `a` and a value `v`, and we want to find the smallest
    index of `a` whose value is greater than or equal to `v`. For example, if we were
    given the array `{-5, -1, 15, 31, 78}` and `v` were 26, we’d return index `3`,
    because the value at index `3` (31) is the first one that’s greater than or equal
    to 26.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does binary search work here? Take a look at the two ingredients:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingredient 1**   Without a binary search, finding the optimal value would
    involve a costly scan through the array. Therefore, optimality is hard to obtain,
    but feasibility is easy: if I give you an index `i`, you can tell me right away
    whether `a[i]` is greater than or equal to `v` just by comparing `a[i]` to `v`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingredient 2**   Any values smaller than `v` come before any values that
    are greater than or equal to `v`—remember that `a` is sorted! That is, the infeasible
    values come before the feasible values.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: It’s true that binary search can be used to find a suitable index in an array
    in logarithmic time; later, in [Chapter 10](ch10.xhtml), we’ll use it for that
    very purpose. But we solved Feeding Ants with binary search, with no such array
    in sight. Don’t restrict yourself to thinking about binary search only when you
    have an array to search. Binary search is far more flexible than that.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: River Jump'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll now see a problem in which we need a greedy algorithm to determine feasibility.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: This is POJ problem `3258`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a river of length *L* along which rocks have been placed. There’s a
    rock at Location 0 (the beginning of the river), a rock at Location *L* (the end
    of the river), and then *n* other rocks between these. For example, on a river
    of length 12, we might have rocks at the following locations: 0, 5, 8, and 12.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: A cow begins on the first rock (Location 0), jumps from there to the second
    rock, jumps from the second rock to the third rock, and so on, until it gets to
    the rock at the end of the river (Location *L*). Its minimum jump distance is
    the minimum distance between any consecutive pair of rocks. In the above example,
    the minimum jump distance is 3, witnessed by the distance between the rocks at
    Locations 5 and 8.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Farmer John is bored by the short jumps made by the cow, so he wants to increase
    the minimum jump distance as much as possible. He can’t remove the rock at Location
    0 or Location *L*, but he is able to remove *m* of the other rocks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: In the above example, suppose that Farmer John is able to remove one rock. His
    choice is then to remove the rock at Location 5 or Location 8\. If he removes
    the rock at Location 5, the minimum jump distance is 4 (from Location 8 to Location
    12). However, he shouldn’t do that, because if he removes the rock at Location
    8, then he achieves a greater minimum jump distance of 5 (from Location 0 to Location
    5).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Our task is to maximize the minimum jump distance that Farmer John can achieve
    by removing *m* rocks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '##### Input'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: A line containing the three integers *L* (the length of the river), *n* (the
    number of rocks, not including the rocks at the beginning and end), and *m* (the
    number of rocks that Farmer John can remove). *L* is between 1 and 1,000,000,000
    (one billion), *n* is between 0 and 50,000, and *m* is between 0 and *n*.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each giving the integer location of a rock. No two rocks will be
    at the same location.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the maximum achievable minimum jump distance. For the above example,
    we would output `5`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is two seconds.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '*A Greedy Idea*'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.xhtml), when solving the Moneygrubbers problem, we introduced
    the idea of a greedy algorithm. A greedy algorithm does what looks promising right
    now, with no regard to the long-term consequences of its choices. Such an algorithm
    is often easy to propose: just state the greedy rule that it uses to make its
    next choice. When solving the Moneygrubbers problem, for example, I proposed the
    greedy algorithm that chooses the option of cheapest cost per apple. That greedy
    algorithm was incorrect. That lesson is worth remembering: while it’s easy to
    propose a greedy algorithm, it’s not easy to find one that’s correct.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: For two reasons, I didn’t dedicate a chapter of the book to greedy algorithms.
    First, they’re not as broadly applicable as other algorithm design approaches
    (such as dynamic programming). Second, when they do happen to work, it’s often
    for subtle, problem-specific reasons. I’ve been duped many times over the years
    by seemingly correct but ultimately flawed greedy algorithms. A careful proof
    of correctness is often required to distinguish between the ones that are right
    and the ones that only feel right.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, greedy algorithms did make a concealed—and this time correct—appearance
    in [Chapter 6](ch06.xhtml) in the form of Dijkstra’s algorithm. Algorithmists
    generally classify Dijkstra’s algorithm as greedy. Once the algorithm declares
    that a node’s shortest path has been found, it never goes back on that decision.
    It commits, once and for all, and does not let future discoveries influence what
    it has done in the past.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Greedy algorithms are now going to reappear. When I was introduced to River
    Jump several years ago, my instinct was that I could use a greedy algorithm to
    solve it. I wonder if you’ll find the proposed algorithm as natural as I did.
    Here’s the greedy rule: find the two rocks that are closest together, remove the
    one that’s closest to its other neighbor rock, and repeat.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the example from the problem description. Here it is as a test
    case:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For convenience, here are the rock locations: 0, 5, 8, and 12\. We’re allowed
    to remove one rock. The two rocks that are closest together are those at Locations
    5 and 8, so the greedy rule will result in one of these being removed. The rock
    at Location 8 is a distance of 4 from its neighbor to the right; the rock at Location
    5 is a distance of 5 from its neighbor to the left. Therefore, the greedy algorithm
    removes the rock at Location 8\. It works correctly in this example.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s throw a bigger example in here and see what the greedy algorithm does.
    Suppose that the river has a length of 12 and we’re allowed to remove two rocks.
    Here’s the test case:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The rock locations are 0, 1, 3, 8, 9, and 12\. What will the greedy algorithm
    do? The rocks that are closest together are the ones at Locations 0 and 1 and
    those at Locations 8 and 9\. We’ll have to choose one pair—let’s choose 0 and
    1\. Since removing the rock at Location 0 is not allowed, we remove the rock at
    Location 1\. The remaining rock locations are 0, 3, 8, 9, and 12.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Now the closest rocks are at Locations 8 and 9\. The distance between 9 and
    12 is less than the distance between 8 and 3, so the greedy algorithm removes
    the rock at Location 9\. We’re left with 0, 3, 8, and 12\. The minimum jump distance
    here, and the correct answer, is 3\. The greedy algorithm wins again.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Isn’t that right? Keep knocking off the smallest distance between two rocks.
    How could we possibly do better than that? The greedy algorithm charms.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, the greedy algorithm is not correct. I encourage you to try to come up
    with a counterexample before I spoil it in the next paragraph.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a counterexample:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’re allowed to remove two rocks. The rock locations are 0, 2, 4, 5, 8, and
    12\. The greedy rule identifies the rocks at Locations 4 and 5 as the closest
    rocks. It will remove the rock at Location 4, since the distance between 4 and
    2 is less than the distance between 5 and 8\. Here’s what’s left: 0, 2, 5, 8,
    and 12.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Now the greedy rule identifies the rocks at Locations 0 and 2 as the closest
    pair. It isn’t allowed to remove the rock at 0, so it removes the rock at 2\.
    We’re left with 0, 5, 8, and 12\. That’s a minimum jump distance of 3\. Here we
    have a mistake made by the greedy algorithm, because the maximum achievable minimum
    jump distance is 4\. To see this, rather than remove the rocks at Locations 2
    and 4, remove the ones at Locations 2 and 5\. That leaves us with 0, 4, 8, and
    12.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: What went wrong? By removing the rock at Location 4 as its first move, the greedy
    algorithm creates a situation involving a jump distance of 2 and a jump distance
    of 3\. It can only fix one of those two with its second move, so it has no chance
    of producing a minimum jump distance of anything greater than 3.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: I don’t know a greedy algorithm that directly solves this problem. Like Feeding
    Ants, this is a tough one to solve head-on. Fortunately, we don’t have to.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing Feasibility*'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In “Binary Search” on [page 240](ch07.xhtml#lev44), I offered two signals that
    point to a binary search solution: that it’s easier to test feasibility than produce
    optimality and that the search space transitions from infeasible to feasible (or
    feasible to infeasible). We’ll see that the River Jump problem passes on both
    counts.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of solving for the optimal solution outright, let’s solve for a different
    question: Is it possible to achieve a minimum jump distance of at least *d*? If
    we can nail this, then we can use binary search to find the largest feasible value
    of *d*.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the test case that ended the previous subsection:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’re allowed to remove two rocks. The rock locations are 0, 2, 4, 5, 8, and
    12.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a question: What is the minimum number of rock removals that are needed
    to achieve a minimum jump distance of at least 6? Let’s work from left to right
    and check. The rock at Location 0 has to stay—that’s spelled out in the problem
    description. It’s then evident that we have no choice of what to do with the rock
    at Location 2: we must remove it. If we didn’t, then the distance between the
    rocks at Locations 0 and 2 would be less than 6\. So, one rock is removed. The
    remaining rocks are at 0, 4, 5, 8, and 12.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider the rock at Location 4—do we keep it or remove it? Again, we’re
    forced to remove it. If we keep it, then the rocks at Locations 0 and 4 would
    be closer together than 6\. That’s our second removal, and we’re left with rocks
    at 0, 5, 8, and 12.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The rock at Location 5 has to be removed, too, because it’s only a distance
    of 5 from the 0 rock. That’s our third removal, leaving us with rocks at 0, 8,
    and 12.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: We have to remove the rock at Location 8, too! It’s far enough from Location
    0 but too close to Location 12\. That’s our fourth removal, ultimately leaving
    us with just two rocks at 0 and 12.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: So it takes four removals to achieve a minimum jump distance of at least 6,
    but we’re only allowed to remove two rocks. As such, 6 is not a feasible solution.
    It’s too big.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Is 3 a feasible solution? That is, can we achieve a minimum jump distance of
    at least 3 by removing two rocks? Let’s see.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The rock at Location 0 stays. The rock at Location 2 has to go. That’s our
    first removal, and it leaves us with this: 0, 4, 5, 8, and 12.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The rock at Location 4 can stay: it’s more than a distance of 3 from Location
    0\. The rock at Location 5, though, has to go, because it’s too close to the rock
    at Location 4\. That’s our second removal, giving us this: 0, 4, 8, and 12.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The rock at Location 8 is fine: it’s far enough away from the rocks at Locations
    4 and 12\. We’re done: it took us only two removals to achieve a minimum jump
    distance of at least 3\. So, 3 is feasible.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'We seem to be homing in on a greedy algorithm for checking feasibility. The
    rule is this: consider each rock in order, and remove it if it’s too close to
    the previously kept rock. Also check the rightmost rock that we kept, and remove
    it if it’s too close to the end of the river. Then, count the number of rocks
    that we removed; that count tells us whether the proposed minimum jump distance
    is feasible given the number of rocks we’re allowed to remove. (To be clear, this
    is a proposed greedy algorithm for checking feasibility of a specified jump distance,
    not for finding the optimal solution in one shot.)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The code for this algorithm is in [Listing 7-4](ch07.xhtml#ch07ex04).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 7-4: Testing the feasibility of the jump distance*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The function has five parameters:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: distance   The minimum jump distance whose feasibility we’re testing
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: rocks   An array giving the location of each rock, not including the rocks at
    the beginning and end of the river
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: num_rocks   The number of rocks in the `rocks` array
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: num_remove   The number of rocks that we’re allowed to remove
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: length   The length of the river
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The function returns `1` (true) if `distance` is a feasible solution and returns
    `0` otherwise.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The variable `prev_rock_location` tracks the location of the most recent rock
    that we’ve kept. Inside the `for` loop, `cur_rock_location` holds the location
    of the rock that we’re currently considering. We then have our crucial test to
    determine whether to keep or remove the current rock ➊. If the current rock is
    too close to the previous rock, then we remove the current rock and increase the
    number of removals by one. Otherwise, we keep the current rock and update `prev_rock_location`
    accordingly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: When the loop terminates, we’ve counted the number of rocks that we must remove.
    Well . . . almost. We still need to check whether the rightmost rock that we’ve
    kept is too close to the end of the river ➋. If it is, then we remove that rock.
    (Don’t worry about the possibility of removing the rock at Location 0\. If we
    really have removed all the rocks, then `prev_rock_location` will be 0\. However,
    `length - 0 < distance` cannot be true; if it were, then we would have returned
    in the `if` statement at the start of the function.)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Now we have no rocks within the minimum jump distance of each other, and we
    have not removed rocks unnecessarily. How could we possibly do better than that?
    The greedy algorithm charms . . . but here we go again. The last time this occurred,
    in “A Greedy Idea” on [page 244](ch07.xhtml#sec105), the greedy algorithm turned
    out to be incorrect. Don’t be convinced by a couple of examples where things happen
    to work out. Don’t let me sweet-talk you into believing that everything is okay.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, I’d like to give a fairly precise argument for why this greedy
    algorithm is correct. Specifically, I’ll show that it removes the minimum number
    of rocks required to achieve a minimum jump distance of at least *d*. I’ll assume
    that *d* is at most the length of the river; otherwise, the greedy algorithm immediately
    and correctly determines that a minimum jump distance of *d* is infeasible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'For each rock from left to right, our greedy algorithm decides whether to keep
    the rock or remove it. Our goal will be to show that it matches, step for step,
    what an optimal solution does. When the greedy algorithm decides to keep a rock,
    we’ll show that an optimal solution keeps that rock, too. When the greedy algorithm
    decides to remove a rock, we’ll show that an optimal solution removes that rock,
    too. If the greedy algorithm does exactly what an optimal solution does, then
    what we get from it must be correct. In this example, “optimal” will be used to
    refer to an optimal solution. For each rock, we have four possibilities: greedy
    and optimal both remove the rock, greedy and optimal both keep the rock, greedy
    removes it but optimal keeps it, and greedy keeps it but optimal removes it. We
    have to show that the third and fourth cases cannot actually occur.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed to the four cases, consider again removing two rocks from
    these rock locations: 0, 2, 4, 5, 8, and 12\. When asked whether it’s possible
    to achieve a minimum jump distance of at least 3, we have seen that greedy will
    remove the rocks at Locations 2 and 5, leaving us with 0, 4, 8, and 12\. So we
    might expect that the optimal solution is also to remove the same two rocks. Although
    that is optimal, another optimal solution is to remove the rocks at Locations
    2 and 4, resulting in these rocks: 0, 5, 8, and 12\. That’s another way to get
    a minimum distance of at least 3 by removing two rocks, and it’s as good as what
    the greedy algorithm produces. Rather than match *the* optimal solution, we’ll
    be just as happy matching *an* optimal solution. We don’t care which one greedy
    matches: all optimal solutions are equally optimal.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'We have some optimal solution *S* that we want greedy to match. Greedy starts
    running, and for some time there are no discrepancies: it does whatever *S* does.
    Greedy at least does the right thing for the rock at Location 0: that one has
    to stay, no matter what.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Greedy is thus looking at the rocks from left to right, doing the right stuff,
    keeping rocks and removing rocks just like optimal solution *S* . . . and then,
    boom, greedy and *S* disagree on what to do with some rock. We think about the
    *first* rock on which greedy and *S* disagree.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Greedy removes it, but optimal keeps it.**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The greedy algorithm only removes a rock when it’s too close to another rock.
    If greedy removes a rock because it’s less than *d* from the rock to the left,
    then *S* must have removed the rock, too. Because this is the first disagreement,
    *S* includes exactly the same rocks to the left as greedy. So if *S* did not remove
    the rock, then it would have two rocks within a distance of less than *d*. However,
    that can’t happen: *S* is an optimal (and necessarily feasible) solution where
    all distances between rocks are at least *d*. We can conclude that *S* really
    does remove the rock, agreeing with greedy. Similar reasoning shows that, if greedy
    removes a rock because it’s too close to the end of the river, then *S* must remove
    it, too.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Greedy keeps it, but optimal removes it.**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We’re not going to be able to make greedy and *S* match here, but that’s okay,
    because we’ll be able to form a new optimal solution *U* that keeps this rock.
    Let *r* be the current rock; the one that greedy keeps and *S* removes. Think
    about a new set of rocks *T* that has exactly the same rocks as *S* plus rock
    *r*. Therefore, *T* removes one fewer rock than *S*. Because of this, *T* can’t
    be a feasible solution. If it were, then it would be better (by one rock) than
    *S*, contradicting the fact that *S* is an optimal solution. Since the only difference
    between *S* and *T* is that *T* has rock *r*, it must be *r* that causes *T* to
    be infeasible. Therefore, in *T*, *r* must be closer than *d* to rock *r*[2] to
    its right. We know that *r*[2] can’t be the rock at the end of the river, because
    then greedy wouldn’t have kept *r* (as *r* would be too close to the end of the
    river). So *r*[2] is some rock that is allowed to be removed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, think about another new set of rocks *U* that has exactly the same rocks
    as *T* except that it doesn’t have *r*[2]. We can say that *U* has the same number
    of rocks as *S*: we added one rock *r* to *S* to get *T*, and we removed one rock
    *r*[2] from *T* to get *U*. Also, *U* has no rocks that are less than a distance
    of *d* apart, because it doesn’t include the offending rock *r*[2]. That is, *U*
    is an optimal solution, just like *S*. Crucially, *U* contains rock *r*! So greedy
    agrees with optimal solution *U* to include *r*.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give our feasibility tester a whirl before we continue. Here’s how to
    call it on the example that we used throughout this section:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code above asks whether it’s possible to achieve a minimum jump distance
    of at least 6 by removing two rocks. The answer is “no,” so you should see `0`
    (false) as the output. Change the first argument from `6` to `3`, and now you’re
    asking whether a minimum jump distance of at least 3 is feasible. Run the program
    again, and you should see `1` (true).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent: now we have a way to check feasibility. It’s time to bring out binary
    search to give us optimality.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '*Searching for a Solution*'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use binary search, let’s adapt the code from [Listing 7-3](ch07.xhtml#ch07ex03).
    In Feeding Ants, we had to achieve four digits of accuracy after the decimal point.
    Here, however, we’re looking to optimize the minimum jump distance, and that’s
    guaranteed to be an integer value because all rocks are at integer locations.
    So we’ll stop when `high` and `low` are within one, rather than within the four
    decimal digits. [Listing 7-5](ch07.xhtml#ch07ex05) gives the new code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 7-5: Searching for the optimal solution (bugged!)*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration, we calculate the midpoint `mid` of the range, and we use
    our helper function to test its feasibility ➊.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'If `mid` is feasible, then everything less than `mid` is also feasible, so
    we update `low` to cut off the low half of the range ➋. Notice the contrast to
    [Listing 7-3](ch07.xhtml#ch07ex03): there, a feasible `mid` means that everything
    greater than `mid` is feasible, so we cut off the high half of the range instead.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: If `mid` is infeasible, then everything greater than `mid` is also infeasible,
    so we update `high` to cut off the high half of the range ➌.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this binary search is not correct. To see why, run it on this
    test case:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should get an output of `5`, but the optimal solution is in fact `4`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Ahh, I know what to do. Let’s change the `printf` call at the bottom to output
    `low` instead of `high`. When the loop terminates, `low` will be one less than
    `high`, so this change will result in an output of `4` instead of `5`. The new
    code is given in [Listing 7-6](ch07.xhtml#ch07ex06).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 7-6: Searching for the optimal solution (still bugged!)*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'That fixes the problematic test case, but now we get this test case wrong:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is a perfectly valid test case, if a little strange: the length of the
    river is 12, and there are no rocks. The maximum achievable minimum jump distance
    is 12, but our binary search returns `11` on this example. Again, we are off by
    one.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Binary search is legendarily difficult to implement correctly. Should that `>`
    be a `>=`? Should that be a `mid` or a `mid + 1`? Do we want `low + high` or `low
    + high + 1`? If you keep on with binary search problems, you’ll grapple with all
    of this eventually. I don’t know any other algorithm with the bug-density potential
    of binary search.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Let’s be a little more careful for our next attempt. Suppose we knew at all
    times that `low` and everything smaller than `low` are feasible and that `high`
    and everything larger than `high` are infeasible. Such a claim is called an *invariant*,
    which simply means that it’s always true as the code runs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'When the loop terminates, `low` will be one less than `high`. If we’ve managed
    to maintain our invariant, then we know that `low` is feasible. We also know that
    nothing greater than `low` can be feasible: `high` is next, and the invariant
    tells us that `high` is infeasible. So `low` will be the maximum feasible value,
    and we’ll need to output `low`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: However, in all of this we assume that we can make this invariant true at the
    beginning of the code and keep it true at all times thereafter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the code above the loop. This code does *not* necessarily
    make the invariant true:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Is `low` feasible? Certainly! A minimum jump distance of at least 0 is always
    achievable, because every jump has a nonzero distance. Is `high` infeasible? Well,
    it could be, but what if we can jump the whole river after we remove the allowed
    number of rocks? Then `length` is feasible, and our invariant is broken. Here’s
    a better initialization:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now `high` certainly isn’t feasible: we can’t achieve a minimum jump distance
    of `length + 1` when the river is only of length `length`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: We next have to figure out what to do for the two possibilities in the loop.
    If `mid` is feasible, then we can set `low = mid`. The invariant is okay, because
    `low` and everything to its left are feasible, and, if `mid` is not feasible,
    then we can set `high = mid`. The invariant is again okay, because `high` and
    everything to its right are infeasible. Thus, in both cases, we maintain the invariant.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We now see that nothing in the code invalidates the invariant, and so we’re
    safe to output `low` when the loop terminates. The correct code is given in [Listing
    7-7](ch07.xhtml#ch07ex07).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 7-7: Searching for the optimal solution*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: For a river of length *L*, we’re calling `can_make_min_distance` a total of
    log *L* times. If we have *n* rocks, then `can_make_min_distance` ([Listing 7-4](ch07.xhtml#ch07ex04))
    takes *O*(*n*) time. Therefore, our solution to this problem is an *O*(*n* log
    *L*) algorithm.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '*Reading the Input*'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re nearly there. All that’s left is to read the input and call `solve`. The
    code is provided in [Listing 7-8](ch07.xhtml#ch07ex08).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 7-8: The* main *function for reading the input*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been analyzing this problem by thinking about locations of rocks from
    left to right, that is, from smallest location to largest location. However, the
    rocks could come from the input in any order. Nothing in the problem description
    guarantees that they’ll be sorted.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: It’s been a while, but we did use `qsort` to sort nodes in [Chapter 2](ch02.xhtml)
    when solving the Descendant Distance problem. Sorting rocks is a little easier
    than sorting those nodes. Our comparison function `compare` takes pointers to
    two integers, and it returns the result of subtracting the second from the first.
    This leads to a negative integer if the first integer is smaller than the second,
    `0` if the two integers are equal, and a positive integer if the first integer
    is larger than the second. We use `qsort` with this comparison function to sort
    the rocks ➊. We then call `solve` with the array of sorted rocks.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: If you submit this solution to the judge, then you should see that all test
    cases pass.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 3: Living Quality'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far in this chapter, we’ve seen two approaches to check feasibility: a recursive
    traversal of a tree and a greedy algorithm. Now, we’ll see an example where we’ll
    use ideas from dynamic programming ([Chapter 3](ch03.xhtml)) to efficiently check
    feasibility.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first problem in the book where we don’t read from standard input
    or write to standard output. We’ll write a function with a name specified by the
    judge. In lieu of standard input, we’ll use an array passed by the judge. In lieu
    of standard output, we’ll return the correct value from our function. This is
    rather nice: we won’t have to bother with `scanf` and `printf` at all!'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, this will also be our first problem from a world championship
    programming competition (IOI 2010). You’ve got this!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ioi10p3`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A city consists of a rectangular grid of blocks. Each block is identified by
    its row and column coordinates. There are *r* rows numbered 0 to *r* – 1 from
    top to bottom and *c* columns numbered 0 to *c* – 1 from left to right.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Each block has been given a distinct *quality rank* between 1 and *rc*. For
    example, if we have seven rows and seven columns, then the ranks of each block
    will be some permutation of the numbers from 1 to 49\. See [Table 7-1](ch07.xhtml#ch07tab1)
    for an example city.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** A Sample City'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '|   | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| **0** | 48 | 16 | 15 | 45 | 40 | 28 | 8 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| **1** | 20 | 11 | 36 | 19 | 24 | 6 | 33 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| **2** | 22 | 39 | 30 | 7 | 9 | 1 | 18 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| **3** | 14 | 35 | 2 | 13 | 31 | 12 | 46 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| **4** | 32 | 37 | 21 | 3 | 41 | 23 | 29 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| **5** | 42 | 49 | 38 | 10 | 17 | 47 | 5 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| **6** | 43 | 4 | 34 | 25 | 26 | 27 | 44 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: 'The *median quality rank* of a rectangle is the quality rank such that half
    of the quality ranks in the rectangle are smaller and half are larger. For example,
    consider the five-row-by-three-column (5×3) rectangle in the top left of [Table
    7-1](ch07.xhtml#ch07tab1). It consists of 15 quality ranks: 48, 16, 15, 20, 11,
    36, 22, 39, 30, 14, 35, 2, 32, 37, and 21\. The median quality rank is 22, because
    seven numbers are less than 22 and the other seven are greater.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be provided integers *h* and *w* that specify the height (number of rows)
    and width (number of columns) of candidate rectangles. Our task is to identify
    the minimum median quality rank of any rectangle with *h* rows and *w* columns.
    (In this problem, low-quality ranks correspond to high qualities; finding the
    minimum median quality rank therefore corresponds to finding a high-quality living
    area of the city.)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use (*x*, *y*) to refer to row *x*, column *y*. Suppose *h* is 5 and *w*
    is 3\. Then, for the city in [Table 7-1](ch07.xhtml#ch07tab1), we would identify
    13 as the minimum median quality rank. The rectangle whose median quality rank
    is 13 is the one whose top-left coordinate is (1, 3) and whose bottom-right coordinate
    is (5, 5).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s nothing to read from standard input. Everything we need will come from
    the judge through function parameters. Here’s the signature for the function that
    we’ll write:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, `r` and `c` are the numbers of rows and columns in the city, respectively.
    Similarly, `h` and `w` are the numbers of rows and columns in the candidate rectangles,
    respectively; `h` will be at most `r` and `w` will be at most `c`. It’s also guaranteed
    that `h` and `w` will be odd numbers. (Why is that? Since multiplying two odd
    numbers results in an odd number, *hw*, the number of blocks in a candidate rectangle,
    will be an odd number. The median is precisely defined in this case: the quality
    rank such that half of the remaining quality ranks are smaller and the other half
    are larger. What if we had an even number of quality ranks, such as the four ranks
    2, 6, 4, and 5? What would the median be? We’d have to choose between 4 and 5\.
    The problem author has spared us this choice.)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'The final parameter `q` gives the quality rank of the blocks. For example,
    `q[2][3]` gives the quality of the block at row 2, column 3\. Notice how the dimensions
    on `q` tell us the maximum number of rows and columns in the city: 3,001, in each
    case.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Output
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We won’t produce anything on standard output. Instead, from the `rectangle`
    function just described, we’ll return the minimum median quality rank.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 4.5 seconds.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '*Sorting Every Rectangle*'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s hard to make much progress toward an efficient solution that doesn’t use
    binary search, but we’ll try here, anyway. It’ll give us practice looping through
    all of the candidate rectangles. We’ll get to binary search in the next subsection.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need a couple of constants and a type definition:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Much as we did in [Chapter 5](ch05.xhtml), we’ll use `board` whenever we need
    a two-dimensional array of the correct size.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are given the top-left and bottom-right coordinates of a rectangle
    and asked to determine the median quality rank of its blocks. How can you do it?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting can help. Sort the quality ranks from smallest to largest, and then
    pick out the element at the middle index. For example, say we have these 15 quality
    ranks again: 48, 16, 15, 20, 11, 36, 22, 39, 30, 14, 35, 2, 32, 37, and 21\. If
    we sort them, we get 2, 11, 14, 15, 16, 20, 21, 22, 30, 32, 35, 36, 37, 39, and
    48\. There are 15 quality ranks, so all we do is take the eighth one, 22, and
    that’s our median.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: There are slightly faster algorithms for finding the median directly, without
    taking the scenic route through sorting. Sorting gives us an algorithm that takes
    *O*(*n* log *n*) time to find the median; there’s a sophisticated *O*(*n*) algorithm
    for finding the median that I encourage you to look up if you are interested.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go there, though. What we do in this subsection is going to be so slow
    that no improved algorithm for finding the median is going to be of benefit.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-9](ch07.xhtml#ch07ex09) gives the code for finding the median of
    a given rectangle.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 7-9: Finding the median of a given rectangle*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The first four parameters of `median` delimit the rectangle by specifying the
    top-left row and column and the bottom-right row and column. The final parameter,
    `q`, holds the quality ranks. We use the one-dimensional array `cur_rectangle`
    to accumulate the quality ranks for the rectangle. The nested `for` loops go through
    each block in the rectangle and add the block’s quality rank to `cur_rectangle`.
    After corralling the quality ranks, we’re all set to feed them to `qsort` ➊. Then
    we know exactly where the median is—it’s in the middle of the array—so we just
    return it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: With that function in hand, we can now proceed to loop through each candidate
    rectangle, keeping track of the one whose median quality rank is the smallest.
    Check out [Listing 7-10](ch07.xhtml#ch07ex010) for the code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 7-10: Finding the smallest median of all candidate rectangles*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable `best` tracks the best (smallest) median that we’ve found so far.
    We start it off with a big value, bigger than the median of any candidate rectangle
    ➊. There’s no way for a rectangle to have a median of `r * c + 1`: that would
    mean that half of its quality ranks were larger than `r * c`, but by the problem
    description, *no* quality ranks can be larger than `r * c`. The nested `for` loops
    consider each possible top-left coordinate for a rectangle. That gives us the
    top row and left column, but we also need the bottom row and right column in order
    to call `median`. To calculate the bottom row, we take the top row, add `h` (the
    number of rows in the candidate rectangles), and then subtract 1 ➋. It’s really
    easy to make an off-by-one error here, but that `- 1` is required. If the top
    row is 4 and `h` is `2`, then we want the bottom row to be 4 + 2 – 1 = 5; if we
    made the bottom row be 4 + 2 = 6, then we’d have a rectangle with three rows instead
    of the desired two. We use a similar calculation to find the right column ➌. With
    the four coordinates available, we call `median` to calculate the median of the
    rectangle ➍. The remainder of the code updates `best` if we’ve found a better
    median.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: We’re done with this solution. There’s no `main` function, because the judge
    calls `rectangle` directly, but the absence of `main` means that we can’t test
    our code on our own computer. For testing purposes, you can introduce a `main`
    function, but don’t keep that in there when you submit to the judge.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example `main` function on the city in [Table 7-1](ch07.xhtml#ch07tab1):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You should see an output of `13` when you run the program.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to submit our solution, minus the `main` function, to the judge. It’ll
    pass a few test cases but time-out on the rest.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: To get a feel for why our code is so slow, let’s focus on the case where *r*
    and *c* are both the same number *m*. To exhibit the worst case, take *h* and
    *w* to both be *m*/2\. (We don’t want the rectangles to be too big, because then
    there won’t be many rectangles; and we don’t want them to be too small, because
    then each is easy to process.) The slowest part of our `median` function is the
    call to `qsort`. It’s given an array with *m*/2 × *m*/2 = *m*²/4 values. On an
    array of *n* values, `qsort` takes *n* log *n* steps. Replacing *n* by *m*²/4
    gives (*m*²/4) log(*m*²/4) = *O*(*m*² log *m*). So we’re already slower than quadratic—and
    all we’ve done is calculate the median for one rectangle! The `rectangle` function
    calls `median` a total of *m*²/4 times, so our total runtime is *O*(*m*⁴ log *m*).
    That power of 4 relegates this solution to only very small problem instances.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: There are two bottlenecks here. The first is sorting each rectangle. The second
    is doing a lot of work from scratch for each rectangle. Using a binary search
    disposes the former, and a neat dynamic-programming trick disposes the latter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '*Using Binary Search*'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Why should we be optimistic that binary search will lead to a speedup here?
    First, in the previous subsection, we saw that finding optimality head-on is a
    costly endeavor; our approach that piggybacked on sorting was slightly slower
    than an *m*⁴ algorithm. Second, we have another example of a problem where all
    infeasible solutions come first and are followed by all feasible solutions. Suppose
    I tell you that there is no rectangle with median quality rank of at most five.
    Then there’d be no point looking for rectangles with median quality five, or four,
    or three, or anything else less than five. Conversely, suppose I tell you that
    there is a rectangle with median quality rank of at most five. Now, there’d be
    no point looking for rectangles with median quality of six, or seven, or anything
    greater than five. This is tailor-made binary search territory.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Feeding Ants problem, small values were infeasible and large values
    were feasible. In the River Jump problem, small values were feasible and large
    values were infeasible. Here, we’re back in the Feeding Ants case: small values
    are infeasible and large values are feasible. We’ll therefore need a change to
    the River Jump invariant, flipping the locations of the feasible and infeasible
    portions of the solution space.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the invariant that we’ll use: `low` and everything smaller than `low`
    are infeasible; `high` and everything larger than `high` are feasible. This tells
    us that we should return `high` when we’re done, as it will be the smallest feasible
    value. The code, in [Listing 7-11](ch07.xhtml#ch07ex011), is otherwise very similar
    to [Listing 7-7](ch07.xhtml#ch07ex07).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 7-11: Searching for the optimal solution*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: To finish the job, we need an implementation of `can_make_quality` to test feasibility.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing Feasibility*'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s the signature for the feasibility-checking function that we’ll write:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In “Sorting Every Rectangle” on [page 256](ch07.xhtml#sec110), we were saddled
    by having to calculate the median quality rank of each rectangle. Now this is
    no longer the case: we’re content to determine whether the median value of some
    rectangle is at most some cutoff `quality` rank value.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an easier problem for which a sorting step is unnecessary. Here’s the
    key observation: the specific values themselves no longer matter; all that matters
    is the relationship between each value and `quality`. To exploit this observation,
    we’ll replace all values that are less than or equal to `quality` by –1 and all
    values greater than `quality` by 1\. We then add up these –1 and 1 values for
    a given rectangle. If we have at least as many –1 values as 1 values (that is,
    there are at least as many small values as large values, relative to `quality`),
    then the sum will be zero or negative, and we can conclude that this rectangle
    has a median quality rank of `quality` or less.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s work an example. Here are the 15 quality ranks again for the 5×3 rectangle
    in the top left of [Table 7-1](ch07.xhtml#ch07tab1): 48, 16, 15, 20, 11, 36, 22,
    39, 30, 14, 35, 2, 32, 37, and 21\. Does this rectangle have a median quality
    rank of 16 or less? Take each value and replace it by –1 if it’s less than or
    equal to 16 and 1 if it’s greater than 16\. Here are the new values: 1, –1, –1,
    1, –1, 1, 1, 1, 1, –1, 1, –1, 1, 1, and 1\. If we add these up, we get a value
    of 5\. This means that there are five more large values than small values, and
    we must conclude that a median of 16 or smaller is not possible for this rectangle.
    If we wanted to know whether a median of 30 was feasible, we’d get this after
    replacing the numbers by –1s and 1s: 1, –1, –1, –1, –1, 1, –1, 1, –1, –1, 1, –1,
    1, 1, and –1\. Adding these up, we get a total of –3.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Aha! So 30 is a feasible median. Crucially, we’re making this feasible–infeasible
    decision with no sorting at all.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: We need to loop through each rectangle, testing whether it has a median quality
    rank of `quality` or less. [Listing 7-12](ch07.xhtml#ch07ex012) does exactly this.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 7-12: Testing the feasibility of* quality'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: We can’t just obliterate the `q` array with –1s and 1s, because then we couldn’t
    use the original quality ranks to later test other values of `quality`. Therefore,
    we use a new array to hold the –1s and 1s ➊. Notice how this array is filled in
    based on whether each value is less than or equal to (–1) or greater than (1)
    the cutoff `quality` parameter that we’re checking ➋.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: We then go through each rectangle, just as we did in [Listing 7-10](ch07.xhtml#ch07ex010).
    We add up all of its –1 and 1 values ➌ and return `1` (true) if it has a median
    quality rank that’s small enough.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: All right! We have sidestepped the sorting—crafty, eh? What we did in this subsection
    is crucial to a fast solution to solving our problem, but we’re not there yet,
    because if you count the number of nested loops, you’ll see that there are four
    of them.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: At the end of “Sorting Every Rectangle” we observed that our first solution—with
    no binary search anywhere!—was a very slow *O*(*m*⁴ log *m*), where *m* is the
    number of rows or columns in the city. Here, our feasibility check is already
    *m*⁴; multiply by the log factor for the binary search, and it’s not clear that
    we’ve made any progress.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Oh, but we have! It’s just locked up behind too many nested loops, involving
    too much recomputation. Dynamic programming is now going to take us the rest of
    the way.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '*A Quicker Way to Test Feasibility*'
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose we start with [Table 7-1](ch07.xhtml#ch07tab1) and are interested in
    whether any 5×3 rectangle has a median quality rank of 16 or less. Changing all
    values less than or equal to 16 to –1 and all values greater than 16 to 1 results
    in [Table 7-2](ch07.xhtml#ch07tab2).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-2:** A City with Quality Ranks Replaced'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1 | –1 | –1 | 1 | 1 | 1 | –1 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| **1** | 1 | –1 | 1 | 1 | 1 | –1 | 1 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| **2** | 1 | 1 | 1 | –1 | –1 | –1 | 1 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| **3** | –1 | 1 | –1 | –1 | 1 | –1 | 1 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| **4** | 1 | 1 | 1 | –1 | 1 | 1 | 1 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| **5** | 1 | 1 | 1 | –1 | 1 | 1 | –1 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| **6** | 1 | –1 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: We might begin by summing the elements of the 5×3 rectangle whose top-left coordinate
    is (0, 0). As we saw in the previous section, the sum of that rectangle is 5\.
    Next, maybe we want to sum the elements of the 5×3 rectangle whose top-left coordinate
    is (0, 1). Adding up all 15 numbers here is what we would have done in the previous
    subsection. However, doing so fails to lean on the work we did to compute the
    sum of the first rectangle. Indeed, this second rectangle has 10 values in common
    with the first rectangle. We should be able to prevent this kind of duplication
    of effort for this and all other rectangles.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Dodging the repeated work here amounts to efficiently solving what’s known as
    a two-dimensional *range sum query*. The one-dimensional case uses similar ideas,
    but in a simpler context, so we’ll briefly study that before returning to finish
    the Living Quality problem. (About half of [Chapter 8](ch08.xhtml) will be devoted
    to range queries, so stay tuned!)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: One-Dimensional Range Sum Queries
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here’s a one-dimensional array:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg262-01.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: 'If asked to find the sum of the array from index 2 to index 5, we could directly
    sum the values in that range: 15 + 9 + 12 + 4 = 40\. That’s not very fast, and
    it would be particularly unfortunate if we were asked for the sum of the entire
    array. However, if we had to answer just a few such queries, we could get away
    with answering each by summing the appropriate values.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine that we’re getting peppered by hundreds or thousands of these queries.
    It makes sense to have done a little up-front work, once, if it means that we
    can then answer the queries more quickly.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Consider the “index 2 to 5” query. What if we could look up the sum from index
    0 to 5? That sum is 48\. That’s not 40, the answer that we want. Far from useless,
    though, is that 48 is quite close to what we need. It’s only wrong because it
    includes the values at index 0 and index 1, stuff that we now need to exclude.
    We could do that if we could look up the sum from index 0 to 1\. That sum is 8\.
    If we subtract this 8 from 48, we get 40.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s needed, then, is a new array, one where index *i* holds the sum of all
    values from index 0 to index *i*. This new array is included in the Prefix Sum
    row in the following table:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg263-01.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: 'No matter the query, we can now quickly answer it using the prefix sum array:
    to calculate the sum of the range from index *a* to *b*, take the value at index
    *b* and subtract the value at index *a* – 1\. For 2 to 5, we get 48 – 8 = 40,
    and for 1 to 6, we get 59 – 6 = 53\. These are constant-time answers, for eternity,
    and all we had to do was one preprocessing pass over the array.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Two-Dimensional Range Sum: Queries'
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s return to the two-dimensional world of our quality ranks. Summing the
    elements of each rectangle is too slow, so we’ll extend what we did in one dimension
    to two dimensions. Specifically, we’ll produce a new array, where index (*i*,
    *j*) is the sum of the elements of the rectangle whose top-left coordinate is
    (0, 0) and whose bottom-right coordinate is (*i*, *j*).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look again at [Table 7-2](ch07.xhtml#ch07tab2).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1 | –1 | –1 | 1 | 1 | 1 | –1 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| **1** | 1 | –1 | 1 | 1 | 1 | –1 | 1 |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| **2** | 1 | 1 | 1 | –1 | –1 | –1 | 1 |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| **3** | –1 | 1 | –1 | –1 | 1 | –1 | 1 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| **4** | 1 | 1 | 1 | –1 | 1 | 1 | 1 |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| **5** | 1 | 1 | 1 | –1 | 1 | 1 | –1 |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| **6** | 1 | –1 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: The corresponding prefix array is in [Table 7-3](ch07.xhtml#ch07tab3). (It may
    seem a little strange to call it a “prefix array” here, but let’s stick with it
    to match the terminology from the one-dimensional case.)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-3:** An Array for Two-Dimensional Range Sum Queries'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1 | 0 | –1 | 0 | 1 | 2 | 1 |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| **1** | 2 | 0 | 0 | 2 | 4 | 4 | 4 |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| **2** | 3 | 2 | 3 | 4 | 5 | 4 | 5 |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| **3** | 2 | 2 | 2 | 2 | 4 | 2 | 4 |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| **4** | 3 | 4 | 5 | 4 | 7 | 6 | 9 |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| **5** | 4 | 6 | 8 | 6 | 10 | 10 | 12 |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| **6** | 5 | 6 | 9 | 8 | 13 | 14 | 17 |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: Let’s make sure we know what this array tells us before worrying about how to
    quickly build it. The value in row 4, column 2 gives the sum of the values of
    the rectangle whose top-left coordinate is (0, 0) and whose bottom-right coordinate
    is (4, 2). We have seen in “Testing Feasibility” that this sum is 5 and, indeed,
    that’s what this array has there.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: How could we compute that (4, 2) value of 5 using other values that we’ve already
    computed? We need to start with its value in [Table 7-2](ch07.xhtml#ch07tab2),
    add what’s in range above it, and add everything in its row to the left. We can
    do this with judicious use of the array in [Table 7-3](ch07.xhtml#ch07tab3), as
    shown in [Table 7-4](ch07.xhtml#ch07tab4).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-4:** Quickly Calculating a Given Sum'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| **0** | • ■ | • ■ | • |  |  |  |  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| **1** | • ■ | • ■ | • |  |  |  |  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| **2** | • ■ | • ■ | • |  |  |  |  |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| **3** | • ■ | • ■ | • |  |  |  |  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| **4** | ■ | ■ | 1 |  |  |  |  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| **5** |  |  |  |  |  |  |  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| **6** |  |  |  |  |  |  |  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: We need to start with the 1, capture the cells that include a circle (those
    above), capture the cells that include a square (those to the left), and add them
    all up. We can capture the cells that include a circle by looking up the element
    at row 3, column 2\. We can also capture the cells that include a square by looking
    up the element at row 4, column 1\. However, adding those together double-counts
    the cells that include both a circle and a square (those both above and to the
    left), but this is not an issue because the element at row 3, column 1 captures
    exactly those circle-and-square cells, whose subtraction undoes the double-counting.
    In all, we have 1 + 2 + 4 – 2 = 5, as desired. As long as we work from top to
    bottom and left to right, we can build this array with only two additions and
    one subtraction per cell.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to build an array like that in [Table 7-3](ch07.xhtml#ch07tab3).
    So what?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'The “so what” is that it enables us to quickly calculate the sum of any rectangle.
    Suppose we wanted the sum of the rectangle whose top-left coordinate is (1, 3)
    and whose bottom-right coordinate is (5, 5). We can’t just use the value 10 in
    row 5, column 5 of [Table 7-3](ch07.xhtml#ch07tab3). That captures everything
    in the desired rectangle but also includes more than we want: it includes elements
    that are outside (above or to the left) of our desired rectangle. However, just
    as in the one-dimensional case, we’ll be able to adjust that value to include
    only the elements in the rectangle. See [Table 7-5](ch07.xhtml#ch07tab5) for how
    to do this. In this table, the cells of the desired rectangle are marked by stars.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-5:** Quickly Calculating the Sum of a Rectangle'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: '| **0** | • ■ | • ■ | • ■ | • | • | • |  |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| **1** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: '| **2** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
- en: '| **3** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
- en: '| **4** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
- en: '| **5** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: '| **6** |  |  |  |  |  |  |  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: This time, we need to subtract the cells that include a circle and the cells
    that include a square. We can get the cells with a circle from row 0, column 5
    and the cells with a square from row 5, column 2\. But subtracting both will double-subtract
    the cells that have both a circle and a square, so we need to add back the cell
    in row 0, column 2\. That is, we have 10 – 2 – 8 + (–1) = –1, which is the sum
    of the rectangle.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a general expression for this calculation:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will be used in the code presented next.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Two-Dimensional Range Sum: Code'
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re ready to put it all together—the –1 and 1 idea, building the prefix array,
    and using the prefix array for fast rectangle sums—in [Listing 7-13](ch07.xhtml#ch07ex013).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 7-13: Testing the feasibility of* quality *quickly*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 is to build the `zero_one` array ➊, exactly as we did in [Listing 7-12](ch07.xhtml#ch07ex012).
    Step 2 is to build the prefix sum array `sum` ➋. We’ll use indices that start
    at 1, rather than 0, so that we don’t have to worry about staying within bounds
    when we later process cells on the edges of the array. Finally, Step 3 is to use
    the prefix sum array to quickly calculate the sum of each rectangle ➌. Notice
    how each rectangle can be summed in constant time here! We paid for the preprocessing
    work of Step 2, but that work pays for itself every time we sum a rectangle without
    summing its elements.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Compared to [Listing 7-12](ch07.xhtml#ch07ex012), we’ve removed two levels of
    nesting from the `for` loops. Therefore, this is an *O*(*m*² log *m*) algorithm,
    which is fast enough to pass all of the test cases. Go for it! Then take a well-deserved
    break, because we’ve got one more big problem to solve before we’re through with
    this chapter.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 4: Cave Doors'
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another IOI championship problem? Bring it on! This one is unique to the chapter
    because it uses binary search not to find an optimal solution, but to quickly
    zone-in on a desired element. As we did in the Living Quality problem, we won’t
    read anything from standard input, and we won’t write anything to standard output.
    Rather, we’ll learn about the problem instance and submit our answer through calls
    to functions provided by the judge. As you read the problem description, try to
    anticipate why binary search is still appropriate here.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ioi13p4`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You are at the entrance to a long, narrow cave, and you want to get through
    the cave to the other side. There are *n* doors that you must pass through: the
    first door is Door 0, the second is Door 1, and so on.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Each door can be open or closed. You can walk through any open door, but you
    can’t get past or see through a closed door. So if Door 0 and Door 1 are open
    but Door 2 is closed, then you progress to Door 2 but no further.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: At the entrance to the cave is a panel of *n* switches. Like the doors, the
    switches are numbered starting from 0\. Each switch can be in the up (0) position
    or the down (1) position. Each switch is associated with a different door, and
    it determines whether that door is open or closed. If a switch is set to the correct
    position, then its associated door is open; otherwise, its associated door is
    closed. You don’t know which switch is associated with which door, and you don’t
    know whether the switch should be up or down for the door to be open. For example,
    maybe Switch 0 is associated with Door 5, and the switch has to be down for Door
    5 to be open. And maybe Switch 1 is associated with Door 0, and the switch has
    to be up for Door 0 to be open.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: You can set the switches to whatever positions you choose and then walk through
    the cave to determine the first door that is closed. You have the stamina to do
    this at most 70,000 times. Your goal is to determine both the correct position
    (0 or 1) and the associated door for each switch.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to write the function with this signature:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: where `n` is the number of doors and switches (between 1 and 5,000). To implement
    this function, you call two functions provided by the judge. These are described
    next.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re not reading anything from standard input. The only way to learn about
    the problem instance is to call the function `tryCombination` provided by the
    judge. Its signature is
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The parameter `switch_positions` is an array of length *n* giving the position
    (0 or 1) of each switch. That is, `switch_positions[0]` gives the position of
    Switch 0, `switch_positions[1]` gives the position of Switch 1, and so on. The
    `tryCombination` function simulates what would happen if we set the switches as
    in `switch_positions` and walked through the cave. If some door is still closed,
    it returns the number of the first closed door; otherwise, it returns `-1` to
    indicate that all doors are open.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Output
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re not writing anything to standard output. Instead, when we’re ready, we
    submit our answer by calling the function `answer` provided by the judge. Its
    signature is
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have one shot at this: when we call `answer`, we can’t then do anything
    else, so we had better submit the correct answer the first time. The parameter
    `switch_positions` is our proposed switch positions, in the same format as for
    `tryCombination`. The parameter `door_for_switch` is our proposed association
    between switches and doors: `door_for_switch[0]` gives the door for Switch 0,
    `door_for_switch[1]` gives the door for Switch 1, and so on.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: The number of calls to `tryCombination`, rather than execution time, is the
    scarce resource here. We’re allowed to make at most 70,000 calls; if we make more,
    then our program is terminated and we do not solve the problem.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '*Solving a Subtask*'
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The author of this problem has split the points across five *subtasks*. The
    fifth subtask is the problem in its full generality as I’ve presented it here.
    The other subtasks impose additional constraints on the problem instances to make
    the problem easier.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: I like when problem authors use subtasks, especially when I’m struggling to
    solve a problem. I can then target each subtask in turn, improving my solution
    as I go, until I solve the full problem. Moreover, if I can’t solve the full problem,
    then I still get points for the subtasks that I was able to solve.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: The first subtask in the Cave Doors problem is to solve the problem when each
    switch `i` is associated with door number `i`. That is, Switch 0 is associated
    with Door 0, Switch 1 is associated with Door 1, and so on. What we need to deduce
    is the correct position (0 or 1) for each switch.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t worry: we won’t stop with this problem until we solve it fully. But let’s
    start by solving Subtask 1 here, so we can focus on correctly calling the `tryCombination`
    and `answer` judge functions before we tackle the other aspects of the problem.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: We don’t have access to the code for the two judge functions, so we’re not going
    to be able to locally compile and run our program. (If you’d like to get things
    set up locally, you can google “IOI 2013 tasks” and find the test data and templates
    for the Cave Doors problem, but you won’t need to do any of that to follow the
    discussion here.) Whenever we want to test what we’re doing, we can submit our
    code to the judge. In particular, once we successfully solve Subtask 1 and submit
    our code, the judge should give us some points. The code for Subtask 1 is given
    in [Listing 7-14](ch07.xhtml#ch07ex014).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 7-14: Solving Subtask 1*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we use a `for` loop to set each switch position to `0` ➊ and associate
    Door `i` with Switch `i` ➋. We’ll update the switch positions when needed, but
    (as per the subtask constraints) we’ll have no reason to touch the door associations
    again.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: The second `for` loop loops through each switch. Its job is to determine if
    the current switch should stay in Position 0 or change to Position 1\. Let’s work
    through the first iteration, when `i` is `0`. We call `tryCombination` ➌, which
    returns to us the number of the first door that is closed. If it returns `0`,
    then Switch 0 is not set correctly; if Switch 0 were set correctly, Door 0 would
    be open, and `tryCombination` would return a number other than `0`. So, if Door
    0 is closed, then we change the position of Switch 0 from `0` to `1` ➍. That opens
    Door 0, and we can move on to Door 1.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: When `i` is 1, we again call `tryCombination`. We won’t get a result of `0`,
    because our code has already done the work to guarantee that Door 0 is open. If
    we get a result of `1`, it means that Door 1 is closed, and we have to change
    Switch 1 from Position 0 to Position 1.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing, we can say that, when we start a new iteration of the loop, all
    of the doors up to and including Door `i - 1` are open. If Door `i` is closed,
    then we change the position of Switch `i` from `0` to `1`; otherwise, Door `i`
    is already open, and Switch `i` is already correctly set.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Once we’re finished with that second `for` loop, we’ve figured out the correct
    position of each switch. We communicate this to the judge through the call to
    the `answer` function ➎.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: I suggest submitting this code to the judge to verify that you’re correctly
    calling `tryCombination` and `answer`. Once you’re ready, we’ll move on to solve
    the real deal.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '*Using Linear Search*'
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s a good thing we solved Subtask 1, beyond the fact of getting our feet wet.
    That’s because there’s a nice strategy in our solution that paves our way. That
    strategy is to figure out how to open each door and never let that door interfere
    again.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: In our solution to Subtask 1, we focus first on Door 0 and get that door open.
    Once it’s open, we never mess with its switch again. With Door 0 out of the way,
    we next focus on getting Door 1 open. Once Door 1 is open, we never mess with
    its switch again. As far as we are concerned, Doors 0 and 1 are gone; the Doors
    may as well start with Door 2\. We continue in this way, knocking off one door
    after another, until all doors are open.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'In Subtask 1, we knew exactly which door was associated with each of the switches.
    There was no searching required to figure out this correspondence. But, to solve
    the full problem, we do need a search, because we don’t know which switch controls
    the current door. We start by getting Door 0 closed. Then we search through the
    switches. We change the position of the current switch and ask whether or not
    Door 0 opened. If not, then this was not the correct switch. If so, then we’ve
    found the switch for Door 0\. We keep Door 0 open from this point onward, and
    we repeat the process for Door 1: getting it closed and then looping through the
    switches to find the one that opens it.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the new `exploreCave` code given in [Listing 7-15](ch07.xhtml#ch07ex015).
    It’s brief, because it offloads the search to a helper function.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 7-15: The* exploreCave *function*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: As with solving Subtask 1, each element of `switch_positions` will end up being
    a 0 or 1, indicating the position of each switch. `door_for_switch` indicates
    the door associated with each switch. We initialize each element of `door_for_switch`
    to `-1` ➊ to indicate that the door for each switch is unknown. When the door
    for Switch `i` becomes known, we’ll update `switch_positions[i]` and `door_for_switch[i]`
    accordingly.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Pop quiz: If `door_for_switch[5]` is `8`, what does that mean? Does it mean
    that Switch 5 is associated with Door 8 or that Door 5 is associated with Switch
    8?'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: It’s the former! Make sure you’re clear on this before continuing.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: For each Door `i`, we call the `set_a_switch` helper function ➋. Its task is
    to search through the switches to determine the one that is associated with Door
    `i`. It also determines whether that switch should be in Position 0 or 1.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The code for `set_a_switch` is given in [Listing 7-16](ch07.xhtml#ch07ex016).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 7-16: Finding and setting the switch for the current door using a
    linear search*'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: The `door` parameter dictates which door we want to solve next.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: We begin with a loop through the switches. We set the position of the switches
    to `0` ➊, but only for those switches that are not associated with a door yet.
    (Remember that, if a switch is already associated with a door, we don’t want to
    change that switch’s position ever again.)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: With all relevant switches set to Position 0, we determine whether the current
    door is open or closed. If it’s open, then we want to close it so that we can
    later change switch positions, one at a time, to see which switch opens it. To
    close the door, we just set all switch positions to `1` ➋. This works because
    the door was open when the switch positions were all `0`; one of those switches
    controls this door, so the door will close when that switch position changes.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'With the door closed, it’s time to search for the switch that opens it. For
    each switch not already associated with a door, we *toggle* its position from
    0 to 1 or 1 to 0 ➌. Notice how subtracting the position from 1 changes the position:
    if it was 1 before, then it’s 0 now; if it was 0 before, then it’s 1 now. Then,
    we check the new status of the door. If it’s open ➍, then we’ve found the associated
    switch! If it’s still closed, then this wasn’t the right switch and the loop continues.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: What we’re doing in `set_a_switch` is a linear search through all of the remaining
    switches. We could have up to 5,000 switches, so finding the switch for a single
    door could take up to 5,000 calls of `tryCombination`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: We can call `tryCombination` up to 70,000 times. If we get unlucky and the search
    for the first door takes 5,000 calls, the second takes 4,999 calls, the third
    takes 4,998 calls, and so on, then we can only handle about 14 doors before we
    go over the limit. Only 14 doors is not much. We could have 5,000 doors—we’re
    not even close! This is the end of the line for a linear search.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '*Using Binary Search*'
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The numbers 5,000 (maximum number of doors) and 70,000 (maximum number of `tryCombination`
    calls) subtly encode the fact that binary search is a plausible solution strategy.
    Notice that log[2] 5,000 rounds up to 13\. If we can find a way to use binary
    search, then it’ll pick out the switch for the current door in only 13 calls of
    `tryCombination`, not 5,000\. If we take 13 calls per door, and we have 5,000
    doors, that’s 13 × 5,000 = 65,000 calls in all. We’ll need one extra call per
    door to tell us whether the door is closed but, still, we should be able to get
    in under the 70,000 limit.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: How can binary search be used here? It must have something to do with eliminating
    half of the switch range on each step. Take some time to think through this before
    continuing!
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll explain the idea through an example. Suppose we have eight doors and eight
    switches and that Door 0 is currently closed. If we flip Switch 0, and Door 0
    doesn’t open, then we’ve learned very little: all we’ve learned is that Switch
    0 isn’t the switch associated with Door 0\. (It’s like starting with “1” when
    guessing someone’s number between 1 and 1,000.) A better idea is to flip half
    of the switches. So let’s flip Switches 0, 1, 2, and 3\. No matter what that does
    to Door 0, we learn a lot. If Door 0 is still closed, then Switches 0 to 3 have
    nothing to do with Door 0, and we can focus only on Switches 4 to 7\. If Door
    0 is now open, we know that one of the Switches 0 to 3 is the switch that’s associated
    with Door 0, and we can focus only on Switches 0 to 3\. One step: half the range
    gone. We continue in this way until we find the switch (and its position) associated
    with Door 0.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we go all the way, cutting the range of switches in half again
    and again until we have only one switch remaining. Let’s say we find that Switch
    6 is associated with Door 0\. We’ll then set Switch 6 so that Door 0 is open.
    That’s how it stays. When we next solve Door 1, or indeed any other door later,
    we’ll be careful not to change the position of Switch 6.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: I can now present the binary search solution to this problem. The new `set_a_switch`
    code is given in [Listing 7-17](ch07.xhtml#ch07ex017). The `exploreCave` function
    is the same as before ([Listing 7-15](ch07.xhtml#ch07ex015)).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 7-17: Finding and setting the switch for the current door using a
    binary search*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Compared to [Listing 7-16](ch07.xhtml#ch07ex016), the only real change is the
    replacement of the linear search with a binary search. Prior to each evaluation
    of the binary search condition ➊, we’ll arrange so that the current door is closed.
    In particular, once `low` and `high` are equal and the loop terminates, the door
    will still be closed. Then all we have to do is change the position of switch
    `low` to open the door.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now study the binary search itself. On each iteration, we calculate the
    midpoint `mid`, then change the position of the first half of the switches (but
    only those that are not already associated with doors). What effect did that have
    on the current door ➋? There are two possibilities:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '**The door is now open.**   We now know that the switch we seek is between
    `low` and `mid`, so we throw away all switches greater than `mid`. We also flip
    each switch between `low` and `mid` back to what they were prior to this iteration.
    This closes the door again so that we’re ready for the next iteration.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '**The door is still closed.**   The switch we want is therefore between `mid
    + 1` and `high`, so we throw away all switches that are `mid` or less. That’s
    all we do! No switches get flipped here, because the door is still closed, just
    as we want it.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: When we finish the binary search, `low` and `high` will be equal, and they tell
    us the switch associated with the current door. The current door is still closed
    at this point, so we flip the switch to open it ➌.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no more caveats: we have a clean, fast, binary-search-based solution.
    Send this off to the judge and you should pass all of the test cases.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes it’s much tougher to find an optimal solution than it is to check
    whether some proposed solution is feasible. How much liquid should be poured in
    a tree? I don’t know. Is 10 liters enough liquid? Now that question I can handle.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: When the conditions are right, binary search can convert a hard optimization
    problem into an easier feasibility-check problem. Sometimes it feels like cheating!
    We pay just an extra logarithmic factor for adding the binary search. A logarithmic
    factor is practically free. In return, we get to deal with an easier problem.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: I’m not claiming that binary search is the only way to solve the problems in
    this chapter. For example, it’s possible to solve Feeding Ants without binary
    search along the lines of what we did in [Chapter 2](ch02.xhtml), but I find that
    solution trickier than the one I presented in this chapter. Some problems that
    can be solved by binary search can also be solved by dynamic programming, but,
    again, doing so may be very challenging and there’d likely be little practical
    payoff anyway.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'What I am claiming is that binary search can offer solutions that are both
    nearly as fast as and easier to design than anything else we might try. If you’re
    not convinced, you might revisit each problem in this chapter, this time considering
    how you might solve it without binary search. But, really: if you’re working on
    a problem and see that you can use binary search, just do it and don’t look back.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feeding Ants is originally from the 2014 Croatian Open Competition in Informatics,
    Round 4\. River Jump is originally from the December 2006 USA Computing Olympiad,
    Silver Division. Living Quality is originally from the 2010 International Olympiad
    in Informatics. Cave Doors is originally from the 2013 International Olympiad
    in Informatics.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary search is one manifestation of a general algorithm design technique
    called *divide and conquer (D&C)*. D&C algorithms solve one or more independent
    subproblems, then combine those solutions to solve the original problem. Binary
    search solves just one subproblem—the one corresponding to the part of the input
    that we know contains the solution. Other D&C algorithms typically solve two or
    more subproblems; in [Chapter 10](ch10.xhtml), we’ll see such an example. To learn
    about other problems that are solved efficiently by D&C algorithms, see *Algorithms
    Illuminated (Part 1): The Basics* by Tim Roughgarden (2017).'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
