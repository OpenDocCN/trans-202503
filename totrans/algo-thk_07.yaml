- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BINARY SEARCH
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter is all about binary search. If you don’t know what binary search
    is— excellent! I’m excited for the opportunity to teach you a systematic, performant
    technique for isolating an optimal solution from among zillions of possible solutions.
    And if you do know what binary search is and think that it’s just for searching
    a sorted array—excellent! You’ll learn that binary search is for so much more
    than that. To keep things fresh, we will not search a sorted array in this entire
    chapter, not even once.
  prefs: []
  type: TYPE_NORMAL
- en: What do minimizing the amount of liquid needed to feed ants, maximizing the
    minimum jump distance between rocks, finding the best living area in a city, and
    flipping switches to open cave doors have in common? Let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: Feeding Ants'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is DMOJ problem `coci14c4p4`.
  prefs: []
  type: TYPE_NORMAL
- en: '#### *The Problem*'
  prefs: []
  type: TYPE_NORMAL
- en: Bobi has a terrarium in the shape of a tree. Each edge of the tree is a pipe
    in which liquid flows down. Some pipes are superpipes that increase the amount
    of liquid that flows through them. Bobi keeps one of his pet ants in each of the
    tree’s leaves. (Yes, this context is a reach. I won’t pretend otherwise, but this
    problem is otherwise ace.)
  prefs: []
  type: TYPE_NORMAL
- en: Each pipe has a percentage value that indicates the percentage of the available
    liquid that flows through it. For example, suppose that a node *n* has three downward
    pipes, where those pipes have percentage values of 20 percent, 50 percent, and
    30 percent, respectively. If 20 liters of liquid arrive at Node *n*, then the
    20 percent pipe gets 20 × 0.2 = 4 liters, the 50 percent pipe gets 20 × 0.5 =
    10 liters, and the 30 percent pipe gets 20 × 0.3 = 6 liters.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the superpipes. For each superpipe, Bobi decides whether its special
    behavior is off or on. If it is off, then it behaves like a regular pipe. If it
    is on, then it squares the amount of liquid that it receives.
  prefs: []
  type: TYPE_NORMAL
- en: Bobi pours liquid into the root of the tree. His goal is to give each ant at
    least the amount of liquid that it requires and to do so by pouring as little
    liquid as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make this description concrete by studying a sample terrarium; see [Figure
    7-1](ch07.xhtml#ch07fig01).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: A sample terrarium*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve numbered the nodes from 1 to 6; the leaf nodes (2, 3, 5, and 6) have an
    additional annotation giving the amount of liquid required by each ant. I’ve also
    annotated each edge with its percentage value. Notice that the percentage values
    of the downward pipes leaving a given node always add up to 100 percent.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one superpipe in the tree, from Node 1 to Node 4; I’ve drawn that with
    a thicker edge. Suppose that 20 liters of liquid are poured into the root. The
    superpipe gets 30 percent of the 20 liters, which is 6 liters. If the superpipe’s
    special behavior is off, then 6 liters flow through it. However, if the superpipe’s
    special behavior is on, then, instead of 6 liters of liquid flowing through it,
    6² = 36 liters of liquid flow through it.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of nodes in the tree. *n* is between 1 and
    1,000\. The tree nodes are numbered from 1 to *n*, and the root of the tree is
    node 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* – 1 lines used to build the tree. Each of these lines represents one pipe
    and consists of four integers: the two nodes connected by the pipe, the pipe’s
    percentage value (between 1 and 100), and whether the pipe is a superpipe (with
    0 meaning no and 1 meaning yes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing *n* integers, one for each node, giving the number of liters
    of liquid needed by the ant in that node. Each ant requires between 1 and 10 liters
    of liquid. For any nonleaf node (where there is no ant), a value of –1 is given.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an input that could generate the sample terrarium in [Figure 7-1](ch07.xhtml#ch07fig01):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note how the first line (integer 6 here) indicates the number of nodes in the
    tree, not the number of lines that build the tree. The number of lines that build
    the tree (in this case five lines) is always one less than the number of nodes.
    (Why is it always one less? Each line that builds the tree effectively tells us
    the parent of one of the *n* nodes. Each node except for the root has a parent,
    so we need *n* – 1 lines to tell us about all of the *n* – 1 parents.)
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the minimum number of liters of liquid that Bobi must pour into the tree’s
    root to feed all the ants. Include four digits of accuracy after the decimal point.
    The correct output is guaranteed to be at most 2,000,000,000 (two billion).
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 0.6 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*A New Flavor of Tree Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As in [Chapter 2](ch02.xhtml), we’re in the domain of trees here. If we want
    to explore a terrarium tree, then we can use recursion. (A full graph-search algorithm
    such as BFS is overkill because there are no cycles.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For the two problems in [Chapter 2](ch02.xhtml), our solutions were based on
    the structure of the tree and the values stored in nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: In Halloween Haul, we calculated the total candy by adding up the values in
    the leaves, and we calculated the total street-walks using the height and shape
    of the tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Descendant Distance, we calculated the number of descendants at the desired
    distance by using the number of children of each node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is, what we needed—candy values, height, tree shape—were right there, encoded
    for us in the tree itself. In the present problem, we’re asked to find the minimum
    number of liters that Bobi must pour—but the tree doesn’t contain any values like
    that! The tree has information on pipe percentage, superpipe status, and ant appetite,
    but it has nothing directly informing us of the amount of liquid that should be
    poured into the root. In particular, the superpipes, with their liquid-squaring
    behavior, make unclear the relationship between the amount of liquid needed by
    the ants and the amount of liquid that should be poured.
  prefs: []
  type: TYPE_NORMAL
- en: Because the tree won’t readily give us what we need, I’ll just pick a value
    out of thin air—say, 10\. There you go, Bobi. Pour 10 liters in there.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you’re very suspicious of what I just did, recklessly choosing a number
    like that. You should be surprised if 10 were the answer. I pulled 10 out of thin
    air, after all. You may also be surprised that we can in fact learn a lot by trying
    out the value 10 and seeing what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use [Figure 7-1](ch07.xhtml#ch07fig01) again. Suppose that we pour 10
    liters of liquid into the root. Twenty percent of 10 is 2, so 2 liters of liquid
    will make it to the ant in Node 2\. Perfect: that ant needs 2 liters of liquid,
    so we’re sending just enough liquid. Let’s continue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since 50 percent of 10 is 5, the ant in Node 3 gets 5 liters of liquid. Now
    we’re in trouble: that ant needs 9 liters of liquid, and 5 liters is not enough.
    More bad news: the pipe between Nodes 1 and 3 is not a superpipe, so there’s nothing
    we can do except declare that 10 is not in fact the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: We could proceed by picking another number of liters out of thin air and similarly
    simulating the flow of liquid on that new number. However, because 10 liters was
    insufficient, now we should restrict our thin-air range to only values *greater
    than 10*. Since 10 liters was insufficient, any smaller value will be insufficient,
    too. There’s no point trying 2 liters or 7 liters or 9.5 liters or anything less
    than 10\. They’re all too small.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s next try 20 liters. This time, the ant at Node 2 gets 4 liters, which
    is just fine because that ant only needs 2 liters. The ant at Node 3 gets 10 liters,
    which again is fine because that ant only needs 9 liters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipe between Nodes 1 and 4 takes 30 percent of the liquid, so that’s 6
    liters of the total 20 liters. However, this pipe is a superpipe! If we use its
    special behavior, the pipe cranks up the 6 liters to 6² = 36 liters, so 36 liters
    arrives at Node 4\. Now the ants at Nodes 5 and 6 are fine: each ant gets 18 liters,
    and they only need 7 liters (Node 5) and 8 liters (Node 6).'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike 10 liters, then, 20 liters is a feasible solution, but is it the optimal
    (that is, minimal) solution? Maybe, maybe not. What we know for sure is that there’s
    no point testing any number of liters greater than 20\. We already have 20 as
    a feasible solution; why try values, such as 25 or 30, that are worse?
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reduced the problem to finding an optimal solution between 10 and
    20 liters. We could keep choosing numbers, reducing the range at each step, until
    our range is so small that one of its endpoints serves as an accurate solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the general case, what number of liters should we choose first? The optimal
    solution could be up to 2 billion, so starting with 10 may be way, way off. And,
    once we test a number of liters, where should we go next? The optimal solution
    might be considerably larger or smaller than our current guess, so adding or subtracting
    10 at a time may not help us make much progress.
  prefs: []
  type: TYPE_NORMAL
- en: These are good questions, good questions that we will answer . . . but not yet.
    Let’s first tackle how to read the input (so that we can explore a tree) and how
    to determine whether a number of liters is a feasible solution. Then, we’ll see
    a super-fast algorithm for searching massive ranges. A range of two billion? We’ll
    eat that for breakfast.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reading the Input*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml), we used a `node` struct at the core of how trees
    were represented. Then, in [Chapter 5](ch05.xhtml), Book Translation, we used
    the adjacency list representation of a graph with an `edge` struct. There we learned
    that whether we use a `node` or `edge` struct comes down to whether it’s the nodes
    or the edges that carry additional attributes. In the present problem, the edges
    carry information (a percentage and a superpipe status), but so do the leaf nodes
    (the amount of liquid required by each ant). It’s therefore tempting and reasonable
    to use *both* an `edge` struct and a `node` struct. Instead, to closely parallel
    the use of adjacency lists, I’ve chosen to stick with only an `edge` struct. As
    in the problem description, we number nodes starting at 1, but, with no `node`
    struct, we have nowhere to store the amount of liquid required by each ant. For
    that reason, we augment the adjacency list with a `liquid_needed` array, where
    `liquid_needed[i]` gives the amount of liquid required by the ant in Node `i`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the constant and `typedef` that we’ll use throughout the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As in Book Translation ([Chapter 5](ch05.xhtml)) and the two problems in [Chapter
    6](ch06.xhtml), we can chain these `edge` structs together through `next` pointers
    to form a linked list of edges. If an edge is in the linked list for nNde `i`,
    then we know that the parent node of the edge is `i`. The `to_node` member tells
    us the child node at which this edge connects with the parent node; `percentage`
    is an integer between 1 and 100 that gives the percentage value for the pipe (edge);
    and `superpipe` is a flag whose value is `1` if the pipe is a superpipe and `0`
    if it’s a regular pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can read the tree from the input, as shown in [Listing 7-1](ch07.xhtml#ch07ex01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: The* main *function for building the tree*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is similar to, but simpler than, [Listing 5-16](ch05.xhtml#ch05ex016)
    (Book Translation). In particular, each edge is read from the input, its members
    are set, and then it’s added to the list of edges for `from_node` ➊. You may expect
    a corresponding edge to be added for `to_node`, since the graph is undirected,
    but I’ve left out such edges: liquid moves down the tree, not up, so adding backward
    edges would needlessly complicate the code that explores a tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the edge information is read in, all that’s left is to read the values
    for the amount of liquid required by each ant. We’ll use the `liquid_needed` array
    for that ➋. The combination of `adj_list` and `liquid_needed` captures everything
    we need to know about the test case.
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Testing Feasibility*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next milestone is this: determine whether a given amount of liquid is a
    feasible solution. This is a crucial step, because once we have a function that
    can test a value for feasibility, we’ll be able to use it to progressively narrow
    the search space until we find the optimal solution. Here’s the signature for
    the function that we’ll write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `node` is the root node of the tree, `liquid` is the amount of liquid
    that we pour into the root of the tree, `adj_list` is the adjacency list for the
    tree, and `liquid_needed` is the amount of liquid required by each ant. We’ll
    return `1` if `liquid` is enough to feed the ants (that is, if `liquid` is a feasible
    solution) and `0` if it is not.
  prefs: []
  type: TYPE_NORMAL
- en: We spent a whole chapter ([Chapter 2](ch02.xhtml)) writing recursive functions
    on trees. Let’s think about whether we can use recursion again.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, to use recursion, we need a base case—a case that can be solved
    with no recursion. Luckily, we have one! If the tree is a single leaf node, then
    we can determine right away whether `liquid` is sufficient. If `liquid` is greater
    than or equal to the amount of liquid needed by the ant in this leaf, then we
    have a feasible solution; otherwise, we don’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can tell whether a node is a leaf by checking the corresponding value in
    `liquid_needed`: if it’s `-1`, then it isn’t a leaf; otherwise, it is. (We could
    have also used the adjacency list to check whether or not the linked list for
    the node was empty.) Here’s what we’ve got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, consider the recursive case. Imagine that the root node of some tree has
    *p* downward pipes (that is, *p* children). We’re given the amount of liquid that’s
    poured into the root. Using the pipe percentage values, we can determine the amount
    of liquid that goes into each pipe; using the superpipe statuses, we can determine
    the amount of liquid that reaches the bottom end of each pipe. If enough liquid
    reaches the bottom end of each pipe, then the liquid poured into the root was
    sufficient and we should return `1`. Otherwise, the amount of liquid that reaches
    the bottom end of some pipe isn’t sufficient, and we should return `0`. This suggests
    that we should make *p* recursive calls, one for each pipe that leaves the root.
    We’ll do that in a loop that uses the adjacency list to go through each such pipe.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for the function is given in [Listing 7-2](ch07.xhtml#ch07ex02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: Testing the feasibility of the amount of liquid*'
  prefs: []
  type: TYPE_NORMAL
- en: The `ok` variable tracks whether `liquid` is a feasible solution for the tree.
    If `ok` is `1`, then the solution is still feasible; if `ok` is `0`, then it’s
    definitely not. We initialize `ok` to `1` ➊, and we set it to `0` if the amount
    of liquid through one of the pipes isn’t sufficient ➌. If `ok` is still `1` at
    the bottom of the function, then we’ve satisfied all pipes and we conclude that
    `liquid` is feasible.
  prefs: []
  type: TYPE_NORMAL
- en: We determine the amount of liquid that enters each pipe by using that pipe’s
    percentage value. Then, if the pipe is a superpipe, we square that value ➋ . .
    . but hey, wait! The problem description says that Bobi gets to decide whether
    or not to use the special behavior of each superpipe. However, here we’re just
    indiscriminately squaring the amount of liquid, thereby always using the special
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we can get away with this is that squaring makes values bigger:
    compare 2 to 2² = 4, 3 to 3² = 9, and so on. Since we want to know whether the
    given amount of liquid is feasible and there’s no penalty for using the special
    behavior of a superpipe, we may as well generate as much liquid as possible. Maybe
    we could have gotten away without using some superpipe special behavior, but no
    one’s asking us to be economical.'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry that squaring makes positive values less than one, such as 0.5,
    smaller. 0.5² = 0.25, so indeed we wouldn’t want to activate superpipe behavior
    in such cases. Each ant requires at least 1 liter of liquid, though. So, if we’re
    down to 0.5 liters of liquid at some node, then nothing we do is going to feed
    the ants in the node’s subtree anyway. We’d eventually return `0` whether or not
    we squared the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s show how useful this `can_feed` function is by continuing the work we
    did in “A New Flavor of Tree Problem” on [page 233](ch07.xhtml#sec97). We showed
    there that 10 liters was not sufficient for the sample instance from the problem
    description. Comment out the `solve` call at the bottom of [Listing 7-1](ch07.xhtml#ch07ex01)
    (don’t worry: we’ll write that `solve` function soon), and add a call to `can_feed`
    to test 10 liters of liquid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a result of `0`, which means that 10 liters isn’t sufficient.
    We also showed that 20 liters was sufficient. Change the `can_feed` call to test
    20 liters instead of 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should see a result of `1`, which means that 20 liters is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know that 10 is not enough but 20 is. Let’s squeeze this range down
    further. Try 15, and you should see an output of `0`. So, it seems 15 is not enough.
    Our optimal answer is now greater than 15 and at most 20.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try 18 next: you should see that 18 is enough. How about 17? No, 17 is not
    enough, nor is 17.5 or 17.9\. It turns out that the optimal solution is indeed
    18.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s enough of the ad hoc searching. Let’s systematize this.
  prefs: []
  type: TYPE_NORMAL
- en: '*Searching for a Solution*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: From the problem description, we know that the optimal solution is at most two
    billion. There’s therefore a massive search space in which the optimal solution
    lies. Our goal is to cut down this space as quickly as possible by never wasting
    a guess.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easy to waste a guess. For example, if we start with a guess of 10, and
    the optimal solution is in fact two billion, then we’ve essentially wasted that
    guess: all we’ve done is eliminate the numbers between 0 and 10\. It’s true that
    a guess of 10 would be fantastic if the optimal solution were, say, 8, because
    that one step would cut the range down to 0 to 10 and we’d find 8 soon after.
    Nonetheless, taking shots like this isn’t worth it, because getting lucky once
    in a while won’t offset the very likely case that our guess tells us almost nothing.
    It’s for this reason that you don’t guess 10 as your first guess when someone
    asks you to guess their number between 1 and 1,000\. Sure, if they say “lower,”
    you look like a full-on rock star, but if they say “higher,” as they most likely
    will, you’ve all but wasted that first guess.'
  prefs: []
  type: TYPE_NORMAL
- en: To guarantee that we learn as much as possible with each guess, we’ll always
    guess the middle of the range. To do so, we maintain two variables, `low` and
    `high`, holding the low end and high end, respectively, of our current range.
    We then calculate the middle of the range, `mid`, test the feasibility of `mid`,
    and update `low` or `high` based on what we learn. We’ll implement this strategy
    in [Listing 7-3](ch07.xhtml#ch07ex03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3: Searching for the optimal solution*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to initialize `low` and `high` so that their range is guaranteed
    to contain the optimal solution. At all times, we’ll maintain that `low` is less
    than or equal to the optimal solution and that `high` is greater than or equal
    to the optimal solution. We start `low` off with a value of 0; as each ant requires
    at least 1 liter, 0 liters is definitely less than or equal to the optimal solution.
    We start `high` off with a value of 2 billion, because it’s guaranteed by the
    problem description that 2 billion is the maximum value of the optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop condition forces the range between `low` and `high` to be very
    small by the time the loop ends ➊. We need four digits of accuracy, hence the
    four 0s after the decimal point in `0.00001`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do in the loop body is to calculate the middle of the range.
    We’ll do that by taking the average of `low` and `high`, storing that result in
    `mid` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to test `mid` liters for feasibility, using `can_feed` ➌. If `mid`
    is feasible, we have learned that guessing anything larger than `mid` would be
    a waste. We therefore set `high = mid` to cut the range off at a maximum of `mid`.
  prefs: []
  type: TYPE_NORMAL
- en: If `mid` is not feasible, then guessing anything smaller than `mid` would be
    a waste. We therefore set `low = mid` to cut the range off at a minimum of `mid`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the loop terminates, `low` and `high` are very close together. We’re printing
    `high` ➍, but printing `low` would work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: This technique, where we keep dividing the range in half until it’s very small,
    is called *binary search*. It’s a surprisingly subtle and powerful algorithm,
    further evidence of which will come from the remaining problems in this chapter.
    It’s also very fast, able to handle ranges of billions or trillions with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Submit the solution to the judge, and then let’s keep going. There’s a lot more
    to know about binary search.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feeding Ants is an exemplar of the types of problems where binary search thrives.
    There are two ingredients to such problems; if you see these ingredients in a
    new problem you’re facing, it’s worth your time to try binary search.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingredient 1: Hard optimality and easy feasibility**   For some problems,
    it’s hard to come up with a way to find an optimal solution. Fortunately, in many
    such cases, it’s considerably easier to determine whether or not some proposed
    solution is feasible. This was the situation in the Feeding Ants problem: we didn’t
    know how to find an optimal solution directly, but we did see how to determine
    whether some number of liters was feasible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingredient 2: Infeasible–feasible split**   We need the problem to exhibit
    the property that there is a border between infeasible and feasible solutions.
    All solutions on one side of the border must be infeasible, and all solutions
    on the other side must be feasible. In Feeding Ants, small values were infeasible
    and large values were feasible. Imagine considering values from small to large
    and asking whether each is infeasible or feasible. In doing so, we’ll see a bunch
    of infeasible values and then a feasible value; after our first feasible value,
    we won’t see infeasible values again. Suppose we try a value of 20 liters and
    find that it’s infeasible. This means that we’re still in the infeasible part
    of the search space, and we must search larger values. If 20 liters is feasible,
    then we’re in the feasible part of the search space, and we should search smaller
    values. (Not meeting Ingredient 2 renders binary search useless. For example,
    suppose we have a problem where small values are infeasible, larger values are
    feasible, and even-larger values are infeasible again. We try a value of 20 and
    find that it is infeasible. Don’t even think about focusing on values greater
    than 20: for all we know, values less than 10 could be infeasible and 10 to 15
    could be feasible, giving 10 as the optimal solution here.) It’s also okay if
    the search space transitions from feasible to infeasible, rather than from infeasible
    to feasible. Our next problem will offer such an example.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Runtime of Binary Search*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The reason why binary search is so powerful is that it makes a huge amount
    of progress with just a single iteration. For example, suppose that we’re searching
    for an optimal solution in a range of two billion. A single iteration of binary
    search throws out half of this range, leaving a range of only one billion. Let
    that sink in: with just a single `if` statement and one variable update to `mid`,
    we make one billion units of progress! If binary search takes *q* iterations to
    search a range of one billion, then it takes only one more iteration, *q* + 1,
    to search a range of two billion. The number of iterations grows very slowly compared
    to the width of the range.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of iterations taken by binary search to cut a range *n* to range
    1 is roughly the number of times that *n* must be divided by 2 to get down to
    1\. For example, say that we start with a range of 8\. After one iteration, we’ll
    have reduced the range to at most 4\. After two iterations, we’ll have reduced
    the range to at most 2\. After three iterations, we’ll have reduced the range
    to 1\. Moreover, if we don’t care about decimal digits of accuracy, then that’s
    it: three iterations.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a mathematical function called the *base-2 logarithm*, which, given
    value *n*, tells you how many times you have to divide *n* by 2 to get 1 or less.
    It’s written log[2] *n* or, when the discussion makes it clear that two is the
    base, as just log *n*. For example, log[2] 8 is 3 and log[2] 16 is 4\. log[2]
    2,000,000,000 (that’s two billion) is 30.9, so it takes about 31 iterations to
    knock this range down to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search is an example of a *logarithmic-time* algorithm. We therefore
    say that it’s *O*(log *m*). (You’d ordinarily use *n* here instead of *m*, but
    we’re going to use *n* for something else later in this section.) To reduce a
    range to 1, *m* is the initial width of the range. However, in Feeding Ants, we
    needed to go further, obtaining four decimal digits of accuracy. What is *m* there?
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to come clean on how we used binary search in Feeding Ants: we do
    more than log[2] 2,000,000,000 iterations of binary search, because we don’t stop
    when the width of the range is 1\. Instead, we stop once we’ve achieved four digits
    of accuracy after the decimal point. Adding five zeros gives us the number of
    iterations that we do: log[2] 200,000,000,000,000 rounds up to 48\. Only 48 iterations
    are needed to pull a solution with four decimal digits of accuracy from a bewildering
    range of trillions. That’s what binary search is made of.'
  prefs: []
  type: TYPE_NORMAL
- en: On a tree of *n* nodes, the `can_feed` function in [Listing 7-2](ch07.xhtml#ch07ex02)
    (Feeding Ants) takes linear time; that is, time proportional to *n*. We call that
    function log[2] *m* × 10⁴ times, where *m* is the width of the range (two billion
    in the test cases). This is proportional to log *m* work. In total, then, we do
    *n* work a total of log *m* times. This is an *O*(*n* log *m*) algorithm. It is
    not quite linear, because of that extra log *m* factor, but still very fast.
  prefs: []
  type: TYPE_NORMAL
- en: '*Determining Feasibility*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What I like most about binary search algorithms is that determining whether
    a value is feasible often requires the use of some other type of algorithm. That
    is, on the outside we have binary search, but on the inside—to test if each value
    is feasible—we have something else. That something else could be anything. In
    Feeding Ants, it was a tree search. In our next problem, it will be a greedy algorithm.
    In our third problem, it will be a dynamic-programming algorithm. We won’t see
    one in this book, but there are problems where checking feasibility requires running
    a graph algorithm. That stuff you’ve learned in the previous chapters will all
    be in play again.
  prefs: []
  type: TYPE_NORMAL
- en: Determining feasibility often requires considerable creativity (just hopefully
    not as much creativity as needed for finding optimality!).
  prefs: []
  type: TYPE_NORMAL
- en: '*Searching a Sorted Array*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you were familiar with binary search prior to reading this chapter, odds
    are that it was in the context of searching a sorted array. A typical scenario
    is that we are given an array `a` and a value `v`, and we want to find the smallest
    index of `a` whose value is greater than or equal to `v`. For example, if we were
    given the array `{-5, -1, 15, 31, 78}` and `v` were 26, we’d return index `3`,
    because the value at index `3` (31) is the first one that’s greater than or equal
    to 26.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does binary search work here? Take a look at the two ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingredient 1**   Without a binary search, finding the optimal value would
    involve a costly scan through the array. Therefore, optimality is hard to obtain,
    but feasibility is easy: if I give you an index `i`, you can tell me right away
    whether `a[i]` is greater than or equal to `v` just by comparing `a[i]` to `v`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingredient 2**   Any values smaller than `v` come before any values that
    are greater than or equal to `v`—remember that `a` is sorted! That is, the infeasible
    values come before the feasible values.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s true that binary search can be used to find a suitable index in an array
    in logarithmic time; later, in [Chapter 10](ch10.xhtml), we’ll use it for that
    very purpose. But we solved Feeding Ants with binary search, with no such array
    in sight. Don’t restrict yourself to thinking about binary search only when you
    have an array to search. Binary search is far more flexible than that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: River Jump'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll now see a problem in which we need a greedy algorithm to determine feasibility.
  prefs: []
  type: TYPE_NORMAL
- en: This is POJ problem `3258`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a river of length *L* along which rocks have been placed. There’s a
    rock at Location 0 (the beginning of the river), a rock at Location *L* (the end
    of the river), and then *n* other rocks between these. For example, on a river
    of length 12, we might have rocks at the following locations: 0, 5, 8, and 12.'
  prefs: []
  type: TYPE_NORMAL
- en: A cow begins on the first rock (Location 0), jumps from there to the second
    rock, jumps from the second rock to the third rock, and so on, until it gets to
    the rock at the end of the river (Location *L*). Its minimum jump distance is
    the minimum distance between any consecutive pair of rocks. In the above example,
    the minimum jump distance is 3, witnessed by the distance between the rocks at
    Locations 5 and 8.
  prefs: []
  type: TYPE_NORMAL
- en: Farmer John is bored by the short jumps made by the cow, so he wants to increase
    the minimum jump distance as much as possible. He can’t remove the rock at Location
    0 or Location *L*, but he is able to remove *m* of the other rocks.
  prefs: []
  type: TYPE_NORMAL
- en: In the above example, suppose that Farmer John is able to remove one rock. His
    choice is then to remove the rock at Location 5 or Location 8\. If he removes
    the rock at Location 5, the minimum jump distance is 4 (from Location 8 to Location
    12). However, he shouldn’t do that, because if he removes the rock at Location
    8, then he achieves a greater minimum jump distance of 5 (from Location 0 to Location
    5).
  prefs: []
  type: TYPE_NORMAL
- en: Our task is to maximize the minimum jump distance that Farmer John can achieve
    by removing *m* rocks.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Input'
  prefs: []
  type: TYPE_NORMAL
- en: 'The input contains one test case, consisting of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing the three integers *L* (the length of the river), *n* (the
    number of rocks, not including the rocks at the beginning and end), and *m* (the
    number of rocks that Farmer John can remove). *L* is between 1 and 1,000,000,000
    (one billion), *n* is between 0 and 50,000, and *m* is between 0 and *n*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each giving the integer location of a rock. No two rocks will be
    at the same location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output the maximum achievable minimum jump distance. For the above example,
    we would output `5`.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*A Greedy Idea*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.xhtml), when solving the Moneygrubbers problem, we introduced
    the idea of a greedy algorithm. A greedy algorithm does what looks promising right
    now, with no regard to the long-term consequences of its choices. Such an algorithm
    is often easy to propose: just state the greedy rule that it uses to make its
    next choice. When solving the Moneygrubbers problem, for example, I proposed the
    greedy algorithm that chooses the option of cheapest cost per apple. That greedy
    algorithm was incorrect. That lesson is worth remembering: while it’s easy to
    propose a greedy algorithm, it’s not easy to find one that’s correct.'
  prefs: []
  type: TYPE_NORMAL
- en: For two reasons, I didn’t dedicate a chapter of the book to greedy algorithms.
    First, they’re not as broadly applicable as other algorithm design approaches
    (such as dynamic programming). Second, when they do happen to work, it’s often
    for subtle, problem-specific reasons. I’ve been duped many times over the years
    by seemingly correct but ultimately flawed greedy algorithms. A careful proof
    of correctness is often required to distinguish between the ones that are right
    and the ones that only feel right.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, greedy algorithms did make a concealed—and this time correct—appearance
    in [Chapter 6](ch06.xhtml) in the form of Dijkstra’s algorithm. Algorithmists
    generally classify Dijkstra’s algorithm as greedy. Once the algorithm declares
    that a node’s shortest path has been found, it never goes back on that decision.
    It commits, once and for all, and does not let future discoveries influence what
    it has done in the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'Greedy algorithms are now going to reappear. When I was introduced to River
    Jump several years ago, my instinct was that I could use a greedy algorithm to
    solve it. I wonder if you’ll find the proposed algorithm as natural as I did.
    Here’s the greedy rule: find the two rocks that are closest together, remove the
    one that’s closest to its other neighbor rock, and repeat.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the example from the problem description. Here it is as a test
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, here are the rock locations: 0, 5, 8, and 12\. We’re allowed
    to remove one rock. The two rocks that are closest together are those at Locations
    5 and 8, so the greedy rule will result in one of these being removed. The rock
    at Location 8 is a distance of 4 from its neighbor to the right; the rock at Location
    5 is a distance of 5 from its neighbor to the left. Therefore, the greedy algorithm
    removes the rock at Location 8\. It works correctly in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s throw a bigger example in here and see what the greedy algorithm does.
    Suppose that the river has a length of 12 and we’re allowed to remove two rocks.
    Here’s the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The rock locations are 0, 1, 3, 8, 9, and 12\. What will the greedy algorithm
    do? The rocks that are closest together are the ones at Locations 0 and 1 and
    those at Locations 8 and 9\. We’ll have to choose one pair—let’s choose 0 and
    1\. Since removing the rock at Location 0 is not allowed, we remove the rock at
    Location 1\. The remaining rock locations are 0, 3, 8, 9, and 12.
  prefs: []
  type: TYPE_NORMAL
- en: Now the closest rocks are at Locations 8 and 9\. The distance between 9 and
    12 is less than the distance between 8 and 3, so the greedy algorithm removes
    the rock at Location 9\. We’re left with 0, 3, 8, and 12\. The minimum jump distance
    here, and the correct answer, is 3\. The greedy algorithm wins again.
  prefs: []
  type: TYPE_NORMAL
- en: Isn’t that right? Keep knocking off the smallest distance between two rocks.
    How could we possibly do better than that? The greedy algorithm charms.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, the greedy algorithm is not correct. I encourage you to try to come up
    with a counterexample before I spoil it in the next paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a counterexample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re allowed to remove two rocks. The rock locations are 0, 2, 4, 5, 8, and
    12\. The greedy rule identifies the rocks at Locations 4 and 5 as the closest
    rocks. It will remove the rock at Location 4, since the distance between 4 and
    2 is less than the distance between 5 and 8\. Here’s what’s left: 0, 2, 5, 8,
    and 12.'
  prefs: []
  type: TYPE_NORMAL
- en: Now the greedy rule identifies the rocks at Locations 0 and 2 as the closest
    pair. It isn’t allowed to remove the rock at 0, so it removes the rock at 2\.
    We’re left with 0, 5, 8, and 12\. That’s a minimum jump distance of 3\. Here we
    have a mistake made by the greedy algorithm, because the maximum achievable minimum
    jump distance is 4\. To see this, rather than remove the rocks at Locations 2
    and 4, remove the ones at Locations 2 and 5\. That leaves us with 0, 4, 8, and
    12.
  prefs: []
  type: TYPE_NORMAL
- en: What went wrong? By removing the rock at Location 4 as its first move, the greedy
    algorithm creates a situation involving a jump distance of 2 and a jump distance
    of 3\. It can only fix one of those two with its second move, so it has no chance
    of producing a minimum jump distance of anything greater than 3.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t know a greedy algorithm that directly solves this problem. Like Feeding
    Ants, this is a tough one to solve head-on. Fortunately, we don’t have to.
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing Feasibility*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In “Binary Search” on [page 240](ch07.xhtml#lev44), I offered two signals that
    point to a binary search solution: that it’s easier to test feasibility than produce
    optimality and that the search space transitions from infeasible to feasible (or
    feasible to infeasible). We’ll see that the River Jump problem passes on both
    counts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of solving for the optimal solution outright, let’s solve for a different
    question: Is it possible to achieve a minimum jump distance of at least *d*? If
    we can nail this, then we can use binary search to find the largest feasible value
    of *d*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the test case that ended the previous subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We’re allowed to remove two rocks. The rock locations are 0, 2, 4, 5, 8, and
    12.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a question: What is the minimum number of rock removals that are needed
    to achieve a minimum jump distance of at least 6? Let’s work from left to right
    and check. The rock at Location 0 has to stay—that’s spelled out in the problem
    description. It’s then evident that we have no choice of what to do with the rock
    at Location 2: we must remove it. If we didn’t, then the distance between the
    rocks at Locations 0 and 2 would be less than 6\. So, one rock is removed. The
    remaining rocks are at 0, 4, 5, 8, and 12.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider the rock at Location 4—do we keep it or remove it? Again, we’re
    forced to remove it. If we keep it, then the rocks at Locations 0 and 4 would
    be closer together than 6\. That’s our second removal, and we’re left with rocks
    at 0, 5, 8, and 12.
  prefs: []
  type: TYPE_NORMAL
- en: The rock at Location 5 has to be removed, too, because it’s only a distance
    of 5 from the 0 rock. That’s our third removal, leaving us with rocks at 0, 8,
    and 12.
  prefs: []
  type: TYPE_NORMAL
- en: We have to remove the rock at Location 8, too! It’s far enough from Location
    0 but too close to Location 12\. That’s our fourth removal, ultimately leaving
    us with just two rocks at 0 and 12.
  prefs: []
  type: TYPE_NORMAL
- en: So it takes four removals to achieve a minimum jump distance of at least 6,
    but we’re only allowed to remove two rocks. As such, 6 is not a feasible solution.
    It’s too big.
  prefs: []
  type: TYPE_NORMAL
- en: Is 3 a feasible solution? That is, can we achieve a minimum jump distance of
    at least 3 by removing two rocks? Let’s see.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rock at Location 0 stays. The rock at Location 2 has to go. That’s our
    first removal, and it leaves us with this: 0, 4, 5, 8, and 12.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rock at Location 4 can stay: it’s more than a distance of 3 from Location
    0\. The rock at Location 5, though, has to go, because it’s too close to the rock
    at Location 4\. That’s our second removal, giving us this: 0, 4, 8, and 12.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rock at Location 8 is fine: it’s far enough away from the rocks at Locations
    4 and 12\. We’re done: it took us only two removals to achieve a minimum jump
    distance of at least 3\. So, 3 is feasible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We seem to be homing in on a greedy algorithm for checking feasibility. The
    rule is this: consider each rock in order, and remove it if it’s too close to
    the previously kept rock. Also check the rightmost rock that we kept, and remove
    it if it’s too close to the end of the river. Then, count the number of rocks
    that we removed; that count tells us whether the proposed minimum jump distance
    is feasible given the number of rocks we’re allowed to remove. (To be clear, this
    is a proposed greedy algorithm for checking feasibility of a specified jump distance,
    not for finding the optimal solution in one shot.)'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this algorithm is in [Listing 7-4](ch07.xhtml#ch07ex04).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4: Testing the feasibility of the jump distance*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function has five parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: distance   The minimum jump distance whose feasibility we’re testing
  prefs: []
  type: TYPE_NORMAL
- en: rocks   An array giving the location of each rock, not including the rocks at
    the beginning and end of the river
  prefs: []
  type: TYPE_NORMAL
- en: num_rocks   The number of rocks in the `rocks` array
  prefs: []
  type: TYPE_NORMAL
- en: num_remove   The number of rocks that we’re allowed to remove
  prefs: []
  type: TYPE_NORMAL
- en: length   The length of the river
  prefs: []
  type: TYPE_NORMAL
- en: The function returns `1` (true) if `distance` is a feasible solution and returns
    `0` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The variable `prev_rock_location` tracks the location of the most recent rock
    that we’ve kept. Inside the `for` loop, `cur_rock_location` holds the location
    of the rock that we’re currently considering. We then have our crucial test to
    determine whether to keep or remove the current rock ➊. If the current rock is
    too close to the previous rock, then we remove the current rock and increase the
    number of removals by one. Otherwise, we keep the current rock and update `prev_rock_location`
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: When the loop terminates, we’ve counted the number of rocks that we must remove.
    Well . . . almost. We still need to check whether the rightmost rock that we’ve
    kept is too close to the end of the river ➋. If it is, then we remove that rock.
    (Don’t worry about the possibility of removing the rock at Location 0\. If we
    really have removed all the rocks, then `prev_rock_location` will be 0\. However,
    `length - 0 < distance` cannot be true; if it were, then we would have returned
    in the `if` statement at the start of the function.)
  prefs: []
  type: TYPE_NORMAL
- en: Now we have no rocks within the minimum jump distance of each other, and we
    have not removed rocks unnecessarily. How could we possibly do better than that?
    The greedy algorithm charms . . . but here we go again. The last time this occurred,
    in “A Greedy Idea” on [page 244](ch07.xhtml#sec105), the greedy algorithm turned
    out to be incorrect. Don’t be convinced by a couple of examples where things happen
    to work out. Don’t let me sweet-talk you into believing that everything is okay.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, I’d like to give a fairly precise argument for why this greedy
    algorithm is correct. Specifically, I’ll show that it removes the minimum number
    of rocks required to achieve a minimum jump distance of at least *d*. I’ll assume
    that *d* is at most the length of the river; otherwise, the greedy algorithm immediately
    and correctly determines that a minimum jump distance of *d* is infeasible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each rock from left to right, our greedy algorithm decides whether to keep
    the rock or remove it. Our goal will be to show that it matches, step for step,
    what an optimal solution does. When the greedy algorithm decides to keep a rock,
    we’ll show that an optimal solution keeps that rock, too. When the greedy algorithm
    decides to remove a rock, we’ll show that an optimal solution removes that rock,
    too. If the greedy algorithm does exactly what an optimal solution does, then
    what we get from it must be correct. In this example, “optimal” will be used to
    refer to an optimal solution. For each rock, we have four possibilities: greedy
    and optimal both remove the rock, greedy and optimal both keep the rock, greedy
    removes it but optimal keeps it, and greedy keeps it but optimal removes it. We
    have to show that the third and fourth cases cannot actually occur.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed to the four cases, consider again removing two rocks from
    these rock locations: 0, 2, 4, 5, 8, and 12\. When asked whether it’s possible
    to achieve a minimum jump distance of at least 3, we have seen that greedy will
    remove the rocks at Locations 2 and 5, leaving us with 0, 4, 8, and 12\. So we
    might expect that the optimal solution is also to remove the same two rocks. Although
    that is optimal, another optimal solution is to remove the rocks at Locations
    2 and 4, resulting in these rocks: 0, 5, 8, and 12\. That’s another way to get
    a minimum distance of at least 3 by removing two rocks, and it’s as good as what
    the greedy algorithm produces. Rather than match *the* optimal solution, we’ll
    be just as happy matching *an* optimal solution. We don’t care which one greedy
    matches: all optimal solutions are equally optimal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have some optimal solution *S* that we want greedy to match. Greedy starts
    running, and for some time there are no discrepancies: it does whatever *S* does.
    Greedy at least does the right thing for the rock at Location 0: that one has
    to stay, no matter what.'
  prefs: []
  type: TYPE_NORMAL
- en: Greedy is thus looking at the rocks from left to right, doing the right stuff,
    keeping rocks and removing rocks just like optimal solution *S* . . . and then,
    boom, greedy and *S* disagree on what to do with some rock. We think about the
    *first* rock on which greedy and *S* disagree.
  prefs: []
  type: TYPE_NORMAL
- en: '**Greedy removes it, but optimal keeps it.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The greedy algorithm only removes a rock when it’s too close to another rock.
    If greedy removes a rock because it’s less than *d* from the rock to the left,
    then *S* must have removed the rock, too. Because this is the first disagreement,
    *S* includes exactly the same rocks to the left as greedy. So if *S* did not remove
    the rock, then it would have two rocks within a distance of less than *d*. However,
    that can’t happen: *S* is an optimal (and necessarily feasible) solution where
    all distances between rocks are at least *d*. We can conclude that *S* really
    does remove the rock, agreeing with greedy. Similar reasoning shows that, if greedy
    removes a rock because it’s too close to the end of the river, then *S* must remove
    it, too.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Greedy keeps it, but optimal removes it.**'
  prefs: []
  type: TYPE_NORMAL
- en: We’re not going to be able to make greedy and *S* match here, but that’s okay,
    because we’ll be able to form a new optimal solution *U* that keeps this rock.
    Let *r* be the current rock; the one that greedy keeps and *S* removes. Think
    about a new set of rocks *T* that has exactly the same rocks as *S* plus rock
    *r*. Therefore, *T* removes one fewer rock than *S*. Because of this, *T* can’t
    be a feasible solution. If it were, then it would be better (by one rock) than
    *S*, contradicting the fact that *S* is an optimal solution. Since the only difference
    between *S* and *T* is that *T* has rock *r*, it must be *r* that causes *T* to
    be infeasible. Therefore, in *T*, *r* must be closer than *d* to rock *r*[2] to
    its right. We know that *r*[2] can’t be the rock at the end of the river, because
    then greedy wouldn’t have kept *r* (as *r* would be too close to the end of the
    river). So *r*[2] is some rock that is allowed to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, think about another new set of rocks *U* that has exactly the same rocks
    as *T* except that it doesn’t have *r*[2]. We can say that *U* has the same number
    of rocks as *S*: we added one rock *r* to *S* to get *T*, and we removed one rock
    *r*[2] from *T* to get *U*. Also, *U* has no rocks that are less than a distance
    of *d* apart, because it doesn’t include the offending rock *r*[2]. That is, *U*
    is an optimal solution, just like *S*. Crucially, *U* contains rock *r*! So greedy
    agrees with optimal solution *U* to include *r*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give our feasibility tester a whirl before we continue. Here’s how to
    call it on the example that we used throughout this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The code above asks whether it’s possible to achieve a minimum jump distance
    of at least 6 by removing two rocks. The answer is “no,” so you should see `0`
    (false) as the output. Change the first argument from `6` to `3`, and now you’re
    asking whether a minimum jump distance of at least 3 is feasible. Run the program
    again, and you should see `1` (true).
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent: now we have a way to check feasibility. It’s time to bring out binary
    search to give us optimality.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Searching for a Solution*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use binary search, let’s adapt the code from [Listing 7-3](ch07.xhtml#ch07ex03).
    In Feeding Ants, we had to achieve four digits of accuracy after the decimal point.
    Here, however, we’re looking to optimize the minimum jump distance, and that’s
    guaranteed to be an integer value because all rocks are at integer locations.
    So we’ll stop when `high` and `low` are within one, rather than within the four
    decimal digits. [Listing 7-5](ch07.xhtml#ch07ex05) gives the new code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-5: Searching for the optimal solution (bugged!)*'
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration, we calculate the midpoint `mid` of the range, and we use
    our helper function to test its feasibility ➊.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `mid` is feasible, then everything less than `mid` is also feasible, so
    we update `low` to cut off the low half of the range ➋. Notice the contrast to
    [Listing 7-3](ch07.xhtml#ch07ex03): there, a feasible `mid` means that everything
    greater than `mid` is feasible, so we cut off the high half of the range instead.'
  prefs: []
  type: TYPE_NORMAL
- en: If `mid` is infeasible, then everything greater than `mid` is also infeasible,
    so we update `high` to cut off the high half of the range ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this binary search is not correct. To see why, run it on this
    test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You should get an output of `5`, but the optimal solution is in fact `4`.
  prefs: []
  type: TYPE_NORMAL
- en: Ahh, I know what to do. Let’s change the `printf` call at the bottom to output
    `low` instead of `high`. When the loop terminates, `low` will be one less than
    `high`, so this change will result in an output of `4` instead of `5`. The new
    code is given in [Listing 7-6](ch07.xhtml#ch07ex06).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-6: Searching for the optimal solution (still bugged!)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That fixes the problematic test case, but now we get this test case wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a perfectly valid test case, if a little strange: the length of the
    river is 12, and there are no rocks. The maximum achievable minimum jump distance
    is 12, but our binary search returns `11` on this example. Again, we are off by
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: Binary search is legendarily difficult to implement correctly. Should that `>`
    be a `>=`? Should that be a `mid` or a `mid + 1`? Do we want `low + high` or `low
    + high + 1`? If you keep on with binary search problems, you’ll grapple with all
    of this eventually. I don’t know any other algorithm with the bug-density potential
    of binary search.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s be a little more careful for our next attempt. Suppose we knew at all
    times that `low` and everything smaller than `low` are feasible and that `high`
    and everything larger than `high` are infeasible. Such a claim is called an *invariant*,
    which simply means that it’s always true as the code runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the loop terminates, `low` will be one less than `high`. If we’ve managed
    to maintain our invariant, then we know that `low` is feasible. We also know that
    nothing greater than `low` can be feasible: `high` is next, and the invariant
    tells us that `high` is infeasible. So `low` will be the maximum feasible value,
    and we’ll need to output `low`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, in all of this we assume that we can make this invariant true at the
    beginning of the code and keep it true at all times thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the code above the loop. This code does *not* necessarily
    make the invariant true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Is `low` feasible? Certainly! A minimum jump distance of at least 0 is always
    achievable, because every jump has a nonzero distance. Is `high` infeasible? Well,
    it could be, but what if we can jump the whole river after we remove the allowed
    number of rocks? Then `length` is feasible, and our invariant is broken. Here’s
    a better initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `high` certainly isn’t feasible: we can’t achieve a minimum jump distance
    of `length + 1` when the river is only of length `length`.'
  prefs: []
  type: TYPE_NORMAL
- en: We next have to figure out what to do for the two possibilities in the loop.
    If `mid` is feasible, then we can set `low = mid`. The invariant is okay, because
    `low` and everything to its left are feasible, and, if `mid` is not feasible,
    then we can set `high = mid`. The invariant is again okay, because `high` and
    everything to its right are infeasible. Thus, in both cases, we maintain the invariant.
  prefs: []
  type: TYPE_NORMAL
- en: We now see that nothing in the code invalidates the invariant, and so we’re
    safe to output `low` when the loop terminates. The correct code is given in [Listing
    7-7](ch07.xhtml#ch07ex07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-7: Searching for the optimal solution*'
  prefs: []
  type: TYPE_NORMAL
- en: For a river of length *L*, we’re calling `can_make_min_distance` a total of
    log *L* times. If we have *n* rocks, then `can_make_min_distance` ([Listing 7-4](ch07.xhtml#ch07ex04))
    takes *O*(*n*) time. Therefore, our solution to this problem is an *O*(*n* log
    *L*) algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reading the Input*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re nearly there. All that’s left is to read the input and call `solve`. The
    code is provided in [Listing 7-8](ch07.xhtml#ch07ex08).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-8: The* main *function for reading the input*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been analyzing this problem by thinking about locations of rocks from
    left to right, that is, from smallest location to largest location. However, the
    rocks could come from the input in any order. Nothing in the problem description
    guarantees that they’ll be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: It’s been a while, but we did use `qsort` to sort nodes in [Chapter 2](ch02.xhtml)
    when solving the Descendant Distance problem. Sorting rocks is a little easier
    than sorting those nodes. Our comparison function `compare` takes pointers to
    two integers, and it returns the result of subtracting the second from the first.
    This leads to a negative integer if the first integer is smaller than the second,
    `0` if the two integers are equal, and a positive integer if the first integer
    is larger than the second. We use `qsort` with this comparison function to sort
    the rocks ➊. We then call `solve` with the array of sorted rocks.
  prefs: []
  type: TYPE_NORMAL
- en: If you submit this solution to the judge, then you should see that all test
    cases pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 3: Living Quality'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far in this chapter, we’ve seen two approaches to check feasibility: a recursive
    traversal of a tree and a greedy algorithm. Now, we’ll see an example where we’ll
    use ideas from dynamic programming ([Chapter 3](ch03.xhtml)) to efficiently check
    feasibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first problem in the book where we don’t read from standard input
    or write to standard output. We’ll write a function with a name specified by the
    judge. In lieu of standard input, we’ll use an array passed by the judge. In lieu
    of standard output, we’ll return the correct value from our function. This is
    rather nice: we won’t have to bother with `scanf` and `printf` at all!'
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, this will also be our first problem from a world championship
    programming competition (IOI 2010). You’ve got this!
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ioi10p3`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A city consists of a rectangular grid of blocks. Each block is identified by
    its row and column coordinates. There are *r* rows numbered 0 to *r* – 1 from
    top to bottom and *c* columns numbered 0 to *c* – 1 from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Each block has been given a distinct *quality rank* between 1 and *rc*. For
    example, if we have seven rows and seven columns, then the ranks of each block
    will be some permutation of the numbers from 1 to 49\. See [Table 7-1](ch07.xhtml#ch07tab1)
    for an example city.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** A Sample City'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 48 | 16 | 15 | 45 | 40 | 28 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 20 | 11 | 36 | 19 | 24 | 6 | 33 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 22 | 39 | 30 | 7 | 9 | 1 | 18 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | 14 | 35 | 2 | 13 | 31 | 12 | 46 |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | 32 | 37 | 21 | 3 | 41 | 23 | 29 |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | 42 | 49 | 38 | 10 | 17 | 47 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| **6** | 43 | 4 | 34 | 25 | 26 | 27 | 44 |'
  prefs: []
  type: TYPE_TB
- en: 'The *median quality rank* of a rectangle is the quality rank such that half
    of the quality ranks in the rectangle are smaller and half are larger. For example,
    consider the five-row-by-three-column (5×3) rectangle in the top left of [Table
    7-1](ch07.xhtml#ch07tab1). It consists of 15 quality ranks: 48, 16, 15, 20, 11,
    36, 22, 39, 30, 14, 35, 2, 32, 37, and 21\. The median quality rank is 22, because
    seven numbers are less than 22 and the other seven are greater.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be provided integers *h* and *w* that specify the height (number of rows)
    and width (number of columns) of candidate rectangles. Our task is to identify
    the minimum median quality rank of any rectangle with *h* rows and *w* columns.
    (In this problem, low-quality ranks correspond to high qualities; finding the
    minimum median quality rank therefore corresponds to finding a high-quality living
    area of the city.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use (*x*, *y*) to refer to row *x*, column *y*. Suppose *h* is 5 and *w*
    is 3\. Then, for the city in [Table 7-1](ch07.xhtml#ch07tab1), we would identify
    13 as the minimum median quality rank. The rectangle whose median quality rank
    is 13 is the one whose top-left coordinate is (1, 3) and whose bottom-right coordinate
    is (5, 5).
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s nothing to read from standard input. Everything we need will come from
    the judge through function parameters. Here’s the signature for the function that
    we’ll write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `r` and `c` are the numbers of rows and columns in the city, respectively.
    Similarly, `h` and `w` are the numbers of rows and columns in the candidate rectangles,
    respectively; `h` will be at most `r` and `w` will be at most `c`. It’s also guaranteed
    that `h` and `w` will be odd numbers. (Why is that? Since multiplying two odd
    numbers results in an odd number, *hw*, the number of blocks in a candidate rectangle,
    will be an odd number. The median is precisely defined in this case: the quality
    rank such that half of the remaining quality ranks are smaller and the other half
    are larger. What if we had an even number of quality ranks, such as the four ranks
    2, 6, 4, and 5? What would the median be? We’d have to choose between 4 and 5\.
    The problem author has spared us this choice.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final parameter `q` gives the quality rank of the blocks. For example,
    `q[2][3]` gives the quality of the block at row 2, column 3\. Notice how the dimensions
    on `q` tell us the maximum number of rows and columns in the city: 3,001, in each
    case.'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We won’t produce anything on standard output. Instead, from the `rectangle`
    function just described, we’ll return the minimum median quality rank.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 4.5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Sorting Every Rectangle*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s hard to make much progress toward an efficient solution that doesn’t use
    binary search, but we’ll try here, anyway. It’ll give us practice looping through
    all of the candidate rectangles. We’ll get to binary search in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need a couple of constants and a type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Much as we did in [Chapter 5](ch05.xhtml), we’ll use `board` whenever we need
    a two-dimensional array of the correct size.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are given the top-left and bottom-right coordinates of a rectangle
    and asked to determine the median quality rank of its blocks. How can you do it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting can help. Sort the quality ranks from smallest to largest, and then
    pick out the element at the middle index. For example, say we have these 15 quality
    ranks again: 48, 16, 15, 20, 11, 36, 22, 39, 30, 14, 35, 2, 32, 37, and 21\. If
    we sort them, we get 2, 11, 14, 15, 16, 20, 21, 22, 30, 32, 35, 36, 37, 39, and
    48\. There are 15 quality ranks, so all we do is take the eighth one, 22, and
    that’s our median.'
  prefs: []
  type: TYPE_NORMAL
- en: There are slightly faster algorithms for finding the median directly, without
    taking the scenic route through sorting. Sorting gives us an algorithm that takes
    *O*(*n* log *n*) time to find the median; there’s a sophisticated *O*(*n*) algorithm
    for finding the median that I encourage you to look up if you are interested.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go there, though. What we do in this subsection is going to be so slow
    that no improved algorithm for finding the median is going to be of benefit.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-9](ch07.xhtml#ch07ex09) gives the code for finding the median of
    a given rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-9: Finding the median of a given rectangle*'
  prefs: []
  type: TYPE_NORMAL
- en: The first four parameters of `median` delimit the rectangle by specifying the
    top-left row and column and the bottom-right row and column. The final parameter,
    `q`, holds the quality ranks. We use the one-dimensional array `cur_rectangle`
    to accumulate the quality ranks for the rectangle. The nested `for` loops go through
    each block in the rectangle and add the block’s quality rank to `cur_rectangle`.
    After corralling the quality ranks, we’re all set to feed them to `qsort` ➊. Then
    we know exactly where the median is—it’s in the middle of the array—so we just
    return it.
  prefs: []
  type: TYPE_NORMAL
- en: With that function in hand, we can now proceed to loop through each candidate
    rectangle, keeping track of the one whose median quality rank is the smallest.
    Check out [Listing 7-10](ch07.xhtml#ch07ex010) for the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-10: Finding the smallest median of all candidate rectangles*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable `best` tracks the best (smallest) median that we’ve found so far.
    We start it off with a big value, bigger than the median of any candidate rectangle
    ➊. There’s no way for a rectangle to have a median of `r * c + 1`: that would
    mean that half of its quality ranks were larger than `r * c`, but by the problem
    description, *no* quality ranks can be larger than `r * c`. The nested `for` loops
    consider each possible top-left coordinate for a rectangle. That gives us the
    top row and left column, but we also need the bottom row and right column in order
    to call `median`. To calculate the bottom row, we take the top row, add `h` (the
    number of rows in the candidate rectangles), and then subtract 1 ➋. It’s really
    easy to make an off-by-one error here, but that `- 1` is required. If the top
    row is 4 and `h` is `2`, then we want the bottom row to be 4 + 2 – 1 = 5; if we
    made the bottom row be 4 + 2 = 6, then we’d have a rectangle with three rows instead
    of the desired two. We use a similar calculation to find the right column ➌. With
    the four coordinates available, we call `median` to calculate the median of the
    rectangle ➍. The remainder of the code updates `best` if we’ve found a better
    median.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re done with this solution. There’s no `main` function, because the judge
    calls `rectangle` directly, but the absence of `main` means that we can’t test
    our code on our own computer. For testing purposes, you can introduce a `main`
    function, but don’t keep that in there when you submit to the judge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example `main` function on the city in [Table 7-1](ch07.xhtml#ch07tab1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You should see an output of `13` when you run the program.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to submit our solution, minus the `main` function, to the judge. It’ll
    pass a few test cases but time-out on the rest.
  prefs: []
  type: TYPE_NORMAL
- en: To get a feel for why our code is so slow, let’s focus on the case where *r*
    and *c* are both the same number *m*. To exhibit the worst case, take *h* and
    *w* to both be *m*/2\. (We don’t want the rectangles to be too big, because then
    there won’t be many rectangles; and we don’t want them to be too small, because
    then each is easy to process.) The slowest part of our `median` function is the
    call to `qsort`. It’s given an array with *m*/2 × *m*/2 = *m*²/4 values. On an
    array of *n* values, `qsort` takes *n* log *n* steps. Replacing *n* by *m*²/4
    gives (*m*²/4) log(*m*²/4) = *O*(*m*² log *m*). So we’re already slower than quadratic—and
    all we’ve done is calculate the median for one rectangle! The `rectangle` function
    calls `median` a total of *m*²/4 times, so our total runtime is *O*(*m*⁴ log *m*).
    That power of 4 relegates this solution to only very small problem instances.
  prefs: []
  type: TYPE_NORMAL
- en: There are two bottlenecks here. The first is sorting each rectangle. The second
    is doing a lot of work from scratch for each rectangle. Using a binary search
    disposes the former, and a neat dynamic-programming trick disposes the latter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Using Binary Search*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Why should we be optimistic that binary search will lead to a speedup here?
    First, in the previous subsection, we saw that finding optimality head-on is a
    costly endeavor; our approach that piggybacked on sorting was slightly slower
    than an *m*⁴ algorithm. Second, we have another example of a problem where all
    infeasible solutions come first and are followed by all feasible solutions. Suppose
    I tell you that there is no rectangle with median quality rank of at most five.
    Then there’d be no point looking for rectangles with median quality five, or four,
    or three, or anything else less than five. Conversely, suppose I tell you that
    there is a rectangle with median quality rank of at most five. Now, there’d be
    no point looking for rectangles with median quality of six, or seven, or anything
    greater than five. This is tailor-made binary search territory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Feeding Ants problem, small values were infeasible and large values
    were feasible. In the River Jump problem, small values were feasible and large
    values were infeasible. Here, we’re back in the Feeding Ants case: small values
    are infeasible and large values are feasible. We’ll therefore need a change to
    the River Jump invariant, flipping the locations of the feasible and infeasible
    portions of the solution space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the invariant that we’ll use: `low` and everything smaller than `low`
    are infeasible; `high` and everything larger than `high` are feasible. This tells
    us that we should return `high` when we’re done, as it will be the smallest feasible
    value. The code, in [Listing 7-11](ch07.xhtml#ch07ex011), is otherwise very similar
    to [Listing 7-7](ch07.xhtml#ch07ex07).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-11: Searching for the optimal solution*'
  prefs: []
  type: TYPE_NORMAL
- en: To finish the job, we need an implementation of `can_make_quality` to test feasibility.
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing Feasibility*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s the signature for the feasibility-checking function that we’ll write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In “Sorting Every Rectangle” on [page 256](ch07.xhtml#sec110), we were saddled
    by having to calculate the median quality rank of each rectangle. Now this is
    no longer the case: we’re content to determine whether the median value of some
    rectangle is at most some cutoff `quality` rank value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an easier problem for which a sorting step is unnecessary. Here’s the
    key observation: the specific values themselves no longer matter; all that matters
    is the relationship between each value and `quality`. To exploit this observation,
    we’ll replace all values that are less than or equal to `quality` by –1 and all
    values greater than `quality` by 1\. We then add up these –1 and 1 values for
    a given rectangle. If we have at least as many –1 values as 1 values (that is,
    there are at least as many small values as large values, relative to `quality`),
    then the sum will be zero or negative, and we can conclude that this rectangle
    has a median quality rank of `quality` or less.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s work an example. Here are the 15 quality ranks again for the 5×3 rectangle
    in the top left of [Table 7-1](ch07.xhtml#ch07tab1): 48, 16, 15, 20, 11, 36, 22,
    39, 30, 14, 35, 2, 32, 37, and 21\. Does this rectangle have a median quality
    rank of 16 or less? Take each value and replace it by –1 if it’s less than or
    equal to 16 and 1 if it’s greater than 16\. Here are the new values: 1, –1, –1,
    1, –1, 1, 1, 1, 1, –1, 1, –1, 1, 1, and 1\. If we add these up, we get a value
    of 5\. This means that there are five more large values than small values, and
    we must conclude that a median of 16 or smaller is not possible for this rectangle.
    If we wanted to know whether a median of 30 was feasible, we’d get this after
    replacing the numbers by –1s and 1s: 1, –1, –1, –1, –1, 1, –1, 1, –1, –1, 1, –1,
    1, 1, and –1\. Adding these up, we get a total of –3.'
  prefs: []
  type: TYPE_NORMAL
- en: Aha! So 30 is a feasible median. Crucially, we’re making this feasible–infeasible
    decision with no sorting at all.
  prefs: []
  type: TYPE_NORMAL
- en: We need to loop through each rectangle, testing whether it has a median quality
    rank of `quality` or less. [Listing 7-12](ch07.xhtml#ch07ex012) does exactly this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-12: Testing the feasibility of* quality'
  prefs: []
  type: TYPE_NORMAL
- en: We can’t just obliterate the `q` array with –1s and 1s, because then we couldn’t
    use the original quality ranks to later test other values of `quality`. Therefore,
    we use a new array to hold the –1s and 1s ➊. Notice how this array is filled in
    based on whether each value is less than or equal to (–1) or greater than (1)
    the cutoff `quality` parameter that we’re checking ➋.
  prefs: []
  type: TYPE_NORMAL
- en: We then go through each rectangle, just as we did in [Listing 7-10](ch07.xhtml#ch07ex010).
    We add up all of its –1 and 1 values ➌ and return `1` (true) if it has a median
    quality rank that’s small enough.
  prefs: []
  type: TYPE_NORMAL
- en: All right! We have sidestepped the sorting—crafty, eh? What we did in this subsection
    is crucial to a fast solution to solving our problem, but we’re not there yet,
    because if you count the number of nested loops, you’ll see that there are four
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of “Sorting Every Rectangle” we observed that our first solution—with
    no binary search anywhere!—was a very slow *O*(*m*⁴ log *m*), where *m* is the
    number of rows or columns in the city. Here, our feasibility check is already
    *m*⁴; multiply by the log factor for the binary search, and it’s not clear that
    we’ve made any progress.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, but we have! It’s just locked up behind too many nested loops, involving
    too much recomputation. Dynamic programming is now going to take us the rest of
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: '*A Quicker Way to Test Feasibility*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose we start with [Table 7-1](ch07.xhtml#ch07tab1) and are interested in
    whether any 5×3 rectangle has a median quality rank of 16 or less. Changing all
    values less than or equal to 16 to –1 and all values greater than 16 to 1 results
    in [Table 7-2](ch07.xhtml#ch07tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-2:** A City with Quality Ranks Replaced'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1 | –1 | –1 | 1 | 1 | 1 | –1 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 1 | –1 | 1 | 1 | 1 | –1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 1 | 1 | 1 | –1 | –1 | –1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | –1 | 1 | –1 | –1 | 1 | –1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | 1 | 1 | 1 | –1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | 1 | 1 | 1 | –1 | 1 | 1 | –1 |'
  prefs: []
  type: TYPE_TB
- en: '| **6** | 1 | –1 | 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: We might begin by summing the elements of the 5×3 rectangle whose top-left coordinate
    is (0, 0). As we saw in the previous section, the sum of that rectangle is 5\.
    Next, maybe we want to sum the elements of the 5×3 rectangle whose top-left coordinate
    is (0, 1). Adding up all 15 numbers here is what we would have done in the previous
    subsection. However, doing so fails to lean on the work we did to compute the
    sum of the first rectangle. Indeed, this second rectangle has 10 values in common
    with the first rectangle. We should be able to prevent this kind of duplication
    of effort for this and all other rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: Dodging the repeated work here amounts to efficiently solving what’s known as
    a two-dimensional *range sum query*. The one-dimensional case uses similar ideas,
    but in a simpler context, so we’ll briefly study that before returning to finish
    the Living Quality problem. (About half of [Chapter 8](ch08.xhtml) will be devoted
    to range queries, so stay tuned!)
  prefs: []
  type: TYPE_NORMAL
- en: One-Dimensional Range Sum Queries
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here’s a one-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg262-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If asked to find the sum of the array from index 2 to index 5, we could directly
    sum the values in that range: 15 + 9 + 12 + 4 = 40\. That’s not very fast, and
    it would be particularly unfortunate if we were asked for the sum of the entire
    array. However, if we had to answer just a few such queries, we could get away
    with answering each by summing the appropriate values.'
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine that we’re getting peppered by hundreds or thousands of these queries.
    It makes sense to have done a little up-front work, once, if it means that we
    can then answer the queries more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the “index 2 to 5” query. What if we could look up the sum from index
    0 to 5? That sum is 48\. That’s not 40, the answer that we want. Far from useless,
    though, is that 48 is quite close to what we need. It’s only wrong because it
    includes the values at index 0 and index 1, stuff that we now need to exclude.
    We could do that if we could look up the sum from index 0 to 1\. That sum is 8\.
    If we subtract this 8 from 48, we get 40.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s needed, then, is a new array, one where index *i* holds the sum of all
    values from index 0 to index *i*. This new array is included in the Prefix Sum
    row in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg263-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'No matter the query, we can now quickly answer it using the prefix sum array:
    to calculate the sum of the range from index *a* to *b*, take the value at index
    *b* and subtract the value at index *a* – 1\. For 2 to 5, we get 48 – 8 = 40,
    and for 1 to 6, we get 59 – 6 = 53\. These are constant-time answers, for eternity,
    and all we had to do was one preprocessing pass over the array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two-Dimensional Range Sum: Queries'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s return to the two-dimensional world of our quality ranks. Summing the
    elements of each rectangle is too slow, so we’ll extend what we did in one dimension
    to two dimensions. Specifically, we’ll produce a new array, where index (*i*,
    *j*) is the sum of the elements of the rectangle whose top-left coordinate is
    (0, 0) and whose bottom-right coordinate is (*i*, *j*).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look again at [Table 7-2](ch07.xhtml#ch07tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1 | –1 | –1 | 1 | 1 | 1 | –1 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 1 | –1 | 1 | 1 | 1 | –1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 1 | 1 | 1 | –1 | –1 | –1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | –1 | 1 | –1 | –1 | 1 | –1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | 1 | 1 | 1 | –1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | 1 | 1 | 1 | –1 | 1 | 1 | –1 |'
  prefs: []
  type: TYPE_TB
- en: '| **6** | 1 | –1 | 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: The corresponding prefix array is in [Table 7-3](ch07.xhtml#ch07tab3). (It may
    seem a little strange to call it a “prefix array” here, but let’s stick with it
    to match the terminology from the one-dimensional case.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-3:** An Array for Two-Dimensional Range Sum Queries'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1 | 0 | –1 | 0 | 1 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 2 | 0 | 0 | 2 | 4 | 4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 3 | 2 | 3 | 4 | 5 | 4 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | 2 | 2 | 2 | 2 | 4 | 2 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | 3 | 4 | 5 | 4 | 7 | 6 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | 4 | 6 | 8 | 6 | 10 | 10 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| **6** | 5 | 6 | 9 | 8 | 13 | 14 | 17 |'
  prefs: []
  type: TYPE_TB
- en: Let’s make sure we know what this array tells us before worrying about how to
    quickly build it. The value in row 4, column 2 gives the sum of the values of
    the rectangle whose top-left coordinate is (0, 0) and whose bottom-right coordinate
    is (4, 2). We have seen in “Testing Feasibility” that this sum is 5 and, indeed,
    that’s what this array has there.
  prefs: []
  type: TYPE_NORMAL
- en: How could we compute that (4, 2) value of 5 using other values that we’ve already
    computed? We need to start with its value in [Table 7-2](ch07.xhtml#ch07tab2),
    add what’s in range above it, and add everything in its row to the left. We can
    do this with judicious use of the array in [Table 7-3](ch07.xhtml#ch07tab3), as
    shown in [Table 7-4](ch07.xhtml#ch07tab4).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-4:** Quickly Calculating a Given Sum'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | • ■ | • ■ | • |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | • ■ | • ■ | • |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | • ■ | • ■ | • |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | • ■ | • ■ | • |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | ■ | ■ | 1 |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **5** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **6** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: We need to start with the 1, capture the cells that include a circle (those
    above), capture the cells that include a square (those to the left), and add them
    all up. We can capture the cells that include a circle by looking up the element
    at row 3, column 2\. We can also capture the cells that include a square by looking
    up the element at row 4, column 1\. However, adding those together double-counts
    the cells that include both a circle and a square (those both above and to the
    left), but this is not an issue because the element at row 3, column 1 captures
    exactly those circle-and-square cells, whose subtraction undoes the double-counting.
    In all, we have 1 + 2 + 4 – 2 = 5, as desired. As long as we work from top to
    bottom and left to right, we can build this array with only two additions and
    one subtraction per cell.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to build an array like that in [Table 7-3](ch07.xhtml#ch07tab3).
    So what?
  prefs: []
  type: TYPE_NORMAL
- en: 'The “so what” is that it enables us to quickly calculate the sum of any rectangle.
    Suppose we wanted the sum of the rectangle whose top-left coordinate is (1, 3)
    and whose bottom-right coordinate is (5, 5). We can’t just use the value 10 in
    row 5, column 5 of [Table 7-3](ch07.xhtml#ch07tab3). That captures everything
    in the desired rectangle but also includes more than we want: it includes elements
    that are outside (above or to the left) of our desired rectangle. However, just
    as in the one-dimensional case, we’ll be able to adjust that value to include
    only the elements in the rectangle. See [Table 7-5](ch07.xhtml#ch07tab5) for how
    to do this. In this table, the cells of the desired rectangle are marked by stars.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-5:** Quickly Calculating the Sum of a Rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | • ■ | • ■ | • ■ | • | • | • |  |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  prefs: []
  type: TYPE_TB
- en: '| **6** |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: This time, we need to subtract the cells that include a circle and the cells
    that include a square. We can get the cells with a circle from row 0, column 5
    and the cells with a square from row 5, column 2\. But subtracting both will double-subtract
    the cells that have both a circle and a square, so we need to add back the cell
    in row 0, column 2\. That is, we have 10 – 2 – 8 + (–1) = –1, which is the sum
    of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a general expression for this calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will be used in the code presented next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two-Dimensional Range Sum: Code'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re ready to put it all together—the –1 and 1 idea, building the prefix array,
    and using the prefix array for fast rectangle sums—in [Listing 7-13](ch07.xhtml#ch07ex013).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-13: Testing the feasibility of* quality *quickly*'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 is to build the `zero_one` array ➊, exactly as we did in [Listing 7-12](ch07.xhtml#ch07ex012).
    Step 2 is to build the prefix sum array `sum` ➋. We’ll use indices that start
    at 1, rather than 0, so that we don’t have to worry about staying within bounds
    when we later process cells on the edges of the array. Finally, Step 3 is to use
    the prefix sum array to quickly calculate the sum of each rectangle ➌. Notice
    how each rectangle can be summed in constant time here! We paid for the preprocessing
    work of Step 2, but that work pays for itself every time we sum a rectangle without
    summing its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to [Listing 7-12](ch07.xhtml#ch07ex012), we’ve removed two levels of
    nesting from the `for` loops. Therefore, this is an *O*(*m*² log *m*) algorithm,
    which is fast enough to pass all of the test cases. Go for it! Then take a well-deserved
    break, because we’ve got one more big problem to solve before we’re through with
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 4: Cave Doors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another IOI championship problem? Bring it on! This one is unique to the chapter
    because it uses binary search not to find an optimal solution, but to quickly
    zone-in on a desired element. As we did in the Living Quality problem, we won’t
    read anything from standard input, and we won’t write anything to standard output.
    Rather, we’ll learn about the problem instance and submit our answer through calls
    to functions provided by the judge. As you read the problem description, try to
    anticipate why binary search is still appropriate here.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ioi13p4`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You are at the entrance to a long, narrow cave, and you want to get through
    the cave to the other side. There are *n* doors that you must pass through: the
    first door is Door 0, the second is Door 1, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Each door can be open or closed. You can walk through any open door, but you
    can’t get past or see through a closed door. So if Door 0 and Door 1 are open
    but Door 2 is closed, then you progress to Door 2 but no further.
  prefs: []
  type: TYPE_NORMAL
- en: At the entrance to the cave is a panel of *n* switches. Like the doors, the
    switches are numbered starting from 0\. Each switch can be in the up (0) position
    or the down (1) position. Each switch is associated with a different door, and
    it determines whether that door is open or closed. If a switch is set to the correct
    position, then its associated door is open; otherwise, its associated door is
    closed. You don’t know which switch is associated with which door, and you don’t
    know whether the switch should be up or down for the door to be open. For example,
    maybe Switch 0 is associated with Door 5, and the switch has to be down for Door
    5 to be open. And maybe Switch 1 is associated with Door 0, and the switch has
    to be up for Door 0 to be open.
  prefs: []
  type: TYPE_NORMAL
- en: You can set the switches to whatever positions you choose and then walk through
    the cave to determine the first door that is closed. You have the stamina to do
    this at most 70,000 times. Your goal is to determine both the correct position
    (0 or 1) and the associated door for each switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to write the function with this signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: where `n` is the number of doors and switches (between 1 and 5,000). To implement
    this function, you call two functions provided by the judge. These are described
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re not reading anything from standard input. The only way to learn about
    the problem instance is to call the function `tryCombination` provided by the
    judge. Its signature is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The parameter `switch_positions` is an array of length *n* giving the position
    (0 or 1) of each switch. That is, `switch_positions[0]` gives the position of
    Switch 0, `switch_positions[1]` gives the position of Switch 1, and so on. The
    `tryCombination` function simulates what would happen if we set the switches as
    in `switch_positions` and walked through the cave. If some door is still closed,
    it returns the number of the first closed door; otherwise, it returns `-1` to
    indicate that all doors are open.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re not writing anything to standard output. Instead, when we’re ready, we
    submit our answer by calling the function `answer` provided by the judge. Its
    signature is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one shot at this: when we call `answer`, we can’t then do anything
    else, so we had better submit the correct answer the first time. The parameter
    `switch_positions` is our proposed switch positions, in the same format as for
    `tryCombination`. The parameter `door_for_switch` is our proposed association
    between switches and doors: `door_for_switch[0]` gives the door for Switch 0,
    `door_for_switch[1]` gives the door for Switch 1, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The number of calls to `tryCombination`, rather than execution time, is the
    scarce resource here. We’re allowed to make at most 70,000 calls; if we make more,
    then our program is terminated and we do not solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solving a Subtask*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The author of this problem has split the points across five *subtasks*. The
    fifth subtask is the problem in its full generality as I’ve presented it here.
    The other subtasks impose additional constraints on the problem instances to make
    the problem easier.
  prefs: []
  type: TYPE_NORMAL
- en: I like when problem authors use subtasks, especially when I’m struggling to
    solve a problem. I can then target each subtask in turn, improving my solution
    as I go, until I solve the full problem. Moreover, if I can’t solve the full problem,
    then I still get points for the subtasks that I was able to solve.
  prefs: []
  type: TYPE_NORMAL
- en: The first subtask in the Cave Doors problem is to solve the problem when each
    switch `i` is associated with door number `i`. That is, Switch 0 is associated
    with Door 0, Switch 1 is associated with Door 1, and so on. What we need to deduce
    is the correct position (0 or 1) for each switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t worry: we won’t stop with this problem until we solve it fully. But let’s
    start by solving Subtask 1 here, so we can focus on correctly calling the `tryCombination`
    and `answer` judge functions before we tackle the other aspects of the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t have access to the code for the two judge functions, so we’re not going
    to be able to locally compile and run our program. (If you’d like to get things
    set up locally, you can google “IOI 2013 tasks” and find the test data and templates
    for the Cave Doors problem, but you won’t need to do any of that to follow the
    discussion here.) Whenever we want to test what we’re doing, we can submit our
    code to the judge. In particular, once we successfully solve Subtask 1 and submit
    our code, the judge should give us some points. The code for Subtask 1 is given
    in [Listing 7-14](ch07.xhtml#ch07ex014).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-14: Solving Subtask 1*'
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we use a `for` loop to set each switch position to `0` ➊ and associate
    Door `i` with Switch `i` ➋. We’ll update the switch positions when needed, but
    (as per the subtask constraints) we’ll have no reason to touch the door associations
    again.
  prefs: []
  type: TYPE_NORMAL
- en: The second `for` loop loops through each switch. Its job is to determine if
    the current switch should stay in Position 0 or change to Position 1\. Let’s work
    through the first iteration, when `i` is `0`. We call `tryCombination` ➌, which
    returns to us the number of the first door that is closed. If it returns `0`,
    then Switch 0 is not set correctly; if Switch 0 were set correctly, Door 0 would
    be open, and `tryCombination` would return a number other than `0`. So, if Door
    0 is closed, then we change the position of Switch 0 from `0` to `1` ➍. That opens
    Door 0, and we can move on to Door 1.
  prefs: []
  type: TYPE_NORMAL
- en: When `i` is 1, we again call `tryCombination`. We won’t get a result of `0`,
    because our code has already done the work to guarantee that Door 0 is open. If
    we get a result of `1`, it means that Door 1 is closed, and we have to change
    Switch 1 from Position 0 to Position 1.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing, we can say that, when we start a new iteration of the loop, all
    of the doors up to and including Door `i - 1` are open. If Door `i` is closed,
    then we change the position of Switch `i` from `0` to `1`; otherwise, Door `i`
    is already open, and Switch `i` is already correctly set.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’re finished with that second `for` loop, we’ve figured out the correct
    position of each switch. We communicate this to the judge through the call to
    the `answer` function ➎.
  prefs: []
  type: TYPE_NORMAL
- en: I suggest submitting this code to the judge to verify that you’re correctly
    calling `tryCombination` and `answer`. Once you’re ready, we’ll move on to solve
    the real deal.
  prefs: []
  type: TYPE_NORMAL
- en: '*Using Linear Search*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s a good thing we solved Subtask 1, beyond the fact of getting our feet wet.
    That’s because there’s a nice strategy in our solution that paves our way. That
    strategy is to figure out how to open each door and never let that door interfere
    again.
  prefs: []
  type: TYPE_NORMAL
- en: In our solution to Subtask 1, we focus first on Door 0 and get that door open.
    Once it’s open, we never mess with its switch again. With Door 0 out of the way,
    we next focus on getting Door 1 open. Once Door 1 is open, we never mess with
    its switch again. As far as we are concerned, Doors 0 and 1 are gone; the Doors
    may as well start with Door 2\. We continue in this way, knocking off one door
    after another, until all doors are open.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Subtask 1, we knew exactly which door was associated with each of the switches.
    There was no searching required to figure out this correspondence. But, to solve
    the full problem, we do need a search, because we don’t know which switch controls
    the current door. We start by getting Door 0 closed. Then we search through the
    switches. We change the position of the current switch and ask whether or not
    Door 0 opened. If not, then this was not the correct switch. If so, then we’ve
    found the switch for Door 0\. We keep Door 0 open from this point onward, and
    we repeat the process for Door 1: getting it closed and then looping through the
    switches to find the one that opens it.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the new `exploreCave` code given in [Listing 7-15](ch07.xhtml#ch07ex015).
    It’s brief, because it offloads the search to a helper function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-15: The* exploreCave *function*'
  prefs: []
  type: TYPE_NORMAL
- en: As with solving Subtask 1, each element of `switch_positions` will end up being
    a 0 or 1, indicating the position of each switch. `door_for_switch` indicates
    the door associated with each switch. We initialize each element of `door_for_switch`
    to `-1` ➊ to indicate that the door for each switch is unknown. When the door
    for Switch `i` becomes known, we’ll update `switch_positions[i]` and `door_for_switch[i]`
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pop quiz: If `door_for_switch[5]` is `8`, what does that mean? Does it mean
    that Switch 5 is associated with Door 8 or that Door 5 is associated with Switch
    8?'
  prefs: []
  type: TYPE_NORMAL
- en: It’s the former! Make sure you’re clear on this before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: For each Door `i`, we call the `set_a_switch` helper function ➋. Its task is
    to search through the switches to determine the one that is associated with Door
    `i`. It also determines whether that switch should be in Position 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: The code for `set_a_switch` is given in [Listing 7-16](ch07.xhtml#ch07ex016).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-16: Finding and setting the switch for the current door using a
    linear search*'
  prefs: []
  type: TYPE_NORMAL
- en: The `door` parameter dictates which door we want to solve next.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with a loop through the switches. We set the position of the switches
    to `0` ➊, but only for those switches that are not associated with a door yet.
    (Remember that, if a switch is already associated with a door, we don’t want to
    change that switch’s position ever again.)
  prefs: []
  type: TYPE_NORMAL
- en: With all relevant switches set to Position 0, we determine whether the current
    door is open or closed. If it’s open, then we want to close it so that we can
    later change switch positions, one at a time, to see which switch opens it. To
    close the door, we just set all switch positions to `1` ➋. This works because
    the door was open when the switch positions were all `0`; one of those switches
    controls this door, so the door will close when that switch position changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the door closed, it’s time to search for the switch that opens it. For
    each switch not already associated with a door, we *toggle* its position from
    0 to 1 or 1 to 0 ➌. Notice how subtracting the position from 1 changes the position:
    if it was 1 before, then it’s 0 now; if it was 0 before, then it’s 1 now. Then,
    we check the new status of the door. If it’s open ➍, then we’ve found the associated
    switch! If it’s still closed, then this wasn’t the right switch and the loop continues.'
  prefs: []
  type: TYPE_NORMAL
- en: What we’re doing in `set_a_switch` is a linear search through all of the remaining
    switches. We could have up to 5,000 switches, so finding the switch for a single
    door could take up to 5,000 calls of `tryCombination`.
  prefs: []
  type: TYPE_NORMAL
- en: We can call `tryCombination` up to 70,000 times. If we get unlucky and the search
    for the first door takes 5,000 calls, the second takes 4,999 calls, the third
    takes 4,998 calls, and so on, then we can only handle about 14 doors before we
    go over the limit. Only 14 doors is not much. We could have 5,000 doors—we’re
    not even close! This is the end of the line for a linear search.
  prefs: []
  type: TYPE_NORMAL
- en: '*Using Binary Search*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The numbers 5,000 (maximum number of doors) and 70,000 (maximum number of `tryCombination`
    calls) subtly encode the fact that binary search is a plausible solution strategy.
    Notice that log[2] 5,000 rounds up to 13\. If we can find a way to use binary
    search, then it’ll pick out the switch for the current door in only 13 calls of
    `tryCombination`, not 5,000\. If we take 13 calls per door, and we have 5,000
    doors, that’s 13 × 5,000 = 65,000 calls in all. We’ll need one extra call per
    door to tell us whether the door is closed but, still, we should be able to get
    in under the 70,000 limit.
  prefs: []
  type: TYPE_NORMAL
- en: How can binary search be used here? It must have something to do with eliminating
    half of the switch range on each step. Take some time to think through this before
    continuing!
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll explain the idea through an example. Suppose we have eight doors and eight
    switches and that Door 0 is currently closed. If we flip Switch 0, and Door 0
    doesn’t open, then we’ve learned very little: all we’ve learned is that Switch
    0 isn’t the switch associated with Door 0\. (It’s like starting with “1” when
    guessing someone’s number between 1 and 1,000.) A better idea is to flip half
    of the switches. So let’s flip Switches 0, 1, 2, and 3\. No matter what that does
    to Door 0, we learn a lot. If Door 0 is still closed, then Switches 0 to 3 have
    nothing to do with Door 0, and we can focus only on Switches 4 to 7\. If Door
    0 is now open, we know that one of the Switches 0 to 3 is the switch that’s associated
    with Door 0, and we can focus only on Switches 0 to 3\. One step: half the range
    gone. We continue in this way until we find the switch (and its position) associated
    with Door 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we go all the way, cutting the range of switches in half again
    and again until we have only one switch remaining. Let’s say we find that Switch
    6 is associated with Door 0\. We’ll then set Switch 6 so that Door 0 is open.
    That’s how it stays. When we next solve Door 1, or indeed any other door later,
    we’ll be careful not to change the position of Switch 6.
  prefs: []
  type: TYPE_NORMAL
- en: I can now present the binary search solution to this problem. The new `set_a_switch`
    code is given in [Listing 7-17](ch07.xhtml#ch07ex017). The `exploreCave` function
    is the same as before ([Listing 7-15](ch07.xhtml#ch07ex015)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-17: Finding and setting the switch for the current door using a
    binary search*'
  prefs: []
  type: TYPE_NORMAL
- en: Compared to [Listing 7-16](ch07.xhtml#ch07ex016), the only real change is the
    replacement of the linear search with a binary search. Prior to each evaluation
    of the binary search condition ➊, we’ll arrange so that the current door is closed.
    In particular, once `low` and `high` are equal and the loop terminates, the door
    will still be closed. Then all we have to do is change the position of switch
    `low` to open the door.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now study the binary search itself. On each iteration, we calculate the
    midpoint `mid`, then change the position of the first half of the switches (but
    only those that are not already associated with doors). What effect did that have
    on the current door ➋? There are two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The door is now open.**   We now know that the switch we seek is between
    `low` and `mid`, so we throw away all switches greater than `mid`. We also flip
    each switch between `low` and `mid` back to what they were prior to this iteration.
    This closes the door again so that we’re ready for the next iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The door is still closed.**   The switch we want is therefore between `mid
    + 1` and `high`, so we throw away all switches that are `mid` or less. That’s
    all we do! No switches get flipped here, because the door is still closed, just
    as we want it.'
  prefs: []
  type: TYPE_NORMAL
- en: When we finish the binary search, `low` and `high` will be equal, and they tell
    us the switch associated with the current door. The current door is still closed
    at this point, so we flip the switch to open it ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no more caveats: we have a clean, fast, binary-search-based solution.
    Send this off to the judge and you should pass all of the test cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes it’s much tougher to find an optimal solution than it is to check
    whether some proposed solution is feasible. How much liquid should be poured in
    a tree? I don’t know. Is 10 liters enough liquid? Now that question I can handle.
  prefs: []
  type: TYPE_NORMAL
- en: When the conditions are right, binary search can convert a hard optimization
    problem into an easier feasibility-check problem. Sometimes it feels like cheating!
    We pay just an extra logarithmic factor for adding the binary search. A logarithmic
    factor is practically free. In return, we get to deal with an easier problem.
  prefs: []
  type: TYPE_NORMAL
- en: I’m not claiming that binary search is the only way to solve the problems in
    this chapter. For example, it’s possible to solve Feeding Ants without binary
    search along the lines of what we did in [Chapter 2](ch02.xhtml), but I find that
    solution trickier than the one I presented in this chapter. Some problems that
    can be solved by binary search can also be solved by dynamic programming, but,
    again, doing so may be very challenging and there’d likely be little practical
    payoff anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'What I am claiming is that binary search can offer solutions that are both
    nearly as fast as and easier to design than anything else we might try. If you’re
    not convinced, you might revisit each problem in this chapter, this time considering
    how you might solve it without binary search. But, really: if you’re working on
    a problem and see that you can use binary search, just do it and don’t look back.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feeding Ants is originally from the 2014 Croatian Open Competition in Informatics,
    Round 4\. River Jump is originally from the December 2006 USA Computing Olympiad,
    Silver Division. Living Quality is originally from the 2010 International Olympiad
    in Informatics. Cave Doors is originally from the 2013 International Olympiad
    in Informatics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary search is one manifestation of a general algorithm design technique
    called *divide and conquer (D&C)*. D&C algorithms solve one or more independent
    subproblems, then combine those solutions to solve the original problem. Binary
    search solves just one subproblem—the one corresponding to the part of the input
    that we know contains the solution. Other D&C algorithms typically solve two or
    more subproblems; in [Chapter 10](ch10.xhtml), we’ll see such an example. To learn
    about other problems that are solved efficiently by D&C algorithms, see *Algorithms
    Illuminated (Part 1): The Basics* by Tim Roughgarden (2017).'
  prefs: []
  type: TYPE_NORMAL
