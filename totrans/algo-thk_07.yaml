- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: BINARY SEARCH
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common1.jpg)'
- en: This chapter is all about binary search. If you don’t know what binary search
    is— excellent! I’m excited for the opportunity to teach you a systematic, performant
    technique for isolating an optimal solution from among zillions of possible solutions.
    And if you do know what binary search is and think that it’s just for searching
    a sorted array—excellent! You’ll learn that binary search is for so much more
    than that. To keep things fresh, we will not search a sorted array in this entire
    chapter, not even once.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容完全是关于二分查找的。如果你不知道二分查找是什么——太棒了！我很高兴有机会教你一种系统的、高效的技术，用来在成千上万的可能解中找到最佳解。如果你知道二分查找是什么，并且认为它只是用来搜索已排序的数组——也太棒了！你将会学到，二分查找不仅仅是为了这个。在本章中，我们将不会搜索已排序的数组，甚至一次也不做。
- en: What do minimizing the amount of liquid needed to feed ants, maximizing the
    minimum jump distance between rocks, finding the best living area in a city, and
    flipping switches to open cave doors have in common? Let’s find out.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化喂养蚂蚁所需的液体量、最大化岩石之间最小跳跃距离、寻找城市中最佳的居住区域以及通过切换开关打开洞穴门，这些问题有什么共同点？让我们一探究竟。
- en: 'Problem 1: Feeding Ants'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 1：喂蚂蚁
- en: This is DMOJ problem `coci14c4p4`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `coci14c4p4`。
- en: '#### *The Problem*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *问题*'
- en: Bobi has a terrarium in the shape of a tree. Each edge of the tree is a pipe
    in which liquid flows down. Some pipes are superpipes that increase the amount
    of liquid that flows through them. Bobi keeps one of his pet ants in each of the
    tree’s leaves. (Yes, this context is a reach. I won’t pretend otherwise, but this
    problem is otherwise ace.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Bobi 有一个形状像树的玻璃箱。树的每一条边都是一根管道，液体沿着这些管道流下。某些管道是超级管道，可以增加通过它们的液体量。Bobi 在树的每一片叶子上放置了一只他的宠物蚂蚁。（是的，这个背景设定有点牵强，我不会装作没有意识到，但这个问题本身是非常棒的。）
- en: Each pipe has a percentage value that indicates the percentage of the available
    liquid that flows through it. For example, suppose that a node *n* has three downward
    pipes, where those pipes have percentage values of 20 percent, 50 percent, and
    30 percent, respectively. If 20 liters of liquid arrive at Node *n*, then the
    20 percent pipe gets 20 × 0.2 = 4 liters, the 50 percent pipe gets 20 × 0.5 =
    10 liters, and the 30 percent pipe gets 20 × 0.3 = 6 liters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每根管道都有一个百分比值，表示通过它的液体占总液体的百分比。例如，假设某个节点 *n* 有三根向下的管道，这些管道的百分比值分别是 20%、50% 和
    30%。如果 20 升液体到达节点 *n*，那么 20% 的管道会得到 20 × 0.2 = 4 升，50% 的管道会得到 20 × 0.5 = 10 升，30%
    的管道会得到 20 × 0.3 = 6 升。
- en: Now consider the superpipes. For each superpipe, Bobi decides whether its special
    behavior is off or on. If it is off, then it behaves like a regular pipe. If it
    is on, then it squares the amount of liquid that it receives.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑超级管道。对于每个超级管道，Bobi 决定它的特殊行为是开启还是关闭。如果它关闭，那么它像普通管道一样工作。如果它开启，那么它会将接收到的液体量平方。
- en: Bobi pours liquid into the root of the tree. His goal is to give each ant at
    least the amount of liquid that it requires and to do so by pouring as little
    liquid as possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Bobi 将液体倒入树的根部。他的目标是给每只蚂蚁至少提供它所需的液体，并且尽可能少地倒入液体。
- en: Let’s make this description concrete by studying a sample terrarium; see [Figure
    7-1](ch07.xhtml#ch07fig01).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过研究一个样本玻璃箱来具体化这个描述；见 [图 7-1](ch07.xhtml#ch07fig01)。
- en: '![Image](../images/ch07fig01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch07fig01.jpg)'
- en: '*Figure 7-1: A sample terrarium*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：一个样本玻璃箱*'
- en: I’ve numbered the nodes from 1 to 6; the leaf nodes (2, 3, 5, and 6) have an
    additional annotation giving the amount of liquid required by each ant. I’ve also
    annotated each edge with its percentage value. Notice that the percentage values
    of the downward pipes leaving a given node always add up to 100 percent.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将节点编号为 1 到 6；叶子节点（2、3、5 和 6）有一个额外的注释，标明了每只蚂蚁所需的液体量。我还在每条边上标注了它的百分比值。注意，从给定节点出发的向下管道的百分比值总和总是
    100%。
- en: There’s one superpipe in the tree, from Node 1 to Node 4; I’ve drawn that with
    a thicker edge. Suppose that 20 liters of liquid are poured into the root. The
    superpipe gets 30 percent of the 20 liters, which is 6 liters. If the superpipe’s
    special behavior is off, then 6 liters flow through it. However, if the superpipe’s
    special behavior is on, then, instead of 6 liters of liquid flowing through it,
    6² = 36 liters of liquid flow through it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 树中有一条超级管道，从节点1到节点4；我已用较粗的边表示这一管道。假设20升液体被倒入根节点。超级管道获得20升液体的30%，即6升。如果超级管道的特殊行为关闭，那么6升液体会通过它。然而，如果超级管道的特殊行为开启，那么，6升液体不会流过，而是6²
    = 36升液体流过。
- en: Input
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，包含以下行：
- en: A line containing *n*, the number of nodes in the tree. *n* is between 1 and
    1,000\. The tree nodes are numbered from 1 to *n*, and the root of the tree is
    node 1.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n*，树中节点的数量。*n* 的值介于1到1,000之间。树的节点编号从1到 *n*，根节点是节点1。
- en: '*n* – 1 lines used to build the tree. Each of these lines represents one pipe
    and consists of four integers: the two nodes connected by the pipe, the pipe’s
    percentage value (between 1 and 100), and whether the pipe is a superpipe (with
    0 meaning no and 1 meaning yes).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* – 1行用于构建树。每一行表示一条管道，包含四个整数：连接该管道的两个节点，管道的百分比值（介于1和100之间），以及管道是否是超级管道（0表示不是，1表示是）。'
- en: A line containing *n* integers, one for each node, giving the number of liters
    of liquid needed by the ant in that node. Each ant requires between 1 and 10 liters
    of liquid. For any nonleaf node (where there is no ant), a value of –1 is given.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n* 个整数，每个整数表示该节点上蚂蚁所需的液体升数。每只蚂蚁需要1到10升液体。对于任何非叶节点（即没有蚂蚁的节点），给定值为-1。
- en: 'Here’s an input that could generate the sample terrarium in [Figure 7-1](ch07.xhtml#ch07fig01):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个可能生成[图7-1](ch07.xhtml#ch07fig01)中示例植物箱的输入：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note how the first line (integer 6 here) indicates the number of nodes in the
    tree, not the number of lines that build the tree. The number of lines that build
    the tree (in this case five lines) is always one less than the number of nodes.
    (Why is it always one less? Each line that builds the tree effectively tells us
    the parent of one of the *n* nodes. Each node except for the root has a parent,
    so we need *n* – 1 lines to tell us about all of the *n* – 1 parents.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一行（此处为整数6）表示树中节点的数量，而不是构建树的行数。构建树的行数（在本例中为五行）总是比节点数少一行。（为什么总是少一行？每一行构建树时，实际上告诉我们一个节点的父节点信息。除了根节点外，每个节点都有一个父节点，因此我们需要
    *n* – 1 行来描述所有的 *n* – 1 个父节点。）
- en: Output
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: Output the minimum number of liters of liquid that Bobi must pour into the tree’s
    root to feed all the ants. Include four digits of accuracy after the decimal point.
    The correct output is guaranteed to be at most 2,000,000,000 (two billion).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输出Bobi必须倒入树根的最少升数，以便喂养所有蚂蚁。输出结果保留四位小数。正确的输出保证不会超过2,000,000,000（20亿）。
- en: The time limit for solving the test case is 0.6 seconds.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制是0.6秒。
- en: '*A New Flavor of Tree Problem*'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*一种新的树问题类型*'
- en: As in [Chapter 2](ch02.xhtml), we’re in the domain of trees here. If we want
    to explore a terrarium tree, then we can use recursion. (A full graph-search algorithm
    such as BFS is overkill because there are no cycles.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[第2章](ch02.xhtml)中一样，我们现在处于树的领域。如果我们想探索一个植物箱树，那么可以使用递归。（像广度优先搜索（BFS）这样的完整图搜索算法是多余的，因为没有循环。）
- en: 'For the two problems in [Chapter 2](ch02.xhtml), our solutions were based on
    the structure of the tree and the values stored in nodes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml)的两个问题中，我们的解决方案是基于树的结构和节点中存储的值：
- en: In Halloween Haul, we calculated the total candy by adding up the values in
    the leaves, and we calculated the total street-walks using the height and shape
    of the tree.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《万圣节糖果运输》中，我们通过将叶节点中的值相加来计算总糖果数，并通过树的高度和形状来计算总街道行走数。
- en: In Descendant Distance, we calculated the number of descendants at the desired
    distance by using the number of children of each node.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《后代距离》中，我们通过使用每个节点的子节点数量来计算所需距离的后代数。
- en: That is, what we needed—candy values, height, tree shape—were right there, encoded
    for us in the tree itself. In the present problem, we’re asked to find the minimum
    number of liters that Bobi must pour—but the tree doesn’t contain any values like
    that! The tree has information on pipe percentage, superpipe status, and ant appetite,
    but it has nothing directly informing us of the amount of liquid that should be
    poured into the root. In particular, the superpipes, with their liquid-squaring
    behavior, make unclear the relationship between the amount of liquid needed by
    the ants and the amount of liquid that should be poured.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们需要的——糖果的数量、身高、树的形状——这些信息就存在树结构里，编码在其中。在当前问题中，我们需要找到Bobi必须倒入的最小升数——但树中并没有类似的值！树中有管道的百分比、超级管道状态以及蚂蚁的食量信息，但没有直接告诉我们应该倒入多少液体。特别是，超级管道的液体平方行为使得蚂蚁所需液体量与应倒入的液体量之间的关系变得不清晰。
- en: Because the tree won’t readily give us what we need, I’ll just pick a value
    out of thin air—say, 10\. There you go, Bobi. Pour 10 liters in there.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为树不会直接给我们需要的值，我就随便挑一个数值——比如，10升。好了，Bobi，把10升倒进去。
- en: I hope you’re very suspicious of what I just did, recklessly choosing a number
    like that. You should be surprised if 10 were the answer. I pulled 10 out of thin
    air, after all. You may also be surprised that we can in fact learn a lot by trying
    out the value 10 and seeing what happens.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你对我刚才做的事非常怀疑，随便选择一个数字。你应该会对10升是答案感到惊讶。毕竟，我是从空中凭空选择了10升。你可能还会惊讶于，事实上，我们通过尝试10升并观察结果，可以学到很多东西。
- en: 'Let’s use [Figure 7-1](ch07.xhtml#ch07fig01) again. Suppose that we pour 10
    liters of liquid into the root. Twenty percent of 10 is 2, so 2 liters of liquid
    will make it to the ant in Node 2\. Perfect: that ant needs 2 liters of liquid,
    so we’re sending just enough liquid. Let’s continue.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再用一下[图7-1](ch07.xhtml#ch07fig01)。假设我们向根部倒入10升液体。10升的20%是2升，因此2升液体会到达节点2的蚂蚁。完美：那只蚂蚁需要2升液体，所以我们正好倒入了足够的液体。接下来继续。
- en: 'Since 50 percent of 10 is 5, the ant in Node 3 gets 5 liters of liquid. Now
    we’re in trouble: that ant needs 9 liters of liquid, and 5 liters is not enough.
    More bad news: the pipe between Nodes 1 and 3 is not a superpipe, so there’s nothing
    we can do except declare that 10 is not in fact the solution.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于10升的50%是5，节点3的蚂蚁得到5升液体。现在我们有麻烦了：那只蚂蚁需要9升液体，而5升显然不够。更糟糕的是：节点1和节点3之间的管道不是超级管道，所以我们无能为力，只能宣告10升不是解答。
- en: We could proceed by picking another number of liters out of thin air and similarly
    simulating the flow of liquid on that new number. However, because 10 liters was
    insufficient, now we should restrict our thin-air range to only values *greater
    than 10*. Since 10 liters was insufficient, any smaller value will be insufficient,
    too. There’s no point trying 2 liters or 7 liters or 9.5 liters or anything less
    than 10\. They’re all too small.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过随便挑选另一个升数来继续，类似地模拟那个新数字下的液体流动。然而，由于10升不足，现在我们应该将我们的“随便挑选”范围限制为仅*大于10*的数值。因为10升不足，任何更小的数值也都不足。尝试2升、7升、9.5升或任何少于10升的数值都没有意义。它们都太少了。
- en: Let’s next try 20 liters. This time, the ant at Node 2 gets 4 liters, which
    is just fine because that ant only needs 2 liters. The ant at Node 3 gets 10 liters,
    which again is fine because that ant only needs 9 liters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们试试20升。这次，节点2的蚂蚁得到4升，这完全没问题，因为那只蚂蚁只需要2升。节点3的蚂蚁得到10升，这也没问题，因为那只蚂蚁只需要9升。
- en: 'The pipe between Nodes 1 and 4 takes 30 percent of the liquid, so that’s 6
    liters of the total 20 liters. However, this pipe is a superpipe! If we use its
    special behavior, the pipe cranks up the 6 liters to 6² = 36 liters, so 36 liters
    arrives at Node 4\. Now the ants at Nodes 5 and 6 are fine: each ant gets 18 liters,
    and they only need 7 liters (Node 5) and 8 liters (Node 6).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 节点1和节点4之间的管道吸收了总液体的30%，也就是20升中的6升。然而，这条管道是超级管道！如果我们使用它的特殊行为，这6升液体会被管道提升至6² =
    36升，因此36升液体到达节点4。现在，节点5和节点6的蚂蚁没问题了：每只蚂蚁得到18升，而它们只需要7升（节点5）和8升（节点6）。
- en: Unlike 10 liters, then, 20 liters is a feasible solution, but is it the optimal
    (that is, minimal) solution? Maybe, maybe not. What we know for sure is that there’s
    no point testing any number of liters greater than 20\. We already have 20 as
    a feasible solution; why try values, such as 25 or 30, that are worse?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与10升不同，20升是一个可行的解，但它是最优（即最小）解吗？也许是，也许不是。我们可以确定的是，测试任何大于20升的液体量没有意义。我们已经得到了20升作为一个可行的解；为什么要尝试更差的值，比如25或30呢？
- en: We’ve now reduced the problem to finding an optimal solution between 10 and
    20 liters. We could keep choosing numbers, reducing the range at each step, until
    our range is so small that one of its endpoints serves as an accurate solution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将问题简化为在10到20升之间找到最优解。我们可以不断选择数字，在每一步缩小范围，直到范围足够小，以至于其中一个端点可以作为准确的解。
- en: In the general case, what number of liters should we choose first? The optimal
    solution could be up to 2 billion, so starting with 10 may be way, way off. And,
    once we test a number of liters, where should we go next? The optimal solution
    might be considerably larger or smaller than our current guess, so adding or subtracting
    10 at a time may not help us make much progress.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，我们应该先选择多少升液体？最优解可能高达20亿，因此从10开始可能会相差甚远。而且，一旦我们测试了一个液体数量，接下来应该选择多少呢？最优解可能比我们当前的猜测要大得多或小得多，所以每次增加或减少10可能无法帮助我们取得多大进展。
- en: These are good questions, good questions that we will answer . . . but not yet.
    Let’s first tackle how to read the input (so that we can explore a tree) and how
    to determine whether a number of liters is a feasible solution. Then, we’ll see
    a super-fast algorithm for searching massive ranges. A range of two billion? We’ll
    eat that for breakfast.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是好问题，值得回答……但还不到时候。让我们首先处理如何读取输入（以便可以探索树结构），以及如何判断一个液体数量是否是可行的解决方案。然后，我们将看到一个超快的算法，用于搜索巨大的范围。20亿的范围？我们吃得了这个早餐。
- en: '*Reading the Input*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*读取输入*'
- en: In [Chapter 2](ch02.xhtml), we used a `node` struct at the core of how trees
    were represented. Then, in [Chapter 5](ch05.xhtml), Book Translation, we used
    the adjacency list representation of a graph with an `edge` struct. There we learned
    that whether we use a `node` or `edge` struct comes down to whether it’s the nodes
    or the edges that carry additional attributes. In the present problem, the edges
    carry information (a percentage and a superpipe status), but so do the leaf nodes
    (the amount of liquid required by each ant). It’s therefore tempting and reasonable
    to use *both* an `edge` struct and a `node` struct. Instead, to closely parallel
    the use of adjacency lists, I’ve chosen to stick with only an `edge` struct. As
    in the problem description, we number nodes starting at 1, but, with no `node`
    struct, we have nowhere to store the amount of liquid required by each ant. For
    that reason, we augment the adjacency list with a `liquid_needed` array, where
    `liquid_needed[i]` gives the amount of liquid required by the ant in Node `i`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.xhtml)中，我们使用了一个`node`结构体来表示树的核心结构。然后，在[第五章](ch05.xhtml)《书籍翻译》中，我们使用了图的邻接表表示法，并使用了一个`edge`结构体。在那里，我们学到了使用`node`结构体还是`edge`结构体取决于是节点还是边缘承载额外的属性。在当前的问题中，边缘承载了信息（一个百分比和一个超管道状态），但叶节点也承载信息（每只蚂蚁所需的液体量）。因此，使用*两者*的`edge`结构体和`node`结构体既合理又具有吸引力。然而，为了更好地模拟邻接表的使用，我选择仅使用`edge`结构体。如同问题描述所说，我们从1开始对节点进行编号，但由于没有`node`结构体，我们没有地方存储每只蚂蚁所需的液体量。因此，我们通过一个`liquid_needed`数组来扩展邻接表，其中`liquid_needed[i]`给出了节点`i`中蚂蚁所需的液体量。
- en: 'Here’s the constant and `typedef` that we’ll use throughout the code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在代码中使用的常量和`typedef`：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As in Book Translation ([Chapter 5](ch05.xhtml)) and the two problems in [Chapter
    6](ch06.xhtml), we can chain these `edge` structs together through `next` pointers
    to form a linked list of edges. If an edge is in the linked list for nNde `i`,
    then we know that the parent node of the edge is `i`. The `to_node` member tells
    us the child node at which this edge connects with the parent node; `percentage`
    is an integer between 1 and 100 that gives the percentage value for the pipe (edge);
    and `superpipe` is a flag whose value is `1` if the pipe is a superpipe and `0`
    if it’s a regular pipe.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在《书籍翻译》（[第5章](ch05.xhtml)）和[第6章](ch06.xhtml)中的两个问题一样，我们可以通过`next`指针将这些`edge`结构体连接在一起，形成一个边的链表。如果一个边在节点`i`的链表中，那么我们就知道该边的父节点是`i`。`to_node`成员告诉我们该边与父节点连接的子节点；`percentage`是一个介于1到100之间的整数，表示该管道（边）的百分比值；`superpipe`是一个标志位，如果该管道是超级管道则其值为`1`，如果是普通管道则为`0`。
- en: Now we can read the tree from the input, as shown in [Listing 7-1](ch07.xhtml#ch07ex01).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从输入中读取树，如[列表7-1](ch07.xhtml#ch07ex01)所示。
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-1: The* main *function for building the tree*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-1：构建树的*主函数*'
- en: 'The code is similar to, but simpler than, [Listing 5-16](ch05.xhtml#ch05ex016)
    (Book Translation). In particular, each edge is read from the input, its members
    are set, and then it’s added to the list of edges for `from_node` ➊. You may expect
    a corresponding edge to be added for `to_node`, since the graph is undirected,
    but I’ve left out such edges: liquid moves down the tree, not up, so adding backward
    edges would needlessly complicate the code that explores a tree.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码类似于[列表5-16](ch05.xhtml#ch05ex016)（书籍翻译）中的代码，但更简洁。具体来说，每条边都是从输入中读取的，成员被设置好后，再将其添加到`from_node`的边列表中➊。你可能会期望会为`to_node`添加对应的边，因为图是无向的，但我省略了这些边：液体沿树向下流动，而不是向上流动，因此添加反向边会不必要地复杂化探索树的代码。
- en: Once the edge information is read in, all that’s left is to read the values
    for the amount of liquid required by each ant. We’ll use the `liquid_needed` array
    for that ➋. The combination of `adj_list` and `liquid_needed` captures everything
    we need to know about the test case.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取了边的信息，剩下的就是读取每个蚂蚁所需的液体量。我们将使用`liquid_needed`数组来存储这些信息➋。`adj_list`和`liquid_needed`的组合包含了我们需要了解的测试用例的所有信息。
- en: '#### *Testing Feasibility*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *测试可行性*'
- en: 'Our next milestone is this: determine whether a given amount of liquid is a
    feasible solution. This is a crucial step, because once we have a function that
    can test a value for feasibility, we’ll be able to use it to progressively narrow
    the search space until we find the optimal solution. Here’s the signature for
    the function that we’ll write:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个里程碑是：确定给定的液体量是否为可行解。这是一个关键步骤，因为一旦我们有了一个可以测试可行性的函数，我们就能够利用它逐步缩小搜索范围，直到找到最优解。以下是我们将要编写的函数签名：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `node` is the root node of the tree, `liquid` is the amount of liquid
    that we pour into the root of the tree, `adj_list` is the adjacency list for the
    tree, and `liquid_needed` is the amount of liquid required by each ant. We’ll
    return `1` if `liquid` is enough to feed the ants (that is, if `liquid` is a feasible
    solution) and `0` if it is not.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`node`是树的根节点，`liquid`是我们倒入树根的液体量，`adj_list`是树的邻接表，`liquid_needed`是每个蚂蚁所需的液体量。如果`liquid`足够喂养蚂蚁（即，`liquid`是可行的解决方案），我们将返回`1`，否则返回`0`。
- en: We spent a whole chapter ([Chapter 2](ch02.xhtml)) writing recursive functions
    on trees. Let’s think about whether we can use recursion again.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整个章节中（[第2章](ch02.xhtml)）都在编写树的递归函数。让我们思考一下，是否还能再次使用递归。
- en: Remember that, to use recursion, we need a base case—a case that can be solved
    with no recursion. Luckily, we have one! If the tree is a single leaf node, then
    we can determine right away whether `liquid` is sufficient. If `liquid` is greater
    than or equal to the amount of liquid needed by the ant in this leaf, then we
    have a feasible solution; otherwise, we don’t.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要使用递归，我们需要一个基准情况——一个可以不通过递归解决的情况。幸运的是，我们有一个！如果树只有一个叶子节点，我们就可以立即判断`liquid`是否足够。如果`liquid`大于或等于该叶子节点中蚂蚁所需的液体量，那么我们就有一个可行的解决方案；否则，我们就没有。
- en: 'We can tell whether a node is a leaf by checking the corresponding value in
    `liquid_needed`: if it’s `-1`, then it isn’t a leaf; otherwise, it is. (We could
    have also used the adjacency list to check whether or not the linked list for
    the node was empty.) Here’s what we’ve got:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查`liquid_needed`中的相应值来判断一个节点是否是叶子节点：如果值为`-1`，那么它不是叶子节点；否则，它就是叶子节点。（我们也可以使用邻接表来检查该节点的链表是否为空。）下面是我们得到的结果：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, consider the recursive case. Imagine that the root node of some tree has
    *p* downward pipes (that is, *p* children). We’re given the amount of liquid that’s
    poured into the root. Using the pipe percentage values, we can determine the amount
    of liquid that goes into each pipe; using the superpipe statuses, we can determine
    the amount of liquid that reaches the bottom end of each pipe. If enough liquid
    reaches the bottom end of each pipe, then the liquid poured into the root was
    sufficient and we should return `1`. Otherwise, the amount of liquid that reaches
    the bottom end of some pipe isn’t sufficient, and we should return `0`. This suggests
    that we should make *p* recursive calls, one for each pipe that leaves the root.
    We’ll do that in a loop that uses the adjacency list to go through each such pipe.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑递归情况。假设某棵树的根节点有*p*条向下的管道（即，*p*个子节点）。我们已经知道根节点输入的液体量。通过管道的百分比值，我们可以确定每条管道进入的液体量；通过超级管道的状态，我们可以确定到达每条管道底端的液体量。如果足够的液体到达每条管道的底端，那么根节点输入的液体量就是足够的，我们应该返回`1`。否则，某条管道到达底端的液体量不足，我们应该返回`0`。这表明我们应该进行*p*次递归调用，每次调用处理一条从根节点出发的管道。我们将在一个循环中使用邻接表遍历每一条管道。
- en: The full code for the function is given in [Listing 7-2](ch07.xhtml#ch07ex02).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的完整代码见[清单7-2](ch07.xhtml#ch07ex02)。
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-2: Testing the feasibility of the amount of liquid*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-2：测试液体量的可行性*'
- en: The `ok` variable tracks whether `liquid` is a feasible solution for the tree.
    If `ok` is `1`, then the solution is still feasible; if `ok` is `0`, then it’s
    definitely not. We initialize `ok` to `1` ➊, and we set it to `0` if the amount
    of liquid through one of the pipes isn’t sufficient ➌. If `ok` is still `1` at
    the bottom of the function, then we’ve satisfied all pipes and we conclude that
    `liquid` is feasible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ok`变量用于跟踪`liquid`是否是树的可行解。如果`ok`为`1`，则解决方案仍然可行；如果`ok`为`0`，则肯定不可行。我们将`ok`初始化为`1`
    ➊，如果通过某条管道的液体量不足，我们就将其设为`0` ➌。如果函数执行到最后，`ok`仍然为`1`，说明所有管道的需求都得到了满足，我们可以得出`liquid`是可行的结论。'
- en: We determine the amount of liquid that enters each pipe by using that pipe’s
    percentage value. Then, if the pipe is a superpipe, we square that value ➋ . .
    . but hey, wait! The problem description says that Bobi gets to decide whether
    or not to use the special behavior of each superpipe. However, here we’re just
    indiscriminately squaring the amount of liquid, thereby always using the special
    behavior.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用管道的百分比值来确定进入每条管道的液体量。如果该管道是超级管道，我们就对该值进行平方 ➋ ……等等，等一下！问题描述说，Bobi可以决定是否使用每条超级管道的特殊行为。然而，在这里，我们只是毫不犹豫地对液体量进行平方，从而总是使用特殊行为。
- en: 'The reason we can get away with this is that squaring makes values bigger:
    compare 2 to 2² = 4, 3 to 3² = 9, and so on. Since we want to know whether the
    given amount of liquid is feasible and there’s no penalty for using the special
    behavior of a superpipe, we may as well generate as much liquid as possible. Maybe
    we could have gotten away without using some superpipe special behavior, but no
    one’s asking us to be economical.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以能够这样做，是因为平方会使数值变大：比较2和2² = 4，3和3² = 9，依此类推。由于我们想知道给定的液体量是否可行，而且使用超级管道的特殊行为没有惩罚，因此我们可以尽可能地生成更多的液体。或许我们能不用某些超级管道的特殊行为，但并没有人要求我们节约。
- en: Don’t worry that squaring makes positive values less than one, such as 0.5,
    smaller. 0.5² = 0.25, so indeed we wouldn’t want to activate superpipe behavior
    in such cases. Each ant requires at least 1 liter of liquid, though. So, if we’re
    down to 0.5 liters of liquid at some node, then nothing we do is going to feed
    the ants in the node’s subtree anyway. We’d eventually return `0` whether or not
    we squared the value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心平方会让小于1的正值（例如0.5）变得更小。0.5² = 0.25，所以在这种情况下，我们确实不希望激活超级管道的行为。每只蚂蚁至少需要1升液体。然而，如果我们在某个节点上只剩下0.5升液体，那么无论我们做什么，都无法为该节点子树中的蚂蚁提供足够的液体。即使我们不平方该值，最终也会返回`0`。
- en: 'Let’s show how useful this `can_feed` function is by continuing the work we
    did in “A New Flavor of Tree Problem” on [page 233](ch07.xhtml#sec97). We showed
    there that 10 liters was not sufficient for the sample instance from the problem
    description. Comment out the `solve` call at the bottom of [Listing 7-1](ch07.xhtml#ch07ex01)
    (don’t worry: we’ll write that `solve` function soon), and add a call to `can_feed`
    to test 10 liters of liquid:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过继续在[第233页](ch07.xhtml#sec97)的《一种新的树问题》中的工作，展示`can_feed`函数有多么有用。我们在那里展示了10升对问题描述中的示例实例来说是不够的。将[列表7-1](ch07.xhtml#ch07ex01)底部的`solve`调用注释掉（别担心，我们很快会编写那个`solve`函数），然后添加一个`can_feed`的调用来测试10升的液体：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see a result of `0`, which means that 10 liters isn’t sufficient.
    We also showed that 20 liters was sufficient. Change the `can_feed` call to test
    20 liters instead of 10:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`0`的结果，这意味着10升不够。我们也展示了20升是足够的。将`can_feed`的调用修改为测试20升而不是10升：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should see a result of `1`, which means that 20 liters is sufficient.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`1`的结果，这意味着20升足够。
- en: Now, we know that 10 is not enough but 20 is. Let’s squeeze this range down
    further. Try 15, and you should see an output of `0`. So, it seems 15 is not enough.
    Our optimal answer is now greater than 15 and at most 20.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道10不够，但20够。让我们进一步缩小这个范围。试试15，你应该看到`0`的输出。所以，似乎15还不够。我们的最优答案现在大于15，最多为20。
- en: 'Try 18 next: you should see that 18 is enough. How about 17? No, 17 is not
    enough, nor is 17.5 or 17.9\. It turns out that the optimal solution is indeed
    18.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来试试18：你应该看到18是足够的。那17呢？不，17不够，17.5和17.9也不行。事实证明，最优解确实是18。
- en: That’s enough of the ad hoc searching. Let’s systematize this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 够了，不再进行这种临时搜索了。让我们将其系统化。
- en: '*Searching for a Solution*'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*寻找解决方案*'
- en: From the problem description, we know that the optimal solution is at most two
    billion. There’s therefore a massive search space in which the optimal solution
    lies. Our goal is to cut down this space as quickly as possible by never wasting
    a guess.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从问题描述中，我们知道最优解最多是20亿。因此，存在一个庞大的搜索空间，最优解就在其中。我们的目标是尽可能快地缩小这个空间，通过避免浪费任何一次猜测来实现。
- en: 'It’s easy to waste a guess. For example, if we start with a guess of 10, and
    the optimal solution is in fact two billion, then we’ve essentially wasted that
    guess: all we’ve done is eliminate the numbers between 0 and 10\. It’s true that
    a guess of 10 would be fantastic if the optimal solution were, say, 8, because
    that one step would cut the range down to 0 to 10 and we’d find 8 soon after.
    Nonetheless, taking shots like this isn’t worth it, because getting lucky once
    in a while won’t offset the very likely case that our guess tells us almost nothing.
    It’s for this reason that you don’t guess 10 as your first guess when someone
    asks you to guess their number between 1 and 1,000\. Sure, if they say “lower,”
    you look like a full-on rock star, but if they say “higher,” as they most likely
    will, you’ve all but wasted that first guess.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易浪费一次猜测。例如，如果我们从10开始猜测，而最优解实际上是20亿，那么我们基本上浪费了那次猜测：我们做的只是排除了0到10之间的数字。确实，如果最优解是8的话，猜10会很棒，因为那一步可以将范围缩小到0到10，我们很快就能找到8。然而，像这样随意猜测并不值得，因为偶尔运气好一次也无法弥补我们猜测几乎没有用的高概率情况。正因为如此，当有人让你猜测1到1000之间的数字时，你不会选择从10开始猜。没错，如果他们说“更低”，你看起来像个明星，但如果他们说“更高”，也就是最有可能的情况，那你基本上就浪费了第一次猜测。
- en: To guarantee that we learn as much as possible with each guess, we’ll always
    guess the middle of the range. To do so, we maintain two variables, `low` and
    `high`, holding the low end and high end, respectively, of our current range.
    We then calculate the middle of the range, `mid`, test the feasibility of `mid`,
    and update `low` or `high` based on what we learn. We’ll implement this strategy
    in [Listing 7-3](ch07.xhtml#ch07ex03).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每次猜测都能获得尽可能多的信息，我们总是猜测范围的中间值。为此，我们维护两个变量，`low`和`high`，分别表示当前范围的低端和高端。然后，我们计算范围的中间值`mid`，测试`mid`的可行性，并根据我们的发现更新`low`或`high`。我们将在[列表7-3](ch07.xhtml#ch07ex03)中实现这一策略。
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-3: Searching for the optimal solution*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-3：寻找最优解*'
- en: It’s important to initialize `low` and `high` so that their range is guaranteed
    to contain the optimal solution. At all times, we’ll maintain that `low` is less
    than or equal to the optimal solution and that `high` is greater than or equal
    to the optimal solution. We start `low` off with a value of 0; as each ant requires
    at least 1 liter, 0 liters is definitely less than or equal to the optimal solution.
    We start `high` off with a value of 2 billion, because it’s guaranteed by the
    problem description that 2 billion is the maximum value of the optimal solution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`low`和`high`很重要，这样它们的范围就能保证包含最优解。我们始终保持`low`小于或等于最优解，`high`大于或等于最优解。我们将`low`初始化为0；因为每只蚂蚁至少需要1升，所以0升肯定小于或等于最优解。我们将`high`初始化为20亿，因为根据问题描述，20亿是最优解的最大值。
- en: The `while` loop condition forces the range between `low` and `high` to be very
    small by the time the loop ends ➊. We need four digits of accuracy, hence the
    four 0s after the decimal point in `0.00001`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环条件会在循环结束时迫使`low`和`high`之间的范围非常小 ➊。我们需要四位精度，因此在`0.00001`的小数点后有四个零。'
- en: The first thing to do in the loop body is to calculate the middle of the range.
    We’ll do that by taking the average of `low` and `high`, storing that result in
    `mid` ➋.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 循环体内的第一件事是计算范围的中间值。我们通过取`low`和`high`的平均值来实现这一点，将结果存储在`mid`中 ➋。
- en: Now it’s time to test `mid` liters for feasibility, using `can_feed` ➌. If `mid`
    is feasible, we have learned that guessing anything larger than `mid` would be
    a waste. We therefore set `high = mid` to cut the range off at a maximum of `mid`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试`mid`升是否可行了，使用`can_feed` ➌。如果`mid`可行，我们已经知道猜测任何大于`mid`的值都是浪费时间。因此，我们将`high
    = mid`，将范围限制在最大值`mid`。
- en: If `mid` is not feasible, then guessing anything smaller than `mid` would be
    a waste. We therefore set `low = mid` to cut the range off at a minimum of `mid`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`mid`不可行，那么猜测任何比`mid`小的值都会浪费时间。因此，我们将`low = mid`，将范围限制在最小值`mid`。
- en: Once the loop terminates, `low` and `high` are very close together. We’re printing
    `high` ➍, but printing `low` would work just as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦循环终止，`low`和`high`会非常接近。我们打印`high` ➍，但打印`low`同样有效。
- en: This technique, where we keep dividing the range in half until it’s very small,
    is called *binary search*. It’s a surprisingly subtle and powerful algorithm,
    further evidence of which will come from the remaining problems in this chapter.
    It’s also very fast, able to handle ranges of billions or trillions with ease.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技巧，我们通过不断将范围一分为二，直到它非常小，被称为*二分查找*。它是一个出奇精巧且强大的算法，剩下的本章问题将进一步证明这一点。它也非常快速，能够轻松处理数十亿或数万亿的范围。
- en: Submit the solution to the judge, and then let’s keep going. There’s a lot more
    to know about binary search.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提交解决方案给评测系统，然后我们继续。关于二分查找，还有很多要学的东西。
- en: Binary Search
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二分查找
- en: Feeding Ants is an exemplar of the types of problems where binary search thrives.
    There are two ingredients to such problems; if you see these ingredients in a
    new problem you’re facing, it’s worth your time to try binary search.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '"喂养蚂蚁"是二分查找得以发挥优势的典型问题。这类问题有两个关键要素；如果你在面对的新问题中看到了这些要素，那么尝试二分查找是值得的。'
- en: '**Ingredient 1: Hard optimality and easy feasibility**   For some problems,
    it’s hard to come up with a way to find an optimal solution. Fortunately, in many
    such cases, it’s considerably easier to determine whether or not some proposed
    solution is feasible. This was the situation in the Feeding Ants problem: we didn’t
    know how to find an optimal solution directly, but we did see how to determine
    whether some number of liters was feasible.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**要素1：硬性最优性与容易可行性**   对于一些问题，找到最优解很困难。幸运的是，在许多这种情况下，确定某个提议的解决方案是否可行要容易得多。这就是“喂养蚂蚁”问题的情况：我们不知道如何直接找到最优解，但我们知道如何判断某个升数是否可行。'
- en: '**Ingredient 2: Infeasible–feasible split**   We need the problem to exhibit
    the property that there is a border between infeasible and feasible solutions.
    All solutions on one side of the border must be infeasible, and all solutions
    on the other side must be feasible. In Feeding Ants, small values were infeasible
    and large values were feasible. Imagine considering values from small to large
    and asking whether each is infeasible or feasible. In doing so, we’ll see a bunch
    of infeasible values and then a feasible value; after our first feasible value,
    we won’t see infeasible values again. Suppose we try a value of 20 liters and
    find that it’s infeasible. This means that we’re still in the infeasible part
    of the search space, and we must search larger values. If 20 liters is feasible,
    then we’re in the feasible part of the search space, and we should search smaller
    values. (Not meeting Ingredient 2 renders binary search useless. For example,
    suppose we have a problem where small values are infeasible, larger values are
    feasible, and even-larger values are infeasible again. We try a value of 20 and
    find that it is infeasible. Don’t even think about focusing on values greater
    than 20: for all we know, values less than 10 could be infeasible and 10 to 15
    could be feasible, giving 10 as the optimal solution here.) It’s also okay if
    the search space transitions from feasible to infeasible, rather than from infeasible
    to feasible. Our next problem will offer such an example.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**要素 2：不可行–可行分割** 我们需要问题展现出一个特性，即在不可行解和可行解之间有一个边界。所有位于边界一侧的解都必须是不可行的，而另一侧的所有解都必须是可行的。在“喂养蚂蚁”问题中，小值是不可行的，大值是可行的。可以想象从小到大的值，并询问每个值是不可行的还是可行的。在这样做的过程中，我们会先看到一堆不可行的值，然后看到一个可行的值；在我们找到第一个可行值后，就再也看不到不可行值了。假设我们尝试了一个20升的值，并发现它是不可行的。这意味着我们仍然处于不可行的搜索空间中，必须继续搜索更大的值。如果20升是可行的，那么我们就进入了可行的搜索空间，应该搜索更小的值。（如果不满足要素
    2，二分查找就失去了作用。例如，假设我们有一个问题，小值不可行，大值可行，而更大的值又不可行。我们尝试了一个20的值并发现它不可行。别想再关注20以后的值：因为我们无法知道10以下的值是否不可行，10到15之间的值是否可行，最终最优解可能是10。）如果搜索空间从可行变为不可行，而不是从不可行变为可行，也是可以的。我们的下一个问题将提供这样的例子。'
- en: '*Runtime of Binary Search*'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*二分查找的运行时间*'
- en: 'The reason why binary search is so powerful is that it makes a huge amount
    of progress with just a single iteration. For example, suppose that we’re searching
    for an optimal solution in a range of two billion. A single iteration of binary
    search throws out half of this range, leaving a range of only one billion. Let
    that sink in: with just a single `if` statement and one variable update to `mid`,
    we make one billion units of progress! If binary search takes *q* iterations to
    search a range of one billion, then it takes only one more iteration, *q* + 1,
    to search a range of two billion. The number of iterations grows very slowly compared
    to the width of the range.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找如此强大的原因在于它只需一次迭代就能取得巨大的进展。例如，假设我们在一个二十亿的范围内搜索最优解。二分查找的单次迭代就能丢弃掉一半的范围，剩下只有十亿的范围。想象一下：仅仅通过一个`if`语句和一次对`mid`变量的更新，我们就取得了十亿的进展！如果二分查找需要*q*次迭代来搜索一个十亿的范围，那么只需要再加一次迭代，*q*
    + 1，就能搜索一个二十亿的范围。与范围宽度相比，迭代次数增长得非常缓慢。
- en: 'The number of iterations taken by binary search to cut a range *n* to range
    1 is roughly the number of times that *n* must be divided by 2 to get down to
    1\. For example, say that we start with a range of 8\. After one iteration, we’ll
    have reduced the range to at most 4\. After two iterations, we’ll have reduced
    the range to at most 2\. After three iterations, we’ll have reduced the range
    to 1\. Moreover, if we don’t care about decimal digits of accuracy, then that’s
    it: three iterations.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找将一个范围*n*缩小到1所需的迭代次数大致是将*n*除以2直到得到1所需要的次数。例如，假设我们从8开始一个范围。经过一次迭代，范围会缩小到最多4。经过两次迭代，范围会缩小到最多2。经过三次迭代，范围会缩小到1。此外，如果我们不关心精度的小数位，那么就到此为止：三次迭代。
- en: There’s a mathematical function called the *base-2 logarithm*, which, given
    value *n*, tells you how many times you have to divide *n* by 2 to get 1 or less.
    It’s written log[2] *n* or, when the discussion makes it clear that two is the
    base, as just log *n*. For example, log[2] 8 is 3 and log[2] 16 is 4\. log[2]
    2,000,000,000 (that’s two billion) is 30.9, so it takes about 31 iterations to
    knock this range down to 1.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个数学函数叫做*二进制对数*，给定值*n*，它告诉你需要将*n*除以2多少次才能得到1或更小的值。它写作log[2] *n*，或者当讨论明确表明底数为2时，简写为log
    *n*。例如，log[2] 8是3，log[2] 16是4。log[2] 2,000,000,000（即20亿）是30.9，因此大约需要31次迭代才能将这个范围缩小到1。
- en: Binary search is an example of a *logarithmic-time* algorithm. We therefore
    say that it’s *O*(log *m*). (You’d ordinarily use *n* here instead of *m*, but
    we’re going to use *n* for something else later in this section.) To reduce a
    range to 1, *m* is the initial width of the range. However, in Feeding Ants, we
    needed to go further, obtaining four decimal digits of accuracy. What is *m* there?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找是一个*对数时间*算法的例子。因此我们说它是*O*(log *m*)。 （通常你会在这里使用*n*而不是*m*，但在本节后面我们将使用*n*表示其他含义。）要将范围减少到1，*m*是范围的初始宽度。然而，在“喂蚁”问题中，我们需要进一步处理，获取四位小数的精度。那么，*m*在这里代表什么呢？
- en: 'It’s time to come clean on how we used binary search in Feeding Ants: we do
    more than log[2] 2,000,000,000 iterations of binary search, because we don’t stop
    when the width of the range is 1\. Instead, we stop once we’ve achieved four digits
    of accuracy after the decimal point. Adding five zeros gives us the number of
    iterations that we do: log[2] 200,000,000,000,000 rounds up to 48\. Only 48 iterations
    are needed to pull a solution with four decimal digits of accuracy from a bewildering
    range of trillions. That’s what binary search is made of.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候公开我们在“喂蚁”问题中如何使用二分查找了：我们做的不仅仅是log[2] 2,000,000,000次二分查找迭代，因为我们不会在范围宽度为1时停止。而是，一旦我们在小数点后获得四位精度时就停止。加上五个零，我们就得到了我们所做的迭代次数：log[2]
    200,000,000,000,000向上取整为48次。仅需48次迭代，就能从一个困惑的万亿范围中得出四位小数精度的解。这就是二分查找的魅力所在。
- en: On a tree of *n* nodes, the `can_feed` function in [Listing 7-2](ch07.xhtml#ch07ex02)
    (Feeding Ants) takes linear time; that is, time proportional to *n*. We call that
    function log[2] *m* × 10⁴ times, where *m* is the width of the range (two billion
    in the test cases). This is proportional to log *m* work. In total, then, we do
    *n* work a total of log *m* times. This is an *O*(*n* log *m*) algorithm. It is
    not quite linear, because of that extra log *m* factor, but still very fast.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个*n*节点的树上，`can_feed`函数（见[清单7-2](ch07.xhtml#ch07ex02)，“喂蚁”问题）需要线性时间；即，时间与*n*成正比。我们称该函数为log[2]
    *m* × 10⁴次，其中*m*是范围的宽度（在测试用例中为20亿）。这与log *m*的工作量成正比。因此，总体来说，我们需要进行*n*次工作，总共需要log
    *m*次。这是一个*O*(*n* log *m*)算法。它不是完全线性的，因为有额外的log *m*因素，但仍然非常快速。
- en: '*Determining Feasibility*'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*确定可行性*'
- en: What I like most about binary search algorithms is that determining whether
    a value is feasible often requires the use of some other type of algorithm. That
    is, on the outside we have binary search, but on the inside—to test if each value
    is feasible—we have something else. That something else could be anything. In
    Feeding Ants, it was a tree search. In our next problem, it will be a greedy algorithm.
    In our third problem, it will be a dynamic-programming algorithm. We won’t see
    one in this book, but there are problems where checking feasibility requires running
    a graph algorithm. That stuff you’ve learned in the previous chapters will all
    be in play again.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢二分查找算法的一点是，判断一个值是否可行通常需要使用其他类型的算法。也就是说，外部我们使用二分查找，但在内部——为了测试每个值是否可行——我们使用其他算法。这个“其他算法”可以是任何东西。在“喂蚁”问题中，它是树搜索。在我们下一个问题中，它将是贪心算法。在我们的第三个问题中，它将是动态规划算法。在本书中我们不会看到这一点，但确实有一些问题需要运行图算法来检查可行性。你在前几章学到的那些内容都会再次派上用场。
- en: Determining feasibility often requires considerable creativity (just hopefully
    not as much creativity as needed for finding optimality!).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 确定可行性通常需要相当的创造力（只是希望不需要像寻找最优解那样多的创造力！）。
- en: '*Searching a Sorted Array*'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*搜索已排序数组*'
- en: If you were familiar with binary search prior to reading this chapter, odds
    are that it was in the context of searching a sorted array. A typical scenario
    is that we are given an array `a` and a value `v`, and we want to find the smallest
    index of `a` whose value is greater than or equal to `v`. For example, if we were
    given the array `{-5, -1, 15, 31, 78}` and `v` were 26, we’d return index `3`,
    because the value at index `3` (31) is the first one that’s greater than or equal
    to 26.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在读这一章之前已经熟悉二分查找，那么大概率是在查找已排序数组的上下文中。一个典型的场景是，给定一个数组 `a` 和一个值 `v`，我们想要找到 `a`
    中第一个大于或等于 `v` 的最小索引。例如，如果我们给定数组 `{-5, -1, 15, 31, 78}` 和 `v` 为 26，我们会返回索引 `3`，因为索引
    `3` 处的值（31）是第一个大于或等于 26 的值。
- en: 'Why does binary search work here? Take a look at the two ingredients:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么二分查找在这里有效？看一下这两个关键要素：
- en: '**Ingredient 1**   Without a binary search, finding the optimal value would
    involve a costly scan through the array. Therefore, optimality is hard to obtain,
    but feasibility is easy: if I give you an index `i`, you can tell me right away
    whether `a[i]` is greater than or equal to `v` just by comparing `a[i]` to `v`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键要素 1**   如果没有二分查找，找到最优值需要在数组中进行耗时的扫描。因此，获得最优解很困难，但判断可行性却很容易：如果我给你一个索引 `i`，你可以通过比较
    `a[i]` 和 `v`，立即告诉我 `a[i]` 是否大于或等于 `v`。'
- en: '**Ingredient 2**   Any values smaller than `v` come before any values that
    are greater than or equal to `v`—remember that `a` is sorted! That is, the infeasible
    values come before the feasible values.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键要素 2**   任何小于 `v` 的值都会出现在大于或等于 `v` 的值之前——记住，`a` 是已排序的！也就是说，不可行的值出现在可行值之前。'
- en: It’s true that binary search can be used to find a suitable index in an array
    in logarithmic time; later, in [Chapter 10](ch10.xhtml), we’ll use it for that
    very purpose. But we solved Feeding Ants with binary search, with no such array
    in sight. Don’t restrict yourself to thinking about binary search only when you
    have an array to search. Binary search is far more flexible than that.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，二分查找可以用来在对数时间内找到数组中的合适索引；稍后在[第 10 章](ch10.xhtml)中，我们将用它来解决这个问题。但我们在用二分查找解决“喂养蚂蚁”问题时，并没有看到数组的存在。不要仅仅在有数组需要查找时才考虑二分查找。二分查找比这更加灵活。
- en: 'Problem 2: River Jump'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 2：河流跳跃
- en: We’ll now see a problem in which we need a greedy algorithm to determine feasibility.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看到一个问题，需要使用贪心算法来判断可行性。
- en: This is POJ problem `3258`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 POJ 问题 `3258`。
- en: '*The Problem*'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: 'There’s a river of length *L* along which rocks have been placed. There’s a
    rock at Location 0 (the beginning of the river), a rock at Location *L* (the end
    of the river), and then *n* other rocks between these. For example, on a river
    of length 12, we might have rocks at the following locations: 0, 5, 8, and 12.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 河流的长度为 *L*，沿途放置了若干石头。河流的起点位置是 0（起点石头），终点位置是 *L*（终点石头），还有 *n* 块石头在这两者之间。例如，在一条长度为
    12 的河流上，我们可能会在以下位置放置石头：0，5，8，12。
- en: A cow begins on the first rock (Location 0), jumps from there to the second
    rock, jumps from the second rock to the third rock, and so on, until it gets to
    the rock at the end of the river (Location *L*). Its minimum jump distance is
    the minimum distance between any consecutive pair of rocks. In the above example,
    the minimum jump distance is 3, witnessed by the distance between the rocks at
    Locations 5 and 8.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一头牛从第一块石头（位置 0）开始，从那里跳到第二块石头，再从第二块跳到第三块石头，依此类推，直到跳到河流尽头的石头（位置 *L*）。它的最小跳跃距离是任何相邻两块石头之间的最小距离。在上述例子中，最小跳跃距离是
    3，体现了位置 5 和位置 8 之间的距离。
- en: Farmer John is bored by the short jumps made by the cow, so he wants to increase
    the minimum jump distance as much as possible. He can’t remove the rock at Location
    0 or Location *L*, but he is able to remove *m* of the other rocks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 农场主约翰对牛的短跳跃感到厌烦，因此他想尽可能增加最小跳跃距离。他不能移除位置 0 或位置 *L* 的石头，但他可以移除 *m* 块其他的石头。
- en: In the above example, suppose that Farmer John is able to remove one rock. His
    choice is then to remove the rock at Location 5 or Location 8\. If he removes
    the rock at Location 5, the minimum jump distance is 4 (from Location 8 to Location
    12). However, he shouldn’t do that, because if he removes the rock at Location
    8, then he achieves a greater minimum jump distance of 5 (from Location 0 to Location
    5).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，假设农场主约翰能够移除一块石头。他的选择是移除位置 5 或位置 8 的石头。如果他移除位置 5 的石头，最小跳跃距离将是 4（从位置 8
    到位置 12）。然而，他不应该这样做，因为如果他移除位置 8 的石头，那么最小跳跃距离将变为 5（从位置 0 到位置 5），这样更好。
- en: Our task is to maximize the minimum jump distance that Farmer John can achieve
    by removing *m* rocks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是通过移除 *m* 块岩石，最大化农民约翰可以达到的最小跳跃距离。
- en: '##### Input'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 输入'
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，包含以下几行：
- en: A line containing the three integers *L* (the length of the river), *n* (the
    number of rocks, not including the rocks at the beginning and end), and *m* (the
    number of rocks that Farmer John can remove). *L* is between 1 and 1,000,000,000
    (one billion), *n* is between 0 and 50,000, and *m* is between 0 and *n*.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含三个整数 *L*（河流的长度），*n*（岩石的数量，不包括起始和结束位置的岩石），以及 *m*（农民约翰可以移除的岩石数量）。*L* 的值在 1
    到 1,000,000,000（一十亿）之间，*n* 的值在 0 到 50,000 之间，*m* 的值在 0 到 *n* 之间。
- en: '*n* lines, each giving the integer location of a rock. No two rocks will be
    at the same location.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行给出一个岩石的位置（整数）。没有两个岩石会处于同一位置。'
- en: Output
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: Output the maximum achievable minimum jump distance. For the above example,
    we would output `5`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出最大可实现的最小跳跃距离。对于上面的例子，我们将输出`5`。
- en: The time limit for solving the test case is two seconds.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 解决该测试用例的时间限制是两秒钟。
- en: '*A Greedy Idea*'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*贪心思想*'
- en: 'In [Chapter 3](ch03.xhtml), when solving the Moneygrubbers problem, we introduced
    the idea of a greedy algorithm. A greedy algorithm does what looks promising right
    now, with no regard to the long-term consequences of its choices. Such an algorithm
    is often easy to propose: just state the greedy rule that it uses to make its
    next choice. When solving the Moneygrubbers problem, for example, I proposed the
    greedy algorithm that chooses the option of cheapest cost per apple. That greedy
    algorithm was incorrect. That lesson is worth remembering: while it’s easy to
    propose a greedy algorithm, it’s not easy to find one that’s correct.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.xhtml)中，解决Moneygrubbers问题时，我们介绍了贪心算法的思想。贪心算法做出当前看起来最有希望的选择，而不考虑其选择的长期后果。这样的算法往往很容易提出：只需要说明它用来做出下一个选择的贪心规则。例如，在解决Moneygrubbers问题时，我提出了一个贪心算法，选择每个苹果成本最低的选项。那个贪心算法是错误的。这个教训值得记住：虽然提出一个贪心算法很容易，但找到一个正确的贪心算法并不容易。
- en: For two reasons, I didn’t dedicate a chapter of the book to greedy algorithms.
    First, they’re not as broadly applicable as other algorithm design approaches
    (such as dynamic programming). Second, when they do happen to work, it’s often
    for subtle, problem-specific reasons. I’ve been duped many times over the years
    by seemingly correct but ultimately flawed greedy algorithms. A careful proof
    of correctness is often required to distinguish between the ones that are right
    and the ones that only feel right.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有为贪心算法单独写一章，原因有两个。首先，它们不像其他算法设计方法（例如动态规划）那样广泛适用。其次，当它们确实有效时，往往是由于一些微妙的、特定问题的原因。多年来，我曾多次被看似正确但最终是有缺陷的贪心算法欺骗。通常需要仔细的正确性证明，才能区分哪些是正确的，哪些只是看起来对。
- en: Nevertheless, greedy algorithms did make a concealed—and this time correct—appearance
    in [Chapter 6](ch06.xhtml) in the form of Dijkstra’s algorithm. Algorithmists
    generally classify Dijkstra’s algorithm as greedy. Once the algorithm declares
    that a node’s shortest path has been found, it never goes back on that decision.
    It commits, once and for all, and does not let future discoveries influence what
    it has done in the past.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，贪心算法确实在[第6章](ch06.xhtml)中以隐蔽的方式出现了——这一次是正确的，形式上是Dijkstra算法。算法学家通常将Dijkstra算法归类为贪心算法。一旦算法宣告一个节点的最短路径已找到，它就永远不会回到这个决定上。它一旦做出决定，就不允许未来的发现影响过去的决策。
- en: 'Greedy algorithms are now going to reappear. When I was introduced to River
    Jump several years ago, my instinct was that I could use a greedy algorithm to
    solve it. I wonder if you’ll find the proposed algorithm as natural as I did.
    Here’s the greedy rule: find the two rocks that are closest together, remove the
    one that’s closest to its other neighbor rock, and repeat.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心算法将重新出现。几年前，当我第一次接触到河流跳跃问题时，我的直觉是我可以使用贪心算法来解决它。我想知道你是否会觉得提出的算法像我一样自然。这里是贪心规则：找到两块最接近的岩石，移除离其邻近岩石最近的那块，并重复这一过程。
- en: 'Let’s return to the example from the problem description. Here it is as a test
    case:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到问题描述中的例子。这里它作为一个测试用例：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For convenience, here are the rock locations: 0, 5, 8, and 12\. We’re allowed
    to remove one rock. The two rocks that are closest together are those at Locations
    5 and 8, so the greedy rule will result in one of these being removed. The rock
    at Location 8 is a distance of 4 from its neighbor to the right; the rock at Location
    5 is a distance of 5 from its neighbor to the left. Therefore, the greedy algorithm
    removes the rock at Location 8\. It works correctly in this example.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，这里是岩石的位置：0、5、8 和 12。我们允许移除一块岩石。最接近的两块岩石分别位于位置 5 和 8，因此贪心规则将移除其中一块。位置 8
    的岩石与右侧邻居的距离为 4；位置 5 的岩石与左侧邻居的距离为 5。因此，贪心算法会移除位置 8 的岩石。在这个例子中，它是正确的。
- en: 'Let’s throw a bigger example in here and see what the greedy algorithm does.
    Suppose that the river has a length of 12 and we’re allowed to remove two rocks.
    Here’s the test case:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增加一个更大的例子，看看贪心算法会怎么做。假设河流的长度为 12，允许移除两块岩石。这里是测试案例：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The rock locations are 0, 1, 3, 8, 9, and 12\. What will the greedy algorithm
    do? The rocks that are closest together are the ones at Locations 0 and 1 and
    those at Locations 8 and 9\. We’ll have to choose one pair—let’s choose 0 and
    1\. Since removing the rock at Location 0 is not allowed, we remove the rock at
    Location 1\. The remaining rock locations are 0, 3, 8, 9, and 12.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 岩石的位置是 0、1、3、8、9 和 12。贪心算法会怎么做？最接近的岩石分别位于位置 0 和 1，以及位置 8 和 9。我们必须选择一对——我们选择
    0 和 1。由于不允许移除位置 0 的岩石，我们移除位置 1 的岩石。剩下的岩石位置是 0、3、8、9 和 12。
- en: Now the closest rocks are at Locations 8 and 9\. The distance between 9 and
    12 is less than the distance between 8 and 3, so the greedy algorithm removes
    the rock at Location 9\. We’re left with 0, 3, 8, and 12\. The minimum jump distance
    here, and the correct answer, is 3\. The greedy algorithm wins again.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最接近的岩石位于位置 8 和 9。位置 9 和 12 之间的距离小于位置 8 和 3 之间的距离，因此贪心算法会移除位置 9 的岩石。剩下的岩石位置是
    0、3、8 和 12。这里的最小跳跃距离，以及正确答案，是 3。贪心算法再次胜利。
- en: Isn’t that right? Keep knocking off the smallest distance between two rocks.
    How could we possibly do better than that? The greedy algorithm charms.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不是吗？不断移除两块岩石之间最小的距离。我们怎么可能做得比这个更好呢？贪心算法令人着迷。
- en: Sadly, the greedy algorithm is not correct. I encourage you to try to come up
    with a counterexample before I spoil it in the next paragraph.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，贪心算法并不正确。我鼓励你在我在下一段揭示答案之前，尝试找出一个反例。
- en: 'Here’s a counterexample:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个反例：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’re allowed to remove two rocks. The rock locations are 0, 2, 4, 5, 8, and
    12\. The greedy rule identifies the rocks at Locations 4 and 5 as the closest
    rocks. It will remove the rock at Location 4, since the distance between 4 and
    2 is less than the distance between 5 and 8\. Here’s what’s left: 0, 2, 5, 8,
    and 12.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们允许移除两块岩石。岩石的位置是 0、2、4、5、8 和 12。贪心规则识别位置 4 和 5 的岩石为最接近的岩石。由于位置 4 和 2 之间的距离小于位置
    5 和 8 之间的距离，它会移除位置 4 的岩石。剩下的岩石位置是 0、2、5、8 和 12。
- en: Now the greedy rule identifies the rocks at Locations 0 and 2 as the closest
    pair. It isn’t allowed to remove the rock at 0, so it removes the rock at 2\.
    We’re left with 0, 5, 8, and 12\. That’s a minimum jump distance of 3\. Here we
    have a mistake made by the greedy algorithm, because the maximum achievable minimum
    jump distance is 4\. To see this, rather than remove the rocks at Locations 2
    and 4, remove the ones at Locations 2 and 5\. That leaves us with 0, 4, 8, and
    12.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，贪心规则识别位置 0 和 2 的岩石为最接近的一对。由于不允许移除位置 0 的岩石，它移除位置 2 的岩石。剩下的岩石位置是 0、5、8 和 12。这里的最小跳跃距离是
    3。贪心算法犯了一个错误，因为最大可实现的最小跳跃距离是 4。为了证明这一点，不要移除位置 2 和 4 的岩石，而是移除位置 2 和 5 的岩石。那样我们剩下的位置是
    0、4、8 和 12。
- en: What went wrong? By removing the rock at Location 4 as its first move, the greedy
    algorithm creates a situation involving a jump distance of 2 and a jump distance
    of 3\. It can only fix one of those two with its second move, so it has no chance
    of producing a minimum jump distance of anything greater than 3.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在哪儿？通过将位置 4 的岩石作为第一步移除，贪心算法创建了一个涉及跳跃距离 2 和跳跃距离 3 的情况。它只能用第二步修正其中一个，所以它无法产生一个大于
    3 的最小跳跃距离。
- en: I don’t know a greedy algorithm that directly solves this problem. Like Feeding
    Ants, this is a tough one to solve head-on. Fortunately, we don’t have to.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道有哪种贪心算法能直接解决这个问题。像“喂蚁”问题一样，这是一个不容易正面解决的难题。幸运的是，我们不必直接解决它。
- en: '*Testing Feasibility*'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*测试可行性*'
- en: 'In “Binary Search” on [page 240](ch07.xhtml#lev44), I offered two signals that
    point to a binary search solution: that it’s easier to test feasibility than produce
    optimality and that the search space transitions from infeasible to feasible (or
    feasible to infeasible). We’ll see that the River Jump problem passes on both
    counts.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第240页](ch07.xhtml#lev44)的“二分查找”中，我提到过两个信号，指向二分查找的解决方案：测试可行性比求解最优解更容易，并且搜索空间从不可行到可行（或从可行到不可行）。我们将看到，河流跳跃问题在这两方面都符合。
- en: 'Instead of solving for the optimal solution outright, let’s solve for a different
    question: Is it possible to achieve a minimum jump distance of at least *d*? If
    we can nail this, then we can use binary search to find the largest feasible value
    of *d*.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不直接求解最优解，而是先解决另一个问题：是否可以实现至少*d*的最小跳跃距离？如果我们能解决这个问题，那么就可以使用二分查找找到*d*的最大可行值。
- en: 'Here’s the test case that ended the previous subsection:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结束上一小节的测试用例：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’re allowed to remove two rocks. The rock locations are 0, 2, 4, 5, 8, and
    12.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除两块岩石。岩石的位置分别是0、2、4、5、8和12。
- en: 'Here’s a question: What is the minimum number of rock removals that are needed
    to achieve a minimum jump distance of at least 6? Let’s work from left to right
    and check. The rock at Location 0 has to stay—that’s spelled out in the problem
    description. It’s then evident that we have no choice of what to do with the rock
    at Location 2: we must remove it. If we didn’t, then the distance between the
    rocks at Locations 0 and 2 would be less than 6\. So, one rock is removed. The
    remaining rocks are at 0, 4, 5, 8, and 12.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题：为了实现至少6的最小跳跃距离，最少需要移除多少块岩石？我们从左到右检查。位置0的岩石必须保留——这一点在问题描述中已明确指出。接下来，很明显我们无法选择如何处理位置2的岩石：我们必须移除它。如果不移除，它将导致位置0和位置2之间的距离小于6。因此，我们移除了一块岩石。剩下的岩石是0、4、5、8和12。
- en: Now, consider the rock at Location 4—do we keep it or remove it? Again, we’re
    forced to remove it. If we keep it, then the rocks at Locations 0 and 4 would
    be closer together than 6\. That’s our second removal, and we’re left with rocks
    at 0, 5, 8, and 12.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑位置4的岩石——我们是保留它还是移除它？我们再次被迫移除它。如果我们保留它，那么位置0和位置4之间的距离将小于6。这是我们的第二次移除，剩下的岩石是0、5、8和12。
- en: The rock at Location 5 has to be removed, too, because it’s only a distance
    of 5 from the 0 rock. That’s our third removal, leaving us with rocks at 0, 8,
    and 12.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 位置5的岩石也必须移除，因为它距离位置0的岩石只有5的距离。这是我们的第三次移除，剩下的岩石是0、8和12。
- en: We have to remove the rock at Location 8, too! It’s far enough from Location
    0 but too close to Location 12\. That’s our fourth removal, ultimately leaving
    us with just two rocks at 0 and 12.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 位置8的岩石也必须移除！它距离位置0足够远，但离位置12太近。这是我们的第四次移除，最终只剩下0和12两块岩石。
- en: So it takes four removals to achieve a minimum jump distance of at least 6,
    but we’re only allowed to remove two rocks. As such, 6 is not a feasible solution.
    It’s too big.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所以需要四次移除才能实现至少6的最小跳跃距离，但我们只能移除两块岩石。因此，6不是一个可行的解决方案。它太大了。
- en: Is 3 a feasible solution? That is, can we achieve a minimum jump distance of
    at least 3 by removing two rocks? Let’s see.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 3是一个可行的解决方案吗？也就是说，通过移除两块岩石，能实现至少3的最小跳跃距离吗？我们来看看。
- en: 'The rock at Location 0 stays. The rock at Location 2 has to go. That’s our
    first removal, and it leaves us with this: 0, 4, 5, 8, and 12.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 位置0的岩石保留。位置2的岩石必须移除。这是我们的第一次移除，剩下的岩石是0、4、5、8和12。
- en: 'The rock at Location 4 can stay: it’s more than a distance of 3 from Location
    0\. The rock at Location 5, though, has to go, because it’s too close to the rock
    at Location 4\. That’s our second removal, giving us this: 0, 4, 8, and 12.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 位于位置4的岩石可以保留：它距离位置0的距离大于3。但是，位置5的岩石必须移除，因为它离位置4的岩石太近。这是我们的第二次移除，剩下的岩石是：0、4、8和12。
- en: 'The rock at Location 8 is fine: it’s far enough away from the rocks at Locations
    4 and 12\. We’re done: it took us only two removals to achieve a minimum jump
    distance of at least 3\. So, 3 is feasible.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 位置8的岩石没有问题：它与位置4和位置12的距离足够远。我们完成了：我们只需移除两块岩石，就能实现至少3的最小跳跃距离。所以，3是可行的。
- en: 'We seem to be homing in on a greedy algorithm for checking feasibility. The
    rule is this: consider each rock in order, and remove it if it’s too close to
    the previously kept rock. Also check the rightmost rock that we kept, and remove
    it if it’s too close to the end of the river. Then, count the number of rocks
    that we removed; that count tells us whether the proposed minimum jump distance
    is feasible given the number of rocks we’re allowed to remove. (To be clear, this
    is a proposed greedy algorithm for checking feasibility of a specified jump distance,
    not for finding the optimal solution in one shot.)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们似乎正在朝着一个检查可行性的贪心算法靠近。规则是这样的：按顺序考虑每块岩石，如果它离之前保留的岩石太近，就移除它。同时检查我们保留的最右边的岩石，如果它离河流的尽头太近，就移除它。然后，计算我们移除的岩石数量；这个数量告诉我们，在允许移除的岩石数量下，所提议的最小跳跃距离是否可行。（需要明确的是，这是一个检查指定跳跃距离可行性的贪心算法提议，而不是一次性找到最优解的算法。）
- en: The code for this algorithm is in [Listing 7-4](ch07.xhtml#ch07ex04).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的代码在[清单 7-4](ch07.xhtml#ch07ex04)中。
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 7-4: Testing the feasibility of the jump distance*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-4：测试跳跃距离的可行性*'
- en: 'The function has five parameters:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数有五个参数：
- en: distance   The minimum jump distance whose feasibility we’re testing
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: distance   我们正在测试可行性的最小跳跃距离
- en: rocks   An array giving the location of each rock, not including the rocks at
    the beginning and end of the river
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: rocks   一个数组，给出每块岩石的位置，河流的起始和结束岩石不包括在内
- en: num_rocks   The number of rocks in the `rocks` array
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: num_rocks   `rocks`数组中岩石的数量
- en: num_remove   The number of rocks that we’re allowed to remove
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: num_remove   我们允许移除的岩石数量
- en: length   The length of the river
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: length   河流的长度
- en: The function returns `1` (true) if `distance` is a feasible solution and returns
    `0` otherwise.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`distance`是一个可行的解，函数返回`1`（真），否则返回`0`。
- en: The variable `prev_rock_location` tracks the location of the most recent rock
    that we’ve kept. Inside the `for` loop, `cur_rock_location` holds the location
    of the rock that we’re currently considering. We then have our crucial test to
    determine whether to keep or remove the current rock ➊. If the current rock is
    too close to the previous rock, then we remove the current rock and increase the
    number of removals by one. Otherwise, we keep the current rock and update `prev_rock_location`
    accordingly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`prev_rock_location`跟踪我们保留的最新岩石的位置。在`for`循环内部，`cur_rock_location`保存我们当前考虑的岩石的位置。接下来我们进行关键的测试，决定是否保留或移除当前岩石
    ➊。如果当前岩石离前一个岩石太近，那么我们移除当前岩石，并将移除次数加一。否则，我们保留当前岩石，并相应地更新`prev_rock_location`。
- en: When the loop terminates, we’ve counted the number of rocks that we must remove.
    Well . . . almost. We still need to check whether the rightmost rock that we’ve
    kept is too close to the end of the river ➋. If it is, then we remove that rock.
    (Don’t worry about the possibility of removing the rock at Location 0\. If we
    really have removed all the rocks, then `prev_rock_location` will be 0\. However,
    `length - 0 < distance` cannot be true; if it were, then we would have returned
    in the `if` statement at the start of the function.)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环终止时，我们已经计算出必须移除的岩石数量。好吧……差不多。我们还需要检查我们保留的最右边的岩石是否离河流的尽头太近 ➋。如果太近，我们就移除那块岩石。（不用担心移除位置
    0 处的岩石。如果我们真的已经移除所有岩石，那么`prev_rock_location`会是 0。但是，`length - 0 < distance`不可能为真；如果是这样，程序在函数开头的`if`语句就会提前返回。）
- en: Now we have no rocks within the minimum jump distance of each other, and we
    have not removed rocks unnecessarily. How could we possibly do better than that?
    The greedy algorithm charms . . . but here we go again. The last time this occurred,
    in “A Greedy Idea” on [page 244](ch07.xhtml#sec105), the greedy algorithm turned
    out to be incorrect. Don’t be convinced by a couple of examples where things happen
    to work out. Don’t let me sweet-talk you into believing that everything is okay.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确保了没有岩石彼此之间的最小跳跃距离过近，且没有不必要地移除岩石。我们怎么可能做得比这更好呢？贪心算法的魅力……不过，我们又来了。上次发生这种情况时，在[第244页](ch07.xhtml#sec105)的《贪心思路》一节中，贪心算法结果是错误的。不要被几个巧合成功的例子说服。不要让我用甜言蜜语让你相信一切都好。
- en: Before moving on, I’d like to give a fairly precise argument for why this greedy
    algorithm is correct. Specifically, I’ll show that it removes the minimum number
    of rocks required to achieve a minimum jump distance of at least *d*. I’ll assume
    that *d* is at most the length of the river; otherwise, the greedy algorithm immediately
    and correctly determines that a minimum jump distance of *d* is infeasible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想给出一个相当精确的论证，说明为什么这个贪心算法是正确的。具体来说，我将展示它移除了为实现至少*d*的最小跳跃距离所需的最少岩石数量。我将假设*d*最大为河流的长度；否则，贪心算法会立即并正确地判断实现至少*d*的最小跳跃距离是不可行的
- en: 'For each rock from left to right, our greedy algorithm decides whether to keep
    the rock or remove it. Our goal will be to show that it matches, step for step,
    what an optimal solution does. When the greedy algorithm decides to keep a rock,
    we’ll show that an optimal solution keeps that rock, too. When the greedy algorithm
    decides to remove a rock, we’ll show that an optimal solution removes that rock,
    too. If the greedy algorithm does exactly what an optimal solution does, then
    what we get from it must be correct. In this example, “optimal” will be used to
    refer to an optimal solution. For each rock, we have four possibilities: greedy
    and optimal both remove the rock, greedy and optimal both keep the rock, greedy
    removes it but optimal keeps it, and greedy keeps it but optimal removes it. We
    have to show that the third and fourth cases cannot actually occur.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从左到右的每块岩石，我们的贪心算法决定是保留岩石还是移除它。我们的目标是展示它与最优解的每一步操作一致。当贪心算法决定保留一块岩石时，我们将展示最优解也保留那块岩石。当贪心算法决定移除一块岩石时，我们将展示最优解也移除那块岩石。如果贪心算法做的与最优解完全相同，那么它得到的结果一定是正确的。在这个例子中，“最优解”将用来指代最优解。对于每块岩石，我们有四种可能性：贪心算法和最优解都移除岩石，贪心算法和最优解都保留岩石，贪心算法移除它但最优解保留它，贪心算法保留它但最优解移除它。我们必须证明第三种和第四种情况不可能发生。
- en: 'Before we proceed to the four cases, consider again removing two rocks from
    these rock locations: 0, 2, 4, 5, 8, and 12\. When asked whether it’s possible
    to achieve a minimum jump distance of at least 3, we have seen that greedy will
    remove the rocks at Locations 2 and 5, leaving us with 0, 4, 8, and 12\. So we
    might expect that the optimal solution is also to remove the same two rocks. Although
    that is optimal, another optimal solution is to remove the rocks at Locations
    2 and 4, resulting in these rocks: 0, 5, 8, and 12\. That’s another way to get
    a minimum distance of at least 3 by removing two rocks, and it’s as good as what
    the greedy algorithm produces. Rather than match *the* optimal solution, we’ll
    be just as happy matching *an* optimal solution. We don’t care which one greedy
    matches: all optimal solutions are equally optimal.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论四种情况之前，再次考虑从这些岩石位置移除两块岩石：0, 2, 4, 5, 8, 和 12。当问是否有可能实现至少3的最小跳跃距离时，我们已经看到贪心算法会移除位置2和5的岩石，剩下的位置是0,
    4, 8, 和12。所以我们可能会预期最优解也会移除这两块岩石。尽管这是最优解，另一种最优解是移除位置2和4的岩石，剩下的位置是0, 5, 8, 和12。这是另一种通过移除两块岩石来实现至少3的最小距离的方法，并且它和贪心算法产生的结果一样好。与其匹配*那个*最优解，我们同样高兴地匹配*一个*最优解。我们不关心贪心算法匹配哪个最优解：所有最优解都是等价的最优解。
- en: 'We have some optimal solution *S* that we want greedy to match. Greedy starts
    running, and for some time there are no discrepancies: it does whatever *S* does.
    Greedy at least does the right thing for the rock at Location 0: that one has
    to stay, no matter what.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个我们希望贪心算法匹配的最优解*S*。贪心算法开始运行，一段时间内没有出现差异：它做的和*S*做的一样。贪心算法至少在位置0的岩石上做了正确的事：那块岩石无论如何都必须保留。
- en: Greedy is thus looking at the rocks from left to right, doing the right stuff,
    keeping rocks and removing rocks just like optimal solution *S* . . . and then,
    boom, greedy and *S* disagree on what to do with some rock. We think about the
    *first* rock on which greedy and *S* disagree.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，贪心算法从左到右查看岩石，做正确的事情，保留岩石和移除岩石，就像最优解*S*一样……然后，哗啦，贪心算法和*S*在处理某些岩石时产生了分歧。我们考虑一下贪心算法和*S*产生分歧的*第一*块岩石。
- en: '**Greedy removes it, but optimal keeps it.**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**贪心算法移除它，但最优解保留它。**'
- en: 'The greedy algorithm only removes a rock when it’s too close to another rock.
    If greedy removes a rock because it’s less than *d* from the rock to the left,
    then *S* must have removed the rock, too. Because this is the first disagreement,
    *S* includes exactly the same rocks to the left as greedy. So if *S* did not remove
    the rock, then it would have two rocks within a distance of less than *d*. However,
    that can’t happen: *S* is an optimal (and necessarily feasible) solution where
    all distances between rocks are at least *d*. We can conclude that *S* really
    does remove the rock, agreeing with greedy. Similar reasoning shows that, if greedy
    removes a rock because it’s too close to the end of the river, then *S* must remove
    it, too.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心算法只会在石头距离另一块石头太近时才移除它。如果贪心算法移除了一块石头，因为它离左边的石头小于*d*，那么*S*也一定移除了那块石头。因为这是第一次不一致，*S*包含了和贪心算法相同的左侧石头。所以如果*S*没有移除这块石头，那它就会有两块石头的距离小于*d*。然而，这是不可能的：*S*是一个最优（并且必然可行的）解，其中所有石头之间的距离至少为*d*。因此，我们可以得出结论，*S*确实移除了那块石头，和贪心算法一致。类似的推理表明，如果贪心算法移除一块石头，因为它离河流的尽头太近，那么*S*也一定会移除它。
- en: '**Greedy keeps it, but optimal removes it.**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**贪心算法保留它，但最优算法移除它。**'
- en: We’re not going to be able to make greedy and *S* match here, but that’s okay,
    because we’ll be able to form a new optimal solution *U* that keeps this rock.
    Let *r* be the current rock; the one that greedy keeps and *S* removes. Think
    about a new set of rocks *T* that has exactly the same rocks as *S* plus rock
    *r*. Therefore, *T* removes one fewer rock than *S*. Because of this, *T* can’t
    be a feasible solution. If it were, then it would be better (by one rock) than
    *S*, contradicting the fact that *S* is an optimal solution. Since the only difference
    between *S* and *T* is that *T* has rock *r*, it must be *r* that causes *T* to
    be infeasible. Therefore, in *T*, *r* must be closer than *d* to rock *r*[2] to
    its right. We know that *r*[2] can’t be the rock at the end of the river, because
    then greedy wouldn’t have kept *r* (as *r* would be too close to the end of the
    river). So *r*[2] is some rock that is allowed to be removed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能让贪心算法和*S*在这里匹配，但没关系，因为我们可以形成一个新的最优解*U*，它保留了这块石头。设*r*为当前的石头；贪心算法保留的，而*S*移除的。考虑一个新的石头集合*T*，它包含了和*S*完全相同的石头，外加石头*r*。因此，*T*比*S*少移除了一块石头。正因为如此，*T*不可能是一个可行解。如果是的话，那它就比*S*（多了一块石头）更好，这与*S*是最优解的事实相矛盾。由于*S*和*T*之间唯一的不同是*T*有石头*r*，所以一定是*r*导致了*T*不可行。因此，在*T*中，*r*必须比石头*r*[2]更接近右边的石头*r*[2]。我们知道，*r*[2]不可能是河流的尽头的石头，因为那样贪心算法就不会保留*r*（因为*r*会离河流尽头太近）。因此，*r*[2]是允许被移除的某个石头。
- en: 'Now, think about another new set of rocks *U* that has exactly the same rocks
    as *T* except that it doesn’t have *r*[2]. We can say that *U* has the same number
    of rocks as *S*: we added one rock *r* to *S* to get *T*, and we removed one rock
    *r*[2] from *T* to get *U*. Also, *U* has no rocks that are less than a distance
    of *d* apart, because it doesn’t include the offending rock *r*[2]. That is, *U*
    is an optimal solution, just like *S*. Crucially, *U* contains rock *r*! So greedy
    agrees with optimal solution *U* to include *r*.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑另一个新的石头集合*U*，它和*T*完全相同，只是它没有石头*r*[2]。我们可以说，*U*和*S*包含相同数量的石头：我们从*S*中加入了一块石头*r*，得到*T*，然后从*T*中移除了一块石头*r*[2]，得到*U*。此外，*U*没有任何距离小于*d*的石头，因为它不包含那块问题石头*r*[2]。也就是说，*U*是一个最优解，就像*S*一样。关键是，*U*包含石头*r*！因此，贪心算法同最优解*U*一致，保留了*r*。
- en: 'Let’s give our feasibility tester a whirl before we continue. Here’s how to
    call it on the example that we used throughout this section:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们先测试一下可行性测试器。这是如何在我们整个章节中使用的示例上调用它的方法：
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code above asks whether it’s possible to achieve a minimum jump distance
    of at least 6 by removing two rocks. The answer is “no,” so you should see `0`
    (false) as the output. Change the first argument from `6` to `3`, and now you’re
    asking whether a minimum jump distance of at least 3 is feasible. Run the program
    again, and you should see `1` (true).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码问是否可能通过移除两块石头来达到至少6的最小跳跃距离。答案是“不行”，所以输出应该是`0`（假）。将第一个参数从`6`改为`3`，现在你在问是否能够实现至少3的最小跳跃距离。再次运行程序，输出应该是`1`（真）。
- en: 'Excellent: now we have a way to check feasibility. It’s time to bring out binary
    search to give us optimality.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 很好：现在我们有了一种检查可行性的方法。是时候使用二分查找来为我们提供最优解了。
- en: '*Searching for a Solution*'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*寻找解法*'
- en: To use binary search, let’s adapt the code from [Listing 7-3](ch07.xhtml#ch07ex03).
    In Feeding Ants, we had to achieve four digits of accuracy after the decimal point.
    Here, however, we’re looking to optimize the minimum jump distance, and that’s
    guaranteed to be an integer value because all rocks are at integer locations.
    So we’ll stop when `high` and `low` are within one, rather than within the four
    decimal digits. [Listing 7-5](ch07.xhtml#ch07ex05) gives the new code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用二分查找，让我们改编[示例 7-3](ch07.xhtml#ch07ex03)中的代码。在“喂蚁”问题中，我们需要在小数点后达到四位精度。然而在这里，我们希望优化最小跳跃距离，而这一定是一个整数值，因为所有岩石的位置都是整数。所以，我们将在`high`和`low`之间的差值为1时停止，而不是达到四个小数位的精度。[示例
    7-5](ch07.xhtml#ch07ex05)给出了新的代码。
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 7-5: Searching for the optimal solution (bugged!)*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-5：搜索最优解（有错误！）*'
- en: On each iteration, we calculate the midpoint `mid` of the range, and we use
    our helper function to test its feasibility ➊.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，我们计算范围的中点`mid`，并使用我们的辅助函数测试它的可行性 ➊。
- en: 'If `mid` is feasible, then everything less than `mid` is also feasible, so
    we update `low` to cut off the low half of the range ➋. Notice the contrast to
    [Listing 7-3](ch07.xhtml#ch07ex03): there, a feasible `mid` means that everything
    greater than `mid` is feasible, so we cut off the high half of the range instead.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`mid`是可行的，那么所有小于`mid`的值也是可行的，因此我们更新`low`，以切掉范围的下半部分 ➋。注意与[示例 7-3](ch07.xhtml#ch07ex03)的对比：在那里，一个可行的`mid`意味着所有大于`mid`的值都是可行的，所以我们切掉的是范围的上半部分。
- en: If `mid` is infeasible, then everything greater than `mid` is also infeasible,
    so we update `high` to cut off the high half of the range ➌.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`mid`是不可行的，那么所有大于`mid`的值也都是不可行的，因此我们更新`high`，以切掉范围的上半部分 ➌。
- en: 'Unfortunately, this binary search is not correct. To see why, run it on this
    test case:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个二分查找并不正确。要了解原因，可以在这个测试用例上运行它：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should get an output of `5`, but the optimal solution is in fact `4`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个`5`的输出，但最优解实际上是`4`。
- en: Ahh, I know what to do. Let’s change the `printf` call at the bottom to output
    `low` instead of `high`. When the loop terminates, `low` will be one less than
    `high`, so this change will result in an output of `4` instead of `5`. The new
    code is given in [Listing 7-6](ch07.xhtml#ch07ex06).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，我知道该怎么做了。让我们将底部的`printf`调用修改为输出`low`而不是`high`。当循环终止时，`low`将比`high`小1，因此这一更改将导致输出`4`而不是`5`。新的代码见[示例
    7-6](ch07.xhtml#ch07ex06)。
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 7-6: Searching for the optimal solution (still bugged!)*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-6：搜索最优解（仍有错误！）*'
- en: 'That fixes the problematic test case, but now we get this test case wrong:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了有问题的测试用例，但现在我们会错过这个测试用例：
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is a perfectly valid test case, if a little strange: the length of the
    river is 12, and there are no rocks. The maximum achievable minimum jump distance
    is 12, but our binary search returns `11` on this example. Again, we are off by
    one.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全有效的测试用例，虽然有点奇怪：河流的长度是12，而且没有岩石。最大可达到的最小跳跃距离是12，但我们的二分查找在这个示例中返回了`11`。再次地，我们差了一。
- en: Binary search is legendarily difficult to implement correctly. Should that `>`
    be a `>=`? Should that be a `mid` or a `mid + 1`? Do we want `low + high` or `low
    + high + 1`? If you keep on with binary search problems, you’ll grapple with all
    of this eventually. I don’t know any other algorithm with the bug-density potential
    of binary search.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找被认为是极难正确实现的。那里的`>`应该改成`>=`吗？应该是`mid`还是`mid + 1`？我们想要的是`low + high`还是`low
    + high + 1`？如果你继续研究二分查找问题，你最终会遇到这些问题。我不知道还有哪个算法的错误密度像二分查找这么高。
- en: Let’s be a little more careful for our next attempt. Suppose we knew at all
    times that `low` and everything smaller than `low` are feasible and that `high`
    and everything larger than `high` are infeasible. Such a claim is called an *invariant*,
    which simply means that it’s always true as the code runs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一次尝试时小心一些。假设我们始终知道`low`及所有小于`low`的值是可行的，而`high`及所有大于`high`的值是不可行的。这样的声明叫做*不变式*，它意味着在代码运行时始终为真。
- en: 'When the loop terminates, `low` will be one less than `high`. If we’ve managed
    to maintain our invariant, then we know that `low` is feasible. We also know that
    nothing greater than `low` can be feasible: `high` is next, and the invariant
    tells us that `high` is infeasible. So `low` will be the maximum feasible value,
    and we’ll need to output `low`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环终止时，`low`将比`high`小1。如果我们成功地保持了不变式，那么我们知道`low`是可行的。我们还知道，`low`之后的任何值都不可能是可行的：接下来是`high`，而不变式告诉我们`high`是不可行的。所以`low`将是最大可行值，我们需要输出`low`。
- en: However, in all of this we assume that we can make this invariant true at the
    beginning of the code and keep it true at all times thereafter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这一切中，我们假设我们可以在代码开始时使不变式成立，并且之后始终保持它成立。
- en: 'Let’s start with the code above the loop. This code does *not* necessarily
    make the invariant true:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从循环之前的代码开始。这段代码*并不*一定能使不变式成立：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Is `low` feasible? Certainly! A minimum jump distance of at least 0 is always
    achievable, because every jump has a nonzero distance. Is `high` infeasible? Well,
    it could be, but what if we can jump the whole river after we remove the allowed
    number of rocks? Then `length` is feasible, and our invariant is broken. Here’s
    a better initialization:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`low`是可行的吗？当然可以！至少为0的最小跳跃距离总是可以实现的，因为每次跳跃都有非零的距离。`high`是不可行的吗？嗯，可能是的，但如果我们在移除允许的岩石数量后能跳过整个河流呢？那么`length`就是可行的，我们的不变式被打破了。这里是一个更好的初始化方法：'
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now `high` certainly isn’t feasible: we can’t achieve a minimum jump distance
    of `length + 1` when the river is only of length `length`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`high`显然是不可行的：当河流的长度为`length`时，我们无法实现最小跳跃距离为`length + 1`。
- en: We next have to figure out what to do for the two possibilities in the loop.
    If `mid` is feasible, then we can set `low = mid`. The invariant is okay, because
    `low` and everything to its left are feasible, and, if `mid` is not feasible,
    then we can set `high = mid`. The invariant is again okay, because `high` and
    everything to its right are infeasible. Thus, in both cases, we maintain the invariant.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要解决循环中的两种可能性。如果`mid`是可行的，那么我们可以设置`low = mid`。不变式是成立的，因为`low`及其左侧的所有值都是可行的；如果`mid`不可行，那么我们可以设置`high
    = mid`。不变式仍然成立，因为`high`及其右侧的所有值都是不可行的。因此，在这两种情况下，我们都保持不变式。
- en: We now see that nothing in the code invalidates the invariant, and so we’re
    safe to output `low` when the loop terminates. The correct code is given in [Listing
    7-7](ch07.xhtml#ch07ex07).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到，代码中没有任何东西使不变式失效，因此当循环结束时，我们可以安全地输出`low`。正确的代码见[清单 7-7](ch07.xhtml#ch07ex07)。
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 7-7: Searching for the optimal solution*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-7：搜索最优解*'
- en: For a river of length *L*, we’re calling `can_make_min_distance` a total of
    log *L* times. If we have *n* rocks, then `can_make_min_distance` ([Listing 7-4](ch07.xhtml#ch07ex04))
    takes *O*(*n*) time. Therefore, our solution to this problem is an *O*(*n* log
    *L*) algorithm.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长度为*L*的河流，我们总共调用`can_make_min_distance`大约log *L*次。如果我们有*n*个岩石，那么`can_make_min_distance`（见[清单
    7-4](ch07.xhtml#ch07ex04)）的时间复杂度是*O*(*n*)。因此，解决这个问题的算法时间复杂度是*O*(*n* log *L*)。
- en: '*Reading the Input*'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*读取输入*'
- en: We’re nearly there. All that’s left is to read the input and call `solve`. The
    code is provided in [Listing 7-8](ch07.xhtml#ch07ex08).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快到了。剩下的就是读取输入并调用`solve`。代码见[清单 7-8](ch07.xhtml#ch07ex08)。
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 7-8: The* main *function for reading the input*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-8：读取输入的主函数*'
- en: We’ve been analyzing this problem by thinking about locations of rocks from
    left to right, that is, from smallest location to largest location. However, the
    rocks could come from the input in any order. Nothing in the problem description
    guarantees that they’ll be sorted.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直通过从左到右思考岩石的位置来分析这个问题，即从最小位置到最大位置。然而，岩石的输入顺序是任意的。问题描述中没有任何保证岩石会按顺序排列。
- en: It’s been a while, but we did use `qsort` to sort nodes in [Chapter 2](ch02.xhtml)
    when solving the Descendant Distance problem. Sorting rocks is a little easier
    than sorting those nodes. Our comparison function `compare` takes pointers to
    two integers, and it returns the result of subtracting the second from the first.
    This leads to a negative integer if the first integer is smaller than the second,
    `0` if the two integers are equal, and a positive integer if the first integer
    is larger than the second. We use `qsort` with this comparison function to sort
    the rocks ➊. We then call `solve` with the array of sorted rocks.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 过去一段时间了，但我们在[第2章](ch02.xhtml)解决后代距离问题时确实使用了`qsort`对节点进行排序。排序岩石比排序那些节点要容易一些。我们的比较函数`compare`接受两个整数指针，并返回第二个减去第一个的结果。如果第一个整数小于第二个，它返回负整数；如果两个整数相等，则返回`0`；如果第一个整数大于第二个，它返回正整数。我们使用这个比较函数和`qsort`对岩石进行排序
    ➊。然后我们用排序后的岩石数组调用`solve`。
- en: If you submit this solution to the judge, then you should see that all test
    cases pass.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个解决方案提交给判题系统，你应该能看到所有测试用例都通过了。
- en: 'Problem 3: Living Quality'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 3：生活质量
- en: 'So far in this chapter, we’ve seen two approaches to check feasibility: a recursive
    traversal of a tree and a greedy algorithm. Now, we’ll see an example where we’ll
    use ideas from dynamic programming ([Chapter 3](ch03.xhtml)) to efficiently check
    feasibility.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中我们已经看到了两种检查可行性的方法：树的递归遍历和贪心算法。现在，我们将看到一个例子，其中我们将使用动态编程（[第 3 章](ch03.xhtml)）中的思想来高效地检查可行性。
- en: 'This is the first problem in the book where we don’t read from standard input
    or write to standard output. We’ll write a function with a name specified by the
    judge. In lieu of standard input, we’ll use an array passed by the judge. In lieu
    of standard output, we’ll return the correct value from our function. This is
    rather nice: we won’t have to bother with `scanf` and `printf` at all!'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中的第一个问题，我们不需要从标准输入读取数据，也不需要写入标准输出。我们将编写一个函数，函数名由裁判指定。我们将使用裁判传递的数组代替标准输入，使用函数返回的正确值代替标准输出。这样做非常好：我们根本不需要麻烦
    `scanf` 和 `printf`！
- en: Incidentally, this will also be our first problem from a world championship
    programming competition (IOI 2010). You’ve got this!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这也是我们在世界冠军编程竞赛（IOI 2010）中的第一个问题。你一定能搞定！
- en: This is DMOJ problem `ioi10p3`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `ioi10p3`。
- en: '*The Problem*'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题描述*'
- en: A city consists of a rectangular grid of blocks. Each block is identified by
    its row and column coordinates. There are *r* rows numbered 0 to *r* – 1 from
    top to bottom and *c* columns numbered 0 to *c* – 1 from left to right.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 城市由一个矩形网格的块组成。每个块由它的行和列坐标标识。城市有 *r* 行，从上到下编号为 0 到 *r* – 1，并且有 *c* 列，从左到右编号为
    0 到 *c* – 1。
- en: Each block has been given a distinct *quality rank* between 1 and *rc*. For
    example, if we have seven rows and seven columns, then the ranks of each block
    will be some permutation of the numbers from 1 to 49\. See [Table 7-1](ch07.xhtml#ch07tab1)
    for an example city.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块都有一个唯一的*质量排名*，其值在 1 到 *rc* 之间。例如，如果我们有七行七列，那么每个块的排名将是从 1 到 49 的某种排列。请参见[表
    7-1](ch07.xhtml#ch07tab1)中的城市示例。
- en: '**Table 7-1:** A Sample City'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1:** 一个示例城市'
- en: '|   | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|   | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | 48 | 16 | 15 | 45 | 40 | 28 | 8 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 48 | 16 | 15 | 45 | 40 | 28 | 8 |'
- en: '| **1** | 20 | 11 | 36 | 19 | 24 | 6 | 33 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 20 | 11 | 36 | 19 | 24 | 6 | 33 |'
- en: '| **2** | 22 | 39 | 30 | 7 | 9 | 1 | 18 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 22 | 39 | 30 | 7 | 9 | 1 | 18 |'
- en: '| **3** | 14 | 35 | 2 | 13 | 31 | 12 | 46 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **3** | 14 | 35 | 2 | 13 | 31 | 12 | 46 |'
- en: '| **4** | 32 | 37 | 21 | 3 | 41 | 23 | 29 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **4** | 32 | 37 | 21 | 3 | 41 | 23 | 29 |'
- en: '| **5** | 42 | 49 | 38 | 10 | 17 | 47 | 5 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **5** | 42 | 49 | 38 | 10 | 17 | 47 | 5 |'
- en: '| **6** | 43 | 4 | 34 | 25 | 26 | 27 | 44 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **6** | 43 | 4 | 34 | 25 | 26 | 27 | 44 |'
- en: 'The *median quality rank* of a rectangle is the quality rank such that half
    of the quality ranks in the rectangle are smaller and half are larger. For example,
    consider the five-row-by-three-column (5×3) rectangle in the top left of [Table
    7-1](ch07.xhtml#ch07tab1). It consists of 15 quality ranks: 48, 16, 15, 20, 11,
    36, 22, 39, 30, 14, 35, 2, 32, 37, and 21\. The median quality rank is 22, because
    seven numbers are less than 22 and the other seven are greater.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形的*中位数质量排名*是指该矩形中一半质量排名小于它，另一半质量排名大于它。例如，考虑[表 7-1](ch07.xhtml#ch07tab1)左上角的五行三列（5×3）矩形。它由
    15 个质量排名组成：48、16、15、20、11、36、22、39、30、14、35、2、32、37 和 21。中位数质量排名是 22，因为有七个数字小于
    22，另外七个大于 22。
- en: We’ll be provided integers *h* and *w* that specify the height (number of rows)
    and width (number of columns) of candidate rectangles. Our task is to identify
    the minimum median quality rank of any rectangle with *h* rows and *w* columns.
    (In this problem, low-quality ranks correspond to high qualities; finding the
    minimum median quality rank therefore corresponds to finding a high-quality living
    area of the city.)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到整数 *h* 和 *w*，它们分别指定候选矩形的高度（行数）和宽度（列数）。我们的任务是确定任意一个 *h* 行 *w* 列矩形的最小中位数质量排名。（在这个问题中，低质量排名对应于高质量；因此，找到最小的中位数质量排名实际上对应于找到一个高质量的城市生活区。）
- en: Let’s use (*x*, *y*) to refer to row *x*, column *y*. Suppose *h* is 5 and *w*
    is 3\. Then, for the city in [Table 7-1](ch07.xhtml#ch07tab1), we would identify
    13 as the minimum median quality rank. The rectangle whose median quality rank
    is 13 is the one whose top-left coordinate is (1, 3) and whose bottom-right coordinate
    is (5, 5).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 (*x*, *y*) 来表示第 *x* 行，第 *y* 列。假设 *h* 为 5，*w* 为 3。那么，对于[表 7-1](ch07.xhtml#ch07tab1)中的城市，我们会将
    13 作为最小的中位数质量排名。中位数质量排名为 13 的矩形的左上坐标是 (1, 3)，右下坐标是 (5, 5)。
- en: Input
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'There’s nothing to read from standard input. Everything we need will come from
    the judge through function parameters. Here’s the signature for the function that
    we’ll write:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入中没有任何需要读取的内容。我们所需的所有信息都将通过函数参数从评测系统传入。以下是我们将要编写的函数签名：
- en: '[PRE23]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, `r` and `c` are the numbers of rows and columns in the city, respectively.
    Similarly, `h` and `w` are the numbers of rows and columns in the candidate rectangles,
    respectively; `h` will be at most `r` and `w` will be at most `c`. It’s also guaranteed
    that `h` and `w` will be odd numbers. (Why is that? Since multiplying two odd
    numbers results in an odd number, *hw*, the number of blocks in a candidate rectangle,
    will be an odd number. The median is precisely defined in this case: the quality
    rank such that half of the remaining quality ranks are smaller and the other half
    are larger. What if we had an even number of quality ranks, such as the four ranks
    2, 6, 4, and 5? What would the median be? We’d have to choose between 4 and 5\.
    The problem author has spared us this choice.)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`r` 和 `c` 分别是城市的行数和列数。同样，`h` 和 `w` 分别是候选矩形的行数和列数；`h` 最多为 `r`，`w` 最多为 `c`。并且保证
    `h` 和 `w` 都是奇数。（为什么是奇数呢？因为两个奇数相乘结果是奇数，所以候选矩形的块数 *hw* 将是奇数。在这种情况下，中位数是精确定义的：质量等级的中位数，即剩余质量等级中有一半小于它，另一半大于它。如果我们有一个偶数个质量等级，比如
    2、6、4 和 5，这时的中位数会是什么？我们将不得不在 4 和 5 之间做出选择。好在问题作者为我们省去了这个选择。）
- en: 'The final parameter `q` gives the quality rank of the blocks. For example,
    `q[2][3]` gives the quality of the block at row 2, column 3\. Notice how the dimensions
    on `q` tell us the maximum number of rows and columns in the city: 3,001, in each
    case.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的参数 `q` 给出了块的质量等级。例如，`q[2][3]` 给出了第 2 行第 3 列块的质量等级。注意 `q` 上的维度告诉我们城市中的最大行数和列数：每个方向都是
    3,001。
- en: Output
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: We won’t produce anything on standard output. Instead, from the `rectangle`
    function just described, we’ll return the minimum median quality rank.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在标准输出上生成任何内容。相反，在刚才描述的 `rectangle` 函数中，我们将返回最小的中位质量等级。
- en: The time limit for solving the test case is 4.5 seconds.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 解答测试用例的时间限制为 4.5 秒。
- en: '*Sorting Every Rectangle*'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*排序每个矩形*'
- en: It’s hard to make much progress toward an efficient solution that doesn’t use
    binary search, but we’ll try here, anyway. It’ll give us practice looping through
    all of the candidate rectangles. We’ll get to binary search in the next subsection.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用二分查找，朝着高效解决方案的方向推进会很困难，但我们还是要尝试一下。这样做会让我们练习遍历所有候选矩形。接下来的小节我们会讨论二分查找。
- en: 'To start, we need a couple of constants and a type definition:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些常量和类型定义：
- en: '[PRE24]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Much as we did in [Chapter 5](ch05.xhtml), we’ll use `board` whenever we need
    a two-dimensional array of the correct size.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第5章](ch05.xhtml)中做的那样，每当我们需要一个正确大小的二维数组时，我们将使用 `board`。
- en: Suppose you are given the top-left and bottom-right coordinates of a rectangle
    and asked to determine the median quality rank of its blocks. How can you do it?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你给定了一个矩形的左上角和右下角坐标，并要求你计算该矩形中各个块的中位质量等级。你该如何做呢？
- en: 'Sorting can help. Sort the quality ranks from smallest to largest, and then
    pick out the element at the middle index. For example, say we have these 15 quality
    ranks again: 48, 16, 15, 20, 11, 36, 22, 39, 30, 14, 35, 2, 32, 37, and 21\. If
    we sort them, we get 2, 11, 14, 15, 16, 20, 21, 22, 30, 32, 35, 36, 37, 39, and
    48\. There are 15 quality ranks, so all we do is take the eighth one, 22, and
    that’s our median.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 排序可以帮助我们。将质量等级从小到大排序，然后选出中间索引位置的元素。例如，假设我们有这 15 个质量等级：48、16、15、20、11、36、22、39、30、14、35、2、32、37
    和 21。如果我们将它们排序，得到 2、11、14、15、16、20、21、22、30、32、35、36、37、39 和 48。共有 15 个质量等级，我们只需要取第八个，即
    22，这就是我们的中位数。
- en: There are slightly faster algorithms for finding the median directly, without
    taking the scenic route through sorting. Sorting gives us an algorithm that takes
    *O*(*n* log *n*) time to find the median; there’s a sophisticated *O*(*n*) algorithm
    for finding the median that I encourage you to look up if you are interested.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些稍微更快的算法可以直接找到中位数，而不是通过排序这条“风景优美”的路。排序算法提供了一种需要 *O*(*n* log *n*) 时间的中位数查找方法；但是有一种复杂的
    *O*(*n*) 算法可以找到中位数，如果你感兴趣的话，我鼓励你去查阅一下。
- en: We won’t go there, though. What we do in this subsection is going to be so slow
    that no improved algorithm for finding the median is going to be of benefit.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们不打算走这条路。在这一小节中，我们所做的事情将非常慢，以至于任何改进的中位数查找算法都无法带来任何帮助。
- en: '[Listing 7-9](ch07.xhtml#ch07ex09) gives the code for finding the median of
    a given rectangle.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-9](ch07.xhtml#ch07ex09)给出了查找给定矩形中位数的代码。'
- en: '[PRE25]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 7-9: Finding the median of a given rectangle*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-9：查找给定矩形的中位数*'
- en: The first four parameters of `median` delimit the rectangle by specifying the
    top-left row and column and the bottom-right row and column. The final parameter,
    `q`, holds the quality ranks. We use the one-dimensional array `cur_rectangle`
    to accumulate the quality ranks for the rectangle. The nested `for` loops go through
    each block in the rectangle and add the block’s quality rank to `cur_rectangle`.
    After corralling the quality ranks, we’re all set to feed them to `qsort` ➊. Then
    we know exactly where the median is—it’s in the middle of the array—so we just
    return it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`median`函数的前四个参数通过指定左上角的行和列，以及右下角的行和列，来限定矩形。最后一个参数`q`保存质量排名。我们使用一维数组`cur_rectangle`来累积矩形的质量排名。嵌套的`for`循环遍历矩形中的每个块，并将块的质量排名添加到`cur_rectangle`中。收集完质量排名后，我们可以将它们传递给`qsort`
    ➊。然后我们就能准确地知道中位数的位置——它位于数组的中间——所以我们只需返回它。'
- en: With that function in hand, we can now proceed to loop through each candidate
    rectangle, keeping track of the one whose median quality rank is the smallest.
    Check out [Listing 7-10](ch07.xhtml#ch07ex010) for the code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个函数，我们现在可以开始循环遍历每个候选矩形，跟踪其中中位数质量排名最小的一个。查看[清单 7-10](ch07.xhtml#ch07ex010)中的代码。
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 7-10: Finding the smallest median of all candidate rectangles*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：查找所有候选矩形中的最小中位数*'
- en: 'The variable `best` tracks the best (smallest) median that we’ve found so far.
    We start it off with a big value, bigger than the median of any candidate rectangle
    ➊. There’s no way for a rectangle to have a median of `r * c + 1`: that would
    mean that half of its quality ranks were larger than `r * c`, but by the problem
    description, *no* quality ranks can be larger than `r * c`. The nested `for` loops
    consider each possible top-left coordinate for a rectangle. That gives us the
    top row and left column, but we also need the bottom row and right column in order
    to call `median`. To calculate the bottom row, we take the top row, add `h` (the
    number of rows in the candidate rectangles), and then subtract 1 ➋. It’s really
    easy to make an off-by-one error here, but that `- 1` is required. If the top
    row is 4 and `h` is `2`, then we want the bottom row to be 4 + 2 – 1 = 5; if we
    made the bottom row be 4 + 2 = 6, then we’d have a rectangle with three rows instead
    of the desired two. We use a similar calculation to find the right column ➌. With
    the four coordinates available, we call `median` to calculate the median of the
    rectangle ➍. The remainder of the code updates `best` if we’ve found a better
    median.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`best`跟踪我们目前找到的最好的（最小的）中位数。我们一开始将其设为一个很大的值，远大于任何候选矩形的中位数 ➊。没有矩形的中位数会是`r *
    c + 1`，这意味着它的一半质量排名大于`r * c`，但根据题目描述，*没有*质量排名会大于`r * c`。嵌套的`for`循环考虑矩形的每个可能的左上角坐标。这给了我们上行和左列，但我们还需要底行和右列来调用`median`函数。为了计算底行，我们取上行，加上`h`（候选矩形的行数），然后减去1
    ➋。在这里很容易犯下“偏差一”的错误，但这个`- 1`是必须的。如果上行是4且`h`是2，那么我们希望底行是4 + 2 – 1 = 5；如果我们将底行设为4
    + 2 = 6，那么矩形就会有三行，而不是我们希望的两行。我们用类似的计算来找到右列 ➌。通过这四个坐标，我们调用`median`函数计算矩形的中位数 ➍。其余代码会在我们找到更好的中位数时更新`best`。
- en: We’re done with this solution. There’s no `main` function, because the judge
    calls `rectangle` directly, but the absence of `main` means that we can’t test
    our code on our own computer. For testing purposes, you can introduce a `main`
    function, but don’t keep that in there when you submit to the judge.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了这个解决方案。没有`main`函数，因为评测系统直接调用`rectangle`函数，但没有`main`函数意味着我们无法在自己的计算机上测试代码。为了测试，你可以添加一个`main`函数，但在提交给评测系统时，记得去掉它。
- en: 'Here’s an example `main` function on the city in [Table 7-1](ch07.xhtml#ch07tab1):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于[表格 7-1](ch07.xhtml#ch07tab1)中城市的`main`函数示例：
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You should see an output of `13` when you run the program.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序时，你应该看到输出为`13`。
- en: Feel free to submit our solution, minus the `main` function, to the judge. It’ll
    pass a few test cases but time-out on the rest.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以将我们的解决方案提交给评测系统，去掉`main`函数后，代码会通过几个测试用例，但在其他用例上会超时。
- en: To get a feel for why our code is so slow, let’s focus on the case where *r*
    and *c* are both the same number *m*. To exhibit the worst case, take *h* and
    *w* to both be *m*/2\. (We don’t want the rectangles to be too big, because then
    there won’t be many rectangles; and we don’t want them to be too small, because
    then each is easy to process.) The slowest part of our `median` function is the
    call to `qsort`. It’s given an array with *m*/2 × *m*/2 = *m*²/4 values. On an
    array of *n* values, `qsort` takes *n* log *n* steps. Replacing *n* by *m*²/4
    gives (*m*²/4) log(*m*²/4) = *O*(*m*² log *m*). So we’re already slower than quadratic—and
    all we’ve done is calculate the median for one rectangle! The `rectangle` function
    calls `median` a total of *m*²/4 times, so our total runtime is *O*(*m*⁴ log *m*).
    That power of 4 relegates this solution to only very small problem instances.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解为什么我们的代码这么慢，我们集中讨论*r*和*c*都是相同数值*m*的情况。为了展示最坏情况，令*h*和*w*都等于*m*/2。（我们不希望矩形太大，因为那样矩形就不多了；我们也不希望它们太小，因为那样每个都很容易处理。）我们`median`函数中最慢的部分是调用`qsort`。它接收一个包含*m*/2
    × *m*/2 = *m*²/4个值的数组。在大小为*n*的数组上，`qsort`需要执行*n* log *n*步。将*n*替换为*m*²/4，得到(*m*²/4)
    log(*m*²/4) = *O*(*m*² log *m*)。所以我们已经比二次方还慢——而我们所做的只是计算一个矩形的中位数！`rectangle`函数总共调用`median`
    *m*²/4次，因此我们的总运行时间是*O*(*m*⁴ log *m*)。这个四次方的时间复杂度使得这个解法只能用于非常小的实例。
- en: There are two bottlenecks here. The first is sorting each rectangle. The second
    is doing a lot of work from scratch for each rectangle. Using a binary search
    disposes the former, and a neat dynamic-programming trick disposes the latter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个瓶颈。第一个是对每个矩形进行排序。第二个是对每个矩形从头开始做大量工作。使用二分查找可以解决第一个问题，而一个巧妙的动态规划技巧可以解决第二个问题。
- en: '*Using Binary Search*'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用二分查找*'
- en: Why should we be optimistic that binary search will lead to a speedup here?
    First, in the previous subsection, we saw that finding optimality head-on is a
    costly endeavor; our approach that piggybacked on sorting was slightly slower
    than an *m*⁴ algorithm. Second, we have another example of a problem where all
    infeasible solutions come first and are followed by all feasible solutions. Suppose
    I tell you that there is no rectangle with median quality rank of at most five.
    Then there’d be no point looking for rectangles with median quality five, or four,
    or three, or anything else less than five. Conversely, suppose I tell you that
    there is a rectangle with median quality rank of at most five. Now, there’d be
    no point looking for rectangles with median quality of six, or seven, or anything
    greater than five. This is tailor-made binary search territory.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该对二分查找带来速度提升感到乐观呢？首先，在上一小节中，我们看到直接寻找最优解是一个昂贵的任务；我们依赖排序的做法比*m*⁴算法稍慢。其次，我们还有另一个例子，说明所有不可行解在前，后面跟着所有可行解。假设我告诉你，没有一个矩形的中位质量排名在五以下。那么寻找质量排名为五、四、三或者任何小于五的矩形就没有意义了。反过来，假设我告诉你，存在一个中位质量排名不超过五的矩形。那么寻找质量排名为六、七或者任何大于五的矩形也就没有意义了。这正是二分查找的理想应用场景。
- en: 'In the Feeding Ants problem, small values were infeasible and large values
    were feasible. In the River Jump problem, small values were feasible and large
    values were infeasible. Here, we’re back in the Feeding Ants case: small values
    are infeasible and large values are feasible. We’ll therefore need a change to
    the River Jump invariant, flipping the locations of the feasible and infeasible
    portions of the solution space.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在喂蚂蚁问题中，小值是不可行的，大值是可行的。在河流跳跃问题中，小值是可行的，大值是不可行的。在这里，我们回到了喂蚂蚁的情况：小值是不可行的，大值是可行的。因此，我们需要对河流跳跃的不变式进行修改，交换解空间中可行和不可行部分的位置。
- en: 'Here’s the invariant that we’ll use: `low` and everything smaller than `low`
    are infeasible; `high` and everything larger than `high` are feasible. This tells
    us that we should return `high` when we’re done, as it will be the smallest feasible
    value. The code, in [Listing 7-11](ch07.xhtml#ch07ex011), is otherwise very similar
    to [Listing 7-7](ch07.xhtml#ch07ex07).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将使用的不变式：`low`及其以下的所有值都是不可行的；`high`及其以上的所有值是可行的。这告诉我们，当我们完成时应该返回`high`，因为它是最小的可行值。代码在[示例
    7-11](ch07.xhtml#ch07ex011)中，除了非常相似于[示例 7-7](ch07.xhtml#ch07ex07)之外，其他部分没有什么不同。
- en: '[PRE28]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 7-11: Searching for the optimal solution*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-11: 搜索最优解*'
- en: To finish the job, we need an implementation of `can_make_quality` to test feasibility.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这项工作，我们需要实现`can_make_quality`来测试可行性。
- en: '*Testing Feasibility*'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*测试可行性*'
- en: 'Here’s the signature for the feasibility-checking function that we’ll write:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将要编写的可行性检查函数的签名：
- en: '[PRE29]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In “Sorting Every Rectangle” on [page 256](ch07.xhtml#sec110), we were saddled
    by having to calculate the median quality rank of each rectangle. Now this is
    no longer the case: we’re content to determine whether the median value of some
    rectangle is at most some cutoff `quality` rank value.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在“排序每个矩形”一节中，位于[第256页](ch07.xhtml#sec110)，我们被迫计算每个矩形的中位数质量排名。现在情况不再是这样：我们只需确定某个矩形的中位数是否最多是某个截止的`quality`排名值。
- en: 'This is an easier problem for which a sorting step is unnecessary. Here’s the
    key observation: the specific values themselves no longer matter; all that matters
    is the relationship between each value and `quality`. To exploit this observation,
    we’ll replace all values that are less than or equal to `quality` by –1 and all
    values greater than `quality` by 1\. We then add up these –1 and 1 values for
    a given rectangle. If we have at least as many –1 values as 1 values (that is,
    there are at least as many small values as large values, relative to `quality`),
    then the sum will be zero or negative, and we can conclude that this rectangle
    has a median quality rank of `quality` or less.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更简单的问题，不需要排序步骤。关键的观察点是：具体的值本身不再重要；重要的是每个值与`quality`之间的关系。为了利用这个观察点，我们将所有小于或等于`quality`的值替换为-1，将所有大于`quality`的值替换为1。然后，我们将这些-1和1的值相加，针对给定的矩形。如果-1的值至少与1的值一样多（即，相对于`quality`，小值和大值的数量至少相同），那么和将是零或负数，我们可以得出结论：这个矩形的中位数质量排名是`quality`或更小。
- en: 'Let’s work an example. Here are the 15 quality ranks again for the 5×3 rectangle
    in the top left of [Table 7-1](ch07.xhtml#ch07tab1): 48, 16, 15, 20, 11, 36, 22,
    39, 30, 14, 35, 2, 32, 37, and 21\. Does this rectangle have a median quality
    rank of 16 or less? Take each value and replace it by –1 if it’s less than or
    equal to 16 and 1 if it’s greater than 16\. Here are the new values: 1, –1, –1,
    1, –1, 1, 1, 1, 1, –1, 1, –1, 1, 1, and 1\. If we add these up, we get a value
    of 5\. This means that there are five more large values than small values, and
    we must conclude that a median of 16 or smaller is not possible for this rectangle.
    If we wanted to know whether a median of 30 was feasible, we’d get this after
    replacing the numbers by –1s and 1s: 1, –1, –1, –1, –1, 1, –1, 1, –1, –1, 1, –1,
    1, 1, and –1\. Adding these up, we get a total of –3.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个例子。这里是[表7-1](ch07.xhtml#ch07tab1)左上角5×3矩形的15个质量排名：48, 16, 15, 20, 11,
    36, 22, 39, 30, 14, 35, 2, 32, 37, 和21。这个矩形的中位数质量排名是16或更小吗？将每个值替换为-1（如果小于或等于16）或1（如果大于16）。得到的新值如下：1,
    -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 和1。如果将这些加起来，结果是5。这意味着大值比小值多五个，我们必须得出结论：这个矩形不可能有16或更小的中位数。如果我们想知道30是否可行，我们可以在将这些数字替换为-1和1后得到：1,
    -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, -1, 1, 1 和-1。将这些加起来，总和是-3。
- en: Aha! So 30 is a feasible median. Crucially, we’re making this feasible–infeasible
    decision with no sorting at all.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！所以 30 是一个可行的中位数。关键是，我们在没有任何排序的情况下做出了这个可行–不可行的决策。
- en: We need to loop through each rectangle, testing whether it has a median quality
    rank of `quality` or less. [Listing 7-12](ch07.xhtml#ch07ex012) does exactly this.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遍历每个矩形，测试它是否具有`quality`或更小的中位数质量排名。[列表7-12](ch07.xhtml#ch07ex012)正是做了这件事。
- en: '[PRE30]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 7-12: Testing the feasibility of* quality'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-12：测试*质量的可行性'
- en: We can’t just obliterate the `q` array with –1s and 1s, because then we couldn’t
    use the original quality ranks to later test other values of `quality`. Therefore,
    we use a new array to hold the –1s and 1s ➊. Notice how this array is filled in
    based on whether each value is less than or equal to (–1) or greater than (1)
    the cutoff `quality` parameter that we’re checking ➋.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能仅仅用-1和1摧毁`q`数组，因为那样我们就不能使用原始的质量排名来测试其他`quality`值。因此，我们使用一个新数组来存储-1和1的值 ➊。注意，这个数组的填充是基于每个值是否小于或等于（-1）或大于（1）我们正在检查的截止`quality`参数
    ➋。
- en: We then go through each rectangle, just as we did in [Listing 7-10](ch07.xhtml#ch07ex010).
    We add up all of its –1 and 1 values ➌ and return `1` (true) if it has a median
    quality rank that’s small enough.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们像在[列表7-10](ch07.xhtml#ch07ex010)中一样遍历每个矩形。我们将所有的-1和1值加起来 ➌，并返回`1`（true），如果它的中位数质量排名足够小。
- en: All right! We have sidestepped the sorting—crafty, eh? What we did in this subsection
    is crucial to a fast solution to solving our problem, but we’re not there yet,
    because if you count the number of nested loops, you’ll see that there are four
    of them.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我们绕过了排序—聪明吧？我们在这一小节中所做的工作对于快速解决问题至关重要，但我们还没有到达最终解决方案，因为如果你计算嵌套循环的数量，你会发现总共有四个。
- en: At the end of “Sorting Every Rectangle” we observed that our first solution—with
    no binary search anywhere!—was a very slow *O*(*m*⁴ log *m*), where *m* is the
    number of rows or columns in the city. Here, our feasibility check is already
    *m*⁴; multiply by the log factor for the binary search, and it’s not clear that
    we’ve made any progress.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在“排序每个矩形”的结尾，我们观察到我们第一个解法——没有任何二分查找！——是一个非常慢的 *O*(*m*⁴ log *m*)，其中 *m* 是城市中的行数或列数。在这里，我们的可行性检查已经是
    *m*⁴；再乘以二分查找的对数因子，似乎我们并没有取得什么进展。
- en: Oh, but we have! It’s just locked up behind too many nested loops, involving
    too much recomputation. Dynamic programming is now going to take us the rest of
    the way.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，但我们已经进展了！只是被太多嵌套循环锁住，涉及过多的重复计算。动态规划现在将帮助我们完成余下的工作。
- en: '*A Quicker Way to Test Feasibility*'
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*一种更快速的可行性测试方法*'
- en: Suppose we start with [Table 7-1](ch07.xhtml#ch07tab1) and are interested in
    whether any 5×3 rectangle has a median quality rank of 16 or less. Changing all
    values less than or equal to 16 to –1 and all values greater than 16 to 1 results
    in [Table 7-2](ch07.xhtml#ch07tab2).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从[表7-1](ch07.xhtml#ch07tab1)开始，并且关心任何5×3的矩形是否有一个中位数质量排名小于等于16。将所有小于或等于16的值改为–1，所有大于16的值改为1，结果就是[表7-2](ch07.xhtml#ch07tab2)。
- en: '**Table 7-2:** A City with Quality Ranks Replaced'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-2：** 替换了质量排名的城市'
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | 1 | –1 | –1 | 1 | 1 | 1 | –1 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 1 | –1 | –1 | 1 | 1 | 1 | –1 |'
- en: '| **1** | 1 | –1 | 1 | 1 | 1 | –1 | 1 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 1 | –1 | 1 | 1 | 1 | –1 | 1 |'
- en: '| **2** | 1 | 1 | 1 | –1 | –1 | –1 | 1 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 1 | 1 | 1 | –1 | –1 | –1 | 1 |'
- en: '| **3** | –1 | 1 | –1 | –1 | 1 | –1 | 1 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| **3** | –1 | 1 | –1 | –1 | 1 | –1 | 1 |'
- en: '| **4** | 1 | 1 | 1 | –1 | 1 | 1 | 1 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **4** | 1 | 1 | 1 | –1 | 1 | 1 | 1 |'
- en: '| **5** | 1 | 1 | 1 | –1 | 1 | 1 | –1 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **5** | 1 | 1 | 1 | –1 | 1 | 1 | –1 |'
- en: '| **6** | 1 | –1 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **6** | 1 | –1 | 1 | 1 | 1 | 1 | 1 |'
- en: We might begin by summing the elements of the 5×3 rectangle whose top-left coordinate
    is (0, 0). As we saw in the previous section, the sum of that rectangle is 5\.
    Next, maybe we want to sum the elements of the 5×3 rectangle whose top-left coordinate
    is (0, 1). Adding up all 15 numbers here is what we would have done in the previous
    subsection. However, doing so fails to lean on the work we did to compute the
    sum of the first rectangle. Indeed, this second rectangle has 10 values in common
    with the first rectangle. We should be able to prevent this kind of duplication
    of effort for this and all other rectangles.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会从求和坐标为(0, 0)的5×3矩形的元素开始。正如我们在前一节中看到的，那个矩形的和是5。接下来，也许我们想要求和坐标为(0, 1)的5×3矩形的元素。在这里加总所有15个数字就是我们在上一小节中所做的事情。然而，这样做未能利用我们在计算第一个矩形的和时所做的工作。事实上，第二个矩形与第一个矩形有10个值是重复的。我们应该能够避免这种重复劳动，处理这个以及所有其他矩形。
- en: Dodging the repeated work here amounts to efficiently solving what’s known as
    a two-dimensional *range sum query*. The one-dimensional case uses similar ideas,
    but in a simpler context, so we’ll briefly study that before returning to finish
    the Living Quality problem. (About half of [Chapter 8](ch08.xhtml) will be devoted
    to range queries, so stay tuned!)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 避免重复工作的关键就是高效地解决所谓的二维*区间和查询*问题。一维的情况使用类似的思路，但在更简单的上下文中，因此我们会简要研究一下，然后再回到解决生活质量问题。（[第8章](ch08.xhtml)将专门讨论区间查询，所以敬请期待！）
- en: One-Dimensional Range Sum Queries
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一维区间和查询
- en: 'Here’s a one-dimensional array:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个一维数组：
- en: '![Image](../images/pg262-01.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg262-01.jpg)'
- en: 'If asked to find the sum of the array from index 2 to index 5, we could directly
    sum the values in that range: 15 + 9 + 12 + 4 = 40\. That’s not very fast, and
    it would be particularly unfortunate if we were asked for the sum of the entire
    array. However, if we had to answer just a few such queries, we could get away
    with answering each by summing the appropriate values.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要求找出从索引2到索引5的数组和，我们可以直接将该范围内的值相加：15 + 9 + 12 + 4 = 40。这样并不快速，特别是如果我们被要求计算整个数组的和时，就显得非常不方便。然而，如果我们只需要回答几个这样的查询，我们可以通过直接相加相应的值来应付。
- en: Now imagine that we’re getting peppered by hundreds or thousands of these queries.
    It makes sense to have done a little up-front work, once, if it means that we
    can then answer the queries more quickly.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下我们被成百上千个查询困扰。如果这样做一次预处理能让我们以后更快地回答这些查询，那就非常值得了。
- en: Consider the “index 2 to 5” query. What if we could look up the sum from index
    0 to 5? That sum is 48\. That’s not 40, the answer that we want. Far from useless,
    though, is that 48 is quite close to what we need. It’s only wrong because it
    includes the values at index 0 and index 1, stuff that we now need to exclude.
    We could do that if we could look up the sum from index 0 to 1\. That sum is 8\.
    If we subtract this 8 from 48, we get 40.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑“索引2到5”的查询。如果我们能查找到从索引0到5的和呢？这个和是48。那不是我们需要的40，虽然它离我们需要的值很接近。之所以不对，是因为它包含了索引0和索引1的值，这些我们现在需要排除掉。如果我们能查到从索引0到1的和呢？这个和是8。如果我们从48中减去这个8，就得到了40。
- en: 'What’s needed, then, is a new array, one where index *i* holds the sum of all
    values from index 0 to index *i*. This new array is included in the Prefix Sum
    row in the following table:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 那么需要的就是一个新的数组，其中索引*i*保存从索引0到索引*i*的所有值的和。这个新数组包含在下面表格中的前缀和行中：
- en: '![Image](../images/pg263-01.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg263-01.jpg)'
- en: 'No matter the query, we can now quickly answer it using the prefix sum array:
    to calculate the sum of the range from index *a* to *b*, take the value at index
    *b* and subtract the value at index *a* – 1\. For 2 to 5, we get 48 – 8 = 40,
    and for 1 to 6, we get 59 – 6 = 53\. These are constant-time answers, for eternity,
    and all we had to do was one preprocessing pass over the array.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 无论查询是什么，现在我们都可以通过前缀和数组快速回答：要计算从索引*a*到*b*的区间和，只需取索引*b*的值，并减去索引*a* – 1的值。对于从2到5的区间，我们得到48
    – 8 = 40，对于从1到6的区间，我们得到59 – 6 = 53。这些都是常数时间的答案，永远不会改变，我们所做的仅仅是对数组进行一次预处理。
- en: 'Two-Dimensional Range Sum: Queries'
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 二维区间和：查询
- en: Let’s return to the two-dimensional world of our quality ranks. Summing the
    elements of each rectangle is too slow, so we’ll extend what we did in one dimension
    to two dimensions. Specifically, we’ll produce a new array, where index (*i*,
    *j*) is the sum of the elements of the rectangle whose top-left coordinate is
    (0, 0) and whose bottom-right coordinate is (*i*, *j*).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到二维的质量排名世界。对每个矩形求和太慢了，所以我们将一维的做法扩展到二维。具体来说，我们将生成一个新的数组，其中索引(*i*, *j*)保存矩形（其左上角坐标为(0,
    0)，右下角坐标为(*i*, *j*)）的元素和。
- en: Let’s look again at [Table 7-2](ch07.xhtml#ch07tab2).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看一下[表格 7-2](ch07.xhtml#ch07tab2)。
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | 1 | –1 | –1 | 1 | 1 | 1 | –1 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 1 | –1 | –1 | 1 | 1 | 1 | –1 |'
- en: '| **1** | 1 | –1 | 1 | 1 | 1 | –1 | 1 |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 1 | –1 | 1 | 1 | 1 | –1 | 1 |'
- en: '| **2** | 1 | 1 | 1 | –1 | –1 | –1 | 1 |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 1 | 1 | 1 | –1 | –1 | –1 | 1 |'
- en: '| **3** | –1 | 1 | –1 | –1 | 1 | –1 | 1 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| **3** | –1 | 1 | –1 | –1 | 1 | –1 | 1 |'
- en: '| **4** | 1 | 1 | 1 | –1 | 1 | 1 | 1 |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| **4** | 1 | 1 | 1 | –1 | 1 | 1 | 1 |'
- en: '| **5** | 1 | 1 | 1 | –1 | 1 | 1 | –1 |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| **5** | 1 | 1 | 1 | –1 | 1 | 1 | –1 |'
- en: '| **6** | 1 | –1 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| **6** | 1 | –1 | 1 | 1 | 1 | 1 | 1 |'
- en: The corresponding prefix array is in [Table 7-3](ch07.xhtml#ch07tab3). (It may
    seem a little strange to call it a “prefix array” here, but let’s stick with it
    to match the terminology from the one-dimensional case.)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的前缀数组在[表格 7-3](ch07.xhtml#ch07tab3)中。（可能叫它“前缀数组”有点奇怪，但为了与一维情况的术语一致，我们暂且这么称呼。）
- en: '**Table 7-3:** An Array for Two-Dimensional Range Sum Queries'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 7-3：** 用于二维区间和查询的数组'
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | 1 | 0 | –1 | 0 | 1 | 2 | 1 |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 1 | 0 | –1 | 0 | 1 | 2 | 1 |'
- en: '| **1** | 2 | 0 | 0 | 2 | 4 | 4 | 4 |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 2 | 0 | 0 | 2 | 4 | 4 | 4 |'
- en: '| **2** | 3 | 2 | 3 | 4 | 5 | 4 | 5 |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 3 | 2 | 3 | 4 | 5 | 4 | 5 |'
- en: '| **3** | 2 | 2 | 2 | 2 | 4 | 2 | 4 |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| **3** | 2 | 2 | 2 | 2 | 4 | 2 | 4 |'
- en: '| **4** | 3 | 4 | 5 | 4 | 7 | 6 | 9 |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| **4** | 3 | 4 | 5 | 4 | 7 | 6 | 9 |'
- en: '| **5** | 4 | 6 | 8 | 6 | 10 | 10 | 12 |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| **5** | 4 | 6 | 8 | 6 | 10 | 10 | 12 |'
- en: '| **6** | 5 | 6 | 9 | 8 | 13 | 14 | 17 |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| **6** | 5 | 6 | 9 | 8 | 13 | 14 | 17 |'
- en: Let’s make sure we know what this array tells us before worrying about how to
    quickly build it. The value in row 4, column 2 gives the sum of the values of
    the rectangle whose top-left coordinate is (0, 0) and whose bottom-right coordinate
    is (4, 2). We have seen in “Testing Feasibility” that this sum is 5 and, indeed,
    that’s what this array has there.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们担心如何快速构建这个数组之前，让我们先弄清楚这个数组告诉了我们什么。第4行第2列的值给出了左上角坐标为(0, 0)、右下角坐标为(4, 2)的矩形的和。我们在“测试可行性”中已经看到，这个和是5，事实上，这就是这个数组中该位置的值。
- en: How could we compute that (4, 2) value of 5 using other values that we’ve already
    computed? We need to start with its value in [Table 7-2](ch07.xhtml#ch07tab2),
    add what’s in range above it, and add everything in its row to the left. We can
    do this with judicious use of the array in [Table 7-3](ch07.xhtml#ch07tab3), as
    shown in [Table 7-4](ch07.xhtml#ch07tab4).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何利用已经计算过的其他值来计算(4, 2)位置的值5？我们需要从[表7-2](ch07.xhtml#ch07tab2)中获得它的值，然后加上它上面范围内的值，再加上它所在行左边的所有值。我们可以通过巧妙使用[表7-3](ch07.xhtml#ch07tab3)中的数组来做到这一点，正如[表7-4](ch07.xhtml#ch07tab4)所示。
- en: '**Table 7-4:** Quickly Calculating a Given Sum'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-4：** 快速计算给定和'
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | • ■ | • ■ | • |  |  |  |  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **0** | • ■ | • ■ | • |  |  |  |  |'
- en: '| **1** | • ■ | • ■ | • |  |  |  |  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **1** | • ■ | • ■ | • |  |  |  |  |'
- en: '| **2** | • ■ | • ■ | • |  |  |  |  |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **2** | • ■ | • ■ | • |  |  |  |  |'
- en: '| **3** | • ■ | • ■ | • |  |  |  |  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **3** | • ■ | • ■ | • |  |  |  |  |'
- en: '| **4** | ■ | ■ | 1 |  |  |  |  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **4** | ■ | ■ | 1 |  |  |  |  |'
- en: '| **5** |  |  |  |  |  |  |  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| **5** |  |  |  |  |  |  |  |'
- en: '| **6** |  |  |  |  |  |  |  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| **6** |  |  |  |  |  |  |  |'
- en: We need to start with the 1, capture the cells that include a circle (those
    above), capture the cells that include a square (those to the left), and add them
    all up. We can capture the cells that include a circle by looking up the element
    at row 3, column 2\. We can also capture the cells that include a square by looking
    up the element at row 4, column 1\. However, adding those together double-counts
    the cells that include both a circle and a square (those both above and to the
    left), but this is not an issue because the element at row 3, column 1 captures
    exactly those circle-and-square cells, whose subtraction undoes the double-counting.
    In all, we have 1 + 2 + 4 – 2 = 5, as desired. As long as we work from top to
    bottom and left to right, we can build this array with only two additions and
    one subtraction per cell.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从1开始，捕获包含圆圈的单元格（上面的那些），捕获包含方框的单元格（左边的那些），并将它们加起来。我们可以通过查找第3行、第2列的元素来捕获包含圆圈的单元格。我们还可以通过查找第4行、第1列的元素来捕获包含方框的单元格。然而，将它们加在一起会重复计算同时包含圆圈和方框的单元格（既在上面又在左边的那些），但这不是问题，因为第3行、第1列的元素正好捕获了那些圆圈和方框的单元格，其减法可以抵消重复计算。总的来说，我们得到了1
    + 2 + 4 – 2 = 5，正是我们所期望的。只要我们从上到下、从左到右工作，我们就能通过每个单元格仅进行两次加法和一次减法来构建这个数组。
- en: We now know how to build an array like that in [Table 7-3](ch07.xhtml#ch07tab3).
    So what?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何构建类似[表7-3](ch07.xhtml#ch07tab3)中的数组。那么，接下来呢？
- en: 'The “so what” is that it enables us to quickly calculate the sum of any rectangle.
    Suppose we wanted the sum of the rectangle whose top-left coordinate is (1, 3)
    and whose bottom-right coordinate is (5, 5). We can’t just use the value 10 in
    row 5, column 5 of [Table 7-3](ch07.xhtml#ch07tab3). That captures everything
    in the desired rectangle but also includes more than we want: it includes elements
    that are outside (above or to the left) of our desired rectangle. However, just
    as in the one-dimensional case, we’ll be able to adjust that value to include
    only the elements in the rectangle. See [Table 7-5](ch07.xhtml#ch07tab5) for how
    to do this. In this table, the cells of the desired rectangle are marked by stars.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: “那又怎样？”这使我们能够快速计算任何矩形的和。假设我们想计算一个矩形的和，它的左上角坐标是(1, 3)，右下角坐标是(5, 5)。我们不能仅仅使用[表7-3](ch07.xhtml#ch07tab3)中第5行第5列的值10。它捕获了矩形中的所有元素，但也包括了我们不想要的部分：它包括了在矩形外部（上面或左边）的元素。然而，正如在一维情况下一样，我们可以调整该值，使它只包括矩形中的元素。有关如何做，请参见[表7-5](ch07.xhtml#ch07tab5)。在这个表中，目标矩形的单元格用星号标记。
- en: '**Table 7-5:** Quickly Calculating the Sum of a Rectangle'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-5：** 快速计算矩形的和'
- en: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  | **0** | **1** | **2** | **3** | **4** | **5** | **6** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | • ■ | • ■ | • ■ | • | • | • |  |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| **0** | • ■ | • ■ | • ■ | • | • | • |  |'
- en: '| **1** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **1** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
- en: '| **2** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **2** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
- en: '| **3** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| **3** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
- en: '| **4** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| **4** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
- en: '| **5** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| **5** | ■ | ■ | ■ | ★ | ★ | ★ |  |'
- en: '| **6** |  |  |  |  |  |  |  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| **6** |  |  |  |  |  |  |  |'
- en: This time, we need to subtract the cells that include a circle and the cells
    that include a square. We can get the cells with a circle from row 0, column 5
    and the cells with a square from row 5, column 2\. But subtracting both will double-subtract
    the cells that have both a circle and a square, so we need to add back the cell
    in row 0, column 2\. That is, we have 10 – 2 – 8 + (–1) = –1, which is the sum
    of the rectangle.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们需要减去包含圆形的单元格和包含方形的单元格。我们可以从第 0 行，第 5 列得到圆形的单元格，从第 5 行，第 2 列得到方形的单元格。但减去这两者会导致双重减去同时包含圆形和方形的单元格，因此我们需要加回第
    0 行，第 2 列的单元格。也就是说，我们有 10 – 2 – 8 + (–1) = –1，这是矩形的和。
- en: 'Here’s a general expression for this calculation:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个计算的一般表达式：
- en: '[PRE31]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will be used in the code presented next.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在接下来的代码中使用。
- en: 'Two-Dimensional Range Sum: Code'
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 二维范围和：代码
- en: We’re ready to put it all together—the –1 and 1 idea, building the prefix array,
    and using the prefix array for fast rectangle sums—in [Listing 7-13](ch07.xhtml#ch07ex013).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备将所有内容整合在一起——–1 和 1 的思路，构建前缀数组，并利用前缀数组进行快速矩形求和——在[示例 7-13](ch07.xhtml#ch07ex013)中。
- en: '[PRE32]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 7-13: Testing the feasibility of* quality *quickly*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-13：快速测试*质量*的可行性*'
- en: Step 1 is to build the `zero_one` array ➊, exactly as we did in [Listing 7-12](ch07.xhtml#ch07ex012).
    Step 2 is to build the prefix sum array `sum` ➋. We’ll use indices that start
    at 1, rather than 0, so that we don’t have to worry about staying within bounds
    when we later process cells on the edges of the array. Finally, Step 3 is to use
    the prefix sum array to quickly calculate the sum of each rectangle ➌. Notice
    how each rectangle can be summed in constant time here! We paid for the preprocessing
    work of Step 2, but that work pays for itself every time we sum a rectangle without
    summing its elements.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是构建`zero_one`数组 ➊，就像我们在[示例 7-12](ch07.xhtml#ch07ex012)中做的那样。第二步是构建前缀和数组`sum`
    ➋。我们将使用从 1 开始的索引，而不是从 0 开始，这样我们在稍后处理数组边缘的单元格时就不必担心越界问题。最后，第三步是使用前缀和数组来快速计算每个矩形的和
    ➌。注意每个矩形如何能在常数时间内求和！我们为第二步的预处理工作付出了代价，但每次在不逐一求和的情况下计算矩形和时，这个工作都会带来回报。
- en: Compared to [Listing 7-12](ch07.xhtml#ch07ex012), we’ve removed two levels of
    nesting from the `for` loops. Therefore, this is an *O*(*m*² log *m*) algorithm,
    which is fast enough to pass all of the test cases. Go for it! Then take a well-deserved
    break, because we’ve got one more big problem to solve before we’re through with
    this chapter.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 与[示例 7-12](ch07.xhtml#ch07ex012)相比，我们从`for`循环中去掉了两层嵌套。因此，这是一个 *O*(*m*² log *m*)
    的算法，足够快，可以通过所有测试用例。加油吧！然后好好休息一下，因为在本章结束之前，我们还需要解决一个大问题。
- en: 'Problem 4: Cave Doors'
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 4：洞穴门
- en: Another IOI championship problem? Bring it on! This one is unique to the chapter
    because it uses binary search not to find an optimal solution, but to quickly
    zone-in on a desired element. As we did in the Living Quality problem, we won’t
    read anything from standard input, and we won’t write anything to standard output.
    Rather, we’ll learn about the problem instance and submit our answer through calls
    to functions provided by the judge. As you read the problem description, try to
    anticipate why binary search is still appropriate here.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 又一个 IOI 决赛题目？来吧！这个问题在本章中是独特的，因为它使用二分查找的目的是快速定位到目标元素，而不是找到最优解。就像我们在生活质量问题中做的一样，我们不会从标准输入读取任何内容，也不会将任何内容写入标准输出。相反，我们将通过调用评测机提供的函数来了解问题实例并提交答案。在阅读问题描述时，尝试预测为什么在这里二分查找仍然适用。
- en: This is DMOJ problem `ioi13p4`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `ioi13p4`。
- en: '*The Problem*'
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: 'You are at the entrance to a long, narrow cave, and you want to get through
    the cave to the other side. There are *n* doors that you must pass through: the
    first door is Door 0, the second is Door 1, and so on.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你正站在一条狭长洞穴的入口，想要穿过洞穴到达另一边。你必须通过 *n* 扇门：第一扇是门 0，第二扇是门 1，依此类推。
- en: Each door can be open or closed. You can walk through any open door, but you
    can’t get past or see through a closed door. So if Door 0 and Door 1 are open
    but Door 2 is closed, then you progress to Door 2 but no further.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 每扇门可以是开着的或关闭的。你可以穿过任何开着的门，但无法穿越或看到关闭的门。所以如果门 0 和门 1 是开的，但门 2 是关的，那么你只能到达门 2，而无法再继续前进。
- en: At the entrance to the cave is a panel of *n* switches. Like the doors, the
    switches are numbered starting from 0\. Each switch can be in the up (0) position
    or the down (1) position. Each switch is associated with a different door, and
    it determines whether that door is open or closed. If a switch is set to the correct
    position, then its associated door is open; otherwise, its associated door is
    closed. You don’t know which switch is associated with which door, and you don’t
    know whether the switch should be up or down for the door to be open. For example,
    maybe Switch 0 is associated with Door 5, and the switch has to be down for Door
    5 to be open. And maybe Switch 1 is associated with Door 0, and the switch has
    to be up for Door 0 to be open.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在洞穴入口处有一个由 *n* 个开关组成的面板。与门一样，开关的编号从 0 开始。每个开关可以处于上（0）或下（1）的位置。每个开关与一个不同的门相关联，并决定该门是开还是关。如果开关设置为正确的位置，则其关联的门是开的；否则，门是关的。你不知道哪个开关与哪个门关联，也不知道开关应该处于上还是下的位置才能打开门。例如，也许开关
    0 与门 5 相关联，并且该开关必须处于下位置才能打开门 5。而开关 1 可能与门 0 相关联，且该开关必须处于上位置才能打开门 0。
- en: You can set the switches to whatever positions you choose and then walk through
    the cave to determine the first door that is closed. You have the stamina to do
    this at most 70,000 times. Your goal is to determine both the correct position
    (0 or 1) and the associated door for each switch.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将开关设置为你选择的任何位置，然后穿越洞穴来确定第一个关闭的门。你有足够的体力进行最多 70,000 次这样的操作。你的目标是确定每个开关的正确位置（0
    或 1）以及与之关联的门。
- en: 'We have to write the function with this signature:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编写具有以下签名的函数：
- en: '[PRE33]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: where `n` is the number of doors and switches (between 1 and 5,000). To implement
    this function, you call two functions provided by the judge. These are described
    next.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`n` 是门和开关的数量（介于 1 和 5,000 之间）。为了实现这个函数，你需要调用评测系统提供的两个函数。接下来会描述这两个函数。
- en: Input
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: We’re not reading anything from standard input. The only way to learn about
    the problem instance is to call the function `tryCombination` provided by the
    judge. Its signature is
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不从标准输入读取任何内容。了解问题实例的唯一方法是调用评测系统提供的 `tryCombination` 函数。其签名是：
- en: '[PRE34]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The parameter `switch_positions` is an array of length *n* giving the position
    (0 or 1) of each switch. That is, `switch_positions[0]` gives the position of
    Switch 0, `switch_positions[1]` gives the position of Switch 1, and so on. The
    `tryCombination` function simulates what would happen if we set the switches as
    in `switch_positions` and walked through the cave. If some door is still closed,
    it returns the number of the first closed door; otherwise, it returns `-1` to
    indicate that all doors are open.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `switch_positions` 是一个长度为 *n* 的数组，给出每个开关的位置（0 或 1）。即，`switch_positions[0]`
    给出开关 0 的位置，`switch_positions[1]` 给出开关 1 的位置，依此类推。`tryCombination` 函数模拟了如果我们将开关设置为
    `switch_positions` 中的状态并穿越洞穴时会发生什么。如果某些门仍然关闭，函数返回第一个关闭的门的编号；否则，返回 `-1`，表示所有门都已打开。
- en: Output
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: We’re not writing anything to standard output. Instead, when we’re ready, we
    submit our answer by calling the function `answer` provided by the judge. Its
    signature is
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有将任何内容写入标准输出。相反，当我们准备好时，我们通过调用评测系统提供的`answer`函数来提交答案。其函数签名是：
- en: '[PRE35]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have one shot at this: when we call `answer`, we can’t then do anything
    else, so we had better submit the correct answer the first time. The parameter
    `switch_positions` is our proposed switch positions, in the same format as for
    `tryCombination`. The parameter `door_for_switch` is our proposed association
    between switches and doors: `door_for_switch[0]` gives the door for Switch 0,
    `door_for_switch[1]` gives the door for Switch 1, and so on.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一次机会：当我们调用 `answer` 时，之后不能再做其他任何操作，因此最好第一次就提交正确的答案。参数 `switch_positions`
    是我们提议的开关位置，格式与 `tryCombination` 相同。参数 `door_for_switch` 是我们提议的开关与门之间的关联：`door_for_switch[0]`
    给出开关 0 对应的门，`door_for_switch[1]` 给出开关 1 对应的门，依此类推。
- en: The number of calls to `tryCombination`, rather than execution time, is the
    scarce resource here. We’re allowed to make at most 70,000 calls; if we make more,
    then our program is terminated and we do not solve the problem.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `tryCombination` 的次数，而不是执行时间，是这里的稀缺资源。我们最多允许进行 70,000 次调用；如果超过这个次数，程序将被终止，我们无法解决问题。
- en: '*Solving a Subtask*'
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决子任务*'
- en: The author of this problem has split the points across five *subtasks*. The
    fifth subtask is the problem in its full generality as I’ve presented it here.
    The other subtasks impose additional constraints on the problem instances to make
    the problem easier.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题的作者将问题分为五个*子任务*。第五个子任务是我在这里展示的完整问题。其他子任务对问题实例施加了额外的约束，使得问题变得更容易。
- en: I like when problem authors use subtasks, especially when I’m struggling to
    solve a problem. I can then target each subtask in turn, improving my solution
    as I go, until I solve the full problem. Moreover, if I can’t solve the full problem,
    then I still get points for the subtasks that I was able to solve.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢问题作者使用子任务，特别是在我难以解决问题时。我可以依次解决每个子任务，并在此过程中不断改进我的解决方案，直到最终解决整个问题。此外，即使我无法解决整个问题，我仍然可以获得我能够解决的子任务的积分。
- en: The first subtask in the Cave Doors problem is to solve the problem when each
    switch `i` is associated with door number `i`. That is, Switch 0 is associated
    with Door 0, Switch 1 is associated with Door 1, and so on. What we need to deduce
    is the correct position (0 or 1) for each switch.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 洞门问题中的第一个子任务是解决当每个开关`i`与门号`i`关联时的问题。也就是说，开关0与门0关联，开关1与门1关联，依此类推。我们需要推导出每个开关的正确位置（0或1）。
- en: 'Don’t worry: we won’t stop with this problem until we solve it fully. But let’s
    start by solving Subtask 1 here, so we can focus on correctly calling the `tryCombination`
    and `answer` judge functions before we tackle the other aspects of the problem.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心：我们不会在解决完全这个问题之前停止。但让我们先从解决子任务1开始，这样我们可以专注于正确调用`tryCombination`和`answer`评测函数，然后再解决问题的其他方面。
- en: We don’t have access to the code for the two judge functions, so we’re not going
    to be able to locally compile and run our program. (If you’d like to get things
    set up locally, you can google “IOI 2013 tasks” and find the test data and templates
    for the Cave Doors problem, but you won’t need to do any of that to follow the
    discussion here.) Whenever we want to test what we’re doing, we can submit our
    code to the judge. In particular, once we successfully solve Subtask 1 and submit
    our code, the judge should give us some points. The code for Subtask 1 is given
    in [Listing 7-14](ch07.xhtml#ch07ex014).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法访问两个评测函数的代码，所以无法在本地编译和运行我们的程序。（如果你想在本地设置，你可以搜索“IOI 2013 tasks”并找到洞门问题的测试数据和模板，但你不需要做这些就可以跟随这里的讨论。）每当我们想测试我们的进展时，可以将代码提交给评测系统。特别是，当我们成功解决了子任务1并提交代码时，评测系统应该会给我们一些积分。子任务1的代码见[列表7-14](ch07.xhtml#ch07ex014)。
- en: '[PRE36]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 7-14: Solving Subtask 1*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-14：解决子任务1*'
- en: To begin, we use a `for` loop to set each switch position to `0` ➊ and associate
    Door `i` with Switch `i` ➋. We’ll update the switch positions when needed, but
    (as per the subtask constraints) we’ll have no reason to touch the door associations
    again.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`for`循环将每个开关的位置设置为`0` ➊，并将门`i`与开关`i`关联起来 ➋。我们将在需要时更新开关的位置，但（根据子任务的约束）我们没有理由再次触及门与开关的关联。
- en: The second `for` loop loops through each switch. Its job is to determine if
    the current switch should stay in Position 0 or change to Position 1\. Let’s work
    through the first iteration, when `i` is `0`. We call `tryCombination` ➌, which
    returns to us the number of the first door that is closed. If it returns `0`,
    then Switch 0 is not set correctly; if Switch 0 were set correctly, Door 0 would
    be open, and `tryCombination` would return a number other than `0`. So, if Door
    0 is closed, then we change the position of Switch 0 from `0` to `1` ➍. That opens
    Door 0, and we can move on to Door 1.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`for`循环遍历每个开关。它的任务是判断当前的开关是保持在位置0还是切换到位置1。我们来处理第一次迭代，当`i`为`0`时。我们调用`tryCombination`
    ➌，它返回给我们第一个关闭的门的编号。如果它返回`0`，说明开关0没有设置正确；如果开关0设置正确，门0应该是打开的，`tryCombination`应该返回一个非零的数字。因此，如果门0是关闭的，我们将开关0的位置从`0`改为`1`
    ➍。这样就打开了门0，我们可以继续处理门1。
- en: When `i` is 1, we again call `tryCombination`. We won’t get a result of `0`,
    because our code has already done the work to guarantee that Door 0 is open. If
    we get a result of `1`, it means that Door 1 is closed, and we have to change
    Switch 1 from Position 0 to Position 1.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当`i`为1时，我们再次调用`tryCombination`。我们不会得到`0`的结果，因为我们的代码已经完成了确保门0是打开的工作。如果我们得到`1`的结果，意味着门1是关闭的，我们必须将开关1从位置0切换到位置1。
- en: Generalizing, we can say that, when we start a new iteration of the loop, all
    of the doors up to and including Door `i - 1` are open. If Door `i` is closed,
    then we change the position of Switch `i` from `0` to `1`; otherwise, Door `i`
    is already open, and Switch `i` is already correctly set.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Once we’re finished with that second `for` loop, we’ve figured out the correct
    position of each switch. We communicate this to the judge through the call to
    the `answer` function ➎.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: I suggest submitting this code to the judge to verify that you’re correctly
    calling `tryCombination` and `answer`. Once you’re ready, we’ll move on to solve
    the real deal.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '*Using Linear Search*'
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s a good thing we solved Subtask 1, beyond the fact of getting our feet wet.
    That’s because there’s a nice strategy in our solution that paves our way. That
    strategy is to figure out how to open each door and never let that door interfere
    again.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: In our solution to Subtask 1, we focus first on Door 0 and get that door open.
    Once it’s open, we never mess with its switch again. With Door 0 out of the way,
    we next focus on getting Door 1 open. Once Door 1 is open, we never mess with
    its switch again. As far as we are concerned, Doors 0 and 1 are gone; the Doors
    may as well start with Door 2\. We continue in this way, knocking off one door
    after another, until all doors are open.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'In Subtask 1, we knew exactly which door was associated with each of the switches.
    There was no searching required to figure out this correspondence. But, to solve
    the full problem, we do need a search, because we don’t know which switch controls
    the current door. We start by getting Door 0 closed. Then we search through the
    switches. We change the position of the current switch and ask whether or not
    Door 0 opened. If not, then this was not the correct switch. If so, then we’ve
    found the switch for Door 0\. We keep Door 0 open from this point onward, and
    we repeat the process for Door 1: getting it closed and then looping through the
    switches to find the one that opens it.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the new `exploreCave` code given in [Listing 7-15](ch07.xhtml#ch07ex015).
    It’s brief, because it offloads the search to a helper function.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 7-15: The* exploreCave *function*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: As with solving Subtask 1, each element of `switch_positions` will end up being
    a 0 or 1, indicating the position of each switch. `door_for_switch` indicates
    the door associated with each switch. We initialize each element of `door_for_switch`
    to `-1` ➊ to indicate that the door for each switch is unknown. When the door
    for Switch `i` becomes known, we’ll update `switch_positions[i]` and `door_for_switch[i]`
    accordingly.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Pop quiz: If `door_for_switch[5]` is `8`, what does that mean? Does it mean
    that Switch 5 is associated with Door 8 or that Door 5 is associated with Switch
    8?'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: It’s the former! Make sure you’re clear on this before continuing.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: For each Door `i`, we call the `set_a_switch` helper function ➋. Its task is
    to search through the switches to determine the one that is associated with Door
    `i`. It also determines whether that switch should be in Position 0 or 1.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个门 `i`，我们调用 `set_a_switch` 辅助函数 ➋。它的任务是遍历开关，找出与门 `i` 关联的开关，并确定该开关应该设置为位置
    0 还是位置 1。
- en: The code for `set_a_switch` is given in [Listing 7-16](ch07.xhtml#ch07ex016).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_a_switch` 的代码见 [Listing 7-16](ch07.xhtml#ch07ex016)。'
- en: '[PRE38]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 7-16: Finding and setting the switch for the current door using a
    linear search*'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-16：使用线性搜索查找并设置当前门的开关*'
- en: The `door` parameter dictates which door we want to solve next.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`door` 参数决定了我们接下来要解决的门。'
- en: We begin with a loop through the switches. We set the position of the switches
    to `0` ➊, but only for those switches that are not associated with a door yet.
    (Remember that, if a switch is already associated with a door, we don’t want to
    change that switch’s position ever again.)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从遍历开关开始。我们将开关的位置设置为 `0` ➊，但仅对那些尚未与门关联的开关进行此操作。（记住，如果某个开关已经与门关联，我们不希望再改变该开关的位置。）
- en: With all relevant switches set to Position 0, we determine whether the current
    door is open or closed. If it’s open, then we want to close it so that we can
    later change switch positions, one at a time, to see which switch opens it. To
    close the door, we just set all switch positions to `1` ➋. This works because
    the door was open when the switch positions were all `0`; one of those switches
    controls this door, so the door will close when that switch position changes.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有相关的开关位置都设置为 0 时，我们判断当前的门是开着还是关着。如果它开着，我们希望将其关上，以便稍后逐一改变开关的位置，看看哪个开关能打开它。为了关闭门，我们只需将所有开关的位置设置为
    `1` ➋。这样有效，因为当所有开关的位置都是 `0` 时，门是开的；其中一个开关控制着这扇门，所以当该开关的位置发生变化时，门就会关闭。
- en: 'With the door closed, it’s time to search for the switch that opens it. For
    each switch not already associated with a door, we *toggle* its position from
    0 to 1 or 1 to 0 ➌. Notice how subtracting the position from 1 changes the position:
    if it was 1 before, then it’s 0 now; if it was 0 before, then it’s 1 now. Then,
    we check the new status of the door. If it’s open ➍, then we’ve found the associated
    switch! If it’s still closed, then this wasn’t the right switch and the loop continues.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 门关闭时，是时候寻找能够打开它的开关了。对于每个尚未与门关联的开关，我们*切换*它的位置，从 0 改为 1 或从 1 改为 0 ➌。注意，减去位置 1
    会改变位置：如果之前是 1，现在就是 0；如果之前是 0，现在就是 1。然后，我们检查门的状态。如果它打开了 ➍，那么我们就找到了关联的开关！如果它仍然关闭，那么这个开关不是正确的，循环继续进行。
- en: What we’re doing in `set_a_switch` is a linear search through all of the remaining
    switches. We could have up to 5,000 switches, so finding the switch for a single
    door could take up to 5,000 calls of `tryCombination`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `set_a_switch` 中做的是一个线性搜索，遍历所有剩余的开关。我们可能最多有 5,000 个开关，因此查找单个门的开关可能需要最多 5,000
    次 `tryCombination` 调用。
- en: We can call `tryCombination` up to 70,000 times. If we get unlucky and the search
    for the first door takes 5,000 calls, the second takes 4,999 calls, the third
    takes 4,998 calls, and so on, then we can only handle about 14 doors before we
    go over the limit. Only 14 doors is not much. We could have 5,000 doors—we’re
    not even close! This is the end of the line for a linear search.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以最多调用 `tryCombination` 70,000 次。如果运气不好，第一个门的搜索需要 5,000 次调用，第二个门需要 4,999 次调用，第三个门需要
    4,998 次调用，以此类推，那么我们最多只能处理 14 扇门，超过这个数量就会超出限制。14 扇门并不多。我们可能有 5,000 扇门——我们甚至还没接近这个数量！这就是线性搜索的极限。
- en: '*Using Binary Search*'
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用二分搜索*'
- en: The numbers 5,000 (maximum number of doors) and 70,000 (maximum number of `tryCombination`
    calls) subtly encode the fact that binary search is a plausible solution strategy.
    Notice that log[2] 5,000 rounds up to 13\. If we can find a way to use binary
    search, then it’ll pick out the switch for the current door in only 13 calls of
    `tryCombination`, not 5,000\. If we take 13 calls per door, and we have 5,000
    doors, that’s 13 × 5,000 = 65,000 calls in all. We’ll need one extra call per
    door to tell us whether the door is closed but, still, we should be able to get
    in under the 70,000 limit.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 5,000（最大门数）和 70,000（最大 `tryCombination` 调用次数）微妙地编码了二分搜索作为一种可行解决策略的事实。注意，log[2]
    5,000 向上取整是 13。如果我们能找到一种使用二分搜索的方法，那么它只需要 13 次 `tryCombination` 调用就能找出当前门的开关，而不是
    5,000 次。如果每扇门需要 13 次调用，我们有 5,000 扇门，那么总共就是 13 × 5,000 = 65,000 次调用。每扇门还需要额外的一次调用来判断门是否关闭，但即便如此，我们仍应该能够在
    70,000 次调用限制内完成。
- en: How can binary search be used here? It must have something to do with eliminating
    half of the switch range on each step. Take some time to think through this before
    continuing!
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll explain the idea through an example. Suppose we have eight doors and eight
    switches and that Door 0 is currently closed. If we flip Switch 0, and Door 0
    doesn’t open, then we’ve learned very little: all we’ve learned is that Switch
    0 isn’t the switch associated with Door 0\. (It’s like starting with “1” when
    guessing someone’s number between 1 and 1,000.) A better idea is to flip half
    of the switches. So let’s flip Switches 0, 1, 2, and 3\. No matter what that does
    to Door 0, we learn a lot. If Door 0 is still closed, then Switches 0 to 3 have
    nothing to do with Door 0, and we can focus only on Switches 4 to 7\. If Door
    0 is now open, we know that one of the Switches 0 to 3 is the switch that’s associated
    with Door 0, and we can focus only on Switches 0 to 3\. One step: half the range
    gone. We continue in this way until we find the switch (and its position) associated
    with Door 0.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we go all the way, cutting the range of switches in half again
    and again until we have only one switch remaining. Let’s say we find that Switch
    6 is associated with Door 0\. We’ll then set Switch 6 so that Door 0 is open.
    That’s how it stays. When we next solve Door 1, or indeed any other door later,
    we’ll be careful not to change the position of Switch 6.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: I can now present the binary search solution to this problem. The new `set_a_switch`
    code is given in [Listing 7-17](ch07.xhtml#ch07ex017). The `exploreCave` function
    is the same as before ([Listing 7-15](ch07.xhtml#ch07ex015)).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 7-17: Finding and setting the switch for the current door using a
    binary search*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Compared to [Listing 7-16](ch07.xhtml#ch07ex016), the only real change is the
    replacement of the linear search with a binary search. Prior to each evaluation
    of the binary search condition ➊, we’ll arrange so that the current door is closed.
    In particular, once `low` and `high` are equal and the loop terminates, the door
    will still be closed. Then all we have to do is change the position of switch
    `low` to open the door.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now study the binary search itself. On each iteration, we calculate the
    midpoint `mid`, then change the position of the first half of the switches (but
    only those that are not already associated with doors). What effect did that have
    on the current door ➋? There are two possibilities:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '**The door is now open.**   We now know that the switch we seek is between
    `low` and `mid`, so we throw away all switches greater than `mid`. We also flip
    each switch between `low` and `mid` back to what they were prior to this iteration.
    This closes the door again so that we’re ready for the next iteration.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '**The door is still closed.**   The switch we want is therefore between `mid
    + 1` and `high`, so we throw away all switches that are `mid` or less. That’s
    all we do! No switches get flipped here, because the door is still closed, just
    as we want it.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: When we finish the binary search, `low` and `high` will be equal, and they tell
    us the switch associated with the current door. The current door is still closed
    at this point, so we flip the switch to open it ➌.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no more caveats: we have a clean, fast, binary-search-based solution.
    Send this off to the judge and you should pass all of the test cases.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes it’s much tougher to find an optimal solution than it is to check
    whether some proposed solution is feasible. How much liquid should be poured in
    a tree? I don’t know. Is 10 liters enough liquid? Now that question I can handle.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: When the conditions are right, binary search can convert a hard optimization
    problem into an easier feasibility-check problem. Sometimes it feels like cheating!
    We pay just an extra logarithmic factor for adding the binary search. A logarithmic
    factor is practically free. In return, we get to deal with an easier problem.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: I’m not claiming that binary search is the only way to solve the problems in
    this chapter. For example, it’s possible to solve Feeding Ants without binary
    search along the lines of what we did in [Chapter 2](ch02.xhtml), but I find that
    solution trickier than the one I presented in this chapter. Some problems that
    can be solved by binary search can also be solved by dynamic programming, but,
    again, doing so may be very challenging and there’d likely be little practical
    payoff anyway.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'What I am claiming is that binary search can offer solutions that are both
    nearly as fast as and easier to design than anything else we might try. If you’re
    not convinced, you might revisit each problem in this chapter, this time considering
    how you might solve it without binary search. But, really: if you’re working on
    a problem and see that you can use binary search, just do it and don’t look back.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feeding Ants is originally from the 2014 Croatian Open Competition in Informatics,
    Round 4\. River Jump is originally from the December 2006 USA Computing Olympiad,
    Silver Division. Living Quality is originally from the 2010 International Olympiad
    in Informatics. Cave Doors is originally from the 2013 International Olympiad
    in Informatics.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary search is one manifestation of a general algorithm design technique
    called *divide and conquer (D&C)*. D&C algorithms solve one or more independent
    subproblems, then combine those solutions to solve the original problem. Binary
    search solves just one subproblem—the one corresponding to the part of the input
    that we know contains the solution. Other D&C algorithms typically solve two or
    more subproblems; in [Chapter 10](ch10.xhtml), we’ll see such an example. To learn
    about other problems that are solved efficiently by D&C algorithms, see *Algorithms
    Illuminated (Part 1): The Basics* by Tim Roughgarden (2017).'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找是一个通用算法设计技巧的体现，称为*分治法 (D&C)*。D&C算法通过解决一个或多个独立的子问题，然后将这些解决方案结合起来，来解决原始问题。二分查找仅解决一个子问题——即对应于我们知道包含解决方案的输入部分的子问题。其他D&C算法通常解决两个或更多的子问题；在[第10章](ch10.xhtml)中，我们将看到这样的一个例子。要了解其他通过D&C算法高效解决的问题，请参见Tim
    Roughgarden（2017年）的*《算法启示录（第一部分）：基础》*。
