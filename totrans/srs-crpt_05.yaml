- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: BLOCK CIPHERS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分组密码
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'During the Cold War, the US and Soviets developed their own ciphers. The US
    government created the Data Encryption Standard (DES), which was adopted as a
    federal standard from 1979 to 2005, while the KGB developed GOST 28147-89, an
    algorithm kept secret until 1990 and still used today. In 2000, the US-based National
    Institute of Standards and Technology (NIST) selected the successor to DES, called
    the *Advanced Encryption Standard (AES)*, an algorithm developed in Belgium and
    now found in most electronic devices. AES, DES, and GOST 28147-89 have something
    in common: they’re all *block ciphers*, a type of cipher that combines a core
    algorithm working on blocks of data with a mode of operation, or a technique to
    process sequences of data blocks.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在冷战时期，美国和苏联分别开发了各自的密码。美国政府创建了数据加密标准（DES），该标准从1979年到2005年被作为联邦标准使用，而KGB开发了GOST
    28147-89，这是一个直到1990年才公开的算法，至今仍在使用。2000年，美国国家标准与技术研究院（NIST）选择了DES的继任者——*高级加密标准（AES）*，这是一个在比利时开发的算法，现在广泛应用于大多数电子设备中。AES、DES和GOST
    28147-89有一个共同点：它们都是 *分组密码*，这是一种结合了一个核心算法（处理数据块）和一种操作模式（或数据块序列处理技术）的密码类型。
- en: This chapter reviews the core algorithms that underlie block ciphers, discusses
    their modes of operation, and explains how they all work together. It also discusses
    how AES works and concludes with coverage of a classic attack tool from the 1970s,
    the meet-in-the-middle attack, and a favorite attack technique of the 2000s—padding
    oracles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了分组密码的核心算法，讨论了它们的工作模式，并解释了它们如何协同工作。它还讨论了 AES 的工作原理，并以覆盖1970年代的经典攻击工具——中间人攻击和2000年代流行的攻击技术——填充oracle攻击作为结尾。
- en: What Is a Block Cipher?
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是分组密码？
- en: 'A block cipher consists of an encryption algorithm and a decryption algorithm:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分组密码由加密算法和解密算法组成：
- en: The *encryption algorithm* (**E**) takes a key, *K*, and a plaintext block,
    *P*, and produces a ciphertext block, *C*. We write an encryption operation as
    *C* = **E**(*K*, *P*).
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加密算法* (**E**) 以一个密钥 *K* 和一个明文块 *P* 为输入，生成一个密文块 *C*。加密操作可以表示为 *C* = **E**(*K*,
    *P*)。'
- en: The *decryption algorithm* (**D**) is the inverse of the encryption algorithm
    and decrypts a message to the original plaintext, *P*. This operation is written
    as *P* = **D**(*K*, *C*).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解密算法* (**D**) 是加密算法的逆操作，将消息解密为原始明文 *P*。这个操作可以表示为 *P* = **D**(*K*, *C*)。'
- en: Since they’re the inverse of each other, the encryption and decryption algorithms
    usually involve similar operations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加密算法和解密算法互为逆操作，通常它们涉及的操作是相似的。
- en: '*Security Goals*'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安全目标*'
- en: If you’ve followed earlier discussions about encryption, randomness, and indistinguishability,
    the definition of a secure block cipher will come as no surprise. Again, we’ll
    define security as random-lookingness, so to speak.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读过关于加密、随机性和不可区分性的早期讨论，安全分组密码的定义应该不会让你感到惊讶。同样，我们将安全性定义为随机性，看起来像是随机的。
- en: In order for a block cipher to be secure, it should be a *pseudorandom permutation
    (PRP)*, meaning that as long as the key is secret, an attacker shouldn’t be able
    to compute an output of the block cipher from any input. That is, as long as *K*
    is secret and random from an attacker’s perspective, they should have no clue
    about what **E**(*K*, *P*) looks like, for any given *P*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使分组密码安全，它应该是一个 *伪随机置换（PRP）*，这意味着只要密钥是保密的，攻击者就不应该能够从任何输入计算出分组密码的输出。也就是说，只要
    *K* 对攻击者来说是保密且随机的，他们应该无法知道 **E**(*K*, *P*) 在给定 *P* 时的样子。
- en: More generally, attackers should be unable to discover any *pattern* in the
    input/output values of a block cipher. In other words, it should be impossible
    to tell a block cipher from a truly random permutation, given black-box access
    to the encryption and decryption functions for some fixed and unknown key. By
    the same token, they should be unable to recover a secure block cipher’s secret
    key; otherwise, they would be able to use that key to tell the block cipher from
    a random permutation. Of course that also implies that attackers can’t predict
    the plaintext that corresponds to a given ciphertext produced by the block cipher.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，攻击者应该无法在一个分组密码的输入/输出值中发现任何 *模式*。换句话说，攻击者在获得加密和解密函数的黑盒访问权限的情况下，应该无法区分一个分组密码和真正的随机置换，前提是密钥是固定且未知的。由此可得，攻击者也无法恢复一个安全分组密码的密钥；否则，他们就能利用该密钥将分组密码与随机置换区分开来。当然，这也意味着攻击者无法预测与某个给定密文对应的明文。
- en: '*Block Size*'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*分组大小*'
- en: 'Two values characterize a block cipher: the block size and the key size. Security
    depends on both values. Most block ciphers have either 64-bit or 128-bit blocks—DES’s
    blocks have 64 (2⁶) bits, and AES’s blocks have 128 (2⁷) bits. In computing, lengths
    that are powers of two simplify data processing, storage, and addressing. But
    why 2⁶ and 2⁷ and not 2⁴ or 2^(16) bits?'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码由两个值来表征：块大小和密钥大小。安全性取决于这两个值。大多数块密码的块大小为64位或128位——DES的块为64位（2⁶），AES的块为128位（2⁷）。在计算中，二的幂次长度简化了数据处理、存储和寻址。但为什么是2⁶和2⁷，而不是2⁴或2^(16)位呢？
- en: For one thing, it’s important that blocks are not too large in order to minimize
    both the length of ciphertext and the memory footprint. With regard to the length
    of the ciphertext, block ciphers process blocks, not bits. This means that in
    order to encrypt a 16-bit message when blocks are 128 bits, you’ll first need
    to convert the message into a 128-bit block, and only then will the block cipher
    process it and return a 128-bit ciphertext. The wider the blocks, the longer this
    overhead. As for the *memory footprint*, in order to process a 128-bit block,
    you need at least 128 bits of memory. This is small enough to fit in the registers
    of most CPUs or to be implemented using dedicated hardware circuits. Blocks of
    64, 128, or even 512 bits are short enough to allow for efficient implementations
    in most cases. But larger blocks (for example, several kilobytes long) can have
    a noticeable impact on the cost and performance of implementations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，块的大小不应过大，以最小化密文的长度和内存占用。关于密文的长度，块密码处理的是块，而不是比特。这意味着，当块为128位时，为了加密一个16位的消息，首先需要将消息转换为一个128位块，只有这样，块密码才会处理它并返回一个128位的密文。块越宽，开销就越大。至于*内存占用*，为了处理一个128位的块，你至少需要128位的内存。这个内存大小足够小，可以适应大多数CPU的寄存器或使用专用硬件电路实现。64位、128位甚至512位的块在大多数情况下都足够短，可以高效实现。但更大的块（例如几千字节）可能会显著影响实现的成本和性能。
- en: When ciphertexts’ length or memory footprint is critical, you may have to use
    64-bit blocks, because these will produce shorter ciphertexts and consume less
    memory. Otherwise, 128-bit or larger blocks are better, mainly because 128-bit
    blocks can be processed more efficiently than 64-bit ones on modern CPUs and are
    also more secure. In particular, CPUs can leverage special CPU instructions in
    order to efficiently process one or more 128-bit blocks in parallel—for example,
    the Advanced Vector Extensions (AVX) family of instructions in Intel CPUs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当密文的长度或内存占用至关重要时，可能需要使用64位块，因为它们生成的密文较短，占用更少的内存。否则，128位或更大的块更好，主要因为128位块在现代CPU上比64位块处理更高效，而且也更安全。特别是，CPU可以利用特殊的CPU指令来高效地并行处理一个或多个128位块——例如，英特尔CPU中的高级向量扩展（AVX）指令集。
- en: '*The Codebook Attack*'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*密码本攻击*'
- en: 'While blocks shouldn’t be too large, they also shouldn’t be too small; otherwise,
    they may be susceptible to *codebook attacks*, which are attacks against block
    ciphers that are only efficient when smaller blocks are used. The codebook attack
    works like this with 16-bit blocks:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然块不应太大，但也不应太小；否则，它们可能容易受到*密码本攻击*的威胁，密码本攻击是针对块密码的一种攻击，只有在使用较小块时才会高效。密码本攻击在使用16位块时的工作原理如下：
- en: Get the 65536 (2^(16)) ciphertexts corresponding to each 16-bit plaintext block.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取对应于每个16位明文块的65536（2^(16)）个密文。
- en: Build a lookup table—the *codebook*—mapping each ciphertext block to its corresponding
    plaintext block.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建查找表——即*密码本*——将每个密文块映射到其对应的明文块。
- en: To decrypt an unknown ciphertext block, look up its corresponding plaintext
    block in the table.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解密一个未知的密文块，可以在表中查找其对应的明文块。
- en: When 16-bit blocks are used, the lookup table needs only 2^(16) × 16 = 2^(20)
    bits of memory, or 128 kilobytes. With 32-bit blocks, memory needs grow to 16
    gigabytes, which is still manageable. But with 64-bit blocks, you’d have to store
    2^(70) bits (a zetabit, or 128 exabytes), so forget about it. Codebook attacks
    won’t be an issue for larger blocks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用16位块时，查找表只需要2^(16) × 16 = 2^(20)位内存，即128千字节。使用32位块时，内存需求增加到16千兆字节，仍然可以管理。但使用64位块时，你需要存储2^(70)位（一个泽比特，或128艾字节），所以这根本不可能。对于更大的块，密码本攻击就不会成为问题。
- en: How to Construct Block Ciphers
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何构建块密码
- en: 'There are hundreds of block ciphers but only a handful of techniques to construct
    one. First, a block cipher used in practice isn’t a gigantic algorithm but a repetition
    of *rounds*, a short sequence of operations that is weak on its own but strong
    in number. Second, there are two main techniques to construct a round: substitution–permutation
    networks (as in AES) and Feistel schemes (as in DES). In this section, we look
    at how these work, after viewing an attack that works when all rounds are identical
    to each other.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有数百种分组密码，但构造分组密码的方法却只有少数几种。首先，实际使用的分组密码并不是一个庞大的算法，而是由多个 *轮次* 组成的，这些轮次是由一小段操作构成的，单独来看可能很弱，但通过重复使用变得非常强大。其次，构造一轮的主要技术有两种：置换-替代网络（如
    AES）和费斯特尔结构（如 DES）。在本节中，我们将探讨这些技术的工作原理，并在此之前，我们还会讨论当所有轮次都相同时会出现的一种攻击。
- en: '*A Block Cipher’s Rounds*'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*分组密码的轮次*'
- en: Computing a block cipher boils down to computing a sequence of *rounds.* In
    a block cipher, a round is a basic transformation that is simple to specify and
    to implement, and which is iterated several times to form the block cipher’s algorithm.
    This construction, consisting of a small component repeated many times, is simpler
    to implement and to analyze than a construction that would consist of a single
    huge algorithm.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 计算分组密码的过程归结为计算一系列的 *轮次*。在分组密码中，轮次是一种基本变换，简单易指定和实现，并且会多次迭代以形成分组密码的算法。这个结构由一个小组件多次重复组成，较之于由一个庞大的算法组成的结构，它在实现和分析上更为简单。
- en: For example, a block cipher with three rounds encrypts a plaintext by computing
    *C* = **R**[3](**R**[2](**R**[1](*P*))), where the rounds are **R**[1], **R**[2],
    and **R**[3] and *P* is a plaintext. Each round should also have an inverse in
    order to make it possible for a recipient to compute back to plaintext. Specifically,
    *P* = **iR**[1](**iR**[2](**iR**[3](*C*))), where **iR**[1] is the inverse of
    **R**[1], and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个三轮的分组密码通过计算 *C* = **R**[3](**R**[2](**R**[1](*P*))) 来加密明文，其中轮次为 **R**[1]、**R**[2]
    和 **R**[3]，*P* 为明文。每一轮还应该有一个逆操作，以便接收方能够将密文解密回明文。具体地说，*P* = **iR**[1](**iR**[2](**iR**[3](*C*)))，其中
    **iR**[1] 是 **R**[1] 的逆操作，依此类推。
- en: The round functions—**R**[1], **R**[2], and so on—are usually identical algorithms,
    but they are parameterized by a value called the *round key*. Two round functions
    with two distinct round keys will behave differently, and therefore will produce
    distinct outputs if fed with the same input.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 轮函数——**R**[1]、**R**[2] 等——通常是相同的算法，但它们由一个名为 *轮密钥* 的值来参数化。两个具有不同轮密钥的轮函数将表现不同，因此如果输入相同，输出也会不同。
- en: Round keys are keys derived from the main key, *K*, using an algorithm called
    a *key schedule*. For example, **R**[1] takes the round key *K*[1], **R**[2] takes
    the round key *K*[2], and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 轮密钥是从主密钥 *K* 中派生出来的密钥，使用一种称为 *密钥调度* 的算法。例如，**R**[1] 使用轮密钥 *K*[1]，**R**[2] 使用轮密钥
    *K*[2]，以此类推。
- en: Round keys should always be different from each other in every round. For that
    matter, not all round keys should be equal to the key *K*. Otherwise, all the
    rounds would be identical and the block cipher would be less secure, as described
    next.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每一轮的轮密钥应该互不相同。因此，并非所有轮密钥都应该与密钥*K*相同。否则，所有轮次将是相同的，分组密码的安全性会降低，正如接下来所描述的那样。
- en: '*The Slide Attack and Round Keys*'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*滑动攻击与轮密钥*'
- en: In a block cipher, no round should be identical to another round in order to
    avoid a *slide attack*. Slide attacks look for two plaintext/ciphertext pairs
    (*P*[1], *C*[1]) and (*P*[2], *C*[2]), where *P*[2] = **R**(*P*[1]) if **R** is
    the cipher’s round (see [Figure 4-1](ch04.xhtml#ch4fig1)). When rounds are identical,
    the relation between the two plaintexts, *P*[2] = **R**(*P*[1]), implies the relation
    *C*[2] = **R**(*C*[1]) between their respective ciphertexts. [Figure 4-1](ch04.xhtml#ch4fig1)
    shows three rounds, but the relation *C*[2] = **R**(*C*[1]) will hold no matter
    the number of rounds, be it 3, 10, or 100\. The problem is that knowing the input
    and output of a single round often helps recover the key. (For details, read the
    1999 paper by Biryukov and Wagner called “Advanced Slide Attacks,” available at
    *[https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf](https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf)*)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在分组密码中，为了避免*滑动攻击*，每一轮的操作不应与其他轮次相同。滑动攻击寻找两个明文/密文对（*P*[1], *C*[1]）和（*P*[2], *C*[2]），其中
    *P*[2] = **R**(*P*[1])，如果**R**是密码的轮函数（参见[图 4-1](ch04.xhtml#ch4fig1)）。当轮次相同的时候，两个明文之间的关系
    *P*[2] = **R**(*P*[1])，就意味着它们各自的密文之间也存在关系 *C*[2] = **R**(*C*[1])。[图 4-1](ch04.xhtml#ch4fig1)显示了三轮，但无论轮数是3、10还是100，关系
    *C*[2] = **R**(*C*[1]) 始终成立。问题在于，知道单轮的输入和输出通常有助于恢复密钥。（详情请阅读1999年Biryukov和Wagner的论文《高级滑动攻击》，可以在
    *[https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf](https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf)*
    上找到）
- en: The use of different round keys as parameters ensures that the rounds will behave
    differently and thus foil slide attacks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的轮密钥作为参数可以确保各轮操作的不同，从而有效防止滑动攻击。
- en: '![image](../images/f04-01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-01.jpg)'
- en: '*Figure 4-1: The principle of the slide attack, against block ciphers with
    identical rounds*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：针对具有相同轮次的分组密码的滑动攻击原理*'
- en: '**NOTE**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*One potential byproduct and benefit of using round keys is protection against
    side-channel attacks, or attacks that exploit information leaked from the implementation
    of a cipher (for example, electromagnetic emanations). If the transformation from
    the main key*, K, *to a round key*, K[i], *is not invertible, then if an attacker
    finds* K[i], *they can’t use that key to find* K. *Unfortunately, few block ciphers
    have a one-way key schedule. The key schedule of AES allows attackers to compute*
    K *from any round key*, K[i], for example.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用轮密钥的一个潜在副作用和好处是防御旁道攻击，旁道攻击是指利用密码实现过程中泄露的信息（例如电磁辐射）进行的攻击。如果从主密钥* K *到轮密钥*
    K[i] *的转换不可逆，那么如果攻击者找到* K[i] *，他们就无法使用该密钥来恢复* K。* 不幸的是，很少有分组密码采用单向密钥调度。AES的密钥调度允许攻击者从任何一个轮密钥*
    K[i] *计算出* K*，例如。'
- en: '*Substitution–Permutation Networks*'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*替代–置换网络*'
- en: If you’ve read textbooks about cryptography, you’ll undoubtedly have read about
    *confusion* and *diffusion*. Confusion means that the input (plaintext and encryption
    key) undergoes complex transformations, and diffusion means that these transformations
    depend equally on all bits of the input. At a high level, confusion is about depth
    whereas diffusion is about breadth. In the design of a block cipher, confusion
    and diffusion take the form of substitution and permutation operations, which
    are combined within substitution–permutation networks (SPNs).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过关于密码学的教材，你一定会接触到*混淆*和*扩散*这两个概念。混淆意味着输入（明文和加密密钥）经历复杂的转换，而扩散则意味着这些转换依赖于输入的所有位。在高级层面上，混淆关注的是深度，而扩散关注的是广度。在分组密码的设计中，混淆和扩散以替代和置换操作的形式出现，这些操作结合在替代–置换网络（SPNs）中。
- en: Substitution often appears in the form of *S-boxes*, or *substitution boxes*,
    which are small lookup tables that transform chunks of 4 or 8 bits. For example,
    the first of the eight S-boxes of the block cipher Serpent is composed of the
    16 elements (3 8 f 1 a 6 5 b e d 4 2 7 0 9 c), where each element represents a
    4-bit nibble. This particular S-box maps the 4-bit nibble 0000 to 3 (0011), the
    4-bit nibble 0101 (5 in decimal) to 6 (0110), and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 替代通常以*S-boxes*（或*替代盒*）的形式出现，这是用于转换4位或8位数据块的小型查找表。例如，分组密码Serpent的八个S-box中的第一个由16个元素组成（3
    8 f 1 a 6 5 b e d 4 2 7 0 9 c），其中每个元素代表一个4位的字节。这个特定的S-box将4位字节0000映射到3（0011），4位字节0101（十进制为5）映射到6（0110），以此类推。
- en: '**NOTE**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*S-boxes must be carefully chosen to be cryptographically strong: they should
    be as nonlinear as possible (inputs and outputs should be related with complex
    equations) and have no statistical bias (meaning, for example, that flipping an
    input bit should potentially affect any of the output bits).*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*S盒必须谨慎选择，以确保其密码学强度：它们应该尽可能非线性（输入和输出应通过复杂的方程式相关联），并且没有统计偏差（例如，翻转一个输入位应该可能影响任何输出位）。*'
- en: 'The permutation in a substitution–permutation network can be as simple as changing
    the order of the bits, which is easy to implement but doesn’t mix up the bits
    very much. Instead of a reordering of the bits, some ciphers use basic linear
    algebra and matrix multiplications to mix up the bits: they perform a series of
    multiplication operations with fixed values (the matrix’s coefficients) and then
    add the results. Such linear algebra operations can quickly create dependencies
    between all the bits within a cipher and thus ensure strong diffusion. For example,
    the block cipher FOX transforms a 4-byte vector (*a*, *b*, *c*, *d*) to (*a*′,
    *b*′, *c*′, *d*′), defined as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 替代-置换网络中的置换可以像更改位的顺序一样简单，这种方法易于实现，但并不会有效地混合位。某些密码算法并不简单地重新排列位，而是使用基本的线性代数和矩阵乘法来混合位：它们执行一系列带有固定值（矩阵系数）的乘法操作，然后将结果相加。这样的线性代数操作可以迅速在所有位之间创建依赖关系，从而确保强烈的扩散。例如，分组密码FOX将4字节向量(*a*,
    *b*, *c*, *d*)转换为(*a*′, *b*′, *c*′, *d*′)，定义如下：
- en: '![image](../images/f0058-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0058-01.jpg)'
- en: In the above equations, the numbers 2 and 253 are interpreted as binary polynomials
    rather than integers; hence, additions and multiplications are defined a bit differently
    than what we’re used to. For example, instead of having 2 + 2 = 4, we have 2 +
    2 = 0\. Regardless, the point is that each byte in the initial state affects all
    4 bytes in the final state.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方程中，数字2和253被解释为二进制多项式，而不是整数；因此，加法和乘法的定义与我们习惯的有所不同。例如，2 + 2 = 4 在这里表示为 2 +
    2 = 0\. 无论如何，重点是初始状态中的每个字节都会影响最终状态中的所有4个字节。
- en: '*Feistel Schemes*'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*费斯特尔方案*'
- en: 'In the 1970s, IBM engineer Horst Feistel designed a block cipher called Lucifer
    that works as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年代，IBM工程师霍斯特·费斯特尔设计了一种名为Lucifer的分组密码，其工作原理如下：
- en: Split the 64-bit block into two 32-bit halves, *L* and *R*.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将64位块分为两个32位的部分，*L* 和 *R*。
- en: Set *L* to *L* ⊕ **F**(*R*), where **F** is a substitution–permutation round.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *L* 设为 *L* ⊕ **F**(*R*)，其中 **F** 是一个替代-置换回合。
- en: Swap the values of *L* and *R*.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换 *L* 和 *R* 的值。
- en: Go to step 2 and repeat 15 times.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到第2步并重复15次。
- en: Merge *L* and *R* into the 64-bit output block.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *L* 和 *R* 合并为64位输出块。
- en: This construction became known as a *Feistel scheme*, as shown in [Figure 4-2](ch04.xhtml#ch4fig2).
    The left side is the scheme as just described; the right side is a functionally
    equivalent representation where, instead of swapping *L* and *R*, rounds alternate
    the operations *L* = *L* ⊕ **F**(*R*) and *R* = *R* ⊕ **F**(*L*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构被称为*费斯特尔方案*，如[图4-2](ch04.xhtml#ch4fig2)所示。左侧是如前所述的方案；右侧是一个功能等效的表示形式，其中，操作
    *L* = *L* ⊕ **F**(*R*) 和 *R* = *R* ⊕ **F**(*L*) 交替进行，而不是交换 *L* 和 *R*。
- en: '![image](../images/f04-02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-02.jpg)'
- en: '*Figure 4-2: The Feistel scheme block cipher construction in two equivalent
    forms*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：费斯特尔方案分组密码结构的两种等效形式*'
- en: I’ve omitted the keys from [Figure 4-2](ch04.xhtml#ch4fig2) to simplify the
    diagrams, but note that the first **F** takes a first round key, *K*[1], and the
    second **F** takes another round key, *K*[2]. In DES, the **F** functions take
    a 48-bit round key, which is derived from the 56-bit key, *K*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[图4-2](ch04.xhtml#ch4fig2)中省略了密钥，以简化图示，但请注意，第一次**F**函数使用第一个回合密钥 *K*[1]，第二次**F**函数使用另一个回合密钥
    *K*[2]。在DES中，**F**函数使用一个48位的回合密钥，该密钥从56位密钥 *K* 中派生。
- en: In a Feistel scheme, the **F** function can be either a pseudorandom permutation
    (PRP) or a pseudorandom function (PRF). A PRP yields distinct outputs for any
    two distinct inputs, whereas a PRF will have values *X* and *Y* for which **F**(*X*)
    = **F**(*Y*). But in a Feistel scheme, that difference doesn’t matter as long
    as **F** is cryptographically strong.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在费斯特尔方案中，**F**函数可以是伪随机置换（PRP）或伪随机函数（PRF）。PRP对任意两个不同输入产生不同的输出，而PRF对于某些值 *X* 和
    *Y*，有 **F**(*X*) = **F**(*Y*)。但在费斯特尔方案中，只要**F**在密码学上足够强大，这种差异并不重要。
- en: How many rounds should there be in a Feistel scheme? Well, DES performs 16 rounds,
    whereas GOST 28147-89 performs 32 rounds. If the **F** function is as strong as
    possible, four rounds are in theory sufficient, but real ciphers use more rounds
    to defend against potential weaknesses in **F**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在费斯特尔结构中应该有多少轮？嗯，DES执行16轮，而GOST 28147-89执行32轮。如果**F**函数尽可能强大，理论上四轮就足够了，但实际的加密算法通常使用更多轮，以防御**F**中可能存在的弱点。
- en: The Advanced Encryption Standard (AES)
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级加密标准（AES）
- en: AES is the most-used cipher in the universe. Prior to the adoption of AES, the
    standard cipher in use was DES, with its ridiculous 56-bit security, as well as
    the upgraded version of DES known as Triple DES, or 3DES.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: AES是世界上最常用的加密算法。在AES采用之前，标准的加密算法是DES，它的56位安全性完全不够，而且升级版的DES称为三重DES（3DES）。
- en: Although 3DES provides a higher level of security (112-bit security), it’s inefficient
    because the key needs to be 168 bits long in order to get 112-bit security, and
    it’s slow in software (DES was created to be fast in integrated circuits, not
    on mainstream CPUs). AES fixes both issues.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管3DES提供了更高的安全性（112位安全性），但它效率低下，因为为了达到112位的安全性，密钥需要168位长，而且在软件中运行较慢（DES是为集成电路设计的，并非为主流CPU设计）。AES解决了这两个问题。
- en: NIST standardized AES in 2000 as a replacement for DES, at which point it became
    the world’s de facto encryption standard. Most commercial encryption products
    today support AES, and the NSA has approved it for protecting top-secret information.
    (Some countries do prefer to use their own cipher, largely because they don’t
    want to use a US standard, but AES is actually more Belgian than it is American.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: NIST在2000年将AES标准化，作为DES的替代方案，至此它成为全球公认的加密标准。今天，大多数商业加密产品都支持AES，NSA也已批准其用于保护最高机密的信息。（一些国家确实更喜欢使用自己的加密算法，主要是因为他们不想使用美国标准，但AES实际上比美国更具比利时背景。）
- en: '**NOTE**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*AES used to be called Rijndael (a portmanteau for its inventors’ names, Rijmen
    and Daemen, pronounced like “rain-dull”) when it was one of the 15 candidates
    in the AES competition, the process held by NIST from 1997 to 2000 to specify
    “an unclassified, publicly disclosed encryption algorithm capable of protecting
    sensitive government information well into the next century,” as stated in the
    1997 announcement of the competition in the Federal Register. The AES competition
    was kind of a “Got Talent” competition for cryptographers, where anyone could
    participate by submitting a cipher or breaking other contestants’ ciphers.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*AES曾被称为Rijndael（这是它的发明者Rijmen和Daemen名字的合成词，发音类似于“rain-dull”），当时它是AES竞赛中的15个候选算法之一。该竞赛由NIST在1997至2000年间举办，目的是指定一个“非机密的、公开的加密算法，能够有效保护敏感的政府信息，直至下个世纪”。这项竞赛可以说是加密学家的“天才大赛”，任何人都可以通过提交自己的加密算法或破解其他参赛者的算法来参与。*'
- en: '*AES Internals*'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AES内部结构*'
- en: AES processes blocks of 128 bits using a secret key of 128, 192, or 256 bits,
    with the 128-bit key being the most common because it makes encryption slightly
    faster and because the difference between 128- and 256-bit security is meaningless
    for most applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: AES处理128位的块，使用128、192或256位的密钥，其中128位密钥是最常见的，因为它使加密速度稍快一些，而且128位和256位安全性的差异对于大多数应用来说并不重要。
- en: '![image](../images/f04-03.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-03.jpg)'
- en: '*Figure 4-3: The internal state of AES viewed as a 4 × 4 array of 16 bytes*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：AES的内部状态，视为一个16字节的4 × 4数组*'
- en: Whereas some ciphers work with individual bits or 64-bit words, AES manipulates
    *bytes*. It views a 16-byte plaintext as a two-dimensional array of bytes (*s*
    = *s*[0], *s*[1], … , *s*[15]), as shown in [Figure 4-3](ch04.xhtml#ch4fig3).
    (The letter *s* is used because this array is called the *internal state*, or
    just *state*.) AES transforms the bytes, columns, and rows of this array to produce
    a final value that is the ciphertext.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有些加密算法处理单个比特或64位字，但AES操作的是*字节*。它将16字节的明文视为一个二维的字节数组（*s* = *s*[0]，*s*[1]，…，*s*[15]），如[图4-3](ch04.xhtml#ch4fig3)所示。（字母*s*表示这个数组，因为它被称为*内部状态*，或简称*状态*。）AES通过变换该数组的字节、列和行来生成最终的密文。
- en: In order to transform its state, AES uses an SPN structure like the one shown
    in [Figure 4-4](ch04.xhtml#ch4fig4), with 10 rounds for 128-bit keys, 12 for 192-bit
    keys, and 14 for 256-bit keys.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了变换其状态，AES采用了如[图4-4](ch04.xhtml#ch4fig4)所示的SPN结构，128位密钥使用10轮，192位密钥使用12轮，256位密钥使用14轮。
- en: '![image](../images/f04-04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-04.jpg)'
- en: '*Figure 4-4: The internal operations of AES*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：AES的内部操作*'
- en: '[Figure 4-4](ch04.xhtml#ch4fig4) shows the four building blocks of an AES round
    (note that all but the last round are a sequence of SubBytes, ShiftRows, MixColumns,
    and AddRoundKey):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-4](ch04.xhtml#ch4fig4)展示了AES轮次的四个基本构件（注意，除了最后一轮，所有轮次都是SubBytes、ShiftRows、MixColumns和AddRoundKey的序列）：'
- en: '**AddRoundKey** XORs a round key to the internal state.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**AddRoundKey** 将一个轮密钥与内部状态进行XOR运算。'
- en: '**SubBytes** Replaces each byte (*s*[0], *s*[1], … , *s*[15]) with another
    byte according to an S-box. In this example, the S-box is a lookup table of 256
    elements.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**SubBytes** 用一个S盒根据查找表替换每个字节（*s*[0]、*s*[1]、…、*s*[15]）。在这个例子中，S盒是一个包含256个元素的查找表。'
- en: '**ShiftRows** Shifts the *i*th row of *i* positions, for *i* ranging from 0
    to 3 (see [Figure 4-5](ch04.xhtml#ch4fig5)).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**ShiftRows** 将第*i*行按*i*个位置进行移位，*i*的范围从0到3（见[图4-5](ch04.xhtml#ch4fig5)）。'
- en: '**MixColumns** Applies the same linear transformation to each of the four columns
    of the state (that is, each group of cells with the same shade of gray, as shown
    on the left side of [Figure 4-5](ch04.xhtml#ch4fig5)).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**MixColumns** 对状态的四列（即每组具有相同灰度的单元格，如[图4-5](ch04.xhtml#ch4fig5)左侧所示）应用相同的线性变换。'
- en: Remember that in an SPN, the *S* stands for substitution and the *P* for permutation.
    Here, the substitution layer is SubBytes and the permutation layer is the combination
    of ShiftRows and MixColumns.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在SPN中，*S*代表替代（substitution），*P*代表置换（permutation）。在这里，替代层是SubBytes，置换层是ShiftRows和MixColumns的组合。
- en: The key schedule function *KeyExpansion*, shown in [Figure 4-4](ch04.xhtml#ch4fig4),
    is the AES key schedule algorithm. This expansion creates 11 round keys (*K*[0],
    *K*[1], … , *K*[10]) of 16 bytes each from the 16-byte key, using the same S-box
    as SubBytes and a combination of XORs. One important property of KeyExpansion
    is that given any round key, *K*[*i*], an attacker can determine all other round
    keys as well as the main key, *K*, by reversing the algorithm. The ability to
    get the key from any round key is usually seen as an imperfect defense against
    side-channel attacks, where an attacker may easily recover a round key.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥调度函数*KeyExpansion*，如[图4-4](ch04.xhtml#ch4fig4)所示，是AES的密钥调度算法。该扩展使用与SubBytes相同的S盒和一系列XOR操作，从16字节密钥中创建11个轮密钥（*K*[0]、*K*[1]、…、*K*[10]），每个轮密钥为16字节。KeyExpansion的一个重要特性是，给定任何轮密钥
    *K*[*i*]，攻击者可以通过反转算法确定所有其他轮密钥以及主密钥 *K*。从任何轮密钥中获取密钥的能力通常被视为对抗旁道攻击的一种不完美防御，因为攻击者可以轻松恢复一个轮密钥。
- en: '![image](../images/f04-05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-05.jpg)'
- en: '*Figure 4-5: ShiftRows rotates bytes within each row of the internal state.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：ShiftRows在内部状态的每一行内旋转字节。*'
- en: 'Without these operations, AES would be totally insecure. Each operation contributes
    to AES’s security in a specific way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这些操作，AES将完全不安全。每个操作以特定的方式贡献了AES的安全性：
- en: Without KeyExpansion, all rounds would use the same key, *K*, and AES would
    be vulnerable to slide attacks.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有KeyExpansion，所有轮次都将使用相同的密钥 *K*，AES将容易受到滑动攻击。
- en: Without AddRoundKey, encryption wouldn’t depend on the key; hence, anyone could
    decrypt any ciphertext without the key.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有AddRoundKey，加密就不再依赖于密钥，因此任何人都可以在没有密钥的情况下解密任何密文。
- en: SubBytes brings nonlinear operations, which add cryptographic strength. Without
    it, AES would just be a large system of linear equations that is solvable using
    high-school algebra.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SubBytes引入了非线性操作，增强了加密强度。如果没有它，AES将只是一个可以用高中代数解出的线性方程的大系统。
- en: Without ShiftRows, changes in a given column would never affect the other columns,
    meaning you could break AES by building four 2^(32)-element codebooks for each
    column. (Remember that in a secure block cipher, flipping a bit in the input should
    affect all the output bits.)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有ShiftRows，给定列中的变化将永远不会影响其他列，这意味着你可以通过为每列构建四个2^(32)元素的代码本来破解AES。（记住，在安全的分组密码中，输入中翻转一个位应影响所有输出位。）
- en: Without MixColumns, changes in a byte would not affect any other bytes of the
    state. A chosen-plaintext attacker could then decrypt any ciphertext after storing
    16 lookup tables of 256 bytes each that hold the encrypted values of each possible
    value of a byte.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有MixColumns，字节的变化不会影响状态中的任何其他字节。这样，一个选择明文的攻击者就可以通过存储16个查找表（每个查找表256字节）来解密任何密文，这些查找表包含每个字节所有可能值的加密值。
- en: 'Notice in [Figure 4-4](ch04.xhtml#ch4fig4) that the last round of AES doesn’t
    include the MixColumns operation. That operation is omitted in order to save useless
    computation: because MixColumns is linear (meaning, predictable), you could cancel
    its effect in the very last round by combining bits in a way that doesn’t depend
    on their value or the key. SubBytes, however, can’t be inverted without the state’s
    value being known prior to AddRoundKey.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[图 4-4](ch04.xhtml#ch4fig4)中，AES 的最后一轮不包括 MixColumns 操作。为了节省无用的计算，省略了该操作：因为
    MixColumns 是线性的（即可预测的），你可以通过以不依赖于其值或密钥的方式组合位来取消其在最后一轮的效果。然而，SubBytes 不能在不知道状态值的情况下进行逆操作，除非在
    AddRoundKey 之前已经知道状态值。
- en: 'To decrypt a ciphertext, AES unwinds each operation by taking its inverse function:
    the inverse lookup table of SubBytes reverses the SubBytes transformation, ShiftRow
    shifts in the opposite direction, MixColumns’s inverse is applied (as in the matrix
    inverse of the matrix encoding its operation), and AddRoundKey’s XOR is unchanged
    because the inverse of an XOR is another XOR.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密密文，AES 通过取其逆函数来解开每个操作：SubBytes 的逆查找表反转 SubBytes 转换，ShiftRow 反向移位，MixColumns
    的逆应用（就像矩阵编码其操作的矩阵逆），而 AddRoundKey 的 XOR 保持不变，因为 XOR 的逆仍然是另一个 XOR。
- en: '*AES in Action*'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AES 实践*'
- en: To try encrypting and decrypting with AES, you can use Python’s crypto­graphy
    library, as in [Listing 4-1](ch04.xhtml#ch4list1).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试使用 AES 进行加密和解密，你可以使用 Python 的加密库，如[列表 4-1](ch04.xhtml#ch4list1)所示。
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: Trying AES with Python’s cryptography library*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-1：使用 Python 的加密库尝试 AES*'
- en: 'Running this script produces something like the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本将生成类似以下的输出：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’ll get different results because the key is randomized at every new execution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到不同的结果，因为每次执行时密钥都会随机化。
- en: Implementing AES
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 AES
- en: Real AES software works differently than the algorithm shown in [Figure 4-4](ch04.xhtml#ch4fig4).
    You won’t find production-level AES code calling a `SubBytes()` function, then
    a `ShiftRows()` function, and then a `MixColumns()` function because that would
    be inefficient. Instead, fast AES software uses special techniques called table-based
    implementations and native instructions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的 AES 软件与[图 4-4](ch04.xhtml#ch4fig4)中展示的算法有所不同。你不会在生产级的 AES 代码中看到调用 `SubBytes()`
    函数、然后是 `ShiftRows()` 函数，再然后是 `MixColumns()` 函数，因为那样效率低下。相反，快速的 AES 软件使用一种称为基于表的实现和本地指令的特殊技术。
- en: '*Table-Based Implementations*'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基于表的实现*'
- en: Table-based implementations of AES replace the sequence SubBytes-ShiftRows-MixColumns
    with a combination of XORs and lookups in tables hardcoded into the program and
    loaded in memory at execution time. This is possible because MixColumns is equivalent
    to XORing four 32-bit values, where each depends on a single byte from the state
    and on SubBytes. Thus, you can build four tables with 256 entries each, one for
    each byte value, and implement the sequence SubBytes-MixColumns by looking up
    four 32-bit values and XORing them together.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 基于表的 AES 实现将 SubBytes-ShiftRows-MixColumns 序列替换为 XOR 和查找表的组合，这些表在程序中硬编码并在执行时加载到内存中。这是可能的，因为
    MixColumns 等同于对四个 32 位值进行 XOR 操作，每个值都依赖于状态中的一个字节和 SubBytes。因此，你可以构建四个包含 256 个条目的表格，每个字节值一个，使用查找四个
    32 位值并将它们 XOR 合起来来实现 SubBytes-MixColumns 序列。
- en: For example, the table-based C implementation in the OpenSSL toolkit looks like
    [Listing 4-2](ch04.xhtml#ch4list2).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，OpenSSL 工具包中的基于表的 C 实现如下所示：[列表 4-2](ch04.xhtml#ch4list2)。
- en: '/* round 1: */'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: /* 第一轮：*/
- en: t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3
    & 0xff] ^ rk[ 4];
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3
    & 0xff] ^ rk[ 4];
- en: t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0
    & 0xff] ^ rk[ 5];
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0
    & 0xff] ^ rk[ 5];
- en: t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1
    & 0xff] ^ rk[ 6];
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1
    & 0xff] ^ rk[ 6];
- en: t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2
    & 0xff] ^ rk[ 7];
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2
    & 0xff] ^ rk[ 7];
- en: '/* round 2: */'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: /* 第二轮：*/
- en: s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3
    & 0xff] ^ rk[ 8];
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3
    & 0xff] ^ rk[ 8];
- en: s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0
    & 0xff] ^ rk[ 9];
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0
    & 0xff] ^ rk[ 9];
- en: s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1
    & 0xff] ^ rk[10];
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1
    & 0xff] ^ rk[10];
- en: s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2
    & 0xff] ^ rk[11];
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2
    & 0xff] ^ rk[11];
- en: --snip--
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '*Listing 4-2: The table-based C implementation of AES in OpenSSL*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-2：OpenSSL中的基于表格的AES C实现*'
- en: A basic table-based implementation of AES encryption needs four kilobytes’ worth
    of tables because each table stores 256 32-bit values, which occupy 256 × 32 =
    8192 bits, or one kilobyte. Decryption requires another four tables, and thus
    four more kilobytes. But there are tricks to reduce the storage from four kilobytes
    to one, or even fewer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的基于表格的AES加密实现需要四千字节的表格，因为每个表格存储256个32位值，分别占用256 × 32 = 8192位，或者一千字节。解密还需要另外四个表格，因此总共需要四千字节的存储。但有一些技巧可以将存储需求从四千字节减少到一千字节，甚至更少。
- en: Alas, table-based implementations are vulnerable to *cache-timing attacks*,
    which exploit timing variations when a program reads or writes elements in cache
    memory. Depending on the relative position in cache memory of the elements accessed,
    access time varies. Timings thus leak information about which element was accessed,
    which in turn leaks information on the secrets involved.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，基于表格的实现容易受到*缓存时间攻击*的影响，这种攻击通过利用程序读取或写入缓存内存元素时的时间差异来进行。根据访问的元素在缓存内存中的相对位置，访问时间会有所不同。于是，时间差泄露了关于访问了哪个元素的信息，而这又进一步泄露了涉及的密钥信息。
- en: 'Cache-timing attacks are difficult to avoid. One obvious solution would be
    to ditch lookup tables altogether by writing a program whose execution time doesn’t
    depend on its inputs, but that’s almost impossible to do and still retain the
    same speed, so chip manufacturers have opted for a radical solution: instead of
    relying on potentially vulnerable software, they rely on *hardware*.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存时间攻击难以避免。一种显而易见的解决方案是完全放弃查找表，编写一个程序，使得执行时间不依赖于输入，但要做到这一点几乎是不可能的，并且仍能保持相同的速度。因此，芯片制造商采取了一个激进的解决方案：他们不依赖于可能存在漏洞的软件，而是依赖于*硬件*。
- en: '*Native Instructions*'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*原生指令*'
- en: 'AES native instructions (AES-NI) solve the problem of cache-timing attacks
    on AES software implementations. To understand how AES-NI works, you need to think
    about the way software runs on hardware: to run a program, a microprocessor translates
    binary code into a series of instructions executed by integrated circuit components.
    For example, a `MUL` assembly instruction between two 32-bit values will activate
    the transistors implementing a 32-bit multiplier in the microprocessor. To implement
    a crypto algorithm, we usually just express a combination of such basic operations—additions,
    multiplications, XORs, and so on—and the microprocessor activates its adders,
    multipliers, and XOR circuits in the prescribed order.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: AES原生指令（AES-NI）解决了AES软件实现中缓存时间攻击的问题。要理解AES-NI的工作原理，你需要考虑软件在硬件上运行的方式：要运行一个程序，微处理器将二进制代码翻译成由集成电路组件执行的一系列指令。例如，`MUL`汇编指令在两个32位值之间执行时，将激活微处理器中实现32位乘法器的晶体管。要实现一个加密算法，我们通常只是表达这种基本操作的组合——加法、乘法、异或等——然后微处理器按照预定顺序激活其加法器、乘法器和异或电路。
- en: AES native instructions take this to a whole new level by providing developers
    with dedicated assembly instructions that compute AES. Instead of coding an AES
    round as a sequence of assembly instructions, when using AES-NI, you just call
    the instruction `AESENC` and the chip will compute the round for you. Native instructions
    allow you to just tell the processor to run an AES round instead of requiring
    you to program rounds as a combination of basic operations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: AES原生指令通过为开发者提供专门的汇编指令来计算AES，达到了全新的高度。使用AES-NI时，你不需要将AES轮次编程为一系列的汇编指令，而只需调用指令`AESENC`，芯片就会为你计算这一轮。原生指令让你可以直接告诉处理器运行一个AES轮次，而不需要将轮次编程为基本操作的组合。
- en: A typical assembly implementation of AES using native instructions looks like
    [Listing 4-3](ch04.xhtml#ch4list3).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生指令的AES典型汇编实现可以参考[列表 4-3](ch04.xhtml#ch4list3)。
- en: '[PRE2]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 4-3: AES native instructions*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-3：AES原生指令*'
- en: This code encrypts the 128-bit plaintext initially in the register `xmm0`, assuming
    that registers `xmm5` to `xmm15` hold the precomputed round keys, with each instruction
    writing its result into `xmm0`. The initial `PXOR` instruction XORs the first
    round key prior to computing the first round, and the final `AESENCLAST` instruction
    performs the last round slightly different from the others (MixColumns is omitted).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 128 位明文最初存放在寄存器 `xmm0` 中，假设寄存器 `xmm5` 到 `xmm15` 存储着预计算好的轮密钥，每条指令将结果写入
    `xmm0`。初始的 `PXOR` 指令在计算第一轮之前对第一个轮密钥进行异或运算，最后的 `AESENCLAST` 指令在执行最后一轮时略有不同（MixColumns
    被省略）。
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*AES is about ten times faster on platforms that implement native instructions,
    which as I write this, are virtually all laptop, desktop, and server microprocessors,
    as well as most mobile phones and tablets. In fact, on the latest Intel microarchitecture
    the AESENC instruction has a latency of four cycles with a reciprocal throughput
    of one cycle, meaning that a call to AESENC takes four cycles to complete and
    that a new call can be made every cycle. To encrypt a series of blocks consecutively
    it thus takes 4 × 10 = 40 cycles to complete the 10 rounds or 40 / 16 = 2.5 cycles
    per byte. At 2 GHz (2 × 10 ⁹ cycles per second), that gives a throughput of about
    736 megabytes per second. If the blocks to encrypt or decrypt are independent
    of each other, as certain modes of operation allow, then four blocks can be processed
    in parallel to take full advantage of the AESENC circuit in order to reach a latency
    of 10 cycles per block instead of 40, or about 3 gigabytes per second.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*AES 在实现了本地指令的平台上速度大约是普通平台的十倍，当前几乎所有的笔记本、台式机和服务器微处理器，以及大多数手机和平板都实现了这些本地指令。事实上，在最新的英特尔微架构上，AESENC
    指令的延迟为四个周期，反向吞吐量为一个周期，这意味着调用 AESENC 需要四个周期完成，并且每个周期都可以进行新的调用。连续加密一系列数据块时，因此完成
    10 轮加密需要 4 × 10 = 40 个周期，或者 40 / 16 = 每字节 2.5 个周期。在 2 GHz（每秒 2 × 10⁹ 个周期）的频率下，这意味着约每秒
    736 兆字节的吞吐量。如果待加密或解密的数据块是独立的，如某些操作模式所允许，那么可以并行处理四个数据块，以充分利用 AESENC 电路，从而将每个数据块的延迟从
    40 个周期缩短到 10 个周期，吞吐量约为每秒 3 吉字节。*'
- en: '*Is AES Secure?*'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AES 是否安全？*'
- en: AES is as secure as a block cipher can be, and it will never be broken. Fundamentally,
    AES is secure because all output bits depend on all input bits in some complex,
    pseudorandom way. To achieve this, the designers of AES carefully chose each component
    for a particular reason—MixColumns for its maximal diffusion properties and SubBytes
    for its optimal non-linearity—and they have shown that this composition protects
    AES against whole classes of cryptanalytic attacks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: AES 和所有块密码一样安全，且永远不会被破解。从根本上说，AES 的安全性来源于所有输出位都依赖于所有输入位，以某种复杂的伪随机方式进行处理。为了实现这一点，AES
    的设计者们仔细选择了每个组成部分，每个选择都有其特定原因——MixColumns 以其最大的扩散特性和 SubBytes 以其最优的非线性特性——并且他们已证明这种组合可以保护
    AES 免受一系列密码分析攻击。
- en: 'But there’s no proof that AES is immune to all possible attacks. For one thing,
    we don’t know what all possible attacks are, and we don’t always know how to prove
    that a cipher is secure against a given attack. The only way to really gain confidence
    in the security of AES is to crowdsource attacks: have many skilled people attempt
    to break AES and, hopefully, fail to do so.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是并没有证据证明 AES 对所有可能的攻击都免疫。首先，我们并不知道所有可能的攻击是什么，而且我们也不总是知道如何证明一个密码算法能抵御某种特定的攻击。真正获得对
    AES 安全性信心的唯一方法就是众包攻击：让许多技术熟练的人尝试破解 AES，并且希望他们未能成功。
- en: After more than 15 years and hundreds of research publications, the theoretical
    security of AES has only been scratched. In 2011 cryptanalysts found a way to
    recover an AES-128 key by performing about 2^(126) operations instead of 2^(128),
    a speed-up of a factor four. But this “attack” requires an insane amount of plaintext–ciphertext
    pairs—about 2^(88) bits worth. In other words, it’s a nice finding but not one
    you need to worry about.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在超过 15 年和数百篇研究论文之后，AES 的理论安全性只被轻微触及。2011 年，密码分析学家发现通过进行大约 2^(126) 次操作而非 2^(128)
    次操作，可以恢复 AES-128 密钥，这相当于加速了四倍。但这种“攻击”需要大量的明文-密文对——大约 2^(88) 位。这意味着虽然是个有趣的发现，但并不是你需要担心的事情。
- en: The upshot is that you should care about a million things when implementing
    and deploying crypto, but AES security is not one of those. The biggest threat
    to block ciphers isn’t in their core algorithms but in their modes of operation.
    When an incorrect mode is chosen, or when the right one is misused, even a strong
    cipher like AES won’t save you.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是，在实现和部署加密时，你需要关心很多事情，但 AES 的安全性并不是其中之一。对分组密码的最大威胁并不来自它们的核心算法，而是它们的操作模式。当选择了不正确的模式，或者正确的模式被滥用时，即使是像
    AES 这样的强加密算法也无法保护你。
- en: Modes of Operation
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作模式
- en: 'In [Chapter 1](ch01.xhtml#ch1), I explained how encryption schemes combine
    a permutation with a mode of operation to handle messages of any length. In this
    section, I’ll cover the main modes of operations used by block ciphers, their
    security and function properties, and how (not) to use them. I’ll begin with the
    dumbest one: electronic codebook.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.xhtml#ch1) 中，我解释了加密方案如何结合置换和操作模式来处理任意长度的消息。在本节中，我将介绍分组密码常用的主要操作模式、它们的安全性和功能特性，以及如何（不）使用它们。我将从最愚蠢的一个开始：电子代码本。
- en: '*The Electronic Codebook (ECB) Mode*'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*电子代码本（ECB）模式*'
- en: '![image](../images/f04-06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-06.jpg)'
- en: '*Figure 4-6: The ECB mode*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：ECB 模式*'
- en: 'The simplest of the block cipher encryption modes is electronic codebook (ECB),
    which is barely a mode of operation at all. ECB takes plaintext blocks *P*[1],
    *P*[2], … , *P*[*N*] and processes each independently by computing *C*[1] = **E**(*K*,
    *P*[1]), *C*[2] = **E**(*K*, *P*[2]), and so on, as shown in [Figure 4-6](ch04.xhtml#ch4fig6).
    It’s a simple operation but also an insecure one. I repeat: ECB is insecure and
    you should not use it!'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的分组密码加密模式是电子代码本（ECB），它几乎不算是一种操作模式。ECB 将明文块 *P*[1]、*P*[2]、…、*P*[*N*] 分别处理，通过计算
    *C*[1] = **E**(*K*, *P*[1])，*C*[2] = **E**(*K*, *P*[2])，依此类推，如 [图 4-6](ch04.xhtml#ch4fig6)
    所示。这是一个简单的操作，但也是一个不安全的操作。我再重复一遍：ECB 是不安全的，你不应该使用它！
- en: Marsh Ray, a cryptographer at Microsoft, once said, “Everybody knows ECB mode
    is bad because we can see the penguin.” He was referring to a famous illustration
    of ECB’s insecurity that uses an image of Linux’s mascot, Tux, as shown in [Figure
    4-7](ch04.xhtml#ch4fig7). You can see the original image of Tux on the left, and
    the image encrypted in ECB mode using AES (though the underlying cipher doesn’t
    matter) on the right. It’s easy to see the penguin’s shape in the encrypted version
    because all the blocks of one shade of gray in the original image are encrypted
    to the same new shade of gray in the new image; in other words, ECB encryption
    just gives you the same image but with different colors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的密码学家 Marsh Ray 曾说过：“每个人都知道 ECB 模式不好，因为我们可以看到企鹅。”他指的是一个著名的示例，展示了 ECB 不安全性的图像，使用了
    Linux 吉祥物 Tux 的图像，如 [图 4-7](ch04.xhtml#ch4fig7) 所示。你可以看到左侧是 Tux 的原始图像，右侧是用 AES
    加密的 ECB 模式图像（尽管底层的加密算法并不重要）。由于原始图像中相同灰度的所有块被加密为新图像中相同的灰度，因此很容易在加密后的版本中看到企鹅的形状；换句话说，ECB
    加密只是给你一个相同的图像，但颜色不同。
- en: '![image](../images/f04-07.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f04-07.jpg)'
- en: '*Figure 4-7: The original image (left) and the ECB-encrypted image (right)*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7：原始图像（左）和 ECB 加密后的图像（右）*'
- en: The Python program in [Listing 4-4](ch04.xhtml#ch4list4) also shows ECB’s insecurity.
    It picks a pseudorandom key and encrypts a 32-byte message `p` containing two
    blocks of null bytes. Notice that encryption yields two identical blocks and that
    repeating encryption with the same key and the same plaintext yields the same
    two blocks again.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-4](ch04.xhtml#ch4list4) 中的 Python 程序也展示了 ECB 的不安全性。它选择一个伪随机密钥并加密一个包含两个空字节块的
    32 字节消息 `p`。请注意，加密后的结果是两个相同的块，且使用相同的密钥和相同的明文重复加密时，结果再次是这两个相同的块。'
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 4-4: Using AES in ECB mode in Python*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-4：在 Python 中使用 AES 的 ECB 模式*'
- en: 'Running this script gives ciphertext blocks like this, for example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本会得到像这样的密文块，例如：
- en: '[PRE4]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, when the ECB mode is used, identical ciphertext blocks reveal
    identical plaintext blocks to an attacker, whether those are blocks within a single
    ciphertext or across different ciphertexts. This shows that block ciphers in ECB
    mode aren’t semantically secure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当使用 ECB 模式时，相同的密文块会向攻击者透露相同的明文块，无论这些是单一密文中的块，还是不同密文中的块。这表明，ECB 模式下的分组密码并不具备语义安全性。
- en: Another problem with ECB is that it only takes complete blocks of data, so if
    blocks were 16 bytes, as in AES, you could only encrypt chunks of 16 bytes, 32
    bytes, 48 bytes, or any other multiple of 16 bytes. There are a few ways to deal
    with this, as you’ll see with the next mode, CBC. (I won’t tell you how these
    tricks work with ECB because you shouldn’t be using ECB in the first place.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '*The Cipher Block Chaining (CBC) Mode*'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cipher block chaining (CBC) is like ECB but with a small twist that makes a
    big difference: instead of encrypting the *i*th block, *P*[*i*], as *C*[*i*] =
    **E**(*K*, *P*[*i*]), CBC sets *C*[*i*] = **E**(*K*, *P*[*i*] ⊕ *C*[*i* − 1]),
    where *C*[*i* − 1] is the previous ciphertext block—thereby *chaining* the blocks
    *C*[*i* − 1] and *C*[*i*]. When encrypting the first block, *P*[1], there is no
    previous ciphertext block to use, so CBC takes a random initial value (IV), as
    shown in [Figure 4-8](ch04.xhtml#ch4fig8).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-08.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: The CBC mode*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The CBC mode makes each ciphertext block dependent on all the previous blocks,
    and ensures that identical plaintext blocks won’t be identical ciphertext blocks.
    The random initial value guarantees that two identical plaintexts will encrypt
    to distinct ciphertexts when calling the cipher twice with two distinct initial
    values.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-5](ch04.xhtml#ch4list5) illustrates these two benefits. This program
    takes an all-zero, 32-byte message (like the one in [Listing 4-4](ch04.xhtml#ch4list4)),
    encrypts it twice with CBC, and shows the two ciphertexts. The line `iv = urandom(16)`,
    shown in bold, picks a new random IV for each new encryption.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '#!/usr/bin/env python'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: from cryptography.hazmat.backends import default_backend
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: from binascii import hexlify as hexa
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: from os import urandom
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: BLOCKLEN = 16
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: the blocks() function splits a data string into space-separated blocks
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def blocks(data):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: split = [hexa(data[i:i+BLOCKLEN]) for i in range(0, len(data), BLOCKLEN)]
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: return ' '.join(split)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: k = urandom(16)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: print 'k = %s' % hexa(k)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: pick a random IV
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iv = urandom(16)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: print 'iv = %s' % hexa(iv)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: pick an instance of AES in CBC mode
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: aes = Cipher(algorithms.AES(k), modes.CBC(iv), backend=default_backend()).encryptor()
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: p = '\x00'*BLOCKLEN*2
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: c = aes.update(p) + aes.finalize()
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: print 'enc(%s) = %s' % (blocks(p), blocks(c))
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: now with a different IV and the same key
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iv = urandom(16)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: print 'iv = %s' % hexa(iv)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: aes = Cipher(algorithms.AES(k), modes.CBC(iv), backend=default_backend()).encryptor()
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: c = aes.update(p) + aes.finalize()
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: print 'enc(%s) = %s' % (blocks(p), blocks(c))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-5: Using AES in CBC mode*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The two plaintexts are the same (two all-zero blocks), but the encrypted blocks
    should be distinct, as in this example execution:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Alas, CBC is often used with a constant IV instead of a random one, which exposes
    identical plaintexts and plaintexts that start with identical blocks. For example,
    say the two-block plaintext *P*[1] || *P*[2] is encrypted in CBC mode to the two-block
    ciphertext *C*[1] || *C*[2]. If *P*[1] || *P*[2]′ is encrypted with the same IV,
    where *P*[2]′ is some block distinct from *P*[2], then the ciphertext will look
    like *C*[1] || *C*[2]′, with *C*[2]′ different from *C*[2] but with the same first
    block *C*[1]. Thus, an attacker can guess that the first block is the same for
    both plaintexts, even though they only see the ciphertexts.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '*In CBC mode, decryption needs to know the IV used to encrypt, so the IV is
    sent along with the ciphertext, in the clear.*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: With CBC, decryption can be much faster than encryption due to parallelism.
    While encryption of a new block, *P*[*i*]*,* needs to wait for the previous block,
    *C*[*i* − 1], decryption of a block computes *P*[*i*] = **D**(*K*, *C*[*i*]) ⊕
    *C*[*i* − 1], where there’s no need for the previous plaintext block, *P*[*i*
    − 1]. This means that all blocks can be decrypted in parallel simultaneously,
    as long as you also know the previous ciphertext block, which you usually do.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*How to Encrypt Any Message in CBC Mode*'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s circle back to the block termination issue and look at how to process
    a plaintext whose length is not a multiple of the block length. For example, how
    would we encrypt an 18-byte plaintext with AES-CBC when blocks are 16 bytes? What
    do we do with the two bytes left? We’ll look at two widely used techniques to
    deal with this problem. The first one, padding, makes the ciphertext a bit longer
    than the plaintext, while the second one, *ciphertext stealing*, produces a ciphertext
    of the same length as the plaintext.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Padding a Message
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Padding is a technique that allows you to encrypt a message of any length, even
    one smaller than a single block. Padding for block ciphers is specified in the
    PKCS#7 standard and in RFC 5652, and is used almost everywhere CBC is used, such
    as in some HTTPS connections.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Padding is used to expand a message to fill a complete block by adding extra
    bytes to the plaintext. Here are the rules for padding 16-byte blocks:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: If there’s one byte left—for example, if the plaintext is 1 byte, 17 bytes,
    or 33 bytes long—pad the message with 15 bytes 0f (15 in decimal).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are two bytes left, pad the message with 14 bytes 0e (14 in decimal).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are three bytes left, pad the message with 13 bytes 0d (13 in decimal).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are 15 plaintext bytes and a single byte missing to fill a block, padding
    adds a single 01 byte. If the plaintext is already a multiple of 16, the block
    length, add 16 bytes 10 (16 in decimal). You get the idea. The trick generalizes
    to any block length up to 255 bytes (for larger blocks, a byte is too small to
    encode values greater than 255).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption of a padded message works like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Decrypt all the blocks as with unpadded CBC.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the last bytes of the last block conform to the padding rule:
    that they finish with at least one 01 byte, at least two 02 bytes, or at least
    three 03 bytes, and so on. If the padding isn’t valid—for example, if the last
    bytes are 01 02 03—the message is rejected. Otherwise, decryption strips the padding
    bytes and returns the plaintext bytes left.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One downside of padding is that it makes ciphertext longer by at least one byte
    and at most a block.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext Stealing
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Ciphertext stealing is another trick used to encrypt a message whose length
    isn’t a multiple of the block size. Ciphertext stealing is more complex and less
    popular than padding, but it offers at least three benefits:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Plaintexts can be of any *bit* length, not just bytes. You can, for example,
    encrypt a message of 131 bits.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ciphertexts are exactly the same length as plaintexts.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ciphertext stealing is not vulnerable to padding oracle attacks, powerful attacks
    that sometimes work against CBC with padding (as we’ll see in [“Padding Oracle
    Attacks”](ch04.xhtml#lev2sec63) on page 74).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In CBC mode, ciphertext stealing extends the last incomplete plaintext block
    with bits from the previous ciphertext block, and then encrypts the resulting
    block. The last, incomplete ciphertext block is made up of the first blocks from
    the previous ciphertext block; that is, the bits that have not been appended to
    the last plaintext block.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-09.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: Ciphertext stealing for CBC-mode encryption*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 4-9](ch04.xhtml#ch4fig9), we have three blocks, where the last block,
    *P*[3], is incomplete (represented by a zero). *P*[3] is XORed with the last bits
    from the previous ciphertext block, and the encrypted result is returned as *C*[2].
    The last ciphertext block, *C*[3], then consists of the first bits from the previous
    ciphertext block. Decryption is simply the inverse of this operation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t any major problems with ciphertext stealing, but it’s inelegant
    and hard to get right, especially when NIST’s standard specifies three different
    ways to implement it (see Special Publication 800-38A).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '*The Counter (CTR) Mode*'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To avoid the troubles and retain the benefits of ciphertext stealing, you should
    use counter mode (CTR). CTR is hardly a block cipher mode: it turns a block cipher
    into a stream cipher that just takes bits in and spits bits out and doesn’t embarrass
    itself with the notion of blocks. (I’ll discuss stream ciphers in detail in [Chapter
    5](ch05.xhtml#ch5).)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-10.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: The CTR mode*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In CTR mode (see [Figure 4-10](ch04.xhtml#ch4fig10)), the block cipher algorithm
    won’t transform plaintext data. Instead, it will encrypt blocks composed of a
    *counter* and a *nonce*. A counter is an integer that is incremented for each
    block. No two blocks should use the same counter within a message, but different
    messages can use the same sequence of counter values (1, 2, 3, …). A nonce is
    a number used only once. It is the same for all blocks in a single message, but
    no two messages should use the same nonce.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 4-10](ch04.xhtml#ch4fig10), in CTR mode, encryption XORs
    the plaintext and the stream taken from “encrypting” the nonce, *N*, and counter,
    *Ctr*. Decryption is the same, so you only need the encryption algorithm for both
    encryption and decryption. The Python script in [Listing 4-6](ch04.xhtml#ch4list6)
    gives you a hands-on example.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 4-6: Using AES in CTR mode*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'The example execution encrypts a 4-byte plaintext and gets a 4-byte ciphertext.
    It then decrypts that ciphertext using the encryption function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As with the initial value in CBC, CTR’s nonce is supplied by the encrypter
    and sent with the ciphertext in the clear. But unlike CBC’s initial value, CTR’s
    nonce doesn’t need to be random, it simply needs to be unique. A nonce should
    be unique for the same reason that a one-time pad shouldn’t be reused: when calling
    the pseudorandom stream, *S*, if you encrypt *P*[1] to *C*[1] = *P*[1] ⊕ *S* and
    *P*[2] to *C*[2] = *P*[2] ⊕ *S* using the same nonce, then *C*[1] ⊕ *C*[2] reveals
    *P*[1] ⊕ *P*[2].'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: A random nonce will do the trick only if it’s long enough; for example, if the
    nonce is *n* bits, chances are that after 2^(*N*/ 2) encryptions and as many nonces
    you’ll run into duplicates. Sixty-four bits are therefore insufficient for a random
    nonce, since you can expect a repetition after approximately 2^(32) nonces, which
    is an unacceptably low number.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The counter is guaranteed unique if it’s incremented for every new plaintext,
    and if it’s long enough; for example, a 64-bit counter.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: One particular benefit to CTR is that it can be faster than in any other mode.
    Not only is it parallelizable, but you can also start encrypting even before knowing
    the message by picking a nonce and computing the stream that you’ll later XOR
    with the plaintext.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: How Things Can Go Wrong
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two must-know attacks on block ciphers: meet-in-the-middle attacks,
    a technique discovered in the 1970s but still used in many cryptanalytic attacks
    (not to be confused with man-in-the-middle attacks), and padding oracle attacks,
    a class of attacks discovered in 2002 by academic cryptographers, then mostly
    ignored, and finally rediscovered a decade later along with several vulnerable
    applications.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '*Meet-in-the-Middle Attacks*'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The 3DES block cipher is an upgraded version of the 1970s standard DES that
    takes a key of 56 × 3 = 168 bits (an improvement on DES’s 56-bit key). But the
    security level of 3DES is 112 bits instead of 168 bits, because of the *meet-in-the-middle
    (MitM)* attack.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in [Figure 4-11](ch04.xhtml#ch4fig11), 3DES encrypts a block
    using the DES encryption and decryption functions: first encryption with a key,
    *K*[1], then decryption with a key, *K*[2], and finally encryption with another
    key, *K*[3]. If *K*[1] = *K*[2], the first two calls cancel themselves out and
    3DES boils down to a single DES with key *K*[3]. 3DES does encrypt-decrypt-encrypt
    rather than encrypting thrice to allow systems to emulate DES when necessary using
    the new 3DES interface.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-11.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: The 3DES block cipher construction*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Why use triple DES and not just double DES, that is, **E**(*K*[1], **E**(*K*[2],
    *P*))? It turns out that the MitM attack makes double DES only as secure as single
    DES. [Figure 4-12](ch04.xhtml#ch4fig12) shows the MitM attack in action.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-12.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: The meet-in-the-middle attack*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The meet-in-the-middle attack works as follows to attack double DES:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Say you have *P* and *C* = **E**(*K*[2], **E**(*K*[1], *P*)) with two unknown
    56-bit keys, *K*[1] and *K*[2]. (DES takes 56-bit keys, so double DES takes 112
    key bits in total.) You build a key–value table with 2^(56) entries of **E**(*K*[1],
    *P*), where **E** is the DES encryption function and *K*[1] is the value stored.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For all 2^(56) values of *K*[2], compute **D**(*K*[2], *C*) and check whether
    the resulting value appears in the table as an index (thus as a middle value,
    represented by a question mark in [Figure 4-12](ch04.xhtml#ch4fig12)).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a middle value is found as an index of the table, you fetch the corresponding
    *K*[1] from the table and verify that the (*K*[1], *K*[2]) found is the right
    one by using other pairs of *P* and *C*. Encrypt *P* using *K*[1] and *K*[2] and
    then check that the ciphertext obtained is the given *C*.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This method recovers *K*[1] and *K*[2] by performing about 2^(57) instead of
    2^(112) operations: step 1 encrypts 2^(56) blocks and then step 2 decrypts at
    most 2^(56) blocks, for 2^(56) + 2^(56) = 2^(57) operations in total. You also
    need to store 2^(56) elements of 15 bytes each, or about 128 petabytes. That’s
    a lot, but there’s a trick that allows you to run the same attack with only negligible
    memory (as you’ll see in [Chapter 6](ch06.xhtml#ch6)).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can apply the MitM attack to 3DES in almost the same way
    you would to double DES, except that the third stage will go through all 2^(112)
    values of *K*[2] and *K*[3]. The whole attack thus succeeds after performing about
    2^(112) operations, meaning that 3DES gets only 112-bit security despite having
    168 bits of key material.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '*Padding Oracle Attacks*'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s conclude this chapter with one of the simplest and yet most devastating
    attacks of the 2000s: the padding oracle attack. Remember that padding fills the
    plaintext with extra bytes in order to fill a block. A plaintext of 111 bytes,
    for example, is a sequence of six 16-byte blocks followed by 15 bytes. To form
    a complete block, padding adds a 01 byte. For a 110-byte plaintext, padding adds
    two 02 bytes, and so on.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: A *padding oracle* is a system that behaves differently depending on whether
    the padding in a CBC-encrypted ciphertext is valid. You can see it as a black
    box or an API that returns either a *success* or an *error* value. A padding oracle
    can be found in a service on a remote host sending error messages when it receives
    malformed ciphertexts. Given a padding oracle, padding oracle attacks record which
    inputs have a valid padding and which don’t, and exploit this information to decrypt
    chosen ciphertext values.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-13.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-13: Padding oracle attacks recover X by choosing C[1] and checking
    the validity of padding.*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Say you want to decrypt ciphertext block *C*[2]. I’ll call *X* the value you’re
    looking for, namely **D**(*K*, *C*[2]), and *P*[2] the block obtained after decrypting
    in CBC mode (see [Figure 4-13](ch04.xhtml#ch4fig13)). If you pick a random block
    *C*[1] and send the two-block ciphertext *C*[1] || *C*[2] to the oracle, decryption
    will only succeed if *C*[1] ⊕ *P*[2] = *X* ends with valid padding—a single 01
    byte, two 02 bytes, or three 03 bytes, and so on.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this observation, padding oracle attacks on CBC encryption can decrypt
    a block *C*[2] like this (bytes are denoted in array notation: *C*[1][0] is *C*[1]’s
    first byte, *C*[1][1] its second byte, and so on up to *C*[1][15], *C*[1]’s last
    byte):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Pick a random block *C*[1] and vary its last byte until the padding oracle accepts
    the ciphertext as valid. Usually, in a valid ciphertext, *C*[1][15] ⊕ *X*[15]
    = 01, so you’ll find *X*[15] after trying around 128 values of *C*[1][15].
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the value *X*[14] by setting *C*[1][15] to *X*[15] ⊕ 02 and searching for
    the *C*[1][14] that gives correct padding. When the oracle accepts the ciphertext
    as valid, it means you have found *C*[1][14] such that *C*[1][14] ⊕ *X*[14] =
    02.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1 and 2 for all 16 bytes.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attack needs on average 128 queries to the oracle for each of the 16 bytes,
    which is about 2000 queries in total. (Note that each query must use the same
    initial value.)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '*In practice, implementing a padding oracle attack is a bit more complicated
    than what I’ve described, because you have to deal with wrong guesses at step
    1\. A ciphertext may have valid padding not because* P[2] *ends with a single
    01 but because it ends with two 02 bytes or three 03 bytes. But that’s easily
    managed by testing the validity of ciphertexts where more bytes are modified.*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a lot to say about block ciphers, be it in how algorithms work or in
    how they can be attacked. For instance, Feistel networks and SPNs aren’t the only
    ways to build a block cipher. The block ciphers IDEA and FOX use the Lai–Massey
    construction, and Threefish uses ARX networks, a combination of addition, word
    rotations, and XORs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: There are also many more modes than just ECB, CBC, and CTR. Some modes are folklore
    techniques that nobody uses, like CFB and OFB, while others are for specific applications,
    like XTS for tweakable encryption or GCM for authenticated encryption.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve discussed Rijndael, the AES winner, but there were 14 other algorithms
    in the race: CAST-256, CRYPTON, DEAL, DFC, E2, FROG, HPC, LOKI97, Magenta, MARS,
    RC6, SAFER+, Serpent, and Twofish. I recommend that you look them up to see how
    they work, how they were designed, how they have been attacked, and how fast they
    are. It’s also worth checking out the NSA’s designs (Skipjack, and more recently,
    SIMON and SPECK) and more recent “lightweight” block ciphers such as KATAN, PRESENT,
    or PRINCE.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
