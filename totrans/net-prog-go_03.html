<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_17" title="17"/>2</span><br/>&#13;
<span class="ChapterTitle">Resource Location and Traffic Routing</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">To write effective network programs, you need to understand how to use human-readable names to identify nodes on the internet, how those names are translated into addresses for network devices to use, and how traffic makes its way between nodes on the internet, even if they’re on opposite sides of the planet. This chapter covers those topics and more.</p>&#13;
<p>We’ll first have a look at how IP addresses identify hosts on a network. Then we’ll discuss <em>routing</em>, or sending traffic between network hosts that aren’t directly connected, and cover some common routing protocols. Finally, we’ll discuss <em>domain name resolution</em> (the process of translating human-readable names to IP addresses), potential privacy implications of DNS, and the solutions to overcome those privacy concerns.</p>&#13;
<p>You’ll need to understand these topics to provide comprehensive network services and locate the resources used by your services, such as third-party application programming interfaces (APIs). This information should <span epub:type="pagebreak" id="Page_18" title="18"/>also help you debug inevitable network outages or performance issues your code may encounter. For example, say you provide a service that integrates the Google Maps API to provide interactive maps and navigation. Your service would need to properly locate the API endpoint and route traffic to it. Or your service may need to store archives in an Amazon Simple Storage Service (S3) bucket via the Amazon S3 API. In each example, name resolution and routing play an integral role.</p>&#13;
<h2 id="h1-500884c02-0001">The Internet Protocol</h2>&#13;
<p class="BodyFirst">The <em>Internet Protocol (IP)</em> is a set of rules that dictate the format of data sent over a network—specifically, the internet.<em> IP addresses</em> identify nodes on a network at the internet layer of the TCP/IP stack, and you use them to facilitate communication between nodes. </p>&#13;
<p>IP addresses function in the same way as postal addresses; nodes send packets to other nodes by addressing packets to the destination node’s IP address. Just as it’s customary to include a return address on postal mail, packet headers include the IP address of the origin node as well. Some protocols require an acknowledgment of successful delivery, and the destination node can use the origin node’s IP address to send the delivery confirmation.</p>&#13;
<p>Two versions of IP addresses are in public use: IPv4 and IPv6. This chapter covers both.</p>&#13;
<h2 id="h1-500884c02-0002">IPv4 Addressing</h2>&#13;
<p class="BodyFirst"><em>IPv4</em> is the fourth version of the Internet Protocol. It was the first IP version in use on the internet’s precursor, ARPANET, in 1983, and the predominant version in use today. IPv4 addresses are 32-bit numbers arranged in four groups of 8 bits (called <em>octets</em>) separated by decimal points.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>RFCs use the term <em>octet</em> as a disambiguation of the term <em>byte</em>, because a byte’s storage size has historically been platform dependent.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>The total range of 32-bit numbers limits us to just over four billion possible IPv4 addresses. <a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a> shows the binary and decimal representation of an IPv4 address.</p>&#13;
<figure>&#13;
<img alt="f02001" src="image_fi/500884c02/f02001.png"/>&#13;
<figcaption><p><a id="figure2-1">Figure 2-1</a>: Four 8-bit octets representing an IPv4 address in both binary and decimal formats</p></figcaption>&#13;
</figure>&#13;
<p>The first line of <a href="#figure2-1">Figure 2-1</a> illustrates an IPv4 address in binary form. The second line is the IPv4 address’s decimal equivalent. We usually write IPv4 addresses in the more readable decimal format when displaying them or when using them in code. We will use their binary representation when we’re discussing network addressing later in this section.</p>&#13;
<h3 id="h2-500884c02-0001"><span epub:type="pagebreak" id="Page_19" title="19"/>Network and Host IDs</h3>&#13;
<p class="BodyFirst">The 32 bits that compose an IPv4 address represent two components: a network ID and a host ID. The <em>network ID</em> informs the network devices responsible for shuttling packets toward their destination about the next appropriate hop in the transmission. These devices are called <em>routers</em>. Routers are like the mail carrier of a network, in that they accept data from a device, examine the network ID of the destination address, and determine where the data needs to be sent to reach its destination. You can think of the network ID as a mailing address’s ZIP (or postal) code.</p>&#13;
<p>Once the data reaches the destination network, the router uses the <em>host ID</em> to deliver the data to the specific recipient. The host ID is like your street address. In other words, a network ID identifies a group of nodes whose address is part of the same network. We’ll see what network and host IDs look like later in this chapter, but <a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a> shows IPv4 addresses sharing the same network ID.</p>&#13;
<figure>&#13;
<img alt="f02002" src="image_fi/500884c02/f02002.png"/>&#13;
<figcaption><p><a id="figure2-2">Figure 2-2</a>: A group of nodes sharing the same network ID</p></figcaption>&#13;
</figure>&#13;
<p><a href="#figure2-3" id="figureanchor2-3">Figure 2-3</a> shows the breakdown of common network ID and host ID sizes in a 32-bit IPv4 address.</p>&#13;
<figure>&#13;
<img alt="f02003" src="image_fi/500884c02/f02003.png"/>&#13;
<figcaption><p><a id="figure2-3">Figure 2-3</a>: Common network ID and host ID sizes</p></figcaption>&#13;
</figure>&#13;
<p>The network ID portion of an IPv4 address always starts with the leftmost bit, and its size is determined by the size of the network it belongs to. The remaining bits designate the host ID. For example, the first 8 bits of the IPv4 address represent the network ID in an 8-bit network, and the remaining 24 bits represent the host ID.</p>&#13;
<p><span epub:type="pagebreak" id="Page_20" title="20"/><a href="#figure2-4" id="figureanchor2-4">Figure 2-4</a> shows the IP address 192.168.156.97 divided into its network ID and host ID. This IP address is part of a 16-bit network. This tells us that the first 16 bits form the network ID and the remaining 16 bits form the host ID.</p>&#13;
<figure>&#13;
<img alt="f02004" src="image_fi/500884c02/f02004.png"/>&#13;
<figcaption><p><a id="figure2-4">Figure 2-4</a>: Deriving the network ID and the host ID from an IPv4 address in a 16-bit network</p></figcaption>&#13;
</figure>&#13;
<p>To derive the network ID for this example, you take the first 16 bits and append zeros for the remaining bits to produce the 32-bit network ID of 192.168.0.0. You prepend zeroed bits to the last 16 bits, resulting in the 32-bit host ID of 0.0.156.97.</p>&#13;
<h3 id="h2-500884c02-0002">Subdividing IPv4 Addresses into Subnets</h3>&#13;
<p class="BodyFirst">IPv4’s network and host IDs allow you to <em>subdivide</em>, or partition, the more than four billion IPv4 addresses into smaller groups to keep the network secure and easier to manage. All IP addresses in these smaller networks, called <em>subnets</em>, share the same network ID but have unique host IDs. The size of the network dictates the number of host IDs and, therefore, the number of individual IP addresses in the network.</p>&#13;
<p>Identifying individual networks allows you to control the flow of information between networks. For example, you could split your network into a subnet meant for public services and another for private services. You could then allow external traffic to reach your public services while preventing external traffic from reaching your private network. As another example, your bank provides services such as online banking, customer support, and mobile banking. These are public services that you interact with after successful authentication. But you don’t have access to the bank’s internal network, where its systems manage electronic transfers, balance ledgers, serve internal email, and so on. These services are restricted to the bank’s employees via the private network.</p>&#13;
<h4 id="h3-500884c02-0001">Allocating Networks with CIDR</h4>&#13;
<p class="BodyFirst">You allocate networks using a method known as <em>Classless Inter-Domain Routing</em><em>(CIDR)</em>. In CIDR, you indicate the number of bits in the network ID by appending a <em>network prefix </em>to each IP address, consisting of a forward slash and an integer. Though it’s appended to the end of the IP address, <span epub:type="pagebreak" id="Page_21" title="21"/>you call it a <em>prefix</em> rather than a <em>suffix</em> because it indicates how many of the IP address’s most significant bits, or prefixed bits, constitute the network ID. For example, you’d write the IP address 192.168.156.97 from <a href="#figure2-4">Figure 2-4</a> as 192.168.156.97/16 in CIDR notation, indicating that it belongs to a 16-bit network and that the network ID is the first 16 bits of the IP address. </p>&#13;
<p>From there, you can derive the network IP address by applying a subnet mask. Subnet masks encode the CIDR network prefix in its decimal representation. They are applied to an IP address using a bitwise AND to derive the network ID.</p>&#13;
<p><a href="#table2-1" id="tableanchor2-1">Table 2-1</a> details the most common CIDR network prefixes, the corresponding subnet mask, the available networks for each network prefix, and the number of usable hosts in each network.</p>&#13;
<figure class="TableTitle">&#13;
<figcaption><p><a id="table2-1">Table 2-1</a>: CIDR Network Prefix Lengths and Their Corresponding Subnet Masks</p></figcaption>&#13;
<table border="1" id="table-500884c02-0001">&#13;
<thead>&#13;
<tr>&#13;
<td><b>CIDR network prefix length</b></td><td><b>Subnet mask</b></td><td><b>Available networks</b></td><td><b>Usable hosts per network</b></td></tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>8</td><td>255.0.0.0</td><td>1</td><td>16,777,214</td></tr>&#13;
<tr>&#13;
<td>9</td><td>255.128.0.0</td><td>2</td><td>8,388,606</td></tr>&#13;
<tr>&#13;
<td>10</td><td>255.192.0.0</td><td>4</td><td>4,194,302</td></tr>&#13;
<tr>&#13;
<td>11</td><td>255.224.0.0</td><td>8</td><td>2,097,150</td></tr>&#13;
<tr>&#13;
<td>12</td><td>255.240.0.0</td><td>16</td><td>1,048,574</td></tr>&#13;
<tr>&#13;
<td>13</td><td>255.248.0.0</td><td>32</td><td>524,286</td></tr>&#13;
<tr>&#13;
<td>14</td><td>255.252.0.0</td><td>64</td><td>262,142</td></tr>&#13;
<tr>&#13;
<td>15</td><td>255.254.0.0</td><td>128</td><td>131,070</td></tr>&#13;
<tr>&#13;
<td>16</td><td>255.255.0.0</td><td>256</td><td>65,534</td></tr>&#13;
<tr>&#13;
<td>17</td><td>255.255.128.0</td><td>512</td><td>32,766</td></tr>&#13;
<tr>&#13;
<td>18</td><td>255.255.192.0</td><td>1,024</td><td>16,382</td></tr>&#13;
<tr>&#13;
<td>19</td><td>255.255.224.0</td><td>2,048</td><td>8,190</td></tr>&#13;
<tr>&#13;
<td>20</td><td>255.255.240.0</td><td>4,096</td><td>4,094</td></tr>&#13;
<tr>&#13;
<td>21</td><td>255.255.248.0</td><td>8,192</td><td>2,046</td></tr>&#13;
<tr>&#13;
<td>22</td><td>255.255.252.0</td><td>16,384</td><td>1,022</td></tr>&#13;
<tr>&#13;
<td>23</td><td>255.255.254.0</td><td>32,768</td><td>510</td></tr>&#13;
<tr>&#13;
<td>24</td><td>255.255.255.0</td><td>65,536</td><td>254</td></tr>&#13;
<tr>&#13;
<td>25</td><td>255.255.255.128</td><td>131,072</td><td>126</td></tr>&#13;
<tr>&#13;
<td>26</td><td>255.255.255.192</td><td>262,144</td><td>62</td></tr>&#13;
<tr>&#13;
<td>27</td><td>255.255.255.224</td><td>524,288</td><td>30</td></tr>&#13;
<tr>&#13;
<td>28</td><td>255.255.255.240</td><td>1,048,576</td><td>14</td></tr>&#13;
<tr>&#13;
<td>29</td><td>255.255.255.248</td><td>2,097,152</td><td>6</td></tr>&#13;
<tr>&#13;
<td>30</td><td>255.255.255.252</td><td>4,194,304</td><td>2</td></tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_22" title="22"/>You may have noticed that the number of usable hosts per network is two less than expected in each row because each network has two special addresses. The first IP address in the network is the network address, and the last IP address is the broadcast address. (We’ll cover broadcast addresses a bit later in this chapter.) Take 192.168.0.0/16, for example. The first IP address in the network is 192.168.0.0. This is the network address. The last IP address in the network is 192.168.255.255, which is the broadcast address. For now, understand that you do not assign the network IP address or the broadcast IP address to a host’s network interface. These special IP addresses are used for routing data between networks and broadcasting, respectively.</p>&#13;
<p>The 31- and 32-bit network prefixes are purposefully absent from <a href="#table2-1">Table 2-1</a>, largely because they are beyond the scope of this book. If you’re curious about 31-bit network prefixes, RFC 3021 covers their application. A 32-bit network prefix signifies a single-host network. For example, 192.168.1.1/32 represents a subnetwork of one node with the address 192.168.1.1.</p>&#13;
<h4 id="h3-500884c02-0002">Allocating Networks That Don’t Break at an Octet Boundary</h4>&#13;
<p class="BodyFirst">Some network prefixes don’t break at an octet boundary. For example, <a href="#figure2-5" id="figureanchor2-5">Figure 2-5</a> derives the network ID and host ID of 192.168.156.97 in a 19-bit network. The full IP address in CIDR notation is 192.168.156.97/19.</p>&#13;
<figure>&#13;
<img alt="f02005" src="image_fi/500884c02/f02005.png"/>&#13;
<figcaption><p><a id="figure2-5">Figure 2-5</a>: Deriving the network ID and the host ID from the IPv4 address in a 19-bit network</p></figcaption>&#13;
</figure>&#13;
<p>In this case, since the network prefix isn’t a multiple of 8 bits, an octet’s bits are split between the network ID and host ID. The 19-bit network example in <a href="#figure2-5">Figure 2-5</a> results in the network ID of 192.168.128.0 and the host ID of 0.0.28.97, where the network ID borrows 3 bits from the third octet, leaving 13 bits for the host ID.</p>&#13;
<p>Appending a zeroed host ID to the network ID results in the network address. In a comparable manner, appending a host ID in which all its bits are 1 to the network ID derives the broadcast address. But the third octet’s equaling 156 can be a little confusing. Let’s focus on just the third octet. The third octet of the network ID is 1000 0000. The third octet of the host ID of all ones is 0001 1111 (the first 3 bits are part of the network ID, remember). If we append the network ID’s third octet to the host ID’s third octet, the result is 1001 1111, which is the decimal 156.</p>&#13;
<h4 id="h3-500884c02-0003"><span epub:type="pagebreak" id="Page_23" title="23"/>Private Address Spaces and Localhost</h4>&#13;
<p class="BodyFirst">RFC 1918 details the private address spaces of 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16 for use in local networks. Universities, corporations, governments, and residential networks can use these subnets for local addressing. </p>&#13;
<p>In addition, each host has the 127.0.0.0/8 subnet designated as its local subnet. Addresses in this subnet are local to the host and simply called <em>localhost</em>. Even if your computer is not on a network, it should still have an address on the 127.0.0.0/8 subnet, most likely 127.0.0.1.</p>&#13;
<h3 id="h2-500884c02-0003">Ports and Socket Addresses</h3>&#13;
<p class="BodyFirst">If your computer were able to communicate over the network with only one node at a time, that wouldn’t provide a very efficient or pleasant experience. It would become annoying if your streaming music stopped every time you clicked a link in your web browser because the browser needed to interrupt the stream to retrieve the requested web page. Thankfully, TCP and UDP allow us to multiplex data transmissions by using <em>ports</em>.</p>&#13;
<p>The operating system uses ports to uniquely identify data transmission between nodes for the purposes of multiplexing the outgoing application data and demultiplexing the incoming data back to the proper application. The combination of an IP address and a port number is a <em>socket address</em>, typically written in the format <em>address:port</em>.</p>&#13;
<p>Ports are 16-bit unsigned integers. Port numbers 0 to 1023 are well-known ports assigned to common services by the <em>Internet Assigned Numbers Authority</em><em>(IANA)</em>. The IANA is a private US nonprofit organization that globally allocates IP addresses and port numbers. For example, HTTP uses port 80. Port 443 is the HTTPS port. SSH servers typically listen on port 22. (These well-known ports are guidelines. An HTTP server may listen to any port, not just port 80.)</p>&#13;
<p>Despite these ports being well-known, there is no restriction on which ports services may use. For example, an administrator who wants to obscure a service from attackers expecting it on port 22 may configure an SSH server to listen on port 22422. The IANA designates ports 1024 to 49151 as semi-reserved for lesser common services. Ports 49152 to 65535 are ephemeral ports meant for client socket addresses as recommended by the IANA. (The port range used for client socket addresses is operating-system dependent.)</p>&#13;
<p>A common example of port usage is the interaction between your web browser and a web server. Your web browser opens a socket with the operating system, which assigns an address to the socket. Your web browser sends a request through the socket to port 80 on the web server. The web server sends its response to the socket address corresponding to the socket your web browser is monitoring. Your operating system receives the response and passes it onto your web browser through the socket. Your web browser’s socket address and the web server’s socket address (server IP and port 80) uniquely identify this transaction. This allows your operating system to properly demultiplex the response and pass it along to the right application (that is, your web browser).</p>&#13;
<h3 id="h2-500884c02-0004"><span epub:type="pagebreak" id="Page_24" title="24"/>Network Address Translation</h3>&#13;
<p class="BodyFirst">The four billion IPv4 addresses may seem like a lot until you consider there will be an estimated 24.6 billion Internet of Things (IoT) devices by 2025, according to the Ericsson Mobility Report of June 2020 (<a class="LinkURL" href="https://www.ericsson.com/en/mobility-report/reports/june-2020/iot-connections-outlook/">https://www.ericsson.com/en/mobility-report/reports/june-2020/iot-connections-outlook/</a>). In fact, we’ve already run out of unreserved IPv4 addresses. The IANA allocated the last IPv4 address block on January 31, 2011.</p>&#13;
<p>One way to address the IPv4 shortage is by using <em>network address translation (NAT)</em>, a process that allows numerous nodes to share the same public IPv4 address. It requires a device, such as a firewall, load balancer, or router that can keep track of incoming and outgoing traffic and properly route incoming traffic to the correct node.</p>&#13;
<p><a href="#figure2-6" id="figureanchor2-6">Figure 2-6</a> illustrates the NAT process between nodes on a private network and the internet.</p>&#13;
<figure>&#13;
<img alt="f02006" src="image_fi/500884c02/f02006.png"/>&#13;
<figcaption><p><a id="figure2-6">Figure 2-6</a>: Network address translation between a private network and the internet</p></figcaption>&#13;
</figure>&#13;
<p>In <a href="#figure2-6">Figure 2-6</a>, a NAT-capable device receives a connection from the client socket address 10.0.0.3:50926 destined for a host on the internet. First, the NAT device opens its own connection to the destination host using its public IP 1.2.3.4, preserving the client’s socket address port. Its socket address for this transaction is 1.2.3.4:50926. If a client is already using port 50926, the NAT device chooses a random port for its socket address. Then, the NAT device sends the request to the destination host and receives the response on its 1.2.3.4:50926 socket. The NAT device knows which client receives the response because it translates its socket address to the client socket address that established the connection. Finally, the client receives the destination host’s response from the NAT device.</p>&#13;
<p>The important thing to remember with network address translation is that a node’s private IPv4 address behind a NAT device is not visible or directly accessible to other nodes outside the network address–translated <span epub:type="pagebreak" id="Page_25" title="25"/>network segment. If you’re writing a service that needs to provide a public address for its clients, you may not be able to rely on your node’s private IPv4 address if it’s behind a NAT device. Hosts outside the NAT device’s private network cannot establish incoming connections. Only clients in the private network may establish connections through the NAT device. Instead, your service must rely on the NAT device’s properly forwarding a port from its public IP to a socket address on your node.</p>&#13;
<h3 id="h2-500884c02-0005">Unicasting, Multicasting, and Broadcasting</h3>&#13;
<p class="BodyFirst">Sending packets from one IP address to another IP address is known as <em>unicast addressing</em>. But TCP/IP’s internet layer supports IP <em>multicasting</em>, or sending a single message to a group of nodes. You can think of it as an opt-in mailing list, such as a newspaper subscription.</p>&#13;
<p>From a network programming perspective, multicasting is simple. Routers and switches typically replicate the message for us, as shown in <a href="#figure2-7" id="figureanchor2-7">Figure 2-7</a>. We’ll discuss multicasting later in this book.</p>&#13;
<figure>&#13;
<img alt="f02007" src="image_fi/500884c02/f02007.png"/>&#13;
<figcaption><p><a id="figure2-7">Figure 2-7</a>: The 192.168.1.10 node sending a packet to a subset of network addresses</p></figcaption>&#13;
</figure>&#13;
<p><em>Broadcasting</em> is the ability to concurrently deliver a message to all IP addresses in a network. To do this, nodes on a network send packets to the <em>broadcast address</em> of a subnet. A network switch or router then propagates the packets out to all IPv4 addresses in the subnet (<a href="#figure2-8" id="figureanchor2-8">Figure 2-8</a>).</p>&#13;
<figure>&#13;
<img alt="f02008" src="image_fi/500884c02/f02008.png"/>&#13;
<figcaption><p><a id="figure2-8">Figure 2-8</a>: The 192.168.1.10 node sending a packet to all addresses on its subnet</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_26" title="26"/>Unlike multicasting, the nodes in the subnet don’t first need to opt in to receiving broadcast messages. If the node at 192.168.1.10 in <a href="#figure2-8">Figure 2-8</a> sends a packet to the broadcast address of its subnet, the network switch will deliver a copy of that packet to the other five IPv4 addresses in the same subnet.</p>&#13;
<h3 id="h2-500884c02-0006">Resolving the MAC Address to a Physical Network Connection</h3>&#13;
<p class="BodyFirst">Recall from <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span> that every network interface has a MAC address uniquely identifying the node’s physical connection to the network. The MAC address is relevant to only the local network, so routers cannot use a MAC address to route data across network boundaries. Instead, they can route traffic across network boundaries by using an IPv4 address. Once a packet reaches the local network of a destination node, the router sends the data to the destination node’s MAC address and, finally, to the destination node’s physical network connection.</p>&#13;
<p>The <em>Address Resolution Protocol</em><em>(ARP)</em>,<em> </em>detailed in RFC 826 (<a class="LinkURL" href="https://tools.ietf.org/html/rfc826/">https://tools.ietf.org/html/rfc826/</a>), finds the appropriate MAC address for a given IP address—a process called <em>resolving</em> the MAC address. Nodes maintain ARP tables that map an IPv4 address to a MAC address. If a node does not have an entry in its ARP table for a destination IPv4 address, the node will send a request to the local network’s broadcast address asking, “Who has this IPv4 address? Please send me your MAC address. Oh, and here is my MAC address.” The destination node will receive the ARP request and respond with an ARP reply to the originating node. The originating node will then send the data to the destination node’s MAC address. Nodes on the network privy to this conversation will typically update their ARP tables with the values.</p>&#13;
<h2 id="h1-500884c02-0003">IPv6 Addressing</h2>&#13;
<p class="BodyFirst">Another solution to the IPv4 shortage is to migrate to the next generation of IP addressing, IPv6. <em>IPv6 addresses</em> are 128-bit numbers arranged in eight colon-separated groups of 16 bits, or <em>hextets.</em> There are more than 340 undecillion (2<sup>128</sup>) IPv6 addresses.</p>&#13;
<h3 id="h2-500884c02-0007">Writing IPv6 Addresses</h3>&#13;
<p class="BodyFirst">In binary form, IPv6 addresses are a bit ridiculous to write. In the interest of legibility and compactness, we write IPv6 addresses with lowercase hexadecimal values instead. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>IPv6 hexadecimal values are case-insensitive. However, the Internet Engineering Task Force (IETF) recommends using lowercase values. </p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>A hexadecimal (hex) digit represents 4 bits, or a <em>nibble</em>, of an IPv6 address. For example, we’d represent the two nibbles 1111 1111 in their hexadecimal equivalent of <code>ff</code>. <a href="#figure2-9" id="figureanchor2-9">Figure 2-9</a> illustrates the same IPv6 address in binary and hex.</p>&#13;
<span epub:type="pagebreak" id="Page_27" title="27"/><figure>&#13;
<img alt="f02009" src="image_fi/500884c02/f02009.png"/>&#13;
<figcaption><p><a id="figure2-9">Figure 2-9</a>: Binary and hex representations of the same IPv6 address</p></figcaption>&#13;
</figure>&#13;
<p>Even though hexadecimal IPv6 addresses are a bit more succinct than their binary equivalent, we still have some techniques available to us to simplify them a bit more.</p>&#13;
<h4 id="h3-500884c02-0004">Simplifying IPv6 Addresses</h4>&#13;
<p class="BodyFirst">An IPv6 address looks something like this: fd00:4700:0010:0000:0000:0000:6814:d103. That’s quite a bit harder to remember than an IPv4 address. Thankfully, you can improve the IPv6 address’s presentation to make it more readable by following a few rules.</p>&#13;
<p>First, you can remove all leading zeros in each hextet. This simplifies your address without changing its value. It now looks like this: fd00:4700:10:0:0:0:6814:d103. Better, but still long.</p>&#13;
<p>Second, you can replace the leftmost group of consecutive, zero-value hextets with double colons, producing the shorter fd00:4700:10::6814:d103. If your address has more than one group of consecutive zero-value hextets, you can remove only the leftmost group. Otherwise, it’s impossible for routers to accurately determine the number of hextets to insert when repopulating the full address from its compressed representation. For example, fd00:4700:0000:0000:ef81:0000:6814:d103 rewrites to fd00:4700::ef81:0:6814:d103. The best you could do with the sixth hextet is to remove the leading zeros.</p>&#13;
<h4 id="h3-500884c02-0005">IPv6 Network and Host Addresses</h4>&#13;
<p class="BodyFirst">Like IPv4 addresses, IPv6 addresses have a network address and a host address. IPv6’s host address is commonly known as the <em>interface ID</em>. The network and host addresses are both 64 bits, as shown in <a href="#figure2-10" id="figureanchor2-10">Figure 2-10</a>. The first 48 bits of the network address are known as the <em>global routing prefix</em><em>(GRP)</em>, and the last 16 bits of the network address are called the <em>subnet ID</em>. The 48-bit GRP is used for globally subdividing the IPv6 address space and routing traffic between these groups. The subnet ID is used to further subdivide each GRP-unique network into site-specific networks. If you run a large ISP, you are assigned one or more GRP-unique blocks of IPv6 addresses. You can then use the subnet ID in each network to further subdivide your allocated IPv6 addresses to your customers.</p>&#13;
<span epub:type="pagebreak" id="Page_28" title="28"/><figure>&#13;
<img alt="f02010" src="image_fi/500884c02/f02010.png"/>&#13;
<figcaption><p><a id="figure2-10">Figure 2-10</a>: IPv6 global routing prefix, subnet ID, and interface ID</p></figcaption>&#13;
</figure>&#13;
<p>The GRP gets determined for you when you request a block of IPv6 addresses from your ISP. IANA assigns the first hextet of the GRP to a regional internet registry (an organization that handles the allocation of addresses for a global region). The regional internet registry then assigns the second GRP hextet to an ISP. The ISP finally assigns the third GRP hextet before assigning a 48-bit subnet of IPv6 addresses to you.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2> &#13;
<p>For more information on the allocation of IPv6 addresses, see IANA’s “IPv6 Global Unicast Address Assignments” document at <a class="LinkURL" href="https://www.iana.org/assignments/ipv6-unicast-address-assignments/ipv6-unicast-address-assignments.xml">https://www.iana.org/assignments/ipv6-unicast-address-assignments/ipv6-unicast-address-assignments.xml</a>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>The first hextet of an IPv6 address gives you a clue to its use. Addresses beginning with the prefix 2000::/3 are meant for global use, meaning every node on the internet will have an IPv6 address starting with 2 or 3 in the first hex. The prefix fc00::/7 designates a unique local address like the 127.0.0.0/8 subnet in IPv4.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>IANA’s “Internet Protocol Version 6 Address Space” document at <a class="LinkURL" href="https://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.xhtml ">https://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.xhtml </a>provides more details.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>Let’s assume your ISP assigned the 2600:fe56:7891::/48 netblock to you. Your 16-bit subnet ID allows you to further subdivide your netblock into a maximum of 65,536 (2<sup>16</sup>) subnets. Each of those subnets supports over 18 quintillion (2<sup>64</sup>) hosts. If you assign 1 to the subnet as shown in <a href="#figure2-10">Figure 2-10</a>, you’d write the full network address as 2600:fe56:7891:1::/64 after removing leading zeros and compressing zero value hextets. Further subnetting your netblock may look like this: 2600:fe56:7891:<b>2</b>::/64, 2600:fe56:7891:<b>3</b>::/64, 2600:fe56:7891:<b>4</b>::/64.</p>&#13;
<h3 id="h2-500884c02-0008">IPv6 Address Categories</h3>&#13;
<p class="BodyFirst">IPv6 addresses are divided into three categories: anycast, multicast, and unicast. Notice there is no broadcast type, as in IPv4. As you’ll see, anycast and multicast addresses fulfill that role in IPv6.</p>&#13;
<h4 id="h3-500884c02-0006">Unicast Addresses</h4>&#13;
<p class="BodyFirst">A <em>unicast</em> IPv6 address uniquely identifies a node. If an originating node sends a message to a unicast address, only the node with that address will receive the message, as shown in <a href="#figure2-11" id="figureanchor2-11">Figure 2-11</a>.</p>&#13;
<span epub:type="pagebreak" id="Page_29" title="29"/><figure>&#13;
<img alt="f02011" src="image_fi/500884c02/f02011.png"/>&#13;
<figcaption><p><a id="figure2-11">Figure 2-11</a>: Sending to a unicast address</p></figcaption>&#13;
</figure>&#13;
<h4 id="h3-500884c02-0007">Multicast Addresses</h4>&#13;
<p class="BodyFirst"><em>Multicast</em> addresses represent a group of nodes. Whereas IPv4 broadcast addresses will propagate a message out to all addresses on the network, multicast addresses will simultaneously deliver a message to a subset of network addresses, not necessarily all of them, as shown in <a href="#figure2-12" id="figureanchor2-12">Figure 2-12</a>.</p>&#13;
<figure>&#13;
<img alt="f02012" src="image_fi/500884c02/f02012.png"/>&#13;
<figcaption><p><a id="figure2-12">Figure 2-12</a>: Sending to a multicast address</p></figcaption>&#13;
</figure>&#13;
<p>Multicast addresses use the prefix ff00::/8.</p>&#13;
<h4 id="h3-500884c02-0008">Anycast Addresses</h4>&#13;
<p class="BodyFirst">Remember that IPv4 addresses must be unique per network segment, or network communication issues can occur. But IPv6 includes support for multiple nodes using the same network address. An <em>anycast</em> address represents a group of nodes listening to the same address. A message sent to an anycast address goes to the nearest node listening to the address. <a href="#figure2-13" id="figureanchor2-13">Figure 2-13</a> represents a group of nodes listening to the same address, where the nearest node to the sender receives the message. The sender could transmit to any of the nodes represented by the dotted lines, but sends to the nearest node (solid line).</p>&#13;
<figure>&#13;
<img alt="f02013" src="image_fi/500884c02/f02013.png"/>&#13;
<figcaption><p><a id="figure2-13">Figure 2-13</a>: Sending to an anycast address</p></figcaption>&#13;
</figure>&#13;
<p>The nearest node isn’t always the most physically close node. It is up to the router to determine which node receives the message, usually the node <span epub:type="pagebreak" id="Page_30" title="30"/>with the least latency between the origin and the destination. Aside from reducing latency, anycast addressing increases redundancy and can geolocate services.</p>&#13;
<p>Sending traffic around the world takes a noticeable amount of time, to the point that the closer you are to a service provider’s servers, the better performance you’ll experience. Geolocating services across the internet is a common method of placing servers geographically close to users to make sure performance is optimal for all users across the globe. It’s unlikely you access servers across an ocean when streaming Netflix. Instead, Netflix geolocates servers close to you so that your experience is ideal.</p>&#13;
<h3 id="h2-500884c02-0009">Advantages of IPv6 over IPv4</h3>&#13;
<p class="BodyFirst">Aside from the ridiculously large address space, IPv6 has inherent advantages over IPv4, particularly with regard to efficiency, autoconfiguration, and security.</p>&#13;
<h4 id="h3-500884c02-0009">Simplified Header Format for More Efficient Routing</h4>&#13;
<p class="BodyFirst">The IPv6 header is an improvement over the IPv4 header. The IPv4 header contains mandatory yet rarely used fields. IPv6 makes these fields optional. The IPv6 header is extensible, in that functionality can be added without breaking backward compatibility. In addition, the IPv6 header is designed for improved efficiency and reduced complexity over the IPv4 header.</p>&#13;
<p>IPv6 also lessens the loads on routers and other hops by ensuring that headers require minimal processing, eliminating the need for checksum calculation at every hop.</p>&#13;
<h4 id="h3-500884c02-0010">Stateless Address Autoconfiguration</h4>&#13;
<p class="BodyFirst">Administrators manually assign IPv4 addresses to each node on a network or rely on a service to dynamically assign addresses. Nodes using IPv6 can automatically configure or derive their IPv6 addresses through <em>stateless address autoconfiguration</em><em>(SLAAC)</em> to reduce administrative overhead.</p>&#13;
<p>When connected to an IPv6 network, a node can solicit the router for its network address parameters using the <em>Neighbor Discovery Protocol</em><em>(NDP)</em>. NDP leverages the Internet Control Message Protocol, discussed later in this chapter, for router solicitation. It performs the same duties as IPv4’s ARP. Once the node receives a reply from the router with the 64-bit network address, the node can derive the 64-bit host portion of its IPv6 address on its own using the 48-bit MAC address assigned to its network interface. The node appends the 16-bit hex FFFE to the first three octets of the MAC address known as the <em>originally unique identifier (OUI)</em>. To this, the node appends the remaining three octets of the MAC address, the network interface controller (NIC) identifier. The result is a unique 64-bit interface ID, as shown in <a href="#figure2-14" id="figureanchor2-14">Figure 2-14</a>. SLAAC works only in the presence of a router that can respond with router advertisement packets. <em>Router advertisement packets</em> contain information clients need to automatically configure their IPv6 address, including the 64-bit network address.</p>&#13;
<span epub:type="pagebreak" id="Page_31" title="31"/><figure>&#13;
<img alt="f02014" src="image_fi/500884c02/f02014.png"/>&#13;
<figcaption><p><a id="figure2-14">Figure 2-14</a>: Deriving the interface ID from the MAC address</p></figcaption>&#13;
</figure>&#13;
<p>If you value your privacy, the method SLAAC uses to derive a unique interface ID should concern you. No matter which network your device is on, SLAAC will make sure the host portion of your IPv6 address contains your NIC’s MAC address. The MAC address is a unique fingerprint that betrays the hardware you use and allows anyone to track your online activity. Thankfully, many people raised these concerns, and SLAAC gained privacy extensions (<a class="LinkURL" href="https://tools.ietf.org/html/rfc4941/">https://tools.ietf.org/html/rfc4941/</a>), which randomize the interface ID. Because of this randomization, it’s possible for more than one node on a network to generate the same interface ID. Thankfully, the NDP will automatically detect and fix any duplicate interface ID for you.</p>&#13;
<h4 id="h3-500884c02-0011">Native IPsec Support</h4>&#13;
<p class="BodyFirst">IPv6 has native support for <em>IPsec</em>, a technology that allows multiple nodes to dynamically create secure connections between each other, ensuring that traffic is encrypted.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>RFC 6434 made IPsec optional for IPv6 implementations.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="h1-500884c02-0004">The Internet Control Message Protocol</h2>&#13;
<p class="BodyFirst">The Internet Protocol relies on the <em>Internet Control Message Protocol</em><em>(ICMP)</em> to give it feedback about the local network. ICMP can inform you of network problems, unreachable nodes or networks, local network configuration, proper traffic routes, and network time-outs. Both IPv4 and IPv6 have their own ICMP implementations, designated ICMPv4 and ICMPv6, respectively.</p>&#13;
<p>Network events often result in ICMP response messages. For instance, if you attempt to send data to an unreachable node, a router will typically respond with an ICMP <em>destination unreachable</em> message informing you that your data couldn’t reach the destination node. A node may become unreachable if it runs out of resources and can no longer respond to incoming data or if data cannot route to the node. Disconnecting a node from a network will immediately make it unreachable.</p>&#13;
<p>Routers use ICMP to help inform you of better routes to your destination node. If you send data to a router that isn’t the appropriate or best <span epub:type="pagebreak" id="Page_32" title="32"/>router to handle traffic for your destination, it may reply with an ICMP <em>redirect</em> message after forwarding your data onto the correct router. The ICMP redirect message is the router’s way of telling you to send your data to the appropriate router in the future.</p>&#13;
<p>You can determine whether a node is online and reachable by using an ICMP <em>echo</em> request (also called a <em>ping</em>). If the destination is reachable and receives your ping, it will reply with its own ICMP <em>echo reply</em> message (also called a <em>pong</em>). If the destination isn’t reachable, the router will respond with a destination unreachable message.</p>&#13;
<p>ICMP can also notify you when data reaches the end of its life before delivery. Every IP packet has a <em>time-to-live</em> value that dictates the maximum number of hops the packet can take before its lifetime expires. The packet’s time-to-live value is a counter and decrements by one for every hop it takes. You will receive an ICMP <em>time exceeded</em> message if the packet you sent doesn’t reach its destination by the time its time-to-live value reaches zero.</p>&#13;
<p>IPv6’s NDP relies heavily on ICMP router solicitation messages to properly configure a node’s NIC.</p>&#13;
<h2 id="h1-500884c02-0005">Internet Traffic Routing</h2>&#13;
<p class="BodyFirst">Now that you know a bit about internet protocol addressing, let’s explore how packets make their way across the internet from one node to another using those addresses. In <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, we discussed how data travels down the network stack of the originating node, across a physical medium, and up the stack of the destination node. But in most cases, nodes won’t have a direct connection, so they’ll have to make use of intermediate nodes to transfer data. <a href="#figure2-15" id="figureanchor2-15">Figure 2-15</a> shows that process. </p>&#13;
<p>The intermediate nodes (Nodes 1 and 2 in <a href="#figure2-15">Figure 2-15</a>) are typically routers or firewalls that control the path data takes from one node to the other. <em>Firewalls</em> control the flow of traffic in and out of a network, primarily to secure networks behind the firewall.</p>&#13;
<p>No matter what type of node they are, intermediate nodes have a network stack associated with each network interface. In <a href="#figure2-15">Figure 2-15</a>, Node 1 receives data on its incoming network interface. The data climbs the stack to Layer 3, where it’s handed off to the outgoing network interface’s stack. The data then makes its way to Node 2’s incoming network interface before ultimately being routed to the server.</p>&#13;
<p>The incoming and outgoing network interfaces in Node 1 and Node 2 may send data over different media types using IPv4, so they must use encapsulation to isolate the implementation details of each media type from the data being sent. Let’s assume Node 1 receives data from the client over a wireless network and it sends data to Node 2 over an Ethernet connection. Node 1’s incoming Layer 1 knows how to convert the radio signals from the wireless network into bits. Layer 1 sends the bits up to Layer 2. Layer 2 converts the bits to a frame and extracts the packet and sends it up to Layer 3.</p>&#13;
<span epub:type="pagebreak" id="Page_33" title="33"/><figure>&#13;
<img alt="f02015" src="image_fi/500884c02/f02015.png"/>&#13;
<figcaption><p><a id="figure2-15">Figure 2-15</a>: Routing packets through two hops</p></figcaption>&#13;
</figure>&#13;
<p>Layer 3 on both the incoming and outgoing NICs speak IPv4, which routes the packet between the two interface network stacks. The outgoing NIC’s Layer 2 receives the packet from its Layer 3 and encapsulates it before sending the frame onto its Layer 1 as bits. The outgoing Layer 1 converts the bits into electric signals suitable for transmission over Ethernet. The data in transport from the client’s Layer 7 never changed despite the data’s traversing multiple nodes over different media on its way to the destination server.</p>&#13;
<h2 id="h1-500884c02-0006">Routing Protocols</h2>&#13;
<p class="BodyFirst">The routing overview in <a href="#figure2-15">Figure 2-15</a> makes the process look easy, but the routing process relies on a symphony of protocols to make sure each packet reaches its destination no matter the physical medium traversed or network outages along the way. Routing protocols have their own criteria for determining the best path between nodes. Some protocols determine a route’s efficiency based on hop count. Some may use bandwidth. Others may use more complicated means to determine which route is the most efficient.</p>&#13;
<p>Routing protocols are either internal or external depending on whether they route packets within an autonomous system or outside of one. An <em>autonomous system</em> is an organization that manages one or more networks. An ISP is an example of an autonomous system. Each autonomous system is assigned an autonomous system number (ASN), as outlined in RFC 1930 (<a class="LinkURL" href="https://tools.ietf.org/html/rfc1930/">https://tools.ietf.org/html/rfc1930/</a>). This ASN is used to broadcast an ISP’s network <span epub:type="pagebreak" id="Page_34" title="34"/>information to other autonomous systems using an external routing protocol. An <em>external routing protocol</em> routes data between autonomous systems. The only routing protocol we’ll cover is BGP since it is the glue of the internet, binding all ASN-assigned ISPs together. You don’t need to understand BGP in depth, but being familiar with it can help you better debug network issues related to your code and improve your code’s resiliency.</p>&#13;
<h3 id="h2-500884c02-0010">The Border Gateway Protocol</h3>&#13;
<p class="BodyFirst">The <em>Border Gateway Protocol (BGP)</em> allows ASN-assigned ISPs to exchange routing information. BGP relies on trust between ISPs. That is, if an ISP says it manages a specific network and all traffic destined for that network should be sent to it, the other ISPs trust this claim and send traffic accordingly. As a result, BGP misconfigurations, or <em>route leaks</em>, often result in very public network outages.</p>&#13;
<p>In 2008, Pakistan Telecommunications Company effectively took down YouTube worldwide after the Pakistani Ministry of Communications demanded the country block <em>youtube.com</em> in protest of a YouTube video. Pakistan Telecom used BGP to send all requests destined for YouTube to a null route, a route that drops all data without notification to the sender. But Pakistan Telecom accidentally leaked its BGP route to the world instead of restricting it to the country. Other ISPs trusted the update and null routed YouTube requests from their clients, making <em>youtube.com</em> inaccessible for two hours all over the world.</p>&#13;
<p>In 2012, Google’s services were rerouted through Indonesia for 27 minutes when the ISP Moratel shared a BGP route directing all Google traffic to Moratel’s network as if Moratel was now hosting Google’s network infrastructure. There was speculation at the time that the route leakage was malicious, but Moratel blamed a hardware failure.</p>&#13;
<p>BGP usually makes news only when something goes wrong. Other times, it plays the silent hero, serving a significant role in mitigating distributed denial-of-service (DDOS) attacks. In a <em>DDOS attack</em>, a malicious actor directs traffic from thousands of compromised nodes to a victim node with the aim of overwhelming the victim and consuming all its bandwidth, effectively denying service to legitimate clients. Companies that specialize in mitigating DDOS attacks use BGP to reroute all traffic destined for the victim node to their AS networks, filter out the malicious traffic from the legitimate traffic, and route the sanitized traffic back to the victim, nullifying the effects of the attack.</p>&#13;
<h2 id="h1-500884c02-0007">Name and Address Resolution</h2>&#13;
<p class="BodyFirst">The <em>Domain Name System</em><em>(DNS)</em> is a way of matching IP addresses to <em>domain names</em>, which are the names we enter in an address bar when we want to visit websites. Although the internet protocol uses IP addresses to locate hosts, domain names (like <em>google.com</em>) are easier for humans to understand and remember. If I gave you the IP address 172.217.6.14 to visit, you wouldn’t know who owned that IP address or what I was directing you to visit. But if <span epub:type="pagebreak" id="Page_35" title="35"/>I gave you <em>google.com </em>instead, you’d know exactly where I was sending you. DNS allows you to remember a hostname instead of its IP address in the same way that your smartphone’s contact list frees you from having to memorize all those phone numbers.</p>&#13;
<p>All domains are children of a <em>top-level domain</em>, such as <em>.com</em>, <em>.net</em>, <em>.org</em>, and so on. Take <em>nostarch.com</em>, for instance. No Starch Press registered the <em>nostarch</em> domain on the <em>.com</em> top-level domain from a registrar with the authority from IANA to register <em>.com</em> domains. No Starch Press now has the exclusive authority to manage DNS records for <em>nostarch.com</em> and publish records on its DNS server. This includes the ability for No Starch Press to publish <em>subdomains</em>—a subdivision of a domain—under its domain. For example, <em>maps.google.com</em> is a subdomain of <em>google.com</em>. A longer example is <em>sub3.sub2.sub1.domain.com</em>, where <em>sub3</em> is a subdomain under <em>sub2.sub1.domain.com</em>, <em>sub2</em> is subdomain under <em>sub1.domain.com</em>, and <em>sub1</em> is a subdomain under <em>domain.com</em>.</p>&#13;
<p>If you enter <code>https://nostarch.com</code> in your web browser, your computer will consult its configured <em>domain name resolver</em>, a server that knows how to retrieve the answer to your query. The resolver will start by asking one of the 13 IANA-maintained root name servers for the IP address of <em>nostarch.com</em>. The root name server will examine the top-level domain of the domain you requested and give your resolver the address of the <em>.com</em> name server. Your resolver will then ask the <em>.com</em> name server for <em>nostarch.com</em>’s IP address, which will examine the domain portion and direct your resolver to ask No Starch Press’s name server. Finally, your resolver will ask No Starch Press’s name server and receive the IP address that corresponds to <em>nostarch.com</em>. Your web browser will establish a connection to this IP address, retrieve the web page, and render it for you. This hierarchical journey of domain resolution allows you to zero in on a specific web server, and all you had to know was the domain name. No Starch Press is free to move its servers to a different ISP with new IP addresses, and yet you’ll still be able to visit its website by using <em>nostarch.com</em>.</p>&#13;
<h3 id="h2-500884c02-0011">Domain Name Resource Records</h3>&#13;
<p class="BodyFirst">Domain name servers maintain <em>resource records</em> for the domains they serve. Resource records contain domain-specific information, used to satisfy domain name queries, like IP addresses, mail server hostnames, mail-handling rules, and authentication tokens. There are many resource records, but this section focuses on only the most common ones: address records, start-of-authority records, name server records, canonical name records, mail exchange records, pointer records, and text records.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>For more details on types of resource records, see Wikipedia’s entry at <a class="LinkURL" href="https://en.wikipedia.org/wiki/List_of_DNS_record_types">https://en.wikipedia.org/wiki/List_of_DNS_record_types</a>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>Our exploration of each resource record will use a utility called <em>dig</em> to query domain name servers. This utility may be available on your operating system, but in case you don’t have dig installed, you can use the G Suite Toolbox Dig utility (<a class="LinkURL" href="https://toolbox.googleapps.com/apps/dig/">https://toolbox.googleapps.com/apps/dig/</a>) in a web browser <span epub:type="pagebreak" id="Page_36" title="36"/>and receive similar output. All domain names you’ll see are <em>fully qualified</em>, which means they end in a period, displaying the domain’s entire hierarchy from the root zone. The <em>root zone</em> is the top DNS namespace.</p>&#13;
<p>Dig’s default output includes a bit of data relevant to your query but irrelevant to your study of its output. Therefore, I’ve elected to snip out header and footer information in dig’s output in each example to follow. Also please be aware that the specific output in this book is a snapshot from when I executed each query. It may look different when you execute these commands.</p>&#13;
<h4 id="h3-500884c02-0012">The Address Record</h4>&#13;
<p class="BodyFirst">The <em>Address (A) record</em> is the most common record you’ll query. An A record will resolve to one or more IPv4 addresses. When your computer asks its resolver to retrieve the IP address for <em>nostarch.com</em>, the resolver ultimately asks the domain name server for the <em>nostarch.com</em> Address (A) resource record. <a href="#listing2-1" id="listinganchor2-1">Listing 2-1</a> shows the question and answer sections when you query for the <em>google.com</em> A record.</p>&#13;
<pre><code>$ <b>dig google.com. a</b>&#13;
<var>-- snip --</var>&#13;
<span class="CodeAnnotationHang">1</span> ;QUESTION&#13;
<span class="CodeAnnotationHang">2</span> google.com. <span class="CodeAnnotation">3</span>IN <span class="CodeAnnotation">4</span>A&#13;
<span class="CodeAnnotationHang">5</span> ;ANSWER&#13;
<span class="CodeAnnotationHang">6</span> google.com. <span class="CodeAnnotation">7</span>299 IN A <span class="CodeAnnotation">8</span>172.217.4.46&#13;
<var>-- snip --</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing2-1">Listing 2-1</a>: DNS answer of the <em>google.com</em> A resource record</p>&#13;
<p>Each section in a DNS reply begins with a header <span class="CodeAnnotation">1</span>, prefixed with a semicolon to indicate that the line is a comment rather than code to be processed. Within the question section, you ask the domain name server for the domain name <em>google.com</em><span class="CodeAnnotation">2</span> with the class <code>IN</code><span class="CodeAnnotation">3</span>, which indicates that this record is internet related. You also use <code>A</code> to ask for the A record <span class="CodeAnnotation">4</span> specifically. </p>&#13;
<p>In the Answer section <span class="CodeAnnotation">5</span>, the domain name server resolves the <em>google.com</em> A record to six IPv4 addresses. The first field of each returned line is the domain name <span class="CodeAnnotation">6</span> you queried. The second field is the TTL value <span class="CodeAnnotation">7</span> for the record. The <em>TTL value</em> tells domain name resolvers how long to cache or remember the record, and it lets you know how long you have until the cached record expires. When you request a DNS record, the domain name resolver will first check its cache. If the answer is in its cache, it will simply return the cached answer instead of asking the domain name server for the answer. This improves domain name resolution performance for records that are unlikely to change frequently. In this example, the record will expire in 299 seconds. The last field is the IPv4 address <span class="CodeAnnotation">8</span>. Your web browser could use any one of the six IPv4 addresses to establish a connection to <em>google.com</em>.</p>&#13;
<p>The AAAA resource record is the IPv6 equivalent of the A record.</p>&#13;
<h4 id="h3-500884c02-0013"><span epub:type="pagebreak" id="Page_37" title="37"/>The Start of Authority Record</h4>&#13;
<p class="BodyFirst">The <em>Start of Authority (SOA) record</em> contains authoritative and administrative details about the domain, as shown in <a href="#listing2-2" id="listinganchor2-2">Listing 2-2</a>. All domains must have an SOA record.</p>&#13;
<pre><code>$ <b>dig google.com. soa</b>&#13;
<var>-- snip --</var>&#13;
;QUESTION&#13;
google.com. IN SOA&#13;
;ANSWER&#13;
google.com. 59 IN SOA <span class="CodeAnnotation">1</span>ns1.google.com. <span class="CodeAnnotation">2</span>dns-admin.google.com. <span class="CodeAnnotation">3</span>248440550 900 900 1800 60&#13;
<var>-- snip --</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing2-2">Listing 2-2</a>: DNS answer of the <em>google.com</em> SOA resource record</p>&#13;
<p>The first four fields of an SOA record are the same as those found in an A record. The SOA record also includes the primary name server <span class="CodeAnnotation">1</span>, the administrator’s email address <span class="CodeAnnotation">2</span>, and fields <span class="CodeAnnotation">3</span> used by secondary name servers outside the scope of this book. Domain name servers primarily consume SOA records. However, the email address is useful if you wish to contact the domain’s administrator.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>The administrator’s email address is encoded as a name, with the at sign (@) replaced by a period.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h4 id="h3-500884c02-0014">The Name Server Record</h4>&#13;
<p class="BodyFirst">The <em>Name Server (NS) record</em> returns the authoritative name servers for the domain name. <em>Authoritative name servers</em> are the name servers able to provide answers for the domain name. NS records will include the primary name server from the SOA record and any secondary name servers answering DNS queries for the domain. <a href="#listing2-3" id="listinganchor2-3">Listing 2-3</a> is an example of the NS records for <em>google.com</em>. </p>&#13;
<pre><code>$ <b>dig google.com. ns</b>&#13;
<var>-- snip --</var>&#13;
;QUESTION&#13;
google.com. IN NS&#13;
;ANSWER&#13;
google.com. 21599 IN NS <span class="CodeAnnotation">1</span>ns1.google.com.&#13;
google.com. 21599 IN NS ns2.google.com.&#13;
google.com. 21599 IN NS ns3.google.com.&#13;
google.com. 21599 IN NS ns4.google.com.&#13;
<var>-- snip --</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing2-3">Listing 2-3</a>: DNS answer of the <em>google.com</em> NS resource records</p>&#13;
<p>Like the CNAME record, discussed next, the NS record will return a fully qualified domain name <span class="CodeAnnotation">1</span>, not an IP address.</p>&#13;
<h4 id="h3-500884c02-0015"><span epub:type="pagebreak" id="Page_38" title="38"/>The Canonical Name Record</h4>&#13;
<p class="BodyFirst">The <em>Canonical Name (CNAME) record</em> points one domain at another. <a href="#listing2-4" id="listinganchor2-4">Listing 2-4</a> shows a CNAME record response. CNAME records can make administration a bit easier. For example, you can create one named <em>mail.yourdomain.com</em> and direct it to Gmail’s login page. This not only is easier for your users to remember but also gives you the flexibility of pointing the CNAME at another email provider in the future without having to inform your users.</p>&#13;
<pre><code>$ <b>dig mail.google.com. a</b>&#13;
<var>-- snip --</var>&#13;
;QUESTION&#13;
mail.google.com. IN A&#13;
;ANSWER&#13;
<span class="CodeAnnotationHang">1</span> mail.google.com. 21599 IN CNAME <span class="CodeAnnotation">2</span>googlemail.l.google.com.&#13;
googlemail.l.google.com. 299 IN A 172.217.3.229&#13;
<var>-- snip --</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing2-4">Listing 2-4</a>: DNS answer of the <em>mail.google.com</em> CNAME resource record</p>&#13;
<p>Notice that you ask the domain name server for the A record of the subdomain <em>mail.google.com</em>. But in this case, you receive a CNAME instead. This tells you that <em>googlemail.l.google.com</em><span class="CodeAnnotation">2</span> is the canonical name for <em>mail.google.com</em><span class="CodeAnnotation">1</span>. Thankfully, you receive the A record for <em>googlemail.l.google.com</em> with the response, alleviating you from having to make a second query. You now know your destination IP address is 172.217.3.229. Google’s domain name server was able to return both the CNAME answer and the corresponding Address answer in the same reply because it is an authority for the CNAME answer’s domain name as well. Otherwise, you would expect only the CNAME answer and would then need to make a second query to resolve the CNAME answer’s IP address.</p>&#13;
<h4 id="h3-500884c02-0016">The Mail Exchange Record</h4>&#13;
<p class="BodyFirst">The <em>Mail Exchange (MX) record</em> specifies the mail server hostnames that should be contacted when sending email to recipients at the domain. Remote mail servers will query the MX records for the domain portion of a recipient’s email address to determine which servers should receive mail for the recipient. <a href="#listing2-5" id="listinganchor2-5">Listing 2-5</a> shows the response a mail server will receive.</p>&#13;
<pre><code>$ <b>dig google.com. mx</b>&#13;
<var>-- snip --</var>&#13;
;QUESTION&#13;
google.com. IN MX&#13;
;ANSWER&#13;
google.com. 599 IN MX <span class="CodeAnnotation">1</span>10 aspmx.l.google.com.&#13;
google.com. 599 IN MX 50 alt4.aspmx.l.google.com.&#13;
google.com. 599 IN MX 30 alt2.aspmx.l.google.com.&#13;
google.com. 599 IN MX 20 alt1.aspmx.l.google.com.&#13;
google.com. 599 IN MX 40 alt3.aspmx.l.google.com.&#13;
<var>-- snip --</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing2-5">Listing 2-5</a>: DNS answer of the <em>google.com</em> MX resource records</p>&#13;
<p><span epub:type="pagebreak" id="Page_39" title="39"/>In addition to the domain name, TTL value, and record type, MX records contain the <em>priority field</em><span class="CodeAnnotation">1</span>, which rates the priority of each mail server. The lower the number, the higher the priority of the mail server. Mail servers attempt to deliver emails to the mail server with the highest priority, then resort to the mail servers with the next highest priority if necessary. If more than one mail server shares the same priority, the mail server will pick one at random.</p>&#13;
<h4 id="h3-500884c02-0017">The Pointer Record</h4>&#13;
<p class="BodyFirst">The <em>Pointer (PTR) record</em> allows you to perform a reverse lookup by accepting an IP address and returning its corresponding domain name. <a href="#listing2-6" id="listinganchor2-6">Listing 2-6</a> shows the reverse lookup for 8.8.4.4.</p>&#13;
<pre><code>$ <b>dig 4.4.8.8.in-addr.arpa. ptr</b>&#13;
<var>-- snip --</var>&#13;
;QUESTION&#13;
<span class="CodeAnnotationHang">1</span> 4.4.8.8.in-addr.arpa. IN PTR&#13;
;ANSWER&#13;
4.4.8.8.in-addr.arpa. 21599 IN PTR <span class="CodeAnnotation">2</span>google-public-dns-b.google.com.&#13;
<var>-- snip --</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing2-6">Listing 2-6</a>: DNS answer of the 8.8.4.4 PTR resource record</p>&#13;
<p>To perform the query, you ask the domain name server for the IPv4 address in reverse order <span class="CodeAnnotation">1</span> with the special domain <em>in-addr.arpa</em> appended because the reverse DNS records are all under the <em>.arpa</em> top-level domain. For example, querying the pointer record for the IP 1.2.3.4 means you need to ask for <em>4.3.2.1.in-addr.arpa</em>. The query in <a href="#listing2-6">Listing 2-6</a> tells you that the IPv4 address 8.8.4.4 reverses to the domain name <em>google-public-dns-b.google.com</em><span class="CodeAnnotation">2</span>. If you were performing a reverse lookup of an IPv6 address, you’d append the special domain <em>ip6.arpa</em> to the reversed IPv6 address as you did for the IPv4 address.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>See Wikipedia for more information on reverse DNS lookup: <a class="LinkURL" href="https://en.wikipedia.org/wiki/Reverse_DNS_lookup">https://en.wikipedia.org/wiki/Reverse_DNS_lookup</a>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h4 id="h3-500884c02-0018">The Text Record</h4>&#13;
<p class="BodyFirst">The <em>Text (TXT) record</em> allows the domain owner to return arbitrary text. These records can contain values that prove domain ownership, values that remote mail servers can use to authorize email, and entries to specify which IP addresses may send mail on behalf of the domain, among other uses. <a href="#listing2-7" id="listinganchor2-7">Listing 2-7</a> shows the text records associated with <em>google.com</em>.</p>&#13;
<pre><code>$ <b>dig google.com. txt</b>&#13;
<var>-- snip --</var>&#13;
;QUESTION&#13;
google.com. IN TXT&#13;
;ANSWER&#13;
<span epub:type="pagebreak" id="Page_40" title="40"/>google.com. 299 IN TXT&#13;
  <span class="CodeAnnotation">1</span>"facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95"&#13;
google.com. 299 IN TXT "docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e"&#13;
google.com. 299 IN TXT <span class="CodeAnnotation">2</span>"v=spf1 include:_spf.google.com ~all"&#13;
google.com. 299 IN TXT&#13;
    "globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8="&#13;
<var>-- snip --</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing2-7">Listing 2-7</a>: DNS answer of the google.com TXT resource records</p>&#13;
<p>The domain queries and answers should start to look familiar by now. The last field in a TXT record is a string of the TXT record value <span class="CodeAnnotation">1</span>. In this example, the field has a Facebook verification key, which proves to Facebook that Google’s corporate Facebook account is who they say they are and has the authority to make changes to Google’s content on Facebook. It also contains <em>Sender Policy Framework</em> rules <span class="CodeAnnotation">2</span>, which inform remote mail servers which IP addresses may deliver email on Google’s behalf.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>The Facebook for Developers site has more information about domain verification at <a class="LinkURL" href="https://developers.facebook.com/docs/sharing/domain-verification/">https://developers.facebook.com/docs/sharing/domain-verification/</a>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h3 id="h2-500884c02-0012">Multicast DNS</h3>&#13;
<p class="BodyFirst"><em>Multicast DNS</em><em>(mDNS)</em> is a protocol that facilitates name resolution over a local area network (LAN) in the absence of a DNS server. When a node wants to resolve a domain name to an IP address, it will send a request to an IP multicast group. Nodes listening to the group receive the query, and the node with the requested domain name responds to the IP multicast group with its IP address. You may have used mDNS the last time you searched for and configured a network printer on your computer.</p>&#13;
<h3 id="h2-500884c02-0013">Privacy and Security Considerations of DNS Queries</h3>&#13;
<p class="BodyFirst">DNS traffic is typically unencrypted when it traverses the internet. A potential exception occurs if you’re connected to a virtual private network (VPN) and are careful to make sure all DNS traffic passes through its encrypted tunnel. Because of DNS’s unencrypted transport, unscrupulous ISPs or intermediate providers may glean sensitive information in your DNS queries and share those details with third parties. You can make a point of visiting HTTPS-only websites, but your DNS queries may betray your otherwise secure browsing habits and allow the DNS server’s administrators to glean the sites you visit.</p>&#13;
<p>Security is also a concern with plaintext DNS traffic. An attacker could convince your web browser to visit a malicious website by inserting a response to your DNS query. Considering the difficulty of pulling off such an attack, it’s not an attack you’re likely to experience, but it’s concerning nonetheless. Since DNS servers often cache responses, this attack usually takes place between your device and the DNS server it’s configured to use. RFC 7626 (<a class="LinkURL" href="https://tools.ietf.org/html/rfc7626/">https://tools.ietf.org/html/rfc7626/</a>) covers these topics in more detail.</p>&#13;
<h4 id="h3-500884c02-0019"><span epub:type="pagebreak" id="Page_41" title="41"/>Domain Name System Security Extensions</h4>&#13;
<p class="BodyFirst">Generally, you can ensure the authenticity of data sent over a network in two ways: authenticating the content and authenticating the channel. <em>Domain Name System Security Extensions</em><em>(DNSSEC)</em> is a method to prevent the covert modification of DNS responses in transit by using digital signatures to authenticate the response. DNSSEC ensures the authenticity of data by authenticating the content. DNS servers cryptographically sign the resource records they serve and make those signatures available to you. You can then validate the responses from authoritative DNS servers against the signatures to make sure the responses aren’t fraudulent.</p>&#13;
<p>DNSSEC doesn’t address privacy concerns. DNSSEC queries still traverse the network unencrypted, allowing for passive observation.</p>&#13;
<h4 id="h3-500884c02-0020">DNS over TLS</h4>&#13;
<p class="BodyFirst">DNS over TLS (DoT), detailed in RFC 7858 (<a class="LinkURL" href="https://tools.ietf.org/html/rfc7858/">https://tools.ietf.org/html/rfc7858/</a>), addresses both security and privacy concerns by using <em>Transport Layer Security</em><em>(TLS)</em> to establish an encrypted connection between the client and its DNS server. TLS is a common protocol used to provide cryptographically secure communication between nodes on a network. Using TLS, DNS requests and responses are fully encrypted in transit, making it impossible for an attacker to eavesdrop on or manipulate responses. DoT ensures the authenticity of data by authenticating the channel. It does not need to rely on cryptographic signatures like DNSSEC because the entire conversation between the DNS server and the client is encrypted.</p>&#13;
<p>DoT uses a different network port than does regular DNS traffic.</p>&#13;
<h4 id="h3-500884c02-0021">DNS over HTTPS</h4>&#13;
<p class="BodyFirst"><em>DNS over HTTPS (DoH)</em>,<em> </em>detailed in RFC 8484<em> </em>(<a class="LinkURL" href="https://tools.ietf.org/html/rfc8484/">https://tools.ietf.org/html/rfc8484/</a>) aims to address DNS security and privacy concerns while using a heavily used TCP port. Like DoT, DoH sends data over an encrypted connection, authenticating the channel. DoH uses a common port and maps DNS requests and responses to HTTP requests and responses. Queries over HTTP can take advantage of all HTTP features, such as caching, compression, proxying, and redirection.</p>&#13;
<h2 id="h1-500884c02-0008">What You’ve Learned</h2>&#13;
<p class="BodyFirst">We covered a lot of ground in this chapter. You learned about IP addressing, starting with the basics of IPv4 multicasting, broadcasting, TCP and UDP ports, socket addresses, network address translation, and ARP. You then learned about IPv6, its address categories, and its advantages over IPv4.</p>&#13;
<p>You learned about the major network-routing protocols, ICMP and DNS. I’ll again recommend the <em>TCP/IP Guide</em> by Charles M. Kozierok (No Starch Press, 2005) for its extensive coverage of the topics in this chapter.</p>&#13;
</section>&#13;
</body></html>