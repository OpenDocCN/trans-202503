<html><head></head><body>
<h2 class="h2" id="ch6"><span epub:type="pagebreak" id="page_105"/><span class="big">6</span><br/>HASH FUNCTIONS</h2>
<div class="image9"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Hash functions—such as MD5, SHA-1, SHA-256, SHA-3, and BLAKE2—comprise the cryptographer’s Swiss Army Knife: they are used in digital signatures, public-key encryption, integrity verification, message authentication, password protection, key agreement protocols, and many other cryptographic protocols. Whether you’re encrypting an email, sending a message on your mobile phone, connecting to an HTTPS website, or connecting to a remote machine through IPSec or SSH, there’s a hash function somewhere under the hood.</p>
<p class="indent">Hash functions are by far the most versatile and ubiquitous of all crypto algorithms. There are many examples of their use in the real world: cloud storage systems use them to identify identical files and to detect modified files; the Git revision control system uses them to identify files in a repository; host-based intrusion detection systems (HIDS) use them to detect modified files; network-based intrusion detection systems (NIDS) use hashes to <span epub:type="pagebreak" id="page_106"/>detect known-malicious data going through a network; forensic analysts use hash values to prove that digital artifacts have not been modified; Bitcoin uses a hash function in its proof-of-work systems—and there are many more.</p>
<div class="image"><img src="../images/f06-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig1"/><em>Figure 6-1: A hash function’s input and output</em></p>
<p class="indentt">Unlike stream ciphers, which create a long output from a short one, hash functions take a long input and produce a short output, called a <em>hash value</em> or <em>digest</em> (see <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>).</p>
<p class="indent">This chapter revolves around two main topics. First, security: what does it mean for a hash function to be secure? To that end, I introduce two essential notions—namely, collision resistance and preimage resistance. The second big topic revolves around hash functions construction. We look at the high-level techniques used by modern hash functions and then review the internals of the most common hash functions: SHA-1, SHA-2, SHA-3, and BLAKE2. Lastly, we see how secure hash functions can behave insecurely if misused.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Do not confuse cryptographic hash functions with</em> noncryptographic <em>ones. Noncryptographic hash functions are used in data structures such as hash tables or to detect accidental errors, and they provide no security whatsoever. For example, cyclic redundancy checks (CRCs) are noncryptographic hashes used to detect accidental modifications of a file.</em></p>
</div>
<h3 class="h3" id="lev1sec39">Secure Hash Functions</h3>
<div class="image"><img src="../images/f06-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig2"/><em>Figure 6-2: A hash function in a digital signature scheme. The hash acts as a proxy for the message.</em></p>
<p class="noindentt">The notion of security for hash functions is different from what we’ve seen thus far. Whereas ciphers protect data confidentiality in an effort to guarantee that data sent in the clear can’t be read, hash functions protect data integrity in an effort to guarantee that data—whether sent in the clear or encrypted—hasn’t been modified. If a hash function is secure, two distinct pieces of data should always have different hashes. A file’s hash can thus serve as its identifier.</p>
<p class="indent">Consider the most common application of a hash function: <em>digital signatures</em>, or just <em>signatures</em>. When digital signatures are used, applications process the hash of the message to be signed rather than the message itself, as shown in <a href="ch06.xhtml#ch6fig2">Figure 6-2</a>. The hash acts as an identifier for the message. If even a single bit is changed in the message, the hash of the message will be totally different. The hash function thus helps ensure that the message has not been modified. Signing a message’s hash is as secure as signing the message itself, and signing a short hash of, say, 256 bits is much faster than signing a message that may be very large. In fact, most signature algorithms can only work on short inputs such as hash values.</p>
<h4 class="h4" id="lev2sec73"><span epub:type="pagebreak" id="page_107"/><em>Unpredictability Again</em></h4>
<p class="noindent">All of the cryptographic strength of hash functions stems from the unpredictability of their outputs. Take the 256-bit hexadecimal values shown next; these hashes are computed using the NIST standard hash function SHA-256 with the ASCII letters <code>a</code>, <code>b</code>, and <code>c</code> as inputs. As you can see, though the values <code>a</code>, <code>b</code>, and <code>c</code> differ by only one or two bits (<code>a</code> is the bit sequence 01100001, <code>b</code> is 01100010, and <code>c</code> is 01100011), their hash values are completely different.</p>
<div class="image1"><img src="../images/f0107-01.jpg" alt="image"/></div>
<p class="indent">Given only these three hashes, it would be impossible to predict the value of the SHA-256 hash of <code>d</code> or any of its bits. Why? Because hash values of a secure hash function are <em>unpredictable</em>. A secure hash function should be like a black box that returns a random string each time it receives an input.</p>
<p class="indent">The general, theoretical definition of a secure hash function is that it behaves like a truly random function (sometimes called a <em>random oracle</em>). Specifically, a secure hash function shouldn’t have any property or pattern that a random function wouldn’t have. This definition is helpful for theoreticians, but in practice we need more specific notions: namely, preimage resistance and collision resistance.</p>
<h4 class="h4" id="lev2sec74"><em>Preimage Resistance</em></h4>
<p class="noindent">A <em>preimage</em> of a given hash value, <em>H</em>, is any message, <em>M</em>, such that <strong>Hash</strong>(<em>M</em>) = <em>H</em>. Preimage <em>resistance</em> describes the security guarantee that given a random hash value, an attacker will never find a preimage of that hash value. Indeed, hash functions are sometimes called <em>one-way</em> <em>functions</em> because you can go from the message to its hash, but not the other way.</p>
<p class="indentb">First, note that a hash function can’t be inverted, even given unlimited computing power. For example, suppose that I hash some message using the SHA-256 hash function and get this 256-bit hash value:</p>
<p class="center"><code>f67a58184cef99d6dfc3045f08645e844f2837ee4bfcc6c949c9f7674367adfd</code></p>
<p class="indentt">Even given unlimited computing power, you would never be able to determine <em>the</em> message that I picked to produce this particular hash, since there are many messages hashing to the same value. You would therefore find <em>some</em> messages that produce this hash value (possibly including the one I picked), but would be unable to determine the message that I used.</p>
<p class="indent">For example, there are 2<sup>256</sup> possible values of a 256-bit hash (a typical length with hash functions used in practice), but there are many more values of, say, 1024-bit messages (namely, 2<sup>1024</sup> possible values). Therefore, it follows that, on average, each possible 256-bit hash value will have 2<sup>1024</sup> / 2<sup>256</sup> = 2<sup>1024 – 256</sup> = 2<sup>768</sup> preimages of 1024 bits each.</p>
<p class="indent"><span epub:type="pagebreak" id="page_108"/>In practice, we must be sure that it is practically impossible to find <em>any</em> message that maps to a given hash value, not just the message that was used, which is what preimage resistance actually stands for. Specifically, we speak of first-preimage and second-preimage resistance. <em>First-preimage resistance</em> (or just <em>preimage resistance</em>) describes cases where it is practically impossible to find a message that hashes to a given value. <em>Second-preimage resistance</em>, on the other hand, describes the case that when given a message, <em>M</em><sub>1</sub>, it’s practically impossible to find another message, <em>M</em><sub>2</sub>, that hashes to the same value that <em>M</em><sub>1</sub> does.</p>
<h5 class="h5">The Cost of Preimages</h5>
<p class="noindent">Given a hash function and a hash value, you can search for first preimages by trying different messages until one hits the target hash. You would do this using an algorithm similar to <code>find-preimage()</code> in <a href="ch06.xhtml#ch6list1">Listing 6-1</a>.</p>
<pre>find-preimage(H) {<br/>    repeat {<br/>        M = random_message()<br/>        if Hash(M) == H then return M<br/>     }<br/>}</pre>
<p class="figcap"><a id="ch6list1"/><em>Listing 6-1: The optimal preimage search algorithm for a secure hash function</em></p>
<p class="indent">In <a href="ch06.xhtml#ch6list1">Listing 6-1</a>, <code>random_message()</code> generates a random message (say, a random 1024-bit value). Obviously, <code>find-preimage()</code> will never complete if the hash’s bit length, <em>n</em>, is large enough, because it will take on average 2<sup><em>n</em></sup> attempts before finding a preimage. That’s a hopeless situation when working with <em>n</em> = 256, as in modern hashes like SHA-256 and BLAKE2.</p>
<h5 class="h5">Why Second-Preimage Resistance Is Weaker</h5>
<p class="noindent">I claim that if you can find first preimages, you can find second preimages as well (for the same hash function). As proof, if the algorithm <code>solve-preimage()</code> returns a preimage of a given hash value, you can use the algorithm in <a href="ch06.xhtml#ch6list2">Listing 6-2</a> to find a second preimage of some message, <em>M</em>.</p>
<pre>solve-second-preimage(M) {<br/>    H = Hash(M)<br/>    return solve-preimage(H)<br/>}</pre>
<p class="figcap"><a id="ch6list2"/><em>Listing 6-2: How to find second preimages if you can find first preimages</em></p>
<p class="indentt">That is, you’ll find the second preimage by seeing it as a preimage problem and applying the preimage attack. It follows that any second-preimage resistant hash function is also preimage resistant. (Were it not, it wouldn’t be second preimage resistant either, per the preceding <code>solve-second-</code><code>preimage</code> algorithm.) In other words, the best attack we can use to <span epub:type="pagebreak" id="page_109"/>find second preimages is almost identical to the best attack we can use to find first preimages (unless the hash function has some defect that allows for more efficient attacks). Also note that a preimage search attack is essentially the same as a key recovery attack on a block cipher or stream cipher—namely, a brute-force search for a single magic value.</p>
<h4 class="h4" id="lev2sec75"><em>Collision Resistance</em></h4>
<p class="noindent">Whatever hash function you choose to use, collisions will inevitably exist due to the <em>pigeonhole principle</em>, which states that if you have <em>m</em> holes and <em>n</em> pigeons to put into those holes, and if <em>n</em> is greater than <em>m</em>, at least one hole must contain more than one pigeon.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>This can be generalized to other items and containers as well. For example, any 27-word sequence in the US Constitution includes at least two words that start with the same letter. In the world of hash functions, holes are the hash values, and pigeons are the messages. Because we know that there are many more possible messages than hash values, collisions</em> must <em>exist.</em></p>
</div>
<p class="indent">However, despite the inevitable, collisions should be as hard to find as the original message in order for a hash function to be considered <em>collision resistant</em>—in other words, attackers shouldn’t be able to find two distinct messages that hash to the same value.</p>
<p class="indent">The notion of collision resistance is related to the notion of second-preimage resistance: if you can find second preimages for a hash function, you can also find collisions, as shown in <a href="ch06.xhtml#ch6list3">Listing 6-3</a>.</p>
<pre>solve-collision() {<br/>    M = random_message()<br/>    return (M, solve-second-preimage(M))<br/>}</pre>
<p class="figcap"><a id="ch6list3"/><em>Listing 6-3: The naive collision search algorithm</em></p>
<p class="indentt">That is, any collision-resistant hash is also second preimage resistant. If this were not the case, there would be an efficient solve-second-preimage algorithm that could be used to break collision resistance.</p>
<h4 class="h4" id="lev2sec76"><em>Finding Collisions</em></h4>
<p class="noindent">It’s faster to find collisions than it is to find preimages, on the order of about 2<sup><em>n</em>/2</sup> operations instead of 2<sup><em>n</em></sup>, thanks to the <em>birthday attack</em>, whose key idea is the following: given <em>N</em> messages and as many hash values, you can produce a total of <em>N</em> × (<em>N</em> – 1) / 2 potential collisions by considering each <em>pair</em> of two hash values (a number of the same order of magnitude as <em>N</em><sup>2</sup>). It’s called <em>birthday</em> attack because it’s usually illustrated using the so-called <em>birthday paradox</em>, or the fact that a group of only 23 persons will include two persons having the same birth date with probability 1/2.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_110"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep">N × (N – <em>1) / 2 is the count of pairs of two</em> distinct <em>messages, where we divide by 2 because we view</em> (M<sub>1</sub>, M<sub>2</sub>) <em>and</em> (M<sub>2</sub>, M<sub>1</sub>) <em>as a same pair. In other words, we don’t care about the ordering.</em></p>
</div>
<p class="indent">For the sake of comparison, in the case of a preimage search, <em>N</em> messages only get you <em>N</em> candidate preimages, whereas the same <em>N</em> messages give approximately <em>N</em><sup>2</sup> potential collisions, as just discussed. With <em>N</em><sup>2</sup> instead of <em>N</em>, we say that there are <em>quadratically</em> more chances to find a solution. The complexity of the search is in turn quadratically lower: in order to find a collision, you’ll need to use the square root of 2<sup><em>n</em></sup> messages; that is, 2<sup><em>n</em>/2</sup> instead of 2<sup><em>n</em></sup>.</p>
<h5 class="h5">The Naive Birthday Attack</h5>
<p class="noindent">Here’s the simplest way to carry out the birthday attack in order to find collisions:</p>
<ol>
<li class="noindent"><p class="list">Compute 2<sup><em>n</em>/2</sup> hashes of 2<sup><em>n</em>/2</sup> arbitrarily chosen messages and store all the message/hash pairs in a list.</p></li>
<li class="noindent"><p class="list">Sort the list with respect to the hash value to move any identical hash values next to each other.</p></li>
<li class="noindent"><p class="list">Search the sorted list to find two consecutive entries with the same hash value.</p></li>
</ol>
<p class="indent">Unfortunately, this method requires a lot of memory (enough to store 2<sup><em>n</em>/2</sup> message/hash pairs), and sorting lots of elements slows down the search, requiring about <em>n</em>2<sup><em>n</em></sup> basic operations on average using even the quicksort algorithm.</p>
<h5 class="h5">Low-Memory Collision Search: The Rho Method</h5>
<p class="noindent">The <em>Rho method</em> is an algorithm for finding collisions that, unlike the naive birthday attack, requires only a small amount of memory. It works like this:</p>
<ol>
<li class="noindent"><p class="list">Given a hash function with <em>n</em>-bit hash values, pick some random hash value (<em>H</em><sub>1</sub>), and define <em>H</em><sub>1</sub> = <em>H′</em><sub>1</sub>.</p></li>
<li class="noindent"><p class="list">Compute <em>H</em><sub>2</sub> = <strong>Hash</strong>(<em>H</em><sub>1</sub>), and <em>H′</em><sub>2</sub> = <strong>Hash</strong>(<strong>Hash</strong>(<em>H′</em><sub>1</sub>)); that is, in the first case we apply the hash function once, while in the second case we apply it twice.</p></li>
<li class="noindent"><p class="list">Iterate the process and compute <em>H</em><sub><em>i</em></sub> <sub>+ 1</sub> = <strong>Hash</strong>(<em>H</em><sub><em>i</em></sub>), <em>H′</em><sub><em>i</em></sub> <sub>+ 1</sub> = <strong>Hash</strong>(<strong>Hash</strong>(<em>H′</em><sub><em>i</em></sub>)), until you reach <em>i</em> such that <em>H</em><sub><em>i</em></sub> <sub>+ 1</sub> = <em>H</em><em>′</em><sub><em>i</em></sub> <sub>+ 1</sub>.</p></li>
</ol>
<p class="indent"><a href="ch06.xhtml#ch6fig3">Figure 6-3</a> will help you to visualize the attack, where an arrow from, say, <em>H</em><sub>1</sub> to <em>H</em><sub>2</sub> means <em>H</em><sub>2</sub> = <strong>Hash</strong>(<em>H</em><sub>1</sub>). Observe that the sequence of <em>H</em><sub><em>i</em></sub>s eventually enters a loop, also called a <em>cycle</em>, which resembles the Greek letter rho (ρ) in shape. The cycle starts at <em>H</em><sub>5</sub> and is characterized by the collision <strong>Hash</strong>(<em>H</em><sub>4</sub>) = <strong>Hash</strong>(<em>H</em><sub>10</sub>) = <em>H</em><sub>5</sub>. The key observation here is that in <span epub:type="pagebreak" id="page_111"/>order to find a collision, you simply need to find such a cycle. The algorithm above allows an attacker to detect the position of the cycle, and therefore to find the collision.</p>
<div class="image"><img src="../images/f06-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig3"/><em>Figure 6-3: The structure of the Rho hash function. Each arrow represents an evaluation of the hash function. The cycle beginning at</em> H<sub>5</sub> <em>corresponds to a collision</em>, <em><strong>Hash</strong></em>(H<sub>4</sub>) = <em><strong>Hash</strong></em>(H<sub>10</sub>) = H<sub>5</sub>.</p>
<p class="indent">Advanced collision-finding techniques work by first detecting the start of the cycle and then finding the collision, without storing numerous values in memory and without needing to sort a long list. The Rho method takes about 2<sup><em>n</em>/2</sup> operations to succeed. Indeed, <a href="ch06.xhtml#ch6fig3">Figure 6-3</a> has many fewer hash values than would an actual function with digests of 256 bits or more. On average, the cycle and the tail (the part that extends from <em>H</em><sub>1</sub> to <em>H</em><sub>5</sub> in <a href="ch06.xhtml#ch6fig3">Figure 6-3</a>) each include about 2<sup><em>n</em>/2</sup> hash values, where <em>n</em> is the bit length of the hash values. Therefore, you’ll need at least 2<sup><em>n</em>/2</sup> + 2<sup><em>n</em>/2</sup> evaluations of the hash to find a collision.</p>
<h3 class="h3" id="lev1sec40">Building Hash Functions</h3>
<p class="noindent">In the 1980s, cryptographers realized that the simplest way to hash a message is to split it into chunks and process each chunk consecutively using a similar algorithm. This strategy is called <em>iterative hashing</em>, and it comes in two main forms:</p>
<ul>
<li class="noindent">Iterative hashing using a <em>compression function</em> that transforms an input to a <em>smaller output</em>, as shown in <a href="ch06.xhtml#ch6fig4">Figure 6-4</a>. This technique is also known as the <em>Merkle–Damgård</em> construction (named after the cryptographers Ralph Merkle and Ivan Damgård).</li>
<li class="noindent">Iterative hashing using a function that transforms an input to an output of the <em>same size</em>, such that any two different inputs give two different outputs (that is, a <em>permutation</em>), as shown in <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>. Such functions are called <em>sponge</em> <em>functions</em>.</li>
</ul>
<p class="indent">We’ll now discuss how these constructions actually work and how compression functions look in practice.</p>
<h4 class="h4" id="lev2sec77"><span epub:type="pagebreak" id="page_112"/><em>Compression-Based Hash Functions: The Merkle–Damgård Construction</em></h4>
<p class="noindent">All hash functions developed from the 1980s through the 2010s are based on the Merkle–Damgård (M–D) construction: MD4, MD5, SHA-1, and the SHA-2 family, as well as the lesser-known RIPEMD and Whirlpool hash functions. The M–D construction isn’t perfect, but it is simple and has proven to be secure enough for many applications.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In MD4, MD5, and RIPEMD, the</em> MD <em>stands for</em> message digest, <em>not</em> Merkle–Damgård.</p>
</div>
<p class="indent">To hash a message, the M–D construction splits the message into blocks of identical size and mixes these blocks with an internal state using a compression function, as shown in <a href="ch06.xhtml#ch6fig4">Figure 6-4</a>. Here, <em>H</em><sub>0</sub> is the initial value (denoted IV) of the internal state, the values <em>H</em><sub>1</sub>, <em>H</em><sub>2</sub>, … are called the <em>chaining values</em>, and the final value of the internal state is the message’s hash value.</p>
<div class="image"><img src="../images/f06-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig4"/><em>Figure 6-4: The Merkle–Damgård construction using a compression function called Compress</em></p>
<p class="indent">The message blocks are usually 512 or 1024 bits, but they can, in principle, be of any size. However, the block length is fixed for a given hash function. For example, SHA-256 works with 512-bit blocks and SHA-512 works with 1024-bit blocks.</p>
<h5 class="h5">Padding Blocks</h5>
<p class="noindent">What happens if you want to hash a message that can’t be split into a sequence of complete blocks? For example, if blocks are 512 bits, then a 520-bit message will consist of one 512-bit block plus 8 bits. In such a case, the M–D construction forms the last block as follows: take the chunk of bits left (8 in our example), append 1 bit, then append 0 bits, and finally append the length of the original message, encoded on a fixed number of bits. This padding trick guarantees that any two distinct messages will give a distinct sequence of blocks, and thus a distinct hash value.</p>
<p class="indent">For example, if you hash the 8-bit string 10101010 using SHA-256, which is a hash function with 512-bit message blocks, the first and only block will appear, in bits, as follows:</p>
<div class="image1"><img src="../images/f0112-01.jpg" alt="image"/></div>
<p class="indent">Here, the message bits are the first eight bits (10101010), and the padding bits are all the subsequent bits (shown in italic). The <em>1000</em> at the end <span epub:type="pagebreak" id="page_113"/>of the block (underlined) is the message’s length, or 8 encoded in binary. The padding thus produces a 512-bit message composed of a single 512-bit block, ready to be processed by SHA-256’s compression function.</p>
<h5 class="h5">Security Guarantees</h5>
<p class="noindent">The Merkle–Damgård construction is essentially a way to turn a secure compression function that takes small, fixed-length inputs into a secure hash function that takes inputs of arbitrary lengths. If a compression function is preimage and collision resistant, then a hash function built on it using the M–D construction will also be preimage and collision resistant. This is true because any successful preimage attack for the M–D hash could be turned into a successful preimage attack for the compression function, as Merkle and Damgård both demonstrated in their 1989 papers (see <a href="ch06.xhtml#lev1sec44">“Further Reading”</a> on page 126). The same is true for collisions: an attacker can’t break the hash’s collision resistance without breaking the underlying compression function’s collision resistance; hence, the security of the latter guarantees the security of the hash.</p>
<p class="indent">Note that the converse argument is wrong, because a collision for the compression function doesn’t necessarily give a collision for the hash. A collision, <strong>Compress</strong>(<em>X</em>, <em>M</em><sub>1</sub>) = <strong>Compress</strong>(<em>Y</em>, <em>M</em><sub>2</sub>), for chaining values <em>X</em> and <em>Y</em>, both distinct from <em>H</em><sub>0</sub>, won’t get you a collision for the hash because you can’t plug the collision into the iterative chain of hashes—except if one of the chaining values happens to be <em>X</em> and the other <em>Y</em>, but that’s unlikely to happen.</p>
<h5 class="h5">Finding Multicollisions</h5>
<p class="noindent">A <em>multicollision</em> occurs when a set of three or more messages hash to the same value. For example, the triplet (<em>X</em>, <em>Y</em>, <em>Z</em>), such that <strong>Hash</strong>(<em>X</em>) = <strong>Hash</strong>(<em>Y</em>) = <strong>Hash</strong>(<em>Z</em>) is called a <em>3-collision</em>. Ideally, multicollisions should be much harder to find than collisions, but there is a simple trick for finding them at almost the same cost as that of a single collision. Here’s how it works:</p>
<ol>
<li class="noindent"><p class="list">Find a first collision: <strong>Compress</strong>(<em>H</em><sub>0</sub>, <em>M</em><sub>1.1</sub>) = <strong>Compress</strong>(<em>H</em><sub>0</sub>, <em>M</em><sub>1.2</sub>) = <em>H</em><sub>1</sub>. Now you have a 2-collision, or two messages hashing to the same value.</p></li>
<li class="noindent"><p class="list">Find a second collision with <em>H</em><sub>1</sub> as a starting chaining value: <strong>Compress</strong>(<em>H</em><sub>1</sub>, <em>M</em><sub>2.1</sub>) = <strong>Compress</strong>(<em>H</em><sub>1</sub>, <em>M</em><sub>2.2</sub>) = <em>H</em><sub>2</sub>. Now you have a 4-collision, with four messages hashing to the same value <em>H</em><sub>2</sub>: <em>M</em><sub>1.1</sub> || <em>M</em><sub>2.1</sub>, <em>M</em><sub>1.1</sub> || <em>M</em><sub>2.2</sub>, <em>M</em><sub>1.2</sub> || <em>M</em><sub>2.1</sub>, and <em>M</em><sub>1.2</sub> || <em>M</em><sub>2.2</sub>.</p></li>
<li class="noindent"><p class="list">Repeat and find <em>N</em> times a collision, and you’ll have 2<sup><em>N</em></sup> <em>N</em>-block messages hashing to the same value, or a 2<sup><em>N</em></sup>-collision, at the cost of “only” about <em>N</em>2<sup><em>N</em></sup> hash computations.</p></li>
</ol>
<p class="indentt">In practice, this trick isn’t all that practical because it requires you to find a basic 2-collision in the first place.</p>
<h5 class="h5"><span epub:type="pagebreak" id="page_114"/>Building Compression Functions: The Davies–Meyer Construction</h5>
<div class="image"><img src="../images/f06-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig5"/><em>Figure 6-5: The Davies–Meyer construction. The dark triangle shows where the block cipher's key is input.</em></p>
<p class="noindent">All compression functions used in real hash functions such as SHA-256 and BLAKE2 are based on block ciphers, because that is the simplest way to build a compression function. <a href="ch06.xhtml#ch6fig5">Figure 6-5</a> shows the most common of the block cipher–based compression functions, the <em>Davies–Meyer construction</em>.</p>
<p class="indentb">Given a message block, <em>M</em><sub><em>i</em></sub>, and the previous chaining value <em>H</em><sub><em>i</em> − 1</sub>, the Davies–Meyer compression function uses a block cipher, <strong>E</strong>, to compute the new chaining value as</p>
<p class="center"><em>H<sub>i</sub></em> = <strong>E</strong>(<em>M<sub>i</sub></em>, <em>H</em><sub><em>i</em> − 1</sub>) ⊕ <em>H</em><sub><em>i</em> − 1</sub></p>
<p class="indent">The message block <em>M</em><sub><em>i</em></sub> acts as the block cipher key, and the chaining value <em>H</em><sub><em>i</em></sub> <sub>– 1</sub> acts as its plaintext block. As long as the block cipher is secure, the resulting compression function is secure as well as collision and preimage resistant. Without the XOR of the preceding chaining value (⊕ <em>H</em><sub><em>i</em></sub> <sub>– 1</sub>), Davies–Meyer would be insecure because you could invert it, going from the new chaining value to the previous one using the block cipher’s decryption function.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The Davies–Meyer construction has a surprising property: you can find</em> fixed points, <em>or chaining values, that are unchanged after applying the compression function with a given message block. It suffices to take</em> H<sub><em>i</em> – 1</sub> = <strong>D</strong>(M<sub>i</sub>, <em>0) as a chaining value, where</em> <strong>D</strong> <em>is the decryption function corresponding to</em> <strong>E</strong>. <em>The new chaining value</em> H<sub>i</sub> <em>is therefore equal to the original</em> H<sub>i – 1</sub>:</p>
<div class="image1"><img src="../images/f0114-01.jpg" alt="image"/></div>
<p class="notep">   <em>We get</em> H<sub>i</sub> = H<sub>i – 1</sub> <em>because plugging the decryption of zero into the encryption function yields zero—the term <strong>E</strong></em>(M<sub>i</sub>, <em><strong>D</strong></em>(M<sub>i</sub>, <em>0))—leaving only the</em> ⊕ H<sub>i – 1</sub> <em>part of the equation in the expression of the compression function’s output. You can then find fixed points for the compression functions of the SHA-2 functions, as with the standards MD5 and SHA-1, which are also based on the Davies–Meyer construction. Fortunately, fixed points aren’t a security risk.</em></p>
</div>
<p class="indentt">There are many block cipher–based compression functions other than Davies–Meyer, such as those shown in <a href="ch06.xhtml#ch6fig6">Figure 6-6</a>, but they are less popular because they’re more complex or require the message block to be the same length as the chaining value.</p>
<div class="image"><span epub:type="pagebreak" id="page_115"/><img src="../images/f06-06.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig6"/><em>Figure 6-6: Other secure block cipher–based compression function constructions</em></p>
<h4 class="h4" id="lev2sec78"><em>Permutation-Based Hash Functions: Sponge Functions</em></h4>
<p class="noindent">After decades of research, cryptographers know everything there is to know about block cipher–based hashing techniques. Still, shouldn’t there be a simpler way to hash? Why bother with a block cipher, an algorithm that takes a secret key, when hash functions don’t take a secret key? Why not build hash functions with a fixed-key block cipher, a single permutation algorithm?</p>
<p class="indent">Those simpler hash functions are called sponge functions, and they use a single permutation instead of a compression function and a block cipher (see <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>). Instead of using a block cipher to mix message bits with the internal state, sponge functions just do an XOR operation. Sponge functions are not only simpler than Merkle–Damgård functions, they’re also more versatile. You will find them used as hash functions and also as deterministic random bit generators, stream ciphers, pseudorandom functions (see <a href="ch07.xhtml#ch7">Chapter 7</a>), and authenticated ciphers (see <a href="ch08.xhtml#ch8">Chapter 8</a>). The most famous sponge function is Keccak, also known as SHA-3.</p>
<div class="image"><img src="../images/f06-07.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig7"/><em>Figure 6-7: The sponge construction</em></p>
<p class="indentt">A sponge function works as follows:</p>
<ol>
<li class="noindent"><p class="list">It XORs the first message block, <em>M</em><sub>1</sub>, to <em>H</em><sub>0</sub>, a predefined initial value of the internal state (for example, the all-zero string). Message blocks are all the same size and smaller than the internal state.</p></li>
<li class="noindent"><p class="list">A permutation, <strong>P</strong>, transforms the internal state to another value of the same size.</p></li>
<li class="noindent"><p class="list">It XORs block <em>M</em><sub>2</sub> and applies <strong>P</strong> again, and then repeats this for the message blocks <em>M</em><sub>3</sub>, <em>M</em><sub>4</sub>, and so on. This is called the <em>absorbing phase</em>.</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_116"/>After injecting all the message blocks, it applies <strong>P</strong> again and extracts a block of bits from the state to form the hash. (If you need a longer hash, apply <strong>P</strong> again and extract a block.) This is called the <em>squeezing phase</em>.</p></li>
</ol>
<p class="indent">The security of a sponge function depends on the length of its internal state and the length of the blocks. If message blocks are <em>r</em>-bit long and the internal state is <em>w</em>-bit long, then there are <em>c</em> = <em>w</em> – <em>r</em> bits of the internal state that can’t be modified by message blocks. The value of <em>c</em> is called a sponge’s <em>capacity</em>, and the security level guaranteed by the sponge function is <em>c</em>/2. For example, to reach 256-bit security with 64-bit message blocks, the internal state should be <em>w</em> = 2 × 256 + 64 = 576 bits. Of course, the security level also depends on the length, <em>n</em>, of the hash value. The complexity of a collision attack is therefore the smallest value between 2<sup><em>n</em>/2</sup> and 2<sup><em>c</em>/2</sup>, while the complexity of a second preimage attack is the smallest value between 2<sup><em>n</em></sup> and 2<sup><em>c</em>/2</sup>.</p>
<p class="indent">To be secure, the permutation <strong>P</strong> should behave like a random permutation, without statistical bias and without a mathematical structure that would allow an attacker to predict outputs. As in compression function–based hashes, sponge functions also pad messages, but the padding is simpler because it doesn’t need to include the message’s length. The last message bit is simply followed by a 1 bit and as many zeroes as necessary.</p>
<h3 class="h3" id="lev1sec41">The SHA Family of Hash Functions</h3>
<p class="noindent">The Secure Hash Algorithm (SHA) hash functions are standards defined by NIST for use by non-military federal government agencies in the US. They are considered worldwide standards, and only certain non-US governments opt for their own hash algorithms (such as China’s SM3, Russia’s Streebog, and Ukraine’s Kupyna) for reasons of sovereignty rather than a lack of trust in SHA’s security. The US SHAs have been more extensively reviewed by cryptanalysts than the non-US ones.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Message Digest 5 (MD5) was the most popular hash function from 1992 until it was broken around 2005, and many applications then switched to one of the SHA hash functions. MD5 processes 512-bit block messages and updates a 128-bit internal state to produce a 128-bit hash, thus providing at best 128-bit preimage security and 64-bit collision security. In 1996, cryptanalysts warned of a collision for MD5’s compression function, but their warning went unheeded until 2005 when a team of Chinese cryptanalysts discovered how to compute collisions for the full MD5 hash. As I write this, it takes only seconds to find a collision for MD5, yet many systems still use or support MD5, often for reasons of backward compatibility.</em></p>
</div>
<h4 class="h4" id="lev2sec79"><em>SHA-1</em></h4>
<p class="noindent">The SHA-1 standard arose from a failure in the NSA’s original SHA-0 hash function. In 1993, NIST standardized the NSA’s SHA-0 hash algorithm, but in 1995 the NSA released SHA-1 to fix an unidentified security issue in SHA-0. The reason for the tweak became clear when in 1998 two researchers <span epub:type="pagebreak" id="page_117"/>discovered how to find collisions for SHA-0 in about 2<sup>60</sup> operations instead of the 2<sup>80</sup> expected for 160-bit hash functions such as SHA-0 and SHA-1. Later attacks reduced the complexity to around 2<sup>33</sup> operations, leading to actual collisions in less than an hour for SHA-0.</p>
<h5 class="h5">SHA-1 Internals</h5>
<p class="noindentb">SHA-1 combines a Merkle–Damgård hash function with a Davies–Meyer compression function based on a specially crafted block cipher, sometimes called SHACAL. That is, SHA-1 works by iterating the following operation over 512-bit message blocks (<em>M</em>):</p>
<p class="center"><em>H</em> = <strong>E</strong>(<em>M</em>, <em>H</em>) + <em>H</em></p>
<p class="indentt">Here, the use of a plus sign (+) rather than ⊕ (XOR) is intentional. <strong>E</strong>(<em>M</em>, <em>H</em>) and <em>H</em> are viewed as arrays of 32-bit integers, and each two words at a same position are added together: the first 32-bit word of <strong>E</strong>(<em>M</em>, <em>H</em>) with the first 32-bit word of <em>H</em>, and so on. The initial value of <em>H</em> is constant for any message, then <em>H</em> is modified as per the above equation, and the final value of <em>H</em> after processing all blocks is returned as the hash of the message.</p>
<p class="indent">Once the block cipher is run using the message block as a key and the current 160-bit chaining value as a plaintext block, the 160-bit result is seen as an array of five 32-bit words, each of which is added to its 32-bit counterpart in the initial <em>H</em> value.</p>
<p class="indent"><a href="ch06.xhtml#ch6list4">Listing 6-4</a> shows SHA-1’s compression function, <code>SHA1-compress()</code>:</p>
<pre>SHA1-compress(H, M) {<br/>    (a0, b0, c0, d0, e0) = H   // parsing H as five 32-bit big endian words<br/>    (a, b, c, d, e) = <span class="codestrong">SHA1-blockcipher</span>(a0, b0, c0, d0, e0, M)<br/>    return (a + a0, b + b0, c + c0, d + d0, e + e0)<br/>}</pre>
<p class="figcap"><a id="ch6list4"/><em>Listing 6-4: SHA-1’s compression function</em></p>
<p class="indent">SHA-1’s block cipher <code>SHA1-blockcipher()</code>, shown in bold in <a href="ch06.xhtml#ch6list5">Listing 6-5</a>, takes a 512-bit message block, <em>M</em>, as a key and transforms the five 32-bit words (<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, and <code>e</code>) by iterating 80 steps of a short sequence of operations to replace the word <code>a</code> with a combination of all five words. It then shifts the other words in the array, as in a shift register.</p>
<pre>SHA1-blockcipher(a, b, c, d, e, M) {<br/>    W = <span class="codestrong">expand</span>(M)<br/>    for i = 0 to 79 {<br/>        new = (a &lt;&lt;&lt; 5) + <span class="codestrong">f</span>(i, b, c, d) + e + K[i] + W[i]<br/>        (a, b, c, d, e) = (new, a, b &gt;&gt;&gt; 2, c, d)<br/>    }<br/>    return (a, b, c, d, e)<br/>}</pre>
<p class="figcap"><a id="ch6list5"/><em>Listing 6-5: SHA-1’s block cipher</em></p>
<p class="indentt"><span epub:type="pagebreak" id="page_118"/>The <code>expand()</code> function shown in <a href="ch06.xhtml#ch6list6">Listing 6-6</a> creates an array of eighty 32-bit words, <em>W</em>, from the 16-word message block by setting <em>W</em>’s first 16 words to <em>M</em> and the subsequent ones to an XOR combination of previous words, rotated one bit to the left.</p>
<pre>expand(M) {<br/>    // the 512-bit M is seen as an array of sixteen 32-bit words<br/>    W = empty array of eighty 32-bit words<br/>    for i = 0 to 79 {<br/>        if i &lt; 16 then W[i] = M[i]<br/>        else<br/>            W[i] = (W[i – 3] ⊕ W[i – 8] ⊕ W[i – 14] ⊕ W[i – 16]) &lt;&lt;&lt; 1<br/>    }<br/>    return W<br/>}</pre>
<p class="figcap"><a id="ch6list6"/><em>Listing 6-6: SHA-1’s expand() function</em></p>
<p class="indentt">The <code>&lt;&lt;&lt; 1</code> operation in <a href="ch06.xhtml#ch6list6">Listing 6-6</a> is the only difference between the SHA-1 and SHA-0 functions.</p>
<p class="indent">Finally, the <code>f()</code> function (see <a href="ch06.xhtml#ch6list7">Listing 6-7</a>) in <code>SHA1-blockcipher()</code> is a sequence of basic bitwise logical operations (a Boolean function) that depends on the round number.</p>
<pre>f(i, b, c, d) {<br/>    if i &lt; 20 then return ((b &amp; c) ⊕ (~b &amp; d))<br/>    if i &lt; 40 then return (b ⊕ c ⊕ d)<br/>    if i &lt; 60 then return ((b &amp; c) ⊕ (b &amp; d) ⊕ (c &amp; d))<br/>    if i &lt; 80 then return (b ⊕ c ⊕ d)<br/>}</pre>
<p class="figcap"><a id="ch6list7"/><em>Listing 6-7: SHA-1’s <span class="literalcaption">f()</span> function.</em></p>
<p class="indent">The second and fourth Boolean functions in <a href="ch06.xhtml#ch6list7">Listing 6-7</a> simply XOR the three input words together, which is a linear operation. In contrast, the first and third functions use the non-linear &amp; operator (logical AND) to protect against differential cryptanalysis, which as you recall, exploits the predictable propagation of bitwise difference. Without the &amp; operator (in other words, if <code>f()</code> were always <code>b</code> ⊕ <code>c</code> ⊕ <code>d</code>, for example), SHA-1 would be easy to break by tracing patterns within its internal state.</p>
<h5 class="h5">Attacks on SHA-1</h5>
<p class="noindent">Though more secure than SHA-0, SHA-1 is still insecure, which is why the Chrome browser marks websites using SHA-1 in their HTTPS connection as insecure. Although its 160-bit hash should grant it 80-bit collision resistance, in 2005 researchers found weaknesses in SHA-1 and estimated that finding a collision would take approximately 2<sup>63</sup> calculations. (That number would be 2<sup>80</sup> if the algorithm were flawless.) A real SHA-1 collision only came twelve years later when after years of cryptanalysis, Marc Stevens and other researchers presented two colliding PDF documents through a joint work with Google researchers (see <em><a href="https://shattered.io/">https://shattered.io/</a></em>).</p>
<p class="indent"><span epub:type="pagebreak" id="page_119"/>The upshot is that you should not use SHA-1. As mentioned, internet browsers now mark SHA-1 as insecure, and SHA-1 is no longer recommended by NIST. Use SHA-2 hash functions instead, or BLAKE2 or SHA-3.</p>
<h4 class="h4" id="lev2sec80"><em>SHA-2</em></h4>
<p class="noindent">SHA-2, the successor to SHA-1, was designed by the NSA and standardized by NIST. SHA-2 is a family of four hash functions: SHA-224, SHA-256, SHA-384, and SHA-512, of which SHA-256 and SHA-512 are the two main algorithms. The three-digit numbers represent the bit lengths of each hash.</p>
<h5 class="h5">SHA-256</h5>
<p class="noindent">The initial motivation behind the development of SHA-2 was to generate longer hashes and thus deliver higher security levels than SHA-1. For example, whereas SHA-1 has 160-bit chaining values, SHA-256 has 256-bit chaining values or eight 32-bit words. Both SHA-1 and SHA-256 have 512-bit message blocks; however, whereas SHA-1 makes 80 rounds, SHA-256 makes 64 rounds, expanding the 16-word message block to a 64-word message block using the <code>expand256()</code> function shown in <a href="ch06.xhtml#ch6list8">Listing 6-8</a>.</p>
<pre>expand256(M) {<br/>    // the 512-bit M is seen as an array of sixteen 32-bit words<br/>    W = empty array of sixty-four 32-bit words<br/>    for i = 0 to 63 {<br/>        if i &lt; 16 then W[i] = M[i]<br/>        else {<br/>            // the "&gt;&gt;" shifts instead of a "&gt;&gt;&gt;" rotates and is not a typo<br/>            s0 = (W[i – 15] &gt;&gt;&gt; 7) ⊕ (W[i – 15] &gt;&gt;&gt; 18) ⊕ (W[i – 15] &gt;&gt; 3)<br/>            s1 = (W[i – 2] &gt;&gt;&gt; 17) ⊕ (W[i – 2] &gt;&gt;&gt; 19) ⊕ (W[i – 2] &gt;&gt; 10)<br/>            W[i] = W[i – 16] + s0 + W[i – 7] + s1<br/>        }<br/>    }<br/>    return W<br/>}</pre>
<p class="figcap"><a id="ch6list8"/><em>Listing 6-8: SHA-256’s <span class="literalcaption">expand256()</span> function</em></p>
<p class="indent">Note how SHA-2’s <code>expand256()</code> message expansion is more complex than SHA-1’s <code>expand()</code>, shown previously in <a href="ch06.xhtml#ch6list6">Listing 6-6</a>, which in contrast simply performs XORs and a 1-bit rotation. The main loop of SHA-256’s compression function is also more complex than that of SHA-1, performing 26 arithmetic operations per iteration compared to 11 for SHA-1. Again, these operations are XORs, logical ANDs, and word rotations.</p>
<h5 class="h5">Other SHA-2 Algorithms</h5>
<p class="noindent">The SHA-2 family includes SHA-224, which is algorithmically identical to SHA-256 except that its initial value is a different set of eight 32-bit words, and its hash value length is 224 bits, instead of 256 bits, and is taken as the first 224 bits of the final chaining value.</p>
<p class="indent"><span epub:type="pagebreak" id="page_120"/>The SHA-2 family also includes the algorithms SHA-512 and SHA-384. SHA-512 is similar to SHA-256 except that it works with 64-bit words instead of 32-bit words. As a result, it uses 512-bit chaining values (eight 64-bit words) and ingests 1024-bit message blocks (sixteen 64-bit words), and it makes 80 rounds instead of 64. The compression function is otherwise almost the same as that of SHA-256, though with different rotation distances to cope with the wider word size. (For example, SHA-512 includes the operation <code>a &gt;&gt;&gt; 34</code>, which wouldn’t make sense with SHA-256’s 32-bit words.) SHA-384 is to SHA-512 what SHA-224 is to SHA-256—namely, the same algorithm but with a different initial value and a final hash truncated to 384 bits.</p>
<p class="indent">Security-wise, all four SHA-2 versions have lived up to their promises so far: SHA-256 guarantees 256-bit preimage resistance, SHA-512 guarantees about 256-bit collision resistance, and so on. Still, there is no genuine proof that SHA-2 functions are secure; we’re talking about probable security.</p>
<p class="indent">That said, after practical attacks on MD5 and on SHA-1, researchers and NIST grew concerned about SHA-2’s long-term security due to its similarity to SHA-1, and many believed that attacks on SHA-2 were just a matter of time. As I write this, though, we have yet to see a successful attack on SHA-2. Regardless, NIST developed a backup plan: SHA-3.</p>
<h4 class="h4" id="lev2sec81"><em>The SHA-3 Competition</em></h4>
<p class="noindent">Announced in 2007, the NIST Hash Function Competition (the official name of the SHA-3 competition) began with a call for submissions and some basic requirements: hash submissions were to be at least as secure and as fast as SHA-2, and they should be able to do at least as much as SHA-2. SHA-3 candidates also shouldn’t look too much like SHA-1 and SHA-2 in order to be immune to attacks that would break SHA-1 and potentially SHA-2. By 2008, NIST had received 64 submissions from around the world, including from universities and large corporations (BT, IBM, Microsoft, Qualcomm, and Sony, to name a few). Of these 64 submissions, 51 matched the requirements and entered the first round of the competition.</p>
<p class="indentb">During the first weeks of the competition, cryptanalysts mercilessly attacked the submissions. In July 2009, NIST announced 14 second-round candidates. After spending 15 months analyzing and evaluating the performance of these candidates, NIST chose five finalists:</p>
<p class="hang"><strong>BLAKE</strong> An enhanced Merkle–Damgård hash whose compression function is based on a block cipher, which is in turn based on the core function of the stream cipher ChaCha, a chain of additions, XORs, and word rotations. BLAKE was designed by a team of academic researchers based in Switzerland and the UK, including myself.</p>
<p class="hang"><strong>Grøstl</strong> An enhanced Merkle–Damgård hash whose compression function uses two permutations (or fixed-key block ciphers) based on the core function of the AES block cipher. Grøstl was designed by a team of seven academic researchers from Denmark and Austria.</p>
<p class="hang"><strong>JH</strong> A tweaked sponge function construction wherein message blocks are injected before and after the permutation rather than just before. <span epub:type="pagebreak" id="page_121"/>The permutation also performs operations similar to a substitution–permutation block cipher (as discussed in <a href="ch04.xhtml#ch4">Chapter 4</a>). JH was designed by a cryptographer from a university in Singapore.</p>
<p class="hang"><strong>Keccak</strong> A sponge function whose permutation performs only bitwise operations. Keccak was designed by a team of four cryptographers working for a semiconductor company based in Belgium and Italy, and included one of the two designers of AES.</p>
<p class="hang"><strong>Skein</strong> A hash function based on a different mode of operation than Merkle–Damgård, and whose compression function is based on a novel block cipher that uses only integer addition, XOR, and word rotation. Skein was designed by a team of eight cryptographers from academia and industry, all but one of whom is based in the US, including the renowned Bruce Schneier.</p>
<p class="indentt">After extensive analysis of the five finalists, NIST announced a winner: Keccak. NIST’s report rewarded Keccak for its “elegant design, large security margin, good general performance, excellent efficiency in hardware, and its flexibility.” Let’s see how Keccak works.</p>
<h4 class="h4" id="lev2sec82"><em>Keccak (SHA-3)</em></h4>
<p class="noindent">One of the reasons that NIST chose Keccak is that it’s completely different from SHA-1 and SHA-2. For one thing, it’s a sponge function. Keccak’s core algorithm is a permutation of a 1600-bit state that ingests blocks of 1152, 1088, 832, or 576 bits, producing hash values of 224, 256, 384, or 512 bits, respectively—the same four lengths produced by SHA-2 hash functions. But unlike SHA-2, SHA-3 uses a single core algorithm rather than two algorithms for all four hash lengths.</p>
<p class="indent">Another reason is that Keccak is more than just a hash. The SHA-3 standard document FIPS 202 defines four hashes—SHA3-224, SHA3-256, SHA3-384, and SHA3-512—and two algorithms called SHAKE128 and SHAKE256. (The name <em>SHAKE</em> stands for <em>Secure Hash Algorithm with Keccak</em>.) These two algorithms are <em>extendable-output functions</em> <em>(XOFs)</em>, or hash functions that can produce hashes of variable length, even very long ones. The numbers 128 and 256 represent the security level of each algorithm.</p>
<p class="indent">The FIPS 202 standard itself is lengthy and hard to parse, but you’ll find open-source implementations that are reasonably fast and make the algorithm easier to understand than the specifications. For example, the MIT-licensed tiny_sha3 (<em><a href="https://github.com/mjosaarinen/tiny_sha3/">https://github.com/mjosaarinen/tiny_sha3/</a></em>) by Markku-Juhani O. Saarinen, explains Keccak’s core algorithm in 19 lines of C, as partially reproduced in <a href="ch06.xhtml#ch6list9">Listing 6-9</a>.</p>
<pre>static void sha3_keccakf(uint64_t st[25], int rounds)<br/>{<br/>    (⊕)<br/>    for (r = 0; r &lt; rounds; r++) {<br/><br/>     <span class="ent">❶</span> // Theta <br/>        for (i = 0; i &lt; 5; i++)<br/>            bc[i] = st[i] ^ st[i + 5] ^ st[i + 10] ^ st[i + 15] ^ st[i + 20];<br/><br/>        for (i = 0; i &lt; 5; i++) {<br/>            t = bc[(i + 4) % 5] ^ ROTL64(bc[(i + 1) % 5], 1);<br/>            for (j = 0; j &lt; 25; j += 5)<br/>                st[j + i] ^= t;<br/>        }<br/><br/>     <span class="ent">❷</span> // Rho Pi<br/>        t = st[1];<br/>        for (i = 0; i &lt; 24; i++) {<br/>            j = keccakf_piln[i];<br/>            bc[0] = st[j];<br/>            st[j] = ROTL64(t, keccakf_rotc[i]);<br/>            t = bc[0];<br/>        }<br/><br/>     <span class="ent">❸</span> // Chi<br/>        for (j = 0; j &lt; 25; j += 5) {<br/>            for (i = 0; i &lt; 5; i++)<br/>                bc[i] = st[j + i];<br/>            for (i = 0; i &lt; 5; i++)<br/>                st[j + i] ^= (~bc[(i + 1) % 5]) &amp; bc[(i + 2) % 5];<br/>        }<br/><br/>     <span class="ent">❹</span> // Iota<br/>        st[0] ^= keccakf_rndc[r];<br/>    }<br/>    (⊕)<br/>}</pre>
<p class="figcap"><span epub:type="pagebreak" id="page_122"/><a id="ch6list9"/><em>Listing 6-9: The tiny_sha3 implementation</em></p>
<p class="indentt">The tiny_sha3 program implements the permutation, <strong>P</strong>, of Keccak, an invertible transformation of a 1600-bit state viewed as an array of twenty-five 64-bit words. As you review the code, notice that it iterates a series of rounds, where each round consists of four main steps (as marked by <span class="ent">❶</span>, <span class="ent">❷</span>, <span class="ent">❸</span>, and <span class="ent">❹</span>):</p>
<ul>
<li class="noindent">The first step, <code>Theta</code> <span class="ent">❶</span>, includes XORs between 64-bit words or a 1-bit rotated value of the words (the <code>ROTL64(w, 1)</code> operation left-rotates a word <code>w</code> of 1 bit).</li>
<li class="noindent">The second step, <code>Rho Pi</code> <span class="ent">❷</span>, includes rotations of 64-bit words by constants hardcoded in the <code>keccakf_rotc[]</code> array.</li>
<li class="noindent">The third step, <code>Chi</code> <span class="ent">❸</span>, includes more XORs, but also logical ANDs (the &amp; operator) between 64-bit words. These ANDs are the only nonlinear operations in Keccak, and they bring with them cryptographic strength.</li>
<li class="noindent">The fourth step, <code>Iota</code> <span class="ent">❹</span>, includes a XOR with a 64-bit constant, hardcoded in the <code>keccakf_rndc[]</code>.</li>
</ul>
<p class="indentt"><span epub:type="pagebreak" id="page_123"/>These operations provide SHA-3 with a strong permutation algorithm free of any bias or exploitable structure. SHA-3 is the product of more than a decade of research, and hundreds of skilled cryptanalysts have failed to break it. It’s unlikely to be broken anytime soon.</p>
<h3 class="h3" id="lev1sec42">The BLAKE2 Hash Function</h3>
<p class="noindent">Security may matter most, but speed comes second. I’ve seen many cases where a developer wouldn’t switch from MD5 to SHA-1 simply because MD5 is faster, or from SHA-1 to SHA-2 because SHA-2 is noticeably slower than SHA-1. Unfortunately, SHA-3 isn’t faster than SHA-2, and because SHA-2 is still secure, there are few incentives to upgrade to SHA-3. So how to hash faster than SHA-1 and SHA-2 and be even more secure? The answer lies in the hash function BLAKE2, released after the SHA-3 competition.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Full disclosure: I’m a designer of BLAKE2, together with Samuel Neves, Zooko Wilcox-O’Hearn, and Christian Winnerlein.</em></p>
</div>
<p class="indentt">BLAKE2 was designed with the following ideas in mind:</p>
<ul>
<li class="noindent">It should be least as secure as SHA-3, if not stronger.</li>
<li class="noindent">It should be faster than all previous hash standards, including MD5.</li>
<li class="noindent">It should be suited for use in modern applications, and able to hash large amounts of data either as a few large messages or many small ones, with or without a secret key.</li>
<li class="noindent">It should be suited for use on modern CPUs supporting parallel computing on multicore systems as well as instruction-level parallelism within a single core.</li>
</ul>
<p class="indent1">The outcome of the engineering process is a pair of main hash functions:</p>
<ul>
<li class="noindent">BLAKE2b (or just BLAKE2), optimized for 64-bit platforms, produces digests ranging from 1 to 64 bytes.</li>
<li class="noindent">BLAKE2s, optimized for 8- to 32-bit platforms, can produce digests ranging from 1 to 32 bytes.</li>
</ul>
<p class="indentt">Each function has a parallel variant that can leverage multiple CPU cores. The parallel counterpart of BLAKE2b, BLAKE2bp, runs on four cores, whereas BLAKE2sp runs on eight cores. The former is the fastest on modern server and laptop CPUs and can hash at close to 2 Gbps on a laptop CPU. In fact, BLAKE2 is the fastest secure hash available today, and its speed and features have made it the most popular non-NIST-standard hash. BLAKE2 is used in countless software applications and has been integrated into major cryptography libraries such as OpenSSL and Sodium.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_124"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>You can find BLAKE2’s specifications and reference code at</em> <a href="https://blake2.net/">https://blake2.net/</a>, <em>and you can download optimized code and libraries from</em> <a href="https://github.com/BLAKE2/">https://github.com/BLAKE2/</a>. <em>The reference code also provides BLAKE2X, an extension of BLAKE2 that can produce hash values of arbitrary length.</em></p>
</div>
<div class="image"><img src="../images/f06-08.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig8"/><em>Figure 6-8: BLAKE2’s compression function. The two halves of the state are XORed together after the block cipher.</em></p>
<p class="indent">BLAKE2’s compression function, shown in <a href="ch06.xhtml#ch6fig8">Figure 6-8</a>, is a variant of the Davies–Meyer construction that takes parameters as additional input—namely, a <em>counter</em> (which ensures that each compression function behaves like a different function) and a <em>flag</em> (which indicates whether the compression function is processing the last message block, for increased security).</p>
<p class="indent">The block cipher in BLAKE2’s compression function is based on the stream cipher ChaCha, itself a variant of the Salsa20 stream cipher discussed in <a href="ch05.xhtml#ch5">Chapter 5</a>. Within this block cipher, BLAKE2b’s core operation is composed of the following chain of operations, which transforms a state of four 64-bit words using two message words, <em>M</em><sub><em>i</em></sub> and <em>M</em><sub><em>j</em></sub>:</p>
<div class="image1"><img src="../images/f0124-01.jpg" alt="image"/></div>
<p class="indentt">BLAKE2s’s core operation is similar but works with 32-bit instead of 64-bit words (and thus uses different rotation values).</p>
<h3 class="h3" id="lev1sec43">How Things Can Go Wrong</h3>
<p class="noindent">Despite their apparent simplicity, hash functions can cause major security troubles when used at the wrong place or in the wrong way—for example, when weak checksum algorithms like CRCs are used instead of a crypto hash to check file integrity in applications transmitting data over a network. However, this weakness pales in comparison to some others, which can cause total compromise in seemingly secure hash functions. We’ll see two examples of failures: the first one applies to SHA-1 and SHA-2, but not to BLAKE2 or SHA-3, whereas the second one applies to all of these four functions.</p>
<h4 class="h4" id="lev2sec83"><span epub:type="pagebreak" id="page_125"/><em>The Length-Extension Attack</em></h4>
<p class="noindent">The <em>length-extension attack</em>, shown in <a href="ch06.xhtml#ch6fig9">Figure 6-9</a>, is the main threat to the Merkle–Damgård construction.</p>
<div class="image"><img src="../images/f06-09.jpg" alt="image"/></div>
<p class="figcap"><a id="ch6fig9"/><em>Figure 6-9: The length-extension attack</em></p>
<p class="indentt">Basically, if you know <strong>Hash</strong>(<em>M</em>) for some <em>unknown</em> message, <em>M</em>, composed of blocks <em>M</em><sub>1</sub> and <em>M</em><sub>2</sub> (after padding), you can determine <strong>Hash</strong>(<em>M</em><sub>1</sub> || <em>M</em><sub>2</sub> || <em>M</em><sub>3</sub>) for any block, <em>M</em><sub>3</sub>. Because the hash of <em>M</em><sub>1</sub> || <em>M</em><sub>2</sub> is the chaining value that follows immediately after <em>M</em><sub>2</sub>, you can add another block, <em>M</em><sub>3</sub>, to the hashed message, even though you don’t know the data that was hashed. What’s more, this trick generalizes to any number of blocks in the unknown message (<em>M</em><sub>1</sub> || <em>M</em><sub>2</sub> here) or in the suffix (<em>M</em><sub>3</sub>).</p>
<p class="indent">The length-extension attack won’t affect most applications of hash functions, but it can compromise security if the hash is used a bit too creatively. Unfortunately, SHA-2 hash functions are vulnerable to the length-extension attack, even though the NSA designed the functions and NIST standardized them while both were well aware of the flaw. This flaw could have been avoided simply by making the last compression function call different from all others (for example, by taking a 1 bit as an extra parameter while the previous calls take a 0 bit). And that is in fact what BLAKE2 does.</p>
<h4 class="h4" id="lev2sec84"><em>Fooling Proof-of-Storage Protocols</em></h4>
<p class="noindent">Cloud computing applications have used hash functions within <em>proof-of-storage</em> protocols—that is, protocols where a server (the cloud provider) proves to a client (a user of a cloud storage service) that the server does in fact store the files that it’s supposed to store on behalf of the client.</p>
<p class="indent">In 2007, the paper “SafeStore: A Durable and Practical Storage System” <em>(<a href="https://www.cs.utexas.edu/~lorenzo/papers/p129-kotla.pdf">https://www.cs.utexas.edu/~lorenzo/papers/p129-kotla.pdf</a></em>) by Ramakrishna Kotla, Lorenzo Alvisi, and Mike Dahlin proposed a proof-of-storage protocol to verify the storage of some file, <em>M</em>, as follows:</p>
<ol>
<li class="noindent"><p class="list">The client picks a random value, <em>C,</em> as a <em>challenge</em>.</p></li>
<li class="noindent"><p class="list">The server computes <strong>Hash</strong>(<em>M</em> || <em>C</em>) as a <em>response</em> and sends the result to the client.</p></li>
<li class="noindent"><p class="list">The client also computes <strong>Hash</strong>(<em>M</em> || <em>C</em>) and checks that it matches the value received from the server.</p></li>
</ol>
<p class="indent">The premise of the paper is that the server shouldn’t be able to fool the client because if the server doesn’t know <em>M</em>, it can’t guess <strong>Hash</strong>(<em>M</em> || <em>C</em>). <span epub:type="pagebreak" id="page_126"/>But there’s a catch: in reality, <strong>Hash</strong> will be an iterated hash that processes its input block by block, computing intermediate chaining values between each block. For example, if <strong>Hash</strong> is SHA-256 and <em>M</em> is 512 bits long (the size of a block in SHA-256), the server can cheat. How? The first time the server receives <em>M</em>, it computes <em>H</em><sub>1</sub> = <strong>Compress</strong>(<em>H</em><sub>0</sub>, <em>M</em><sub>1</sub>), the chaining value obtained from SHA-256’s initial value, <em>H</em><sub>0</sub>, and from the 512-bit <em>M</em>. It then records <em>H</em><sub>1</sub> in memory and discards <em>M</em>, at which point it no longer stores <em>M</em>.</p>
<p class="indent">Now when the client sends a random value, <em>C</em>, the server computes <strong>Compress</strong>(<em>H</em><sub>1</sub>, <em>C</em>), after adding the padding to <em>C</em> to fill a complete block, and returns the result as <strong>Hash</strong>(<em>M</em> || <em>C</em>). The client then believes that, because the server returned the correct value of <strong>Hash</strong>(<em>M</em> || <em>C</em>), it holds the complete message—except that it may not, as you’ve seen.</p>
<p class="indent">This trick will work for SHA-1, SHA-2, as well as SHA-3 and BLAKE2. The solution is simple: ask for <strong>Hash</strong>(<em>C</em> || <em>M</em>) instead of <strong>Hash</strong>(<em>M</em> || <em>C</em>).</p>
<h3 class="h3" id="lev1sec44">Further Reading</h3>
<p class="noindent">To learn more about hash functions, read the classics from the 1980s and 90s: research articles like Ralph Merkle’s “One Way Hash Functions and DES” and Ivan Damgård’s “A Design Principle for Hash Functions.” Also read the first thorough study of block cipher-based hashing, “Hash Functions Based on Block Ciphers: A Synthetic Approach” by Preneel, Govaerts, and Vandewalle.</p>
<p class="indent">For more on collision search, read the 1997 paper “Parallel Collision Search with Cryptanalytic Applications” by van Oorschot and Wiener. To learn more about the theoretical security notions that underpin preimage resistance and collision resistance, as well as length-extension attacks, search for <em>indifferentiability</em>.</p>
<p class="indent">For more recent research on hash functions, see the archives of the SHA-3 competition, which include all the different algorithms and how they were broken. You’ll find many references on the SHA-3 Zoo at <em><a href="http://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo">http://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo</a></em>, and on NIST’s page, <em><a href="http://csrc.nist.gov/groups/ST/hash/sha-3/">http://csrc.nist.gov/groups/ST/hash/sha-3/</a></em>.</p>
<p class="indent">For more on the SHA-3 winner Keccak and sponge functions, see <em><a href="http://keccak.noekeon.org/">http://keccak.noekeon.org/</a></em> and <em><a href="http://sponge.noekeon.org/">http://sponge.noekeon.org/</a></em>, the official pages of the Keccak designers.</p>
<p class="indentb">Last but not least, research these two real exploitations of weak hash functions:</p>
<ul>
<li class="noindent">The nation-state malware Flame exploited an MD5 collision to make a counterfeit certificate and appear to be a legitimate piece of software.</li>
<li class="noindent">The Xbox game console used a weak block cipher (called TEA) to build a hash function, which was exploited to hack the console and run arbitrary code on it.</li>
</ul>
</body></html>