<html><head></head><body>
<h2 class="h" id="ch10"><span epub:type="pagebreak" id="page_305" class="calibre1"/><strong class="calibre2"><span class="big">10</span><br class="calibre3"/>STATISTICS</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">The true Logic for this world is the Calculus of Probabilities.</em></p>
<p class="center1">—James Clerk Maxwell</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">Many readers of this book are likely to skip one or more chapters in <a href="part2.xhtml" class="calibre10">Part II</a>. A biologist may not be interested in physics applications, for example. But <em class="calibre11">this</em> particular chapter has something in it for everyone, because sooner or later, all scientists must deal with the subject of statistics.</p>
<p class="indent">Anyone conducting experiments knows that the treatment and analysis of experimental data is a direct application of statistical methods and concepts. Every scientific calculator features buttons for calculating means and standard deviations of rows of numbers. In this chapter, you will learn how to apply Julia and its statistical libraries to manipulate, plot, and analyze all kinds of data. Julia is generally faster, more flexible, more extensible, and more powerful than R, the near-standard language in this field. But if you have R programs that you are already working with, I’ll explain how to use them from within your Julia environment.</p>
<p class="indent">The concepts of probabilities and distributions are ubiquitous in physics, from the classical theories of statistical mechanics to quantum theory, in which probability plays a fundamental role. But statistics, and its basis in <span epub:type="pagebreak" id="page_306"/>the language of probabilities, has its fingerprints all over science, even apart from experiments and observations. One of the detailed examples in this chapter involves probabilistic modeling in biology: an application of these ideas outside of both analysis of experiments and physics.</p>
<h3 class="h2" id="ch10lev1"><strong class="calibre2">Probability</strong></h3>
<p class="noindent">We don’t have the space here for a complete course in probability and statistics, but fortunately, we can do everything we need to do without a detailed mathematical development. Almost all scientists have some familiarity with the basic concepts and methods of the discipline, but I will not assume any special knowledge.</p>
<p class="indent">To understand and use statistics, we first need a clear grasp of <em class="calibre11">probability</em>. For our purposes, we can understand a probability as a number between 0 and 1, inclusive, that represents the likelihood of an event. A probability of 0 means that the event is impossible, and a probability of 1 means that it must occur. Any other probability can be interpreted as the frequency, or proportion of times, with which the event will occur in a large number of experiments. For example, if we say that the probability of heads when you flip a coin is 1/2, this means if you flip the coin a large number of times, the ratio of times that it comes up heads divided by the total number of flips will be close to 0.5.</p>
<p class="indent">How many times is a large number of times? What we really mean is that there is a limit</p>
<div class="image"><img alt="Image" src="../images/306math.jpg" class="calibre6"/></div>
<p class="noindent">which just says that as we do more and more experiments, the number of times that we observe the event <em class="calibre11">x</em>, <em class="calibre11">n</em><sub class="calibre24"><em class="calibre11">x</em></sub>, divided by the total number of experiments, <em class="calibre11">N</em>, gets closer and closer to a certain ratio. We call this ratio the probability. In probability theory, <em class="calibre11">experiment</em> means a process, such as flipping a coin or rolling a die.</p>
<p class="indent">The preceding paragraph describes a particular view of probability called the <em class="calibre11">frequency interpretation</em>. There are other ways to look at probability and its meaning, but in some sense, they are all equivalent. The frequency interpretation is practical, serves our purposes well, and is what most people think of when they need to pin down their idea of what probability means in practice. For more formal approaches to the subject, see “Further Reading” on <a href="ch10.xhtml#fur10" class="calibre10">page 359</a>.</p>
<p class="indent">We’ll often want to simulate events in our computer programs that are supposed to occur with certain probabilities. This could be part of the simulation of a system, such as the molecules of a gas bouncing around in a box, which we may want to initialize with random positions and velocities, or it could be part of a statistical test. But this presents a problem: if probability represents chance, the outcome of some kind of random process, and what goes on inside our computers is (we certainly hope) deterministic, how can we use computers to generate random events?</p>
<p class="indent"><span epub:type="pagebreak" id="page_307"/>For the purposes of the examples in this book, we actually don’t want our random events to be random, because we may want to repeat simulations or check to see whether we get identical results after changing a computational technique. We need to be able to repeat particular sequences of “random” events. Surely this is a contradiction. If we know what’s going to happen, it can’t be random.</p>
<p class="indent">The random numbers we generate in our programs are called <em class="calibre11">pseudorandom</em> numbers. They look like sequences of random numbers, satisfy certain tests of randomness, and adhere to given <em class="calibre11">distributions</em> (explained next). However, naturally, they are not really random. Again, we don’t actually want them to be.</p>
<p class="indent">Except when we do. In some cryptography applications, we really need actual, unpredictable random numbers. Because the bad guys know the various algorithms for generating pseudorandom numbers, being able to predict such sequences can lead to defeating cryptographic systems. For such purposes, computer security systems exploit sources of real unpredictability available on any computer (known as <em class="calibre11">entropy sources</em>). These sources can be stored data derived from the timing of key presses on the keyboard, for example. The search for entropy has led to some creative solutions, such as pointing cameras at a wall of lava lamps.</p>
<p class="indent">Julia actually provides a way to tap into the entropy provided by your operating system. However, in this book, we are not interested in cryptography, but in science, so we want our random numbers to be not so random, and we’ll be using Julia’s pseudorandom number generators. I’ll follow common practice for the rest of this chapter and just call these pseudorandom numbers “random numbers.”</p>
<h3 class="h2" id="ch10lev2"><strong class="calibre2">Random Numbers in Julia</strong></h3>
<p class="noindent">Julia has functions for generating random numbers with all kinds of numerical types, even complex numbers. The basic random number generators are part of <code>Base</code>, so you can use them without any <code>import</code> statements.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">I mentioned earlier that one reason to use pseudorandom numbers is so we can repeat a sequence of random numbers when developing code. This sequence repeatability is not guaranteed to work forever, however. The random sequence returned by a particular function can change when upgrading Julia, so you can’t depend on this for code development over the long term. See “Further Reading” on <a href="ch10.xhtml#fur10" class="calibre10">page 359</a> if you need long-term reproducible number sequences.</em></p>
</div>
<p class="indent">The simplest use is just calling <code>rand()</code>, which returns a random <code>Float64</code> <em class="calibre11">uniformly distributed</em> in the interval [0, 1). This means that the number might be equal to 0, but it will be less than 1, and all numbers in this interval are equally likely.</p>
<p class="indent">We can check that the <code>rand()</code> function is doing what we expect by generating a bunch of random numbers and plotting them with a scatterplot. We could do this by calling <code>rand()</code> many times, storing its returned values in an array, and plotting the array. But <code>rand()</code> makes it even easier: if we give it an <span epub:type="pagebreak" id="page_308"/>integer argument, it will oblige us by returning an array of random values whose length will be determined by the argument. If we give it more than one, we’ll get back a higher-dimensional array. The little program shown in <a href="ch10.xhtml#ch10lis1" class="calibre10">Listing 10-1</a> fills a length-10<sup class="calibre23">5</sup> array with random floats and visualizes their distribution with a scatterplot.</p>
<pre class="calibre13">using Plots

ra = rand(100000)
scatter(ra, markersize=1, label=nothing)</pre>
<p class="list" id="ch10lis1"><em class="calibre11">Listing 10-1: Testing random number generation</em></p>
<p class="indent">In the resulting plot, shown in <a href="ch10.xhtml#ch10fig1" class="calibre10">Figure 10-1</a>, each of the 10<sup class="calibre23">5</sup> numbers is represented by a tiny dot. All the numbers lie within the correct interval, and they appear to be randomly and uniformly distributed, as they are supposed to be. A plot like this is a useful visual check to ensure that a pseudorandom number generator is behaving correctly and not introducing any unwanted patterns in the distribution of values.</p>
<div class="image"><img alt="Image" id="ch10fig1" src="../images/ch10fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-1: Uniformly distributed random floats</em></p>
<p class="indent">To get random integers, or some type other than floats, simply pass the type as an argument. The call <code>rand(Int)</code>, which is the same as <code>rand(Int64)</code>, returns a random integer within the range defined by the lowest and highest possible integers of that type. This is rarely what you want in applications, however. You’ll probably want a random integer within some specified range that is relevant to your problem. In that case, simply pass the range as an argument: <code>rand(1:6)</code> represents the roll of a die, for example.</p>
<p class="indent"><span epub:type="pagebreak" id="page_309"/>In fact, that argument can be a tuple or list as well, from which <code>rand()</code> will pick a random element, all with equal likelihood. You can even do something like <code>rand([1, 3, "abc"])</code>, and get either <code>1</code>, <code>3</code>, or the string <code>"abc"</code>, each with a probability of 1/3. If you pass in a single string, it will be considered a collection of characters, and you will get a random character back.</p>
<p class="indent">The simple call <code>rand()</code> is useful in simulations where you want events to occur with a certain probability. If the probability of the event is supposed to be <code>P</code>, in your code, you’ll have something like the following, which is a way to make something happen with a specified probability:</p>
<pre class="calibre13">if P &gt; rand()
    event()
end</pre>
<p class="indent">The call to <code>rand()</code> works because it generates <em class="calibre11">uniformly distributed</em> random numbers in the interval [0, 1). Imagine repeatedly throwing a dart at a square dartboard one meter on a side (and assume it lands in a random place on the board). In the long run, the dart will land within the rightmost 90 centimeters 90 percent of the time. The <code>rand()</code> function is the dart.</p>
<p class="indent">Keeping in mind that, over the long term, you can’t count on being able to repeat a particular sequence generated by one of Julia’s random number functions, you’ll need to know how to do it in the short term when debugging code or developing an algorithm. You’ll often want to rerun a program after changing something that you believe should not change the results. If the program uses random numbers, and the sequence is truly unpredictable, such tests become impossible.</p>
<p class="indent">By passing a <em class="calibre11">seed</em> to a random number generator, you can generate a sequence of high-quality pseudorandom numbers and also repeat the same sequence in subsequent runs of your program. To do this, you need to import the <code>Random</code> package, as you’ll need to use at least one function that’s not in <code>Base</code>. But <code>Random</code> has a few other goodies, as you’ll see shortly.</p>
<p class="indent">The following listing shows the three lines of code that illustrate the basic procedure:</p>
<pre class="calibre13">using Random

rgen = MersenneTwister(7654);
rand(rgen)</pre>
<p class="indent">After importing <code>Random</code>, the <code>MersenneTwister()</code> function, which is a random number–generating algorithm, will be available. The name comes from the mathematical library from which the function is taken. Its argument, in this case <code>7654</code>, is called a <em class="calibre11">seed</em>. The purpose of the seed is to generate a particular sequence that we can repeat if needed. The <code>rand()</code> function, and all the other random number functions in Julia, accept an optional first argument that specifies the particular instance of the generator to use. As before, every time we call <code>rand()</code>, we get a random number between 0 and 1. But now we can restart the sequence anytime we want by reinitializing <code>rgen</code> using the same seed. We can generate a different, unpredictable sequence by simply <span epub:type="pagebreak" id="page_310"/>changing the seed. Except for the most casual use, you should always specify a generator and supply it with a seed rather than using the simpler form of <code>rand()</code> as we did in the previous example.</p>
<h3 class="h2" id="ch10lev3"><strong class="calibre2">The Monty Hall Problem</strong></h3>
<p class="noindent">The ability to generate random numbers opens up a whole world of possibilities for interesting simulations. First, let’s consider the <em class="calibre11">Monty Hall problem</em>, which is named after the longtime host of the game show <em class="calibre11">Let’s Make a Deal</em>. This problem is guaranteed to generate lively debate in statistics classes and is something that experienced mathematicians, even statisticians, often get wrong—or they used to, before the problem became famous. For us, it will serve as an example of how a probabilistic computer simulation can verify a result that we believe we have calculated analytically. Simulations can supply some additional confidence in the solutions to tricky probability problems, where it is so easy to go astray analytically.</p>
<p class="indent">Imagine three doors. Behind one is a prize, say, a fancy car, and behind the other two are joke prizes. Monty often used goats for these “loser” prizes. You want the car. Monty asks you to choose a door. He knows where everything is, but you know nothing.</p>
<p class="indent">Let’s say, to be definite, that you choose door #1. Before revealing what’s behind that door, Monty opens one of the other ones, say, door #3, to reveal a goat. He offers you the chance to switch to door #2 if you like.</p>
<p class="indent">Here is the question: should you stick with your original choice or switch to door #2? Does it matter?</p>
<p class="indent">The correct answer is that you should switch. Nevertheless, many people have a strong initial intuition that it must not make any difference. After all, now two doors are available: door #1 and door #2. Surely they have an equal chance of leading to the prize, so it’s the same as flipping a coin: heads or tails are equally likely.</p>
<p class="indent">However, this thinking is wrong. Initially, the probability that your choice was a winner was 1/3. Everyone agrees with that. That means that the probability that the prize was in <em class="calibre11">one of the other doors</em> is 2/3. Since the prize is guaranteed to be somewhere, the total probability must add up to 1. These initial probabilities still hold. The probability that door #1 is the winner is still 1/3. The probability that one of the others is, instead, is still 2/3. But now the set of “one of the others” consists of just door #2, since Monty has eliminated door #3. You should switch to increase your chances of winning from 1/3 to 2/3.</p>
<p class="indent">This analysis is just one of many ways to approach the problem, but they all (if done correctly) lead to the same conclusion. Nevertheless, at this point many people remain unconvinced. Sometimes actually doing the experiment can persuade people who don’t believe in math.</p>
<p class="indent"><span epub:type="pagebreak" id="page_311"/>The following program performs just such an experiment—a simple example of a simulation using a random process:</p>
<pre class="calibre13">   N = 3000

   stay = zeros(Int32, N)
   switch = zeros(Int32, N)

   for game in 1:N
       prize = rand(1:3)
       choice = rand(1:3)
       if choice == prize
           stay[game] = 1
       end
   end

   for game in 1:N
       prize = rand(1:3)
       choice = rand(1:3)
       if choice != prize
           switch[game] = 1
       end
   end

<span class="ent">➊</span> stayra = [sum(stay[1:i]) / i for i in 1:N]
   switchra = [sum(switch[1:i]) / i  for i in 1:N]

   using Plots

   plot(1:N, [stayra, switchra, ones(N)*1/3, ones(N)*2/3],
        label=["Stay" "Switch" "" ""])
   annotate!(2700, 1/3 + 0.05, "1/3")
   annotate!(2700, 2/3 + 0.05, "2/3")</pre>
<p class="indent">This program plays the game <code>N</code> times, where <code>N</code> is set to 3,000. It stores the record of wins or losses in two arrays, one for the set of 3,000 plays where the player stays with the initial choice of door and one for the round where the player decides to switch. The arrays are initialized to be all 0s. If the player wins game number <code>game</code>, that array element is changed to 1.</p>
<p class="indent">The two arrays <span class="ent">➊</span> hold the running average of each strategy, defined using list comprehensions. These are the arrays we want to look at.</p>
<p class="indent">The plot in <a href="ch10.xhtml#ch10fig2" class="calibre10">Figure 10-2</a> shows that in the long run the switching strategy wins 2/3 of the time, while the player who stubbornly sticks with the initial choice wins only 1/3 of the time.</p>
<div class="image"><img alt="Image" id="ch10fig2" src="../images/ch10fig02.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-2: Two Monty Hall strategies</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_312"/>These ratios agree with the argument if we remember the meaning of the frequency interpretation of probability: over the long run, the ratio of events (wins, in this case) to the total number of experiments should approach the probability. Note that if you run this code yourself, the graph may look slightly different, because you’ll get a different sequence of random numbers, but the <em class="calibre11">long-term behavior</em> should be the same.</p>
<h3 class="h2" id="ch10lev4"><strong class="calibre2">Counting</strong></h3>
<p class="noindent">After probability, the next most important idea in statistics is <em class="calibre11">counting</em>, also called <em class="calibre11">combinatorics</em>. Counting has to do with answering questions about how many ways an event can happen. If you roll a pair of dice, in how many ways can the sum of the two numbers that come up equal six? If there are 30 people on the squad, how many nine-person baseball teams are possible?</p>
<p class="indent">When simulating systems involving probability on a computer, to calculate correctly the probabilities of various events, we often <em class="calibre11">count</em> the number of ways a given event can happen and divide by the total number of all possibilities. If all of the ways are equally likely, this gives us the probability.</p>
<p class="indent">In the dice example, there are 10 ways to get a sum of six, so the probability is 10/36.</p>
<p class="indent">Two additional counting concepts arise frequently when dealing with probabilistic situations, and often in other places as well: <em class="calibre11">permutations</em>, calculated using factorials, and <em class="calibre11">combinations</em>, which involve binomial coefficients.</p>
<h4 class="h3" id="ch10lev1sec1"><strong class="calibre2"><em class="calibre4">Factorials</em></strong></h4>
<p class="noindent">The first counting concept is the idea of <em class="calibre11">permutations</em>: the number of distinct ways to arrange a collection of objects. If you have eight <em class="calibre11">Scrabble</em> tiles, <span epub:type="pagebreak" id="page_313"/>all bearing different letters, how many different eight-letter strings can you make out of them?</p>
<p class="indent">The answer is 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40, 320.</p>
<p class="indent">Here’s a quick argument to show why this is true: there are eight ways to choose the first tile; once that is chosen, there are seven ways to choose the next tile; and so on. This pattern comes up so often that we have a special name and mathematical notation for it. It is called the <em class="calibre11">factorial</em>, and it’s written as 8! in this case. Julia also has a built-in function for it, but since <code>!</code> is used for other purposes, we need to spell it out: <code>factorial(8)</code>.</p>
<p class="indent">The factorial function grows insanely quickly, so above <code>factorial(20)</code>, you need to supply the argument as a <code>BigInt</code>, and you’ll get a <code>BigInt</code> back. How quickly does the factorial grow? The number of ways to arrange a standard 52-card deck is far larger than the number of stars in the universe. It’s so large that, after shuffling a deck, there is almost no chance that the particular arrangement of cards you are holding in your hand has existed before in the history of the world.</p>
<h4 class="h3" id="ch10lev1sec2"><strong class="calibre2"><em class="calibre4">Binomial Coefficients</em></strong></h4>
<p class="noindent">The second combinatorial concept we’ll be using is the <em class="calibre11">binomial coefficient</em>. This comes up in many mathematical contexts, and Julia has a built-in function called <code>binomial()</code> that deals with it. In the context of counting, the binomial coefficient answers the baseball teams question mentioned earlier. If there are 30 players available, the number of ways to form nine-member teams is written as:</p>
<div class="image"><img alt="Image" src="../images/313math.jpg" class="calibre6"/></div>
<p class="indent">The baseball problem is calculated with <code>binomial(30, 9)</code>. The combinatorial term for these problems, involving binomial coefficients, is <em class="calibre11">combinations</em>.</p>
<p class="indent">See “Further Reading” on <a href="ch10.xhtml#fur10" class="calibre10">page 359</a> to learn more details about binomial coefficients: why they are so named, how to calculate them using factorials, and their connections to other areas of mathematics.</p>
<h3 class="h2" id="ch10lev5"><strong class="calibre2">Modeling a Pandemic</strong></h3>
<p class="noindent">We now have enough tools to perform a significant calculation. <a href="ch10.xhtml#ch10lis2" class="calibre10">Listing 10-2</a> is a simulation that models the spread of an infection through a population. It’s similar to models epidemiologists use to perform computational experiments with different scenarios for the spread of COVID-19. This model is a bit simplified relative to those, as my purpose is to illustrate an application of the tools and ideas from the chapter so far. For a pointer to similar models being used now in research, see “Further Reading.”</p>
<pre class="calibre13">   using Plots
   using Printf
   using JLD
   <span epub:type="pagebreak" id="page_314"/>worldgrad = cgrad([:blue, :red, :black, :green], [0.25, 0.50, 0.75],
               categorical=true)
   n = 16
<span class="ent">➊</span> initial = Dict("infected"=&gt;0.5, "isolated"=&gt;0.15)
   transition = Dict("infected"=&gt;0.05, "dead"=&gt;0.1, "dud"=&gt;7)
   include("plotworld.jl")
   """Simulate pandemic growth.
       n: length of side of world array;
       initial: starting proportions of infected and isolated subpopulations;
       transition: probabilities of infection and of death after dud days of
                   infection;
       days: number of days before stopping;
       seeding: selects spatially random or centered initial distribution of
                infected individuals;
       plotmode: display or save plots of simulation while running, or save
                 only the final state.
   """
   function pandemic(n::Int, initial, transition, days::Int; seeding=:normal,
                     plotmode=:display)
       noi = [] # Number of infected people
       nod = [] # Number of dead people
       function finish()
           if plotmode == :last
               plotfilename = @sprintf "%d.png" days
               savefig(plotworld(world, noi, nod, worldgrad), plotfilename);
           end
           @save "pandata.jld" world noi nod
       end
       function nif(I, J) # Number of infected neighbors of an uninfected cell
           return sum(world[I-1:I+1,J-1:J+1] .== infected)
       end
       tpi = zeros(8)
    <span class="ent">➋</span> for N in 1:8
          tp = 0
          for i in 1:N
              tp += (-1)^(i-1)*binomial(N, i)*transition["infected"]^i
          end
          tpi[N] = tp # The total probability of infection with N infected neighbors
      end
      ok::Int32 = 1
      infected::Int32 = 2
      dead::Int32 = 3
      isolated::Int32 = 4
      world = fill(ok, n, n)
      if seeding == :normal
          world[rand(n, n) .&lt; initial["infected"]] .= infected
      end
      <span epub:type="pagebreak" id="page_315"/>world[rand(n, n) .&lt; initial["isolated"]] .= isolated
      if seeding == :center
          world[n ÷ 2, n ÷ 2] = infected
      end
   <span class="ent">➌</span> next = copy(world)
   <span class="ent">➍</span> aoi = fill(0, n, n) # Age of infection
      dud = transition["dud"]
      for day in 1:days
          for j in 2:n-1 for i in 2:n-1
              if world[i, j] == ok
                  if nif(i, j) &gt; 0
                      if tpi[nif(i, j)] &gt;= rand()
                          next[i, j] = infected
                          aoi[i, j] = day
                      end
                  end
              end
              if (world[i, j] == infected) &amp;&amp; ((day - aoi[i, j]) == dud)
                  if rand() &lt; transition["dead"]
                      next[i, j] = dead
                  end
              end
          end; end
          world = copy(next)
       <span class="ent">➎</span> push!(noi, sum(world[2:n-1, 2:n-1] .== infected))
          push!(nod, sum(world[2:n-1, 2:n-1] .== dead))
       <span class="ent">➏</span> if day &gt; 4dud
              if noi[end] == noi[end - dud] &amp;&amp; nod[end] == nod[end - dud]
                  return finish()
              end
          end
          if plotmode == :save
              plotfilename = @sprintf "%05d.png" day
              savefig(plotworld(world, noi, nod, worldgrad), plotfilename);
          elseif plotmode == :display
              display(plotworld(world, noi, nod, worldgrad))
          end
      end
      finish()
  end
  days = 2000
  pandemic(n, initial, transition, days; seeding=:normal, plotmode=:display)</pre>
<p class="list" id="ch10lis2"><em class="calibre11">Listing 10-2: A pandemic simulation</em></p>
<p class="indent">The strategy is to represent the population as a square matrix. Each cell represents one person and can be in one of four possible states: <code>infected</code>, <code>dead</code>, <code>isolated</code>, or <code>ok</code>. An <code>isolated</code> person can’t become <code>infected</code>. An <code>ok</code> person <span epub:type="pagebreak" id="page_316"/>is not <code>infected</code>, but may become so. An <code>infected</code> person may die after a certain number of “days,” or iterations, a number assigned to <code>dud</code>; if the person survives past this period, immortality is achieved. A <code>dead</code> person is no longer infectious. Thus, an <code>ok</code> person can never be infected (is “protected”) if surrounded by <code>dead</code> or <code>isolated</code> people. Death and lockdown prevent the spread of the disease.</p>
<p class="indent">The simulation is initialized with probabilities, to establish both the starting state and its evolution. The state at <code>day = 1</code> is set up using the probabilities in the <code>initial</code> dictionary <span class="ent">➊</span>. At every iteration, the state of each person is updated according to the probabilities in the <code>transition</code> dictionary on the following line and the value of <code>dud</code> in that dictionary, which is the number of days during which someone needs to be infected before the disease may become fatal.</p>
<p class="indent">The population matrix is called <code>world</code>, and the length of its side is stored in <code>n</code>. Don’t take the matrix geometry too literally. It does not assume that people stand in one spot while the disease runs its course. The matrix <code>world</code> represents a network of contact rather than a spatial arrangement.</p>
<p class="indent">After importing some libraries that you have seen before and including a file with the plotting function, which we’ll get to later, the <code>pandemic()</code> function, which does the actual calculation, is defined. This function gets two keyword arguments: <code>seeding</code> should be either <code>:normal</code> or <code>:center</code>. In the former case, infection is seeded randomly, according to <code>initial["infected"]</code>; but if <code>seeding</code> is set to <code>:center</code>, a single infected individual is placed at the center of the world.</p>
<p class="indent">The second keyword, <code>plotmode</code>, controls whether daily plots are created, and if so, whether they are displayed or saved to files. At the end of the calculation, the <code>finish()</code> function is called, which saves a plot of the final state if the <code>plotmode</code> = <code>:last</code>. This function also uses the <code>@save</code> macro to save the <code>world</code> and the infection and death histories to a <em class="calibre11">.jld</em> file (introduced in <a href="ch09.xhtml" class="calibre10">Chapter 9</a>).</p>
<p class="indent">At every iteration, the program has to decide, for each <code>ok</code> person, whether to change that person to the <code>infected</code> state. This is determined randomly, based on the probability of infection by each infected neighbor each day, given in <code>transition["infected"]</code>, and on the number of infected neighbors.</p>
<p class="indent">But, we need to be careful here. The probability of infection with two infected neighbors is not twice the probability of infection with only a single sick neighbor. We need to subtract the probability of becoming infected by both neighbors. We won’t provide a full treatment of the combination of events in probability theory here, but you likely can easily see why we can’t simply add the probabilities.</p>
<p class="indent">Imagine you are flipping two coins and want to find the probability of getting at least one head. You know that the probability of a head with either coin alone is 1/2. If you add those, you get a probability of 1. But that can’t be right, because it would mean a head <em class="calibre11">must</em> appear, and you know there’s a good chance you’ll get two tails. The correct calculation includes subtracting the probability of <em class="calibre11">two</em> heads: 1/2 + 1/2 <em class="calibre11">–</em> 1/4 = 3/4. You will get at least one head three-fourths of the time in the long run. At this point, you <span epub:type="pagebreak" id="page_317"/>are in a good position to write a little Julia program to verify this, if you have any doubts.</p>
<p class="indent">The coin problem corresponds exactly to the case where you are in contact with two infected people and the probability of infection = 1/2. On the grid, however, each person can have up to eight neighbors. It’s a bit more complicated than the case of two neighbors, but the idea is the same. For each new neighbor, you have to add the probability of infection by that neighbor, but subtract all the combinations it can make with the other neighbors. The word <em class="calibre11">combinations</em> suggests that we might have to reach for a binomial coefficient, and indeed we do. The formula for the total probability of infection by <em class="calibre11">n</em> neighbors, if the probability of infection by a single neighbor is <em class="calibre11">p</em>, is:</p>
<div class="image"><img alt="Image" src="../images/317math.jpg" class="calibre6"/></div>
<p class="indent">See “Further Reading” on <a href="ch10.xhtml#fur10" class="calibre10">page 359</a> for more about this formula and related matters. This probability is pre-calculated for all possible numbers of neighbors, <code>1:8</code>, and the results are stored in the <code>tpi</code> <span class="ent">➋</span> array.</p>
<p class="indent">It is necessary, before each iteration’s calculations begin, to make a copy of the <code>world</code> array, which is called <code>next</code> in the program <span class="ent">➌</span>. We update the cells in <code>next</code>, and then copy it back into <code>world</code>. If <code>world</code> is updated in place, cells will be transitioned based on the partially updated information in neighbor cells, which would be inconsistent. A <code>copy</code> is required, as we’ve encountered in previous chapters, because a simple <code>next = world</code> would create a second reference to the array rather than an actual copy.</p>
<p class="indent">An array <code>aoi</code> is initialized to 0s <span class="ent">➍</span>; it will record the <code>day</code> on which each person becomes infected, so that the survival probability can be applied at the appropriate time.</p>
<p class="indent">The subsequent loops over persons within the loop over days, given all the foregoing, should be self explanatory. After the sweep of the matrix, we <code>push!()</code> <span class="ent">➎</span> new values for the current total number of infected and dead people onto the vectors <code>noi</code> and <code>nod</code>, respectively. Julia’s neat and succinct syntax calculates these totals using a sum over a binary array.</p>
<p class="indent">Here, and in the previous loops over the <code>world</code>, the program treats only elements in <code>2:n-1</code> rather than the entire array, to implement the boundary condition. In keeping one row or column of cells on the boundaries “frozen,” the updating logic is simplified, as the expression, for example, for calculating the number of each person’s infected neighbors is identical for each nonfrozen person.</p>
<p class="indent">As in a physics problem, there are other possibilities for boundary conditions. The people on the edges could be updated based on their reduced numbers of neighbors, but doing so can induce artifacts. Periodic boundary conditions are another possibility, where the neighbor-ness wraps around the matrix to the opposite side. Any choice is to some degree arbitrary.</p>
<p class="indent">The conditional block <span class="ent">➏</span> checks to see whether the calculation has reached a steady state. If it has, there is no point in continuing, and the <span epub:type="pagebreak" id="page_318"/>cleanup operation is called. The final line in the program starts the calculation by calling <code>pandemic()</code>.</p>
<p class="indent">This simple algorithm can produce interesting behavior, and it can be used to explore questions such as the effect of lockdown conformity on the spread of the infection, and how a higher fatality rate can slow the growth of a pandemic.</p>
<p class="indent"><a href="ch10.xhtml#ch10fig3" class="calibre10">Figure 10-3</a> shows the output of a 512×512 simulation with these initial and transition probabilities:</p>
<pre class="calibre13">initial = Dict("infected"=&gt;0.001, "isolated"=&gt;0.5)
transition = Dict("infected"=&gt;0.08, "dead"=&gt;0.25, "dud"=&gt;5)</pre>
<p class="indent">The simulation stops after 1,064 iterations when reaching a steady state. The notation on the figure means that 5.48 percent of the population was protected from infection due to the isolation of others and the effects of mortality interrupting disease transmission.</p>
<div class="image"><img alt="Image" id="ch10fig3" src="../images/ch10fig03.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-3: Steady state reached in a pandemic simulation</em></p>
<p class="indent">See the book’s supplementary website (<a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a>) for a color version of the plot and an animation of a similar simulation. In the printed grayscale version, the darkest shades on the heatmap plot represent dead or infected people, white represents people who remained protected from infection, and the middle tone corresponds to isolated people.</p>
<p class="indent"><a href="ch10.xhtml#ch10lis3" class="calibre10">Listing 10-3</a> shows the simple function that calculates the protected percentage and makes plots as in <a href="ch10.xhtml#ch10fig3" class="calibre10">Figure 10-3</a>.</p>
<pre class="calibre13">using Plots
using Printf
"""Plot a heatmap of the current state of the pandemic with the histories
<span epub:type="pagebreak" id="page_319"/>of the number of infected and dead people; calculate and display the
proportion of people protected from infection."""
function plotworld(world, noi, nod, worldgrad)
    ok::Int32 = 1
    day = length(noi)
    protected = sum(world[2:n-1, 2:n-1] .== ok) / n^2 * 100
 <span class="ent">➊</span> prot = @sprintf("%.2f%% protected", protected)
    p1 = heatmap(1:n, 1:n, world, c=worldgrad, clims=(1, 4), legend=nothing);
    p2 = plot(1:day, noi, label=nothing, yformatter=y -&gt; @sprintf("%.1e", y),
              titlefontsize=10);
    p3 = plot(1:day, nod, label=nothing, annotate=
              (0.7day, 0.1nod[end], text(prot, :blue, 7)), yformatter=
               y -&gt; @sprintf("%.1e", y), titlefontsize=10);
 <span class="ent">➋</span> layout=@layout [a{0.6w} grid(2, 1)];
    return plot(p1, p2, p3, layout=layout,
                title=["" "Number infected." "Number dead."]);
end</pre>
<p class="list" id="ch10lis3"><em class="calibre11">Listing 10-3: Visualizing the pandemic</em></p>
<p class="indent">The <code>plotworld()</code> function uses the <code>@sprintf</code> macro <span class="ent">➊</span>, introduced in “Macros for String Formatting” on <a href="ch06.xhtml#ch06sec1sec11" class="calibre10">page 177</a>, to format the variable <code>protected</code> and the y-axis label for display. After creating three plots and storing them in <code>p1</code>, <code>p2</code>, and <code>p3</code>, the <code>@layout</code> macro, described in “Creating Complex Layouts Using @layout” on <a href="ch04.xhtml#ch04lev1sec28" class="calibre10">page 118</a>, arranges them <span class="ent">➋</span> into a summary display of the simulation.</p>
<h3 class="h2" id="ch10lev6"><strong class="calibre2">Common Statistics Functions</strong></h3>
<p class="noindent">Julia provides functions to calculate all of the common statistical parameters, as well as special plotting functions for statistical visualization of data.</p>
<p class="indent">Some reorganization of the Julia statistics packages is underway, so everything may not be where you might expect it. This section describes where the packages are at the time of writing, but, when you try things out, you may discover that a function or two have moved.</p>
<p class="indent">If you are analyzing data of any kind, you will make heavy use of at least some of the functions described in this section, most of which are in the <code>Statistics</code> package, which is part of the standard Julia library. In the remainder of this chapter, I will assume you’ve imported the package with the <code>using Statistics</code> command.</p>
<p class="indent">The package provides the basic functions that summarize datasets with statistical parameters. For the <em class="calibre11">mean</em>, or arithmetic average, use <code>mean(</code><span class="codeitalic1">data</span><code>)</code>, where, here and below, <span class="codeitalic1">data</span> is some vector of observations.</p>
<p class="indent">For the <em class="calibre11">median</em>, which is the middle value in the data, use <code>median(</code><span class="codeitalic1">data</span><code>)</code>. If there are an even number of data points, none of them can be the middle value. In this case, <code>median()</code> returns the mean of the two middle values:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">median([1, 2, 3])</span>
2.0

<span epub:type="pagebreak" id="page_320"/>julia&gt; <span class="codestrong">median([1, 2, 3, 4])</span>
2.5</pre>
<p class="indent">At the time of writing, <code>Statistics</code> does not contain a <em class="calibre11">mode</em> function. The mode is the most common value, or the maximum of a continuous distribution, if it exists. From this idea come the terms <em class="calibre11">bimodal</em> and <em class="calibre11">multimodal</em> to describe distributions with more than one local maximum. The height distribution in <a href="ch10.xhtml#ch10fig4" class="calibre10">Figure 10-4</a> is an example of a bimodal distribution.</p>
<p class="indent">If you need a mode function, you can import it from another package called <code>StatsBase</code>, which you will need to <code>add</code>. <code>StatsBase</code> contains some other less commonly used statistical functions that are not in the standard <code>Statistics</code> package, but you may want to import only the ones you plan to use. If you just need to add a mode function to your toolbox, you can enter <code>import</code> <code>StatsBase.mode</code>.</p>
<p class="indent">Here are a few examples showing how the <code>mode()</code> function behaves:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">mode([1, 3, 2, 9, 9])</span>
9

julia&gt; <span class="codestrong">mode([1, 3, 2, 9, 9, 4, 4])</span>
9

julia&gt; <span class="codestrong">mode([1, 3, 2, 9]</span>)
1</pre>
<p class="indent">If there is more than one mode, the function returns the first one. Consequently, if each value appears only once, they are all modes, so the function returns the first value.</p>
<p class="indent">The standard <code>Statistics</code> package contains most of the other basic statistical functions, including the following:</p>
<div class="bqparan">
<p class="noindentin"><span class="codestrong1">std</span>  Standard deviation</p>
<p class="noindentin"><span class="codestrong1">stdm</span>  Standard deviation with specified mean</p>
<p class="noindentin"><span class="codestrong1">var</span>  Variance</p>
<p class="noindentin"><span class="codestrong1">varm</span>  Variance with specified mean</p>
<p class="noindentin"><span class="codestrong1">cor</span>  Pearson correlation</p>
<p class="noindentin"><span class="codestrong1">cov</span>  Covariance</p>
<p class="noindentin"><span class="codestrong1">middle</span>  (max + min) / 2</p>
<p class="noindentin"><span class="codestrong1">quantile</span>  Quantile</p>
</div>
<p class="indent">These commands work on vectors or pairs of vectors of data in the way you would expect. In addition, the <code>cor()</code> function will accept a matrix and return a correlation matrix, and the <code>cov()</code> function can work similarly.</p>
<p class="indent">The <code>mean()</code> function takes an optional first argument that can be a unary operator or a function of one numeric variable. The function then maps the <span epub:type="pagebreak" id="page_321"/>operator or function over the data vector before calculating the mean. This can be convenient if you need to scale or otherwise process the data, but, for the case of a simple vector, it gives the same result as broadcasting the function over the array:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">mean([1, 2, 3])</span>
2.0

julia&gt; <span class="codestrong">mean(x -&gt; 2x, [1, 2, 3])</span>
4.0

julia&gt; <span class="codestrong">mean(2 .* [1, 2, 3])</span>
4.0</pre>
<p class="indent">There are two versions of the standard deviation and the variance used in statistics. The formula the <code>var()</code> function uses by default is</p>
<div class="image"><img alt="Image" src="../images/321math.jpg" class="calibre6"/></div>
<p class="noindent">where <em class="calibre11">μ</em> is the mean, the <em class="calibre11">x</em><sub class="calibre24"><em class="calibre11">n</em></sub> values are individual data points, <em class="calibre11">N</em> is the total number of data points, and <em class="calibre11">σ</em><sup class="calibre23">2</sup> is the <em class="calibre11">sample variance</em>, or the variance with Bessel’s correction applied. The standard deviation <code>std()</code> is just the positive square root of this.</p>
<p class="indent">In order to calculate the <em class="calibre11">population variance</em> and <em class="calibre11">population standard deviation</em>, supply the keyword argument <code>corrected</code> with a value of <code>false</code> to either of these functions. This will replace the 1/(<em class="calibre11">N –</em> 1) term in the formula with 1/<em class="calibre11">N</em>. Explaining the origin of the correction would take us too far into the arcana of statistical theory, but for most purposes, the defaults are what you want, and it makes little difference for reasonably large <em class="calibre11">N</em> in any case.</p>
<p class="indent">In either incarnation, the standard deviation is a measure of the average distance from the mean of a set of observations or of a theoretical distribution. It tells us how “spread out” the distribution is.</p>
<h3 class="h2" id="ch10lev7"><strong class="calibre2">Distributions</strong></h3>
<p class="noindent">We’ve looked at several examples of how we can do a lot with simple, uniformly distributed random numbers. However, not every random occurrence is uniformly distributed. Most things in nature display other types of distributions.</p>
<p class="indent">Consider the heights of adults in a particular city. Obviously, you don’t expect that the probability of finding a 7-foot-tall adult is the same as finding one with closer to average height: heights are not uniformly distributed. If you make a graph, dividing the horizontal axis into height ranges covering, say, intervals of 2 inches, and collect the heights of a sample of residents, you can plot how many heights fall into each interval. After collecting a large number of measurements, this plot will start to look like a smooth curve, something like <a href="ch10.xhtml#ch10fig4" class="calibre10">Figure 10-4</a>. It has two peaks, because the average height of <span epub:type="pagebreak" id="page_322"/>men is a little higher than women, and it shows that there are more people close to the average than very tall or very short.</p>
<div class="image"><img alt="Image" id="ch10fig4" src="../images/ch10fig04.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-4: Possible histogram of adult heights</em></p>
<p class="indent">This type of graph is called a <em class="calibre11">histogram</em>; it is one way to represent a <em class="calibre11">distribution</em>. Probability distributions are the mathematical objects at the center of statistics, just as a probability forms, naturally, the central idea of probability theory. A distribution simply tells you how much of your data, or what proportion of your data, falls within different ranges. As a description of actual data it’s called an <em class="calibre11">empirical distribution</em>, whereas if it comes from a model it’s a <em class="calibre11">theoretical distribution</em>.</p>
<p class="indent">You can think of the discipline of statistics this way: probabilities tell us how likely something is to happen, and the mathematics of probability theory lets us elaborate this, telling us the likelihood of combinations of events and answering related questions. Statistics is the reverse: it starts with observations, and lets us systematically infer the probabilities that led to those observations. With these probabilities, we can make predictions about future observations.</p>
<p class="indent">Julia provides several packages and a great number of functions for helping out with statistics, including functions for statistical graphing. To produce a histogram like the one shown in <a href="ch10.xhtml#ch10fig4" class="calibre10">Figure 10-4</a>, simply call (after <code>using Plots</code>) <code>histogram(data, bins = 100)</code>. The <code>data</code> in this call is the actual series of observations; the <code>bins</code> tells the routine to use that number of intervals to construct the histogram. For each interval, it will count the number of observations in <code>data</code> and draw the rectangle at the appropriate height. The area of each rectangle represents the number of observations in the horizontal axis interval that it covers. Beware that the same dataset may produce very different plots when choosing different numbers of bins; some choices <span epub:type="pagebreak" id="page_323"/>will better reflect the underlying distribution than others. If you leave out the <code>bins</code> argument, the <code>histogram()</code> routine will attempt to choose the “best” value, using a formula from statistical theory that is designed to best represent the data. This formula does not always work perfectly, so the careful scientist or statistician will always be aware of the nature of the data being plotted, and intervene manually if necessary.</p>
<h4 class="h3" id="ch10lev1sec3"><strong class="calibre2"><em class="calibre4">The Normal Distribution</em></strong></h4>
<p class="noindent">Consider the <code>rand()</code> function described earlier in this chapter. Since it generates a floating-point number that is equally likely to be anywhere in the interval from 0 to 1, the mean value of the numbers it returns should be 0.5. The number is just as likely to be greater than 0.5 as to be smaller than that midpoint.</p>
<p class="indent">This means if you call <code>rand()</code> many times, and calculate the mean of the results, you should get something fairly close to 0.5: <code>mean(rand(1000))</code> should be approximately 0.5. I did it just now and got 0.49869515604579906. Intuitively, you may expect if you use a number smaller than 1,000, the mean is more likely to be farther from 0.5, and that is correct.</p>
<p class="indent">But even using 1,000 numbers, the mean will rarely be exactly 0.5. Since (unless you reset the seed) you will get a different set of random numbers each time, the mean will be different each time, as well. The numbers themselves, as you know, are uniformly distributed in [0, 1). If you call <code>mean(rand(1000))</code> many times, how will the <em class="calibre11">means</em> be distributed?</p>
<p class="indent">You know they can’t be distributed uniformly, because they are more likely to be near 0.5 than far from it. But what exactly is the distribution of the means?</p>
<p class="indent">Let’s write a little program to find out. Even those who have studied statistics and know what to expect may find the numerical experiment in <a href="ch10.xhtml#ch10lis4" class="calibre10">Listing 10-4</a> interesting.</p>
<pre class="calibre13">using Plots
using Statistics
N = 10000
averages = zeros(N)
for i in 1:N
    averages[i] = mean(rand(1000))
end
histogram(averages, label="Empirical")</pre>
<p class="list" id="ch10lis4"><em class="calibre11">Listing 10-4: Exploring the distribution of the mean</em></p>
<p class="indent">The program is a straightforward calculation of the <code>N</code> means of 1,000 random numbers. To see how these means are distributed, we turn to the <code>histogram()</code> plotting function introduced earlier in the chapter. The purpose of this function is exactly to display distributions. The <code>"Empirical"</code> label indicates that the histogram is the result of a numerical experiment. <a href="ch10.xhtml#ch10fig5" class="calibre10">Figure 10-5</a> shows the result.</p>
<div class="image"><img alt="Image" id="ch10fig5" src="../images/ch10fig05.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-5: Distribution of the mean of uniform random numbers</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_324"/>Obviously, the distribution of the means is not uniform. As we expect, it shows that means closer to 0.5 are more frequent.</p>
<p class="indent">In fact, from a central result in probability theory, we can predict the precise mathematical form of this distribution. It should be</p>
<div class="image"><img alt="Image" src="../images/324math.jpg" class="calibre6"/></div>
<p class="noindent">where <em class="calibre11">x</em> is the random variable whose distribution we are describing, <em class="calibre11">σ</em> is the standard deviation, and <em class="calibre11">μ</em> is the mean.</p>
<p class="indent">This is the equation for the famous <em class="calibre11">normal distribution</em>, also called the <em class="calibre11">Gaussian</em>. Does it describe the empirical distribution from the program? We don’t need to translate the equation into code to find out. This distribution is so crucial, it’s included in the second most important Julia package for statistical work, <code>Distributions</code>.</p>
<p class="indent">Once you import this package into your namespace, the function <code>Normal</code>(μ, σ) creates a normal distribution with a mean of μ and a standard deviation of σ. You can interact with the distribution by sampling from it using the <code>rand()</code> function. For example, if you create a normal distribution with a mean of 10 and a standard deviation of 2 with <code>d = Normal(10, 2)</code>, you can draw 10 samples from it with <code>rand(d, 10)</code>. Calling <code>rand()</code> without supplying an explicit distribution, as we’ve been doing up to now, uses the uniform distribution by default.</p>
<p class="indent">One way to see if the empirical distribution shown is predicted by the normal distribution is to take a healthy sample from the normal distribution and plot its histogram with the previous one. To make the plot easier to see, instead of trying to plot two <code>histogram()</code> plots on the same graph, we can <span epub:type="pagebreak" id="page_325"/>plot the second one using a different type of histogram display by supplying the <code>:scatterhist</code> series type to the normal <code>plot()</code> command. Adding the four additional lines shown in <a href="ch10.xhtml#ch10lis5" class="calibre10">Listing 10-5</a> to the program in <a href="ch10.xhtml#ch10lis4" class="calibre10">Listing 10-4</a> makes the graphical comparison that we want.</p>
<pre class="calibre13">using Distributions
σ = std(averages)
nd = Normal(0.5, σ)
plot!(rand(nd, 10000), seriestype=:scatterhist, label="Normal sample")</pre>
<p class="list" id="ch10lis5"><em class="calibre11">Listing 10-5: Sampling from the normal distribution</em></p>
<p class="indent"><a href="ch10.xhtml#ch10fig6" class="calibre10">Figure 10-6</a> shows that the two distributions are close, as theory predicts.</p>
<div class="image"><img alt="Image" id="ch10fig6" src="../images/ch10fig06.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-6: Comparing the empirical and theoretical distributions</em></p>
<p class="indent">Note that in order to compare two histograms directly, they must have the same bin width, or both be normalized. In these examples, I allow the routines to compute the bin width automatically, knowing that for similar distributions the widths would be the same.</p>
<p class="indent">The <code>Distributions</code> package provides many probability distributions in addition to the normal distribution. It also includes many functions for using these distributions, along with other statistical tools.</p>
<h4 class="h3" id="ch10lev1sec4"><strong class="calibre2"><em class="calibre4">Probability Density Functions</em></strong></h4>
<p class="noindent">One of those tools is <code>pdf()</code>, which stands for <em class="calibre11">probability density function</em>. This function describes the distribution in the following sense: if you integrate the <span epub:type="pagebreak" id="page_326"/>probability density function over a certain interval, the result is the probability that an observation lies within that interval. In other words, the probability that an observation lies between <em class="calibre11">a</em> and <em class="calibre11">b</em> is the area under the distribution curve between <em class="calibre11">a</em> and <em class="calibre11">b</em>.</p>
<p class="indent">Usually, when referring to the graph of a distribution, we mean the graph of its probability density function. The integral over the entire distribution must exist and be equal to 1, because it is certain that any observation must have some value within the range of possible values.</p>
<p class="indent">All of the <code>histogram()</code> plotting types have an optional <code>normalize</code> keyword argument that can be set to <code>true</code> to make the histogram plot indicate probabilities rather than raw counts—for example:</p>
<pre class="calibre13">   histogram(averages, label="Empirical", normalize=true)
   plot!(rand(nd, 10000), seriestype=:scatterhist, label="Normal sample",
         normalize=true)
<span class="ent">➊</span> plot!(0.46:0.001:0.54, pdf.(nd, 0.46:0.001:0.54), lw=5, label="Normal PDF")</pre>
<p class="indent">Those three lines repeat the plots of the two histograms just plotted in <a href="ch10.xhtml#ch10fig6" class="calibre10">Figure 10-6</a>, but normalized. Now the areas of the histogram rectangles, shown in <a href="ch10.xhtml#ch10fig7" class="calibre10">Figure 10-7</a>, are probabilities rather than raw counts. The new curve is a plot <span class="ent">➊</span> of the probability density function of the normal distribution with the same mean and standard deviation as the sample. It is a graph of the equation for <em class="calibre11">ϕ</em>, displayed after <a href="ch10.xhtml#ch10fig5" class="calibre10">Figure 10-5</a>. <a href="ch10.xhtml#ch10fig7" class="calibre10">Figure 10-7</a> shows how accurately it predicts the results of the numerical experiment in <a href="ch10.xhtml#ch10lis4" class="calibre10">Listing 10-4</a>.</p>
<div class="image"><img alt="Image" id="ch10fig7" src="../images/ch10fig07.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-7: Adding the probability density function</em></p>
<p class="indent">Because of the normal distribution’s importance, Julia provides another function, similar to <code>rand()</code>, that returns normally distributed random numbers rather than uniformly distributed ones. The <code>randn()</code> function is part <span epub:type="pagebreak" id="page_327"/>of <code>Base</code>, so you don’t need an <code>import</code>. It returns single numbers or arrays, normally distributed with a mean of 0 and a standard deviation of 1.</p>
<p class="indent">Let’s repeat the plot from <a href="ch10.xhtml#ch10lis1" class="calibre10">Listing 10-1</a> using <code>randn()</code>:</p>
<pre class="calibre13">using Plots
ra = randn(100000)
scatter(ra, markersize=1, label=nothing)</pre>
<p class="indent">The only difference is in using <code>randn()</code> instead of <code>rand()</code>. <a href="ch10.xhtml#ch10fig8" class="calibre10">Figure 10-8</a> shows the result. As in <a href="ch10.xhtml#ch10fig1" class="calibre10">Figure 10-1</a>, each of the 10<sup class="calibre23">5</sup> numbers is represented by a tiny dot, but now the dots are not uniformly distributed.</p>
<div class="image"><img alt="Image" id="ch10fig8" src="../images/ch10fig08.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-8: Normally distributed random floats</em></p>
<p class="indent">Instead, they are crowded around the value 0 on the vertical axis, with their density getting thinner the farther they are from 0, the mean of their distribution.</p>
<h3 class="h2" id="ch10lev8"><strong class="calibre2">Dealing with Data</strong></h3>
<p class="noindent">So far, all the “data” in this chapter has been either made up or the result of collecting results from numerical pseudorandom processes. If you are using Julia for statistical analysis, the odds are good that you have some actual, real-life data to analyze.</p>
<p class="indent">In this section, we’ll explore the most important methods in Julia for dealing with real data. We’ll look at a data type that comes in handy when manipulating data in the real world, how to read data from the most common types of datafiles, how to use dataframes to view and analyze this data, <span epub:type="pagebreak" id="page_328"/>and how to take advantage of Julia’s statistical packages to understand and visualize numerical information.</p>
<h4 class="h3" id="ch10lev1sec5"><strong class="calibre2"><em class="calibre4">Missing Values</em></strong></h4>
<p class="noindent">There is an unusual data type I didn’t mention in <a href="ch08.xhtml" class="calibre10">Chapter 8</a> because I was saving it for this chapter. It’s a singleton type called <code>Missing</code>, and it is used to represent missing values.</p>
<p class="indent">Imagine you have a sensor that is supposed to record the temperature inside a tank of water at regular intervals of time. Unfortunately, every now and then it fails to record a measurement. Those failures are recorded as 0s, but that number is far outside the range of possible measurements, so these failures can’t be mistaken for actual temperatures. At the end of the experiment you have two vectors, or perhaps two columns of a matrix, one for the times of the measurements and the other for the temperatures. When analyzing this data, you don’t want the false zero temperatures to be included in the analysis because that would distort your calculations. You want a better solution than simply deleting the failed readings because that would create a false record of what actually happened in the experiment, and, to keep the timing and temperature vectors the same length, perhaps for plotting the results, you will have to delete the corresponding entries from the timing vector, leading to a time sequence containing gaps.</p>
<p class="indent">The <code>Missing</code> type provides one solution to this set of problems and others—for example, in data science, where the concept of missing values arises. It has some properties that may seem peculiar, illustrated in <a href="ch10.xhtml#ch10lis6" class="calibre10">Listing 10-6</a>, which is a REPL session exploring arithmetic on the <code>Missing</code> type.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m = missing</span>
missing

julia&gt; <span class="codestrong">3m</span>
missing

julia&gt; <span class="codestrong">3 + m</span>
missing

julia&gt; <span class="codestrong">missing/3</span>
missing

julia&gt; <span class="codestrong">missing/0</span>
missing

julia&gt; <span class="codestrong">missing + missing</span>
missing

julia&gt; <span class="codestrong">typeof(m)</span>
Missing</pre>
<p class="list" id="ch10lis6"><em class="calibre11">Listing 10-6: Arithmetic properties of</em> <span class="codeitalic">missing</span> <em class="calibre11">values</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_329"/>We see from <a href="ch10.xhtml#ch10lis6" class="calibre10">Listing 10-6</a> that arithmetic on <code>missing</code> values leads to a <code>missing</code> result, even when dividing by 0.</p>
<p class="indent">Usually, <code>missing</code> values are not floating around by themselves, but are found as part of a collection of data. <a href="ch10.xhtml#ch10lis7" class="calibre10">Listing 10-7</a> is a little function that creates an array, replaces some of its values with <code>missing</code> values, and plots the result.</p>
<pre class="calibre13">using Plots
function plotmissing()
    a::Vector{Union{Missing, Float64}} = sin.(0:0.03:2π) .+ rand(210)/4
    a[49:54] .= missing
    plot(a, legend=nothing, linewidth=3)
end</pre>
<p class="list" id="ch10lis7"><em class="calibre11">Listing 10-7: Creating some missing data for plotting</em></p>
<p class="indent">We need to declare the array to be able to accept <code>missing</code> values as well as floating-point numbers. If we omit this declaration, the compiler will complain when we try to assign <code>missing</code> to any location in the array because it will have defined it as <code>Vector{Float64}</code>.</p>
<p class="indent">The plot in <a href="ch10.xhtml#ch10fig9" class="calibre10">Figure 10-9</a> shows that <code>Plots</code> knows how to handle missing data.</p>
<div class="image"><img alt="Image" id="ch10fig9" src="../images/ch10fig09.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-9: Plotting with missing data</em></p>
<p class="indent">By default, it leaves a gap where there are <code>missing</code> values.</p>
<h5 class="h4" id="ch10sec1sec1"><strong class="calibre2">Functions for Handling Missing Values</strong></h5>
<p class="noindent">Julia provides several functions to do convenient things with <code>missing</code> values. To illustrate what these do, suppose we have an array, <code>a</code>, with some numbers and some <code>missing</code> elements:</p>
<pre class="calibre13">a = [1, missing, 2, 3, missing, 4]</pre>
<p class="indent"><span epub:type="pagebreak" id="page_330"/>If you want the sum of the <em class="calibre11">numbers</em> in the array, you might try <code>sum(a)</code>, but if you refer to <a href="ch10.xhtml#ch10lis6" class="calibre10">Listing 10-6</a>, you will see that, since adding a number to a <code>missing</code> value yields <code>missing</code>, the end result of the <code>sum()</code> operation will just be <code>missing</code>. Here, Julia’s <code>skipmissing()</code> function, which does as its name suggests, comes to the rescue:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">sum(skipmissing(a))</span>
10</pre>
<p class="indent">The <code>skipmissing()</code> function, which is built into <code>Base</code>, returns an iterator:</p>
<pre class="calibre13">for i in skipmissing(a)
    println(i)
end</pre>
<p class="indent">If you run that loop, you’ll see this:</p>
<pre class="calibre13">1
2
3
4</pre>
<p class="indent">If you need to make a new array with the <code>missing</code> values omitted, use <code>collect(skipmissing(a))</code>.</p>
<p class="indent">If, instead, you want to make an array with a particular value substituted for the <code>missing</code> values in the original array, the function for that is <code>coalesce()</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">coalesce.(a, NaN)</span>
6-element Vector{Real}:
   1
 NaN
   2
   3
 NaN
   4</pre>
<p class="indent">Notice how we need to use the dot operator to apply <code>coalesce()</code> to all the elements of the vector, and how the type of the returned array is no longer a <code>Union</code> with <code>missing</code>.</p>
<p class="indent">If you have a program that analyzes data, and want to generalize it so it can handle data collections with <code>missing</code> elements, the <code>skipmissing()</code> function makes that task relatively straightforward. You may only have to replace occurrences of your data arrays with <code>skipmissing()</code> acting on those arrays.</p>
<p class="indent">You may, however, prefer an approach that does not litter your code with a multitude of calls to <code>skipmissing()</code>. You can take advantage of Julia’s multiple dispatch to define your own methods for <code>sum()</code>, and for any other functions that operate on your data arrays, to handle <code>missing</code> elements however you like. If, whenever you <code>sum()</code> an array of data (and keeping in mind the warning about type piracy from <a href="ch08.xhtml" class="calibre10">Chapter 8</a>), you know that you will <span epub:type="pagebreak" id="page_331"/>always want the <code>missing</code> values ignored and the numerical values added together, you can define a method this way:</p>
<pre class="calibre13">import Base.sum
function sum(a::AbstractArray{Union{Missing, Int64}})
    return sum(skipmissing(a))
end</pre>
<p class="indent">That example works for integers, but it’s easily modified for other numerical types.</p>
<p class="indent">The function <code>ismissing()</code> returns <code>true</code> if its argument is <code>missing</code> and <code>false</code> otherwise. It’s often more expressive than comparing against the <code>Missing</code> type in data expressions.</p>
<p class="indent">The <code>Missings</code> package provides a few more convenience functions for dealing with this data type. This package is not in the standard library, so you’ll have to <code>add</code> and <code>import</code> it.</p>
<p class="indent">Anyone making use of <code>missing</code> values is likely to appreciate two functions from this package. As shown in <a href="ch10.xhtml#ch10lis7" class="calibre10">Listing 10-7</a>, it’s a little cumbersome to define a vector that can hold both the needed numerical type and optional values—and, more important, you may have a numerical array that you need to convert to a type that will allow you to add <code>missing</code> values to it. The following little REPL session shows how to use the <code>allowmissing()</code> function from the <code>Missings</code> package, which solves both of these problems:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">import Missings</span>
julia&gt; <span class="codestrong">a = rand(4)</span>
julia&gt; <span class="codestrong">a = Missings.allowmissing(a)</span>
julia&gt; <span class="codestrong">a[3] = missing;</span>
julia&gt; <span class="codestrong">a</span>
4-element Vector{Union{Missing, Float64}}:
 0.6225362617934931
 0.4473340385496267
  missing
 0.5062746637386624</pre>
<p class="indent">You can convert a <code>Vector{Union{Missing, Float64}}</code> type back into a pure floating-point numerical type using <code>Missings.disallowmissing()</code>, but first you must eliminate any <code>missing</code> values from it.</p>
<h5 class="h4" id="ch10sec1sec2"><strong class="calibre2">Logic with Missing Values</strong></h5>
<p class="noindent">Before leaving the topic of Julia’s <code>Missing</code> data type, let’s look at how it behaves in the context of logic expressions. We typically think of operations on logical values as following a two-valued (Boolean) logic, where the only possible values are <code>true</code> and <code>false</code>, a calculus that is reviewed in “Logic” on <a href="ch02.xhtml#ch02lev1sec3" class="calibre10">page 31</a>. The <code>missing</code> value expands the world of Boolean logic to encompass a third truth state, which is neither <code>true</code> nor <code>false</code>, but indeterminate. In Julia, the <code>missing</code> type, along with bitwise AND (<code>&amp;</code>), bitwise OR (<code>|</code>), bitwise exclusive OR (<code>xor</code>), equality (<code>==</code>), and negation (<code>!</code>), form a system of three-valued logic.</p>
<p class="indent"><span epub:type="pagebreak" id="page_332"/>The results of a logical expression thus can be <code>true</code>, <code>false</code>, or <code>missing</code>. The following list shows how the system works, and after some thought, the entries should make intuitive sense. For example, the result of <code>true | missing</code> is <code>true</code> because the result will be <code>true</code> <em class="calibre11">no matter the truth value of the second operand</em>. And the result of <code>true &amp; missing</code> must be <code>missing</code>, because it will <em class="calibre11">depend</em> on the truth value of the second operand, which is undetermined.</p>
<div class="bqparan">
<p class="noindentin"><span class="codestrong1">true | missing</span>   <code>true</code></p>
<p class="noindentin"><span class="codestrong1">true &amp; missing</span>   <code>true</code></p>
<p class="noindentin"><span class="codestrong1">false | missing</span>   <code>missing</code></p>
<p class="noindentin"><span class="codestrong1">false &amp; missing</span>   <code>false</code></p>
<p class="noindentin"><span class="codestrong1">xor(true, missing)</span>   <code>missing</code></p>
<p class="noindentin"><span class="codestrong1">xor(false, missing)</span>   <code>missing</code></p>
<p class="noindentin"><span class="codestrong1">!missing</span>   <code>missing</code></p>
<p class="noindentin"><span class="codestrong1">missing == missing</span>   <code>missing</code></p>
<p class="noindentin"><span class="codestrong1">missing === missing</span>   <code>true</code></p>
</div>
<p class="indent">Since the truth value of <code>missing == missing</code> depends on the values of the missing items, it is itself <code>missing</code>. However, since <code>missing</code> is a singleton type, all instances of it are the same object; hence <code>missing === missing</code> must be <code>true</code>.</p>
<h4 class="h3" id="ch10lev1sec6"><strong class="calibre2"><em class="calibre4">CSV Files</em></strong></h4>
<p class="noindent">Data that’s of moderate size often comes in the form of a comma-separated value (CSV) file. These are text files with items delimited by commas, and optionally with descriptive headers. They have the considerable advantages of being human readable and amenable to processing with all of the Linux command line tools. But they have the disadvantages of taking up more space than necessary, being less efficient than binary representations, and possibly not faithfully representing the original values after conversion into text. For those reasons, this format is probably not the best choice for storing, say, the output of a physics simulation. However, CSV is perhaps the most common format for distributing what are commonly called “statistics,” such as demographic data or the pandemic data that we’ll explore later.</p>
<p class="indent">You may be tempted to write your own programs for reading CSV files, parsing them, and turning them into some Julia data structure. If you’ve come this far in the book, you will certainly be able to do so. However, it would be wise to resist the temptation, except as an exercise.</p>
<p class="indent">For real work, it’s a better idea to use the <code>CSV</code> package, which we’ll need to <code>add</code> in the package manager. This package can handle any delimiter, in addition to commas: the popular tab-separated file format as well as any custom format you may come across. It’s even able, in many cases, to figure out by itself what delimiter the file is using. This delimiter need not be limited to a single character; it can be a string as well. The <code>CSV</code> package can deal with comments mixed in with the data, column headers, and anything else <span epub:type="pagebreak" id="page_333"/>you’re likely to encounter. It can read files from disk or, given a URL, can fetch them over the internet. It can handle dates in any format and transform labels into more code-friendly forms. Perhaps most importantly, it transforms the textual information into a Julia data type that can be further transformed into one of several different table-like data formats designed to be easily manipulated for statistical work.</p>
<h4 class="h3" id="ch10lev1sec7"><strong class="calibre2"><em class="calibre4">Dataframes</em></strong></h4>
<p class="noindent">The most important of these table-like data structures is <code>dataframe</code>, provided by the <code>DataFrames</code> package, which also needs to be <code>add</code>ed. Indeed, as the data structure returned by CSV after it reads a file is not the most convenient for exploration, the usual strategy is to immediately transform it into a <code>dataframe</code>.</p>
<p class="indent">A <code>dataframe</code> is a table of values, like a matrix, but with extra functionality designed for data exploration. Along with the <code>dataframe</code> data type, the <code>DataFrames</code> package exports several functions for manipulating it. In addition, many Julia functions with which you are already familiar have methods that extend their functionality to the <code>dataframe</code>.</p>
<p class="indent">It is most useful to think of a <code>dataframe</code> as a set of columns stuck together. Each column has a unique name. A column can be referred to with its integer index, with its name as a string, or with its name as a symbol. When you are examining, plotting, or manipulating data, you are doing these things to <code>dataframe</code> columns.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">We treat dataframes as sets of columns for data analysis and visualization. However, most Julia functions that operate on collections treat dataframes as collections of rows. See “Further Reading” on <a href="ch10.xhtml#fur10" class="calibre10">page 359</a> for an illuminating article on this subject.</em></p>
</div>
<p class="indent">Let’s consider an example using real-life data that comes in a typically messy form. Our journey through this data will make the earlier discussion of dataframes concrete and introduce the important functions for wrangling data from sources in the wild.</p>
<p class="indent">Let’s look at some data from the COVID-19 Data Repository maintained by the Center for Systems Science and Engineering (CSSE) at Johns Hopkins University (<a href="https://github.com/CSSEGISandData/COVID-19" class="calibre10"><em class="calibre11">https://github.com/CSSEGISandData/COVID-19</em></a>). This data comes in the form of CSV files, using an actual comma as a delimiter. The first line contains headings to describe each data column, but the format of those headings will make subsequent manipulation in Julia inconvenient. The first problem is that some of the headers are names of countries or territories that contain spaces. The second is that some of the headers are dates, but these are in a format that we need to take into account so that they are parsed correctly.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">The datafile used in the examples here is available in the online resource area under the name</em> time_series_covid19_confirmed_global.csv<em class="calibre11">. The CSSE data grows in size over time, so some of the plots shown in this section may become unwieldy with future versions of the file from Johns Hopkins.</em></p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_334"/>Fortunately, the file reading function in the <code>CSV</code> package is equipped to deal with both of those common issues. <a href="ch10.xhtml#ch10lis8" class="calibre10">Listing 10-8</a> shows the instructions for reading the CSV file and converting it immediately into a <code>dataframe</code>.</p>
<pre class="calibre13">using CSV, DataFrames
covdat = CSV.File("time_series_covid19_confirmed_global.csv";
    normalizenames=true) |&gt; DataFrame</pre>
<p class="list" id="ch10lis8"><em class="calibre11">Listing 10-8: Reading a CSV file</em></p>
<p class="indent">The <code>normalizenames</code> option replaces spaces and other troublesome characters in column names with underscores and performs any other transformations needed to turn header text into legal Julia identifiers. The <code>dateformat</code> keyword argument should be self-explanatory.</p>
<p class="indent">The first argument to <code>CSV.File()</code> is the name of the file on disk, which I previously downloaded and saved. Another option is to pass the URL of the file here. <code>CSV.File()</code> will recognize this and automatically download the data over the internet. The date format is determined by inspecting the file, whose first line, which contains the column headers, looks like this:</p>
<pre class="calibre13">Province/State,Country/Region,Lat,Long,1/22/20,1/23/20,1/24/20,...</pre>
<p class="indent">There are 432 columns. The end of the second command in <a href="ch10.xhtml#ch10lis8" class="calibre10">Listing 10-8</a> converts the <code>CSV.File()</code> object into a <code>DataFrame</code> object, which is stored in the variable <code>covdat</code>. If this is executed in a REPL, Julia will print out a truncated representation of the dataframe. <a href="ch10.xhtml#ch10fig10" class="calibre10">Figure 10-10</a> shows what that looks like. In this particular case, I’ve narrowed the REPL window so it fits better on the page.</p>
<div class="image"><img alt="Image" id="ch10fig10" src="../images/ch10fig10.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-10: Representation of a dataframe in the REPL</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_335"/>The display indicates how much information has been omitted, the names of the visible columns, and the type of data they contain. A question mark after the data type means some values may be <code>missing</code>. Here is a typical use for the <code>missing</code> data type: most of the countries in the files do not have a province listed, but a few do. Missing data is represented in the original CSV file by a number that is . . . missing.</p>
<p class="indent">The fancy display of dataframes in the REPL is accomplished by <code>show()</code>, usually implicitly. A <code>print()</code> of a dataframe spits out the whole thing, without the nice formatting or type information, and is usually not what you want. In addition, <code>show()</code> can create HTML and LaTeX versions, and control other aspects of the dataframe display. Consult the REPL help to learn the details.</p>
<h5 class="h4" id="ch10sec1sec3"><strong class="calibre2">The @df Macro</strong></h5>
<p class="noindent">For the rest of the chapter, we’re going to make extensive use of a macro found in the <code>StatsPlots</code> package called <code>@df</code>. It’s part of <code>StatsPlots</code> because it’s especially effective at making commands for plotting from dataframes more concise, but its use is not limited to <code>plot()</code> commands. From this point on, the following command is assumed:</p>
<pre class="calibre13">using StatsPlots, Statistics</pre>
<p class="indent">The <code>@df</code> macro does what macros do best: it rewrites code so that our programs are easier to write and read. This macro has one job: it replaces symbols in an expression with the columns of the dataframe that appears as its first argument. This simple expression rewriting is enough to make this macro popular because it frees the programmer from having to repeat the name of the dataframe multiple times in an expression. Consider the following example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">@df covdat print((minimum(:_1_1_21), maximum(:_1_1_21), mean(:_1_1_21)))</span>
(0, 20252310, 306902.8576642336)</pre>
<p class="indent">In this expression, the symbol <code>:_1_1_21</code> is converted to <code>covdat._1_1_21</code> each time it appears. The argument of the macro following the name of the dataframe must be a block or a function call, so the above would fail without wrapping the result in the <code>print()</code> function.</p>
<p class="indent">Since <code>Symbols</code> are converted into dataframe columns when using the <code>@df</code> macro, we need some syntax to indicate when a <code>Symbol</code> should be left alone—for example, if there is a conflict between a column name and a symbol used for another purpose. The macro provides the “<code>^()</code>” wrapper to handle these conflicts. If, for example, a column called “topleft” happens to be in your dataframe, you’ll need to use the syntax <code>legend=^(:topleft)</code> in the plotting command to put the legend in the Northwest.</p>
<h5 class="h4" id="ch10sec1sec4"><strong class="calibre2">Indexing and Filtering Dataframes</strong></h5>
<p class="noindent">A dataframe can be indexed and filtered using the same methods that we apply to matrices. However, dataframes come with some extra indexing methods that let us take advantage of their named columns.</p>
<p class="indent"><span epub:type="pagebreak" id="page_336"/>I include in this chapter only the indexing and filtering methods that I think are most likely to be useful in the majority of cases. There are, in addition to everything covered here, several packages that supply macros and functions providing yet more ways to select and transform the information in a dataframe. Their intention is to allow a more streamlined syntax for certain common tasks, and these packages can be convenient. However, most of them are in somewhat of a state of flux. As in most sections in this book, I try to confine myself to methods that have solidified—that you can learn once and use forever.</p>
<p class="indent">Items in a dataframe can be extracted using the familiar forms of integer indexing. Here are a few examples:</p>
<pre class="calibre13"><span class="ent">➊</span> julia&gt; <span class="codestrong">covdat[3, 2]</span>
  "Algeria"

<span class="ent">➋</span> julia&gt; <span class="codestrong">covdat[3:6, 2]</span>
   4-element Vector{String}:
   "Algeria"
   "Andorra"
   "Angola"
   "Antigua and Barbuda"

<span class="ent">➌</span> julia&gt; <span class="codestrong">covdat[1, 2:4]</span>
   DataFrameRow
   Row | Country_Region  Lat       Long
       | String          Float64?  Float64?
  ------------------------------------------
     1 | Afghanistan      33.9391     67.71</pre>
<p class="indent">Notice how the data type of the result depends on how we index the dataframe. If we ask for one element <span class="ent">➊</span>, we get back a single value, in this case a string. If we ask for a range of rows in a single column <span class="ent">➋</span>, we get a <code>Vector</code>. Finally, if we extract data horizontally, by indexing a single row and a range of columns <span class="ent">➌</span>, we get a data type that we haven’t seen before: a <code>DataFrameRow</code>.</p>
<p class="indent">Let’s ask Julia for a range of rows and a range of columns:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">covdat[266:268, 2:4]</span>
3×3 DataFrame
 Row | Country_Region  Lat       Long
     | String          Float64?  Float64?
------------------------------------------
   1 | Uruguay         -32.5228  -55.7658
   2 | Uzbekistan       41.3775   64.5853
   3 | Vanuatu         -15.3767  166.959</pre>
<p class="indent">We get back a smaller dataframe. What else could it be?</p>
<p class="indent"><span epub:type="pagebreak" id="page_337"/>We don’t have to count indices to refer to columns, but can use their names, as in <a href="ch10.xhtml#ch10lis9" class="calibre10">Listing 10-9</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">covdat[272:end, [:Country_Region, :Lat, :Long, :_1_22_21]]</span>
3×4 DataFrame
 Row | Country_Region  Lat       Long      _1_22_21
     | String          Float64?  Float64?  Int64
----------------------------------------------------
   1 | Yemen            15.5527   48.5164      2118
   2 | Zambia          -13.1339   27.8493     43333
   3 | Zimbabwe        -19.0154   29.1549     30523</pre>
<p class="list" id="ch10lis9"><em class="calibre11">Listing 10-9: Selecting columns by name</em></p>
<p class="indent">We use <code>Symbol</code>s to index the dataframe’s columns. For each column title, a <code>Symbol</code> with the same name is created for efficient indexing. We could just as well have used the string versions of the column names in <a href="ch10.xhtml#ch10lis9" class="calibre10">Listing 10-9</a>, but using <code>Symbol</code>s is more efficient. This is one reason for using <code>normalizenames</code> when reading the data: headers containing spaces would not be valid <code>Symbol</code> names, and we would be forced to use the string versions. <a href="ch10.xhtml#ch10lis9" class="calibre10">Listing 10-9</a> shows the last three countries, their latitude and longitude, and the number of COVID cases on January 22, 2021.</p>
<p class="indent">The headings of the columns for latitude and longitude have data types printed with question marks. This means somewhere in this table is a country or a province with one or both of these values missing. To see those countries or provinces, we need to find the <em class="calibre11">row</em> in the table where <code>:Lat</code> or <code>:Long</code> has the value <code>missing</code>. To select rows from a dataframe where one or more columns satisfy some condition, we can use the <code>filter()</code> function (described in “The filter() Operator” on <a href="ch06.xhtml#ch06sec1sec4" class="calibre10">page 163</a>. The <code>DataFrame</code> package extends the <code>filter()</code> function to operate on dataframes by filtering rows and returning a new dataframe. The following line of code filters our COVID dataframe, looking for the rows with missing latitude or longitude:</p>
<pre class="calibre13">filter(r -&gt; (r.Lat === missing) || (r.Long ===  missing), covdat)

1×432 DataFrame
 Row | Province_State          Country_Region  Lat       Long     ...
     | String?                 String          Float64?  Float64? ...
-------------------------------------------------------------------
   1 | Repatriated Travellers  Canada          missing   missing  ...
                                                428 columns omitted</pre>
<p class="indent">The result is a dataframe with a single row, with the curious notation <code>Repatriated Travellers</code> in place of the province.</p>
<p class="indent">Rather than use the <code>filter()</code> function, you can get the same result with bitmask indexing or any other technique that works with normal arrays.</p>
<p class="indent"><span epub:type="pagebreak" id="page_338"/>Notice in the example just shown how we specified the columns for the filter using the column names as bare words. This is yet another form of indexing, which is convenient in filter expressions. We can also use that syntax to select columns from the dataframe, turning them into <code>Vector</code>s:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">covdat.Country_Region</span>
274-element Vector{String}:
 "Afghanistan"
 "Albania"
 "Algeria"
 "Andorra"
 :
 "Yemen"
 "Zambia"
 "Zimbabwe"</pre>
<p class="indent">Since selecting columns provides us with <code>Vector</code>s, we can use this form of indexing for plotting:</p>
<pre class="calibre13">using Plots
plot(covdat.Country_Region, covdat._1_1_21; xrotation=40,
     label="Cases on 1JAN2021", legend=:topleft)</pre>
<p class="indent">Nothing mysterious is going on here. We simply extracted two vectors from the dataframe and plotted them in the usual way, resulting in <a href="ch10.xhtml#ch10fig11" class="calibre10">Figure 10-11</a>.</p>
<div class="image"><img alt="Image" id="ch10fig11" src="../images/ch10fig11.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-11: Cases vs. country</em></p>
<p class="indent">This plot is not ideal, however. It shows us something about the distribution of the number of cases on the date in question, but the horizontal axis is <span epub:type="pagebreak" id="page_339"/>essentially useless because there is no room for hundreds of country labels. Perhaps, instead of trying to plot all the data at once, it would be more useful to plot some meaningful subset. Let’s limit our visualization to the countries with a lot of cases, by using the filtering mechanism we just learned. Also, let’s switch to a bar chart, which is the more appropriate visualization for this type of data:</p>
<pre class="calibre13">covhc = filter(r -&gt; r._1_1_21 &gt; 2*10^6, covdat)
@df covhc bar(:Country_Region, :_1_1_21; xrotation=40,
     label="Cases on 1JAN2021", legend=:topleft)</pre>
<p class="indent">Now we have something useful: a chart of the countries with more than two million cases on New Year’s Day 2021, shown in <a href="ch10.xhtml#ch10fig12" class="calibre10">Figure 10-12</a>.</p>
<div class="image"><img alt="Image" id="ch10fig12" src="../images/ch10fig12.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-12: Countries with over two million cases</em></p>
<p class="indent">In the previous indexing commands, we used integer indexing to select columns, which worked well, but required us to count to the first column of interest. Also, it was only convenient because we knew that the columns we wanted extended to the end, which simplified the indexing expression.</p>
<p class="indent">An alternative that lets us use column names directly is the <code>Between()</code> function. The equivalent expression for selecting the date columns is:</p>
<pre class="calibre13">covdat[1, Between(:_1_22_20, end)]</pre>
<p class="indent">This can be easily modified to choose any closed interval of columns.</p>
<p class="indent">Another option is the <code>Not()</code> function. Here is a selection that returns the same <code>DataFrameRow</code> as the previous one:</p>
<pre class="calibre13">covdat[1, Not([:Country_Region, :Province_State, :Lat, :Long])]</pre>
<p class="indent"><span epub:type="pagebreak" id="page_340"/>The columns that remain after the listed ones are excluded are just the ones we want: the date columns.</p>
<p class="indent">We can also select columns using regular expressions applied to the names of their titles. Here is another way to make the same selection, returning the same <code>DataFrameRow</code>:</p>
<pre class="calibre13">covdat[1, r"_2"]</pre>
<p class="indent">Sometimes this is the most convenient way to select data. For example, if we want to extract only the columns for February 2021 for Afghanistan, we could just say <code>covdat[1, r"_2_\d*_21"]</code>.</p>
<p class="indent">But what if we want to make a <code>DataFrameRow</code> with all the date columns <em class="calibre11">and</em>, say, the <code>Country_Region</code> column (but none of the other ones)? None of the indexing techniques we’ve seen so far make this convenient, although you might be able to twist them to get the desired result. There is no need for contortions, however, because we can use the <code>Cols()</code> function. The following lines show four different ways to use this function to get a <code>DataFrameRow</code> similar to the one we created using multiple techniques earlier, but with the addition of the <code>Country_Region</code> column:</p>
<pre class="calibre13">covdat[1, Cols(:Country_Region, r"_1")]
covdat[1, Cols("Country_Region", r"_1")]
covdat[1, Cols(2, r"_1")]
covdat[1, Cols(2, 5:end)]</pre>
<p class="indent">As we can see, the <code>Cols()</code> function lets you pick out individual columns or ranges of columns using numerical indices, regular expressions, or column names either as symbols or as strings. It can also reorder columns. The following rearranges the <code>covdat</code> dataframe to place the latitude and longitude columns at the end:</p>
<pre class="calibre13">covdat[:, Cols(1:2, r"_", :Lat, :Long)]</pre>
<p class="indent">With this, we have a large enough toolbox to do most of the indexing, selecting, and rearranging of dataframes that we’re likely to encounter in our work.</p>
<h5 class="h4" id="ch10sec1sec5"><strong class="calibre2">Mutating Dataframes</strong></h5>
<p class="noindent">The indexing expressions <code>covdat[:, :Country_Region]</code> and <code>covdat.Country_Region</code> both seem to return a <code>Vector</code> with contents identical to the <code>Country_Region</code> column of the dataframe called <code>covdat</code>. However, they are not identical:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">covdat[:, :Country_Region] == covdat.Country_Region</span>
true

julia&gt; <span class="codestrong">covdat[:, :Country_Region] === covdat.Country_Region</span>
false</pre>
<p class="indent"><span epub:type="pagebreak" id="page_341"/>This tells us that while the two left- and right-hand sides contain the same values, they are not the same object. The syntax <code>dataframe[:, :col]</code> makes a <em class="calibre11">copy</em> of the column and returns it as a <code>Vector</code>. But <code>covdat.Country_Region</code> is a <em class="calibre11">reference</em> to the column. If you have a choice, avoid making unnecessary copies, as it is slower and consumes memory. Also, if you want to mutate a column by assigning to individual elements, you must use a reference rather than a copy, as shown in <a href="ch10.xhtml#ch10lis10" class="calibre10">Listing 10-10</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">covdat.Country_Region[1] = "Disneyworld"</span>
"Disneyworld"

julia&gt; <span class="codestrong">covdat</span>
274×432 DataFrame
 Row | Province_State  Country_Region      Lat       Long    ...
     | String?         String              Float64?  Float64 ...
--------------------------------------------------------------
   1 | missing         Disneyworld          33.9391   67.71  ...
   2 | missing         Albania              41.1533   20.168
  :  |       :                 :              :         :
 274 | missing         Zimbabwe            -19.0154   29.154
                              429 columns and 271 rows omitted</pre>
<p class="list" id="ch10lis10"><em class="calibre11">Listing 10-10: Mutating a dataframe</em></p>
<p class="indent">The direct dot syntax used here only works when using a literal column name after the dot, not with a variable holding a column name. If you’re using variables to hold the names of columns, you must use square brackets. However, that doesn’t mean you are obligated to make copies of columns. Another syntax allows you to use square brackets to reference a column using a variable, and without making a copy: <code>dataframe[!</code>, <span class="codeitalic1">var</span><code>]</code> means the same thing as <code>dataframe.columnname</code> if <span class="codeitalic1">var</span> is set to <code>"columnname"</code>.</p>
<p class="indent">A command such as <code>covdat[:, c][1] = "Disneyworld"</code> will have no effect on the original dataframe. However, the assignment in <a href="ch10.xhtml#ch10lis10" class="calibre10">Listing 10-10</a> can also be written as</p>
<pre class="calibre13">covdat[!, :Country_Region][1] = "Disneyworld"</pre>
<p class="noindent">which will mutate the dataframe. The meaning of the exclamation point is suggested by its use in mutating functions, introduced in “Functions That Mutate Their Arguments” on <a href="ch02.xhtml#ch02lev1sec17" class="calibre10">page 56</a>.</p>
<h5 class="h4" id="ch10sec1sec6"><strong class="calibre2">Transposing Dataframes</strong></h5>
<p class="noindent">Dataframes make it convenient to plot or operate on columns of data. But suppose, using the data in the <code>covdat</code> dataframe, that you wanted to plot the time histories of case numbers for various countries. For each country, its time series is the part of the <em class="calibre11">row</em> for that country starting in the fifth column. We know, from the indexing section earlier, that we can extract rows from <span epub:type="pagebreak" id="page_342"/>the dataframe, and that doing so gets us not a <code>Vector</code>, but a <code>DataFrameRow</code>. This means that, for plotting, we need to convert the result into a <code>Vector</code>. Here is one way to put all of this together to plot the time histories of COVID cases in the US:</p>
<pre class="calibre13">using Chain
@chain covdat begin
    filter(r -&gt; r.Country_Region == "US", _)[1, 5:end]
    Vector()
    plot(names(covdat)[5:end], _, xrotation=45, legend=:topleft,
         label="US cases", lw=3)
end</pre>
<p class="indent">I snuck in a function you haven’t seen before: <code>names()</code> returns the names of the columns in a dataframe in the form of a <code>Vector</code> of strings, so it is what we need to make meaningful x-tick labels.</p>
<p class="indent">The listing employs the <code>@chain</code> macro introduced in “The @chain Macro” on <a href="ch06.xhtml#ch06sec1sec8" class="calibre10">page 174</a>. The pipeline syntax is popular when wrangling data from dataframes, as this activity inherently involves a series of transformations. The code snippet will produce the desired timeline plot, shown in <a href="ch10.xhtml#ch10fig13" class="calibre10">Figure 10-13</a>.</p>
<div class="image"><img alt="Image" id="ch10fig13" src="../images/ch10fig13.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-13: US cases vs. date</em></p>
<p class="indent">Now, to compare different countries, I would merely need to repeat the plotting pipeline using <code>plot!()</code> to add a new curve, substituting the country name of interest.</p>
<p class="indent">You may be thinking that there is a lot to type just to plot a row of data, and that this could be a bit of a drag for interactive work. Again, all this typing is required because the intention behind dataframes is to deal with them as a set of columns, so plotting rows is going against the grain. It would be <span epub:type="pagebreak" id="page_343"/>smoother to go with the dataframe flow and somehow flip the dataframe around first, so the rows become columns. This would make the code easier to write and read. Selecting the data to plot would be more direct, and it would come in the form of a <code>Vector</code> that can be plotted immediately, eliminating the need for conversion.</p>
<p class="indent">We want to end up with a series of columns for different countries, with each column containing the series of case numbers for the country. If we have that kind of dataframe, we can plot any country’s case number history directly. We would also like a column containing the date labels to use in plots. We can omit the other columns. We don’t plan to use the latitude and longitude information in these plots or in our subsequent analysis, but they will remain in the original <code>covdat</code> dataframe if we need them. We are just making a new dataframe as a tool to ease our exploration of the data.</p>
<p class="indent">Before proceeding, however, we need to do something about the fact that some of the country names appear more than once, because some of them are listed along with several entries for <code>Province_State</code>. If these country names are to become column titles, they must be unique. A little later on we’ll learn how to incorporate this data, but for now, we can simply eliminate the rows with provinces, keeping only the main country entries:</p>
<pre class="calibre13">covmc = covdat[ismissing.(covdat.Province_State), :]</pre>
<p class="indent">With the troublesome rows deleted, we can now safely exchange rows for columns. It probably sounds like we need some kind of transpose of the dataframe; however, the <code>transpose()</code> function, that we know and love from our work with matrices, will not work here. Fortunately, the <code>DataFrame</code> package comes with a function designed exactly for this purpose. We learned about the <code>permutedims()</code> function in “Adjoints and Transposes” on <a href="ch05.xhtml#ch05lev1sec17" class="calibre10">page 144</a>, as a kind of generalized transpose operation. The <code>DataFrames</code> package extends this function to handle <code>DataFrame</code>s; here’s how to use it:</p>
<pre class="calibre13">covmc = covmc[:, Not([:Province_State, :Lat, :Long])]
cdcn = permutedims(covmc, 1, "d")</pre>
<p class="indent">In the first line, we get rid of the columns that we won’t need. The transpose happens in the second line, where the first argument to <code>permutedims()</code> is the dataframe to be transposed, the second argument selects the column from the original dataframe whose contents are to be used as column names for the transposed dataframe, and the third argument is the name to give the new column, whose contents will be composed of the column names of the original dataframe. Since we eliminated the <code>Province_State</code> column, the first column of <code>covmc</code> is now <code>Country_Region</code>, so the names in the column of countries are used as the new column titles. We can specify the column to pivot around using any kind of selector, so we could have written the following as well:</p>
<pre class="calibre13">cdcn = permutedims(covmc, :Country_Region, "d")</pre>
<p class="indent">Our new dataframe, <code>cdcn</code>, appears as shown in <a href="ch10.xhtml#ch10fig14" class="calibre10">Figure 10-14</a>.</p>
<div class="image"><img alt="Image" id="ch10fig14" src="../images/ch10fig14.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-14: The</em> <span class="codeitalic">cdcn</span> <em class="calibre11">dataframe in the REPL</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_344"/>There is one problem with our freshly transposed dataframe: some of the column titles now have spaces in their names. You can’t see them in the small piece of the dataframe shown in <a href="ch10.xhtml#ch10fig14" class="calibre10">Figure 10-14</a>, but we know that they’re there:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">[c for c in covdat.Country_Region if contains(c, " ")]</span>
46-element Vector{String}:
 "Antigua and Barbuda"
 "Bosnia and Herzegovina"
 "Burkina Faso"
 "Cabo Verde"
 :
 "United Kingdom"
 "United Kingdom"
 "West Bank and Gaza"</pre>
<p class="indent">It’s not a serious problem, but, as you now know, legal symbol names are more convenient and lead to neater and more efficient code.</p>
<p class="indent">The function <code>rename!()</code> transforms the column names of a dataframe in place (hence the mutation warning sign). It has several methods; the method that we shall use takes a function as its first argument and the dataframe to be altered as its second argument. The supplied function is applied to each column separately. The command in <a href="ch10.xhtml#ch10lis11" class="calibre10">Listing 10-11</a> replaces spaces with underlines in the column names of <code>cdcn</code>.</p>
<pre class="calibre13">rename!(x -&gt; replace(x, " " =&gt; "_"), cdcn)</pre>
<p class="list" id="ch10lis11"><em class="calibre11">Listing 10-11: Renaming columns of a dataframe</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_345"/>Did it work? Let’s take a peek at a relevant bit of the dataframe:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">cdcn[:, r"^Un"]</span>
428×2 DataFrame
 Row | United_Arab_Emirates   United_Kingdom
     | Int64                  Int64
--------------------------------------------
   1 |                    0                0
   2 |                    0                0
  :                       :                :
 428 |               446594          4312908</pre>
<p class="indent">Now we can plot time-dependent case numbers for selected countries with ease:</p>
<pre class="calibre13">@df cdcn plot(:d, [:Zambia :Albania :Afghanistan]; xrotation=35,
              legend=:topleft, lw=3, ls=[:solid :dash :dot])</pre>
<p class="indent">The <code>@df</code> macro from <code>StatsPlots</code> was useful there, as the command refers to several columns using <code>Symbol</code>s; without it, we would be obligated to mention the name of the dataframe each time. This <code>plot()</code> command produces the graph in <a href="ch10.xhtml#ch10fig15" class="calibre10">Figure 10-15</a>.</p>
<div class="image"><img alt="Image" id="ch10fig15" src="../images/ch10fig15.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-15: Timeline of cases in three countries</em></p>
<p class="indent">In a <code>plot()</code> command inside a <code>@df</code> macro call, the <code>cols()</code> function (note the lowercase) can be used to select a numerical range of columns with <code>cols(a:b)</code>, all the columns with <code>cols()</code>, or a column whose <code>Symbol</code> name is stored in a variable, with <code>c = :thecol</code> and <code>cols(c)</code>.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_346" class="calibre1"/><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">Remember that</em> <span class="codeitalic1">Cols</span><em class="calibre11">, with an uppercase C, is for column selection within square brackets and is part of</em> <span class="codeitalic1">DataFrames.jl</span><em class="calibre11">, whereas</em> <span class="codeitalic1">cols</span><em class="calibre11">, using lowercase, is a utility function for use in the</em> <span class="codeitalic1">@df</span> <em class="calibre11">macro, provided by</em> <span class="codeitalic1">StatsPlots.jl</span>.</p>
</div>
<p class="indent">With all the machinery that we now have under our belts, we can do more than plot random selections of countries. One thing that might be interesting is to plot only those countries whose caseloads rise above a certain level on any day included in the dataset. Here is one way to do that, using the <code>@df</code> macro and <code>cols()</code> function from <code>StatsPlots</code>:</p>
<pre class="calibre13">sc = [Symbol(c) for c in names(cdcn)[2:end] if maximum(cdcn[:, c]) &gt; 3*10^6]
@df cdcn plot(:d, cols(sc); xrotation=35, lw=2, legend=:topleft, ls=:auto)</pre>
<p class="indent">The strategy is to collect the relevant columns as an array of <code>Symbol</code>s, so that we can select them in the <code>plot()</code> statements using <code>cols()</code>. <a href="ch10.xhtml#ch10fig16" class="calibre10">Figure 10-16</a> shows the result.</p>
<div class="image"><img alt="Image" id="ch10fig16" src="../images/ch10fig16.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-16: Countries with large caseloads</em></p>
<p class="indent"><code>StatsPlots</code> has turned the symbols identifying the columns into strings for the plot, providing a useful legend.</p>
<h5 class="h4" id="ch10sec1sec7"><strong class="calibre2">Summarizing Dataframes</strong></h5>
<p class="noindent">Another useful device that <code>DataFrames</code> provides is the <code>combine</code> function. This allows us to map a function onto a set of columns to create a new dataframe that is a summary of an existing dataframe. For example, suppose we want a table that contains the maximum number of cases seen for each country. The <code>combine()</code> function makes this simple:</p>
<pre class="calibre13"><span epub:type="pagebreak" id="page_347"/>julia&gt; <span class="codestrong">combine(cdcn, 2:190 .=&gt; maximum)</span>
1×189 DataFrame
 Row | Afghanistan_maximum  Albania_maximum  Algeria_maximum ...
     | Int64                Int64            Int64           ...
--------------------------------------------------------------
   1 |               56192           122295           116438 ...
                                           186 columns omitted</pre>
<p class="indent">For each column in the range of columns defined in the second argument, <code>combine()</code> applies the <code>maximum()</code> function to its contents.</p>
<p class="indent">The <code>combine()</code> function creates new column names by appending the name of the function. If you would like to preserve the original name, pass in <code>renamecols = false</code>.</p>
<p class="indent">This data is a good candidate for another bar chart, but it would be more convenient to have it transposed, with a column of countries and a column of maximums. We know how to do that now, but something is missing: we need to add a column to hold the new column names. <a href="ch10.xhtml#ch10lis12" class="calibre10">Listing 10-12</a> combines the methods we’ve learned to first make a permuted dataframe called <code>cdmp</code> and then, in the last line, copy only the rows with the largest caseloads into another dataframe, <code>cdmpc</code>.</p>
<pre class="calibre13">cdmax = combine(cdcn, 2:190 .=&gt; maximum, renamecols=false)
cdmax[!, :Country] = ["Maximum"]
cdmp = permutedims(cdmax, :Country)
cdmpc = cdmp[cdmp.Maximum .&gt; 2*10^6, :]</pre>
<p class="list" id="ch10lis12"><em class="calibre11">Listing 10-12: Plotting maximum caseloads</em></p>
<p class="indent">After executing the code in <a href="ch10.xhtml#ch10lis12" class="calibre10">Listing 10-12</a>, <code>cdmpc</code> looks like this:</p>
<pre class="calibre13">14×2 DataFrame
 Row | Country          Maximum
     | String           Int64
--------------------------------
   1 | Argentina         2269877
   2 | Brazil           12220011
  :  |       :             :
  13 | US               30010928
  14 | United_Kingdom    4312908
                 10 rows  omitted</pre>
<p class="indent">You see that there are only 14 countries that experienced a caseload of more than two million during the time period covered by this dataset. Now we can make a bar chart with this simple command:</p>
<pre class="calibre13">bar(cdmpc.Country, cdmpc.Maximum, xrotation=45, label=nothing,
    title="Countries with highest maximum caseloads")</pre>
<p class="indent"><span epub:type="pagebreak" id="page_348"/>This creates the graph in <a href="ch10.xhtml#ch10fig17" class="calibre10">Figure 10-17</a>.</p>
<div class="image"><img alt="Image" id="ch10fig17" src="../images/ch10fig17.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-17: The highest maximum caseloads</em></p>
<p class="indent">The need for summary statistics of the data in a dataframe is so common that a function is available that does the foregoing work for us, but it’s good to know how to do it “manually,” in case you need something it doesn’t provide. That function is called <code>describe()</code>, and here’s how it works:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">describe(cdcn, :max; cols=Not(:d))</span>
189×2 DataFrame
 Row | variable             max
     | Symbol               Int64
------------------------------------
   1 | Afghanistan            56192
   2 | Albania               122295
   3 | Algeria               116438
   4 | Andorra                11638
   5 | Angola                 21836
   6 | Antigua_and_Barbuda     1080
  :  |          :              :
 184 | Venezuela             153315
 185 | Vietnam                 2576
 186 | West_Bank_and_Gaza    230076
 187 | Yemen                   3703
 188 | Zambia                 86993
 189 | Zimbabwe               36749
                    177 rows omitted</pre>
<p class="indent"><span epub:type="pagebreak" id="page_349"/>That’s certainly easier! By default, <code>describe()</code> returns a <code>DataFrame</code> with the means and medians as well, but those are not meaningful for these timelines, so we limit the statistics calculated by passing a symbol, <code>:max</code>, for the one we want. The function can calculate the other summary statistics as well, such as standard deviation, and automatically skips <code>missing</code> values. It can even report the number of <code>missing</code> values in each column, if you so desire.</p>
<h5 class="h4" id="ch10sec1sec8"><strong class="calibre2">Grouping Dataframes</strong></h5>
<p class="noindent">Earlier we threw away some of the data, namely the additional provinces for the several countries for which such entries existed. As promised, we’ll now find a way to include that information.</p>
<p class="indent">Let’s suppose we are not interested in looking at the data for individual provinces, but instead would like to add up the numbers for all the provinces belonging to each country and just look at the total case numbers. This makes a bit more sense than just deleting that data. The most convenient way to do this kind of thing involves the concept of the <em class="calibre11">grouped dataframe</em> and an associated new data type, the <code>GroupedDataFrame</code>.</p>
<p class="indent">A <code>GroupedDataFrame</code> is something like a vector of dataframes. Each dataframe in the vector is created from a source dataframe by collating the rows that have the same value in a chosen column. In our case, we’ll group by <code>Country_Region</code>. Most of the resulting members of the <code>GroupedDataFrame</code> will have a single row because most countries appear only once. But those countries that appear multiple times, because they have <code>Province_State</code> values, will give rise to members of the <code>GroupedDataFrame</code> with more than one row, with one for each <code>Province_State</code>.</p>
<p class="indent">One small wrinkle is that the members of a <code>GroupedDataFrame</code> are not actually dataframes, but have a new data type called <code>SubDataFrame</code>; however, the distinction is usually not important.</p>
<p class="indent">The following will group the <code>covdat</code> dataframe by country:</p>
<pre class="calibre13">cvgp = groupby(covdat, :Country_Region)</pre>
<p class="indent">Now <code>cvgp</code> is a <code>GroupedDataFrame</code>. Let’s examine it in the REPL:</p>
<pre class="calibre13"><span class="ent">➊</span> julia&gt; <span class="codestrong">length(cvgp)</span>
   192

<span class="ent">➋</span> julia&gt; <span class="codestrong">length(covdat.Country_Region) - length(cvgp)</span>
   82

<span class="ent">➌</span> julia&gt; <span class="codestrong">cvgp[1]</span>
   1×432 SubDataFrame
    Row | Province_State  Country_Region  Lat       Long      _ ...
        | String?         String          Float64?  Float64?  I ...
   --------------------------------------------------------------
      1 | missing         Afghanistan      33.9391     67.71    ...
                                              428 columns omitted

<span epub:type="pagebreak" id="page_350"/><span class="ent">➍</span> julia&gt; <span class="codestrong">cvgp[183]</span>
   12×432 SubDataFrame
    Row | Province_State                     Country_Region  La ...
        | String?                            String          Fl ...
   --------------------------------------------------------------
      1 | Anguilla                           United Kingdom   1 ...
      2 | Bermuda                            United Kingdom   3
     :  |                 :                        :
     12 | missing                            United Kingdom   5
                                   430 columns and 9 rows omitted</pre>
<p class="indent">The grouped dataframe has 192 members <span class="ent">➊</span>, which tells us how may distinct countries are included in the data (remembering that one of them is <code>Repatriated Travellers</code>).</p>
<p class="indent">Subtracting that from the total number of rows <span class="ent">➋</span>, we learn that 82 countries have provinces listed.</p>
<p class="indent">Looking at individual members of <code>cvgp</code> <span class="ent">➌</span> <span class="ent">➍</span> confirms that these are dataframes devoted to individual countries. The next step is to add up the case numbers across all provinces for each date, so each country’s numbers will include all of its provinces. That’s what the <code>combine()</code> function is for. When I introduced <code>combine()</code>, we used it on a dataframe, but when applied to a grouped dataframe, it does exactly what we want, applying the specified function along the selected columns for each group member individually and then returning a normal <code>DataFrame</code> as the result.</p>
<p class="indent">First we need an array holding the columns to sum, which are the date columns, and then we can <code>combine()</code> them. We’ll store the result in a new variable:</p>
<pre class="calibre13">dcols = cdcn.d
cvsm = combine(cvgp, dcols .=&gt; sum, renamecols=false)</pre>
<p class="indent">Now <code>cvsm</code> has the same structure as our original <code>covdat</code>, but only 192 rows, one for each country. As before, it will be convenient to have on hand the transpose of this dataframe:</p>
<pre class="calibre13">cvsp = permutedims(cvsm, :Country_Region, "d")</pre>
<p class="indent">And, as before, it’s better to normalize (remove the spaces from) the column names. After repeating the procedure from <a href="ch10.xhtml#ch10lis11" class="calibre10">Listing 10-11</a> on <code>cvsp</code>, we have a dataframe convenient for plotting.</p>
<p class="indent">Now it’s easy to compare the timelines for France, both with and without its territories:</p>
<pre class="calibre13">@df cvsp plot(:d, :France; xrotation=35, label="France with territories", legend=:topleft)
@df cdcn plot!(:d, :France; xrotation=35, label="France minus territories", legend=:topleft,
               ls=:dash)</pre>
<p class="indent"><a href="ch10.xhtml#ch10fig18" class="calibre10">Figure 10-18</a> shows the results.</p>
<div class="image"><img alt="Image" id="ch10fig18" src="../images/ch10fig18.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-18: Time history of the caseload in France</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_351"/>In most cases, the inclusion of the <code>Province_State</code> columns makes a barely visible difference in the plot.</p>
<h3 class="h2" id="ch10lev9"><strong class="calibre2">Multivariate Data</strong></h3>
<p class="noindent">The previous examples all dealt with timelines: a single quantity, in this case numbers of infections, as a function of date, for various countries. Another form of data involves the frequencies of a number of events in, say, different places, or compared among different demographic groups. <a href="ch10.xhtml#ch10fig4" class="calibre10">Figure 10-4</a> showed a simple example of this form of data, where the events are observations of height and the demographic groups are men and women.</p>
<p class="indent">When you have data on more than one variable, you can use statistical methods to look for associations among them, always remembering that “correlation does not imply causation.” But an association can suggest that it might be worthwhile to look further, and the <em class="calibre11">lack</em> of correlation might be useful in ruling out hypotheses.</p>
<p class="indent">In the (made up) example of men’s and women’s heights, if we also had, from the same subjects, data about income level, or age, we could look for associations. Are richer people taller? When does the increase of height with age level off? Julia’s <code>DataFrame</code>s, combined with its convenient statistical functions and the visualizations provided by <code>StatsPlots</code>, make this kind of data exploration a relatively easy and pleasant task.</p>
<p class="indent">I compiled our second datafile from data maintained by the US Census Bureau (<a href="https://www.census.gov" class="calibre10"><em class="calibre11">https://www.census.gov</em></a>). It is available in the supplementary website at <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a>, in the file named <em class="calibre11">census.dat</em>. The file is in tabseparated value format, with one line of column headers and comment lines that each begin with a hash mark (#). The data consists of absolute numbers <span epub:type="pagebreak" id="page_352"/>of reported crimes in several categories in 2011 for each county in the US, plus a column for the total population of the county and one for the percentage of minors who did not complete high school. The comment lines give the totals for each state and for the entire country. Here are the first nine lines of the 3,143-line file:</p>
<pre class="calibre13">Areaname    Larceny Murder  MVTheft Robbery MinorsNHI   EstimatedPop
##UNITED STATES 6384687 16107   1196608 405471  10.8    295753151
##ALABAMA   97640   308 10796   5636    7.8 4545049
Autauga, AL 1149    0   112 28  8   47870
Baldwin, AL 1973    5   137 37  11.3    162564
Barbour, AL 64  0   7   1   7.8 29452
Bibb, AL    144 0   18  3   8.  21375
Blount, AL  558 0   134 6   11.8    55035
Bullock, AL 54  0   0   3   7.9 10975</pre>
<p class="indent">Clearly, the first thing we need to do is use the <code>CSV</code> package to read this and store it in a dataframe. The <code>CSV.File</code> function will detect that tabs are used as delimiters, and also that the first line is a header, but we should tell it about the comments:</p>
<pre class="calibre13">cbc = CSV.File("census.dat", comment="#") |&gt; DataFrame
cbc = cbc[cbc.EstimatedPop .!= 0, :]</pre>
<p class="indent">The second line eliminates any rows (there were three) with a zero population. As we plan to divide the absolute numbers by population to convert them into rates, we need to delete those rows. Here is the conversion:</p>
<pre class="calibre13">for c in 2:5
    cbc[!, c] = cbc[!, c] ./ cbc[!, 7]
end</pre>
<p class="indent">At this point, our dataframe looks like this:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">cbc</span>
3143×7 DataFrame
  Row | Areaname        Larceny      Murder      MVTheft      Robber ...
      | String          Float64      Float64     Float64      Float6 ...
----------------------------------------------------------------------
    1 | Autauga, AL     0.0240025    0.0         0.00233967   0.0005 ...
    2 | Baldwin, AL     0.0121368    3.07571e-5  0.000842745  0.0002
    3 | Barbour, AL     0.00217303   0.0         0.000237675  3.3953
    4 | Bibb, AL        0.00673684   0.0         0.000842105  0.0001
    5 | Blount, AL      0.010139     0.0         0.00243481   0.0001 ...
    6 | Bullock, AL     0.00492027   0.0         0.0          0.0002
    7 | Butler, AL      0.0227653    9.83381e-5  0.00108172   0.0007
    8 | Calhoun, AL     0.0256511    4.46106e-5  0.00215915   0.0014
  :   |       :              :           :            :            :
 3137 | Sheridan, WY    0.0167767    0.0         0.000921795  3.6871 ...
 <span epub:type="pagebreak" id="page_353"/>3138 | Sublette, WY    0.0387191    0.0         0.00262009   0.0
 3139 | Sweetwater, WY  0.0296249    2.68341e-5  0.00262974   0.0001
 3140 | Teton, WY       0.0197487    0.0         0.00149925   0.0001
 3141 | Uinta, WY       0.0283567    0.0         0.00190417   0.0002 ...
 3142 | Washakie, WY    0.00425093   0.0         0.000128816  0.0
 3143 | Weston, WY      0.0122008    0.0         0.0          0.0001
                                       3 columns and 3128 rows omitted</pre>
<p class="indent">How is a particular crime category, say, larceny, distributed among the counties? Are they all the same? How likely is it for a county to have an unusually high larceny rate? We can answer those kinds of questions with a histogram, which we can produce with this command:</p>
<pre class="calibre13">@df cbc histogram(:Larceny; legend=nothing)</pre>
<p class="indent">In many commands that pull data from the dataframe, the <code>@df</code> macro will save some typing and make the code easier to read. The histogram, shown in <a href="ch10.xhtml#ch10fig19" class="calibre10">Figure 10-19</a>, shows that about 400 counties had no larceny at all during the report year, and most had rates (total number divided by population) below 2 percent. Above that rate, the distribution drops off steadily and fairly rapidly.</p>
<div class="image"><img alt="Image" id="ch10fig19" src="../images/ch10fig19.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-19: Histogram of larcenies</em></p>
<p class="indent">With our dataframe set up, exploring this data in the REPL is simple (the following assumes that <code>Statistics</code> has already been imported):</p>
<pre class="calibre13">julia&gt; <span class="codestrong">mean(cbc.Larceny)</span>
0.014305068778810368

<span epub:type="pagebreak" id="page_354"/>julia&gt; <span class="codestrong">@df cbc cor(:Murder, :Larceny)</span>
0.29993876295850447

julia&gt; <span class="codestrong">@df cbc cor(:MVTheft, :Larceny)</span>
0.6528140798664165</pre>
<p class="indent">The average larceny rate is about 1.4 percent. How is this crime correlated with other crimes? The correlation with murder is weak, meaning that knowledge of a high larceny rate in a particular county tells you nothing about its murder rate. However, the correlation with vehicle theft is significant: a county with a high larceny rate is a place where you are more likely to get your car stolen. That may not be surprising, but before we take it seriously, we should remember that the correlation coefficients calculated by the <code>cor()</code> function of the <code>Statistics</code> package are the Pearson coefficients, which assume a linear relationship between the two variables under consideration. Does such a linear relationship hold between these two crime categories? The way to answer this kind of question is with a scatterplot:</p>
<pre class="calibre13">@df cbc scatter(:MVTheft, :Larceny; legend=nothing, markersize=2,
    opacity=0.3, xlabel="Motor vehicle theft", ylabel="Larceny",
    xrange=[0, 0.015])</pre>
<p class="indent">It does look from <a href="ch10.xhtml#ch10fig20" class="calibre10">Figure 10-20</a> as if there is at least a roughly linear relationship between the two rates, so the correlation coefficient is meaningful.</p>
<div class="image"><img alt="Image" id="ch10fig20" src="../images/ch10fig20.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-20: Larceny–motor vehicle theft scatterplot</em></p>
<p class="indent">Using a small marker size combined with a low opacity is effective when making scatterplots with many points. The idea is that there are likely to be regions with a lot of overlap. Using small, transparent points allows the <span epub:type="pagebreak" id="page_355"/>point density at any location to appear as a buildup of image density there. Using opaque or larger points would create a plot where we can’t distinguish between moderate and high densities once the markers begin to obscure each other.</p>
<p class="indent">This idea is made more systematic with a plot recipe from <code>StatsPlots</code> called <code>histogram2d()</code>. As the name suggests, it takes two variables and creates a two-dimensional histogram. The result is similar to a scatterplot, but with the plane divided into cells and the cells colored according to the number of points they contain. Here is how it works:</p>
<pre class="calibre13">@df cbc histogram2d(:MVTheft, :Larceny; xlabel="Motor vehicle theft",
                    ylabel="Larceny", xrange=[0, 0.015])</pre>
<p class="indent">As with ordinary histograms, we can adjust the number of bins if the automatic calculation is not optimal, but in this case, the algorithm does a good job. The result shown in <a href="ch10.xhtml#ch10fig21" class="calibre10">Figure 10-21</a> conveys information similar to the scatterplot in <a href="ch10.xhtml#ch10fig20" class="calibre10">Figure 10-20</a>, but now we can read off the number of cases from the color map.</p>
<div class="image"><img alt="Image" id="ch10fig21" src="../images/ch10fig21.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-21: Two-dimensional histogram of two categories of crime</em></p>
<p class="indent">The <code>describe()</code> function that we met earlier is useful for getting an overview of this type of data. The result can be made more concise by eliminating the uninteresting bits:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">describe(cbc, :mean, :max, :nmissing)[2:end,:]</span>
6×4 DataFrame
 Row | variable      mean         max           nmissing
     | Symbol        ...Union     Any           Int64
--------------------------------------------------------
   <span epub:type="pagebreak" id="page_356"/>1 | Larceny       0.0143051    0.0925926            0
   2 | Murder        3.01897e-5   0.000539374          0
   3 | MVTheft       0.00156298   0.0231045            0
   4 | Robbery       0.000357696  0.00987096           0
   5 | MinorsNHI     11.5316      42.9                 0
   6 | EstimatedPop  94099.0      9803912              0</pre>
<p class="indent">The last column in the description table informs us that there are no missing values. The reason for the composite data types is that the summary dataframe contained a row of county names that we eliminated with the indexing expression, so these columns actually contain a mix of numbers and strings.</p>
<p class="indent">You can combine the two-dimensional histogram of <a href="ch10.xhtml#ch10fig21" class="calibre10">Figure 10-21</a> with normal one-dimensional histograms of each variable using the <code>marginalhist()</code> recipe from <code>StatsPlots</code>:</p>
<pre class="calibre13">@df cbc marginalhist(:MVTheft, :Larceny; xlabel="Motor vehicle theft",
                     ylabel="Larceny")</pre>
<p class="indent">The result, shown in <a href="ch10.xhtml#ch10fig22" class="calibre10">Figure 10-22</a>, is a nice visualization of two distributions simultaneously.</p>
<div class="image"><img alt="Image" id="ch10fig22" src="../images/ch10fig22.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-22: Illustrating the marginal histogram plot recipe</em></p>
<p class="indent">The <code>StatsPlots</code> package has another trick up its sleeve. It can combine some of the plots we’ve already seen into a composite visualization that makes it easy to pick out associations and patterns among a group of variables almost at a glance. This is achieved with the <code>corrplot()</code> recipe, as follows:</p>
<pre class="calibre13"><span epub:type="pagebreak" id="page_357"/>@df cbc corrplot([:MinorsNHI :MVTheft :Robbery]; fillcolor=cgrad(),
                 xrotation=40)</pre>
<p class="indent">We’ve chosen three variables to look at; it’s possible to look at everything at once, or any other subset with more than two categories. The need to include the <code>fillcolor</code> argument is a bug that may be fixed by the time you are reading this, so you may want to try omitting it. It controls the palette used in the two-dimensional histograms, and, as you saw earlier, it’s not needed in regular <code>histogram2d</code> plots to get the default coloring.</p>
<p class="indent"><a href="ch10.xhtml#ch10fig23" class="calibre10">Figure 10-23</a> shows the result.</p>
<div class="image"><img alt="Image" id="ch10fig23" src="../images/ch10fig23.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 10-23: A correlation plot</em></p>
<p class="indent">The recipe produces a matrix of plots comparing every possible combination of pairs of variables from the vector of arrays provided in the first argument. Along the diagonal of this plot matrix (where the two variables are identical) we have conventional, one-dimensional histograms; above the diagonal, we see all three possible two-dimensional histograms; and below the diagonal, we have all the scatterplots, using transparent points. As a bonus, the scatterplots also feature regression (best fit) lines drawn through the points, and the marker color reflects the type of correlation: positive correlations are blue, lack of correlation is indicated by yellow, and negative correlations are red. This is a powerful visualization that carries a rich payload of information. A quick look tells us that failure to complete secondary school is unrelated to rates of vehicle theft or robbery, but those two types of crime are correlated with each other.</p>
<h3 class="h2" id="ch10lev10"><span epub:type="pagebreak" id="page_358" class="calibre1"/><strong class="calibre2">Other Packages</strong></h3>
<p class="noindent">This section briefly describes a few more tools that readers interested in statistics will want to be aware of. See “Further Reading” on <a href="ch10.xhtml#fur10" class="calibre10">page 359</a> for some additional resources you may find useful.</p>
<h4 class="h3" id="ch10lev1sec8"><strong class="calibre2"><em class="calibre4">JuliaDB for Out of Core Datasets</em></strong></h4>
<p class="noindent">Dataframes are powerful data types, but they’re intended for data structures that fit in RAM. For data that is too large to fit in memory, a better choice is <code>JuliaDB</code>, which is designed to work efficiently with such “out of core” datasets.</p>
<h4 class="h3" id="ch10lev1sec9"><strong class="calibre2"><em class="calibre4">RCall for Interacting with R</em></strong></h4>
<p class="noindent">The R programming language is a long-established language and system for statistical analysis. Like Julia, R is free software and has a large population of devoted users. However, it is not a good general-purpose programming language, and it can be quite slow for certain types of calculations. If you are starting a new project, and do not happen to have a personal library of R code that you have developed over the years, I recommend using Julia for your statistics needs. It already has a large and capable ecosystem of statistical packages, and more packages are being added every day. Julia won’t let you down if your analysis program turns into something that needs to run quickly on big data. Its ability to run on GPUs and other multiprocessor hardware, and the efficiency of its compiled code, means that you won’t need to rewrite your programs in order for them to scale.</p>
<p class="indent">However, if you have already invested time and effort into writing R routines that you want to keep using, you need not rewrite them. You can use them from, and in combination with, Julia. The <code>RCall</code> package has several macros for interoperating with R routines and data structures, as well as a special REPL mode for interacting directly with R within the Julia session. In fact, as soon as you type <code>using RCall</code>, an R process starts up in the background. It locates your R installation and can even install R for you.</p>
<h4 class="h3" id="ch10lev1sec10"><strong class="calibre2"><em class="calibre4">P-hacking</em></strong></h4>
<p class="noindent">For calculating p-values and performing other analyses to contribute to the replication crisis in science, the <code>HypothesisTests</code> package at <a href="https://github.com/JuliaStats/HypothesisTests.jl" class="calibre10"><em class="calibre11">https://github.com/JuliaStats/HypothesisTests.jl</em></a> is invaluable.</p>
<h3 class="h2" id="ch10lev11"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">The concepts and techniques of statistics cut across all scientific disciplines. Julia, with its statistics packages, puts a lot of exploratory and analytical power at our fingertips. Good integration with the <code>Plots</code> package makes visualization fast and easy as well. While systems such as R, a standard for statistical analysis for decades, offer some functions not yet built into Julia’s <span epub:type="pagebreak" id="page_359"/>packages, the latter are developing quickly. Julia has some advantages today over the venerable workhorses: the ease of developing in the language makes it easier to add missing capabilities, and Julia’s efficiency frees you from the need to rewrite your code in a faster language when faced with big data or computationally intensive analyses.</p>
<p class="indent">We’ll revisit some of the concepts introduced in this chapter in the next chapter, with simulated evolution, and in <a href="ch13.xhtml" class="calibre10">Chapter 13</a>, where we explore the techniques of probabilistic programming to make inferences about models.</p>
<div class="box">
<p class="boxtitle-d" id="fur10"><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">For details on the lava lamp entropy project, see <a href="https://blog.cloudflare.com/randomness-101-lavarand-in-production/" class="calibre10"><em class="calibre11">https://blog.cloudflare.com/randomness-101-lavarand-in-production/</em></a>.</li>
<li class="noindent1">The pandemic simulation in this chapter implements a simplified model along the lines of the widely used COVID-19  model developed at  <a href="https://github.com/mrc-ide/covid-sim" class="calibre10"><em class="calibre11">https://github.com/mrc-ide/covid-sim</em></a>.</li>
<li class="noindent1">The formula for the combination of events used in the pandemic simulation is derived in Chapter IV of William Feller’s standard work on probability theory,  <em class="calibre11">An Introduction to Probability Theory and Its Applications</em>,  Volume  1  (Wiley  1968).</li>
<li class="noindent1">An alternative random number generator designed for long-term stability is available at <a href="https://github.com/JuliaRandom/StableRNGs.jl" class="calibre10"><em class="calibre11">https://github.com/JuliaRandom/StableRNGs.jl</em></a>.  You may want to use it if you would like your programs to use the same pseudorandom sequences across future versions of Julia and its packages.</li>
<li class="noindent1">The <code>RCall</code> package resides at <a href="https://github.com/JuliaInterop/RCall.jl" class="calibre10"><em class="calibre11">https://github.com/JuliaInterop/RCall.jl</em></a>.</li>
<li class="noindent1">A frequently updated list of Julia statistics and machine learning packages,  with brief descriptions,  is available at <a href="https://github.com/JuliaStats" class="calibre10"><em class="calibre11">https://github.com/JuliaStats</em></a>.</li>
<li class="noindent1">See this  20-minute tutorial video by Juan Klopper for an introduction to statistics in Julia: <a href="https://www.youtube.com/watch?v=xbsr46Dw8hg" class="calibre10"><em class="calibre11">https://www.youtube.com/watch?v=xbsr46Dw8hg</em></a>.</li>
<li class="noindent1">A textbook by Yoni Nazarathy and Hayden Klok about doing statistics,  data science,  and machine learning with Julia is available at <a href="https://statisticswithjulia.org" class="calibre10"><em class="calibre11">https://statisticswithjulia.org</em></a>.</li>
<li class="noindent1">The headquarters of the <code>JuliaDB</code> package is <a href="https://juliadb.juliadata.org/latest/out_of_core/" class="calibre10"><em class="calibre11">https://juliadb.juliadata.org/latest/out_of_core/</em></a>.</li>
<li class="noindent1">More information on dataframes as collections of rows is available at  <a href="https://bkamins.github.io/julialang/2023/02/24/dfrows.html" class="calibre10"><em class="calibre11">https://bkamins.github.io/julialang/2023/02/24/dfrows.html</em></a>.<span epub:type="pagebreak" id="page_360"/></li>
</ul>
</div>
</body></html>