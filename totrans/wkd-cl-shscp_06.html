<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_117"/><span class="big"><strong>5</strong></span><br/><strong>SYSTEM ADMINISTRATION: MANAGING USERS</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">No sophisticated operating system, whether it’s Windows, OS X, or Unix, can run indefinitely without human intervention. If you’re on a multiuser Linux system, someone is already performing the necessary system administration tasks. You might be able to ignore the proverbial “man behind the curtain” who is managing and maintaining everything, or you might well be the Great and Powerful Oz yourself, the person who pulls the levers and pushes the buttons to keep the system running. If you have a single-user system, there are system administration tasks that you should be performing on a regular basis.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_118"/>Fortunately, simplifying life for Linux system administrators (the goal for this chapter) is one of the most common uses of shell scripting. In fact, quite a few Linux commands are actually shell scripts, and many of the most basic tasks, like adding users, analyzing disk usage, and managing the filespace of the guest account, can be accomplished more efficiently with short scripts.</p>&#13;
<p class="indent">What’s surprising is that many system administration scripts are no more than 20 to 30 lines long. Heck, you can use Linux commands to identify scripts and run a pipe to figure out how many lines each contains. Here are the 15 shortest scripts in <em>/usr/bin/</em>:</p>&#13;
<pre class="programs">$ <span class="codestrong">file /usr/bin/* | grep "shell script" | cut -d: -f1 | xargs wc -l \</span>&#13;
<span class="codestrong">| sort -n | head -15</span>&#13;
    3 zcmp&#13;
    3 zegrep&#13;
    3 zfgrep&#13;
    4 mkfontdir&#13;
    5 pydoc&#13;
    7 sgmlwhich&#13;
    8 batch&#13;
    8 ps2pdf12&#13;
    8 ps2pdf13&#13;
    8 ps2pdf14&#13;
    8 timed-read&#13;
    9 timed-run&#13;
   10 c89&#13;
   10 c99&#13;
   10 neqn</pre>&#13;
<p class="indent">None of the shortest 15 scripts in the <em>/usr/bin/</em> directory are longer than 10 lines. And at 10 lines, the equation-formatting script <span class="literal">neqn</span> is a fine example of how a little shell script can really improve the user experience:</p>&#13;
<pre class="programs">#!/bin/bash&#13;
# Provision of this shell script should not be taken to imply that use of&#13;
#   GNU eqn with groff -Tascii|-Tlatin1|-Tutf8|-Tcp1047 is supported.&#13;
&#13;
: ${GROFF_BIN_PATH=/usr/bin}&#13;
PATH=$GROFF_BIN_PATH:$PATH&#13;
export PATH&#13;
exec eqn -Tascii ${1+"$@"}&#13;
&#13;
# eof</pre>&#13;
<p class="indent">Like <span class="literal">neqn</span>, the scripts presented in this chapter are short and useful, offering a range of administrative capabilities including easy system backups; the creation, management, and deletion of users and their data; an easy-to-use frontend for the <span class="literal">date</span> command that changes the current date and time; and a helpful tool to validate <em>crontab</em> files.</p>&#13;
<h3 class="h3" id="ch05lev1sec01"><span epub:type="pagebreak" id="page_119"/><strong>#35 Analyzing Disk Usage</strong></h3>&#13;
<p class="noindenta">Even with the advent of very large disks and their continual drop in price, system administrators seem to be perpetually tasked with keeping an eye on disk usage so that shared drives don’t fill up.</p>&#13;
<p class="indent">The most common monitoring technique is to look at the <em>/usr</em> or <em>/home</em> directory, using the <span class="literal">du</span> command to determine the disk usage of all subdirectories and reporting the top 5 or 10 users. The problem with this approach, however, is that it doesn’t take into account space usage elsewhere on the hard disk(s). If some users have additional archive space on a second drive, or you have some sneaky types who keep MPEGs in a dot directory in <em>/tmp</em> or in an unused directory in the <em>ftp</em> area, this usage will escape detection. Also, if you have home directories spread across multiple drives, searching each <em>/home</em> isn’t necessarily optimal.</p>&#13;
<p class="indent">Instead, a better solution is to get all the account names directly from the <em>/etc/passwd</em> file and then to search the filesystems for files owned by each account, as shown in <a href="ch05.xhtml#ch5ex1">Listing 5-1</a>.</p>&#13;
<h4 class="h4" id="ch05lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # fquota--Disk quota analysis tool for Unix; assumes all user&#13;
   #   accounts are &gt;= UID 100&#13;
&#13;
   MAXDISKUSAGE=20000   # In megabytes&#13;
&#13;
   for name in $(cut -d: -f1,3 /etc/passwd | awk -F: '$2 &gt; 99 {print $1}')&#13;
   do&#13;
     /bin/echo -n "User $name exceeds disk quota. Disk usage is: "&#13;
     # You might need to modify the following list of directories to match&#13;
     #   the layout of your disk. The most likely change is from /Users to /home.&#13;
<span class="ent">➊</span>   find / /usr /var /Users -xdev -user $name -type f -ls | \&#13;
       awk '{ sum += $7 } END { print sum / (1024*1024) " Mbytes" }'&#13;
&#13;
<span class="ent">➋</span> done | awk "\$9 &gt; $MAXDISKUSAGE { print \$0 }"&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch5ex1"/><em>Listing 5-1: The</em> <span class="literal"><em>fquota</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch05lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">By convention, user IDs 1 through 99 are for system daemons and administrative tasks, while 100 and above are for user accounts. Since Linux administrators tend to be a fairly organized bunch, this script skips all accounts that have a uid of less than 100.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_120"/>The <span class="literal">-xdev</span> argument to the <span class="literal">find</span> command <span class="ent">➊</span> ensures that <span class="literal">find</span> doesn’t go through all filesystems. In other words, this argument prevents the command from slogging through system areas, read-only source directories, removable devices, the <em>/proc</em> directory of running processes (on Linux), and similar areas. This is why we specify directories like <em>/usr</em>, <em>/var</em>, and <em>/home</em> explicitly. These directories are commonly on their own filesystems for backup and managerial purposes. Adding them when they reside on the same filesystem as the root filesystem doesn’t mean they will be searched twice.</p>&#13;
<p class="indent">It may seem at first glance that this script outputs an <span class="literal">exceeds disk quota</span> message for each and every account, but the <span class="literal">awk</span> statement after the loop <span class="ent">➋</span> only allows this message to be reported for accounts with usage greater than the predefined <span class="literal">MAXDISKUSAGE</span>.</p>&#13;
<h4 class="h4" id="ch05lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script has no arguments and should be run as root to ensure it has access to all directories and filesystems. The smart way to do this is by using the helpful <span class="literal">sudo</span> command (run the command <span class="literal">man sudo</span> in your terminal for more details). Why is <span class="literal">sudo</span> helpful? Because it allows you to execute <em>one</em> command as root, after which you will go back to being a regular user. Each time you want to run an administrative command, you have to consciously use <span class="literal">sudo</span> to do so. Using <span class="literal">su - root</span>, by contrast, makes you root for all subsequent commands until you exit the subshell, and when you get distracted, it’s all too easy to forget you are root and type in something that can lead to disaster.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>You will have to modify the directories listed in the</em> <span class="literal"><em>find</em></span> <em>command</em> <span class="ent">➊</span> <em>to match the corresponding directories in your own disk topography.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Because this script searches across filesystems, it should be no surprise that it takes a while to run. On a large system, it could easily take somewhere between a cup of tea and a lunch with your significant other. <a href="ch05.xhtml#ch5ex2">Listing 5-2</a> details the results.</p>&#13;
<pre class="programs">$ <span class="codestrong">sudo fquota</span>&#13;
User taylor exceeds disk quota. Disk usage is: 21799.4 Mbytes</pre>&#13;
<p class="listcap"><a id="ch5ex2"/><em>Listing 5-2: Testing the</em> <span class="literal"><em>fquota</em></span> <em>script</em></p>&#13;
<p class="indent">You can see that <span class="literal">taylor</span> is way out of control with his disk usage! His 21GB definitely exceeds the 20GB per user quota.</p>&#13;
<h4 class="h4" id="ch05lev2sec05"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">A complete script of this nature should have some sort of automated email capability to warn the scofflaws that they’re hogging disk space. This enhancement is demonstrated in the very next script.</p>&#13;
<h3 class="h3" id="ch05lev1sec02"><span epub:type="pagebreak" id="page_121"/><strong>#36 Reporting Disk Hogs</strong></h3>&#13;
<p class="noindenta">Most system administrators seek the easiest way to solve a problem, and the easiest way to manage disk quotas is to extend <span class="literal">fquota</span> (<a href="ch05.xhtml#ch05lev1sec01">Script #35</a> on <a href="ch05.xhtml#page_119">page 119</a>) to issue email warnings directly to users who are consuming too much space, as shown in <a href="ch05.xhtml#ch5ex3">Listing 5-3</a>.</p>&#13;
<h4 class="h4" id="ch05lev2sec06"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # diskhogs--Disk quota analysis tool for Unix; assumes all user&#13;
   #   accounts are &gt;= UID 100. Emails a message to each violating user&#13;
   #   and reports a summary to the screen.&#13;
&#13;
   MAXDISKUSAGE=500&#13;
<span class="ent">➊</span> violators="/tmp/diskhogs0.$$"&#13;
&#13;
<span class="ent">➋</span> trap "$(which rm) -f $violators" 0&#13;
&#13;
<span class="ent">➌</span> for name in $(cut -d: -f1,3 /etc/passwd | awk -F: '$2 &gt; 99 { print $1 }')&#13;
   do&#13;
<span class="ent">➍</span>   /bin/echo -n "$name "&#13;
     # You might need to modify the following list of directories to match the&#13;
     #   layout of your disk. The most likely change is from /Users to /home.&#13;
     find / /usr /var /Users -xdev -user $name -type f -ls | \&#13;
       awk '{ sum += $7 } END { print sum / (1024*1024) }'&#13;
&#13;
   done | awk "\$2 &gt; $MAXDISKUSAGE { print \$0 }" &gt; $violators&#13;
&#13;
<span class="ent">➎</span> if [ ! -s $violators ] ; then&#13;
     echo "No users exceed the disk quota of ${MAXDISKUSAGE}MB"&#13;
     cat $violators&#13;
     exit 0&#13;
   fi&#13;
&#13;
   while read account usage ; do&#13;
&#13;
<span class="ent">➏</span>   cat &lt;&lt; EOF | fmt | mail -s "Warning: $account Exceeds Quota" $account&#13;
     Your disk usage is ${usage}MB, but you have been allocated only&#13;
     ${MAXDISKUSAGE}MB. This means that you need to delete some of your&#13;
     files, compress your files (see 'gzip' or 'bzip2' for powerful and&#13;
     easy-to-use compression programs), or talk with us about increasing&#13;
     your disk allocation.&#13;
&#13;
     Thanks for your cooperation in this matter.&#13;
&#13;
     Your afriendly neighborhood sysadmin&#13;
     EOF&#13;
&#13;
     echo "Account $account has $usage MB of disk space. User notified."&#13;
&#13;
   done &lt; $violators&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_122"/><a id="ch5ex3"/><em>Listing 5-3: The</em> <span class="literal"><em>diskhogs</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch05lev2sec07"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script uses <a href="ch05.xhtml#ch05lev1sec01">Script #35</a> as a base, with changes marked at <span class="ent">➊</span>, <span class="ent">➋</span>, <span class="ent">➍</span>, <span class="ent">➎</span>, and <span class="ent">➏</span>. Note the addition of the <span class="literal">fmt</span> command in the email pipeline at <span class="ent">➏</span>.</p>&#13;
<p class="indent">This handy trick improves the appearance of an automatically generated email when fields of unknown length, like <span class="literal">$account</span>, are embedded in the text. The logic of the <span class="literal">for</span> loop <span class="ent">➌</span> in this script is slightly different from the logic of the <span class="literal">for</span> loop in <a href="ch05.xhtml#ch05lev1sec01">Script #35</a>: because the output of the loop in this script is intended purely for the second part of the script, during each cycle, the script simply reports the account name and disk usage rather than a <span class="literal">disk quota exceeded</span> error message.</p>&#13;
<h4 class="h4" id="ch05lev2sec08"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script has no starting arguments and should be run as root for accurate results. This can most safely be accomplished by using the <span class="literal">sudo</span> command, as shown in <a href="ch05.xhtml#ch5ex4">Listing 5-4</a>.</p>&#13;
<h4 class="h4" id="ch05lev2sec09"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">sudo diskhogs</span>&#13;
Account ashley has 539.7MB of disk space. User notified.&#13;
Account taylor has 91799.4MB of disk space. User notified.</pre>&#13;
<p class="listcap"><a id="ch5ex4"/><em>Listing 5-4: Testing the</em> <span class="literal"><em>diskhogs</em></span> <em>script</em></p>&#13;
<p class="indent">If we now peek into the <span class="literal">ashley</span> account mailbox, we’ll see that a message from the script has been delivered, shown in <a href="ch05.xhtml#ch5ex5">Listing 5-5</a>.</p>&#13;
<pre class="programs">Subject: Warning: ashley Exceeds Quota&#13;
&#13;
Your disk usage is 539.7MB, but you have been allocated only 500MB. This means&#13;
that you need to delete some of your files, compress your files (see 'gzip' or&#13;
'bzip2' for powerful and easy-to-use compression programs), or talk with us&#13;
about increasing your disk allocation.&#13;
&#13;
Thanks for your cooperation in this matter.&#13;
&#13;
Your friendly neighborhood sysadmin</pre>&#13;
<p class="listcap"><a id="ch5ex5"/><em>Listing 5-5: The email sent to the</em> <span class="literal"><em>ashley</em></span> <em>user for being a disk hog</em></p>&#13;
<h4 class="h4" id="ch05lev2sec10"><span epub:type="pagebreak" id="page_123"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">A useful refinement to this script would be to allow certain users to have larger quotas than others. This could easily be accomplished by creating a separate file that defines the disk quota for each user and setting a default quota in the script for users not appearing in the file. A file with account name and quota pairs could be scanned with <span class="literal">grep</span> and the second field extracted with a call to <span class="literal">cut -f2</span>.</p>&#13;
<h3 class="h3" id="ch05lev1sec03"><strong>#37 Improving the Readability of df Output</strong></h3>&#13;
<p class="noindenta">The <span class="literal">df</span> utility output can be cryptic, but we can improve its readability. The script in <a href="ch05.xhtml#ch5ex6">Listing 5-6</a> converts the byte counts reported by <span class="literal">df</span> into more human-friendly units.</p>&#13;
<h4 class="h4" id="ch05lev2sec11"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # newdf--A friendlier version of df&#13;
&#13;
   awkscript="/tmp/newdf.$$"&#13;
&#13;
   trap "rm -f $awkscript" EXIT&#13;
&#13;
   cat &lt;&lt; 'EOF' &gt; $awkscript&#13;
   function showunit(size)&#13;
<span class="ent">➊</span> { mb = size / 1024; prettymb=(int(mb * 100)) / 100;&#13;
<span class="ent">➋</span>   gb = mb / 1024; prettygb=(int(gb * 100)) / 100;&#13;
&#13;
     if ( substr(size,1,1) !~ "[0-9]" ||&#13;
          substr(size,2,1) !~ "[0-9]" ) { return size }&#13;
     else if ( mb &lt; 1) { return size "K" }&#13;
     else if ( gb &lt; 1) { return prettymb "M" }&#13;
     else              { return prettygb "G" }&#13;
   }&#13;
&#13;
   BEGIN {&#13;
     printf "%-37s %10s %7s %7s %8s %-s\n",&#13;
           "Filesystem", "Size", "Used", "Avail", "Capacity", "Mounted"&#13;
   }&#13;
&#13;
   !/Filesystem/ {&#13;
&#13;
     size=showunit($2);&#13;
     used=showunit($3);&#13;
     avail=showunit($4);&#13;
&#13;
     printf "%-37s %10s %7s %7s %8s %-s\n",&#13;
           $1, size, used, avail, $5, $6&#13;
   }&#13;
&#13;
   EOF&#13;
&#13;
<span class="ent">➌</span> df -k | awk -f $awkscript&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_124"/><a id="ch5ex6"/><em>Listing 5-6: The</em> <span class="literal"><em>newdf</em></span> <em>script, wrapping</em> <span class="literal"><em>df</em></span> <em>so it is easier to use</em></p>&#13;
<h4 class="h4" id="ch05lev2sec12"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Much of the work in this script takes place within an <span class="literal">awk</span> script, and it wouldn’t take too big of a step to write the entire script in <span class="literal">awk</span> rather than in the shell, using the <span class="literal">system()</span> function to call <span class="literal">df</span> directly. (Actually, this script would be an ideal candidate to rewrite in Perl, but that’s outside the scope of this book.)</p>&#13;
<p class="indent">There’s also an old-school trick in this script at <span class="ent">➊</span> and <span class="ent">➋</span> that comes from programming in BASIC, of all things.</p>&#13;
<p class="indent">When working with arbitrary-precision numeric values, a quick way to limit the number of digits after the decimal is to multiply the value by a power of 10, convert it to an integer (dropping the fractional portion), and then divide it by the same power of 10: <span class="literal">prettymb=(int(mb * 100)) / 100;</span>. With this code, a value like 7.085344324 becomes a much more attractive 7.08.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Some versions of</em> <span class="literal"><em>df</em></span> <em>have an</em> <span class="literal"><em>-h</em></span> <em>flag that offers an output format similar to this script’s output format. However, as with many of the scripts in this book, this one will let you achieve friendly and more meaningful output on every Unix or Linux system, regardless of what version of</em> <span class="literal"><em>df</em></span> <em>is present.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec13"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script has no arguments and can be run by anyone, root or otherwise. To avoid reporting disk use on devices that you aren’t interested in, use <span class="literal">grep -v</span> after the call to <span class="literal">df</span>.</p>&#13;
<h4 class="h4" id="ch05lev2sec14"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Regular <span class="literal">df</span> reports are difficult to understand, as shown in <a href="ch05.xhtml#ch5ex7">Listing 5-7</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">df</span>&#13;
Filesystem                        512-blocks Used      Available Capacity Mounted on&#13;
/dev/disk0s2                      935761728  628835600 306414128 68%      /&#13;
devfs                             375        375       0         100%     /dev&#13;
map -hosts                        0          0         0         100%     /net&#13;
map auto_home                     0          0         0         100%     /home&#13;
localhost:/mNhtYYw9t5GR1SlUmkgN1E 935761728  935761728 0         100%     /Volumes/MobileBackups</pre>&#13;
<p class="listcap"><a id="ch5ex7"/><em>Listing 5-7: The default output of</em> <span class="literal"><em>df</em></span> <em>is convoluted and confusing.</em></p>&#13;
<p class="indent">The new script exploits <span class="literal">awk</span> to improve readability and knows how to convert 512-byte blocks into a more readable gigabyte format, as you can see in <a href="ch05.xhtml#ch5ex8">Listing 5-8</a>.</p>&#13;
<pre class="programs"><span epub:type="pagebreak" id="page_125"/>$ <span class="codestrong">newdf</span>&#13;
Filesystem                         Size    Used     Avail    Capacity  Mounted&#13;
/dev/disk0s2                       446.2G  299.86G  146.09G  68%       /&#13;
devfs                              187K    187K     0        100%      /dev&#13;
map -hosts                         0       0        0        100%&#13;
map auto_home                      0       0        0        100%&#13;
localhost:/mNhtYYw9t5GR1SlUmkgN1E  446.2G  446.2G   0        100%      /Volumes/MobileBackups</pre>&#13;
<p class="listcap"><a id="ch5ex8"/><em>Listing 5-8: The easier to read and understand output of</em> <span class="literal"><em>newdf</em></span></p>&#13;
<h4 class="h4" id="ch05lev2sec15"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">There are a number of gotchas in this script, not the least of which is that a lot of versions of <span class="literal">df</span> now include <span class="literal">inode</span> usage, and many also include processor internal information even though it’s really completely uninteresting (for example, the two <span class="literal">map</span> entries in the example above). In fact, this script would be far more useful if we screened those things out, so the first change you could make would be to use the <span class="literal">-P</span> flag in the call to <span class="literal">df</span> near the end of the script <span class="ent">➌</span> to remove the <span class="literal">inode</span> usage information. (You could also add it as a new column, but then the output would get even wider and harder to format.) In terms of removing things like the <span class="literal">map</span> data, that’s an easy <span class="literal">grep</span>, right? Simply add <span class="literal">|grep -v "^map"</span> at the end of <span class="ent">➊</span> and you’ll mask ’em forevermore.</p>&#13;
<h3 class="h3" id="ch05lev1sec04"><strong>#38 Figuring Out Available Disk Space</strong></h3>&#13;
<p class="noindenta">While <a href="ch05.xhtml#ch05lev1sec03">Script #37</a> simplified the <span class="literal">df</span> output to be easier to read and understand, the more basic question of how much disk space is available on the system can be addressed in a shell script. The <span class="literal">df</span> command reports disk usage on a per-disk basis, but the output can be a bit baffling:</p>&#13;
<pre class="programs">$ <span class="codestrong">df</span>&#13;
Filesystem          1K-blocks  Used     Available  Use%  Mounted on&#13;
/dev/hdb2           25695892   1871048  22519564   8%    /&#13;
/dev/hdb1           101089     6218     89652      7%    /boot&#13;
none                127744     0        127744     0%    /dev/shm</pre>&#13;
<p class="indent">A more useful version of <span class="literal">df</span> would sum the “available capacity” values in column 4 and present the sum in a human-readable format. It’s a task easily accomplished with a script using the <span class="literal">awk</span> command, as shown in <a href="ch05.xhtml#ch5ex9">Listing 5-9</a>.</p>&#13;
<h4 class="h4" id="ch05lev2sec16"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # diskspace--Summarizes available disk space and presents it in a logical&#13;
   #   and readable fashion&#13;
&#13;
   tempfile="/tmp/available.$$"&#13;
   trap "rm -f $tempfile" EXIT&#13;
&#13;
   cat &lt;&lt; 'EOF' &gt; $tempfile&#13;
       { sum += $4 }&#13;
   END { mb = sum / 1024&#13;
         gb = mb / 1024&#13;
         printf "%.0f MB (%.2fGB) of available disk space\n", mb, gb&#13;
       }&#13;
   EOF&#13;
&#13;
<span class="ent">➊</span> df -k | awk -f $tempfile&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_126"/><a id="ch5ex9"/><em>Listing 5-9: The</em> <span class="literal"><em>diskspace</em></span> <em>script, a handy wrapper with friendlier output to</em> <span class="literal"><em>df</em></span></p>&#13;
<h4 class="h4" id="ch05lev2sec17"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The <span class="literal">diskspace</span> shell script relies mainly on a temporary <span class="literal">awk</span> script that is written to the <em>/tmp</em> directory. This <span class="literal">awk</span> script calculates the total amount of disk space left using data fed to it and then prints the result in a user-friendly format. The output of <span class="literal">df</span> is then piped through <span class="literal">awk</span> <span class="ent">➊</span>, which performs the actions in the <span class="literal">awk</span> script. When execution of the script is finished, the temporary <span class="literal">awk</span> script is removed from the <em>/tmp</em> directory because of the <span class="literal">trap</span> command run at the beginning of the script.</p>&#13;
<h4 class="h4" id="ch05lev2sec18"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script, which can be run as any user, produces a succinct one-line summary of available disk space.</p>&#13;
<h4 class="h4" id="ch05lev2sec19"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">For the same system that generated the earlier <span class="literal">df</span> output, this script reports output similar to that shown in <a href="ch05.xhtml#ch5ex10">Listing 5-10</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">diskspace</span>&#13;
96199 MB (93.94GB) of available disk space</pre>&#13;
<p class="listcap"><a id="ch5ex10"/><em>Listing 5-10: Testing the</em> <span class="literal"><em>diskspace</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch05lev2sec20"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">If your system has lots of disk space across many multiterabyte drives, you might expand this script to automatically return values in terabytes as needed. If you’re just out of space, it’ll doubtlessly be discouraging to see 0.03GB of available disk space—but that’s a good incentive to use <a href="ch05.xhtml#ch05lev1sec02">Script #36</a> on <a href="ch05.xhtml#page_121">page 121</a> and clean things up, right?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_127"/>Another issue to consider is whether it’s more useful to know about the available disk space on all devices, including those partitions that cannot grow, like <em>/boot</em>, or whether it’s enough to report on just user volumes. If the latter, you can improve this script by making a call to <span class="literal">grep</span> immediately after the <span class="literal">df</span> call <span class="ent">➊</span>. Use <span class="literal">grep</span> with the desired device names to include only particular devices, or use <span class="literal">grep -v</span> followed by the unwanted device names to screen out devices you don’t want included.</p>&#13;
<h3 class="h3" id="ch05lev1sec05"><strong>#39 Implementing a Secure locate</strong></h3>&#13;
<p class="noindenta">The <span class="literal">locate</span> script, <a href="ch02.xhtml#ch02lev1sec06">Script #19</a> on <a href="ch02.xhtml#page_68">page 68</a>, is useful but has a security problem: if the build process is run as root, it builds a list of all files and directories on the entire system, regardless of owner, allowing users to see directories and filenames that they wouldn’t otherwise have permission to access. The build process can be run as a generic user (as OS X does, running <span class="literal">mklocatedb</span> as user <span class="literal">nobody</span>), but that’s not right either, because you want to be able to locate file matches anywhere in your directory tree, regardless of whether user <span class="literal">nobody</span> has access to those particular files and directories.</p>&#13;
<p class="indent">One way to solve this dilemma is to increase the data saved in the <span class="literal">locate</span> database so that each entry has an owner, group, and permissions string attached. But then the <span class="literal">mklocatedb</span> database itself remains insecure, unless the <span class="literal">locate</span> script is run as either a <span class="literal">setuid</span> or <span class="literal">setgid</span> script, and that’s something to be avoided at all costs in the interest of system security.</p>&#13;
<p class="indent">A compromise is to have a separate <em>.locatedb</em> file for each user. This isn’t too bad of an option, because a personal database is needed only for users who actually use the <span class="literal">locate</span> command. Once invoked, the system creates a <em>.locatedb</em> file in the user’s home directory, and a <span class="literal">cron</span> job can update existing <em>.locatedb</em> files nightly to keep them in sync. The very first time someone runs the secure <span class="literal">slocate</span> script, it outputs a message warning them that they may see only matches for files that are publicly accessible. Starting the very next day (depending on the <span class="literal">cron</span> schedule), the users get their personalized results.</p>&#13;
<h4 class="h4" id="ch05lev2sec21"><em><strong>The Code</strong></em></h4>&#13;
<p class="noindenta">Two scripts are necessary for a secure <span class="literal">locate</span>: the database builder, <span class="literal">mkslocatedb</span> (shown in <a href="ch05.xhtml#ch5ex11">Listing 5-11</a>) and the actual search utility, <span class="literal">slocate</span> (shown in <a href="ch05.xhtml#ch5ex12">Listing 5-12</a>).</p>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # mkslocatedb--Builds the central, public locate database as user nobody&#13;
   #   and simultaneously steps through each user's home directory to find&#13;
   #   those that contain a .slocatedb file. If found, an additional, private&#13;
   #   version of the locate database will be created for that user.&#13;
&#13;
   locatedb="/var/locate.db"&#13;
   slocatedb=".slocatedb"&#13;
&#13;
   if [ "$(id -nu)" != "root" ] ; then&#13;
     echo "$0: Error: You must be root to run this command." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ "$(grep '^nobody:' /etc/passwd)" = "" ] ; then&#13;
     echo "$0: Error: you must have an account for user 'nobody'" &gt;&amp;2&#13;
     echo "to create the default slocate database." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   cd /            # Sidestep post-su pwd permission problems.&#13;
&#13;
   # First create or update the public database.&#13;
<span class="ent">➊</span> su -fm nobody -c "find / -print" &gt; $locatedb 2&gt;/dev/null&#13;
   echo "building default slocate database (user = nobody)"&#13;
   echo ... result is $(wc -l &lt; $locatedb) lines long.&#13;
&#13;
   # Now step through the user accounts on the system to see who has&#13;
   #   a .slocatedb file in their home directory.&#13;
   for account in $(cut -d: -f1 /etc/passwd)&#13;
   do&#13;
     homedir="$(grep "^${account}:" /etc/passwd | cut -d: -f6)"&#13;
&#13;
     if [ "$homedir" = "/" ] ; then&#13;
       continue # Refuse to build one for root dir.&#13;
     elif [ -e $homedir/$slocatedb ] ; then&#13;
       echo "building slocate database for user $account"&#13;
       su -m $account -c "find / -print" &gt; $homedir/$slocatedb \&#13;
        2&gt;/dev/null&#13;
       chmod 600 $homedir/$slocatedb&#13;
       chown $account $homedir/$slocatedb&#13;
       echo ... result is $(wc -l &lt; $homedir/$slocatedb) lines long.&#13;
     fi&#13;
   done&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_128"/><a id="ch5ex11"/><em>Listing 5-11: The</em> <span class="literal"><em>mkslocatedb</em></span> <em>script</em></p>&#13;
<p class="indent">The <span class="literal">slocate</span> script itself (shown in <a href="ch05.xhtml#ch5ex12">Listing 5-12</a>) is the user interface to the <span class="literal">slocate</span> database.</p>&#13;
<pre class="programs">#!/bin/bash&#13;
# slocate--Tries to search the user's own secure locatedb database for the&#13;
#   specified pattern. If the pattern doesn't match, it means no database&#13;
#   exists, so it outputs a warning and creates one. If personal .slocatedb&#13;
#   is empty, it uses system database instead.&#13;
&#13;
locatedb="/var/locate.db"&#13;
slocatedb="$HOME/.slocatedb"&#13;
&#13;
if [ ! -e $slocatedb -o "$1" = "--explain" ] ; then&#13;
  cat &lt;&lt; "EOF" &gt;&amp;2&#13;
Warning: Secure locate keeps a private database for each user, and your&#13;
database hasn't yet been created. Until it is (probably late tonight),&#13;
I'll just use the public locate database, which will show you all&#13;
publicly accessible matches rather than those explicitly available to&#13;
account ${USER:-$LOGNAME}.&#13;
EOF&#13;
  if [ "$1" = "--explain" ] ; then&#13;
    exit 0&#13;
  fi&#13;
&#13;
  # Before we go, create a .slocatedb file so that cron will fill it&#13;
  # the next time the mkslocatedb script is run.&#13;
&#13;
  touch $slocatedb      # mkslocatedb will build it next time through.&#13;
  chmod 600 $slocatedb  # Start on the right foot with permissions.&#13;
&#13;
elif [ -s $slocatedb ] ; then&#13;
  locatedb=$slocatedb&#13;
else&#13;
  echo "Warning: using public database. Use \"$0 --explain\" for details." &gt;&amp;2&#13;
fi&#13;
&#13;
if [ -z "$1" ] ; then&#13;
  echo "Usage: $0 pattern" &gt;&amp;2&#13;
  exit 1&#13;
fi&#13;
&#13;
exec grep -i "$1" $locatedb</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_129"/><a id="ch5ex12"/><em>Listing 5-12: The</em> <span class="literal"><em>slocate</em></span> <em>script, the companion script to</em> <span class="literal"><em>mkslocatedb</em></span></p>&#13;
<h4 class="h4" id="ch05lev2sec22"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The <span class="literal">mkslocatedb</span> script revolves around the idea that a process running as root can temporarily become owned by a different user ID by using <span class="literal">su -fm <em>user</em></span> <span class="ent">➊</span>. It can then run <span class="literal">find</span> on the filesystem of each user as that user in order to create a user-specific database of filenames. Working with the <span class="literal">su</span> command proves tricky within this script, though, because by default, <span class="literal">su</span> not only wants to change the effective user ID but also wants to import the environment of the specified account. The end result is odd and confusing error messages on just about any Unix unless the <span class="literal">-m</span> flag is specified, which prevents the user environment from being imported. The <span class="literal">-f</span> flag is extra insurance, bypassing the <em>.cshrc</em> file for any <span class="literal">csh</span> or <span class="literal">tcsh</span> users.</p>&#13;
<p class="indent">The other unusual notation at <span class="ent">➊</span> is <span class="literal">2&gt;/dev/null,</span> which routes all error messages directly to the proverbial bit bucket: anything redirected to <em>/dev/null</em> vanishes without a trace. This is an easy way to skip the inevitable flood of <span class="literal">permission denied</span> error messages for each <span class="literal">find</span> function invoked.</p>&#13;
<h4 class="h4" id="ch05lev2sec23"><span epub:type="pagebreak" id="page_130"/><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">The <span class="literal">mkslocatedb</span> script is unusual in that not only must it be run as root, but using <span class="literal">sudo</span> won’t cut it. You need to either log in as root or use the more powerful <span class="literal">su</span> command to become root before running the script. This is because <span class="literal">su</span> will actually switch you to the root user in order to run the script, in contrast to <span class="literal">sudo</span>, which simply grants the current user root privileges. <span class="literal">sudo</span> can result in different permissions being set on files than <span class="literal">su</span> does. The <span class="literal">slocate</span> script, of course, has no such requirements.</p>&#13;
<h4 class="h4" id="ch05lev2sec24"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Building the <span class="literal">slocate</span> database for both <span class="literal">nobody</span> (the public database) and user <span class="literal">taylor</span> on a Linux box produces the output shown in <a href="ch05.xhtml#ch5ex13">Listing 5-13</a>.</p>&#13;
<pre class="programs"># <span class="codestrong">mkslocatedb</span>&#13;
building default slocate database (user = nobody)&#13;
... result is 99809 lines long.&#13;
building slocate database for user taylor&#13;
... result is 99808 lines long.</pre>&#13;
<p class="listcap"><a id="ch5ex13"/><em>Listing 5-13: Running the</em> <span class="literal"><em>mkslocatedb</em></span> <em>script as root</em></p>&#13;
<p class="indent">To search for a particular file or set of files that match a given pattern, let’s first try it as user <span class="literal">tintin</span> (who doesn’t have a <em>.slocatedb</em> file):</p>&#13;
<pre class="programs">tintin $ <span class="codestrong">slocate Taylor-Self-Assess.doc</span>&#13;
Warning: using public database. Use "slocate --explain" for details.&#13;
$</pre>&#13;
<p class="indent">Now we’ll enter the same command, but as user <span class="literal">taylor</span>, who owns the file being sought:</p>&#13;
<pre class="programs">taylor $ <span class="codestrong">slocate Taylor-Self-Assess.doc</span>&#13;
/Users/taylor/Documents/Merrick/Taylor-Self-Assess.doc</pre>&#13;
<h4 class="h4" id="ch05lev2sec25"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">If you have a very large filesystem, it’s possible that this approach will consume a nontrivial amount of space. One way to address this issue is to make sure that the individual <em>.slocatedb</em> database files don’t contain entries that also appear in the central database. This requires a bit more processing up front (<span class="literal">sort</span> both and then use <span class="literal">diff</span>, or simply skip <em>/usr</em> and <em>/bin</em> when searching for individual user files), but it could pay off in terms of saved space.</p>&#13;
<p class="indent">Another technique for saving space is to build the individual <em>.slocatedb</em> files with references only to files that have been accessed since the last update. This works better if the <span class="literal">mkslocatedb</span> script is run weekly rather than daily; otherwise, each Monday all users would be back to ground zero because they’d be unlikely to have run the <span class="literal">slocate</span> command over the weekend.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_131"/>Finally, another easy way to save space would be to keep the <em>.slocatedb</em> files compressed and uncompress them on the fly when they are searched with <span class="literal">slocate</span>. See the <span class="literal">zgrep</span> command in <a href="ch04.xhtml#ch04lev1sec07">Script #33</a> on <a href="ch04.xhtml#page_109">page 109</a> for inspiration regarding how to do this.</p>&#13;
<h3 class="h3" id="ch05lev1sec06"><strong>#40 Adding Users to the System</strong></h3>&#13;
<p class="noindenta">If you’re responsible for managing a network of Unix or Linux systems, you’ve already experienced the frustration caused by subtle incompatibilities among the different operating systems in your dominion. Some of the most basic administration tasks prove to be the most incompatible across different flavors of Unix, and chief among these tasks is user account management. Rather than have a single command line interface that is 100 percent consistent across all Linux flavors, each vendor has developed its own graphical interface for working with the peculiarities of its own system.</p>&#13;
<p class="indent">The Simple Network Management Protocol (SNMP) was ostensibly supposed to help normalize this sort of thing, but managing user accounts is just as difficult now as it was a decade ago, particularly in a heterogeneous computing environment. As a result, a very helpful set of scripts for a system administrator includes a version of <span class="literal">adduser</span>, <span class="literal">suspenduser</span>, and <span class="literal">deleteuser</span> that can be customized for your specific needs and then easily ported to all of your Unix systems. We’ll show you <span class="literal">adduser</span> here and cover <span class="literal">suspenduser</span> and <span class="literal">deleteuser</span> in the next two scripts.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>OS X is an exception to this rule, with its reliance on a separate user account database. To retain your sanity, just use the Mac versions of these commands and don’t try to figure out the byzantine command line access that they sort of grant administrative users.</em></p>&#13;
</div>&#13;
<p class="indent">On a Linux system, an account is created by adding a unique entry to the <em>/etc/passwd</em> file, consisting of a one- to eight-character account name, a unique user ID, a group ID, a home directory, and a login shell for that user. Modern systems store the encrypted password value in <em>/etc/shadow</em>, so a new user entry must be added to that file, too. Finally, the account needs to be listed in the <em>/etc/group</em> file, with the user either as their own group (the strategy implemented in this script) or as part of an existing group. <a href="ch05.xhtml#ch5ex14">Listing 5-14</a> shows how we can accomplish all of these steps.</p>&#13;
<h4 class="h4" id="ch05lev2sec26"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # adduser--Adds a new user to the system, including building their&#13;
   #   home directory, copying in default config data, etc.&#13;
   #   For a standard Unix/Linux system, not OS X.&#13;
&#13;
   pwfile="/etc/passwd"&#13;
   shadowfile="/etc/shadow"&#13;
   gfile="/etc/group"&#13;
   hdir="/home"&#13;
&#13;
   if [ "$(id -un)" != "root" ] ; then&#13;
     echo "Error: You must be root to run this command." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   echo "Add new user account to $(hostname)"&#13;
   /bin/echo -n "login: "     ; read login&#13;
&#13;
   # The next line sets the highest possible user ID value at 5000,&#13;
   #   but you should adjust this number to match the top end&#13;
   #   of your user ID range.&#13;
<span class="ent">➊</span> uid="$(awk -F: '{ if (big &lt; $3 &amp;&amp; $3 &lt; 5000) big=$3 } END { print big + 1 }'\&#13;
          $pwfile)"&#13;
   homedir=$hdir/$login&#13;
&#13;
   # We are giving each user their own group.&#13;
   gid=$uid&#13;
&#13;
   /bin/echo -n "full name: " ; read fullname&#13;
   /bin/echo -n "shell: "     ; read shell&#13;
&#13;
   echo "Setting up account $login for $fullname..."&#13;
&#13;
   echo ${login}:x:${uid}:${gid}:${fullname}:${homedir}:$shell &gt;&gt; $pwfile&#13;
   echo ${login}:*:11647:0:99999:7::: &gt;&gt; $shadowfile&#13;
&#13;
   echo "${login}:x:${gid}:$login" &gt;&gt; $gfile&#13;
&#13;
   mkdir $homedir&#13;
   cp -R /etc/skel/.[a-zA-Z]* $homedir&#13;
   chmod 755 $homedir&#13;
   chown -R ${login}:${login} $homedir&#13;
&#13;
   # Setting an initial password&#13;
   aexec passwd $login</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_132"/><a id="ch5ex14"/><em>Listing 5-14: The</em> <span class="literal"><em>adduser</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch05lev2sec27"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The coolest single line in this script is at <span class="ent">➊</span>. This scans through the <em>/etc/passwd</em> file to figure out the largest user ID currently in use that’s less than the highest allowable user account value (this script uses 5000, but you should adjust this for your own configuration) and then adds 1 to it for the new account user ID. This saves the admin from having to remember what the next available ID is, and it also offers a high degree of consistency in account information as the user community evolves and changes.</p>&#13;
<p class="indent">The script creates an account with this user ID. Then it creates the account’s home directory and copies into it the contents of the <em>/etc/skel</em> directory. By convention, the <em>/etc/skel</em> directory is where a master <em>.cshrc</em>, <span epub:type="pagebreak" id="page_133"/><em>.login</em>, <em>.bashrc</em>, and <em>.profile</em> are kept, and on sites where there’s a web server offering <span class="literal">~account</span> service, a directory like <em>/etc/skel/public_html</em> would also be copied across to the new home directory. This is super useful if your organization provisions Linux workstations or accounts with special bash configurations for engineers or developers.</p>&#13;
<h4 class="h4" id="ch05lev2sec28"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script must be run by root and has no starting arguments.</p>&#13;
<h4 class="h4" id="ch05lev2sec29"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Our system already has an account named <span class="literal">tintin</span>, so we’ll ensure that <span class="literal">snowy</span><sup><a id="fn_01" href="footnote.xhtml#fn01">1</a></sup> has his own account too (shown in <a href="ch05.xhtml#ch5ex15">Listing 5-15</a>).</p>&#13;
<pre class="programs">$ <span class="codestrong">sudo adduser</span>&#13;
Add new user account to aurora&#13;
login: <span class="codestrong">snowy</span>&#13;
full name: <span class="codestrong">Snowy the Dog</span>&#13;
shell: <span class="codestrong">/bin/bash</span>&#13;
Setting up account snowy for Snowy the Dog...&#13;
Changing password for user snowy.&#13;
New password:&#13;
Retype new password:&#13;
passwd: all authentication tokens updated successfully.</pre>&#13;
<p class="listcap"><a id="ch5ex15"/><em>Listing 5-15: Testing the</em> <span class="literal"><em>adduser</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch05lev2sec30"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">One significant advantage of using your own <span class="literal">adduser</span> script is that you can add code and change the logic of certain operations without worrying about an OS upgrade stepping on the modifications. Possible modifications include automatically sending a welcome email that outlines usage guidelines and online help options, automatically printing out an account information sheet that can be routed to the user, adding a <span class="literal">firstname_lastname</span> or <span class="literal">firstname.lastname</span> alias to the mail <em>aliases</em> file, or even copying a set of files into the account so that the owner can immediately begin to work on a team project.</p>&#13;
<h3 class="h3" id="ch05lev1sec07"><strong>#41 Suspending a User Account</strong></h3>&#13;
<p class="noindenta">Whether a user is being escorted off the premises for industrial espionage, a student is taking the summer off, or a contractor is going on hiatus, there are many times when it’s useful to disable an account without actually deleting it from the system.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_134"/>This can be done simply by changing the user’s password to a new value that they aren’t told, but if the user is logged in at the time, it’s also important to log them out and shut off access to that home directory from other accounts on the system. When an account is suspended, odds are very good that the user needs to be off the system <em>now</em>—not when they feel like it.</p>&#13;
<p class="indent">Much of the script in <a href="ch05.xhtml#ch5ex16">Listing 5-16</a> revolves around ascertaining whether the user is logged in, notifying the user that they are being logged off, and kicking the user off the system.</p>&#13;
<h4 class="h4" id="ch05lev2sec31"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # suspenduser--Suspends a user account for the indefinite future&#13;
&#13;
   homedir="/home"         # Home directory for users&#13;
   secs=10                 # Seconds before user is logged out&#13;
&#13;
   if [ -z $1 ] ; then&#13;
     echo "Usage: $0 account" &gt;&amp;2&#13;
     exit 1&#13;
   elif [ "$(id -un)" != "root" ] ; then&#13;
     echo "Error. You must be 'root' to run this command." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   echo "Please change the password for account $1 to something new."&#13;
   passwd $1&#13;
&#13;
   # Now let's see if they're logged in and, if so, boot 'em.&#13;
   if who|grep "$1" &gt; /dev/null ; then&#13;
&#13;
     for tty in $(who | grep $1 | awk '{print $2}'); do&#13;
&#13;
       cat &lt;&lt; "EOF" &gt; /dev/$tty&#13;
&#13;
   ******************************************************************************&#13;
   URGENT NOTICE FROM THE ADMINISTRATOR:&#13;
&#13;
   This account is being suspended, and you are going to be logged out&#13;
   in $secs seconds. Please immediately shut down any processes you&#13;
   have running and log out.&#13;
&#13;
   If you have any questions, please contact your supervisor or&#13;
   John Doe, Director of Information Technology.&#13;
   ******************************************************************************&#13;
   EOF&#13;
     done&#13;
&#13;
     echo "(Warned $1, now sleeping $secs seconds)"&#13;
&#13;
     sleep $secs&#13;
&#13;
     jobs=$(ps -u $1 | cut -d\ -f1)&#13;
&#13;
<span class="ent">➊</span>   kill -s HUP $jobs                  # Send hangup sig to their processes.&#13;
     sleep 1                            # Give it a second...&#13;
<span class="ent">➋</span>   kill -s KILL $jobs &gt; /dev/null 2&gt;1 # and kill anything left.&#13;
&#13;
     echo "$1 was logged in. Just logged them out."&#13;
   fi&#13;
&#13;
   # Finally, let's close off their home directory from prying eyes.&#13;
   chmod 000 $homedir/$1&#13;
&#13;
   echo "Account $1 has been suspended."&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_135"/><a id="ch5ex16"/><em>Listing 5-16: The</em> <span class="literal"><em>suspenduser</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch05lev2sec32"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script changes the user’s password to a value unknown to the user and then shuts off the user’s home directory. If they are logged in, we give a few seconds’ warning and then log the user out by killing all of their running processes.</p>&#13;
<p class="indent">Notice how the script sends the <span class="literal">SIGHUP</span> (<span class="literal">HUP</span>) hang-up signal to each running process <span class="ent">➊</span> and then waits a second before sending the more aggressive <span class="literal">SIGKILL</span> (<span class="literal">KILL</span>) signal <span class="ent">➋</span>. The <span class="literal">SIGHUP</span> signal quits running applications—except not <em>always</em>, and it won’t kill a login shell. The <span class="literal">SIGKILL</span> signal, however, can’t be ignored or blocked, so it’s guaranteed to be 100 percent effective. It’s not preferred, though, because it doesn’t give the application any time to clean up temporary files, flush file buffers to ensure that changes are written to disk, and so forth.</p>&#13;
<p class="indent">Unsuspending a user is a simple two-step process of opening their home directory back up (with <span class="literal">chmod 700</span>) and resetting the password to a known value (with <span class="literal">passwd</span>).</p>&#13;
<h4 class="h4" id="ch05lev2sec33"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script must be run as root, and it has one argument: the name of the account to suspend.</p>&#13;
<h4 class="h4" id="ch05lev2sec34"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">It turns out that <span class="literal">snowy</span> has already been abusing his account. Let’s suspend him, as shown in <a href="ch05.xhtml#ch5ex17">Listing 5-17</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">sudo suspenduser snowy</span>&#13;
Please change the password for account snowy to something new.&#13;
Changing password for user snowy.&#13;
New password:&#13;
Retype new password:&#13;
passwd: all authentication tokens updated successfully.&#13;
(Warned snowy, now sleeping 10 seconds)&#13;
snowy was logged in. Just logged them out.&#13;
Account snowy has been suspended.</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_136"/><a id="ch5ex17"/><em>Listing 5-17: Testing the</em> <span class="literal"><em>suspenduser</em></span> <em>script on the user</em> <span class="literal"><em>snowy</em></span></p>&#13;
<p class="indent">Since <span class="literal">snowy</span> was logged in at the time, <a href="ch05.xhtml#ch5ex18">Listing 5-18</a> shows what he saw on his screen just seconds before he was kicked off the system.</p>&#13;
<pre class="programs">******************************************************************************&#13;
URGENT NOTICE FROM THE ADMINISTRATOR:&#13;
&#13;
This account is being suspended, and you are going to be logged out&#13;
in 10 seconds. Please immediately shut down any processes you&#13;
have running and log out.&#13;
&#13;
If you have any questions, please contact your supervisor or&#13;
John Doe, Director of Information Technology.&#13;
******************************************************************************</pre>&#13;
<p class="listcap"><a id="ch5ex18"/><em>Listing 5-18: The warning printed to a user’s terminals before they are suspended</em></p>&#13;
<h3 class="h3" id="ch05lev1sec08"><strong>#42 Deleting a User Account</strong></h3>&#13;
<p class="noindenta">Deleting an account is a bit more tricky than suspending it, because the script needs to check the entire filesystem for files owned by the user before the account information is removed from <em>/etc/passwd</em> and <em>/etc/shadow</em>. <a href="ch05.xhtml#ch5ex19">Listing 5-19</a> ensures a user and their data are fully deleted from the system. It expects the previous <span class="literal">suspenduser</span> script is in the current <span class="literal">PATH</span>.</p>&#13;
<h4 class="h4" id="ch05lev2sec35"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # deleteuser--Deletes a user account without a trace.&#13;
   #   Not for use with OS X.&#13;
&#13;
   homedir="/home"&#13;
   pwfile="/etc/passwd"&#13;
   shadow="/etc/shadow"&#13;
   newpwfile="/etc/passwd.new"&#13;
   newshadow="/etc/shadow.new"&#13;
   suspend="$(which suspenduser)"&#13;
   locker="/etc/passwd.lock"&#13;
&#13;
   if [ -z $1 ] ; then&#13;
     echo "Usage: $0 account" &gt;&amp;2&#13;
     exit 1&#13;
   elif [ "$(whoami)" != "root" ] ; then&#13;
     echo "Error: you must be 'root' to run this command."&gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   $suspend $1    # Suspend their account while we do the dirty work.&#13;
&#13;
   uid="$(grep -E "^${1}:" $pwfile | cut -d: -f3)"&#13;
&#13;
   if [ -z $uid ] ; then&#13;
     echo "Error: no account $1 found in $pwfile" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # Remove the user from the password and shadow files.&#13;
   grep -vE "^${1}:" $pwfile &gt; $newpwfile&#13;
   grep -vE "^${1}:" $shadow &gt; $newshadow&#13;
&#13;
   lockcmd="$(which lockfile)"             # Find lockfile app in the path.&#13;
<span class="ent">➊</span> if [ ! -z $lockcmd ] ; then             # Let's use the system lockfile.&#13;
     eval $lockcmd -r 15 $locker&#13;
   else                                    # Ulp, let's do it ourselves.&#13;
<span class="ent">➋</span>   while [ -e $locker ] ; do&#13;
       echo "waiting for the password file" ; sleep 1&#13;
     done&#13;
<span class="ent">➌</span>   touch $locker                         # Create a file-based lock.&#13;
   fi&#13;
&#13;
   mv $newpwfile $pwfile&#13;
   mv $newshadow $shadow&#13;
<span class="ent">➍</span> rm -f $locker                           # Click! Unlocked again.&#13;
&#13;
   chmod 644 $pwfile&#13;
   chmod 400 $shadow&#13;
&#13;
   # Now remove home directory and list anything left.&#13;
   rm -rf $homedir/$1&#13;
&#13;
   echo "Files still left to remove (if any):"&#13;
   find / -uid $uid -print 2&gt;/dev/null | sed 's/^/ /'&#13;
&#13;
   echo ""&#13;
   echo "Account $1 (uid $uid) has been deleted, and their home directory "&#13;
   echo "($homedir/$1) has been removed."&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_137"/><a id="ch5ex19"/><em>Listing 5-19: The</em> <span class="literal"><em>deleteuser</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch05lev2sec36"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">To avoid anything changing in the to-be-suspended user’s account while the script is working, the very first task that <span class="literal">deleteuser</span> performs is to suspend the user account by calling <span class="literal">suspenduser</span>.</p>&#13;
<p class="indent">Before modifying the password file, this script locks it using the <span class="literal">lockfile</span> program if it’s available <span class="ent">➊</span>. Alternatively, on Linux you could also look into using the <span class="literal">flock</span> utility for creating a file lock. If not, the script drops back to a <span epub:type="pagebreak" id="page_138"/>relatively primitive semaphore locking mechanism through the creation of the file <em>/etc/passwd.lock</em>. If the lock file already exists <span class="ent">➋</span>, this script will wait for it to be deleted by another program; once it’s gone, <span class="literal">deleteuser</span> immediately creates it and proceeds <span class="ent">➌</span>, deleting it when done <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch05lev2sec37"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script must be run as root (use <span class="literal">sudo</span>) and needs the name of the account to delete as a command argument. <a href="ch05.xhtml#ch5ex20">Listing 5-20</a> shows the script being run on the user <span class="literal">snowy</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>WARNING</strong></span></p>&#13;
<p class="notep"><em>This script is irreversible and causes lots of files to vanish, so be careful if you want to experiment with it!</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec38"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">sudo deleteuser snowy</span>&#13;
Please change the password for account snowy to something new.&#13;
Changing password for user snowy.&#13;
New password:&#13;
Retype new password:&#13;
passwd: all authentication tokens updated successfully.&#13;
Account snowy has been suspended.&#13;
Files still left to remove (if any):&#13;
  /var/log/dogbone.avi&#13;
&#13;
Account snowy (uid 502) has been deleted, and their home directory&#13;
(/home/snowy) has been removed.</pre>&#13;
<p class="listcap"><a id="ch5ex20"/><em>Listing 5-20: Testing the</em> <span class="literal"><em>deleteuser</em></span> <em>script on the user</em> <span class="literal"><em>snowy</em></span></p>&#13;
<p class="indent">That sneaky <span class="literal">snowy</span> had hidden an AVI file (<em>dogbone.avi</em>) in <em>/var/log</em>. Luckily we noticed that—who knows what it could be?</p>&#13;
<h4 class="h4" id="ch05lev2sec39"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">This <span class="literal">deleteuser</span> script is deliberately incomplete. You should decide what additional steps to take—whether to compress and archive a final copy of the account files, write them to tape, back them up on a cloud service, burn them to a DVD-ROM, or even mail them directly to the FBI (hopefully we’re just kidding on that last one). In addition, the account needs to be removed from the <em>/etc/group</em> files. If there are stray files outside of the user’s home directory, the <span class="literal">find</span> command identifies them, but it’s still up to the sysadmin to examine and delete each one as appropriate.</p>&#13;
<p class="indent">Another useful addition to this script would be a dry-run mode, allowing you to see what the script would remove from the system before actually performing the user deletion.</p>&#13;
<h3 class="h3" id="ch05lev1sec09"><span epub:type="pagebreak" id="page_139"/><strong>#43 Validating the User Environment</strong></h3>&#13;
<p class="noindenta">Because people migrate their login, profile, and other shell environment customizations from one system to another, it’s not uncommon for these settings to progressively decay; eventually, the <span class="literal">PATH</span> can include directories that aren’t on the system, the <span class="literal">PAGER</span> can point to a nonexistent binary, and worse.</p>&#13;
<p class="indent">A sophisticated solution to this problem is to first check the <span class="literal">PATH</span> to ensure that it includes only valid directories on the system, and then to check each of the key helper application settings to ensure that they’re either indicating a fully qualified file that exists or are specifying a binary that’s in the <span class="literal">PATH</span>. This is detailed in <a href="ch05.xhtml#ch5ex21">Listing 5-21</a>.</p>&#13;
<h4 class="h4" id="ch05lev2sec40"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # validator--Ensures that the PATH contains only valid directories&#13;
   #   and then checks that all environment variables are valid.&#13;
   #   Looks at SHELL, HOME, PATH, EDITOR, MAIL, and PAGER.&#13;
&#13;
   errors=0&#13;
&#13;
<span class="ent">➊</span> source library.sh   # This contains <a href="ch01.xhtml#ch01lev1sec02">Script #1</a>, the in_path() function.&#13;
&#13;
<span class="ent">➋</span> validate()&#13;
   {&#13;
     varname=$1&#13;
     varvalue=$2&#13;
&#13;
     if [ ! -z $varvalue ] ; then&#13;
<span class="ent">➌</span>     if [ "${varvalue%${varvalue#?}}" = "/" ] ; then&#13;
         if [ ! -x $varvalue ] ; then&#13;
           echo "** $varname set to $varvalue, but I cannot find executable."&#13;
           (( errors++ ))&#13;
         fi&#13;
       else&#13;
         if in_path $varvalue $PATH ; then&#13;
           echo "** $varname set to $varvalue, but I cannot find it in PATH."&#13;
           errors=$(( $errors + 1 ))&#13;
         fi&#13;
       fi&#13;
     fi&#13;
   }&#13;
&#13;
   # BEGIN MAIN SCRIPT&#13;
   # =================&#13;
&#13;
<span class="ent">➍</span> if [ ! -x ${SHELL:?"Cannot proceed without SHELL being defined."} ] ; then&#13;
     echo "** SHELL set to $SHELL, but I cannot find that executable."&#13;
     errors=$(( $errors + 1 ))&#13;
   fi&#13;
   if [ ! -d ${HOME:?"You need to have your HOME set to your home directory"} ]&#13;
   then&#13;
     echo "** HOME set to $HOME, but it's not a directory."&#13;
     errors=$(( $errors + 1 ))&#13;
   fi&#13;
&#13;
   # Our first interesting test: Are all the paths in PATH valid?&#13;
&#13;
<span class="ent">➎</span> oldIFS=$IFS; IFS=":"     # IFS is the field separator. We'll change to ':'.&#13;
&#13;
<span class="ent">➏</span> for directory in $PATH&#13;
   do&#13;
     if [ ! -d $directory ] ; then&#13;
       echo "** PATH contains invalid directory $directory."&#13;
       errors=$(( $errors + 1 ))&#13;
     fi&#13;
   done&#13;
&#13;
   IFS=$oldIFS             # Restore value for rest of script.&#13;
&#13;
   # The following variables should each be a fully qualified path,&#13;
   #   but they may be either undefined or a progname. Add additional&#13;
   #   variables as necessary for your site and user community.&#13;
&#13;
   validate "EDITOR" $EDITOR&#13;
   validate "MAILER" $MAILER&#13;
   validate "PAGER"  $PAGER&#13;
&#13;
   # And, finally, a different ending depending on whether errors &gt; 0&#13;
&#13;
   if [ $errors -gt 0 ] ; then&#13;
     echo "Errors encountered. Please notify sysadmin for help."&#13;
   else&#13;
     echo "Your environment checks out fine."&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_140"/><a id="ch5ex21"/><em>Listing 5-21: The</em> <span class="literal"><em>validator</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch05lev2sec41"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The tests performed by this script aren’t overly complex. To check that all the directories in <span class="literal">PATH</span> are valid, the code steps through each directory to ensure that it exists <span class="ent">➏</span>. Notice that the internal field separator (<span class="literal">IFS</span>) had to be changed to a colon at <span class="ent">➎</span> so that the script would properly step through all of the <span class="literal">PATH</span> directories. By convention, the <span class="literal">PATH</span> variable uses a colon to separate each of its directories:</p>&#13;
<pre class="programs">$ <span class="codestrong">echo $PATH</span>&#13;
/bin/:/sbin:/usr/bin:/sw/bin:/usr/X11R6/bin:/usr/local/mybin</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_141"/>To validate that the environment variable values are valid, the <span class="literal">validate()</span> function <span class="ent">➋</span> first checks whether each value begins with a <span class="literal">/</span>. If it does, the function checks whether the variable is an executable. If it doesn’t begin with a <span class="literal">/</span>, the script calls the <span class="literal">in_path()</span> function imported from the library we started with <a href="ch01.xhtml#ch01lev1sec02">Script #1</a> on <a href="ch01.xhtml#page_11">page 11</a> <span class="ent">➊</span> to see whether the program is found in one of the directories in the current <span class="literal">PATH</span>.</p>&#13;
<p class="indent">The most unusual aspects of this script are its use of default values within some of the conditionals and its use of variable slicing. Its use of default values in the conditionals is exemplified by the line at <span class="ent">➍</span>. The notation <span class="literal">${<em>varname</em>:?"<em>errorMessage</em>"}</span> can be read as “If <span class="literal"><em>varname</em></span> exists, substitute its value; otherwise, fail with the error <span class="literal"><em>errorMessage</em></span>.”</p>&#13;
<p class="indent">The variable-slicing notation <span class="literal">${varvalue%${varvalue#?}}</span> used at <span class="ent">➌</span> is the POSIX substring function, and it produces only the first character of the variable <span class="literal">varvalue</span>. In this script, it’s used to tell whether an environment variable has a fully qualified filename (one starting with <span class="literal">/</span> and specifying the path to the binary).</p>&#13;
<p class="indent">If your version of Unix/Linux doesn’t support either of these notations, they can be replaced in a straightforward fashion. For example, instead of <span class="literal">${SHELL:?No Shell}</span>, you could substitute the following:</p>&#13;
<pre class="programs">if [ -z "$SHELL" ] ; then&#13;
  echo "No Shell" &gt;&amp;2; exit 1&#13;
fi</pre>&#13;
<p class="indent">And instead of <span class="literal">{varvalue%${varvalue#?}}</span>, you could use this code to accomplish the same result:</p>&#13;
<pre class="programs">$(echo $varvalue | cut -c1)</pre>&#13;
<h4 class="h4" id="ch05lev2sec42"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This is code that users can run to check their own environment. There are no starting arguments, as <a href="ch05.xhtml#ch5ex22">Listing 5-22</a> shows.</p>&#13;
<h4 class="h4" id="ch05lev2sec43"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">validator</span>&#13;
** PATH contains invalid directory /usr/local/mybin.&#13;
** MAILER set to /usr/local/bin/elm, but I cannot find executable.&#13;
Errors encountered. Please notify sysadmin for help.</pre>&#13;
<p class="listcap"><a id="ch5ex22"/><em>Listing 5-22: Testing the</em> <span class="literal"><em>validator</em></span> <em>script</em></p>&#13;
<h3 class="h3" id="ch05lev1sec10"><strong>#44 Cleaning Up After Guests Leave</strong></h3>&#13;
<p class="noindenta">Although many sites disable the <span class="literal">guest</span> user for security reasons, others do have a guest account (often with a trivially guessable password) to allow clients or people from other departments to access the network. It’s a useful <span epub:type="pagebreak" id="page_142"/>account, but there’s one big problem: with multiple people sharing the same account, it’s easy for someone to leave things messed up for the next user—maybe they were experimenting with commands, editing <em>.rc</em> files, adding subdirectories, or so forth.</p>&#13;
<p class="indent">This script in <a href="ch05.xhtml#ch5ex23">Listing 5-23</a> addresses the problem by cleaning up the account space each time a user logs out of the guest account. It deletes any newly created files or subdirectories, removes all dotfiles, and rebuilds the official account files, copies of which are stored in a read-only archive tucked away in the guest account’s <em>.template</em> directory.</p>&#13;
<h4 class="h4" id="ch05lev2sec44"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">#!/bin/bash&#13;
&#13;
# fixguest--Cleans up the guest account during the logout process&#13;
&#13;
# Don't trust environment variables: reference read-only sources.&#13;
&#13;
iam=$(id -un)&#13;
myhome="$(grep "^${iam}:" /etc/passwd | cut -d: -f6)"&#13;
&#13;
# *** Do NOT run this script on a regular user account!&#13;
&#13;
if [ "$iam" != "guest" ] ; then&#13;
  echo "Error: you really don't want to run fixguest on this account." &gt;&amp;2&#13;
  exit 1&#13;
fi&#13;
&#13;
if [ ! -d $myhome/..template ] ; then&#13;
  echo "$0: no template directory found for rebuilding." &gt;&amp;2&#13;
  exit 1&#13;
fi&#13;
&#13;
# Remove all files and directories in the home account.&#13;
&#13;
cd $myhome&#13;
&#13;
rm -rf * $(find . -name ".[a-zA-Z0-9]*" -print)&#13;
&#13;
# Now the only thing present should be the ..template directory.&#13;
&#13;
cp -Rp ..template/* .&#13;
exit 0</pre>&#13;
<p class="listcap"><a id="ch5ex23"/><em>Listing 5-23: The</em> <span class="literal"><em>fixguest</em></span> <em>script</em></p>&#13;
<h4 class="h4" id="ch05lev2sec45"><span epub:type="pagebreak" id="page_143"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">For this script to work correctly, you’ll want to create a master set of template files and directories within the guest home directory, tucked into a new directory called <em>..template</em>. Change the permissions of the <em>..template</em> directory to be read-only and then ensure that all the files and directories within <em>..template</em> have the proper ownership and permissions for user <span class="literal">guest</span>.</p>&#13;
<h4 class="h4" id="ch05lev2sec46"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">A logical time to run the <span class="literal">fixguest</span> script is at logout, by invoking it in the <em>.logout</em> file (which works with most shells, though not all). Also, it’ll doubtless save you lots of complaints from users if the <span class="literal">login</span> script outputs a message like this one:</p>&#13;
<pre class="programs">Notice: All files are purged from the guest account immediately&#13;
upon logout, so please don't save anything here you need. If you&#13;
want to save something, email it to your main account instead.&#13;
You've been warned!</pre>&#13;
<p class="indent">However, because some guest users might be savvy enough to tinker with the <em>.logout</em> file, it would be worthwhile to invoke the <span class="literal">fixguest</span> script from <span class="literal">cron</span> too. Just make sure no one is logged into the account when it runs!</p>&#13;
<h4 class="h4" id="ch05lev2sec47"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">There are no visible results from running this program, except that the <span class="literal">guest</span> home directory is restored to mirror the layout and files in the ..<em>template</em> directory.<span epub:type="pagebreak" id="page_144"/></p>&#13;
</body></html>