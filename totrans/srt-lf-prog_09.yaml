- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9'
- en: THE WEB BROWSER**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网页浏览器**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: You probably don’t think of it this way, but the web browser you use every day
    is a *virtual machine*—an abstract computer with an incredibly complicated instruction
    set implemented entirely in software. In other words, it’s one of those interpreters
    you learned about in the last chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没这样想过，但你每天使用的网页浏览器实际上是一个*虚拟机*——一个具有极其复杂指令集的抽象计算机，完全通过软件实现。换句话说，它就是你在上一章学到的那种解释器。
- en: In this chapter, you’ll learn about some of the functionality of this virtual
    machine. You’ll learn about the input language and how it’s interpreted by the
    browser. Browsers are extremely complicated beasties, however, so I can’t cover
    every feature.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习到一些关于这个虚拟机的功能。你将了解输入语言以及浏览器如何解析它。浏览器是极其复杂的东西，因此我无法覆盖所有功能。
- en: One thing that makes browsers interesting to learn about is that, on one hand,
    they’re big, complex applications, and on the other, they’re software-implemented
    computers that you can program. Browsers have a *developer console*, which you
    can use while playing with the examples from this chapter. This allows you to
    get a real-time view of how the browser operates.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让浏览器变得有趣的一点是，它们一方面是庞大而复杂的应用程序，另一方面，它们是你可以编程的软件实现的计算机。浏览器有一个*开发者控制台*，你可以在使用本章示例时通过它来查看浏览器的实时操作。
- en: Understanding the web browser also teaches us something about system design,
    which is arguably more important than programming ([Chapter 15](ch15.xhtml#ch15)
    covers system design in more detail). The popularity of the web has turned the
    browser into a magnet for new features. Many of these features have extended browser
    functionality in a compatible manner by adding to the original instruction set.
    Other features have duplicated existing functionality in incompatible ways, the
    result being that browsers now support multiple instruction sets, and the complete
    set of features is not available in any of them. It should become clear in this
    chapter that I’m not thrilled by the latter category of features—those that are
    merely different instead of adding value.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 了解网页浏览器也教会我们一些关于系统设计的知识，而系统设计可能比编程更为重要（[第15章](ch15.xhtml#ch15)更详细地讲解了系统设计）。网页的流行使得浏览器成为新功能的吸引力源。这些功能中的许多通过向原始指令集添加扩展来兼容地扩展浏览器功能。还有一些功能以不兼容的方式重复了现有功能，结果是浏览器现在支持多个指令集，并且在任何一个浏览器中都无法获得完整的功能集。在本章中你应该能清楚地看到，我对后者类别的功能并不感到兴奋——那些只是不同而没有增加价值的功能。
- en: For starters, having multiple ways to do things means you as a programmer have
    a lot more to learn, which isn’t a great use of your time for features that don’t
    add value. And you need to expend energy choosing which way to do your code. Adding
    multiple approaches also increases the complexity of programs. Industry statistics
    show a direct relationship between the amount of code in a program and the number
    of bugs. Browsers crash often. And, as [Chapter 13](ch13.xhtml#ch13) covers in
    more detail, more complex code is more likely to contain security problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，拥有多种方式做事意味着作为程序员的你需要学习更多的内容，而这些功能并没有增加价值，因此这并不是一个很好的时间利用。而且你需要花费精力选择该采用哪种方式来编写代码。增加多种方法也增加了程序的复杂性。行业统计数据显示，程序中代码的数量与程序中的错误数量之间有直接关系。浏览器经常崩溃。而且，正如[第13章](ch13.xhtml#ch13)更详细讨论的那样，更复杂的代码更容易包含安全问题。
- en: 'Incompatible ways of doing things makes programmers more prone to errors. It’s
    like an American driving a car in New Zealand: some of the controls are in different
    places because New Zealanders drive on the left-hand side of the road. People
    from countries where you drive on the right are easy to spot, as they turn on
    their windshield wipers when making a turn. You don’t want to program in an environment
    that facilitates these sorts of avoidable errors.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以不兼容的方式做事让程序员更容易出错。这就像一个美国人在新西兰开车：由于新西兰人是左侧行驶，部分控制按钮的位置不同。来自右侧行驶国家的人很容易被认出来，因为他们在转弯时会打开挡风玻璃雨刷。你不希望在一个容易造成这些可避免错误的环境中进行编程。
- en: In my opinion, the fact that many of the web standards have become *living documents*
    is a clear sign of trouble. If you’re not familiar with that term, I’m referring
    to online documents that are constantly being updated. Standards exist to provide
    stability and interoperability. Living documents don’t; at best, they capture
    a moment in time. It’s difficult to program to constantly changing specifications.
    In this context, living documents make life easier for a few document creators
    (because those documents and the software that they reference never have to be
    “done”) and more difficult for a much larger number of consumers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，许多网络标准已经成为 *活文档* 这一事实，明显表明了问题的存在。如果你不熟悉这个术语，我指的是那些不断更新的在线文档。标准的存在是为了提供稳定性和互操作性，而活文档则不是；充其量，它们只捕捉了一个特定时刻。随着规格不断变化，很难进行编程。在这种情况下，活文档让少数文档创作者的生活变得更轻松（因为这些文档和它们所引用的软件永远不需要“完成”），但却使更多消费者的生活变得更困难。
- en: '**Markup Languages**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**标记语言**'
- en: 'Had this book been written 15 years earlier, this chapter would have started
    with an introduction to HTML, the HyperText Markup Language. But, as I’ve already
    implied, the browser has a lot in common with the Great Pacific Garbage Patch:
    it keeps getting bigger by attracting features that stick to it. Among these are
    multiple markup languages, so we’ll begin with an overview of them.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这本书是在 15 年前写的，本章将以对 HTML（超文本标记语言）的介绍开始。但正如我之前提到的，浏览器与太平洋垃圾带有很多相似之处：它通过吸引附着在其上的功能不断膨胀。其中之一就是多种标记语言，所以我们将从它们的概述开始。
- en: '*Markup* is a system for annotating or adding marks to text in a way that can
    be distinguished from that text—like homework that a teacher has written snarky
    comments in red pencil on.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*标记* 是一种为文本添加注释或标记的系统，这些标记与文本本身区分开来——就像老师在作业上用红色铅笔写的刻薄评论。'
- en: Markup languages are not new; they existed long before computers. They were
    developed as a side effect of the printing press so that authors and editors could
    describe what they wanted to the “pressmen” who set the type. This useful notion
    was carried forward when computers automated typesetting. Today’s markup languages
    are just the latest incarnations of an old idea.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 标记语言并不新鲜；它们在计算机出现之前就已经存在。它们是印刷机的副产品，旨在帮助作者和编辑向“排版工”描述他们想要的内容。当计算机自动化排版时，这一有用的概念得以延续。今天的标记语言只是这一古老思想的最新表现。
- en: There are a large number of markup languages. For example, I originally wrote
    this book in a markup language for typesetting called `troff`. The source for
    this paragraph is shown in [Listing 9-1](ch09.xhtml#ch09list01).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 标记语言的种类繁多。例如，我最初是用一种名为 `troff` 的排版标记语言写这本书的。此段落的源代码如 [清单 9-1](ch09.xhtml#ch09list01)
    所示。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: troff for the preceding paragraph*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-1：上述段落的 troff 示例*'
- en: As you can see, most of it is just the text, but there are three elements of
    markup. The `.PP` tells `troff` to start a paragraph. The `\fC` tells `troff`
    to push the current font onto a stack and replace it with font `C`, for Courier.
    The `\fP` tells `troff` to pop the font stack (see “[Stacks](ch05.xhtml#ch05lev1sec3)”
    on [page 122](ch05.xhtml#page_122)), which restores the previous font.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，大部分内容只是文本，但其中有三个标记元素。`.PP` 告诉 `troff` 开始一个段落。`\fC` 告诉 `troff` 将当前字体推入堆栈，并用字体
    `C`（即 Courier 字体）替换它。`\fP` 告诉 `troff` 弹出字体堆栈（参见 [“堆栈”](ch05.xhtml#ch05lev1sec3)
    在 [第122页](ch05.xhtml#page_122)），恢复先前的字体。
- en: Web pages are regular text files, just like the `troff` example. You don’t need
    a fancy program to create them; you can do it in any text editor. As a matter
    of fact, fancy web page creation programs produce bloated results that you can
    easily beat by handcrafting them yourself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网页是常规的文本文件，就像 `troff` 示例一样。你不需要复杂的程序来创建它们；你可以在任何文本编辑器中完成。事实上，复杂的网页创建程序会产生冗余的结果，而你完全可以通过手工制作来轻松超越它们。
- en: How do you mark up a regular text file when the only tool available is more
    text? By giving superpowers to some characters, the way Superman has superpowers
    even though he’s also a mild-mannered reporter. For example, `troff` gives superpowers
    to any line that begins with a `.` or `'` and to anything that begins with a `\`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当唯一可用的工具还是更多文本时，你如何对常规文本文件进行标记？通过赋予某些字符超级能力，就像超人即使是一个温文尔雅的记者，也拥有超能力一样。例如，`troff`
    赋予任何以 `.` 或 `'` 开头的行以及任何以 `\` 开头的内容超级能力。
- en: IBM rolled its own markup language, called *GML* (short for *Generalized Markup
    Language*, though it’s really named for its developers, Goldfarb, Mosher, and
    Lorie), which the company used for its ISIL publishing tool. This work was expanded
    into the *Standard Generalized Markup Language (SGML)*, which was adopted by the
    International Standards Organization in the 1980s. SGML was so “generalized” that
    it’s not clear that anybody was ever able to produce a complete working implementation
    of the standard.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: IBM推出了自家标记语言，名为*GML*（即*通用标记语言*的缩写，尽管它实际上是为其开发者Goldfarb、Mosher和Lorie命名的），该公司用于其ISIL出版工具。这项工作后来扩展为*标准通用标记语言（SGML）*，并在1980年代被国际标准化组织采纳。SGML如此“通用”，以至于尚不清楚是否有人能够完全实现该标准。
- en: '*eXtensible Markup Language (XML)* is a more practical subset of SGML. Support
    for it was a later addition to browsers.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*可扩展标记语言（XML）*是SGML的一个更实用的子集。浏览器对其的支持是后来的新增功能。'
- en: HTML and XML both have their roots in SGML. They borrow some of the same syntax
    but don’t conform to the standard.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HTML和XML都源自SGML。它们借用了相同的语法，但并不完全符合标准。
- en: XHTML is a modified form of HTML that conforms to the XML rules.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: XHTML是符合XML规则的HTML修改版。
- en: '**Uniform Resource Locators**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**统一资源定位符**'
- en: The first web browser (called WorldWideWeb), invented by English engineer and
    computer scientist Sir Tim Berners-Lee in 1990, was pretty straightforward in
    how it worked, as shown in [Figure 9-1](ch09.xhtml#ch09fig01). The browser used
    a *Uniform Resource Locator (URL)* to request a document from a server using the
    HTTP protocol discussed in “[The World Wide Web](ch06.xhtml#ch06lev3sec4)” on
    [page 159](ch06.xhtml#page_159). The server sent the document to the browser,
    which would display it. The document used to be written in HTML, but now it can
    be written in a variety of languages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个网页浏览器（名为WorldWideWeb），由英国工程师兼计算机科学家蒂姆·伯纳斯-李爵士于1990年发明，其工作方式相当直接，如[图9-1](ch09.xhtml#ch09fig01)所示。浏览器使用*统一资源定位符（URL）*通过HTTP协议从服务器请求文档，HTTP协议在“[万维网](ch06.xhtml#ch06lev3sec4)”一节中讨论过，见[第159页](ch06.xhtml#page_159)。服务器将文档发送给浏览器，浏览器显示文档。文档曾经是用HTML编写的，但现在可以用多种语言编写。
- en: '![Image](../images/09fig01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig01.jpg)'
- en: '*Figure 9-1: Web browser interaction with web server*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：网页浏览器与网页服务器的交互*'
- en: URLs are text strings that have some structure. Right now we just care about
    the three parts of that structure shown in [Figure 9-2](ch09.xhtml#ch09fig02).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: URL是具有一定结构的文本字符串。现在我们只关心结构中的三个部分，如[图9-2](ch09.xhtml#ch09fig02)所示。
- en: '![Image](../images/09fig02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig02.jpg)'
- en: '*Figure 9-2: Anatomy of a URL*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：URL的结构*'
- en: The *scheme* indicates the communication mechanism—for example, `https` selects
    HyperText Transfer Protocol (Secure). The server that we want to communicate with
    is the *host*. It can be a numeric internet address (see “[IP Addresses](ch06.xhtml#ch06lev3sec2)”
    on [page 159](ch06.xhtml#page_159)) but is most commonly specified as a domain
    name (see “[Domain Name System](ch06.xhtml#ch06lev3sec3)” on [page 159](ch06.xhtml#page_159)).
    The location of the document to be retrieved is the *path*, which looks just like
    a filesystem path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*方案*表示通信机制——例如，`https`选择超文本传输协议（安全）。我们想要通信的服务器是*主机*。它可以是数字互联网地址（参见“[IP地址](ch06.xhtml#ch06lev3sec2)”在[第159页](ch06.xhtml#page_159)）但最常见的是作为域名指定（参见“[域名系统](ch06.xhtml#ch06lev3sec3)”在[第159页](ch06.xhtml#page_159)）。要检索的文档位置是*路径*，它看起来就像文件系统路径。'
- en: One of the schemes is `file`. When it’s used, the host/path portion of the URL
    is a local filename—the name of a file on the same system on which the browser
    is running. In other words, the `file` scheme points to a file on your computer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方案是`file`。当它被使用时，URL中的主机/路径部分是本地文件名——即浏览器运行所在系统上的文件名。换句话说，`file`方案指向你计算机上的文件。
- en: There are an ever-growing number of schemes, such as `bitcoin` for cryptocurrencies
    and `tv` for television broadcasts. These are similar, and in many cases identical,
    to the protocols that we saw back in “[The World Wide Web](ch06.xhtml#ch06lev3sec4).”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有越来越多的方案，如`bitcoin`用于加密货币，`tv`用于电视广播。这些方案与我们在“[万维网](ch06.xhtml#ch06lev3sec4)”一节中看到的协议非常相似，甚至在很多情况下是相同的。
- en: '**HTML Documents**'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**HTML文档**'
- en: 'As mentioned, the first web pages were documents written in HTML. HTML utilized
    *hypertext*—text that links to something else, such as other web pages. Sci-fi
    buffs can think of it like combining hyperspace with text: you hit a link and,
    *zap*, you’re someplace else. Hypertext has been around for quite some time, but
    the web was its compelling application.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，最早的网页是用HTML编写的文档。HTML利用了*超文本*—即链接到其他内容的文本，例如其他网页。科幻迷可以把它看作是将超空间与文本结合：你点击一个链接，*嗖*，你就到了另一个地方。超文本已经存在了一段时间，但网络是它最具吸引力的应用。
- en: Take a look at the simple HTML document in [Listing 9-2](ch09.xhtml#ch09list02).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看看[清单9-2](ch09.xhtml#ch09list02)中的简单HTML文档。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-2: My First Web Page*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-2：我的第一个网页*'
- en: Enter the HTML shown in [Listing 9-2](ch09.xhtml#ch09list02) into a file and
    open it in your browser. You should see something like [Figure 9-3](ch09.xhtml#ch09fig03).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单9-2](ch09.xhtml#ch09list02)中的HTML代码输入到一个文件中，并在浏览器中打开。你应该会看到类似于[图9-3](ch09.xhtml#ch09fig03)的内容。
- en: '![Image](../images/09fig03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig03.jpg)'
- en: '*Figure 9-3: Browser display of My First Web Page*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：浏览器显示我的第一个网页*'
- en: You can see that the display in [Figure 9-3](ch09.xhtml#ch09fig03) doesn’t look
    much like the text in [Listing 9-2](ch09.xhtml#ch09list02). That’s because the
    less-than sign (`<`) is a character with superpowers. In this case, it begins
    an *element* of markup. You might notice that elements come in pairs; for each
    start `<tag>` there is a matching end `</tag>`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，[图9-3](ch09.xhtml#ch09fig03)中的显示内容看起来与[清单9-2](ch09.xhtml#ch09list02)中的文本不太一样。这是因为小于号（`<`）是一个具有超能力的字符。在这种情况下，它开始了一个*元素*的标记。你可能会注意到，元素是成对出现的；每个开始的`<tag>`都有一个匹配的结束`</tag>`。
- en: The tag determines how the browser interprets the markup element. Tags are essentially
    virtual machine instructions. For example, `<title>` puts its contents—what’s
    between the start and end tags—into the browser title bar. The `<b>` and `<big>`
    elements make the word “Cool!” bold and big, and it’s part of the `<body>` of
    the web page.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 标签决定了浏览器如何解释标记元素。标签本质上是虚拟机指令。例如，`<title>`将其内容—即开始和结束标签之间的内容—显示到浏览器的标题栏中。`<b>`和`<big>`元素将单词“Cool!”变为粗体和大号，它是网页的`<body>`部分的一部分。
- en: Because the `<` has superpowers, you may wonder how to use that character without
    the superpowers—for example, if you wanted to display `This is my first web page
    with a <`. HTML includes its own form of kryptonite called an *entity reference*,
    which is an alternate form of a character. In this case, the sequence `&lt;` represents
    the `<` character without triggering its superpowers. (Of course, now there’s
    a new superpowered character `&`, which can itself be represented using the `&amp;`
    sequence.) Using an entity reference, you could type `This is my first web page
    with a &lt;` and it would look correct.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`<`具有超能力，你可能会想知道如何使用这个字符而不触发它的超能力——例如，如果你想显示`This is my first web page with
    a <`。HTML包含了它自己的一种克星，称为*实体引用*，它是字符的替代形式。在这种情况下，序列`&lt;`表示小于号（`<`）字符，而不会触发其超能力。（当然，现在有了一个新的超级字符`&`，它本身可以使用`&amp;`序列表示。）使用实体引用，你可以输入`This
    is my first web page with a &lt;`，它看起来就正确了。
- en: HTML elements aren’t quite as simple. There are a number of random exceptions
    where end tags are not required, and there’s a `<tag/>` form for elements with
    no content. XHTML eliminates these exceptions. The only complication that we care
    about here is *attributes*, which are optional sets of name/value pairs, as shown
    in [Listing 9-3](ch09.xhtml#ch09list03).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: HTML元素并不完全简单。有一些随机的例外情况，其中不需要结束标签，而且对于没有内容的元素，有一种`<tag/>`的形式。XHTML消除了这些例外。我们这里关心的唯一复杂问题是*属性*，即一组可选的名称/值对，如[清单9-3](ch09.xhtml#ch09list03)所示。
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-3: HTML elements with attributes*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-3：带有属性的HTML元素*'
- en: Some attribute `names` have predefined behaviors; you can include arbitrary
    attributes for any that aren’t predefined. Attribute values are treated identically,
    with the exception of `class`, whose value is treated as a space-separated list
    of values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性`名称`有预定义的行为；对于那些没有预定义行为的，你可以包含任意的属性值。属性值的处理方式是相同的，唯一例外的是`class`，它的值被视为一个由空格分隔的值列表。
- en: '**The Document Object Model**'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文档对象模型**'
- en: Web browsers process documents according to the *Document Object Model (DOM)*.
    You can think of a web page as a series of elements that enclose other elements
    as illustrated by the indentation in the [Listing 9-2](ch09.xhtml#ch09list02)
    HTML. [Figure 9-4](ch09.xhtml#ch09fig04), which looks sort of like an aerial cutaway
    view of a twisted *matryoshka* (Russian nesting) doll, shows what this structure
    looks like for the code in [Listing 9-2](ch09.xhtml#ch09list02).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Web 浏览器根据 *文档对象模型（DOM）* 来处理文档。你可以把网页看作一系列包含其他元素的元素，如[列表 9-2](ch09.xhtml#ch09list02)中的
    HTML 所示的缩进所示。[图 9-4](ch09.xhtml#ch09fig04)，看起来有点像一个扭曲的*俄罗斯套娃*（matryoshka）的航拍剖面图，展示了[列表
    9-2](ch09.xhtml#ch09list02)中的代码结构。
- en: '![Image](../images/09fig04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig04.jpg)'
- en: '*Figure 9-4: Nested elements in an HTML document*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：HTML 文档中的嵌套元素*'
- en: Let’s grab that picture by the edge of the HTML and tilt it so that all of the
    innards hang out the bottom, as shown in [Figure 9-5](ch09.xhtml#ch09fig05).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将图片从 HTML 边缘抓取并倾斜，使得所有内部部分悬挂在底部，如[图 9-5](ch09.xhtml#ch09fig05)所示。
- en: Look familiar? It’s our old friend, the directed acyclic graph, or DAG (from
    “[Stacks](ch05.xhtml#ch05lev1sec3)” on [page 122](ch05.xhtml#page_122)), and a
    tree structure too (see “[Hierarchical Data Structures](ch07.xhtml#ch07lev1sec11)”
    on [page 199](ch07.xhtml#page_199)). Not only that, but the HTML can be processed
    using techniques from [Chapter 8](ch08.xhtml#ch08) and the result is a parse tree
    (see “[Parse Trees](ch08.xhtml#ch08lev1sec7)” on [page 228](ch08.xhtml#page_228)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来熟悉吗？它是我们的老朋友，定向无环图（DAG），来自“[栈](ch05.xhtml#ch05lev1sec3)”章节中的[第122页](ch05.xhtml#page_122)，也是一种树形结构（参见“[层级数据结构](ch07.xhtml#ch07lev1sec11)”章节中的[第199页](ch07.xhtml#page_199)）。不仅如此，HTML
    可以通过[第8章](ch08.xhtml#ch08)中的技术进行处理，结果是一个解析树（参见“[解析树](ch08.xhtml#ch08lev1sec7)”章节中的[第228页](ch08.xhtml#page_228)）。
- en: '![Image](../images/09fig05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig05.jpg)'
- en: '*Figure 9-5: HTML document as a tree structure*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：HTML 文档作为树形结构*'
- en: '***Tree Lexicon***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***树形词汇表***'
- en: Tree structures like the DOM are so common that an entire lexicon has developed
    around them. The examples in [Table 9-1](ch09.xhtml#ch09tab01) are taken from
    [Figure 9-5](ch09.xhtml#ch09fig05).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 像 DOM 这样的树形结构非常常见，已经形成了完整的词汇表。表[9-1](ch09.xhtml#ch09tab01)中的例子来自[图 9-5](ch09.xhtml#ch09fig05)。
- en: '**Table 9-1:** Tree Lexicon'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 树形词汇表'
- en: '| **Term** | **Definition** | **Example** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **术语** | **定义** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Node | An element in the tree | `html`, `head`, `body` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 节点 | 树中的一个元素 | `html`、`head`、`body` |'
- en: '| Interior node | An element in the tree that has arrows entering and leaving
    | `title` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 内部节点 | 树中有箭头进出其内部的元素 | `title` |'
- en: '| Terminal node | An element in the tree that has no arrows leaving it | `Cool!`
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 终端节点 | 树中没有箭头指向其他节点的元素 | `Cool!` |'
- en: '| Root | The top of the tree | `html` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 根节点 | 树的顶部 | `html` |'
- en: '| Parent | A node whose arrow points directly to another node | `html` is the
    parent of `head` and `body` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 父节点 | 其箭头直接指向其他节点的节点 | `html` 是 `head` 和 `body` 的父节点 |'
- en: '| Child | A node directly pointed to by another node | `head` and `body` are
    children of `html` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 子节点 | 直接由其他节点指向的节点 | `head` 和 `body` 是 `html` 的子节点 |'
- en: '| Descendant | A node directly or indirectly pointed to by another node | `title`
    is a descendent of `html` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 后代节点 | 直接或间接被其他节点指向的节点 | `title` 是 `html` 的后代节点 |'
- en: '| Ancestor | A node that directly or indirectly points to a node | `body` is
    an ancestor of `big` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 祖先节点 | 直接或间接指向某节点的节点 | `body` 是 `big` 的祖先节点 |'
- en: '| Sibling | A node with a common parent | `head` is a sibling of `body` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 同级节点 | 有共同父节点的节点 | `head` 是 `body` 的同级节点 |'
- en: Nodes in a tree are ordered. For example, `head` is the first child of `html`,
    and `body` is the second and also last child of `html`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 树中的节点是有序的。例如，`head` 是 `html` 的第一个子节点，`body` 是 `html` 的第二个并且也是最后一个子节点。
- en: '***Interpreting the DOM***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解释 DOM***'
- en: What does a browser do with a document tree? Although it’s possible that someone
    could build a piece of computing hardware with instructions corresponding to the
    HTML elements, nobody has done so yet. That rules out compiling the DOM parse
    tree into machine language. The other choice is to interpret it using *depth-first
    traversal*, as shown in [Figure 9-6](ch09.xhtml#ch09fig06).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器如何处理文档树？虽然有人可能构建了与 HTML 元素对应的计算硬件指令，但至今没有人这么做过。这排除了将 DOM 解析树编译为机器语言的可能。另一种选择是使用*深度优先遍历*来解释它，如[图
    9-6](ch09.xhtml#ch09fig06)所示。
- en: '![Image](../images/09fig06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig06.jpg)'
- en: '*Figure 9-6: HTML document traversal order*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：HTML 文档遍历顺序*'
- en: As you can see, the browser starts at the root, descends to the first child,
    then to its first child, and so on until it hits a terminal node. It then goes
    up to the closest ancestor that has another child and does the same thing from
    there, and so on until every node in the tree is visited. Note that the ordering
    follows the way in which the HTML is written. Depth-first traversal is yet another
    application of stacks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，浏览器从根节点开始，下降到第一个子节点，然后到它的第一个子节点，依此类推，直到到达终端节点。然后它会回到最近的有其他子节点的祖先节点，并从那里开始做同样的事情，直到树中的每个节点都被访问。请注意，遍历顺序遵循
    HTML 的书写方式。深度优先遍历是栈的又一应用。
- en: '**Cascading Style Sheets**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**层叠样式表**'
- en: An original idea behind HTML was that authors wrote web pages and browsers figured
    out how to display them. This made sense because there was no way for the author
    to know things like the size of a browser’s window, the screen resolution, or
    the number of available colors and fonts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 的原始理念是，作者编写网页，而浏览器负责确定如何显示这些页面。这是合理的，因为作者无法知道浏览器窗口的大小、屏幕分辨率或可用的颜色和字体数量。
- en: Once the web became popular, the marketing types got their hands on it. Glitz
    became important. All sorts of stuff got added (mostly via the creation of a new
    CSS specification) to allow authors to finely control how their pages are displayed.
    Of course, this is exactly the opposite of the original intent. The result is
    messy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦网络变得流行，营销人员也开始介入。华丽的效果变得重要。各种各样的内容被加入其中（主要通过创建新的 CSS 规范），以便作者能精确控制网页的显示方式。当然，这完全违背了最初的设计意图。结果变得混乱。
- en: HTML web pages originally included styling information. For example, the `font`
    element that selected a text font had a `size` attribute that controlled the size.
    This approach didn’t work as well when pages were displayed on a diverse set of
    devices from desktops to cell phones. *Cascading Style Sheets (CSS)* separates
    the styling from the HTML so that the HTML can be written once and have different
    styles applied depending on the target device.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 网页最初包括样式信息。例如，`font` 元素用于选择文本字体，并且有一个 `size` 属性来控制字体大小。当页面在从桌面到手机等各种设备上显示时，这种方法并不奏效。*层叠样式表
    (CSS)* 将样式与 HTML 分离，这样就可以写一次 HTML，并根据目标设备应用不同的样式。
- en: '[Figure 9-7](ch09.xhtml#ch09fig07) shows a data structure that could be used
    to represent an HTML element in memory.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-7](ch09.xhtml#ch09fig07) 显示了一个可以用来表示 HTML 元素在内存中数据结构。'
- en: '![Image](../images/09fig07.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig07.jpg)'
- en: '*Figure 9-7: HTML element data structure*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：HTML 元素数据结构*'
- en: This diagram looks really complicated, but it simply glues together a few things
    you’ve already learned about. There’s a compound data type (see “[Compound Data
    Types](ch07.xhtml#ch07lev1sec5)” on [page 189](ch07.xhtml#page_189)) for elements
    and another for attributes. The attributes are organized as a singly linked list
    (see “[Singly Linked Lists](ch07.xhtml#ch07lev1sec6)” on [page 191](ch07.xhtml#page_191)).
    Elements are arranged in a tree (see “[Hierarchical Data Structures](ch07.xhtml#ch07lev1sec11)”
    on [page 199](ch07.xhtml#page_199)). Because there are an arbitrary number of
    children whose ordering matters, they’re organized using a doubly linked list
    (see “[Doubly Linked Lists](ch07.xhtml#ch07lev1sec10)” on [page 198](ch07.xhtml#page_198)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图看起来非常复杂，但它只是将你已经学过的一些内容结合在一起。元素有一个复合数据类型（参见 “[复合数据类型](ch07.xhtml#ch07lev1sec5)”
    章节中的 [第189页](ch07.xhtml#page_189)），属性也有一个类似的类型。属性被组织成一个单链表（参见 “[单链表](ch07.xhtml#ch07lev1sec6)”
    章节中的 [第191页](ch07.xhtml#page_191)）。元素以树状结构排列（参见 “[层次数据结构](ch07.xhtml#ch07lev1sec11)”
    章节中的 [第199页](ch07.xhtml#page_199)）。由于可能有任意数量的子元素且顺序很重要，它们通过双链表进行组织（参见 “[双链表](ch07.xhtml#ch07lev1sec10)”
    章节中的 [第198页](ch07.xhtml#page_198)）。
- en: This organization matters because CSS uses a variation of regular expressions
    (see “[Regular Expressions](ch08.xhtml#ch08lev2sec2)” on [page 224](ch08.xhtml#page_224))
    called *selectors* to locate elements in the DOM, similar to how `yacc` matches
    tokens on a stack. CSS then allows attributes to be associated with the selected
    elements. This enables a web page designer, for example, to change the text size
    depending on the target device or to collapse a side menu into a drop-down menu
    for devices with smaller screens.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组织结构很重要，因为 CSS 使用了一种正则表达式的变体（参见 “[正则表达式](ch08.xhtml#ch08lev2sec2)” 章节中的 [第224页](ch08.xhtml#page_224)），称为
    *选择器*，用于定位 DOM 中的元素，类似于 `yacc` 在堆栈上匹配符号的方式。然后，CSS 允许将属性与选中的元素关联。例如，这使得网页设计师能够根据目标设备调整文本大小，或者将侧边菜单折叠成适用于小屏幕设备的下拉菜单。
- en: CSS muddies up the terminology. It defines a large number of *properties*—things
    like color, font size, and so on. Once these properties are associated with a
    DOM element, they’re called *attributes*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 混淆了术语。它定义了大量的*属性*——例如颜色、字体大小等。一旦这些属性与 DOM 元素关联，它们就被称为*属性*。
- en: '[Table 9-2](ch09.xhtml#ch09tab02) shows some of the CSS selectors. Originally
    there were only a few, but new ones are being added at an alarming rate.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-2](ch09.xhtml#ch09tab02) 展示了一些 CSS 选择器。最初只有少数几个，但现在新增的选择器正在以惊人的速度增加。'
- en: '**Table 9-2:** CSS Selectors'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-2:** CSS 选择器'
- en: '| **Pattern** | **Meaning** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **含义** |'
- en: '| --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `*` | Matches any element |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 匹配任何元素 |'
- en: '| `E` | Matches any element of type `E` (that is, `<E>`...`</E>`) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `E` | 匹配任何类型为 `E` 的元素（即 `<E>`...`</E>`） |'
- en: '| `F` | Matches any element of type `F` (that is, `<F>`...`</F>`) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `F` | 匹配任何类型为 `F` 的元素（即 `<F>`...`</F>`） |'
- en: '| `E F` | Matches any element `F` that is a descendent of an `E` element |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `E F` | 匹配任何是 `E` 元素的后代的元素 `F` |'
- en: '| `E > F` | Matches any element `F` that is a child of an `E` element |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `E > F` | 匹配任何是 `E` 元素子元素的元素 `F` |'
- en: '| `E + F` | Matches any element `F` with an immediate sibling element `E` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `E + F` | 匹配任何与 `E` 元素具有直接兄弟关系的元素 `F` |'
- en: '| `E - F` | Matches any element `F` preceded by any sibling element `E` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `E - F` | 匹配任何由兄弟元素 `E` 前置的元素 `F` |'
- en: '| `E[name]` | Matches any element `E` that has attribute `name` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `E[name]` | 匹配任何具有 `name` 属性的 `E` 元素 |'
- en: '| `E[name=value]` | Matches any element `E` that has attribute `name` with
    `value` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `E[name=value]` | 匹配任何具有 `name` 属性且值为 `value` 的 `E` 元素 |'
- en: '| `E[name~="value"]` | Matches any `E` element whose `name` attribute is a
    space-separated list of words, one of which matches `value` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `E[name~="value"]` | 匹配任何 `E` 元素，其 `name` 属性是一个由空格分隔的单词列表，其中一个单词匹配 `value`
    |'
- en: '| `E#id` | Matches any `E` element that has an ID attribute with a value of
    `id` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `E#id` | 匹配任何具有 `id` 值为 `id` 的 ID 属性的 `E` 元素 |'
- en: '| `E.class` | Matches any `E` element that has a class attribute with a value
    of `class` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `E.class` | 匹配任何具有 `class` 属性值为 `class` 的 `E` 元素 |'
- en: '| `E:first-child` | Matches element `E` if it is the first child of its parent
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `E:first-child` | 如果元素 `E` 是其父元素的第一个子元素，则匹配该元素 |'
- en: '| `E:last-child` | Matches element `E` if it is the last child of its parent
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `E:last-child` | 如果元素 `E` 是其父元素的最后一个子元素，则匹配该元素 |'
- en: '| `E:`n`th-child(`n`)` | Matches element `E` if it is the *n*th child of its
    parent |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `E:nth-child(n)` | 如果元素 `E` 是其父元素的第 *n* 个子元素，则匹配该元素 |'
- en: '| `E:empty` | Matches element `E` if it has no children |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `E:empty` | 如果元素 `E` 没有子元素，则匹配该元素 |'
- en: '| `E:link` | Matches element `E` if it is a hyperlink anchor such as `<a>`
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `E:link` | 如果元素 `E` 是一个超链接锚点（例如 `<a>`），则匹配该元素 |'
- en: '| `E:visited` | Matches element `E` if it is a hyperlink anchor such as `<a>`
    that has been visited |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `E:visited` | 如果元素 `E` 是一个超链接锚点（如 `<a>`）且已访问过，则匹配该元素 |'
- en: '| `E:hover` | Matches element `E` when the mouse hovers over it |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `E:hover` | 当鼠标悬停在元素 `E` 上时匹配该元素 |'
- en: '| `E:active` | Matches element `E` on which the mouse is down |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `E:active` | 匹配鼠标按下时的元素 `E` |'
- en: '| `E:focus` | Matches element `E` if it has the input focus, meaning that it’s
    listening to the keyboard |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `E:focus` | 如果元素 `E` 获得输入焦点（即它在监听键盘输入），则匹配该元素 |'
- en: HTML includes a `<link>` element that can be used to associate a separate file
    containing CSS with a web page. That’s the preferred usage because it conforms
    to the principle of keeping the content separate from the styling. But that’s
    overkill for what we’re doing here. HTML also includes a `<style>` element that
    allows CSS to be embedded directly in HTML documents. That’s what we’ll use for
    our examples.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 包含一个 `<link>` 元素，可以用来将包含 CSS 的独立文件与网页关联。这是首选的用法，因为它符合将内容与样式分开的原则。但对于我们这里的工作来说，这是过于复杂的。HTML
    还包含一个 `<style>` 元素，允许将 CSS 直接嵌入 HTML 文档中。这就是我们在示例中使用的方式。
- en: Let’s modify our web page from [Listing 9-1](ch09.xhtml#ch09list01) to include
    some simple styling, which is shown in bold in [Listing 9-4](ch09.xhtml#ch09list04).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改来自 [列表 9-1](ch09.xhtml#ch09list01) 的网页，添加一些简单的样式，在 [列表 9-4](ch09.xhtml#ch09list04)
    中以粗体显示。
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-4: Web page with embedded CSS*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-4: 带嵌入式 CSS 的网页*'
- en: 'You can see that there are two selectors in [Listing 9-4](ch09.xhtml#ch09list04):
    `body` and `big`. Each selector is followed by a list of property names and values;
    a colon separates each name from its value, there is a semicolon after the value,
    and the list of names and values for each selector is enclosed in curly brackets.
    First, we set the `color` of all text in the document body to `blue`. Next, we
    set the `color` of the text inside the `<big>` element to `yellow`, and we set
    the `font-size` to `200%` of normal. Give it a try!'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在[清单 9-4](ch09.xhtml#ch09list04)中有两个选择器：`body` 和 `big`。每个选择器后面跟着一组属性名称和值；冒号分隔每个名称和它的值，值后面有一个分号，每个选择器的名称和值列表都被花括号括起来。首先，我们将文档主体中所有文本的
    `color` 设置为 `blue`。接下来，我们将 `<big>` 元素中文本的 `color` 设置为 `yellow`，并将 `font-size`
    设置为正常大小的 `200%`。试试看吧！
- en: CSS was an afterthought; nobody had it in mind when developing HTML. There are
    some quirks as a result. HTML has all sorts of elements with defined meanings.
    For example, there is a `<b>` element that makes text **bold** and a `<i>` element
    for *italics*. But the CSS snippet in [Listing 9-5](ch09.xhtml#ch09list05) changes
    their meanings to be the opposite.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 是一个事后想法；在开发 HTML 时并没有考虑到它。结果也因此有一些奇怪的地方。HTML 有各种元素，其含义是定义好的。例如，`<b>` 元素使文本变为
    **粗体**，`<i>` 元素则用于 *斜体*。但是，[清单 9-5](ch09.xhtml#ch09list05)中的 CSS 代码片段改变了它们的含义，使它们变得相反。
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 9-5: Swapping bold and italic using CSS*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-5：使用 CSS 交换粗体和斜体*'
- en: For all intents and purposes, CSS eliminates the distinction between many HTML
    elements. You can think of HTML elements as having a default set of styles, but
    once those styles are changed via CSS, the element name may no longer have any
    relation to to its original purpose.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就所有实际目的而言，CSS 消除了许多 HTML 元素之间的区别。你可以把 HTML 元素看作是有一个默认的样式集，但一旦通过 CSS 更改了这些样式，元素名称可能就不再与其原本的用途相关。
- en: CSS originally just provided a more flexible mechanism for attaching attributes
    to elements, but then it started adding new attributes. These new attributes were
    not retrofitted into HTML. As a result, some attributes can be specified in both
    HTML and CSS, and others only in CSS. There’s a bit of an attitude among the programming
    community that the old way should no longer be used, but that ignores the issues
    of maintaining existing code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 最初只是提供了一种更灵活的机制来将属性附加到元素上，但后来它开始添加新的属性。这些新属性并没有被回溯到 HTML 中。因此，一些属性可以在 HTML
    和 CSS 中都指定，而其他属性则只能在 CSS 中指定。编程社区中有一种看法，认为旧的方法不再使用，但这忽略了维护现有代码的问题。
- en: '**XML and Friends**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**XML 与朋友们**'
- en: 'XML looks a lot like HTML. However, like SGML it requires *well-formed* elements.
    This means that each `<tag>` must have a matching `</tag>`. Implicit end tags
    are not permitted. The big distinction between HTML and XML is that HTML was created
    for a specific application: web pages. XML is a general-purpose markup language
    that can be used for many different applications.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: XML 看起来很像 HTML。然而，像 SGML 一样，它要求元素是 *格式正确的*。这意味着每个 `<tag>` 都必须有一个匹配的 `</tag>`。不允许使用隐式结束标签。HTML
    和 XML 之间的一个重大区别是，HTML 是为特定的应用程序（即网页）创建的，而 XML 是一种通用的标记语言，可以用于许多不同的应用。
- en: Most XML tags don’t have preassigned meanings. You can assign any meaning to
    them that you want. XML provides structure you can use to create your own application-specific
    markup languages. For example, suppose you want to keep track of vegetables in
    your garden. You could create a Vegetable Markup Language (VML) that looks like
    [Listing 9-6](ch09.xhtml#ch09list06).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 XML 标签没有预先分配的含义。你可以为它们分配任何你想要的含义。XML 提供了结构，你可以利用它来创建你自己的应用特定的标记语言。例如，假设你想跟踪你花园中的蔬菜。你可以创建一个看起来像[清单
    9-6](ch09.xhtml#ch09list06)那样的蔬菜标记语言（VML）。
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-6: XML-based markup language example*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-6：基于 XML 的标记语言示例*'
- en: Conflicts can arise from allowing people to create their own markup languages,
    however. For example, suppose that in addition to VML, someone else creates a
    Recipe Markup Language (RML) that also includes a `<name>` element, as in [Listing
    9-7](ch09.xhtml#ch09list07).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，允许人们创建自己的标记语言可能会引发冲突。例如，假设除了 VML 之外，还有人创建了一个包含 `<name>` 元素的食谱标记语言（RML），就像在[清单
    9-7](ch09.xhtml#ch09list07)中所示。
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 9-7: XML-based markup language example with name conflict*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：具有名称冲突的基于 XML 的标记语言示例*'
- en: There is no way to tell whether the `<name>` elements are vegetable names or
    recipe names. We need a mechanism to allow us to combine VML and RML without confusing
    the `<name>` elements. This mechanism is an element tag prefix known as a *namespace*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法判断 `<name>` 元素是蔬菜名称还是食谱名称。我们需要一个机制来允许我们结合 VML 和 RML，而不混淆 `<name>` 元素。这个机制就是一个被称为
    *命名空间* 的元素标签前缀。
- en: As you’d expect from something browser related, there are multiple ways to specify
    namespaces, but I cover only one of them here. Each namespace is associated with
    a URL, although there’s no requirement that it be a valid URL; it just has to
    be distinct from the others. The `xmlns` attribute on the `<xml>` element associates
    a namespace prefix with a URL. [Listing 9-8](ch09.xhtml#ch09list08) shows our
    combined garden and recipe markups with distinguishing namespaces.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从与浏览器相关的内容中所预期的那样，指定命名空间有多种方式，但这里仅介绍其中一种。每个命名空间都与一个 URL 相关联，尽管没有要求它必须是有效的
    URL；它只需与其他命名空间区分开来即可。`xmlns` 属性用于在 `<xml>` 元素上将命名空间前缀与 URL 关联。 [清单 9-8](ch09.xhtml#ch09list08)
    显示了我们结合的花园和食谱标记，并区分了命名空间。
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 9-8: XML-based markup language example with namespaces*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-8：带有命名空间的基于 XML 的标记语言示例*'
- en: You can see that the elements from both fictitious markup languages are combined
    and that they are distinguished by prefix. The namespace prefix is arbitrary and
    left up to whatever is combining the different markup languages together. There’s
    no requirement that `rml` be the prefix for the Recipe Markup Language; we could
    choose `recipe` if we needed to combine this code with another RML, such as Ridiculous
    Markup Language.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到来自两个虚构标记语言的元素已被结合，并通过前缀进行区分。命名空间前缀是任意的，取决于将不同标记语言结合在一起的方式。没有要求 `rml` 必须是食谱标记语言的前缀；如果我们需要将这段代码与另一个
    RML（例如荒谬标记语言）结合使用，也可以选择 `recipe`。
- en: Plenty of tools are available to help you write applications that understand
    custom markup languages such as the ones just described. There are also libraries
    for many programming languages that create and operate on parse trees from XML
    documents.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以帮助你编写理解自定义标记语言（如上述描述的标记语言）的应用程序。许多编程语言也有库，可以从 XML 文档中创建并操作解析树。
- en: One tool is a *Document Type Definition (DTD)*. You can think of this as meta-markup.
    A DTD is an XML-looking document (there are no ending tags for some reason) that
    defines the legal elements in a markup language. XML includes a mechanism that
    allows an XML document to reference a DTD. You could, for example, make a DTD
    that says that one or more `<vegetable>` elements are allowed in a `<garden>`
    element and that a `<vegetable>` can contain only `<name>`, `<variety>`, and `<days-until-maturity>`
    elements. XML parsers can validate the XML against the DTD. Although this is useful,
    it doesn’t do the most important part. For example, although a DTD can ensure
    that a required `<variety>` exists, it can’t test for a valid variety.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一种工具是 *文档类型定义（DTD）*。你可以将其视为元标记。DTD 是一个看起来像 XML 的文档（出于某些原因没有结束标签），它定义了标记语言中的合法元素。XML
    包含一个机制，允许 XML 文档引用 DTD。例如，你可以制作一个 DTD，规定一个或多个 `<vegetable>` 元素可以出现在 `<garden>`
    元素中，并且 `<vegetable>` 只能包含 `<name>`、`<variety>` 和 `<days-until-maturity>` 元素。XML
    解析器可以验证 XML 是否符合 DTD。尽管这很有用，但它没有做最重要的部分。例如，虽然 DTD 可以确保必需的 `<variety>` 存在，但它不能测试
    `variety` 是否有效。
- en: The *XML Path Language (XPath)* provides selectors for XML documents by, as
    you might guess, creating yet another incompatible syntax; it has essentially
    the same functionality of CSS selectors but in a completely different syntax that
    you may need to learn. XPath isn’t very useful by itself but is an important component
    of *Xtensible Stylesheet Language Transformations (XSLT)*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*XML 路径语言（XPath）* 通过创建另一种不兼容的语法，提供了用于 XML 文档的选择器；它本质上具有 CSS 选择器的相同功能，但语法完全不同，你可能需要学习它。XPath
    本身并不是特别有用，但它是 *可扩展样式表语言转换（XSLT）* 的重要组成部分。'
- en: XSLT is yet another XML-based language. When combined with XPath, it allows
    you to write a piece of XML that transforms an XML document into other forms by
    searching and modifying the parse tree. [Listing 9-9](ch09.xhtml#ch09list09) shows
    a simple example where an XPath expression is used to match any vegetable in the
    garden and then output the name and variety of each, separated by a space.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: XSLT 是另一种基于 XML 的语言。当与 XPath 结合使用时，它允许你编写一段 XML，通过搜索和修改解析树将 XML 文档转换为其他形式。 [清单
    9-9](ch09.xhtml#ch09list09) 显示了一个简单的示例，其中使用 XPath 表达式匹配花园中的任何蔬菜，然后输出每个蔬菜的名称和品种，并用空格分隔。
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-9: Call any vegetable using XSLT and XPath*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-9：使用 XSLT 和 XPath 调用任意蔬菜*'
- en: Applying the XSLT in [Listing 9-9](ch09.xhtml#ch09list09) to the XML in [Listing
    9-6](ch09.xhtml#ch09list06) produces the results in [Listing 9-10](ch09.xhtml#ch09list10).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 9-9](ch09.xhtml#ch09list09)中的 XSLT 应用于[清单 9-6](ch09.xhtml#ch09list06)中的
    XML，生成的结果如[清单 9-10](ch09.xhtml#ch09list10)所示。
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-10: Call any vegetable results*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-10：调用任何蔬菜的结果*'
- en: Another example is shown in [Listing 9-11](ch09.xhtml#ch09list11), which selects
    only vegetables when the value of the name is `rutabaga`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是[清单 9-11](ch09.xhtml#ch09list11)中所示的例子，当名称的值为`rutabaga`时，它只选择蔬菜。
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 9-11: Call it by name*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-11：按名称调用*'
- en: Applying the XSLT from [Listing 9-11](ch09.xhtml#ch09list11) to the XML in [Listing
    9-6](ch09.xhtml#ch09list06) produces what you see in [Listing 9-12](ch09.xhtml#ch09list12).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 9-11](ch09.xhtml#ch09list11)中的 XSLT 应用于[清单 9-6](ch09.xhtml#ch09list06)中的
    XML，生成的结果如[清单 9-12](ch09.xhtml#ch09list12)所示。
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 9-12: Call it by name results*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-12：按名称调用结果*'
- en: XSLT is especially useful for transforming markup containing arbitrary data
    into HTML for display in a browser.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: XSLT 特别适用于将包含任意数据的标记转换为 HTML 以在浏览器中显示。
- en: '**JavaScript**'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: Our example web page is static—that is, all it does is display some formatted
    text. Going back to [Figure 9-1](ch09.xhtml#ch09fig01), the only way to change
    what’s displayed is to send another URL to a web server to get a new document.
    Not only is this a slow process, but it also wastes resources. If you entered
    a phone number into a form, the data would have to be sent to a server to determine
    whether it contained all numbers, and the server would have to send back a page
    with an error message if it didn’t.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例网页是静态的——也就是说，它只显示一些格式化的文本。回到[图 9-1](ch09.xhtml#ch09fig01)，唯一改变显示内容的方法是发送另一个
    URL 到 web 服务器以获取新文档。这不仅是一个缓慢的过程，而且还浪费资源。如果你在表单中输入了电话号码，数据必须发送到服务器以确定它是否包含所有数字，如果没有，服务器还必须返回一个带有错误信息的页面。
- en: In 1993, Mark Andreesen created the graphical Mosaic web browser, which fueled
    the consumer internet boom. He went on to found Netscape, which released the Netscape
    Navigator browser in 1994\. Realizing the need for more interactive web pages,
    Netscape introduced the JavaScript programming language in 1995\. JavaScript has
    since been standardized by the Ecma International standards organization, formerly
    the European Computer Manufacturers Association, as ECMA-262\. It’s also known
    as ECMAScript, which sounds like a skin condition and has since been known to
    make browsers flaky. JavaScript borrowed from both the C programming language
    and from Java, which itself borrowed from C.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 1993 年，马克·安德森（Mark Andreesen）创造了图形化的 Mosaic 网页浏览器，这推动了消费互联网的繁荣。他随后创办了 Netscape，并于
    1994 年发布了 Netscape Navigator 浏览器。意识到需要更多交互式网页，Netscape 于 1995 年推出了 JavaScript
    编程语言。此后，JavaScript 被国际标准化组织 Ecma International（前身为欧洲计算机制造商协会）标准化为 ECMA-262。它也被称为
    ECMAScript，这个名字听起来像是一种皮肤病，而且已经被证明会让浏览器变得不稳定。JavaScript 借鉴了 C 编程语言和 Java，而 Java
    本身也借鉴了 C。
- en: JavaScript allows web pages to contain actual programs that run on your computer
    instead of on the server. These programs can modify the DOM and can communicate
    directly with a web server, as shown in [Figure 9-8](ch09.xhtml#ch09fig08).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许网页包含在你的计算机上运行的实际程序，而不是在服务器上运行。这些程序可以修改 DOM，并可以直接与 web 服务器通信，如[图
    9-8](ch09.xhtml#ch09fig08)所示。
- en: '![Image](../images/09fig08.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig08.jpg)'
- en: '*Figure 9-8: Web browser interaction with JavaScript and web server*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：Web 浏览器与 JavaScript 和 Web 服务器的交互*'
- en: The interaction between the JavaScript program and the server is not the same
    as the browser/server communication we saw in [Figure 9-1](ch09.xhtml#ch09fig01).
    Instead, it takes place via *Asynchronous JavaScript and XML (AJAX)*. Let’s break
    that down. *Asynchronous* is related to what we saw with ripple counters in “[Counters](ch03.xhtml#ch03lev2sec6)”
    on [page 77](ch03.xhtml#page_77); in this instance, it means the browser has no
    control over when (and if) a server responds. The *JavaScript* part just means
    it’s under the control of a JavaScript program. I’m not going to explain the *and*.
    Finally, the data from the server to the JavaScript program was initially encoded
    using *XML*, not HTML.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 程序与服务器之间的交互不同于我们在[图 9-1](ch09.xhtml#ch09fig01)中看到的浏览器/服务器通信。相反，它通过*异步
    JavaScript 和 XML（AJAX）*进行。我们来逐一解析。*异步*与我们在[第 77 页](ch03.xhtml#page_77)中“[计数器](ch03.xhtml#ch03lev2sec6)”一节看到的涟漪计数器相关；在此情况下，它意味着浏览器无法控制服务器何时（以及是否）做出响应。*JavaScript*
    部分则意味着它由 JavaScript 程序控制。我不打算解释*和*的含义。最后，服务器到 JavaScript 程序的数据最初使用*XML*编码，而不是
    HTML。
- en: You can include JavaScript in an HTML document by enclosing it in `<script>`
    elements. Let’s add some to what we had in [Listing 9-4](ch09.xhtml#ch09list04),
    again showing the changes in bold, in [Listing 9-13](ch09.xhtml#ch09list13).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 JavaScript 包裹在 `<script>` 元素中，将其包含在 HTML 文档中。让我们在[清单 9-4](ch09.xhtml#ch09list04)中增加一些内容，再次显示以粗体表示的更改，如[清单
    9-13](ch09.xhtml#ch09list13)所示。
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-13: Web page with embedded JavaScript*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-13：嵌入了 JavaScript 的网页*'
- en: Let’s see what this does without going into all the nitpicky details. Part of
    the browser definition is that there is a `window.onload` variable that can be
    set to a function to execute when the initial page has finished loading. Another
    part of the definition says that there is a `document.getElementsByTagName` function
    that returns an array of all matching elements in the DOM. Here it returns the
    one `<big>` element. Finally, it allows us to change various element properties.
    In this case, we set the background color to green.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码的效果，而不深入所有的细节。浏览器的定义之一是有一个 `window.onload` 变量，可以设置为一个函数，当初始页面加载完成时执行。定义的另一部分提到有一个
    `document.getElementsByTagName` 函数，它返回 DOM 中所有匹配元素的数组。在这里，它返回唯一的 `<big>` 元素。最后，它允许我们更改各种元素的属性。在这种情况下，我们将背景色设置为绿色。
- en: There are a large number of defined functions for DOM manipulation. They allow
    us to do more than just change CSS styles from a program. There are also functions
    that allow you to rearrange the DOM tree, including the ability to add and delete
    elements.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量定义好的函数用于 DOM 操作。它们允许我们做的不仅仅是从程序中更改 CSS 样式。还有一些函数可以让你重新排列 DOM 树，包括添加和删除元素的能力。
- en: '**jQuery**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**jQuery**'
- en: Using the browser DOM functions from the previous section has two problems.
    First, the DOM functions don’t have exactly the same behavior on different browsers.
    Second, they’re pretty cumbersome to use—not exactly a user-friendly interface.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节中的浏览器 DOM 函数有两个问题。首先，DOM 函数在不同浏览器上的行为并不完全相同。其次，它们使用起来非常繁琐——并不是一个用户友好的接口。
- en: Enter *jQuery*, a library introduced by American software engineer John Resig
    in 2006\. It solved both of the problems just mentioned. It smoothed over the
    incompatibilities between browsers so that the programmers using it didn’t have
    to. And it supplied a DOM manipulation interface that was much easier to use.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 进入*jQuery*，这是美国软件工程师 John Resig 在 2006 年推出的一个库。它解决了刚才提到的两个问题。它平滑了浏览器之间的不兼容问题，使得使用它的程序员不必自己处理这些问题。同时，它还提供了一个更容易使用的
    DOM 操作接口。
- en: The jQuery library combines selectors with *actions*. The code in [Listing 9-14](ch09.xhtml#ch09list14)
    does exactly the same thing as the code in [Listing 9-13](ch09.xhtml#ch09list13)
    but in a more programmer-friendly way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 库将选择器与*操作*结合起来。[清单 9-14](ch09.xhtml#ch09list14)中的代码与[清单 9-13](ch09.xhtml#ch09list13)中的代码完全相同，只是用一种更适合程序员的方式表达。
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 9-14: Web page with embedded JavaScript and jQuery*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-14：嵌入了 JavaScript 和 jQuery 的网页*'
- en: The first `<script>` element imports the jQuery library; the second contains
    our code. The “document ready” function that the browser calls when the page is
    loaded contains a single jQuery statement. The first part of it, `$('big')`, is
    a selector. It’s similar to the CSS selectors we saw in [Table 9-2](ch09.xhtml#ch09tab02).
    The remainder of the statement, `.css('background', 'green')`, is an action to
    perform on the selected elements. In this case, the `css` function modifies the
    `background` property, setting it to `green`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`<script>`元素导入了jQuery库；第二个包含了我们的代码。浏览器在页面加载时调用的“文档就绪”函数包含一个简单的jQuery语句。它的第一部分，`$('big')`，是一个选择器。它与我们在[表格
    9-2](ch09.xhtml#ch09tab02)中看到的CSS选择器类似。语句的其余部分，`.css('background', 'green')`，是在选中的元素上执行的操作。在这种情况下，`css`函数修改了`background`属性，将其设置为`green`。
- en: Let’s add the piece of jQuery in [Listing 9-15](ch09.xhtml#ch09list15) to the
    document ready function to add some interactivity.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将[示例 9-15](ch09.xhtml#ch09list15)中的jQuery代码添加到文档就绪函数中，增加一些交互性。
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 9-15: jQuery event handler*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-15: jQuery 事件处理器*'
- en: 'This simple piece of code attaches an *event handler* to the `<big>` element
    that is executed when the mouse clicks it. This handler does two things: it inserts
    a new `<i>` element before the `<big>` element, and it increases the `<big>` font
    size.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码将一个*事件处理器*附加到`<big>`元素上，当鼠标点击该元素时会执行。这个处理器做了两件事：它在`<big>`元素前插入一个新的`<i>`元素，并且增加了`<big>`的字体大小。
- en: As you can see in this example, jQuery makes it easy to manipulate the DOM using
    JavaScript. You can open up your browser’s debugging console and watch these changes
    occur when you click.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个示例中看到的，jQuery使得使用JavaScript操作DOM变得简单。你可以打开浏览器的调试控制台，点击时观察这些变化发生。
- en: jQuery blazed a path, and a very popular one at that; the library is very widely
    used. However, as seems endemic in the web community, some programmers decided
    to create parallel, incompatible paths. There are now a number of JavaScript libraries
    that do the same things, only differently.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery开辟了一条道路，而且是一条非常流行的道路；这个库被广泛使用。然而，正如在网页社区中常见的情况，有些程序员决定创建并行的、不兼容的路径。现在有许多JavaScript库做着相同的事情，只是方式不同。
- en: '**SVG**'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SVG**'
- en: '*Scalable Vector Graphics (SVG)* is kind of an odd duck in the collection of
    browser additions. It’s yet another completely different language that allows
    you to produce nice-looking graphics and text in a manner that is completely incompatible
    with everything else.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*可缩放矢量图形 (SVG)* 是浏览器附加功能中的一个异类。它是另一种完全不同的语言，允许你以完全不兼容其他所有方式生成美观的图形和文本。'
- en: John Warnock and Chuck Geschke founded Adobe Systems in 1982 and developed the
    PostScript language. Warnock had been working on more complicated versions of
    the ideas in PostScript for years, and the development of PostScript was similar
    to the way that the overly complex SGML was simplified to HTML. The duo caught
    a lucky break when Steve Jobs requested that they use PostScript to drive laser
    printers. The PostScript-based Apple LaserWriter was a major factor in the formation
    of the desktop publishing industry and was responsible for Adobe’s success.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰·沃诺克和查克·盖什基于1982年创立了Adobe公司，并开发了PostScript语言。沃诺克多年来一直在研究PostScript理念的更复杂版本，PostScript的发展类似于过于复杂的SGML被简化为HTML的过程。当史蒂夫·乔布斯要求他们使用PostScript驱动激光打印机时，这对二人组来说是一次幸运的突破。基于PostScript的Apple
    LaserWriter是桌面出版行业形成的一个重要因素，并为Adobe的成功奠定了基础。
- en: PostScript had some issues with *portability*—getting the same results everywhere.
    The *Portable Document Format (PDF)*, based on PostScript, was created to address
    these issues. SVG is more or less PDF wedged into browsers. Of course, SVG and
    PDF aren’t completely compatible because that would make too much sense.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: PostScript在*可移植性*上存在一些问题——无法在不同环境中得到相同的结果。基于PostScript的*可移植文档格式（PDF）*被创建来解决这些问题。SVG或多或少是PDF嵌入到浏览器中的形式。当然，SVG和PDF并不完全兼容，因为那样太有意义了。
- en: In general, SVG is more automatic than the recently added canvas (covered in
    the next section). You can tell it to do things, and it will, whereas with a canvas
    you have to write a program to manipulate it. Add the contents of [Listing 9-16](ch09.xhtml#ch09list16)
    to the `body` of your web page and give it a spin, because every web page needs
    a red pulsing circle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，SVG比最近新增的canvas（将在下一节讨论）更具自动化。你可以指示它执行任务，它就会做，而在canvas上，你必须编写程序来操作它。将[示例
    9-16](ch09.xhtml#ch09list16)的内容添加到网页的`body`中并试试，因为每个网页都需要一个红色脉动的圆圈。
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-16: SVG animated circle*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-16: SVG 动画圆形*'
- en: '**HTML5**'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**HTML5**'
- en: As I mentioned at the beginning of this chapter, it seems that in the browser
    world, there’s no idea that should be implemented only once. HTML5 is the latest
    incarnation of HTML. Among other things, it adds a big pile of *semantic* elements,
    including `<header>`, `<footer>`, and `<section>`, which—if used as intended—would
    add consistent structure to documents.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开头提到的，在浏览器的世界里，似乎没有什么想法是只需要实现一次的。HTML5 是 HTML 的最新版本。除了其他内容外，它增加了一大堆*语义化*元素，包括
    `<header>`、`<footer>` 和 `<section>`，如果按预期使用，它们将为文档增加一致的结构。
- en: HTML5 introduces the *canvas*, which provides pretty much the same functionality
    as SVG but in a completely different way. The major difference is that canvases
    can be manipulated only with a new set of JavaScript functions, unlike SVG, which
    can use the existing DOM functions. In other words, you would have to write a
    JavaScript program in order to duplicate [Listing 9-16](ch09.xhtml#ch09list16)
    using a canvas.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 引入了 *canvas*，它提供了几乎与 SVG 相同的功能，但以完全不同的方式。主要的区别在于，canvas 只能通过一组新的 JavaScript
    函数进行操作，而不像 SVG 那样可以使用现有的 DOM 函数。换句话说，你必须编写一个 JavaScript 程序，才能使用 canvas 重现 [列表
    9-16](ch09.xhtml#ch09list16) 中的内容。
- en: HTML5 also adds `<audio>` and `<video>`, which provide somewhat standard mechanisms
    for audio and video.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 还增加了 `<audio>` 和 `<video>` 元素，提供了某种标准机制来处理音频和视频。
- en: '**JSON**'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**JSON**'
- en: I touched on AJAX back in “[JavaScript](ch09.xhtml#ch09lev1sec7)” on [page 251](ch09.xhtml#page_251)
    and mentioned that asynchronous XML-formatted data is sent from the server to
    the browser JavaScript program. Well, that’s *so* four sections ago. The *X* in
    AJAX is now a *J* for JSON. Although the acronym AJAJ floats around, the technique
    is still called AJAX.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 “[JavaScript](ch09.xhtml#ch09lev1sec7)” 一节中提到了 AJAX，并且提到异步的 XML 格式数据从服务器发送到浏览器的
    JavaScript 程序。好吧，那已经是*四个章节前的事*了。AJAX 中的 *X* 现在变成了 *J*，代表 JSON。虽然 AJAJ 这个缩写有时也会出现，但这项技术仍然被称为
    AJAX。
- en: '*JSON* stands for JavaScript Object Notation. It’s essentially a human-readable
    text format for a JavaScript *object*, which is one of JavaScript’s compound data
    types. The theory is that data in this format can be exchanged in an interoperable
    manner, although problems with the specification mean that this exchange is possible
    only if you adhere to certain unspecified rules such as avoiding certain characters.
    Programmers also need to work around the fact that JSON doesn’t support all the
    JavaScript data types.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSON* 代表 JavaScript 对象表示法。它本质上是一种人类可读的文本格式，用于表示 JavaScript 的 *对象*，它是 JavaScript
    的复合数据类型之一。理论上，这种格式的数据可以以互操作的方式交换，尽管由于规范的问题，这种交换只有在遵循某些未指定的规则（例如避免使用某些字符）时才能实现。程序员还需要绕过
    JSON 不支持所有 JavaScript 数据类型的限制。'
- en: '[Listing 9-17](ch09.xhtml#ch09list17) builds a JavaScript object and converts
    it to JSON format. It then shows the result that was stored in the variable the_quest,
    shown in bold below.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-17](ch09.xhtml#ch09list17) 构建了一个 JavaScript 对象并将其转换为 JSON 格式。然后，它展示了存储在变量
    the_quest 中的结果，以下内容为粗体显示。'
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 9-17: JSON and the Argonauts*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-17：JSON 和阿尔戈英雄*'
- en: JSON has an advantage over XML when using JavaScript, and not just because converting
    JavaScript objects into JSON is trivial, as shown in [Listing 9-17](ch09.xhtml#ch09list17).
    The companion JavaScript `eval` function can execute JSON directly, because it’s
    data, as if it’s a JavaScript program. JSON is popular because it eliminates the
    need for extra code to handle data export and import.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 JavaScript 时，JSON 相较于 XML 有一个优势，这不仅仅是因为将 JavaScript 对象转换为 JSON 很简单，如在 [列表
    9-17](ch09.xhtml#ch09list17) 中所示。配套的 JavaScript `eval` 函数可以直接执行 JSON，因为它是数据，就像它是一个
    JavaScript 程序一样。JSON 之所以受欢迎，是因为它消除了处理数据导入和导出的额外代码需求。
- en: Just because it’s easy to use JSON doesn’t mean you can be cavalier about it,
    however. Blithely importing JSON data using `eval` can allow an attacker to execute
    arbitrary code in a browser. More recently, a companion `JSON.parse` function
    has been added that safely converts JSON back into a JavaScript object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅因为 JSON 易于使用，并不意味着你可以对此掉以轻心。随意使用 `eval` 导入 JSON 数据可能会让攻击者在浏览器中执行任意代码。最近，新增了一个配套的
    `JSON.parse` 函数，它可以安全地将 JSON 转换回 JavaScript 对象。
- en: '**Summary**'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you’ve learned the basics of how many of the components comprising
    a web browser work. [Figure 9-9](ch09.xhtml#ch09fig09) illustrates the pieces
    we’ve discussed. Of course, browsers include a lot more functionality that isn’t
    particularly interesting, such as bookmarks and history.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你已经学习了构成网页浏览器的许多组件是如何工作的。[图 9-9](ch09.xhtml#ch09fig09) 展示了我们讨论过的各个部分。当然，浏览器还包含许多不太引人注目的功能，比如书签和历史记录。
- en: '![Image](../images/09fig09.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig09.jpg)'
- en: '*Figure 9-9: Browser block diagram*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：浏览器模块图*'
- en: The diagram may look pretty complicated, but it’s just an assemblage of parts
    that you’ve already seen. These include language parsers, parse trees, regular
    expressions, interpreters, networking, input, and output.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图看起来可能相当复杂，但它只是由你已经见过的一些部分组成。这些部分包括语言解析器、解析树、正则表达式、解释器、网络、输入和输出。
- en: It also illustrates a distinction between hardware and software design. Designing
    hardware is more expensive than designing software. It’s unlikely that a hardware
    designer would construct a system that used six different incompatible methods
    to do the same thing before breakfast. But because there isn’t the same up-front
    cost in software, software designers are often less careful. The result is often
    a larger, more complex result that might cost less up front but often costs more
    later because of the number of complicated interoperating parts that must be maintained.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它还说明了硬件和软件设计之间的区别。设计硬件比设计软件更为昂贵。硬件设计师不太可能在早餐前就构建一个使用六种不同、不兼容方法来完成相同任务的系统。但是，由于软件的前期成本较低，软件设计师往往不够谨慎。结果通常是一个更大、更复杂的系统，前期成本可能较低，但由于需要维护许多复杂的互操作部件，后期的成本通常更高。
- en: Now that you’ve learned something about the workings of this complex interpreter,
    in the next chapter we’ll write some programs for it. You’ll see a program written
    for a browser in JavaScript and the same program written in C. This will illustrate
    some of the important system-level considerations that are hidden from web programmers
    but are important for system-level programming.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些关于这个复杂解释器的工作原理，下一章我们将为它编写一些程序。你将看到一个为浏览器编写的JavaScript程序和一个用C语言编写的相同程序。这将说明一些对网页程序员隐藏的，但对系统级编程至关重要的系统级考虑因素。
