- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE WEB BROWSER**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You probably don’t think of it this way, but the web browser you use every day
    is a *virtual machine*—an abstract computer with an incredibly complicated instruction
    set implemented entirely in software. In other words, it’s one of those interpreters
    you learned about in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about some of the functionality of this virtual
    machine. You’ll learn about the input language and how it’s interpreted by the
    browser. Browsers are extremely complicated beasties, however, so I can’t cover
    every feature.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that makes browsers interesting to learn about is that, on one hand,
    they’re big, complex applications, and on the other, they’re software-implemented
    computers that you can program. Browsers have a *developer console*, which you
    can use while playing with the examples from this chapter. This allows you to
    get a real-time view of how the browser operates.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the web browser also teaches us something about system design,
    which is arguably more important than programming ([Chapter 15](ch15.xhtml#ch15)
    covers system design in more detail). The popularity of the web has turned the
    browser into a magnet for new features. Many of these features have extended browser
    functionality in a compatible manner by adding to the original instruction set.
    Other features have duplicated existing functionality in incompatible ways, the
    result being that browsers now support multiple instruction sets, and the complete
    set of features is not available in any of them. It should become clear in this
    chapter that I’m not thrilled by the latter category of features—those that are
    merely different instead of adding value.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, having multiple ways to do things means you as a programmer have
    a lot more to learn, which isn’t a great use of your time for features that don’t
    add value. And you need to expend energy choosing which way to do your code. Adding
    multiple approaches also increases the complexity of programs. Industry statistics
    show a direct relationship between the amount of code in a program and the number
    of bugs. Browsers crash often. And, as [Chapter 13](ch13.xhtml#ch13) covers in
    more detail, more complex code is more likely to contain security problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Incompatible ways of doing things makes programmers more prone to errors. It’s
    like an American driving a car in New Zealand: some of the controls are in different
    places because New Zealanders drive on the left-hand side of the road. People
    from countries where you drive on the right are easy to spot, as they turn on
    their windshield wipers when making a turn. You don’t want to program in an environment
    that facilitates these sorts of avoidable errors.'
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the fact that many of the web standards have become *living documents*
    is a clear sign of trouble. If you’re not familiar with that term, I’m referring
    to online documents that are constantly being updated. Standards exist to provide
    stability and interoperability. Living documents don’t; at best, they capture
    a moment in time. It’s difficult to program to constantly changing specifications.
    In this context, living documents make life easier for a few document creators
    (because those documents and the software that they reference never have to be
    “done”) and more difficult for a much larger number of consumers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Markup Languages**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Had this book been written 15 years earlier, this chapter would have started
    with an introduction to HTML, the HyperText Markup Language. But, as I’ve already
    implied, the browser has a lot in common with the Great Pacific Garbage Patch:
    it keeps getting bigger by attracting features that stick to it. Among these are
    multiple markup languages, so we’ll begin with an overview of them.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Markup* is a system for annotating or adding marks to text in a way that can
    be distinguished from that text—like homework that a teacher has written snarky
    comments in red pencil on.'
  prefs: []
  type: TYPE_NORMAL
- en: Markup languages are not new; they existed long before computers. They were
    developed as a side effect of the printing press so that authors and editors could
    describe what they wanted to the “pressmen” who set the type. This useful notion
    was carried forward when computers automated typesetting. Today’s markup languages
    are just the latest incarnations of an old idea.
  prefs: []
  type: TYPE_NORMAL
- en: There are a large number of markup languages. For example, I originally wrote
    this book in a markup language for typesetting called `troff`. The source for
    this paragraph is shown in [Listing 9-1](ch09.xhtml#ch09list01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: troff for the preceding paragraph*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, most of it is just the text, but there are three elements of
    markup. The `.PP` tells `troff` to start a paragraph. The `\fC` tells `troff`
    to push the current font onto a stack and replace it with font `C`, for Courier.
    The `\fP` tells `troff` to pop the font stack (see “[Stacks](ch05.xhtml#ch05lev1sec3)”
    on [page 122](ch05.xhtml#page_122)), which restores the previous font.
  prefs: []
  type: TYPE_NORMAL
- en: Web pages are regular text files, just like the `troff` example. You don’t need
    a fancy program to create them; you can do it in any text editor. As a matter
    of fact, fancy web page creation programs produce bloated results that you can
    easily beat by handcrafting them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: How do you mark up a regular text file when the only tool available is more
    text? By giving superpowers to some characters, the way Superman has superpowers
    even though he’s also a mild-mannered reporter. For example, `troff` gives superpowers
    to any line that begins with a `.` or `'` and to anything that begins with a `\`.
  prefs: []
  type: TYPE_NORMAL
- en: IBM rolled its own markup language, called *GML* (short for *Generalized Markup
    Language*, though it’s really named for its developers, Goldfarb, Mosher, and
    Lorie), which the company used for its ISIL publishing tool. This work was expanded
    into the *Standard Generalized Markup Language (SGML)*, which was adopted by the
    International Standards Organization in the 1980s. SGML was so “generalized” that
    it’s not clear that anybody was ever able to produce a complete working implementation
    of the standard.
  prefs: []
  type: TYPE_NORMAL
- en: '*eXtensible Markup Language (XML)* is a more practical subset of SGML. Support
    for it was a later addition to browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: HTML and XML both have their roots in SGML. They borrow some of the same syntax
    but don’t conform to the standard.
  prefs: []
  type: TYPE_NORMAL
- en: XHTML is a modified form of HTML that conforms to the XML rules.
  prefs: []
  type: TYPE_NORMAL
- en: '**Uniform Resource Locators**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first web browser (called WorldWideWeb), invented by English engineer and
    computer scientist Sir Tim Berners-Lee in 1990, was pretty straightforward in
    how it worked, as shown in [Figure 9-1](ch09.xhtml#ch09fig01). The browser used
    a *Uniform Resource Locator (URL)* to request a document from a server using the
    HTTP protocol discussed in “[The World Wide Web](ch06.xhtml#ch06lev3sec4)” on
    [page 159](ch06.xhtml#page_159). The server sent the document to the browser,
    which would display it. The document used to be written in HTML, but now it can
    be written in a variety of languages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: Web browser interaction with web server*'
  prefs: []
  type: TYPE_NORMAL
- en: URLs are text strings that have some structure. Right now we just care about
    the three parts of that structure shown in [Figure 9-2](ch09.xhtml#ch09fig02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: Anatomy of a URL*'
  prefs: []
  type: TYPE_NORMAL
- en: The *scheme* indicates the communication mechanism—for example, `https` selects
    HyperText Transfer Protocol (Secure). The server that we want to communicate with
    is the *host*. It can be a numeric internet address (see “[IP Addresses](ch06.xhtml#ch06lev3sec2)”
    on [page 159](ch06.xhtml#page_159)) but is most commonly specified as a domain
    name (see “[Domain Name System](ch06.xhtml#ch06lev3sec3)” on [page 159](ch06.xhtml#page_159)).
    The location of the document to be retrieved is the *path*, which looks just like
    a filesystem path.
  prefs: []
  type: TYPE_NORMAL
- en: One of the schemes is `file`. When it’s used, the host/path portion of the URL
    is a local filename—the name of a file on the same system on which the browser
    is running. In other words, the `file` scheme points to a file on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: There are an ever-growing number of schemes, such as `bitcoin` for cryptocurrencies
    and `tv` for television broadcasts. These are similar, and in many cases identical,
    to the protocols that we saw back in “[The World Wide Web](ch06.xhtml#ch06lev3sec4).”
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML Documents**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned, the first web pages were documents written in HTML. HTML utilized
    *hypertext*—text that links to something else, such as other web pages. Sci-fi
    buffs can think of it like combining hyperspace with text: you hit a link and,
    *zap*, you’re someplace else. Hypertext has been around for quite some time, but
    the web was its compelling application.'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the simple HTML document in [Listing 9-2](ch09.xhtml#ch09list02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-2: My First Web Page*'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the HTML shown in [Listing 9-2](ch09.xhtml#ch09list02) into a file and
    open it in your browser. You should see something like [Figure 9-3](ch09.xhtml#ch09fig03).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: Browser display of My First Web Page*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the display in [Figure 9-3](ch09.xhtml#ch09fig03) doesn’t look
    much like the text in [Listing 9-2](ch09.xhtml#ch09list02). That’s because the
    less-than sign (`<`) is a character with superpowers. In this case, it begins
    an *element* of markup. You might notice that elements come in pairs; for each
    start `<tag>` there is a matching end `</tag>`.
  prefs: []
  type: TYPE_NORMAL
- en: The tag determines how the browser interprets the markup element. Tags are essentially
    virtual machine instructions. For example, `<title>` puts its contents—what’s
    between the start and end tags—into the browser title bar. The `<b>` and `<big>`
    elements make the word “Cool!” bold and big, and it’s part of the `<body>` of
    the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `<` has superpowers, you may wonder how to use that character without
    the superpowers—for example, if you wanted to display `This is my first web page
    with a <`. HTML includes its own form of kryptonite called an *entity reference*,
    which is an alternate form of a character. In this case, the sequence `&lt;` represents
    the `<` character without triggering its superpowers. (Of course, now there’s
    a new superpowered character `&`, which can itself be represented using the `&amp;`
    sequence.) Using an entity reference, you could type `This is my first web page
    with a &lt;` and it would look correct.
  prefs: []
  type: TYPE_NORMAL
- en: HTML elements aren’t quite as simple. There are a number of random exceptions
    where end tags are not required, and there’s a `<tag/>` form for elements with
    no content. XHTML eliminates these exceptions. The only complication that we care
    about here is *attributes*, which are optional sets of name/value pairs, as shown
    in [Listing 9-3](ch09.xhtml#ch09list03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-3: HTML elements with attributes*'
  prefs: []
  type: TYPE_NORMAL
- en: Some attribute `names` have predefined behaviors; you can include arbitrary
    attributes for any that aren’t predefined. Attribute values are treated identically,
    with the exception of `class`, whose value is treated as a space-separated list
    of values.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Document Object Model**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web browsers process documents according to the *Document Object Model (DOM)*.
    You can think of a web page as a series of elements that enclose other elements
    as illustrated by the indentation in the [Listing 9-2](ch09.xhtml#ch09list02)
    HTML. [Figure 9-4](ch09.xhtml#ch09fig04), which looks sort of like an aerial cutaway
    view of a twisted *matryoshka* (Russian nesting) doll, shows what this structure
    looks like for the code in [Listing 9-2](ch09.xhtml#ch09list02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: Nested elements in an HTML document*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s grab that picture by the edge of the HTML and tilt it so that all of the
    innards hang out the bottom, as shown in [Figure 9-5](ch09.xhtml#ch09fig05).
  prefs: []
  type: TYPE_NORMAL
- en: Look familiar? It’s our old friend, the directed acyclic graph, or DAG (from
    “[Stacks](ch05.xhtml#ch05lev1sec3)” on [page 122](ch05.xhtml#page_122)), and a
    tree structure too (see “[Hierarchical Data Structures](ch07.xhtml#ch07lev1sec11)”
    on [page 199](ch07.xhtml#page_199)). Not only that, but the HTML can be processed
    using techniques from [Chapter 8](ch08.xhtml#ch08) and the result is a parse tree
    (see “[Parse Trees](ch08.xhtml#ch08lev1sec7)” on [page 228](ch08.xhtml#page_228)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: HTML document as a tree structure*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Tree Lexicon***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tree structures like the DOM are so common that an entire lexicon has developed
    around them. The examples in [Table 9-1](ch09.xhtml#ch09tab01) are taken from
    [Figure 9-5](ch09.xhtml#ch09fig05).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Tree Lexicon'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Term** | **Definition** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Node | An element in the tree | `html`, `head`, `body` |'
  prefs: []
  type: TYPE_TB
- en: '| Interior node | An element in the tree that has arrows entering and leaving
    | `title` |'
  prefs: []
  type: TYPE_TB
- en: '| Terminal node | An element in the tree that has no arrows leaving it | `Cool!`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Root | The top of the tree | `html` |'
  prefs: []
  type: TYPE_TB
- en: '| Parent | A node whose arrow points directly to another node | `html` is the
    parent of `head` and `body` |'
  prefs: []
  type: TYPE_TB
- en: '| Child | A node directly pointed to by another node | `head` and `body` are
    children of `html` |'
  prefs: []
  type: TYPE_TB
- en: '| Descendant | A node directly or indirectly pointed to by another node | `title`
    is a descendent of `html` |'
  prefs: []
  type: TYPE_TB
- en: '| Ancestor | A node that directly or indirectly points to a node | `body` is
    an ancestor of `big` |'
  prefs: []
  type: TYPE_TB
- en: '| Sibling | A node with a common parent | `head` is a sibling of `body` |'
  prefs: []
  type: TYPE_TB
- en: Nodes in a tree are ordered. For example, `head` is the first child of `html`,
    and `body` is the second and also last child of `html`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Interpreting the DOM***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What does a browser do with a document tree? Although it’s possible that someone
    could build a piece of computing hardware with instructions corresponding to the
    HTML elements, nobody has done so yet. That rules out compiling the DOM parse
    tree into machine language. The other choice is to interpret it using *depth-first
    traversal*, as shown in [Figure 9-6](ch09.xhtml#ch09fig06).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: HTML document traversal order*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the browser starts at the root, descends to the first child,
    then to its first child, and so on until it hits a terminal node. It then goes
    up to the closest ancestor that has another child and does the same thing from
    there, and so on until every node in the tree is visited. Note that the ordering
    follows the way in which the HTML is written. Depth-first traversal is yet another
    application of stacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cascading Style Sheets**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An original idea behind HTML was that authors wrote web pages and browsers figured
    out how to display them. This made sense because there was no way for the author
    to know things like the size of a browser’s window, the screen resolution, or
    the number of available colors and fonts.
  prefs: []
  type: TYPE_NORMAL
- en: Once the web became popular, the marketing types got their hands on it. Glitz
    became important. All sorts of stuff got added (mostly via the creation of a new
    CSS specification) to allow authors to finely control how their pages are displayed.
    Of course, this is exactly the opposite of the original intent. The result is
    messy.
  prefs: []
  type: TYPE_NORMAL
- en: HTML web pages originally included styling information. For example, the `font`
    element that selected a text font had a `size` attribute that controlled the size.
    This approach didn’t work as well when pages were displayed on a diverse set of
    devices from desktops to cell phones. *Cascading Style Sheets (CSS)* separates
    the styling from the HTML so that the HTML can be written once and have different
    styles applied depending on the target device.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-7](ch09.xhtml#ch09fig07) shows a data structure that could be used
    to represent an HTML element in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: HTML element data structure*'
  prefs: []
  type: TYPE_NORMAL
- en: This diagram looks really complicated, but it simply glues together a few things
    you’ve already learned about. There’s a compound data type (see “[Compound Data
    Types](ch07.xhtml#ch07lev1sec5)” on [page 189](ch07.xhtml#page_189)) for elements
    and another for attributes. The attributes are organized as a singly linked list
    (see “[Singly Linked Lists](ch07.xhtml#ch07lev1sec6)” on [page 191](ch07.xhtml#page_191)).
    Elements are arranged in a tree (see “[Hierarchical Data Structures](ch07.xhtml#ch07lev1sec11)”
    on [page 199](ch07.xhtml#page_199)). Because there are an arbitrary number of
    children whose ordering matters, they’re organized using a doubly linked list
    (see “[Doubly Linked Lists](ch07.xhtml#ch07lev1sec10)” on [page 198](ch07.xhtml#page_198)).
  prefs: []
  type: TYPE_NORMAL
- en: This organization matters because CSS uses a variation of regular expressions
    (see “[Regular Expressions](ch08.xhtml#ch08lev2sec2)” on [page 224](ch08.xhtml#page_224))
    called *selectors* to locate elements in the DOM, similar to how `yacc` matches
    tokens on a stack. CSS then allows attributes to be associated with the selected
    elements. This enables a web page designer, for example, to change the text size
    depending on the target device or to collapse a side menu into a drop-down menu
    for devices with smaller screens.
  prefs: []
  type: TYPE_NORMAL
- en: CSS muddies up the terminology. It defines a large number of *properties*—things
    like color, font size, and so on. Once these properties are associated with a
    DOM element, they’re called *attributes*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-2](ch09.xhtml#ch09tab02) shows some of the CSS selectors. Originally
    there were only a few, but new ones are being added at an alarming rate.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2:** CSS Selectors'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pattern** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Matches any element |'
  prefs: []
  type: TYPE_TB
- en: '| `E` | Matches any element of type `E` (that is, `<E>`...`</E>`) |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | Matches any element of type `F` (that is, `<F>`...`</F>`) |'
  prefs: []
  type: TYPE_TB
- en: '| `E F` | Matches any element `F` that is a descendent of an `E` element |'
  prefs: []
  type: TYPE_TB
- en: '| `E > F` | Matches any element `F` that is a child of an `E` element |'
  prefs: []
  type: TYPE_TB
- en: '| `E + F` | Matches any element `F` with an immediate sibling element `E` |'
  prefs: []
  type: TYPE_TB
- en: '| `E - F` | Matches any element `F` preceded by any sibling element `E` |'
  prefs: []
  type: TYPE_TB
- en: '| `E[name]` | Matches any element `E` that has attribute `name` |'
  prefs: []
  type: TYPE_TB
- en: '| `E[name=value]` | Matches any element `E` that has attribute `name` with
    `value` |'
  prefs: []
  type: TYPE_TB
- en: '| `E[name~="value"]` | Matches any `E` element whose `name` attribute is a
    space-separated list of words, one of which matches `value` |'
  prefs: []
  type: TYPE_TB
- en: '| `E#id` | Matches any `E` element that has an ID attribute with a value of
    `id` |'
  prefs: []
  type: TYPE_TB
- en: '| `E.class` | Matches any `E` element that has a class attribute with a value
    of `class` |'
  prefs: []
  type: TYPE_TB
- en: '| `E:first-child` | Matches element `E` if it is the first child of its parent
    |'
  prefs: []
  type: TYPE_TB
- en: '| `E:last-child` | Matches element `E` if it is the last child of its parent
    |'
  prefs: []
  type: TYPE_TB
- en: '| `E:`n`th-child(`n`)` | Matches element `E` if it is the *n*th child of its
    parent |'
  prefs: []
  type: TYPE_TB
- en: '| `E:empty` | Matches element `E` if it has no children |'
  prefs: []
  type: TYPE_TB
- en: '| `E:link` | Matches element `E` if it is a hyperlink anchor such as `<a>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `E:visited` | Matches element `E` if it is a hyperlink anchor such as `<a>`
    that has been visited |'
  prefs: []
  type: TYPE_TB
- en: '| `E:hover` | Matches element `E` when the mouse hovers over it |'
  prefs: []
  type: TYPE_TB
- en: '| `E:active` | Matches element `E` on which the mouse is down |'
  prefs: []
  type: TYPE_TB
- en: '| `E:focus` | Matches element `E` if it has the input focus, meaning that it’s
    listening to the keyboard |'
  prefs: []
  type: TYPE_TB
- en: HTML includes a `<link>` element that can be used to associate a separate file
    containing CSS with a web page. That’s the preferred usage because it conforms
    to the principle of keeping the content separate from the styling. But that’s
    overkill for what we’re doing here. HTML also includes a `<style>` element that
    allows CSS to be embedded directly in HTML documents. That’s what we’ll use for
    our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s modify our web page from [Listing 9-1](ch09.xhtml#ch09list01) to include
    some simple styling, which is shown in bold in [Listing 9-4](ch09.xhtml#ch09list04).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-4: Web page with embedded CSS*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that there are two selectors in [Listing 9-4](ch09.xhtml#ch09list04):
    `body` and `big`. Each selector is followed by a list of property names and values;
    a colon separates each name from its value, there is a semicolon after the value,
    and the list of names and values for each selector is enclosed in curly brackets.
    First, we set the `color` of all text in the document body to `blue`. Next, we
    set the `color` of the text inside the `<big>` element to `yellow`, and we set
    the `font-size` to `200%` of normal. Give it a try!'
  prefs: []
  type: TYPE_NORMAL
- en: CSS was an afterthought; nobody had it in mind when developing HTML. There are
    some quirks as a result. HTML has all sorts of elements with defined meanings.
    For example, there is a `<b>` element that makes text **bold** and a `<i>` element
    for *italics*. But the CSS snippet in [Listing 9-5](ch09.xhtml#ch09list05) changes
    their meanings to be the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-5: Swapping bold and italic using CSS*'
  prefs: []
  type: TYPE_NORMAL
- en: For all intents and purposes, CSS eliminates the distinction between many HTML
    elements. You can think of HTML elements as having a default set of styles, but
    once those styles are changed via CSS, the element name may no longer have any
    relation to to its original purpose.
  prefs: []
  type: TYPE_NORMAL
- en: CSS originally just provided a more flexible mechanism for attaching attributes
    to elements, but then it started adding new attributes. These new attributes were
    not retrofitted into HTML. As a result, some attributes can be specified in both
    HTML and CSS, and others only in CSS. There’s a bit of an attitude among the programming
    community that the old way should no longer be used, but that ignores the issues
    of maintaining existing code.
  prefs: []
  type: TYPE_NORMAL
- en: '**XML and Friends**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'XML looks a lot like HTML. However, like SGML it requires *well-formed* elements.
    This means that each `<tag>` must have a matching `</tag>`. Implicit end tags
    are not permitted. The big distinction between HTML and XML is that HTML was created
    for a specific application: web pages. XML is a general-purpose markup language
    that can be used for many different applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Most XML tags don’t have preassigned meanings. You can assign any meaning to
    them that you want. XML provides structure you can use to create your own application-specific
    markup languages. For example, suppose you want to keep track of vegetables in
    your garden. You could create a Vegetable Markup Language (VML) that looks like
    [Listing 9-6](ch09.xhtml#ch09list06).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-6: XML-based markup language example*'
  prefs: []
  type: TYPE_NORMAL
- en: Conflicts can arise from allowing people to create their own markup languages,
    however. For example, suppose that in addition to VML, someone else creates a
    Recipe Markup Language (RML) that also includes a `<name>` element, as in [Listing
    9-7](ch09.xhtml#ch09list07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-7: XML-based markup language example with name conflict*'
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to tell whether the `<name>` elements are vegetable names or
    recipe names. We need a mechanism to allow us to combine VML and RML without confusing
    the `<name>` elements. This mechanism is an element tag prefix known as a *namespace*.
  prefs: []
  type: TYPE_NORMAL
- en: As you’d expect from something browser related, there are multiple ways to specify
    namespaces, but I cover only one of them here. Each namespace is associated with
    a URL, although there’s no requirement that it be a valid URL; it just has to
    be distinct from the others. The `xmlns` attribute on the `<xml>` element associates
    a namespace prefix with a URL. [Listing 9-8](ch09.xhtml#ch09list08) shows our
    combined garden and recipe markups with distinguishing namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-8: XML-based markup language example with namespaces*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the elements from both fictitious markup languages are combined
    and that they are distinguished by prefix. The namespace prefix is arbitrary and
    left up to whatever is combining the different markup languages together. There’s
    no requirement that `rml` be the prefix for the Recipe Markup Language; we could
    choose `recipe` if we needed to combine this code with another RML, such as Ridiculous
    Markup Language.
  prefs: []
  type: TYPE_NORMAL
- en: Plenty of tools are available to help you write applications that understand
    custom markup languages such as the ones just described. There are also libraries
    for many programming languages that create and operate on parse trees from XML
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: One tool is a *Document Type Definition (DTD)*. You can think of this as meta-markup.
    A DTD is an XML-looking document (there are no ending tags for some reason) that
    defines the legal elements in a markup language. XML includes a mechanism that
    allows an XML document to reference a DTD. You could, for example, make a DTD
    that says that one or more `<vegetable>` elements are allowed in a `<garden>`
    element and that a `<vegetable>` can contain only `<name>`, `<variety>`, and `<days-until-maturity>`
    elements. XML parsers can validate the XML against the DTD. Although this is useful,
    it doesn’t do the most important part. For example, although a DTD can ensure
    that a required `<variety>` exists, it can’t test for a valid variety.
  prefs: []
  type: TYPE_NORMAL
- en: The *XML Path Language (XPath)* provides selectors for XML documents by, as
    you might guess, creating yet another incompatible syntax; it has essentially
    the same functionality of CSS selectors but in a completely different syntax that
    you may need to learn. XPath isn’t very useful by itself but is an important component
    of *Xtensible Stylesheet Language Transformations (XSLT)*.
  prefs: []
  type: TYPE_NORMAL
- en: XSLT is yet another XML-based language. When combined with XPath, it allows
    you to write a piece of XML that transforms an XML document into other forms by
    searching and modifying the parse tree. [Listing 9-9](ch09.xhtml#ch09list09) shows
    a simple example where an XPath expression is used to match any vegetable in the
    garden and then output the name and variety of each, separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-9: Call any vegetable using XSLT and XPath*'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the XSLT in [Listing 9-9](ch09.xhtml#ch09list09) to the XML in [Listing
    9-6](ch09.xhtml#ch09list06) produces the results in [Listing 9-10](ch09.xhtml#ch09list10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-10: Call any vegetable results*'
  prefs: []
  type: TYPE_NORMAL
- en: Another example is shown in [Listing 9-11](ch09.xhtml#ch09list11), which selects
    only vegetables when the value of the name is `rutabaga`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-11: Call it by name*'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the XSLT from [Listing 9-11](ch09.xhtml#ch09list11) to the XML in [Listing
    9-6](ch09.xhtml#ch09list06) produces what you see in [Listing 9-12](ch09.xhtml#ch09list12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-12: Call it by name results*'
  prefs: []
  type: TYPE_NORMAL
- en: XSLT is especially useful for transforming markup containing arbitrary data
    into HTML for display in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our example web page is static—that is, all it does is display some formatted
    text. Going back to [Figure 9-1](ch09.xhtml#ch09fig01), the only way to change
    what’s displayed is to send another URL to a web server to get a new document.
    Not only is this a slow process, but it also wastes resources. If you entered
    a phone number into a form, the data would have to be sent to a server to determine
    whether it contained all numbers, and the server would have to send back a page
    with an error message if it didn’t.
  prefs: []
  type: TYPE_NORMAL
- en: In 1993, Mark Andreesen created the graphical Mosaic web browser, which fueled
    the consumer internet boom. He went on to found Netscape, which released the Netscape
    Navigator browser in 1994\. Realizing the need for more interactive web pages,
    Netscape introduced the JavaScript programming language in 1995\. JavaScript has
    since been standardized by the Ecma International standards organization, formerly
    the European Computer Manufacturers Association, as ECMA-262\. It’s also known
    as ECMAScript, which sounds like a skin condition and has since been known to
    make browsers flaky. JavaScript borrowed from both the C programming language
    and from Java, which itself borrowed from C.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript allows web pages to contain actual programs that run on your computer
    instead of on the server. These programs can modify the DOM and can communicate
    directly with a web server, as shown in [Figure 9-8](ch09.xhtml#ch09fig08).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: Web browser interaction with JavaScript and web server*'
  prefs: []
  type: TYPE_NORMAL
- en: The interaction between the JavaScript program and the server is not the same
    as the browser/server communication we saw in [Figure 9-1](ch09.xhtml#ch09fig01).
    Instead, it takes place via *Asynchronous JavaScript and XML (AJAX)*. Let’s break
    that down. *Asynchronous* is related to what we saw with ripple counters in “[Counters](ch03.xhtml#ch03lev2sec6)”
    on [page 77](ch03.xhtml#page_77); in this instance, it means the browser has no
    control over when (and if) a server responds. The *JavaScript* part just means
    it’s under the control of a JavaScript program. I’m not going to explain the *and*.
    Finally, the data from the server to the JavaScript program was initially encoded
    using *XML*, not HTML.
  prefs: []
  type: TYPE_NORMAL
- en: You can include JavaScript in an HTML document by enclosing it in `<script>`
    elements. Let’s add some to what we had in [Listing 9-4](ch09.xhtml#ch09list04),
    again showing the changes in bold, in [Listing 9-13](ch09.xhtml#ch09list13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-13: Web page with embedded JavaScript*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what this does without going into all the nitpicky details. Part of
    the browser definition is that there is a `window.onload` variable that can be
    set to a function to execute when the initial page has finished loading. Another
    part of the definition says that there is a `document.getElementsByTagName` function
    that returns an array of all matching elements in the DOM. Here it returns the
    one `<big>` element. Finally, it allows us to change various element properties.
    In this case, we set the background color to green.
  prefs: []
  type: TYPE_NORMAL
- en: There are a large number of defined functions for DOM manipulation. They allow
    us to do more than just change CSS styles from a program. There are also functions
    that allow you to rearrange the DOM tree, including the ability to add and delete
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**jQuery**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the browser DOM functions from the previous section has two problems.
    First, the DOM functions don’t have exactly the same behavior on different browsers.
    Second, they’re pretty cumbersome to use—not exactly a user-friendly interface.
  prefs: []
  type: TYPE_NORMAL
- en: Enter *jQuery*, a library introduced by American software engineer John Resig
    in 2006\. It solved both of the problems just mentioned. It smoothed over the
    incompatibilities between browsers so that the programmers using it didn’t have
    to. And it supplied a DOM manipulation interface that was much easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: The jQuery library combines selectors with *actions*. The code in [Listing 9-14](ch09.xhtml#ch09list14)
    does exactly the same thing as the code in [Listing 9-13](ch09.xhtml#ch09list13)
    but in a more programmer-friendly way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-14: Web page with embedded JavaScript and jQuery*'
  prefs: []
  type: TYPE_NORMAL
- en: The first `<script>` element imports the jQuery library; the second contains
    our code. The “document ready” function that the browser calls when the page is
    loaded contains a single jQuery statement. The first part of it, `$('big')`, is
    a selector. It’s similar to the CSS selectors we saw in [Table 9-2](ch09.xhtml#ch09tab02).
    The remainder of the statement, `.css('background', 'green')`, is an action to
    perform on the selected elements. In this case, the `css` function modifies the
    `background` property, setting it to `green`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add the piece of jQuery in [Listing 9-15](ch09.xhtml#ch09list15) to the
    document ready function to add some interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-15: jQuery event handler*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple piece of code attaches an *event handler* to the `<big>` element
    that is executed when the mouse clicks it. This handler does two things: it inserts
    a new `<i>` element before the `<big>` element, and it increases the `<big>` font
    size.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this example, jQuery makes it easy to manipulate the DOM using
    JavaScript. You can open up your browser’s debugging console and watch these changes
    occur when you click.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery blazed a path, and a very popular one at that; the library is very widely
    used. However, as seems endemic in the web community, some programmers decided
    to create parallel, incompatible paths. There are now a number of JavaScript libraries
    that do the same things, only differently.
  prefs: []
  type: TYPE_NORMAL
- en: '**SVG**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Scalable Vector Graphics (SVG)* is kind of an odd duck in the collection of
    browser additions. It’s yet another completely different language that allows
    you to produce nice-looking graphics and text in a manner that is completely incompatible
    with everything else.'
  prefs: []
  type: TYPE_NORMAL
- en: John Warnock and Chuck Geschke founded Adobe Systems in 1982 and developed the
    PostScript language. Warnock had been working on more complicated versions of
    the ideas in PostScript for years, and the development of PostScript was similar
    to the way that the overly complex SGML was simplified to HTML. The duo caught
    a lucky break when Steve Jobs requested that they use PostScript to drive laser
    printers. The PostScript-based Apple LaserWriter was a major factor in the formation
    of the desktop publishing industry and was responsible for Adobe’s success.
  prefs: []
  type: TYPE_NORMAL
- en: PostScript had some issues with *portability*—getting the same results everywhere.
    The *Portable Document Format (PDF)*, based on PostScript, was created to address
    these issues. SVG is more or less PDF wedged into browsers. Of course, SVG and
    PDF aren’t completely compatible because that would make too much sense.
  prefs: []
  type: TYPE_NORMAL
- en: In general, SVG is more automatic than the recently added canvas (covered in
    the next section). You can tell it to do things, and it will, whereas with a canvas
    you have to write a program to manipulate it. Add the contents of [Listing 9-16](ch09.xhtml#ch09list16)
    to the `body` of your web page and give it a spin, because every web page needs
    a red pulsing circle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-16: SVG animated circle*'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML5**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned at the beginning of this chapter, it seems that in the browser
    world, there’s no idea that should be implemented only once. HTML5 is the latest
    incarnation of HTML. Among other things, it adds a big pile of *semantic* elements,
    including `<header>`, `<footer>`, and `<section>`, which—if used as intended—would
    add consistent structure to documents.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 introduces the *canvas*, which provides pretty much the same functionality
    as SVG but in a completely different way. The major difference is that canvases
    can be manipulated only with a new set of JavaScript functions, unlike SVG, which
    can use the existing DOM functions. In other words, you would have to write a
    JavaScript program in order to duplicate [Listing 9-16](ch09.xhtml#ch09list16)
    using a canvas.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 also adds `<audio>` and `<video>`, which provide somewhat standard mechanisms
    for audio and video.
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I touched on AJAX back in “[JavaScript](ch09.xhtml#ch09lev1sec7)” on [page 251](ch09.xhtml#page_251)
    and mentioned that asynchronous XML-formatted data is sent from the server to
    the browser JavaScript program. Well, that’s *so* four sections ago. The *X* in
    AJAX is now a *J* for JSON. Although the acronym AJAJ floats around, the technique
    is still called AJAX.
  prefs: []
  type: TYPE_NORMAL
- en: '*JSON* stands for JavaScript Object Notation. It’s essentially a human-readable
    text format for a JavaScript *object*, which is one of JavaScript’s compound data
    types. The theory is that data in this format can be exchanged in an interoperable
    manner, although problems with the specification mean that this exchange is possible
    only if you adhere to certain unspecified rules such as avoiding certain characters.
    Programmers also need to work around the fact that JSON doesn’t support all the
    JavaScript data types.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-17](ch09.xhtml#ch09list17) builds a JavaScript object and converts
    it to JSON format. It then shows the result that was stored in the variable the_quest,
    shown in bold below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-17: JSON and the Argonauts*'
  prefs: []
  type: TYPE_NORMAL
- en: JSON has an advantage over XML when using JavaScript, and not just because converting
    JavaScript objects into JSON is trivial, as shown in [Listing 9-17](ch09.xhtml#ch09list17).
    The companion JavaScript `eval` function can execute JSON directly, because it’s
    data, as if it’s a JavaScript program. JSON is popular because it eliminates the
    need for extra code to handle data export and import.
  prefs: []
  type: TYPE_NORMAL
- en: Just because it’s easy to use JSON doesn’t mean you can be cavalier about it,
    however. Blithely importing JSON data using `eval` can allow an attacker to execute
    arbitrary code in a browser. More recently, a companion `JSON.parse` function
    has been added that safely converts JSON back into a JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned the basics of how many of the components comprising
    a web browser work. [Figure 9-9](ch09.xhtml#ch09fig09) illustrates the pieces
    we’ve discussed. Of course, browsers include a lot more functionality that isn’t
    particularly interesting, such as bookmarks and history.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: Browser block diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram may look pretty complicated, but it’s just an assemblage of parts
    that you’ve already seen. These include language parsers, parse trees, regular
    expressions, interpreters, networking, input, and output.
  prefs: []
  type: TYPE_NORMAL
- en: It also illustrates a distinction between hardware and software design. Designing
    hardware is more expensive than designing software. It’s unlikely that a hardware
    designer would construct a system that used six different incompatible methods
    to do the same thing before breakfast. But because there isn’t the same up-front
    cost in software, software designers are often less careful. The result is often
    a larger, more complex result that might cost less up front but often costs more
    later because of the number of complicated interoperating parts that must be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned something about the workings of this complex interpreter,
    in the next chapter we’ll write some programs for it. You’ll see a program written
    for a browser in JavaScript and the same program written in C. This will illustrate
    some of the important system-level considerations that are hidden from web programmers
    but are important for system-level programming.
  prefs: []
  type: TYPE_NORMAL
