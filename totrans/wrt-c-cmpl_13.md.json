["```\nmovq    $2, %rax\naddq    $2, %rax\n```", "```\nmovl    $2, %eax\naddl    $2, %eax\n```", "```\n11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111101\n```", "```\n 11111111 11111111 11111111 11111101\n```", "```\n00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000\n```", "```\n 10000000 00000000 00000000 00000000\n```", "```\nmovl    %ecx, %eax\n```", "```\nstatic long var = 100;\n```", "```\n .data\n    .align 8\nvar:\n    .quad 100\n```", "```\nprogram = Program(declaration*)\ndeclaration = FunDecl(function_declaration) | VarDecl(variable_declaration)\nvariable_declaration = (identifier name, exp? init,\n                      ❶ **type var_type,** storage_class?)\nfunction_declaration = (identifier name, identifier* params, block? body,\n                      ❷ **type fun_type,** storage_class?)\n\n❸ **type = Int | Long | FunType(type* params, type ret)**\nstorage_class = Static | Extern\nblock_item = S(statement) | D(declaration)\nblock = Block(block_item*)\nfor_init = InitDecl(variable_declaration) | InitExp(exp?)\nstatement = Return(exp)\n          | Expression(exp)\n          | If(exp condition, statement then, statement? else)\n          | Compound(block)\n          | Break\n          | Continue\n          | While(exp condition, statement body)\n          | DoWhile(statement body, exp condition)\n          | For(for_init init, exp? condition, exp? post, statement body)\n          | Null\nexp = Constant(**const**)\n    | Var(identifier)\n  ❹ **| Cast(type target_type, exp)**\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n    | Assignment(exp, exp)\n    | Conditional(exp condition, exp, exp)\n    | FunctionCall(identifier, exp* args)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan | LessOrEqual\n                | GreaterThan | GreaterOrEqual\n❺ **const = ConstInt(int) | ConstLong(int)**\n```", "```\ntype = Int | FunType(int param_count)\n```", "```\n<program> ::= {<declaration>}\n<declaration> ::= <variable-declaration> | <function-declaration>\n<variable-declaration> ::= {<specifier>}+ <identifier> [\"=\" <exp>] \";\"\n<function-declaration> ::= {<specifier>}+ <identifier> \"(\" <param-list> \")\" (<block> | \";\")\n<param-list> ::= \"void\"\n               | **{<type-specifier>}+** <identifier> {\",\" **{<type-specifier>}+** <identifier>}\n**<type-specifier> ::= \"int\" | \"long\"**\n<specifier> ::= **<type-specifier> |** \"static\" | \"extern\"\n<block> ::= \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n<for-init> ::= <variable-declaration> | [<exp>] \";\"\n<statement> ::= \"return\" <exp> \";\"\n              | <exp> \";\"\n              | \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n              | <block>\n              | \"break\" \";\"\n              | \"continue\" \";\"\n              | \"while\" \"(\" <exp> \")\" <statement>\n              | \"do\" <statement> \"while\" \"(\" <exp> \")\" \";\"\n              | \"for\" \"(\" <for-init> [<exp>] \";\" [<exp>] \")\" <statement>\n              | \";\"\n<exp> ::= <factor> | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n<factor> ::= **<const>** | <identifier>\n           **| \"(\" {<type-specifier>}+ \")\" <factor>**\n           | <unop> <factor> | \"(\" <exp> \")\"\n           | <identifier> \"(\" [<argument-list>] \")\"\n<argument-list> ::= <exp> {\",\" <exp>}\n<unop> ::= \"-\" | \"~\" | \"!\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n**<const> ::= <int> | <long>**\n<identifier> ::= ? An identifier token ?\n<int> ::= ? An int token ?\n**<long> ::= ? An int or long token ?**\n```", "```\nparse_type(specifier_list):\n    if specifier_list == [\"int\"]:\n        return Int\n    if (specifier_list == [\"int\", \"long\"]\n        or specifier_list == [\"long\", \"int\"]\n        or specifier_list == [\"long\"]):\n        return Long\n    fail(\"Invalid type specifier\")\n```", "```\nparse_type_and_storage_class(specifier_list):\n    types = []\n    storage_classes = []\n    for specifier in specifier_list:\n        if specifier is \"int\" **or \"long\"**:\n            types.append(specifier)\n        else:\n            storage_classes.append(specifier)\n\n    **type = parse_type(types)**\n\n    if length(storage_classes) > 1:\n        fail(\"Invalid storage class\")\n    if length(storage_classes) == 1:\n        storage_class = parse_storage_class(storage_classes[0])\n    else:\n        storage_class = null\n\n    return (type, storage_class)\n```", "```\nparse_constant(token):\n    v = integer value of token\n    if v > 2^63 - 1:\n        fail(\"Constant is too large to represent as an int or long\")\n\n    if token is an int token and v <= 2^31 - 1:\n        return ConstInt(v)\n\n    return ConstLong(v)\n```", "```\nexp = Constant(const, **type**)\n    | Var(identifier, **type**)\n    | Cast(type target_type, exp, **type**)\n    | Unary(unary_operator, exp, **type**)\n    | Binary(binary_operator, exp, exp, **type**)\n    | Assignment(exp, exp, **type**)\n    | Conditional(exp condition, exp, exp, **type**)\n    | FunctionCall(identifier, exp* args, **type**)\n```", "```\nclass BaseExp {\n    `--snip--`\n **type expType;**\n}\n```", "```\ntyped_exp = TypedExp(type, exp)\nexp = Constant(const)\n    | Var(identifier)\n    | Cast(type target_type, typed_exp)\n    | Unary(unary_operator, typed_exp)\n    | Binary(binary_operator, typed_exp, typed_exp)\n    | Assignment(typed_exp, typed_exp)\n    | Conditional(typed_exp condition, typed_exp, typed_exp)\n    | FunctionCall(identifier, typed_exp* args)\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n    | Var(v) ->\n        v_type = symbols.get(v).type\n        if v_type is a function type:\n            fail(\"Function name used as variable\")\n        return set_type(e, v_type)\n```", "```\n | Constant(c) ->\n        match c with\n        | ConstInt(i) -> return set_type(e, Int)\n        | ConstLong(l) -> return set_type(e, Long)\n```", "```\n | Cast(t, inner) ->\n        typed_inner = typecheck_exp(inner, symbols)\n        cast_exp = Cast(t, typed_inner)\n        return set_type(cast_exp, t)\n```", "```\n | Unary(op, inner) ->\n        typed_inner = typecheck_exp(inner, symbols)\n        unary_exp = Unary(op, typed_inner)\n        match op with\n        | Not -> return set_type(unary_exp, Int)\n        | _   -> return set_type(unary_exp, get_type(typed_inner))\n```", "```\nget_common_type(type1, type2):\n    if type1 == type2:\n        return type1\n    else:\n        return Long\n```", "```\nconvert_to(e, t):\n    if get_type(e) == t:\n        return e\n    cast_exp = Cast(t, e)\n    return set_type(cast_exp, t)\n```", "```\n | Binary(op, e1, e2) ->\n      ❶ typed_e1 = typecheck_exp(e1, symbols)\n        typed_e2 = typecheck_exp(e2, symbols)\n        if op is And or Or:\n            binary_exp = Binary(op, typed_e1, typed_e2)\n            return set_type(binary_exp, Int)\n      ❷ t1 = get_type(typed_e1)\n        t2 = get_type(typed_e2)\n        common_type = get_common_type(t1, t2)\n        converted_e1 = convert_to(typed_e1, common_type)\n        converted_e2 = convert_to(typed_e2, common_type)\n        binary_exp = Binary(op, converted_e1, converted_e2)\n      ❸ if op is Add, Subtract, Multiply, Divide, or Remainder:\n            return set_type(binary_exp, common_type)\n        else:\n            return set_type(binary_exp, Int)\n```", "```\n | Assignment(left, right) ->\n        typed_left = typecheck_exp(left, symbols)\n        typed_right = typecheck_exp(right, symbols)\n        left_type = get_type(typed_left)\n        converted_right = convert_to(typed_right, left_type)\n        assign_exp = Assignment(typed_left, converted_right)\n        return set_type(assign_exp, left_type)\n```", "```\n | FunctionCall(f, args) ->\n        f_type = symbols.get(f).type\n        match f_type with\n        | FunType(param_types, ret_type) ->\n            if length(param_types) != length(args):\n                fail(\"Function called with the wrong number of arguments\")\n            converted_args = []\n          ❶ for (arg, param_type) in zip(args, param_types):\n                typed_arg = typecheck_exp(arg, symbols)\n                converted_args.append(convert_to(typed_arg, param_type))\n            call_exp = FunctionCall(f, converted_args)\n          ❷ return set_type(call_exp, ret_type)\n        | _ -> fail(\"Variable used as function name\")\n```", "```\ninitial_value = Tentative | Initial(**static_init**) | NoInitializer\n**static_init = IntInit(int) | LongInit(int)**\n```", "```\nstatic int i = 100L;\n```", "```\nstatic int i = 2147483650L;\n```", "```\nStaticVariable(identifier, bool global, **type t, static_init init**)\n```", "```\nval = Constant(**const**) | Var(identifier)\n```", "```\nSignExtend(val src, val dst)\nTruncate(val src, val dst)\n```", "```\nprogram = Program(top_level*)\ntop_level = Function(identifier, bool global, identifier* params, instruction* body)\n          | StaticVariable(identifier, bool global, **type t, static_init init**)\ninstruction = Return(val)\n            **| SignExtend(val src, val dst)**\n            **| Truncate(val src, val dst)**\n            | Unary(unary_operator, val src, val dst)\n            | Binary(binary_operator, val src1, val src2, val dst)\n            | Copy(val src, val dst)\n            | Jump(identifier target)\n            | JumpIfZero(val condition, identifier target)\n            | JumpIfNotZero(val condition, identifier target)\n            | Label(identifier)\n            | FunCall(identifier fun_name, val* args, val dst)\nval = Constant(**const**) | Var(identifier)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual\n                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual\n```", "```\nemit_tacky(e, instructions, symbols):\n    match e with\n    | `--snip--`\n | Cast(t, inner) ->\n        result = emit_tacky(inner, instructions, symbols)\n        if t == get_type(inner):\n          ❶ return result\n        dst_name = make_temporary()\n        symbols.add(dst_name, t, attrs=LocalAttr)\n        dst = Var(dst_name)\n        if t == Long:\n          ❷ instructions.append(SignExtend(result, dst))\n        else:\n          ❸ instructions.append(Truncate(result, dst))\n        return dst\n```", "```\nemit_tacky(e, instructions, **symbols**):\n    match e with\n    | `--snip--`\n    | Binary(op, e1, e2) ->\n        v1 = emit_tacky(e1, instructions, **symbols**)\n        v2 = emit_tacky(e2, instructions, **symbols**)\n        dst_name = make_temporary()\n        **symbols.add(dst_name, get_type(e), attrs=LocalAttr)**\n        dst = Var(dst_name)\n        tacky_op = convert_binop(op)\n        instructions.append(Binary(tacky_op, v1, v2, dst))\n        return dst\n    | `--snip--`\n```", "```\nmake_tacky_variable(var_type, symbols):\n    var_name = make_temporary()\n    symbols.add(var_name, var_type, attrs=LocalAttr)\n    return Var(var_name)\n```", "```\nprogram = Program(top_level*)\n**assembly_type = Longword | Quadword**\ntop_level = Function(identifier name, bool global, instruction* instructions)\n          | StaticVariable(identifier name, bool global, **int alignment, static_init init**)\ninstruction = Mov(**assembly_type,** operand src, operand dst)\n            **| Movsx(operand src, operand dst)**\n            | Unary(unary_operator, **assembly_type**, operand)\n | Binary(binary_operator, **assembly_type**, operand, operand)\n            | Cmp(**assembly_type**, operand, operand)\n            | Idiv(**assembly_type**, operand)\n            | Cdq(**assembly_type**)\n            | Jmp(identifier)\n            | JmpCC(cond_code, identifier)\n            | SetCC(cond_code, operand)\n            | Label(identifier)\n            | Push(operand)\n            | Call(identifier)\n            | Ret\n\nunary_operator = Neg | Not\nbinary_operator = Add | Sub | Mult\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int) | Data(identifier)\ncond_code = E | NE | G | GE | L | LE\nreg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | **SP**\n```", "```\nBinary(Add, Constant(ConstInt(3)), Var(\"src\"), Var(\"dst\"))\n```", "```\nMov(Longword, Imm(3), Pseudo(\"dst\"))\nBinary(Add, Longword, Pseudo(\"src\"), Pseudo(\"dst\"))\n```", "```\nconvert_function_call(FunCall(fun_name, args, dst)):\n    `--snip--`\n    // pass args on stack\n    for tacky_arg in reverse(stack_args):\n        assembly_arg = convert_val(tacky_arg)\n        if assembly_arg is a Reg or Imm operand **or has type Quadword**:\n            emit(Push(assembly_arg))\n        else:\n            emit(Mov(**Longword**, assembly_arg, Reg(AX)))\n            emit(Push(Reg(AX)))\n    `--snip--`\n```", "```\nSignExtend(src, dst)\n```", "```\nMovsx(src, dst)\n```", "```\nTruncate(src, dst)\n```", "```\nMov(Longword, src, dst)\n```", "```\nStaticVariable(identifier name, bool global, **int alignment, static_init init**)\n```", "```\nAllocateStack(bytes)\n```", "```\nBinary(Sub, Quadword, Imm(bytes), Reg(SP))\n```", "```\nDeallocateStack(bytes)\n```", "```\nBinary(Add, Quadword, Imm(bytes), Reg(SP))\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Function(name, global,\n          [Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><param1 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, Reg(DI), param1),\n           Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><param2 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, Reg(SI), param2),</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy next four parameters from registers>,</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">\n           Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><param7 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, Stack(16), param7),\n           Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><param8 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, Stack(24), param8),</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy remaining parameters from stack></samp><samp class=\"SANS_Futura_Std_Book_11\">]</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">+\n        instructions)</samp>\n```", "```\nasm_symtab_entry = ObjEntry(assembly_type, bool is_static)\n                 | FunEntry(bool defined)\n```", "```\nMov(Longword, Imm(0), Pseudo(\"foo\"))\nMov(Quadword, Imm(1), Pseudo(\"bar\"))\n```", "```\nMovsx(Imm(10), Stack(-16))\n```", "```\nMov(Longword, Imm(10), Reg(R10))\nMovsx(Reg(R10), Reg(R11))\nMov(Quadword, Reg(R11), Stack(-16))\n```", "```\nMov(Quadword, Imm(4294967295), Stack(-16))\n```", "```\nMov(Quadword, Imm(4294967295), Reg(R10))\nMov(Quadword, Reg(R10), Stack(-16))\n```", "```\nBinary(Sub, Quadword, Imm(bytes), Reg(SP))\n```", "```\nMov(Longword, Imm(4294967299), Reg(R10))\n```", "```\nMov(Longword, Imm(3), Reg(R10))\n```", "```\n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><global-directive></samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">.bss</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><alignment-directive>\n<name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">\n    <init></samp>\n```", "```\n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><global-directive></samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">.data</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><alignment-directive>\n<name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:</samp> \n <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><init></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">mov</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><t>   </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><dst></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">movslq   </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><dst></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><unary_operator></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><t>    </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><operand></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><binary_operator></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><t>   </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src>, <dst></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">idiv</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><t>  </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><operand></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">cdq</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">cqo</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">cmp</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><t></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><operand></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><operand></samp>\n```"]