- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 23 RECURSION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter covers one of my favorite topics: recursion, or code that calls
    itself. I’ll start with a much more detailed definition, but the only way to truly
    understand this concept is through examples, so we’ll step through multiple instances
    of Batch recursion. One will be the calculation of a factorial, a truly classic
    example, with another being the conversion of a decimal to a hexadecimal. The
    last example will be something that’s quintessentially Batch: a recursive search
    through directories and their subdirectories. Then you’ll learn an important limitation
    to be aware of before you write code that calls itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Recursion* is the technique where a bit of code invokes or calls itself. You
    can do this in the vast majority of coding languages. In a more object-oriented
    language, a command inside a method calls that particular method. Even in a procedural
    language like COBOL, a command inside a program calls that particular program.
    Batch is no different. In recursive Batch, a routine typically contains a call
    command that calls that particular routine. Less frequently, a bat file contains
    a call command that calls that particular bat file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a simple logical beauty to recursion that can best be summed up with
    one word: *elegance*. I was trained as a mathematician before becoming a coder,
    and in both disciplines elegance is the greatest praise, and *functional* is a
    back-handed compliment at best, whether it be in reference to a proof in the former
    discipline or a program in the latter. There are many words and phrases of compliment
    for a piece of code—well-constructed, slick, nifty, smart, well-thought-out—but
    elegant stands alone as the best adjective a coder can hear. But when someone
    calls your code functional, the conceit is “It’ll work, but it’s supremely ugly,
    even logically offensive, and I could’ve done far better.” In the Venn diagram
    of descriptive terms for code and supermodels, the intersection set is a set of
    one: elegant.'
  prefs: []
  type: TYPE_NORMAL
- en: If your first instinct is that recursion sounds like the makings of an endless
    loop, your caution is prudent. If the call is done unconditionally, yes, the result
    will be an endless loop (or a crash when the call stack blows up). Recursion must
    have some sort of conditional logic, usually an if command, that’ll execute code
    for either the recursive case or the base case.
  prefs: []
  type: TYPE_NORMAL
- en: The *recursive case* performs the recursive call, and the *base case* does not.
    A properly designed recursive call will get you one step closer to the base case.
    Several executions of the recursive case usually lead to a call that executes
    the base case, starting the process of backing out of the recursive calls. The
    best way to understand this is through examples (to come), stepping through each
    recursive call and keeping track of the state of each variable for each call,
    often with pencil and paper.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is quite different from the while and do...while commands introduced
    in [Chapter 9](chapter9.xhtml). The goto command branched backward in the code
    to re-execute some code that just executed, but nothing was being called; there
    was no intent of control being returned. Instead, the technique of recursion calls
    or invokes the code of which it’s a part.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is the coding equivalent of the Ouroboros, the mythological serpent
    or dragon eating its own tail (see [Figure 23-1](#fig23-1)). The beast has convergent
    roots dating back to ancient China, Egypt, and Greece. It often symbolizes “eternal
    cyclic renewal,” infinity, eternity, and even alchemy. I’ve long viewed it as
    an excellent metaphor for code invoking itself, even before knowing it by name.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig23-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23-1: A representation of the Ouroboros'
  prefs: []
  type: TYPE_NORMAL
- en: Salvador Dali expressed his typically atypical interpretation of the creature
    in his work *The Ouroboros*. It’s certainly presumptuous, but when I’m done coding
    a bit of recursive logic, I feel a very small affinity to an artist such as Dali,
    imagining the pride he must’ve felt in sharing his works with the world. A great
    painter rightly wants to showcase his works for others to view as a preeminent
    chef surely looks forward to diners sampling her plat du jour. Instead of a gallery
    showing or a restaurant opening, I anticipate the date of the next code review
    with my peers. I’m embellishing to a degree (and not comfortable admitting to
    what degree), but I do take pride in a fine bit of recursion, and I hope that
    you do or will as well.
  prefs: []
  type: TYPE_NORMAL
- en: Factorials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The classic example of recursion in any math or programming text is the factorial,
    and I see no reason to counter tradition. The factorial of *n*, represented by
    *n*!, is *n* × (*n* – 1) × (*n* – 2) ... 2 × 1, or more informally, the product
    of the successive multiplication of the integer and all the integers less than
    it down to 1.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*When asking a mathematician how old he was turning, I received the reply,
    “my last factorial birthday.” He was nearing 24 and didn’t expect to make it to
    120 or 5!. I was once guilty of decorating a 30th birthday cake with 6! / 4!.
    Factorials can be fun as well as useful, but I digress.*'
  prefs: []
  type: TYPE_NORMAL
- en: The factorial of 4 is the product of 4 and the factorial of 3, which is the
    product of 3 and the factorial of 2, which is the product of 2 and the factorial
    of 1, which is simply 1\. The pattern begs for recursion. A routine that accepts
    a number as input and returns its factorial can multiply that number by the factorial
    of the number one less than it. And, the best way to find that second factorial
    is for the routine to call itself. When finding the factorial of an integer greater
    than 1, we invoke the recursive case, and when finding the factorial of 1, we
    have satisfied the base case and elegantly return the number 1\. That’s recursion!
    Now we must turn this into code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The :Factorial routine accepts a numerical input parameter and passes back
    the number’s factorial as the variable name we pass in the second parameter. Before
    getting to the routine itself, the following call to it populates factorial with
    the factorial of 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be expecting a more complex routine, but here it is in its simplicity.
    Take note of the call command recursively invoking the :Factorial routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the input parameter, %~1, equals 1, the if command asserts that the base
    case is satisfied and we set the second parameter, %~2, to 1, because the factorial
    of 1 is 1, and we are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the integer is greater than 1, control goes to the code block under the
    else keyword, where the logic for the recursive case executes. We next find the
    number one less than our input value: nbrLessOne. To determine the factorial of
    nbrLessOne, we recursively call the same exact routine that we are currently in
    and retrieve the result as the lessOneFact variable. Finally, we multiply the
    routine’s input value by the factorial returned from the recursive call, assign
    the result to the second parameter, %~2, which we return to the calling code,
    and we are done.'
  prefs: []
  type: TYPE_NORMAL
- en: This top-down reading of the routine is helpful and a great first step, but
    it glosses over what happens in the successive recursive calls. To really understand
    what’s happening, let’s explore the logic again by stepping through a sample execution
    with the input parameter of 4.
  prefs: []
  type: TYPE_NORMAL
- en: Because 4 is greater than 1, we immediately jump down to the else code block,
    find the prior number of 3, and do the recursive call. Let’s put a breadcrumb
    down and come back to it later.
  prefs: []
  type: TYPE_NORMAL
- en: The second time through the routine, the input parameter is 3, so we call recursively
    again to find the factorial of 2. Place a second breadcrumb at the call command.
  prefs: []
  type: TYPE_NORMAL
- en: The third time through the routine, the input is 2, so we perform yet another
    recursive call, this time to find the factorial of the number 1. Place a third
    breadcrumb.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the if command is true, the base case is satisfied, and we return the
    value 1 as the second parameter, %~2.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can pick up the breadcrumbs in reverse order as we find our way back
    to the original call. At the third breadcrumb we get back the factorial of 1 in
    the lessOneFact variable, and we multiply it by that call’s input parameter, %~1,
    which is 2. We assign the product of 2 to the return parameter and pass it back.
  prefs: []
  type: TYPE_NORMAL
- en: We now find ourselves back at the second breadcrumb where we multiply that call’s
    input parameter of 3 by lessOneFact, which holds the just returned value of 2.
    The routine passes back the result of 6, or the factorial of 3, to the site of
    the first breadcrumb.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic multiplies the original input parameter of 4 by lessOneFact, which
    now holds 6. We return the result of 24 to the original call. That last point
    is subtle and critical: we aren’t passing the result back to one of the recursive
    calls in the routine; we’re finally passing the result back to the original call.
    And we are done.'
  prefs: []
  type: TYPE_NORMAL
- en: The concept may be a bit confusing at first, and there is no shame in rereading
    the last few lines more than once. Curiously, the variables seem to have multiple
    states at one time. The nbrLessOne and lessOneFact variables contain three different
    values each, the input parameter took on four values, and we assigned the output
    parameter four times. Batch accomplishes this with the *call stack*. Before performing
    a recursive call, it stores pertinent data on the call stack, and it can do this
    for multiple calls.
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter places all active variables on the call stack before it does
    the first recursive call. During that call, the variables may take on new values
    that it again places atop the call stack before the next recursive call. When
    control returns from each call, the interpreter simply restores the corresponding
    values from the top of the call stack and continues processing.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, there are means to calculate factorials without recursion, but they
    are uninspired and far less enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: Decimal to Hexadecimal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before converting a decimal number (base 10) to a hexadecimal number (base 16)
    with recursive Batch code, let’s consider how to do it mathematically. For decimal
    numbers less than 256, start by dividing the number by 16, leaving a quotient
    and a remainder. These two numbers will be the two digits of the hexadecimal number,
    with one catch. Either number is in the range from 0 to 15, but we want a single
    character. The numbers 0 through 9 are fine, but if the value is a two-digit decimal
    number, we must map it to a hexadecimal digit. That is, 10 maps to A, 11 maps
    to B, and so on, up to 15 mapping to F.
  prefs: []
  type: TYPE_NORMAL
- en: If the decimal number is between 256 and 4,095, it maps to a three-digit hexadecimal
    number. This requires two rounds of division. The remainder of the first division
    provides the rightmost hexadecimal digit, and we divide the quotient again by
    16\. The remainder becomes the second rightmost hexadecimal digit, and the new
    quotient is the leading hexadecimal digit. As the numbers get larger, the same
    pattern holds; for instance, a six-digit hexadecimal number requires five divisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly the type of pattern that also screams out for recursion. The
    following Batch routine converts a decimal number into a hexadecimal number. Similar
    to the factorials example there are two parameters: the first is the decimal input,
    and the second is the variable containing the hexadecimal output. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I’m storing the 16 hexadecimal characters in hexChars for later use. The routine
    divides the decimal number by 16, giving us quotient, while modulo division by
    16 gives us remainder. If the quotient is 0, the result is a single character.
    This is the base case. We substring the appropriate character out of hexChars,
    using remainder as the offset. Notice that 0 maps to 0, 1 maps to 1, and so on,
    until 9 maps to 9. Then 10 maps to A, 11 maps to B, and, ultimately, 15 maps to
    F. We return this single digit as the value of the second parameter to complete
    the base case.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive case occurs when quotient is greater than 0. The quotient variable
    needs to be converted further, so we perform a recursive call of :GetHex and get
    back its hexadecimal value in the recur variable, which can be one to many characters.
    We assign the return parameter a concatenation of this value and the same mapping
    of the remainder to a hexadecimal digit that we just witnessed.
  prefs: []
  type: TYPE_NORMAL
- en: '(By the way, notice the two concatenated values. We resolve the recur variable
    with exclamation marks because it’s assigned in the code block as part of the
    call command. The rightmost byte is resolved from this text: !hexChars:~%remainder%,1!.
    This time I’m employing delayed expansion with the exclamation marks after first
    resolving the offset, or remainder, with percent signs.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To really understand this logic, let’s step through it to convert 700 to a
    hexadecimal number. First, let’s do it mathematically: 700 / 16 = 43 with a remainder
    of 12\. The 12 maps to the hexadecimal digit C, which will be the rightmost byte
    of the final result. Next, 43 / 16 = 2 with a remainder of 11, which maps to the
    next byte from the right in the final result, B. The quotient of 2 is a one-digit
    number, so it represents itself. The result is the hexadecimal number, 2BC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following call command returns the value 2BC as the hexVal variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Taking this step by step, since the input parameter is 700, the quotient variable
    is 43, and the remainder variable is 12. Because quotient isn’t 0, the recursive
    case logic executes. The interpreter puts the remainder of 12 on the stack for
    now and passes 43 as the first parameter of a recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: In this pass, quotient is 2, and remainder is 11. Again, the recursive case
    logic executes, and 11 finds its way onto the stack as we pass 2 in another recursive
    call.
  prefs: []
  type: TYPE_NORMAL
- en: In what’ll be the final pass, quotient is 0, and remainder is 2. Since quotient
    equals 0, the base case logic finally executes. The decimal digit 2 maps to the
    hexadecimal digit 2, and we pass it back as the output parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s reverse direction and step back through the calls that we just made.
    The interpreter restores remainder to its value of 11 before the set command concatenates
    two values. The first is the just returned value of 2, and the second is B, which
    we mapped to from the 11. Hence, the routine passes back 2B as the output parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the initial pass, the interpreter restores the remainder variable of
    12 from the call stack. We concatenate two values, the just returned 2B and C,
    which is the hexadecimal value corresponding to the 12. Finally, the routine passes
    back 2BC as the output parameter to the original call command.
  prefs: []
  type: TYPE_NORMAL
- en: With each call, the recursive logic is determining another hexadecimal digit,
    ultimately returning a multibyte hexadecimal value. At first glance, these few
    lines of code might not look like much, but under close inspection the routine
    turns out to be quite involved and interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Directory Searches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last two examples offer great demonstrations of recursion, allowing us to
    step through the recursive calls, but for my last example I want something that
    has Batch in its DNA, something not easily done in other languages. We’ll recursively
    search a directory and all of its subdirectories to produce a report detailing
    the total number of bytes and files in each folder.
  prefs: []
  type: TYPE_NORMAL
- en: If that sounds familiar, you learned about the for command with the /D (directory)
    and /R (recursion) options in [Chapter 18](chapter18.xhtml). This command easily
    created a simple list of all the subdirectories, but it handled the recursive
    call for you and didn’t leave much room for modifications. True recursion provides
    much more flexibility and power over the output, and that’s what we’ll do here.
  prefs: []
  type: TYPE_NORMAL
- en: Before coding the recursive routine, we need a plan and some analysis. To produce
    the detail records, we’ll use a dir command targeting a directory and use it as
    the input to a for /F command. The routine will write the totals for the directory
    to the report and recursively call itself, passing each subdirectory. Then it
    will process each subdirectory, making recursive calls for any subdirectories
    of subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only way to write code like that is to see the output of the embedded command,
    in this case a dir command. Depending on the contents of the directory, the dir
    C:\Batch\* command might produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’ll need to skip seven lines, the five header records plus the two entries
    showing directories of one or two periods. Of the remaining records, if the second
    token equals File(s), we’ve found the entry with the total number of files (token
    1) and total bytes of those files (token 3). If the fourth token equals <DIR>,
    we’ve found a folder name for a subdirectory (token 5). We don’t know much about
    the subdirectory yet, but a recursive call will bring up the same type of information
    about it. We can ignore the other records detailing each file and the final trailer
    record.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could write the data to the console, but let’s use our report writing skills
    from [Chapter 22](chapter22.xhtml). The first section of code creates the header
    data and makes the initial call to the recursive :GetFldrSz routine that gets
    the folder information starting with the contents of *C:\Batch\*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Focusing on the :GetFldrSz routine, the for /F command uses a dir command as
    its input, and that command uses the routine’s sole parameter, a directory, appended
    with a wildcard as its argument. The for /F command uses five tokens (tokens=1-5)
    and skips the unwanted header records (skip=7).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the fourth token, %%d, equals <DIR>, we’ve found the recursive case; the
    recursive call passing as its argument the input directory appended with the name
    of the subfolder from the fifth token: %~1\%%e. Otherwise, the base case looks
    for the second token, %%b, to match the text File(s). If so, we store the total
    number of files and bytes in the folder in variables padded with leading spaces.
    Using those recently learned formatting techniques, we write a record to the report
    detailing the three pieces of information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the directory structure isn’t very complex, this code might write the following
    recursively generated report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The last line contains the information from the dir command we executed to get
    a feel for the expected output, and it also shows the root directory argument
    from the initial call command. The other four detail lines are products of the
    recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this design is that the code makes a call for each subfolder,
    regardless of how many exist, if any at all. This routine is a framework, and
    there are countless auxiliary processes possible with minor modifications. Perhaps
    only directories in excess of a certain number of files or bytes should make the
    report. Shifting attention to files, perhaps you want to flag recently modified
    files to be part of an entirely different report, or maybe archive them. Perhaps
    you want to delete old or excessively large files, or maybe files fitting a certain
    mask or having a certain attribute. The list goes on.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of caveats, however. The previous code doesn’t work on a
    root directory such as *C:\* because we are skipping the first two detail records
    produced by the dir command (the <DIR> records with one or two dots for the directory).
    Remember from [Chapter 13](chapter13.xhtml) that this command doesn’t display
    those two records when the argument is just a drive letter. With some modifications,
    we can account for that issue, but the other caveat is more of a batveat, and
    it applies more generally to recursion. It’s the possibility of a stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion Stack Overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The primary batveat concerning recursion is important, yet very avoidable.
    With each successive recursive call, the interpreter places data onto the call
    stack, allowing you to use a variable that may have scores of values, one for
    each invocation. But memory is finite, and the interpreter doesn’t allocate much
    of it for the call stack. When it reaches 90 percent of its allocation, the interpreter
    aborts with a message such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Setting aside all justified critiques of Batch’s seemingly random use of capitalization
    and space-delimited lettering, this failed after 507 recursive calls, but 506
    isn’t the limit. I’ve used recursion quite a bit and have never seen it blow up
    with 300 or fewer recursive calls, but it varies greatly from machine to machine
    and from situation to situation. Every language has a limitation on recursion,
    but most usually allow far more levels. This is manageable, but you must take
    this limitation into consideration when coding a solution.
  prefs: []
  type: TYPE_NORMAL
- en: If the code is part of a larger process in an environment where an abort might
    result in a substantial financial loss with the possibility of you and others
    being woken up in the middle of the night to address the fallout, then you should
    limit recursive calls to situations where the call stack will max out well below
    the threshold of a possible overflow. But please don’t let this scare you off
    from such a wonderful technique. Well-designed recursion will easily stay inside
    these guardrails.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the conversion of an integer to a hexadecimal number requires
    10 or fewer recursive calls for numbers less than nine trillion. Even the recursive
    code traversing a directory structure isn’t in danger of overflowing the call
    stack. Some directories might hold hundreds of subdirectories, but a close reading
    of the code in the previous section shows that sibling folders are never on the
    call stack at the same time. The interpreter continually adds and removes items
    from the call stack so that it’s never deeper than the level of the deepest folder
    from the root, rarely more than a dozen. You can safely code these solutions in
    any language, including Batch.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I hope that you enjoyed this chapter as much as I did. You’ve learned how recursion
    works from a coder’s perspective and the interpreter’s perspective—that is, I
    demonstrated how to execute recursion and also discussed how the interpreter is
    using the call stack behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: I also demonstrated the usefulness of stepping through the code, recursive call
    by recursive call, with detailed examples. You must be careful of overflowing
    the recursion stack, but recursion is a wonderfully elegant tool when used wisely.
    Be on the lookout for problems in need of a recursive solution. For any process
    that iterates through a finite number of repetitive steps, a loop is usually the
    first solution that comes to mind, but look for the recursive case and the base
    case. If you see them, you can write some recursive logic. (For more on this topic,
    see [Chapter 23](chapter23.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is great for searching directories. In the next chapter, I’ll also
    discuss searches, but with a far more narrowed focus. Instead of searching every
    directory on your computer, you’ll learn how to search for a string inside a larger
    string, a file, or even multiple files.
  prefs: []
  type: TYPE_NORMAL
