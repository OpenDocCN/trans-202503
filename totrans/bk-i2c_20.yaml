- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Bare-Metal Peripheral Programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 裸机外设编程
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Chapter 11 described how to program an I²C controller device at the register
    level. This chapter provides the complement to that information, showing how to
    program an MCU as an I²C peripheral at the machine register level, allowing you
    to create your own I²C peripherals. To do so, it explores a fairly comprehensive
    example of such programming running on the ATtiny84 MCU, a SparkFun Atto84 board.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第 11 章描述了如何在寄存器级别编程 I²C 控制器设备。本章提供了与此信息互补的内容，展示了如何在机器寄存器级别将 MCU 编程为 I²C 外设，允许你创建自己的
    I²C 外设。为此，本章探索了一个相当全面的编程示例，运行在 ATtiny84 MCU 上，一个 SparkFun Atto84 开发板上。
- en: Creating a software-based (bit-banging) I²C peripheral on such an MCU as simple
    and slow as the ATtiny84 is next to impossible (see Chapter 3, which punted on
    this task). Fortunately, the ATtiny84 provides hardware support that enables the
    peripheral programming covered in this chapter, fulfilling the promise in Chapter
    3 to provide support for an I²C peripheral on the ATtiny84.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 ATtiny84 这样简单且速度较慢的 MCU 上创建基于软件（位级控制）的 I²C 外设几乎是不可能的（请参见第 3 章，该章节已放弃这一任务）。幸运的是，ATtiny84
    提供了硬件支持，使得本章所涉及的外设编程成为可能，履行了第 3 章中承诺提供 ATtiny84 支持 I²C 外设的承诺。
- en: 16.1 The ATtiny as an I²C Peripheral
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 ATtiny 作为 I²C 外设
- en: The ATtiny84—and, in fact, most of the members of the Atmel ATtiny family—provides
    a couple of pieces of hardware that dramatically reduce the burden on software
    when processing I²C bus transactions. The first and arguably most important is
    the *Universal Serial Interface (**USI)*, a generic shift register than can handle
    up to 8 data bits before overflowing (though it can be programmed for fewer bits).
    On the ATtiny84, you can use the USI port to implement I²C, SPI, serial, USB,
    and other types of communication (hence the word *Universal* in its name).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ATtiny84——事实上，Atmel ATtiny 系列的大部分成员——提供了几种硬件支持，显著减少了处理 I²C 总线事务时软件的负担。首先也是最重要的支持是*通用串行接口（**USI**）*，一个通用的移位寄存器，能够处理最多
    8 位数据，直到溢出（尽管它可以编程为处理更少的位）。在 ATtiny84 上，你可以使用 USI 端口实现 I²C、SPI、串行、USB 和其他类型的通信（因此它名字中的
    *Universal* 代表了这一点）。
- en: You can either program the USI to accept data from an external pin and make
    that serial data available as an 8-bit byte (serial to parallel mode) or use the
    USI to accept an 8-bit data value and shift it out serially on some pin. By connecting
    the input and output on the USI to the SDA pin, you can enable the USI to receive
    data from the I²C bus or transmit data onto the I²C bus. You can also select the
    USI’s clock source, using either an internal timer or an external pin. This is
    useful for I²C operation—if you choose the external option and use the SCL pin
    at the clock source, you can shift data into the USI synchronized to the SCL clock
    signal.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编程 USI 接收来自外部引脚的数据，并将这些串行数据作为 8 位字节（串行转并行模式）提供，或者使用 USI 接收 8 位数据值并将其串行输出到某个引脚。通过将
    USI 的输入和输出连接到 SDA 引脚，你可以启用 USI 从 I²C 总线接收数据或将数据传输到 I²C 总线。你还可以选择 USI 的时钟源，使用内部定时器或外部引脚。这对于
    I²C 操作非常有用——如果你选择外部选项并使用 SCL 引脚作为时钟源，你可以将数据与 SCL 时钟信号同步地移入 USI。
- en: Beyond the USI, the ATtiny84 also provides a start condition detector and a
    shift-register overflow interrupt that allow you to quickly handle important I²C
    conditions that are difficult to manage on an 8-MHz CPU’s software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 USI，ATtiny84 还提供了一个起始条件检测器和一个移位寄存器溢出中断，允许你快速处理一些在 8 MHz CPU 的软件中难以管理的 I²C
    条件。
- en: The USI and other support hardware are not a true I²C interface; indeed, Atmel
    often refers to this as the two-wire interface, since they don’t fully support
    the I²C standard. For example, the USI does not support glitch filtering or slew
    rate control. You’ll have to live with other compromises as well (such as having
    to do considerable work in software), because the USI was not designed specifically
    for I²C communications. It’s a jack of all trades, master of none.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: USI 和其他支持硬件并不是真正的 I²C 接口；事实上，Atmel 通常将其称为双线接口，因为它们并不完全支持 I²C 标准。例如，USI 不支持故障滤波或速率控制。你还必须接受其他妥协（例如需要在软件中进行大量工作），因为
    USI 并不是专门为 I²C 通信设计的。它是一个多面手，但不是专家。
- en: The information in this chapter comes from two main sources. The first is the
    Atmel AVR312 application note, “Using the USI Module as a I²C Slave,” which describes
    how to implement I²C communication using the USI. The second and biggest source
    is the TinyWire library (see “For More Information” at the end of this chapter).
    This site lists many contributors, including BroHogan, Don Blake, Jochen Toppe,
    and Suovula; see the source code for complete details.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的信息来源于两个主要来源。第一个是Atmel AVR312应用说明《将USI模块用作I²C从设备》，该说明描述了如何使用USI实现I²C通信。第二个也是最大的来源是TinyWire库（请参阅本章末尾的“更多信息”）。该网站列出了许多贡献者，包括BroHogan、Don
    Blake、Jochen Toppe和Suovula；完整的详细信息请查看源代码。
- en: This chapter will not repeat the discussion of the ATtiny84 MCU registers appearing
    in Chapter 11\. Please refer to section 11.2, “ATtiny Controller Programming,”
    in Chapter 11 for information concerning the registers and the USI.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会重复讨论第11章中出现的ATtiny84 MCU寄存器。有关寄存器和USI的详细信息，请参考第11章第11.2节《ATtiny控制器编程》。
- en: 16.2 Introducing the Memory Peripheral
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 介绍内存外围设备
- en: With a generic microcontroller like the ATtiny84, you can create a wide variety
    of different peripheral lines. For example, you could easily use the device to
    build a small port expander or ADC, given the on-board digital I/O and analog
    input pins. Alternatively, you could create something fancier like a NeoPixel
    driver (see “For More Information”) or just about anything else you could connect
    to an Atto84 (minus two pins, needed for the SDA and SCL lines).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像ATtiny84这样的通用微控制器，你可以创建各种不同的外围设备。例如，凭借其板载的数字I/O和模拟输入引脚，你可以轻松地使用该设备构建一个小型端口扩展器或ADC。或者，你还可以创建更复杂的设备，如NeoPixel驱动程序（参见“更多信息”）或其他任何你能够连接到Atto84的设备（减去两个引脚，用于SDA和SCL线）。
- en: 'This chapter will show you how to create a simple 4-byte memory peripheral,
    something you probably won’t have any real-world use for. However, working with
    this almost trivial device has some advantages:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你展示如何创建一个简单的4字节内存外围设备，虽然这个设备在实际应用中可能没什么用处。然而，使用这个几乎是微不足道的设备有一些优势：
- en: 'Because it’s simple, it’s easy to understand. You won’t waste time trying to
    figure out how the device works in addition to the intended challenge: learning
    how to create an I²C peripheral device.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为它简单，所以容易理解。你不会浪费时间去弄明白设备如何工作，除了预定的挑战：学习如何创建一个I²C外围设备。
- en: It reduces the amount of code you have to read (and the number of pages in this
    book you need to pay for).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了你需要阅读的代码量（以及你需要支付的本书页数）。
- en: 'It provides a framework for creating more complex devices: you can easily strip
    out the trivial memory device code and insert code for your own real-world device.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个框架，用于创建更复杂的设备：你可以轻松去除不必要的内存设备代码，并插入你自己实际设备的代码。
- en: This memory device supports four memory locations. You can read and write any
    number of these locations with a single operation. You can also specify a starting
    offset into the array; if the length you specify would go beyond the end of the
    array, the index simply wraps back around to the beginning.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内存设备支持四个内存位置。你可以通过单次操作读取和写入这些位置中的任意数量。你还可以指定数组的起始偏移量；如果你指定的长度超出了数组的末尾，索引会自动回绕到数组的开头。
- en: The I²C write command takes the form shown in [Figure 16-1](#figure16-1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: I²C写入命令采用[图16-1](#figure16-1)所示的形式。
- en: '![](image_fi/502468c16/f16001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c16/f16001.png)'
- en: 'Figure 16-1: Peripheral write command'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-1：外围设备写入命令
- en: 'The write command actually serves two purposes: as you would expect by its
    name, it allows you to write data to the four memory locations (registers). It
    also lets you specify the memory address (register number) from which subsequent
    read commands will retrieve their data along with the amount of data to fetch.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 写入命令实际上有两个目的：正如它的名字所暗示的那样，它允许你将数据写入四个内存位置（寄存器）。它还允许你指定内存地址（寄存器号），后续的读取命令将从该地址获取数据，并且可以指定要获取的数据量。
- en: Read commands take the form shown in [Figure 16-2](#figure16-2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 读取命令采用[图16-2](#figure16-2)所示的形式。
- en: '![](image_fi/502468c16/f16002.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c16/f16002.png)'
- en: 'Figure 16-2: Peripheral read command'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-2：外围设备读取命令
- en: 'Notice that a command byte immediately follows the I²C address byte in an I²C
    write transaction. The LO 3 bits (sss) specify a data transfer length that must
    be in the range 0 to 4; larger values are clipped to 4\. Bits 3 and 4 (rr) specify
    the starting offset into the register array (the register number). Bit 5 (d) specifies
    a data direction: a 0 means that the rrsss bits apply to the data that immediately
    follow the command byte, which will be written to the register, while a 1 tells
    the peripheral to ignore any further data (until a stop condition comes along)
    and use the rrsss bits for the next I²C read operation.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 I²C 写事务中，命令字节紧跟在 I²C 地址字节后面。低 3 位（sss）指定数据传输长度，必须在 0 到 4 的范围内；更大的值会被限制为
    4。第 3 位和第 4 位（rr）指定寄存器数组的起始偏移量（寄存器号）。第 5 位（d）指定数据方向：0 表示 rrsss 位应用于紧随命令字节之后的数据，这些数据将写入寄存器，而
    1 则告诉外设忽略任何进一步的数据（直到出现停止条件），并将 rrsss 位用于下一个 I²C 读取操作。
- en: 'Consider the following I²C bus sequences:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 I²C 总线序列：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first byte of the first line is an I²C write operation to the device at
    address 0x20 (the memory peripheral). The command byte specifies d = 0 (memory
    write), rr = 0, and sss = 4\. This writes the following 4 bytes (1, 2, 3, and
    4) to memory locations 0 through 3\.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的第一个字节是一个 I²C 写操作，针对地址为 0x20（内存外设）的设备。命令字节指定 d = 0（内存写），rr = 0，sss = 4。此操作将
    4 个字节（1、2、3 和 4）写入内存位置 0 到 3。
- en: The second line is also an I²C write operation. The command byte specifies d
    = 1 (memory read), rr = 0, and sss = 4\. When the d bit is 0, there is no data
    payload after the command byte. This write operation appears to be specifying
    a memory read operation, which might seem odd; in reality, however, it’s just
    setting the peripheral’s read parameter registers in preparation for a data read.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行也是一个 I²C 写操作。命令字节指定 d = 1（内存读取），rr = 0，sss = 4。当 d 位为 0 时，命令字节后没有数据负载。这个写操作看起来像是指定一个内存读取操作，虽然这可能有些奇怪；实际上，它只是为数据读取准备外设的读取参数寄存器。
- en: The third line in this example is an I²C read operation (LO bit of the address
    byte contains 1). Immediately after the controller puts this address byte on the
    bus, the peripheral responds by returning 4 bytes (the number of bytes specified
    by the previous write command on line two). In this case, `ww`, `xx`, `yy`, and
    `zz` will actually be 01, 02, 03, and 04, as the command on the first line previously
    wrote those values to the registers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的第三行是一个 I²C 读取操作（地址字节的 LO 位为 1）。当控制器将该地址字节放到总线上时，外设通过返回 4 个字节（由第二行的写命令指定的字节数）作出响应。在此案例中，`ww`、`xx`、`yy`
    和 `zz` 实际上将是 01、02、03 和 04，因为第一行的命令已将这些值写入寄存器。
- en: This memory peripheral has some additional semantics, but you should now understand
    the core of what is happening in the code. I’ll refer you to the source code for
    more specific issues, such as address wraparound, multiple read operations, and
    so on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内存外设具有一些额外的语义，但你现在应该理解代码中发生的核心内容。对于更具体的问题，如地址环绕、多次读操作等，我将引导你查看源代码。
- en: 16.3 The Memory Peripheral Software Architecture
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 内存外设软件架构
- en: 'The memory peripheral software has four main components:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 内存外设软件有四个主要组件：
- en: Initialization code
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化代码
- en: Interrupt service routines
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断服务例程
- en: Callbacks to the main program (from the ISRs)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 ISRs 到主程序的回调
- en: The main loop
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主循环
- en: 'The program is broken up into two pieces: the main file containing the Arduino
    `setup()` and `loop()` functions, as well as the callback functions, and a second
    file containing the library code that handles I²C operations—specifically, the
    ISRs and utility functions (which the following paragraphs briefly describe).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 程序被分为两个部分：一个主文件，包含 Arduino 的`setup()`和`loop()`函数，以及回调函数；另一个文件包含处理 I²C 操作的库代码——具体来说，是中断服务例程（ISRs）和实用函数（接下来的段落将简要描述这些）。
- en: The `setup()` function calls the ISR library initialization function and sets
    up pointer addresses to the callback functions. The main Arduino loop is empty
    (the CPU just idly spins when interrupt processing isn’t happening) because the
    ISRs handle all the work. In a more complex peripheral design, you’d probably
    handle background activities in the main loop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()`函数调用 ISR 库初始化函数，并设置指向回调函数的指针地址。主 Arduino 循环为空（当没有中断处理时，CPU 只是空闲旋转），因为所有工作都由
    ISRs 处理。在更复杂的外设设计中，你可能会在主循环中处理后台活动。'
- en: 'There are three callback functions in this program, which the ISRs call in
    three situations:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序中有三个回调函数，ISRs会在三种情况中调用它们：
- en: Before transmitting any data from the peripheral to the controller in response
    to an I²C read request
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在响应I²C读取请求之前，从外设传输任何数据到控制器
- en: After transmitting the data from the peripheral to the controller in response
    to an I²C read request, when an ACK or a NAK is expected from the controller
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在响应I²C读取请求之后，从外设传输数据到控制器时，期望从控制器接收到ACK或NAK
- en: Upon receiving data from the controller in response to an I²C write request
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在收到来自控制器的数据后，以响应I²C写入请求
- en: These callbacks are generally responsible for supplying data to send to the
    controller (for an I²C read operation) or dealing with data arriving from a controller
    (for an I²C write operation).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调函数通常负责提供要发送到控制器的数据（用于I²C读取操作），或处理来自控制器的数据（用于I²C写入操作）。
- en: 'The two main ISRs in the system handle two events: the presence of a start
    condition and the completion of a data byte transaction (receipt or transmission)
    on the I²C bus. Because these events happen infrequently and don’t demand too
    much processor time, I²C transactions don’t swamp the CPU as they did in the bit-banging
    approach (see Chapter 3 for the bit-banging approach).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的两个主要中断服务例程处理两个事件：启动条件的存在和I²C总线上数据字节事务（接收或传输）的完成。由于这些事件发生频率较低，且不会占用过多处理器时间，因此I²C事务不会像位操作法那样淹没CPU（有关位操作法，请参见第3章）。
- en: 16.3.1 The Main File
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.1 主文件
- en: This section walks through *attiny84_Periph.ino*, the main program for the memory
    peripheral device. Because of the size and complexity of this source file, I will
    break it up into pieces and describe each piece separately.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讲解*attiny84_Periph.ino*，这是内存外设设备的主程序。由于此源文件的大小和复杂性，我将其拆分成若干部分并分别描述每一部分。
- en: 'The first section covers the comments and `#include` statements you find in
    a typical C or C++ program:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分涵盖了你在典型的C或C++程序中常见的注释和`#include`语句：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, the memory peripheral program stores the 4 bytes in the `i2c_regs` variable:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，内存外设程序将4个字节存储到`i2c_regs`变量中：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This section of the program also contains the global variables that track the
    rr and sss values in the last command byte. There are two sets of these variables—one
    for memory read operations (d = 1) and one for memory write operations (d = 0).
    This section also includes some defines for command bit masks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序部分还包含全局变量，用于跟踪最后一个命令字节中的rr和sss值。这里有两组这些变量——一组用于内存读取操作（d = 1），另一组用于内存写入操作（d
    = 0）。此部分还包括一些用于命令位掩码的定义。
- en: 'The next section begins the callback routines. The interrupt service routines
    call the `requestHandledEvent()` function once it’s done transmitting a byte to
    the controller in response to an I²C read command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节开始回调例程。中断服务例程在完成向控制器传输一个字节以响应I²C读取命令后，会调用`requestHandledEvent()`函数：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, the code expects an ACK or a NAK from the controller. Normally,
    this function would handle cleanup (such as clearing buffers, turning off electronic
    signals, and so on). However, since the memory peripheral requires no cleanup,
    this function simply returns. For this project, you technically could have skipped
    initializing the pointer to this function, since the library’s default condition
    is to do nothing; I’ve included it just so you’re aware of its presence in the
    system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，代码期望从控制器接收到一个ACK或NAK。通常，这个函数会处理清理工作（如清除缓冲区、关闭电子信号等）。然而，由于内存外设无需清理，因此此函数简单地返回。对于这个项目，技术上你可以跳过初始化该函数的指针，因为库的默认条件是无操作；我加入它只是为了让你知道它在系统中的存在。
- en: Next comes the `requestEvent()` callback function. The ISRs call this function
    when an I²C read command has arrived, before actually transmitting any data to
    the controller.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`requestEvent()`回调函数。当收到I²C读取命令时，中断服务例程会调用此函数，实际传输任何数据到控制器之前。
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In theory, you could use this function to initialize the output stream with
    the data that the ISRs will transmit to the controller, but this code uses `usiI2CTransmitByte()`
    for that purpose. Like the Arduino `Wire.write()` function, `requestEvent()` doesn’t
    actually transmit the data; the function just appends it to an internal buffer.
    The ISRs will handle the actual data transmission later. In this source code,
    this buffer has a limited length of 16 bytes. If you attempt to insert more than
    16 bytes into the buffer, the code will block until space becomes available. For
    the memory peripheral device, `requestEvent()` just fetches the number of bytes
    specified by the `read_size` variable (filled in by the sss field of the command
    byte from the previous write operation), starting at the offset specified by the
    `read_position` global (from the rr field).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以使用此函数初始化输出流，向控制器发送ISRs将传输的数据，但这段代码使用`usiI2CTransmitByte()`来实现这个目的。与Arduino的`Wire.write()`函数类似，`requestEvent()`并不实际传输数据；该函数只是将数据附加到一个内部缓冲区中。ISRs将在稍后处理实际的数据传输。在这段源代码中，这个缓冲区的最大长度为16个字节。如果你试图将超过16个字节的数据插入缓冲区，代码会阻塞，直到空间可用。对于内存外设，`requestEvent()`仅获取由`read_size`变量指定的字节数（由前一个写操作中的命令字节的sss字段填写），并从`read_position`全局变量（来自rr字段）指定的偏移量开始。
- en: Next, the callback function `receiveEvent()` handles the data stream received
    from the controller during an I²C write operation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，回调函数`receiveEvent()`处理在I²C写操作期间从控制器接收的数据流。
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `receiveEvent()` function is responsible for stripping out the bits from
    the command byte, parsing the command, and dealing with any additional data appearing
    beyond the command byte (that is, writing that data to the `i2c_regs` array).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`receiveEvent()`函数负责从命令字节中提取位，解析命令，并处理命令字节之后出现的任何额外数据（即，将数据写入`i2c_regs`数组）。'
- en: Next, the `setup()` function calls the ISR library code’s initialization function
    `usiI2CPeripheralInit()`, which does most of the real work, and then sets up the
    address of the callback functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`setup()`函数调用ISR库代码的初始化函数`usiI2CPeripheralInit()`，该函数完成大部分实际工作，然后设置回调函数的地址。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `setup()` function must also initialize the pointers to the callback functions.
    Since the ISRs do all the real work, the main Arduino loop is empty:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()`函数还必须初始化回调函数的指针。由于ISR执行所有实际工作，主Arduino循环是空的：'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If this peripheral device were a little more complex, the `main()` function
    could handle some background tasks while waiting for I²C commands to arrive.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个外设设备稍微复杂一些，`main()`函数可以在等待I²C命令到达时处理一些后台任务。
- en: 16.3.2 The Interrupt Service Routine Library
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.2 中断服务例程库
- en: This section will discuss *usiI2CPeriph.c*, the source code for the ISR module.
    This is a modification of the original AVR two-wire peripheral code written by
    Donald Blake and modified by Jochen Toppe. I have made further modifications to
    adjust for the sample application in *attiny84_Periph.ino*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论*usiI2CPeriph.c*，这是ISR模块的源代码。它是由Donald Blake编写的原始AVR双线外设代码的修改版，并由Jochen
    Toppe进行了修改。我进一步修改了它，以适应*attiny84_Periph.ino*中的示例应用。
- en: As in the previous section, I’ll describe this code piece by piece. As this
    code is an implementation of the architecture that Atmel’s AVR312 application
    note describes, it wouldn’t hurt to have a copy of the application note available
    so you can reference it while reading this code (see “For More Information”).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 和上一节一样，我将逐行描述这段代码。由于这段代码实现了Atmel的AVR312应用笔记中描述的架构，因此有一份应用笔记作为参考在阅读这段代码时会很有帮助（见“更多信息”）。
- en: 'As usual, the first part of the source file contains introductory comments,
    header file includes, and some important defines and macros:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，源文件的第一部分包含简介注释、头文件包含以及一些重要的定义和宏：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `DDRA`, `PORTA`, `PORTA6`, `PINA6`, `PINA4`, `USISIF`, `USI_START_vect`,
    and `USI_OVF_vect` definitions appear in the *avr/io.h* header file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`DDRA`、`PORTA`、`PORTA6`、`PINA6`、`PINA4`、`USISIF`、`USI_START_vect`和`USI_OVF_vect`定义出现在*avr/io.h*头文件中。'
- en: 'The `USI Overflow` ISR (from AVR312, `ISR( USI_OVERFLOW_VECTOR )` in this code)
    implements a state machine, as per AVR312\. The `ISRstate_t` type definition provides
    meaningful names for each of the states this function implements. See the code
    comments for a description of each of these states:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`USI溢出`ISR（来自AVR312，在此代码中为`ISR( USI_OVERFLOW_VECTOR )`）实现了一个状态机，符合AVR312的描述。`ISRstate_t`类型定义为此函数实现的每个状态提供有意义的名称。请参阅代码注释，了解每个状态的描述：'
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next up are some global variables (local to this source file):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一些全局变量（仅限于当前源文件）：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These variables are used as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量的使用方式如下：
- en: '`periphAddress` Holds the peripheral device’s I²C address (for example, 0x20
    for the memory peripheral device)'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`periphAddress` 保存外设设备的 I²C 地址（例如，内存外设设备的地址为 0x20）'
- en: '`sleep_enable_bit` Saves the state of the SE bit in the MCUCR register as this
    bit gets overwritten by changes to the MCUCR in the ISRs'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sleep_enable_bit` 保存 MCUCR 寄存器中 SE 位的状态，因为该位会在 ISR 中修改 MCUCR 时被覆盖'
- en: '`in_transaction` A Boolean variable that tracks whether you’re in the middle
    of an I²C transaction (that is, you haven’t yet seen a stop condition) while entering
    and leaving the overflow ISR'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`in_transaction` 一个布尔变量，用于跟踪你是否正在进行 I²C 事务（即，在进入和退出溢出 ISR 时，还没有看到停止条件）'
- en: '`ISRstate` Holds the current state value (`ISRstate_t`) for the overflow ISR
    state machine'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ISRstate` 保存当前状态值（`ISRstate_t`），用于溢出 ISR 状态机'
- en: '`rx*` variables Receive buffer variables'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rx*` 变量 接收缓冲区变量'
- en: '`tx*` variables Transmit buffer variables'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tx*` 变量 传输缓冲区变量'
- en: '`usi_onRequestPtr` Pointer to callback function that the overflow ISR calls
    after receiving the address byte but before returning any data to the controller
    device'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`usi_onRequestPtr` 指向回调函数的指针，溢出 ISR 在接收到地址字节后但在返回数据给控制器设备之前会调用此函数'
- en: '`usi_onReceiverPtr` Pointer to the callback function that the overflow ISR
    calls after receiving the address byte but before reading any additional data
    sent by the controller device on an I²C write operation'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`usi_onReceiverPtr` 指向回调函数的指针，溢出 ISR 在接收到地址字节后但在读取控制器设备通过 I²C 写操作发送的其他数据之前会调用此函数'
- en: '`usi_afterRequestPtr` Pointer to callback function that the overflow ISR calls
    after processing all the bytes received from the controller on an I²C read operation'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`usi_afterRequestPtr` 指向回调函数的指针，溢出 ISR 在处理完从控制器接收的所有字节之后会调用此函数，适用于 I²C 读取操作'
- en: 'There are also three function pointers appearing in the global declarations:
    `usi_afterRequestPtr`, `usi_onRequestPtr`, and `usi_onReceiverPtr`. In addition
    to these variables, this section defines two empty functions with which it initializes
    the callback pointers. Pre-initializing these function pointers spares the code
    from having to check if these pointers contain NULL.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个函数指针出现在全局声明中：`usi_afterRequestPtr`、`usi_onRequestPtr` 和 `usi_onReceiverPtr`。除了这些变量外，本节定义了两个空函数，通过这些函数初始化回调指针。预初始化这些函数指针可以避免代码检查这些指针是否为
    NULL。
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next are a couple of utility support functions private to this source file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一些仅限于当前源文件的实用支持函数。
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `startSetConditionMode()` function initializes the ATtiny84’s interrupt
    system to disable the USI overflow interrupt and enable the start condition interrupt.
    This happens, for example, when an I²C transaction is complete and the peripheral
    is waiting for another start condition to come along. Once the code initializes
    these interrupts, it can do something else (currently just spinning in the empty
    loop function) until the next start condition.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`startSetConditionMode()` 函数初始化 ATtiny84 的中断系统，禁用 USI 溢出中断并启用起始条件中断。例如，当一个
    I²C 事务完成后，外设正在等待另一个起始条件时，就会发生这种情况。一旦代码初始化了这些中断，它就可以做其他事情（目前仅在空循环函数中旋转），直到下一个起始条件到来。'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See section 11.2, “ATtiny Controller Programming,” in Chapter 11 for an explanation
    of the USICR and USISR registers that appear in this code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见第 11 章中的第 11.2 节，“ATtiny 控制器编程”，以了解代码中出现的 USICR 和 USISR 寄存器的说明。
- en: The next section of the program introduces public functions that the main application
    can call, beginning with the main ISR initialization function. This programs the
    SDA and SCL lines as outputs, programs them high (the quiescent state), and sets
    up the system to wait for a start condition interrupt.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的下一个部分引入了主应用程序可以调用的公共函数，从主 ISR 初始化函数开始。此函数将 SDA 和 SCL 引脚设置为输出，设置为高电平（静态状态），并将系统设置为等待起始条件中断。
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Up next are various functions for testing the presence of data in the transmit
    and receive buffers, as well as inserting data into, and extracting data from,
    these buffers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一些用于测试传输和接收缓冲区中是否有数据的各种函数，以及向这些缓冲区插入数据和从中提取数据的函数：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next comes the ISR that handles the arrival of a start condition on the I²C
    bus. Special hardware inside the ATtiny84 detects the presence of a start condition
    and triggers the interrupt that calls the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是处理 I²C 总线上起始条件到达的 ISR。ATtiny84 内部的特殊硬件检测到起始条件的存在并触发中断，从而调用以下代码：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `USI_START_VECTOR` interrupt service routine begins by turning off the sleep
    mode ❶. This prevents the CPU from sleeping while processing a byte coming in
    on the I²C pins. Next, the ISR set the state so that the code will process an
    address byte immediately following the start condition ❷.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`USI_START_VECTOR` 中断服务程序首先关闭睡眠模式❶。这可以防止 CPU 在处理来自 I²C 引脚的字节时进入睡眠状态。接下来，ISR
    设置状态，以便在开始条件之后立即处理地址字节❷。'
- en: The `while` loop waits until the SCL line goes low (the end of the start condition)
    ❸, and then the code checks to see if this is an actual start condition (SDA line
    is low) or a stop condition (SDA line is high). If it’s a start condition, the
    ISR checks to see if this is a restart condition, meaning there was no stop condition
    since the last start ❹. Once the ISR has properly seen a start (or restart) condition,
    it enables the overflow interrupt to trigger when the USI receives the next full
    byte ❺. In the event a stop condition arrived, the code resets the interrupts
    to look for a new start condition ❻.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环会等待直到 SCL 线变低（即开始条件结束）❸，然后代码检查这是否为一个实际的开始条件（SDA 线为低电平）或停止条件（SDA 线为高电平）。如果是开始条件，ISR
    会检查这是否为重新启动条件，意味着从上一个开始条件以来没有出现停止条件❹。一旦 ISR 正确识别到开始（或重新启动）条件，它会启用溢出中断，以便在 USI
    接收到下一个完整字节时触发❺。如果到达了停止条件，代码会重置中断，以便寻找新的开始条件❻。'
- en: 'The USI Overflow interrupt service routine processes the bytes that arrive
    from the USI:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: USI 溢出中断服务程序处理从 USI 到达的字节：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because each byte can have a different meaning, the overflow ISR tracks the
    arrivals with a state machine (and the `ISRstate` variable). The first byte to
    arrive after the start condition is the address-R/W byte. The LO bit (R/W) determines
    whether the state machine will handle memory read operations (R/W = 1, state =
    `USI_PERIPH_SEND_DATA`) or memory write operations (R/W = 0, state = `USI_PERIPH_REQUEST_DATA`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个字节可能有不同的含义，溢出 ISR 使用状态机（以及 `ISRstate` 变量）来跟踪字节的到达。开始条件之后到达的第一个字节是地址读写字节。LO
    位（R/W）决定状态机是处理内存读取操作（R/W = 1，状态 = `USI_PERIPH_SEND_DATA`）还是内存写入操作（R/W = 0，状态 =
    `USI_PERIPH_REQUEST_DATA`）。
- en: 'The following code is the start of the actual state machine, controlled by
    the `ISRstate` variable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是实际状态机的开始，由 `ISRstate` 变量控制：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first state appearing in this code is `USI_PERIPH_CHECK_ADDRESS`, which
    corresponds to the arrival of a start condition. This state checks the incoming
    I²C address byte and R/W bit. If the address doesn’t match, the code turns off
    the overflow interrupt enable, because the code will ignore all incoming bytes
    until a new start condition comes along; the current bus transactions are intended
    for some other device. If the address matches, however, this code changes the
    state based on the R/W bit. One state handles additional incoming bytes (an I²C
    write operation), while another handles outgoing bytes (an I²C read operation).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中出现的第一个状态是 `USI_PERIPH_CHECK_ADDRESS`，它对应于开始条件的到来。该状态检查传入的 I²C 地址字节和 R/W
    位。如果地址不匹配，代码会关闭溢出中断使能，因为代码会忽略所有传入的字节，直到新的开始条件出现；当前的总线事务是为其他设备准备的。然而，如果地址匹配，代码则会根据
    R/W 位改变状态。一个状态处理额外的传入字节（I²C 写操作），另一个状态处理传出的字节（I²C 读操作）。
- en: Next, the `USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA` state verifies that an ACK
    or a NAK came from the controller after the peripheral has transmitted a byte
    to the controller (an I²C read operation).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA` 状态会验证外设在向控制器传输一个字节后，控制器是否发送了 ACK
    或 NAK（一个 I²C 读取操作）。
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If a NAK arrived, you’re done transmitting data back to the controller; if an
    ACK arrived, the program continues transmitting more data. If this code were to
    receive an ACK from the controller, it would normally set the state to `USI_PERIPH_SEND_DATA`.
    However, this code simply falls down into that state and immediately transmits
    the next byte to the controller without changing the state (it will be set back
    to `USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA`, anyway).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到 NAK，你的数据传输就结束了；如果收到 ACK，程序继续传输更多数据。如果这段代码接收到来自控制器的 ACK，它通常会将状态设置为 `USI_PERIPH_SEND_DATA`。然而，这段代码只是直接进入该状态，并立即将下一个字节传输给控制器，而不改变状态（无论如何，它最终会被重新设置为
    `USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA`）。
- en: Next, the `USI_PERIPH_SEND_DATA` state transmits a byte of data to the controller
    in response to a read operation. After transmitting a byte, it also sets the state
    to `USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA` to handle the ACK or NAK from the
    controller.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`USI_PERIPH_SEND_DATA` 状态会在响应读取操作时向控制器发送一个字节的数据。传输完字节后，它还会将状态设置为 `USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA`，以处理控制器的
    ACK 或 NAK。
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, the `USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA` state sets up the USI to
    wait for a single bit, either the ACK or NAK, to arrive in the USI. This state
    also changes the state variable to `USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA`, which
    will process the ACK or NAK when it arrives.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA` 状态将 USI 设置为等待单个位的到来，无论是 ACK 还是
    NAK。此状态还会将状态变量更改为 `USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA`，在 ACK 或 NAK 到达时处理它。
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, the `USI_PERIPH_REQUEST_DATA` state sets up the system to expect the
    arrival of a byte from the controller (that is, an I²C write operation). This
    state gets set after the address byte or after an arbitrary byte is read from
    the controller (that is, some byte in a stream of bytes the controller is transmitting).
    This code delays until the SCL line goes high and then looks for a possible stop
    condition. If no stop condition occurs, then the system sets the state to `USI_PERIPH_GET_DATA_AND_SEND_ACK`
    and waits for the next byte to arrive:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`USI_PERIPH_REQUEST_DATA` 状态会设置系统以期望从控制器接收到一个字节（即一个 I²C 写操作）。该状态在地址字节或从控制器读取任意字节后设置（即控制器传输的字节流中的某个字节）。这段代码会延迟直到
    SCL 线变高，然后查找是否存在停止条件。如果没有停止条件，系统会将状态设置为 `USI_PERIPH_GET_DATA_AND_SEND_ACK`，并等待下一个字节的到来：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If a byte has arrived from the controller, the following state fetches that
    byte from the USI and adds it to the receive buffer. This code also sends the
    controller an ACK in response to the received byte:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经从控制器接收到了一个字节，接下来的状态将从 USI 中取出该字节并将其添加到接收缓冲区。该代码还会向控制器发送一个 ACK 以响应接收到的字节：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This concludes the code to handle I²C peripherals on an ATtiny84\. In addition
    to the code appearing in *attiny84_Periph.ino* and *usiI2CPeriph.c*, the full
    memory peripheral software has a small header file (*usiI2CPeriph.h*). I will
    not reproduce that header file here as it simply replicates information appearing
    in these two listings. See the online source files for the full source code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码处理 ATtiny84 上的 I²C 外设。除了 *attiny84_Periph.ino* 和 *usiI2CPeriph.c* 中的代码外，完整的内存外设软件还有一个小的头文件
    (*usiI2CPeriph.h*)。由于该头文件只是重复了这两个列表中的信息，我不会在这里再现它。请参见在线源文件以获取完整的源代码。
- en: It should be straightforward to modify the code in *attiny84_Periph.ino* to
    implement whatever peripheral you desire on the Atto84 device (assuming, of course,
    it’s powerful enough for the job). You could, for example, program it as an ADC—only
    10 bits, because the Atto84 built-in ADC is a 10-bit ADC—or as a small GPIO expander.
    With a little more work, you could use it to create an I²C NeoPixel controller.
    Your imagination is limited only by the ATtiny84’s capabilities.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *attiny84_Periph.ino* 中的代码以在 Atto84 设备上实现你想要的任何外设应该是非常直接的（当然，前提是它足够强大来完成这个任务）。例如，你可以将其编程为
    ADC——仅支持 10 位，因为 Atto84 内建的 ADC 是 10 位 ADC——或者作为一个小型 GPIO 扩展器。如果再做一点工作，你可以用它来创建一个
    I²C NeoPixel 控制器。你的想象力仅受 ATtiny84 能力的限制。
- en: 16.3.3 A Sample Controller Application
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.3 一个示例控制器应用
- en: If you compile the code in *attiny84_Periph.ino* and *usiI2CPeriph.c* and program
    it into a SparkFun Atto84 SBC, that code will happily start execution after power-up
    and . . . do nothing (nothing observable, anyway). Because that Atto84 becomes
    an I²C peripheral, you must connect it to an I²C controller device that is programmed
    to talk to the Atto84\. [Listing 16-1](#listing16-1) is a simple Arduino program
    that you can use to exercise the memory peripheral.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译 *attiny84_Periph.ino* 和 *usiI2CPeriph.c* 代码，并将其编程到 SparkFun Atto84 SBC
    上，那么该代码在上电后会愉快地开始执行……然后什么也不做（至少是看不见的）。因为 Atto84 变成了一个 I²C 外设，所以你必须将其连接到一个已编程为与
    Atto84 通信的 I²C 控制器设备。[Listing 16-1](#listing16-1) 是一个简单的 Arduino 程序，可以用来操作该内存外设。
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you run this program on an Arduino-compatible system and connect its SDA
    and SCL lines to the Atto84 from the previous sections, this program will exercise
    the memory capabilities of that Atto84 I²C peripheral.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个兼容 Arduino 的系统上运行这个程序，并将其 SDA 和 SCL 线路连接到前面章节中的 Atto84，那么该程序将测试该 Atto84
    I²C 外设的内存功能。
- en: 16.4 Chapter Summary
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 章节总结
- en: 'This chapter covered how to program a SparkFun Atto84 (ATtiny84) as an I²C
    peripheral. It began with a brief discussion of the ATtiny84 Universal Serial
    Interface that it used to implement I²C communication in hardware. It then described
    a simple device implemented as an I²C peripheral: an I²C memory device. The meat
    of this chapter was the actual implementation of the I²C memory peripheral on
    the Atto84\. Finally, the chapter concluded with a simple I²C controller application
    for an Arduino-compatible system that exercises the memory peripheral.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何将 SparkFun Atto84（ATtiny84）编程为 I²C 外设。首先简要讨论了 ATtiny84 通用串行接口，它用于在硬件中实现
    I²C 通信。接着描述了作为 I²C 外设实现的一个简单设备：I²C 存储器设备。本章的核心内容是 I²C 存储器外设在 Atto84 上的实际实现。最后，本章以一个简单的
    I²C 控制器应用程序作为结尾，适用于与 Arduino 兼容的系统，用于操作存储器外设。
