- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TYPES AND ENTITIES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: The idea that every expression has a type is central to Haskell. Haskell has
    several built-in types available to us in the Prelude and a system for making
    our own types. In this chapter, we’ll discuss some of the built-in types, and
    in [Chapter 10](ch10.xhtml), we’ll see how to make types of our own.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Basic Types
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types reflect the nature of information. For example, in physics, we want to
    know whether something is a scalar or a vector. These are different types. It
    makes no sense to add a scalar to a vector, and the computer can prevent us from
    making this mistake if we use a good system of types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](ch03.xhtml#ch3tab1) shows Haskell’s most important basic types.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Haskell’s Basic Types'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** | **Examples** |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
- en: '| `Bool` | Boolean | `False, True` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
- en: '| `Char` | Character | `''h'', ''7''` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| `String` | String | `"101 N. College Ave."` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| `Int` | Small (machine-precision) integer | `42` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| `Integer` | Arbitrarily large integer | `18446744073709551616` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| `Float` | Single-precision floating point | `0.33333334` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| `Double` | Double-precision floating point | `0.3333333333333333` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: The `Bool` type is for values that are either true or false, like the result
    of a comparison. For example, `3 > 4` evaluates to `False`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Char` type is for single characters. The `String` type is for a sequence
    of characters. The types `Int`, `Integer`, `Float`, and `Double` are for numbers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at each of these types.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean Type
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Bool` type has only two possible values: `False` and `True`. The type
    is used for expressions that are meant to represent claims that might be true
    or false.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Haskell has an `if-then-else` expression whose value depends on a Boolean. The
    expression has the form `if` `b` `then` `c` `else` `a`. Here `b` is an expression
    of type `Bool` called the *condition* is called the *consequent* is called the
    *alternative*. Haskell’s type system demands not only that `b` have type `Bool`
    but also that the consequent `c` and the alternative `a` have the same type (this
    can be any type, `Bool` or something else). If the condition `b` evaluates to
    `True`, the entire `if-then-else` expression evaluates to `c`; if the condition
    `b` evaluates to `False`, the entire `if-then-else` expression evaluates to `a`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with an imperative language like Python or C, it may help
    to realize that Haskell’s `if-then-else` construction is an *expression*, not
    a statement. An expression evaluates to a value. In imperative languages, `if-then`
    constructions are typically statements that are executed if the condition is true
    and ignored otherwise. In an imperative language, the `else` clause is optional;
    that is, it’s only used when there are statements to be executed if the condition
    is false. Because the `if-then-else` construction in a functional language is
    an expression, the `else` clause is mandatory, not optional. *Some* value must
    be returned whether the condition is true or false.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of the `if-then-else` expression, consider the following function
    (which is sometimes called the *Heaviside step function* or the *unit step function*):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/026equ01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: We can write a definition for this function in Haskell using the `if-then-else`
    construction. In Haskell, we are not allowed to begin the names of constants or
    functions with a capital letter (recall the discussion of variable identifiers
    in the last chapter), so we’ll call this function `stepFunction`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The function `stepFunction` accepts a `Double` as input (called `x` in the definition)
    and returns a `Double` as output. The expression `x <= 0` is the condition, the
    expression `0` is the consequent, and the expression `1` is the alternative.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The Prelude provides a few functions that work with Booleans. The first is `not`,
    which has type `Bool -> Bool`, meaning it accepts a Boolean as input and gives
    another Boolean as output. The function `not` returns `True` if its input is `False`
    and returns `False` if its input is `True`. You can see this for yourself in GHCi
    if you type
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: or
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: at the GHCi prompt.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [Chapter 2](ch02.xhtml), GHCi has a command `:type` (`:t` for
    short) that asks about the type of something. You can ask GHCi for the type of
    `not` by entering
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: at the GHCi prompt. GHCi commands that start with a colon are not part of the
    Haskell language itself. You cannot use the colon commands in a Haskell program
    file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean AND operator `&&` takes two Booleans as input and gives one Boolean
    as output. The output is `True` only when both inputs are `True`, and it’s `False`
    otherwise. [Table 3-2](ch03.xhtml#ch3tab2) describes the behavior of the `&&`
    operator.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Definition of the AND Operator'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '| *x* | *y* | *x* `&&` *y* |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| `False` | `False` | `False` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `False` | `True` | `False` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `True` | `False` | `False` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `True` | `True` | `True` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: The Boolean OR operator `||` takes two Booleans as input and gives one Boolean
    as output. The output is `False` only when both inputs are `False`, and it’s `True`
    otherwise. [Table 3-3](ch03.xhtml#ch3tab3) describes the behavior of the `||`
    operator.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Definition of the OR Operator'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '| *x* | *y* | *x* `&#124;&#124;` *y* |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `False` | `False` | `False` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| `False` | `True` | `True` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `True` | `False` | `True` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `True` | `True` | `True` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: These operators are listed in [Table 1-2](ch01.xhtml#ch1tab2) with their precedence
    and associativity. You can play with them in GHCi, asking for evaluations of expressions
    such as
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: at the GHCi prompt.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The Character Type
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Char` type is for single characters, including uppercase and lowercase
    letters, digits, and some special characters (like the newline character, which
    produces a new line of text). Here are some examples of character definitions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is very little reason to make these definitions because any place we could
    use `newLine`, for example, we could just as easily use `'\n'`, which takes up
    less space. We do it here only to show the relationship between the term `'X'`
    and the type `Char`. As shown in the examples above, a character can be formed
    by enclosing a single letter or digit in single quotes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The String Type
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A string is a sequence of characters. (In [Chapter 5](ch05.xhtml), we’ll learn
    that a string is a *list* of characters, where list has a precise meaning.) Here
    are some examples:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These definitions are not as useless as the ones shown earlier for characters,
    because although `"Hello, world!"` is entirely equivalent to `hello`, the name
    `hello` is at least shorter and easier to type than the string it represents.
    If such a string was needed at several different places in a program, that would
    justify the definition of a name such as `hello`. To form a string from a sequence
    of characters, we enclose the character sequence in double quotes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Types
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The basic numeric types are `Int`, `Integer`, `Float`, and `Double`. The `Int`
    type is for small integers. A 32-bit machine will use 32 bits to represent an
    `Int`, which gives numbers up to a few billion. A 64-bit machine will use 64 bits
    to represent an `Int`, which gives numbers up to about 10^(18). The `Integer`
    type is for arbitrary integers. The computer will use whatever number of bits
    it needs to represent an `Integer` exactly. On my 64-bit machine, I get the following
    results:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that I get no error message about going too high with `Int`; I just get
    the wrong answer. The `Int` type is good for almost any kind of counting you might
    ask the computer to do. The computer can’t count up to 10^(18) because it takes
    too long.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The `Float` type is for approximations to real numbers and has a precision of
    about 7 decimal digits. The `Double` type is for approximations to real numbers
    and has a precision of about 15 decimal digits. I always choose `Double` for my
    real numbers unless I am using a library written by someone else that uses `Float`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The numeric examples in the rightmost column of [Table 3-1](ch03.xhtml#ch3tab1)
    *can be* expressions of the type indicated, but an expression by itself, such
    as `42`, does not *necessarily* have type `Int`. To be specific, `False` and `True`
    must have type `Bool`, `'h'` and `'7'` must have type `Char`, and `"101 N. College
    Ave."` must have type `String`. On the other hand, `42` could have type `Int`,
    `Integer`, `Float`, or `Double`. Clarifying this ambiguity is one reason to give
    a type signature with each name you define in a Haskell program. Without a type
    signature, the compiler cannot tell which of the four numeric types you might
    want for a number like `18446744073709551616`. Any of the four numeric types would
    try to hold the number, but only `Integer` would represent the number exactly.
    The complexity of numeric types in Haskell is related to a more advanced language
    feature called *type classes*, which we’ll discuss in [Chapter 8](ch08.xhtml).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The four numeric types in [Table 3-1](ch03.xhtml#ch3tab1) are not the only numeric
    types in the Prelude. The Prelude includes a `Rational` type for rational numbers
    that we won’t use in this book but that you can explore on your own if you are
    interested. Complex numbers are provided by a library module called `Data.Complex`.
    We won’t use complex numbers in this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Function Types
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Haskell provides several ways to form new types from existing types. Given
    any two types `a` and `b`, there is a type `a -> b` for functions that take an
    expression of type `a` as input and produce an expression of type `b` as output.
    Here is an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function `isX` takes a character as input and gives a Boolean as output.
    The function returns `True` if the input character is `'X'` and returns `False`
    otherwise. Adding parentheses may help in reading the function definition. The
    definition is equivalent to
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In general in a definition, the name on the left of the single equal sign (`=`)
    is being defined (`isX` in this case), and the expression on the right of the
    single equal sign is the body of the definition. The expression `c == 'X'` uses
    the equality operator `==` from [Table 1-2](ch01.xhtml#ch1tab2) to ask if the
    input character `c` is the same as `'X'`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: If we put this function definition into a Haskell program file (for example,
    *FunctionType.hs*) and load it into GHCi,
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: we can ask about the types of things. If we ask about the type of `isX`,
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'we see what we wrote in our type signature. In GHCi, we can also ask for the
    type of `isX ''t''`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This makes sense because the expression `isX 't'` represents the function isX
    applied to the character argument `'t'`. Therefore, the type represents the type
    of the output of `isX`, namely `Bool`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We can also ask GHCi for the *value* of `isX 't'` (as opposed to the type of
    the expression). If we enter `isX 't'` at the GHCi prompt,
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: we see that the value of `isX 't'` is `False` because `'t'` is not equal to
    `'X'`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a function with type `Bool -> String`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function `bagFeeMessage` takes a Boolean as input and gives a string as
    output. The input Boolean (called `checkingBags`) is intended to represent an
    answer (`True` or `False`) to the question of whether a passenger is checking
    bags. The style of naming a variable by sticking words together without spaces
    and using a capital letter at the beginning of the second and subsequent words
    is common in Haskell programming.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `bagFeeMessage` 以布尔值作为输入，并返回一个字符串作为输出。输入的布尔值（称为 `checkingBags`）表示一个答案（`True`
    或 `False`），用于回答乘客是否托运行李。将多个单词连接在一起且每个单词首字母大写的命名方式，在 Haskell 编程中很常见。
- en: 'There is an alternative way to write the function `bagFeeMessage` that uses
    a facility in Haskell called *pattern matching*. Some data types have one or more
    patterns that values of that type fall into. The idea behind pattern matching
    for `Bool` is that the only possible values are `False` and `True`, so why not
    just give the output for each possible input? The fundamental way of achieving
    pattern matching is with the `case`-`of` construction. Here is what the function
    looks like using pattern matching:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种替代方式可以编写 `bagFeeMessage` 函数，它使用了 Haskell 中的一个功能叫做 *模式匹配*。一些数据类型具有一个或多个模式，值会符合其中的某个模式。对于
    `Bool` 类型的模式匹配的思想是，唯一可能的值是 `False` 和 `True`，那么为何不为每个可能的输入给出输出呢？实现模式匹配的基本方式是使用
    `case`-`of` 构造。下面是使用模式匹配的函数样式：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This doesn’t look so different from the `if`-`then`-`else` construction, but
    the `case`-`of` construction is more general because it can be used with other
    data types, not just `Bool`. In [Chapter 5](ch05.xhtml), for example, we will
    see that every list falls into one of two patterns that can be distinguished using
    the `case`-`of` construction.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与 `if`-`then`-`else` 构造没有什么不同，但 `case`-`of` 构造更为通用，因为它不仅可以与 `Bool` 类型一起使用，还可以与其他数据类型一起使用。例如，在[第五章](ch05.xhtml)中，我们将看到每个列表都属于两种模式之一，可以通过
    `case`-`of` 构造来区分。
- en: Although the `case`-`of` construction is the basic way to do pattern matching,
    Haskell provides some syntactic sugar for the special case in which we want to
    pattern match on the input to a function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `case`-`of` 构造是进行模式匹配的基本方式，Haskell 还为特殊情况提供了一些语法糖，在这种情况下我们希望对函数的输入进行模式匹配。
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By using pattern matching on the input, we have avoided using the `if`-`then`-`else`
    construction. Also, we no longer need the variable `checkingBags`, which held
    the input value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对输入进行模式匹配，我们避免了使用 `if`-`then`-`else` 构造。而且，我们不再需要变量 `checkingBags`，它用于保存输入值。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'Haskell has built-in types and facilities for making our own types. Types are
    intended to describe the meaning of data. This chapter looks at seven of the most
    common built-in types: `Bool`, `Char`, `String`, `Int`, `Integer`, `Float`, and
    `Double`. It also considers function types, which are very important to the language
    because functions play such a central role. We got a first glimpse of pattern
    matching, both with the `case`-`of` construction and by pattern matching on the
    input. In the next chapter, we begin our physics work, starting with motion in
    one dimension.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 内置了类型和工具来创建我们自己的类型。类型的目的是描述数据的含义。本章介绍了七种最常见的内置类型：`Bool`、`Char`、`String`、`Int`、`Integer`、`Float`
    和 `Double`。它还涉及了函数类型，这对语言来说非常重要，因为函数在其中扮演着核心角色。我们初步接触了模式匹配，包括使用 `case`-`of` 构造和通过对输入进行模式匹配。在下一章中，我们将开始我们的物理学工作，从一维运动开始。
- en: Exercises
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Exercise 3.1.** Add parentheses to the following expressions to indicate
    the order in which Haskell’s precedence and associativity rules ([Table 1-2](ch01.xhtml#ch1tab2))
    would evaluate the expressions. Some of the expressions are well-formed and have
    a clear type. In those cases, give the type of the (entire) expression. Also identify
    expressions that are not correctly formed (and consequently do not have a clear
    type) and say what is wrong with them.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 3.1.** 为以下表达式添加括号，以指示 Haskell 的优先级和结合性规则（[表 1-2](ch01.xhtml#ch1tab2)）如何评估这些表达式。有些表达式是格式正确的，并且具有明确的类型。对于这些表达式，给出（整个）表达式的类型。还要识别格式不正确的表达式（因此没有明确类型），并说明其错误所在。'
- en: (a) `False || True && False || True`
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (a) `False || True && False || True`
- en: (b) `2 / 3 / 4 == 4 / 3 / 2`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (b) `2 / 3 / 4 == 4 / 3 / 2`
- en: (c) `7 - 5 / 4 > 6 || 2 ^ 5 - 1 == 31`
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: (c) `7 - 5 / 4 > 6 || 2 ^ 5 - 1 == 31`
- en: (d) `2 < 3 < 4`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: (d) `2 < 3 < 4`
- en: (e) `2 < 3 && 3 < 4`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: (e) `2 < 3 && 3 < 4`
- en: (f) `2 && 3 < 4`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: (f) `2 && 3 < 4`
- en: '**Exercise 3.2.** Write Haskell function definitions for the following mathematical
    functions. In each case, write a type signature (the type should be `Double ->
    Double` for each function) and a function definition.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: (a) ![Image](Images/032equ01.jpg)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: (b) ![Image](Images/032equ02.jpg)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 3.3.** Define a function `isXorY` with type signature'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: that will return `True` if the input character is `'X'` or `'Y'` (capital X
    or Y) and return `False` otherwise. Test your function by loading it into GHCi
    and giving it inputs of `'X'`, `'Y'`, `'Z'`, and so on.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 3.4.** Define a function `bagFee` with type signature'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: that will return the integer `100` if the person is checking bags and the integer
    `0` if not. Use an `if`-`then`-`else` construction for this function. Then define
    a second function, `bagFee2`, with the same type signature that uses pattern matching
    on the input instead of the `if`-`then`-`else` construction.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 3.5.** Define a function `greaterThan50` with type signature'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: that will return `True` if the given integer is greater than 50 and return `False`
    otherwise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 3.6.** Define a function `amazingCurve` with type signature'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: that will double a student’s score on an exam. However, if the new score after
    doubling is greater than 100, the function should output `100`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 3.7.** What is the *type* of the expression `bagFee False` using
    the definition of `bagFee` you wrote in Exercise 3.4? What is the *value* of the
    expression `bagFee False` using that definition of `bagFee`?'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 3.8.** “Give every function a type signature.” In Haskell, it is
    good practice to give every function you define in your program file a type signature.
    We have been doing this all along. Type signatures serve as a form of documentation
    to readers of your program (including yourself).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Add type signatures for each of the definitions in the code below:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Exercise 3.9.** There are only a finite number of functions with type `Bool
    ->` `Bool`. How many are there? What would be good names for them? How many functions
    have type `Bool -> Bool -> Bool`?'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 3.10.** Devise an expression using `True`, `False`, `&&`, and `||`
    that would come out differently if the precedence of `||` was higher than the
    precedence of `&&`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
