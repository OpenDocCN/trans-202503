- en: B
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B
- en: BECAUSE I CAN’T RESIST
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我无法抗拒
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common1.jpg)'
- en: 'In this appendix, I include additional material related to some of the problems
    studied in this book. I consider this appendix as optional: it doesn’t concern
    material that I think is core to the goal of learning about data structures and
    algorithms. However, if you’re keen to learn more about a problem, this appendix
    is for you.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我包括了一些与本书中研究的某些问题相关的附加材料。我认为这个附录是可选的：它并不涉及我认为对学习数据结构和算法目标至关重要的内容。然而，如果你渴望更深入了解某个问题，这个附录将适合你。
- en: 'Unique Snowflakes: Implicit Linked Lists'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unique Snowflakes：隐式链表
- en: 'It’s often the case that at compile time we don’t know how much memory our
    program will need. If you’ve ever asked, “How big should I make this array?” or
    “Will this array be big enough?” then you’ve experienced firsthand the inflexibility
    of C arrays: we have to choose an array size, but we might not know the size we
    need until the array starts filling up. In many such cases, linked lists neatly
    solve the problem. Whenever we require new memory to store some data, we just
    call `malloc` at runtime to add a node to a linked list.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在编译时我们并不知道程序需要多少内存。如果你曾经问过：“我应该把这个数组做多大？”或者“这个数组够大吗？”那么你就亲身体验过C语言数组的局限性：我们必须选择一个数组大小，但在数组开始填充之前，我们可能不知道需要多大的数组。在许多这种情况下，链表能巧妙地解决问题。每当我们需要新内存来存储数据时，我们只需在运行时调用`malloc`来向链表添加一个节点。
- en: In the first problem in [Chapter 1](ch01.xhtml), Unique Snowflakes, we used
    linked lists to chain together the snowflakes that reside in the same bucket.
    For every snowflake that we read in, we used `malloc` to allocate memory for exactly
    one snowflake. If we read 5,000 snowflakes, we’ll have made 5,000 `malloc` calls.
    The time taken by these `malloc` calls can add up.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml)的第一个问题——Unique Snowflakes中，我们使用链表将位于同一桶中的雪花串联起来。对于每个我们读取的雪花，我们使用`malloc`为每一个雪花分配内存。如果我们读取了5,000个雪花，我们就会进行5,000次`malloc`调用。这些`malloc`调用所耗费的时间可能会积累起来。
- en: 'Wait! We just said that linked lists are useful when we don’t know how much
    memory we might need. In Unique Snowflakes, we *do* know! Or, at least, we know
    the *maximum* that we’ll need: it’s whatever is required to store at most 100,000
    snowflakes.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我们刚才说过，当我们不知道需要多少内存时，链表是有用的。而在Unique Snowflakes问题中，我们*确实*知道！或者，至少我们知道我们需要的*最大*内存：它是存储最多100,000个雪花所需的内存。
- en: That raises questions. Why are we using `malloc`, anyway? Is there a way to
    avoid using `malloc` and linked lists? Indeed, we can solve Unique Snowflakes
    in a way that doesn’t use `malloc` and leads to a doubling of speed. How?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了几个问题。为什么我们要使用`malloc`呢？有没有办法避免使用`malloc`和链表呢？事实上，我们可以通过一种不使用`malloc`且能使速度翻倍的方式来解决Unique
    Snowflakes问题。怎么做呢？
- en: 'The key idea is to preallocate an array of the maximum number of nodes (100,000)
    that we might use. The array is called `nodes`, and it stores the nodes from all
    of the (now-implicit) linked lists. Each element of `nodes` is an integer giving
    the index of the next node in its list of nodes. Let’s get a handle on this by
    deciphering a sample `nodes` array:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关键思想是预先分配一个数组，存储我们可能使用的最大节点数（100,000）。这个数组称为`nodes`，它存储所有（现在是隐式的）链表中的节点。`nodes`中的每个元素是一个整数，表示其节点列表中下一个节点的索引。让我们通过解读一个示例`nodes`数组来理解这一点：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Suppose we know that one of the lists starts at index `6`. The value of index
    `6`, `5`, tells us that index `5` is the next node in the list. Similarly, index
    `5` tells us that index `4` is the next node in the list. Index `4` tells us that
    index `2` is the next node in the list. What about index `2`, with the value of
    `-1`? We’ll use `-1` as our `NULL` value: it indicates that there’s no “next”
    element. We have discovered the list of indices `6`, `5`, `4`, and `2`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们知道其中一个列表从索引`6`开始。索引`6`的值是`5`，这告诉我们索引`5`是列表中的下一个节点。同样，索引`5`告诉我们索引`4`是列表中的下一个节点。索引`4`告诉我们索引`2`是列表中的下一个节点。那么索引`2`，值为`-1`呢？我们将`-1`作为我们的`NULL`值：它表示没有“下一个”元素。我们已经发现了索引`6`、`5`、`4`和`2`的列表。
- en: There’s one more nonempty list in that array. Suppose we know this list starts
    at index `3`. Index `3` tells us that index `1` is the next node in the list.
    Index `1` tells us that index `0` is the next node in the list. That’s all then—index
    `0` is a `-1`, so the list is over. We have discovered the list of indices `3`,
    `1`, and `0`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个数组中还有一个非空列表。假设我们知道这个列表从索引`3`开始。索引`3`告诉我们索引`1`是列表中的下一个节点。索引`1`告诉我们索引`0`是列表中的下一个节点。然后就结束了——索引`0`是`-1`，所以列表结束了。我们已经发现了索引`3`、`1`和`0`的列表。
- en: That’s the `nodes` array. If some index has a value of `-1`, then it’s the end
    of a list. Otherwise, it gives the index of the next element in the list.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`nodes`数组。如果某个索引的值为`-1`，则表示这是链表的结束。否则，它给出了链表中下一个元素的索引。
- en: Notice that `nodes` doesn’t tell us anything about where the lists start. We
    had to assume that we somehow knew that the list heads were at indices `6` and
    `3`. How could we have known that? By using another array, `heads`, that gives
    the index of the first node in a list. `heads` uses `-1` for the value of any
    element that does not start a list.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`nodes`数组并没有告诉我们链表的起始位置。我们必须假设我们知道链表头节点的索引分别是`6`和`3`。我们是怎么知道的呢？通过使用另一个数组`heads`，它给出了链表中第一个节点的索引。如果某个元素不是链表的起始节点，`heads`会使用`-1`表示。
- en: 'Our `malloc`-less solution uses a total of three arrays in the `main` function:
    `snowflakes`, `nodes`, and `heads`. The `snowflakes` array stores the actual snowflakes
    so that we can look up a snowflake according to the indices in `nodes` and `heads`.
    Here are the three arrays:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的无`malloc`解决方案在`main`函数中使用了三个数组：`snowflakes`、`nodes`和`heads`。`snowflakes`数组存储实际的雪花数据，以便我们根据`nodes`和`heads`中的索引查找雪花。以下是这三个数组：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Only two of our functions must be adjusted to move from linked lists to the
    implicit lists that we use here: `identify_identical` and `main`. These adjustments
    are about syntax, not substance: `identify_identical` still performs pairwise
    comparisons of all snowflakes in a list, and `main` still reads in the snowflakes
    and builds the lists.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个函数需要调整才能从链表过渡到我们在这里使用的隐式链表：`identify_identical`和`main`。这些调整是语法层面的，而不是功能层面的：`identify_identical`仍然执行列表中所有雪花的两两比较，而`main`仍然读取雪花并构建链表。
- en: The new `identify_identical` is in [Listing B-1](app02.xhtml#app02ex01)—compare
    this to what we had before in [Listing 1-12](ch01.xhtml#ch01ex012)!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`identify_identical`函数见[Listing B-1](app02.xhtml#app02ex01)—请与之前在[Listing
    1-12](ch01.xhtml#ch01ex012)中的内容进行对比！
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing B-1: Identifying identical snowflakes in implicit linked lists*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing B-1：在隐式链表中识别相同的雪花*'
- en: Inside the `for` loop, `node1` is set to the head of the current list. If this
    list is empty, then the outer `while` loop won’t run at all for this node. If
    it isn’t empty, then, by using the `nodes` array, `node2` is set to the node after
    `node1` ➊. Rather than linked-list code like `node2 = node2->next`, we again use
    the `nodes` array to find the next node ➋ ➌.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内，`node1`被设置为当前列表的头节点。如果这个列表为空，则外部的`while`循环对于这个节点不会执行。如果列表不为空，那么通过使用`nodes`数组，`node2`被设置为`node1`之后的节点➊。我们不是使用像`node2
    = node2->next`这样的链表代码，而是再次使用`nodes`数组来查找下一个节点➋ ➌。
- en: The new `main` function is given in [Listing B-2](app02.xhtml#app02ex02).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`main`函数见[Listing B-2](app02.xhtml#app02ex02)。
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing B-2: The* main *function for implicit linked lists*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing B-2：隐式链表的* main *函数*'
- en: Suppose we have just read a snowflake and we have stored it in row `i` of `snowflakes`.
    We want this snowflake to become the head of its list. To accomplish this, we
    store the old list head at `nodes[i]` ➊, and then we set the head of the list
    to be snowflake `i` ➋.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们刚读取了一片雪花，并将其存储在`snowflakes`数组的第`i`行。我们希望这片雪花成为它所在链表的头节点。为此，我们将旧的链表头节点存储在`nodes[i]`➊处，然后将链表头节点设置为雪花`i`➋。
- en: Take some time to compare this solution to our linked-list solution. Which do
    you prefer? Is the `malloc`-less solution harder or easier for you to understand?
    Submit both to the judge; is the speedup worth it?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间将这个解决方案与我们的链表解决方案进行比较。你更喜欢哪个？没有`malloc`的解决方案对你来说是更难理解还是更容易理解？请提交两个版本给评审员；这种加速值得吗？
- en: 'Burger Fervor: Reconstructing a Solution'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汉堡热潮：重构解决方案
- en: In [Chapter 3](ch03.xhtml), we solved three problems—Burger Fervor, Moneygrubbers,
    and Hockey Rivalry—that involved minimizing or maximizing the value of a solution.
    In Burger Fervor, we maximized Homer’s time spent eating burgers; we gave an answer
    such as `2 2`, meaning two burgers and two minutes drinking beer. In Moneygrubbers,
    we minimized the amount of money required to purchase apples; we gave an answer
    such as `Buy 3 for $3.00`. In Hockey Rivalry, we maximized the number of goals
    in rivalry games; we gave an answer such as `20`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.xhtml)中，我们解决了三个问题——汉堡热潮、贪财者和冰球对抗——这些问题涉及最小化或最大化解决方案的值。在汉堡热潮中，我们最大化了霍默吃汉堡的时间；我们给出了一个答案，比如`2
    2`，意味着两个汉堡和两分钟喝啤酒。在贪财者中，我们最小化了购买苹果所需的金钱；我们给出了一个答案，比如`买3个，花费$3.00`。在冰球对抗中，我们最大化了对抗比赛中的进球数；我们给出了一个答案，比如`20`。
- en: Notice, though, that what we are doing here is giving the *value* of an optimal
    solution. We are not giving the optimal solution itself. We are not indicating
    which burgers to eat, or how to purchase the apples, or which games are the rivalry
    games.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，我们在这里做的是给出最优解的*值*，而不是给出最优解本身。我们并没有指明应该吃哪些汉堡，或者如何购买苹果，或者哪些游戏是竞争性游戏。
- en: The vast majority of optimization problems in competitive programming ask for
    the value of an optimal solution, which was the focus in [Chapters 3](ch03.xhtml)
    and [4](ch04.xhtml). However, we can, if we like, use memoization and dynamic
    programming to return an optimal solution itself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 绝大多数优化问题在竞赛编程中要求最优解的*值*，这是[第3章](ch03.xhtml)和[第4章](ch04.xhtml)的重点。然而，如果我们愿意，也可以使用记忆化和动态规划来返回最优解本身。
- en: 'Let’s see how this is done using Burger Fervor as an example. Given the following
    test case:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用“汉堡狂热”作为例子，看看这是如何做的。给定以下测试用例：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'let’s output not only the value of an optimal solution, but an optimal solution
    itself, like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不仅输出最优解的*值*，还输出最优解本身，像这样：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first line is what we had before; the other lines constitute an optimal
    solution itself, proof that the `2 2` is indeed achievable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是我们之前的内容；其他行则构成了最优解本身，证明`2 2`确实是可以实现的。
- en: 'Outputting an optimal solution like this is known as *reconstructing* or *recovering*
    a solution. Both of these words suggest that we already have the pieces that can
    be put together to produce the optimal solution. And that’s true: what we need
    is sitting right there in the `memo` or `dp` array. Here, let’s use the `dp` array;
    the `memo` array could be used in precisely the same way.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出最优解的*值*被称为*重构*或*恢复*解。以上两个词都表明我们已经有了可以拼接成最优解的各个部分。确实如此：我们所需要的就在`memo`或`dp`数组中。在这里，我们使用`dp`数组；`memo`数组也可以以相同的方式使用。
- en: 'We’re going to write the body for this function signature:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个函数签名编写主体：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Recall that we have *m*-minute and *n*-minute burgers. The `m` and `n` parameters
    are these values and come from the current test case. The `dp` parameter is the
    array that is produced by the dynamic-programming algorithm in [Listing 3-8](ch03.xhtml#ch03ex08).
    Finally, the `minutes` parameter is the number of minutes spent eating burgers.
    The function will print, one per line, the number of burgers that should be eaten
    in an optimal solution.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们有*m*分钟和*n*分钟的汉堡。`m`和`n`参数就是这些值，并且来自当前的测试用例。`dp`参数是由[清单3-8](ch03.xhtml#ch03ex08)中的动态规划算法生成的数组。最后，`minutes`参数是吃汉堡所花费的时间。该函数将按行打印应在最优解中吃的汉堡数量。
- en: What is the last burger that Homer should eat in an optimal solution? If we
    were solving this problem from scratch, then we wouldn’t know this answer. We’d
    have to see what happens if we choose an *m*-minute burger to be last and also
    see what happens if we choose an *n*-minute burger to be last. Indeed, that’s
    what we did when solving this problem in [Chapter 3](ch03.xhtml). Remember, though,
    that we now have the `dp` array at our disposal. That array is going to tell us
    which of the two options is the best.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在最优解中，霍默最后应该吃哪个汉堡？如果我们从头开始解决这个问题，那么我们并不知道答案。我们需要看看如果选择一个*m*分钟的汉堡作为最后一个会发生什么，同时也要看看如果选择一个*n*分钟的汉堡作为最后一个会发生什么。实际上，这就是我们在[第3章](ch03.xhtml)中解决这个问题时所做的。记住，现在我们有了`dp`数组可以使用。这个数组将告诉我们哪种选择是最好的。
- en: 'Here’s the key idea: take a look at `dp[minutes - m]` and `dp[minutes - n]`.
    Both of those values are available to us, because the `dp` array has already been
    constructed. Whichever of these values is larger tells us what we should use as
    the last burger. That is, if `dp[minutes - m]` is larger, then an *m*-minute burger
    is last; if `dp[minutes - n]` is larger, then an *n*-minute burger is last. (If
    `dp[minutes - m]` and `dp[minutes - n]` are equal, then you can choose arbitrarily
    whether to make the last burger an *m*-minute or *n*-minute burger.)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的思路是：查看`dp[minutes - m]`和`dp[minutes - n]`。这两个值都已经可以访问，因为`dp`数组已经构建完成。哪个值更大，就告诉我们应该选择哪一个作为最后的汉堡。也就是说，如果`dp[minutes
    - m]`更大，那么最后一个是*m*分钟的汉堡；如果`dp[minutes - n]`更大，那么最后一个是*n*分钟的汉堡。（如果`dp[minutes -
    m]`和`dp[minutes - n]`相等，那么你可以随意选择最后一个是*m*分钟还是*n*分钟的汉堡。）
- en: This reasoning parallels that used in [Listing 3-8](ch03.xhtml#ch03ex08) to
    build the `dp` array. There, we chose the maximum of `first` and `second`; here,
    we reverse engineer which of those choices the dynamic-programming algorithm made.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种推理与[清单3-8](ch03.xhtml#ch03ex08)中构建`dp`数组的方式相似。在那里，我们选择了`first`和`second`的最大值；这里，我们则是反向推断出动态规划算法所做的选择。
- en: Once we have deduced the final burger, we remove the time taken to eat that
    burger and then repeat the process. We keep going until we get down to zero minutes,
    at which point our reconstruction is complete. [Listing B-3](app02.xhtml#app02ex03)
    gives the code for the function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推导出最终的汉堡，我们会去掉吃掉那个汉堡所花的时间，然后重复这个过程。我们一直进行下去，直到剩下零分钟为止，这时我们的重构就完成了。[清单B-3](app02.xhtml#app02ex03)给出了该函数的代码。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing B-3: Reconstructing the solution*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单B-3：重构解决方案*'
- en: 'This function should be called in two places in [Listing 3-8](ch03.xhtml#ch03ex08),
    once after each `printf` call. The first is:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数应在[清单3-8](ch03.xhtml#ch03ex08)的两个地方调用，每次在`printf`调用后。第一次是：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second is:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I encourage you to reconstruct optimal solutions for the Moneygrubbers and Hockey
    Rivalry problems, following this same style.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你以同样的风格重构“Moneygrubbers”和“Hockey Rivalry”问题的最优解。
- en: 'Knight Chase: Encoding Moves'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 骑士追击：编码移动
- en: 'In the Knight Chase problem of [Chapter 5](ch05.xhtml), we designed a BFS algorithm
    to find the number of moves needed for a knight to reach each square from its
    starting point. The knight has eight possible moves, and we wrote each of them
    out in our code (see [Listing 5-1](ch05.xhtml#ch05ex01)). For example, here’s
    what we did to have the knight explore moving up one and right two:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml)的骑士追击问题中，我们设计了一个BFS算法，用来找出骑士从起点到每个方格所需的步数。骑士有八个可能的移动，我们在代码中写出了每一个（见[清单5-1](ch05.xhtml#ch05ex01)）。例如，下面是我们让骑士探索上移1和右移2的做法：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s what we did for up one and left two:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对上移1和左移2的做法：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There is gross code duplication there: the only change is a plus sign to a
    minus sign! In fact, all eight moves are encoded in a very similar way, just messing
    around with some pluses and minuses and 1s and 2s. That kind of thing is quite
    error-prone.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有严重的代码重复：唯一的变化是加号变成了减号！事实上，所有八个移动都以非常相似的方式编码，只是在一些加号、减号和1、2之间进行调整。这样的做法很容易出错。
- en: Fortunately, there is a neat technique to dodge this kind of code duplication.
    It applies to many problems where you’re asked to explore an implicit graph of
    multiple dimensions (such as rows and columns).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种巧妙的技术可以避开这种代码重复。它适用于许多要求探索多维（如行和列）隐式图的题目。
- en: 'Here are the knight’s eight possible moves, as presented in the problem description
    in [Chapter 5](ch05.xhtml):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是问题描述中[第5章](ch05.xhtml)中展示的骑士的八个可能移动：
- en: Up 1, right 2
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上1，右2
- en: Up 1, left 2
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上1，左2
- en: Down 1, right 2
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下1，右2
- en: Down 1, left 2
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下1，上2
- en: Up 2, right 1
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上2，右1
- en: Up 2, left 1
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上2，左1
- en: Down 2, right 1
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下2，右1
- en: Down 2, left 1
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下2，左1
- en: 'Let’s first focus on the rows and write down how each move changes the row
    number. The first move increases the row number by one, as does the second move.
    The third and fourth moves, by contrast, reduce the row number by one. The fifth
    and sixth moves increase the row number by two, and the seventh and eighth moves
    reduce the row number by two. Here’s an array of those numbers:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先关注行，并写下每个移动如何改变行号。第一个移动使行号增加1，第二个移动也如此。第三和第四个移动则使行号减少1。第五和第六个移动使行号增加2，第七和第八个移动使行号减少2。以下是这些数值的数组：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s called `row_dif` because it gives the difference in row numbers between
    the current row and the row after making a move.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它叫做`row_dif`，因为它给出了当前行与移动后行号之间的差异。
- en: 'Now let’s do the same thing for the columns. The first move increases the column
    number by two, the second move decreases the column number by two, and so on.
    As an array, the column differences are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对列做同样的事情。第一个移动使列号增加2，第二个移动使列号减少2，依此类推。作为一个数组，列的差值为：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What’s useful about these two parallel arrays is that they characterize the
    effect that each move has on the current row and column. The numbers in `row_dif[0]`
    and `col_dif[0]` tell you that the first move increases the row by one and increases
    the column by two, those in `row_dif[1]` and `col_dif[1]` tell you that the second
    move increases the row by one and decreases the column by two, and so on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个平行数组的有用之处在于，它们描述了每个移动对当前行和列的影响。`row_dif[0]`和`col_dif[0]`中的数字告诉你，第一个移动会使行增加1，列增加2，`row_dif[1]`和`col_dif[1]`中的数字告诉你，第二个移动会使行增加1，列减少2，依此类推。
- en: 'Now, instead of typing out eight near-identical calls to `add_position`, we
    can use a loop of eight iterations, typing out just one call to `add_position`
    in there. Here’s how it’s done, using a new integer variable `m` to loop through
    the moves:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不需要输入八个几乎完全相同的`add_position`调用，而是可以使用一个包含八次迭代的循环，只需在其中输入一次`add_position`调用。以下是实现方式，使用一个新的整数变量`m`来循环遍历移动：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That’s better! Update your Knight Chase code from [Chapter 5](ch05.xhtml) and
    give it a go with the judge. You should still pass all of the test cases and your
    code shouldn’t be noticeably faster or slower, but you’ve shaved off quite a bit
    of repetitive code, and that’s a win.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好！更新你在[第5章](ch05.xhtml)中的骑士追击代码，并与判题系统一起测试。你应该仍然能通过所有的测试用例，且代码的运行速度不会明显变快或变慢，但你已经消除了相当多的重复代码，这是一个胜利。
- en: We had only eight moves here, so we managed to survive Knight Chase in [Chapter
    5](ch05.xhtml) without using this encoding trick. However, if we had many more
    moves than this, then pasting the call to `add_position` over and over simply
    wouldn’t be feasible. What we’ve seen here scales much more nicely.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里只有八个移动，因此我们能够在[第5章](ch05.xhtml)中的骑士追击游戏中生还，而没有使用这种编码技巧。然而，如果我们有更多的移动，重复调用`add_position`就不再可行了。我们在这里看到的方式扩展性更好。
- en: 'Dijkstra’s Algorithm: Using a Heap'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dijkstra算法：使用堆
- en: 'In [Chapter 6](ch06.xhtml), we learned Dijkstra’s algorithm for finding shortest
    paths in weighted graphs. The runtime of our Dijkstra implementation was *O*(*n*²),
    where *n* is the number of nodes in the graph. Dijkstra’s algorithm spends a lot
    of its time searching for minimums: on each iteration, it has to find the node
    whose distance is minimum of all nodes that are not done.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.xhtml)中，我们学习了Dijkstra算法，它用于在加权图中找到最短路径。我们实现的Dijkstra算法的运行时间是*O*(*n*²)，其中*n*是图中节点的数量。Dijkstra算法大部分时间都在寻找最小值：每次迭代时，它都必须找到距离最小的节点，且这些节点尚未完成处理。
- en: Then, in [Chapter 8](ch08.xhtml), we learned about max-heaps and min-heaps.
    A max-heap won’t help here—but a min-heap will, because its job is to quickly
    find the minimum. We can therefore use a min-heap to speed up Dijkstra’s algorithm.
    This is a match made in computer-science heaven.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在[第8章](ch08.xhtml)中，我们学习了最大堆和最小堆。最大堆在这里没有用处——但是最小堆有用，因为它的作用是快速找到最小值。因此，我们可以使用最小堆来加速Dijkstra算法。这简直是计算机科学的天堂配对。
- en: 'The min-heap will hold all of the nodes that have been discovered and that
    are not done. It might also hold some discovered nodes that *are* done. That’s
    okay, though: as we did when solving the Supermarket Promotion problem with heaps
    in [Chapter 8](ch08.xhtml), we’ll just ignore any done node that happens to come
    off the min-heap.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最小堆将保存所有已发现且尚未完成的节点。它也可能包含一些已发现但已完成的节点。不过没关系：就像我们在[第8章](ch08.xhtml)中使用堆解决超市促销问题时做的那样，我们只需要忽略从最小堆中出来的已完成节点。
- en: '*Mice Maze: Tracing with Heaps*'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*老鼠迷宫：使用堆进行追踪*'
- en: 'Let’s enhance our solution to the Mice Maze problem from [Chapter 6](ch06.xhtml)
    to use a min-heap. Here’s the graph that we used there ([Figure 6-1](ch06.xhtml#ch06fig01)):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增强[第6章](ch06.xhtml)中对老鼠迷宫问题的解决方案，使用最小堆。这是我们在那里使用的图形（[图6-1](ch06.xhtml#ch06fig01)）：
- en: '![Image](../images/unapp02fig01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/unapp02fig01.jpg)'
- en: In [Chapter 6](ch06.xhtml), we traced Dijkstra’s algorithm starting from Node
    1\. Let’s do that again, this time using a min-heap. Each heap element will consist
    of a node and a time necessary to reach that node. We’ll see that there can be
    multiple occurrences of the same node on the heap. However, because it’s a min-heap,
    we’ll be able to process each node using only its minimum time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.xhtml)中，我们从节点1开始追踪Dijkstra算法。让我们再次做一次这项工作，这次使用最小堆。每个堆元素将包含一个节点和到达该节点所需的时间。我们将看到，堆中可能有多个相同节点的出现。然而，由于它是一个最小堆，我们将能够使用每个节点的最小时间来处理它。
- en: In each min-heap snapshot that follows, I’ve arranged the rows in the same order
    as they’d be stored in the heap array.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的每个最小堆快照中，我按照它们在堆数组中存储的顺序排列了行。
- en: 'We start with only Node 1 in the heap, with a time of 0\. We have no time information
    for other nodes. We therefore have this snapshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从只有节点 1 在堆中的状态开始，时间为 0。我们没有其他节点的时间信息。因此，我们的快照如下：
- en: Min-heap
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最小堆
- en: '| ***node*** | ***time*** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***时间*** |'
- en: '| --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 0 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 |'
- en: Rest of State
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其余状态
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最小时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | false | 0 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 1 | false | 0 |'
- en: '| 2 | false |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 2 | false |  |'
- en: '| 3 | false |  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 3 | false |  |'
- en: '| 4 | false |  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false |  |'
- en: '| 5 | false |  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 5 | false |  |'
- en: 'Extracting from the min-heap gives us its sole element, Node 1\. We then process
    Node 1 to update the shortest paths to Nodes 2, 3, 4, and 5 and place these nodes
    on the min-heap. Here’s our state now:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从最小堆中提取出唯一的元素节点 1。然后我们处理节点 1，更新到节点 2、3、4 和 5 的最短路径，并将这些节点放入最小堆中。现在的状态如下：
- en: Min-heap
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最小堆
- en: '| ***node*** | ***time*** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***时间*** |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 3 | 6 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 6 |'
- en: '| 2 | 12 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 12 |'
- en: '| 5 | 7 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 7 |'
- en: '| 4 | 45 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 45 |'
- en: Rest of State
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其余状态
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最小时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | false | 12 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 2 | false | 12 |'
- en: '| 3 | false | 6 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 3 | false | 6 |'
- en: '| 4 | false | 45 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 45 |'
- en: '| 5 | false | 7 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 5 | false | 7 |'
- en: 'Node 3 is next out of the min-heap and gives us a shorter path to Node 2\.
    We therefore add another occurrence of Node 2 to the heap, this one with a shorter
    path than before. Here’s what we’ve got now:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 3 是接下来从最小堆中弹出的，它为节点 2 提供了一个更短的路径。因此，我们将另一个节点 2 加入堆中，这个节点的路径比之前更短。现在的状态如下：
- en: Min-heap
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最小堆
- en: '| ***node*** | ***time*** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***时间*** |'
- en: '| --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 5 | 7 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 7 |'
- en: '| 2 | 8 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 8 |'
- en: '| 4 | 45 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 45 |'
- en: '| 2 | 12 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 12 |'
- en: Rest of State
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其余状态
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最小时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | false | 8 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 2 | false | 8 |'
- en: '| 3 | true | 6 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 3 | true | 6 |'
- en: '| 4 | false | 45 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 45 |'
- en: '| 5 | false | 7 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 5 | false | 7 |'
- en: 'Next out is Node 5\. It doesn’t lead to any shortest-path updates, so nothing
    new gets added to the heap. Here’s where we are:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个弹出的节点是节点 5。它没有导致任何最短路径更新，所以没有新的节点被加入堆中。现在的状态如下：
- en: Min-heap
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最小堆
- en: '| ***node*** | ***time*** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***时间*** |'
- en: '| --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2 | 8 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 8 |'
- en: '| 2 | 12 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 12 |'
- en: '| 4 | 45 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 45 |'
- en: Rest of State
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其余状态
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最小时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | false | 8 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 2 | false | 8 |'
- en: '| 3 | true | 6 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 3 | true | 6 |'
- en: '| 4 | false | 45 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 45 |'
- en: '| 5 | true | 7 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 5 | true | 7 |'
- en: 'Node 2 is next out of the min-heap—specifically the one with 8 time, not the
    one with 12 time! It leads to an update of Node 4’s shortest path, and consequently
    a new occurrence of Node 4 on the min-heap. Here’s the result:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 2 是下一个从最小堆中弹出的节点——具体来说是时间为 8 的那个，而不是时间为 12 的那个！它导致了节点 4 最短路径的更新，因此节点 4 会重新出现在最小堆中。结果如下：
- en: Min-heap
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最小堆
- en: '| ***node*** | ***time*** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***时间*** |'
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2 | 12 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 12 |'
- en: '| 4 | 45 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 45 |'
- en: '| 4 | 17 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 17 |'
- en: Rest of State
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其余状态
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最小时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | true | 8 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 2 | true | 8 |'
- en: '| 3 | true | 6 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 3 | true | 6 |'
- en: '| 4 | false | 17 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 17 |'
- en: '| 5 | true | 7 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 5 | true | 7 |'
- en: 'The next node to come out of the min-heap is Node 2\. Again! Node 2 is already
    done, so we simply extract it from the heap and do nothing else. We certainly
    don’t process this node again. Here’s what’s left:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个从最小堆中弹出的节点是节点 2。又来了！节点 2 已经完成，所以我们直接从堆中提取它，不做任何其他处理。我们当然不会再次处理这个节点。剩下的状态如下：
- en: Min-heap
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最小堆
- en: '| ***cell*** | ***time*** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| ***单元格*** | ***时间*** |'
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 4 | 17 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 17 |'
- en: '| 4 | 45 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 45 |'
- en: Rest of State
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其余状态
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最小时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | true | 8 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 2 | true | 8 |'
- en: '| 3 | true | 6 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 3 | true | 6 |'
- en: '| 4 | false | 17 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 17 |'
- en: '| 5 | true | 7 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 5 | true | 7 |'
- en: The two occurrences of Node 4 will be extracted from the min-heap in turn. The
    first Node 4 won’t lead to any shortest-path updates—all other nodes are done—but
    will set Node 4 to done. The second Node 4 will therefore be skipped.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 两个节点 4 会依次从最小堆中提取。第一个节点 4 不会导致任何最短路径更新——其他所有节点都已经完成——但是会将节点 4 标记为已完成。第二个节点 4
    因此会被跳过。
- en: In most textbook heap-based implementations of Dijkstra’s algorithm, it is assumed
    that there’s a way to decrease the shortest-path distance of a node in a heap.
    That way, a node can be updated in the heap, and there’s no need to have multiple
    occurrences of a node hanging around. The heaps that we developed in [Chapter
    8](ch08.xhtml), though, don’t support such a “decrease” operation. Rest assured
    that what we’re doing here, with the insertions instead of updates, has the same
    worst-case time complexity. Which is what, exactly?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数基于堆的教材实现中，Dijkstra 算法假设有一种方法可以减少堆中节点的最短路径距离。这样，节点就可以在堆中更新，而无需存在多个相同的节点。然而，在[第
    8 章](ch08.xhtml)中我们开发的堆并不支持这种“减少”操作。请放心，我们这里采用插入而非更新的方法，具有相同的最坏情况时间复杂度。那么，究竟是什么呢？
- en: Let’s use *n* to represent the number of nodes in the graph and *m* the number
    of edges. We process each edge *u* *→* *v* at most once, when *u* is extracted
    from the heap. Each edge can lead to at most one insertion into the heap, so we
    insert at most *m* elements. The biggest the heap could ever get, then, is size
    *m*. We can only extract what’s been inserted, so there are at most *m* extractions.
    That’s 2*m* heap operations in all, each of which takes at most log *m* time.
    Therefore, we have an *O*(*m* log *m*) algorithm.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 设图中有 *n* 个节点，*m* 条边。我们最多处理每条边 *u* *→* *v* 一次，当 *u* 从堆中提取时。每条边至多会导致一次堆插入，因此我们最多插入
    *m* 个元素。那么堆的最大大小就是 *m*。我们只能提取已经插入的元素，因此最多有 *m* 次提取操作。总共是 2*m* 次堆操作，每次操作最多花费 log
    *m* 时间。因此，我们得到了一个 *O*(*m* log *m*) 的算法。
- en: 'Compare this to the *O*(*n*²) implementation from [Chapter 6](ch06.xhtml).
    The heap-based implementation is a clear win when the number of edges is small
    in relation to *n*². For example, if there are *n* edges, then the heap-based
    implementation is *O*(*n* log *n*), which blows away the *O*(*n*²) runtime in
    [Chapter 6](ch06.xhtml). If the number of edges is large, then it matters less
    which implementation we use. For example, if there are *n*² edges, then the heap-based
    implementation is *O*(*n*² log *n*), which is competitive with, but a little slower
    than, *O*(*n*²). If you don’t know in advance whether your graph will have few
    or many edges, using a heap is a safe bet: the only cost is the extra log *n*
    factor on graphs with many edges, but that’s a small price to pay in exchange
    for much better performance on graphs with few edges.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与[第 6 章](ch06.xhtml)中的 *O*(*n*²) 实现进行比较。当边的数量相对于 *n*² 较小时，基于堆的实现明显更优。例如，如果有
    *n* 条边，则基于堆的实现是 *O*(*n* log *n*)，这比[第 6 章](ch06.xhtml)中的 *O*(*n*²) 运行时间要快得多。如果边的数量很大，那么选择哪种实现就不那么重要了。例如，如果有
    *n*² 条边，堆的实现是 *O*(*n*² log *n*)，尽管比 *O*(*n*²) 稍慢，但依然有竞争力。如果你无法预见图中边的数量较少还是较多，使用堆是一个安全的选择：唯一的成本是在边多的图中额外的
    log *n* 因子，但在边少的图中获得更好的性能，这是值得付出的代价。
- en: '*Mice Maze: Implementation with Heaps*'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*老鼠迷宫：使用堆的实现*'
- en: 'Now let’s solve Mice Maze using heaps. We use this struct for the heap elements:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用堆来解决老鼠迷宫问题。我们为堆元素使用以下结构：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I won’t replicate the min-heap insertion code ([Listing 8-5](ch08.xhtml#ch08ex05))
    or extraction code ([Listing 8-6](ch08.xhtml#ch08ex06)) here. The only change
    is to compare `time` rather than `cost`; I’ll leave that to you.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里重复最小堆插入代码（[清单 8-5](ch08.xhtml#ch08ex05)）或提取代码（[清单 8-6](ch08.xhtml#ch08ex06)）。唯一的变化是将比较对象从
    `cost` 改为 `time`；这部分留给你完成。
- en: The `main` function is the same as it was in [Chapter 6](ch06.xhtml) ([Listing
    6-1](ch06.xhtml#ch06ex01)). All we need is a replacement of `find_time` ([Listing
    6-2](ch06.xhtml#ch06ex02)) to use a min-heap instead of linear searches. That
    code is given in [Listing B-4](app02.xhtml#app02ex04).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数与[第 6 章](ch06.xhtml)中的相同（[清单 6-1](ch06.xhtml#ch06ex01)）。我们需要做的只是替换
    `find_time`（[清单 6-2](ch06.xhtml#ch06ex02)），使用最小堆代替线性搜索。该代码可以在[清单 B-4](app02.xhtml#app02ex04)中找到。'
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing B-4: Shortest path to exit using Dijkstra’s algorithm and heaps*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 B-4：使用 Dijkstra 算法和堆求解最短路径*'
- en: Each cell can result in at most `MAX_CELLS` elements added to the min-heap,
    and there are at most `MAX_CELLS`. We’re safe from overflowing the min-heap, then,
    if we allocate space for `MAX_CELLS * MAX_CELLS` elements plus one, since we index
    starting at `1` rather than `0` ➊.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元格最多可以向最小堆中添加 `MAX_CELLS` 个元素，并且最多有 `MAX_CELLS` 个单元格。因此，如果我们为 `MAX_CELLS
    * MAX_CELLS` 个元素加一分配空间，就可以避免溢出最小堆，因为我们从 `1` 开始索引，而不是从 `0` 开始 ➊。
- en: The main `while` loop continues as long as there’s something in the min-heap
    ➋. If the node that we extract from the min-heap is already done, then we don’t
    do anything on its iteration ➌. Otherwise, we process the outgoing edges as usual
    ➍, adding nodes to the min-heap when shorter paths are found ➎.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 主 `while` 循环会一直执行，只要最小堆中有元素 ➋。如果从最小堆提取的节点已经完成，那么我们就不在其迭代上做任何操作 ➌。否则，我们像往常一样处理出边
    ➍，当找到更短的路径时，将节点添加到最小堆 ➎。
- en: Compressing Path Compression
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩路径压缩
- en: In [Chapter 9](ch09.xhtml), you learned about path compression, an optimization
    to the tree-based union-find data structure. We saw its code in the context of
    the Social Network problem in [Listing 9-8](ch09.xhtml#ch09ex08). Written like
    that, with the two `while` loops, is not how you’ll see the code in practice.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.xhtml)中，你学习了路径压缩，这是对基于树的并查集数据结构的优化。我们在[列表 9-8](ch09.xhtml#ch09ex08)中看到了它在社交网络问题中的代码。那样写，带有两个
    `while` 循环，并不是你在实际中看到的代码样式。
- en: I generally don’t like to dwell on opaque code—and I hope I haven’t presented
    you with any such code in the book—but I’ll make an exception here, because you
    may at some point run into a particularly dense, one-line implementation of path
    compression. It’s presented in [Listing B-5](app02.xhtml#app02ex05).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不喜欢停留在晦涩的代码上——我希望书中没有给你展示过这样的代码——但在这里我做个例外，因为你可能会在某个时刻遇到一个特别复杂的、一行实现的路径压缩代码。它展示在[列表
    B-5](app02.xhtml#app02ex05)中。
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing B-5: Path compression in practice*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 B-5：路径压缩的实际应用*'
- en: I changed `person` to `p` to get the code on one line (since readability is
    already shot, why not?).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 `person` 改为 `p`，使代码只占一行（因为可读性已经差到这种程度，为什么不呢？）。
- en: 'There’s a lot going on here: the `? :` ternary if operator, using the result
    of the `=` assignment operator, and even recursion. We’re going to unravel this
    in three steps.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容：`? :` 三元条件运算符，使用 `=` 赋值运算符的结果，甚至还有递归。我们将分三步来解开这个问题。
- en: '*Step 1: No More Ternary If*'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*步骤 1：不再使用三元条件语句*'
- en: 'The `? :` operator is a form of if–else that returns a value. Programmers use
    it when they want to save space and jam an entire if statement on one line. A
    quick example looks like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`? :` 运算符是一种返回值的 if-else 形式。程序员通常在希望节省空间时使用它，将整个 if 语句压缩到一行中。一个简单的例子如下：'
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If `x` is greater than or equal to 10, `"big"` is returned; otherwise, `"small"`
    is returned.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 大于或等于 10，则返回 `"big"`；否则，返回 `"small"`。
- en: 'The `? :` operator is called a *ternary* operator because it takes three operands:
    the first expression is the boolean expression whose truth we are testing, the
    second expression is the result when the first expression is true, and the third
    is the result when the first expression is false.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`? :` 运算符被称为 *三元* 运算符，因为它有三个操作数：第一个表达式是我们正在测试其真值的布尔表达式，第二个表达式是当第一个表达式为真时的结果，第三个是当第一个表达式为假时的结果。'
- en: 'Let’s rewrite [Listing B-5](app02.xhtml#app02ex05) to use a standard `if...else`
    statement rather than the ternary `if`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写[列表 B-5](app02.xhtml#app02ex05)，使用标准的 `if...else` 语句，而不是三元 `if`：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That’s a little better. Now we explicitly see that the code has two paths:
    one if `p` is already the root and the other if `p` is not the root.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这样稍微好一点。现在我们明确看到代码有两条路径：一条是当 `p` 已经是根节点时，另一条是当 `p` 不是根节点时。
- en: '*Step 2: Cleaner Assignment Operator*'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*步骤 2：更清晰的赋值运算符*'
- en: What do you think this code snippet does?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这段代码做了什么？
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The answer is that it prints `5`! You know that `x = 5` assigns `5` to `x`,
    but it’s also an expression whose value is `5`. That’s right: `=` assigns a value,
    but it also returns the value that it stored in the variable. It’s also why we
    can do'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是它打印出 `5`！你知道 `x = 5` 会把 `5` 赋给 `x`，但它也是一个值为 `5` 的表达式。没错：`=` 赋值，但它也返回存储在变量中的值。这也是我们可以执行以下操作的原因：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: to assign the same value to multiple variables.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的值赋给多个变量。
- en: 'In the path-compression code, we have a return statement and an assignment
    statement on the same line. That line both assigns a value to `parent[p]` and
    returns that value. Let’s split those two actions out:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径压缩代码中，我们在同一行上有一个返回语句和一个赋值语句。那一行既赋值给 `parent[p]`，又返回该值。让我们将这两个操作分开：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’re explicitly finding the representative for `p`, assigning `parent[p]` to
    that representative, and then returning the representative.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确找到了 `p` 的代表，将 `parent[p]` 赋值给该代表，然后返回该代表。
- en: '*Step 3: Understand the Recursion*'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*步骤 3：理解递归*'
- en: 'Now we have the recursion isolated on its own line:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将递归独立成一行：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `find` function performs path compression from its argument to the root
    of the tree, and it returns the root of the tree. Therefore, this recursive call
    performs path compression from `p`’s parent to the root of the tree, and it returns
    the root of the tree. That handles all of the path compression except for `p`
    itself. We need to set `p`’s parent to the root of the tree as well, which we
    do with this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`函数从它的参数到树的根进行路径压缩，并返回树的根。因此，这次递归调用执行了从`p`的父节点到树根的路径压缩，并返回树的根。这样就处理了除`p`本身之外的所有路径压缩。我们还需要将`p`的父节点设置为树的根，这可以通过以下方式实现：'
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There we have it: proof that the one-line path-compression code really does
    work!'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：证明了一行路径压缩代码确实有效！
- en: 'Caps and Bottles: In-Place Sorting'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 瓶盖和瓶子：就地排序
- en: 'In [Chapter 10](ch10.xhtml), we solved the Caps and Bottles problem using a
    famous “splitting” idea from Quicksort. If you look back at [Listing 10-9](ch10.xhtml#ch010ex09),
    you’ll notice that we’re allocating a lot of additional memory as our algorithm
    runs. Specifically, on each invocation of `solve`, we use `malloc` to allocate
    memory for four arrays: the small caps, the small bottles, the big caps, and the
    big bottles.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.xhtml)中，我们使用快速排序中一个著名的“拆分”思想解决了“瓶盖和瓶子”问题。如果你回头查看[列表10-9](ch10.xhtml#ch010ex09)，你会发现我们在算法运行过程中分配了大量的额外内存。具体来说，在每次调用`solve`时，我们都会使用`malloc`为四个数组分配内存：小瓶盖、小瓶子、大瓶盖和大瓶子。
- en: It’s possible to avoid this use of additional memory and perform the splitting
    directly in the `cap_nums` and `bottle_nums` arrays. This won’t decrease the number
    of queries that we need to make, but it does decrease the memory that our program
    uses. It’s also a common optimization that people perform when implementing Quicksort.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接在`cap_nums`和`bottle_nums`数组中进行拆分，我们有可能避免使用额外的内存。这不会减少我们需要进行的查询次数，但确实减少了程序使用的内存。这也是在实现快速排序时，常见的一种优化方法。
- en: To make this work, we need to keep track of the border between small values
    and large values. We’ll maintain a variable called `border` to make this happen.
    Once we finish going through all of the caps and bottles, that `border` variable
    will tell us exactly where our problem is split in two; we need that in order
    to make our recursive calls. See [Listing B-6](app02.xhtml#app02ex06) for our
    new solution that uses this idea.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个方法有效，我们需要跟踪小值和大值之间的边界。我们将维护一个名为`border`的变量来实现这一点。一旦我们完成了遍历所有瓶盖和瓶子，`border`变量将准确告诉我们问题在哪里被分成了两部分；我们需要它来进行递归调用。请参见[列表
    B-6](app02.xhtml#app02ex06)，该列表展示了我们使用此思想的新解决方案。
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing B-6: Solution with no extra memory allocation*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 B-6：无额外内存分配的解决方案*'
- en: Rather than an `n` parameter giving the number of caps and bottles, now we need
    `left` and `right` parameters delimiting the operative part of the arrays ➊.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用一个`n`参数来表示瓶盖和瓶子的数量，现在我们需要使用`left`和`right`参数来限定数组的操作部分 ➊。
- en: Prior to the first `while` loop, we choose our random cap ➋. The key invariant
    for the first `while` loop is that all bottles from `left` to `border - 1` are
    small bottles and all bottles from `border` to `i - 1` are big bottles. The loop
    will also eventually find the matching bottle; when it does, it puts that at the
    right ➌. We’ll then be able to ignore that bottle in future recursive calls.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次`while`循环之前，我们选择了我们的随机边界 ➋。第一个`while`循环的关键不变量是：从`left`到`border - 1`的所有瓶子都是小瓶子，而从`border`到`i
    - 1`的所有瓶子都是大瓶子。循环最终还会找到匹配的瓶子；当它找到时，会把它放到右边 ➌。然后我们可以在后续的递归调用中忽略这个瓶子。
- en: If we find that the cap is too big for the current bottle ➍, it means that the
    current bottle is on the wrong side of `border`. After all, it’s a small bottle,
    and small bottles have to go to the left of `border`. To fix it, we swap that
    small bottle with the big bottle at `bottle_nums[border]` ➎, and then we increment
    `border` to take into account that we now have one more small bottle to the left
    of `border`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现瓶盖对于当前瓶子来说太大 ➍，这意味着当前瓶子位于`border`的错误一侧。毕竟，它是一个小瓶子，而小瓶子应该位于`border`的左边。为了解决这个问题，我们将这个小瓶子与`bottle_nums[border]`处的大瓶子交换
    ➎，然后我们将`border`递增，以便考虑到我们现在有了一个新的小瓶子在`border`的左侧。
- en: When that `while` loop is done, we’ll have rearranged the bottles so the small
    bottles are first and the big bottles follow. We’ll also have placed the matching
    bottle at the right, so we tell the judge about that match now ➏.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当`while`循环完成时，我们将重新排列瓶子，使小瓶子排在前面，大瓶子排在后面。我们还会把匹配的瓶子放到右边，所以现在就可以告诉判断器这个匹配了 ➏。
- en: The second `while` loop is nearly identical to the first, though this time it’s
    splitting the caps rather than the bottles.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`while`循环与第一个几乎完全相同，只不过这次它分割的是瓶盖，而不是瓶子。
- en: 'The final thing we need to do is make our two recursive calls. The first one
    goes from `left` to `border - 1` ➐—that’s all of the small caps and bottles. The
    second one goes from `border` to `right - 1` ➑—that’s all of the big caps and
    bottles. Be careful: we need `right - 1` here, not `right`. The bottle and cap
    at index `right` have already been matched and should therefore never again be
    passed to a recursive call.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是进行两个递归调用。第一个调用从`left`到`border - 1` ➐——那是所有的小瓶子和瓶盖。第二个调用从`border`到`right
    - 1` ➑——那是所有的大瓶子和瓶盖。注意：这里我们需要`right - 1`，而不是`right`。索引为`right`的瓶子和瓶盖已经匹配过了，因此不应再传递给递归调用。
