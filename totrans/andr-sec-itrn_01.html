<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Android&#x2019;s Security Model"><div class="titlepage"><div><div><h1 class="title"><a id="androidapostrophes_security_model"/>Chapter 1. Android’s Security Model</h1></div></div></div><p><a id="iddle2173" class="indexterm"/><a id="iddle2186" class="indexterm"/>This chapter will first briefly introduce Android’s architecture, inter-process communication (IPC) mechanism, and main components. We then describe Android’s security model and how it relates to the underlying Linux security infrastructure and code signing. We conclude with a brief overview of some newer additions to Android’s security model, namely multi-user support, mandatory access control (MAC) based on SELinux, and verified boot. Android’s architecture and security model are built on top of the traditional Unix process, user, and file paradigm, but this paradigm is not described from scratch here. We assume a basic familiarity with Unix-like systems, particularly Linux.</p><div class="sect1" title="Android’s Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="androidapostrophes_architecture"/>Android’s Architecture</h1></div></div></div><p>Let’s briefly examine Android’s architecture from the bottom up. <a class="xref" href="ch01.html#android_architecture" title="Figure 1-1. The Android architecture">Figure 1-1</a> shows a simplified representation of the Android stack.</p><div class="figure"><a id="android_architecture"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00002"/><img src="figs/web/01fig01.png" alt="The Android architecture"/></div></div><p class="title">Figure 1-1. The Android architecture</p></div><div class="sect2" title="Linux Kernel"><div class="titlepage"><div><div><h2 class="title"><a id="linux_kernel"/>Linux Kernel</h2></div></div></div><p><a id="iddle1139" class="indexterm"/><a id="iddle1223" class="indexterm"/><a id="iddle1224" class="indexterm"/><a id="iddle2141" class="indexterm"/><a id="iddle2162" class="indexterm"/><a id="iddle2265" class="indexterm"/><a id="iddle3100" class="indexterm"/>As you can see in <a class="xref" href="ch01.html#android_architecture" title="Figure 1-1. The Android architecture">Figure 1-1</a>, Android is built on top of the Linux kernel. As in any Unix system, the kernel provides drivers for hardware, networking, file-system access, and process management. Thanks to the Android Mainlining Project,<sup>[<a id="ch01fn01" href="#ftn.ch01fn01" class="footnote">1</a>]</sup> you can now run Android with a recent vanilla kernel (with some effort), but an Android kernel is slightly different from a “regular” Linux kernel that you might find on a desktop machine or a non-Android embedded device. The differences are due to a set of new features (sometimes called <span class="emphasis"><em>Androidisms</em></span><sup>[<a id="ch01fn02" href="#ftn.ch01fn02" class="footnote">2</a>]</sup>) that were originally added to support Android. Some of the main Androidisms are the low memory killer, wakelocks (integrated as part of wakeup sources support in the mainline Linux kernel), anonymous shared memory (ashmem), alarms, paranoid networking, and Binder.</p><p>The most important Androidisms for our discussion are Binder and paranoid networking. Binder implements IPC and an associated security mechanism, which we discuss in more detail in <a class="xref" href="ch01.html#binder" title="Binder">Binder</a>. Paranoid networking restricts access to network sockets to applications that hold specific permissions. We delve deeper into this topic in <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>.</p></div><div class="sect2" title="Native Userspace"><div class="titlepage"><div><div><h2 class="title"><a id="native_userspace"/>Native Userspace</h2></div></div></div><p>On top of the kernel is the native userspace layer, consisting of the <span class="emphasis"><em>init</em></span> binary (the first process started, which starts all other processes), several native daemons, and a few hundred native libraries that are used throughout the system. While the presence of an <span class="emphasis"><em>init</em></span> binary and daemons is reminiscent <a id="iddle1164" class="indexterm"/><a id="iddle1215" class="indexterm"/><a id="iddle1515" class="indexterm"/><a id="iddle1517" class="indexterm"/><a id="iddle1606" class="indexterm"/><a id="iddle2051" class="indexterm"/><a id="iddle2056" class="indexterm"/>of a traditional Linux system, note that both <span class="emphasis"><em>init</em></span> and the associated startup scripts have been developed from scratch and are quite different from their mainline Linux counterparts.</p></div><div class="sect2" title="Dalvik VM"><div class="titlepage"><div><div><h2 class="title"><a id="dalvik_vm"/>Dalvik VM</h2></div></div></div><p>The bulk of Android is implemented in Java and as such is executed by a Java Virtual Machine (JVM). Android’s current Java VM implementation is called <span class="emphasis"><em>Dalvik</em></span> and it is the next layer in our stack. Dalvik was designed with mobile devices in mind and cannot run Java bytecode (<span class="emphasis"><em>.class</em></span> files) directly: its native input format is called <span class="emphasis"><em>Dalvik Executable (DEX)</em></span> and is packaged in <span class="emphasis"><em>.dex</em></span> files. In turn, <span class="emphasis"><em>.dex</em></span> files are packaged either inside system Java libraries (JAR files), or inside Android applications (APK files, discussed in <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>).</p><p>Dalvik and Oracle’s JVM have different architectures—register-based in Dalvik versus stack-based in the JVM—and different instruction sets. Let’s look at a simple example to illustrate the differences between the two VMs (see <a class="xref" href="ch01.html#static_java_method_that_adds_two_integer" title="Example 1-1. Static Java method that adds two integers">Example 1-1</a>).</p><div class="example"><a id="static_java_method_that_adds_two_integer"/><p class="title">Example 1-1. Static Java method that adds two integers</p><div class="example-contents"><pre class="programlisting">public static int add(int i, int j) {
    return i + j;
}</pre></div></div><p>When compiled for each VM, the <code class="literal">add()</code> static method, which simply adds two integers and returns the result, would generate the bytecode shown in <a class="xref" href="ch01.html#jvm_and_dalvik_bytecode" title="Example 1-2. JVM and Dalvik bytecode">Example 1-2</a>.</p><div class="example"><a id="jvm_and_dalvik_bytecode"/><p class="title">Example 1-2. JVM and Dalvik bytecode</p><div class="example-contents"><p><span class="strong"><strong>JVM Bytecode</strong></span></p><a id="pro_id00001"/><pre class="programlisting">public static int add(int, int);
  Code:
     0: iload_0➊
     1: iload_1➋
     2: iadd➌
     3: ireturn➍</pre><p><span class="strong"><strong>Dalvik Bytecode</strong></span></p><a id="pro_id00002"/><pre class="programlisting">.method public static add(II)I

    add-int v0, p0, p1➎


    return v0➏
.end method</pre></div></div><p>Here, the JVM uses two instructions to load the parameters onto the stack (➊ and ➋), then executes the addition ➌, and finally returns the result ➍. In contrast, Dalvik uses a single instruction to add parameters (in registers <span class="emphasis"><em>p0</em></span> and <span class="emphasis"><em>p1</em></span>) and puts the result in the <span class="emphasis"><em>v0</em></span> register ➎. Finally, it returns the contents of the <span class="emphasis"><em>v0</em></span> register ➏. As you can see, Dalvik uses fewer instructions to achieve the same result. Generally speaking, register-based VMs use fewer instructions, but the resulting code is larger than the corresponding code in a stack-based VM. However, on most architectures, <a id="iddle1217" class="indexterm"/><a id="iddle1218" class="indexterm"/><a id="iddle1225" class="indexterm"/><a id="iddle1985" class="indexterm"/><a id="iddle2037" class="indexterm"/><a id="iddle2358" class="indexterm"/><a id="iddle2644" class="indexterm"/><a id="iddle2894" class="indexterm"/>loading code is less expensive than instruction dispatch, so register-based VMs can be interpreted more efficiently.<sup>[<a id="ch01fn03" href="#ftn.ch01fn03" class="footnote">3</a>]</sup></p><p>In most production devices, system libraries and preinstalled applications do not contain device-independent DEX code directly. As a performance optimization, DEX code is converted to a device-dependent format and stored in an Optimized DEX (<span class="emphasis"><em>.odex</em></span>) file, which typically resides in the same directory as its parent JAR or APK file. A similar optimization process is performed for user-installed applications at install time.</p></div><div class="sect2" title="Java Runtime Libraries"><div class="titlepage"><div><div><h2 class="title"><a id="java_runtime_libraries"/>Java Runtime Libraries</h2></div></div></div><p>A Java language implementation requires a set of runtime libraries, defined mostly in the <code class="literal">java.*</code> and <code class="literal">javax.*</code> packages. Android’s core Java libraries are originally derived from the Apache Harmony project<sup>[<a id="ch01fn04" href="#ftn.ch01fn04" class="footnote">4</a>]</sup> and are the next layer on our stack. As Android has evolved, the original Harmony code has changed significantly. In the process, some features have been replaced entirely (such as internationalization support, the cryptographic provider, and some related classes), while others have been extended and improved. The core libraries are developed mostly in Java, but they have some native code dependencies as well. Native code is linked into Android’s Java libraries using the standard <span class="emphasis"><em>Java Native Interface (JNI)</em></span>,<sup>[<a id="ch01fn05" href="#ftn.ch01fn05" class="footnote">5</a>]</sup> which allows Java code to call native code and vice versa. The Java runtime libraries layer is directly accessed both from system services and applications.</p></div><div class="sect2" title="System Services"><div class="titlepage"><div><div><h2 class="title"><a id="system_services"/>System Services</h2></div></div></div><p>The layers introduced up until now make up the plumbing necessary to implement the core of Android —system services. <span class="emphasis"><em>System services</em></span> (79 as of version 4.4) implement most of the fundamental Android features, including display and touch screen support, telephony, and network connectivity. Most system services are implemented in Java; some fundamental ones are written in native code.</p><p>With a few exceptions, each system service defines a remote interface that can be called from other services and applications. Coupled with the service discovery, mediation, and IPC provided by Binder, system services effectively implement an object-oriented OS on top of Linux.</p><p>Let’s look at how Binder enables IPC on Android in detail, as this is one of the cornerstones of Android’s security model.</p></div><div class="sect2" title="Inter-Process Communication"><div class="titlepage"><div><div><h2 class="title"><a id="inter-process_communication"/>Inter-Process Communication</h2></div></div></div><p>As mentioned previously, Binder is an inter-process communication (IPC) mechanism. Before getting into detail about how Binder works, let’s briefly review IPC.</p><p><a id="iddle1209" class="indexterm"/><a id="iddle1211" class="indexterm"/><a id="iddle1267" class="indexterm"/><a id="iddle1270" class="indexterm"/><a id="iddle1404" class="indexterm"/><a id="iddle1407" class="indexterm"/><a id="iddle1408" class="indexterm"/><a id="iddle1427" class="indexterm"/><a id="iddle2519" class="indexterm"/><a id="iddle2592" class="indexterm"/><a id="iddle2634" class="indexterm"/>As in any Unix-like system, processes in Android have separate address spaces and a process cannot directly access another process’s memory (this is called <span class="emphasis"><em>process isolation</em></span>). This is usually a good thing, both for stability and security reasons: multiple processes modifying the same memory can be catastrophic, and you don’t want a potentially rogue process that was started by another user to dump your email by accessing your mail client’s memory. However, if a process wants to offer some useful service(s) to other processes, it needs to provide some mechanism that allows other processes to discover and interact with those services. That mechanism is referred to as <span class="emphasis"><em>IPC</em></span>.</p><p>The need for a standard IPC mechanism is not new, so several options predate Android. These include files, signals, sockets, pipes, semaphores, shared memory, message queues, and so on. While Android uses some of these (such as local sockets), it does not support others (namely System V IPCs like semaphores, shared memory segments, and message queues).</p></div><div class="sect2" title="Binder"><div class="titlepage"><div><div><h2 class="title"><a id="binder"/>Binder</h2></div></div></div><p>Because the standard IPC mechanisms weren’t flexible or reliable enough, a new IPC mechanism called <span class="emphasis"><em>Binder</em></span> was developed for Android. While Android’s Binder is a new implementation, it’s based on the architecture and ideas of OpenBinder.<sup>[<a id="ch01fn06" href="#ftn.ch01fn06" class="footnote">6</a>]</sup></p><p>Binder implements a distributed component architecture based on abstract interfaces. It is similar to Windows Common Object Model (COM) and Common Object Broker Request Architectures (CORBA) on Unix, but unlike those frameworks, it runs on a single device and does not support remote procedure calls (RPC) across the network (although RPC support could be implemented on top of Binder). A full description of the Binder framework is outside the scope of this book, but we introduce its main components briefly in the following sections.</p><div class="sect3" title="Binder Implementation"><div class="titlepage"><div><div><h3 class="title"><a id="binder_implementation"/>Binder Implementation</h3></div></div></div><p>As mentioned earlier, on a Unix-like system, a process cannot access another process’s memory. However, the kernel has control over all processes and therefore can expose an interface that enables IPC. In Binder, this interface is the <span class="emphasis"><em>/dev/binder</em></span> device, which is implemented by the Binder kernel driver. The <span class="emphasis"><em>Binder driver</em></span> is the central object of the framework, and all IPC calls go through it. Inter-process communication is implemented with a single <code class="literal">ioctl()</code> call that both sends and receives data through the <code class="literal">binder_write_read</code> structure, which consists of a <code class="literal">write_buffer</code> containing commands for the driver, and a <code class="literal">read_buffer</code> containing commands that the userspace needs to perform.</p><p>But how is data actually passed between processes? The Binder driver manages part of the address space of each process. The Binder driver-managed chunk of memory is read-only to the process, and all writing <a id="iddle1125" class="indexterm"/><a id="iddle1137" class="indexterm"/><a id="iddle1213" class="indexterm"/><a id="iddle1273" class="indexterm"/><a id="iddle1420" class="indexterm"/><a id="iddle1702" class="indexterm"/><a id="iddle1763" class="indexterm"/><a id="iddle2477" class="indexterm"/>is performed by the kernel module. When a process sends a message to another process, the kernel allocates some space in the destination process’s memory, and copies the message data directly from the sending process. It then queues a short message to the receiving process telling it where the received message is. The recipient can then access that message directly (because it is in its own memory space). When a process is finished with the message, it notifies the Binder driver to mark the memory as free. <a class="xref" href="ch01.html#binder_ipc" title="Figure 1-2. Binder IPC">Figure 1-2</a> shows a simplified illustration of the Binder IPC architecture.</p><div class="figure"><a id="binder_ipc"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00003"/><img src="figs/web/01fig03.png" alt="Binder IPC"/></div></div><p class="title">Figure 1-2. Binder IPC</p></div><p>Higher-level IPC abstractions in Android such as <span class="emphasis"><em>Intents</em></span> (commands with associated data that are delivered to components across processes), <span class="emphasis"><em>Messengers</em></span> (objects that enable message-based communication across processes), and <span class="emphasis"><em>ContentProviders</em></span> (components that expose a cross-process data management interface) are built on top of Binder. Additionally, service interfaces that need to be exposed to other processes can be defined using the <span class="emphasis"><em>Android Interface Definition Language (AIDL)</em></span>, which enables clients to call remote services as if they were local Java objects. The associated <code class="literal">aidl</code> tool automatically generates <span class="emphasis"><em>stubs</em></span> (client-side representations of the remote object) and <span class="emphasis"><em>proxies</em></span> that map interface methods to the lower-level <code class="literal">transact()</code> Binder method and take care of converting parameters to a format that Binder can transmit (this is called <span class="emphasis"><em>parameter marshalling/unmarshalling</em></span>). Because Binder is inherently typeless, AIDL-generated stubs and proxies also provide type safety by including the target interface name in each Binder transaction (in the proxy) and validating it in the stub.</p></div><div class="sect3" title="Binder Security"><div class="titlepage"><div><div><h3 class="title"><a id="binder_security"/>Binder Security</h3></div></div></div><p>On a higher level, each object that can be accessed through the Binder framework implements the <code class="literal">IBinder</code> interface and is called a <span class="emphasis"><em>Binder object</em></span>. Calls to a Binder object are performed inside a <span class="emphasis"><em>Binder transaction</em></span>, which contains a reference to the target object, the ID of the method to execute, and a data buffer. The Binder driver automatically adds the process ID (PID) and effective user ID (EUID) of the calling process to the transaction <a id="iddle1009" class="indexterm"/><a id="iddle1057" class="indexterm"/><a id="iddle1207" class="indexterm"/><a id="iddle1210" class="indexterm"/><a id="iddle1214" class="indexterm"/><a id="iddle1265" class="indexterm"/><a id="iddle1269" class="indexterm"/><a id="iddle1274" class="indexterm"/><a id="iddle1313" class="indexterm"/><a id="iddle2331" class="indexterm"/><a id="iddle2923" class="indexterm"/>data. The called process (<span class="emphasis"><em>callee</em></span>) can inspect the PID and EUID and decide whether it should execute the requested method based on its internal logic or system-wide metadata about the calling application.</p><p>Since the PID and EUID are filled in by the kernel, caller processes cannot fake their identity to get more privileges than allowed by the system (that is, Binder prevents <span class="emphasis"><em>privilege escalation</em></span>). This is one of the central pieces of Android’s security model, and all higher-level abstractions, such as permissions, build upon it. The EUID and PID of the caller are accessible via the <code class="literal">getCallingPid()</code> and <code class="literal">getCallingUid()</code> methods of the <code class="literal">android.os.Binder</code> class, which is part of Android’s public API.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note01"/>Note</h3><p><span class="emphasis"><em>The calling process’s EUID may not map to a single application if more than one application is executing under the same UID (see <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a> for details). However, this does not affect security decisions, as processes running under the same UID are typically granted the same set of permissions and privileges (unless process-specific SELinux rules have been defined).</em></span></p></div></div><div class="sect3" title="Binder Identity"><div class="titlepage"><div><div><h3 class="title"><a id="binder_identity"/>Binder Identity</h3></div></div></div><p>One of the most important properties of Binder objects is that they maintain a unique identity across processes. Thus if process A creates a Binder object and passes it to process B, which in turn passes it to process C, calls from all three processes will be processed by the same Binder object. In practice, process A will reference the Binder object directly by its memory address (because it is in process A’s memory space), while process B and C will receive only a handle to the Binder object.</p><p>The kernel maintains the mapping between “live” Binder objects and their handles in other processes. Because a Binder object’s identity is unique and maintained by the kernel, it is impossible for userspace processes to create a copy of a Binder object or obtain a reference to one unless they have been handed one through IPC. Thus a Binder object is a unique, unforgeable, and communicable object that can act as a security <span class="emphasis"><em>token</em></span>. This enables the use of capability-based security in Android.</p></div><div class="sect3" title="Capability-Based Security"><div class="titlepage"><div><div><h3 class="title"><a id="capability-based_security"/>Capability-Based Security</h3></div></div></div><p>In a <span class="emphasis"><em>capability-based security model</em></span>, programs are granted access to a particular resource by giving them an unforgeable <span class="emphasis"><em>capability</em></span> that both references the target object and encapsulates a set of access rights to it. Because capabilities are unforgeable, the mere fact that a program possesses a capability is sufficient to give it access to the target resource; there is no need to maintain access control lists (ACLs) or similar structures associated with actual resources.</p></div><div class="sect3" title="Binder Tokens"><div class="titlepage"><div><div><h3 class="title"><a id="binder_tokens"/>Binder Tokens</h3></div></div></div><p>In Android, Binder objects can act as capabilities and are called <span class="emphasis"><em>Binder tokens</em></span> when used in this fashion. A Binder token can be both a capability and a target resource. The possession of a Binder token grants the owning <a id="iddle1206" class="indexterm"/><a id="iddle1264" class="indexterm"/><a id="iddle2330" class="indexterm"/>process full access to a Binder object, enabling it to perform Binder transactions on the target object. If the Binder object implements multiple actions (by selecting the action to perform based on the <code class="literal">code</code> parameter of the Binder transaction), the caller can perform any action when it has a reference to that Binder object. If more granular access control is required, the implementation of each action needs to implement the necessary permission checks, typically by utilizing the PID and EUID of the caller process.</p><p>A common pattern in Android is to allow all actions to callers running as <span class="emphasis"><em>system</em></span> (UID 1000) or <span class="emphasis"><em>root</em></span> (UID 0), but perform additional permission checks for all other processes. Thus access to important Binder objects such as system services is controlled in two ways: by limiting who can get a reference to that Binder object and by checking the caller identity before performing an action on the Binder object. (This check is optional and implemented by the Binder object itself, if required.)</p><p>Alternatively, a Binder object can be used only as a capability without implementing any other functionality. In this usage pattern, the same Binder object is held by two (or more) cooperating processes, and the one acting as a server (processing some kind of client requests) uses the Binder token to authenticate its clients, much like web servers use session cookies.</p><p>This usage pattern is used internally by the Android framework and is mostly invisible to applications. One notable use case of Binder tokens that is visible in the public API is <span class="emphasis"><em>window tokens</em></span>. The top-level window of each activity is associated with a Binder token (called a window token), which Android’s window manager (the system service responsible for managing application windows) keeps track of. Applications can obtain their own window token but cannot get access to the window tokens of other applications. Typically you don’t want other applications adding or removing windows on top of your own; each request to do so must provide the window token associated with the application, thus guaranteeing that window requests are coming from your own application or from the system.</p></div><div class="sect3" title="Accessing Binder Objects"><div class="titlepage"><div><div><h3 class="title"><a id="accessing_binder_objects"/>Accessing Binder Objects</h3></div></div></div><p>Although Android controls access to Binder objects for security purposes, and the only way to communicate with a Binder object is to be given a reference to it, some Binder objects (most notably system services) need to be universally accessible. It is, however, impractical to hand out references to all system services to each and every process, so we need some mechanism that allows processes to discover and obtain references to system services as needed.</p><p>In order to enable service discovery, the Binder framework has a single <span class="emphasis"><em>context manager</em></span>, which maintains references to Binder objects. Android’s context manager implementation is the <span class="emphasis"><em>servicemanager</em></span> native daemon. It is started very early in the boot process so that system services can register with it as they start up. Services are registered by passing a service name and a Binder reference to the service manager. Once a service is registered, <a id="iddle1208" class="indexterm"/><a id="iddle1212" class="indexterm"/><a id="iddle1266" class="indexterm"/><a id="iddle1272" class="indexterm"/><a id="iddle1520" class="indexterm"/><a id="iddle2140" class="indexterm"/><a id="iddle2587" class="indexterm"/>any client can obtain its Binder reference by using its name. However, most system services implement additional permission checks, so obtaining a reference does not automatically guarantee access to all of its functionality. Because anyone can access a Binder reference when it is registered with the service manager, only a small set of whitelisted system processes can register system services. For example, only a process executing as UID 1002 (<code class="literal">AID_BLUETOOTH</code>) can register the <span class="emphasis"><em>bluetooth</em></span> system service.</p><p>You can view a list of registered services by using the <code class="literal">service list</code> command, which returns the name of each registered service and the implemented <code class="literal">IBinder</code> interface. Sample output from running the command on an Android 4.4 device is shown in <a class="xref" href="ch01.html#obtaining_a_list_of_registered_system_se" title="Example 1-3. Obtaining a list of registered system services with the service list command">Example 1-3</a>.</p><div class="example"><a id="obtaining_a_list_of_registered_system_se"/><p class="title">Example 1-3. Obtaining a list of registered system services with the <code class="literal">service list</code> command</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>service list</strong></span>
service list
Found 79 services:
0       sip: [android.net.sip.ISipService]
1       phone: [com.android.internal.telephony.ITelephony]
2       iphonesubinfo: [com.android.internal.telephony.IPhoneSubInfo]
3       simphonebook: [com.android.internal.telephony.IIccPhoneBook]
4       isms: [com.android.internal.telephony.ISms]
5       nfc: [android.nfc.INfcAdapter]
6       media_router: [android.media.IMediaRouterService]
7       print: [android.print.IPrintManager]
8       assetatlas: [android.view.IAssetAtlas]
9       dreams: [android.service.dreams.IdreamManager]
--<span class="emphasis"><em>snip</em></span>--</pre></div></div></div><div class="sect3" title="Other Binder Features"><div class="titlepage"><div><div><h3 class="title"><a id="other_binder_features"/>Other Binder Features</h3></div></div></div><p>While not directly related to Android’s security model, two other notable Binder features are reference counting and death notification (also known as link to death). <span class="emphasis"><em>Reference counting</em></span> guarantees that Binder objects are automatically freed when no one references them and is implemented in the kernel driver with the <code class="literal">BC_INCREFS</code>, <code class="literal">BC_ACQUIRE</code>, <code class="literal">BC_RELEASE</code>, and <code class="literal">BC_DECREFS</code> commands. Reference counting is integrated at various levels of the Android framework but is not directly visible to applications.</p><p><span class="emphasis"><em>Death notification</em></span> allows applications that use Binder objects that are hosted by other processes to be notified when those processes are killed by the kernel and to perform any necessary cleanup. Death notification is implemented with the <code class="literal">BC_REQUEST_DEATH_NOTIFICATION</code> and <code class="literal">BC_CLEAR_DEATH_NOTIFICATION</code> commands in the kernel driver and the <code class="literal">linkToDeath()</code> and <code class="literal">unlinkToDeath()</code> methods of the <code class="literal">IBinder</code> interface<sup>[<a id="ch01fn07" href="#ftn.ch01fn07" class="footnote">7</a>]</sup> in the framework. (Death notifications for local binders are not sent, because local binders cannot die without the hosting process dying as well.)</p></div></div><div class="sect2" title="Android Framework Libraries"><div class="titlepage"><div><div><h2 class="title"><a id="android_framework_libraries"/>Android Framework Libraries</h2></div></div></div><p><a id="iddle1189" class="indexterm"/><a id="iddle1204" class="indexterm"/><a id="iddle1216" class="indexterm"/><a id="iddle1829" class="indexterm"/><a id="iddle2498" class="indexterm"/><a id="iddle2526" class="indexterm"/><a id="iddle2569" class="indexterm"/><a id="iddle2832" class="indexterm"/><a id="iddle2889" class="indexterm"/><a id="iddle2897" class="indexterm"/>Next on the stack are the Android framework libraries, sometimes called just “the framework.” The framework includes all Java libraries that are not part of the standard Java runtime (<code class="literal">java.*</code>, <code class="literal">javax.*</code>, and so on) and is for the most part hosted under the <code class="literal">android</code> top-level package. The framework includes the basic blocks for building Android applications, such as the base classes for activities, services, and content providers (in the <code class="literal">android.app.*</code> packages); GUI widgets (in the <code class="literal">android.view.*</code> and <code class="literal">android.widget</code> packages); and classes for file and database access (mostly in the <code class="literal">android.database.*</code> and <code class="literal">android.content.*</code> packages). It also includes classes that let you interact with device hardware, as well as classes that take advantage of higher-level services offered by the system.</p><p>Even though almost all Android OS functionality above the kernel level is implemented as system services, it is not exposed directly in the framework but is accessed via facade classes called <span class="emphasis"><em>managers</em></span>. Typically, each manager is backed by a corresponding system service; for example, the <code class="literal">BluetoothManager</code> is a facade for the <code class="literal">BluetoothManagerService</code>.</p></div><div class="sect2" title="Applications"><div class="titlepage"><div><div><h2 class="title"><a id="applications"/>Applications</h2></div></div></div><p>On the highest level of the stack are <span class="emphasis"><em>applications</em></span> (or <span class="emphasis"><em>apps</em></span>), which are the programs that users directly interact with. While all apps have the same structure and are built on top of the Android framework, we distinguish between system apps and user-installed apps.</p><div class="sect3" title="System Apps"><div class="titlepage"><div><div><h3 class="title"><a id="system_apps"/>System Apps</h3></div></div></div><p><span class="emphasis"><em>System apps</em></span> are included in the OS image, which is read-only on production devices (typically mounted as <span class="emphasis"><em>/system</em></span>), and cannot be uninstalled or changed by users. Therefore, these apps are considered secure and are given many more privileges than user-installed apps. System apps can be part of the core Android OS or can simply be preinstalled user applications, such as email clients or browsers. While all apps installed under <span class="emphasis"><em>/system</em></span> were treated equally in earlier versions of Android (except by OS features that check the app signing certificate), Android 4.4 and higher treat apps installed in <span class="emphasis"><em>/system/priv-app/</em></span> as privileged applications and will only grant permissions with protection level <span class="emphasis"><em>signatureOrSystem</em></span> to privileged apps, not to all apps installed under <span class="emphasis"><em>/system</em></span>. Apps that are signed with the platform signing key can be granted system permissions with the <span class="emphasis"><em>signature</em></span> protection level, and thus can get OS-level privileges even if they are not preinstalled under <span class="emphasis"><em>/system</em></span>. (See <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a> for details on permissions and code signing.)</p><p>While system apps cannot be uninstalled or changed, they can be updated by users as long as the updates are signed with the same private key, and some can be overridden by user-installed apps. For example, a user can choose to replace the preinstalled application launcher or input method with a third-party application.</p></div><div class="sect3" title="User-Installed Apps"><div class="titlepage"><div><div><h3 class="title"><a id="user-installed_apps"/>User-Installed Apps</h3></div></div></div><p><a id="iddle1140" class="indexterm"/><a id="iddle1182" class="indexterm"/><a id="iddle1184" class="indexterm"/><a id="iddle1188" class="indexterm"/><a id="iddle1190" class="indexterm"/><a id="iddle1199" class="indexterm"/><a id="iddle1202" class="indexterm"/><a id="iddle1203" class="indexterm"/><a id="iddle1205" class="indexterm"/><a id="iddle2571" class="indexterm"/><a id="iddle2763" class="indexterm"/><a id="iddle2999" class="indexterm"/><a id="iddle3003" class="indexterm"/><span class="emphasis"><em>User-installed apps</em></span> are installed on a dedicated read-write partition (typically mounted as <span class="emphasis"><em>/data</em></span>) that hosts user data and can be uninstalled at will. Each application lives in a dedicated security sandbox and typically cannot affect other applications or access their data. Additionally, apps can only access resources that they have explicitly been granted a permission to use. Privilege separation and the principle of least privilege are central to Android’s security model, and we will explore how they are implemented in the next section.</p></div><div class="sect3" title="Android App Components"><div class="titlepage"><div><div><h3 class="title"><a id="android_app_components"/>Android App Components</h3></div></div></div><p>Android applications are a combination of loosely coupled <span class="emphasis"><em>components</em></span> and, unlike traditional applications, can have more than one entry point. Each component can offer multiple entry points that can be reached based on user actions in the same or another application, or triggered by a system event that the application has registered to be notified about.</p><p>Components and their entry points, as well as additional metadata, are defined in the application’s manifest file, called <span class="emphasis"><em>AndroidManifest.xml</em></span>. Like most Android resource files, this file is compiled into a binary XML format (similar to ASN.1) before bundling it in the application package (APK) file in order to decrease size and speed up parsing. The most important application property defined in the manifest file is the application package name, which uniquely identifies each application in the system. The package name is in the same format as Java package names (reverse domain name notation; for example, <span class="emphasis"><em>com.google.email</em></span>).</p><p>The <span class="emphasis"><em>AndroidManifest.xml</em></span> file is parsed at application install time, and the package and components it defines are registered with the system. Android requires each application to be signed using a key controlled by its developer. This guarantees that an installed application cannot be replaced by another application that claims to have the same package name (unless it is signed with the same key, in which case the existing application is updated). We’ll discuss code signing and application packages in <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>.</p><p>The main components of Android apps are listed below.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Activities</strong></span></span></dt><dd><p>An <span class="emphasis"><em>activity</em></span> is a single screen with a user interface. Activities are the main building blocks of Android GUI applications. An application can have multiple activities and while they are usually designed to be displayed in a particular order, each activity can be started independently, potentially by a different app (if allowed).</p></dd><dt><span class="term"><span class="strong"><strong>Services</strong></span></span></dt><dd><p>A <span class="emphasis"><em>service</em></span> is a component that runs in the background and has no user interface. Services are typically used to perform some long-running operation, such as downloading a file or playing music, without blocking the user interface. Services can also define a remote interface using <a id="iddle1167" class="indexterm"/><a id="iddle1183" class="indexterm"/><a id="iddle1185" class="indexterm"/><a id="iddle1187" class="indexterm"/><a id="iddle1200" class="indexterm"/><a id="iddle1201" class="indexterm"/><a id="iddle1302" class="indexterm"/><a id="iddle1419" class="indexterm"/><a id="iddle1513" class="indexterm"/><a id="iddle2649" class="indexterm"/><a id="iddle2708" class="indexterm"/><a id="iddle2712" class="indexterm"/><a id="iddle2778" class="indexterm"/><a id="iddle2795" class="indexterm"/><a id="iddle2796" class="indexterm"/><a id="iddle2879" class="indexterm"/>AIDL and provide some functionality to other apps. However, unlike system services, which are part of the OS and are always running, application services are started and stopped on demand.</p></dd><dt><span class="term"><span class="strong"><strong>Content providers</strong></span></span></dt><dd><p><span class="emphasis"><em>Content providers</em></span> provide an interface to app data, which is typically stored in a database or files. Content providers can be accessed via IPC and are mainly used to share an app’s data with other apps. Content providers offer fine-grained control over what parts of data are accessible, allowing an application to share only a subset of its data.</p></dd><dt><span class="term"><span class="strong"><strong>Broadcast receivers</strong></span></span></dt><dd><p>A <span class="emphasis"><em>broadcast receiver</em></span> is a component that responds to systemwide events, called <span class="emphasis"><em>broadcasts</em></span>. Broadcasts can originate from the system (for example, announcing changes in network connectivity), or from a user application (for example, announcing that background data update has completed).</p></dd></dl></div></div></div></div><div class="sect1" title="Android’s Security Model"><div class="titlepage"><div><div><h1 class="title"><a id="androidapostrophes_security_mode-id00001"/>Android’s Security Model</h1></div></div></div><p>Like the rest of the system, Android’s security model also takes advantage of the security features offered by the Linux kernel. Linux is a multiuser operating system and the kernel can isolate user resources from one another, just as it isolates processes. In a Linux system, one user cannot access another user’s files (unless explicitly granted permission) and each process runs with the identity (<span class="emphasis"><em>user</em></span> and <span class="emphasis"><em>group ID</em></span>, usually referred to as <span class="emphasis"><em>UID</em></span> and <span class="emphasis"><em>GID</em></span>) of the user that started it, unless the set-user-ID or set-group-ID (SUID and SGID) bits are set on the corresponding executable file.</p><p>Android takes advantage of this user isolation, but treats users differently than a traditional Linux system (desktop or server) does. In a traditional system, a UID is given either to a physical user that can log into the system and execute commands via the shell, or to a system service (daemon) that executes in the background (because system daemons are often accessible over the network, running each daemon with a dedicated UID can limit the damage if one is compromised). Android was originally designed for smartphones, and because mobile phones are personal devices, there was no need to register different physical users with the system. The physical user is implicit, and UIDs are used to distinguish applications instead. This forms the basis of Android’s application sandboxing.</p><div class="sect2" title="Application Sandboxing"><div class="titlepage"><div><div><h2 class="title"><a id="application_sandboxing"/>Application Sandboxing</h2></div></div></div><p>Android automatically assigns a unique UID, often called an <span class="emphasis"><em>app ID</em></span>, to each application at installation and executes that application in a dedicated process running as that UID. Additionally, each application is given a dedicated data directory which only it has permission to read and write to. Thus, applications are isolated, or <span class="emphasis"><em>sandboxed</em></span>, both at the process level (by having each run in a dedicated process) and at the file level (by having a private data directory). This creates a kernel-level application sandbox, which applies to all applications, regardless of whether they are executed in a native or virtual machine process.</p><p>System daemons and applications run under well-defined and constant UIDs, and very few daemons run as the root user (UID 0). Android does not have the traditional <span class="emphasis"><em>/etc/password</em></span> file and its system UIDs are statically defined in the <span class="emphasis"><em>android_filesystem_config.h</em></span> header file. UIDs for system services start from 1000, with 1000 being the <span class="emphasis"><em>system</em></span> (<code class="literal">AID_SYSTEM</code>) user, which has special (but still limited) privileges. Automatically generated UIDs for applications start at 10000 (<code class="literal">AID_APP</code>), and the corresponding usernames are in the form <span class="emphasis"><em>app_XXX</em></span> or <span class="emphasis"><em>uY_aXXX</em></span> (on Android versions that support multiple physical users), where <span class="emphasis"><em>XXX</em></span> is the offset from <span class="emphasis"><em>AID_APP</em></span> and <span class="emphasis"><em>Y</em></span> is the Android user ID (not the same as UID). For example, the 10037 UID corresponds to the <span class="emphasis"><em>u0_a37</em></span> username and may be assigned to the Google email client application (<span class="emphasis"><em>com.google.android.email</em></span> package). <a class="xref" href="ch01.html#each_application_process_executes_as_a_d" title="Example 1-4. Each application process executes as a dedicated user on Android">Example 1-4</a> shows that the email application process executes as the <span class="emphasis"><em>u0_a37</em></span> user ➊, while other application processes execute as different users.</p><div class="example"><a id="each_application_process_executes_as_a_d"/><p class="title">Example 1-4. Each application process executes as a dedicated user on Android</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ps</strong></span>
--<span class="emphasis"><em>snip</em></span>--
u0_a37    16973 182  941052  60800 ffffffff 400d073c S com.google.android.email➊
u0_a8     18788 182  925864  50236 ffffffff 400d073c S com.google.android.dialer
u0_a29    23128 182  875972  35120 ffffffff 400d073c S com.google.android.calendar
u0_a34    23264 182  868424  31980 ffffffff 400d073c S com.google.android.deskclock
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>The data directory of the email application is named after its package name and is created under <span class="emphasis"><em>/data/data/</em></span> on single-user devices. (Multi-user devices use a different naming scheme as discussed in <a class="xref" href="ch04.html" title="Chapter 4. User Management">Chapter 4</a>.) All files inside the data directory are owned by the dedicated Linux user, <span class="emphasis"><em>u0_a37</em></span>, as shown in <a class="xref" href="ch01.html#application_directories_are_owned_by_the" title="Example 1-5. Application directories are owned by the dedicated Linux user">Example 1-5</a> (with timestamps omitted). Applications can optionally create files using the <code class="literal">MODE_WORLD_READABLE</code> and <code class="literal">MODE_WORLD_WRITEABLE</code> flags to allow direct access to files by other applications, which effectively sets the <code class="literal">S_IROTH</code> and <code class="literal">S_IWOTH</code> access bits on the file, respectively. However, the direct sharing of files is discouraged, and those flags are deprecated in Android versions 4.2 and higher.</p><div class="example"><a id="application_directories_are_owned_by_the"/><p class="title">Example 1-5. Application directories are owned by the dedicated Linux user</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -l /data/data/com.google.android.email</strong></span>
drwxrwx--x u0_a37   u0_a37            app_webview
drwxrwx--x u0_a37   u0_a37            cache
drwxrwx--x u0_a37   u0_a37            databases
drwxrwx--x u0_a37   u0_a37            files
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p><a id="iddle1141" class="indexterm"/><a id="iddle1521" class="indexterm"/><a id="iddle2465" class="indexterm"/><a id="iddle2713" class="indexterm"/><a id="iddle2967" class="indexterm"/>Application UIDs are managed alongside other package metadata in the <span class="emphasis"><em>/data/system/packages.xml</em></span> file (the canonical source) and also written to the <span class="emphasis"><em>/data/system/packages.list</em></span> file. (We discuss package management and the <span class="emphasis"><em>packages.xml</em></span> file in <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>.) <a class="xref" href="ch01.html#uid_corresponding_to_each_application_is" title="Example 1-6. The UID corresponding to each application is stored in /data/system/packages.list">Example 1-6</a> shows the UID assigned to the <span class="emphasis"><em>com.google.android.email</em></span> package as it appears in <span class="emphasis"><em>packages.list</em></span>.</p><div class="example"><a id="uid_corresponding_to_each_application_is"/><p class="title">Example 1-6. The UID corresponding to each application is stored in <span class="roman">/data/system/packages.list</span></p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>grep 'com.google.android.email' /data/system/packages.list</strong></span>
com.google.android.email 10037 0 /data/data/com.google.android.email default 3003,1028,1015</pre></div></div><p>Here, the first field is the package name, the second is the UID assigned to the application, the third is the debuggable flag (<code class="literal">1</code> if debuggable), the fourth is the application’s data directory path, and the fifth is the <span class="emphasis"><em>seinfo</em></span> label (used by SELinux). The last field is a list of the supplementary GIDs that the app launches with. Each GID is typically associated with an Android permission (discussed next) and the GID list is generated based on the permissions granted to the application.</p><p>Applications can be installed using the same UID, called a <span class="emphasis"><em>shared user ID</em></span>, in which case they can share files and even run in the same process. Shared user IDs are used extensively by system applications, which often need to use the same resources across different packages for modularity. For example, in Android 4.4 the system UI and keyguard (lockscreen implementation) share UID 10012 (see <a class="xref" href="ch01.html#system_packages_sharing_the_same_uid" title="Example 1-7. System packages sharing the same UID">Example 1-7</a>).</p><div class="example"><a id="system_packages_sharing_the_same_uid"/><p class="title">Example 1-7. System packages sharing the same UID</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>grep ' 10012 ' /data/system/packages.list</strong></span>
com.android.keyguard 10012 0 /data/data/com.android.keyguard platform 1028,1015,1035,3002,3001
com.android.systemui 10012 0 /data/data/com.android.systemui platform 1028,1015,1035,3002,3001</pre></div></div><p>While the shared user ID facility is not recommended for non-system apps, it’s available to third-party applications as well. In order to share the same UID, applications need to be signed by the same code signing key. Additionally, because adding a shared user ID to a new version of an installed app causes it to change its UID, the system disallows this (see <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>). Therefore, a shared user ID cannot be added retroactively, and apps need to be designed to work with a shared ID from the start.</p></div><div class="sect2" title="Permissions"><div class="titlepage"><div><div><h2 class="title"><a id="permissions"/>Permissions</h2></div></div></div><p>Because Android applications are sandboxed, they can access only their own files and any world-accessible resources on the device. Such a limited application wouldn’t be very interesting though, and Android can grant additional, fine-grained access rights to applications in order to allow for richer functionality. Those access rights are called <span class="emphasis"><em>permissions</em></span>, and they can control access to hardware devices, Internet connectivity, data, or OS services.</p><p>Applications can request permissions by defining them in the <span class="emphasis"><em>AndroidManifest.xml</em></span> file. At application install time, Android inspects <a id="iddle1142" class="indexterm"/><a id="iddle1986" class="indexterm"/><a id="iddle2710" class="indexterm"/>the list of requested permissions and decides whether to grant them or not. Once granted, permissions cannot be revoked and they are available to the application without any additional confirmation. Additionally, for features such as private key or user account access, explicit user confirmation is required for each accessed object, even if the requesting application has been granted the corresponding permission (see <a class="xref" href="ch07.html" title="Chapter 7. Credential Storage">Chapter 7</a> and <a class="xref" href="ch08.html" title="Chapter 8. Online Account Management">Chapter 8</a>). Some permission can only be granted to applications that are part of the Android OS, either because they’re preinstalled or signed with the same key as the OS. Third-party applications can define custom permissions and define similar restrictions known as permission <span class="emphasis"><em>protection levels</em></span>, thus restricting access to an app’s services and resources to apps created by the same author.</p><p>Permission can be enforced at different levels. Requests to lower-level system resources, such as device files, are enforced by the Linux kernel by checking the UID or GID of the calling process against the resource’s owner and access bits. When accessing higher-level Android components, enforcement is performed either by the Android OS or by each component (or both). We discuss permissions in <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>.</p></div><div class="sect2" title="IPC"><div class="titlepage"><div><div><h2 class="title"><a id="ipc"/>IPC</h2></div></div></div><p>Android uses a combination of a kernel driver and userspace libraries to implement IPC. As discussed in “<a class="xref" href="ch01.html#binder" title="Binder">Binder</a>”, the Binder kernel driver guarantees that the UID and PID of callers cannot be forged, and many system services rely on the UID and PID provided by Binder to dynamically control access to sensitive APIs exposed via IPC. For example, the system Bluetooth manager service only allows system applications to enable Bluetooth silently if the caller is running with the <span class="emphasis"><em>system</em></span> UID (1000) by using the code shown in <a class="xref" href="ch01.html#checking_that_the_caller_is_running_with" title="Example 1-8. Checking that the caller is running with the system UID">Example 1-8</a>. Similar code is found in other system services.</p><div class="example"><a id="checking_that_the_caller_is_running_with"/><p class="title">Example 1-8. Checking that the caller is running with the <span class="roman">system</span> UID</p><div class="example-contents"><pre class="programlisting">public boolean enable() {
    if ((Binder.getCallingUid() != Process.SYSTEM_UID) &amp;&amp;
        (!checkIfCallerIsForegroundUser())) {
        Log.w(TAG,"enable(): not allowed for non-active and non-system user");
        return false;
     }
--<span class="emphasis"><em>snip</em></span>--
}</pre></div></div><p>More coarse-grained permissions that affect all methods of a service exposed via IPC can be automatically enforced by the system by specifying a permission in the service declaration. As with requested permissions, required permissions are declared in the <span class="emphasis"><em>AndroidManifest.xml</em></span> file. Like the dynamic permission check in the example above, per-component permissions are also implemented by consulting the caller UID obtained from Binder under the hood. The system uses the package database to determine the permission required by the callee component, and then maps the <a id="iddle1163" class="indexterm"/><a id="iddle1403" class="indexterm"/><a id="iddle2255" class="indexterm"/><a id="iddle2411" class="indexterm"/><a id="iddle2495" class="indexterm"/><a id="iddle2648" class="indexterm"/><a id="iddle2709" class="indexterm"/><a id="iddle2711" class="indexterm"/><a id="iddle2714" class="indexterm"/><a id="iddle2966" class="indexterm"/>caller UID to a package name and retrieves the set of permissions granted to the caller. If the required permission is in that set, the call succeeds. If not, it fails and the system throws a <code class="literal">SecurityException</code>.</p></div><div class="sect2" title="Code Signing and Platform Keys"><div class="titlepage"><div><div><h2 class="title"><a id="code_signing_and_platform_keys"/>Code Signing and Platform Keys</h2></div></div></div><p>All Android applications must be signed by their developer, including system applications. Because Android APK files are an extension of the Java JAR package format,<sup>[<a id="ch01fn08" href="#ftn.ch01fn08" class="footnote">8</a>]</sup> the code signing method used is also based on JAR signing. Android uses the APK signature to make sure updates for an app are coming from the same author (this is called the <span class="emphasis"><em>same origin policy</em></span>) and to establish trust relationships between applications. Both of these security features are implemented by comparing the signing certificate of the currently installed target app with the certificate of the update or related application.</p><p>System applications are signed by a number of <span class="emphasis"><em>platform keys</em></span>. Different system components can share resources and run inside the same process when they are signed with the same platform key. Platform keys are generated and controlled by whoever maintains the Android version installed on a particular device: device manufacturers, carriers, Google for Nexus devices, or users for self-built open source Android versions. (We’ll discuss code signing and the APK format in <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>.)</p></div><div class="sect2" title="Multi-User Support"><div class="titlepage"><div><div><h2 class="title"><a id="multi-user_support"/>Multi-User Support</h2></div></div></div><p>Because Android was originally designed for handset (smartphone) devices that have a single physical user, it assigns a distinct Linux UID to each installed application and traditionally does not have a notion of a physical user. Android gained support for multiple physical users in version 4.2, but multi-user support is only enabled on tablets, which are more likely to be shared. Multi-user support on handset devices is disabled by setting the maximum number of users to 1.</p><p>Each user is assigned a unique user ID, starting with 0, and users are given their own dedicated data directory under <span class="emphasis"><em>/data/system/users/&lt;user ID&gt;/</em></span>, which is called the user’s <span class="emphasis"><em>system directory</em></span>. This directory hosts user-specific settings such as homescreen parameters, account data, and a list of currently installed applications. While application binaries are shared between users, each user gets a copy of an application’s data directory.</p><p>To distinguish applications installed for each user, Android assigns a new effective UID to each application when it is installed for a particular user. This effective UID is based on the target physical user’s user ID and the app’s UID in a single-user system (the <span class="emphasis"><em>app ID</em></span>). This composite structure of the granted UID guarantees that even if the same application is installed by two different users, both application instances get their own sandbox. Additionally, Android guarantees dedicated shared storage (hosted on an SD card for older devices), which is world-readable, to each physical user. <a id="iddle1073" class="indexterm"/><a id="iddle1135" class="indexterm"/><a id="iddle1509" class="indexterm"/><a id="iddle1634" class="indexterm"/><a id="iddle2174" class="indexterm"/><a id="iddle2187" class="indexterm"/><a id="iddle2363" class="indexterm"/><a id="iddle2376" class="indexterm"/><a id="iddle2715" class="indexterm"/><a id="iddle2716" class="indexterm"/><a id="iddle2739" class="indexterm"/><a id="iddle2750" class="indexterm"/><a id="iddle2902" class="indexterm"/><a id="iddle2986" class="indexterm"/>The user to first initialize the device is called the <span class="emphasis"><em>device owner</em></span>, and only they can manage other users or perform administrative tasks that influence the whole device (such as factory reset). (We discuss multi-user support in greater detail in <a class="xref" href="ch04.html" title="Chapter 4. User Management">Chapter 4</a>.)</p></div><div class="sect2" title="SELinux"><div class="titlepage"><div><div><h2 class="title"><a id="selinux"/>SELinux</h2></div></div></div><p>The traditional Android security model relies heavily on the UIDs and GIDs granted to applications. While those are guaranteed by the kernel, and by default each application’s files are private, nothing prevents an application from granting world access to its files (whether intentionally or due to a programming error).</p><p>Similarly, nothing prevents malicious applications from taking advantage of the overly permissive access bits of system files or local sockets. In fact, inappropriate permissions assigned to application or system files have been the source of a number of Android vulnerabilities. Those vulnerabilities are unavoidable in the default access control model employed by Linux, known as <span class="emphasis"><em>discretionary access control (DAC)</em></span>. <span class="emphasis"><em>Discretionary</em></span> here means that once a user gets access to a particular resource, they can pass it on to another user at their discretion, such as by setting the access mode of one of their files to world-readable. In contrast, <span class="emphasis"><em>mandatory access control (MAC)</em></span> ensures that access to resources conforms to a system-wide set of <span class="emphasis"><em>authorization rules</em></span> called a <span class="emphasis"><em>policy</em></span>. The policy can only be changed by an administrator, and users cannot override or bypass it in order to, for example, grant everyone access to their own files.</p><p><span class="emphasis"><em>Security Enhanced Linux (SELinux)</em></span> is a MAC implementation for the Linux kernel and has been integrated in the mainline kernel for more than 10 years. As of version 4.3, Android integrates a modified SELinux version from the Security Enhancements for Android (SEAndroid) project<sup>[<a id="ch01fn09" href="#ftn.ch01fn09" class="footnote">9</a>]</sup> that has been augmented to support Android-specific features such as Binder. In Android, SELinux is used to isolate core system daemons and user applications in different security <span class="emphasis"><em>domains</em></span> and to define different access policies for each domain. As of version 4.4, SELinux is deployed in <span class="emphasis"><em>enforcing mode</em></span> (violations to the system policy generate runtime errors), but policy enforcement is only applied to core system daemons. Applications still run in <span class="emphasis"><em>permissive mode</em></span> and violations are logged but do not cause runtime errors. (We give more details about Android’s SELinux implementation in <a class="xref" href="ch12.html" title="Chapter 12. Selinux">Chapter 12</a>.)</p></div><div class="sect2" title="System Updates"><div class="titlepage"><div><div><h2 class="title"><a id="system_updates"/>System Updates</h2></div></div></div><p>Android devices can be updated over-the-air (OTA) or by connecting the device to a PC and pushing the update image using the standard Android debug bridge (ADB) client or some vendor-provided application with similar functionality. Because in addition to system files, an Android update might need to modify the baseband (modem) firmware, bootloader, and <a id="iddle1295" class="indexterm"/><a id="iddle1471" class="indexterm"/><a id="iddle1787" class="indexterm"/><a id="iddle2717" class="indexterm"/><a id="iddle2840" class="indexterm"/><a id="iddle3056" class="indexterm"/>other parts of the device that are not directly accessible from Android, the update process typically uses a special-purpose, minimal OS with exclusive access to all device hardware. This is called a <span class="emphasis"><em>recovery OS</em></span> or simply <span class="emphasis"><em>recovery</em></span>.</p><p>OTA updates are performed by downloading an OTA package file (typically a ZIP file with an added code signature), which contains a small script file to be interpreted by the recovery, and rebooting the device in <span class="emphasis"><em>recovery mode</em></span>. Alternatively, the user can enter recovery mode by using a device-specific key combination when booting the device, and apply the update manually by using the menu interface of the recovery, which is usually navigated using the hardware buttons (Volume up/down, Power, and so on) of the device.</p><p>On production devices, the recovery accepts only updates signed by the device manufacturer. Update files are signed by extending the ZIP file format to include a signature over the whole file in the comment section (see <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>), which the recovery extracts and verifies before installing the update. On some devices (including all Nexus devices, dedicated developer devices, and some vendor devices), device owners can replace the recovery OS and disable system update signature verification, allowing them to install updates by third parties. Switching the device bootloader to a mode that allows replacing the recovery and system images is called <span class="emphasis"><em>bootloader unlocking</em></span> (not to be confused with SIM-unlocking, which allows a device to be used on any mobile network) and typically requires wiping all user data (factory reset) in order to make sure that a potentially malicious third-party system image does not get access to existing user data. On most consumer devices, unlocking the bootloader has the side effect of voiding the device’s warranty. (We discuss system updates and recovery images in <a class="xref" href="ch13.html" title="Chapter 13. System Updates and Root Access">Chapter 13</a>.)</p></div><div class="sect2" title="Verified Boot"><div class="titlepage"><div><div><h2 class="title"><a id="verified_boot"/>Verified Boot</h2></div></div></div><p>As of version 4.4, Android supports verified boot using the <span class="emphasis"><em>verity</em></span> target<sup>[<a id="ch01fn10" href="#ftn.ch01fn10" class="footnote">10</a>]</sup> of Linux’s Device-Mapper. Verity provides transparent integrity checking of block devices using a cryptographic hash tree. Each node in the tree is a cryptographic hash, with leaf nodes containing the hash value of a physical data block and intermediary nodes containing hash values of their child nodes. Because the hash in the root node is based on the values of all other nodes, only the root hash needs to be trusted in order to verify the rest of the tree.</p><p>Verification is performed with an RSA public key included in the boot partition. Device blocks are checked at runtime by calculating the hash value of the block as it is read and comparing it to the recorded value in the hash tree. If the values do not match, the read operation results in an I/O error indicating that the filesystem is corrupted. Because all checks are performed by the kernel, the boot process needs to verify the integrity of the kernel in order for verified boot to work. This process is device-specific and is typically implemented by using an unchangeable, hardware-specific key that is “burned” (written to write-only memory) into the device. That key is used to verify the integrity of each bootloader level and eventually the kernel. (We discuss verified boot in <a class="xref" href="ch10.html" title="Chapter 10. Device Security">Chapter 10</a>.)</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00002"/>Summary</h1></div></div></div><p>Android is a privilege-separated operating system based on the Linux kernel. Higher-level system functions are implemented as a set of cooperating system services that communicate using an IPC mechanism called Binder. Android isolates applications from each other by running each with a distinct system identity (Linux UID). By default, applications are given very few privileges and have to request fine-grained permission in order to interact with system services, hardware devices, or other applications. Permissions are defined in each application’s manifest file and are granted at install time. The system uses the UID of each application to find out what permissions it has been granted and to enforce them at runtime. In recent versions, system processes isolation takes advantage of SELinux to further constrain the privileges given to each process.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch01fn01" href="#ch01fn01" class="para">1</a>] </sup><span class="emphasis"><em>Android Mainlining Project</em></span>, <span class="emphasis"><em><a class="ulink" href="http://elinux.org/Android_Mainlining_Project">http://elinux.org/Android_Mainlining_Project</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch01fn02" href="#ch01fn02" class="para">2</a>] </sup>For a more detailed discussion of Androidisms, see Karim Yaghmour’s <span class="emphasis"><em>Embedded Android</em></span>, O’Reilly, 2013, pp. 29–38.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch01fn03" href="#ch01fn03" class="para">3</a>] </sup>Yunhe Shi et al.<span class="emphasis"><em>, Virtual Machine Showdown: Stack Versus Registers</em></span>, <span class="emphasis"><em><a class="ulink" href="https://www.usenix.org/legacy/events/vee05/full_papers/p153-yunhe.pdf">https://www.usenix.org/legacy/events/vee05/full_papers/p153-yunhe.pdf</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch01fn04" href="#ch01fn04" class="para">4</a>] </sup>The Apache Software Foundation, <span class="emphasis"><em>Apache Harmony</em></span>, <span class="emphasis"><em><a class="ulink" href="http://harmony.apache.org/">http://harmony.apache.org/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch01fn05" href="#ch01fn05" class="para">5</a>] </sup>Oracle, <span class="emphasis"><em>Java™ Native Interface</em></span>, <span class="emphasis"><em><a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/">http://docs.oracle.com/javase/7/docs/technotes/guides/jni/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch01fn06" href="#ch01fn06" class="para">6</a>] </sup>PalmSource, Inc., <span class="emphasis"><em>OpenBinder</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/">http://www.angryredplanet.com/~hackbod/openbinder/docs/html/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch01fn07" href="#ch01fn07" class="para">7</a>] </sup>Google, <span class="emphasis"><em>Android APIs Reference</em></span>, “IBinder,” <span class="emphasis"><em><a class="ulink" href="http://developer.android.com/reference/android/os/IBinder.html">http://developer.android.com/reference/android/os/IBinder.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch01fn08" href="#ch01fn08" class="para">8</a>] </sup>Oracle, <span class="emphasis"><em>JAR File Specification</em></span>, <span class="emphasis"><em><a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html">http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch01fn09" href="#ch01fn09" class="para">9</a>] </sup>SELinux Project, <span class="emphasis"><em>SE for Android</em></span>, <span class="emphasis"><em><a class="ulink" href="http://selinuxproject.org/page/SEAndroid">http://selinuxproject.org/page/SEAndroid</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch01fn10" href="#ch01fn10" class="para">10</a>] </sup>Linux kernel source tree, <span class="emphasis"><em>dm-verity</em></span>, <span class="emphasis"><em><a class="ulink" href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/device-mapper/verity.txt">http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/device-mapper/verity.txt</a></em></span></p></div></div></div></body></html>