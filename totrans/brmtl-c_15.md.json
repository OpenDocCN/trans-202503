["```\n`pointer` = malloc(`number-of-bytes`);\n```", "```\n#include <stdlib.h>\n#include <stdio.h>\n\n// Singly linked list with name as payload\nstruct aList {\n     struct aList* next; // Next node on the list\n     char name[50];      // Name for this node\n};\n\nint main() {\n    struct aList* listPtr = malloc(sizeof(*listPtr));\n    if (listPtr == NULL) {\n        printf(\"ERROR: Ran out of memory\\n\");\n        exit(8);\n    }\n    return (0);\n}\n```", "```\n`pointer` = malloc(sizeof(*`pointer`));\n```", "```\nstruct aList* listPtr = malloc(sizeof(listPtr));\n```", "```\nstruct aList* listPtr = malloc(sizeof(struct aList));\n```", "```\nstruct aListImproved* listPtr = malloc(sizeof(struct aList));\n```", "```\nstruct aList* listPtr = malloc(sizeof(struct aList));\n```", "```\nstruct aListImproved* listPtr;\n// 3,000 lines of dense code\n\n// WRONG\nlistPtr = malloc(sizeof(struct aList));\n```", "```\nif (listPtr == NULL) {\n    printf(\"ERROR: Ran out of memory\\n\");\n    exit(8);\n}\n```", "```\nfree(listPtr);\nlistPtr = NULL;\n```", "```\nfree(listPtr);\nlistPtr->name[0] = '\\0'; // Wrong, but will execute and\n                         // possibly create a strange error\n                         // much later in the program\n```", "```\nfree(listPtr);\nlistPtr = NULL;\nlistPtr->name[0] = '\\0';  // Program crashes with a good\n                          // indication of where and why\n```", "```\n#define NAME_SIZE 20    // Max number of characters in a name\n/**\n * A node in the linked list\n */\nstruct linkedList {\n    struct linkedList* next;    // Next node\n    char name[NAME_SIZE];       // Name of the node\n};\n```", "```\nstatic void addName(void)\n{\n    printf(\"Enter word to add: \");\n\n    char line[NAME_SIZE];       // Input line\n\n    if (fgets(line, sizeof(line), stdin) == NULL)\n        return;\n\n    if (line[strlen(line)-1] == '\\n')\n        line[strlen(line)-1] = '\\0';\n\n    // Get a new node.\n    struct linkedList* newNode = malloc(sizeof(*newNode));\n\n    strncpy(newNode->name, line, sizeof(newNode->name)-1);\n    newNode->name[sizeof(newNode->name)-1] = '\\0';\n    newNode->next = theList;\n    theList = newNode;\n}\n```", "```\nfgets(`array`, `size`, `file`)\n```", "```\nfor (const struct linkedList* curNode = 1 theList;\n   2 curNode != NULL;\n   3 curNode = curNode->next){\n    printf(\"%s, \", curNode->name);\n}\n```", "```\nstatic void deleteWord(void)\n{\n    printf(\"Enter word to delete: \");\n\n    char line[NAME_SIZE];       // Input line\n\n    if (fgets(line, sizeof(line), stdin) == NULL)\n        return;\n\n    if (line[strlen(line)-1] == '\\n')\n        line[strlen(line)-1] = '\\0';\n\n    struct linkedList* prevNode = NULL; // Pointer to previous node\n  1 for (struct linkedList* curNode = theList;\n         curNode != NULL;\n         curNode = curNode->next) {\n       2 if (strcmp(curNode->name, line) == 0) {\n            if (prevNode == NULL) {\n              3 theList = curNode->next;\n            } else {\n              4 prevNode->next = curNode->next;\n            }\n          5 free(curNode);\n            curNode = NULL;\n            return;\n        }\n      6 prevNode = curNode;\n    }\n    printf(\"WARNING: Node not found %s\\n\", line);\n}\n```", "```\n/**\n * Demonstrate a singly linked list.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define NAME_SIZE 20    // Max number of characters in a name\n/**\n * A node in the linked list\n */\nstruct linkedList {\n    struct linkedList* next;    // Next node\n    char name[NAME_SIZE];       // Name of the node\n};\n// The linked list of words\nstatic struct linkedList* theList = NULL;\n\n/**\n * Add a name to the linked list.\n */\nstatic void addName(void)\n{\n    printf(\"Enter word to add: \");\n\n    char line[NAME_SIZE];       // Input line\n\n    if (fgets(line, sizeof(line), stdin) == NULL)\n        return;\n\n    if (line[strlen(line)-1] == '\\n')\n        line[strlen(line)-1] = '\\0';\n\n    // Get a new node.\n    struct linkedList* newNode = malloc(sizeof(*newNode));\n\n strncpy(newNode->name, line, sizeof(newNode->name)-1);\n    newNode->name[sizeof(newNode->name)-1] = '\\0';\n    newNode->next = theList;\n    theList = newNode;\n}\n\n/**\n * Delete a word from the list.\n */\nstatic void deleteWord(void)\n{\n    printf(\"Enter word to delete: \");\n\n    char line[NAME_SIZE];       // Input line\n\n    if (fgets(line, sizeof(line), stdin) == NULL)\n        return;\n\n    if (line[strlen(line)-1] == '\\n')\n        line[strlen(line)-1] = '\\0';\n\n    struct linkedList* prevNode = NULL; // Pointer to the previous node\n    for (struct linkedList* curNode = theList;\n         curNode != NULL;\n         curNode = curNode->next) {\n        if (strcmp(curNode->name, line) == 0) {\n            if (prevNode == NULL) {\n                theList = curNode->next;\n            } else {\n                prevNode->next = curNode->next;\n            }\n            free(curNode);\n            curNode = NULL;\n            return;\n        }\n        prevNode = curNode;\n    }\n    printf(\"WARNING: Node not found %s\\n\", line);\n}\n\n/**\n * Print the linked list.\n */\nstatic void printList(void)\n{\n    // Loop over each node in the list.\n    for (const struct linkedList* curNode = theList;\n         curNode != NULL;\n         curNode = curNode->next) {\n        printf(\"%s, \", curNode->name);\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n\n    while (true) {\n        printf(\"a-add, d-delete, p-print, q-quit: \");\n        char line[100]; // An input line\n        if (fgets(line, sizeof(line), stdin) == NULL)\n            break;\n\n        switch (line[0]) {\n            case 'a':\n                addName();\n                break;\n            case 'd':\n                deleteWord();\n                break;\n            case 'p':\n                printList();\n                break;\n            case 'q':\n                exit(8);\n            default:\n                printf(\n                    \"ERROR: Unknown command %c\\n\", line[0]);\n                break;\n        }\n    }\n}\n```", "```\n{\n    int* dynamicArray;    // A dynamic array\n    // Allocate 100 elements.\n    dynamicArray = malloc(sizeof(int) * 100);\n}\n```", "```\nfree(nodePtr);\nnextPtr = nodePtr->Next;   // Illegal\n```", "```\nfree(nodePtr);\nnodePtr = NULL;\nnextPtr = nodePtr->Next;   // Crashes the program\n```", "```\nint* theData;   // An array of data\n*theData = malloc(sizeof(*theData)*10);\ntheData[0] = 0;\ntheData[10] = 10; // Error\n```", "```\n/**\n * Leaks memory and uses it badly.\n * Generates warnings when compiled.\n * Generates errors when run.\n *\n * Please don't program like this.\n */\n#include <stdlib.h>\n\nstatic void leak(void)\n{\n    char* data = malloc(100);\n}\n\nint main()\n{\n    leak();\n    return (0);\n}\n```", "```\n$ **valgrind --leak-check=full ./leaker**\n`--snip--`\n==14500== 100 bytes in 1 blocks are definitely lost in loss record 1 of 1\n==14500==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==14500==    by 0x10865B: leak (leaker.c:12) 1\n==14500==    by 0x10866B: main (leaker.c:17)\n==14500==\n==14500== LEAK SUMMARY:\n==14500==    definitely lost: 100 bytes in 1 blocks\n`--snip--`\n```", "```\n$ **/leaker**\n\n=================================================================\n==14427==ERROR: LeakSanitizer: detected memory leaks\n\nDirect leak of 100 byte(s) in 1 object(s) allocated from:\n    #0 0x7f07c712cb50 in __interceptor_malloc (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xdeb50)\n    #1 0x5607aef0b7fb in leak /home/sdo/bare/xx.leaker/leaker.c:15\n    #2 0x5607aef0b80b in main /home/sdo/bare/xx.leaker/leaker.c:17\n    #3 0x7f07c6c7eb96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\n\nSUMMARY: AddressSanitizer: 100 byte(s) leaked in 1 allocation(s).\n```"]