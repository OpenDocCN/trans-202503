- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Real-Time Music Visualizer by Michael Krumpus
  prefs: []
  type: TYPE_NORMAL
- en: This project shows you how to create an awesome music visualizer using an arduino
    and an LED strip.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0095-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After building this project, you’ll be able to plug any music source into the
    circuit and the LED strip will display a cool, multicolored light show synchronized
    to your music in real time. This project is great for parties, DJ booths, or even
    your dorm room! To see the visualizer in action, have a look at this short video:
    *[https://youtu.be/GkjBT-EmRw8](https://youtu.be/GkjBT-EmRw8)*.'
  prefs: []
  type: TYPE_NORMAL
- en: First we’ll look at the theory behind making a music visualizer so you have
    some understanding of how it works before getting into the build. After the circuit
    is built, you’ll learn how the code works and how to load it into the Arduino.
    Finally, we’ll cover some tips on how to revise the code to make it behave differently
    so you can experiment on your own.
  prefs: []
  type: TYPE_NORMAL
- en: '**GET THE PARTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The parts for the Real-Time Music Visualizer are easy to find. This list suggests
    Adafruit for some of the more specialized parts and Mouser for simple passive
    components.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The length of your LED strip determines your power needs. For a 2 m strip,
    a 2 A power supply is enough. But if you use a 3 m strip, you’ll need a 5 A or
    10 A supply. Adafruit P/N 658 is a good option for 10 A.*'
  prefs: []
  type: TYPE_NORMAL
- en: Arduino Uno (Adafruit P/N 50; see “[Getting Started with the Arduino and the
    Arduino IDE](intro.xhtml#lev17)” on [page 15](intro.xhtml#page_15) for setup instructions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1, 2, or 3 m WS2812B RGB LED strip (for example, Adafruit NeoPixel P/N 1461)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5 V, 2 A power supply (Adafruit P/N 276, or P/N 658 for 10 A)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1 mm DC breadboard power jack (Adafruit P/N 368)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two breadboard audio jacks (Adafruit P/N 1699)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10 kΩ potentiometer (for example, Adafruit P/N 356)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solderless full-size breadboard (Adafruit P/N 239)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22-gauge solid hookup wire for connecting components (Adafruit P/N 1311)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three 4.7 kΩ resistors (Mouser P/N 291-4.7K-RC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 100 kΩ resistors (Mouser P/N 291-100K-RC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.2 kΩ resistor (Mouser P/N 291-2.2K-RC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 470 Ω resistor (Mouser P/N 291-470-RC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0.047 μF (47 nF) ceramic capacitor (Mouser P/N 594-K473K10X7RF5UH5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10 μF aluminum electrolytic capacitor (Mouser P/N 80-ESK106M016AC3AA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1,000 μF aluminum electrolytic capacitor (Mouser P/N 647-UVR1C102MPD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 3.5 mm audio cables (Adafruit P/N 2698)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Music player and speakers of your choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HOW IT WORKS: TURNING MUSIC INTO DATA**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To visualize your music, the visualizer must analyze the content of an audio
    signal and display something in response on the LED strip. But how do we analyze
    an audio signal with Arduino code? The secret lies in the *Fast Fourier Transform
    (FFT)* algorithm, a mathematical technique dating back to the 19th century. We
    won’t go into the math details because digital signal processing is quite complex,
    but the basic idea is that a signal that varies over time (like the voltage of
    an audio signal) can be analyzed and broken down into its frequency components.
    You’re probably already familiar with this idea if you’ve seen a spectrum analyzer
    on stereo equipment and music players on your computer, shown in [Figure 5-1](ch05.xhtml#ch05fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0097-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-1:** A typical spectrum analyzer'
  prefs: []
  type: TYPE_NORMAL
- en: The vertical bars represent frequency bands, with the bars on the left representing
    lower frequencies (bass) and those on the right representing higher frequencies
    (treble). The Arduino code in this project will sample the audio signal’s voltage
    and perform the FFT algorithm on the audio samples to determine the signal strength
    in each frequency band. Then we’ll use the levels of the low-frequency bands (the
    bass beat of the music) to create an interesting display on the LED strip.
  prefs: []
  type: TYPE_NORMAL
- en: In the visualizer circuit you’ll plug your computer, phone, tablet, or other
    music device into a 3.5 mm (1/8 inch) input jack to take the music signal. You’ll
    connect an output jack to your powered speakers, stereo amplifier, or whatever
    device you use to amplify your music and output it to speakers. In other words,
    the circuit sits between your music source and amplifier/speaker equipment so
    it can “listen” to the music and put on a show. The rest of the circuit consists
    of some simple components and an Arduino. There are some tricky aspects to dealing
    with audio signals in electronics, so this section describes a couple of the techniques
    we’ll use to make the circuit work. This section will teach you quite a bit about
    audio processing!
  prefs: []
  type: TYPE_NORMAL
- en: '**Input Bias**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An Arduino board can measure voltages on its six analog input pins, labeled
    A0 through A5 on the board. Your visualizer will connect the audio signal for
    your music to Arduino pin A0 to take a large number of sample measurements very
    quickly, then apply the FFT algorithm to the signal to transform it into data
    the Arduino can analyze.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re familiar with analog input measurement on Arduino, you know that
    a call to the `analogRead()` function, which reads data from the analog pins,
    returns a value in the range of 0–1023, which represents the measured voltage
    in the range of 0–5 V. But there is a problem when we want to measure an analog
    audio signal: audio is an *alternating current*, not direct current. That is,
    the voltage swings above ground (0 V) and then *below* ground to a negative voltage
    (see [Figure 5-2](ch05.xhtml#ch05fig2)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0098-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-2:** A simple audio signal oscillating between positive and negative
    voltages'
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino cannot measure voltages below 0 V, so we cannot connect an audio
    signal to pin A0 without potentially damaging the Arduino. How do we solve this?
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to “bias” the voltage up to a higher level so that it is not
    centered around 0 V, but around a higher voltage instead. That means when the
    voltage swings low it won’t dip under 0 V. We accomplish this with a voltage divider
    made out of two resistors of equal value. The audio signal has one resistor connecting
    it to 5 V and another connecting it to 0 V ([Figure 5-3](ch05.xhtml#ch05fig3)).
    This biases the signal up to the midpoint between 0 and 5 V, or 2.5 V.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0099-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-3:** An input bias circuit for an audio signal'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](ch05.xhtml#ch05fig4) shows the same signal, but centered around
    2.5 V instead of 0 V. Now the Arduino can measure audio voltages without worrying
    about them swinging below ground. Audio signals are usually only a few volts from
    peak to peak, so this approach works well.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0099-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-4:** An audio signal now biased up 2.5 V'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sensitivity Control**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The audio signal needs to be strong enough that the voltage swings over a large
    enough range for the visualizer to be able to effectively analyze it. But some
    audio sources don’t output a really strong signal. We need to give our circuit
    the ability to adjust the sensitivity so that we can work with weak signals. This
    section describes a clever trick to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from the previous section that the Arduino can measure voltages between
    0 V and 5 V, and that we’ve biased the audio voltage up to be centered around
    2.5 V. If the audio signal is weak and the voltage doesn’t vary much, we’d have
    a signal like that shown in [Figure 5-5](ch05.xhtml#ch05fig5). This might be the
    case in a “line-level” signal where the peak-to-peak voltage is only 1 V.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0100-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-5:** A weak audio signal'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring this signal will result in `analogRead(0)` values around 512 (the
    midpoint between 0–1023), but they won’t vary enough to give us a good analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the Arduino board has a special pin called the *analog reference
    (AREF)*. We can provide a voltage on this pin and tell the Arduino code that this
    is the highest voltage we are going to read on the analog input. For example,
    to measure voltages between 0 V and 2 V and have the `analogRead()` value use
    the full 0–1023 range, we provide 2 V on the AREF pin. A 2 V measurement will
    give the value of 1023 instead of something much lower.
  prefs: []
  type: TYPE_NORMAL
- en: In this circuit we’ll use a potentiometer to provide a voltage to the AREF pin.
    For higher sensitivity, we simply provide a lower voltage by turning the potentiometer.
  prefs: []
  type: TYPE_NORMAL
- en: Easy, right? Not so fast! Remember that the audio signal is centered around
    2.5 V. If we lower the analog reference too low, we’ll be ignoring the upper part
    of the signal because the top peaks will be “cut off.” In this case we will just
    get garbage from the FFT algorithm. The solution is that we *also* lower the top
    voltage on the input bias circuit so that the bias circuit will center the audio
    signal around the midpoint between 0 V and the voltage we provide to AREF. [Figure
    5-6](ch05.xhtml#ch05fig6) shows the situation where we have a weak audio signal
    that swings only about 1 V from peak to peak. The potentiometer in the circuit
    provides an AREF voltage of 2 V, which we also use as the top of the bias circuit.
    Now the audio signal is centered around 1 V and fills a much larger range of `analogRead()`
    values. In effect, we’ve amplified the signal! We didn’t actually increase the
    voltage of the signal; we simply reduced the range of voltages that we’re measuring
    so that the weak signal fills more of the range. Clever.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0100-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-6:** A weak audio signal with sensitivity adjusted to set top voltage
    to 2 V'
  prefs: []
  type: TYPE_NORMAL
- en: '**BUILD IT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to start building the music visualizer circuit on a breadboard. These
    instructions will show this process in multiple steps to make it easier to build
    up the circuit. You may choose to lay out your components on the breadboard differently,
    but these diagrams are intended to give you the most clarity. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: '**Add the audio jacks to the breadboard.** Connect the left and right channels
    of the input jack directly to the left and right channels of the output jack,
    respectively, as shown in [Figure 5-7](ch05.xhtml#ch05fig7). This means that the
    music flows through to output. The jack middle pins should connect to ground.
    Also connect the power rails of each side of the board with red and black wires
    as shown.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0101-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 5-7:** Audio jacks and power rail connections'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Filter out noise with an audio summing circuit.** Now connect the left and
    right channels together through a resistor on each channel to prevent crosstalk
    (interference) between them. Add a 4.7 kΩ resistor on each channel, as shown in
    [Figure 5-8](ch05.xhtml#ch05fig8). Add the 10 μF capacitor with the negative terminal
    (the shorter lead) on the left, connected to the output jack via the 4.7 kΩ resistor.
    Then add a 0.047 μF (or 47 nF) capacitor and connect one leg to the positive terminal
    of the 10 μF capacitor and the other leg to ground, as shown. These help to filter
    out noise and block DC current.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0101-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 5-8:** Audio summing circuit and filter'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Build up the input bias and analog reference circuit.** Recall that our voltage
    divider is made of two 100 kΩ resistors and will center the audio signal between
    0 V and the analog reference voltage, which we control with the 10 kΩ potentiometer.
    Insert those resistors, with one leg of the first resistor placed directly in
    the ground rail, and the other leg connected to the second 100 kΩ resistor, as
    shown in [Figure 5-9](ch05.xhtml#ch05fig9). Make sure the second resistor is inserted
    adjacent to the first, as shown. Now place a potentiometer in the breadboard and
    connect the rightmost pin to ground through a 2.2 kΩ resistor. Connect a 4.7 kΩ
    resistor to the middle pin of the potentiometer—this will eventually connect to
    the AREF pin on the Arduino—and make sure this resistor straddles the center divide
    on the breadboard. This middle pin should also connect to the second leg of the
    second 100 kΩ resistor. The final empty pin of the potentiometer connects to the
    power rail.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0102-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 5-9:** Input bias components'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Connect a power jack to power the circuit.** Connect the power jack to the
    power rails of the breadboard. Also connect the large 1,000 μF capacitor to the
    power lines as shown in [Figure 5-10](ch05.xhtml#ch05fig10). Electrolytic capacitors
    are polarized, so pay attention to the polarity: the positive lead is longer than
    the negative lead and should connect to the positive rail. There is also a white
    stripe on the negative side of the capacitor. This capacitor provides a reservoir
    of voltage in case the LED strip draws a lot of current all at once. For example,
    setting all LEDs on the strip to white at the same time would draw a lot of current
    from the circuit, but the capacitor would help smooth out any resulting voltage
    dips so the circuit doesn’t overload.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0103-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 5-10:** Power connection for the LED strip'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Connect the LED strip to your circuit.** The LED strip has three connections:
    5 V, ground, and data in (DIN). These electrical connections are not always in
    the same order on all LED strips. For example, the DIN connection is often in
    the middle, but [Figure 5-11](ch05.xhtml#ch05fig11) shows it at the top. Just
    pay close attention to the labels on your LED strip. You may need to solder wires
    to your LED strip if yours doesn’t have a connector of some kind (turn to the
    appendix for instructions on soldering). Whatever the case, connect the 5 V, ground,
    and DIN connections to the circuit as shown in [Figure 5-11](ch05.xhtml#ch05fig11),
    with the DIN pin connected to a 470 Ω resistor (the other end of the resistor
    will connect to the Arduino).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0103-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 5-11:** Connecting the LED strip'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Wire up the Arduino.** We’re almost done! The last wires connect to your
    Arduino board, as shown in [Figure 5-12](ch05.xhtml#ch05fig12). The green wire
    connects Arduino pin 6 to the 470 Ω resistor on the DIN connection. The blue wire
    connects to the Arduino AREF pin. The yellow wire is the audio signal and connects
    to Arduino analog pin A0\. The last connection you need to make is wiring the
    breadboard ground signal to an Arduino ground pin marked GND, but don’t make this
    connection just yet. If there is a program already running on your Arduino, it
    could damage parts of your circuit when you connect your circuit to the Arduino.
    So, to be safe, we’ll load the sketch for this project first and then finish connecting
    the Arduino.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0104-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 5-12:** Connecting the Arduino to the circuit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**CODE IT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This circuit won’t do anything without some awesome code on the Arduino! The
    Arduino sketch we’ll use is fairly complex and there isn’t room to print it all
    here, but this section will describe how it generally works so you can learn the
    basics. Download the sketch from the book’s resources at *[https://nostarch.com/LEDHandbook/](https://nostarch.com/LEDHandbook/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**How It Works**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Arduino program’s job is to “listen” to the music by capturing voltage samples
    in a buffer and then perform an FFT analysis on those samples to determine the
    levels of each frequency band. This gives us data similar to an ordinary spectrum
    analyzer—the signal strength of each frequency band at any particular moment.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of just displaying columns of LEDs, though, we do something much more
    interesting. Every time a new maximum or peak in a frequency band is detected,
    the code generates a pair of moving pixels that originate in the middle of the
    LED strip and move outward toward the ends. The speed of the moving pixels depends
    on the peak’s strength, and the pixels fade in brightness as they move outward.
    The colors of the peaks vary randomly. Note that we pay attention only to the
    bottom three frequency bands (out of eight bands) so that we are visualizing the
    music’s beat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for the main loop, with explanatory comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There’s a lot more to the code than this main loop, and most of the heavy lifting
    is performed in the `analyzeAudioSamples()` and `doVisualization()` functions.
    You certainly don’t have to understand how all of it works to enjoy the project,
    though. In the next section you will load the code onto your Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: '**Get the Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The full source code for the project is in the book’s resources at *[https://nostarch.com/LEDHandbook/](https://nostarch.com/LEDHandbook/)*.
    You’ll also find the library used to drive the RGB (red-green-blue) LED strip
    in the resources, which you’ll need to install into the Arduino IDE. Adafruit
    has an excellent guide on installing Arduino libraries at *[https://learn.adafruit.com/adafruit-neopixel-uberguide/arduino-library-installation](https://learn.adafruit.com/adafruit-neopixel-uberguide/arduino-library-installation)*.
    After installation, your Arduino directory for this code should have this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now open the Arduino IDE and load the RealtimeMusicVisualizer sketch. Compile
    and upload it to your Arduino. It is usually a good idea to disconnect the Arduino
    from your new circuit before powering on the Arduino. After you’ve uploaded the
    code onto the Arduino, you can make the four wire connections to your circuit
    described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '**USE IT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the music visualizer is as easy as making a few connections:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the audio input jack to your music source with a 3.5 mm audio cable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the audio output jack to your stereo receiver or some powered speakers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect your 5 V power supply to the power jack on the breadboard circuit. The
    power supply must be capable of supplying at least 2 A of current.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect power to your Arduino board, either with a USB cable or other power
    adapter. Otherwise, you can provide power to the Arduino from the 5 V breadboard
    supply by connecting a wire to the 5 V pin on the Arduino.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now turn on the music and enjoy the show! You’ll want your music player to be
    at a fairly high volume, especially if it’s a small device like a phone or tablet.
    Computers tend to output a stronger signal. If the music is not producing much
    of a visualization, increase the sensitivity of the potentiometer on the breadboard
    by turning the knob clockwise until you can clearly see the beat of the music.
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKE IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’re experienced with Arduino programming, you’ll probably want to play
    with the code and make it do different things. Here are some ideas to explore:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Change the number of LEDs.** If your LED strip has a different number of
    LEDs, you should adjust the code. For example, if you have a 3 m strip with 180
    LEDs, change the line in the file *RealtimeMusicVisualizer.ino* that defines `N_LEDS`
    to the new value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Make the pixels move in one direction.** Instead of having the moving pixels
    move from the center of the strip toward both ends, you can make them start from
    one end only. Set `SINGLE_DIRECTION` to `true` in *RealtimeMusicVisualizer.ino*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Make the code respond to more frequency bands.** The code pays attention
    only to the bottom three frequency bands. By changing the value of `CUTOFF_BAND`,
    you can listen to more bands. The current value is `2` because the bottom three
    bands are numbered 0, 1, and 2\. If you wanted to respond to the bottom five bands,
    you’d change the line to this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Change the brightness.** Is the visualizer too bright for you? Maybe you
    aren’t throwing a huge party but just adding some bling to your dorm room. You
    can turn down the brightness by reducing the value of `MAX_BRIGHTNESS`. The default
    is `255`, so try a lower value like `100`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Change the way the colors vary over time.** The visualizer displays pixels
    of two colors that change over time. For each of these two colors, the speed at
    which the color changes over time is controlled by the values `MIN_COLOR_CHANGE_COUNT`
    and `MAX_COLOR_CHANGE_COUNT`. When a new color is chosen, a value between these
    min and max values is set, indicating how many pixels will be that color until
    a new color is chosen. The default min and max values are `5` and `10`. If you
    want the chosen colors to appear for longer before they change, increase these
    values. If you want every pixel to be a new color, you can set both values to
    `1`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Write your own visualization.** If you have an idea for a whole new visualization,
    you can modify or rewrite the function `doVisualization()`. This function draws
    the moving pixels that are defined by the `peak_t` structures in the array `peaks`.
    If you study the code for a while, you will understand how it works. This project
    is based on a more complex visualizer that has many different visualizations:
    the Lumazoid board (a nootropic design product). You can get some ideas for different
    visualizations from the Lumazoid source code at *[https://github.com/nootropicdesign/lumazoid](https://github.com/nootropicdesign/lumazoid)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SUMMARY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve built the circuit and got everything working, congratulations! You
    now have a very cool way to light up your music, and hopefully you learned some
    things along the way, too. If you read all the material in this chapter about
    how music is analyzed using digital signal processing and how to deal with audio
    signal voltages using simple electronics tricks, you already know more than most
    people about the true nature of audio signals.
  prefs: []
  type: TYPE_NORMAL
