["```\n➊ /* ###\n\n   * IP: GHIDRA\n\n   *\n\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n\n   * you may not use this file except in compliance with the License.\n\n   * You may obtain a copy of the License at\n\n   * http://www.apache.org/licenses/LICENSE-2.0\n\n   * Unless required by applicable law or agreed to in writing, software\n\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n   * See the License for the specific language governing permissions and\n\n   * limitations under the License.\n\n   */\n\n➋  //Counts the number of defined strings in the current selection,\n\n   //or current program if no selection is made,\n\n   //and saves the results to a file.\n\n➌ //@category CustomerSubmission.Strings\n```", "```\n// Counts the number of defined strings that match a regex in the current\n\n// selection, or current program if no selection is made, and displays the\n\n// number of matching strings to the console.\n\n//\n\n//@author Ghidrabook\n\n//@category Ghidrabook.CH14\n\n//@keybinding\n\n//@menupath\n\n//@toolbar\n```", "```\nimport ghidra.app.script.GhidraScript;\n\nimport ghidra.program.model.listing.*;\n\nimport ghidra.program.util.ProgramSelection;\n\nimport java.io.*;\n```", "```\npublic class FindStringsByRegex extends GhidraScript➊ {\n\n   @Override\n\n   public void run() throws Exception {\n\n      String regex =\n\n         askString(\"Please enter the regex\",\n\n         Please enter the regex you're looking to match:);\n\n      Listing listing = currentProgram.getListing();\n\n      DataIterator dataIt;\n\n      if (currentSelection != null) {\n\n          dataIt = listing.getDefinedData(currentSelection, true);\n\n      }\n\n      else {\n\n         dataIt = listing.getDefinedData(true);\n\n      }\n\n      Data data;\n\n      String type;\n\n      int counter = 0;\n\n      while (dataIt.hasNext() && !monitor.isCancelled()) {\n\n         data = dataIt.next();\n\n         type = data.getDataType().getName().toLowerCase();\n\n         if (type.contains(\"unicode\") || type.contains(\"string\")) {\n\n            String s = data.getDefaultValueRepresentation();\n\n            if (s.matches(regex)) {\n\n               counter++;\n\n               println(s);\n\n            }\n\n         }\n\n      }\n\n      println(counter + \" matching strings were found\");\n\n   }\n\n}\n```", "```\nFindStringsByRegex.java> Running...\n\nFindStringsByRegex.java> \"Fatal error: glibc detected an invalid stdio handle\\n\"\n\nFindStringsByRegex.java> \"Unknown error \"\n\nFindStringsByRegex.java> \"internal error\"\n\nFindStringsByRegex.java> \"relocation error\"\n\nFindStringsByRegex.java> \"symbol lookup error\"\n\nFindStringsByRegex.java> \"Fatal error: length accounting in _dl_exception_create_format\\n\"\n\nFindStringsByRegex.java> \"Fatal error: invalid format in exception string\\n\"\n\nFindStringsByRegex.java> \"error while loading shared libraries\"\n\nFindStringsByRegex.java> \"Unknown error\"\n\nFindStringsByRegex.java> \"version lookup error\"\n\nFindStringsByRegex.java> \"sdlerror.o\"\n\nFindStringsByRegex.java> \"dl-error.o\"\n\nFindStringsByRegex.java> \"fatal_error\"\n\nFindStringsByRegex.java> \"strerror.o\"\n\nFindStringsByRegex.java> \"strerror\"\n\nFindStringsByRegex.java> \"__strerror_r\"\n\nFindStringsByRegex.java> \"_dl_signal_error\"\n\nFindStringsByRegex.java> \"__dlerror\"\n\nFindStringsByRegex.java> \"_dlerror_run\"\n\nFindStringsByRegex.java> \"_dl_catch_error\"\n\nFindStringsByRegex.java> 20 matching strings were found\n\nFindStringsByRegex.java> Finished!\n```", "```\nprotected abstract void run() throws Exception;\n```", "```\n// ch14_1_flat.java\n\nvoid run() throws Exception {\n\n  int ptrSize = currentProgram.getDefaultPointerSize();\n\n ➊ Function func = getFirstFunction();\n\n  while (func != null && !monitor.isCancelled()) {\n\n     String name = func.getName();\n\n     long addr = func.getBody().getMinAddress().getOffset();\n\n     long end = func.getBody().getMaxAddress().getOffset();\n\n  ➋ StackFrame frame = func.getStackFrame();\n\n  ➌ int locals = frame.getLocalSize();\n\n  ➍ int args = frame.getParameterSize();\n\n     printf(\"Function: %s, starts at %x, ends at %x\\n\", name, addr, end);\n\n     printf(\"  Local variable area is %d bytes\\n\", locals);\n\n     printf(\"  Arguments use %d bytes (%d args)\\n\", args, args / ptrSize);\n\n  ➎ func = getFunctionAfter(func);\n\n  }\n\n}\n```", "```\n// ch14_2_flat.java\n\npublic void run() throws Exception {\n\n   Listing plist = currentProgram.getListing();\n\n➊ Function func = getFunctionContaining(currentAddress);\n\n   if (func != null) {\n\n   ➋ InstructionIterator iter = plist.getInstructions(func.getBody(), true);\n\n      int count = 0;\n\n      while (iter.hasNext() && !monitor.isCancelled()) {\n\n         count++;\n\n         Instruction ins = iter.next();\n\n      }\n\n   ➌ popup(String.format(\"%s contains %d instructions\\n\",\n\n                          func.getName(), count));\n\n   }\n\n   else {\n\n      popup(String.format(\"No function found at location %x\",\n\n                          currentAddress.getOffset()));\n\n   }\n\n}\n```", "```\n// ch14_3_flat.java\n\nvoid run() throws Exception {\n\n   Listing plist = currentProgram.getListing();\n\n➊ Function func = getFunctionContaining(currentAddress);\n\n   if (func != null) {\n\n      String fname = func.getName();\n\n      InstructionIterator iter = plist.getInstructions(func.getBody(), true);\n\n   ➋ while (iter.hasNext() && !monitor.isCancelled()) {\n\n         Instruction ins = iter.next();\n\n         Address addr = ins.getMinAddress();\n\n         Reference refs[] = ins.getReferencesFrom();\n\n     ➌ for (int i = 0; i < refs.length; i++) {\n\n        ➍ if (refs[i].getReferenceType().isCall()) {\n\n               Address tgt = refs[i].getToAddress();\n\n               Symbol sym = getSymbolAt(tgt);\n\n               String sname = sym.getName();\n\n               long offset = addr.getOffset();\n\n               printf(\"%s calls %s at 0x%x\\n\", fname, sname, offset);\n\n            }\n\n         }\n\n      }\n\n   }\n\n}\n```", "```\nchar *strcpy(char *dest, const char *source);\n```", "```\n   // ch14_4_flat.java\n\n➊ public void list_calls(Function tgtfunc) {\n\n     String fname = tgtfunc.getName();\n\n     Address addr = tgtfunc.getEntryPoint();\n\n     Reference refs[] = getReferencesTo(addr);\n\n  ➋ for (int i = 0; i < refs.length; i++) {\n\n     ➌ if (refs[i].getReferenceType().isCall()) {\n\n           Address src = refs[i].getFromAddress();\n\n        ➍ Function func = getFunctionContaining(src);\n\n           if (func.isThunk()) {\n\n              continue;\n\n           }\n\n           String caller = func.getName();\n\n           long offset = src.getOffset();\n\n        ➎ printf(\"%s is called from 0x%x in %s\\n\", fname, offset, caller);\n\n        }\n\n      }\n\n   }\n\n➏ public void getFunctions(String name, List<Function> list) {\n\n      SymbolTable symtab = currentProgram.getSymbolTable();\n\n      SymbolIterator si = symtab.getSymbolIterator();\n\n      while (si.hasNext()) {\n\n        Symbol s = si.next();\n\n        if (s.getSymbolType() != SymbolType.FUNCTION || s.isExternal()) {\n\n          continue;\n\n       }\n\n       if (s.getName().equals(name)) {\n\n          list.add(getFunctionAt(s.getAddress()));\n\n       }\n\n    }\n\n }\n\n public void run() throws Exception {\n\n    List<Function> funcs = new ArrayList<Function>();\n\n    getFunctions(\"strcpy\", funcs);\n\n    getFunctions(\"sprintf\", funcs);\n\n    funcs.forEach((f) -> list_calls(f));\n\n }\n```", "```\n08049ede  MOV    dword ptr [EBP + local_8],0x0\n\n        LAB_08049ee5\n\n08049ee5  CMP    dword ptr [EBP + local_8],0x3c1\n\n08049eec  JA     LAB_08049f0d\n\n08049eee  MOV    EDX,dword ptr [EBP + local_8]\n\n08049ef1  ADD    EDX,DAT_0804b880\n\n08049ef7  MOV    EAX,dword ptr [EBP + local_8]\n\n08049efa  ADD    EAX,DAT_0804b880\n\n08049eff  MOV    AL,byte ptr [EAX]=>DAT_0804b880\n\n08049f01  XOR    EAX,0x4b\n\n08049f04  MOV    byte ptr [EDX],AL=>DAT_0804b880\n\n08049f06  LEA    EAX=>local_8,[EBP + -0x4]\n\n08049f09  INC    dword ptr [EAX]=>local_8\n\n08049f0b  JMP    LAB_08049ee5\n```", "```\n// ch14_5_flat.java\n\npublic void run() throws Exception {\n\n   int local_8 = 0;\n\n   while (local_8 <= 0x3C1) {\n\n      long edx = local_8;\n\n      edx = edx + 0x804B880;\n\n      long eax = local_8;\n\n      eax = eax + 0x804B880;\n\n      int al = getByte(toAddr(eax));\n\n      al = al ^ 0x4B;\n\n      setByte(toAddr(edx), (byte)al);\n\n      local_8++;\n\n   }\n\n}\n```", "```\npublic void run() throws Exception {\n\n   for (int local_8 = 0; local_8 <= 0x3C1; local_8++) {\n\n      Address addr = toAddr(0x804B880 + local_8);\n\n      setByte(addr, (byte)(getByte(addr) ^ 0x4B));\n\n   }\n\n}\n```"]