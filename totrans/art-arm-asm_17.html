<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_795" aria-label="795"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch14">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">14</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">STRING OPERATIONS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">A <i>string</i> is a collection of values stored in contiguous memory locations. Strings are usually arrays of bytes, half words, words, dwords, or quad words. Some CISC CPUs, such as the Intel x86-64, support instructions that operate directly on strings of data. However, the ARM does not provide instructions for this purpose, as string operations tend to be complex and violate RISC design guidelines. Nevertheless, it is possible to operate on string data structures by using discrete ARM instructions.</p>&#13;
<p class="TX">Although the ARM CPU does not support string-specific instructions, string operations are still an important function that CPUs must perform. This chapter discusses how to work with strings when using ARM assembly language. First off, this chapter describes how to call functions in the C stdlib to implement string operations. These functions are well written <span role="doc-pagebreak" epub:type="pagebreak" id="pg_796" aria-label="796"/>(typically in assembly language) and provide a high-performance implementation, as long as you are using zero-terminated strings. As noted throughout this book, however, zero-terminated strings are not the most suitable string data structure for high-performance string operations. Therefore, this chapter describes a better string format that allows you to write faster string functions.</p>&#13;
<p class="TX">Of course, the problem with a new string implementation is that the C stdlib functions don’t support it, so this chapter also describes how to implement various string functions that support the new string format. Finally, this chapter concludes by discussing Unicode strings and string functions.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-145"/><span class="SANS_Futura_Std_Bold_B_11">14.1 Zero-Terminated Strings and Functions</span></h3>&#13;
<p class="TNI1"><span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> briefly introduced the string data type, discussing zero-terminated strings (commonly used in C/C++ and languages derived from them), length-prefixed strings, string descriptors, and other string forms. As noted there, the zero-terminated string is the most common string form in use today. In particular, Linux (Pi OS) and macOS generally use zero-terminated strings for API functions to which you pass or receive string data. Therefore, you’ll often use zero-terminated strings in your ARM assembly language programs running under these OSes. This section describes the issues with zero-terminated strings and how to call functions in the C stdlib that support zero-terminated strings.</p>&#13;
<p class="TX">The main problem with zero-terminated strings is performance. Such strings often require scanning over every character in the string to perform simple operations such as computing the string length. For example, the following code computes the length of a string named <span class="SANS_TheSansMonoCd_W5Regular_11">longZString</span>:</p>&#13;
<pre id="pre-1119"><code>          lea   x1, longZString&#13;
          mov   x2, x1         // Save pointer to string.&#13;
whileLp:  ldrb  w0, [x1], #1   // Fetch next char and inc X1.&#13;
          cmp   w0, #0         // See if 0 byte.&#13;
          bne   whileLp        // Repeat while not 0.&#13;
          sub   x0, x1, x2     // X0 = X1 - X2&#13;
          sub   x0, x0, #1     // Adjust for extra increment.&#13;
&#13;
// String length is now in X0.</code></pre>&#13;
<p class="TX">If <span class="SANS_TheSansMonoCd_W5Regular_11">longZString</span> is indeed very long, this code sequence can take a long time to execute.</p>&#13;
<p class="TX">Length-prefixed strings (see section 4.6.2, <span class="Xref">“Length-Prefixed Strings,”</span> on <span class="Xref"><a href="chapter4.xhtml#pg_188">page 188</a></span>) solve this problem by including the string’s current length along with the data. Any string function that uses the string’s length will operate much more efficiently because it doesn’t have to first scan the entire string to determine its length. If you get to choose the string format to use in your assembly language code, choosing a data type that includes the length as part of the string’s data can dramatically improve string-processing performance.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_797" aria-label="797"/>Unfortunately, you don’t always get to choose the string format to use in your code. Sometimes external datasets, applications, or OSes force the zero-terminated string format on you (for example, OS API calls generally require zero-terminated strings).</p>&#13;
<p class="TX">It is possible to improve the performance of naive string functions such as the string-length code given earlier. In particular, the code at <span class="SANS_TheSansMonoCd_W5Regular_11">whileLp</span> processes a single byte per iteration of the loop. Because the ARM64 CPU is capable of processing 8 bytes at a time in general-purpose registers (and 16 bytes at a time in vector registers), you might wonder whether it’s possible to do better than one character per loop iteration. After all, if you can process 16 bytes per loop iteration (rather than 1), the function should run 16 times faster, right?</p>&#13;
<p class="TX">The answer is a qualified yes. The first caveat is that processing 16 bytes per iteration is more complex and will require more than three instructions in the loop body. Expecting a 16-times improvement is therefore overly optimistic; 4 to 8 times faster is probably a more reasonable expectation but still worth achieving.</p>&#13;
<p class="TX">The second caveat is that processing 16 characters at a time requires loading 16 bytes from memory on each iteration, meaning that for many strings you’ll have to read data from memory beyond the end of the string. Thus, it’s possible to read beyond the end of an MMU page in memory containing the string, which could lead to a memory protection fault (see section 3.1.7, <span class="Xref">“Memory Access and MMU Pages,”</span> on <span class="Xref"><a href="chapter3.xhtml#pg_127">page 127</a></span>). While such a situation is rare, it nevertheless represents a defect in your code that could crash your application.</p>&#13;
<p class="TX">One last issue, while not as lethal as an illegal memory access, is that loading 16 bytes of data from memory into a vector register works best if the data is aligned on a 16-byte boundary. Unfortunately, a zero-terminated string is not guaranteed to begin on such a boundary in memory.</p>&#13;
<p class="TX">If you have complete control of string placement in memory, you can arrange for strings to always begin on a 16-byte boundary. Likewise, you can always include padding at the end of the strings so you’re guaranteed to be able to read at least 15 bytes beyond the end of the string’s data, thereby avoiding the MMU page-boundary problem. Unfortunately, few programs have such tight control over their strings that they can guarantee this arrangement in memory. For example, if an OS returns a pointer to a string, it may violate alignment and padding requirements.</p>&#13;
<p class="TX">As a general rule, I recommend calling C stdlib functions if you’re going to manipulate zero-terminated (C) strings. In the past, C stdlib functions were written in C, and even with the best optimizing compilers it was easy enough for a good assembly language programmer to write faster code than the compiler produced. However, modern C stdlib string code is typically written in assembly language (by an <i>expert</i> programmer) and is often much better than any code you would write yourself. The GNU C stdlib for AARCH64, for example, has the following functions written in handcoded <span role="doc-pagebreak" epub:type="pagebreak" id="pg_798" aria-label="798"/>assembly language (see section 14.6, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter14.xhtml#pg_859">page 859</a></span> for more on these):</p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">strcpy</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">strchr</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">strchrnul</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">strcmp</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">strcpy</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">strlen</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">strncmp</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">strnlen</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">strrchr</span></p>&#13;
<p class="TX">The following is the GNU C stdlib <i>strlen.S</i> source file (slightly modified for formatting and comments):</p>&#13;
<pre id="pre-1120"><code>// strlen.S&#13;
//&#13;
// Copyright (C) 2012-2022 Free Software Foundation, Inc.&#13;
// This file is part of the GNU C Library. The GNU C&#13;
// Library is free software; you can redistribute it&#13;
// and/or modify it under the terms of the GNU Lesser&#13;
// General Public License as published by the Free&#13;
// Software Foundation; either version 2.1 of the License,&#13;
// or (at your option) any later version. The GNU C&#13;
// Library is distributed in the hope that it will be&#13;
// useful, but WITHOUT ANY WARRANTY; without even the&#13;
// implied warranty of MERCHANTABILITY or FITNESS FOR A&#13;
// PARTICULAR PURPOSE. See the GNU Lesser General Public&#13;
// License for more details. You should have received a&#13;
// copy of the GNU Lesser General Public License along&#13;
// with the GNU C Library. If not, see&#13;
// &lt;https://www.gnu.org/licenses/&gt;.&#13;
&#13;
#include &lt;sysdep.h&gt;&#13;
&#13;
// Assumptions:&#13;
//&#13;
// ARMv8-a, AArch64, Advanced SIMD&#13;
// MTE compatible&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> #define srcin       x0&#13;
#define result      x0&#13;
&#13;
#define src         x1&#13;
#define synd        x2&#13;
#define tmp         x3&#13;
#define shift       x4&#13;
&#13;
#define data        q0&#13;
#define vdata       v0&#13;
#define vhas_nul    v1&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_799" aria-label="799"/>#define vend        v2&#13;
#define dend        d2&#13;
&#13;
// Core algorithm: For each 16-byte chunk, calculate a&#13;
// 64-bit nibble mask value with 4 bits per byte. This code&#13;
// take 4 bits of every comparison byte with shift right&#13;
// and narrow by 4 instruction. Since the bits in the&#13;
// nibble mask reflect the order in which things occur in&#13;
// the original string, counting trailing 0s identifies&#13;
// exactly which byte matched.&#13;
&#13;
// On input, X0 contains a pointer to a zero-terminated string.&#13;
// On return, X0 contains the string length.&#13;
&#13;
STRLEN:&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> bic     src, srcin, 15&#13;
        ld1     {vdata.16b}, [src]&#13;
        cmeq    vhas_nul.16b, vdata.16b, 0&#13;
        lsl     shift, srcin, 2&#13;
        shrn    vend.8b, vhas_nul.8h, 4     /* 128 -&gt; 64 */&#13;
        fmov    synd, dend&#13;
        lsr     synd, synd, shift&#13;
        cbz     synd, zloop&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> rbit    synd, synd&#13;
        clz     result, synd&#13;
        lsr     result, result, 2&#13;
        ret&#13;
&#13;
        .p2align 5&#13;
zloop:&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> ldr     data, [src, 16]!&#13;
        cmeq    vhas_nul.16b, vdata.16b, 0&#13;
        umaxp   vend.16b, vhas_nul.16b, vhas_nul.16b&#13;
        fmov    synd, dend&#13;
        cbz     synd, zloop&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> shrn    vend.8b, vhas_nul.8h, 4     /* 128 -&gt; 64 */&#13;
        sub     result, src, srcin&#13;
        fmov    synd, dend&#13;
        rbit    synd, synd&#13;
        clz     tmp, synd&#13;
        add     result, result, tmp, lsr 2&#13;
        ret</code></pre>&#13;
<p class="TX">The defines <span class="CodeAnnotation" aria-label="annotation1">❶</span> give the registers meaningful names within the function. Personally, I prefer to see the register names with comments describing their contents rather than redefined registers, to make it easier to avoid reusing registers, but this is certainly an acceptable style, especially for C library code that uses the ARM ABI.</p>&#13;
<p class="TX">As noted earlier, code that operates on 16 bytes at a time (as this version of <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span> does) has to deal with two issues: aligning data on a 16-byte boundary and preventing data access beyond the end of the MMU page containing the string. This code achieves both of those requirements by <span role="doc-pagebreak" epub:type="pagebreak" id="pg_800" aria-label="800"/>using the <span class="SANS_TheSansMonoCd_W5Regular_11">bic</span> instruction <span class="CodeAnnotation" aria-label="annotation2">❷</span> to set the LO 4 bits of the string pointer to 0. Setting the LO 4 bits to 0 will align the pointer on the 16-byte boundary on or before the beginning of the string. Note that <span class="SANS_TheSansMonoCd_W5Regular_11">src</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">X1</span>) might now point at up to 15 characters before the actual start of the string (which might contain some 0 bytes; this function will deal with that issue later). Because MMU pages always begin on a 4,096-byte boundary (which are also 16-byte boundaries), adjusting the pointer to the beginning of the 16-byte boundary will never produce a memory access outside the MMU page containing the start of the string.</p>&#13;
<p class="TX">Another advantage to aligning the pointer on a 16-byte boundary is that you don’t have to worry about accidental illegal memory accesses at the end of the MMU page. Because 4,096 is divisible by 16, loading 16 bytes at a time on 16-byte boundaries will never produce a memory access that crosses a page boundary. If the zero-terminating byte is anywhere within those 16 bytes, reading data to the end of the 16-byte block is safe. Clearing the LO 4 bits of the pointer thus allows safe memory accesses within an MMU page.</p>&#13;
<p class="TX">The problem with aligning the <span class="SANS_TheSansMonoCd_W5Regular_11">src</span> pointer to a 16-byte boundary is that doing so may change the pointer to point at memory <i>before</i> the start of the string. While this won’t create MMU page fault problems, it might cause the code to incorrectly compute the string’s length. At the very least, you don’t want to count any extra bytes before the start of the string, nor do you want to terminate the string-length calculation, because 0s appear in those earlier bytes.</p>&#13;
<p class="TX">Fortunately, the code handles this in a clever way <span class="CodeAnnotation" aria-label="annotation2">❷</span>. First, the <span class="SANS_TheSansMonoCd_W5Regular_11">ld1</span> instruction starts the process by loading 16 bytes from the aligned address in <span class="SANS_TheSansMonoCd_W5Regular_11">src</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">cmeq</span> instruction then locates every 0 byte in those 16, then stores <span class="SANS_TheSansMonoCd_W5Regular_11">0xFF</span> in the corresponding bytes of V1 (<span class="SANS_TheSansMonoCd_W5Regular_11">vhas_null</span>) and 0s everywhere else.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">shrn</span> instruction shifts the compare mask bits to the right 4 bit positions. The even bytes now contain two comparison masks in the LO and HO nibbles, and the “narrowing” component of the instruction extracts those even bytes and packs them into the LO 8 bytes of V2 (for a total of 16 nibbles), which the <span class="SANS_TheSansMonoCd_W5Regular_11">fmov</span> instruction copies into X2.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> instruction (which I skipped discussing in the previous paragraph) is part of the code that deals with extra bytes appearing in the 16-byte block prior to the string. This multiplies the original address by 4; this will be an index into the nibbles held in X2, where the string will actually start (using only the LO 6 bits of the shifted value). The <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span> instruction shifts the nibble mask to the right by the number of bits held in the LO 6 bits of X4 (<span class="SANS_TheSansMonoCd_W5Regular_11">shift</span>). This removes the <span class="SANS_TheSansMonoCd_W5Regular_11">cmeq</span> nibble masks from X2 for the bytes that appear before the start of the string. These <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span> instructions allow the algorithm to ignore the (possible) extra bytes in the 16-byte block before the string.</p>&#13;
<p class="TX">The resulting value in X2 will contain <span class="SANS_TheSansMonoCd_W5Regular_11">0b1111</span> nibbles everywhere a 0 byte appears in the portion of the string held in V0 (<span class="SANS_TheSansMonoCd_W5Regular_11">vdata</span>), and <span class="SANS_TheSansMonoCd_W5Regular_11">0b0000</span> in all the other nibbles. In particular, X2 will contain 0 if there were no 0 bytes in the string in V0. If X2 contains 0 (meaning no 0 bytes), the string’s terminating 0 byte must appear later in the string; in that case, the <span class="SANS_TheSansMonoCd_W5Regular_11">cbz</span> instruction transfers control to label <span class="SANS_TheSansMonoCd_W5Regular_11">zloop</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_801" aria-label="801"/>If X2 does not contain 0, a <span class="SANS_TheSansMonoCd_W5Regular_11">0b1111</span> nibble indicates the position of a 0 byte in the string. The <span class="SANS_TheSansMonoCd_W5Regular_11">rbit</span> (reverse bits) instruction <span class="CodeAnnotation" aria-label="annotation3">❸</span> reverses all the bits in X2, and the <span class="SANS_TheSansMonoCd_W5Regular_11">clz</span> instruction counts the number of leading 0s. Because each byte in the string is marked by 4 bits in X2, the count in X0 (result) is four times the length of the string. The <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span> instruction shifts this count right by 2, which divides the bit count by 4, producing the string length.</p>&#13;
<p class="TX">The function then returns this length to the caller in X0. This code handles the case where the string appears in the first block of bytes loaded into V0 (<span class="SANS_TheSansMonoCd_W5Regular_11">vdata</span>). If the string is sufficiently long that the code must fetch another block of 16 bytes from memory, the function transfers control to the code <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The code at <span class="SANS_TheSansMonoCd_W5Regular_11">zloop</span> is responsible for processing blocks of 16 characters, where the first byte read from memory is part of the string (unlike the previous code, where the first 1–15 bytes might not be part of the string). This loop rapidly scans through blocks of 16 bytes, looking for the first one that contains a 0. As this loop takes five instructions to process 16 bytes (versus three instructions to process a single byte in the original string-length example), you would expect it to run approximately eight times faster than the single-byte-at-a-time code.</p>&#13;
<p class="TX">Once the loop finds a 0 byte somewhere in a block of 16 bytes <span class="CodeAnnotation" aria-label="annotation5">❺</span>, it determines the position of the 0 byte (using the same technique as earlier <span class="CodeAnnotation" aria-label="annotation2">❷</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>), adds the distance from the start of the string to the current 16-byte block, then adds the number of nonzero bytes in the current 16-byte block.</p>&#13;
<p class="TX">Although this code is tricky and complex, computing the length of a zero-terminated string is a common operation, so it’s worth the optimization work. You would be hard-pressed to improve on this algorithm when writing your own code.</p>&#13;
<p class="TX">Again, because the <i>glibc</i> (GNU Library for C) authors have spent considerable time optimizing their ARM string functions, I highly recommend calling the C stdlib functions if they are appropriate for your application.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-146"/><span class="SANS_Futura_Std_Bold_B_11">14.2 A String Format for Assembly Language Programmers</span></h3>&#13;
<p class="TNI1">As mentioned many times in this book, the zero-terminated string is not the best string data type to use if you want to write the highest-performing code. Choosing a string format that incorporates the length, and possibly other information, as well as providing data alignment for the string data, can improve performance in many cases. This section introduces a sample format that provides these improvements.</p>&#13;
<p class="TX">The string format discussed in this section is based on the HLA string format (see section 4.6.2, <span class="Xref">“Length-Prefixed Strings,”</span> on <span class="Xref"><a href="chapter4.xhtml#pg_188">page 188</a>)</span>. HLA strings consist of two 32-bit length values followed by the character data and a zero-terminating byte. A string “variable” is just a pointer object that points to the first character of the string (or to a zero-terminating byte, if the string is empty).</p>&#13;
<p class="TX">The current length of the string (character count, not including the zero-terminating byte) appears at address <span class="SANS_TheSansMonoCd_W5Regular_11">ptr-4</span>, and a maximum allocated <span role="doc-pagebreak" epub:type="pagebreak" id="pg_802" aria-label="802"/>space (for characters) value appears at address <span class="SANS_TheSansMonoCd_W5Regular_11">ptr-8</span> (where <span class="SANS_TheSansMonoCd_W5Regular_11">ptr</span> is the pointer to the character data). Both length values are unsigned 32-bit values, supporting strings up to 4GB in length. For HLA, string objects are always aligned on a 4-byte boundary and the storage allocated for the string (and 0 byte) is always a multiple of 4 bytes.</p>&#13;
<p class="TX">For strings on a 64-bit CPU, a few changes are appropriate. First, the 4-byte maximum length and current length fields can remain. You probably don’t need strings that can hold more than four billion characters. The alignment should be on a 16-byte boundary, allowing the use of Neon vector registers to efficiently process 16 bytes at a time from memory. Finally, storage allocated for strings should always be a multiple of 16 bytes (to prevent problems when reading bytes beyond the end of the string). Here’s a first pass at a structure that defines this string type:</p>&#13;
<pre id="pre-1121"><code>struct  string, -8&#13;
word    string.maxlen&#13;
word    string.len&#13;
byte    string.chars  // Note: up to 4GB chars&#13;
ends    string</code></pre>&#13;
<p class="TX">With this struct declaration and a pointer to a string object in X0, you can access the fields of the string as follows:</p>&#13;
<pre id="pre-1122"><code>ldr  w1, [x0, #string.maxlen]  // Fetch the maxlen field.&#13;
ldr  w2, [x0, #string.len]     // Fetch the current length.</code></pre>&#13;
<p class="TX">Note that X0 points directly at the first character of the string (if it isn’t empty), so you can reference the character data by using <span class="SANS_TheSansMonoCd_W5Regular_11">[x0]</span> directly (you don’t need to use the <span class="SANS_TheSansMonoCd_W5Regular_11">string.chars</span> field name, which turns out to be 0, anyway).</p>&#13;
<p class="TX">If you would actually like to allocate storage for string data, or initialize some string storage with character data, the following two macros are useful (as a first approximation, with a minor modification to appear in the next section):</p>&#13;
<pre id="pre-1123"><code>            .macro  str.buf strName, maxSize&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .word   \maxSize&#13;
            .word   0&#13;
\strName:   .space  ((\maxSize+16) &amp; 0xFFFFFFF0), 0&#13;
            .endm&#13;
&#13;
            .macro  str.literal strName, strChars&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .word   len_\strName    // string.maxlen&#13;
            .word   len_\strName    // string.len&#13;
&#13;
            // Emit the string data and compute the&#13;
            // string's length:&#13;
&#13;
\strName:   .ascii  "\strChars"&#13;
len_\strName=       .-\strName&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_803" aria-label="803"/>            .byte   0   // Zero-terminating byte&#13;
&#13;
            // Ensure object is multiple of 16 bytes:&#13;
&#13;
            .align  4&#13;
            .endm</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">str.buf</span> macro will allocate storage for a string that can hold a maximum of <span class="SANS_TheSansMonoCd_W5Regular_11">maxSize</span> characters (plus a zero-terminating byte). The <span class="SANS_TheSansMonoCd_W5Regular_11">.align</span> directive ensures that the object begins on a 16-byte boundary (2<sup>4</sup>). It initializes the first word of the structure (<span class="SANS_TheSansMonoCd_W5Regular_11">string.maxlen</span>) with <span class="SANS_TheSansMonoCd_W5Regular_11">maxSize</span> passed as the argument. It creates an empty string by initializing the second 4 bytes (the <span class="SANS_TheSansMonoCd_W5Regular_11">string.len</span> field) with 0. Finally, it allocates sufficient storage for <span class="SANS_TheSansMonoCd_W5Regular_11">maxSize + 1</span> characters (for the string data and a zero-terminating byte, initializing them to zeros) and additional storage to ensure that the whole data structure (including the <span class="SANS_TheSansMonoCd_W5Regular_11">string.maxlen</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">string.len</span> fields) consumes a multiple of 16 bytes.</p>&#13;
<p class="TX">Here’s an example use of the <span class="SANS_TheSansMonoCd_W5Regular_11">str.buf</span> macro:</p>&#13;
<pre id="pre-1124"><code>str.buf  myString, 100  // Maximum of 100 chars in string</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">str.literal</span> macro also creates string buffers, but instead of initializing it with the empty string, you can specify a string literal in the macro:</p>&#13;
<pre id="pre-1125"><code>str.literal hwStr, "Hello, World!\n"</code></pre>&#13;
<p class="TX">Note that <span class="SANS_TheSansMonoCd_W5Regular_11">str.literal</span> will initialize both the <span class="SANS_TheSansMonoCd_W5Regular_11">string.maxlen</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">string.len</span> fields with the actual size of the string literal you supply.</p>&#13;
<p class="TX">This string data type has one small issue. Although the entire structure is aligned on a 16-byte boundary—and the whole structure is a multiple of 16 bytes long, at least when you create the buffers with the <span class="SANS_TheSansMonoCd_W5Regular_11">str.buf</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str.literal</span> macros—the first character of string data is actually at an address that is not a multiple of 16 (though it is a multiple of 8). To process string data 16 bytes at a time, you must either make a special case of the first 8 bytes or add another 8 bytes to the beginning of the structure (some additional fields or just 8 padding bytes). In the next section, you’ll see a modification of these two macros that adds an extra field for this purpose.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-252"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.2.1 Dynamic String Allocation</span></h4>&#13;
<p class="TNI1">As long as you use only the <span class="SANS_TheSansMonoCd_W5Regular_11">str.buf</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str.literal</span> macros to allocate storage for string variables, you don’t have to worry about alignment and MMU page issues; your string data structures will always be allocated on a 16-byte boundary (because of the <span class="SANS_TheSansMonoCd_W5Regular_11">.align 4</span> statement) and will always be a multiple of 16 bytes long. However, if you want to dynamically allocate storage for your strings (using the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> function, for example), you must deal with data alignment and padding issues yourself.</p>&#13;
<p class="TX">The C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> function makes no promises about the storage it allocates, other than it will return a pointer to <i>at least</i> the amount of storage you’ve requested if the function succeeds. In particular, the C stdlib doesn’t <span role="doc-pagebreak" epub:type="pagebreak" id="pg_804" aria-label="804"/>make any guarantees about the alignment of the storage you’ve requested. Also, <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> may allocate a few bytes more than you’ve requested, but you can never count on this. If you want your storage to be allocated on a certain byte boundary (such as a 16-byte boundary), you’ll have to handle this yourself.</p>&#13;
<aside class="box" aria-label="box-33">&#13;
<p class="BH" id="box-33"><span class="SANS_Dogma_OT_Bold_B_11">MALLOC() AND MEMORY ALIGNMENT</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">Although the C stdlib doesn’t address data alignment of the storage you’ve requested, I’ve run some experiments on macOS and Linux (64-bit), and it appears that both OSes always allocate storage on 16-byte boundaries. I tested this by calling</span> <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> <span class="SANS_Futura_Std_Book_11">256 times, allocating 1, 2, 3, ..., 256 bytes of storage. I logically OR’d all the resulting pointers together. The result had 0s in the LO 4 bits (meaning all return pointers were 16-byte aligned). It’s therefore probably justified to assume that all calls to</span> <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> <span class="SANS_Futura_Std_Book_11">on these machines return a 16-byte-aligned block memory.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">That being said, there is no guarantee that this will be true for every version of</span> <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> <span class="SANS_Futura_Std_Book_11">you might call. If you want to live dangerously, you can assume 16-byte alignment on the returned blocks, but I’d recommend you always check the return value to verify this.</span></p>&#13;
</aside>&#13;
<p class="TX">If you can’t guarantee that <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> returns a properly aligned block, you can create a <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span> function that does this for you:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  On entry, add 16 to the requested storage size to make room for any needed padding bytes.</p>&#13;
<p class="ListNumber">  2.  Call the <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> function with the new allocation size.</p>&#13;
<p class="ListNumber">  3.  Save the pointer that <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> returns (you will need it to free the storage later).</p>&#13;
<p class="ListNumber">  4.  Add 15 to the pointer and clear the LO 4 bits of the sum; then add 16 so the pointer contains the address of the first character position in the string.</p>&#13;
<p class="ListNumber">  5.  Set the <span class="SANS_TheSansMonoCd_W5Regular_11">maxlen</span> field as appropriate.</p>&#13;
<p class="ListNumber">  6.  Initialize the <span class="SANS_TheSansMonoCd_W5Regular_11">len</span> field to 0.</p>&#13;
<p class="ListNumber">  7.  Store a zero-terminating byte at the first character position (to create an empty string).</p>&#13;
<p class="ListNumber">  8.  Return the pointer to the first character position as the <span class="SANS_TheSansMonoCd_W5Regular_11">str.malloc</span> result.</p>&#13;
</div>&#13;
<p class="TX">A function that deallocates the string storage is much simpler: all you need to do is fetch the allocated pointer (saved during the <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span> call), then call the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> function to free the storage. From where do you retrieve the allocated pointer value? The best place to keep it is within the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_805" aria-label="805"/>string object data structure itself, as accomplished in the following modification of the <span class="SANS_TheSansMonoCd_W5Regular_11">string</span> structure:</p>&#13;
<pre id="pre-1126"><code>struct  string, -16&#13;
dword   string.allocPtr // At offset -16&#13;
word    string.maxlen   // At offset -8&#13;
word    string.len      // At offset -4&#13;
byte    string.chars    // At offset 0&#13;
&#13;
// Note: characters in string occupy offsets&#13;
// 0 ... in this structure.&#13;
&#13;
ends    string</code></pre>&#13;
<p class="TX">The header fields now consume 16 bytes, so the <span class="SANS_TheSansMonoCd_W5Regular_11">string.chars</span> field will start on a 16-byte aligned boundary (assuming the whole structure is on a 16-byte boundary).</p>&#13;
<p class="TX">Before providing the code to implement <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span>, I’ll introduce one other useful string constructor function that <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span> will use: <span class="SANS_TheSansMonoCd_W5Regular_11">str.bufInit</span>. Its purpose is similar to the <span class="SANS_TheSansMonoCd_W5Regular_11">str.buf</span> macro insofar as it initializes a memory buffer to hold a string object, but while you use <span class="SANS_TheSansMonoCd_W5Regular_11">str.buf</span> to declare a static object in memory during assembly, <span class="SANS_TheSansMonoCd_W5Regular_11">str.bufInit</span> allows you to initialize a block of memory at runtime. The <span class="SANS_TheSansMonoCd_W5Regular_11">str.bufInit</span> function does the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Adjusts the pointer passed to it so that the address held in the pointer is 16-byte aligned (adding 0 to 15 to the pointer’s value if it is not already 16-byte aligned).</li>&#13;
<li class="BL">Initializes the <span class="SANS_TheSansMonoCd_W5Regular_11">string.allocPtr</span> field to 0 (<span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>) to differentiate the buffer from one created by <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span>.</li>&#13;
<li class="BL">Computes the <span class="SANS_TheSansMonoCd_W5Regular_11">string.maxlen</span> field value based on the buffer size passed to the function, subtracting any padding bytes needed to achieve 16-byte alignment, as well as the 16 bytes required by the header field and any additional bytes needed to ensure that the whole structure is a multiple of 16 bytes long.</li>&#13;
<li class="BL">Initializes the <span class="SANS_TheSansMonoCd_W5Regular_11">string.len</span> field to 0 and stores a zero-terminating byte at the beginning of the character buffer area.</li>&#13;
</ul>&#13;
<p class="TX">Before presenting the implementation of these string functions, a quick sidetrack is necessary to present the <span class="SANS_TheSansMonoCd_W5Regular_11">volatile_save</span> structure the code will use to preserve registers. This structure appears in the <i>aoaa.inc</i> header file and takes the following form:</p>&#13;
<pre id="pre-1127"><code>// Structure to hold the volatile registers saved by functions&#13;
// that call C stdlib funcs&#13;
//&#13;
// Note: size of this structure must be a multiple of 16 bytes!&#13;
&#13;
            struct  volatile_save&#13;
            qword   volatile_save.x0x1&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_806" aria-label="806"/>            qword   volatile_save.x2x3&#13;
            qword   volatile_save.x4x5&#13;
            qword   volatile_save.x6x7&#13;
            qword   volatile_save.x8x9&#13;
            qword   volatile_save.x10x11&#13;
            qword   volatile_save.x12x13&#13;
            qword   volatile_save.x14x15&#13;
            qword   volatile_save.v0&#13;
            qword   volatile_save.v1&#13;
            qword   volatile_save.v2&#13;
            qword   volatile_save.v3&#13;
            qword   volatile_save.v4&#13;
            qword   volatile_save.v5&#13;
            qword   volatile_save.v6&#13;
            qword   volatile_save.v7&#13;
            qword   volatile_save.v8&#13;
            qword   volatile_save.v9&#13;
            qword   volatile_save.v10&#13;
            qword   volatile_save.v11&#13;
            qword   volatile_save.v12&#13;
            qword   volatile_save.v13&#13;
            qword   volatile_save.v14&#13;
            qword   volatile_save.v15&#13;
            ends    volatile_save</code></pre>&#13;
<p class="TX">Listing 14-1 contains the <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span> functions, as well as updates to the <span class="SANS_TheSansMonoCd_W5Regular_11">str.buf</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str.literal</span> macros (to handle the <span class="SANS_TheSansMonoCd_W5Regular_11">string.allocPtr</span> field). The listing uses the <span class="SANS_TheSansMonoCd_W5Regular_11">string</span> structure (I gave earlier in this section) that includes the <span class="SANS_TheSansMonoCd_W5Regular_11">string.allocPtr</span> field. For strings whose storage is allocated dynamically, this field will contain the allocation pointer that <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span> will use when deallocating the string’s storage. For string objects that were not created on the heap, this field will contain <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> (0). This structure is the first major piece of code appearing in the listing.</p>&#13;
<pre id="pre-1128"><code>// Listing14-1.S&#13;
//&#13;
// String initialization, allocation, and deallocation functions and macros&#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
// Assembly language string data structure:&#13;
&#13;
            struct  string, -16&#13;
            dword   string.allocPtr // At offset -16&#13;
            word    string.maxlen   // At offset -8&#13;
            word    string.len      // At offset -4&#13;
            byte    string.chars    // At offset 0&#13;
&#13;
            // Note: characters in string occupy offsets&#13;
            // 0 ... in this structure.&#13;
&#13;
            ends    string</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_807" aria-label="807"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">str.buf</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str.literal</span> macros contain minor modifications (to the macros with the same name given earlier in this chapter) that include storage for the <span class="SANS_TheSansMonoCd_W5Regular_11">allocPtr</span> field:</p>&#13;
<pre id="pre-1129"><code>// Listing14-1.S (cont.)&#13;
//&#13;
// str.buf&#13;
//&#13;
// Allocate storage for an empty string&#13;
// with the specified maximum size:&#13;
&#13;
            .macro  str.buf strName, maxSize&#13;
            .align  4         // Align on 16-byte boundary.&#13;
            .dword  0         // NULL ptr for allocation ptr&#13;
            .word   \maxSize  // Maximum string size&#13;
            .word   0         // Current string length&#13;
\strName:   .space  ((\maxSize+16) &amp; 0xFFFFFFF0), 0&#13;
            .endm&#13;
&#13;
// str.literal&#13;
//&#13;
// Allocate storage for a string buffer and initialize&#13;
// it with a string literal:&#13;
&#13;
            .macro  str.literal strName, strChars&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .dword  0   // NULL ptr for allocation ptr&#13;
            .word   len_\strName    // string.maxlen&#13;
            .word   len_\strName    // string.len&#13;
&#13;
            // Emit the string data and compute the&#13;
            // string's length:&#13;
&#13;
\strName:   .ascii  "\strChars"&#13;
len_\strName=       .-\strName&#13;
            .byte   0   // Zero-terminating byte&#13;
&#13;
            // Ensure object is multiple of 16 bytes:&#13;
&#13;
            .align  4&#13;
            .endm</code></pre>&#13;
<p class="TX">Note that both of these macros will initialize this field to <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> (0).</p>&#13;
<p class="TX">The next section of the listing is the code section, beginning with the usual <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle</span> function:</p>&#13;
<pre id="pre-1130"><code>// Listing14-1.S (cont.)&#13;
&#13;
            .code&#13;
            .global malloc&#13;
            .global free&#13;
&#13;
ttlStr:     wastr  "Listing14-1"&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_808" aria-label="808"/>// Standard getTitle function&#13;
// Returns pointer to program name in X0&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle</code></pre>&#13;
<p class="TX">Next, the <span class="SANS_TheSansMonoCd_W5Regular_11">str.bufInit</span> function initializes a memory buffer for use as a string variable:</p>&#13;
<pre id="pre-1131"><code>// Listing14-1.S (cont.)&#13;
//&#13;
// str.bufInit&#13;
//&#13;
// Initializes a raw memory buffer for use as an assembly&#13;
// language string object&#13;
//&#13;
// On entry:&#13;
//&#13;
//  X0- Pointer to the first byte of a buffer&#13;
//  W1- Buffer length&#13;
//&#13;
// On return:&#13;
//&#13;
//  X0- Pointer to string variable object&#13;
//  X1- Maximum string length&#13;
//&#13;
//  Carry flag clear if success, set if error&#13;
&#13;
            proc    str.bufInit&#13;
&#13;
            locals  str_bufInit_l&#13;
            dword   str_bufInit_l.saveX2&#13;
            byte    str_bufInit_l.stkSpace, 64&#13;
            endl    str_bufInit_l&#13;
&#13;
            enter   str_bufInit_l.size&#13;
            str     x2, [fp, #str_bufInit_l.saveX2]&#13;
&#13;
            // Clear HO 32 bits of X1:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> and     x1, x1, #0xFFFFFFFF&#13;
&#13;
            // Ensure that the pointer is aligned&#13;
            // on a 16-byte boundary:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> add     x2, x0, #15&#13;
            bic     x2, x2, #0xf&#13;
&#13;
            // Point X2 at the start of the&#13;
            // character data:&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_809" aria-label="809"/>          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> add     x2, x2, #string.chars-string.allocPtr&#13;
&#13;
            // Compute the new maxlen value:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> sub     x0, x2, x0&#13;
            subs    x1, x1, x0&#13;
            bmi     str.bufInit.bad&#13;
&#13;
            // Force maxlen to be a multiple of 16:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> bic     x1, x1, #0xf&#13;
&#13;
            // Error if maxlen is 0:&#13;
&#13;
            cbz     x1, str.bufInit.bad&#13;
&#13;
            // Initialize the string struct fields:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> str     xzr, [x2, #string.allocPtr] // NULL&#13;
            str     w1,  [x2, #string.maxlen]&#13;
            str     wzr, [x2, #string.len]      // Empty str&#13;
            strb    wzr, [x2, #string.chars]    // 0 byte&#13;
&#13;
            mov     x0, x2      // Return str ptr in X0.&#13;
&#13;
            ldr     x2, [fp, #str_bufInit_l.saveX2]&#13;
            adds    xzr, xzr, xzr     // Clear the carry flag.&#13;
            leave&#13;
&#13;
// Error return (sets the carry flag):&#13;
&#13;
str.bufInit.bad:&#13;
            ldr     x2, [fp, #str_bufInit_l.saveX2]&#13;
            cmp     x2, #0  // Set the carry flag.&#13;
            leave&#13;
            endp    str.bufInit</code></pre>&#13;
<p class="TX">This function expects a pointer to the buffer in X0 along with the buffer length in W1. It initializes the fields of the string object and returns a pointer to the string object in X0. The code begins by clearing the HO 32 bits of X1, so the code can work with 64-bit values <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It then adjusts the pointer passed in X0 to make it 16-byte aligned, by adding 16 and clearing the LO 4 bits of the sum <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This adjusts X0 to point at the next higher 16-byte aligned address if it wasn’t already so aligned.</p>&#13;
<p class="TX">Next, the code adjusts the pointer to contain the address of the first byte of character data in the string (so that the other fields have negative offsets from the pointer) <span class="CodeAnnotation" aria-label="annotation3">❸</span>. It then computes the new <span class="SANS_TheSansMonoCd_W5Regular_11">maxlen</span> value by subtracting out the padding bytes (for 16-byte alignment) and the size of the fields preceding the character data <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The function returns an error if this difference is a negative value.</p>&#13;
<p class="TX">The code ensures that the length of the character data is a multiple of 16 bytes (possibly further reducing the <span class="SANS_TheSansMonoCd_W5Regular_11">maxlen</span> size) by clearing the LO 4 bits <span role="doc-pagebreak" epub:type="pagebreak" id="pg_810" aria-label="810"/>of the length value <span class="CodeAnnotation" aria-label="annotation5">❺</span>. The function returns an error if the <span class="SANS_TheSansMonoCd_W5Regular_11">maxlen</span> value turns out to be 0.</p>&#13;
<p class="TX">Finally, the code initializes the fields of the string object (producing an empty string) <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Note that</p>&#13;
<pre id="pre-1132"><code>adds    xzr, xzr, xzr</code></pre>&#13;
<p class="Continued1">clears the carry flag (successful return) because adding 0 to anything never produces an unsigned overflow (carry). Also note that</p>&#13;
<pre id="pre-1133"><code>cmp     x2, #0</code></pre>&#13;
<p class="Continued1">always sets the carry flag because the carry will be set after a comparison if the left value is greater than or equal to (higher than or the same as) the right value. Of course, for unsigned values, any value will always be greater than or equal to 0.</p>&#13;
<p class="TX">Two functions in Listing 14-1, <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span>, will call the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> functions. The <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span> functions preserve all registers they modify that don’t contain explicit return values. However, because the <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> functions follow the ARM ABI, they are allowed to overwrite values in the volatile register set. To preserve the register values, the <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span> functions must preserve the volatile registers by using the <span class="SANS_TheSansMonoCd_W5Regular_11">volatile_save</span> structure.</p>&#13;
<p class="TX">Up next is the <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span> function:</p>&#13;
<pre id="pre-1134"><code>// Listing14-1.S (cont.)&#13;
//&#13;
// str.alloc&#13;
//&#13;
// Allocates storage for an assembly language string&#13;
// object on the heap (C stdlib malloc heap)&#13;
//&#13;
// On entry:&#13;
//&#13;
//  W0- Maximum string length for string object&#13;
//&#13;
// On exit:&#13;
//&#13;
//  X0- Pointer to string object (NULL if error)&#13;
//&#13;
//  Carry clear if successful, set if error&#13;
&#13;
            proc    str.alloc&#13;
&#13;
            locals  str_alloc&#13;
            dword   str_alloc.maxlen    // Really only a word&#13;
            dword   str_alloc.saveX1&#13;
            salign  4   // 16-byte align vsave&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> byte    str_alloc.vsave, volatile_save.size&#13;
            byte    str_alloc.stkSpace, 64&#13;
            endl    str_alloc&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_811" aria-label="811"/>            enter   str_alloc.size&#13;
&#13;
            // Preserve X1 and point it at the&#13;
            // volatile_save.x0x1 entry in str_alloc.vsave:&#13;
&#13;
            str     x1, [fp, #str_alloc.saveX1]&#13;
&#13;
            // Load X1 with the effective address of&#13;
            // str_alloc.vsave (which will be the&#13;
            // volatile_save.x0x1 element):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> add     x1, fp, #str_alloc.vsave&#13;
&#13;
            // Preserve all the volatile registers (call to&#13;
            // malloc may change these). Note that X1 is&#13;
            // currently pointing at volatile_save.x0x1 in&#13;
            // str_alloc.vsave (volatile_save). You don't know&#13;
            // that you *have* to save all the registers (it's&#13;
            // unlikely malloc will modify them all), but just&#13;
            // to be safe ...&#13;
&#13;
            // The following code stores away X2, ..., X15 and&#13;
            // V0..V15 in successive memory locations in the&#13;
            // volatile_save structure. X1 was already preserved,&#13;
            // and it returns the result in X0.&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> stp     x2,  x3,  [x1, #16]!&#13;
            stp     x4,  x5,  [x1, #16]!&#13;
            stp     x6,  x7,  [x1, #16]!&#13;
            stp     x8,  x9,  [x1, #16]!&#13;
            stp     x10, x11, [x1, #16]!&#13;
            stp     x12, x13, [x1, #16]!&#13;
            stp     x14, x15, [x1, #16]!&#13;
&#13;
            str     q0,  [x1, #16]!&#13;
            str     q1,  [x1, #16]!&#13;
            str     q2,  [x1, #16]!&#13;
            str     q3,  [x1, #16]!&#13;
            str     q4,  [x1, #16]!&#13;
            str     q5,  [x1, #16]!&#13;
            str     q6,  [x1, #16]!&#13;
            str     q7,  [x1, #16]!&#13;
            str     q8,  [x1, #16]!&#13;
            str     q9,  [x1, #16]!&#13;
            str     q10, [x1, #16]!&#13;
            str     q11, [x1, #16]!&#13;
            str     q12, [x1, #16]!&#13;
            str     q13, [x1, #16]!&#13;
            str     q14, [x1, #16]!&#13;
            str     q15, [x1, #16]!&#13;
&#13;
            // Save maxlen value for now:&#13;
&#13;
            str     w0, [fp, #str_alloc.maxlen]&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_812" aria-label="812"/>            // Force maxlen to be a multiple of 16 and&#13;
            // add in 16 extra bytes so you can ensure&#13;
            // that the storage is 16-byte aligned.&#13;
            // Also add in the size of the string.struct&#13;
            // fields:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> add     x0, x0, #31 + (string.chars-string.allocPtr)&#13;
            and     x0, x0, #0xffffffff // Fix at 32 bits.&#13;
            bic     x0, x0, #0xf        // Force to multiple of 16.&#13;
&#13;
            // Call C stdlib malloc function to allocate the&#13;
            // storage:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> bl      malloc&#13;
            cmp     x0, x0              // Set carry flag on error.&#13;
            cbz     x0, str.alloc.bad   // Error if NULL return.&#13;
&#13;
            mov     x1, x0              // Save allocation pointer.&#13;
&#13;
            // Adjust pointer to point at start of characters&#13;
            // in string struct and 16-byte align the pointer:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> add     x0, x0, #15+(string.chars-string.allocPtr)&#13;
            bic     x0, x0, #0xf&#13;
&#13;
            // Initialize the string struct fields:&#13;
&#13;
            str     x1,  [x0, #string.allocPtr] // Save alloc ptr.&#13;
            ldr     w2,  [fp, #str_alloc.maxlen]&#13;
            str     w2,  [x0, #string.maxlen]   // Save maxlen.&#13;
            str     wzr, [x0, #string.len]      // Empty string.&#13;
            strb    wzr, [x0, #string.chars]    // Zero terminator&#13;
&#13;
            // Restore all the volatile general-&#13;
            // purpose registers:&#13;
&#13;
            adds    xzr, xzr, xzr   // Clear carry for success.&#13;
&#13;
str.alloc.bad:&#13;
&#13;
            // Restore all the volatile registers.&#13;
            // From this point forward, the code must&#13;
            // not change the carry flag.&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> add     x1, fp, #str_alloc.vsave&#13;
            ldp     x2,  x3,  [x1, #16]!&#13;
            ldp     x4,  x5,  [x1, #16]!&#13;
            ldp     x6,  x7,  [x1, #16]!&#13;
            ldp     x8,  x9,  [x1, #16]!&#13;
            ldp     x10, x11, [x1, #16]!&#13;
            ldp     x12, x13, [x1, #16]!&#13;
            ldp     x14, x15, [x1, #16]!&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_813" aria-label="813"/>            ldr     q0,  [x1, #16]!&#13;
            ldr     q1,  [x1, #16]!&#13;
            ldr     q2,  [x1, #16]!&#13;
            ldr     q3,  [x1, #16]!&#13;
            ldr     q4,  [x1, #16]!&#13;
            ldr     q5,  [x1, #16]!&#13;
            ldr     q6,  [x1, #16]!&#13;
            ldr     q7,  [x1, #16]!&#13;
            ldr     q8,  [x1, #16]!&#13;
            ldr     q9,  [x1, #16]!&#13;
            ldr     q10, [x1, #16]!&#13;
            ldr     q11, [x1, #16]!&#13;
            ldr     q12, [x1, #16]!&#13;
            ldr     q13, [x1, #16]!&#13;
            ldr     q14, [x1, #16]!&#13;
            ldr     q15, [x1, #16]!&#13;
&#13;
            ldr     x1, [fp, #str_alloc.saveX1]&#13;
&#13;
            leave&#13;
            endp    str.alloc</code></pre>&#13;
<p class="TX">The local variable declaration <span class="SANS_TheSansMonoCd_W5Regular_11">str_alloc.vsave</span> (type <span class="SANS_TheSansMonoCd_W5Regular_11">volatile_save</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>) will hold the preserved values of the volatile registers. Unfortunately, this structure is so large that you cannot directly access fields by using the <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #offset]</span> addressing mode. Therefore, the code computes the address of the <span class="SANS_TheSansMonoCd_W5Regular_11">volatile_save.x0x1</span> field into X1 and stores successive registers into the block pointed at by X1 <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This code must initialize X1 prior to storing anything in <span class="SANS_TheSansMonoCd_W5Regular_11">str_alloc.vsave</span>, so it first preserves X1 in a different local variable. Because the function returns the result in X0 and has to save X1 in a different location, this code doesn’t actually use the <span class="SANS_TheSansMonoCd_W5Regular_11">volatile_save.x0x1</span> field of <span class="SANS_TheSansMonoCd_W5Regular_11">str_alloc.vsave</span>.</p>&#13;
<p class="TX">The code saves all the volatile registers except X0 and X1 <span class="CodeAnnotation" aria-label="annotation3">❸</span>. It uses the pre-increment addressing mode, so it skips over the <span class="SANS_TheSansMonoCd_W5Regular_11">volatile_save.x0x1</span> field when writing the X2 and X3 registers to the structure.</p>&#13;
<p class="TX">Next, the code computes a string allocation size by adding 16 to <span class="SANS_TheSansMonoCd_W5Regular_11">maxlen</span> (to cover the extra fields in the string data structure) <span class="CodeAnnotation" aria-label="annotation4">❹</span>; it also adjusts the allocation size to be a multiple of 16 (greater than or equal to the requested size plus 16). This ensures that the character data area is a multiple of 16 bytes long, so string-handling code can manipulate 16 bytes at a time without worrying about accessing data beyond the allocated storage.</p>&#13;
<p class="TX">The call to <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span> allocates the storage for the string object. This code checks for a <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> (0) return result and returns an error if <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> fails. On success, the code initializes the fields of the string object and then returns a pointer to the object in X0 (with the carry clear on a successful call) <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Finally, the code restores all the volatile registers (except X0, which contains the function result) <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_814" aria-label="814"/>Next, the code includes the <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span> function:</p>&#13;
<pre id="pre-1135"><code>// Listing14-1.S (cont.)&#13;
//&#13;
// str.free&#13;
//&#13;
// Deallocates storage for an assembly language string&#13;
// object that was previously allocated via str.alloc&#13;
//&#13;
// On entry:&#13;
//&#13;
//  W0- Pointer to string object to deallocate&#13;
&#13;
            proc    str.free&#13;
&#13;
            locals  str_free&#13;
            dword   str_free.maxlen // Really a word&#13;
            dword   str_free.saveX1&#13;
            salign  4   // 16-byte align vsave&#13;
            byte    str_free.vsave, volatile_save.size&#13;
            byte    str_free.stkSpace,64&#13;
            endl    str_free&#13;
&#13;
            enter   str_free.size&#13;
&#13;
            // Preserve X1:&#13;
&#13;
            str     x1, [fp, #str_free.saveX1]&#13;
&#13;
            // Load X1 with the effective address of&#13;
            // str_alloc.vsave (which will be the&#13;
            // volatile_save.x0x1 element):&#13;
&#13;
            add     x1, fp, #str_free.vsave&#13;
&#13;
            // Preserve all the volatile registers (call to free&#13;
            // may change these):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> stp     x2,  x3,  [x1, #16]!&#13;
            stp     x4,  x5,  [x1, #16]!&#13;
            stp     x6,  x7,  [x1, #16]!&#13;
            stp     x8,  x9,  [x1, #16]!&#13;
            stp     x10, x11, [x1, #16]!&#13;
            stp     x12, x13, [x1, #16]!&#13;
            stp     x14, x15, [x1, #16]!&#13;
&#13;
            str     q0,  [x1, #16]!&#13;
            str     q1,  [x1, #16]!&#13;
            str     q2,  [x1, #16]!&#13;
            str     q3,  [x1, #16]!&#13;
            str     q4,  [x1, #16]!&#13;
            str     q5,  [x1, #16]!&#13;
            str     q6,  [x1, #16]!&#13;
            str     q7,  [x1, #16]!&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_815" aria-label="815"/>            str     q8,  [x1, #16]!&#13;
            str     q9,  [x1, #16]!&#13;
            str     q10, [x1, #16]!&#13;
            str     q11, [x1, #16]!&#13;
            str     q12, [x1, #16]!&#13;
            str     q13, [x1, #16]!&#13;
            str     q14, [x1, #16]!&#13;
            str     q15, [x1, #16]!&#13;
&#13;
            // Fetch the allocation pointer from the&#13;
            // string struct data type:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> ldr     x1, [x0, #string.allocPtr]&#13;
&#13;
            // Make sure it's not NULL (non-allocated&#13;
            // pointer):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> cbz     x1, str.free.done&#13;
&#13;
            // Defensive code, set the allocPtr field to&#13;
            // NULL:&#13;
&#13;
            str     xzr, [x0, #string.allocPtr]&#13;
&#13;
            // Deallocate the storage:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> mov     x0, x1&#13;
            bl      free&#13;
&#13;
str.free.done:&#13;
&#13;
            // Restore the volatile register before&#13;
            // returning:&#13;
&#13;
            add     x1, fp, #str_free.vsave&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> ldp     x2,  x3,  [x1, #16]!&#13;
            ldp     x4,  x5,  [x1, #16]!&#13;
            ldp     x6,  x7,  [x1, #16]!&#13;
            ldp     x8,  x9,  [x1, #16]!&#13;
            ldp     x10, x11, [x1, #16]!&#13;
            ldp     x12, x13, [x1, #16]!&#13;
            ldp     x14, x15, [x1, #16]!&#13;
&#13;
            ldr     q0,  [x1, #16]!&#13;
            ldr     q1,  [x1, #16]!&#13;
            ldr     q2,  [x1, #16]!&#13;
            ldr     q3,  [x1, #16]!&#13;
            ldr     q4,  [x1, #16]!&#13;
            ldr     q5,  [x1, #16]!&#13;
            ldr     q6,  [x1, #16]!&#13;
            ldr     q7,  [x1, #16]!&#13;
            ldr     q8,  [x1, #16]!&#13;
            ldr     q9,  [x1, #16]!&#13;
            ldr     q10, [x1, #16]!&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_816" aria-label="816"/>            ldr     q11, [x1, #16]!&#13;
            ldr     q12, [x1, #16]!&#13;
            ldr     q13, [x1, #16]!&#13;
            ldr     q14, [x1, #16]!&#13;
            ldr     q15, [x1, #16]!&#13;
&#13;
            ldr     x1, [fp, #str_free.saveX1]&#13;
            leave&#13;
            endp    str.free</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span> function also calls a C stdlib function and therefore must preserve all the volatile registers. In fact, the preservation code <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span> makes up the bulk of the statements in this function.</p>&#13;
<p class="TX">The caller passes the address of an assembly string object in the X0 register to this function. However, this is not the address that the code passes to the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> function; instead, this code fetches the address found in the <span class="SANS_TheSansMonoCd_W5Regular_11">string.allocPtr</span> field to pass on to <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Before actually calling <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span>, the code first checks whether this pointer value is <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. A <span class="SANS_TheSansMonoCd_W5Regular_11">NULL string.allocPtr</span> value means that the string wasn’t originally allocated with a call to <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span>. If that’s the case, <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span> simply returns (without registering an error), allowing code to call this function on dynamically and statically allocated objects. This is sometimes convenient when an arbitrary string pointer has been passed to a function that frees the storage without knowing how the storage was originally created.</p>&#13;
<p class="TX">Finally, the <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span> function calls the <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> function <span class="CodeAnnotation" aria-label="annotation4">❹</span> to return the storage to the heap.</p>&#13;
<p class="TX">Here’s a main program example (along with some data) that tests the functions appearing in Listing 14-1:</p>&#13;
<pre id="pre-1136"><code>// Listing14-1.S (cont.)&#13;
//&#13;
// Some read-only strings:&#13;
&#13;
fmtStr:     wastr   "hwStr=%s"&#13;
fmtStr2:    wastr   "hwDynamic=%s"&#13;
fmtStr3:    wastr   "strBufInit error\n"&#13;
&#13;
            str.literal hwLiteral, "Hello, world!\n"&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// Main program to test the code:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  lcl&#13;
            qword   hwStr&#13;
            qword   hwDynamic&#13;
            byte    hwBuffer, 256&#13;
            byte    stkSpace, 64&#13;
            endl    lcl&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_817" aria-label="817"/>            enter   lcl.size      // Reserve space for locals.&#13;
&#13;
            // Demonstrate call to str.bufInit:&#13;
&#13;
            // Initialize hwBuffer as a string object and&#13;
            // save pointer in hwStr:&#13;
&#13;
            add     x0, fp, #hwBuffer&#13;
            mov     x1, #256    // Buffer size&#13;
            bl      str.bufInit&#13;
            str     x0, [fp, #hwStr]&#13;
&#13;
            // Force copy of hwLiteral into hwStr:&#13;
&#13;
            lea     x2, hwLiteral&#13;
            ldr     w3, [x2, #string.len]   // Get length.&#13;
            str     w3, [x0, #string.len]   // Save hwStr len.&#13;
&#13;
            // Cheesy string copy. You know the length is less&#13;
            // than 16 bytes and both string objects have a&#13;
            // minimum of 16 character locations available.&#13;
&#13;
            ldr     q0, [x2]    // Copy "Hello, world!\n" string.&#13;
            str     q0, [x0]&#13;
&#13;
            // Now, hwStr contains a copy of hwLiteral.&#13;
            // Print hwStr (because the assembly language&#13;
            // string format always includes a zero-terminating&#13;
            // byte, you can just call printf to print the string).&#13;
            // Note that X0 still contains the hwStr pointer.&#13;
&#13;
            mov     x1, x0&#13;
            lea     x0, fmtStr&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
            // Demonstrate call to str.alloc and str.free:&#13;
&#13;
            mov     x0, #256    // String size&#13;
            bl      str.alloc&#13;
            bcs     badAlloc&#13;
            str     x0, [fp, #hwDynamic]&#13;
&#13;
            // Force copy of hwLiteral into hwDynamic:&#13;
&#13;
            lea     x2, hwLiteral&#13;
            ldr     w3, [x2, #string.len]   // Get length.&#13;
            str     w3, [x0, #string.len]   // Save hwDynamic len.&#13;
&#13;
            // Cheesy string copy. You know the length is less&#13;
            // than 16 bytes and both string objects have a&#13;
            // minimum of 16 character locations available.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_818" aria-label="818"/>            ldr     q0, [x2]    // Copy "Hello, world!\n" string.&#13;
            str     q0, [x0]&#13;
&#13;
            // Now hwDynamic contains a copy of hwLiteral.&#13;
            // Print hwDynamic (because the assembly language&#13;
            // string format always includes a zero-terminating&#13;
            // byte, you can just call printf to print the string).&#13;
            // Note that X0 still contains the hwDynamic pointer.&#13;
&#13;
            mov     x1, x0&#13;
            lea     x0, fmtStr2&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
            // Free the string storage:&#13;
&#13;
            ldr     x0, [fp, #hwDynamic]&#13;
            bl      str.free&#13;
&#13;
AllDone:    leave&#13;
&#13;
badAlloc:   lea     x0, fmtStr3&#13;
            bl      printf&#13;
            leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> function provides a few simple examples of calls to the <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">str.bufInit</span> functions.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command for Listing 14-1 and the sample program output:</p>&#13;
<pre id="pre-1137"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing14-1</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing14-1</span>&#13;
Calling Listing14-1:&#13;
hwStr=Hello, world!&#13;
hwDynamic=Hello, world!&#13;
Listing14-1 terminated</code></pre>&#13;
<p class="TX">As you can see, this code properly copied the static string to the dynamically allocated string.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-253"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.2.2 String Copy Function</span></h4>&#13;
<p class="TNI1">Listing 14-1 demonstrates the lack of perhaps the most important string function of all: one that copies character data from one string to another. This section presents <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy</span>, the second-most-used string function (after string length, in my experience), which makes a copy of the data in one string variable and stores that data in a second string variable.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy</span> function must do the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_819" aria-label="819"/>Compare the length of the source string against the maximum length of the destination string and return an error if the source string will not fit in the destination string variable.</li>&#13;
<li class="BL">Copy the <span class="SANS_TheSansMonoCd_W5Regular_11">len</span> field from the source string to the destination string.</li>&#13;
<li class="BL">Copy <span class="SANS_TheSansMonoCd_W5Regular_11">len + 1</span> characters from the source string to the destination string, which will also copy the zero-terminating byte.</li>&#13;
</ul>&#13;
<p class="TX">Listing 14-2 provides the implementation of this function.</p>&#13;
<pre id="pre-1138"><code>// Listing14-2.S&#13;
//&#13;
// A str.cpy string copy function&#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
// Assembly language string data structure:&#13;
&#13;
            struct  string, -16&#13;
            dword   string.allocPtr // At offset -16&#13;
            word    string.maxlen   // At offset -8&#13;
            word    string.len      // At offset -4&#13;
            byte    string.chars    // At offset 0&#13;
&#13;
            // Note: characters in string occupy offsets&#13;
            // 0 ... in this structure&#13;
&#13;
            ends    string&#13;
&#13;
// str.buf&#13;
//&#13;
// Allocate storage for an empty string&#13;
// with the specified maximum size:&#13;
&#13;
            .macro  str.buf strName, maxSize&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .dword  0   // NULL ptr for allocation ptr&#13;
            .word   \maxSize&#13;
            .word   0&#13;
\strName:   .space  ((\maxSize+16) &amp; 0xFFFFFFF0), 0&#13;
            .endm&#13;
&#13;
// str.literal:&#13;
//&#13;
// Allocate storage for a string buffer and initialize&#13;
// it with a string literal:&#13;
&#13;
            .macro  str.literal strName, strChars&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .dword  0   // NULL ptr for allocation ptr&#13;
            .word   len_\strName    // string.maxlen&#13;
            .word   len_\strName    // string.len&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_820" aria-label="820"/>            // Emit the string data and compute the&#13;
            // string's length:&#13;
&#13;
\strName:   .ascii  "\strChars"&#13;
len_\strName=       .-\strName&#13;
            .byte   0   // Zero-terminating byte&#13;
&#13;
            // Ensure object is multiple of 16 bytes:&#13;
&#13;
            .align  4&#13;
            .endm&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
&#13;
            .data&#13;
            str.buf     destination, 256&#13;
            str.literal source, "String to copy"&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
&#13;
            .code&#13;
            .global malloc&#13;
            .global free&#13;
&#13;
ttlStr:     wastr  "Listing14-2"&#13;
&#13;
// Standard getTitle function&#13;
// Returns pointer to program name in X0&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// str.cpy&#13;
//&#13;
// Copies the data from one string variable to another.&#13;
//&#13;
// On entry:&#13;
//&#13;
//  X0- Pointer to source string (string struct variable)&#13;
//  X1- Pointer to destination string&#13;
//&#13;
// On exit:&#13;
//&#13;
//  Carry flag clear if no errors; carry is set if&#13;
//  the source string will not fit in the destination.&#13;
&#13;
            proc    str.cpy&#13;
&#13;
            locals  str_cpy&#13;
            qword   str_cpy.saveV0&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_821" aria-label="821"/>            qword   str_cpy.saveX2X3&#13;
            dword   str_cpy.saveX4&#13;
            byte    str_cpy.stkSpace,64 // Not actually needed&#13;
            endl    str_cpy&#13;
&#13;
            enter   str_cpy.size&#13;
&#13;
            // Preserve X2 ... X4 and V0:&#13;
&#13;
            str     q0,     [fp, #str_cpy.saveV0]&#13;
            stp     x2, x3, [fp, #str_cpy.saveX2X3]&#13;
            str     x4,     [fp, #str_cpy.saveX4]&#13;
&#13;
            // Ensure the source will fit in the destination&#13;
            // string object:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> ldr     w4, [x0, #string.len]&#13;
            ldr     w3, [x1, #string.maxlen]&#13;
            cmp     w4, w3&#13;
            bhi     str.cpy.done    // Note: carry is set.&#13;
&#13;
            // Set the length of the destination string&#13;
            // to the length of the source string:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> str     w4, [x1, #string.len]&#13;
&#13;
            // X4 contains the number of characters to copy.&#13;
            // While this is greater than 16, copy 16 bytes&#13;
            // at a time from source to dest:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> mov     x2, x0  // Preserve X0 and X1.&#13;
            mov     x3, x1&#13;
cpy16:      ldr     q0, [x2], #16&#13;
            str     q0, [x3], #16&#13;
            subs    w4, w4, #16&#13;
            bhi     cpy16&#13;
&#13;
// At this point, you have fewer than 16 bytes to copy. If&#13;
// W4 is not 0, just copy 16 remaining bytes (you know,&#13;
// because of the string data structure, that if you have at&#13;
// least 1 byte left to copy, you can safely copy&#13;
// 16 bytes):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> beq     setZByte    // Skip if 0 bytes.&#13;
&#13;
            ldr     q0, [x2]&#13;
            str     q0, [x3]&#13;
&#13;
// Need to add a zero-terminating byte to the end of&#13;
// the string. Note that maxlen does not include the&#13;
// 0 byte, so it's always safe to append the 0&#13;
// byte to the end of the string.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_822" aria-label="822"/>setZByte:   ldr     w4,  [x0, #string.len]&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> strb    wzr, [x1, w4, uxtw]&#13;
&#13;
            adds    wzr, wzr, wzr   // Clears the carry&#13;
&#13;
str.cpy.done:&#13;
            ldr     q0,     [fp, #str_cpy.saveV0]&#13;
            ldp     x2, x3, [fp, #str_cpy.saveX2X3]&#13;
            ldr     x4,     [fp, #str_cpy.saveX4]&#13;
            leave&#13;
            endp    str.cpy&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// A read-only format string:&#13;
&#13;
fmtStr:     wastr   "source='%s', destination='%s'\n"&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// Main program to test the code:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  lcl&#13;
            byte    stkSpace, 64&#13;
            endl    lcl&#13;
&#13;
            enter   lcl.size      // Reserve space for locals.&#13;
&#13;
            lea     x0, source&#13;
            lea     x1, destination&#13;
            bl      str.cpy&#13;
&#13;
            mov     x2, x1&#13;
            mov     x1, x0&#13;
            lea     x0, fmtStr&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
AllDone:    leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy</span> function is straightforward and efficient, almost entirely because of the design of the string data type (in particular, the alignment and padding requirements of the string). The code first checks to ensure that the current length of the source string is less than or equal to the maximum length allowed for the destination string <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the source string’s length is too large, control transfers to the end of the function and it returns. The comparison will set the carry flag if the source length is “higher or same” as the destination maximum length. Therefore, this comparison automatically sets the carry flag to indicate a <i>string overflow</i> error <span role="doc-pagebreak" epub:type="pagebreak" id="pg_823" aria-label="823"/>if it branches because the <span class="SANS_TheSansMonoCd_W5Regular_11">string.len</span> field is higher than the <span class="SANS_TheSansMonoCd_W5Regular_11">string.maxlen</span> field. Because the new destination string will be a copy of the source string, the code then sets the destination <span class="SANS_TheSansMonoCd_W5Regular_11">string.len</span> field to the source string’s length <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">The code is responsible for copying the character data from the source string to the destination string <span class="CodeAnnotation" aria-label="annotation3">❸</span>. This is a <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loop, so it always copies 16 bytes, even if the string length is 0. That’s okay because the string data type always ensures that the character storage area is a multiple of 16 bytes long (including space for a zero-terminating byte). This loop may end up copying just the zero-terminating byte and 15 bytes of garbage data, but it will not access memory beyond the end of the string object’s storage.</p>&#13;
<p class="TX">For each of the 16 bytes the loop copies <span class="CodeAnnotation" aria-label="annotation3">❸</span>, the code decrements the length counter (W4) by 16. The <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instruction sets the flags exactly as a <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction would, so the <span class="SANS_TheSansMonoCd_W5Regular_11">bhi</span> instruction repeats the loop as long as the value in W4 is greater than 16 (prior to the <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instruction). If the string’s length is a multiple of 16 bytes long, this loop will terminate after copying the last 16 bytes of the string (when W4 decrements to 0). In this situation, the <span class="SANS_TheSansMonoCd_W5Regular_11">beq</span> instruction <span class="CodeAnnotation" aria-label="annotation4">❹</span> transfers control to the code that will append the zero-terminating byte.</p>&#13;
<p class="TX">If the string’s length is not an integral multiple of 16, subtracting 16 will produce a result greater than 0 but less than 16 (meaning some characters remain left to copy from the source to the destination). Therefore, the code will fall through to the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instructions and copy the remaining bytes of the string (plus some garbage bytes).</p>&#13;
<p class="TX">Finally, the code will store a zero-terminating byte to the end of the string <span class="CodeAnnotation" aria-label="annotation5">❺</span> in the event the previous <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instructions didn’t copy that byte along with the character data.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Technically, the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">beq</span> <i>instruction in Listing 14-2 is unnecessary. If the string’s length is an exact multiple of 16 bytes long, at least 1 additional byte must be copied: the zero-terminating byte. Therefore, the data structure is guaranteed to contain at least 16 additional bytes, so falling through to the next pair of load and store instructions won’t create a problem. As an interesting experiment, you might determine whether removing the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">beq</span> <i>instruction improves or hurts the algorithm’s performance.</i></p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample program output for the code in Listing 14-2:</p>&#13;
<pre id="pre-1139"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing14-2</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing14-2</span>&#13;
Calling Listing14-2:&#13;
source='String to copy', destination='String to copy'&#13;
Listing14-2 terminated</code></pre>&#13;
<p class="TX">Although this string is shorter than 16 characters long and doesn’t fully test <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy</span>, I’ve run this program with different source strings to verify that it works for larger strings.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_824" aria-label="824"/>&#13;
<h4 class="H2" id="sec5"><span id="h2-254"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.2.3 String Comparison Function</span></h4>&#13;
<p class="TNI1">After copying strings, comparing strings is the string function you’ll likely use most often. To compare two character strings, use the following steps:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Extract a character at corresponding indices from both strings.</p>&#13;
<p class="ListNumber">  2.  Compare the two characters. If they are not equal, the comparison is complete and the result of the string comparison is the result of this character comparison (not equal, less than, or greater than). If they are equal and not zero, repeat step 1.</p>&#13;
<p class="ListNumber">  3.  If the two characters are both 0 bytes, the comparison is finished, and the two strings are equal.</p>&#13;
</div>&#13;
<p class="TX">This algorithm works for zero-terminated strings (and, because they are also zero-terminated, for the assembly language string format given in this chapter). Note that the comparison algorithm does not use the string-length value.</p>&#13;
<p class="TX">Here’s a naive version of this string comparison in ARM64 assembly language that assumes X0 and X1 point at the string data to compare:</p>&#13;
<pre id="pre-1140"><code>cmpLp:&#13;
    ldrb w2, [x0], #1&#13;
    ldrb w3, [x1], #1&#13;
    cmp  w2, w3&#13;
    bne  strNE&#13;
    cbnz w2, cmpLp&#13;
&#13;
// At this point, the strings are equal.&#13;
    .&#13;
    .&#13;
    .&#13;
strNE:&#13;
    // At this point, the strings are not equal.</code></pre>&#13;
<p class="TX">As you saw with the <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span> function, processing multiple bytes at once using 64- or 128-bit registers is usually much faster. Can you improve performance by using vector registers? The big problem with this is that vector comparisons check for a specific comparison (<span class="SANS_TheSansMonoCd_W5Regular_11">lt</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">le</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">eq</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ne</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">gt</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">ge</span>). They don’t set the condition code flags, so you can use the conditional branches, which is what most programmers would prefer. That being the case, comparing eight characters at a time using 64-bit general-purpose registers is probably the best solution.</p>&#13;
<p class="TX">Given the efficiency of the glibc <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span> function, you might wonder whether its <span class="SANS_TheSansMonoCd_W5Regular_11">strcmp()</span> function is also good. Listing 14-3 presents this function, with its operation explained in the comments.</p>&#13;
<pre id="pre-1141"><code>// Listing14-3.S&#13;
//&#13;
// GNU glibc strcmp function&#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_825" aria-label="825"/>// Copyright (C) 2013 ARM Ltd.&#13;
// Copyright (C) 2013 Linaro.&#13;
//&#13;
// This code is based on glibc cortex strings work originally&#13;
// authored by Linaro and relicensed under GPLv2 for the&#13;
// Linux kernel. The original code can be found @&#13;
//&#13;
// http://bazaar.launchpad.net/~linaro-toolchain-dev/&#13;
// cortex-strings/trunk/&#13;
//&#13;
// files/head:/src/aarch64/&#13;
//&#13;
// This program is free software; you can redistribute it&#13;
// and/or modify it under the terms of the GNU General Public&#13;
// License version 2 as published by the Free Software&#13;
// Foundation.&#13;
//&#13;
// This program is distributed in the hope that it will be&#13;
// useful, but WITHOUT ANY WARRANTY; without even the implied&#13;
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR&#13;
// PURPOSE. See the GNU General Public License for more&#13;
// details.&#13;
//&#13;
// You should have received a copy of the GNU General Public&#13;
// License along with this program. If not, see&#13;
// &lt;http://www.gnu.org/licenses/&gt;.&#13;
&#13;
#include &lt;linux/linkage.h&gt;&#13;
#include &lt;asm/assembler.h&gt;&#13;
&#13;
// Compare two strings&#13;
//&#13;
// Parameters:&#13;
//  X0 - Const string 1 pointer&#13;
//  X1 - Const string 2 pointer&#13;
//&#13;
// Returns:&#13;
//  X0 - An integer less than, equal to, or greater&#13;
//       than zero if S1 is found, respectively, to be&#13;
//       less than, to match, or to be greater than S2&#13;
&#13;
#define REP8_01 0x0101010101010101&#13;
#define REP8_7f 0x7f7f7f7f7f7f7f7f&#13;
#define REP8_80 0x8080808080808080&#13;
&#13;
// Parameters and result&#13;
&#13;
src1        .req    x0&#13;
src2        .req    x1&#13;
result      .req    x0&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_826" aria-label="826"/>// Internal variables&#13;
&#13;
data1       .req    x2&#13;
data1w      .req    w2&#13;
data2       .req    x3&#13;
data2w      .req    w3&#13;
has_nul     .req    x4&#13;
diff        .req    x5&#13;
syndrome    .req    x6&#13;
tmp1        .req    x7&#13;
tmp2        .req    x8&#13;
tmp3        .req    x9&#13;
zeroones    .req    x10&#13;
pos         .req    x11&#13;
&#13;
strcmp:&#13;
    eor tmp1, src1, src2&#13;
    mov zeroones, #REP8_01&#13;
    tst tmp1, #7&#13;
    b.ne    .Lmisaligned8&#13;
    ands    tmp1, src1, #7&#13;
    b.ne    .Lmutual_align&#13;
&#13;
// NUL detection works on the principle that (X - 1) &amp;&#13;
// (~X) &amp; 0x80 (=&gt; (X - 1) &amp; ~(X | 0x7f)) is nonzero if&#13;
// a byte is 0, and can be done in parallel across the&#13;
// entire word.&#13;
&#13;
.Lloop_aligned:&#13;
    ldr data1, [src1], #8&#13;
    ldr data2, [src2], #8&#13;
.Lstart_realigned:&#13;
    sub tmp1, data1, zeroones&#13;
    orr tmp2, data1, #REP8_7f&#13;
    eor diff, data1, data2  // Nonzero if differences found&#13;
    bic has_nul, tmp1, tmp2 // Nonzero if NUL terminator&#13;
    orr syndrome, diff, has_nul&#13;
    cbz syndrome, .Lloop_aligned&#13;
    b   .Lcal_cmpresult&#13;
.Lmutual_align:&#13;
&#13;
// Sources are mutually aligned but are not currently at&#13;
// an alignment boundary. Round down the addresses and&#13;
// then mask off the bytes that precede the start point:&#13;
&#13;
    bic src1, src1, #7&#13;
    bic src2, src2, #7&#13;
    lsl tmp1, tmp1, #3  // Bytes beyond alignment -&gt; bits&#13;
    ldr data1, [src1], #8&#13;
    neg tmp1, tmp1      // (Bits to align) - 64&#13;
    ldr data2, [src2], #8&#13;
    mov tmp2, #~0&#13;
&#13;
    lsr tmp2, tmp2, tmp1 // Shift (tmp1 &amp; 63)&#13;
    orr data1, data1, tmp2&#13;
    orr data2, data2, tmp2&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_827" aria-label="827"/>    b   .Lstart_realigned&#13;
.Lmisaligned8:&#13;
&#13;
// Get the align offset length to compare per byte first.&#13;
// After this process, one string's address will be&#13;
// aligned.&#13;
&#13;
    and     tmp1, src1, #7&#13;
    neg     tmp1, tmp1&#13;
    add     tmp1, tmp1, #8&#13;
    and     tmp2, src2, #7&#13;
    neg     tmp2, tmp2&#13;
    add     tmp2, tmp2, #8&#13;
    subs    tmp3, tmp1, tmp2&#13;
    csel    pos, tmp1, tmp2, hi // Choose the maximum.&#13;
.Ltinycmp:&#13;
    ldrb    data1w, [src1], #1&#13;
    ldrb    data2w, [src2], #1&#13;
    subs    pos, pos, #1&#13;
    ccmp    data1w, #1, #0, ne      // NZCV = 0b0000&#13;
    ccmp    data1w, data2w, #0, cs  // NZCV = 0b0000&#13;
    b.eq    .Ltinycmp&#13;
    cbnz    pos, 1f  // Find the null or unequal ...&#13;
    cmp     data1w, #1&#13;
    ccmp    data1w, data2w, #0, cs&#13;
    b.eq    .Lstart_align  // The last bytes are equal.&#13;
1:&#13;
    sub result, data1, data2&#13;
    ret&#13;
.Lstart_align:&#13;
    ands    xzr, src1, #7&#13;
    b.eq    .Lrecal_offset&#13;
&#13;
    // Process more leading bytes to make str1 aligned:&#13;
&#13;
    add src1, src1, tmp3&#13;
    add src2, src2, tmp3&#13;
&#13;
    // Load 8 bytes from aligned str1 and nonaligned str2:&#13;
&#13;
    ldr data1, [src1], #8&#13;
    ldr data2, [src2], #8&#13;
    sub tmp1, data1, zeroones&#13;
    orr tmp2, data1, #REP8_7f&#13;
    bic has_nul, tmp1, tmp2&#13;
    eor diff, data1, data2 // Nonzero if differences found&#13;
    orr syndrome, diff, has_nul&#13;
    cbnz    syndrome, .Lcal_cmpresult&#13;
&#13;
    // How far is the current str2 from the alignment boundary?&#13;
&#13;
    and tmp3, tmp3, #7&#13;
.Lrecal_offset:&#13;
    neg pos, tmp3&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_828" aria-label="828"/>.Lloopcmp_proc:&#13;
&#13;
// Divide the 8 bytes into two parts. First, adjust the src&#13;
// to the previous alignment boundary, load 8 bytes from&#13;
// from the SRC2 alignment boundary, then compare with the&#13;
// relative bytes from SRC1. If all 8 bytes are equal,&#13;
// start the second part's comparison. Otherwise, finish&#13;
// the comparison. This special handle can guarantee all&#13;
// the accesses are in the thread/task space in order to&#13;
// avoid overrange access.&#13;
&#13;
    ldr data1, [src1,pos]&#13;
    ldr data2, [src2,pos]&#13;
    sub tmp1, data1, zeroones&#13;
    orr tmp2, data1, #REP8_7f&#13;
    bic has_nul, tmp1, tmp2&#13;
    eor diff, data1, data2  // Nonzero if differences found&#13;
    orr syndrome, diff, has_nul&#13;
    cbnz    syndrome, .Lcal_cmpresult&#13;
&#13;
    // The second part of the process:&#13;
&#13;
    ldr data1, [src1], #8&#13;
    ldr data2, [src2], #8&#13;
    sub tmp1, data1, zeroones&#13;
    orr tmp2, data1, #REP8_7f&#13;
    bic has_nul, tmp1, tmp2&#13;
    eor diff, data1, data2  // Nonzero if differences found&#13;
    orr syndrome, diff, has_nul&#13;
    cbz syndrome, .Lloopcmp_proc&#13;
.Lcal_cmpresult:&#13;
&#13;
// Reverse the byte order as big-endian, so CLZ can find&#13;
// the most significant 0 bits:&#13;
&#13;
    rev syndrome, syndrome&#13;
    rev data1, data1&#13;
    rev data2, data2&#13;
&#13;
    clz pos, syndrome&#13;
&#13;
// The MS-nonzero bit of the syndrome marks either the&#13;
// first bit that is different or the top bit of the&#13;
// first 0 byte. Shifting left now will bring the&#13;
// critical information into the top bits.&#13;
&#13;
    lsl data1, data1, pos&#13;
    lsl data2, data2, pos&#13;
&#13;
// But you need to zero-extend (char is unsigned) the value&#13;
// and then perform a signed 32-bit subtraction:&#13;
&#13;
    lsr data1, data1, #56&#13;
    sub result, data1, data2, lsr #56&#13;
    ret</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_829" aria-label="829"/>The majority of the complexity is due to the code being written to handle string data that is not aligned to an 8-byte boundary. This string-comparison code could be written more simply if it could assume that the source and destination strings were always aligned on an 8-byte boundary. Because the assembly language string object is, by definition, always aligned on a 16-byte boundary, it is possible to write a more efficient comparison function for those strings. Listing 14-4 provides such a <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp</span> function.</p>&#13;
<pre id="pre-1142"><code>// Listing14-4.S&#13;
//&#13;
// A str.cmp string comparison function&#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
// Assembly language string data structure:&#13;
&#13;
            struct  string, -16&#13;
            dword   string.allocPtr // At offset -16&#13;
            word    string.maxlen   // At offset -8&#13;
            word    string.len      // At offset -4&#13;
            byte    string.chars    // At offset 0&#13;
&#13;
            // Note: characters in string occupy offsets&#13;
            // 0 ... in this structure.&#13;
&#13;
            ends    string&#13;
&#13;
// str.buf&#13;
//&#13;
// Allocate storage for an empty string&#13;
// with the specified maximum size:&#13;
&#13;
            .macro  str.buf strName, maxSize&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .dword  0   // NULL ptr for allocation ptr&#13;
            .word   \maxSize&#13;
            .word   0&#13;
\strName:   .space  ((\maxSize+16) &amp; 0xFFFFFFF0), 0&#13;
            .endm&#13;
&#13;
// str.literal&#13;
//&#13;
// Allocate storage for a string buffer and initialize&#13;
// it with a string literal:&#13;
&#13;
            .macro  str.literal strName, strChars&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .dword  0   // NULL ptr for allocation ptr&#13;
            .word   len_\strName    // string.maxlen&#13;
            .word   len_\strName    // string.len&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_830" aria-label="830"/>            // Emit the string data and compute the&#13;
            // string's length:&#13;
&#13;
\strName:   .ascii  "\strChars"&#13;
len_\strName=       .-\strName&#13;
            .byte   0   // Zero-terminating byte&#13;
&#13;
            // Ensure object is multiple of 16 bytes:&#13;
&#13;
            .align  4&#13;
            .endm&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
&#13;
            .data&#13;
            str.buf     destination, 256&#13;
            str.literal left,   "some string"&#13;
            str.literal right1, "some string"&#13;
            str.literal right2, "some string."&#13;
            str.literal right3, "some string"&#13;
            str.literal right4, ""&#13;
            str.literal right5, "t"&#13;
            str.literal right6, " "&#13;
&#13;
            str.literal left2,  "some string 16.."&#13;
            str.literal right7, "some string 16.."&#13;
            str.literal right8, "some string 16."&#13;
            str.literal right9, "some string 16..."&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
&#13;
            .code&#13;
            .global malloc&#13;
            .global free&#13;
&#13;
ttlStr:     wastr   "Listing14-4"&#13;
&#13;
// Standard getTitle function&#13;
// Returns pointer to program name in X0&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// str.cmp&#13;
//&#13;
// Compares two string objects&#13;
//&#13;
// On entry:&#13;
//&#13;
//  X0- Pointer to left string&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_831" aria-label="831"/>//  X1- Pointer to right string&#13;
//&#13;
//      left op right&#13;
//&#13;
//  Where op is the string comparison operation&#13;
//&#13;
// On exit:&#13;
//&#13;
//  Condition code flags contain state of comparison&#13;
&#13;
            proc    str.cmp&#13;
&#13;
            locals  str_cmp&#13;
            qword   str_cmp.saveX2X3&#13;
            dword   str_cmp.saveX4X5&#13;
            dword   str_cmp.saveX6X7&#13;
            byte    str_cmp.stkSpace,64&#13;
            endl    str_cmp&#13;
&#13;
            enter   str_cmp.size&#13;
&#13;
            // Preserve X2 ... X7:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> stp     x2, x3, [fp, #str_cmp.saveX2X3]&#13;
            stp     x4, x5, [fp, #str_cmp.saveX4X5]&#13;
            stp     x6, x7, [fp, #str_cmp.saveX6X7]&#13;
&#13;
            mov     x2, x0  // Preserve X0 and X1.&#13;
            mov     x3, x1&#13;
&#13;
            // Compute the minimum of the string lengths:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> ldr     w6, [x2, #string.len]&#13;
            ldr     w7, [x3, #string.len]&#13;
            cmp     w6, w7&#13;
            csel    w6, w6, w7, hs&#13;
            b.al    cmpLen&#13;
&#13;
cmp8:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> ldr     x4, [x2], #8&#13;
            ldr     x5, [x3], #8&#13;
            rev     x4, x4&#13;
            rev     x5, x5&#13;
            cmp     x4, x5&#13;
            bne     str.cmp.done&#13;
cmpLen:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> subs    w6, w6, #8      // Also compares W6 to 8&#13;
            bhs     cmp8&#13;
&#13;
            // Fewer than eight characters left (and more&#13;
            // than zero). Cheapest to just compare them&#13;
            // one at a time:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> adds    w6, w6, #8&#13;
            beq     str.cmp.done  // If lens are equal&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_832" aria-label="832"/>cmp1:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> ldrb    w4, [x2], #1&#13;
            ldrb    w5, [x3], #1&#13;
            cmp     w4, w5&#13;
            bne     str.cmp.done&#13;
            subs    w6, w6, #1&#13;
            bne     cmp1&#13;
&#13;
            // At this point, the strings are equal&#13;
            // through the length of the shorter&#13;
            // string. The comparison is thus based&#13;
            // on the result of comparing the lengths&#13;
            // of the two strings.&#13;
&#13;
cmpLens:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> ldr     w6, [x0, #string.len]   // Fetch left len.&#13;
            cmp     w6, w7                  // Right len&#13;
&#13;
str.cmp.done:&#13;
            ldp     x2, x3, [fp, #str_cmp.saveX2X3]&#13;
            ldp     x4, x5, [fp, #str_cmp.saveX4X5]&#13;
            ldp     x6, x7, [fp, #str_cmp.saveX6X7]&#13;
            leave&#13;
            endp    str.cmp&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// Some read-only strings:&#13;
&#13;
ltFmtStr:   wastr   "Left ('%s') is less than right ('%s')\n"&#13;
gtFmtStr:   wastr   "Left ('%s') is greater than right ('%s')\n"&#13;
eqFmtStr:   wastr   "Left ('%s') is equal to right ('%s')\n"&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// prtResult&#13;
//&#13;
// Utility function to print the result of a string&#13;
// comparison&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> proc    prtResult&#13;
&#13;
            mov     x2, x1&#13;
            mov     x1, x0&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            beq     strsEQ&#13;
            bhi     strGT&#13;
&#13;
            // Must be LT at this point&#13;
&#13;
            lea     x0, ltFmtStr&#13;
            b       printf&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_833" aria-label="833"/>strsEQ:     lea     x0, eqFmtStr&#13;
            b       printf&#13;
&#13;
strGT:      lea     x0, gtFmtStr&#13;
            b       printf&#13;
&#13;
            endp    prtResult&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// Main program to test the code:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  lcl&#13;
            byte    stkSpace, 64&#13;
            endl    lcl&#13;
&#13;
            enter   lcl.size      // Reserve space for locals.&#13;
&#13;
            lea     x0, left&#13;
            lea     x1, right1&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
            lea     x0, left&#13;
            lea     x1, right2&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
            lea     x0, left&#13;
            lea     x1, right3&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
            lea     x0, left&#13;
            lea     x1, right4&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
            lea     x0, left&#13;
            lea     x1, right5&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
            lea     x0, left&#13;
            lea     x1, right6&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
            lea     x0, left2&#13;
            lea     x1, right7&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_834" aria-label="834"/>            lea     x0, left2&#13;
            lea     x1, right8&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
            lea     x0, left2&#13;
            lea     x1, right9&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
AllDone:    leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp</span> function does not modify the X0 or X1 registers, but it will modify X2 through X7, so this code begins by preserving these register values <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It then copies the values in X0 and X1 into X2 and X3 (respectively), which it will use in the code.</p>&#13;
<p class="TX">When comparing the strings, <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp</span> will compare only to the length of the shorter string. The code computes the minimum length of the two strings <span class="CodeAnnotation" aria-label="annotation2">❷</span>, leaving the result in W6. If the two strings are equal to the length of the shorter string, the shorter string is considered less than the longer string.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">cmp8</span> loop compares the characters in the string 8 bytes at a time <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Strings are intrinsically a <i>big-endian</i> data structure, meaning the lower-order bytes in the string have the most-significant values. Therefore, you cannot simply load 8 successive bytes into a pair of 64-bit registers and compare those registers; that would produce a little-endian comparison result. To resolve this issue, the code executes two <span class="SANS_TheSansMonoCd_W5Regular_11">rev</span> instructions to swap the bytes in the two 64-bit registers prior to comparing them, resulting in a big-endian comparison.</p>&#13;
<p class="TX">After comparing the two dwords, the code branches to the return code if those dwords are not equal. At that point, the ARM condition codes will hold the result of the comparison. If the two dwords are equal, the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp8</span> loop must repeat until it has exhausted all the characters or finds a pair of dwords that are not equal. The code subtracts 8 from W6 and repeats if the value prior to the subtraction was greater than or equal to 8 (remember, <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> set the flags the same way) <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Because this code subtracts 8 from W6 before comparing the corresponding characters, if W6 winds up with 0, eight characters still remain to compare. That’s why this code repeats even when subtracting 8 produces a 0 result.</p>&#13;
<p class="TX">If the code falls down to <span class="CodeAnnotation" aria-label="annotation5">❺</span>, the W6 contains a negative result. The code adds 8 to this value to determine the number of characters it must still process. If the result is 0, the strings are the same length and all characters in the string are equal; in that case, the code exits (with the flags already containing appropriate values). If the result is nonzero, the code processes the remaining characters in the two strings one character at a time <span class="CodeAnnotation" aria-label="annotation6">❻</span>. (Four instructions per character, for an average of four characters per string, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_835" aria-label="835"/>assuming random string lengths, is usually faster than attempting to zero out the excess bytes and compare 8 bytes at a time.)</p>&#13;
<p class="TX">If the code transfers or drops through to <span class="SANS_TheSansMonoCd_W5Regular_11">cmpLens</span> <span class="CodeAnnotation" aria-label="annotation7">❼</span>, the strings were equal to the length of the shorter string. At this point, the code determines the result of the comparison by comparing the strings’ lengths.</p>&#13;
<p class="TX">The main program compares several strings to test the <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp</span> function. The <span class="SANS_TheSansMonoCd_W5Regular_11">prtResult</span> function <span class="CodeAnnotation" aria-label="annotation8">❽</span> is a short utility function that prints the result of the comparisons.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>This code would be slightly more efficient if it preserved X0 and X1 rather than X2 and X3, then used X0 and X1 rather than X2 and X3. However, I left X0 and X1 alone because during development I used</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">printf()</span> <i>to print some debugging messages. Feel free to change this code to use X0/X1 rather than X2/X3 if the two extra instructions (those that move X0 and X1 into X2 and X3) bother you.</i></p>&#13;
<p class="TX">As was the case for the glibc <span class="SANS_TheSansMonoCd_W5Regular_11">strcmp()</span> function, the <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp</span> function expects pointers to the two strings to compare in X0 and X1. The <i>left</i> string is X0, and the <i>right</i> string is X1. Left and right have to do with their position in a comparison expression. The following example demonstrates the positions of the two strings in an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement:</p>&#13;
<pre id="pre-1143"><code>if(leftStr &lt;= rightStr) then ...</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">strcmp()</span> function returns a result in X0 indicating the result of the comparison:</p>&#13;
<ul class="ul">&#13;
<li class="BL">If X0 is negative, the left string (X0) is less than the right string (X1).</li>&#13;
<li class="BL">If X0 is 0, the two strings are equal.</li>&#13;
<li class="BL">If X0 is positive, the left string is greater than the right string.</li>&#13;
</ul>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp</span> function, on the other hand, returns the comparison result in the condition code flags, so you can use the conditional branch instructions upon return to test the result.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 14-4:</p>&#13;
<pre id="pre-1144"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing14-4</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing14-4</span>&#13;
Calling Listing14-4:&#13;
Left ('some string') is equal to right ('some string')&#13;
Left ('some string') is less than right ('some string.')&#13;
Left ('some string') is greater than right ('some string')&#13;
Left ('some string') is greater than right ('')&#13;
Left ('some string') is less than right ('t')&#13;
Left ('some string') is greater than right (' ')&#13;
Left ('some string 16..') is equal to right ('some string 16..')&#13;
Left ('some string 16..') is greater than right ('some string 16.')&#13;
Left ('some string 16..') is less than right ('some string 16..')&#13;
Listing14-4 terminated</code></pre>&#13;
<p class="TX">As you can see, <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp</span> returned the proper results for the test strings.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_836" aria-label="836"/>&#13;
<h4 class="H2" id="sec6"><span id="h2-255"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.2.4 Substring Function</span></h4>&#13;
<p class="TNI1">The last ASCII example I’ll provide in this chapter is the substring function <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span>. A typical substring function extracts a portion of the characters from a string, creating a new string from the substring. It typically has four parameters: a pointer to a source string, an index into the substring where the extraction is to begin, a length specifying the number of characters to copy from the source, and a pointer to a destination string.</p>&#13;
<p class="TX">The substring operation has several issues:</p>&#13;
<ul class="ul">&#13;
<li class="BL">You can’t assume that the source characters are aligned on a 16-byte boundary.</li>&#13;
<li class="BL">The specified starting index might be beyond the length of the source string.</li>&#13;
<li class="BL">The specified substring length might extend beyond the end of the source string.</li>&#13;
<li class="BL">The length of the substring might exceed the maximum length of the destination string.</li>&#13;
</ul>&#13;
<p class="TX">The first issue is often impossible to deal with. Most of the time, either the source characters or the destination characters will have an unaligned address. The <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> code in this section will choose to keep the destination address aligned on a 16-byte boundary (which it gets by default). The function must carefully check the length while copying data to ensure that it doesn’t read any data beyond the end of the source-string data structure.</p>&#13;
<p class="TX">You can handle the second issue in two ways: either return an error code without copying any data or simply store an empty string into the destination. This latter solution is often the most convenient, and I rely on it in this section’s code.</p>&#13;
<p class="TX">Likewise, there are two ways to handle the third issue: either return an error code without copying any data or copy all the characters from the starting index to the end of the source string into the destination string. Once again, the latter solution is often the most convenient, and the <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> code relies on it.</p>&#13;
<p class="TX">The fourth issue is a bit more problematic. The <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> code could truncate the string it copies, but this situation usually indicates a serious error on the part of the application (string overflow). Therefore, <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> will return a flag in the carry to indicate success or failure.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you prefer to return an error status for the second and third issues listed here, you can easily modify</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">str.substr</span> <i>to accomplish this.</i></p>&#13;
<p class="TX">Listing 14-5 provides the <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> function and a sample main program that tests it.</p>&#13;
<pre id="pre-1145"><code>// Listing14-5.S&#13;
//&#13;
// A str.substr substring function&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_837" aria-label="837"/>            #include    "aoaa.inc"&#13;
&#13;
// Assembly language string data structure:&#13;
&#13;
            struct  string, -16&#13;
            dword   string.allocPtr // At offset -16&#13;
            word    string.maxlen   // At offset -8&#13;
            word    string.len      // At offset -4&#13;
            byte    string.chars    // At offset 0&#13;
&#13;
            // Note: characters in string occupy offsets&#13;
            // 0 ... in this structure&#13;
&#13;
            ends    string&#13;
&#13;
// str.buf&#13;
//&#13;
// Allocate storage for an empty string&#13;
// with the specified maximum size:&#13;
&#13;
            .macro  str.buf strName, maxSize&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .dword  0   // NULL ptr for allocation ptr&#13;
            .word   \maxSize&#13;
            .word   0&#13;
\strName:   .space  ((\maxSize+16) &amp; 0xFFFFFFF0), 0&#13;
            .endm&#13;
&#13;
// str.literal&#13;
//&#13;
// Allocate storage for a string buffer and initialize&#13;
// it with a string literal:&#13;
&#13;
            .macro  str.literal strName, strChars&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .dword  0   // NULL ptr for allocation ptr&#13;
            .word   len_\strName    // string.maxlen&#13;
            .word   len_\strName    // string.len&#13;
&#13;
            // Emit the string data and compute the&#13;
            // string's length:&#13;
&#13;
\strName:   .ascii  "\strChars"&#13;
len_\strName=       .-\strName&#13;
            .byte   0   // Zero-terminating byte&#13;
&#13;
            // Ensure object is multiple of 16 bytes:&#13;
&#13;
            .align  4&#13;
            .endm&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_838" aria-label="838"/>            .data&#13;
fmtStr:     .ascii      "Source string:\n\n"&#13;
            .ascii      "          1111111111222222222233333\n"&#13;
            .ascii      "01234567890123456789012345678901234\n"&#13;
            .asciz      "%s\n\n"&#13;
&#13;
            str.buf     smallDest, 32&#13;
            str.literal dest,   "Initial destination string"&#13;
&#13;
//                             1111111111222222222233333&#13;
//                   01234567890123456789012345678901234&#13;
str.literal source, "Hello there, world! How's it going?"&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
&#13;
            .code&#13;
&#13;
ttlStr:     wastr  "listing14-5"&#13;
&#13;
// Standard getTitle function&#13;
// Returns pointer to program name in X0&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// str.substr&#13;
//&#13;
// Extracts a substring&#13;
//&#13;
// On entry:&#13;
//&#13;
//  X0- Pointer to source string&#13;
//  W1- Starting index into source string&#13;
//  W2- Length of substring&#13;
//  X3- Destination string&#13;
//&#13;
// On exit:&#13;
//&#13;
//  Carry clear on success and result stored at X3&#13;
//&#13;
//  If the substring will not fit in X3, return with&#13;
//  the carry set (and no data copied).&#13;
&#13;
            proc    str.substr&#13;
&#13;
            locals  str_substr&#13;
            qword   str_substr.saveV0&#13;
            qword   str_substr.saveX0X1&#13;
            qword   str_substr.saveX2X3&#13;
            qword   str_substr.saveX6X7&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_839" aria-label="839"/>            byte    str_substr.stkSpace,64  // Not needed&#13;
            endl    str_substr&#13;
&#13;
            enter   str_substr.size&#13;
&#13;
            // Preserve X0 ... X7 and V0:&#13;
&#13;
            str     q0,     [fp, #str_substr.saveV0]&#13;
            stp     x0, x1, [fp, #str_substr.saveX0X1]&#13;
            stp     x2, x3, [fp, #str_substr.saveX2X3]&#13;
            stp     x6, x7, [fp, #str_substr.saveX6X7]&#13;
&#13;
            // Handle the exceptional conditions:&#13;
            //&#13;
            // 1. Index &gt;= source.len   (return empty string)&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> ldr     w6, [x0, #string.len]&#13;
            cmp     w1, w6&#13;
            bhs     returnEmpty&#13;
&#13;
            // 2. Index + substr length &gt; source length&#13;
            // If so, reduce the length to match the end&#13;
            // of the string:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> add     w7, w1, w2      // W7 = index + substr length&#13;
            cmp     w6, w7&#13;
            csel    w6, w6, w7, ls  // W6 = min(source len, sum)&#13;
            sub     w6, w6, w1      // W6 = actual length&#13;
&#13;
            // 3. Substr length &gt; destination maxlen&#13;
            //    (fail):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> ldr     w7, [x3, #string.maxlen]&#13;
            cmp     w6, w7          // Carry set if&#13;
            bhi     str.sub.exit    // W6 &gt;= W7.&#13;
&#13;
            // At this point, W6 contains the actual number of&#13;
            // characters to copy from the source&#13;
            // to the destination. This could be less than the&#13;
            // length passed in W2 if the index + substr length&#13;
            // exceeded the length of the source string.&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> str     w6, [x3, #string.len]   // Save as dest len.&#13;
&#13;
            // Point X0 at the first character of the substring&#13;
            // to copy to the destination string (base address&#13;
            // plus starting index):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> add     x0, x0, w1, uxtw&#13;
            b.al    test16&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_840" aria-label="840"/>            // Copy the substring 16 bytes at a time:&#13;
&#13;
copy16:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> ldr     q0, [x0], #16   // Get bytes to copy.&#13;
            str     q0, [x3], #16   // Store into dest.&#13;
&#13;
            // Decrement the number of characters to copy by&#13;
            // 16. Quit if the result is negative (meaning&#13;
            // fewer than 16 characters were left to&#13;
            // copy). Remember, subs sets the flags the same&#13;
            // as cmp, so the following compares the value in&#13;
            // W6 against 16 and branches to copy16 if&#13;
            // 16 or more characters are left to copy:&#13;
test16:&#13;
            subs    w6, w6, #16&#13;
            bhs     copy16&#13;
&#13;
            // W6 has gone negative. Need to add 16 to determine&#13;
            // the number of bytes left to copy:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> add     w6, w6, #16     // Now W6 contains 0 to 15.&#13;
&#13;
            // Switch statement based on the number of characters&#13;
            // left to copy in the substring. Handle as a special&#13;
            // case each of the 0 ... 15 bytes to copy:&#13;
&#13;
            and     x6, x6, #0xFFFFFFFF  // Zero-extend to 64 bits.&#13;
            adr     x7, JmpTbl&#13;
            ldr     w6, [x7, x6, lsl #2] // *4 for 32-bit entries&#13;
            add     x7, x7, w6, sxtw     // Sign-extend to 64 bits.&#13;
            br      x7&#13;
&#13;
JmpTbl:     .word   str.sub.success-JmpTbl  // _0bytesToCopy&#13;
            .word   _1byteToCopy-JmpTbl&#13;
            .word   _2bytesToCopy-JmpTbl&#13;
            .word   _3bytesToCopy-JmpTbl&#13;
            .word   _4bytesToCopy-JmpTbl&#13;
            .word   _5bytesToCopy-JmpTbl&#13;
            .word   _6bytesToCopy-JmpTbl&#13;
            .word   _7bytesToCopy-JmpTbl&#13;
            .word   _8bytesToCopy-JmpTbl&#13;
            .word   _9bytesToCopy-JmpTbl&#13;
            .word   _10bytesToCopy-JmpTbl&#13;
            .word   _11bytesToCopy-JmpTbl&#13;
            .word   _12bytesToCopy-JmpTbl&#13;
            .word   _13bytesToCopy-JmpTbl&#13;
            .word   _14bytesToCopy-JmpTbl&#13;
            .word   _15bytesToCopy-JmpTbl&#13;
&#13;
// Special case copying 1-15 bytes:&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation8">❽</span> _14bytesToCopy:&#13;
            ldr     x7, [x0], #8&#13;
            str     x7, [x3], #8&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_841" aria-label="841"/>_6bytesToCopy:&#13;
            ldr     w7, [x0], #4&#13;
            str     w7, [x3], #4&#13;
&#13;
_2bytesToCopy:&#13;
            ldrh    w7, [x0], #2&#13;
            strh    w7, [x3], #2&#13;
            b.al    str.sub.success&#13;
&#13;
_13bytesToCopy:&#13;
            ldr     x7, [x0], #8&#13;
            str     x7, [x3], #8&#13;
&#13;
_5bytesToCopy:&#13;
            ldr     w7, [x0], #4&#13;
            str     w7, [x3], #4&#13;
            ldrb    w7, [x0], #1&#13;
            strb    w7, [x3], #1&#13;
            b.al    str.sub.success&#13;
&#13;
_12bytesToCopy:&#13;
            ldr     x7, [x0], #8&#13;
            str     x7, [x3], #8&#13;
&#13;
_4bytesToCopy:&#13;
            ldr     w7, [x0], #4&#13;
            str     w7, [x3], #4&#13;
            b.al    str.sub.success&#13;
&#13;
_11bytesToCopy:&#13;
            ldr     x7, [x0], #8&#13;
            str     x7, [x3], #8&#13;
            ldrh    w7, [x0], #2&#13;
            strh    w7, [x3], #2&#13;
            ldrb    w7, [x0], #1&#13;
            strb    w7, [x3], #1&#13;
            b.al    str.sub.success&#13;
&#13;
_10bytesToCopy:&#13;
            ldr     x7, [x0], #8&#13;
            str     x7, [x3], #8&#13;
            ldrh    w7, [x0], #2&#13;
            strh    w7, [x3], #2&#13;
            b.al    str.sub.success&#13;
&#13;
_9bytesToCopy:&#13;
            ldr     x7, [x0], #8&#13;
            str     x7, [x3], #8&#13;
            ldrb    w7, [x0], #1&#13;
            strb    w7, [x3], #1&#13;
            b.al    str.sub.success&#13;
&#13;
_8bytesToCopy:&#13;
            ldr     x7, [x0], #8&#13;
            str     x7, [x3], #8&#13;
            b.al    str.sub.success&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_842" aria-label="842"/>_15bytesToCopy:&#13;
            ldr     x7, [x0], #8&#13;
            str     x7, [x3], #8&#13;
&#13;
_7bytesToCopy:&#13;
            ldr     w7, [x0], #4&#13;
            str     w7, [x3], #4&#13;
&#13;
_3bytesToCopy:&#13;
            ldrh    w7, [x0], #2&#13;
            strh    w7, [x3], #2&#13;
&#13;
_1byteToCopy:&#13;
            ldrb    w7, [x0], #1&#13;
            strb    w7, [x3], #1&#13;
&#13;
// Branch here after copying all string data.&#13;
// Need to add a zero-terminating byte to the&#13;
// end of the destination string:&#13;
&#13;
str.sub.success:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> strb    wzr, [x3]       // Zero-terminating byte&#13;
            adds    wzr, wzr, wzr   // Clear carry for success.&#13;
&#13;
str.sub.exit:&#13;
            ldr     q0,     [fp, #str_substr.saveV0]&#13;
            ldp     x0, x1, [fp, #str_substr.saveX0X1]&#13;
            ldp     x2, x3, [fp, #str_substr.saveX2X3]&#13;
            ldp     x6, x7, [fp, #str_substr.saveX6X7]&#13;
            leave&#13;
&#13;
// Special case where the code just returns an empty string:&#13;
&#13;
returnEmpty:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation10">❿</span> strh    wzr, [x3, #string.len]&#13;
            b.al    str.sub.success&#13;
&#13;
            endp    str.substr&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// testSubstr&#13;
//&#13;
//  Utility function to test call to str.substr&#13;
//&#13;
// On entry:&#13;
//  X0, X1, X2, X3 -- str.substr parameters&#13;
&#13;
successStr: wastr   "substr('%s', %2d, %3d)= '%s'\n"&#13;
failureStr: wastr   "substr('%s', %2d, %3d) failed\n"&#13;
&#13;
            proc    testSubstr&#13;
&#13;
            locals  testSS&#13;
            byte    testSS.stkspace, 64&#13;
            endl    testSS&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_843" aria-label="843"/>            enter   testSS.size&#13;
&#13;
            lea     x5, successStr&#13;
            bl      str.substr&#13;
            bcc     success&#13;
            lea     x5, failureStr&#13;
&#13;
success:&#13;
            mov     x4, x3&#13;
            mov     x3, x2&#13;
            mov     x2, x1&#13;
            mov     x1, x0&#13;
            mov     x0, x5&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            mstr    x3, [sp, #16]&#13;
            mstr    x4, [sp, #24]&#13;
            bl      printf&#13;
            leave&#13;
            endp    testSubstr&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// Main program to test the code:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  lcl&#13;
            byte    stkSpace, 64&#13;
            endl    lcl&#13;
&#13;
            enter   lcl.size      // Reserve space for locals.&#13;
&#13;
            lea     x0, fmtStr&#13;
            lea     x1, source&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
            lea     x0, source&#13;
            mov     x1, #0&#13;
            mov     x2, #11&#13;
            lea     x3, dest&#13;
            bl      testSubstr&#13;
&#13;
            lea     x0, source&#13;
            mov     x1, #20&#13;
            mov     x2, #15&#13;
            lea     x3, dest&#13;
            bl      testSubstr&#13;
&#13;
            lea     x0, source&#13;
            mov     x1, #20&#13;
            mov     x2, #20&#13;
            lea     x3, dest&#13;
            bl      testSubstr&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_844" aria-label="844"/>            lea     x0, source&#13;
            mov     x1, #40&#13;
            mov     x2, #20&#13;
            lea     x3, dest&#13;
            bl      testSubstr&#13;
&#13;
            lea     x0, source&#13;
            mov     x1, #0&#13;
            mov     x2, #100&#13;
            lea     x3, smallDest&#13;
            bl      testSubstr&#13;
&#13;
AllDone:    leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> function begins by finding any special cases it must handle. It first checks whether the starting index value is beyond the end of the source string; if so, the function returns the empty string as the result <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Next, the code checks whether the starting index plus the substring length would extend beyond the end of the source string; if so, it adjusts the length to reach to the end of the source string (and no farther) <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, if the substring length is greater than the maximum length of the destination string, <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> immediately returns with the carry flag set to indicate an error condition <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">If none of the special cases exist, the code can successfully copy a substring into the destination string. <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> begins this process by setting the length of the destination string to the length of the substring <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The code then copies the substring data starting at the index position, beginning by adding the value of the index to the string pointer <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">The loop copies 16 bytes at a time using the V0 vector register (Q0) <span class="CodeAnnotation" aria-label="annotation6">❻</span>, as long as there are 16 or more bytes left to copy. When fewer than 16 bytes are left to copy, the code drops down to <span class="CodeAnnotation" aria-label="annotation7">❼</span> and adds 16 to the remaining length value (because the loop subtracted 16 one too many times).</p>&#13;
<p class="TX">After adding 16, W6 will contain a value in the range 0 to 15, the number of bytes left to copy. The code could have executed a simple loop to copy the remaining bytes one at a time to the destination, but that would be somewhat slow. Instead, I chose to execute a (simulated) switch statement to transfer control to one of 16 labels <span class="CodeAnnotation" aria-label="annotation8">❽</span> where the code exists to carry out a straight-line, brute-force copy of the necessary bytes. (To reduce code size, I’ve interleaved these sections as much as possible, sharing various code sequences.)</p>&#13;
<p class="TX">Once they copy the necessary number of bytes, all these code sequences converge <span class="CodeAnnotation" aria-label="annotation9">❾</span> (also the location where the switch code transfers if 0 bytes are left to copy). This code appends a zero-terminating byte to the end of the string, clears the carry flag, and returns to the caller.</p>&#13;
<p class="TX">The code handles the special case in which <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> returns an empty string because the index value was greater than the length of the source string <span class="CodeAnnotation" aria-label="annotation10">❿</span>. This code sets the length of the destination string to 0, then transfers to <span class="CodeAnnotation" aria-label="annotation9">❾</span> to zero-terminate the string and return success. The <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> function calls a special helper function (<span class="SANS_TheSansMonoCd_W5Regular_11">testSubstr</span>) to perform various tests and print the results.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_845" aria-label="845"/>It is very unlikely that the start of the substring will lie on a 16-byte boundary. Therefore, when the function in Listing 14-5 fetches 16 bytes at a time from the source string, it will probably be an unaligned memory access (which is slower). Without writing a lot of code, you can’t do much about this other than accept that execution will be slightly slower. Because the accesses may not be aligned on a 16-byte boundary, it is important that this code copies only the specified number of bytes (never reading beyond the end of the source string) to ensure it doesn’t access an inappropriate memory page.</p>&#13;
<p class="TX">Here is the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for the program in Listing 14-5:</p>&#13;
<pre id="pre-1146"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing14-5</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing14-5</span>&#13;
Calling Listing14-5:&#13;
Source string:&#13;
&#13;
          1111111111222222222233333&#13;
01234567890123456789012345678901234&#13;
Hello there, world! How's it going?&#13;
&#13;
substr('Hello there, world! How's it going?',  0,  11)= 'Hello there'&#13;
substr('Hello there, world! How's it going?', 20,  15)= 'How's it going?'&#13;
substr('Hello there, world! How's it going?', 20,  20)= 'How's it going?'&#13;
substr('Hello there, world! How's it going?', 40,  20)= ''&#13;
substr('Hello there, world! How's it going?',  0, 100) failed&#13;
Listing14-5 terminated</code></pre>&#13;
<p class="TX">While this isn’t an exhaustive test by any means, this output is sufficient to show the basic operation of <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-256"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.2.5 More String Functions</span></h4>&#13;
<p class="TNI1">Of course, any decent string library has many additional string functions. A <span class="SANS_TheSansMonoCd_W5Regular_11">str.len</span> function is the most obvious function missing thus far. The implementation of this function should be fairly obvious: just fetch the <span class="SANS_TheSansMonoCd_W5Regular_11">string.len</span> field from the string data structure. Even ignoring this oversight, however, there are dozens of other string functions you might want to use (the HLA standard library, for example, provides over 200 string functions).</p>&#13;
<p class="TX">Unfortunately, this book doesn’t have room to describe a complete set of string library functions. After reading this chapter, you should possess the skills needed to implement any string functions you need on your own. See section 14.6, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter14.xhtml#pg_859">page 859</a></span> for further resources to help you do so.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-147"/><span class="SANS_Futura_Std_Bold_B_11">14.3 The Unicode Character Set</span></h3>&#13;
<p class="TNI1">All code examples up to this point in this book have assumed that strings in assembly language consist of sequences of ASCII characters, largely because <span role="doc-pagebreak" epub:type="pagebreak" id="pg_846" aria-label="846"/>Gas doesn’t directly support Unicode. However, Linux and macOS systems generally work with Unicode (though ASCII is a subset of Unicode). Now that you’ve seen how to implement string functions for ASCII characters, it’s time to expand on <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>’s cursory introduction to Unicode and discuss string functions for Unicode strings.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-257"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.3.1 Unicode History</span></h4>&#13;
<p class="TNI1">A few decades back, engineers at Aldus Corporation, NeXT, Sun Microsystems, Apple Computer, IBM, Microsoft, the Research Libraries Group, and Xerox realized that their new computer systems with bitmaps and user-selectable fonts could display far more than 256 characters at one time. At the time, <i>double-byte character sets (DBCSs)</i> were the most common solution.</p>&#13;
<p class="TX">DBCSs had a couple of issues, however. First, as they were typically variable-length encodings, they required special library code; common character or string algorithms that depended on fixed-length character encodings would not work properly with them. Second, no consistent standard existed; different DBCSs used the same encoding for different characters.</p>&#13;
<p class="TX">To avoid these compatibility problems, the engineers sought a different solution. They came up with the Unicode character set, which originally used a 2-byte character size. Like DBCSs, this approach still required special library code (existing single-byte string functions would not always work with 2-byte characters). Other than changing the size of a character, however, most existing string algorithms would still work with 2-byte characters. The Unicode definition included all the (known or living) character sets at the time, giving each character a unique encoding, to avoid the consistency problems that plagued differing DBCSs.</p>&#13;
<p class="TX">The original Unicode standard used a 16-bit word to represent each character. Therefore, Unicode supported up to 65,536 character codes—a huge advance over the 256 possible codes representable with an 8-bit byte. Furthermore, Unicode is upward compatible from ASCII. If the HO 9 bits of a Unicode character’s binary representation contain 0, the LO 7 bits use the standard ASCII code. (ASCII is a 7-bit code, so if the HO 9 bits of a 16-bit Unicode value are all 0, the remaining 7 bits are an ASCII encoding for a character.) If the HO 9 bits contain a nonzero value, the 16 bits form an extended character code, above and beyond the ASCII character set.</p>&#13;
<p class="TX">You may be wondering why so many character codes are necessary. When Unicode was first being developed, certain Asian character sets contained 4,096 characters. The Unicode character set even provided codes you could use to create an application-defined character set. Approximately half of the 65,536 possible character codes have been defined, and the remaining character encodings are reserved for future expansion.</p>&#13;
<p class="TX">Today, Unicode is a universal character set, long replacing ASCII and older DBCSs. All modern OSes (including macOS, Windows, Linux, Pi OS, Android, and Unix), all web browsers, and most modern applications provide Unicode support. The Unicode Consortium, a nonprofit corporation, maintains the Unicode standard. By maintaining the standard, the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_847" aria-label="847"/>consortium helps guarantee that a character you write on one system will display as you expect on a different system or application.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-258"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.3.2 Code Points and Code Planes</span></h4>&#13;
<p class="TNI1">Alas, as well-thought-out as the original Unicode standard was, its creators couldn’t have anticipated the subsequent explosion in characters. Emojis, astrological symbols, arrows, pointers, and a wide variety of symbols introduced for the internet, mobile devices, and web browsers—along with a desire to support historic, obsolete, and rare scripts—have greatly expanded the Unicode symbol repertoire.</p>&#13;
<p class="TX">In 1996, systems engineers discovered that 65,536 symbols were insufficient. Rather than require 3 or 4 bytes for each Unicode character, those in charge of the Unicode definition gave up on trying to create a fixed-size representation of characters and allowed for opaque (and multiple) encodings of Unicode characters. Today, Unicode defines 1,112,064 code points, far exceeding the 2-byte capacity originally set aside for Unicode characters.</p>&#13;
<p class="TX">A Unicode <i>code point</i> is simply an integer value associated with a particular character symbol; you can think of it as the Unicode equivalent of the ASCII code for a character. The convention for Unicode code points is to specify the value in hexadecimal with a U+ prefix. For example, U+0041 is the Unicode code point for the letter A.</p>&#13;
<p class="TX">Blocks of 65,536 characters are known as a <i>multilingual plane</i> in Unicode. The first multilingual plane, U+000000 to U+00FFFF, roughly corresponds to the original 16-bit Unicode definition; the Unicode standard calls this the <i>Basic Multilingual Plane (BMP)</i>. Planes 1 (U+010000 to U+01FFFF), 2 (U+020000 to U+02FFFF), and 14 (U+0E0000 to U+0EFFFF) are supplementary planes. Plane 3 (U+030000 to U+03FFFF) is the <i>Tertiary Ideographic Plane</i> (see <i><a href="https://unicode.org/roadmaps/tip/">https://<wbr/>unicode<wbr/>.org<wbr/>/roadmaps<wbr/>/tip<wbr/>/</a></i>). Unicode reserves planes 4 through 13 for future expansion and planes 15 and 16 for user-defined character sets.</p>&#13;
<p class="TX">The Unicode standard defines code points in the range U+000000 to U+10FFFF. Note that 0x10ffff is 1,114,111, which is where most of the 1,112,064 characters in the Unicode character set come from; the remaining 2,048 values form the <i>surrogate code points</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-259"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.3.3 Surrogate Code Points</span></h4>&#13;
<p class="TNI1">As noted earlier, Unicode began life as a 16-bit (2-byte) character set encoding. When it became apparent that 16 bits were insufficient to handle all the possible characters that existed at the time, an expansion was necessary. As of Unicode v2.0, the Unicode Consortium extended the definition of Unicode to include multiword characters. Now Unicode uses surrogate code points (U+D800 through U+DFFF) to encode values larger than U+FFFF, as shown in <a href="chapter14.xhtml#fig14-1">Figure 14-1</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_848" aria-label="848"/>&#13;
<figure class="IMG"><img class="img1" id="fig14-1" src="../images/Figure14-1.jpg" alt="" width="1156" height="357"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 14-1: Surrogate code-point encoding for Unicode planes 1–16</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The two words, unit 1 (high surrogate) and unit 2 (low surrogate), always appear together. The unit 1 value with HO bits 0b110110 specifies the upper 10 bits (b10 through b19) of the Unicode scalar, and the unit 2 value with HO bits 0b110111 specifies the lower 10 bits (b0 through b9) of the Unicode scalar. Therefore, the value of bits b16 to b19 plus 1 specifies Unicode planes 1 through 16. Bits b0 through b15 specify the Unicode scalar value within the plane.</p>&#13;
<p class="TX">Note that surrogate codes appear only in the BMP. None of the other multilingual planes contain surrogate codes. Bits b0 through b19 extracted from the unit 1 and 2 values always specify a Unicode scalar value (even if the values fall in the range U+D800 through U+DFFF).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-260"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.3.4 Glyphs, Characters, and Grapheme Clusters</span></h4>&#13;
<p class="TNI1">Each Unicode code point has a unique name. For example, U+0045 has the name LATIN CAPITAL LETTER A. The symbol A is <i>not</i> the name of the character. A is a <i>glyph</i>, a series of strokes (one horizontal and two slanted strokes) that a device draws in order to represent the character.</p>&#13;
<p class="TX">Many glyphs exist for the single Unicode character LATIN CAPITAL LETTER A. For example, a Times Roman A and a Times Roman Italic A have different glyphs, but Unicode doesn’t differentiate between them (or between the A character in any two different fonts). The character LATIN CAPITAL LETTER A remains U+0045 regardless of the font or style you use to draw it.</p>&#13;
<p class="TX">The term <i>character</i> has a simple meaning when working with ASCII. The character code 0x41 corresponds to the LATIN CAPITAL LETTER A, which has a consistent representation when it appears on a display screen; in particular, a one-to-one correspondence exists between ASCII character codes and the symbol a user expects to see on the display. The situation is dramatically more complex when working with Unicode. There’s a difference between what you’d normally call a character and the definition of a Unicode character (<i>scalar</i> in Unicode terminology). For example, consider the following Swift code:</p>&#13;
<pre id="pre-1147"><code>import Foundation&#13;
let eAccent  :String = "e\u{301}"&#13;
print(eAccent)&#13;
print("eAccent.count=\(eAccent.count)")&#13;
print("eAccent.utf16.count=\(eAccent.utf16.count)")</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_849" aria-label="849"/>This section uses the Swift programming language for examples because it is one of the first programming languages that attempts to do Unicode right (though a huge performance hit results from it). Assembly, on the other hand, requires the programmer to handle everything manually and isn’t the best tool for many Unicode examples. I explain how to translate this to assembly code in section 14.4, <span class="Xref">“Unicode in Assembly Language,”</span> on <span class="Xref"><a href="chapter14.xhtml#pg_853">page 853</a></span>.</p>&#13;
<p class="TX">The Swift syntax for specifying a Unicode scalar value within a string is <span class="SANS_TheSansMonoCd_W5Regular_11">"\u{</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">hex</span><span class="SANS_TheSansMonoCd_W5Regular_11">}"</span>, where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">hex</span> is a hexadecimal value, as in <span class="SANS_TheSansMonoCd_W5Regular_11">"\u{301}"</span>. In this example, <span class="SANS_TheSansMonoCd_W5Regular_11">301</span> is the hexadecimal code for the <i>combining acute accent</i> character. The first <span class="SANS_TheSansMonoCd_W5Regular_11">print()</span> statement prints the character, producing <span class="SANS_TheSansMonoCd_W5Regular_11">é</span> on the output, as you expect. The second <span class="SANS_TheSansMonoCd_W5Regular_11">print()</span> statement prints the number of characters Swift determines are present in the string—in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>. The third <span class="SANS_TheSansMonoCd_W5Regular_11">print()</span> statement prints the number of elements (UTF-16 elements, discussed further later in this section) in the string. In this case, that number is <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>, because the string holds 2 words of UTF-16 data.</p>&#13;
<p class="TX">In this example, is <span class="accent">é</span> one character or two? Internally (assuming UTF-16 encoding), the computer sets aside 4 bytes of memory for this single character (two 16-bit Unicode scalar values). On the screen, however, the output takes only one character position and looks like a single character to the user. When this character appears within a text editor and the cursor is immediately to the right of the character, the user expects that pressing <small>BACKSPACE</small> will delete it. From the user’s perspective, then, this is a single character (as Swift reports when you print the count attribute of the string).</p>&#13;
<p class="TX">In Unicode, however, a <i>character</i> is largely equivalent to a code point. In Unicode terminology, when you talk about symbols that an application displays to an end user, you refer to them not as characters but as <i>grapheme clusters</i>. These are sequences of one or more Unicode code points that combine to form a single language element (that is, something that appears as a single character to the user on the display, such as <span class="accent">é</span>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-261"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.3.5 Normal Forms and Canonical Equivalence</span></h4>&#13;
<p class="TNI1">The Unicode character <span class="accent">é</span> actually existed on personal computers long before Unicode came along: it’s part of the original IBM PC character set and of the Latin-1 character set (used, for example, on old DEC terminals). Unicode uses the Latin-1 character set for the code points in the range U+00A0 to U+00FF, and U+00E9 just happens to correspond to the <span class="accent">é</span> character. Therefore, you can modify the earlier program as follows:</p>&#13;
<pre id="pre-1148"><code>import Foundation&#13;
let eAccent  :String = "\u{E9}"&#13;
print(eAccent)&#13;
print("eAccent.count=\(eAccent.count)")&#13;
print("eAccent.utf16.count=\(eAccent.utf16.count)")</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_850" aria-label="850"/>The outputs from this program are as follows:</p>&#13;
<pre id="pre-1149"><code>é&#13;
eAccent.count=1&#13;
eAccent.utf16.count=1</code></pre>&#13;
<p class="TX">Ouch! You now have a couple of strings that all produce <span class="accent">é</span> but contain a different number of code points. Imagine how this complicates programming strings containing Unicode characters. For example, if you try to compare the following three strings (Swift syntax), what will the result be?</p>&#13;
<pre id="pre-1150"><code>let eAccent1 :String = "\u{E9}"&#13;
let eAccent2 :String = "e\u{301}"</code></pre>&#13;
<p class="TX">To the user, both strings look the same on the screen. However, they clearly contain different values. If you compare them to see whether they are equal, will the result be true or false?</p>&#13;
<p class="TX">Ultimately, that depends on which string libraries you’re using. Most current string libraries would return false if you compared these strings for equality. Many languages’ string libraries simply report that both strings are unequal.</p>&#13;
<p class="TX">The two Unicode/Swift strings <span class="SANS_TheSansMonoCd_W5Regular_11">"\{E9}"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"e\{301}"</span> should produce the same output on the display. Therefore, they are canonically equivalent according to the Unicode standard. Some string libraries won’t report any of these strings as being equivalent. Some, like the one accompanying Swift, will handle small canonical equivalences (such as <span class="SANS_TheSansMonoCd_W5Regular_11">"\{E9}" == "e\{301}"</span>) but not arbitrary sequences that should be equivalent. (This is probably a good balance of correctness versus efficiency; it can be computationally expensive to handle all the weird cases that won’t normally happen, such as <span class="SANS_TheSansMonoCd_W5Regular_11">"e\{301}\{301}"</span>.)</p>&#13;
<p class="TX">Unicode defines <i>normal forms</i> for Unicode strings. One aspect of normal form is to replace canonically equivalent sequences with an equivalent sequence—for example, replace <span class="SANS_TheSansMonoCd_W5Regular_11">"e\u{309}"</span> with <span class="SANS_TheSansMonoCd_W5Regular_11">"\u{E9}"</span> or vice versa (the shorter form is usually preferable). Some Unicode sequences allow multiple combining characters. Often, the order of the combining characters is irrelevant to producing the desired grapheme cluster. However, comparing two such characters is easier if the combining characters are in a specified order. Normalizing Unicode strings may also produce results whose combining characters always appear in a fixed order, thereby improving the efficiency of string comparisons.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-262"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.3.6 Encodings</span></h4>&#13;
<p class="TNI1">As of Unicode 2.0, the standard supports a 21-bit character space capable of handling over a million characters (though most of the code points remain reserved for future use). Rather than use a fixed-size 3-byte (or worse, 4-byte) encoding to allow the larger character set, the Unicode Consortium allows different encodings: UTF-32, UTF-16, and UTF-8 (<i>UTF</i> stands for <span role="doc-pagebreak" epub:type="pagebreak" id="pg_851" aria-label="851"/><i>Unicode Transformation Format</i>). Each of these three encodings comes with advantages and disadvantages.</p>&#13;
<p class="TX"><i>UTF-32</i> uses 32-bit integers to hold Unicode scalars. The advantage to this scheme is that a 32-bit integer can represent every Unicode scalar value in only 21 bits. Programs that require random access to characters in strings—without having to search for surrogate pairs—and other constant-time operations are usually possible when using UTF-32. The obvious drawback to UTF-32 is that each Unicode scalar value requires 4 bytes of storage—twice that of the original Unicode definition and four times that of ASCII characters.</p>&#13;
<p class="TX">It may seem that using two or four times as much storage (over ASCII and the original Unicode) is a small price to pay. After all, modern machines have several orders of magnitude more storage than they did when Unicode first appeared. However, that extra storage has a huge impact on performance, because those additional bytes quickly consume cache storage. Furthermore, modern string-processing libraries often operate on character strings 8 bytes at a time (on 64-bit machines). With ASCII characters, that means a given string function can process up to eight characters concurrently; with UTF-32, that same string function can operate on only two characters concurrently. As a result, the UTF-32 version will run four times slower than the ASCII version. Ultimately, even Unicode scalar values are insufficient to represent all Unicode characters (that is, many Unicode characters require a sequence of Unicode scalars), so using UTF-32 doesn’t solve the problem.</p>&#13;
<p class="TX">As the name suggests, the second encoding format that Unicode supports, <i>UTF-16</i>, uses 16-bit (unsigned) integers to represent Unicode values. To handle scalar values greater than 0xFFFF, UTF-16 uses the surrogate-pair scheme to represent values in the range 0x010000 to 0x10FFFF. Because the vast majority of useful characters fit into 16 bits, most UTF-16 characters require only 2 bytes. For those rare cases where surrogates are necessary, UTF-16 requires two words (32 bits) to represent the character.</p>&#13;
<p class="TX">The last encoding, and unquestionably the most popular, is <i>UTF-8</i>. The UTF-8 encoding is forward-compatible from the ASCII character set. In particular, all ASCII characters have a single-byte representation (their original ASCII code, where the HO bit of the byte containing the character contains a 0 bit). If the UTF-8 HO bit is 1, UTF-8 requires 1 to 3 additional bytes to represent the Unicode code point.</p>&#13;
<p class="TX"><a href="chapter14.xhtml#tab14-1">Table 14-1</a> provides the UTF-8 encoding schema, where the <i>x</i> bits are the Unicode point bits.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab14-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 14-1:</span></span> <span class="SANS_Futura_Std_Book_11">UTF-8 Encoding</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Bytes</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Bits for code point</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">First code point</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Last code point</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Byte 1</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Byte 2</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Byte 3</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Byte 4</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">7</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">U+00</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">U+7F</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span><span class="SANS_Futura_Std_Book_Oblique_11">xxxxxxx</span></p></td>&#13;
<td class="TBF"/>&#13;
<td class="TBF"/>&#13;
<td class="TBF"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">11</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">U+80</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">U+7FF</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">110</span><span class="SANS_Futura_Std_Book_Oblique_11">xxxxx</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10</span><span class="SANS_Futura_Std_Book_Oblique_11">xxxxxx</span></p></td>&#13;
<td class="TB"/>&#13;
<td class="TB"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">16</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">U+800</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">U+FFFF</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1110</span><span class="SANS_Futura_Std_Book_Oblique_11">xxxx</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10</span><span class="SANS_Futura_Std_Book_Oblique_11">xxxxxx</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10</span><span class="SANS_Futura_Std_Book_Oblique_11">xxxxxx</span></p></td>&#13;
<td class="TB"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">4</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">21</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">U+10000</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">U+10FFFF</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">11110</span><span class="SANS_Futura_Std_Book_Oblique_11">xxx</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10</span><span class="SANS_Futura_Std_Book_Oblique_11">xxxxxx</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10</span><span class="SANS_Futura_Std_Book_Oblique_11">xxxxxx</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">10</span><span class="SANS_Futura_Std_Book_Oblique_11">xxxxxx</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_852" aria-label="852"/>For multibyte sequences, byte 1 contains the HO bits, byte 2 contains the next HO bits (LO bits compared to byte 1), and so on. For example, the 2-byte sequence (0b11011111, 0b10000001) corresponds to the Unicode scalar 0b0000_0111_1100_0001 (U+07C1).</p>&#13;
<p class="TX">UTF-8 encoding is probably the most common encoding in use, since most web pages use it. Most C stdlib string functions will operate on UTF-8 text without modification (although some can produce malformed UTF-8 strings if the programmer isn’t careful).</p>&#13;
<p class="TX">Different languages and OSes default to using different encodings. For example, macOS and Windows tend to use UTF-16 encoding, whereas most Unix systems use UTF-8. Some variants of Python use UTF-32 as their native character format. By and large, though, most programming languages use UTF-8 because they can continue to use older ASCII-based character-processing libraries to process UTF-8 characters.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-263"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.3.7 Combining Characters</span></h4>&#13;
<p class="TNI1">Although UTF-8 and UTF-16 encodings are much more compact than UTF-32, the CPU overhead and algorithmic complexities of dealing with multibyte (or multiword) character sets complicates their use, introducing bugs and performance issues. Despite the issues of wasting memory, especially in the cache, why not simply define characters as 32-bit entities and be done with it? This seems like it would simplify string-processing algorithms, improving performance and reducing the likelihood of defects in the code.</p>&#13;
<p class="TX">The problem with this theory is that you cannot represent all possible grapheme clusters with only 21 bits (or even 32 bits) of storage. Many grapheme clusters consist of several concatenated Unicode code points. Here’s an example from Chris Eidhof and Ole Begemann’s <i>Advanced Swift</i>, version 3.0 (CreateSpace, 2017):</p>&#13;
<pre id="pre-1151"><code>let chars: [Character] = [&#13;
    "\u{1ECD}\u{300}",&#13;
    "\u{F2}\u{323}",&#13;
    "\u{6F}\u{323}\u{300}",&#13;
]&#13;
print(chars)</code></pre>&#13;
<p class="TX">Each of these Unicode grapheme clusters produces the same output: <small>Ò</small><span class="accent1">.</span>, (a character from the Yoruba character set). The character sequence <span class="SANS_TheSansMonoCd_W5Regular_11">(U+1ECD, U+300)</span> is an <span class="accent">o</span><span class="accent1">.</span> followed by a combining acute. The character sequence <span class="SANS_TheSansMonoCd_W5Regular_11">(U+F2, U+323)</span> is an <span class="accent">ò</span> followed by a combining dot. The character sequence <span class="SANS_TheSansMonoCd_W5Regular_11">(U+6F, U+323, U+300)</span> is an o followed by a combining dot, followed by a combining acute.</p>&#13;
<p class="TX">The Swift string comparisons treat all four strings as equal:</p>&#13;
<pre id="pre-1152"><code>print("\u{1ECD} + \u{300} = \u{1ECD}\u{300}")&#13;
print("\u{F2} + \u{323} = \u{F2}\u{323}")&#13;
print("\u{6F} + \u{323} + \u{300} = \u{6F}\u{323}\u{300}")&#13;
print("\u{6F} + \u{300} + \u{323} = \u{6F}\u{300}\u{323}")&#13;
print(chars[0] == chars[1]) // Outputs true.&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_853" aria-label="853"/>Print(chars[0] == chars[2]) // Outputs true.&#13;
print(chars[0] == chars[3]) // Outputs true.&#13;
Print(chars[1] == chars[2]) // Outputs true.&#13;
print(chars[1] == chars[3]) // Outputs true.&#13;
Print(chars[2] == chars[3]) // Outputs true.</code></pre>&#13;
<p class="TX">No single Unicode scalar value will produce this character. You must combine at least two Unicode scalars (or as many as three) to produce this grapheme cluster on the output device. Even UTF-32 encoding would still require two (32-bit) scalars to produce this particular output.</p>&#13;
<p class="TX">Emojis present another challenge that can’t be solved using UTF-32. Consider the Unicode scalar U+1F471. This prints an emoji of a person with blond hair. If you add a skin-color modifier, you obtain <span class="SANS_TheSansMonoCd_W5Regular_11">(U+1F471, U+1F3FF)</span>, which produces a person with a dark skin tone and blond hair. In both cases, a single character displays on the screen. The first example uses a single Unicode scalar value, but the second example requires two. There is no way to encode this with a single UTF-32 value.</p>&#13;
<p class="TX">The bottom line is that certain Unicode grapheme clusters require multiple scalars, no matter how many bits you assign to the scalar (it’s possible to combine 30 or 40 scalars into a single grapheme cluster, for example). That means you’re stuck dealing with multiword sequences to represent a single “character,” regardless of how hard you try to avoid it. This is why UTF-32 has never really taken off: it doesn’t solve the problem of random access into a string of Unicode characters. When normalizing and combining Unicode scalars, using UTF-8 or UTF-16 encodings is more efficient.</p>&#13;
<p class="TX">Again, most languages and OSes today support Unicode in one form or another (typically using UTF-8 or UTF-16 encoding). Despite the obvious problems with dealing with multibyte character sets, modern programs need to deal with Unicode strings rather than simple ASCII strings.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h1-148"/><span class="SANS_Futura_Std_Bold_B_11">14.4 Unicode in Assembly Language</span></h3>&#13;
<p class="TNI1">As noted in section 2.17, <span class="Xref">“Gas Support for the Unicode Character Set,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_102">page 102</a></span>), Gas doesn’t provide especially good support for Unicode strings. If you have a text editor that allows you to enter Unicode text into a source file, you might be able to type non-ASCII UTF-8 characters into a string constant and have Gas accept them. In general, though, the safest way to insert non-ASCII Unicode characters into an assembly language source file is to use hexadecimal constants. This section describes how to output Unicode characters from a console application and provides a brief introduction to Unicode string functions.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-264"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.4.1 Writing Console Applications with UTF-8 Characters</span></h4>&#13;
<p class="TNI1">To be able to print strings containing UTF-8 characters, you must ensure that your OS is able to accept them. This is generally accomplished by using <span role="doc-pagebreak" epub:type="pagebreak" id="pg_854" aria-label="854"/>the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">setlocale()</span> function. Unfortunately, the parameter list varies by locale, so I can’t provide a universal example that works everywhere. For US English, I typically use the following function call:</p>&#13;
<pre id="pre-1153"><code>setlocale(LC_ALL, "en_US.UTF-8");</code></pre>&#13;
<p class="TX">The exact string for the second parameter will vary based on the country and language. You can search online for a description of the <span class="SANS_TheSansMonoCd_W5Regular_11">setlocale()</span> function for more details about calling this function (or see section 14.6, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter14.xhtml#pg_859">page 859</a></span>). The following Linux/macOS command will list the available locale strings for your system:</p>&#13;
<pre id="pre-1154"><code>locale -a</code></pre>&#13;
<p class="TX">Here are some of the strings produced by this command under macOS (on a Mac mini M1):</p>&#13;
<pre id="pre-1155"><code>C                   en_NZ.ISO8859-1     it_IT&#13;
POSIX               en_NZ.ISO8859-15    it_IT.ISO8859-1&#13;
af_ZA               en_NZ.US-ASCII      it_IT.ISO8859-15&#13;
af_ZA.ISO8859-1     en_NZ.UTF-8         it_IT.UTF-8&#13;
af_ZA.ISO8859-15    en_US               ja_JP&#13;
&#13;
<var>Many entries snipped ...</var>&#13;
&#13;
zh_TW.Big5&#13;
zh_TW.UTF-8</code></pre>&#13;
<p class="TX">See <span class="Xref">“For More Information”</span> for an explanation of the locale string format.</p>&#13;
<p class="TX">You could call <span class="SANS_TheSansMonoCd_W5Regular_11">setlocale()</span> from your assembly language code, but I’ve found it more convenient to modify the <i>c.cpp</i> program that the <i>build</i> script uses. The following shows this modification:</p>&#13;
<pre id="pre-1156"><code>// c-utf8.cpp&#13;
//&#13;
// (Rename to c.cpp to use with build script.)&#13;
//&#13;
// Generic C++ driver program to demonstrate returning function&#13;
// results from assembly language to C++. Also includes a&#13;
// "readLine" function that reads a string from the user and&#13;
// passes it on to the assembly language code.&#13;
//&#13;
// Need to include stdio.h so this program can call "printf"&#13;
// and stdio.h so this program can call strlen.&#13;
&#13;
#include &lt;errno.h&gt;&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;locale.h&gt;&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_855" aria-label="855"/>// extern "C" namespace prevents "name mangling" by the C++&#13;
// compiler.&#13;
&#13;
extern "C"&#13;
{&#13;
    // asmMain is the assembly language code's "main program":&#13;
&#13;
    void asmMain(void);&#13;
&#13;
    // getTitle returns a pointer to a string of characters&#13;
    // from the assembly code that specifies the title of that&#13;
    // program (which makes this program generic and usable&#13;
    // with a large number of sample programs in "The Art of&#13;
    // ARM Assembly Language").&#13;
&#13;
    char *getTitle(void);&#13;
&#13;
    // C++ function that the assembly&#13;
    // language program can call:&#13;
&#13;
    int readLine(char *dest, int maxLen);&#13;
&#13;
};&#13;
&#13;
// readLine reads a line of text from the user (from the&#13;
// console device) and stores that string into the destination&#13;
// buffer the first argument specifies. Strings are limited in&#13;
// length to the value specified by the second argument&#13;
// (minus 1).&#13;
//&#13;
// This function returns the number of characters actually&#13;
// read, or -1 if there was an error.&#13;
//&#13;
// Note that if the user enters too many characters (maxlen or&#13;
// more), this function returns only the first maxlen - 1&#13;
// characters. This is not considered an error.&#13;
&#13;
int readLine(char *dest, int maxLen)&#13;
{&#13;
    // Note: fgets returns NULL if there was an error, else&#13;
    // it returns a pointer to the string data read (which&#13;
    // will be the value of the dest pointer).&#13;
&#13;
    char *result = fgets(dest, maxLen, stdin);&#13;
    if(result != NULL)&#13;
    {&#13;
        // Wipe out the newline character at the&#13;
        // end of the string:&#13;
&#13;
        int len = strlen(result);&#13;
        if(len &gt; 0)&#13;
        {&#13;
            dest[len - 1] = 0;&#13;
        }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_856" aria-label="856"/>        return len;&#13;
    }&#13;
    return -1; // If there was an error&#13;
}&#13;
&#13;
int main(void)&#13;
{&#13;
    // Get the assembly language program's title:&#13;
&#13;
    char *title = getTitle();&#13;
&#13;
    setlocale(LC_ALL, "en_US.UTF-8");&#13;
    asmMain();&#13;
    printf("%s terminated\n", title);&#13;
}</code></pre>&#13;
<p class="TX">Listing 14-6 presents a trivial program that demonstrates example text output containing UTF-8, to be compiled and linked with <i>c-utf8.cpp</i>. This example prints the UTF-8 sequence U+65 (lowercase e) followed by U+301 (combining acute accent character).</p>&#13;
<pre id="pre-1157"><code>// Listing14-6.S&#13;
//&#13;
// Simple program to demonstrate UTF-8 output&#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
            .data&#13;
fmtStr:     .ascii  "Unicode='"&#13;
&#13;
            // e followed by U+301 (0xCC, 0x81 in UTF-8)&#13;
&#13;
            .ascii  "e"&#13;
            .byte   0xCC, 0x81&#13;
&#13;
            .asciz  "'\n"&#13;
&#13;
            .code&#13;
ttlStr:     wastr  "Listing14-6.S"&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  lcl&#13;
            qword   saveX20_X21&#13;
            byte    stkSpace, 64&#13;
            endl    lcl&#13;
&#13;
            enter   lcl.size      // Reserve space for locals.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_857" aria-label="857"/>            lea     x0, fmtStr&#13;
            bl      printf&#13;
&#13;
AllDone:    leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">Note that the UTF-8 encoding for U+301 requires 2 bytes</p>&#13;
<pre id="pre-1158"><code>1 1 0 b<span class="TheSansMonoCd_W5Regular_SUB">11</span> b<span class="TheSansMonoCd_W5Regular_SUB">10</span> b<span class="TheSansMonoCd_W5Regular_SUB">9</span> b<span class="TheSansMonoCd_W5Regular_SUB">8</span> b<span class="TheSansMonoCd_W5Regular_SUB">7</span>,    1 0 b<span class="TheSansMonoCd_W5Regular_SUB">6</span> b<span class="TheSansMonoCd_W5Regular_SUB">5</span> b<span class="TheSansMonoCd_W5Regular_SUB">4</span> b<span class="TheSansMonoCd_W5Regular_SUB">3</span> b<span class="TheSansMonoCd_W5Regular_SUB">2</span> b<span class="TheSansMonoCd_W5Regular_SUB">1</span> b<span class="TheSansMonoCd_W5Regular_SUB">0</span></code></pre>&#13;
<p class="Continued1">where B<sub>11</sub> down to B<sub>0</sub> is 0x301 or 0b011_0000_0001. Therefore, the two UTF-8 bytes are 0b1100_1100 (0xCC) and 0b10000001 (0x81).</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 14-6 (assuming that <i>c-utf8.cpp</i> has been renamed to <i>c.cpp</i>):</p>&#13;
<pre id="pre-1159"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing14-6</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing14-6</span>&#13;
Unicode='é'&#13;
Listing14-6.S terminated</code></pre>&#13;
<p class="TX">As you can see, the character sequence <span class="SANS_TheSansMonoCd_W5Regular_11">e</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">0xcc</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">0x89</span> produces the accented <span class="SANS_TheSansMonoCd_W5Regular_11">é</span> character.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-265"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">14.4.2 Using Unicode String Functions</span></h4>&#13;
<p class="TNI1">As long as you stick with UTF-8 encoding, character string functions that operate on ASCII strings will <i>mostly</i> work with Unicode strings. You should be aware of a few issues, though:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Unless you keep strings in a canonical form, some string comparisons may report that two strings are not equal when, in fact, they would appear equal to the reader.</li>&#13;
<li class="BL">String comparison for <i>less than</i> and <i>greater than</i> will likely produce nonintuitive results because ASCII comparisons don’t work well in the face of Unicode scalars whose values consume 2 or more bytes.</li>&#13;
<li class="BL">A string-length calculation (when using zero-terminated or the assembly language string data type) will report the number of <i>bytes</i> in the string, not the number of characters (scalars or glyphs). Unless the string contains only ASCII characters, the length calculation will be wrong. The only reasonable way to count characters in a Unicode string is to process each glyph one at a time and count the glyphs.</li>&#13;
<li class="BL">Functions that accept indices into a string generally require glyph indices, not byte indices. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> function given earlier could extract a substring containing a portion of a glyph at the beginning of the string, or chop a glyph in half at the end of the string, if the index and length parameters aren’t carefully chosen. Functions that insert glyphs into a string or delete characters from a string will suffer from this same problem.</li>&#13;
</ul>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_858" aria-label="858"/>Because of these issues (and more), it’s dangerous to use ASCII-based string functions on Unicode and UTF-8 strings. It goes without saying that ASCII-based functions will not work on UTF-16 or UTF-32 encodings of Unicode characters.</p>&#13;
<p class="TX">Section 14.6, <span class="Xref">“For More Information,”</span> on <span class="Xref">the next page</span> provides links to several string libraries (mostly written on C/C++) that process Unicode strings. The International Components for Unicode (UCI) library is important to consider, since it’s the library provided by the Unicode Consortium. At the time of writing, this library (ICU74.2) claims the following support:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The latest version of the Unicode standard</li>&#13;
<li class="BL">Character set conversions with support for over 220 code pages</li>&#13;
<li class="BL">Locale data for more than 300 locales</li>&#13;
<li class="BL">Language-sensitive text collation (sorting) and searching based on the Unicode Collation Algorithm (ISO 14651)</li>&#13;
<li class="BL">Regular expression matching and Unicode sets</li>&#13;
<li class="BL">Transformations for normalization, upper- and lowercase, script transliterations (50+ pairs)</li>&#13;
<li class="BL">Resource bundles for storing and accessing localized information</li>&#13;
<li class="BL">Date/number/message formatting and parsing of culture-specific input/output formats</li>&#13;
<li class="BL">Calendar-specific date and time manipulation</li>&#13;
<li class="BL">Text boundary analysis for finding character, word, and sentence boundaries</li>&#13;
</ul>&#13;
<p class="TX">Although this isn’t a complete set of string functions you’d expect in a typical programming language, it does provide all the basic operations needed to correctly implement a full set of functions. Also keep in mind that Unicode string functions aren’t particularly fast. Unfortunately, because of the design of the Unicode character set (and multibyte character sets in general), you have to process each and every character in a string to accomplish mundane tasks. Only a few functions, like <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy</span>, can work without scanning over every character in the string.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1" id="sec19"><span id="h1-149"/><span class="SANS_Futura_Std_Bold_B_11">14.5 Moving On</span></h3>&#13;
<p class="TNI1">This chapter covered string data structures (zero-terminated and special assembly language strings), calling C stdlib string functions from assembly, writing assembly language–based string functions, and using the Unicode character set (and Unicode string functions).</p>&#13;
<p class="TX">The next chapter discusses managing large projects in assembly language, particularly how to create library modules, which will prove useful for combining several string functions into a single library module.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_859" aria-label="859"/>&#13;
<h3 class="H1" id="sec20"><span id="h1-150"/><span class="SANS_Futura_Std_Bold_B_11">14.6 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">The official Unicode website is the main source for information about all things concerning the Unicode standard. This is the closest thing to an official Unicode library: <i><a href="https://icu.unicode.org/home">https://<wbr/>icu<wbr/>.unicode<wbr/>.org<wbr/>/home</a></i>.</li>&#13;
<li class="BL">GNU offers a Unicode string library at <i><a href="https://www.gnu.org/software/libunistring/manual/libunistring.html">https://<wbr/>www<wbr/>.gnu<wbr/>.org<wbr/>/software<wbr/>/libunistring<wbr/>/manual<wbr/>/libunistring<wbr/>.html</a></i>.</li>&#13;
<li class="BL">You can find the source code for the functions from the GNU C stdlib for AARCH64 discussed in this chapter at <i><a href="https://github.com/bminor/glibc/tree/master/sysdeps/aarch64">https://<wbr/>github<wbr/>.com<wbr/>/bminor<wbr/>/glibc<wbr/>/tree<wbr/>/master<wbr/>/sysdeps<wbr/>/aarch64</a></i>.</li>&#13;
<li class="BL">For the GitHub repository containing the source code for the glibc string functions written in ARM assembly, see <i><a href="https://github.com/ARM-software/optimized-routines/tree/master/string/aarch64">https://<wbr/>github<wbr/>.com<wbr/>/ARM<wbr/>-software<wbr/>/optimized<wbr/>-routines<wbr/>/tree<wbr/>/master<wbr/>/string<wbr/>/aarch64</a></i>. You can study this code to learn advanced string-handling tricks in assembly language.</li>&#13;
<li class="BL">For help writing ARM string-handling functions in assembly language, you can post questions to a forum I’ve set up at <i><a href="https://forums.randallhyde.com">https://<wbr/>forums<wbr/>.randallhyde<wbr/>.com</a></i>.</li>&#13;
<li class="BL">For a list of various Unicode string libraries, see <i><a href="https://unicodebook.readthedocs.io/libraries.html#libunistring">https://<wbr/>unicodebook<wbr/>.readthedocs<wbr/>.io<wbr/>/libraries<wbr/>.html#libunistring</a></i>.</li>&#13;
<li class="BL">Wikipedia offers more detail on Unicode code points at <i><a href="https://en.wikipedia.org/wiki/Unicode#General_Category_property">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Unicode#General<wbr/>_Category<wbr/>_property</a></i>.</li>&#13;
<li class="BL">My website links to information on the HLA string library (x86): <i><a href="https://www.randallhyde.com/AssemblyLanguage/HighLevelAsm/HLADoc/index.html">https://<wbr/>www<wbr/>.randallhyde<wbr/>.com<wbr/>/AssemblyLanguage<wbr/>/HighLevelAsm<wbr/>/HLADoc<wbr/>/index<wbr/>.html</a></i>.</li>&#13;
<li class="BL">ARM Developer assembly language string library source code can be found at <i><a href="https://developer.arm.com/documentation/102620/0100/Optimized-string-routines---libastring">https://<wbr/>developer<wbr/>.arm<wbr/>.com<wbr/>/documentation<wbr/>/102620<wbr/>/0100<wbr/>/Optimized<wbr/>-string<wbr/>-routines<wbr/>-<wbr/>-<wbr/>-libastring</a></i>.</li>&#13;
<li class="BL">For more on the <span class="SANS_TheSansMonoCd_W5Regular_11">setlocale()</span> function, see <i><a href="https://man7.org/linux/man-pages/man3/setlocale.3.html">https://<wbr/>man7<wbr/>.org<wbr/>/linux<wbr/>/man<wbr/>-pages<wbr/>/man3<wbr/>/setlocale<wbr/>.3<wbr/>.html</a></i>. For an explanation of the locale string format, see <i><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html">https://<wbr/>docs<wbr/>.oracle<wbr/>.com<wbr/>/javase<wbr/>/8<wbr/>/docs<wbr/>/api<wbr/>/java<wbr/>/util<wbr/>/Locale<wbr/>.html</a></i> (or search for <b>locale function</b>).</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-34">&#13;
<p class="BH" id="box-34"><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  What is a zero-terminated string?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  Why are zero-terminated string functions so slow (in general)?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  How does the string assembly language type presented in this chapter generally improve the performance of string functions? Name at least three reasons.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  Why can’t the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> <span class="SANS_Futura_Std_Book_11">function copy the source data on a 16-byte boundary?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  Why are most Unicode string functions intrinsically slow?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>