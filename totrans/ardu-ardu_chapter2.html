<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch2" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch2">
<span class="CN"><span aria-label=" Page 13. " epub:type="pagebreak" id="pg_13" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">PORT MANIPULATION</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">This chapter introduces <i>port manipulation</i>, the process of simultaneously addressing your Arduino’s digital input and output pins to increase the speed of controlling or reading their statuses. Doing so reduces the <i>response time</i>, or the time required for a digital read or write to complete, thus increasing the sketch’s speed of operation. Port manipulation also uses less code than normal digital write/read functions, reducing the size of your sketch, which comes in handy when you hit the upper limits of your Arduino’s memory constraints.</p>
<p class="TX">In this chapter, you’ll learn to:</p>
<ul class="ul">
<li class="BL">Use port manipulation to rapidly control digital outputs</li>
<li class="BL">Control seven-segment LED displays</li>
<li class="BL"><span aria-label=" Page 14. " epub:type="pagebreak" id="pg_14" role="doc-pagebreak"/>Read multiple digital input pins simultaneously</li>
<li class="BL">Read binary-coded decimal (BCD) switches</li>
</ul>
<p class="TX">Along the way, you’ll build a binary number display, a light-emitting diode (LED) blinking wave, and a single-digit LED die. The instructions in this chapter are for an Arduino Uno or compatible board, original Nano, or other Arduino-compatible with an ATmega328-series microcontroller.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-11"/><samp class="SANS_Futura_Std_Bold_B_11">Ports, Pins, and Registers</samp></h2>
<p class="TNI">A <i>port</i> is a collection of sequential I/O pins. Each has a <i>register</i> (a section of memory inside the microcontroller), which is written to control the output status or read from if the pin status is set to an input. You use another register—the data direction register (DDR)—to set pins in a port as inputs or outputs.</p>
<p class="TX"><a href="chapter2.xhtml#fig2-1">Figure 2-1</a> shows the pins and the ports in which they are grouped. Port B consists of digital pins D13 through D8, port C consists of analog pins A5 through A0, and port D consists of digital pins D7 through D0.</p>
<figure class="IMG"><img alt="A SIMPLIFIED DIAGRAM OF AN ARDUINO UNO SHOWING THE THREE I/O PIN PORTS: PORT B, C AND D" class="img5" id="fig2-1" src="../images/fig2-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: Ports on the Arduino Uno</samp></p></figcaption>
</figure>
<p class="TX">To set a pin as an input or output, you don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> as you normally would. Rather, use the following simple syntax:</p>

<pre><code>DDR<var>x</var> = B<var>yyyyyyyy</var></code></pre>

<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">DDR</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> is the data direction register, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> is the port (B, C, or D) and each <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp> matches a pin in the port (from highest to lowest). The B in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyyyyyy</samp> indicates that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyyyyyy</samp> is a binary number. For example, to set all of port D to digital outputs, you use the following line of code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>:</p>

<pre><code>DDRD = B11111111;
</code></pre>

<p class="TX">To set digital pins D13, D12, and D11 to inputs and digital pins D9, D8, and D7 to outputs, use the following code:</p>

<pre><code>DDRB = B000111; // Port B has six pins in total
</code></pre>

<p class="TX"><span aria-label=" Page 15. " epub:type="pagebreak" id="pg_15" role="doc-pagebreak"/>You can see how much sketch space this saves compared to multiples or loops of <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp>.</p>
<aside aria-labelledby="box2" class="box">
<h3 class="BoxTitle" id="box2"><samp class="SANS_Dogma_OT_Bold_B_11">EXERCISING CAUTION WHEN USING PORT MANIPULATION AND D1/D0 PINS</samp></h3>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">If you use port manipulation to control digital pins D1 and D0, your sketch may lose the ability to use the Serial Monitor in the IDE or communicate with other devices via the UART. In such cases, you may want to use SoftwareSerial to create a different pair of UART pins to communicate with devices such as GPS modules that use a UART-style interface, as demonstrated in Chapter 15 of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Arduino Workshop</samp><samp class="SANS_Futura_Std_Book_11">, 2nd edition (No Starch Press, 2021), for example.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Furthermore, any external circuitry you’ve connected to digital pins D1 and D0 may be triggered when you upload a sketch—the highs and lows of the serial communication are the same as digital writes and reads. In this case, I recommend you upload sketches with a USBasp programmer such as PMD Way part number 263343, shown here.</samp></p>
<figure class="IMG1-nb"><img alt="A photo of the USBasp programmer and the two cables that are included to connect between the programmer and an Arduino Uno" class="img5" src="../images/pg15.png"/>
</figure>
</aside>
<p class="TX">In addition to abbreviating your code and shortening the response time, port manipulation can save you hardware costs when controlling digital output pins. For example, in the past, you may have used a shift register IC to control an LED display. Port manipulation allows you to do the same using a spare bank of I/O pins instead.</p>
<p class="TX">Let’s put this theory into practice with some projects.</p>
<p class="HeadProject"><span id="h1-12"/><span aria-label=" Page 16. " epub:type="pagebreak" id="pg_16" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #4: Increasing Digital Output Pin Speed</samp></p>
<p class="TNI">In this project, you’ll practice using port manipulation by controlling eight digital outputs at once, with LEDs used to display output status.</p>
<p class="TX">You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">Eight 1 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">Eight LEDs</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Male-to-male jumper wires</li>
</ul>
<p class="TX">To minimize the number of part types used in this book and therefore reduce the cost of completing projects, this project uses the same 1 kΩ resistors from the previous chapter instead of the usual 560 Ω or thereabouts. The LEDs will still be plenty bright.</p>
<p class="TX">Assemble the circuit as shown in <a href="chapter2.xhtml#fig2-2">Figure 2-2</a> on the solderless breadboard, connecting the points labeled D7 through D0 and GND to the Arduino’s respective pins.</p>
<figure class="IMG"><img alt="A SCHEMATIC FOR PROJECT #4" class="img7" id="fig2-2" src="../images/fig2-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: Schematic for Project #4</samp></p></figcaption>
</figure>
<p class="TX">Enter and upload the following sketch to your Arduino:</p>
<span id="pro-4"/>

<pre><code>// Project #4 - Fast digital outputs

void setup()
{
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> DDRD = B11111111; // Set PORTD (digital 7 through 0) to outputs
}

void loop()
{
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PORTD = B11111111;
    delay(500);
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PORTD = B00000000;
    delay(500);
}
</code></pre>

<p class="TX"><span aria-label=" Page 17. " epub:type="pagebreak" id="pg_17" role="doc-pagebreak"/>Once the upload is complete, all the LEDs should blink on and off every half second. The pins on port D are set to outputs <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and all turned on <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and then off again <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This simple example shows how little code is required to accomplish a lot of digital pin control.</p>
<p class="TX">Keep the hardware for this project together, as you’ll use it again in Project #5.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-13"/><samp class="SANS_Futura_Std_Bold_B_11">Speed Advantage</samp></h2>
<p class="TNI">The Arduino environment uses a hardware abstraction layer that simplifies controlling the hardware in your Arduino board or compatible circuit with the help of software functions and classes. This code requires extra processing time, which normally slows down sketch execution. Port manipulation allows you to bypass the hardware abstraction layer, which greatly reduces the amount of code the CPU needs to run to accomplish the same task.</p>
<p class="TX">To see how much port manipulation speeds up I/O pin operation, this section shows how to use test equipment such as a frequency counter or a digital storage oscilloscope (DSO) to measure the frequency at which a port of digital pins turns on and off. If you have an oscilloscope or a frequency counter, you can follow along.</p>
<p class="TX">First, test the pin speed with the usual Arduino sketch functions, using the sketch in <a href="#LiT-2-1">Listing 2-1</a> with a digital pin connected to the oscilloscope.</p>
<span id="LiT-2-1"/>

<pre><code>void setup()
{
    for (int a = 0; a &lt; 8; a++)
    {
        pinMode(a, OUTPUT);
    }
}

void loop()
{
    for (int a = 0; a &lt; 8; a++)
    {
        digitalWrite(a, HIGH);
    }
    for (int a = 0; a &lt; 8; a++)
    {
        digitalWrite(a, LOW);
    }
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1 A pin speed test, which turns digital pins D7 to D0 on and off in sequence and then repeats</samp></p>
<p class="TX"><a href="chapter2.xhtml#fig2-3">Figure 2-3</a> shows the results of this measurement: an average frequency of 15.15 kHz, which gives a time interval of around 0.000066 seconds (66 <span class="greek"><span lang="el" xml:lang="el">μ</span></span>s) to turn all eight digital pins on and off.<span aria-label=" Page 18. " epub:type="pagebreak" id="pg_18" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A SCREEN CAPTURE OF A DIGITAL STORAGE OSCILLOSCOPE MEASURING THE PERIOD BETWEEN ARDUINO DIGITAL OUTPUT ON AND OFF USING ARDUINO CODE" class="img1" id="fig2-3" src="../images/fig2-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The results from running the <a href="#LiT-2-1">Listing 2-1</a> test</samp></p></figcaption>
</figure>
<p class="TX">Now repeat this test with the modified sketch in <a href="#LiT-2-2">Listing 2-2</a>, which uses port manipulation.</p>
<span id="LiT-2-2"/>

<pre><code>void setup()
{
    DDRD = B11111111; // Set PORTD (digital 7 through 0) to outputs
}

void loop()
{
    PORTD = B11111111;
    PORTD = B00000000;
    PORTD = B11111111;
    PORTD = B00000000;
    PORTD = B11111111;
    PORTD = B00000000;
    PORTD = B11111111;
    PORTD = B00000000;
    PORTD = B11111111;
    PORTD = B00000000;
    PORTD = B11111111;
    PORTD = B00000000;
    PORTD = B11111111;
    PORTD = B00000000;
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: Using port manipulation to test pin speed</samp></p>
<p class="TX"><span aria-label=" Page 19. " epub:type="pagebreak" id="pg_19" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> commands in <a href="#LiT-2-2">Listing 2-2</a> demonstrate turning the pins on and off long enough for the oscilloscope to capture the true speed of this operation. If there were only two <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> commands (for on and off), the time measurement would include the period between the pins being turned off and the loop starting over.</p>
<p class="TX"><a href="chapter2.xhtml#fig2-4">Figure 2-4</a> shows the results of this sketch on the oscilloscope.</p>
<figure class="IMG"><img alt="A SCREEN CAPTURE OF A DIGITAL STORAGE OSCILLOSCOPE MEASURING THE PERIOD BETWEEN ARDUINO DIGITAL OUTPUT ON AND OFF USING PORT MANIPULATION CODE" class="img1" id="fig2-4" src="../images/fig2-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: Results from the “fast” test</samp></p></figcaption>
</figure>
<p class="TX">This second test resulted in an average frequency of 8.06 MHz, or a time interval of around 0.00000012406 seconds (0.12405 <span class="greek"><span lang="el" xml:lang="el">μ</span></span>s) to turn all eight digital pins on and off. On average, using port manipulation turned those pins on and off around 532 times faster than normal sketch functions.</p>
<p class="TX">You can see how much using port manipulation improves operation speed and reduces the amount of required code in your sketches. In the next project, we’ll demonstrate these benefits of port manipulation by controlling LEDs for display purposes.</p>
<p class="HeadProject"><span id="h1-14"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #5: Displaying Binary Numbers</samp></p>
<p class="TNI">In this project, you’ll continue to consolidate your knowledge of port manipulation by using the method to display binary numbers with eight LEDs.</p>
<p class="TX">This project uses the same hardware as Project #4. Once you’ve uploaded the sketch, the LEDs should illuminate in turn to display binary numbers from 0 to 255, with the least-significant bit on the right side of the LEDs.</p>

<pre><code><span aria-label=" Page 20. " epub:type="pagebreak" id="pg_20" role="doc-pagebreak"/>// Project #5 - Display binary numbers

void setup()
{
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> DDRD = B11111111; // Set PORTD (digital 7 through 0) to outputs
}

void loop()
{
    for (int a = 0; a &lt; 256; a++)
    {
       <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PORTD = a;
         delay(250);
    }
}
</code></pre>

<p class="TX">Once again, we set the pins on port D to outputs <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then set <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> to the increasing value of the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. As the port register contains 8 bits, we can assign an integer between 0 and 255 to the port so that the outputs match the binary equivalent of the number assigned to the register <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Before moving on, let’s practice mastering bit-shifting in port manipulation by turning LEDs on and off in one direction and then the other.</p>
<p class="HeadProject"><span id="h1-15"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #6: Creating a Blinking LED Wave</samp></p>
<p class="TNI">In this project, using the hardware from Projects #4 and #5, you’ll create a wavelike light pattern to emulate the lights across the bonnet of the famous vehicle K.I.T.T. from the 1980s television show <i>Knight Rider</i>. Once you’ve uploaded this sketch, you should be presented with your own version of K.I.T.T.’s iconic scrolling lights.</p>
<span id="pro-6"/>

<pre><code>// Project #6 - Creating a blinking LED wave

void setup()
{
    DDRD = B11111111; // Set PORTD (digital 7 through 0) to outputs
}

void loop()
{
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> for (int k = 0; k &lt; 8; k++)
    {
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> PORTD = 1 &lt;&lt; k;
         delay(100);
    }

  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> for (int k = 6; k &gt; 0; —k)
    {
        PORTD = 1 &lt;&lt; k;
        delay(100);
    }
}
</code></pre>

<p class="TX"><span aria-label=" Page 21. " epub:type="pagebreak" id="pg_21" role="doc-pagebreak"/>This sketch has two loops: one to blink the LEDs from right to left and one to blink them in the opposite direction. We use bit-shifting to move the number 1 from right to left along the port register. We loop eight times, for eight LEDs <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The LED is activated by assigning 1 to the port register <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which turns on the LED on digital pin D0 in the second run of the loop.</p>
<p class="TX">The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> is 1, so we shift the bit one to the left (using <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;</samp>) in the port register, turning on the second LED on digital pin D1. This process repeats until all eight LEDs have been turned on and off. The following list of port register bytes represents each event in this sequence of events:</p>

<pre><code>00000001 // PORD = 1 &lt;&lt; 0
00000010 // PORD = 1 &lt;&lt; 1
00000100 // PORD = 1 &lt;&lt; 2
00001000 // PORD = 1 &lt;&lt; 3
00010000 // PORD = 1 &lt;&lt; 4
00100000 // PORD = 1 &lt;&lt; 5
01000000 // PORD = 1 &lt;&lt; 6
10000000 // PORD = 1 &lt;&lt; 7
</code></pre>

<p class="TX">The process then repeats in reverse in the second loop at <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, beginning by putting a bit in the seventh position (<samp class="SANS_TheSansMonoCd_W5Regular_11">01000000</samp>), and then continues along to bit 1. We don’t need to put a bit in location 0 for this second loop, as that would illuminate the first LED twice in a row.</p>
<p class="TX">The next two projects demonstrate another convenient application for port manipulation: using seven-segment LED displays, which are simply eight LEDs arranged to form a number with an optional decimal point.</p>
<p class="HeadProject"><span id="h1-16"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #7: Controlling Seven-Segment LED Displays</samp></p>
<p class="TNI">People generally use an external shift register IC, such as the 74HC595, to display simple numerical information with seven-segment LED displays. If you have the digital I/O pins to spare, however, you can save money on parts by using the method in this project. This project also includes a quick review of bitwise arithmetic.</p>
<p class="TX">You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">Eight 1 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">A common-cathode seven-segment LED display (FND500-compatible)</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Male-to-male jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter2.xhtml#fig2-5">Figure 2-5</a> on the solderless breadboard and connect the points labeled D7 through D0 and GND to the Arduino’s respective pins.<span aria-label=" Page 22. " epub:type="pagebreak" id="pg_22" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #7" class="img7" id="fig2-5" src="../images/fig2-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: The schematic for Project #7</samp></p></figcaption>
</figure>
<p class="TX">Once you’ve uploaded the sketch, the numbers 0 through 9 should display in turn and then display once more, this time with the decimal point in the LED display turned on.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-7"/>

<pre><code>// Project #7 - Controlling seven-segment LED displays with port manipulation

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> int digits[] = {B11111100, // 0
                B01100000, // 1
                B11011010, // 2
                B11110010, // 3
                B01100110, // 4
                B10110110, // 5
                B10111110, // 6
                B11100000, // 7
                B11111110, // 8
                B11110110}; // 9
void setup()
{
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> DDRD = B11111111; // Set PORTD (digital 7 through 0) to outputs
}

void loop()
{
    for (int a = 0; a &lt; 10; a++)
    {
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> PORTD = digits[a];
         delay(250);
    }

    for (int a = 0; a &lt; 10; a++)
    {
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> PORTD = digits[a]|B00000001; // Activate decimal point (D0)
         delay(250);
    }
}
</code></pre>

<p class="TX"><span aria-label=" Page 23. " epub:type="pagebreak" id="pg_23" role="doc-pagebreak"/>The sketch defines an array with 10 elements <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, each including a binary number representing the LEDs of the display needed to power on or off to display each digit. From the schematic in <a href="chapter2.xhtml#fig2-5">Figure 2-5</a>, you can see that the display is wired so its first pin (A) is connected to digital pin D7, and so on. In this project, port D is set at <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Displaying the required digit is a simple matter of allocating the required array element (0 to 9) to <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> at <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">The loop <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> turns the decimal point on. Bit 0 in each array element represents the decimal point LED in the display, so the sketch needs to change the bit in bit 0 using the OR function (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>) in bitwise arithmetic. When you use OR to compare 2 bits, the result is 1 if either bit is 1 or if both are 1.</p>

<pre><code>1|0 = 1 // 1 or 0 = 1
0|1 = 1 // 0 or 1 = 1
1|1 = 1 // 1 or 1 = 1
0|0 = 0 // 0 or 0 = 0
</code></pre>

<p class="TX">Therefore, you can add the decimal point to a numerical byte using the following (in the sketch, the numerical byte is set to display the number 1 and the decimal point):</p>

<pre><code>B01100000 | // Byte to display digit 1
B00000001 = // "or" decimal point bit
B01100001 // Gives us digit 1 with decimal point
</code></pre>

<p class="TX">In the future, if you’re using the LED display in your own projects with port manipulation, you can take advantage of the following custom function to display numbers with or without the decimal point. You can also test it by adding it to Project #7.</p>

<pre><code>void display(int n, boolean point)
{
    if (point == false) // No decimal point
    {
        PORTD = digits[n];
    }
    else if (point == true) // Decimal point
    {
      PORTD = digits[n]|B00000001;
    }
}
</code></pre>

<p class="TX">If you want to turn off a particular output that you know is currently on without affecting the other pins, use the bitwise AND function <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>. When a bit is compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> 0, the result is 0 if the bit is 1. For example:</p>

<pre><code>1&amp;0 = 0 // 1 or 0 = 0
0&amp;1 = 0 // 0 or 1 = 0
</code></pre>

<p class="TX"><span aria-label=" Page 24. " epub:type="pagebreak" id="pg_24" role="doc-pagebreak"/>To turn off the first and last output when all pins are on, you’d use the following code, which leaves bits 6 through 1 on, with 7 and 0 off:</p>

<pre><code>PORTx = B11111111 &amp;
        B01111110;
</code></pre>

<p class="TX">Now that you have the LED display circuit connected, let’s make an electronic die.</p>
<p class="HeadProject"><span id="h1-17"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #8: Creating an Electronic Die</samp></p>
<p class="TNI">In this project, you’ll create an electronic die that generates a random number between one and six to mimic rolling a physical die.</p>
<p class="TX">This project uses the same hardware as Project #7. Upload the sketch; the display should rapidly scroll through the numbers and then slow down bit by bit until it stops.</p>
<span id="pro-8"/>

<pre><code>// Project #8 - Single-digit electronic die

int digits[] = {B11111100, // 0
                B01100000, // 1
                B11011010, // 2
                B11110010, // 3
                B01100110, // 4
                B10110110, // 5
                B10111110, // 6
                B11100000, // 7
                B11111110, // 8
                B11110110}; // 9

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> void display(int n, boolean point)
{
    if (point == false)
    {
        PORTD = digits[n];
    } else if (point == true)
    {
        PORTD = digits[n] | B00000001;
    }
}

void displayRandom(int _delay)
{
    display(random(1, 7), false); // Display the number
    if (_delay &gt; 0)
    {
        delay(_delay); // Hold the display on for the delay received
    }
    else if (_delay == 0)
    {
        do // The delay entered was 0, hold the display on
        {}
<span aria-label=" Page 25. " epub:type="pagebreak" id="pg_25" role="doc-pagebreak"/>        while (1);
    }
}

void setup()
{
    DDRD = B11111111; // Set PORTD (digital 7 through 0) to outputs
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> randomSeed(analogRead(0)); // Seed the random generator
}

void loop()
{
    int a;
    // Cycle the LEDs around for effect
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> for (a = 0; a &lt; 100; a++)
    {
        displayRandom(50);
    }
    // Display numbers with increasing delay
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> for (a = 1; a &lt; 10; a++)
    {
        displayRandom(a * 100);
    }
    // Stop at the final random number and LED
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> displayRandom(0);
}
</code></pre>

<p class="TX">The sketch is a combination of new code and the functions that were used in Project #7. The sketch first uses the custom function from that project to display the digits <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and then seed the random number generator <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. It rapidly displays 100 random numbers for visual effect <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and then displays the next 10 random numbers with an increasing time delay between each number <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Finally, after one last random number is displayed <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, everything stops. To display another random number, press the reset button.</p>
<p class="HeadProject"><span id="h1-18"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #9: Reading Multiple Digital Inputs Simultaneously</samp></p>
<p class="TNI">You can also read digital input pins rapidly using the port-style operations, rather than by using multiple <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalRead()</samp> functions. Since each port returns 8 bits of data (including ports B and C, which have only six physical pins), we can simply set the required port to inputs and then assign the value of a port to a variable. The value is an 8-bit number that represents the status of the input pins.</p>
<p class="TX">Once inputs have been set using the <samp class="SANS_TheSansMonoCd_W5Regular_11">DDR</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> function in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, just assign the port to a variable to read the status of the pins. For example, to read the status of port D once set to inputs, use this:</p>

<pre><code>int port = PIND; // Value of pins on PORTD is stored in integer "port"
</code></pre>

<p class="TX">This project demonstrates how to read an entire port at once and then display the status of that port using another port of LEDs.</p>
<p class="TX"><span aria-label=" Page 26. " epub:type="pagebreak" id="pg_26" role="doc-pagebreak"/>You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">Four 1 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">Four 10 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">Four LEDs</li>
<li class="BL">Four tactile buttons</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Male-to-male jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter2.xhtml#fig2-6">Figure 2-6</a> on the solderless breadboard and connect the points labeled D7 through D4, D13 through D10, 5V, and GND to the Arduino’s respective pins.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #9" class="img7" id="fig2-6" src="../images/fig2-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: The schematic for Project #9</samp></p></figcaption>
</figure>
<p class="TX">Once you’ve uploaded the sketch, pressing a button should illuminate the matching LED.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-9"/>

<pre><code>// Project #9 - Simultaneous reading of Arduino digital inputs

void setup()
{
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> DDRB = B00000000; // Set PORTB (digital 13 through 8) to inputs
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> DDRD = B11111111; // Set PORTD (digital 7 through 0) to outputs
}

void loop()
{
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> PORTD = PINB&lt;&lt;2; // Bit-shift PORTB value as only 6 bits
}
</code></pre>

<p class="TX">This sketch demonstrates the code minimalization made possible using port manipulation: you can read the status of up to eight buttons in one <span aria-label=" Page 27. " epub:type="pagebreak" id="pg_27" role="doc-pagebreak"/>line, instead of using eight separate <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalRead()</samp> functions. After setting the pins’ status <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, the sketch assigns the value of the pins (<samp class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp>) to port D, which sets the outputs as instructed <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">Next, the code bit-shifts the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp> 2 bits to the left <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Port B has only six physical pins but still returns an 8-bit number when read. The two most significant bits are 0, and the final six represent the status of D13 to D8. Therefore, this project moves the <samp class="SANS_TheSansMonoCd_W5Regular_11">PINB</samp> value to the left so the bits match port D for the output control.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-19"/><samp class="SANS_Futura_Std_Bold_B_11">Binary-Coded Decimal Switches</samp></h2>
<p class="TNI">The form of reading digital inputs demonstrated in Project #9 lends itself well to input devices with more than one output, such as rotary switches with BCD outputs representing the binary values of numbers 0 through 9. BCD switches are a convenient method of accepting user input for setting options, values, or other project requirements where the user inputs a number between 0 and 9.</p>
<figure class="IMG"><img alt="THE SCHEMATIC SYMBOL FOR A TYPICAL BCD SWITCH" class="img3" id="fig2-7" src="../images/fig2-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-7: The schematic symbol for a typical BCD switch</samp></p></figcaption>
</figure>
<p class="TX">BCD switches offer 10 position selections and have 4 output pins easily readable with 4 digital input pins. The fifth pin is commonly connected to the 5V pin, which allows the current to flow through to the switched output pins. <a href="chapter2.xhtml#fig2-7">Figure 2-7</a> shows the schematic symbol for a typical BCD switch.</p>
<figure class="IMG"><img alt="A PHOTO OF A PUSH-WHEEL BCD SWITCH" class="img3" id="fig2-8" src="../images/fig2-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-8: A push-wheel BCD switch</samp></p></figcaption>
</figure>
<p class="TX">Examples of BCD switches include the retro-style “push-wheel” switches, as shown in <a href="chapter2.xhtml#fig2-8">Figure 2-8</a>, and rotary switches, as shown in <a href="chapter2.xhtml#fig2-9">Figure 2-9</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF A ROTARY BCD SWITCH" class="img3" id="fig2-9" src="../images/fig2-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-9: A rotary BCD switch</samp></p></figcaption>
</figure>
<p class="TX">For performing simple BCD experiments, it’s easier to use the rotary BCD switch shown in <a href="chapter2.xhtml#fig2-9">Figure 2-9</a>, as it doesn’t require any soldering.</p>
<p class="TX">With any switch, users must be careful to move the lever or pointer to the correct position. For example, if you change a rotary switch and leave the pointer between two digits, it will not return a correct value. The next project demonstrates how to implement these switches with port manipulation.</p>
<p class="HeadProject"><span id="h1-20"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #10: Reading BCD Switches</samp></p>
<p class="TNI">This project demonstrates reading a BCD switch by using port manipulation to return the value <span aria-label=" Page 28. " epub:type="pagebreak" id="pg_28" role="doc-pagebreak"/>in both binary and decimal to the Serial Monitor, allowing you to receive numerical user input simply and efficiently.</p>
<p class="TX">You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A BCD rotary or push-wheel switch</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Male-to-male jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter2.xhtml#fig2-10">Figure 2-10</a> on the solderless breadboard and connect the points labeled 5V and D11 through D8 to the Arduino’s respective pins.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #10" class="img4" id="fig2-10" src="../images/fig2-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-10: The schematic for Project #10</samp></p></figcaption>
</figure>
<p class="TX">Enter and upload the sketch and then open the Serial Monitor. You should see the value of the switch’s setting displayed in both binary and decimal, as shown in <a href="chapter2.xhtml#fig2-11">Figure 2-11</a>.</p>
<figure class="IMG"><img alt="AN EXAMPLE OUTPUT FROM PROJECT #10 ON THE ARDUINO SERIAL MONITOR, SHOWING BINARY AND DECIMAL RESULTS FROM READING THE BCD SWITCH" class="img8" id="fig2-11" src="../images/fig2-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-11: Example output for Project #10</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 29. " epub:type="pagebreak" id="pg_29" role="doc-pagebreak"/>Let’s see how this works:</p>
<span id="pro-10"/>

<pre><code>// Project #10 - Reading BCD switches

void setup()
{
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> DDRB = B11110000; // Set PORTB (digital 11 through 8) to inputs
    Serial.begin(9600);
}

void loop()
{
    Serial.print("Switch value - Binary: ");
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Serial.print(PINB,BIN);
    Serial.print(", Decimal: ");
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Serial.println(PINB);
    delay(250);
}
</code></pre>

<p class="TX">The code sets pins D11 through D8 to inputs and sets D12 and D13 to outputs <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, since it doesn’t want to return the values of pins D12 and D13. It then simply returns the value of port B to the Serial Monitor in binary <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and decimal <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> forms. The binary value should reflect the actual signals from the switch back to the Arduino’s input pins, while the decimal is the integer equivalent of the same signals.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h2 class="H1" id="sec5"><span id="h1-21"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">This chapter showed you how to work more quickly and efficiently with your Arduino’s digital input and output pins by using port manipulation, controlling many LEDs without external ICs and receiving settings without needing to use a display or multiple switches. In the next chapter, you’ll learn how to use the physically smaller and cheaper ATtiny series of microcontrollers for less complex Arduino projects.</p>
</section>
</section>
</body>
</html>