- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Long Range Radio: LPWAN'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Low-Power Wide Area Network (LPWAN)* is a group of wireless, low-power, wide
    area network technologies designed for long-range communications at a low bit
    rate. These networks can reach more than six miles, and their power consumption
    is so low that their batteries can last up to 20 years. In addition, the overall
    technology cost is relatively cheap. LPWANs can use licensed or unlicensed frequencies
    and include proprietary or open standard protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: LPWAN technologies are common in IoT systems, such as smart cities, infrastructure,
    and logistics. They’re used in place of cables or in cases where it could be insecure
    to plug nodes directly into the main network. For example, in infrastructure,
    LPWAN sensors often measure river flood levels or pressure on water pipes. In
    logistics, sensors might report temperatures from refrigerated units inside containers
    carried by ships or trucks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we focus on one of the main LPWAN radio technologies, *Long
    Range (LoRa),* because it’s popular in multiple countries and has an open source
    specification called LoRaWAN. It’s used for a variety of critical purposes, such
    as railway level crossings, burglar alarms, Industrial Control System (ICS) monitoring,
    natural disaster communication, and even receiving messages from space. We first
    demonstrate how to use and program simple devices to send, receive, and capture
    LoRa radio traffic. Then we move up one layer and show you how to decode LoRaWAN
    packets, as well as how LoRaWAN networks work. Additionally, we provide an overview
    of various attacks that are possible against this technology and demonstrate a
    bit-flipping attack.
  prefs: []
  type: TYPE_NORMAL
- en: LPWAN, LoRa, and LoRaWAN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LoRa is one of three main LPWAN modulation technologies. The other two are *Ultra
    Narrowband (UNB)* and *NarrowBand (NB-IoT).* LoRa is *spread spectrum*, meaning
    devices transmit the signal on a bandwidth larger than the frequency content of
    the original information; it uses a bit rateranging from 0.3Kbps to 50Kbps per
    channel. *UNB* uses a very narrow bandwidth, and *NB-IoT* leverages existing cellular
    infrastructure, such as the global network operator Sigfox, which is the biggest
    player. These different LPWAN technologies offer varying levels of security. Most
    of them include network and device or subscriber authentication, identity protection,
    advanced standard encryption (AES), message confidentiality, and key provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: When people in the IoT industry talk about LoRa, they’re usually referring to
    the combination of LoRa and LoRaWAN. *LoRa* is a proprietary modulation scheme
    patented by Semtech and licensed to others. In the seven-layer OSI model of computer
    networking, LoRa defines the physical layer, which involves the radio interface,
    whereas LoRaWAN defines the layers above it. LoRaWAN is an open standard maintained
    by LoRa Alliance, a nonprofit association of more than 500 member companies.
  prefs: []
  type: TYPE_NORMAL
- en: LoRaWAN networks are composed of nodes, gateways, and network servers ([Figure
    13-1](#figure13-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f13001](Images/f13001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: LoRaWAN network architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '*Nodes* are small, cheap devices that communicate with the gateways using the
    LoRaWAN protocol. *Gateways* are slightly larger, more expensive devices that
    act as middlemen to relay data between the nodes and the network server, with
    which they communicate over any kind of standard IP connection. (This IP connection
    can be cellular, Wi-Fi, or so on.) The *network server* is then sometimes connected
    to an *application server*, which implements logic upon receiving messages from
    a node. For example, if the node is reporting a temperature value above a certain
    threshold, the server could reply with commands to the node and take appropriate
    action (for instance, open a valve). LoRaWAN networks use a *star-of-stars topology*,
    which means that multiple nodes can talk to one or more gateways, which talk to
    one network server.'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing LoRa Traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll demonstrate how to capture LoRa traffic. By doing so,
    you’ll learn how to use the CircuitPython programming language and interact with
    simple hardware tools. Various tools can capture LoRa signals, but we selected
    those that demonstrate techniques you might use for other IoT hacking tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, we’ll use three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LoStik** An open source USB LoRa device (available from [https://ronoth.com/lostik/](https://ronoth.com/lostik/)).
    LoStik uses either the Microchip modules RN2903 (US) or RN2483 (EU), depending
    on which International Telecommunications Union (ITU) region you’re in. Make sure
    you get the one that covers your region.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CatWAN USB Stick** An open source USB stick compatible with LoRa and LoRaWAN
    (available at [https://electroniccats.com/store/catwan-usb-stick/](https://electroniccats.com/store/catwan-usb-stick/)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Heltec LoRa 32** An ESP32 development board for LoRa ([https://heltec.org/project/wifi-lora-32/](https://heltec.org/project/wifi-lora-32/)).
    ESP32 boards are low-cost, low-power microcontrollers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll make the LoStik into a receiver and the Heltec board into a sender and
    then have them talk to each other using LoRa. We’ll then set up the CatWAN stick
    as a sniffer to capture the LoRa traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Heltec LoRa 32 Development Board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start by programming the Heltec board using the Arduino IDE. Return to
    Chapter 7 for an introduction to the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the IDE if you don’t already have it, then add the Heltec libraries
    for Arduino-ESP32\. These will let you program ESP32 boards, such as the Heltec
    LoRa module, using the Arduino IDE. To accomplish the installs, click **File**▶**Preferences**▶**Settings**,
    and then click the **Additional Boards Manager URLs** button. Add the following
    URL in the list: [https://resource.heltec.cn/download/package_heltec_esp32_index.json](https://resource.heltec.cn/download/package_heltec_esp32_index.json),
    and click **OK**. Then click **ToolsBoardBoards **Manager**. Search for **Heltec
    ESP32** and click **Install** on the Heltec ESP32 Series Dev-boards by Heltec
    Automation option that should appear. We specifically used version 0.0.2-rc1.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The next step is to install the *Heltec ESP32* library. Click **Sketch**▶**Include
    Library**▶**Manage Libraries**. Then search for “Heltec ESP32” and click **Install**
    on the Heltec ESP32 Dev-Boards by Heltec Automation option. We used version 1.0.8.'
  prefs: []
  type: TYPE_NORMAL
- en: To check where the libraries are saved, click **File**▶**Preferences**▶**Sketchbook
    location**. On Linux, the directory listed there is typically */home/<username>/Arduino*
    where you should find a subfolder called *libraries* containing libraries like
    “Heltec ESP32 Dev Boards.”
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also probably need to install the *UART bridge VCP driver* so the Heltec
    board appears as a serial port when you connect it to your computer. You can get
    the drivers at [https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers/](https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers/).
    If you’re running Linux, make sure you select the proper version for the kernel
    you’re running. The release notes include instructions on how to compile the kernel
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you’re logged in as a nonroot user, you might need to add your
    username to the group that has read and write access to the */dev/ttyACM** and
    */dev/ttyUSB** special device files. You’ll need this to access the Serial Monitor
    functionality from within the Arduino IDE. Open a terminal and enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This output means that the group owner of the file is *dialout* (it might differ
    in your distribution), so you need to add your username to this group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Users belonging to the dialout group have full and direct access to serial ports
    on the system. Once you add your username to the group, you should have the access
    you need for this step.
  prefs: []
  type: TYPE_NORMAL
- en: Programming the Heltec Module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To program the Heltec module, we’ll connect it to a USB port in our computer.
    Make sure you’ve first connected the detachable antenna to the main module. Otherwise,
    you might damage the board ([Figure 13-2](#figure13-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f13002](Images/f13002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: The Heltec Wi-Fi LoRa 32 (V2) is based on ESP32 and SX127x and
    supports Wi-Fi, BLE, LoRa, and LoRaWAN. The arrow indicates where to connect the
    antenna.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Arduino IDE, select the board by clicking **Tools**▶**Board**▶**WiFi
    LoRa 32 (V2)**, as shown in [Figure 13-3](#figure13-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f13003](Images/f13003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: Select the correct board in the Arduino IDE: WiFi LoRa 32(V2).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll start writing an Arduino program to make the Heltec module act as
    a LoRa packets sender. The code will configure the Heltec module radio and send
    simple LoRa payloads in a loop. Click **File**▶**New** and paste the code from
    [Listing 13-1](#listing13-1) into the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-1: The Arduino code that allows the Heltec LoRa module to act as
    a basic LoRa packet sender'
  prefs: []
  type: TYPE_NORMAL
- en: We first include the Heltec libraries, which contain functions for interfacing
    with the OLED display on the board and the SX127x LoRa node chips. We’re using
    the US version of LoRa, so we define the frequency to be 915 MHz.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `setup()` function 1, which, remember, gets called once when an
    Arduino sketch begins. Here, we’re using it to initialize the Heltec module and
    its OLED display. The four boolean values in `Heltec.begin` enable the board’s
    display; the LoRa radio; the serial interface, which allows you to see output
    from the device using the Serial Monitor, explained shortly; and PABOOST (the
    high-power transmitter). The last argument sets the frequency used to transmit
    signals. The rest of the commands inside `setup()` initialize and set up the OLED
    display.
  prefs: []
  type: TYPE_NORMAL
- en: Like `setup()`, the `loop()` function 2 is a built-in Arduino function and it
    runs indefinitely, so this is where we place our main logic. We begin each loop
    by printing the string `Sending packet:`, followed by a counter on the OLED display
    to keep track of how many LoRa packets we’ve sent so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we start the process of sending a LoRa packet 3. The next four commands
    4 configure the LoRa radio: they disable the *cyclic redundancy check (CRC)* on
    the LoRa header (by default, a CRC isn’t used), set a spreading factor of 7, set
    the transmission power to a maximum value of 20, and add the actual payload (with
    the `LoRa.print()` function from the *Heltec* library) to the packet. The *CRC*
    is an error-detecting value of fixed length that helps the receiver check for
    packet corruption. The *spreading factor* determines the duration of a LoRa packet
    on air. SF7 is the shortest time on air, and SF12 is the longest. Each step up
    in spreading factor doubles the time it takes on air to transmit the same amount
    of data. Although slower, higher spreading factors can be used for a longer range.
    The *transmission power* is the amount of power in watts of radio frequency energy
    that the LoRa radio will produce; the higher it is, the stronger the signal will
    be. We then send the packet by calling `LoRa.endPacket()`5.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we increase the packet `counter` and turn the LED on the Heltec board
    on and off to indicate we just sent another LoRa packet 6.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand our Arduino program, we recommend that you read the *Heltec
    ESP32 LoRa* library code and API documentation at [https://github.com/HelTecAutomation/Heltec_ESP32/tree/master/src/lora/](https://github.com/HelTecAutomation/Heltec_ESP32/tree/master/src/lora/).
  prefs: []
  type: TYPE_NORMAL
- en: Testing the LoRa Sender
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To try the code, upload it to the Heltec board. Make sure you’ve selected the
    correct port in the Arduino IDE. Click **Tools**▶**Port** and select the USB port
    to which the Heltec is connected. Normally, this should be */dev/ttyUSB0* or in
    some cases */dev/ttyACM0\.*
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can open the Serial Monitor console by clicking **Tools**▶**Serial
    Monitor**. We’ve redirected most output to the board’s OLED display, so the serial
    console isn’t that necessary in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Then click **Sketch**▶**Upload**, which should compile, upload, and run the
    code in the board. You should now see the packet counter on the board’s screen,
    as shown in [Figure 13-4](#figure13-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f13004](Images/f13004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: The Heltec board running our code and displaying the packet number
    currently being sent'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the LoStik
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To receive packets from the Heltec board, we’ll now set up the LoStik as a
    LoRa receiver ([Figure 13-5](#figure13-5)). We used the RN2903 (US) version of
    the LoStik, which covers the United States, Canada, and South America. We advise
    you to consult the following map showing the LoRaWAN (and LoRa) frequency plans
    and regulations by country at The Things Network project: [https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html](https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '![f13005](Images/f13005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: The LoStik comes in two versions: the RN2903 (US) and RN2483 (EU)
    modules by Microchip. Make sure you select the right one for your ITU region.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To download and experiment with some of the code examples provided by the LoStik’s
    developer, you can run this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the examples, you’ll need Python 3 and the `pyserial` package. You can
    install the latter by pointing the `pip` package manager to the *requirements.txt*
    file inside the *examples* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you plug the LoStik into your computer, enter the following command to
    see which device file descriptor it was assigned to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It should be assigned to */dev/ttyUSB0* if you don’t have any other peripheral
    devices attached.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the LoRa Receiver Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a text editor, like Vim, enter the following Python script, which lets LoStik
    act as a basic LoRa receiver. The code will send configuration commands to the
    LoRa radio chip (RN2903) in the LoStik through the serial interface to make it
    listen for certain kinds of LoRa traffic and print the received packet data to
    the terminal. [Listing 13-2](#listing13-2) shows our code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-2: A Python script that lets LoStik act as a basic LoRa receiver'
  prefs: []
  type: TYPE_NORMAL
- en: The Python script first imports the necessary modules 1, including the `serial`
    classes `LineReader` and `ReaderThread` from the `pyserial` package. These two
    classes will help us implement a serial port read loop using threads. Next, we
    set up a very basic command line argument parser 2 through which we’ll pass the
    device file descriptor for the serial port (for example, */dev/ttyUSB0*) as the
    only argument to our program. We define `PrintLines`3, a subclass of `serial.threaded.LineReader`,``which
    our `ReaderThread` object will use. This class implements the program’s main logic.
    We initialize all the LoStik radio settings inside `connection_made`4, because
    it’s called when the thread is started.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]**'
  prefs: []
  type: TYPE_NORMAL
