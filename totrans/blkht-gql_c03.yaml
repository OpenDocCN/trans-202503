- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GraphQL Attack Surface
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we first explore GraphQL’s language and type system through
    the eyes of a hacker. Then we provide an overview of the common weaknesses in
    GraphQL. We hope you have your imaginary black hat handy, because you’re about
    to learn how a feature can turn into a weakness, how a misconfiguration can turn
    into an information leak, and how implementation design flaws can lead to DoS
    opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: What Is an Attack Surface?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *attack surface* is the sum of all possible attack vectors an adversary can
    use to compromise the confidentiality, integrity, and availability of a system.
    For example, imagine a physical building with a front door, a side door, and multiple
    windows. As attackers, we view each of these windows and doors as a possible opportunity
    to gain unauthorized access to the building.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a system has a higher risk of an attack succeeding when its attack
    surface is large, such as when it consists of many applications, databases, servers,
    endpoints, and so on. The more windows and doors a building has, the higher the
    probability that one of those entry points is unlocked or insecure.
  prefs: []
  type: TYPE_NORMAL
- en: Attack surfaces change over time, especially as systems and their environments
    evolve. This is particularly true in cloud environments, where infrastructure
    is elastic. For example, a server could live for only a limited amount of time,
    or an IP address could change, sometimes multiple times a day.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review all the windows and doors in GraphQL and highlight possible attack
    vectors we can use to unlock them. Understanding these concepts will aid you in
    the next chapters, where we dive deeper into offensive security.
  prefs: []
  type: TYPE_NORMAL
- en: The Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the purposes of discussing GraphQL’s attack surface, we will break its
    specification into two sections: its language and its type system. We begin by
    covering the language, used to make requests to a GraphQL API server, from a client’s
    point of view. Next, we’ll review its type system from a server’s point of view.
    You can learn about these concepts and other GraphQL internals by using the GraphQL
    specification; here, we intend to distill only the parts that will equip you with
    enough knowledge to test GraphQL attack vectors in future chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL language comprises many useful components that clients can leverage.
    At first glance, the way these elements are represented within requests may appear
    confusing. [Figure 3-1](#figure3-1) is a sample GraphQL query whose components
    are explained in [Table 3-1](#table3-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c03/F03001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: A sample GraphQL query'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, GraphQL queries are uniquely structured, and it is important
    to understand the various parts. [Table 3-1](#table3-1) provides a description
    of each component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3-1: The Components of a GraphQL Query'
  prefs: []
  type: TYPE_NORMAL
- en: '| **#** | **Component** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Operation type | Type that defines the method of interaction with the
    server (query, mutation, or subscription) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Operation name | Arbitrary client-created label used to provide a unique
    name to an operation |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Top-level field | Function that returns a single unit of information
    or object requested within an operation (may contain nested fields) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Argument (of a top-level field) | Parameter name used to send information
    to a field to tailor the behavior and results of that field |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Value | Data related to an argument sent to a field |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Field | Nested function that returns a single unit of information or
    object requested within an operation |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Directive | Feature used to decorate fields to change their validation
    or execution behavior, altering a value returned by a GraphQL server |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Argument (of a directive) | Parameter name used to send information to
    a field or object to tailor its behavior and results |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Argument (of a field) | Parameter name used to send information to a
    field to tailor the behavior and results of the field |'
  prefs: []
  type: TYPE_TB
- en: The following sections explore these components, as well as a few additional
    GraphQL features, with a focus on how they contribute to GraphQL’s attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: Queries, Mutations, and Subscriptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We discussed the root operation types query, mutation, and subscription in Chapter
    1 and showed an example of using the query type to retrieve data. (For that reason,
    we won’t revisit the query type here.) As hackers, the real fun often happens
    when we can modify data. Creating, updating, and deleting data within a target
    platform empowers us to expose business logic flaws.
  prefs: []
  type: TYPE_NORMAL
- en: Mutations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In GraphQL, we can unlock data modification powers by using *mutations*. Here
    is an example of a mutation query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We define the mutation operation by using the `mutation` keyword. Then we call
    the top-level `editPaste` field, which accepts the arguments `id` and `content`.
    (We will discuss arguments later in this chapter.) This mutation essentially takes
    the paste with the `id` of `1` and updates its content. We then request the updated
    paste. This is an example of a mutation that changes and reads data simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Subscriptions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *subscription* operation works bidirectionally: it allows clients to retrieve
    real-time data from a server, and allows servers to send updates to clients. Subscriptions
    are not as common as queries and mutations, but many servers do use them, so it
    is important to know how they work.'
  prefs: []
  type: TYPE_NORMAL
- en: Subscriptions are carried over a transport protocol, most commonly *WebSocket*,
    a real-time communication protocol that allows clients and servers to exchange
    messages at any given time over a long-lived connection. However, because the
    GraphQL specification doesn’t define which transport protocol to use for subscriptions,
    you might see consumers use other ones.
  prefs: []
  type: TYPE_NORMAL
- en: When a client and server want to communicate over WebSocket, they perform a
    handshake that upgrades the existing HTTP connection to a WebSocket one. WebSocket
    internals are outside the scope of this book, but you can learn more about this
    technology by reading PortSwigger’s technical blog post on the topic at [https://portswigger.net/web-security/websockets/what-are-websockets](https://portswigger.net/web-security/websockets/what-are-websockets).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because DVGA supports subscriptions over WebSocket, we can observe the handshake
    between DVGA’s frontend interface and the GraphQL server. Clients can use subscriptions
    to fetch information from the DVGA server, such as newly created pastes. For example,
    when you browse to the Public Pastes page on *http://localhost:5013*, you should
    see an outgoing HTTP request that looks like the following in the browser’s developer
    tools Network tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The GraphQL server response to this handshake request looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the handshake caused the client and server to switch from HTTP
    to WebSocket, as indicated by the response code of `101 Switching Protocols`.
    The `Sec-WebSocket-Accept` response header informs the client that the server
    has accepted the protocol switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the handshake completes, DVGA will send a subscription request over the
    newly established WebSocket connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We define the subscription operation by using the `subscription` keyword, then
    request the `paste` top-level field and select the `id`, `title`, and `content`
    fields. This subscription allows clients to subscribe to the `paste` field; whenever
    a new paste is created in DVGA, the GraphQL server will notify all subscribers
    of the event. This removes the need for the client to constantly ask the server
    for updates, which is especially useful because the server may not have anything
    new to return at that exact moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to try sending this subscription request to DVGA by using Altair,
    you’ll need to assign a subscription URL. You can do so in Altair by clicking
    the two-arrow icon on the left sidebar and entering the WebSocket URL ***ws://localhost:5013/subscriptions***.
    Next, to receive data from the DVGA subscription, you’ll need to create a paste.
    You can either use the DVGA user interface to create it via the Public Pastes
    page or send a mutation, like the following one, from another Altair tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: WebSocket connections are prone to *cross-site WebSocket hijacking (CSWSH)*
    vulnerabilities, which happen when the server does not validate the origin of
    a client in the handshake process. WebSocket connections can also be vulnerable
    to *man-in-the-middle* *(MITM)* attacks when the transport of messages isn’t carried
    over an encrypted channel such as Transport Layer Security (TLS). The existence
    of such vulnerabilities could have a security impact on actions carried over GraphQL
    subscriptions. In Chapter 9, we’ll cover WebSocket-based attacks in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Operation Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL *operation names* are labels used to uniquely identify an operation
    in certain contexts. They appear in the executable documents that clients send
    to a GraphQL service. These documents can contain a list of one or more operations.
    For example, the document in [Listing 3-1](#listing3-1) shows a single query operation
    requesting a `pastes` top-level field with a nested `title` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-1: An executable query document'
  prefs: []
  type: TYPE_NORMAL
- en: If a document contains only one operation, and that operation is a query defining
    no variables and containing no directives, then that operation may be represented
    in its shorthand form, without the `query` keyword, as shown in [Listing 3-2](#listing3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-2: A shorthand query document'
  prefs: []
  type: TYPE_NORMAL
- en: However, a document may also contain multiple operations. If the document has
    more than one operation of the same type, operation names must be used.
  prefs: []
  type: TYPE_NORMAL
- en: Clients define these operation names, which means they can be completely random,
    making them a great way to potentially fool an analyst reviewing logs of GraphQL
    applications. For example, imagine that a client sends a document using the operation
    name `getPastes`, but instead of returning a list of paste objects, they in fact
    delete all pastes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-3](#listing3-3) provides an example of a document with `getPasteTitles`
    and `getPasteContent` set as query operation names. Although these operation names
    are appropriate given the requested content, they could just as well have been
    completely unrelated to the queries’ actions. Only the underlying operation logic
    and selection fields determine the request’s output.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-3: A query document with multiple operations, each one labeled with
    an operation name'
  prefs: []
  type: TYPE_NORMAL
- en: Because operation names are client-driven inputs, they could also potentially
    be used as attack vectors for injection. Some implementations of GraphQL allow
    special characters in operation names. The applications might store these names
    in their audit logs, third-party applications, or other systems. These could cause
    mayhem if not properly sanitized.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting observation you might make after looking at Listings 3-1,
    3-2 and 3-3 is that a client can request the exact same information by using different
    documents. This level of freedom offers clients a lot of power; however, it increases
    the number of possible requests, which in turn increases the application’s attack
    surface. Parsers that don’t take into consideration the various ways a query can
    be constructed are prone to unexpected errors.
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *field* is a single piece of information available within an operation’s
    *selection set*, or the list encapsulated between the curly brackets (`{}`). In
    the following example, `id`, `title`, and `content` are fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Because these three fields sit at the root level of the shorthand query, they
    are also known as *top-level fields*. Fields may also contain their own selection
    set, allowing for the representation of complex data relationships. In the following
    example, the top-level `owner` field has its own selection set with one nested
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, selection sets are made up of fields, and fields can have their own selection
    sets with their own fields. Do any security issues jump out at you? In Chapter
    5, we’ll explore how circular field relationships may result in recursive and
    expensive requests that can degrade performance and potentially crash a GraphQL
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fields are very important when it comes to interacting with GraphQL services.
    Not knowing what fields are available can be pretty limiting. Luckily, implementations
    have deployed a handy tool for us, known as *field suggestions*. When a client
    misspells a field, the error message returned by a server that implements field
    suggestions will reference the field it believes the client was trying to call.
    For example, if we sent a query for a paste with the field name of `titl` in DVGA
    (notice the typo), the server will respond with suggested alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This field suggestion feature makes GraphQL a convenient, friendly, and simple
    tool not only for API consumers but also for hackers. We can exploit this feature
    to find fields we may not have known about otherwise. We’ll discuss this information
    disclosure technique in Chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like REST APIs, GraphQL allows clients to send *arguments* for various fields
    in their queries to tailor the results they return. If you take another look at
    [Figure 3-1](#figure3-1), you’ll notice that arguments can be implemented at various
    levels—namely, in fields and directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following query, the `users` field has an `id` argument with a value
    of `1`. Without the `id` argument, this query would return the entire list of
    users in DVGA. The argument filters this list to those with the same identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the response to this request will return a single user object,
    its ID, and its username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments can also be passed to nested fields. Consider this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The nested `username` field now has an argument called `capitalize`. This argument
    accepts a Boolean value, here set to `true`. In DVGA, this argument will make
    GraphQL capitalize the first character of the username field and return it in
    the response, converting `admin` into `Admin`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments are *unordered*, which means that changing their order does not change
    the logic of the query. In the following example, whether you pass the `limit`
    argument or the `public` argument first doesn’t change the query’s meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The way these arguments are processed and validated is completely up to the
    application, and implementation differences could lead to vulnerabilities. For
    example, because GraphQL is strongly typed, passing an integer value to an argument
    that expects a string value will result in a validation error. If you instead
    pass it a string, the validation at the GraphQL level will pass, but the application
    should still verify the format of this input. If the value is an email address,
    for instance, the application might check the value against an email-format regular
    expression or look for the at (`@`) symbol.
  prefs: []
  type: TYPE_NORMAL
- en: If an application uses a library that provides custom scalar types for email
    addresses, the library itself could perform this validation, making it harder
    for the application maintainers to make mistakes. External GraphQL libraries,
    such as graphql-scalars ([https://github.com/Urigo/graphql-scalars](https://github.com/Urigo/graphql-scalars))
    for JavaScript, provide useful custom scalar types for specific use cases, such
    as timestamps, IP addresses, website URLs, and more. Of course, vulnerabilities
    in custom scalar types could still exist. For example, a vulnerability found in
    Python’s ipaddress library (CVE-2021-29921) could enable an attacker to bypass
    IP-based access controls.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, arguments give clients a lot of power to manipulate the behavior
    of their requests and are another great attack vector. Because the value of an
    argument is client driven, it can potentially be stuffed with malicious content
    in injection-based attacks. In Chapter 8, we highlight tools and techniques used
    to exploit arguments if their values are not properly sanitized for injection
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Aliases* allow clients to change a field’s response key to something other
    than the original field’s name. For example, here we use `myalias` as an alias
    for the `title` field name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will contain the `myalias` key instead of the original `title`
    field name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Aliases can come in handy when you’re dealing with identical response keys.
    Consider the query in [Listing 3-4](#listing3-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-4: Duplicate queries with different argument values'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this query, we use the `pastes` field twice. In each query, we pass it the
    `public` argument with different values (`false` and `true`). The `public` argument
    is a way to filter for specific pastes based on their permissions: a public paste
    is viewable by all clients, while a private paste can be viewed by only the original
    author. Copy the query from [Listing 3-4](#listing3-4) into Altair and send it
    to the DVGA. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The GraphQL server tells us that a conflict occurred while using this query.
    Since we’ve sent the same query using different arguments, GraphQL is unable to
    process them together. This is where aliases are helpful: we can rename our queries
    so the server will treat them differently. [Listing 3-5](#listing3-5) shows how
    to use aliases to avoid key conflicts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-5: Aliasing two queries'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following response, you will notice two JSON keys, `queryOne` and `queryTwo`,
    for each alias we specified in the query at [Listing 3-5](#listing3-5). You can
    think of each JSON key as a separate response to a distinct query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So far, aliases look pretty innocent. Rest assured that we can weaponize them.
    In Chapter 5, we will teach you how to leverage aliases for a variety of DoS attacks,
    and in Chapter 7, we’ll use them to defeat authentication controls.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Fragments* allow clients to reuse the same set of fields in a GraphQL query
    for readability and to avoid field repetition. Instead of repeating the fields,
    you can define a fragment once and use it whenever you need that particular set
    of fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fragments are defined using the `fragment` keyword, followed by any name you
    desire, and declared using the `on` keyword on an object type name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we define a fragment named `CommonFields`. Using the `on`
    keyword, we declare that this fragment is related to the `PasteObject`, which
    can give us access to fields that you are already familiar with by now, such as
    `title` and `content`. [Listing 3-6](#listing3-6) shows how to use this fragment
    in a query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-6: Defining the `CommonFields` fragment and using it in a query'
  prefs: []
  type: TYPE_NORMAL
- en: Using three dots (`...`), also called a *spread operator*, we can reference
    the `CommonFields` fragment in different parts of a query to access paste-related
    fields such as `title` and `content`. There is no limit to the number of times
    a fragment can be referenced in a query.
  prefs: []
  type: TYPE_NORMAL
- en: From a penetration testing perspective, fragments can be constructed such that
    they reference one another, allowing for a circular fragment condition that could
    lead to DoS conditions. You will learn how to abuse this in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can supply *variables* to operations as argument values by declaring them
    within the GraphQL document. Variables are useful because they avoid costly string
    building during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Variables are defined at the top of an operation, after the operation name.
    [Listing 3-7](#listing3-7) shows a query that uses a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-7: The `status` variable passed to the `public` argument of the `pastes`
    object'
  prefs: []
  type: TYPE_NORMAL
- en: Using the dollar sign (`$`) symbol, we provide the variable name `status` and
    its type, `Boolean`. The `!` after the variable type means that the variable is
    required for the operation.
  prefs: []
  type: TYPE_NORMAL
- en: To set the variable’s value, you can either provide a default value when defining
    the variable type or send a JSON object with the variable name and value in the
    document. In Altair, you can define variables within the Variables pane located
    directly below the left-hand Query pane, as shown in [Figure 3-2](#figure3-2).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we pass a variable named `status` with a Boolean value of `false`.
    This value will be used wherever the variable exists in the document. Variables
    provide an easier way to reuse the values we pass to arguments in fields or directives.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c03/f03002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: The Altair Variables pane (in the bottom-left corner)'
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Directives* allow you to *decorate*, or change the behavior of, a field within
    a document. The behavior change could affect the way the particular field gets
    validated, processed, or executed by the application. Directives can be seen as
    arguments’ big brother, as they allow for higher-level control, such as conditionally
    including or skipping fields based on certain logic. They come in two flavors:
    query level and schema level. Both types are declared with `@` and can leverage
    arguments (much like fields).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementations typically provide several out-of-the-box directives, and GraphQL
    API developers can also create their own custom directives as they please. Unlike
    operation names or aliases, clients can use only the directives defined by the
    server. [Table 3-2](#table3-2) shows the common default directives you will often
    see in the wild, their use, and the location in which they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3-2: Common Schema and Query-Level Directives'
  prefs: []
  type: TYPE_NORMAL
- en: '| **#** | **Name** | **Description** | **Location** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `@skip` | Conditionally omits a field from the response | Query |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `@include` | Conditionally includes a field in the response | Query |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `@deprecated` | Signals a deprecation of a schema component | Schema
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `@specifiedBy` | Specifies a custom scalar type (such as RFCs) | Schema
    |'
  prefs: []
  type: TYPE_TB
- en: Clients can apply the `@skip` directive to a field to dynamically omit it from
    the response. When the `if` condition in the directive’s argument is `true`, the
    field won’t be included. Consider the query in [Listing 3-8](#listing3-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-8: Using the `@skip` directive to omit owner information from a query'
  prefs: []
  type: TYPE_NORMAL
- en: We can see the use of the `@skip` directive, which includes an `if` condition,
    check for the value of the `$pasteOnly` Boolean variable ❶. If this variable is
    set to `true`, the entire `owner` field (as well as its nested fields) will be
    skipped and hidden from the response.
  prefs: []
  type: TYPE_NORMAL
- en: The `@include` query directive is the opposite of the `@skip` directive. It
    will include only a field and its nested fields if the argument passed to it is
    set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The `@deprecated` directive is different from the `@skip` and `@include` directives
    because clients do not use it in query documents. Known as a *schema-level directive*,
    `@deprecated` is used only in GraphQL schema definitions. It appears at the end
    of a field or type definition as a way to document that the field or type is no
    longer supported.
  prefs: []
  type: TYPE_NORMAL
- en: The `@deprecated` ``directive has an optional `reason` string argument that
    allows developers to specify a message to clients or developers who attempt to
    use the field. This information will appear in places such as the responses to
    the introspection query and the documentation section of GraphQL IDE tools such
    as GraphiQL Explorer and GraphQL Playground. [Listing 3-9](#listing3-9) is an
    example schema that shows how the `@deprecated` directive can be used.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
