- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: The GraphQL Attack Surface
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 攻击面
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we first explore GraphQL’s language and type system through
    the eyes of a hacker. Then we provide an overview of the common weaknesses in
    GraphQL. We hope you have your imaginary black hat handy, because you’re about
    to learn how a feature can turn into a weakness, how a misconfiguration can turn
    into an information leak, and how implementation design flaws can lead to DoS
    opportunities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先从黑客的角度探讨 GraphQL 的语言和类型系统。然后，我们提供 GraphQL 中常见弱点的概述。希望你准备好了你的“假想黑帽”，因为你即将学习到一个功能如何变成一个弱点，错误配置如何变成信息泄漏，实施设计缺陷如何导致
    DoS（拒绝服务）机会。
- en: What Is an Attack Surface?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是攻击面？
- en: An *attack surface* is the sum of all possible attack vectors an adversary can
    use to compromise the confidentiality, integrity, and availability of a system.
    For example, imagine a physical building with a front door, a side door, and multiple
    windows. As attackers, we view each of these windows and doors as a possible opportunity
    to gain unauthorized access to the building.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*攻击面*是指对手可以用来破坏系统机密性、完整性和可用性的所有可能攻击向量的总和。例如，想象一座带有前门、侧门和多个窗户的实体建筑。作为攻击者，我们将每个窗户和门视为可能的机会，以获得未经授权的访问权限。'
- en: Typically, a system has a higher risk of an attack succeeding when its attack
    surface is large, such as when it consists of many applications, databases, servers,
    endpoints, and so on. The more windows and doors a building has, the higher the
    probability that one of those entry points is unlocked or insecure.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当系统的攻击面较大时，其遭受攻击成功的风险较高，例如由许多应用程序、数据库、服务器、端点等组成时。就像一栋建筑拥有更多的窗户和门，攻击者就有更高的机会找到一个没有锁上的入口点或不安全的入口点。
- en: Attack surfaces change over time, especially as systems and their environments
    evolve. This is particularly true in cloud environments, where infrastructure
    is elastic. For example, a server could live for only a limited amount of time,
    or an IP address could change, sometimes multiple times a day.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击面随着时间的推移而变化，尤其是随着系统及其环境的演化。这在云环境中尤为明显，因为基础设施具有弹性。例如，一台服务器可能只存在有限的时间，或者 IP
    地址可能会变化，有时一天内会变化多次。
- en: Let’s review all the windows and doors in GraphQL and highlight possible attack
    vectors we can use to unlock them. Understanding these concepts will aid you in
    the next chapters, where we dive deeper into offensive security.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 GraphQL 中所有的窗户和门，并突出可能的攻击向量，看看我们可以如何利用它们。理解这些概念将帮助你在接下来的章节中深入了解进攻性安全。
- en: The Language
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言
- en: 'For the purposes of discussing GraphQL’s attack surface, we will break its
    specification into two sections: its language and its type system. We begin by
    covering the language, used to make requests to a GraphQL API server, from a client’s
    point of view. Next, we’ll review its type system from a server’s point of view.
    You can learn about these concepts and other GraphQL internals by using the GraphQL
    specification; here, we intend to distill only the parts that will equip you with
    enough knowledge to test GraphQL attack vectors in future chapters.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论 GraphQL 的攻击面，我们将其规范分为两个部分：语言和类型系统。我们首先从客户端的角度介绍语言，用于向 GraphQL API 服务器发出请求。接下来，我们将从服务器的角度回顾其类型系统。你可以通过使用
    GraphQL 规范来学习这些概念以及其他 GraphQL 内部知识；在这里，我们的目的是提炼出能够让你掌握足够知识的部分，以便在未来的章节中测试 GraphQL
    攻击向量。
- en: The GraphQL language comprises many useful components that clients can leverage.
    At first glance, the way these elements are represented within requests may appear
    confusing. [Figure 3-1](#figure3-1) is a sample GraphQL query whose components
    are explained in [Table 3-1](#table3-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 语言包含许多客户端可以利用的有用组件。乍一看，这些元素在请求中的表示方式可能会让人感到困惑。[图 3-1](#figure3-1)是一个示例
    GraphQL 查询，其组件在[表 3-1](#table3-1)中有详细解释。
- en: '![](image_fi/502840c03/F03001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c03/F03001.png)'
- en: 'Figure 3-1: A sample GraphQL query'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：一个示例 GraphQL 查询
- en: As you can see, GraphQL queries are uniquely structured, and it is important
    to understand the various parts. [Table 3-1](#table3-1) provides a description
    of each component.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，GraphQL 查询具有独特的结构，理解各个部分非常重要。[表 3-1](#table3-1)提供了每个组件的描述。
- en: 'Table 3-1: The Components of a GraphQL Query'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1：GraphQL 查询的组成部分
- en: '| **#** | **Component** | **Description** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **#** | **组件** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Operation type | Type that defines the method of interaction with the
    server (query, mutation, or subscription) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 操作类型 | 定义与服务器交互方法的类型（查询、变更或订阅） |'
- en: '| 2 | Operation name | Arbitrary client-created label used to provide a unique
    name to an operation |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 操作名称 | 客户端创建的任意标签，用于为操作提供唯一名称 |'
- en: '| 3 | Top-level field | Function that returns a single unit of information
    or object requested within an operation (may contain nested fields) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 顶级字段 | 在操作中请求的返回单一信息或对象的函数（可能包含嵌套字段） |'
- en: '| 4 | Argument (of a top-level field) | Parameter name used to send information
    to a field to tailor the behavior and results of that field |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 参数（顶级字段的） | 用于向字段发送信息的参数名称，以调整该字段的行为和结果 |'
- en: '| 5 | Value | Data related to an argument sent to a field |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 值 | 与发送给字段的参数相关的数据 |'
- en: '| 6 | Field | Nested function that returns a single unit of information or
    object requested within an operation |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 字段 | 返回在操作中请求的单一信息或对象的嵌套函数 |'
- en: '| 7 | Directive | Feature used to decorate fields to change their validation
    or execution behavior, altering a value returned by a GraphQL server |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 指令 | 用于修饰字段的特性，改变其验证或执行行为，从而改变 GraphQL 服务器返回的值 |'
- en: '| 8 | Argument (of a directive) | Parameter name used to send information to
    a field or object to tailor its behavior and results |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 参数（指令的） | 用于向字段或对象发送信息的参数名称，以调整其行为和结果 |'
- en: '| 9 | Argument (of a field) | Parameter name used to send information to a
    field to tailor the behavior and results of the field |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 参数（字段的） | 用于向字段发送信息的参数名称，以调整字段的行为和结果 |'
- en: The following sections explore these components, as well as a few additional
    GraphQL features, with a focus on how they contribute to GraphQL’s attack surface.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将探索这些组件，以及一些额外的 GraphQL 特性，重点讨论它们如何影响 GraphQL 的攻击面。
- en: Queries, Mutations, and Subscriptions
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询、变更和订阅
- en: We discussed the root operation types query, mutation, and subscription in Chapter
    1 and showed an example of using the query type to retrieve data. (For that reason,
    we won’t revisit the query type here.) As hackers, the real fun often happens
    when we can modify data. Creating, updating, and deleting data within a target
    platform empowers us to expose business logic flaws.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第1章讨论了根操作类型查询、变更和订阅，并展示了使用查询类型获取数据的示例。（因此我们在这里不再重复查询类型。）作为黑客，真正的乐趣通常发生在我们能够修改数据时。在目标平台中创建、更新和删除数据使我们能够暴露业务逻辑漏洞。
- en: Mutations
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变更
- en: 'In GraphQL, we can unlock data modification powers by using *mutations*. Here
    is an example of a mutation query:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 中，我们可以通过使用*变更*来解锁数据修改功能。下面是一个变更查询的示例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We define the mutation operation by using the `mutation` keyword. Then we call
    the top-level `editPaste` field, which accepts the arguments `id` and `content`.
    (We will discuss arguments later in this chapter.) This mutation essentially takes
    the paste with the `id` of `1` and updates its content. We then request the updated
    paste. This is an example of a mutation that changes and reads data simultaneously.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `mutation` 关键字定义变更操作。然后我们调用顶级的 `editPaste` 字段，它接受 `id` 和 `content` 参数。（我们将在本章稍后讨论参数。）这个变更操作本质上是将
    `id` 为 `1` 的粘贴内容更新。然后我们请求更新后的粘贴。这是一个同时更改和读取数据的变更示例。
- en: Subscriptions
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 订阅
- en: 'The *subscription* operation works bidirectionally: it allows clients to retrieve
    real-time data from a server, and allows servers to send updates to clients. Subscriptions
    are not as common as queries and mutations, but many servers do use them, so it
    is important to know how they work.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*订阅*操作是双向工作的：它允许客户端从服务器获取实时数据，并允许服务器向客户端发送更新。订阅不像查询和变更那样常见，但许多服务器确实使用它们，因此了解它们的工作原理是很重要的。'
- en: Subscriptions are carried over a transport protocol, most commonly *WebSocket*,
    a real-time communication protocol that allows clients and servers to exchange
    messages at any given time over a long-lived connection. However, because the
    GraphQL specification doesn’t define which transport protocol to use for subscriptions,
    you might see consumers use other ones.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅通过传输协议进行传输，最常见的是*WebSocket*，一种实时通信协议，允许客户端和服务器在长时间连接下随时交换消息。然而，由于 GraphQL
    规范并未定义订阅使用的传输协议，你可能会看到消费者使用其他协议。
- en: When a client and server want to communicate over WebSocket, they perform a
    handshake that upgrades the existing HTTP connection to a WebSocket one. WebSocket
    internals are outside the scope of this book, but you can learn more about this
    technology by reading PortSwigger’s technical blog post on the topic at [https://portswigger.net/web-security/websockets/what-are-websockets](https://portswigger.net/web-security/websockets/what-are-websockets).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Because DVGA supports subscriptions over WebSocket, we can observe the handshake
    between DVGA’s frontend interface and the GraphQL server. Clients can use subscriptions
    to fetch information from the DVGA server, such as newly created pastes. For example,
    when you browse to the Public Pastes page on *http://localhost:5013*, you should
    see an outgoing HTTP request that looks like the following in the browser’s developer
    tools Network tab:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The GraphQL server response to this handshake request looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the handshake caused the client and server to switch from HTTP
    to WebSocket, as indicated by the response code of `101 Switching Protocols`.
    The `Sec-WebSocket-Accept` response header informs the client that the server
    has accepted the protocol switch.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'After the handshake completes, DVGA will send a subscription request over the
    newly established WebSocket connection:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We define the subscription operation by using the `subscription` keyword, then
    request the `paste` top-level field and select the `id`, `title`, and `content`
    fields. This subscription allows clients to subscribe to the `paste` field; whenever
    a new paste is created in DVGA, the GraphQL server will notify all subscribers
    of the event. This removes the need for the client to constantly ask the server
    for updates, which is especially useful because the server may not have anything
    new to return at that exact moment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to try sending this subscription request to DVGA by using Altair,
    you’ll need to assign a subscription URL. You can do so in Altair by clicking
    the two-arrow icon on the left sidebar and entering the WebSocket URL ***ws://localhost:5013/subscriptions***.
    Next, to receive data from the DVGA subscription, you’ll need to create a paste.
    You can either use the DVGA user interface to create it via the Public Pastes
    page or send a mutation, like the following one, from another Altair tab:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: WebSocket connections are prone to *cross-site WebSocket hijacking (CSWSH)*
    vulnerabilities, which happen when the server does not validate the origin of
    a client in the handshake process. WebSocket connections can also be vulnerable
    to *man-in-the-middle* *(MITM)* attacks when the transport of messages isn’t carried
    over an encrypted channel such as Transport Layer Security (TLS). The existence
    of such vulnerabilities could have a security impact on actions carried over GraphQL
    subscriptions. In Chapter 9, we’ll cover WebSocket-based attacks in more detail.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Operation Names
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL *operation names* are labels used to uniquely identify an operation
    in certain contexts. They appear in the executable documents that clients send
    to a GraphQL service. These documents can contain a list of one or more operations.
    For example, the document in [Listing 3-1](#listing3-1) shows a single query operation
    requesting a `pastes` top-level field with a nested `title` field.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL的*操作名称*是用于在特定上下文中唯一标识一个操作的标签。它们出现在客户端发送给GraphQL服务的可执行文档中。这些文档可以包含一个或多个操作的列表。例如，[列表
    3-1](#listing3-1)中的文档展示了一个查询操作，要求返回`pastes`顶级字段以及一个嵌套的`title`字段。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-1: An executable query document'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-1：一个可执行的查询文档
- en: If a document contains only one operation, and that operation is a query defining
    no variables and containing no directives, then that operation may be represented
    in its shorthand form, without the `query` keyword, as shown in [Listing 3-2](#listing3-2).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档仅包含一个操作，并且该操作是一个没有定义变量且不包含指令的查询，则该操作可以用简写形式表示，省略`query`关键字，如[列表 3-2](#listing3-2)所示。
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-2: A shorthand query document'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-2：一个简写查询文档
- en: However, a document may also contain multiple operations. If the document has
    more than one operation of the same type, operation names must be used.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个文档也可能包含多个操作。如果文档中有多个相同类型的操作，则必须使用操作名称。
- en: Clients define these operation names, which means they can be completely random,
    making them a great way to potentially fool an analyst reviewing logs of GraphQL
    applications. For example, imagine that a client sends a document using the operation
    name `getPastes`, but instead of returning a list of paste objects, they in fact
    delete all pastes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端定义这些操作名称，这意味着它们可以完全随机，这使得它们成为潜在欺骗分析师（审查GraphQL应用程序日志的人）的一个好方法。例如，假设一个客户端发送了一个使用操作名称`getPastes`的文档，但它并没有返回一个粘贴对象的列表，而是删除了所有粘贴。
- en: '[Listing 3-3](#listing3-3) provides an example of a document with `getPasteTitles`
    and `getPasteContent` set as query operation names. Although these operation names
    are appropriate given the requested content, they could just as well have been
    completely unrelated to the queries’ actions. Only the underlying operation logic
    and selection fields determine the request’s output.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-3](#listing3-3)提供了一个文档示例，其中`getPasteTitles`和`getPasteContent`被设置为查询操作名称。尽管这些操作名称对于所请求的内容是合适的，但它们也可以与查询的实际操作完全无关。只有底层操作逻辑和选择字段决定了请求的输出。'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-3: A query document with multiple operations, each one labeled with
    an operation name'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-3：一个包含多个操作的查询文档，每个操作都带有操作名称标签
- en: Because operation names are client-driven inputs, they could also potentially
    be used as attack vectors for injection. Some implementations of GraphQL allow
    special characters in operation names. The applications might store these names
    in their audit logs, third-party applications, or other systems. These could cause
    mayhem if not properly sanitized.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作名称是客户端驱动的输入，它们也可能成为注入攻击的向量。某些GraphQL的实现允许操作名称中包含特殊字符。应用程序可能会将这些名称存储在审计日志、第三方应用程序或其他系统中。如果没有正确处理，可能会造成混乱。
- en: Another interesting observation you might make after looking at Listings 3-1,
    3-2 and 3-3 is that a client can request the exact same information by using different
    documents. This level of freedom offers clients a lot of power; however, it increases
    the number of possible requests, which in turn increases the application’s attack
    surface. Parsers that don’t take into consideration the various ways a query can
    be constructed are prone to unexpected errors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能会在查看列表 3-1、3-2 和 3-3 后注意到的有趣现象是，客户端可以通过使用不同的文档请求完全相同的信息。这种自由度给客户端带来了很大的能力；然而，它也增加了可能的请求数量，从而增加了应用程序的攻击面。那些没有考虑到查询构造方式的解析器，容易发生意外错误。
- en: Fields
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段
- en: 'A *field* is a single piece of information available within an operation’s
    *selection set*, or the list encapsulated between the curly brackets (`{}`). In
    the following example, `id`, `title`, and `content` are fields:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*字段*是操作的*选择集*中可用的单个信息项，选择集是位于大括号（`{}`）之间的列表。在以下示例中，`id`、`title`和`content`是字段：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because these three fields sit at the root level of the shorthand query, they
    are also known as *top-level fields*. Fields may also contain their own selection
    set, allowing for the representation of complex data relationships. In the following
    example, the top-level `owner` field has its own selection set with one nested
    field:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这三个字段位于快捷查询的根级别，它们也被称为*顶级字段*。字段也可以包含它们自己的选择集，允许表示复杂的数据关系。在以下示例中，顶级`owner`字段有其自己的选择集，其中包含一个嵌套字段：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, selection sets are made up of fields, and fields can have their own selection
    sets with their own fields. Do any security issues jump out at you? In Chapter
    5, we’ll explore how circular field relationships may result in recursive and
    expensive requests that can degrade performance and potentially crash a GraphQL
    server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，选择集由字段组成，字段可以具有其自己的选择集和它们自己的字段。您有什么安全问题要指出吗？在第5章中，我们将探讨循环字段关系可能导致递归和昂贵请求的安全问题，这可能会降低性能并潜在崩溃GraphQL服务器。
- en: 'Fields are very important when it comes to interacting with GraphQL services.
    Not knowing what fields are available can be pretty limiting. Luckily, implementations
    have deployed a handy tool for us, known as *field suggestions*. When a client
    misspells a field, the error message returned by a server that implements field
    suggestions will reference the field it believes the client was trying to call.
    For example, if we sent a query for a paste with the field name of `titl` in DVGA
    (notice the typo), the server will respond with suggested alternatives:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及与GraphQL服务交互时，字段非常重要。不知道有哪些字段可用可能会相当限制。幸运的是，实现已为我们部署了一个方便的工具，称为*字段建议*。当客户端拼写错误字段时，实现字段建议的服务器返回的错误消息将引用它认为客户端试图调用的字段。例如，如果我们在DVGA中发送一个查询，字段名称为`titl`（注意拼写错误），服务器将以建议的替代方案响应：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This field suggestion feature makes GraphQL a convenient, friendly, and simple
    tool not only for API consumers but also for hackers. We can exploit this feature
    to find fields we may not have known about otherwise. We’ll discuss this information
    disclosure technique in Chapter 6.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字段建议功能使得GraphQL不仅对API消费者而言成为一个方便、友好和简单的工具，对于黑客来说也是如此。我们可以利用此功能来发现我们可能不知道的字段。我们将在第6章讨论这种信息披露技术。
- en: Arguments
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: Like REST APIs, GraphQL allows clients to send *arguments* for various fields
    in their queries to tailor the results they return. If you take another look at
    [Figure 3-1](#figure3-1), you’ll notice that arguments can be implemented at various
    levels—namely, in fields and directives.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与REST API类似，GraphQL允许客户端为其查询中的各种字段发送*参数*，以定制它们返回的结果。如果您再看一下[图3-1](#figure3-1)，您会注意到参数可以在各个级别实现，即在字段和指令中。
- en: 'In the following query, the `users` field has an `id` argument with a value
    of `1`. Without the `id` argument, this query would return the entire list of
    users in DVGA. The argument filters this list to those with the same identifier:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下查询中，`users`字段具有一个`id`参数，其值为`1`。如果没有`id`参数，此查询将返回DVGA中的整个用户列表。该参数将此列表过滤为具有相同标识符的用户：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As expected, the response to this request will return a single user object,
    its ID, and its username:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，对此请求的响应将返回单个用户对象、其ID和其用户名：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Arguments can also be passed to nested fields. Consider this query:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 参数也可以传递给嵌套字段。考虑这个查询：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The nested `username` field now has an argument called `capitalize`. This argument
    accepts a Boolean value, here set to `true`. In DVGA, this argument will make
    GraphQL capitalize the first character of the username field and return it in
    the response, converting `admin` into `Admin`, for example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的`username`字段现在具有名为`capitalize`的参数。此参数接受一个布尔值，此处设置为`true`。在DVGA中，此参数将使GraphQL将用户名字段的第一个字符大写，并在响应中返回，例如将`admin`转换为`Admin`：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Arguments are *unordered*, which means that changing their order does not change
    the logic of the query. In the following example, whether you pass the `limit`
    argument or the `public` argument first doesn’t change the query’s meaning:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是*无序*的，这意味着改变它们的顺序不会改变查询的逻辑。在以下示例中，无论您先传递`limit`参数还是`public`参数，都不会改变查询的含义：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The way these arguments are processed and validated is completely up to the
    application, and implementation differences could lead to vulnerabilities. For
    example, because GraphQL is strongly typed, passing an integer value to an argument
    that expects a string value will result in a validation error. If you instead
    pass it a string, the validation at the GraphQL level will pass, but the application
    should still verify the format of this input. If the value is an email address,
    for instance, the application might check the value against an email-format regular
    expression or look for the at (`@`) symbol.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数的处理和验证方式完全由应用程序决定，实施差异可能导致安全漏洞。例如，由于 GraphQL 是强类型的，将一个整数值传递给一个期望字符串值的参数将导致验证错误。如果你传递的是字符串，GraphQL
    层面的验证会通过，但应用程序仍应验证该输入的格式。例如，如果该值是一个电子邮件地址，应用程序可能会使用正则表达式检查其格式是否符合电子邮件地址的规范，或者检查是否包含
    `@` 符号。
- en: If an application uses a library that provides custom scalar types for email
    addresses, the library itself could perform this validation, making it harder
    for the application maintainers to make mistakes. External GraphQL libraries,
    such as graphql-scalars ([https://github.com/Urigo/graphql-scalars](https://github.com/Urigo/graphql-scalars))
    for JavaScript, provide useful custom scalar types for specific use cases, such
    as timestamps, IP addresses, website URLs, and more. Of course, vulnerabilities
    in custom scalar types could still exist. For example, a vulnerability found in
    Python’s ipaddress library (CVE-2021-29921) could enable an attacker to bypass
    IP-based access controls.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用了一个为电子邮件地址提供自定义标量类型的库，该库本身可能会执行此验证，从而减少应用程序维护人员犯错的机会。像 graphql-scalars（[https://github.com/Urigo/graphql-scalars](https://github.com/Urigo/graphql-scalars)）这样的外部
    GraphQL 库为特定用例提供了有用的自定义标量类型，例如时间戳、IP 地址、网站 URL 等。当然，自定义标量类型中仍然可能存在漏洞。例如，Python
    的 ipaddress 库中发现的漏洞（CVE-2021-29921）可能使攻击者绕过基于 IP 的访问控制。
- en: As you can see, arguments give clients a lot of power to manipulate the behavior
    of their requests and are another great attack vector. Because the value of an
    argument is client driven, it can potentially be stuffed with malicious content
    in injection-based attacks. In Chapter 8, we highlight tools and techniques used
    to exploit arguments if their values are not properly sanitized for injection
    purposes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，参数赋予了客户端很大的权限来操控请求的行为，因此它们是另一个重要的攻击向量。由于参数的值由客户端驱动，它可能会在基于注入的攻击中被填充恶意内容。在第
    8 章中，我们将介绍如果参数值没有正确清理以防止注入攻击时，如何利用这些参数的工具和技术。
- en: Aliases
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 别名
- en: '*Aliases* allow clients to change a field’s response key to something other
    than the original field’s name. For example, here we use `myalias` as an alias
    for the `title` field name:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*别名* 允许客户端将字段的响应键更改为与原字段名称不同的内容。例如，在这里我们将 `myalias` 作为 `title` 字段名称的别名：'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The response will contain the `myalias` key instead of the original `title`
    field name:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将包含 `myalias` 键，而不是原始的 `title` 字段名称：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Aliases can come in handy when you’re dealing with identical response keys.
    Consider the query in [Listing 3-4](#listing3-4).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理相同的响应键时，别名非常有用。请参阅[列表 3-4](#listing3-4)中的查询。
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 3-4: Duplicate queries with different argument values'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-4：使用不同参数值的重复查询
- en: 'In this query, we use the `pastes` field twice. In each query, we pass it the
    `public` argument with different values (`false` and `true`). The `public` argument
    is a way to filter for specific pastes based on their permissions: a public paste
    is viewable by all clients, while a private paste can be viewed by only the original
    author. Copy the query from [Listing 3-4](#listing3-4) into Altair and send it
    to the DVGA. You should see the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，我们使用了 `pastes` 字段两次。在每个查询中，我们传递了不同值的 `public` 参数（`false` 和 `true`）。`public`
    参数是一种根据权限过滤特定粘贴内容的方式：公开粘贴可以被所有客户端查看，而私密粘贴仅能由原作者查看。将[列表 3-4](#listing3-4)中的查询复制到
    Altair 并发送给 DVGA，你应该看到以下输出：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The GraphQL server tells us that a conflict occurred while using this query.
    Since we’ve sent the same query using different arguments, GraphQL is unable to
    process them together. This is where aliases are helpful: we can rename our queries
    so the server will treat them differently. [Listing 3-5](#listing3-5) shows how
    to use aliases to avoid key conflicts.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 服务器告诉我们，在使用此查询时发生了冲突。由于我们使用不同的参数发送了相同的查询，GraphQL 无法同时处理它们。这时，别名就派上用场了：我们可以重命名查询，使服务器将其视为不同的查询。[列表
    3-5](#listing3-5) 展示了如何使用别名来避免键冲突。
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 3-5: Aliasing two queries'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following response, you will notice two JSON keys, `queryOne` and `queryTwo`,
    for each alias we specified in the query at [Listing 3-5](#listing3-5). You can
    think of each JSON key as a separate response to a distinct query:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So far, aliases look pretty innocent. Rest assured that we can weaponize them.
    In Chapter 5, we will teach you how to leverage aliases for a variety of DoS attacks,
    and in Chapter 7, we’ll use them to defeat authentication controls.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Fragments
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Fragments* allow clients to reuse the same set of fields in a GraphQL query
    for readability and to avoid field repetition. Instead of repeating the fields,
    you can define a fragment once and use it whenever you need that particular set
    of fields.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Fragments are defined using the `fragment` keyword, followed by any name you
    desire, and declared using the `on` keyword on an object type name:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, we define a fragment named `CommonFields`. Using the `on`
    keyword, we declare that this fragment is related to the `PasteObject`, which
    can give us access to fields that you are already familiar with by now, such as
    `title` and `content`. [Listing 3-6](#listing3-6) shows how to use this fragment
    in a query:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 3-6: Defining the `CommonFields` fragment and using it in a query'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Using three dots (`...`), also called a *spread operator*, we can reference
    the `CommonFields` fragment in different parts of a query to access paste-related
    fields such as `title` and `content`. There is no limit to the number of times
    a fragment can be referenced in a query.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: From a penetration testing perspective, fragments can be constructed such that
    they reference one another, allowing for a circular fragment condition that could
    lead to DoS conditions. You will learn how to abuse this in Chapter 5.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can supply *variables* to operations as argument values by declaring them
    within the GraphQL document. Variables are useful because they avoid costly string
    building during runtime.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Variables are defined at the top of an operation, after the operation name.
    [Listing 3-7](#listing3-7) shows a query that uses a variable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 3-7: The `status` variable passed to the `public` argument of the `pastes`
    object'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Using the dollar sign (`$`) symbol, we provide the variable name `status` and
    its type, `Boolean`. The `!` after the variable type means that the variable is
    required for the operation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: To set the variable’s value, you can either provide a default value when defining
    the variable type or send a JSON object with the variable name and value in the
    document. In Altair, you can define variables within the Variables pane located
    directly below the left-hand Query pane, as shown in [Figure 3-2](#figure3-2).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we pass a variable named `status` with a Boolean value of `false`.
    This value will be used wherever the variable exists in the document. Variables
    provide an easier way to reuse the values we pass to arguments in fields or directives.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c03/f03002.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c03/f03002.png)'
- en: 'Figure 3-2: The Altair Variables pane (in the bottom-left corner)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：Altair 变量窗格（位于左下角）
- en: Directives
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指令
- en: '*Directives* allow you to *decorate*, or change the behavior of, a field within
    a document. The behavior change could affect the way the particular field gets
    validated, processed, or executed by the application. Directives can be seen as
    arguments’ big brother, as they allow for higher-level control, such as conditionally
    including or skipping fields based on certain logic. They come in two flavors:
    query level and schema level. Both types are declared with `@` and can leverage
    arguments (much like fields).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*指令*允许你*装饰*或改变文档中字段的行为。行为变化可能会影响特定字段在应用程序中的验证、处理或执行方式。指令可以被看作是参数的“高级版本”，因为它们允许更高层次的控制，比如根据某些逻辑有条件地包含或跳过字段。指令分为两种类型：查询级别和模式级别。两种类型都以`@`开头，并且可以利用参数（类似于字段）。'
- en: Implementations typically provide several out-of-the-box directives, and GraphQL
    API developers can also create their own custom directives as they please. Unlike
    operation names or aliases, clients can use only the directives defined by the
    server. [Table 3-2](#table3-2) shows the common default directives you will often
    see in the wild, their use, and the location in which they are defined.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实现通常提供几种开箱即用的指令，GraphQL API 开发人员也可以根据需要创建自己的自定义指令。与操作名称或别名不同，客户端只能使用服务器定义的指令。[表
    3-2](#table3-2)显示了你在实际使用中经常会看到的常见默认指令，它们的用途以及定义的位置。
- en: 'Table 3-2: Common Schema and Query-Level Directives'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2：常见的模式和查询级别指令
- en: '| **#** | **Name** | **Description** | **Location** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **#** | **名称** | **描述** | **位置** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | `@skip` | Conditionally omits a field from the response | Query |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `@skip` | 有条件地从响应中省略字段 | 查询 |'
- en: '| 2 | `@include` | Conditionally includes a field in the response | Query |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `@include` | 有条件地将字段包含在响应中 | 查询 |'
- en: '| 3 | `@deprecated` | Signals a deprecation of a schema component | Schema
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `@deprecated` | 表示某个模式组件已弃用 | 模式 |'
- en: '| 4 | `@specifiedBy` | Specifies a custom scalar type (such as RFCs) | Schema
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `@specifiedBy` | 指定自定义标量类型（如 RFC） | 模式 |'
- en: Clients can apply the `@skip` directive to a field to dynamically omit it from
    the response. When the `if` condition in the directive’s argument is `true`, the
    field won’t be included. Consider the query in [Listing 3-8](#listing3-8).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以将`@skip`指令应用于某个字段，以动态地将其从响应中省略。当指令参数中的`if`条件为`true`时，该字段将不会被包含。请参考[清单 3-8](#listing3-8)中的查询。
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 3-8: Using the `@skip` directive to omit owner information from a query'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-8：使用`@skip`指令从查询中省略所有者信息
- en: We can see the use of the `@skip` directive, which includes an `if` condition,
    check for the value of the `$pasteOnly` Boolean variable ❶. If this variable is
    set to `true`, the entire `owner` field (as well as its nested fields) will be
    skipped and hidden from the response.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`@skip`指令的使用，它包含一个`if`条件，检查`$pasteOnly`布尔变量的值 ❶。如果此变量设置为`true`，整个`owner`字段（以及它的嵌套字段）将被跳过，并从响应中隐藏。
- en: The `@include` query directive is the opposite of the `@skip` directive. It
    will include only a field and its nested fields if the argument passed to it is
    set to `true`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`@include`查询指令与`@skip`指令相反。只有当传递给它的参数设置为`true`时，它才会包括该字段及其嵌套字段。'
- en: The `@deprecated` directive is different from the `@skip` and `@include` directives
    because clients do not use it in query documents. Known as a *schema-level directive*,
    `@deprecated` is used only in GraphQL schema definitions. It appears at the end
    of a field or type definition as a way to document that the field or type is no
    longer supported.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`@deprecated`指令不同于`@skip`和`@include`指令，因为客户端不会在查询文档中使用它。作为一种*模式级指令*，`@deprecated`只在GraphQL模式定义中使用。它出现在字段或类型定义的末尾，用于记录该字段或类型不再支持。'
- en: The `@deprecated` ``directive has an optional `reason` string argument that
    allows developers to specify a message to clients or developers who attempt to
    use the field. This information will appear in places such as the responses to
    the introspection query and the documentation section of GraphQL IDE tools such
    as GraphiQL Explorer and GraphQL Playground. [Listing 3-9](#listing3-9) is an
    example schema that shows how the `@deprecated` directive can be used.``
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`@deprecated` ``指令有一个可选的 `reason` 字符串参数，允许开发者指定一条消息，告知那些尝试使用该字段的客户端或开发者。这些信息会出现在如
    introspection 查询的响应以及 GraphQL IDE 工具（如 GraphiQL Explorer 和 GraphQL Playground）中的文档部分等地方。[列表
    3-9](#listing3-9) 是一个示例架构，展示了如何使用 `@deprecated` 指令。``'
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
