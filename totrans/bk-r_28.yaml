- en: '**23**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ADVANCED PLOT CUSTOMIZATION**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many users are first drawn to R because of its impressive graphical flexibility
    and the ease with which you can control and tailor the resulting visuals. In this
    chapter, you’ll take a closer look at the base R graphics device, and at how you
    can fine-tune the plots you’re already familiar with, to get the most use out
    of your visualizations. In the chapters that follow, you’ll then expand your repertoire
    in both `ggplot2` and traditional R graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Much of this chapter will assume you’re familiar with the content of [Chapters
    7](ch07.xhtml#ch07) and [14](ch14.xhtml#ch14). In general, I’ll also assume you’re
    using the standard base R application (for example, *R.app* on a Mac or *Rgui.exe*
    in Windows—see [Appendix A](app01.xhtml#app01)), since the behavior and availability
    of some of the commands can vary if you’re working with R in a different context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your operating system, the default software drivers used to render
    graphical displays on your computer screen are also different. In the standard
    *R.app* application on a Mac, for example, you’ll notice that producing a live
    plot will open a window with a banner title that looks something like *Quartz
    2 [*]*—the default graphics device driver for OS X is the Quartz window system.
    On a Windows machine, you’ll see *R Graphics: Device 2 (ACTIVE)*. The numbering
    of any graphics devices always starts at 2; Device 1 is referred to as the *null
    device*, meaning there’s nothing active currently.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For a list of devices your R session has available, enter* `?Devices` *at
    the prompt. You’ll note that the list includes commands such as* `png` *and* `pdf`*,
    which are the so-called silent graphics devices that enable direct-to-file plotting,
    as detailed in [Chapter 8](ch08.xhtml#ch08). You can use a different device for
    any given plot if you want, though the default is almost always appropriate if
    you’re plotting directly to your screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**23.1 Handling the Graphics Device**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, your plotting has dealt with one image at a time. It’s possible to have
    multiple graphics devices open, but only one will be deemed active at any given
    time (the banner titles highlight the currently active device with the *[*]* or
    the *(ACTIVE)*). This is useful when you’re working on several plots at once or
    want to view or alter one plot without closing any others.
  prefs: []
  type: TYPE_NORMAL
- en: '***23.1.1 Manually Opening a New Device***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The typical base R commands you’ve met already (such as `plot`, `hist`, `boxplot`,
    and so on) will automatically open a device for plotting and draw the desired
    plot, if nothing is currently open. You can also open new device windows using
    `dev.new`; this newest window will immediately become active, and any subsequent
    plotting commands will affect that particular device.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, first close any open graphics windows and then enter the following
    at the R prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a plot of the spatial locations of the occurrences of the
    1000 seismic events in the ready-to-use `quakes` data frame. If the only device
    currently available is Device 1, the null device, any plotting command that refreshes
    a plotting window and produces a new image (such as `plot` here or more specialized
    commands such as `hist` or `boxplot`) will automatically open a new instance of
    the default graphics device before actually plotting the data. On my machine,
    I see *Quartz 2 [*]* open and display the plot of the spatial coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say you’d also like to see a histogram of the number of stations
    that detected each event. Execute the following to open a new plotting window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This new window will be numbered 3 (it usually sits itself on top of the previously
    open window, so you may want to move it to one side with your mouse). Importantly,
    you’ll see that this becomes the active device: on a Mac the *[*]* is now on the
    Device 3 banner; in Windows, Device 3 will say *(ACTIVE)*, and Device 2 will now
    say *(inactive)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can enter the usual command to bring up the desired histogram
    in Device 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you hadn’t used `dev.new`, the histogram would’ve just overwritten the plot
    of the spatial locations in Device 2.
  prefs: []
  type: TYPE_NORMAL
- en: '***23.1.2 Switching Between Devices***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To change something in Device 2 without closing Device 3, use `dev.set` followed
    by the device number you want to make active. The following code activates Device
    2 and replots the locations of the seismic events so that the size of each point
    is proportional to the number of stations that detected the event. It also tidies
    up the axis labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using `dev.set` always confirms the newly active device by printing to the console;
    the specific text will vary according to your operating system and type of device.
  prefs: []
  type: TYPE_NORMAL
- en: Switching back to Device 3, as a final tweak, add a vertical line marking off
    the mean number of detecting stations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 23-1](ch23.xhtml#ch23fig1) shows the two graphics devices after making
    these modifications.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-1: My two visible graphics devices, Device 2 (left) and Device 3
    (right), showing the final results of producing and manipulating two plots of
    the* `quakes` *data*'
  prefs: []
  type: TYPE_NORMAL
- en: '***23.1.3 Closing a Device***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To close a graphics device, either click the *X* with your mouse as you would
    to close any window or use the `dev.off` function (you originally saw this command
    in [Chapter 8](ch08.xhtml#ch08) when closing a direct-to-file device). Calling
    `dev.off()` with no arguments simply closes the currently active device. Otherwise,
    you can specify the device number just as when using `dev.set`. To close the plot
    of the spatial locations, leaving the histogram as the active device, call `dev.off`
    with an argument of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then repeat the call without an argument to close the remaining device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `dev.set`, the printed output tells you what the newly active device
    is after you close one. When you close the last available actionable device, you’re
    returned to the null device.
  prefs: []
  type: TYPE_NORMAL
- en: '***23.1.4 Multiple Plots in One Device***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also control the number of individual plots in any one device. There
    are a few ways to do this; I’ll describe the two easiest ways here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting the mfrow Parameter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Recall the `par` function is used to control various graphical parameters of
    traditional R plots. The `mfrow` argument instructs a new (or the currently active)
    device to “invisibly” divide itself into a grid of the specified dimensions, with
    each cell holding one plot. You pass the `mfrow` option a numeric integer vector
    of length 2 in the order of `c(rows`,columns); as you might guess, its default
    is `c(1,1)`.
  prefs: []
  type: TYPE_NORMAL
- en: In your R session, make sure there are no plotting windows open. Now, say you
    want the two plots of the `quakes` data side by side in the same device. You would
    set `mfrow` as a 1 × 2 grid with the vector `c(1,2)`—one row of plots and two
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first line uses the optional arguments `width` and `height` to preset the
    dimensions of the new device, in inches, so it is twice as wide as it is high.
    [Figure 23-2](ch23.xhtml#ch23fig2) shows exactly how the images are displayed,
    with the creation of a new plot filling the available cells as governed by the
    value of `mfrow`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-2: Using* `mfrow` *in* `par` *to generate a grid of plots in a single
    graphics device, showing the two plots of the* `quakes` *data*'
  prefs: []
  type: TYPE_NORMAL
- en: If you close any graphics devices and rerun this code without the lead-in call
    to `dev.new`, executing `par(mfrow=c(1,2))` will automatically open a graphics
    device of the default square size of 7 × 7 inches. The two plots will still appear
    side by side but will be squashed. You can manually resize the device with your
    mouse to something more appropriate to the set value of `mfrow`, and then when
    you replot, the visualizations and their axes will be clearer. You’ll find you
    use this trial-and-error approach quite often to produce multiple plots in a single
    device, especially if you don’t want to be concerned with explicitly calling `dev.new`
    and setting `width` and `height`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that any use of `par` in this way will affect *only* the currently active
    device. Subsequent calls to `dev.new` will open new devices with, for example,
    `mfrow` set back to be the default “one plot only” with `c(1,1)`. In other words,
    if you want to tailor the options of any new graphics device (including the direct-to-file
    devices), you need to set the required values of `par` after opening the device
    but before executing any plotting commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining a Particular Layout**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can refine the arrangements of plots in a single device using the `layout`
    function, which offers more ways to individualize the panels into which the plots
    will be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Return to the student survey data in `survey` in the `MASS` package. Suppose
    you want an array of three statistical plots—a scatterplot of height on writing
    handspan, side-by-side boxplots of height split by smoking status, and a barplot
    of the frequencies of exercise of the students. If you want the plots arranged
    in a square device (as opposed to a single row or column of three plots), using
    only `mfrow` in `par` may not work best. You could set a square grid with `par(mfrow=c(2,2))`,
    but you’d end up with a blank space for the cell with no image assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use `layout`, you provide the dimensions in a matrix `mat` as the
    first argument; these govern an invisible rectangular grid, just like controlling
    the `mfrow` option. The difference now is that you can use numeric integer entries
    in `mat` to tell `layout` which plot number will go where. Examine the following
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The dimensions of this matrix create a 2 × 2 grid of plotting cells, but the
    values inside `lay.mat` tell R that you want plot 1 to take the upper-left cell,
    plot 2 to take the upper-right cell, and plot 3 to stretch itself over the two
    bottom cells.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `layout` as follows will either silently initialize the active device
    based on `lay.mat` or open a new one (if the null device is the only device currently
    available) and initialize it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you’re ever unsure of the result of your specification, you can use the `layout.show`
    function to see how plots will be placed. The following line produces the image
    on the left of [Figure 23-3](ch23.xhtml#ch23fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Then, once you’ve loaded the `MASS` package by calling `library("MASS")` so
    you can access `survey`, run the following lines to place the plots in the order
    the plotting commands are executed, matched to the integers in `lay.mat`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you’ve already closed down the plot arising from `layout.show`,
    then you’ll need to reinitialize a new device with the same call to `layout` for
    these three plots to display as intended. The result should look like the right
    of [Figure 23-3](ch23.xhtml#ch23fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-3: Left: Using* `layout.show` *to visualize the planned plotting
    layout and order. Right: Demonstrating three plots of the* `survey` *data arranged
    according to* `lay.mat` *through* `layout`.'
  prefs: []
  type: TYPE_NORMAL
- en: Probably the biggest benefit of `layout` is its ability to relax the rigidity
    of plotting cells when compared to using the `mfrow par` option, as you’ve just
    seen. Additional arguments to `layout`, namely, `widths` and `heights`, even allow
    you to preset the relative widths and heights of the cells as structured in the
    `mat` argument. See the documentation in `?layout` for details; you’ll find some
    other examples of its flexibility at the bottom of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*An unfortunate consequence of the two methods discussed here is the inability
    to edit a previous plot once you’ve finished it and moved on to the next. There
    is a* `split.screen` *function, which does allow you to set up several “screens”
    in a single device and switch between them. However, this method requires a lot
    of extra coding and in general doesn’t behave well with regard to plotting regions
    and margins (see the next section) in R. Many users (myself included) prefer to
    remain with* `layout`*, even if it means going through a bit of trial and error.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**23.2 Plotting Regions and Margins**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the main concern when plotting is of course the data set or model being
    visualized, it’s additionally important to ensure the plot is annotated clearly
    and accurately to facilitate correct interpretation. To help do this, you need
    to know how to manipulate and draw in all visible areas of a given device, not
    just the area where your data lie.
  prefs: []
  type: TYPE_NORMAL
- en: For any single plot created using base R graphics, there are three regions that
    make up the image.
  prefs: []
  type: TYPE_NORMAL
- en: • The *plot region* is all you’ve dealt with so far. This is where your actual
    plot appears and where you’ll usually be drawing your points, lines, text, and
    so on. The plot region uses the *user coordinate system*, which reflects the value
    and scale of the horizontal and vertical axes.
  prefs: []
  type: TYPE_NORMAL
- en: • The *figure region* is the area that contains the space for your axes, their
    labels, and any titles. These spaces are also referred to as the *figure margins*.
  prefs: []
  type: TYPE_NORMAL
- en: • The *outer region*, also referred to as the *outer margins*, is additional
    space around the figure region that is not included by default but can be specified
    if it’s needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explicitly measure and set margin space in a few different ways. One
    typical way is in terms of *lines*—specifically, the number of lines of text that
    can fit on top of one another parallel to each edge. You specify these as vectors
    of length 4 in a particular order; each of the four elements corresponds to one
    of the four sides: `c(bottom`, left, top, right). The graphical parameters `oma`
    (outer margin) and `mar` (figure margin) are used to control these amounts; like
    `mfrow`, they are initialized through a call to `par` before you begin to draw
    any new plot.'
  prefs: []
  type: TYPE_NORMAL
- en: '***23.2.1 Default Spacing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can find your default figure margin settings with a call to `par` in R.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that `oma=c(0, 0, 0, 0)`—there is no outer margin set by default.
    The default figure margin space is `mar=c(5.1, 4.1, 4.1, 2.1)`—in other words,
    5.1 lines of text on the bottom, 4.1 on the left and top, and 2.1 on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate these regions, consider the image on the left of [Figure 23-4](ch23.xhtml#ch23fig4),
    created in a fresh graphics device with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f23-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-4: Illustrating graphical device regions as treated by traditional
    (base) R graphics; solid-line boxes show the plot region, dashed-line boxes show
    the figure region, and a dotted-line box shows the outer region area. Left: Default
    settings. Right: User specification, through* `par`*, of the outer and figure
    margin areas in “lines of text” via* `oma` *and* `mar`*, respectively.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you use the `box` function with the optional argument `which` set to `"figure"`,
    it shows you the figure region (the additional specification of `lty=2` draws
    dashed lines).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re looking at this plot in your onscreen graphics device, you should
    note the dashed lines snug up against the window edges. Examining the default
    values in `mar`, you can see, relatively speaking, that they correctly correspond
    to the spacing on the four sides of the plot region (given with the default solid
    box). The widest figure margin, parallel to the bottom of the plot region, is
    5.1 lines; the narrowest figure margin, parallel to the right of the plot region,
    is 2.1 lines.
  prefs: []
  type: TYPE_NORMAL
- en: '***23.2.2 Custom Spacing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s produce the same plot but with tailored outer margins so that the bottom,
    left, top, and right areas are one, four, three, and two lines, respectively,
    and the figure margins are four, five, six, and seven lines. The result of the
    following code is given on the right of [Figure 23-4](ch23.xhtml#ch23fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the irregular margins have squashed the plot region in the default
    square device to accommodate the defined spacing around the edges. If you set
    graphical parameters that squash the plot region into nonexistence, R will throw
    an error stating `figure margins too large`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you’d usually manipulate margin space to accommodate particular annotations
    of the plot, let’s look at the `mtext` function, used specifically to produce
    text in the figure or outer margins. By default, the argument `outer` is `FALSE`,
    meaning the text will be written in the figure margin. Setting `outer=TRUE` positions
    the text in the outer region. If you’ve kept the most recent plot open, the following
    lines provide the additional margin annotation visible on the right of [Figure
    23-4](ch23.xhtml#ch23fig4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, you provide the text you want written in a character string as the first
    argument, and the argument line instructs how many lines of space away from the
    inside border the text should appear. There’s also an optional argument `side`
    in `mtext`, which dictates where the text appears. It defaults to `3`, setting
    the text at the top, but you can set `side=1` to place the text on the bottom,
    use `side=2` to set it on the left, and use `side=4` to set it on the right. Look
    to `?mtext` for details on even more arguments available for the margin text.
  prefs: []
  type: TYPE_NORMAL
- en: You might also like to investigate the ready-to-use function `title`, which
    is a specialized implementation of `mtext` often used if figure margin annotation
    for the four axes of a plot (beyond the basic capabilities of specifying things
    such as `main`, `xlab`, or `ylab`) is the primary concern.
  prefs: []
  type: TYPE_NORMAL
- en: '***23.2.3 Clipping***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Controlling *clipping* allows you to draw in or add elements to the margin regions
    with reference to the user coordinates of the plot itself. For example, you might
    want to place a legend outside the plotting area, or you might want to draw an
    arrow that extends beyond the plot region to embellish a particular observation.
  prefs: []
  type: TYPE_NORMAL
- en: The graphical parameter `xpd` controls clipping in base R graphics. By default,
    `xpd` is set to `FALSE`, so all drawing is clipped to the available plot region
    only (with the exception of special margin-addition functions such as `mtext`).
    Setting `xpd` to `TRUE` allows you to draw things outside the formally defined
    plot region into the figure margins but not into any outer margins. Setting `xpd`
    to `NA` will permit drawing in all three areas—plot region, figure margins, and
    the outer margins.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at the images in [Figure 23-5](ch23.xhtml#ch23fig5),
    showing side-by-side boxplots of mileage split by number of cylinders, created
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The particular result of this code is the top-left image in [Figure 23-5](ch23.xhtml#ch23fig5).
    I’ve defined the device region itself with particular figure and outer margins
    for the purpose of illustration. The plotting of the horizontal axis is suppressed
    with `xaxt="n"` in the call to `boxplot`; calls to `box` add the boundaries of
    the figure and outer margins (dashed and dotted lines, respectively). Lastly,
    calls to `arrows` and `text` point to and annotate each boxplot; the label for
    V4 cars extends into the outer margin, the label for V6 cars extends into the
    figure region, and the label for V8 cars remains contained within the plot region.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the graphical parameter `xpd` is specified only in the two “add-to-current-plot”
    functions `arrows` and `text`, explicitly set as the default `FALSE`. This means
    all plotting is restricted to the plot region.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the code chunk again but now set `xpd=TRUE` in the calls to `arrows`
    and `text`, you’ll get the image in the top right of [Figure 23-5](ch23.xhtml#ch23fig5).
    This allows the label for the V6 car to be printed in the margin, instead of being
    chopped off. Finally, rerunning the code with `xpd=NA` produces the lower plot
    in [Figure 23-5](ch23.xhtml#ch23fig5), where all drawing outside the plot region
    is permitted.
  prefs: []
  type: TYPE_NORMAL
- en: This effect is usually desirable when you need to annotate the main plot somehow,
    especially when there isn’t enough space in the plot region to squeeze in any
    additions. Plots that I’ve created in earlier chapters, such as the bottom image
    of [Figure 16-6](ch16.xhtml#ch16fig6) on [page 349](ch16.xhtml#page_349) (where
    the legend sits outside the main plot) and [Figure 17-3](ch17.xhtml#ch17fig3)
    on [page 380](ch17.xhtml#page_380) (where I annotated the critical values), were
    created specifying `xpd=TRUE` in the relevant functions (`legend`, `text`, `segments`,
    and `arrows`).
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated, you’d typically set `xpd` in the specific commands (in other
    words, on a line-by-line basis), so only the results of that particular command
    will be produced with the given clipping rule. This offers a bit more control
    over what is and isn’t visible outside the plot region. You can, however, set
    `xpd` alongside `oma` and `mar` in the initial call to `par` to make the value
    of `xpd` “universal” to that device.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-5: Illustrating the behavior of setting* `xpd=FALSE` *(top left,
    default),* `xpd=TRUE` *(top right), and* `xpd=NA` *(bottom) in relevant plotting
    commands to enable drawing in figure and outer margins with respect to the user
    coordinates of the plot region*'
  prefs: []
  type: TYPE_NORMAL
- en: '**23.3 Point-and-Click Coordinate Interaction**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your dealings with the graphics device don’t need to be solely command based.
    Under typical circumstances, R can read mouse clicks you make inside the device.
  prefs: []
  type: TYPE_NORMAL
- en: '***23.3.1 Retrieving Coordinates Silently***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `locator` command allows you to find and return user coordinates. To see
    how it works, first execute a call to `plot(1,1)` to bring up a simple plot with
    a single point in the middle. To use `locator`, you simply execute the function
    (with no arguments for default behavior), which will “hang” the console, without
    returning you to the prompt. Then, on an active graphics device, your mouse cursor
    will change to a + symbol (you may need to first click your device once to bring
    it to the foreground of your computer desktop). With your cursor as the +, you
    can perform a series of (left) mouse clicks inside the device, and R will silently
    record the precise user coordinates. To stop this, simply right-click to terminate
    the command (other options to stop are system dependent and are mentioned in the
    help file `?locator`), and once you do, the coordinates you identified in the
    device are returned as a list with components `$x` and `$y`. These are printed
    to the console screen unless you specifically assign the call to `locator` to
    an R object.
  prefs: []
  type: TYPE_NORMAL
- en: 'On my machine, I silently identified four points at arbitrary locations around
    the plotted point at (1,1), from top left clockwise around to the bottom left.
    The following is the output printed to my console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This silent use of `locator` is useful if you need to, for example, identify
    approximate user coordinates in the plot region where you need to place future
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '***23.3.2 Visualizing Selected Coordinates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also use `locator` to plot the points you select as either individual
    points or as lines. Running the following code produces [Figure 23-6](ch23.xhtml#ch23fig6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Drawing using `locator` requires you to specify the plot `type`, as covered
    in [Chapter 7](ch07.xhtml#ch07). Selecting `type="o"` (as opposed to the silent
    default, `type="n"`) is what produces the overplotted points and lines in [Figure
    23-6](ch23.xhtml#ch23fig6). For just points, use `type="p"`; for just lines, use
    `type="l"`. The graphical parameters controlling other relevant features, such
    as point/line type and color, can also be used, as you’ve seen in conventionally
    produced plots in [Chapter 7](ch07.xhtml#ch07). I also used `xpd=TRUE`, shown
    earlier, to allow the `locator` points and/or lines to protrude into the figure
    region margins. The call to `locator` is directly assigned to a new object `Rtist`,
    illustrating how you can use the clicked coordinates later if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-6: Using* `locator` *to draw an arbitrary sequence of overplotted
    points and lines*'
  prefs: []
  type: TYPE_NORMAL
- en: '***23.3.3 Ad Hoc Annotation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `locator` function also allows you to place ad hoc annotations, such as
    legends, on your plot—remember, since `locator` returns valid R user coordinates,
    these results can directly form the positional argument of most standard annotation
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Return to the student survey data in the `MASS` package, first loading the package
    by calling `library("MASS")`. The following call produces the scatter-plot used
    to illustrate a multiple linear model of mean student height as a function of
    handspan and sex in [Section 21.3.3](ch21.xhtml#ch21lev2sec195).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For the plot in [Section 21.3.3](ch21.xhtml#ch21lev2sec195) ([Figure 21-1](ch21.xhtml#ch21fig1)
    on [page 495](ch21.xhtml#page_495)), I simply used the string `"topleft"` to position
    the legend. This time, call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: An optional argument to `locator`, `n`, takes a positive integer for an upper
    limit on how many points you want to select; it defaults to `512`. If you specify
    `n=1`, `locator` will automatically terminate after you left-click once in the
    device, so you don’t need to manually exit the function with a right-click.
  prefs: []
  type: TYPE_NORMAL
- en: When the code is executed, the + cursor will appear on the graphics device,
    and you simply need to click once for the desired location of the legend. I chose
    to click the blank space above the cloud of points, producing the image in [Figure
    23-7](ch23.xhtml#ch23fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-7: Ad hoc placement of a legend on a scatterplot of the* `survey`
    *data*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 23.1**'
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 20.5.4](ch20.xhtml#ch20lev2sec188) ([page 478](ch20.xhtml#page_478)),
    I gave you code showing a simple linear model fitted with a categorical predictor
    being treated as continuous (the `mtcars` data with `mpg` as the response and
    `cyl` as the explanatory variable). Reproduce the side-by-side boxplots and the
    scatterplot (with fitted line) from [Figure 20-6](ch20.xhtml#ch20fig6), but this
    time, use `mfrow` to present the two plots as a vertical column in one device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the appropriate layout matrices to reproduce the following three plots
    (as they appear in a square device):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0589-01a.jpg)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_IMG
- en: '![image](../images/f0589-02a.jpg)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_IMG
- en: '![image](../images/f0589-03a.jpg)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_IMG
- en: 'By opening a new device of dimension 9 × 4.5 inches, set the following layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0589-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Then, produce the following combined set of plots exactly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0590-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'To achieve this, note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – After you open the device and setting the layout, the plot margins should
    be reset to four lines, four lines, two lines, and one line of space on the bottom,
    left, top, and right, respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – After each plot, add a gray box corresponding to the figure region to achieve
    the visible partitions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Plots 1 and 4 are the same as the two plots shown in [Figures 23-1](ch23.xhtml#ch23fig1)
    and [23-2](ch23.xhtml#ch23fig2).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Plots 2 and 3 are scatterplots showing the number of detecting stations on
    the *y*-axis, with magnitude and depth on the *x*-axis, respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Do not place main titles on any plots, and ensure the axis titles are neat
    (that is, compared to their defaults).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a little R function named `interactive.arrow`. The purpose of this function
    is to superimpose an arrow upon any base R plot using two clicks of your mouse.
    The details are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – The crux of your function will be the use of `locator` to read exactly two
    mouse clicks. You may assume a suitable active graphics device is already open
    whenever the function is called. The first click should mean the beginning of
    the arrow, and the second click should mean the tip of the arrow (where it’s pointing
    to).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – In the function, the coordinates returned by `locator` should be passed to
    `arrows` to do the actual drawing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The function should take an ellipsis as its first argument, intended to hold
    additional arguments to be passed directly to `arrows`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The function should take an optional logical argument `label`, which defaults
    to `NA` but should be intended to have an optional character string. If `label`
    is not `NA`, then `locator` should be invoked once more (separately, after drawing
    the arrow) to select exactly one coordinate. That point will be passed to `text`
    so that the user can additionally place the character string given to `label`
    as an annotation (intended to be for the interactively placed arrow). The call
    to `text` should consistently allow completely relaxed clipping (in other words,
    any text added in this fashion will still be visible in the figure region and
    outer margins, if there are any).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Take another look at the rightmost plot of [Figure 14-6](ch14.xhtml#ch14fig6)
    on [page 298](ch14.xhtml#page_298), a stand-alone boxplot of the magnitude data
    from the `quakes` data frame. Arrows and labels were superimposed externally pointing
    out the various statistics summarized by a boxplot. Create the same boxplot and
    use `interactive.arrow` to annotate the same features to your own satisfaction
    (you’ll likely have to use the ellipsis to relax the clipping associated with
    each arrow). My result is given here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0591-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**23.4 Customizing Traditional R Plots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’re familiar with the way R places and handles plots in the graphics
    device, it’s time to focus on common features of plots. So far, you’ve largely
    left the default settings in place.
  prefs: []
  type: TYPE_NORMAL
- en: '***23.4.1 Graphical Parameters for Style and Suppression***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want finer control over an R plot, you’ll typically want to begin with
    a “clean slate.” To do this, you need to be aware of the default settings of certain
    graphical parameters when calling a plotting function and of how to suppress things
    such as boxes and axes. This is where you’ll start.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example image, let’s plot MPG against horsepower (from the ready-to-use
    `mtcars` data set) and set each plotted point to be sized proportionally to the
    weight of each car. For convenience, create the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The last object is the car weight vector scaled by its sample mean. This creates
    a vector where cars less than the average weight have a value < 1 and cars more
    than the average weight have a value > 1, making it ideal for the `cex` parameter
    to scale the size of the plotted points accordingly (refer to [Chapter 7](ch07.xhtml#ch07)).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by focusing on some more graphical parameters usually used in the
    first instance of a call to `plot`, paving the way for using the `box` and `axis`
    commands. Executing the following line gives you the default appearance of the
    plot and its box, axes, and labeling; this is shown as the leftmost image in [Figure
    23-8](ch23.xhtml#ch23fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are two axis “styles,” controlled by the graphical parameters `xaxs` and
    `yaxs`. Their sole purpose is to decide whether to impose the small amount of
    additional horizontal and vertical buffer space that’s present at the ends of
    each axis to prevent points being chopped off at the end of the plotting region.
    The default, `xaxs="r"` and `yaxis="r"`, is to include that space. The alternative,
    setting one or both of these to `"i"`, instructs the plot region to be *strictly*
    defined by the upper and lower limits of the data (or by those optionally supplied
    to `xlim` and/or `ylim`), that is, with *no* additional padding space.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following line produces the middle plot in [Figure 23-8](ch23.xhtml#ch23fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This plot is almost the same as the default, but note now that there’s no padding
    space at the end of the axes; the most extreme data points sit right on the axes.
    Generally, the default axis style `"r"` is fine, but on occasions where you need
    finer control over the axes’ scales and the corresponding plot region, that additional
    buffer space can be problematic. On those occasions, you’ll often see `xlim`/`ylim`
    being used in conjunction with `xaxs="i"`/`yaxs="i"`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-8: Plotting MPG against horsepower for the* `mtcars` *data; point
    size proportional to car weight, using a call to* `plot` *only. Left: Default
    appearance. Middle: Setting* `xaxs="i"` *and* `yaxs="i"` *to prevent the buffer
    spacing on the limits of the axes. Right: Using* `xaxt`, `yaxt`, `xlab`, `ylab`*,
    and* `bty` *to suppress all box, axis, and label drawing (alternatively achieved
    by setting* `axes=FALSE` *and* `ann=FALSE`*).*'
  prefs: []
  type: TYPE_NORMAL
- en: If you want total control over the specific appearance of any boxes, axes, and
    their labels, you’ll want to start a plot with none of these and add them as per
    your design. The rightmost plot in [Figure 23-8](ch23.xhtml#ch23fig8) is the result
    of suppressing the default drawing of these by a call to either
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can achieve this either by setting the parameters `xaxt`, `yaxt`, and `bty`
    to `"n"` and setting the default axis labels `xlab` and `ylab` to the empty string
    `""`, or by simply setting both `axes` and `ann` to `FALSE` (the former suppressing
    all axes and the box, the latter suppressing any annotation). Although the first
    way might seem overcomplicated, it affords you greater flexibility in suppressing
    each aspect of a given plot (as opposed to the “total” suppression enforced by
    the second approach).
  prefs: []
  type: TYPE_NORMAL
- en: '***23.4.2 Customizing Boxes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you’re starting with a suppressed-box or suppressed-axis plot, to add a
    box specific to the current plot region in the active graphics device, you use
    `box` and specify its type with `bty`. For example, if you start with a plot like
    the one on the right of [Figure 23-8](ch23.xhtml#ch23fig8) (just run the most
    recent line of code to get this), then additionally calling the following line
    provides you with the image given on the left of [Figure 23-9](ch23.xhtml#ch23fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bty` argument is supplied a single character: `"o"` (default), `"l"`,
    `"7"`, `"c"`, `"u"`, `"]"`, or `"n"`. The help file entry for `bty` in `?par`
    tells you that based on one of these values, the resulting box boundaries will
    follow the appearance of the corresponding uppercase letter, with the exception
    of `"n"` (which, as you saw a moment ago, will suppress the box).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-9: Various box configurations added to the* `mtcars` *scatterplot*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use other relevant parameters that you’ve met already, such as `lty`,
    `lwd`, and `col`, to further control the appearance of a box. Replot the data
    as on the right of [Figure 23-8](ch23.xhtml#ch23fig8) and then call the following
    to produce the image in the middle of [Figure 23-9](ch23.xhtml#ch23fig9):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The final example on the right of [Figure 23-9](ch23.xhtml#ch23fig9) is created
    with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '***23.4.3 Customizing Axes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you have the box the way you want it, you can focus on the axes. The `axis`
    function allows you to control the addition and appearance of an axis on any of
    the four sides of the plot region in greater detail. The first argument it takes
    is `side`, provided with a single integer: `1` (bottom), `2` (left), `3` (top),
    or `4` (right). These numbers are consistent with the positions of the relevant
    margin-spacing values when you’re setting graphical parameter vectors like `mar`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you might want to change on an axis is where the tick marks
    are drawn. By default, R uses the built-in function `pretty` to find a “neat”
    sequence of values for the scale of each axis, but you can set your own by passing
    the `at` argument to `axis`. The following lines create the plot on the left of
    [Figure 23-10](ch23.xhtml#ch23fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, an evenly spaced sequence of 10 values spanning the range of `hp` is
    stored as `hpseq`. The initial call to `plot` suppresses the *x*-axis, the box,
    and any default axis labels; however, the *y*-axis is permitted to appear as per
    its default. Then `axis` is instructed to draw the *x*-axis (`side=1`), with tick
    marks at `hpseq`. To provide a comparison to that, an axis is also drawn along
    the top (`side=3`), but this time the tick marks are drawn at `hpseq` after it’s
    rounded to the nearest integer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-10: Customizing axes of the* `mtcars` *scatterplot*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see on the left of the figure, the custom *x*-axis I’ve created on
    the bottom shows 10 tick marks at the sequence of values supplied to `at`. R may
    suppress some of the labels so they don’t overlap one another, which is what has
    occurred here. Since these “decimal” values mightn’t be aesthetically pleasing,
    the axis that’s been drawn along the top has tick marks drawn at the nearest integers
    of `hpseq`, achieved using `round` in the final call to `axis` shown earlier.
    Although, strictly speaking, this now means that the tick marks are no longer
    exactly evenly spaced, the rounded values mean shorter default axis labels that
    can all be displayed in the current device.
  prefs: []
  type: TYPE_NORMAL
- en: You can see from these difficulties that tick mark locations are generally best
    left to R, unless you have specific axis values that you know you want marked
    out—you’ll see an example of this in [Section 23.6](ch23.xhtml#ch23lev1sec81).
    For now, let’s look at some other tweaks you can make to your axes. In particular,
    the `tcl` (length of the ticks), `las` (orientation of the labels), and `mgp`
    (axis spacing) parameters are arguably among those more frequently used. The following
    code creates the plot on the right of [Figure 23-10](ch23.xhtml#ch23fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After a new sequence—`hpseq2`—is defined as all integers that lie within the
    recorded range of the data and are evenly spaced by 25 units, the plot is initialized.
    The box and axes are suppressed, but the default variable titles (`mpg` and `hp`)
    along the axes remain.
  prefs: []
  type: TYPE_NORMAL
- en: Now, an L-shaped box and the *y*-axis (`side=2`) are added. In the latter, the
    `tcl` parameter governs the length of each tick mark in “parallel lines of text”
    (recall this is a standard unit measurement for margin spacing in an R plot);
    it defaults to `-0.5`. When the value is negative, it draws the tick marks away
    from the plot region; when it’s positive, the tick marks are drawn inward. For
    this `side=2` axis, `tcl=-2`, meaning that the ticks will point outward from the
    plot but be four times the length they usually are (two whole lines of text as
    opposed to half a line).
  prefs: []
  type: TYPE_NORMAL
- en: The `las` parameter controls the way the labels for each tick mark are oriented;
    setting it to `1` instructs R to produce all tick labels *horizontally*, regardless
    of axis side. The default, `las=0`, writes all labels *parallel* to the corresponding
    axis; the alternative `las=2` means labels are always *perpendicular* to the corresponding
    axes; and using `las=3` orients all labels to be read *vertically*, regardless
    of axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, the `mgp` parameter controls three further aspects of axis spacing
    and, as such, is supplied a vector of length 3 as per the following definition:
    `c(axis title`,axis labels,axis line). Once more, these arguments are expressed
    in “lines of text.” The default value of `mgp` is `c(3,1,0)`—meaning that in every
    axis you’ve seen so far, the title has sat three lines of text away from the plot
    region, the tick mark labels one line of text away, and the axis line itself zero
    lines of text away from the plot region (so it’s flush with any drawn plot region
    box). When used in `axis`, only the second and third elements of `mpg` are relevant.
    In the vertical axis in the plot on the right of [Figure 23-10](ch23.xhtml#ch23fig10),
    the only alteration from the default was to set the second element (spacing of
    the axis labels) to `2.5`—pushing the axis labels out to the left, further away
    from the plot region. The tick marks themselves are considerably lengthened by
    `tcl`, so this is required to avoid the axis tick mark labels going through those
    ticks. Try replotting the image and that axis, but without specifying `mgp`, and
    you’ll see that unappealing result.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving to the addition of the *x*-axis (`side=1`), you can see tick marks at
    `hpseq2` being placed via `at`. This time, a positive value has been supplied
    to `tcl`, instructing the axis to have *inward*-facing tick marks of 1.5 lines
    of text in length. In `mpg`, note that the third element of the vector is now
    set to `1`, meaning you want the axis line itself to sit one line of text away
    from the plot region. Looking at the right of [Figure 23-10](ch23.xhtml#ch23fig10),
    you can see that the entire axis has been moved downward, away from the plot region.
    To account for this in terms of the spacing of the tick mark labeling, the second
    element of `mgp` has been increased a little from its default, to be `1.5`.
  prefs: []
  type: TYPE_NORMAL
- en: '**23.5 Specialized Text and Label Notation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you’ll investigate some immediately accessible tools for controlling fonts
    and displaying special notation, such as Greek symbols and mathematical expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '***23.5.1 Font***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The displayed font is controlled by two graphical parameters: `family` for
    the specific font family and `font`, an integer selector for controlling bold
    and italic typeface.'
  prefs: []
  type: TYPE_NORMAL
- en: Available fonts depend on both your operating system and the graphics device
    you’re using. That said, there are three generic families—`"sans"` (the default),
    `"serif"`, and `"mono"`—that are always available. These are paired with the four
    possible values of `font`—`1` (normal text, default), `2` (bold), `3` (italic),
    and `4` (bold and italic). You can set these two graphical parameters universally
    for a device using `par`, but like the use of `xpd`, it’s just as common (if not
    more so) to set `family` and `font` in the relevant annotation functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 23-11](ch23.xhtml#ch23fig11) shows you some variants alongside the
    corresponding values of `family` and `font`. To create it, start with an empty
    plot region with preset *x*- and *y*-limits, created with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the image with six possible variants is completed by executing the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, `text` is used to place the content at predetermined coordinates, and
    `mtext` is used to add to the top figure margin.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-11: Displaying font styles through use of the* `family` *and* `font`
    *graphical parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: '***23.5.2 Greek Symbols***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For statistically or mathematically technical plots, annotation may occasionally
    require Greek symbols or mathematical markup. You can display these using the
    `expression` function, which, among other things, is capable of invoking the `plotmath`
    mode of R ([Murrell and Ihaka, 2000](ref.xhtml#ref50); [Murrell, 2011](ref.xhtml#ref49)).
    Use of `expression` returns a special object that has a class of the same name
    and can subsequently be passed to any argument in a plotting function that requires
    the character string to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Focusing for the moment on Greek symbols, consider [Figure 23-12](ch23.xhtml#ch23fig12),
    which is produced with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f23-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-12: Displaying Greek symbols using* `expression`'
  prefs: []
  type: TYPE_NORMAL
- en: If you just want a single special character by itself, then something like `expression(alpha)`
    is all you need to produce *β* in the plot, as in the first call to `text` shown
    in the code chunk. Note that the specification of the special characters is done
    *without* quotes around the name of the desired symbol. More commonly, however,
    you’ll want a character to appear alongside other components, such as regular
    text or in an equation. For that, you need to use `paste` inside the call to `expression`,
    separating the components with commas. These are shown in the remaining three
    calls to `text`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `cex` to control size, though use of `family` and `font` affects
    only quoted regular text, not symbols, as the final call to `text` demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: The `title` function, which allows you to add axis and main titles, is then
    used to add the title “Gr*ɛɛ*k” by supplying the corresponding `expression` to
    `main`. I use `cex.main=2` in the same call to double its size (the slightly different
    tag `cex.main` is required there to distinguish between the size of the main title
    and any axis titles, controlled via `cex.lab`).
  prefs: []
  type: TYPE_NORMAL
- en: '***23.5.3 Mathematical Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Formatting entire mathematical expressions to appear in R plots is a bit more
    complicated and is reminiscent of using markup languages like LAT[E]X. Because
    of this, I won’t give a full exposition of the syntax required here, but I’ll
    provide some examples of the kinds of things that are possible, as shown in [Figure
    23-13](ch23.xhtml#ch23fig13). To create the image, I first defined four expression
    objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And then I used them in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f23-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-13: Some examples of typesetting mathematical expressions in R plots*'
  prefs: []
  type: TYPE_NORMAL
- en: 'All Greek and mathematical markup is contained within a call to `expression`.
    It’s necessary to use `paste` if you require separate components (separated by
    commas), some of which may or may not be regular text (in other words, in quotes)
    to produce the final result. Here are some key notes:'
  prefs: []
  type: TYPE_NORMAL
- en: • Superscripts are given by `^` and subscripts by `[ ]`; for example, `c^2`
    provides c² in `expr1`, and the `a[1]^2` component provides ![image](../images/f0601-01a.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: • You can group components with parentheses `( )`, which are visible (for example,
    the `(1-pi)^(n-x[i])` component of `expr2`), or with braces `{ }`, which aren’t
    (for example, the `pi^{x[i]}` component).
  prefs: []
  type: TYPE_NORMAL
- en: • Italicized alphabetic variables are drawn with `italic()`; for example, `italic(n)`
    produces *n* in `expr3`.
  prefs: []
  type: TYPE_NORMAL
- en: '• Constructs for common arithmetic operators already exist, such as `sum( ,
    , )` and `frac( , )`; for example, in `expr3`, calling `sum(italic(x)[italic(i)],italic(i)==1,italic(n))`
    produces a result that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0601-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'and `frac(italic(x)[1]+...+italic(x)[italic(n)],italic(n))` produces an expression
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0601-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • There are additional markup tools for proper formatting of expressions, such
    as combining regular text in quotes directly next to mathematical markup and creating
    spaces between components without needing to insert quotes. The need for these
    depends where the markup contents are exactly (in other words, as a stand-alone
    component of the call to `paste` or as a component of an operator tool like `frac`).
    See, for example, the `")"==frac( , )` part of `expr4`, and the space-separation
    of the two components `x^{alpha-1}~(1-x)^{beta-1}` with a `~` (these sit on the
    numerator of the fraction).
  prefs: []
  type: TYPE_NORMAL
- en: There’s an extensive amount of functionality built in to R for this type of
    string formatting in graphical displays that I haven’t covered here. If you’re
    interested in seeing more, see the help file accessed by entering `?plotmath`
    at the prompt as a first step. There’s also an extremely useful demonstration,
    which you can view in R by entering `demo(plotmath)`, that shows off much of what’s
    possible, alongside the relevant syntax for `expression`.
  prefs: []
  type: TYPE_NORMAL
- en: '**23.6 A Fully Annotated Scatterplot**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To provide a final example that covers most of the concepts you’ve considered
    so far, let’s create a detailed plot of the MPG by horsepower data that was used
    in [Sections 23.4.1](ch23.xhtml#ch23lev2sec232) to [23.4.3](ch23.xhtml#ch23lev2sec234).
    The images in [Figure 23-14](ch23.xhtml#ch23fig14) show the final result as the
    largest plot on the bottom, with three smaller interim plots to illustrate the
    various stages of production appearing along the top.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f23-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-14: A detailed version of the* `mtcars` *scatterplot of MPG by horsepower,
    with point size proportional to weight*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, ensure you have the objects `mpg`, `hp`, `wtcex`, and `hpseq2` (defined
    in [Sections 23.4.1](ch23.xhtml#ch23lev2sec232) and [23.4.3](ch23.xhtml#ch23lev2sec234))
    ready in your workspace, since you’ll use them to ease the length of the code.
    Here they are again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot, with a slightly wider right margin than default and a U-shaped box,
    is started with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This provides the top-left image of [Figure 23-14](ch23.xhtml#ch23fig14). I’ve
    used `dev.new` to explicitly open a new graphics device on my machine, which defaults
    to 7 × 7 inches. You can use `width` and `height` arguments supplied to `dev.new`
    to alter this on your machine if you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add some axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: These two lines add the left vertical axis for MPG; the tick marks are lengthened
    a little using `tcl`, their labels are made horizontal through `las`, and a `"mono"`
    font is requested. For the horizontal axis (horsepower), longer outward tick marks
    are drawn at the values in `hpseq2`, but their labels are suppressed by setting
    `labels=FALSE`. You’ll populate those in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than using MPG as a measure of fuel efficiency, many countries use “liters
    per one hundred kilometers” (L/100km). So, for their benefit, let’s say you want
    to provide a second vertical axis on the right of the plot that provides L/100km.
    To do this, you need the conversion formula. Based on a US gallon, an approximate
    conversion between the two is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0603-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It turns out that this function is *involutory*. That is, to convert from MPG
    back to L/100km, simply swap those two variables in the equation.
  prefs: []
  type: TYPE_NORMAL
- en: A little experimentation with the conversion formula, based on the limits of
    the observed MPG data, has given me a sensible collection of L/100km values at
    which to mark the right axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that these are in decreasing order for convenience, since you can see
    that once you convert these to MPG, the results are increasing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This makes sense—a smaller number for L/100km means a more fuel-efficient car.
  prefs: []
  type: TYPE_NORMAL
- en: Why do you need the MPG version of these numbers? Well, remember that the plot
    itself is on the scale of MPG, so to instruct R to mark off the appropriate tick
    marks on the right side, you need the L/100km values in MPG “coordinates.”
  prefs: []
  type: TYPE_NORMAL
- en: With that done, one final call to `axis` leaves you with the top-middle plot
    in [Figure 23-14](ch23.xhtml#ch23fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Of particular note here is that you’ve used `at` to specify the tick marks on
    the MPG scale, at the values in `MPG.L100`, but since they correspond to the L/100km
    sequence in `L100`, it’s the latter vector that you supply to `labels` to actually
    label said tick marks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it’s time to annotate the axes with some titles and provide the labels
    for the tick marks on the horizontal axis. Before doing that, construct an `expression`
    for the MPG-to-L/100km conversion to clarify the right vertical axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In `express.L100`, the `%~~%` provides an “approximately equal to” sign (≈),
    and `%*%` provides an explicit multiplication symbol (×).
  prefs: []
  type: TYPE_NORMAL
- en: Then, by running the following lines, you get the top-right image in [Figure
    23-14](ch23.xhtml#ch23fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first line provides a main title and *x*- and *y*-axis titles in a `"serif"`
    style. Then `mtext` places a `"serif"` version of the arithmetic expression just
    created in an appropriate position `line=3` on the right axis (`side=4`). The
    third line places the `"mono"`-style tick mark labels in `hpseq2` along the *x*-axis
    at the appropriate user coordinates in the same vector, with a vertical position
    of `7.5`, after a little trial and error. Since you’re using `text` to draw in
    the figure margin, you must set `xpd` to `TRUE`. Special to `text` is the optional
    `srt` graphical parameter, which allows you to rotate the labels. Here, they’ve
    been rotated `45` degrees.
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to put the final touches on the plot. So far, the scaled sizes
    of the points according to car weight have been ignored. It’d be helpful to provide
    at least minimal information about that and other features that can aid in interpretation
    of the relationship (especially since there are two vertical axes), like an overlaid
    grid.
  prefs: []
  type: TYPE_NORMAL
- en: Superimposition of a grid on such a plot is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can specify the number of cells along the horizontal and vertical axes using
    the optional arguments `nx` and `ny`, respectively; if not, R will draw the grid
    lines at what would be the default *x*- and *y*-axis tick marks (as I’ve let it
    do here). Other aesthetics can be altered in the usual way, using arguments such
    as `col` (color) and `lty` (line type).
  prefs: []
  type: TYPE_NORMAL
- en: The fun part is now trying to work out how to reference the sizes of the plotted
    points by the weights of the cars. There are a number of ways you might achieve
    this. For this last example, I’ll manhandle the `legend` function in an effort
    to produce the graphic. The following three lines provide the end result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The legend is placed at user coordinates (250,30), and three points of the default
    `pch` type `1` are included—one large, one standard, and one small—using `pt.cex`
    set to `1.5`, `1`, and `0.5`, respectively. Instead of writing text labels for
    each of these three points by using the `legend` argument, I simply assign them
    to be empty strings made up of 10 spaces. What this does is widen the box around
    the legend, creating a space for what will instead accompany the three points—a
    small-headed arrow pointing upward and the word *Weight*. Finding suitable user
    coordinates for the arrow to fit inside the artificially empty legend box took
    a little trial and error, and I place the “Weight” text by invoking the interactive
    `locator` function as you saw used in [Section 23.3](ch23.xhtml#ch23lev1sec78).
  prefs: []
  type: TYPE_NORMAL
- en: Playing with R functionality to produce intricate plots like this is an excellent
    way to start learning how to handle the traditional graphical abilities of the
    language. It’s not uncommon to use trial and error and little cheats to reach
    an end result, though of course that kind of thing comes at the expense of the
    robustness of your code. For example, resizing the graphics device even moderately
    and attempting to reproduce the `mtcars` scatterplot shown earlier will likely
    result in a displeasing misalignment of the arrow in the legend. If you want to
    learn more, the authoritative reference on graphics in R is arguably Murrell ([2011](ref.xhtml#ref49)),
    which is a good text to consult once you’re familiar with the fundamentals discussed
    here and want a comprehensive guide on all things visual in R.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 23.2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the following tasks, you’ll work with the diamond-pricing data as analyzed
    by Chu ([2001](ref.xhtml#ref13)). You’ll need an Internet connection for this.
    Read the data in and name the columns as you’ve done previously with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: R> dia.url <- "http://www.amstat.org/publications/jse/v9n2/4cdata.txt"
  prefs: []
  type: TYPE_NORMAL
- en: R> diamonds <- read.table(dia.url)
  prefs: []
  type: TYPE_NORMAL
- en: R> names(diamonds) <- c("Carat","Color","Clarity","Cert","Price")
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new graphics device of 6 × 6 inches. Initialize the margin spacing to
    be zero, four, two, and zero lines on the bottom, left, top, and right of the
    plot region, respectively. Then, complete the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Produce side-by-side boxplots of the diamond prices in Singapore dollars (SGD$)
    split by certification. Suppress all axes and the surrounding box—note that the
    `boxplot` command requires you to set `frame=FALSE` for suppressing the box (as
    opposed to `bty="n"` in `plot`). Use the same command to provide an appropriate
    title.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, insert a vertical axis. The axis should have tick marks ranging from SGD$0
    to SGD$18000, progressing in steps of SGD$2000\. However, the axis should be clipped
    to the plotting region. The axis tick marks should point inward and be one line
    in length. The axis labels should sit only half a line away from the axis and
    should be horizontally readable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, use `locator` in conjunction with `text` to add an appropriate title
    sitting at the top of the *y*-axis; note that clipping will need to be relaxed.
    Use the same approach to add text, sitting inside each boxplot, denoting the corresponding
    certification (GIA, HRD, or IGI).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'My version of the plot looks like this:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0606-01.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Now, open a new graphics device of 8 × 7 inches. Set the figure margins to be
    two, five, three, and five lines on the bottom, left, top, and right, respectively.
    Also allow one line of outer margin space on each side other than the bottom,
    which should get two lines of outer margin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Produce a scatterplot of diamond price on the vertical axis and carat weight
    on the horizontal axis. Use the colors red, green, and blue to distinguish the
    points according to certification. Suppress all axes, boxes, labels, and titles
    in the initial plot, but then add a U-shaped box.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the horizontal axis. Use `axis` to place tick marks at an evenly spaced
    sequence of carat values between 0.2 and 1.1, in steps of 0.1\. Use a bold, italic,
    sans-style font for the labels and adjust the labels to be only half a line from
    the axis. Then add smaller, outward-facing tick marks between the existing ones.
    To do this, make a second call to the `axis` function and place the ticks at a
    sequence of values from 0.15 to 1.05 at steps of 0.1\. Set these secondary tick
    marks to have a length of one-quarter of a line and suppress the axis labels.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the vertical axes. On the left, ticks should appear at SGD$1000–17000\.
    Labels should be horizontally readable and in the same font style as the horizontal
    axis. On the right, axis ticks should be made in the equivalent of US dollars
    (USD$) at the sequence USD$1000–11000 in steps of USD$1000 and should be labeled
    as such. To do this, use the conversion USD$ = 1.37 × SGD$. Label orientation
    and font should match the other axes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Fit a linear model of price on a quadratic polynomial of carat weight for the
    data. Provide a prediction of the model for a sequence of carat values spanning
    the range of the observed values; include estimation of a 95 percent prediction
    interval. Use this information to superimpose a gray solid line for the fitted
    values and gray dashed lines for the prediction interval upon the scatterplot.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up expression objects for labeling the approximate US dollar conversion
    and the regression equation. Name the conversion `expr1`; it should look something
    like USD$ ≈ 1.37 × SGD$. The regression equation should look similar to Price
    = *β[0]* + *β*[1]Carat + *β*[2]Carat²; name it `expr2`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `mtext` to add an appropriate main title and titles for all three individual
    axes. You may need to experiment a little with line depth for each one, as well
    as whether to write in the outer margin or the figure margin, depending on your
    own spacing preference. The rightmost axis title should make use of `expr1`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Either via trial and error to find appropriate coordinates or by using the `interactive.arrow`
    function from [Exercise 23.1](ch23.xhtml#ch23exc1), place an arrow pointing to
    the fitted polynomial regression line and label it with `expr2`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, use a call to `locator` to place a legend in any appropriate location,
    referencing the color of the points according to the appropriate certification.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'My version of the plot looks like this:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0608-01.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dev.new` | Open new graphics device | [Section 23.1.1](ch23.xhtml#ch23lev2sec222),
    [p. 576](ch23.xhtml#page_576) |'
  prefs: []
  type: TYPE_TB
- en: '| `dev.set` | Change active device | [Section 23.1.2](ch23.xhtml#ch23lev2sec223),
    [p. 577](ch23.xhtml#page_577) |'
  prefs: []
  type: TYPE_TB
- en: '| `dev.off` | Close device | [Section 23.1.3](ch23.xhtml#ch23lev2sec224), [p.
    578](ch23.xhtml#page_578) |'
  prefs: []
  type: TYPE_TB
- en: '| `par` | Set graphical parameters | [Section 23.1.4](ch23.xhtml#ch23lev2sec225),
    [p. 579](ch23.xhtml#page_579) |'
  prefs: []
  type: TYPE_TB
- en: '| `layout` | Open new graphics device | [Section 23.1.4](ch23.xhtml#ch23lev2sec225),
    [p. 580](ch23.xhtml#page_580) |'
  prefs: []
  type: TYPE_TB
- en: '| `box` | Add box to plot | [Section 23.2.1](ch23.xhtml#ch23lev2sec226), [p.
    583](ch23.xhtml#page_583) |'
  prefs: []
  type: TYPE_TB
- en: '| `mtext` | Write text in margins | [Section 23.2.2](ch23.xhtml#ch23lev2sec227),
    [p. 584](ch23.xhtml#page_584) |'
  prefs: []
  type: TYPE_TB
- en: '| `locator` | Interactive coordinates | [Section 23.3.1](ch23.xhtml#ch23lev2sec229),
    [p. 587](ch23.xhtml#page_587) |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | Add axis to plot | [Section 23.4.3](ch23.xhtml#ch23lev2sec234),
    [p. 594](ch23.xhtml#page_594) |'
  prefs: []
  type: TYPE_TB
- en: '| `expression` | Render Greek/math in plot | [Section 23.5.2](ch23.xhtml#ch23lev2sec236),
    [p. 598](ch23.xhtml#page_598) |'
  prefs: []
  type: TYPE_TB
- en: '| `title` | Add main/axis titles | [Section 23.5.2](ch23.xhtml#ch23lev2sec236),
    [p. 598](ch23.xhtml#page_598) |'
  prefs: []
  type: TYPE_TB
- en: '| `italic` | Italicize text | [Section 23.5.3](ch23.xhtml#ch23lev2sec237),
    [p. 600](ch23.xhtml#page_600) |'
  prefs: []
  type: TYPE_TB
- en: '| `grid` | Add grid to plot | [Section 23.6](ch23.xhtml#ch23lev1sec81), [p.
    605](ch23.xhtml#page_605) |'
  prefs: []
  type: TYPE_TB
