<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch08">
  <div id="header0801" class="chapter">
   <h1 class="cn">
    <span class="page" id="p168">
    </span>
    <span class="page" id="p169">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch08">
     8
    </a>
   </h1>
   <h1 class="ctfm">
    Controlling Motors with Mosfets
   </h1>
  </div>
  <div class="figure" id="ct08">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   AVRs cannot directly control motors. In order to enable this, we need to use external components:
   <i class="calibre5">
    metal-oxide-semiconductor field-effect transistors (MOSFETs)
   </i>
   , transistors that can switch or amplify voltages in circuits.
  </p>
  <p class="calibre8">
   In this chapter, you’ll learn how to:
  </p>
  <ul class="calibre10">
   <li class="blf">
    • Use PWM with MOSFETs to control DC motors.
   </li>
   <li class="bl">
    • Use MOSFETs to control larger currents.
   </li>
   <li class="bll">
    • Use motor driver ICs to interface larger motors with your AVR microcontrollers.
   </li>
  </ul>
  <p class="calibre8">
   Along the way, you’ll build a temperature-controlled fan and a two-wheel-drive robot vehicle, building on prior knowledge to complete more interesting and complex projects. By the end of the chapter, you’ll have the skills to begin using MOSFETs in your own projects both for fun and for more serious applications, such as robotics, automation, or toys.
  </p>
  <div class="chapter">
   <h2 class="ah" id="ah1001">
    <span class="page" id="p170">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1001">
     The MOSFET
    </a>
   </h2>
   <p class="paft">
    We use MOSFETs when we need to control large currents and voltage using a small signal, such as that from a microcontroller’s digital output pin. MOSFETs are available in various sizes, such as those shown in
    <a class="url" href="nsp-boxall502581-0018.xhtml#f08001">
     Figure 8-1
    </a>
    , to match different projects’ requirements.
   </p>
   <div class="figure" id="f08001">
    <p class="fig">
     <img alt="Photo of four different MOSFETs" height="1072" src="images/nsp-boxall502581-f08001.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span>
      </span>
      <span class="calibre4">
       Figure 8-1
      </span>
      : Various MOSFETs
     </p>
    </div>
   </div>
   <p class="calibre8">
    We will be using the small 2N7000 version shown at the bottom left in
    <a class="url" href="nsp-boxall502581-0018.xhtml#f08001">
     Figure 8-1
    </a>
    , which has three leads. When you’re looking at the front of the 2N7000—the flat-faced side—the pins are, from left to right, the source, gate, and drain pins (I’ll explain their functions momentarily).
   </p>
   <p class="calibre8">
    <a class="url" href="nsp-boxall502581-0018.xhtml#f08002">
     Figure 8-2
    </a>
    shows the schematic symbol for the 2N7000 MOSFET.
   </p>
   <div class="figure" id="f08002">
    <p class="fig">
     <img alt="Schematic symbol for the 2N7000 MOSFET" height="705" src="images/nsp-boxall502581-f08002.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span>
      </span>
      <span class="calibre4">
       Figure 8-2
      </span>
      : Schematic symbol for 2N7000 MOSFET
     </p>
    </div>
   </div>
   <p class="calibre8">
    It’s easy to operate a MOSFET. When you apply a small current to the gate pin, a large current can flow in through the drain pin and out through the source pin. You can also connect a PWM signal to the gate pin of a MOSFET, allowing you to control lights, motors, and more in various ways. That’s what we’ll focus on in this chapter.
   </p>
   <p class="calibre8">
    <span id="p171">
    </span>
    Our 2N7000 MOSFET can handle up to 60 V DC at 200 mA continuously, or 500 mA in bursts. When choosing a MOSFET for your projects, be sure to check the voltage and current maximums against the signal you want to switch.
   </p>
   <p class="calibre8">
    We connect a 10
    <span lang="en" xml:lang="en">
     kΩ
    </span>
    resistor between the MOSFET’s gate and the source pin every time we use a MOSFET, as you’ll see in the following project. This acts to keep the gate switched off when a current is not applied to it, in the same way a resistor pulls down a button, as shown in
    <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
     Chapter 3
    </a>
    ; it stops the MOSFET from turning slightly on or off at random.
   </p>
   <p class="hd" id="pro34">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro34">
     <span class="ccust1">
      Project 34: DC Motor Control with PWM and MOSFET
     </span>
    </a>
   </p>
   <p class="paft">
    This project demonstrates how to control a small DC motor using PWM and a MOSFET. As the microcontroller cannot provide enough current for the motor on its own, we use an external power supply and a MOSFET to handle the motor’s requirements.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1001">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1001">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     For this project, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • Small DC motor and matching power
     </li>
     <li class="bl">
      • 2N7000 MOSFET
     </li>
     <li class="bll">
      • 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistor
     </li>
    </ul>
    <p class="calibre8">
     A small DC motor model like the one shown in
     <a class="url" href="nsp-boxall502581-0018.xhtml#f08003">
      Figure 8-3
     </a>
     with a maximum of 12 V DC will suffice.
    </p>
    <div class="figure" id="f08003">
     <p class="fig">
      <img alt="Photo of a small DC motor" height="1032" src="images/nsp-boxall502581-f08003.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 8-3
       </span>
       : Small DC motor
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p172">
     </span>
     You will also need external power, such as a battery pack that holds several AA cells. A 6 AA cell pack like the one shown in
     <a class="url" href="nsp-boxall502581-0018.xhtml#f08004">
      Figure 8-4
     </a>
     will provide up to 9 V DC, enough power to run a 12 V DC motor nicely.
    </p>
    <div class="figure" id="f08004">
     <p class="fig">
      <img alt="Photo of six AA cells in a battery holder for a 9 V supply" height="320" src="images/nsp-boxall502581-f08004.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 8-4
       </span>
       : AA battery pack
      </p>
     </div>
    </div>
    <p class="calibre8">
     Assemble the circuit as shown in
     <a class="url" href="nsp-boxall502581-0018.xhtml#f08005">
      Figure 8-5
     </a>
     . Note that the black/negative lead from the battery pack will be connected to GND.
    </p>
    <div class="figure" id="f08005">
     <p class="fig">
      <img alt="Schematic diagram for Project 34" height="1200" src="images/nsp-boxall502581-f08005.jpg" width="1167" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 8-5
       </span>
       : Schematic for
       <a class="url" href="nsp-boxall502581-0018.xhtml#pro34">
        Project 34
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Don’t disassemble the circuit once you’ve finished using it, as you will use it as part of the circuit in the
     <a class="url" href="nsp-boxall502581-0018.xhtml#pro35">
      following project
     </a>
     .
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1002">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1002">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 34
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 8
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . The DC motor should start from 0, increase speed to a complete on state, then reduce speed back to a complete off state, then repeat the procedure.
    </p>
    <p class="calibre8">
     <span id="p173">
     </span>
     Let’s see how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 34 - DC Motor Control with PWM and MOSFET
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ #define wait 10
     </p>
     <p class="cl2">
      <!--<ccust1>2</ccust1>-->
      ❷ void initPWM(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Timers 1A and 1B
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; WGM10);        // Fast PWM mode
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; WGM12);        // Fast PWM mode
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; CS11);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void motorOn(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="clf">
      <!--<ccust1>3</ccust1>-->
      ❸ TCCR1A &amp;= ~(1 &lt;&lt; COM1A1);      // Disconnect PWM from PB1
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; PORTB1);        // Set PB1 on
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void motorOff(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ TCCR1A &amp;= ~(1 &lt;&lt; COM1A1);      // Disconnect PWM from PB1
     </p>
     <p class="cl">
      PORTB &amp;= ~(1 &lt;&lt; PORTB1);       // Set PB1 off
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void motorPWM(uint8_t duty)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ TCCR1A |= (1 &lt;&lt; COM1A1);       // Connect PWM to OCR1A—PB1
     </p>
     <p class="cl">
      OCR1A = duty;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB |= (1 &lt;&lt; PORTB1);         // Set PORTB pin 1 as output
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ initPWM();
     </p>
     <p class="cl">
      uint8_t a;
     </p>
     <p class="clf">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      motorOff();                 // Motor off
     </p>
     <p class="cl">
      _delay_ms(3000);
     </p>
     <p class="clf">
      for (a = 1; a &lt;255; a++)    // Slowly increase motor speed
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      motorPWM(a);
     </p>
     <p class="cl">
      _delay_ms(wait);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      motorOn();                  // Motor full on
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="clf">
      <span id="p174">
      </span>
      for (a = 254; a &gt; 0;—a)   // Slowly decrease motor speed
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      motorPWM(a);
     </p>
     <p class="cl">
      _delay_ms(wait);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     You should be familiar with the code used in this project by now as you learned about using PWM in
     <a class="url" href="nsp-boxall502581-0017.xhtml#ch07">
      Chapter 7
     </a>
     , but let’s go through it together. First, we set the required registers to initialize PWM operation
     <!--<ccust1>2</ccust1>-->
     ❷. To make control easier, we use three functions:
     <code class="calibre23">
      motorOn()
     </code>
     ,
     <code class="calibre23">
      motorOff()
     </code>
     , and
     <code class="calibre23">
      motorPWM()
     </code>
     . The
     <code class="calibre23">
      motorOn()
     </code>
     function turns the motor completely on by first disconnecting PORTB1 from PWM
     <!--<ccust1>3</ccust1>-->
     ❸ and then setting it to high. This gives 100 percent power to the motor via the MOSFET at all times.
    </p>
    <p class="calibre8">
     We use the
     <code class="calibre23">
      motorOff()
     </code>
     function to completely turn the motor off by disconnecting PORTB1 from PWM
     <!--<ccust1>4</ccust1>-->
     ❹ and setting it to low. This turns off the MOSFET gate pin, so the motor has no power. Again, this is necessary as you can’t send a 0 percent duty cycle to the OCR1A register and expect it to be off 100 percent of the time. Even with a duty cycle of 0 percent, every time the hardware timer resets the output is turned on briefly during the reset.
    </p>
    <p class="calibre8">
     Finally, the function
     <code class="calibre23">
      motorPWM()
     </code>
     , which accepts the required duty cycle value, is used to set the motor speed with PWM. It connects PORTB1 to PWM
     <!--<ccust1>5</ccust1>-->
     ❺ and then loads the OCR1A register with the required value.
    </p>
    <p class="calibre8">
     Our main code repeatedly turns the motor on and increases the speed to 100 percent, then reduces the speed back to 0, then turns the motor off for 3 seconds. We turn the motor off at the start of the code, to allow the end user a moment’s notice before spinning it up. You can change the delay time in the PWM loops by altering the value of
     <code class="calibre23">
      wait
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶.
    </p>
    <p class="calibre8">
     Now that you know how to control a DC motor, let’s apply this skill to a practical example by building a temperature-controlled fan system.
    </p>
    <p class="hd" id="pro35">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro35">
      <span class="ccust1">
       Project 35: Temperature-Controlled Fan
      </span>
     </a>
    </p>
    <p class="paft">
     In this project, you’ll combine your existing knowledge of motor control with your newfound MOSFET skills, using temperature sensors to make a temperature-controlled fan.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1003">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1003">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     For this project, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • Small DC motor and matching power
     </li>
     <li class="bl">
      <span id="p175">
      </span>
      • 2N7000 MOSFET
     </li>
     <li class="bl">
      • TMP36 temperature sensor
     </li>
     <li class="bl">
      • 0.1
      <span lang="el" xml:lang="el">
       μF
      </span>
      ceramic capacitor
     </li>
     <li class="bll">
      • 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistor
     </li>
    </ul>
    <p class="calibre8">
     You can use the small DC motor from the
     <a class="url" href="nsp-boxall502581-0018.xhtml#pro34">
      previous project
     </a>
     just to see how this works, or you can pick up a DC motor–powered cooling fan from an electrical retailer, such as the unit from PMD Way (part number 59119182) shown in
     <a class="url" href="nsp-boxall502581-0018.xhtml#f08006">
      Figure 8-6
     </a>
     . Some fans may have four wires, but only two of these are required (power and GND). Once again, we’ll need to use external power for the fan.
    </p>
    <div class="figure" id="f08006">
     <p class="fig">
      <img alt="Photo of a small cooling fan" src="images/nsp-boxall502581-f08006.jpg" class="calibre30"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 8-6
       </span>
       : DC cooling fan
      </p>
     </div>
    </div>
    <p class="calibre8">
     Assemble the circuit as shown in
     <a class="url" href="nsp-boxall502581-0018.xhtml#f08007">
      Figure 8-7
     </a>
     .
    </p>
    <div class="figure" id="f08007">
     <p class="fig">
      <img alt="Schematic diagram for Project 35" height="1200" src="images/nsp-boxall502581-f08007.jpg" width="1161" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 8-7
       </span>
       : Schematic for
       <a class="url" href="nsp-boxall502581-0018.xhtml#pro35">
        Project 35
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p176">
     </span>
     As you assemble the project, note that the black/negative lead from the battery pack or fan power supply will be connected to GND. Also, don’t forget to connect AV
     <sub class="calibre28">
      CC
     </sub>
     to 5 V.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1004">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1004">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 35
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 8
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Once you’ve applied power, the project should wait three seconds before taking the temperature and operating the fan, depending on the current temperature.
    </p>
    <p class="calibre8">
     To see how this works, take a look at the code:
    </p>
    <pre>
     <p class="clf">
      // Project 35 - Temperature-Controlled Fan
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      void startADC()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; REFS0);                 // Use AVcc pin with ADC
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX0);    // Use ADC5 (pin 28)
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0); // Prescaler for 1 MHz (/8)
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADEN);                 // Enable ADC
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initPWM(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Timers 1A and 1B
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; WGM10);                // Fast PWM mode
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; WGM12);                // Fast PWM mode
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; CS11);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void motorOff(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TCCR1A &amp;= ~(1 &lt;&lt; COM1A1);              // Disconnect PWM from PB1
     </p>
     <p class="cl">
      PORTB &amp;= ~(1 &lt;&lt; PORTB1);               // Set PB1 off
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void motorOn(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TCCR1A &amp;= ~(1 &lt;&lt; COM1A1);              // Disconnect PWM from PB1
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; PORTB1);                // Set PB1 on
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void motorPWM(uint8_t duty)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; COM1A1);               // Connect PWM to OCR1A—PB1
     </p>
     <p class="cl">
      OCR1A = duty;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB |= (1 &lt;&lt; PORTB1);                 // Set PORTB pin 1 as output
     </p>
     <p class="cl">
      <span id="p177">
      </span>
      <!--<ccust1>1</ccust1>-->
      ❶ startADC();
     </p>
     <p class="cl">
      initPWM();
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ uint8_t ADCvalue;
     </p>
     <p class="cl">
      float voltage;
     </p>
     <p class="cl">
      float temperature;
     </p>
     <p class="clf">
      // Delay motor action for a few moments on start
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ _delay_ms(3000);
     </p>
     <p class="clf">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Get reading from TMP36 via ADC
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ ADCSRA |= (1 &lt;&lt; ADSC);              // Start ADC measurement
     </p>
     <p class="cl">
      while (ADCSRA &amp; (1 &lt;&lt; ADSC) );      // Wait until conversion complete
     </p>
     <p class="cl">
      _delay_ms(10);
     </p>
     <p class="clf">
      // Get value from ADC register, convert to 8-bit value
     </p>
     <p class="cl">
      ADCvalue = ADC &gt;&gt; 2;
     </p>
     <p class="clf">
      // Convert reading to temperature value (Celsius)
     </p>
     <p class="cl">
      voltage = (ADCvalue * (5000 / 256));
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ temperature = (voltage—500) / 10;
     </p>
     <p class="clf">
      // Now you have a temperature value, take action
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ if (temperature&lt;25)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Under 25 degrees, turn motor off
     </p>
     <p class="cl">
      motorOff();
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ else if ((temperature&gt;=25) &amp; (temperature &lt;35))
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // At or above 25 and below 35 degrees, set motor to 50% PWM
     </p>
     <p class="cl">
      motorPWM(127);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ else if (temperature&gt;=35)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // 35 degrees and over, turn motor full on
     </p>
     <p class="cl">
      motorOn();
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      <!--<ccust1>9</ccust1>-->
      ❾ _delay_ms(500); // Prevent rapid motor speed changes
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This code builds upon the ADC and temperature sensor from
     <a class="url" href="nsp-boxall502581-0014.xhtml#pro19">
      Project 19
     </a>
     in
     <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
      Chapter 4
     </a>
     and the PWM motor control used in
     <a class="url" href="nsp-boxall502581-0018.xhtml#pro34">
      Project 34
     </a>
     . First, we activate the ADC to read the TMP36 temperature sensor and activate PWM for variable-speed motor control
     <!--<ccust1>1</ccust1>-->
     ❶ (the
     <code class="calibre23">
      startADC()
     </code>
     and
     <code class="calibre23">
      initPWM()
     </code>
     functions are defined at the beginning of the program). We introduce the variables required to calculate the temperature for the thermostat
     <!--<ccust1>2</ccust1>-->
     ❷, and then we introduce a delay at startup so the motor doesn’t jump into life straight after a reset or power-up
     <!--<ccust1>3</ccust1>-->
     ❸.
    </p>
    <p class="calibre8">
     In the main loop, we take the value from the ADC
     <!--<ccust1>4</ccust1>-->
     ❹ and convert it to degrees Celsius
     <!--<ccust1>5</ccust1>-->
     ❺. The code can now use this temperature value to
     <span id="p178">
     </span>
     determine whether to operate the motor. In this project, the motor is switched off if the temperature is below 25 degrees
     <!--<ccust1>6</ccust1>-->
     ❻. If the temperature is between 25 and 34 degrees inclusive, the fan runs at half speed
     <!--<ccust1>7</ccust1>-->
     ❼. If the temperature is 35 degrees or over, the fan runs at full speed
     <!--<ccust1>8</ccust1>-->
     ❽.
    </p>
    <p class="calibre8">
     Finally, after checking the temperature, there is a short delay
     <!--<ccust1>9</ccust1>-->
     ❾ to avoid
     <i class="calibre5">
      hysteresis
     </i>
     —that is, rapid changes in the characteristics of the circuit. For example, if the sensor were in the path of a breeze or a fluttering curtain, the temperature might fluctuate rapidly between 24.99 and 25 degrees, causing the motor to turn continuously on and off. The delay allows us to avoid this.
    </p>
    <p class="calibre8">
     At this point, I hope you’re beginning to see how we can combine basic AVR code and tools to solve new problems. Building on prior knowledge, we’ve started to move beyond the simpler projects in earlier chapters to more complex, practical applications.
    </p>
    <p class="calibre8">
     Now that we’ve experimented with basic motor control using the MOSFET, we’ll move on to controlling the direction of rotation as well as the speed of a DC motor. To do this, we’ll use the L293D motor driver IC.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah1002">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1002">
     The L293D Motor Driver IC
    </a>
   </h2>
   <p class="paft">
    To control the speed and direction of one or two small DC motors, we’ll use the L293D motor driver IC from STMicroelectronics, shown in
    <a class="url" href="nsp-boxall502581-0018.xhtml#f08008">
     Figure 8-8
    </a>
    . This is in the same type of package as a microcontroller, and thus we can easily use it in a solderless breadboard for experimenting.
   </p>
   <div class="figure" id="f08008">
    <p class="fig">
     <img alt="Photo of the L293D motor driver IC" height="800" src="images/nsp-boxall502581-f08008.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span>
      </span>
      <span class="calibre4">
       Figure 8-8
      </span>
      : L293D motor driver IC
     </p>
    </div>
   </div>
   <p class="calibre8">
    You can use small motor driver ICs like the L293D for robotics or small toys that run from 4.5 to 36 V DC at up to 600 mA, with some restrictions with regard to heat that I’ll explain later. The L293D saves you a lot of time, as it takes care of distributing power to the motors and spares you from building a bunch of external circuitry. It is known as an
    <i class="calibre5">
     H-BRIDGE IC
    </i>
    because it has an internal circuit of MOSFETs and other components configured in the shape of the letter H, as shown in
    <a class="url" href="nsp-boxall502581-0018.xhtml#f08009">
     Figure 8-9
    </a>
    .
   </p>
   <div class="figure" id="f08009">
    <p class="fig">
     <span id="p179">
     </span>
     <img alt="Internal block diagram for the L293D motor driver IC" height="792" src="images/nsp-boxall502581-f08009.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span>
      </span>
      <span class="calibre4">
       Figure 8-9
      </span>
      : L293D IC block diagram
     </p>
    </div>
   </div>
   <p class="calibre8">
    Thankfully, we don’t need to build the L293D IC’s circuitry ourselves; it’s already set up and ready for us to connect the motors, control logic, and power. Instead, we just connect motors, power, GND, and outputs from a microcontroller. To see how to wire up the L293D to one DC motor, take a look at the pinouts in
    <a class="url" href="nsp-boxall502581-0018.xhtml#f08010">
     Figure 8-10
    </a>
    .
   </p>
   <div class="figure" id="f08010">
    <p class="fig">
     <img alt="Pinouts for the L293D motor driver IC" height="904" src="images/nsp-boxall502581-f08010.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span>
      </span>
      <span class="calibre4">
       Figure 8-10
      </span>
      : L293D IC pinouts
     </p>
    </div>
   </div>
   <p class="calibre8">
    There are four GND pins: 4, 5, 12, and 13. Connect those to GND. Next, locate the two power pins. Connect the first one—V
    <sub class="calibre28">
     CC
    </sub>
    1, which is the logic (or control) power pin—to the 5 V, as you did with your
    <span id="p180">
    </span>
    microcontroller in our earlier projects. Then connect the second power pin, V
    <sub class="calibre28">
     CC
    </sub>
    2, to the positive of the motor power supply (up to 36 V DC). Finally, connect the motor: one wire to pin 3 and the other to pin 6.
   </p>
   <p class="calibre8">
    Controlling the motor requires three signals from digital outputs on our microcontroller. First, we set the ENABLE pin: either to high, so that the driver IC sends power to the motor, or to low, so that the motor stops. The signals from the next two pins, 1A and 2A, control the polarity of the power to the motor, and thus the rotational direction. With ENABLE set high, the motor will rotate in one direction with 1A high and 2A low and rotate in the other direction with 1A low and 2A high.
    <a class="url" href="nsp-boxall502581-0018.xhtml#tab0801">
     Table 8-1
    </a>
    summarizes all this for easy reference.
   </p>
   <table id="tab0801" class="calibre13">
    <thead class="calibre14">
     <tr class="calibre15">
      <th colspan="4" class="calibre16">
       <p class="th1">
        <span class="calibre4">
         Table 8-1
        </span>
        : L293D Single Motor Control
       </p>
      </th>
     </tr>
     <tr class="calibre15">
      <th scope="col" class="calibre16">
       <p class="tch">
        ENABLE pin/EN1 (pin 1)
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        1A pin/out 1 (pin 2)
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        2A pin/out 2 (pin 7)
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        Motor action
       </p>
      </th>
     </tr>
    </thead>
    <tbody class="calibre17">
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        High
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        High
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        Low
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        Forward
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        High
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        Low
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        High
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        Backward
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        Low
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        High or Low
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        High or Low
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        Stop
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="calibre8">
    There’s no way to tell from the outside whether your motor will run forward or backward; you will need to do a test run to determine which of the two 1A/2A combinations is which for your motor. You can alter the speed of the motor by applying a PWM signal to the ENABLE pin.
   </p>
   <div class="box">
    <div class="chapter" id="bxheader0801">
     <p class="bxh">
      A Few Words about Heat
     </p>
    </div>
    <p class="bxaft">
     The L293D can become warm (or hot) when running toward the higher end of its capacity. It shouldn’t be used in a solderless breadboard in these situations, as the four GND pins are also used as a heatsink. This means they might melt the plastic around the pins, leaving the L293D stuck in the breadboard. If you’re going to control larger motors, build your circuit using your own PCB, use a breakout board for the motor control, or solder the circuit onto a stripboard.
    </p>
   </div>
   <p class="calibre8">
    Now that you’re familiar with the theory of the L293D, let’s put it into practice in the
    <a class="url" href="nsp-boxall502581-0018.xhtml#pro36">
     next project
    </a>
    .
   </p>
   <p class="hd" id="pro36">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro36">
     <span class="ccust1">
      Project 36: DC Motor Control with L293D
     </span>
    </a>
   </p>
   <p class="paft">
    This project demonstrates how you can control a small DC motor using PWM and the L293D motor driver IC, operating the motor in either direction and at various speeds. This will give you the remaining skills you need to build your first moving robot vehicle in the
    <a class="url" href="nsp-boxall502581-0018.xhtml#pro37">
     next project
    </a>
    .
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1005">
     <span class="page" id="p181">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1005">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     For this project, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • Small DC motor and matching power
     </li>
     <li class="bll">
      • L293D motor driver IC
     </li>
    </ul>
    <p class="calibre8">
     Use the same DC motor and matching power supply you used for
     <a class="url" href="nsp-boxall502581-0018.xhtml#pro34">
      Project 34
     </a>
     . Assemble the circuit as shown in
     <a class="url" href="nsp-boxall502581-0018.xhtml#f08011">
      Figure 8-11
     </a>
     .
    </p>
    <div class="figure" id="f08011">
     <p class="fig">
      <img alt="Schematic diagram for Project 36" height="984" src="images/nsp-boxall502581-f08011.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 8-11
       </span>
       : Schematic for
       <a class="url" href="nsp-boxall502581-0018.xhtml#pro36">
        Project 36
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     As you assemble the circuit, connect the black/negative lead from the battery pack or external power to GND once again.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1006">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1006">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 36
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 8
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Once you’ve applied power, the project should wait three seconds before operating the motor at two different speeds successively, both forward and backward.
    </p>
    <p class="calibre8">
     Let’s see how this works.
    </p>
    <pre>
     <p class="clf">
      <span id="p182">
      </span>
      // Project 36 - DC Motor Control with L293D
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void initPWM(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TCCR2A |= (1 &lt;&lt; WGM20);     // Fast PWM mode
     </p>
     <p class="cl">
      TCCR2A |= (1 &lt;&lt; WGM21);     // Fast PWM mode, part 2
     </p>
     <p class="cl">
      TCCR2B |= (1 &lt;&lt; CS21);      // PWM Freq = F_CPU/8/256
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2">
      <!--<ccust1>2</ccust1>-->
      ❷ void motorForward(uint8_t duty)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set direction
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ PORTB |= (1 &lt;&lt; PORTB1);     // PB1 HIGH
     </p>
     <p class="cl">
      PORTB &amp;= ~(1 &lt;&lt; PORTB2);    // PB2 LOW
     </p>
     <p class="clf">
      // Set speed
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ if (duty == 255)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; PORTB3);  // Set PORTB3 to on
     </p>
     <p class="cl">
      } else if (duty &lt; 255)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ TCCR2A |= (1 &lt;&lt; COM2A1); // PWM output on OCR2A—PB3
     </p>
     <p class="cl">
      OCR2A = duty;            // Set PORTB3 to PWM value
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>6</ccust1>-->
      ❻ void motorBackward(uint8_t duty)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Set direction
     </p>
     <p class="cl">
      PORTB &amp;= ~(1 &lt;&lt; PORTB1);    // PB1 LOW
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; PORTB2);     // PB2 HIGH
     </p>
     <p class="clf">
      // Set speed
     </p>
     <p class="cl">
      if (duty == 255)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; PORTB3);  // Set PORTB3 to on
     </p>
     <p class="cl">
      } else if (duty &lt; 255)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TCCR2A |= (1 &lt;&lt; COM2A1); // PWM output on OCR2A—PB3
     </p>
     <p class="cl">
      OCR2A = duty;            // Set PORTB3 to PWM value
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>7</ccust1>-->
      ❼ void motorOff(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Disconnect PWM output from OCR2A—PB3
     </p>
     <p class="cl">
      TCCR2A &amp;= ~(1 &lt;&lt; COM2A1);
     </p>
     <p class="cl">
      // Set ENABLE to zero for brake
     </p>
     <p class="cl">
      PORTB &amp;= ~(1 &lt;&lt; PORTB3);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      <span id="p183">
      </span>
      {
     </p>
     <p class="cl">
      // Set PORTB3, 2, and 1 as outputs
     </p>
     <p class="cl">
      DDRB |= (1 &lt;&lt; PORTB3)|(1 &lt;&lt; PORTB2)|(1 &lt;&lt; PORTB1);
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ initPWM();
     </p>
     <p class="cl">
      _delay_ms(3000);            // Wait a moment before starting
     </p>
     <p class="cl">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>9</ccust1>-->
      ❾ motorForward(64);
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      motorOff();
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      motorForward(255);
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      motorOff();
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      motorBackward(64);
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      motorOff();
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      motorBackward(255);
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      motorOff();
     </p>
     <p class="cl">
      _delay_ms(2000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This code builds on that of previous motor control projects in this chapter, with the required additions for the L293D. We set up PWM at points
     <!--<ccust1>1</ccust1>-->
     ❶ and
     <!--<ccust1>8</ccust1>-->
     ❽. The first of the motor control functions,
     <code class="calibre23">
      motorForward()
     </code>
     <!--<ccust1>2</ccust1>-->
     ❷, rotates the motor in one direction and accepts a duty cycle value of between 1 and 255. Per
     <a class="url" href="nsp-boxall502581-0018.xhtml#tab0801">
      Table 8-1
     </a>
     , we set the outputs as high and low for motor directional control
     <!--<ccust1>3</ccust1>-->
     ❸. The code then checks if the required duty cycle value is 255
     <!--<ccust1>4</ccust1>-->
     ❹, and if so simply switches the ENABLE pin to high for full-speed motor running instead of using PWM. However, if it’s less than 255, then PWM is enabled for the output pin controlling the L293D ENABLE pin
     <!--<ccust1>5</ccust1>-->
     ❺ and the required duty cycle value is dropped into OCR2A.
    </p>
    <p class="calibre8">
     The motor control method used in
     <code class="calibre23">
      motorForward()
     </code>
     is repeated with the function
     <code class="calibre23">
      motorBackward()
     </code>
     <!--<ccust1>6</ccust1>-->
     ❻, except with the outputs for motor control set to low and high for reverse rotation. Finally, the
     <code class="calibre23">
      motorOff()
     </code>
     function
     <!--<ccust1>7</ccust1>-->
     ❼ turns off the motor by first disabling PWM for the output pin controlling the L293D ENABLE pin and then setting it to low. With all this complete, you can now use the motor control functions to control the speed and direction of motor rotation, as demonstrated in the main loop of the code
     <!--<ccust1>9</ccust1>-->
     ❾.
    </p>
    <p class="calibre8">
     Now that you know how to control the speed and direction of a DC motor, let’s use two motors to control a small robot vehicle.
    </p>
    <p class="hd" id="pro37">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro37">
      <span class="ccust1">
       Project 37: Controlling a Two-Wheel-Drive Robot Vehicle
      </span>
     </a>
    </p>
    <p class="paft">
     In this project, you’ll learn to control a small two-wheel-drive robot vehicle. The suggested hardware includes two DC motors and a
     <i class="calibre5">
      castor
     </i>
     (a small,
     <span id="p184">
     </span>
     swiveling wheel fixed to the bottom of your robot vehicle), allowing you to easily control the speed and direction of travel. I hope this inspires you to create your own more complex robotic creations!
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1007">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1007">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     For this project, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • Two small DC motors and matching power
     </li>
     <li class="bl">
      • 2WD robot vehicle chassis (such as PMD Way part number 72341119)
     </li>
     <li class="bl">
      • Four AA battery cells
     </li>
     <li class="bl">
      • 1N4004 power diode
     </li>
     <li class="bl">
      • L293D motor driver IC
     </li>
    </ul>
    <div class="chapter">
     <h4 class="ch" id="ch1001">
      The Chassis
     </h4>
     <p class="paft">
      The foundation of any robot vehicle is a solid chassis containing the motors, drivetrain, and power supply. You can choose from many chassis models available on the market. To keep things simple, this project relies on an inexpensive robot chassis with two small DC motors that operate at around 6 V DC and two matching wheels, as shown in
      <a class="url" href="nsp-boxall502581-0018.xhtml#f08012">
       Figure 8-12
      </a>
      .
     </p>
     <div class="figure" id="f08012">
      <p class="fig">
       <img alt="Photo of a two-wheel-drive robot chassis with motors, wheels, and battery holder" height="1022" src="images/nsp-boxall502581-f08012.jpg" width="1200" class="calibre11"/>
      </p>
      <div class="chapter">
       <p class="figh">
        <span>
        </span>
        <span class="calibre4">
         Figure 8-12
        </span>
        : Two-wheel-drive robot vehicle chassis (PMD Way part number 72341119)
       </p>
      </div>
     </div>
     <p class="calibre8">
      The task of physically assembling the robot chassis varies between models, but most require a few additional tools beyond those included in the kit, such as screwdrivers. If you haven’t settled on a final design and wish to get your robot moving in a temporary configuration, you can attach the electronics to the chassis with a reusable putty adhesive like Blu-Tack.
     </p>
    </div>
    <div class="chapter">
     <h4 class="ch" id="ch1002">
      <span class="page" id="p185">
      </span>
      The Power Supply
     </h4>
     <p class="paft">
      The motors included with the robot chassis typically operate at around 6 V DC, so we’ll use the 4 AA cell battery holder included with the example chassis in
      <a class="url" href="nsp-boxall502581-0018.xhtml#f08012">
       Figure 8-12
      </a>
      . We can’t use 6 V to power the microcontroller circuit, so we place a 1N4004 diode between the power supply positive and the 5 V connection on the microcontroller. The diode will cause a 0.7 V drop in voltage, bringing the microcontroller supply to around 5.3 V DC. The voltage will again drop as the battery life decreases.
     </p>
     <p class="calibre8">
      Assemble the circuit as shown in
      <a class="url" href="nsp-boxall502581-0018.xhtml#f08013">
       Figure 8-13
      </a>
      .
     </p>
     <div class="figure" id="f08013">
      <p class="fig">
       <img alt="Schematic diagram for Project 37" height="1139" src="images/nsp-boxall502581-f08013.jpg" width="1200" class="calibre11"/>
      </p>
      <div class="chapter">
       <p class="figh">
        <span>
        </span>
        <span class="calibre4">
         Figure 8-13
        </span>
        : Schematic for
        <a class="url" href="nsp-boxall502581-0018.xhtml#pro37">
         Project 37
        </a>
       </p>
      </div>
     </div>
     <p class="calibre8">
      Again, the black/negative lead from the battery pack or external power connects to GND, and the red/positive lead runs to both the L293D V
      <sub class="calibre28">
       CC
      </sub>
      2 pin and the 1N4004 diode.
     </p>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1008">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1008">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 37
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 8
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Once you remove the AVR programmer and the vehicle starts up, it should wait three seconds before moving off forward and then turning left, right, and so on as directed by the sequence of functions in the main loop of the code.
    </p>
    <p class="calibre8">
     This code is the culmination of our experiments with DC motor control using the L293D motor controller IC and PWM. Let’s see how it works:
    </p>
    <pre>
     <p class="cl1f">
      <span id="p186">
      </span>
      // Project 37 - Controlling a Two-Wheel-Drive Robot Vehicle
     </p>
     <p class="cl1f">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl1">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl1f">
      void initPWM(void)
      <!--<ccust1>1</ccust1>-->
      ❶
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      TCCR2A |= (1 &lt;&lt; WGM20);                 // Fast PWM mode
     </p>
     <p class="cl1">
      TCCR2A |= (1 &lt;&lt; WGM21); );              // Fast PWM mode, part 2
     </p>
     <p class="cl1">
      TCCR2B |= (1 &lt;&lt; CS21); );               // PWM Freq = F_CPU/8/256
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1f">
      void moveForward(uint8_t duty)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      // Set direction
     </p>
     <p class="cl1">
      PORTB |= (1 &lt;&lt; PORTB4)|(1 &lt;&lt; PORTB1);
      <!--<ccust1>2</ccust1>-->
      ❷ // PB4,1 HIGH
     </p>
     <p class="cl1">
      PORTB &amp;= ~(1 &lt;&lt; PORTB5)&amp;~(1 &lt;&lt; PORTB2); // PB5,2 LOW
     </p>
     <p class="cl1f">
      // Set speed
     </p>
     <p class="cl1">
      if (duty == 255)
      <!--<ccust1>3</ccust1>-->
      ❸
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      PORTB |= (1 &lt;&lt; PORTB3);              // Set PORTB3 to on
     </p>
     <p class="cl1">
      PORTD |= (1 &lt;&lt; PORTD3);              // Set PORTD3 to on
     </p>
     <p class="cl1">
      } else if (duty &lt; 255)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      TCCR2A |= (1 &lt;&lt; COM2A1);
      <!--<ccust1>4</ccust1>-->
      ❹           // PWM output on OCR2A—PB3
     </p>
     <p class="cl1">
      TCCR2A |= (1 &lt;&lt; COM2B1);             // PWM to OCR2B—PD3
     </p>
     <p class="cl1">
      OCR2A = duty;                        // Set PORTB3 to PWM value
     </p>
     <p class="cl1">
      OCR2B = duty;                        // Set PORTD3 to PWM value
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1f">
      void moveBackward(uint8_t duty)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      // Set direction
     </p>
     <p class="cl1">
      PORTB &amp;= ~(1 &lt;&lt; PORTB4)&amp;~(1 &lt;&lt; PORTB1); // PB4,1 LOW
     </p>
     <p class="cl1">
      PORTB |= (1 &lt;&lt; PORTB5)|(1 &lt;&lt; PORTB2);   // PB5,2 HIGH
     </p>
     <p class="cl1f">
      // Set speed
     </p>
     <p class="cl1">
      if (duty == 255)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      PORTB |= (1 &lt;&lt; PORTB3);              // Set PORTB3 to on
     </p>
     <p class="cl1">
      PORTD |= (1 &lt;&lt; PORTD3);              // Set PORTD3 to on
     </p>
     <p class="cl1">
      } else if (duty &lt; 255)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      TCCR2A |= (1 &lt;&lt; COM2A1);             // PWM output on OCR2A—PB3
     </p>
     <p class="cl1">
      TCCR2A |= (1 &lt;&lt; COM2B1);             // PWM to OCR2B—PD3
     </p>
     <p class="cl1">
      OCR2A = duty;                        // Set PORTB3 to PWM value
     </p>
     <p class="cl1">
      OCR2B = duty;                        // Set PORTD3 to PWM value
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1f">
      void moveLeft(uint8_t duty)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      <span id="p187">
      </span>
      // Set direction
     </p>
     <p class="cl1">
      PORTB |= (1 &lt;&lt; PORTB4)|(1 &lt;&lt; PORTB2);   // PB4,2 HIGH
     </p>
     <p class="cl1">
      PORTB &amp;= ~(1 &lt;&lt; PORTB5)&amp;~(1 &lt;&lt; PORTB1); // PB5,1 LOW
     </p>
     <p class="cl1f">
      // Set speed
     </p>
     <p class="cl1">
      if (duty == 255)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      PORTB |= (1 &lt;&lt; PORTB3);              // Set PORTB3 to on
     </p>
     <p class="cl1">
      PORTD |= (1 &lt;&lt; PORTD3);              // Set PORTD3 to on
     </p>
     <p class="cl1">
      } else if (duty &lt; 255)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      TCCR2A |= (1 &lt;&lt; COM2A1);             // PWM output on OCR2A—PB3
     </p>
     <p class="cl1">
      TCCR2A |= (1 &lt;&lt; COM2B1);             // PWM to OCR2B—PD3
     </p>
     <p class="cl1">
      OCR2A = duty;                        // Set PORTB3 to PWM value
     </p>
     <p class="cl1">
      OCR2B = duty;                        // Set PORTD3 to PWM value
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1f">
      void moveRight(uint8_t duty)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      // Set direction
     </p>
     <p class="cl1">
      PORTB |= (1 &lt;&lt; PORTB5)|(1 &lt;&lt; PORTB1);   // PB5,1 HIGH
     </p>
     <p class="cl1">
      PORTB &amp;= ~(1 &lt;&lt; PORTB4)&amp;~(1 &lt;&lt; PORTB2); // PB4,2 LOW
     </p>
     <p class="cl1f">
      // Set speed
     </p>
     <p class="cl1">
      if (duty == 255)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      PORTB |= (1 &lt;&lt; PORTB3);              // Set PORTB3 to on
     </p>
     <p class="cl1">
      PORTD |= (1 &lt;&lt; PORTD3);              // Set PORTD3 to on
     </p>
     <p class="cl1">
      } else if (duty &lt; 255)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      TCCR2A |= (1 &lt;&lt; COM2A1);             // PWM output on OCR2A—PB3
     </p>
     <p class="cl1">
      TCCR2A |= (1 &lt;&lt; COM2B1);             // PWM to OCR2B—PD3
     </p>
     <p class="cl1">
      OCR2A = duty;                        // Set PORTB3 to PWM value
     </p>
     <p class="cl1">
      OCR2B = duty;                        // Set PORTD3 to PWM value
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1f">
      void motorsOff(void)
      <!--<ccust1>5</ccust1>-->
      ❺
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      TCCR2A &amp;= ~(1 &lt;&lt; COM2A1); // Disconnect PWM from OCR2A—PB3
     </p>
     <p class="cl1">
      TCCR2A &amp;= ~(1 &lt;&lt; COM2B1); // Disconnect PWM from OCR2B—PD3
     </p>
     <p class="cl1">
      PORTB &amp;= ~(1 &lt;&lt; PORTB3);  // Set ENABLE pins to zero for brake
     </p>
     <p class="cl1">
      PORTD &amp;= ~(1 &lt;&lt; PORTD3);
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1f">
      int main(void)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      // Set PORTB5, 4, 3, 2, and 1 as outputs
     </p>
     <p class="cl1">
      DDRB |= (1 &lt;&lt; PORTB5)|(1 &lt;&lt; PORTB4)|(1 &lt;&lt; PORTB3)|(1 &lt;&lt; PORTB2)|(1 &lt;&lt; PORTB1);
      <!--<ccust1>6</ccust1>-->
      ❻
     </p>
     <p class="cl1">
      DDRD |= (1 &lt;&lt; PORTD3);
      <!--<ccust1>7</ccust1>-->
      ❼               // Set PORTD3 as output
     </p>
     <p class="cl1">
      initPWM();
      <!--<ccust1>8</ccust1>-->
      ❽
     </p>
     <p class="cl1">
      _delay_ms(3000);                       // Wait a moment before starting
     </p>
     <p class="cl1">
      while(1)
     </p>
     <p class="cl1">
      {
     </p>
     <p class="cl1">
      <span id="p188">
      </span>
      moveForward(128);
     </p>
     <p class="cl1">
      _delay_ms(2000);
     </p>
     <p class="cl1">
      moveLeft(128);
     </p>
     <p class="cl1">
      _delay_ms(2000);
     </p>
     <p class="cl1">
      moveRight(128);
     </p>
     <p class="cl1">
      _delay_ms(2000);
     </p>
     <p class="cl1">
      motorsOff();
     </p>
     <p class="cl1">
      moveBackward(128);
     </p>
     <p class="cl1">
      _delay_ms(2000);
     </p>
     <p class="cl1">
      }
     </p>
     <p class="cl1l">
      }
     </p>
    </pre>
    <p class="calibre8">
     At
     <!--<ccust1>1</ccust1>-->
     ❶ and
     <!--<ccust1>8</ccust1>-->
     ❽, the code initiates PWM for two digital outputs so it can control two motors. After PWM initiation comes
     <code class="calibre23">
      moveForward()
     </code>
     , the first of five functions to control the motors. You might need to switch the wires on each motor if they appear to work opposite to the code. Four of these functions—
     <code class="calibre23">
      moveForward()
     </code>
     ,
     <code class="calibre23">
      moveBackward()
     </code>
     ,
     <code class="calibre23">
      moveLeft()
     </code>
     , and
     <code class="calibre23">
      moveRight()
     </code>
     —are identical, except in the order of motor rotation. They all accept a value for the duty cycle to control the speed of the motors. The function
     <code class="calibre23">
      motorsOff()
     </code>
     cuts the power off to both motors.
    </p>
    <p class="calibre8">
     In this case, we set the direction of the motors forward by making digital outputs high or low, depending on required rotation type
     <!--<ccust1>2</ccust1>-->
     ❷. Refer to
     <a class="url" href="nsp-boxall502581-0018.xhtml#tab0801">
      Table 8-1
     </a>
     for the requisite output configurations. The motor movement functions check if the user requires full speed (a duty cycle of 100 percent, represented by 255)
     <!--<ccust1>3</ccust1>-->
     ❸. If so, it simply sets the ENABLE pins of the L293D to on. However, if you pass a lower value for the duty cycle through a motor movement function, the program activates the PWM output to the ENABLE pins
     <!--<ccust1>4</ccust1>-->
     ❹ and fills the PWM registers OCR2A and B with the required duty cycle.
    </p>
    <p class="calibre8">
     The other three movement functions operate similarly, except that the motor rotations are set up to allow for turning left or right or moving backward. The
     <code class="calibre23">
      motorsOff()
     </code>
     function stops movement by turning off PWM and setting both L293D ENABLE pins to low
     <!--<ccust1>5</ccust1>-->
     ❺. Finally, the program sets the six required pins to outputs to control the L293D
     <!--<ccust1>6</ccust1><ccust1>7</ccust1>-->
     ❻❼.
    </p>
    <p class="calibre8">
     You can use the functions used in the main loop of the code to change the direction of movement, the speed via the duty cycles, and the duration with the delay functions, and stop the motors when required.
    </p>
    <p class="calibre8">
     We have used a single timer with two PWM outputs for both motors (OCR2A and OCR2B) so that they share the same PWM generation and will thus synchronize with each other. If you use two different timers for two motors that need to operate together, the PWM signals will differ slightly and the two motors will operate slightly differently from one other.
    </p>
    <p class="calibre8">
     Now that we have experimented with DC motors, in the
     <a class="url" href="nsp-boxall502581-0019.xhtml#ch09">
      next chapter
     </a>
     we’ll examine another useful tool of the AVR system: the internal EEPROM.
    </p>
   </div>
  </div>
 </div>
</div></body></html>