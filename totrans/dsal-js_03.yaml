- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 2 FUNCTIONAL PROGRAMMING IN JAVASCRIPT
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 在JavaScript中使用函数式编程
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: '*Functional programming (FP)* is a programming paradigm based on functions,
    which are the only building blocks for your code. Using FP improves your code’s
    modularity and helps you write more understandable, testable, and easy-to-maintain
    code while avoiding bugs; it’s a win all around.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数式编程（FP）*是一种基于函数的编程范式，函数是你代码的唯一构建块。使用FP可以提高代码的模块化，帮助你编写更易理解、可测试和易于维护的代码，同时避免出现
    bug；这是一个全方位的胜利。'
- en: Some people claim that FP is an enlightened approach to programming that leaves
    *object-oriented programming (OOP)* and other paradigms far behind. Others say
    that it is only theoretical, is not applicable “in the real world,” and causes
    more problems than it solves. As in most domains, the differences aren’t black
    or white, but a shade of gray. It’s not a matter of using only FP or never using
    FP. We’ll use it in this book, but not dogmatically, and in this chapter, you’ll
    see how JavaScript lets you work functionally, how and when to use FP, and instances
    when *not* to use it. Wherever FP applies and is more appropriate, we’ll use it,
    but if OOP is better suited, it will be used instead.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人声称，FP是一种开明的编程方法，它让*面向对象编程（OOP）*和其他范式远远落后。也有些人认为，它只是理论上的概念，不适用于“现实世界”，并且带来了比解决的问题更多的麻烦。像大多数领域一样，差异并非非黑即白，而是介于灰色之间。这不仅仅是使用FP还是不使用FP的问题。在本书中，我们会使用FP，但不是教条式的，并且在本章中，你将看到JavaScript如何让你进行函数式编程，何时使用FP以及何时*不*使用它。无论何时FP适用并且更为合适，我们会使用它，但如果OOP更为适用，我们也会改用OOP。
- en: NOTE
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注
- en: '*FP is not a modern fad. The second-oldest programming language still in common
    use (after FORTRAN, which appeared in 1957) is LISP (which appeared one year later),
    and it’s completely based on FP. Many other FP languages have appeared in the
    more than 60 years since, and even nonfunctional languages, such as JavaScript,
    also provide the same kind of functionality.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*FP不是一种现代的时尚。第二古老的编程语言（仅次于1957年出现的FORTRAN）是LISP（于一年后出现），它完全基于FP。自那时以来，许多其他FP语言相继出现，甚至像JavaScript这样的非函数式语言也提供了相同类型的功能。*'
- en: Why Use Functional Programming?
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用函数式编程？
- en: 'Consider what features are most important to you when programming and then
    ask whether FP provides them. Most programmers usually want the code they write
    to be:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程时，考虑哪些特性对你最重要，然后问自己，FP是否能够提供这些特性。大多数程序员通常希望自己编写的代码是：
- en: '**Understandable **Code is written once but read many times, and users should
    be able to “get” your functions and their relationships without great effort.
    FP tends to produce shorter and cleaner code, which is easier to understand.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**易懂 **代码只需要编写一次，但会被阅读多次，用户应该能够轻松理解你的函数及其关系，而无需过多的努力。函数式编程通常生成更短、更简洁的代码，这使得理解起来更加容易。'
- en: '**Maintainable **Your code most likely will need maintenance sometime in the
    future, and it should be easy to do. The same features that make FP code easier
    to understand also allow for easier maintenance. You also don’t need to worry
    about breaking other things when modifying any given function.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**可维护 **你的代码很可能在未来需要维护，并且应该便于进行修改。使FP代码更易理解的特性也使得维护变得更为简便。你还无需担心在修改某个函数时会破坏其他部分。'
- en: '**Testable **Unit testing is a common part of development work, allowing you
    to verify the behavior of each component of your code. Unit tests also serve as
    a sort of documentation, providing examples of how to use any given function to
    people reading your code. If your programming style doesn’t favor writing easily
    testable code, you’ll have problems. FP always produces functions you can test
    on your own.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**可测试 **单元测试是开发工作中的常见部分，它允许你验证代码每个组件的行为。单元测试还作为一种文档，为阅读你代码的人提供如何使用某个函数的示例。如果你的编程风格不支持编写易于测试的代码，你将遇到问题。FP始终生成可以独立测试的函数。'
- en: '**Modular **You should divide your code’s features into independent modules,
    each pertaining to one specific aspect of your program, so that if you make changes
    in one module, they won’t affect the rest of your code. The goal in FP is to write
    independent functions you can refactor or modify without impacting other functions.
    Writing independent functions helps you achieve *separation of concerns* (distinct
    parts of a program have little overlap). Also, modules tend to be *highly cohesive*,
    which means they include functions that really belong together, and they are *loosely
    coupled*, so changes in a function are not likely to require changes in other
    functions.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块化** 你应该将代码的功能划分为独立的模块，每个模块涉及程序的一个特定方面，这样如果你在一个模块中做出更改，它就不会影响到其他代码。FP的目标是编写独立的函数，这些函数可以重构或修改，而不影响其他函数。编写独立的函数有助于实现*关注点分离*（程序的不同部分重叠较少）。此外，模块往往是*高度内聚*的，这意味着它们包含的函数确实是属于一起的，并且它们是*松散耦合*的，因此函数中的更改不太可能需要修改其他函数。'
- en: '**Reusable **Reusing code saves time and money. Because functions stand on
    their own in FP, you can use a well-written set of functions anywhere.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**可重用** 重用代码可以节省时间和金钱。由于在FP中函数独立存在，因此你可以在任何地方使用编写良好的函数集合。'
- en: Of course, object-oriented code can do all of these things as well. No one is
    ever going to say that FP is a silver bullet that solves all your software development
    problems. I always suggest taking the middle road; a well-thought-out, balanced
    mix is usually the best solution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，面向对象的代码也能做到这些。没有人会说FP是解决所有软件开发问题的银弹。我总是建议采取中庸之道；经过深思熟虑、平衡的混合通常是最佳解决方案。
- en: '### JavaScript as a Functional Language'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '### JavaScript作为函数式语言'
- en: '*Is JavaScript functional?* When people discuss functional languages, they
    typically mention Haskell, Erlang, Scala, and the like; no one usually includes
    JavaScript. That might be because no precise definition exists for what constitutes
    a functional language, what features a functional language should provide, or
    how it should work. For the purposes of this book, we’ll consider a language to
    be functional if (and only if) it supports common FP features; you’ll see how
    JavaScript compares. We’ll take advantage of items like functions as first-class
    objects, array functions, pure functions, higher-order functions, and recursion
    and avoid side effects (or *impurities*, in FP lexicon) using (local or global)
    state, mutating objects or arguments, and so on.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript是函数式的吗？* 当人们讨论函数式语言时，他们通常提到Haskell、Erlang、Scala等；通常不会提到JavaScript。这可能是因为目前没有确切的定义来说明什么构成了函数式语言、函数式语言应该提供哪些特性，或者它应该如何工作。本书中，我们将认为只有当一种语言支持常见的FP特性时，它才算是函数式语言；你将看到JavaScript如何与之比较。我们将利用诸如将函数视为一等公民、数组函数、纯函数、高阶函数和递归等特性，同时避免副作用（或者说FP术语中的*不纯*），避免使用（局部或全局）状态、变更对象或参数等。'
- en: Functions as First-Class Objects
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数作为一等公民
- en: In JavaScript, to say that functions are *first-class objects* means you can
    do anything with them that you’d be able to do with other objects. You can store
    functions in variables, pass functions as arguments, or return a function as a
    result from some other function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是*一等公民*，意味着你可以对它们执行任何你可以对其他对象执行的操作。你可以将函数存储在变量中，将函数作为参数传递，或将一个函数作为结果从其他函数返回。
- en: 'Consider an example of doing an application programming interface (API) call.
    If you work with something like Axios (or SuperAgent, or other similar libraries
    that simplify the process of doing an async call to a remote server), you’ve likely
    seen code like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个应用程序接口（API）调用的例子。如果你使用像Axios（或者SuperAgent，或者其他类似的库，它们简化了对远程服务器的异步调用过程），你可能见过这样的代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The parameter to the .then() method is a function, and it’s passed in the same
    way you pass a number or an array.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: .then()方法的参数是一个函数，它的传递方式和你传递数字或数组一样。
- en: 'In [Chapter 12](chapter12.xhtml), we’ll be doing that as well, and we’ll be
    also able to assign default values to function parameters in order to change the
    way the function performs:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](chapter12.xhtml)，我们也会这样做，我们还将能够为函数参数赋予默认值，以改变函数的执行方式：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preOrder() function takes two arguments: a tree (you’ll learn about trees
    later) and a visit function; if you don’t provide the visit function, the default
    value will be a simple function that just logs whatever you pass to it.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: preOrder()函数接受两个参数：一棵树（你将在后面学习树）和一个访问函数；如果你没有提供访问函数，默认值将是一个简单的函数，它只会记录你传递给它的内容。
- en: Taking one or more functions as parameters makes the function a *higher-order
    function*; the other identifying characteristic for such a function is returning
    a function as a result. Common functions (those that do not receive or return
    functions) are called *first-order functions*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个或多个函数作为参数使得该函数成为*高阶函数*；这种函数的另一个特征是返回一个函数作为结果。普通函数（那些不接收或返回函数的）被称为*一阶函数*。
- en: 'Working with the same example, you could also write the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的例子中，你还可以编写如下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function is stored in a variable ❶, as functions are just another type of
    value that can go in a variable, and then the variable’s contents are passed to
    a function ❷ in exactly the same way that you pass myTree, another variable with
    a different kind of value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数存储在变量❶中，因为函数只是另一种可以存放在变量中的值类型，然后变量的内容以与传递myTree（另一个类型不同的变量）相同的方式传递给函数❷。
- en: You’ll see more examples throughout this chapter, including functions that return
    functions as results.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中你会看到更多的例子，包括返回函数作为结果的函数。
- en: Declarative-Style Programming
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 声明式编程
- en: FP works in a higher-level, *declarative* style instead of the imperative style
    used in procedural, “common” programming. With declarative programming, you specify
    what you want, but not the individual detailed steps necessary to accomplish it,
    as you would do in procedural coding. The best example of declarative coding involves
    arrays. Working with arrays usually entails loops, which you can do “by hand”
    (think of using a while loop) or with the preferred for statement, but JavaScript
    lets you work declaratively with some specific array functions. In fact, we’ll
    look at some *methods* for this, but the same concept applies; a method is just
    a function after all.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）采用更高层次的*声明式*风格，而不是在过程式“常规”编程中使用的命令式风格。在声明式编程中，你只需要指定你想要什么，而不是逐个详细地列出完成它所需的步骤，这在过程式编码中是必须的。声明式编码的最佳示例是数组操作。操作数组通常涉及循环，你可以“手动”实现（比如使用
    while 循环），或者使用更常见的 for 语句，但 JavaScript 让你可以使用一些特定的数组函数进行声明式操作。事实上，我们将在接下来讨论一些*方法*，但概念是一样的；方法归根结底也是函数。
- en: 'The following list details some of the available array functions that let you
    search or select elements from an array:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表详细介绍了一些可用的数组函数，帮助你在数组中查找或选择元素：
- en: '**.filter() **Picks elements that satisfy some condition out of an array'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**.filter() **从数组中挑选出满足某些条件的元素'
- en: '**.find() and .findIndex() **Search an array to find an element that satisfies
    some condition'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**.find() 和 .findIndex() **在数组中查找满足某些条件的元素'
- en: '**.some() **Lets you know whether at least one element of an array satisfies
    a condition'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**.some() **检查数组中是否至少有一个元素满足某个条件'
- en: '**.every() **Lets you test whether all elements of an array satisfy a condition'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**.every() **测试数组中的所有元素是否满足某个条件'
- en: 'Other functions transform an array into a new array or a single result:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数将数组转换成一个新的数组或单个结果：
- en: '**.map() **Lets you transform one array into another by applying a given function
    to its elements'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**.map() **通过对数组的元素应用给定的函数，将一个数组转换为另一个数组'
- en: '**.reduce() **Applies a given operation to the whole array from left to right,
    reducing it to a single result'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**.reduce() **对整个数组应用给定的操作，从左到右，将其简化为一个单一结果'
- en: '**.reduceRight() **Works like .reduce() but from right to left'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**.reduceRight() **与 .reduce() 类似，但从右到左进行操作'
- en: 'This list isn’t meant to be complete: there are more functions that transform
    arrays, like .flat() or .flatMap(), but you won’t see them here.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不是完整的：还有更多转换数组的函数，如 .flat() 或 .flatMap()，但你在这里看不到它们。
- en: NOTE
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Some people say that these functions are slower than the corresponding hand-written
    loops and that you’ll suffer some performance hit for using them. Even if those
    things were true, they are irrelevant. Unless you are having some real performance
    problems and after analyzing your code you reach the conclusion that the array
    functions are to blame, writing longer, more bug-prone code doesn’t really make
    much sense.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*有些人说这些函数比对应的手写循环更慢，使用它们会带来一些性能损失。即使这些说法是真的，它们也不重要。除非你遇到了真正的性能问题，并且在分析代码后得出结论认为是数组函数导致的，编写更长、更多错误的代码实际上没有什么意义。*'
- en: Filtering an Array
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 过滤数组
- en: 'Let’s take a look at a common task: going through an array, selecting elements
    that satisfy some condition, and dropping the rest. The .filter() method does
    exactly that: you provide a *predicate* (a function that produces a boolean result
    in terms of its arguments), and a new array is produced, with only the elements
    of the original array for which the predicate returned true.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个常见的任务：遍历数组，选择满足某些条件的元素，并丢弃其余元素。 .filter() 方法正是实现了这一点：你提供一个*谓词*（一个根据参数生成布尔结果的函数），然后返回一个新数组，只包含原始数组中满足谓词条件的元素。
- en: 'For example, to select all values under 21, the following predicate would be
    useful:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要选择所有小于21的值，以下谓词将非常有用：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The under21() function gets a value and returns true if the value is less than
    21\. Now you can write the code as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: under21()函数获取一个值，如果该值小于21，则返回true。现在你可以像下面这样编写代码：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This specifies that you want to apply the “under 21” check to filter the original
    array, and the result is a new array with only the values that satisfied the given
    test. You don’t need to write anything to control a loop, initialize an output
    array, or anything else. The code is much shorter and truly declarative; it specifies
    only *what* you wanted to get, not *how* to get it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了你想要应用“小于21”检查来过滤原始数组，结果是一个新数组，只包含满足给定测试的值。你不需要编写任何代码来控制循环，初始化输出数组或其他任何东西。代码更简洁且真正声明性；它只指定了*你想要什么*，而不是*如何得到它*。
- en: Searching an Array
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 搜索数组
- en: 'Other methods let you search an array for some element that satisfies a predicate,
    returning either the element or its position in the array:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法让你可以搜索数组中某个满足谓词的元素，返回该元素或它在数组中的位置：
- en: '**find() **Goes through the array from beginning to end, testing for the given
    predicate; if an element of the array satisfies it, the element is returned; if
    no elements satisfy the predicate, undefined is returned. A recent new method,
    findLast(), does the same, but searches from the end to the beginning.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**find()** 从头到尾遍历数组，测试给定的谓词；如果数组中的某个元素满足谓词，该元素将被返回；如果没有元素满足谓词，则返回undefined。最近的新方法findLast()做了相同的事情，但它是从尾部向头部搜索。'
- en: '**findIndex() **Is similar to find(), but it returns the position of the first
    element satisfying the predicate or -1 if no elements satisfy it. The new findLastIndex()
    returns the position of the last element that satisfies the predicate.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**findIndex()** 类似于find()，但它返回第一个满足谓词的元素的位置，如果没有元素满足谓词，则返回-1。新方法findLastIndex()返回最后一个满足谓词的元素位置。'
- en: These methods are practical, because they provide all the needed search code
    in a single line. There is no limit to the complexity of a search predicate. You
    aren’t limited to looking only for a value, for example, and can test any condition,
    as you did with under21() previously.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法非常实用，因为它们在一行代码中提供了所有需要的搜索代码。搜索谓词的复杂性没有限制。例如，你不仅限于寻找一个值，还可以测试任何条件，就像你之前使用under21()一样。
- en: 'Here are examples of using both of these searching methods at once, since they
    are related and similar:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些同时使用这两种搜索方法的示例，因为它们是相关且相似的：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first element of myArray that satisfies the under21 predicate is 9 ❶, and
    it’s at position 1 of the array ❷. If you redo the calls using an equal21 predicate
    that checks whether a value is 21, you get undefined ❸ and -1 ❹, because no such
    element is found in the array.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 满足under21谓词的myArray的第一个元素是9 ❶，它位于数组的第1个位置 ❷。如果你使用一个equal21谓词重新调用，该谓词检查值是否为21，你将得到undefined
    ❸和-1 ❹，因为数组中找不到这样的元素。
- en: NOTE
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you are searching for a specific value,* .includes()*,* .index()*, and*
    .lastIndexOf() *are quite useful, though less flexible than the FP-oriented methods
    described earlier, because they just let you search for a value and not test for
    any possible condition.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你正在搜索一个特定的值，* .includes()，.index() 和 * .lastIndexOf() *会非常有用，尽管它们的灵活性不如前面描述的函数式编程（FP）方法，因为它们只是让你搜索一个值，而不能测试任何可能的条件。*'
- en: Testing an Array
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试数组
- en: 'Related methods for searching are .some() and .every(). The first checks whether
    *any* element of an array satisfies some predicate, and the second checks whether
    *all* elements satisfy it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与搜索相关的方法有 .some() 和 .every()。第一个检查数组中是否*任何*元素满足某个谓词，第二个检查是否*所有*元素都满足该谓词：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you test whether some elements of the array are under 21, the answer is true,
    but not all elements are true. If you repeat these tests for equality to 21, both
    answers are false.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你测试数组中是否有元素小于21，答案是“真”，但并非所有元素都为真。如果你重复进行这些等于21的测试，两个答案都为假。
- en: You could omit these functions if you have the methods in the previous section
    (see question 2.7 at the end of the chapter).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了上一节中的方法，你可以省略这些函数（请参见本章末尾的第 2.7 问题）。
- en: Transforming an Array
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转换一个数组
- en: Algorithms often need to go through a set of elements (such as an array) and
    apply some operation to each of them to create a new set. For instance, in a web
    application, you could have a list of strings, which could represent numbers,
    and you’d want to transform that list into a list of the corresponding numeric
    values. Setting up a loop to go through all elements of an array systematically,
    processing elements one by one, and producing a new array is a common procedure
    and usually taught early on to developers. This kind of transformation is also
    key in FP, and JavaScript calls it the .map() function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 算法通常需要遍历一组元素（如数组），对每个元素应用某些操作，进而创建一个新的集合。例如，在一个 Web 应用程序中，你可能有一个字符串列表，这些字符串可能表示数字，你可能想将这个列表转换为对应的数字值列表。为数组的所有元素设置一个循环，系统地处理每个元素，并生成一个新的数组，是一个常见的过程，通常会在开发者学习初期教授。这种转换在函数式编程（FP）中也非常关键，JavaScript
    通过 .map() 函数来实现。
- en: 'Consider an introductory example that just produces a new array, with all values
    multiplied by 10:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的例子，它只生成一个新的数组，并将所有值乘以 10：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Start with the same array you’ve been using. If you map it with a function that
    multiplies its argument by 10, you get a new array whose values are 10 times the
    original ones.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从你一直在使用的数组开始。如果你用一个将参数乘以 10 的函数来映射它，你将得到一个新的数组，其值是原数组值的 10 倍。
- en: Using .map() instead of a common loop means clearer code, and mapping is a well-known
    pattern in FP. The code is also shorter, which means fewer chances of introducing
    bugs. And finally, the code produces a new array instead of modifying the original
    one, so the function is *pure* (you’ll learn what that means later in this chapter).
    Whenever possible, use .map(), but be aware that some of its features could bite
    you; see question 2.4 at the end of this chapter for an example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .map() 而不是常规的循环意味着代码更加清晰，而且映射是函数式编程中的一个著名模式。代码也更简短，这意味着出错的机会更少。最后，代码生成一个新的数组，而不是修改原始数组，因此该函数是
    *纯粹的*（你将在本章后面学习这是什么意思）。只要可能，使用 .map()，但要注意它的一些特性可能会让你吃亏；请参考本章末尾的第 2.4 问题获取示例。
- en: Reducing an Array to a Single Value
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将数组简化为单一值
- en: 'Here is another common task: writing loops that go through a complete array,
    performing some kind of operation and ending up with a single computed value.
    (A typical example is an array with a list of numbers and adding them up.) You
    can implement this kind of task in a functional way using either the .reduce()
    or, less frequently, the .reduceRight() function. The following sums up a complete
    array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个常见任务：编写遍历整个数组的循环，执行某种操作，最后得到一个计算结果。（一个典型的例子是一个包含数字的数组，将它们加起来。）你可以使用 .reduce()
    或较少使用的 .reduceRight() 函数以函数式的方式实现这种任务。以下代码对整个数组进行求和：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This logic does all that’s needed to apply a function that receives two values
    and returns their sum to the complete array, starting with 0\. In other words,
    it sums all the elements of the array. The a argument stands for *accumulator*
    (initially 0), and v stands for *value* (each of the elements of the array). You
    don’t need to provide the initial value for .reduce(), but it’s safer to do so.
    If you try to reduce an empty array without an initial value, you’ll get a runtime
    error.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑完成了应用一个接收两个值并返回它们和的函数到整个数组的所有操作，从 0 开始。换句话说，它将数组中的所有元素相加。a 参数代表 *累加器*（初始值为
    0），v 代表 *值*（数组中的每个元素）。你不需要为 .reduce() 提供初始值，但提供初始值更安全。如果你试图在没有初始值的情况下对一个空数组进行归约操作，你将遇到运行时错误。
- en: 'To show the power of .reduce(), look at another case where you calculate more
    than one result: averaging the array values. For that, you need not only their
    sum, which you already know how to get, but also their count (forget that you
    could use myArray.length to provide the latter; this is just an example):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 .reduce() 的强大功能，来看另一个案例，在这个案例中，你需要计算多个结果：计算数组值的平均值。为此，你不仅需要它们的总和（你已经知道如何获取），还需要它们的数量（不要忘记你可以使用
    myArray.length 来获取后者；这只是一个例子）：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The object has two fields (s for the sum and c for the count), and the reducing
    function recalculates those values at each step; the final result matches the
    previous example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象有两个字段（s 代表总和，c 代表计数），并且归约函数在每一步都重新计算这些值；最终结果与前面的示例相符。
- en: If you need to process an array from right to left, .reduceRight() works the
    same way, but it starts at the end of the array and goes back to the first element.
    Of course, you also could reverse the original array by first using .reverse()
    and then .reduce(), but that would cause a side effect. The array would be reversed
    in place (see “Mutating Arguments” on page 33 for more about this).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从右到左处理数组，`.reduceRight()` 的工作方式与 `.reduce()` 相同，但它从数组的末尾开始，返回到第一个元素。当然，你也可以通过先使用
    `.reverse()` 然后再使用 `.reduce()` 来反转原始数组，但那会产生副作用。数组会就地被反转（关于此，请参见第33页的“变异参数”）。
- en: Looping Through Arrays
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 遍历数组
- en: 'The .forEach() array function takes care of looping through an array, invoking
    a callback for each element, so you just have to declare what kind of work you
    want to do and nothing else. You can redo the array summing logic using this function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`.forEach()` 数组函数负责遍历数组，为每个元素调用回调，因此你只需要声明你想要做什么工作，其他的都不需要。你可以使用这个函数重新实现数组求和逻辑：'
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First set the sum variable to 0; this variable will get the sum of all elements
    in the array ❶. Then go through the array ❷ and specify what you want to do with
    each v element. In this case, add it to sum, and the final result ❸ is exactly
    the same as before.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将 `sum` 变量设置为 0；该变量将获得数组中所有元素的总和❶。然后遍历数组❷并指定你希望对每个元素 `v` 做的操作。在这种情况下，将其加到
    `sum` 中，最终结果❸与之前完全相同。
- en: Higher-Order Functions
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高阶函数
- en: As mentioned previously, functions that receive other functions as arguments
    or that return functions as results are called *higher-order functions*. This
    means all functions that work with callbacks are higher-order functions, and so
    are all the array methods just discussed. Some of these functions allow you to
    work in a more declarative style (like the ones you saw earlier), and others allow
    you to extend a function and modify what it does—for example, adding logging as
    an aid for debugging or memoizing for better performance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，接收其他函数作为参数或返回函数作为结果的函数被称为 *高阶函数*。这意味着所有与回调函数一起工作的函数都是高阶函数，刚才讨论的所有数组方法也是如此。这些函数中的一些允许你以更声明式的方式工作（就像你之前看到的），而另一些则允许你扩展函数并修改它的行为——例如，添加日志记录以帮助调试或使用记忆化以提高性能。
- en: 'Consider one of the uses for higher-order functions: returning a new function,
    with an example of wrapped behavior. Wrapping produces a new function that keeps
    its original functionality but adds some extra behavior. Imagine you want to add
    logging to a function for debugging purposes. You could modify the function of
    course, but doing so is risky, because you could accidentally touch something
    you shouldn’t. You also could use a debugger, but a wrapper function provides
    more flexibility.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下高阶函数的用途之一：返回一个新函数，包含一个包装的行为示例。包装产生一个新函数，它保留了原始功能，但添加了一些额外的行为。假设你想为一个函数添加日志记录功能，用于调试目的。你当然可以修改这个函数，但这样做是有风险的，因为你可能会不小心修改不该触碰的部分。你也可以使用调试器，但包装函数提供了更多的灵活性。
- en: 'The original function could be something like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 原始函数可能是这样的：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You then could modify it to add logging:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以修改它来添加日志记录：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the function had several return statements, however, you’d need to modify
    them all.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果函数有多个返回语句，你需要修改它们所有的返回部分。
- en: 'Using a higher-order logging function is better:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高阶日志记录函数更好：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The addLogging() function receives a function as argument and returns a new
    function ❹. First, this new function logs the original function’s name ❶ and the
    arguments it received. Then it actually calls the original function to calculate
    whatever the function calculated ❷. After that, the new function logs the result
    ❸ and finally returns that value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`addLogging()` 函数接收一个函数作为参数，并返回一个新函数❹。首先，这个新函数记录原始函数的名称❶和它接收到的参数。然后，它实际上调用原始函数来计算函数所需的内容❷。之后，新函数记录结果❸，并最终返回该值。'
- en: 'Here’s a simple example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The sum2() function logs something and returns the sum of its arguments ❶. When
    you pass sum2 as a parameter to addLogging and call the resulting function ❷,
    you get the extra logging you wanted without touching the original function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum2()` 函数记录某些内容，并返回它的参数之和❶。当你将 `sum2` 作为参数传递给 `addLogging` 并调用返回的函数❷时，你可以获得额外的日志记录，而不需要触及原始函数。'
- en: Side Effects
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 副作用
- en: 'When a function depends only on the parameters it receives and doesn’t produce
    any side effects, it is called a *pure function*. The concept of pure functions
    is closely related to mathematical functions: given an *f*(*x*) function, all
    it does when given a value for *x* is calculate a new value.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数仅依赖它所接收的参数，并且不产生任何副作用时，它被称为*纯函数*。纯函数的概念与数学函数密切相关：给定一个*f*(*x*)函数，当给定一个*x*的值时，它所做的只是计算一个新的值。
- en: Using pure functions is advantageous because they don’t produce any side effects,
    such as changing the program state, modifying variables, mutating objects, and
    so on. This means that when you call a pure function, you don’t need to worry
    about any possible changes anywhere in your code or the possibility of something
    else getting broken; you can concentrate on which arguments you pass to the function,
    knowing no “surprises” will happen. When given the same arguments, the function
    will always return the same result. That result won’t depend on any “outside”
    variables or state, which could change and then cause the function to produce
    a different result. On the other hand, a pure function cannot depend on random
    numbers, the time of day, the result of input/output (I/O) functions, and so on;
    it depends only on its input.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯函数的一个优点是它们不会产生任何副作用，例如改变程序状态、修改变量、改变对象等。这意味着当你调用一个纯函数时，你不需要担心代码中的任何可能的变化或其他部分可能会被破坏；你可以专注于传递给函数的参数，知道不会发生任何“意外”。当传入相同的参数时，函数总是会返回相同的结果。这个结果不会依赖于任何“外部”变量或状态，这些变量或状态可能会改变并导致函数产生不同的结果。另一方面，纯函数不能依赖于随机数、一天中的时间、输入/输出（I/O）函数的结果等；它只依赖于它的输入。
- en: Using Global State
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用全局状态
- en: The most common reason for side effects is using nonlocal variables that are
    shared with other parts of the code. Since a pure function always produces the
    same output given the same inputs, if a function depends somehow on variables
    outside it, it automatically becomes impure.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用的最常见原因是使用与代码其他部分共享的非局部变量。由于纯函数在给定相同输入时总是产生相同的输出，如果一个函数依赖于它之外的某些变量，它就自动变成了不纯函数。
- en: The problem goes deeper; debugging a function that depends on global state is
    more difficult, because in order to understand why a function returned a given
    value, you must also understand how the program state was reached, and that itself
    requires understanding all the previous history of the running code. The injunction
    against using global variables is a good one, even if you aren’t specifically
    following FP tenets.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 问题更为复杂；调试一个依赖于全局状态的函数更加困难，因为为了理解为什么一个函数返回了某个特定的值，你必须还要理解程序状态是如何达到的，而这本身就需要理解运行代码的所有历史。即使你没有特别遵循函数式编程（FP）的原则，避免使用全局变量的建议也是非常有价值的。
- en: Keeping Inner State
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 保持内部状态
- en: You can extend the practice of not using external variables to include avoiding
    internal variables, which keep state between calls. Even if no global variables
    are present, internal variables may cause future calls to the function to return
    different output, even when provided with the same input arguments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将不使用外部变量的做法扩展到避免使用内部变量，这些变量在函数调用之间保持状态。即使没有全局变量的存在，内部变量也可能导致未来对函数的调用返回不同的输出，即使传入相同的输入参数。
- en: Using internal state is why functional programmers don’t like working with objects.
    OOP requires data to be stored in an object to use for calculations, which automatically
    enables the possibility of impure code, because some methods could calculate results
    depending not only on their arguments but on the internal attributes as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内部状态是为什么函数式编程者不喜欢使用对象的原因。面向对象编程（OOP）要求数据存储在对象中以供计算，这自动开启了不纯代码的可能性，因为某些方法可能不仅依赖于它们的参数，还依赖于对象的内部属性。
- en: '##### Mutating Arguments'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 变更参数'
- en: 'We’ve considered working with (and possibly modifying) external or internal
    variables, but there is one more “sin” you might commit: modifying the actual
    arguments to the function. In JavaScript, arguments are passed by value, unless
    they are objects or arrays, which are passed by reference. The latter implies
    that if the function modifies the arguments, it will actually be modifying the
    original object or array, which is certainly a side effect. You saw a possible
    case earlier in the chapter when emulating .reduceRight() by first applying .reverse()
    to reverse an array—an unexpected side effect (see the section “Reducing an Array
    to a Single Value” on page 29).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了操作（并可能修改）外部或内部变量，但还有一种“罪行”你可能会犯：修改函数的实际参数。在 JavaScript 中，参数是按值传递的，除非它们是对象或数组，这些是按引用传递的。后者意味着，如果函数修改了参数，它实际上是在修改原始对象或数组，这无疑是一种副作用。你在本章之前看到的一个可能的例子是通过首先应用
    .reverse() 来反转数组，从而模拟 .reduceRight() ——这是一个意外的副作用（参见第 29 页的“将数组缩减为单个值”部分）。
- en: Detecting this kind of error can be difficult, because JavaScript itself provides
    several functions and methods that modify their input by definition. For example,
    if you decided to sort an input array, doing myArray.sort() would actually modify
    the original array, which is something the caller of your function might not be
    aware of. Other array methods, such as pop() or splice(), also affect the involved
    array; many such *mutator* methods exist. (Note, however, that ECMAScript recently
    added the toSorted(), toReversed(), and toSpliced() methods that do not affect
    the original array.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 检测这种错误可能比较困难，因为 JavaScript 本身提供了几个会根据定义修改其输入的函数和方法。例如，如果你决定对输入数组进行排序，执行 `myArray.sort()`
    实际上会修改原始数组，而这可能是调用你函数的用户未曾注意到的。其他数组方法，如 pop() 或 splice()，也会影响相关数组；类似的*变异*方法还有很多。（然而需要注意的是，ECMAScript
    最近增加了 toSorted()、toReversed() 和 toSpliced() 方法，它们不会影响原始数组。）
- en: Returning Impure Functions
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回不纯函数
- en: Some functions are inherently impure. For example, if you call an API to get
    the daily news, you expect it to return new results every time. If you’re programming
    a game and need to use Math.random() to generate randomness, you’ll want a different
    result every time; it won’t be useful if it always returns the same number. Similarly,
    any function that deals with the current date or time will be impure, because
    its results depend on an outside condition (the time), which could be considered
    a part of global state.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数本质上是不纯的。例如，如果你调用一个 API 来获取每日新闻，你期望每次返回不同的结果。如果你正在编写一个游戏，并且需要使用 Math.random()
    来生成随机数，你会希望每次结果不同；如果它总是返回相同的数字，那就没有用了。类似地，任何与当前日期或时间相关的函数都会是不纯的，因为其结果取决于外部条件（即时间），这可以看作是全球状态的一部分。
- en: For I/O-related functions, the returned result could vary for other reasons.
    I/O errors can happen unexpectedly; for example, an external service could crash
    or access rights to some filesystem could change. This means that at any time,
    the function might throw an exception instead of returning data. Even a seemingly
    safe function like console.log(), which doesn’t produce internal changes, is impure,
    because the user will see a change in console output.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与 I/O 相关的函数，返回结果可能因其他原因发生变化。I/O 错误可能会意外发生；例如，外部服务可能崩溃，或者某些文件系统的访问权限可能发生变化。这意味着函数在任何时候都可能抛出异常，而不是返回数据。即使是看似安全的函数，如
    console.log()，它不产生内部变化，但也是不纯的，因为用户会看到控制台输出的变化。
- en: Impure Functions
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不纯函数
- en: Doing away with all impurities likely isn’t feasible, so the next option is
    to consider how to reduce the problem size. One solution is to avoid the usage
    of state, and another solution is to use the *injection* pattern to control impurity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 摆脱所有不纯的情况可能不现实，因此下一个选项是考虑如何减少问题的规模。一个解决方案是避免使用状态，另一个解决方案是使用*注入*模式来控制不纯性。
- en: Avoiding State
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 避免状态
- en: With regard to setting global state, fortunately, there is a well-known solution.
    If a function needs to *get* global state, just provide the function whatever
    state elements it needs as arguments. This method solves that problem, because
    the function won’t then need to access global state directly. On the other hand,
    if a function needs to *set* global state, it shouldn’t do so directly. The function
    should produce an updated state and return it, and the caller should be responsible
    for updating the global state. If there’s a need to update state, at least it
    will be done at a higher level; whatever provides the state data to the function
    also will update the state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置全局状态，幸运的是，有一个广为人知的解决方案。如果一个函数需要*获取*全局状态，只需将所需的状态元素作为参数提供给该函数。这种方法解决了这个问题，因为函数就不需要直接访问全局状态了。另一方面，如果一个函数需要*设置*全局状态，它不应该直接这么做。该函数应该生成一个更新后的状态并返回，调用者应负责更新全局状态。如果确实需要更新状态，至少会在更高的层次上进行；提供状态数据给函数的同时，也会更新状态。
- en: These two rules also simplify testing. Instead of having to set some global
    state, provide the function with the initial state and then check whether the
    returned new state is correct.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条规则也简化了测试。你不需要设置某些全局状态，只需将初始状态提供给函数，然后检查返回的新状态是否正确。
- en: Using Injection
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用依赖注入
- en: So the problem of working with state is solved, but what about when you really
    need some impure function—for instance, for I/O or for random numbers? The technique
    shown here provides more flexible code, simplifies unit testing, and allows easier
    maintenance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，处理状态的问题已经解决了，但如果你真的需要一些不纯粹的函数——例如用于 I/O 或随机数时怎么办呢？这里展示的技术提供了更灵活的代码，简化了单元测试，并便于后期维护。
- en: 'Suppose a function needed to call an API and did it directly by using Axios,
    as shown earlier in this chapter (see the section “Functions as First-Class Objects”
    on page 25):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个函数需要调用 API，并且像本章之前展示的那样直接通过 Axios 实现（参见第25页的“函数作为一等公民”部分）：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Instead of calling the API directly, provide (or inject) a function to do it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不直接调用 API，而是提供（或注入）一个函数来执行它：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You define a new getData() function that actually calls the API ❶ and passes
    it to the (modified) doSomething() function as a new extra argument ❷. You haven’t
    actually avoided using impurities (such as doing I/O), but now the caller is in
    control by injecting a relevant function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了一个新的 getData() 函数，实际调用了 API ❶ 并将其作为新的额外参数 ❷ 传递给（修改后的）doSomething() 函数。你实际上并没有避免使用不纯函数（例如进行
    I/O 操作），但现在调用者通过注入相关函数来控制这一过程。
- en: 'This solution is the same as what was used for avoiding global state, since
    using axios.get() directly is in fact using a method of a global object, and what
    you are doing to avoid this situation is providing an extra parameter to be used
    by the function, so it won’t have to access anything global directly. The whole
    code still will be doing its I/O as required, but now the lower doSomething()
    function is pure, and for testing purposes, you can provide a mock function.  ###
    Summary'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案与避免使用全局状态时的做法是一样的，因为直接使用 axios.get() 实际上是在使用全局对象的方法，而你避免这种情况的做法是为函数提供一个额外的参数，这样它就不需要直接访问任何全局对象了。整个代码仍然会按需进行
    I/O 操作，但现在更低层次的 doSomething() 函数是纯粹的，并且为了测试目的，你可以提供一个模拟函数。### 总结
- en: In this chapter, we’ve described features of FP, how it’s supported by JavaScript,
    and a few examples of its usage. Working in an FP-oriented way allows for clearer,
    more maintainable code, and we’ll be using that style throughout the book whenever
    it makes sense. In later chapters, we’ll aim to apply FP and use functions for
    algorithms and data structures. [Chapter 18](chapter18.xhtml) takes a totally
    functional route and explores how the concept of FP extends to functional data
    structures.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们描述了函数式编程（FP）的特点，JavaScript 如何支持它，并给出了几个使用示例。以 FP 为导向的编程方式能够使代码更清晰、更易于维护，且我们将在本书中根据实际情况始终使用这种风格。在后续章节中，我们将致力于应用
    FP，并使用函数来处理算法和数据结构。[第18章](chapter18.xhtml)完全采用函数式编程路线，探讨了 FP 概念如何扩展到函数式数据结构。
- en: Questions
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: '**2.1  Pure or Impure?**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.1 纯粹还是不纯粹？**'
- en: Consider the following function that calculates the circumference of a circle
    given its radius but accesses a global variable to do it. Is it pure or impure?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下一个计算圆周长的函数，它通过访问全局变量来计算，但它是纯粹还是不纯粹的？
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**2.2  Prepare for Failure**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.2 为失败做好准备**'
- en: The addLogging() function doesn’t take into account the possibility of the original
    function throwing an exception. Can you modify it to produce proper results in
    that case as well?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`addLogging()` 函数没有考虑到原始函数抛出异常的情况。你能修改它以便在这种情况下也能正确返回结果吗？'
- en: '**2.3  You Got Time?**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.3 你有时间吗？**'
- en: Write an addTiming() higher-order function that will take a function as a parameter
    and produce an equivalent new function, but will log timing data on the console.
    The kind of solution you want is along the lines of the addLogging() function
    mentioned in this chapter; take care to account for exceptions as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `addTiming()` 高阶函数，它接受一个函数作为参数并生成一个等效的新函数，但会在控制台记录时间数据。你想要的解决方案类似于本章提到的
    `addLogging()` 函数；也要注意异常的处理。
- en: '**2.4  Parsing Problem**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.4 解析问题**'
- en: 'If you attempt to do ["1", "2", "4", "8", "16", "32"].map(parseInt), a weird
    [1, NaN, NaN, NaN, 1, 17] result is produced; can you explain why? Hint: check
    what parameters are passed by map() to your function.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试对 `["1", "2", "4", "8", "16", "32"]` 使用 `.map(parseInt)`，会得到一个奇怪的结果 `[1,
    NaN, NaN, NaN, 1, 17]`；你能解释一下为什么吗？提示：检查 `.map()` 向你的函数传递了哪些参数。
- en: '**2.5  Deny Everything**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.5 否定一切**'
- en: 'Write a negate() higher-order function that, given a predicate, will produce
    a complementary predicate that returns the opposite result. For example, if you
    had an isAdult() function that checked whether its argument was 21 or more, negate(isAdult)
    would check whether its argument was *not* 21 or more. (Tip: you may find this
    function useful for the next two questions.)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `negate()` 高阶函数，给定一个谓词，它将生成一个互补谓词，返回相反的结果。例如，如果你有一个 `isAdult()` 函数检查某个参数是否大于或等于
    21，`negate(isAdult)` 将检查该参数是否*不*大于或等于 21。（提示：你可能会发现这个函数在接下来的两个问题中很有用。）
- en: '**2.6  Every, Some ... None?**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.6 每个、一些 ... 没有？**'
- en: Create a .none() method that will check whether no element of an array satisfies
    a given predicate.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `.none()` 方法，用于检查数组中是否没有元素满足给定的谓词条件。
- en: '**2.7  No Some, No Every**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.7 没有一些，没有每个**'
- en: Write the equivalents of .some() and .every() based on .find() or .findIndex().
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `.find()` 或 `.findIndex()` 编写 `.some()` 和 `.every()` 的等效函数。
- en: '**2.8  What Does It Do?**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.8 它做了什么？**'
- en: 'Explain what the following code produces and why:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 解释以下代码的输出及其原因：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
