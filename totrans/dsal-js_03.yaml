- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 2 FUNCTIONAL PROGRAMMING IN JAVASCRIPT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Functional programming (FP)* is a programming paradigm based on functions,
    which are the only building blocks for your code. Using FP improves your code’s
    modularity and helps you write more understandable, testable, and easy-to-maintain
    code while avoiding bugs; it’s a win all around.'
  prefs: []
  type: TYPE_NORMAL
- en: Some people claim that FP is an enlightened approach to programming that leaves
    *object-oriented programming (OOP)* and other paradigms far behind. Others say
    that it is only theoretical, is not applicable “in the real world,” and causes
    more problems than it solves. As in most domains, the differences aren’t black
    or white, but a shade of gray. It’s not a matter of using only FP or never using
    FP. We’ll use it in this book, but not dogmatically, and in this chapter, you’ll
    see how JavaScript lets you work functionally, how and when to use FP, and instances
    when *not* to use it. Wherever FP applies and is more appropriate, we’ll use it,
    but if OOP is better suited, it will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*FP is not a modern fad. The second-oldest programming language still in common
    use (after FORTRAN, which appeared in 1957) is LISP (which appeared one year later),
    and it’s completely based on FP. Many other FP languages have appeared in the
    more than 60 years since, and even nonfunctional languages, such as JavaScript,
    also provide the same kind of functionality.*'
  prefs: []
  type: TYPE_NORMAL
- en: Why Use Functional Programming?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider what features are most important to you when programming and then
    ask whether FP provides them. Most programmers usually want the code they write
    to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understandable **Code is written once but read many times, and users should
    be able to “get” your functions and their relationships without great effort.
    FP tends to produce shorter and cleaner code, which is easier to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainable **Your code most likely will need maintenance sometime in the
    future, and it should be easy to do. The same features that make FP code easier
    to understand also allow for easier maintenance. You also don’t need to worry
    about breaking other things when modifying any given function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testable **Unit testing is a common part of development work, allowing you
    to verify the behavior of each component of your code. Unit tests also serve as
    a sort of documentation, providing examples of how to use any given function to
    people reading your code. If your programming style doesn’t favor writing easily
    testable code, you’ll have problems. FP always produces functions you can test
    on your own.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modular **You should divide your code’s features into independent modules,
    each pertaining to one specific aspect of your program, so that if you make changes
    in one module, they won’t affect the rest of your code. The goal in FP is to write
    independent functions you can refactor or modify without impacting other functions.
    Writing independent functions helps you achieve *separation of concerns* (distinct
    parts of a program have little overlap). Also, modules tend to be *highly cohesive*,
    which means they include functions that really belong together, and they are *loosely
    coupled*, so changes in a function are not likely to require changes in other
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusable **Reusing code saves time and money. Because functions stand on
    their own in FP, you can use a well-written set of functions anywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, object-oriented code can do all of these things as well. No one is
    ever going to say that FP is a silver bullet that solves all your software development
    problems. I always suggest taking the middle road; a well-thought-out, balanced
    mix is usually the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: '### JavaScript as a Functional Language'
  prefs: []
  type: TYPE_NORMAL
- en: '*Is JavaScript functional?* When people discuss functional languages, they
    typically mention Haskell, Erlang, Scala, and the like; no one usually includes
    JavaScript. That might be because no precise definition exists for what constitutes
    a functional language, what features a functional language should provide, or
    how it should work. For the purposes of this book, we’ll consider a language to
    be functional if (and only if) it supports common FP features; you’ll see how
    JavaScript compares. We’ll take advantage of items like functions as first-class
    objects, array functions, pure functions, higher-order functions, and recursion
    and avoid side effects (or *impurities*, in FP lexicon) using (local or global)
    state, mutating objects or arguments, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as First-Class Objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In JavaScript, to say that functions are *first-class objects* means you can
    do anything with them that you’d be able to do with other objects. You can store
    functions in variables, pass functions as arguments, or return a function as a
    result from some other function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example of doing an application programming interface (API) call.
    If you work with something like Axios (or SuperAgent, or other similar libraries
    that simplify the process of doing an async call to a remote server), you’ve likely
    seen code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The parameter to the .then() method is a function, and it’s passed in the same
    way you pass a number or an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](chapter12.xhtml), we’ll be doing that as well, and we’ll be
    also able to assign default values to function parameters in order to change the
    way the function performs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preOrder() function takes two arguments: a tree (you’ll learn about trees
    later) and a visit function; if you don’t provide the visit function, the default
    value will be a simple function that just logs whatever you pass to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking one or more functions as parameters makes the function a *higher-order
    function*; the other identifying characteristic for such a function is returning
    a function as a result. Common functions (those that do not receive or return
    functions) are called *first-order functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the same example, you could also write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The function is stored in a variable ❶, as functions are just another type of
    value that can go in a variable, and then the variable’s contents are passed to
    a function ❷ in exactly the same way that you pass myTree, another variable with
    a different kind of value.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see more examples throughout this chapter, including functions that return
    functions as results.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative-Style Programming
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FP works in a higher-level, *declarative* style instead of the imperative style
    used in procedural, “common” programming. With declarative programming, you specify
    what you want, but not the individual detailed steps necessary to accomplish it,
    as you would do in procedural coding. The best example of declarative coding involves
    arrays. Working with arrays usually entails loops, which you can do “by hand”
    (think of using a while loop) or with the preferred for statement, but JavaScript
    lets you work declaratively with some specific array functions. In fact, we’ll
    look at some *methods* for this, but the same concept applies; a method is just
    a function after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list details some of the available array functions that let you
    search or select elements from an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.filter() **Picks elements that satisfy some condition out of an array'
  prefs: []
  type: TYPE_NORMAL
- en: '**.find() and .findIndex() **Search an array to find an element that satisfies
    some condition'
  prefs: []
  type: TYPE_NORMAL
- en: '**.some() **Lets you know whether at least one element of an array satisfies
    a condition'
  prefs: []
  type: TYPE_NORMAL
- en: '**.every() **Lets you test whether all elements of an array satisfy a condition'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other functions transform an array into a new array or a single result:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.map() **Lets you transform one array into another by applying a given function
    to its elements'
  prefs: []
  type: TYPE_NORMAL
- en: '**.reduce() **Applies a given operation to the whole array from left to right,
    reducing it to a single result'
  prefs: []
  type: TYPE_NORMAL
- en: '**.reduceRight() **Works like .reduce() but from right to left'
  prefs: []
  type: TYPE_NORMAL
- en: 'This list isn’t meant to be complete: there are more functions that transform
    arrays, like .flat() or .flatMap(), but you won’t see them here.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Some people say that these functions are slower than the corresponding hand-written
    loops and that you’ll suffer some performance hit for using them. Even if those
    things were true, they are irrelevant. Unless you are having some real performance
    problems and after analyzing your code you reach the conclusion that the array
    functions are to blame, writing longer, more bug-prone code doesn’t really make
    much sense.*'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering an Array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s take a look at a common task: going through an array, selecting elements
    that satisfy some condition, and dropping the rest. The .filter() method does
    exactly that: you provide a *predicate* (a function that produces a boolean result
    in terms of its arguments), and a new array is produced, with only the elements
    of the original array for which the predicate returned true.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to select all values under 21, the following predicate would be
    useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The under21() function gets a value and returns true if the value is less than
    21\. Now you can write the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This specifies that you want to apply the “under 21” check to filter the original
    array, and the result is a new array with only the values that satisfied the given
    test. You don’t need to write anything to control a loop, initialize an output
    array, or anything else. The code is much shorter and truly declarative; it specifies
    only *what* you wanted to get, not *how* to get it.
  prefs: []
  type: TYPE_NORMAL
- en: Searching an Array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Other methods let you search an array for some element that satisfies a predicate,
    returning either the element or its position in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '**find() **Goes through the array from beginning to end, testing for the given
    predicate; if an element of the array satisfies it, the element is returned; if
    no elements satisfy the predicate, undefined is returned. A recent new method,
    findLast(), does the same, but searches from the end to the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: '**findIndex() **Is similar to find(), but it returns the position of the first
    element satisfying the predicate or -1 if no elements satisfy it. The new findLastIndex()
    returns the position of the last element that satisfies the predicate.'
  prefs: []
  type: TYPE_NORMAL
- en: These methods are practical, because they provide all the needed search code
    in a single line. There is no limit to the complexity of a search predicate. You
    aren’t limited to looking only for a value, for example, and can test any condition,
    as you did with under21() previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of using both of these searching methods at once, since they
    are related and similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first element of myArray that satisfies the under21 predicate is 9 ❶, and
    it’s at position 1 of the array ❷. If you redo the calls using an equal21 predicate
    that checks whether a value is 21, you get undefined ❸ and -1 ❹, because no such
    element is found in the array.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you are searching for a specific value,* .includes()*,* .index()*, and*
    .lastIndexOf() *are quite useful, though less flexible than the FP-oriented methods
    described earlier, because they just let you search for a value and not test for
    any possible condition.*'
  prefs: []
  type: TYPE_NORMAL
- en: Testing an Array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Related methods for searching are .some() and .every(). The first checks whether
    *any* element of an array satisfies some predicate, and the second checks whether
    *all* elements satisfy it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you test whether some elements of the array are under 21, the answer is true,
    but not all elements are true. If you repeat these tests for equality to 21, both
    answers are false.
  prefs: []
  type: TYPE_NORMAL
- en: You could omit these functions if you have the methods in the previous section
    (see question 2.7 at the end of the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Transforming an Array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Algorithms often need to go through a set of elements (such as an array) and
    apply some operation to each of them to create a new set. For instance, in a web
    application, you could have a list of strings, which could represent numbers,
    and you’d want to transform that list into a list of the corresponding numeric
    values. Setting up a loop to go through all elements of an array systematically,
    processing elements one by one, and producing a new array is a common procedure
    and usually taught early on to developers. This kind of transformation is also
    key in FP, and JavaScript calls it the .map() function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an introductory example that just produces a new array, with all values
    multiplied by 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Start with the same array you’ve been using. If you map it with a function that
    multiplies its argument by 10, you get a new array whose values are 10 times the
    original ones.
  prefs: []
  type: TYPE_NORMAL
- en: Using .map() instead of a common loop means clearer code, and mapping is a well-known
    pattern in FP. The code is also shorter, which means fewer chances of introducing
    bugs. And finally, the code produces a new array instead of modifying the original
    one, so the function is *pure* (you’ll learn what that means later in this chapter).
    Whenever possible, use .map(), but be aware that some of its features could bite
    you; see question 2.4 at the end of this chapter for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing an Array to a Single Value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here is another common task: writing loops that go through a complete array,
    performing some kind of operation and ending up with a single computed value.
    (A typical example is an array with a list of numbers and adding them up.) You
    can implement this kind of task in a functional way using either the .reduce()
    or, less frequently, the .reduceRight() function. The following sums up a complete
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This logic does all that’s needed to apply a function that receives two values
    and returns their sum to the complete array, starting with 0\. In other words,
    it sums all the elements of the array. The a argument stands for *accumulator*
    (initially 0), and v stands for *value* (each of the elements of the array). You
    don’t need to provide the initial value for .reduce(), but it’s safer to do so.
    If you try to reduce an empty array without an initial value, you’ll get a runtime
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the power of .reduce(), look at another case where you calculate more
    than one result: averaging the array values. For that, you need not only their
    sum, which you already know how to get, but also their count (forget that you
    could use myArray.length to provide the latter; this is just an example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The object has two fields (s for the sum and c for the count), and the reducing
    function recalculates those values at each step; the final result matches the
    previous example.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to process an array from right to left, .reduceRight() works the
    same way, but it starts at the end of the array and goes back to the first element.
    Of course, you also could reverse the original array by first using .reverse()
    and then .reduce(), but that would cause a side effect. The array would be reversed
    in place (see “Mutating Arguments” on page 33 for more about this).
  prefs: []
  type: TYPE_NORMAL
- en: Looping Through Arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The .forEach() array function takes care of looping through an array, invoking
    a callback for each element, so you just have to declare what kind of work you
    want to do and nothing else. You can redo the array summing logic using this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First set the sum variable to 0; this variable will get the sum of all elements
    in the array ❶. Then go through the array ❷ and specify what you want to do with
    each v element. In this case, add it to sum, and the final result ❸ is exactly
    the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned previously, functions that receive other functions as arguments
    or that return functions as results are called *higher-order functions*. This
    means all functions that work with callbacks are higher-order functions, and so
    are all the array methods just discussed. Some of these functions allow you to
    work in a more declarative style (like the ones you saw earlier), and others allow
    you to extend a function and modify what it does—for example, adding logging as
    an aid for debugging or memoizing for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider one of the uses for higher-order functions: returning a new function,
    with an example of wrapped behavior. Wrapping produces a new function that keeps
    its original functionality but adds some extra behavior. Imagine you want to add
    logging to a function for debugging purposes. You could modify the function of
    course, but doing so is risky, because you could accidentally touch something
    you shouldn’t. You also could use a debugger, but a wrapper function provides
    more flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original function could be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You then could modify it to add logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the function had several return statements, however, you’d need to modify
    them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a higher-order logging function is better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The addLogging() function receives a function as argument and returns a new
    function ❹. First, this new function logs the original function’s name ❶ and the
    arguments it received. Then it actually calls the original function to calculate
    whatever the function calculated ❷. After that, the new function logs the result
    ❸ and finally returns that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The sum2() function logs something and returns the sum of its arguments ❶. When
    you pass sum2 as a parameter to addLogging and call the resulting function ❷,
    you get the extra logging you wanted without touching the original function.
  prefs: []
  type: TYPE_NORMAL
- en: Side Effects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When a function depends only on the parameters it receives and doesn’t produce
    any side effects, it is called a *pure function*. The concept of pure functions
    is closely related to mathematical functions: given an *f*(*x*) function, all
    it does when given a value for *x* is calculate a new value.'
  prefs: []
  type: TYPE_NORMAL
- en: Using pure functions is advantageous because they don’t produce any side effects,
    such as changing the program state, modifying variables, mutating objects, and
    so on. This means that when you call a pure function, you don’t need to worry
    about any possible changes anywhere in your code or the possibility of something
    else getting broken; you can concentrate on which arguments you pass to the function,
    knowing no “surprises” will happen. When given the same arguments, the function
    will always return the same result. That result won’t depend on any “outside”
    variables or state, which could change and then cause the function to produce
    a different result. On the other hand, a pure function cannot depend on random
    numbers, the time of day, the result of input/output (I/O) functions, and so on;
    it depends only on its input.
  prefs: []
  type: TYPE_NORMAL
- en: Using Global State
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The most common reason for side effects is using nonlocal variables that are
    shared with other parts of the code. Since a pure function always produces the
    same output given the same inputs, if a function depends somehow on variables
    outside it, it automatically becomes impure.
  prefs: []
  type: TYPE_NORMAL
- en: The problem goes deeper; debugging a function that depends on global state is
    more difficult, because in order to understand why a function returned a given
    value, you must also understand how the program state was reached, and that itself
    requires understanding all the previous history of the running code. The injunction
    against using global variables is a good one, even if you aren’t specifically
    following FP tenets.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Inner State
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can extend the practice of not using external variables to include avoiding
    internal variables, which keep state between calls. Even if no global variables
    are present, internal variables may cause future calls to the function to return
    different output, even when provided with the same input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using internal state is why functional programmers don’t like working with objects.
    OOP requires data to be stored in an object to use for calculations, which automatically
    enables the possibility of impure code, because some methods could calculate results
    depending not only on their arguments but on the internal attributes as well.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Mutating Arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve considered working with (and possibly modifying) external or internal
    variables, but there is one more “sin” you might commit: modifying the actual
    arguments to the function. In JavaScript, arguments are passed by value, unless
    they are objects or arrays, which are passed by reference. The latter implies
    that if the function modifies the arguments, it will actually be modifying the
    original object or array, which is certainly a side effect. You saw a possible
    case earlier in the chapter when emulating .reduceRight() by first applying .reverse()
    to reverse an array—an unexpected side effect (see the section “Reducing an Array
    to a Single Value” on page 29).'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting this kind of error can be difficult, because JavaScript itself provides
    several functions and methods that modify their input by definition. For example,
    if you decided to sort an input array, doing myArray.sort() would actually modify
    the original array, which is something the caller of your function might not be
    aware of. Other array methods, such as pop() or splice(), also affect the involved
    array; many such *mutator* methods exist. (Note, however, that ECMAScript recently
    added the toSorted(), toReversed(), and toSpliced() methods that do not affect
    the original array.)
  prefs: []
  type: TYPE_NORMAL
- en: Returning Impure Functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some functions are inherently impure. For example, if you call an API to get
    the daily news, you expect it to return new results every time. If you’re programming
    a game and need to use Math.random() to generate randomness, you’ll want a different
    result every time; it won’t be useful if it always returns the same number. Similarly,
    any function that deals with the current date or time will be impure, because
    its results depend on an outside condition (the time), which could be considered
    a part of global state.
  prefs: []
  type: TYPE_NORMAL
- en: For I/O-related functions, the returned result could vary for other reasons.
    I/O errors can happen unexpectedly; for example, an external service could crash
    or access rights to some filesystem could change. This means that at any time,
    the function might throw an exception instead of returning data. Even a seemingly
    safe function like console.log(), which doesn’t produce internal changes, is impure,
    because the user will see a change in console output.
  prefs: []
  type: TYPE_NORMAL
- en: Impure Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Doing away with all impurities likely isn’t feasible, so the next option is
    to consider how to reduce the problem size. One solution is to avoid the usage
    of state, and another solution is to use the *injection* pattern to control impurity.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding State
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With regard to setting global state, fortunately, there is a well-known solution.
    If a function needs to *get* global state, just provide the function whatever
    state elements it needs as arguments. This method solves that problem, because
    the function won’t then need to access global state directly. On the other hand,
    if a function needs to *set* global state, it shouldn’t do so directly. The function
    should produce an updated state and return it, and the caller should be responsible
    for updating the global state. If there’s a need to update state, at least it
    will be done at a higher level; whatever provides the state data to the function
    also will update the state.
  prefs: []
  type: TYPE_NORMAL
- en: These two rules also simplify testing. Instead of having to set some global
    state, provide the function with the initial state and then check whether the
    returned new state is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Using Injection
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: So the problem of working with state is solved, but what about when you really
    need some impure function—for instance, for I/O or for random numbers? The technique
    shown here provides more flexible code, simplifies unit testing, and allows easier
    maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose a function needed to call an API and did it directly by using Axios,
    as shown earlier in this chapter (see the section “Functions as First-Class Objects”
    on page 25):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of calling the API directly, provide (or inject) a function to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You define a new getData() function that actually calls the API ❶ and passes
    it to the (modified) doSomething() function as a new extra argument ❷. You haven’t
    actually avoided using impurities (such as doing I/O), but now the caller is in
    control by injecting a relevant function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution is the same as what was used for avoiding global state, since
    using axios.get() directly is in fact using a method of a global object, and what
    you are doing to avoid this situation is providing an extra parameter to be used
    by the function, so it won’t have to access anything global directly. The whole
    code still will be doing its I/O as required, but now the lower doSomething()
    function is pure, and for testing purposes, you can provide a mock function.  ###
    Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ve described features of FP, how it’s supported by JavaScript,
    and a few examples of its usage. Working in an FP-oriented way allows for clearer,
    more maintainable code, and we’ll be using that style throughout the book whenever
    it makes sense. In later chapters, we’ll aim to apply FP and use functions for
    algorithms and data structures. [Chapter 18](chapter18.xhtml) takes a totally
    functional route and explores how the concept of FP extends to functional data
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**2.1  Pure or Impure?**'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following function that calculates the circumference of a circle
    given its radius but accesses a global variable to do it. Is it pure or impure?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**2.2  Prepare for Failure**'
  prefs: []
  type: TYPE_NORMAL
- en: The addLogging() function doesn’t take into account the possibility of the original
    function throwing an exception. Can you modify it to produce proper results in
    that case as well?
  prefs: []
  type: TYPE_NORMAL
- en: '**2.3  You Got Time?**'
  prefs: []
  type: TYPE_NORMAL
- en: Write an addTiming() higher-order function that will take a function as a parameter
    and produce an equivalent new function, but will log timing data on the console.
    The kind of solution you want is along the lines of the addLogging() function
    mentioned in this chapter; take care to account for exceptions as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.4  Parsing Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you attempt to do ["1", "2", "4", "8", "16", "32"].map(parseInt), a weird
    [1, NaN, NaN, NaN, 1, 17] result is produced; can you explain why? Hint: check
    what parameters are passed by map() to your function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2.5  Deny Everything**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a negate() higher-order function that, given a predicate, will produce
    a complementary predicate that returns the opposite result. For example, if you
    had an isAdult() function that checked whether its argument was 21 or more, negate(isAdult)
    would check whether its argument was *not* 21 or more. (Tip: you may find this
    function useful for the next two questions.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**2.6  Every, Some ... None?**'
  prefs: []
  type: TYPE_NORMAL
- en: Create a .none() method that will check whether no element of an array satisfies
    a given predicate.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.7  No Some, No Every**'
  prefs: []
  type: TYPE_NORMAL
- en: Write the equivalents of .some() and .every() based on .find() or .findIndex().
  prefs: []
  type: TYPE_NORMAL
- en: '**2.8  What Does It Do?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explain what the following code produces and why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
