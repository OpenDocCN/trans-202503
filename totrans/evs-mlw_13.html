<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_167" aria-label="167"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch10">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ANTI-DEBUGGING</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2"><i>Anti-debugging</i> is a series of anti-reversing techniques used by malware (and even some legitimate programs) to hamper or prevent debugging. For example, the malware might try to interfere with the debugger process if it detects that it’s attached to a debugger, or it might try to prevent debugging altogether by using so-called anti-attach mechanisms or crashing the debugger program. In this chapter, we’ll explore some of these techniques in detail.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-143"/><samp class="SANS_Futura_Std_Bold_B_11">Using Windows API Functions to Access the PEB</samp></h3>&#13;
<p class="TNI1">As you learned in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, the Process Environment Block (PEB) is a structure that contains pointers to information in memory about the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_168" aria-label="168"/>currently running process. The PEB includes several pointers that are relevant to anti-debugging, as listed in <a href="chapter10.xhtml#tab10-1">Table 10-1</a>.</p>&#13;
<p class="TT" id="tab10-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">PEB Members Relating to Anti-debugging</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">PEB offset</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">PEB member</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x002</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Indicates whether the program is currently being debugged</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x018</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessHeap</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Contains pointers to the heap’s</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp> <samp class="SANS_Futura_Std_Book_11">members</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x068</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Contains information related to the creation of memory heaps</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Windows exposes a wealth of data about its internal workings to programs via its APIs. Some Windows API functions have the sole purpose of telling the calling program whether a debugger is attached, and malware can easily exploit this fact by having them query the PEB to determine whether it’s being debugged. Not only that, but malware can also abuse some API functions to trick Windows into exposing an attached debugger. In this section, we’ll look at some common ways in which malware can leverage the Windows API and NT API to try to identify a malware analyst debugging its code. Later in the chapter, you’ll see how malware can also query the PEB directly, which is why it’s important to have at least a basic understanding of the PEB’s relevant members.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-144"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IsDebuggerPresent and CheckRemoteDebuggerPresent</samp></h4>&#13;
<p class="TNI1">One of the best-known and simplest Windows functions for detecting debuggers is <samp class="SANS_TheSansMonoCd_W5Regular_11">IsDebuggerPresent</samp>. This function returns a nonzero value if the current process is being debugged; otherwise, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp> function returns the same information, but with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. The following example shows how malware might use it:</p>&#13;
<pre class="pre-82"><code><var>--snip--</var>&#13;
push [ebp+hProcess]&#13;
push [ebp+DebuggerPresent]&#13;
call CheckRemoteDebuggerPresent&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">Two parameters are being pushed to the stack here: a handle to the target process (in this case, the malware’s own process, <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>) followed by a pointer to a variable that will receive the information returned (<samp class="SANS_TheSansMonoCd_W5Regular_11">DebuggerPresent</samp>). Once the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp>, the return value (<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>) is stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DebuggerPresent</samp> variable. As you’ll see later in the chapter, these are some of the easiest debugger detection techniques to circumvent.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_169" aria-label="169"/>&#13;
<h4 class="H2" id="sec3"><span id="h-145"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQueryInformationProcess</samp></h4>&#13;
<p class="TNI1">To detect a debugger, <samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp> calls the system function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationProcess</samp>, a lower-level Windows NT function that can return a lot of different information about the system. <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationProcess</samp> can also be called directly. It takes several parameters, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessHandle</samp> (a handle to the target process) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass</samp> value (the type of information that should be returned). In the case of debugger detection, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass</samp> value would be <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessDebugPort</samp>. A nonzero value indicates that the process is currently running under a debugger.</p>&#13;
<p class="TX">Alternatively, the malware author can specify <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass ProcessDebugFlags</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">1F</samp>). If the process is being debugged, the debug flags will be set, tipping off the malware. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessDebugObjectHandle</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">1E</samp>) information class can also reveal a debugger.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-146"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQuerySystemInformation</samp></h4>&#13;
<p class="TNI1"><samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp> is a Windows NT function that can be used to, you guessed it, query system information. This function can return many different types of information, and an especially crucial structure for our purposes is <samp class="SANS_TheSansMonoCd_W5Regular_11">SYSTEM_KERNEL_DEBUGGER_INFORMATION</samp>. This structure contains two important values for debugger detection: <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerEnabled</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerNotPresent</samp>, both of which can be used to detect a kernel debugger attached to the calling process. <i>Kernel debuggers</i> are specialized tools for debugging low-level software and sometimes for malware analysis. If <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerEnabled</samp> returns nonzero or <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerNotPresent</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, it might indicate to the malware that a kernel debugger is present.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-147"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">OutputDebugString</samp></h4>&#13;
<p class="TNI1">The <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp> function simply displays a string in the debugger. If a process is attached to a debugger, the string will be displayed; if not, <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp> will return with an error. Malware can abuse this function by manually setting an error code using <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp> (this error can be any arbitrary value), calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp> with a random string value, and then calling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp> to check whether the error state has changed, as demonstrated in the following pseudocode:</p>&#13;
<pre class="pre-83"><code>SetLastError("5");&#13;
OutputDebugString("testing123");&#13;
&#13;
error = GetLastError();&#13;
&#13;
if (error == "5"):&#13;
  // Debugger detected.&#13;
  // Execute evasion code, such as TerminateProcess.&#13;
else:&#13;
  // Did not detect debugger; continue execution.</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_170" aria-label="170"/>This malware sample sets an error code of <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> using <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>, then invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp> with the random string value <samp class="SANS_TheSansMonoCd_W5Regular_11">testing123</samp>. Next, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp> to get the last error code and compares that value to the error code from the previous <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp> call. If the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp> succeeded with no error, the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp> code should still be <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>, meaning that a debugger is present. This is an old technique, but malware occasionally still attempts to use it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-148"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">CloseHandle and NtClose</samp></h4>&#13;
<p class="TNI1">If a malware sample is being debugged and the malware attempts to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">CloseHandle</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp> function with an invalid handle, it will raise an <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_INVALID_HANDLE</samp> exception. Once this exception is triggered, it will be passed to the debugger’s exception handler, tipping off the malware that it is being debugged. The following simple code demonstrates this:</p>&#13;
<pre class="pre-84"><code>mov ebx, [invalid_handle]&#13;
call NtClose</code></pre>&#13;
<p class="TX">The preceding code calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp> with an invalid handle as a parameter. Once executed, this will raise an exception and tip off the malware that it is being debugged.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-149"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQueryObject</samp></h4>&#13;
<p class="TNI1">For a debugger to work properly, it must create a special kernel object called a <i>debug object</i>. Malware can call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp> to get a list of all debug objects, whose presence would indicate either that the malware is currently being debugged or that the host has used a debugger in the past.</p>&#13;
<p class="TX">The first parameter for this function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Handle</samp>, is the handle to the object being queried for information. The second parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>, accepts an <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformationClass</samp> value that will tell the function what type of data needs to be returned. The third parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformation</samp>, accepts a pointer to where the returned data will be stored.</p>&#13;
<p class="TX">If you spot malware calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>, providing an <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformationClass</samp> value of <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectAllTypesInformation</samp>), and then inspecting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformation</samp> buffer for strings such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugObject</samp>, you can be relatively certain the malware is attempting to identify a debugger.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h-150"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Heap Flags</samp></h4>&#13;
<p class="TNI1">The PEB contains pointers to the process’s memory heap structure, known as the <i>process heap</i>, at location 0x18 (0x30 for 64-bit processes). The process heap contains various members that are pointers to additional data; two of these members are <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp>, which point to a block of data that provides information to the Windows kernel about the process heap memory. In Windows 7 and above, if a process is being debugged, the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> member will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x40000062</samp>, and the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp> member will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x40000060</samp>. To detect a debugger, malware may <span role="doc-pagebreak" epub:type="pagebreak" id="pg_171" aria-label="171"/>attempt to read these values in its heap structure by calling the function <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlQueryProcessHeapInformation</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlQueryProcessDebugInformation</samp>, or it may manually read the PEB as we’ll discuss in the next section.</p>&#13;
<p class="TX">This isn’t a common anti-debugging technique, so I won’t go into further detail here, but it’s important to be aware that it exists. If you spot malware calling one or both of these functions, inspect the code that follows. If the malware is querying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp> member, there’s a good chance it’s trying to detect your debugger.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h-151"/><samp class="SANS_Futura_Std_Bold_B_11">Directly Accessing the PEB</samp></h3>&#13;
<p class="TNI1">Rather than relying on the Windows functions described in the previous section, malware might directly access and read the PEB, as shown in the following assembly code:</p>&#13;
<pre class="pre-85"><code><var>--snip--</var>&#13;
mov eax, [fs:0x30]&#13;
cmp [eax+0x2], 1&#13;
jnz DebuggerDetected&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">Here, in order to obtain the address of the PEB to read it, the malware moves the address at <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:0x30</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>. (As you might recall from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:0x30</samp> is the address for the beginning of the PEB.) Next, the malware compares the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">eax+0x2</samp>, which is the <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp> field in the PEB structure. If this value is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, it’s likely that a debugger is attached to the process, and the malware might respond accordingly.</p>&#13;
<p class="TX">Another example of manual PEB reading involves the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp>, which is located at byte 0x68 in the PEB and contains information related to the creation of memory heaps. When a process is started under a debugger, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp> will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>, so malware can read that value in its PEB for a quick debugger check.</p>&#13;
<p class="TX">Keep in mind that malware can query any member of the PEB structure in this manner. Accessing the PEB directly, rather than invoking common Windows functions in order to do so, can be an effective way for malware to detect a debugger without raising alarms.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h-152"/><samp class="SANS_Futura_Std_Bold_B_11">Timing Checks</samp></h3>&#13;
<p class="TNI1"><span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span> described timing checks specifically in the context of detecting sandboxes and VM environments, but these checks can also be used to detect debuggers. Three of the common timing-based methods for debugger detection are <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction, and system time checks.</p>&#13;
<p class="TX">As you might remember from <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> returns the number of milliseconds that have elapsed since system boot-up. Malware can call <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> at various points in its code to see how much time has elapsed since its last call to this function. When malware is being debugged, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_172" aria-label="172"/>the program will naturally execute more slowly, especially if the malware analyst is setting breakpoints throughout the debugging process. If the analyst happens to place a breakpoint on a function or is single-stepping through code, the difference between the first call of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> and the last will be much greater than it would be otherwise. Malware can exploit this fact to detect a debugger.</p>&#13;
<p class="TX">Malware can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction in a similar manner. By placing <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instructions throughout its code, malware can determine whether it’s being debugged based on CPU timing (see the x64dbg screenshot in <a href="chapter10.xhtml#fig10-1">Figure 10-1</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig10-1" src="../images/fig10-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Malware using rdtsc as an anti-debugging technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Finally, malware can simply query the system time by calling functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLocalTime</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemTime</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemTime</samp> at various points in its code to detect a debugger in use.</p>&#13;
<p class="TX">There are many other methods of using timing checks to catch a debugger in its tracks; these are only some of the most common. The takeaway here is that if you spot malware that is occasionally calling timing functions or using instructions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> throughout its code, it could be using anti-debugging techniques. The best way to address this is to simply avoid using a debugger. However, this isn’t always practical. You may have to identify where these functions and instructions are being executed in the malware and patch them out, or you may modify their return values to trick the malware into believing it’s not being debugged.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h-153"/><samp class="SANS_Futura_Std_Bold_B_11">System Artifacts</samp></h3>&#13;
<p class="TNI1">Malware may be able to detect a debugger via system artifacts such as desktop windows, registry keys, and loaded modules. We’ll cover each briefly in this section, but you might also find it helpful to refer back to <span class="Xref"><a href="part2.xhtml">Part II</a></span>, which covered how malware might search for these types of artifacts.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h-154"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hunting for Debugger Windows</samp></h4>&#13;
<p class="TNI1"><span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> discussed how malware can detect analyst tools using functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FindWindow</samp>, which locates a desktop window, and <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>, which enumerates open desktop windows. Malware can also use these functions to look specifically for debugger windows. For example, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">FindWindow</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_173" aria-label="173"/>to enumerate open windows with debugger product names such as x64dbg, OllyDbg, or Immunity debugger. <a href="chapter10.xhtml#fig10-2">Figure 10-2</a> shows the ransomware variant Satan hunting for any open OllyDbg windows.</p>&#13;
<figure class="IMG"><img class="img100" id="fig10-2" src="../images/fig10-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: The malware Satan looking for OllyDbg-related windows</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h-155"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Enumerating Loaded Modules</samp></h4>&#13;
<p class="TNI1">When you attach malware to a debugger, the debugger may load modules into the malware’s address space; for example, the WinDbg debugger may load the <i>dbghelp.dll</i> library. Malware can locate a suspect module by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp> function and passing the module’s name (such as <i>dbghelp.dll</i>) as a parameter. Alternatively, it can enumerate all loaded modules by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> and then search for a specific module name.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h-156"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Searching for Debugger Processes</samp></h4>&#13;
<p class="TNI1">Malware can also enumerate the running processes on the host to search for debugger processes. To do so, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>, then look specifically for common debugger process names, such as <i>ollydbg.exe</i>, <i>x64dbg.exe</i>, or <i>ida64.exe</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h-157"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Checking Parent Processes</samp></h4>&#13;
<p class="TNI1">To detect a debugger, malware can check to see what its parent process is. If the malware is running inside a debugger, its parent process will be the debugger process. If the malware detects it is running as a child process of a debugger process (such as <i>x64dbg.exe</i>), the malware will identify that it is being debugged.</p>&#13;
<p class="TX">Malware can detect its parent process in a few ways. One approach is to obtain its own process ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetCurrentProcessId</samp>), take a snapshot of all running processes (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>), and use <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Proces32Next</samp> to search for its own process name. Once it finds its process, the process snapshot structure contains an entry (<samp class="SANS_TheSansMonoCd_W5Regular_11">th32ParentProcessID</samp>) representing its parent process ID.</p>&#13;
<p class="TX">Similarly, malware could spawn a child process using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>, making the malware’s original process the parent process of this new child. The child process could then invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp> with its parent process as a parameter. If the parent process (the original malware process) is already being debugged, this function will throw an exception such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PORT_ALREADY_SET</samp>, cluing in the malware that there’s a debugger attached to it.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_174" aria-label="174"/>&#13;
<h3 class="H1" id="sec16"><span id="h-158"/><samp class="SANS_Futura_Std_Bold_B_11">Breakpoint Detection and Traps</samp></h3>&#13;
<p class="TNI1">When investigating malware in a debugger, a malware analyst commonly creates breakpoints on specific instructions, function calls, or specific memory segments. As you might remember from <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, the act of creating software breakpoints in the malware’s code modifies the running malware sample. This means that the malware can detect these breakpoints in some interesting ways. This section will discuss some of the breakpoint detection, circumvention, and exploitation methods malware might employ.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h-159"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Detecting Debuggers with Breakpoints</samp></h4>&#13;
<p class="TNI1">When a debugger hits a breakpoint instruction such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> (one of the most common) in a program, it breaks at that point in the program’s code. This occurs because the breakpoint instruction causes an interrupt exception in the program, which ultimately transfers control to the debugger. When a program is not being debugged, however, breakpoint instructions cause an <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp> and the control flow is passed to the program’s default exception handler.</p>&#13;
<p class="TX">This is a great way for malware to test whether it’s being debugged. If malware executes the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> and it’s not being debugged, an <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp> will be raised and the exception handler will be invoked. Of course, the opposite is also true. If this <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp> doesn’t invoke the exception handler, the malware can infer that it’s being debugged. Take a look at the following simplified pseudocode:</p>&#13;
<pre class="pre-86"><code><var>--snip--</var>&#13;
IsBeingDebugged() {&#13;
  try {&#13;
   <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> asm ("int 3");&#13;
     return true;&#13;
  }&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> catch (EXCEPTION_EXECUTE_HANDLER) {&#13;
     return false;&#13;
  }&#13;
}&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">This pseudocode features a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">try... catch</samp> statement. The malware attempts to execute the <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> instruction <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and if this statement successfully returns without invoking an exception handler, the malware assumes it’s running in a debugger. If this instruction raises an exception <span class="CodeAnnotation" aria-label="annotation2">❷</span>, however, the malware can safely assume it’s not attached to a debugger.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h-160"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Detecting and Circumventing Software Breakpoints</samp></h4>&#13;
<p class="TNI1">Malware can also directly detect the use of breakpoints by implementing breakpoint-scanning techniques. In the following assembly code example, the malware scans its code for the breakpoint instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp> in hex):</p>&#13;
<pre class="pre-87"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_175" aria-label="175"/><var>--snip--</var>&#13;
mov ebx, &lt;kernel32.WriteProcessMemory&gt;&#13;
cmp byte ptr ds:[ebx], 0xCC&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">This malware sample is trying to determine whether a malware analyst has set a software breakpoint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> function. First, the malware moves the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> register. Then, it compares the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp> (the <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> debugger breakpoint instruction) to the first byte in <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>, which is the beginning of the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> function and where the breakpoint will reside. Once the malware identifies a software breakpoint, it may attempt to overwrite or clear the breakpoint.</p>&#13;
<p class="TX">You can overcome some breakpoint detection techniques by using uncommon breakpoint instructions. Many debuggers have this option. In x64dbg, simply navigate to <b>Options</b><span class="MenuArrow"></span><b>Settings</b><span class="MenuArrow"></span><b>Engine</b> and set your preferred breakpoint instruction under Default Breakpoint Type, as shown in <a href="chapter10.xhtml#fig10-3">Figure 10-3</a>.</p>&#13;
<figure class="IMG"><img class="img80" id="fig10-3" src="../images/fig10-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: Setting the default breakpoint type in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Some variations of malware look for these alternative breakpoint instructions as well, so a better option is to use hardware breakpoints to circumvent software breakpoint detection techniques. Hardware breakpoints can also be circumvented by malware, however, as the next section will discuss.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h-161"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Detecting and Circumventing Hardware and Memory Breakpoints</samp></h4>&#13;
<p class="TNI1">Like software breakpoints, hardware breakpoints can be used by analysts to intercept function calls, break on interesting behavior, and generally control the malware’s execution. Because hardware breakpoints are implemented in CPU registers (DR0–DR3) rather than as instructions, malware can scan these registers for them. If any of these registers contain data (specifically, a memory address), the malware might assume there’s a hardware breakpoint in place and take evasive actions, such as clearing these registers, effectively removing the breakpoints. One way to find hardware breakpoints <span role="doc-pagebreak" epub:type="pagebreak" id="pg_176" aria-label="176"/>is by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp> function (or <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64GetThreadContext</samp> for 64-bit programs) as follows:</p>&#13;
<pre class="pre-88"><code>CONTEXT context;&#13;
context.ContextFlags = CONTEXT_DEBUG_REGISTERS;&#13;
HANDLE hThread = GetCurrentThread();&#13;
GetThreadContext(hThread, &amp;context);&#13;
&#13;
if ((context.Dr0) || (context.Dr1) || (context.Dr2) || (context.Dr3)) {&#13;
   return true;&#13;
}</code></pre>&#13;
<p class="TX">In this sample pseudocode (adapted from <a href="https://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide"><i>https://<wbr/>www<wbr/>.codeproject<wbr/>.com<wbr/>/Articles<wbr/>/30815<wbr/>/An<wbr/>-Anti<wbr/>-Reverse<wbr/>-Engineering<wbr/>-Guide</i></a>), the malware defines a new <samp class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT</samp> structure (<samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>), which is a Windows structure used to store CPU state and related data for the process. This structure must be in place to store the debug register (DR0–DR3) data that the malware will check for shortly. Next, the malware specifies that the <samp class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT_DEBUG_REGISTERS</samp> should be the data that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp> returns. The malware then gets a handle to its current thread (<samp class="SANS_TheSansMonoCd_W5Regular_11">HANDLE</samp>) and calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp>, which will store the current thread’s <samp class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT_DEBUG_REGISTERS</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> structure. Finally, the malware sample inspects the debug registers for data. If these registers are nonzero, the check returns true, informing the malware that a hardware breakpoint has been set by the debugger.</p>&#13;
<p class="TX">The malware can then completely remove any hardware breakpoints it detects by using <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp> (or <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64SetThreadContext</samp> for 64-bit malware). Adding this line to the preceding code example will effectively clear the debug registers, subsequently removing the malware analyst’s hardware breakpoints:</p>&#13;
<pre class="pre-89"><code>context.Dr0 = null;&#13;
context.Dr1 = null;&#13;
context.Dr2 = null;&#13;
context.Dr3 = null;&#13;
&#13;
SetThreadContext(hThread, &amp;context);</code></pre>&#13;
<p class="TX">Finally, malware can detect memory breakpoints with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp> function. Setting a memory breakpoint alters the memory page, so if the malware invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp> on a suspect memory page, and if it returns an unexpected value such as <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_NOACCESS</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>, it might infer that a hardware breakpoint has been set on this memory page. Another option to achieve the same effect is for the malware to execute <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualQuery</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualQueryEx</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryVirtualMemory</samp>. We’ll discuss memory breakpoints more in the next section.</p>&#13;
<p class="TX">If you suspect that a malware sample is using any of the techniques described in this section, it’s helpful to hook (place a breakpoint on) these functions. Once a breakpoint is hit, you can simply modify the return value or <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> out the call to the function altogether. The debugger plug-in ScyllaHide, described on <span class="Xref"><a href="chapter10.xhtml#pg_181">page 181</a></span>, can also be useful here.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_177" aria-label="177"/>&#13;
<h4 class="H2" id="sec20"><span id="h-162"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Memory Page Guards for Breakpoint Detection</samp></h4>&#13;
<p class="TNI1"><i>Memory page guards</i> are a special flag implemented in Windows for memory access. When allocating new memory pages, a program can add the <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp> flag as a sort of alarm system for memory access. When this area of memory is accessed by the program (or by a different program), it raises a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_GUARD_PAGE_VIOLATION</samp> exception. If the program is running under a debugger, <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp> often behaves a bit differently (because the debugger is handling the exception) and won’t raise the normal exception.</p>&#13;
<p class="TX">Malware can take advantage of this by implementing page guards on certain memory pages. If these pages are accessed from outside a debugger (meaning that the malware isn’t being debugged), the malware will raise the exception as normal. If no exception is raised, depending on the debugger being used and its configuration, this could alert the malware that it’s being debugged. To set page guards in memory, malware can call <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp>) value set. The following code shows a malware sample calling <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> with this parameter set:</p>&#13;
<pre class="pre-90"><code><var>--snip--</var>&#13;
push 104h ; 0x100 (PAGE_GUARD) + 0x4 (READ/WRITE)&#13;
push edi&#13;
push esi&#13;
call VirtualAlloc&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">This code calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">flNewProtect</samp> value set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x104</samp>, which is a combination of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>) and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x4</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">READ/WRITE</samp>) protection. Memory allocation and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> are covered in more detail in <span class="Xref"><a href="part4.xhtml">Part IV</a></span>, particularly <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h-163"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Breakpoint Traps</samp></h4>&#13;
<p class="TNI1">Malware can insert breakpoint instructions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int 2d</samp> throughout its code in order to force the debugger to break often, causing a lot of trouble for the malware analysts debugging it. A constantly breaking debugger makes debugging a headache. Breakpoint instructions intentionally placed in malware are sometimes called <i>traps</i>.</p>&#13;
<p class="TX"><a href="chapter10.xhtml#fig10-4">Figure 10-4</a> shows a sample of the Dridex malware in x64dbg using the <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> trap technique.</p>&#13;
<figure class="IMG"><img class="img100" id="fig10-4" src="../images/fig10-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: A Dridex malware sample using a breakpoint anti-debug trap</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_178" aria-label="178"/>The Dridex code shown here executes two <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> instructions, increments <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>, executes two more <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> instructions, and then continues to loop. This function repeats 13,512 times (<samp class="SANS_TheSansMonoCd_W5Regular_11">cmp eax, 13512</samp>), which can cause major frustration for the malware analyst debugging the sample.</p>&#13;
<p class="TX">It’s often difficult to circumvent this trap technique in malware. The best approach is to identify the problematic instructions and patch them out. As in the case of this Dridex sample, the malware may create a loop (using <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>, and so on) of these breakpoint instructions, in which case you’d need to patch out or modify the loop instruction to bypass this behavior.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h3 class="H1" id="sec22"><span id="h-164"/><samp class="SANS_Futura_Std_Bold_B_11">Unhandled Exceptions</samp></h3>&#13;
<p class="TNI1">Malware can set a top-level exception handler (called an <i>unhandled exception filter</i>) to test for a debugger. This supersedes any other handlers, such as the default SEH, by first invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">SetUnhandledExceptionFilter</samp>, which allows the calling program to become the top-level exception handler, then invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">UnhandledExceptionFilter</samp>, which forces the exception handler to execute. When a malware program isn’t being debugged, the exception will be passed to the new handler. If it <i>is</i> being debugged, then the new handler won’t be called and the exception will be passed to the debugger, indicating to the malware that it’s running inside a debugger.</p>&#13;
<p class="TX">To deal with this technique, you can intercept calls to both <samp class="SANS_TheSansMonoCd_W5Regular_11">SetUnhandledExceptionFilter</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">UnhandledExceptionFilter</samp> (via breakpoints or hooks) and modify the function calls or patch them out of the code completely. <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> discusses exception handling in more detail.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h3 class="H1" id="sec23"><span id="h-165"/><samp class="SANS_Futura_Std_Bold_B_11">Checksums, Section Hashing, and Self-Healing</samp></h3>&#13;
<p class="TNI1">Malware can take a checksum (or hash) of its code to determine whether a breakpoint has been placed or an analyst has otherwise modified the code in the debugger. Using any hashing algorithm (MD5, for example), the malware author can create a hash of its code line by line or hash an entire section of code (typically called <i>section hashing</i>), then compare this with a baseline sum. If there’s a discrepancy, the malware may assume that a breakpoint has been set or its code has been otherwise modified.</p>&#13;
<p class="TX">Malware can also implement so-called <i>self-healing</i> techniques, in which it stores clean copies of its code and, if it detects code tampering, restores the original version. The following pseudocode demonstrates how this might look in practice:</p>&#13;
<pre class="pre-91"><code>// Calculate the checksum of the clean code.&#13;
clean_code_checksum = calculate_checksum(clean_code)&#13;
&#13;
// At runtime, recalculate the checksum and compare it to the stored value.&#13;
malware_code = read_malware_code()&#13;
malware_code_checksum = calculate_checksum(malware_code)&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_179" aria-label="179"/>// If checksums do not match, terminate the malware.&#13;
if malware_code_checksum != clean_code_checksum:&#13;
  terminate_malware()&#13;
else:&#13;
  // The code has not been tampered with! Continue running.</code></pre>&#13;
<p class="TX">There’s not much an analyst can do to circumvent this technique. The most effective method is to identify where the malware is obtaining a checksum of a certain segment of code and then patch this functionality out of its code. Hardware breakpoints can also be used in the event that the malware is using this approach to look for software breakpoints.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h3 class="H1" id="sec24"><span id="h-166"/><samp class="SANS_Futura_Std_Bold_B_11">Exploiting, Crashing, and Interfering with the Debugger</samp></h3>&#13;
<p class="TNI1">Sometimes the most effective anti-debugging method is to directly interfere with the debugger by causing it to crash or behave unpredictably. Just like any software, debuggers can have bugs in their code that allow the malware to interfere with analysis, crash the debugger, or possibly even crash the operating system itself. A popular example is a bug in version 1.1 of OllyDbg whereby malware could call the <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp> function and pass <samp class="SANS_TheSansMonoCd_W5Regular_11">%s</samp> as a parameter; OllyDbg would be unable to handle this value, causing the running malware sample to crash and preventing further debugging.</p>&#13;
<p class="TX">Perhaps slightly less offensive is the <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp> function, which malware can abuse to interfere with analysis tools. <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp> takes only one parameter: <samp class="SANS_TheSansMonoCd_W5Regular_11">fBlockIt</samp>. If this parameter is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, mouse and keyboard events to all applications will be blocked, which can seriously interfere with the debugging process. If malware detects that it is being manually inspected or running under a debugger, it may simply call <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp> as a self-defense mechanism. Luckily, you can easily get around this technique by using <small>CTRL</small>-<small>ALT</small>-<small>DELETE</small>, which will escape the <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp> routine. You can also modify the function call in a debugger, setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">fBlockIt</samp> parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.</p>&#13;
<p class="TX">Finally, malware can use <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp> to hide code execution from the debugger or to crash the debugger altogether. By passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadInformationClass</samp> value <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadHideFromDebugger</samp> (in hex, 0x11) to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp> function, the malware can covertly execute code, causing the malware analyst to lose control of the running sample. Additionally, if the malware executes a breakpoint instruction (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>) in the covertly executed code, the malware process will hang indefinitely in the debugger. I’ll discuss this technique in the context of covert code execution in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>.</p>&#13;
<p class="TX">These are only a few examples of known debugger exploitation techniques, and there are certainly more that are unknown. Malware analysts should be wary of these techniques and expect new ones to pop up when analyzing advanced evasive malware. Remember to always conduct analysis and debugging in a safe testing environment.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_180" aria-label="180"/>&#13;
<h3 class="H1" id="sec25"><span id="h-167"/><samp class="SANS_Futura_Std_Bold_B_11">Debug Blocking and Anti-attach Techniques</samp></h3>&#13;
<p class="TNI1">Instead of detecting a debugger or actively interfering with it, malware may simply try to prevent it from functioning altogether. This series of techniques is often called <i>debug blocking</i> or <i>anti-attach</i>.</p>&#13;
<p class="TX">To attach to a running malware sample, normally the debugger calls the Windows function <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>. In the event that the process is already being debugged, this function will fail. Malware can take advantage of this by simply acting as its own debugger. It can spawn a child process and set the parent process as the debugger. When attempting to attach a debugger to this child process, a malware analyst will be met with a frustrating <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PORT_ALREADY_SET</samp> exception, meaning that the process is already being debugged.</p>&#13;
<p class="TX">To overcome this technique, you can attach a debugger to the parent process and set a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">WaitForDebugEvent</samp>. When the breakpoint is hit, you can force the process (which is acting as the debugger) to unattach from its child process by invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcessStop</samp> function.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For more information on this technique, check out the research paper “The Art of Unpacking” by Mark Vincent Yason. The paper is old but still very relevant. Read it at</i> <a href="https://www.blackhat.com/presentations/bh-usa-07/Yason/Whitepaper/bh-usa-07-yason-WP.pdf">https://<wbr/>www<wbr/>.blackhat<wbr/>.com<wbr/>/presentations<wbr/>/bh<wbr/>-usa<wbr/>-07<wbr/>/Yason<wbr/>/Whitepaper<wbr/>/bh<wbr/>-usa<wbr/>-07<wbr/>-yason<wbr/>-WP<wbr/>.pdf</a>.</p>&#13;
<p class="TX">Malware can also modify common debugger functions to prevent debugging; the malware family GuLoader does exactly this. When attaching to a process, the debugger will invoke the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgBreakPoint</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgUiRemoteBreakin</samp>, which essentially allow the debugger to use breakpoints within the program being debugged. GuLoader modifies <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgBreakPoint</samp> by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> opcode and replacing it with <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> instructions, effectively impairing the function. Likewise, GuLoader modifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgUiRemoteBreakin</samp> function with an invalid call instruction, which will ultimately cause an exception, possibly resulting in a crash of the malware being debugged. <i>CrowdStrike</i> wrote an exceptional article on GuLoader; for more information on these techniques, read the paper at <a href="https://www.crowdstrike.com/blog/guloader-malware-analysis/"><i>https://<wbr/>www<wbr/>.crowdstrike<wbr/>.com<wbr/>/blog<wbr/>/guloader<wbr/>-malware<wbr/>-analysis<wbr/>/</i></a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h3 class="H1" id="sec26"><span id="h-168"/><samp class="SANS_Futura_Std_Bold_B_11">Other Anti-debugging Techniques</samp></h3>&#13;
<p class="TNI1">There are many more methods malware can use to discover or interfere with a debugger in use. And, of course, researchers and malware authors constantly identify new, creative ways to detect and circumvent debuggers. I’ve tried to cover as many commonly used or particularly interesting techniques as possible in this chapter.</p>&#13;
<p class="TX">Some methods I chose not to describe here because they’re uncommon or difficult to implement. For example, some malware families (rootkits, for instance) can directly inspect their <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> blocks for signs of an attached <span role="doc-pagebreak" epub:type="pagebreak" id="pg_181" aria-label="181"/>debugger, but this is quite rare. Other techniques are subject to error. For example, malware can check its debug privileges by attempting to call <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> with the target of a system process, such as <i>csrss.exe</i>. If the malware can get a handle to this process, it may infer that it’s being debugged, but it’s not always accurate. Another example is the use of the <i>trap flag</i>, a special flag in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EFLAGS</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RFLAGS</samp> registers that can give away the presence of a debugger. Both methods can produce false positives, are more difficult to implement, and thus are not as widely used.</p>&#13;
<p class="TX">To end this chapter, we’ll take a look at how to counter anti-debugging techniques that you encounter when reverse engineering.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h3 class="H1" id="sec27"><span id="h-169"/><samp class="SANS_Futura_Std_Bold_B_11">Countering Anti-debugging Techniques</samp></h3>&#13;
<p class="TNI1">In order to effectively bypass anti-debugging techniques, first you need to have an idea of what exactly you’re up against. You could identify the techniques a malware sample is employing simply by single-stepping through its code and manually searching for them, but of course, this isn’t very efficient. Typically, you’ll want to use a disassembler in combination with a debugger to better understand any anti-debugging methods you encounter.</p>&#13;
<p class="TX">Before digging into any malware, I always inspect the sample in a PE static analysis and triage tool such as PEStudio or PE-bear. These types of tools allow me to inspect imports and strings in the file that may help identify possible anti-debugging-related libraries and function calls. I also use tools like CAPA, which I described in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>.</p>&#13;
<p class="TX">Once I’ve identified anti-debugging techniques in the executable, I inspect the surrounding code with the help of a disassembler and decide how I’ll counter and bypass these techniques. This often involves setting breakpoints on suspect code and function calls in the debugger and modifying the code dynamically.</p>&#13;
<p class="TX">There are some great tools that can help automate the process of bypassing anti-debugging techniques. <i>ScyllaHide</i> (<a href="https://github.com/x64dbg/ScyllaHide"><i>https://<wbr/>github<wbr/>.com<wbr/>/x64dbg<wbr/>/ScyllaHide</i></a>), a plug-in for x64dbg and other debuggers, is perhaps the most popular. It can hide a debugger from malware by dynamically modifying the malware’s code and hooking suspect functions to bypass many debugger detection and anti-debugger techniques (as shown in <a href="chapter10.xhtml#fig10-5">Figure 10-5</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_182" aria-label="182"/>&#13;
<figure class="IMG"><img class="img100" id="fig10-5" src="../images/fig10-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: The ScyllaHide menu in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To enable an <i>anti-anti-debugging</i> feature in ScyllaHide, simply check the box next to the feature, then select <b>Apply</b> and <b>OK</b>. Mousing over each option will pop up more information about it. I often enable the entire left column of options, and this rarely causes problems. That said, while most of these options can be enabled safely, some of them may break the malware sample, possibly causing it to crash or behave in unexpected ways. So, use this with care.</p>&#13;
<p class="TX"><i>HyperHide</i> (<a href="https://github.com/Air14/HyperHide"><i>https://<wbr/>github<wbr/>.com<wbr/>/Air14<wbr/>/HyperHide</i></a>) provides many of the same features as ScyllaHide, but it’s always a good idea to have multiple tools in your toolbox. <a href="chapter10.xhtml#fig10-6">Figure 10-6</a> shows HyperHide’s anti-anti-debugging capabilities.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_183" aria-label="183"/>&#13;
<figure class="IMG"><img class="img100" id="fig10-6" src="../images/fig10-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: The HyperHide menu in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Both tools feature very similar anti-anti-debugging options, but one may work better than the other in certain circumstances. Try them both out and see which you prefer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h3 class="H1" id="sec28"><span id="h-170"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">This chapter discussed many common anti-debugging methods that malware might use to detect and circumvent debugging tools. Many of these techniques are widely used in all sorts of malware, from commodity <span role="doc-pagebreak" epub:type="pagebreak" id="pg_184" aria-label="184"/>infostealers to advanced bespoke and targeted threats, so it’s important to understand the concepts described here. In the next chapter, you’ll learn how malware can covertly execute code to evade dynamic analysis tools like debuggers and use misdirection techniques to disrupt the analysis process.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>