- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings in WebAssembly
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses how to handle strings in WAT because WebAssembly doesn’t
    have a built-in string data type as high-level languages do. To represent string
    data in WebAssembly, you must set linear memory to ASCII or Unicode character
    values. You need to know where you’re setting your data in linear memory and how
    many bytes the string will use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the ASCII and Unicode character formats before
    we explore the relationship between string objects and how to store them in linear
    memory. You’ll learn how JavaScript can retrieve the strings from linear memory
    and output them to the command line. Once you know how to pass string data from
    WebAssembly to JavaScript, we’ll cover two popular methods for string management:
    null-terminated strings and length-prefixed strings, discussing the pros and cons
    of each technique. You’ll learn how to copy a string from one location in linear
    memory to another using a byte-by-byte copy and a 64-bit copy. Then you’ll convert
    integer data into number strings in decimal, hexadecimal, and binary formats.'
  prefs: []
  type: TYPE_NORMAL
- en: ASCII and Unicode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with strings in WebAssembly, you need to know which character set
    you’re using, because different sets look different in linear memory. *American
    Standard Code for Information Interchange (ASCII)* is a 7-bit character encoding
    system that supports up to 128 characters with an 8th bit that might be used for
    error checking or is simply set to 0\. The ASCII character set works well if your
    code is only supporting the English language.
  prefs: []
  type: TYPE_NORMAL
- en: '*Unicode Transformation Format (UTF)* comes in 7-bit, 8-bit, 16-bit, and 32-bit
    flavors, which are called UTF-7, UTF-8, UTF-16, and UTF-32\. UTF-7 and ASCII are
    identical. UTF-8 incorporates UTF-7 and allows for some additional Latin, Middle
    Eastern, and Asian characters by creating a flexible length format that allows
    for additional bytes when the starting byte of the format falls outside of the
    ASCII character set. UTF-16 is also a flexible length character set where most
    characters take up two bytes. Because some codes expand the number of bytes a
    character uses to four, UTF-16 supports more than 1.1 million characters. UTF-32
    is a fixed 32-bit character set that supports more than 4 billion characters.
    In this book, we’ll work exclusively with the ASCII/UTF-7 character set because
    it’s simple to read and understand.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings in Linear Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only way to pass a string from WebAssembly to JavaScript is to create an
    array of character data inside a memory `buffer` object like we did in Chapter
    2 with the hello world app. You can then pass a 32-bit integer into JavaScript
    that represents the location of that character data in the memory buffer. The
    only problem with this scheme is that it doesn’t tell JavaScript where the data
    ends. The C language manages this by using a null-terminating byte: a byte with
    a value of 0 (not a character 0) tells the program that the string ends in the
    previous byte. We’ll look at three ways to pass strings between WAT and JavaScript,
    including null-termination, and then look at how to copy strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing the String Length to JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most obvious way to work with strings is to pass a string position and a
    string length to JavaScript so JavaScript can extract the string from linear memory
    and can know when it ends. Create a new WAT file named *strings.wat* and add the
    code in [Listing 5-1](#listing5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat(part 1 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: Passing strings from WebAssembly to JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: This module imports a JavaScript function we’ll create called `"str_pos_len"`
    1, which finds a string in the memory buffer using a combination of the string’s
    position and its location in linear memory. We also need to import a memory buffer
    we’ll declare in JavaScript 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define two strings in memory: `"Know the length of this string"` 3
    and `"Also know the length of this string"` 4. The two strings specify that we
    need to know the length of those strings because they’re just character arrays
    in linear memory and we need to indicate where they begin and end. The first string
    has 30 characters and the second has 35\. Later, in the `"main"` 5 function, we
    call `$str_pos_len` twice. The first time 6, we pass in the position of the first
    string in memory `(i32.const` `256)` followed by the length of that string `(i32.const
    30)`. This tells the JavaScript we’ll write in a moment to extract 30 bytes starting
    at memory position 256 into a string and display it to the console. The second
    time we call `$str_pos_len` 7, we pass in the position of the second string in
    memory `(i32.const 384)` followed by the length of that string `(i32.const` `35)`.
    The JavaScript then displays the second string to the console. Compile the WebAssembly
    module using the command in [Listing 5-2](#listing5-2).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: Compiling *strings.wat*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve compiled your WebAssembly module, create a JavaScript file named
    *strings.js* and enter the code in [Listing 5-3](#listing5-3).
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.js(part 1 of 3)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: JavaScript that calls the WebAssembly string function'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `importObject` we define `str_pos_len` 1, which takes the position
    of the string in memory and its length. It uses the position of the length to
    retrieve an array of bytes 2 of the length provided. We use a `TextDecoder` to
    convert that byte array into a string 3. Then we call `console.log` 4 to display
    the string. When you run the JavaScript, you should see the message in [Listing
    5-4](#listing5-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-4: String length output'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll discuss null-terminated strings, which is a method for tracking
    string length that languages such as C/C++ use.
  prefs: []
  type: TYPE_NORMAL
- en: Null-Terminated Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second method of passing strings is *null-terminated*(or *zero-terminated*)
    strings. Null-termination is a method for defining string length used by the C
    programming language. In a null-terminated string, you place a value of 0 as the
    last character in the array. The benefit of null-terminated strings is that you
    don’t have to know the string’s length as you’re using it. The downside is that
    this requires more computation when processing strings because your program needs
    to take the time to locate the terminating null byte. Let’s open the *strings.wat*
    file and add the code in [Listing 5-5](#listing5-5) for our null-terminated strings.
    First, we need to add an import of a `null_str` function that we’ll define later
    in the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat(part 2 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-5: Modifying *strings.wat* from [Listing 5-1](#listing5-1) to import
    the `null_str` function'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that unlike `str_pos_len` 1, the `null_str` 2 function only requires
    one `i32` parameter, because the code working with it only needs to know where
    the string begins in linear memory. It’s up to the code to figure out where that
    null byte is located to manipulate it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, between the `import` statement that defines the buffer and the `(data``)`
    expression that defines the earlier strings, in [Listing 5-6](#listing5-6) we
    add two more data expressions that define null-terminated strings.
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat(part 3 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-6: Modifying *strings.wat* from [Listing 5-1](#listing5-1) to add
    null-terminated string data'
  prefs: []
  type: TYPE_NORMAL
- en: The first data defines the string `"null terminating string\00"`1. Notice the
    last three characters `\00`. The `\` character is the escape character in WAT.
    If you follow an escape character with two hexadecimal digits, it defines a numeric
    byte with the value you specify. That means that `\00` represents a single byte
    with a value of `0`. The second data expression creates the string `"another null
    terminating string\00"` 2, which is also null-terminated and ending with `\00`.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 5-7](#listing5-7), we add two lines in the beginning of the `main`
    function to call the imported `$null_str` JavaScript function, passing it the
    location in linear memory of the null-terminated strings.
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat (part 4 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-7: Modifying *strings.wat* from [Listing 5-1](#listing5-1) to call
    the `null_str` function'
  prefs: []
  type: TYPE_NORMAL
- en: We pass in a value of `0` 1, which is the location in memory where we defined
    the string `"null terminating string\00"`. Then we pass in the value `128` 2,
    where we defined the string `"another null terminating string\00"`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve made those changes in your WAT file, open *strings.js* to add some
    more code. First, add a new function to the `env` object nested in `importObject`,
    as shown in [Listing 5-8](#listing5-8).
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.js (part 2 of 3)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-8: The `null_str` function added to `importObject` in *strings.js*
    from [Listing 5-3](#listing5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The code starts by defining the maximum possible length of the string in the
    variable `max_mem` 1. To find the string that’s null terminated, we decode a chunk
    of linear memory with the maximum string length into one long string, and then
    use JavaScript’s split function to get the null-terminated string. Inside the
    `env` object, we add another function called `null_str` 2 that takes a single
    `str_pos` parameter. JavaScript then needs to extract an array of bytes from the
    memory buffer starting at the position specified by the `str_pos` parameter passed
    into the function. We cannot search through the memory buffer until we convert
    it into a string. But before converting it to a string, we need to convert it
    into an array of bytes 3. Then we create a `TextDecoder` object to decode those
    bytes into one long string 4.
  prefs: []
  type: TYPE_NORMAL
- en: We split the string into an array using the null byte `"\0"` 5. Splitting on
    the null byte creates an array of strings that terminate in the null byte. Only
    the first item in the array is an actual string we defined. We’re using the split
    as a quick and dirty way to take the string out of linear memory. We then set
    `log_string` to the first string in the array. We call the JavaScript `console.log`
    function 6, passing it `log_string` to display that string to the console. Because
    we’re calling it with two different strings from WebAssembly, we should now have
    the four messages in [Listing 5-9](#listing5-9) logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-9: Output from null-terminating strings'
  prefs: []
  type: TYPE_NORMAL
- en: Length-Prefixed Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A third way to store a string in memory is to include the length of the string
    at the beginning of the string data. A string created with this method is called
    a *length-prefixed string* and can improve processing performance. The way we’re
    prefixing limits the strings to a maximum length of 255 because a single byte
    of data can only hold a number between 0 and 255.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by modifying the current *strings.wat* file, as shown in [Listing
    5-10](#listing5-10), to add a new import line for the `len_prefix` function we’ll
    define later in the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat (part 5 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-10: Modifying *strings.wat* from [Listing 5-1](#listing5-1) to add
    the `len_prefix` function import'
  prefs: []
  type: TYPE_NORMAL
- en: The `len_prefix` 1 function will take the first byte of the string to find the
    length.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add two new strings that begin with a hexadecimal number indicating
    their length. Add the code in [Listing 5-11](#listing5-11) to *strings.wat*.
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat (part 6 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-11: Modifying *strings.wat* from [Listing 5-1](#listing5-1) to add
    length-prefixed string data'
  prefs: []
  type: TYPE_NORMAL
- en: The first string, `"\16length-prefixed string"`, has 22 characters, so we prefix
    it with `\16` because 22 in decimal is 16 in hexadecimal 1. The second string,
    `"\1eanother length-prefixed string"`, is 30 characters long, so we prefix it
    with a hexadecimal `\1e` 2.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to add two calls to the imported `$len_prefix` function with the
    two memory locations where we just created the strings. The `"main"` function
    should now look like the code in [Listing 5-12](#listing5-12).
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat (part 7 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-12: Modifying *strings.wat* from [Listing 5-1](#listing5-1) to add
    calls to the `$len_prefix` function'
  prefs: []
  type: TYPE_NORMAL
- en: The first call to `$len_prefix` 1 passes it the location of the data string
    `"\16length-prefixed string"` at memory location `512`. The second call 2 passes
    the location of the second length-prefixed string `"\1eanother length-prefixed
    string"` at memory location `640`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can run this, we need to add a new function to our JavaScript `importObject`.
    Open *strings.js* and add the `len_prefix` function to the `importObject`, as
    shown in [Listing 5-13](#listing5-13).
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.js (part 3 of 3)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-13: Add the `len_prefix` function to `importObject` in *strings.js*
    from [Listing 5-3](#listing5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The new `len_prefix` 1 function takes in a string position and then takes the
    first byte from the position as a number in the constant `str_len` 2. It uses
    the value in `str_len` to copy the proper number of `bytes` 3 from linear memory
    so it can decode them into the `log_string` 4 it will log to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our WAT and JavaScript, we can compile the WAT module using
    `wat2wasm`, as shown in [Listing 5-14](#listing5-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-14: Compile *strings.wat*'
  prefs: []
  type: TYPE_NORMAL
- en: Then we can run our JavaScript file using `node`, as shown in [Listing 5-15](#listing5-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-15: Run *strings.js* using `node`'
  prefs: []
  type: TYPE_NORMAL
- en: You should see the output in [Listing 5-16](#listing5-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-16: Output from *strings.js*'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn how to copy strings using WAT.
  prefs: []
  type: TYPE_NORMAL
- en: Copying Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest way to copy a string from one location in linear memory to another
    is to loop over every byte of data, load it, and then store it in the new location.
    However, this method is slow. A more efficient method is to copy the strings eight
    bytes at a time using 64-bit integer loads and stores. Unfortunately, not all
    strings are multiples of eight bytes. To cover all cases as efficiently as possible,
    we’ll need a combination of a byte-by-byte copy and a faster 64-bit copy.
  prefs: []
  type: TYPE_NORMAL
- en: Byte-by-Byte Copy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll first write a function that does a slower byte-by-byte copy: it takes
    as parameters a source memory location, a destination memory location, and the
    length of the string we want to copy.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue to add code to our *strings.wat* file. In [Listing 5-17](#listing5-17),
    we add the function `$byte_copy` to the *strings.wat* file.
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat (part 8 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-17: A slow byte-by-byte method of copying strings added to *strings.wat*
    ([Listing 5-1](#listing5-1))'
  prefs: []
  type: TYPE_NORMAL
- en: This `$byte_copy` function copies the block of memory from `$source` 1 to `$source`
    + `$len` 2 into the memory location `$dest` 3 to `$dest` + `len` one byte at a
    time. This loop loads a byte from `$source` using the `(i32.load8_u``)` expression
    4. It then stores that byte in the `$dest` location using the `i32.store8` command
    5. Then we increment the destination location 6 in the `$dest` variable 7 and
    we increment the `$source` 8 variable to make those variables point to the next
    bytes in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 64-Bit Copy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Copying a string byte-by-byte is slower than it needs to be, whereas a 64-bit
    integer is eight bytes long, and copying eight bytes at a time is significantly
    faster than copying a single byte at a time. We’ll write another function similar
    to `$byte_copy` that copies the data significantly faster by doing it eight bytes
    at a time. Unfortunately, not all strings have lengths that are multiples of eight.
    If a string has a length of 43 characters, we can copy the first 40 bytes using
    five separate eight-byte copies, but for the last three bytes, we’ll need to go
    back to the byte-by-byte copy method.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that these byte copies don’t prevent out of bounds memory
    access. The code will attempt to copy data to or from somewhere it shouldn’t.
    However, if you try to access data outside the bounds of linear memory, the WebAssembly
    security model will cause the read or write to fail, halting the code’s execution.
    As stated earlier, these functions weren’t intended to be general purpose, but
    instead are for demonstrating the different ways you can copy strings.
  prefs: []
  type: TYPE_NORMAL
- en: Add the 64-bit copy function `$byte_copy_i64` in [Listing 5-18](#listing5-18)
    to your *strings.wat* file.
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat (part 9 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-18: A faster method of copying strings added to *strings.wat* ([Listing
    5-2](#listing5-2))'
  prefs: []
  type: TYPE_NORMAL
- en: The load and store functions are `(i64.load``)` and `(i64.store``)`1, which
    load and store 64 bits (8 bytes) at a time. This method runs four to five times
    faster than loading and storing a single byte at a time (on x64 architecture).
    The other significant difference is that `$dest` 2 and `$source` 3 are incremented
    by `8` instead of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Combination Copy Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned earlier, not all strings are multiples of eight. Therefore, we’ll
    define a new, improved function in [Listing 5-19](#listing5-19) that copies eight
    bytes at a time using the `$byte_copy_i64` function and then copies the remaining
    bytes using `$byte_copy`, which copies a single byte at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat (part 10 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-19: Copy eight bytes at a time when possible and a single byte at
    a time when not.'
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, the `$string_copy` function must combine the eight-byte and
    single-byte copy functions to copy the string as quickly as possible. The `$len`
    parameter is the entire length of the string in bytes. The local variable `$len_less_singles`
    1 is the number of bytes that can be copied with the 64-bit copy. We get this
    number by masking off the last three bits. The `$singles` variable is the remaining
    three bits that aren’t in the multiples of eight and is set by performing a bitwise
    `(i32.and``)` expression 2 (hurray for bit masking) between `$len` and `7` (binary
    111). The last three bits of the length indicate the number of remaining bytes
    if we used an eight-byte copy for the majority of the bytes. As an example, using
    an `i32.and` expression on the `$len` of `190` and `7` looks like [Figure 5-1](#figure5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](Images/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: Using binary AND to mask out all but the last three bits'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, calling `i32.and` passing the values 190 and 7 results in the
    binary 110, which is 6 in decimal. The `i32.and` expression sets all but the last
    three bits of our `$len` parameter to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the number of `$singles` isn’t zero 3, the code first copies the individual
    bytes that cannot be copied using the 64-bit copy. The `if` block sets `$len_less_singles`
    4 to `$len` - `$singles`: that is the number of bytes that must be copied individually.
    The local variable `$start_source_byte` 5 is set to `$source+$len_less_singles`,
    setting it to the starting byte of the byte-by-byte copy 7.'
  prefs: []
  type: TYPE_NORMAL
- en: Then the variable `$start_dest_byte` 6 is set to `$dest+$len_less_singles`,
    which sets it to the destination location for the byte-by-byte copy. The branch
    then calls `$byte_copy` to copy those remaining single bytes.
  prefs: []
  type: TYPE_NORMAL
- en: After the `if` block, the code must copy the bytes that it can with the 64-bit
    copy function `(call` `$byte_copy_i64)`a. We determine the number of bytes to
    copy with this function by using a bitwise `(i32.and``)` 9 expression of the length
    in `$len` with the 32-bit constant value `0xff_ff_ff_f8` 8. The value `0xff_ff_ff_f8`
    in binary is all 1s except the last three bits, which are set to 0\. Using the
    bitwise AND zeros out the last three bits of the length, which makes the length
    a multiple of eight.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a string copy function, let’s change the `main` function to
    test it. Change the `main` function so it contains only the code in [Listing 5-20](#listing5-20).
  prefs: []
  type: TYPE_NORMAL
- en: '**strings.wat (part 11 of 11)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-20: New version of the `main` function for *strings.wat* ([Listing
    5-2](#listing5-2))'
  prefs: []
  type: TYPE_NORMAL
- en: We removed the code that printed the null-terminated strings and the length-prefixed
    strings to the console. We keep the two lines that print the string at linear
    memory location `256` 1, `"Know the length of this string"`, and the string at
    memory location `384` 2, `"Also know the length of this string"`. Leaving these
    lines in will print the original value for the strings to the console before the
    copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `$string_copy` 3 copies 30 bytes from the first string to the second
    string. Then we print the second string location with the original string length.
    This will print `"Know the length of this stringtring"` 4 to the console, which
    looks wrong because it ends with the word `stringtring`. The reason the last word
    doesn’t end with `string` and has an additional five characters is that we needed
    to change the length to that of the string we copied from. If we’d been copying
    a null-terminated string or a length-prefixed string, this wouldn’t have been
    a problem, because the null-byte or prefix would keep track of the length for
    us: but in this case, we need to know that the new length is `30`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we call `$str_pos_len` passing in `384` as the index and `30` as the length
    5, it will properly print `"Know the length of this string"` to the console. We
    can recompile *strings.wat* using the command in [Listing 5-21](#listing5-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-21: Compiling *strings.wat*'
  prefs: []
  type: TYPE_NORMAL
- en: Run *strings.js* from the command line to see the output in [Listing 5-22](#listing5-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-22: Output from *strings.js* after adding a call to `$string_copy`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
