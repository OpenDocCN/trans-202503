<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="11" id="Page_11"/>2</span><br/>
<span class="ChapterTitle">Basic Commands and Directory Hierarchy</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This chapter is a guide to the Unix commands and utilities you’ll encounter throughout this book. This is preliminary material, and you may already know a substantial amount of it. Even if you think you’re up to speed, take a few moments to flip through the chapter just to make sure, especially when it comes to the directory hierarchy material in <span class="xref" itemid="xref_target_Section 2.19">Section 2.19</span>.</p>
<p>Why Unix commands? Isn’t this a book about how Linux works? It is, of course, but Linux is a Unix flavor at heart. You’ll see the word <em>Unix</em> in this chapter more than <em>Linux</em> because you can take what you learn straight over to BSD and other Unix-flavored systems. I’ve attempted to avoid covering too many Linux-specific user interface extensions, not only to give you a better background for using the other operating systems, but also because these extensions tend to be unstable. You’ll be able to adapt to new Linux <span epub:type="pagebreak" title="12" id="Page_12"/>releases much more quickly if you know the core commands. In addition, knowing these commands can boost your understanding of the kernel, as many correspond directly to system calls.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	For more details about Unix for beginners than you’ll find here, consider reading <span class="Regular">The Linux Command Line</span>, 2nd edition (No Starch Press, 2019), <span class="Regular">UNIX for the Impatient</span>, 2nd edition (Addison-Wesley Professional, 1995), and <span class="Regular">Learning the UNIX Operating System</span>, 5th edition (O’Reilly, 2001).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c02-0001">	2.1	The Bourne Shell: /bin/sh</h2>
<p class="BodyFirst">The shell is one of the most important parts of a Unix system. A <em>shell</em> is a program that runs commands, like the ones that users enter into a terminal window. These commands can be other programs or built-in features of the shell. The shell also serves as a small programming environment. Unix programmers often break common tasks into smaller components and use the shell to manage tasks and piece things together.</p>
<p>Many important parts of the system are actually <em>shell scripts</em>—text files that contain a sequence of shell commands. If you’ve worked with MS-DOS previously, you can think of shell scripts as very powerful <em>.BAT</em> files. Because they’re important, <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> is devoted entirely to shell scripts.</p>
<p>As you progress through this book and gain practice, you’ll add to your knowledge of manipulating commands using the shell. One of the best things about the shell is that if you make a mistake, you can easily see what you typed to find out what went wrong, and then try again.</p>
<p>There are many different Unix shells, but all derive features from the Bourne shell (<em>/bin/sh</em>), a standard shell developed at Bell Labs for early versions of Unix. Every Unix system needs a version of the Bourne shell in order to function correctly, as you will see throughout this book.</p>
<p>Linux uses an enhanced version of the Bourne shell called <code>bash</code> or the “Bourne-again” shell. The <code>bash</code> shell is the default shell on most Linux distributions, and <em>/bin/sh</em> is normally a link to <code>bash</code> on a Linux system. You should use the <code>bash</code> shell when running the examples in this book.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You may not have <var>bash</var> as your default shell if you’re using this chapter as a guide for a Unix account at an organization where you’re not the system administrator. You can change your shell with <var>chsh</var> or ask your system administrator for help.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c02-0002">	2.2	Using the Shell</h2>
<p class="BodyFirst">When you install Linux, you should create at least one regular user to be your personal account. For this chapter, you should log in as the regular user.</p>
<h3 id="h2-500402c02-0001"><span epub:type="pagebreak" title="13" id="Page_13"/>2.2.1	The Shell Window</h3>
<p class="BodyFirst">After logging in, open a shell window (often referred to as a <em>terminal</em>). The easiest way to do so from a GUI like Gnome or KDE is to open a terminal application, which starts a shell inside a new window. Once you’ve opened a shell, it should display a prompt at the top that usually ends with a dollar sign (<code>$</code>). On Ubuntu, that prompt should look like <var>name@host:path</var><code>$</code>, and on Fedora, it’s <code>[</code><var>name@host path</var><code>]$</code>, where <var>name</var> is your username, <var>host</var> is the name of your machine, and <var>path</var> is your current working directory (see <span class="xref" itemid="xref_target_Section 2.4.1">Section 2.4.1</span>). If you’re familiar with Windows, the shell window will look something like a DOS command prompt; in macOS the Terminal application is essentially the same as a Linux shell window.</p>
<p>This book contains many commands that you will type at a shell prompt. They all begin with a single <code>$</code> to denote the shell prompt. For example, type this command (just the part in bold, not the <code>$</code>) and press <span class="KeyCaps">enter</span>:</p>
<pre><code>$ <b>echo Hello there.</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Many shell commands in this book start with <var>#</var>. You should run these commands as the superuser (root), so they require extra caution. The best practice when running them is to use <var>sudo</var> in order to provide some protection and a log that you can look up later for possible errors. You’ll see how to do this in <span class="xref" itemid="xref_target_Section 2.20">Section 2.20</span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Now enter this command:</p>
<pre><code>$ <b>cat /etc/passwd</b></code></pre>
<p>This command displays the contents of the <em>/etc/passwd</em> system information file and then returns your shell prompt. Don’t worry about what <em>this</em> file does right now; you’ll learn all about it in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>
<p>Commands usually begin with a program to run and may be followed by <em>arguments</em> that tell the program what to operate on and how to do so. Here, the program is <code>cat</code>, and there is one argument, <code>/etc/passwd</code>. Many arguments are options that modify the default behavior of a program and typically begin with a dash (<code>-</code>). You’ll see this shortly in the discussion of <code>ls</code>. There are some exceptions that don’t follow this normal command structure, however, such as shell built-ins and the temporary use of environment variables.</p>
<h3 id="h2-500402c02-0002">2.2.2	cat</h3>
<p class="BodyFirst">The <code>cat</code> program is one of the easiest in Unix to understand; it simply outputs the contents of one or more files or another source of input. The general syntax of a <code>cat</code> command is as follows:</p>
<pre><code>$ <b>cat </b><var class="bold">file1</var><b> </b><var class="bold">file2</var><b> ...</b></code></pre>
<p><span epub:type="pagebreak" title="14" id="Page_14"/>When you run this command, <code>cat</code> prints the contents of <var>file1</var>, <var>file2</var>, and any other files that you specify as arguments (denoted by <code>...</code> in the preceding example), and then exits. The program is called <code>cat</code> because it performs concatenation when it prints the contents of more than one file. There are many ways to run <code>cat</code>; let’s use it to explore Unix I/O.</p>
<h3 id="h2-500402c02-0003">2.2.3	Standard Input and Standard Output</h3>
<p class="BodyFirst">Unix processes use I/O <em>streams</em> to read and write data. Processes read data from input streams and write data to output streams. Streams are very flexible. For example, the source of an input stream can be a file, a device, a terminal window, or even the output stream from another process.</p>
<p>To see an input stream at work, enter <code class="bold">cat</code> (with no arguments) and press <span class="KeyCaps">enter</span>. This time, you won’t get any immediate output, and you won’t get your shell prompt back because <code>cat</code> is still running. Now type anything and press <span class="KeyCaps">enter</span> at the end of each line. When used like this, the <code>cat</code> command repeats any line that you type. Once you’re sufficiently bored, press <span class="KeyCaps">ctrl</span>-D on an empty line to terminate <code>cat</code> and return to the shell prompt.</p>
<p>The reason <code>cat</code> adopts an interactive behavior here has to do with streams. When you don’t specify an input filename, <code>cat</code> reads from the <em>standard input</em> stream provided by the Linux kernel rather than a stream connected to a file. In this case, the standard input is connected to the terminal where you run <code>cat</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Pressing <span class="KeyCaps">ctrl</span>-D on an empty line stops the current standard input entry from the terminal with an EOF (end-of-file) message (and often terminates a program). Don’t confuse this with <span class="KeyCaps">ctrl</span>-C, which usually terminates a program regardless of its input or output.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><em>Standard output</em> is similar. The kernel gives each process a standard output stream where it can write its output. The <code>cat</code> command always writes its output to the standard output. When you ran <code>cat</code> in the terminal, the standard output was connected to that terminal, so that’s where you saw the output.</p>
<p>Standard input and output are often abbreviated as <em>stdin</em> and <em>stdout</em>. Many commands operate as <code>cat</code> does; if you don’t specify an input file, the command reads from stdin. Output is a little different. Some programs (like <code>cat</code>) send output only to stdout, but others have the option to send output directly to files.</p>
<p>There is a third standard I/O stream, called <em>standard error</em>. You’ll see it in <span class="xref" itemid="xref_target_Section 2.14.1">Section 2.14.1</span>.</p>
<p>One of the best features of standard streams is that you can easily manipulate them to read and write to places other than the terminal, as you’ll learn in <span class="xref" itemid="xref_target_Section 2.14">Section 2.14</span>. In particular, you’ll learn how to connect streams to files and other processes.</p>
<h2 id="h1-500402c02-0003"><span epub:type="pagebreak" title="15" id="Page_15"/>	2.3	Basic Commands</h2>
<p class="BodyFirst">Now let’s look at some more Unix commands. Most of the following programs take multiple arguments, and some have so many options and formats that an unabridged listing would be pointless. This is a simplified list of the basic commands; you don’t need all of the details just yet.</p>
<h3 id="h2-500402c02-0004">2.3.1	ls</h3>
<p class="BodyFirst">The <code>ls</code> command lists the contents of a directory. The default is the current directory, but you can add any directory or file as an argument, and there are many useful options. For example, use <code>ls -l</code> for a detailed (long) listing and <code>ls -F</code> to display file type information. Here is a sample long listing; it includes the owner of the file (column 3), the group (column 4), the file size (column 5), and the modification date/time (between column 5 and the filename):</p>
<pre><code>$ <b>ls -l</b>
total 3616
-rw-r--r-- 1 juser users 3804    May 28 10:40  abusive.c
-rw-r--r-- 1 juser users 4165    Aug 13 10:01  battery.zip
-rw-r--r-- 1 juser users 131219  Aug 13 10:33  beav_1.40-13.tar.gz
-rw-r--r-- 1 juser users 6255    May 20 14:34  country.c
drwxr-xr-x 2 juser users 4096    Jul 17 20:00  cs335
-rwxr-xr-x 1 juser users 7108    Jun 16 13:05  dhry
-rw-r--r-- 1 juser users 11309   Aug 13 10:26  dhry.c
-rw-r--r-- 1 juser users 56      Jul  9 15:30  doit
drwxr-xr-x 6 juser users 4096    Feb 20 13:51  dw
drwxr-xr-x 3 juser users 4096    Jul  1 16:05  hough-stuff</code></pre>
<p>You’ll learn more about column 1 of this output in <span class="xref" itemid="xref_target_Section 2.17">Section 2.17</span>. You can ignore column 2 for now; it’s the number of hard links to the file and is explained in <span class="xref" itemid="xref_target_Section 4.6">Section 4.6</span>.</p>
<h3 id="h2-500402c02-0005">2.3.2	cp</h3>
<p class="BodyFirst">In its simplest form, <code>cp</code> copies files. For example, to copy <var>file1</var> to <var>file2</var>, enter this:</p>
<pre><code>$ <b>cp </b><var class="bold">file1</var><b> </b><var class="bold">file2</var></code></pre>
<p>You can also copy a file to another directory, keeping the same file name in that directory:</p>
<pre><code>$ <b>cp </b><var class="bold">file</var><b> </b><var class="bold">dir</var></code></pre>
<p>To copy more than one file to a directory (folder) named <var>dir</var>, try something like this example, which copies three files:</p>
<pre><code>$ <b>cp <var class="bold">file1</var> <var class="bold">file2</var> <var class="bold">file3</var></b><b> </b><var class="bold">dir</var></code></pre>
<h3 id="h2-500402c02-0006"><span epub:type="pagebreak" title="16" id="Page_16"/>2.3.3	mv</h3>
<p class="BodyFirst">The <code>mv</code> (move) command works much like <code>cp</code>. In its simplest form, it renames a file. For example, to rename <var>file1</var> to <var>file2</var>, enter this:</p>
<pre><code>$ <b>mv </b><var class="bold">file1</var><b> </b><var class="bold">file2</var></code></pre>
<p>You can also use <code>mv</code> to move files to other directories in the same way as <code>cp</code>.</p>
<h3 id="h2-500402c02-0007">2.3.4	touch</h3>
<p class="BodyFirst">The <code>touch</code> command can create a file. If the target file already exists, <code>touch</code> doesn’t change the file, but it does update the file’s modification timestamp. For example, to create an empty file, enter this:</p>
<pre><code>$ <b>touch </b><var class="bold">file</var></code></pre>
<p>Then run <code class="bold">ls -l</code> on that file. You should see output like the following, where the date and time indicate when you ran <code>touch</code>:</p>
<pre><code>$ <b>ls -l </b><var class="bold">file</var>
-rw-r--r-- 1 juser users 0  May 21 18:32  <var>file</var></code></pre>
<p>To see a timestamp update, wait at least a minute and then run the same <code>touch</code> command again. The timestamp returned by <code>ls -l</code> will update.</p>
<h3 id="h2-500402c02-0008">2.3.5	rm</h3>
<p class="BodyFirst">The <code>rm</code> command deletes (removes) a file. After you remove a file, it’s usually gone from your system and generally cannot be undeleted unless you restore it from a backup.</p>
<pre><code>$ <b>rm </b><var class="bold">file</var></code></pre>
<h3 id="h2-500402c02-0009">2.3.6	echo</h3>
<p class="BodyFirst">The <code>echo</code> command prints its arguments to the standard output:</p>
<pre><code>$ <b>echo Hello again.</b>
Hello again.</code></pre>
<p>The <code>echo</code> command is very useful for finding expansions of shell globs (“wildcards” such as <code>*</code>) and variables (such as <code>$HOME</code>), which you will encounter later in this chapter.</p>
<h2 id="h1-500402c02-0004">	2.4	Navigating Directories</h2>
<p class="BodyFirst">The Unix directory hierarchy starts at <em>/</em>, also called the <em>root directory</em>. The directory separator is the slash (<em>/</em>), <em>not</em> the backslash (\). There are several <span epub:type="pagebreak" title="17" id="Page_17"/>standard subdirectories in the root directory, such as <em>/usr</em>, as you’ll learn in <span class="xref" itemid="xref_target_Section 2.19">Section 2.19</span>.</p>
<p>When you refer to a file or directory, you specify a <em>path</em> or <em>pathname</em>. When a path starts with <em>/</em> (such as <em>/usr/lib</em>), it’s a <em>full</em> or <em>absolute</em> path.</p>
<p>A path component identified by two dots (<em>..</em>) specifies the parent of a directory. For example, if you’re working in <em>/usr/lib</em>, the path <em>..</em> would refer to <em>/usr</em>. Similarly, <em>../bin</em> would refer to <em>/usr/bin</em>.</p>
<p>One dot (<em>.</em>) refers to the current directory; for example, if you’re in <em>/usr/lib</em>, the path . is still <em>/usr/lib</em>, and <em>./X11</em> is <em>/usr/lib/X11</em>. You won’t have to use <em>.</em> very often because most commands default to the current directory if a path doesn’t start with <em>/</em> (so you could just use <em>X11</em> instead of <em>./X11</em> in the preceding example).</p>
<p>A path not beginning with <em>/</em> is called a <em>relative path</em>. Most of the time, you’ll work with relative pathnames, because you’ll already be in or near the directory you need.</p>
<p>Now that you have a sense of the basic directory mechanics, here are some essential directory commands.</p>
<h3 id="h2-500402c02-0010">2.4.1	cd</h3>
<p class="BodyFirst">The <em>current working directory</em> is the directory that a process (such as the shell) is currently in. In addition to the default shell prompt in most Linux distributions, you can see your current directory with the <code>pwd</code> command, described in <span class="xref" itemid="xref_target_Section 2.5.3">Section 2.5.3</span>.</p>
<p>Each process can independently set its own current working directory. The <code>cd</code> command changes the shell’s current working directory:</p>
<pre><code>$ <b>cd </b><var class="bold">dir</var></code></pre>
<p>If you omit <var>dir</var>, the shell returns to your <em>home directory</em>, the directory where you started when you first logged in. Some programs abbreviate your home directory with the <code>~</code> symbol (a <em>tilde</em>).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The <var>cd</var> command is a shell built-in. It wouldn’t work as a separate program because if it were to run as a subprocess, it could not (normally) change its parent’s current working directory. This may not seem a particularly important distinction at the moment, but there are times when knowing this fact can clear up confusion.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c02-0011">2.4.2	mkdir</h3>
<p class="BodyFirst">The <code>mkdir</code> command creates a new directory <var>dir</var>:</p>
<pre><code>$ <b>mkdir </b><var class="bold">dir</var></code></pre>
<h3 id="h2-500402c02-0012">2.4.3	rmdir</h3>
<p class="BodyFirst">The <code>rmdir</code> command removes the directory <var>dir</var>:</p>
<pre><code>$ <b>rmdir </b><var class="bold">dir</var></code></pre>
<p><span epub:type="pagebreak" title="18" id="Page_18"/>If <var>dir</var> isn’t empty, this command fails. However, if you’re impatient, you probably don’t want to laboriously delete all the files and subdirectories inside <var>dir</var> first. You can use <code>rm -r</code><var> dir</var> to delete a directory and its contents, but be careful! This is one of the few commands that can do serious damage, especially if you run it as the superuser. The <code>-r</code> option specifies <em>recursive delete</em> to repeatedly delete everything inside <var>dir</var>. Don’t use the <code>-r</code> flag with globs such as a star (<code>*</code>). And above all, always double-check your command before you run it.</p>
<h3 id="h2-500402c02-0013">2.4.4	Shell Globbing (“Wildcards”)</h3>
<p class="BodyFirst">The shell can match simple patterns to file and directory names, a process known as <em>globbing</em>. This is similar to the concept of wildcards in other systems. The simplest of these is the glob character <code>*</code>, which tells the shell to match any number of arbitrary characters. For example, the following command prints a list of files in the current directory:</p>
<pre><code>$ <b>echo *</b></code></pre>
<p>The shell matches arguments containing globs to filenames, substitutes the filenames for those arguments, and then runs the revised command line. The substitution is called <em>expansion</em> because the shell substitutes all matching filenames for a simplified expression. Here are some ways to use <code>*</code> to expand filenames:</p>
<ul>
<li><code>at*</code> expands to all filenames that start with <code>at</code>.</li>
<li><code>*at</code> expands to all filenames that end with <code>at</code>.</li>
<li><code>*at*</code> expands to all filenames that contain <code>at</code>.</li>
</ul>
<p>If no files match a glob, the <code>bash</code> shell performs no expansion, and the command runs with literal characters such as <code>*.</code> For example, try a command such as <code>echo *dfkdsafh</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you’re used to the Windows command prompt, you might instinctively type <code>*.*</code> to match all files. Break this habit now. In Linux and other versions of Unix, you must use <code>*</code> to match all files. In the Unix shell, <code>*.*</code> matches only files and directories that contain the dot (<code>.</code>) character in their names. Unix filenames do not need extensions and often do not carry them.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Another shell glob character, the question mark (<code>?</code>), instructs the shell to match exactly one arbitrary character. For example, <code>b?at</code> matches <code>boat</code> and <code>brat</code>.</p>
<p>If you don’t want the shell to expand a glob in a command, enclose the glob in single quotes (<code>''</code>). For example, the command <code>echo '*'</code> prints a star. You will find this handy for a few of the commands described in the next <span epub:type="pagebreak" title="19" id="Page_19"/>section, such as <code>grep</code> and <code>find</code>. (You’ll learn more much about quoting in <span class="xref" itemid="xref_target_Section 11.2">Section 11.2</span>.)</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	It is important to remember that the shell performs expansions <span class="Regular">before</span> running commands, and <span class="Regular">only</span> then. Therefore, if a <var>*</var> makes it to a command without expanding, the shell won’t do anything more with it; it’s up to the command to decide what it wants to do.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>There is more to the shell’s pattern-matching capabilities, but <code>*</code> and <code>?</code> are what you need to know now. <span class="xref" itemid="xref_target_Section 2.7">Section 2.7</span> describes glob behavior with those funny files that start with a dot.</p>
<h2 id="h1-500402c02-0005">	2.5	Intermediate Commands</h2>
<p class="BodyFirst">This section describes the most essential intermediate Unix commands.</p>
<h3 id="h2-500402c02-0014">2.5.1	grep</h3>
<p class="BodyFirst">The <code>grep</code> command prints the lines from a file or input stream that match an expression. For example, to print the lines in the<em> /etc/passwd </em>file that contain the text <code>root</code>, enter this:</p>
<pre><code>$ <b>grep root /etc/passwd</b></code></pre>
<p>The <code>grep</code> command is extraordinarily handy when operating on multiple files at once because it prints the filename in addition to the matching line. For example, if you want to check every file in <em>/etc</em> that contains the word <code>root</code>, you could use this command:</p>
<pre><code>$ <b>grep root /etc/*</b></code></pre>
<p>Two of the most important <code>grep</code> options are <code>-i</code> (for case-insensitive matches) and <code>-v</code> (which inverts the search—that is, prints all lines that <em>don’t</em> match). There is also a more powerful variant called <code>egrep</code> (which is just a synonym for <code>grep -E</code>).</p>
<p><code>grep</code> understands <em>regular expressions</em>, patterns that are grounded in computer science theory and are very common in Unix utilities. Regular expressions are more powerful than wildcard-style patterns, and they have a different syntax. There are three important things to remember about regular expressions:</p>
<ul>
<li><code>.*</code> matches any number of characters, including none (like the <code>*</code> in globs and wildcards).</li>
<li><code>.+</code> matches any one or more characters.</li>
<li><code>.</code> matches exactly one arbitrary character.</li>
</ul>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="20" id="Page_20"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	The grep(1) manual page contains a detailed description of regular expressions, but it can be somewhat difficult to read. To learn more, you can read <span class="Regular">Mastering Regular Expressions</span>, 3rd edition, by Jeffrey E. F. Friedl (O’Reilly, 2006), or see the regular expressions chapter of <span class="Regular">Programming Perl</span>, 4th edition, by Tom Christensen et al. (O’Reilly, 2012). If you like math and are interested in where regular expressions come from, look up <span class="Regular">Introduction to Automata Theory, Languages, and Computation</span>, 3rd edition, by Jeffrey Ullman and John Hopcroft (Prentice Hall, 2006).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c02-0015">2.5.2	less</h3>
<p class="BodyFirst">The <code>less</code> command comes in handy when a file is really big or when a command’s output is long and scrolls off the top of the screen.</p>
<p>To page through a big file like <em>/usr/share/dict/words</em>, you can use the command <code>less</code> <code>/usr/share/dict/words</code>. When running <code>less</code>, you’ll see the contents of the file one screenful at a time. Press the spacebar to go forward in the file and press b (lowercase) to skip back one screenful. To quit, press q.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The <var>less</var> command is an enhanced version of an older program named <var>more</var>. Linux desktops and servers have <var>less</var>, but it’s not standard on many embedded systems and other Unix systems. If you ever run into a situation when you can’t use <var>less</var>, try <var>more</var>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You can also search for text inside <code>less</code>. For example, to search forward for a word, you can type <code>/</code><var>word</var>, and to search backward, you can use <code>?</code><var>word</var>. When you find a match, press n to continue searching.</p>
<p>As you’ll learn in <span class="xref" itemid="xref_target_Section 2.14">Section 2.14</span>, you can send the standard output of nearly any program directly to another program’s standard input. This is exceptionally useful when you have a command with a lot of output to sift through and you’d like to use something like <code>less</code> to view the output. Here’s an example of sending the output of a <code>grep</code> command to <code>less</code>:</p>
<pre><code>$ <b>grep ie /usr/share/dict/words | less</b></code></pre>
<p>Try this command out for yourself. You’ll probably find many similar uses for <code>less</code>.</p>
<h3 id="h2-500402c02-0016">2.5.3	pwd</h3>
<p class="BodyFirst">The <code>pwd</code> (print working directory) program simply outputs the name of the current working directory. You may be wondering why you need this when most Linux distributions set up user accounts with the current working directory in the prompt. There are two reasons.</p>
<p>First, not all prompts include the current working directory, especially because you may want to get rid of it in your own prompt because it takes up a lot of space. If you do so, you need <code>pwd</code>.</p>
<p>Second, the symbolic links that you’ll learn about in <span class="xref" itemid="xref_target_Section 2.17.2">Section 2.17.2</span> can sometimes obscure the true full path of the current working directory. Use <code>pwd -P</code> to eliminate this confusion.</p>
<h3 id="h2-500402c02-0017"><span epub:type="pagebreak" title="21" id="Page_21"/>2.5.4	diff</h3>
<p class="BodyFirst">To see the differences between two text files, use <code>diff</code>:</p>
<pre><code>$ <b>diff </b><var class="bold">file1</var><b> </b><var class="bold">file2</var></code></pre>
<p>Several options can control the format of the output, and the default output format is often the most comprehensible for human beings. However, most programmers prefer the output from <code>diff -u</code> when they need to send the output to someone else, because automated tools have an easier time with this format.</p>
<h3 id="h2-500402c02-0018">2.5.5	file</h3>
<p class="BodyFirst">If you see a file and are unsure of its format, try using the <code>file</code> command to see if the system can guess it:</p>
<pre><code>$ <b>file </b><var class="bold">file</var></code></pre>
<p>You may be surprised by how much this innocent-looking command can do.</p>
<h3 id="h2-500402c02-0019">2.5.6	find and locate</h3>
<p class="BodyFirst">It’s frustrating when you know that a certain file is in a directory tree somewhere but you just don’t know where. Run <code>find</code> to find <var>file</var> in <var>dir</var> as follows:</p>
<pre><code>$ <b>find </b><var class="bold">dir</var><b> -name </b><var class="bold">file</var><b> -print</b></code></pre>
<p>Like most programs in this section, <code>find</code> is capable of some fancy stuff. However, don’t try options such as <code>-exec</code> before you know the form shown here by heart and understand why you need the <code>-name</code> and <code>-print</code> options. The <code>find</code> command accepts special pattern-matching characters such as <code>*</code>, but you must enclose them in single quotes (<code>'*'</code>) to protect the special characters from the shell’s own globbing feature. (Recall from <span class="xref" itemid="xref_target_Section 2.4.4">Section 2.4.4</span> that the shell expands globs <em>before</em> running commands.)</p>
<p>Most systems also have a <code>locate</code> command for finding files. Rather than searching for a file in real time, <code>locate</code> searches an index that the system builds periodically. Searching with <code>locate</code> is much faster than <code>find</code>, but if the file you’re looking for is newer than the index, <code>locate</code> won’t find it.</p>
<h3 id="h2-500402c02-0020">2.5.7	head and tail</h3>
<p class="BodyFirst">The <code>head</code> and <code>tail</code> commands allow you to quickly view a portion of a file or stream of data. For example, <code>head /etc/passwd</code> shows the first 10 lines of the password file, and <code>tail /etc/passwd</code> shows the last 10 lines.</p>
<p>To change the number of lines to display, use the <var>-n</var> option, where <var>n</var> is the number of lines you want to see (for example, <code>head -5 /etc/passwd</code>). To print lines starting at line <var>n</var>, use <code>tail +</code><var>n</var>.</p>
<h3 id="h2-500402c02-0021"><span epub:type="pagebreak" title="22" id="Page_22"/>2.5.8	sort</h3>
<p class="BodyFirst">The <code>sort</code> command quickly puts the lines of a text file in alphanumeric order. If the file’s lines start with numbers and you want to sort in numerical order, use the <code>-n</code> option. The <code>-r</code> option reverses the order of the sort.</p>
<h2 id="h1-500402c02-0006">	2.6	Changing Your Password and Shell</h2>
<p class="BodyFirst">Use the <code>passwd</code> command to change your password. You’ll be asked for your old password and then prompted for your new password twice.</p>
<p>The best passwords tend to be long “nonsense” sentences that are easy to remember. The longer the password (in terms of character length), the better; try for 16 characters or more. (In the very old days, the number of characters you could use was limited, so you were advised to add strange characters and such.)</p>
<p>You can change your shell with the <code>chsh</code> command (to an alternative such as <code>zsh</code>, <code>ksh</code> or <code>tcsh</code>), but keep in mind that this book assumes you’re running <code>bash</code>, so if you make a change, some of the examples may not work.</p>
<h2 id="h1-500402c02-0007">	2.7	Dot Files</h2>
<p class="BodyFirst">Change to your home directory if you’re not already there, type <code>ls</code> to take a look around, and then run <code>ls -a</code>. Do you see the difference in the output? When you run <code>ls</code> without the <code>-a</code>, you won’t see the configuration files called <em>dot files</em>. These are files and directories whose names begin with a dot (<code>.</code>). Common dot files are <em>.bashrc</em> and <em>.login</em>, and there are dot directories, too, such as <em>.ssh</em>.</p>
<p>There’s nothing special about dot files or directories. Some programs don’t show them by default so that you won’t see a complete mess when listing the contents of your home directory. For example, <code>ls</code> doesn’t list dot files unless you use the <code>-a</code> option. In addition, shell globs don’t match dot files unless you explicitly use a pattern such as <code>.*</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You can run into problems with globs because <var>.*</var> matches <var>.</var> and <var>..</var> (the current and parent directories). You may wish to use a pattern such as <var>.[^.]*</var> or <var>.??*</var> to get all dot files <span class="Regular">except</span> the current and parent directories.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c02-0008">	2.8	Environment and Shell Variables</h2>
<p class="BodyFirst">The shell can store temporary variables, called <em>shell variables</em>, containing the values of text strings. Shell variables are very useful for keeping track of values in scripts, and some shell variables control the way the shell behaves. (For example, the <code>bash</code> shell reads the <code>PS1</code> variable before displaying the prompt.)</p>
<p><span epub:type="pagebreak" title="23" id="Page_23"/>To assign a value to a shell variable, use the equal sign (<code>=</code>). Here’s a simple example:</p>
<pre><code>$ <b>STUFF=blah</b></code></pre>
<p>The preceding example sets the value of the variable named <code>STUFF</code> to <code>blah</code>. To access this variable, use <code>$STUFF</code> (for example, try running <code>echo $STUFF</code>). You’ll learn about the many uses of shell variables in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Don’t put any spaces around the <var>=</var> when assigning a variable.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>An <em>environment variable</em> is like a shell variable, but it’s not specific to the shell. All processes on Unix systems have environment variable storage. The main difference between environment and shell variables is that the operating system passes all of your shell’s environment variables to programs that the shell runs, whereas shell variables cannot be accessed in the commands that you run.</p>
<p>You assign an environment variable with the shell’s <code>export</code> command. For example, if you’d like to make the <code>$STUFF</code> shell variable into an environment variable, use the following:</p>
<pre><code>$ <b>STUFF=blah</b>
$ <b>export STUFF</b></code></pre>
<p>Because child processes inherit environment variables from their parent, many programs read them for configuration and options. For example, you can put your favorite <code>less</code> command-line options in the <code>LESS</code> environment variable, and <code>less</code> will use those options when you run it. (Many manual pages contain a section labeled ENVIRONMENT that describes these variables.)</p>
<h2 id="h1-500402c02-0009">	2.9	The Command Path</h2>
<p class="BodyFirst"><code>PATH</code> is a special environment variable that contains the <em>command path</em> (or <em>path</em> for short), a list of system directories that the shell searches when trying to locate a command. For example, when you run <code>ls</code>, the shell searches the directories listed in <code>PATH</code> for the <code>ls</code> program. If programs with the same name appear in several directories in the path, the shell runs the first matching program.</p>
<p>If you run <code>echo $PATH</code>, you’ll see that the path components are separated by colons (<code>:</code>). For example:</p>
<pre><code>$ <b>echo $PATH</b>
/usr/local/bin:/usr/bin:/bin</code></pre>
<p><span epub:type="pagebreak" title="24" id="Page_24"/>To tell the shell to look in more places for programs, change the <code>PATH</code> environment variable. For example, by using this command, you can add a directory <var>dir</var> to the beginning of the path so that the shell looks in <var>dir</var> before looking in any of the other <code>PATH</code> directories:</p>
<pre><code>$ <b>PATH=</b><var class="bold">dir</var><b>:$PATH</b></code></pre>
<p>Or you can append a directory name to the end of the <code>PATH</code> variable, causing the shell to look in <var>dir</var> last:</p>
<pre><code>$ <b>PATH=$PATH:</b><var class="bold">dir</var></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You can accidentally wipe out your entire path if you mistype <var>$PATH</var> when modifying your path. If this happens, don’t panic! The damage isn’t permanent; you can just start a new shell. (For a lasting effect, you need to mistype it when editing a certain configuration file, and even then it isn’t difficult to rectify.) The easiest way to return to normal is to close the current terminal window and start another.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c02-0010">	2.10	Special Characters</h2>
<p class="BodyFirst">When discussing Linux with others, you should know a few names for some of the special characters that you’ll encounter. If you’re amused by this sort of thing, see the “Jargon File” (<em>http://www.catb.org/jargon/html/</em>) or its printed companion, <em>The New Hacker’s Dictionary</em>, 3rd edition, by Eric S. Raymond (MIT Press, 1996).</p>
<p><a href="#table2-1" id="tableanchor2-1">Table 2-1</a> describes a select set of the special characters, many of which you’ve already seen in this chapter. Some utilities, such as the Perl programming language, use almost all of these special characters! (Keep in mind that these are the American names for the characters.)</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-1">Table 2-1</a>: Special Characters</p></figcaption>
<table id="table-500402c02-0001" border="1">
<thead>
<tr>
<td><b>Character</b></td><td><b>Name(s)</b></td><td><b>Uses</b></td></tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td><td>star, asterisk</td><td>Regular expression, glob character</td></tr>
<tr>
<td><code>.</code></td><td>dot</td><td>Current directory, file/hostname delimiter</td></tr>
<tr>
<td><code>!</code></td><td>bang</td><td>Negation, command history</td></tr>
<tr>
<td><code>|</code></td><td>pipe</td><td>Command pipes</td></tr>
<tr>
<td><code>/</code></td><td>(forward) slash</td><td>Directory delimiter, search command</td></tr>
<tr>
<td><code>\</code></td><td>backslash</td><td>Literals, macros (<em>never</em> directories)</td></tr>
<tr>
<td><code>$</code></td><td>dollar</td><td>Variables, end of line</td></tr>
<tr>
<td><code>'</code></td><td>tick, (single) quote</td><td>Literal strings</td></tr>
<tr>
<td><code>`</code></td><td>backtick, backquote</td><td>Command substitution</td></tr>
<tr>
<td><code>"</code></td><td>double quote</td><td>Semi-literal strings</td></tr>
<tr>
<td><code>^</code></td><td>caret</td><td>Negation, beginning of line</td></tr>
<tr>
<td><code><span epub:type="pagebreak" title="25" id="Page_25"/>~</code></td><td>tilde, squiggle</td><td>Negation, directory shortcut</td></tr>
<tr>
<td><code>#</code></td><td>hash, sharp, pound</td><td>Comments, preprocessor, substitutions</td></tr>
<tr>
<td><code>[ ]</code></td><td>(square) brackets</td><td>Ranges</td></tr>
<tr>
<td><code>{ }</code></td><td>braces, (curly) brackets</td><td>Statement blocks, ranges</td></tr>
<tr>
<td><code>_</code></td><td>underscore, under</td><td>Cheap substitute for a space used when spaces aren’t wanted or allowed, or when autocomplete algorithms get confused</td></tr>
</tbody>
</table>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You will often see control characters marked with a caret; for example, ^C for <span class="KeyCaps">ctrl</span>-C.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c02-0011">	2.11	Command-Line Editing</h2>
<p class="BodyFirst">As you play with the shell, notice that you can edit the command line using the left and right arrow keys, as well as page through previous commands using the up and down arrows. This is standard on most Linux systems.</p>
<p>However, it’s a good idea to forget about the arrow keys and use control key combinations instead. If you learn the ones listed in <a href="#table2-2" id="tableanchor2-2">Table 2-2</a>, you’ll find that you’re better able to enter text in the many Unix programs that use these standard keystrokes.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-2">Table 2-2</a>: Command-Line Keystrokes</p></figcaption>
<table id="table-500402c02-0002" border="1">
<thead>
<tr>
<td><b>Keystroke</b></td><td><b>Action</b></td></tr>
</thead>
<tbody>
<tr>
<td><span class="KeyCaps">ctrl</span>-B</td><td>Move the cursor left</td></tr>
<tr>
<td><span class="KeyCaps">ctrl</span>-F</td><td>Move the cursor right</td></tr>
<tr>
<td><span class="KeyCaps">ctrl</span>-P</td><td>View the previous command (or move the cursor up)</td></tr>
<tr>
<td><span class="KeyCaps">ctrl</span>-N</td><td>View the next command (or move the cursor down)</td></tr>
<tr>
<td><span class="KeyCaps">ctrl</span>-A</td><td>Move the cursor to the beginning of the line</td></tr>
<tr>
<td><span class="KeyCaps">ctrl</span>-E</td><td>Move the cursor to the end of the line</td></tr>
<tr>
<td><span class="KeyCaps">ctrl</span>-W</td><td>Erase the preceding word</td></tr>
<tr>
<td><span class="KeyCaps">ctrl</span>-U</td><td>Erase from cursor to beginning of line</td></tr>
<tr>
<td><span class="KeyCaps">ctrl</span>-K</td><td>Erase from cursor to end of line</td></tr>
<tr>
<td><span class="KeyCaps">ctrl</span>-Y</td><td>Paste erased text (for example, from <span class="KeyCaps">ctrl</span>-U)</td></tr>
</tbody>
</table>
</figure>
<h2 id="h1-500402c02-0012">	2.12	Text Editors</h2>
<p class="BodyFirst">Speaking of editing, it’s time to learn an editor. To get serious with Unix, you must be able to edit text files without damaging them. Most parts of the system use plaintext configuration files (like the ones in <em>/etc</em>). It’s not difficult to edit files, but you will do it so often that you need a powerful tool for the job.</p>
<p><span epub:type="pagebreak" title="26" id="Page_26"/>You should try to learn one of the two de facto standard Unix text editors, vi and Emacs. Most Unix wizards are religious about their choice of editor, but don’t listen to them. Just choose for yourself. If you choose one that matches the way that you work, you’ll find it easier to learn. Basically, the choice comes down to this:</p>
<ul>
<li>If you want an editor that can do almost anything and has extensive online help, and you don’t mind doing some extra typing to get these features, try Emacs.</li>
<li>If speed is everything, give vi a shot; it “plays” a bit like a video game.</li>
</ul>
<p><em>Learning the vi and Vim Editors: Unix Text Processing</em>, 7th edition, by Arnold Robbins, Elbert Hannah, and Linda Lamb (O’Reilly, 2008), can tell you everything you need to know about vi. For Emacs, use the online tutorial: start Emacs, press <span class="KeyCaps">ctrl</span>-H, and then type T. Or read <em>GNU Emacs Manual</em>, 18th edition, by Richard M. Stallman (Free Software Foundation, 2018).</p>
<p>You might be tempted to experiment with a friendlier editor when you first start out, such as nano, Pico, or one of the myriad GUI editors out there, but if you tend to make a habit out of the first thing that you use, you don’t want to go this route.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Editing text is where you’ll first start to see a difference between the terminal and the GUI. Editors such as vi run inside the terminal window, using the standard terminal I/O interface. GUI editors start their own window and present their own interface, independent of terminals. Emacs runs in a GUI by default but will run in a terminal window as well.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c02-0013">	2.13	Getting Online Help</h2>
<p class="BodyFirst">Linux systems come with a wealth of documentation. For basic commands, the manual pages (or <em>man pages</em>) will tell you what you need to know. For example, to see the manual page for the <code>ls</code> command, run <code>man</code> as follows:</p>
<pre><code>$ <b>man ls</b></code></pre>
<p>Most manual pages concentrate primarily on reference information, perhaps with some examples and cross-references, but that’s about it. Don’t expect a tutorial, and don’t expect an engaging literary style.</p>
<p>When programs have many options, the manual page often lists the options in some systematic way (for example, in alphabetical order), but it won’t tell you what the important ones are. If you’re patient, you can usually find what you need to know in the man page. If you’re impatient, ask a friend—or pay someone to be your friend so that you can ask him or her.</p>
<p>To search for a manual page by keyword, use the <code>-k</code> option:</p>
<pre><code>$ <b>man -k </b><var class="bold">keyword</var></code></pre>
<p><span epub:type="pagebreak" title="27" id="Page_27"/>This is helpful if you don’t quite know the name of the command that you want. For example, if you’re looking for a command to sort something, run:</p>
<pre><code>$ <b>man -k sort</b>
--<var>snip</var>--
comm (1) - compare two sorted files line by line
qsort (3) - sorts an array
sort (1) - sort lines of text files
sortm (1) - sort messages
tsort (1) - perform topological sort
--<var>snip</var>--</code></pre>
<p>The output includes the manual page name, the manual section (see below), and a quick description of what the manual page contains.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you have any questions about the commands described in the previous sections, you may be able to find the answers by using the <var>man</var> command.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Manual pages are referenced by numbered sections. When someone refers to a manual page, they often put the section number in parentheses next to the name, like ping(8). <a href="#table2-3" id="tableanchor2-3">Table 2-3</a> lists the sections and their numbers.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-3">Table 2-3</a>: Online Manual Sections</p></figcaption>
<table id="table-500402c02-0003" border="1">
<thead>
<tr>
<td><b>Section</b></td><td><b>Description</b></td></tr>
</thead>
<tbody>
<tr>
<td>1</td><td>User commands</td></tr>
<tr>
<td>2</td><td>Kernel system calls</td></tr>
<tr>
<td>3</td><td>Higher-level Unix programming library documentation </td></tr>
<tr>
<td>4</td><td>Device interface and driver information</td></tr>
<tr>
<td>5</td><td>File descriptions (system configuration files)</td></tr>
<tr>
<td>6</td><td>Games</td></tr>
<tr>
<td>7</td><td>File formats, conventions, and encodings (ASCII, suffixes, and so on)</td></tr>
<tr>
<td>8</td><td>System commands and servers</td></tr>
</tbody>
</table>
</figure>
<p>Sections 1, 5, 7, and 8 should be good supplements to this book. Section 4 may be of marginal use, and Section 6 would be great if only it were a little larger. You probably won’t be able to use Section 3 if you aren’t a programmer, but you may be able to understand some of the material in Section 2 once you’ve read more about system calls in this book.</p>
<p>Some common terms have many matching manual pages across several sections. By default, <code>man</code> displays the first page that it finds. You can select a manual page by section. For example, to read the <em>/etc/passwd</em> file description (as opposed to the <code>passwd</code> command), you can insert the section number before the page name like so:</p>
<pre><code>$ <b>man 5 passwd</b></code></pre>
<p><span epub:type="pagebreak" title="28" id="Page_28"/>Manual pages cover the essentials, but there are many more ways to get online help (aside from searching the internet). If you’re just looking for a certain option for a command, try entering a command name followed by <code>--help</code> or <code>-h</code> (the option varies from command to command). You may get a deluge (as in the case of <code>ls --help</code>), or you may find just what you’re looking for.</p>
<p>Some time ago, the GNU Project decided that it didn’t like manual pages very much and switched to another format called <em>info</em> (or <em>texinfo</em>). Often this documentation goes further than a typical manual page does, but it can be more complex. To access an info manual, use <code>info</code> with the command name:</p>
<pre><code>$ <b>info </b><var class="bold">command</var></code></pre>
<p>If you don’t like the <code>info</code> reader, you can send the output to <code>less</code> (just add <code>| less</code>).</p>
<p>Some packages dump their available documentation into <em>/usr/share/doc</em> with no regard for online manual systems such as <code>man</code> or <code>info</code>. See this directory on your system if you find yourself searching for documentation—and, of course, search the internet.</p>
<h2 id="h1-500402c02-0014">	2.14	Shell Input and Output</h2>
<p class="BodyFirst">Now that you’re familiar with basic Unix commands, files, and directories, you’re ready to learn how to redirect standard input and output. Let’s start with standard output.</p>
<p>To send the output of <var>command</var> to a file instead of the terminal, use the <code>&gt;</code> redirection character:</p>
<pre><code>$ <var class="bold">command</var><b> &gt; </b><var class="bold">file</var></code></pre>
<p>The shell creates <var>file</var> if it does not already exist. If <var>file</var> exists, the shell erases (<em>clobbers</em>) the original file first. (Some shells have parameters that prevent clobbering. For example, you can enter <code>set -C</code> to avoid clobbering in <code>bash</code>.)</p>
<p>You can append the output to the file instead of overwriting it with the <code>&gt;&gt;</code> redirection syntax:</p>
<pre><code>$ <var class="bold">command</var><b> &gt;&gt; </b><var class="bold">file</var></code></pre>
<p>This is a handy way to collect output in one place when executing sequences of related commands.</p>
<p>To send the standard output of a command to the standard input of another command, use the pipe character (<code>|</code>). To see how this works, try these two commands:</p>
<pre><code>$ <b>head /proc/cpuinfo</b>
$ <b>head /proc/cpuinfo | tr a-z A-Z</b></code></pre>
<p><span epub:type="pagebreak" title="29" id="Page_29"/>You can send output through as many piped commands as you wish; just add another pipe before each additional command.</p>
<h3 id="h2-500402c02-0022">2.14.1	Standard Error</h3>
<p class="BodyFirst">Occasionally, you may redirect standard output but find that the program still prints something to the terminal. This is called <em>standard error</em> (stderr); it’s an additional output stream for diagnostics and debugging. For example, this command produces an error:</p>
<pre><code>$ <b>ls /fffffffff &gt; f</b></code></pre>
<p>After completion, <em>f</em> should be empty, but you still see the following error message on the terminal as standard error:</p>
<pre><code>ls: cannot access /fffffffff: No such file or directory</code></pre>
<p>You can redirect the standard error if you like. For example, to send standard output to <em>f</em> and standard error to <em>e</em>, use the <code>2&gt;</code> syntax, like this:</p>
<pre><code>$ <b>ls /fffffffff &gt; f 2&gt; e</b></code></pre>
<p>The number 2 specifies the <em>stream ID</em> that the shell modifies. Stream ID 1 is standard output (the default), and 2 is standard error.</p>
<p>You can also send the standard error to the same place as stdout with the <code>&gt;&amp;</code> notation. For example, to send both standard output and standard error to the file named <em>f</em>, try this command:</p>
<pre><code>$ <b>ls /fffffffff &gt; f 2&gt;&amp;1</b></code></pre>
<h3 id="h2-500402c02-0023">2.14.2	Standard Input Redirection</h3>
<p class="BodyFirst">To channel a file to a program’s standard input, use the <code>&lt;</code> operator:</p>
<pre><code>$ <b>head &lt; /proc/cpuinfo</b></code></pre>
<p>You will occasionally run into a program that requires this type of redirection, but because most Unix commands accept filenames as arguments, this isn’t very common. For example, the preceding command could have been written as <code>head /proc/cpuinfo</code>.</p>
<h2 id="h1-500402c02-0015">	2.15	Understanding Error Messages</h2>
<p class="BodyFirst">When you encounter a problem on a Unix-like system such as Linux, you <em>must</em> read the error message. Unlike messages from other operating systems, Unix errors usually tell you exactly what went wrong.</p>
<h3 id="h2-500402c02-0024"><span epub:type="pagebreak" title="30" id="Page_30"/>2.15.1	Anatomy of a Unix Error Message</h3>
<p class="BodyFirst">Most Unix programs generate and report the same basic error messages, but there can be subtle differences between the output of any two programs. Here’s an example that you’ll certainly encounter in some form or other:</p>
<pre><code>$ <b>ls /dsafsda</b>
ls: cannot access /dsafsda: No such file or directory</code></pre>
<p>There are three components to this message:</p>
<ul>
<li>The program name, <code>ls</code>. Some programs omit this identifying information, which can be annoying when you’re writing shell scripts, but it’s not really a big deal.</li>
<li>The filename, <code>/dsafsda</code>, which is a more specific piece of information. There’s a problem with this path.</li>
<li>The error <code>No such file or directory</code> indicates the problem with the filename.</li>
</ul>
<p>Putting it all together, you get something like “<code>ls</code> tried to open <code>/dsafsda</code> but couldn’t because it doesn’t exist.” This may seem obvious, but these messages can get a little confusing when you run a shell script that includes an erroneous command under a different name.</p>
<p>When troubleshooting errors, always address the first error first. Some programs report that they can’t do anything before reporting a host of other problems. For example, say you run a fictitious program called <code>scumd</code> and you see this error message:</p>
<pre><code>scumd: cannot access /etc/scumd/config: No such file or directory</code></pre>
<p>Following this is a huge list of other error messages that looks like a complete catastrophe. Don’t let those other errors distract you. You probably just need to create <em>/etc/scumd/config</em>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Don’t confuse error messages with warning messages. Warnings often look like errors, but they contain the word <span class="Regular">warning</span>. A warning usually means something is wrong but the program will try to continue running anyway. To fix a problem noted in a warning message, you may have to hunt down a process and kill it before doing anything else. (You’ll learn about listing and killing processes in <span class="xref" itemid="xref_target_Section 2.16">Section 2.16</span>.)</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c02-0025">2.15.2	Common Errors</h3>
<p class="BodyFirst">Many errors you’ll encounter in Unix programs result from things that can go wrong with files and processes. Quite a few of these errors stem directly from conditions that kernel system calls encounter, so you can learn something about how the kernel sends problems back to processes by looking at them. </p>
<h4 id="h3-500402c02-0001"><span epub:type="pagebreak" title="31" id="Page_31"/>No such file or directory</h4>
<p class="BodyFirst">This is the number one error. You tried to access a file that doesn’t exist. Because the Unix file I/O system doesn’t discriminate much between files and directories, this error message covers both cases. You get it when you try to read a file that doesn’t exist, when you try to change to a directory that isn’t there, when you try to write to a file in a directory that doesn’t exist, and so on. This error is also known as ENOENT, short for “Error NO ENTity.”</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you’re interested in system calls, this is usually the result of <var>open()</var> returning ENOENT. See the open(2) manual page for more information on the errors it can encounter.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c02-0002">File exists</h4>
<p class="BodyFirst">In this case, you probably tried to create a file that already exists. This is common when you try to create a directory with the same name as a file.</p>
<h4 id="h3-500402c02-0003">Not a directory, Is a directory</h4>
<p class="BodyFirst">These messages pop up when you try to use a file as a directory, or a directory as a file. For example:</p>
<pre><code>$ <b>touch a</b>
$ <b>touch a/b</b>
touch: a/b: Not a directory</code></pre>
<p>Notice that the error message applies only to the <code>a</code> part of <code>a/b</code>. When you encounter this problem, you may need to dig around a little to find the path component that is being treated like a directory.</p>
<h4 id="h3-500402c02-0004">No space left on device</h4>
<p class="BodyFirst">You’re out of disk space.</p>
<h4 id="h3-500402c02-0005">Permission denied</h4>
<p class="BodyFirst">You get this error when you attempt to read or write to a file or directory that you’re not allowed to access (you have insufficient privileges). This error also shows when you try to execute a file that does not have the execute bit set (even if you can read the file). You’ll read more about permissions in <span class="xref" itemid="xref_target_Section 2.17">Section 2.17</span>.</p>
<h4 id="h3-500402c02-0006">Operation not permitted</h4>
<p class="BodyFirst">This usually happens when you try to kill a process that you don’t own.</p>
<h4 id="h3-500402c02-0007">Segmentation fault, Bus error</h4>
<p class="BodyFirst">A <em>segmentation fault</em> essentially means that the person who wrote the program that you just ran screwed up somewhere. The program tried to access <span epub:type="pagebreak" title="32" id="Page_32"/>a part of memory that it was not allowed to touch, and the operating system killed it. Similarly, a <em>bus error</em> means that the program tried to access some memory in a way it shouldn’t have. When you get one of these errors, you might be giving a program some input that it did not expect. In rare cases, it might be faulty memory hardware.</p>
<h2 id="h1-500402c02-0016">	2.16	Listing and Manipulating Processes</h2>
<p class="BodyFirst">Recall from <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span> that a process is a running program. Each process on the system has a numeric <em>process ID</em> <em>(PID)</em>. For a quick listing of running processes, just run <code class="bold">ps</code> on the command line. You should get a list like this one:</p>
<pre><code>$ <b>ps</b>
  PID TTY STAT TIME COMMAND
  520 p0  S    0:00 -bash
  545  ?  S    3:59 /usr/X11R6/bin/ctwm -W
  548  ?  S    0:10 xclock -geometry -0-0
 2159 pd  SW   0:00 /usr/bin/vi lib/addresses
31956 p3  R    0:00 ps</code></pre>
<p>The fields are as follows:</p>
<ol class="none">
<li><code class="bold">PID</code> The process ID.</li>
<li><code class="bold">TTY</code> The terminal device where the process is running. More about this later.</li>
<li><code class="bold">STAT</code> The process status—that is, what the process is doing and where its memory resides. For example, <code>S</code> means sleeping and <code>R</code> means running. (See the ps(1) manual page for a description of all the symbols.)</li>
<li><code class="bold">TIME</code> The amount of CPU time in minutes and seconds that the process has used so far. In other words, the total amount of time that the process has spent running instructions on the processor. Remember that because processes don’t run constantly, this is different from the time since the process started (or “wall-clock time”).</li>
<li><code class="bold">COMMAND</code> This one might seem obvious as the command used to run the program, but be aware that a process can change this field from its original value. Furthermore, the shell can perform glob expansion, and this field will reflect the expanded command instead of what you enter at the prompt.</li>
</ol>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	PIDs are unique for each process running on a system. However, after a process terminates, the kernel can eventually reuse the PID for a new process.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c02-0026">2.16.1	ps Command Options</h3>
<p class="BodyFirst">The <code>ps</code> command has many options. To make things more confusing, you can specify options in three different styles—Unix, BSD, and GNU. Many <span epub:type="pagebreak" title="33" id="Page_33"/>people find the BSD style to be the most comfortable (perhaps because it involves less typing), so that’s what we’ll use in this book. Here are some of the most useful option combinations:</p>
<ol class="none">
<li><code class="bold">ps x</code> Show all of your running processes.</li>
<li><code class="bold">ps ax</code> Show all processes on the system, not just the ones you own.</li>
<li><code class="bold">ps u</code> Include more detailed information on processes.</li>
<li><code class="bold">ps w</code> Show full command names, not just what fits on one line.</li>
</ol>
<p>As with other programs, you can combine options, as in <code>ps aux</code> and <code>ps auxw</code>.</p>
<p>To check on a specific process, add its PID to the argument list of the <code>ps</code> command. For example, to inspect the current shell process, you can use <code>ps u $$</code> (<code>$$</code> is a shell variable that evaluates to the current shell’s PID). You’ll find information on the administration commands <code>top</code> and <code>lsof</code> in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>. These can be useful for locating processes, even when you’re doing something other than system maintenance.</p>
<h3 id="h2-500402c02-0027">2.16.2	Process Termination</h3>
<p class="BodyFirst">To terminate a process, you send it a <em>signal</em>—a message to a process from the kernel—with the <code>kill</code> command. In most cases, all you need to do is this:</p>
<pre><code>$ <b>kill </b><var class="bold">pid</var></code></pre>
<p>There are many types of signals. The default (used above) is <code>TERM</code>, or terminate. You can send different signals by adding an extra option to <code>kill</code>. For example, to freeze a process instead of terminating it, use the <code>STOP</code> signal:</p>
<pre><code>$ <b>kill -STOP </b><var class="bold">pid</var></code></pre>
<p>A stopped process is still in memory, ready to pick up where it left off. Use the <code>CONT</code> signal to continue running the process again:</p>
<pre><code>$ <b>kill -CONT </b><var class="bold">pid</var></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Using <span class="KeyCaps">ctrl</span>-C to terminate a process that is running in the current terminal is the same as using <var>kill</var> to end the process with the <var>INT</var> (interrupt) signal.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The kernel gives most processes a chance to clean up after themselves upon receiving signals (with the <em>signal handler</em> mechanism). However, some processes may choose a nonterminating action in response to a signal, get wedged in the act of trying to handle it, or simply ignore it, so you might find a process still running after you try to terminate it. If this happens and you really need to kill a process, the most brutal way to terminate it is with the <code>KILL</code> signal. Unlike other signals, <code>KILL</code> cannot be ignored; in fact, the operating system doesn’t even give the process a chance. The kernel just terminates the process and forcibly removes it from memory. Use this method only as a last resort.</p>
<p><span epub:type="pagebreak" title="34" id="Page_34"/>You should not kill processes indiscriminately, especially if you don’t know what they’re doing. You may be shooting yourself in the foot.</p>
<p>You may see other users entering numbers instead of names with <code>kill</code>—for example, <code>kill -9</code> instead of <code>kill -KILL</code>. This is because the kernel uses numbers to denote the different signals; you can use <code>kill</code> this way if you know the number of the signal that you want to send. Run <code class="bold">kill -l</code> to get a mapping of signal numbers to names.</p>
<h3 id="h2-500402c02-0028">2.16.3	Job Control</h3>
<p class="BodyFirst">Shells support <em>job control</em>, a way to send <code>TSTP</code> (similar to <code>STOP</code>) and <code>CONT</code> signals to programs by using various keystrokes and commands. This allows you to suspend and switch between programs you’re using. For example, you can send a <code>TSTP</code> signal with <span class="KeyCaps">ctrl</span>-Z and then start the process again by entering <code>fg</code> (bring to foreground) or <code>bg</code> (move to background; see the next section). But despite its utility and the habits of many experienced users, job control is not necessary and can be confusing for beginners: It’s common for users to press <span class="KeyCaps">ctrl-</span>Z instead of <span class="KeyCaps">ctrl</span>-C, forget about what they were running, and eventually end up with numerous suspended processes.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE </span></h2>
<p>	To see if you’ve accidentally suspended any processes on your current terminal, run the <var class="bold">jobs</var> command.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If you want to run multiple programs, run each in a separate terminal window, put noninteractive processes in the background (as explained in the next section), and learn to use the <code>screen</code> and <code>tmux</code> utilities.</p>
<h3 id="h2-500402c02-0029">2.16.4	Background Processes</h3>
<p class="BodyFirst">Normally, when you run a Unix command from the shell, you don’t get the shell prompt back until the program finishes executing. However, you can detach a process from the shell and put it in the “background” with the ampersand (<code>&amp;</code>); this gives you the prompt back. For example, if you have a large file that you need to decompress with <code>gunzip</code> (you’ll see this in <span class="xref" itemid="xref_target_Section 2.18">Section 2.18</span>), and you want to do some other stuff while it’s running, run a command like this one:</p>
<pre><code>$ <b>gunzip </b><var class="bold">file</var><b>.gz &amp;</b></code></pre>
<p>The shell should respond by printing the PID of the new background process, and the prompt should return immediately so that you can continue working. If the process takes a very long time, it can even continue to run after you log out, which comes in particularly handy if you have to run a program that does a lot of number crunching. If the process finishes before you log out or close the terminal window, the shell usually notifies you, depending on your setup.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="35" id="Page_35"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	If you’re remotely accessing a machine and want to keep a program running when you log out, you may need to use the <var>nohup</var> command; see its manual page for details.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The dark side of running background processes is that they may expect to work with the standard input (or worse, read directly from the terminal). If a program tries to read something from the standard input when it’s in the background, it can freeze (try <code>fg</code> to bring it back) or terminate. Also, if the program writes to the standard output or standard error, the output can appear in the terminal window with no regard for anything else running there, meaning that you can get unexpected output when you’re working on something else.</p>
<p>The best way to make sure that a background process doesn’t bother you is to redirect its output (and possibly input) as described in <span class="xref" itemid="xref_target_Section 2.14">Section 2.14</span>.</p>
<p>If spurious output from background processes gets in your way, learn how to redraw the content of your terminal window. The <code>bash</code> shell and most full-screen interactive programs support <span class="KeyCaps">ctrl</span>-L to redraw the entire screen. If a program is reading from the standard input, <span class="KeyCaps">ctrl</span>-R usually redraws the current line, but pressing the wrong sequence at the wrong time can leave you in an even worse situation than before. For example, entering <span class="KeyCaps">ctrl</span>-R at the <code>bash</code> prompt puts you in reverse isearch mode (press <span class="KeyCaps">esc</span> to exit).</p>
<h2 id="h1-500402c02-0017">	2.17	File Modes and Permissions</h2>
<p class="BodyFirst">Every Unix file has a set of <em>permissions</em> that determine whether you can read, write, or run the file. Running <code>ls -l</code> displays the permissions. Here’s an example of such a display:</p>
<pre><code>-rw-r--r--<span class="CodeAnnotation" aria-label="annotation1">1</span> 1 juser somegroup 7041  Mar 26 19:34  endnotes.html</code></pre>
<p>The file’s <em>mode</em> <span class="CodeAnnotation" aria-label="annotation1">1</span> represents the file’s permissions and some extra information. There are four parts to the mode, as illustrated in <a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>.</p>
<figure>
<img src="image_fi/500402c02/f02001.png" alt="f02001"/>
<figcaption><p><a id="figure2-1">Figure 2-1</a>: The pieces of a file mode</p></figcaption></figure>
<p>The first character of the mode is the <em>file type</em>. A dash (<code>-</code>) in this position, as in the example, denotes a <em>regular</em> file, meaning that there’s nothing special about the file; it’s just binary or text data. This is by far the most common kind of file. Directories are also common and are indicated by a <code>d</code> in the file type slot. (<span class="xref" itemid="xref_target_Section 3.1">Section 3.1</span> lists the remaining file types.)</p>
<p><span epub:type="pagebreak" title="36" id="Page_36"/>The rest of a file’s mode contains the permissions, which break down into three sets: <em>user</em>, <em>group</em>, and <em>other</em>, in that order. For example, the <code>rw-</code> characters in the example are the user permissions, the <code>r--</code> characters that follow are the group permissions, and the final <code>r--</code> characters are the other permissions.</p>
<p>Each permission set can contain four basic representations:</p>
<ul>
<li><code>r</code> means that the file is readable.</li>
<li><code>w</code> means that the file is writable.</li>
<li><code>x</code> means that the file is executable (you can run it as a program).</li>
<li><code>-</code> means “nothing” (more specifically, the permission for that slot in the set has not been granted).</li>
</ul>
<p>The user permissions (the first set) pertain to the user who owns the file. In the preceding example, that’s <code>juser</code>. The second set, group permissions, are for the file’s group (<code>somegroup</code> in the example). Any user in that group can take advantage of these permissions. (Use the <code>groups</code> command to see what group you’re in, and see <span class="xref" itemid="xref_target_Section 7.3.5">Section 7.3.5</span> for more information.)</p>
<p>Everyone else on the system has access according to the third set, the other permissions, which are sometimes called <em>world</em> permissions.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Each read, write, and execute permission slot is sometimes called a <span class="Regular">permission bit</span> because the underlying representation in the operating system is a series of bits. Therefore, you may hear people refer to parts of the permissions as “the read bits.”</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Some executable files have an <code>s</code> in the user permissions listing instead of an <code>x</code>. This indicates that the executable is <em>setuid</em>, meaning that when you execute the program, it runs as though the file owner is the user instead of you. Many programs use this setuid bit to run as root in order to get the privileges they need to change system files. One example is the <code>passwd</code> program, which needs to change the <em>/etc/passwd</em> file.</p>
<h3 id="h2-500402c02-0030">2.17.1	Modifying Permissions</h3>
<p class="BodyFirst">To change permissions on a file or directory, use the <code>chmod</code> command. First, pick the set of permissions that you want to change, and then pick the bit to change. For example, to add group (<code>g</code>) and world (<code>o</code>, for “other”) read (<code>r</code>) permissions to <var>file</var>, you could run these two commands:</p>
<pre><code>$ <b>chmod g+r </b><var class="bold">file</var>
$ <b>chmod o+r </b><var class="bold">file</var></code></pre>
<p>Or you could do it all in one shot:</p>
<pre><code>$ <b>chmod go+r </b><var class="bold">file</var></code></pre>
<p><span epub:type="pagebreak" title="37" id="Page_37"/>To remove these permissions, use <code>go-r</code> instead of <code>go+r</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Obviously, you shouldn’t make files world-writable because doing so enables anyone on your system to change them. But would this also allow anyone connected to the internet to change them? Probably not, unless your system has a network security hole. In that case, file permissions won’t help you anyway.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You may sometimes see people changing permissions with numbers, for example:</p>
<pre><code>$ <b>chmod 644 </b><var class="bold">file</var></code></pre>
<p>This is called an <em>absolute</em> change because it sets <em>all</em> permission bits at once. To understand how this works, you need to know how to represent the permission bits in octal form (each numeral represents a number in base 8, 0 through 7, and corresponds to a permission set). See the chmod(1) manual page or info manual for more.</p>
<p>You don’t really need to know how to construct absolute modes if you prefer to use them; just memorize the modes that you use most often. <a href="#table2-4" id="tableanchor2-4">Table 2-4</a> lists the most common ones.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-4">Table 2-4</a>: Absolute Permission Modes</p></figcaption>
<table id="table-500402c02-0004" border="1">
<thead>
<tr>
<td><b>Mode</b></td><td><b>Meaning</b></td><td><b>Used for</b></td></tr>
</thead>
<tbody>
<tr>
<td><code>644</code></td><td>user: read/write; group, other: read</td><td>files</td></tr>
<tr>
<td><code>600</code></td><td>user: read/write; group, other: none</td><td>files</td></tr>
<tr>
<td><code>755</code></td><td>user: read/write/execute; group, other: read/execute</td><td>directories, programs</td></tr>
<tr>
<td><code>700</code></td><td>user: read/write/execute; group, other: none</td><td>directories, programs</td></tr>
<tr>
<td><code>711</code></td><td>user: read/write/execute; group, other: execute</td><td>directories</td></tr>
</tbody>
</table>
</figure>
<p>Directories also have permissions. You can list the contents of a directory if it’s readable, but you can only access a file in a directory if the directory is executable. You need both in most cases; one common mistake people make when setting the permissions of directories is to accidentally remove the execute permission when using absolute modes.</p>
<p>Finally, you can specify a set of default permissions with the <code>umask</code> shell command, which applies a predefined set of permissions to any new file you create. In general, use <code>umask 022</code> if you want everyone to be able to see all of the files and directories that you create, and use <code>umask 077</code> if you don’t. If you want to make your desired permissions mask apply to new windows and later sessions, you need to put the <code>umask</code> command with the desired mode in one of your startup files, as discussed in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>.</p>
<h3 id="h2-500402c02-0031"><span epub:type="pagebreak" title="38" id="Page_38"/>2.17.2	Working with Symbolic Links</h3>
<p class="BodyFirst">A <em>symbolic link</em> is a file that points to another file or a directory, effectively creating an alias (like a shortcut in Windows). Symbolic links offer quick access to obscure directory paths.</p>
<p>In a long directory listing, symbolic links look like this (notice the <code>l</code> as the file type in the file mode):</p>
<pre><code>lrwxrwxrwx 1 ruser users  11 Feb 27 13:52  somedir -&gt; /home/origdir</code></pre>
<p>If you try to access <em>somedir</em> in this directory, the system gives you <em>/home/origdir</em> instead. Symbolic links are simply filenames that point to other names. Their names and the paths to which they point don’t have to mean anything. In the preceding example, <em>/home/origdir</em> doesn’t need to exist.</p>
<p>In fact, if <em>/home/origdir</em> does not exist, any program that accesses <em>somedir</em> returns an error reporting that <em>somedir</em> doesn’t exist (except for <code>ls somedir</code>, a command that stupidly informs you that <em>somedir</em> is <em>somedir</em>). This can be baffling because you can see something named <em>somedir</em> right in front of your eyes.</p>
<p>This is not the only way that symbolic links can be confusing. Another problem is that you can’t identify the characteristics of a link target just by looking at the name of the link; you must follow the link to see if it goes to a file or directory. Your system may also have links that point to other links, which are called <em>chained symbolic links</em> and can be a nuisance when you’re trying to track them down.</p>
<p>To create a symbolic link from <em>target</em> to <em>linkname</em>, use <code>ln -s</code> as follows:</p>
<pre><code>$ <b>ln -s <var class="bold">target</var> <var class="bold">linkname</var></b></code></pre>
<p>The <var>linkname</var> argument is the name of the symbolic link, the <var>target</var> argument is the path of the file or directory that the link <em>points</em> to, and the <code>-s</code> flag specifies a symbolic link (see the warning that follows).</p>
<p>When making a symbolic link, check the command twice before you run it, because several things can go wrong. For example, if you accidentally reverse the order of the arguments (<code>ln -s </code><var>linkname target</var>), you’re in for some fun if <em>linkname</em> is a directory that already exists. If this is the case (and it quite often is), <code>ln</code> creates a link named <em>target</em> inside <em>linkname,</em> and the link will point to itself unless <em>linkname</em> is a full path. If something goes wrong when you create a symbolic link to a directory, check that directory for errant symbolic links and remove them.</p>
<p>Symbolic links can also cause headaches when you don’t know that they exist. For example, you can easily edit what you think is a copy of a file but is actually a symbolic link to the original.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	Don’t forget the <var>-s</var> option when creating a symbolic link. Without it, <var>ln</var> creates a hard link, giving an additional real filename to a single file. The new filename has the status of the old one; it points (links) directly to the file data instead of to another filename as a symbolic link does. Hard links can be even more confusing than symbolic links. Unless you understand the material in <span class="xref" itemid="xref_target_Section 4.6">Section 4.6</span>, avoid using them.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="39" id="Page_39"/>With all these warnings about symbolic links, you might be wondering why anyone would want to use them. As it turns out, their pitfalls are significantly outweighed by the power they provide for organizing files and their ability to easily patch up small problems. One common use case is when a program expects to find a particular file or directory that already exists somewhere else on your system. You don’t want to make a copy, and if you can’t change the program, you can just create a symbolic link from it to the actual file or directory location.</p>
<h2 id="h1-500402c02-0018">	2.18	Archiving and Compressing Files</h2>
<p class="BodyFirst">Now that you’ve learned about files, permissions, and possible errors, you need to master <code>gzip</code> and <code>tar</code>, two common utilities for compressing and bundling files and directories.</p>
<h3 id="h2-500402c02-0032">2.18.1	gzip</h3>
<p class="BodyFirst">The program <code>gzip</code> (GNU Zip) is one of the current standard Unix compression programs. A file that ends with <em>.gz</em> is a GNU Zip archive. Use <code>gunzip </code><var>file</var><code>.gz</code> to uncompress <em>&lt;file&gt;.gz</em> and remove the suffix; to compress the file again, use <code>gzip </code><var>file</var>.</p>
<h3 id="h2-500402c02-0033">2.18.2	tar</h3>
<p class="BodyFirst">Unlike the ZIP programs for other operating systems, <code>gzip</code> does not create archives of files; that is, it doesn’t pack multiple files and directories into a single file. To create an archive, use <code>tar</code> instead:</p>
<pre><code>$ <b>tar cvf </b><var class="bold">archive</var><b>.tar </b><var class="bold">file1</var><b> </b><var class="bold">file2</var><b> ...</b></code></pre>
<p>Archives created by <code>tar</code> usually have a <em>.tar</em> suffix (this is by convention; it isn’t required). For example, in the previous command, <var>file1</var>, <var>file2</var>, and so on are the names of the files and directories that you wish to archive in <em>&lt;archive&gt;.tar</em>. The <code>c</code> flag activates <em>create mode</em>. The <code>v</code> and <code>f</code> flags have more specific roles.</p>
<p>The <code>v</code> flag activates verbose diagnostic output, causing <code>tar</code> to print the names of the files and directories in the archive when it encounters them. Adding another <code>v</code> causes <code>tar</code> to print details such as file size and permissions. If you don’t want <code>tar</code> to tell you what it’s doing, omit the <code>v</code> flag.</p>
<p>The <code>f</code> flag denotes the file option. The next argument on the command line after the <code>f</code> flag must be the archive file for <code>tar</code> to create (in the preceding example, it is <em>&lt;archive&gt;.tar</em>). You <em>must</em> use this option followed by a filename at all times, except with tape drives. To use standard input or output, set the filename to a dash (<code>-</code>).</p>
<h4 id="h3-500402c02-0008"><span epub:type="pagebreak" title="40" id="Page_40"/>Unpacking .tar Files</h4>
<p class="BodyFirst">To unpack a <em>.tar</em> file with <code>tar</code> use the <code>x</code> flag:</p>
<pre><code>$ <b>tar xvf </b><var class="bold">archive</var><b>.tar</b></code></pre>
<p>In this command, the <code>x</code> flag puts <code>tar</code> into <em>extract</em> (<em>unpack</em>) <em>mode</em>. You can extract individual parts of the archive by entering the names of the parts at the end of the command line, but you must know their exact names. (To find out for sure, see the table-of-contents mode described next.)</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	When using extract mode, remember that <var>tar</var> does not remove the archived <span class="Regular">.tar</span> file after extracting its contents.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c02-0009">Using Table-of-Contents Mode</h4>
<p class="BodyFirst">Before unpacking, it’s usually a good idea to check the contents of a <em>.tar</em> file with the <em>table-of-contents mode</em> by using the <code>t</code> flag instead of the <code>x</code> flag. This mode verifies the archive’s basic integrity and prints the names of all files inside. If you don’t test an archive before unpacking it, you can end up dumping a huge mess of files into the current directory, which can be really difficult to clean up.</p>
<p>When you check an archive with the <code>t</code> mode, verify that everything is in a rational directory structure; that is, all file pathnames in the archive should start with the same directory. If you’re unsure, create a temporary directory, change to it, and then extract. (You can always use <code>mv * ..</code> if the archive didn’t create a mess.)</p>
<p>When unpacking, consider using the <code>p</code> option to preserve permissions. Use this in extract mode to override your <code>umask</code> and get the exact permissions specified in the archive. The <code>p</code> option is the default when you’re working as the superuser. If you’re having trouble with permissions and ownership when unpacking an archive as the superuser, make sure that you’re waiting until the command terminates and you get the shell prompt back. Although you may only want to extract a small part of an archive, <code>tar</code> must run through the whole thing, and you must not interrupt the process because it sets the permissions only <em>after</em> checking the entire archive.</p>
<p>Commit <em>all</em> of the <code>tar</code> options and modes in this section to memory. If you’re having trouble, make some flash cards. This may sound like grade school, but it’s very important to avoid careless mistakes with this command.</p>
<h3 id="h2-500402c02-0034">2.18.3	Compressed Archives (.tar.gz)</h3>
<p class="BodyFirst">Many beginners find it confusing that archives are normally found compressed, with filenames ending in <em>.tar.gz</em>. To unpack a compressed archive, work from the right side to the left; get rid of the <em>.gz</em> first and then worry about the <em>.tar</em>. For example, these two commands decompress and unpack <em>&lt;file&gt;.tar.gz</em>:</p>
<pre><code>$ <b>gunzip </b><var class="bold">file</var><b>.tar.gz</b>
$ <b>tar xvf </b><var class="bold">file</var><b>.tar</b></code></pre>
<p><span epub:type="pagebreak" title="41" id="Page_41"/>When starting out, it’s fine to do this one step at a time, first running <code>gunzip</code> to decompress and then <code>tar</code> to verify and unpack. To create a compressed archive, do the reverse: run <code>tar</code> first and <code>gzip</code> second. Do this frequently enough, and you’ll soon memorize how the archiving and compression process works. But even if you don’t do it all that often, you can see how tiresome all of the typing can become and you’ll start looking for shortcuts. Let’s take a look at those now.</p>
<h3 id="h2-500402c02-0035">2.18.4	zcat</h3>
<p class="BodyFirst">The method just shown isn’t the fastest or most efficient way to invoke <code>tar</code> on a compressed archive, and it wastes disk space and kernel I/O time. A better way is to combine archival and compression functions with a pipeline. For example, this command pipeline unpacks <em>&lt;file&gt;.tar.gz</em>:</p>
<pre><code>$ <b>zcat </b><var class="bold">file</var><b>.tar.gz | tar xvf -</b></code></pre>
<p>The <code>zcat</code> command is the same as <code>gunzip -dc</code>. The <code>-d</code> option decompresses and the <code>-c</code> option sends the result to standard output (in this case, to the <code>tar</code> command).</p>
<p>Because it’s so common to use <code>zcat</code>, the version of <code>tar</code> that comes with Linux has a shortcut. You can use <code>z</code> as an option to automatically invoke <code>gzip</code> on the archive; this works both for extracting an archive (with the <code>x</code> or <code>t</code> modes in <code>tar</code>) and creating one (with <code>c</code>). For example, use the following to verify a compressed archive:</p>
<pre><code>$ <b>tar ztvf </b><var class="bold">file</var><b>.tar.gz</b></code></pre>
<p>However, try to remember that you’re actually performing two steps when taking the shortcut.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	A <span class="Regular">.tgz</span> file is the same as a <span class="Regular">.tar.gz</span> file. The suffix is meant to fit into FAT (MS-DOS-based) filesystems.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c02-0036">2.18.5	Other Compression Utilities</h3>
<p class="BodyFirst">Two more compression programs are <code>xz</code> and <code>bzip2</code>, whose compressed files end with <em>.xz</em> and <em>.bz2</em>, respectively. While marginally slower than <code>gzip</code>, these often compact text files a little more. The decompressing programs to use are <code>unxz</code> and <code>bunzip2</code>, and the options of both are close enough to their <code>gzip</code> counterparts that you don’t need to learn anything new. </p>
<p>Most Linux distributions come with <code>zip</code> and <code>unzip</code> programs that are compatible with the ZIP archives on Windows systems. They work on the usual <em>.zip</em> files as well as self-extracting archives ending in <em>.exe</em>. But if you encounter a file that ends in <em>.Z</em>, you have found a relic created by the <code>compress</code> program, which was once the Unix standard. The <code>gunzip</code> program can unpack these files, but <code>gzip</code> won’t create them.</p>
<h2 id="h1-500402c02-0019"><span epub:type="pagebreak" title="42" id="Page_42"/>	2.19	Linux Directory Hierarchy Essentials</h2>
<p class="BodyFirst">Now that you know how to examine files, change directories, and read manual pages, you’re ready to start exploring your system files and directories. The details of the Linux directory structure are outlined in the Filesystem Hierarchy Standard, or FHS (<em>https://refspecs.linuxfoundation.org/fhs.shtml</em>), but a brief walkthrough should suffice for now.</p>
<p><a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a> offers a simplified overview of the hierarchy, showing some of the directories under <em>/</em>, <em>/usr</em>, and <em>/var</em>. Notice that the directory structure under <em>/usr</em> contains some of the same directory names as <em>/</em>.</p>
<figure>
<img src="image_fi/500402c02/f02002.png" alt="f02002"/>
<figcaption><p><a id="figure2-2">Figure 2-2</a>: Linux directory hierarchy</p></figcaption></figure>
<p>Here are the most important subdirectories in root:</p>
<ol class="none">
<li><b><i>/bin</i></b> Contains ready-to-run programs (also known as <em>executables</em>), including most of the basic Unix commands such as <code>ls</code> and <code>cp</code>. Most of the programs in <em>/bin</em> are in binary format, having been created by a C compiler, but some are shell scripts in modern systems.</li>
<li><b><i>/dev</i></b> Contains device files. You’ll learn more about these in Chapter 3.</li>
<li><b><i>/etc</i></b> This core system configuration directory (pronounced <em>EHT-see</em>) contains the user password, boot, device, networking, and other setup files.</li>
<li><b><i>/home</i></b> Holds home (personal) directories for regular users. Most Unix installations conform to this standard.</li>
<li><b><i>/lib</i></b> An abbreviation for <em>library</em>, this directory holds library files containing code that executables can use. There are two types of libraries: static and shared. The <em>/lib</em> directory should contain only shared libraries, but other lib directories, such as <em>/usr/lib,</em> contain both varieties as well as other auxiliary files. (We’ll discuss shared libraries in more detail in <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>.)</li>
<li><b><i>/proc</i></b> Provides system statistics through a browsable directory-and-file interface. Much of the <em>/proc</em> subdirectory structure on Linux is unique, but many other Unix variants have similar features. The <em>/proc</em> directory contains information about currently running processes as well as some kernel parameters.</li>
<li><span epub:type="pagebreak" title="43" id="Page_43"/><b><i>/run</i></b> Contains runtime data specific to the system, including certain process IDs, socket files, status records, and, in many cases, system logging. This is a relatively recent addition to the root directory; in older systems, you can find it in <em>/var/run</em>. On newer systems, <em>/var/run</em> is a symbolic link to <em>/run</em>.</li>
<li><b><i>/sys</i></b> This directory is similar to <em>/proc</em> in that it provides a device and system interface. You’ll read more about <em>/sys</em> in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>.</li>
<li><b><i>/sbin</i></b> The place for system executables. Programs in /<em>sbin</em> directories relate to system management, so regular users usually do not have /<em>sbin</em> components in their command paths. Many of the utilities found here don’t work if not run as root.</li>
<li><b><i>/tmp</i></b> A storage area for smaller, temporary files that you don’t care much about. Any user may read to and write from <em>/tmp</em>, but the user may not have permission to access another user’s files there. Many programs use this directory as a workspace. If something is extremely important, don’t put it in <em>/tmp</em> because most distributions clear <em>/tmp</em> when the machine boots and some even remove its old files periodically. Also, don’t let <em>/tmp</em> fill up with garbage because its space is usually shared with something critical (the rest of <em>/</em>, for example).</li>
<li><b><i>/usr</i></b> Although pronounced “user,” this subdirectory has no user files. Instead, it contains a large directory hierarchy, including the bulk of the Linux system. Many of the directory names in <em>/usr</em> are the same as those in the root directory (like <em>/usr/bin</em> and <em>/usr/lib</em>), and they hold the same type of files. (The reason that the root directory does not contain the complete system is primarily historic—in the past, it was to keep space requirements low for the root.)</li>
<li><b><i>/var</i></b> The variable subdirectory, where programs record information that can change over the course of time. System logging, user tracking, caches, and other files that system programs create and manage are here. (You’ll notice a <em>/var/tmp</em> directory here, but the system doesn’t wipe it on boot.)</li>
</ol>
<h3 id="h2-500402c02-0037">2.19.1	Other Root Subdirectories</h3>
<p class="BodyFirst">There are a few other interesting subdirectories in the root directory:</p>
<ol class="none">
<li><b><i>/boot</i></b> Contains kernel boot loader files. These files pertain only to the very first stage of the Linux startup procedure, so you won’t find information about how Linux starts up its services in this directory. See <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> for more about this.</li>
<li><b><i>/media</i></b> A base attachment point for removable media such as flash drives that is found in many distributions.</li>
<li><b><i>/opt</i></b> This may contain additional third-party software. Many systems don’t use <em>/opt</em>.</li>
</ol>
<h3 id="h2-500402c02-0038"><span epub:type="pagebreak" title="44" id="Page_44"/>2.19.2	The /usr Directory</h3>
<p class="BodyFirst">The <em>/usr</em> directory may look relatively clean at first glance, but a quick look at <em>/usr/bin</em> and <em>/usr/lib</em> reveals that there’s a lot here; <em>/usr</em> is where most of the user-space programs and data reside. In addition to <em>/usr/bin</em>, <em>/usr/sbin</em>, and <em>/usr/lib</em>, <em>/usr</em> contains the following:</p>
<ol class="none">
<li><b><i>/include</i></b> Holds header files used by the C compiler.</li>
<li><b><i>/local</i></b> Is where administrators can install their own software. Its structure should look like that of <em>/</em> and <em>/usr</em>.</li>
<li><b><i>/man</i></b> Contains manual pages.</li>
<li><b><i>/share</i></b> Contains files that should work on other kinds of Unix machines with no loss of functionality. These are usually auxiliary data files that programs and libraries read as necessary. In the past, networks of machines would share this directory from a file server, but today a <em>share</em> directory used in this manner is rare because there are no realistic space restraints for these kinds of files on contemporary systems. Instead, on Linux distributions, you’ll find /<em>man</em>, /<em>info</em>, and many other subdirectories here because it is an easily understood convention.</li>
</ol>
<h3 id="h2-500402c02-0039">2.19.3	Kernel Location</h3>
<p class="BodyFirst">On Linux systems, the kernel is normally a binary file <em>/vmlinuz</em> or <em>/boot/vmlinuz</em>. A <em>boot loader</em> loads this file into memory and sets it in motion when the system boots. (You’ll find details on the boot loader in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.)</p>
<p>Once the boot loader starts the kernel, the main kernel file is no longer used by the running system. However, you’ll find many modules that the kernel loads and unloads on demand during the course of normal system operation. Called <em>loadable kernel modules</em>, they are located under <em>/lib/modules</em>.</p>
<h2 id="h1-500402c02-0020">	2.20	Running Commands as the Superuser</h2>
<p class="BodyFirst">Before going any further, you should learn how to run commands as the superuser. You may be tempted to start a root shell, but doing so has many disadvantages:</p>
<ul>
<li>You have no record of system-altering commands.</li>
<li>You have no record of the users who performed system-altering commands.</li>
<li>You don’t have access to your normal shell environment.</li>
<li>You have to enter the root password (if you have one).</li>
</ul>
<h3 id="h2-500402c02-0040"><span epub:type="pagebreak" title="45" id="Page_45"/>2.20.1	sudo</h3>
<p class="BodyFirst">Most distributions use a package called <code>sudo</code> to allow administrators to run commands as root when they are logged in as themselves. For example, in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, you’ll learn about using <code>vipw</code> to edit the <em>/etc/passwd</em> file. You could do it like this:</p>
<pre><code>$ <b>sudo vipw</b></code></pre>
<p>When you run this command, <code>sudo</code> logs this action with the syslog service under the local2 facility. You’ll also learn more about system logs in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>
<h3 id="h2-500402c02-0041">2.20.2	/etc/sudoers</h3>
<p class="BodyFirst">Of course, the system doesn’t let just <em>any</em> user run commands as the superuser; you must configure the privileged users in your <em>/etc/sudoers</em> file. The <code>sudo</code> package has many options (that you’ll probably never use), which makes the syntax in <em>/etc/sudoers</em> somewhat complicated. For example, this file gives <var>user1</var> and <var>user2</var> the power to run any command as root without having to enter a password:</p>
<pre><code>User_Alias ADMINS = <var>user1</var>, <var>user2</var>

ADMINS ALL = NOPASSWD: ALL

root ALL=(ALL) ALL</code></pre>
<p>The first line defines an <code>ADMINS</code> user alias with the two users, and the second line grants the privileges. The <code>ALL = NOPASSWD: ALL</code> part means that the users in the <code>ADMINS</code> alias can use <code>sudo</code> to execute commands as root. The second <code>ALL</code> means “any command.” The first <code>ALL</code> means “any host.” (If you have more than one machine, you can set different kinds of access for each machine or group of machines, but we won’t cover that feature.)</p>
<p>The <code>root ALL=(ALL) ALL</code> simply means that the superuser may also use <code>sudo</code> to run any command on any host. The extra <code>(ALL)</code> means that the superuser may also run commands as any other user. You can extend this privilege to the <code>ADMINS</code> users by adding <code>(ALL)</code> to the second <em>/etc/sudoers</em> line, as shown here:</p>
<pre><code>ADMINS ALL = (ALL) NOPASSWD: ALL</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Use the <var>visudo</var> command to edit <span class="Regular">/etc/sudoers</span>. This command checks for file syntax errors after you save the file.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c02-0042"><span epub:type="pagebreak" title="46" id="Page_46"/>2.20.3	sudo Logs</h3>
<p class="BodyFirst">Although we’ll go into logs in more detail later in the book, you can find the <code>sudo</code> logs on most systems with this command:</p>
<pre><code>$ <b>journalctl SYSLOG_IDENTIFIER=sudo</b></code></pre>
<p>On older systems, you’ll need to look for a logfile in <em>/var/log</em>, such as <em>/var/log/auth.log</em>.</p>
<p>That’s it for <code>sudo</code> for now. If you need to use its more advanced features, see the sudoers(5) and sudo(8) manual pages. (The actual mechanics of user switching are covered in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.)</p>
<h2 id="h1-500402c02-0021">	2.21	Looking Forward</h2>
<p class="BodyFirst">You should now know how to do the following at the command line: run programs, redirect output, interact with files and directories, view process listings, view manual pages, and generally make your way around the user space of a Linux system. You should also be able to run commands as the superuser. You may not yet know much about the internal details of user-space components or what goes on in the kernel, but with the basics of files and processes under your belt, you’re on your way. In the next few chapters, you’ll be working with both kernel and user-space system components using the command-line tools that you just learned.</p>
</section>
</body></html>