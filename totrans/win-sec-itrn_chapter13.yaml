- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NETWORK
    AUTHENTICATION</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">网络身份验证</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: The previous chapter discussed interactive authentication, which allows a user
    to log in to a computer and interact with a desktop. By contrast, *network authentication*
    occurs when the user has already authenticated to a Windows system but wants to
    use resources on another Windows system, typically over a network.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章讨论了交互式身份验证，它允许用户登录到计算机并与桌面进行交互。相比之下，*网络身份验证*发生在用户已经在Windows系统上进行身份验证，但希望在另一台Windows系统上使用资源时，通常是通过网络进行的。
- en: The simplest approach to performing network authentication might seem to be
    to transfer the user’s credentials to the remote system. The service that receives
    the credentials could then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API and specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp>
    logon type to create a noninteractive logon session. However, this approach isn’t
    very secure. To use <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>,
    a network-facing service must know the user’s full credentials, and providing
    a remote system with these credentials is problematic for many reasons. For one,
    we must trust the remote service to handle the credentials securely. For another,
    if the authentication takes place over a hostile network, an attacker could capture
    the credentials.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 执行网络身份验证的最简单方法可能是将用户的凭据传输到远程系统。接收凭据的服务随后可以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API，并指定<samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp>登录类型来创建一个非交互式登录会话。然而，这种方法并不安全。要使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>，一个面向网络的服务必须知道用户的完整凭据，并且将这些凭据提供给远程系统在许多方面存在问题。首先，我们必须信任远程服务能够安全地处理这些凭据。其次，如果身份验证发生在一个敌对网络上，攻击者可能会捕获这些凭据。
- en: To mitigate these security issues, Windows implements multiple network authentication
    protocols. These protocols don’t require sending a network service the user’s
    credentials or transferring a plaintext password over the network. (Of course,
    there are always caveats, which we’ll identify over the course of this chapter.)
    You’ll find these network authentication protocols in the security packages we
    discussed in the previous chapter, and you can access them via a generic API,
    which allows an application to easily change the authentication protocol used.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这些安全问题，Windows实现了多种网络身份验证协议。这些协议不需要将用户的凭据发送给网络服务，也不需要将明文密码通过网络传输。（当然，也有一些警告，我们将在本章过程中指出。）你将在上一章中讨论的安全包中找到这些网络身份验证协议，并且可以通过通用API访问它们，从而允许应用程序轻松地更改所使用的身份验证协议。
- en: This chapter begins by describing the *NT LAN Manager (NTLM)* authentication
    protocol, the oldest Windows protocol still in use, in some depth, covering how
    it uses the user’s credentials to prevent their disclosure over the network. Then
    we’ll look at a well-known attack, *NTLM relay*, and the ways Microsoft has tried
    to mitigate it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先详细介绍了*NT LAN Manager (NTLM)*身份验证协议，它是仍在使用的最古老的Windows协议，涵盖了它如何使用用户的凭据防止在网络上泄露。接下来我们将讨论一种著名的攻击方式——*NTLM中继*，以及Microsoft为减轻这一攻击所采取的措施。
- en: <samp class="SANS_Futura_Std_Bold_B_11">NTLM Network Authentication</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">NTLM 网络身份验证</samp>
- en: 'NTLM derives from the *LAN Manager (LM)* authentication protocol, which supported
    the Server Message Block (SMB) file sharing protocol as part of the LAN Manager
    operating system. Microsoft reimplemented the authentication protocol in Windows
    3.11 (the infamous Windows for Workgroups), then built upon it further and dubbed
    it NTLM when it introduced Windows NT. In the latest versions of Windows, there
    are three variants of NTLM in use:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM源自于*LAN Manager (LM)*身份验证协议，LAN Manager操作系统支持Server Message Block (SMB)文件共享协议。Microsoft在Windows
    3.11（著名的Windows for Workgroups）中重新实现了该身份验证协议，随后进一步扩展并命名为NTLM，首次出现在Windows NT中。在最新版本的Windows中，使用了三种NTLM变体：
- en: '**NTLMv1    **The original NTLM version, introduced in Windows NT 3.1'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTLMv1    **原始的NTLM版本，首次在Windows NT 3.1中引入'
- en: '**NTLMv2    **A version of NTLM introduced in NT 4 Service Pack 4 that added
    additional security features'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTLMv2    **NTLM的一个版本，于NT 4服务包4中引入，增加了额外的安全功能'
- en: '**NTLMv2 Session    **NTLMv1, but with the additional security features from
    NTLMv2'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTLMv2会话    **NTLMv1，但具有NTLMv2的附加安全特性'
- en: We’ll focus on NTLMv2, the only version whose values are accepted by default
    on Windows Vista and above. You might still encounter NTLMv1 or NTLMv2 Session
    in mixed operating system environments (for example, when accessing Linux-based
    network storage devices), but in a modern Windows environment, these should be
    rare.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点介绍NTLMv2，这是唯一在Windows Vista及更高版本中默认接受的版本。在混合操作系统环境中（例如，当访问基于Linux的网络存储设备时），你仍然可能会遇到NTLMv1或NTLMv2会话，但在现代Windows环境中，这些情况应该是罕见的。
- en: '[Figure 13-1](chapter13.xhtml#fig13-1) shows an overview of the NTLM authentication
    process that occurs between a Windows client application and a Windows server.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-1](chapter13.xhtml#fig13-1)显示了发生在Windows客户端应用程序和Windows服务器之间的NTLM认证过程概览。'
- en: '![](../images/Figure13-1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: An overview of
    the NTLM authentication protocol</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-1：NTLM认证协议概览</samp>
- en: 'NTLM authentication begins when the client application makes a network connection
    to the server. The client and the server then exchange a sequence of binary *authentication
    tokens* generated by the LSAs on the two machines. For the NTLM, these tokens
    consist of three authentication messages: the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    message, which specifies which features the client supports ❶; the server’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> message, which selects
    one of the client’s features and provides a random challenge value to use in the
    exchange ❷; and the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    message, which contains a value that proves the client’s knowledge of the user’s
    password to the server ❸.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM认证从客户端应用程序与服务器建立网络连接开始。客户端和服务器随后交换一系列由两台机器上的LSA生成的二进制*认证令牌*。对于NTLM，这些令牌由三个认证消息组成：客户端的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>消息，它指定客户端支持的功能❶；服务器的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>消息，它选择客户端的一个功能并提供一个随机挑战值，用于交换过程中❷；以及客户端的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>消息，它包含一个证明客户端掌握用户密码的值❸。
- en: At a high level, the authentication process occurs between the two LSAs. However,
    it’s up to the application and server to transport these authentication tokens
    over some network protocol. Microsoft describes the authentication protocol in
    *MS-NLMP*, available online. The document omits some features, which I’ll point
    out as we walk through an example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，认证过程发生在两个LSA之间。然而，应用程序和服务器负责通过某些网络协议传输这些认证令牌。微软在*MS-NLMP*中描述了认证协议，该文档可以在线获得。文档省略了一些功能，我们将在讲解示例时指出这些功能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NTLM Authentication
    Using PowerShell</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用PowerShell进行NTLM认证</samp>
- en: Let’s perform network authentication using PowerShell so you can see what information
    the authentication tokens contain. We’ll use a local user account, though a domain
    account would work just as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用PowerShell进行网络认证，这样你就可以看到认证令牌包含的信息。我们将使用本地用户帐户，尽管域帐户同样可以正常工作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing the Client</samp>
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">初始化客户端</samp>
- en: The authentication process starts when the client application calls the Security
    Support Provider Interface (SSPI) API <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>.
    The system implements the SSPI APIs to abstract the authentication protocol implemented
    by a security package. This allows applications to more easily change the network
    authentication protocol they use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 认证过程在客户端应用程序调用安全支持提供程序接口（SSPI）API <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>时开始。系统实现SSPI
    API以抽象由安全包实现的认证协议。这使得应用程序更容易更改它们使用的网络认证协议。
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>
    API selects the security package used for network authentication and provides
    explicit credentials for the authentication if needed. It returns a handle for
    use by a second SSPI API, <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>,
    which uses the selected security package but executes in the LSA.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个<samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>
    API选择用于网络身份验证的安全包，并在需要时提供明确的身份验证凭据。它返回一个句柄，供第二个SSPI API <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>使用，该API使用选定的安全包，但在LSA中执行。
- en: The security package in the LSA processes <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>,
    then requests and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    authentication token to the caller. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token describes which authentication features the client supports and should be
    sent to the server over the network protocol. [Listing 13-1](chapter13.xhtml#Lis13-1)
    performs this client initialization in PowerShell.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: LSA中的安全包处理<samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>，然后请求并返回一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>身份验证令牌给调用者。<samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>令牌描述客户端支持的身份验证功能，并应通过网络协议发送到服务器。[列表13-1](chapter13.xhtml#Lis13-1)在PowerShell中执行此客户端初始化。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 13-1: Initializing a client for NTLM authentication and formatting
    a NEGOTIATE authentication token'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-1：初始化NTLM身份验证的客户端并格式化NEGOTIATE身份验证令牌
- en: We start by getting the credentials handle using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>
    command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>.
    By specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Package</samp> parameter, we
    select the use of the NTLM security package. We also specify that these credentials
    are for outbound authentication (that is, from a client to a server). Lastly,
    we specify the username and domain from the current environment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>命令来获取凭据句柄，该命令调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>。通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Package</samp>参数指定<samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp>，我们选择使用NTLM安全包。我们还指定这些凭据用于出站身份验证（即从客户端到服务器）。最后，我们指定当前环境中的用户名和域。
- en: Notice that we do not specify a password; this is because the LSA has already
    cached the password for us in our logon session. The fact that we don’t need to
    specify the password is a key part of *Integrated Windows Authentication (IWA)*,
    which allows users to automatically authenticate to the network authentication
    using their credentials, without prompting them for a password.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有指定密码；这是因为LSA已经在我们的登录会话中缓存了密码。我们不需要指定密码这一事实是*集成 Windows 身份验证（IWA）*的关键部分，它允许用户自动使用其凭据进行网络身份验证，而无需提示他们输入密码。
- en: With the credentials handle, we create a client authentication context by calling
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>
    command and specifying the handle. Under the hood, this command calls the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp> API.
    If the call to the API succeeds, the client context now contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token. We store a copy of the token for later use, then pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    command to parse its contents and print them to the shell.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用凭据句柄，我们通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>命令并指定该句柄来创建客户端身份验证上下文。在后台，此命令调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp> API。如果对API的调用成功，客户端上下文现在包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>令牌。我们存储该令牌的副本以备后用，然后将其传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>命令，以解析其内容并将其打印到Shell中。
- en: The main component of the token is a list of flags that reflect the features
    the client requests, the features the client supports, and which parts of the
    token are valid. In this case, the token has nine flags set, though these can
    change depending on the system’s configuration. [Table 13-1](chapter13.xhtml#tab13-1)
    shows what the flags mean in this context.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的主要组成部分是一个标志列表，反映了客户端请求的功能、客户端支持的功能以及令牌的有效部分。在这种情况下，令牌设置了九个标志，尽管这些标志会根据系统配置的不同而变化。[表
    13-1](chapter13.xhtml#tab13-1)展示了这些标志在此上下文中的含义。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-1:</samp> <samp class="SANS_Futura_Std_Book_11">Select
    NTLM Flags</samp>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-1：</samp> <samp class="SANS_Futura_Std_Book_11">选择
    NTLM 标志</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">标志名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client supports Unicode strings.</samp> |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp> | <samp class="SANS_Futura_Std_Book_11">客户端支持
    Unicode 字符串。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client supports byte character strings (for example, ASCII).</samp> |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> | <samp class="SANS_Futura_Std_Book_11">客户端支持字节字符字符串（例如，ASCII）。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestTarget</samp> | <samp
    class="SANS_Futura_Std_Book_11">The client requires the server to send a target
    name in the response.</samp> |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestTarget</samp> | <samp
    class="SANS_Futura_Std_Book_11">客户端要求服务器在响应中发送目标名称。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests to use the NTLM hash.</samp> |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> | <samp class="SANS_Futura_Std_Book_11">客户端请求使用
    NTLM 哈希。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AlwaysSign</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests that the authentication be signed to ensure integrity.</samp>
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AlwaysSign</samp> | <samp class="SANS_Futura_Std_Book_11">客户端请求对身份验证进行签名以确保完整性。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    | <samp class="SANS_Futura_Std_Book_11">The client requests NTLMv2 Session security.</samp>
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    | <samp class="SANS_Futura_Std_Book_11">客户端请求 NTLMv2 会话安全性。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client has sent the operating system and NTLM protocol version.</samp> |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp> | <samp class="SANS_Futura_Std_Book_11">客户端已发送操作系统和
    NTLM 协议版本。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests a 128-bit signing key.</samp> |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp> | <samp class="SANS_Futura_Std_Book_11">客户端请求
    128 位签名密钥。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests a 56-bit signing key.</samp> |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp> | <samp class="SANS_Futura_Std_Book_11">客户端请求
    56 位签名密钥。</samp> |'
- en: You might wonder why the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    flag is set. This flag changes NTLMv1 to NTLMv2 Session security, but I mentioned
    earlier that NTLMv1 is disabled by default. The LSA sets the flag anyway, just
    in case the server responds with a request for NTLMv1\. Except for <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp>,
    these flags all indicate the features the client requires. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp>
    flag indicates major, minor, and build values of the operating system version,
    as well as the NTLM protocol version, which has been fixed at 15 since Windows
    Server 2003.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么设置了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    标志。这个标志将 NTLMv1 更改为 NTLMv2 会话安全性，但我之前提到过 NTLMv1 默认情况下是禁用的。尽管如此，LSA 还是会设置这个标志，以防服务器响应
    NTLMv1 请求。除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp> 之外，这些标志都表示客户端所要求的功能。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Version</samp> 标志表示操作系统版本的主版本号、次版本号和构建值，以及
    NTLM 协议版本，自 Windows Server 2003 起已固定为 15。
- en: To ensure the integrity of the authentication protocol, NTLM generates an encryption
    key based on the values in the exchange, then uses it to apply a *message integrity
    code (MIC)* to the entire exchange. A MIC is a cryptographic hash of the authentication
    tokens sent and received in the current exchange. It’s used to detect whether
    the authentication tokens have been tampered with over the network.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保身份验证协议的完整性，NTLM 基于交换中的值生成加密密钥，然后使用该密钥为整个交换应用*消息完整性码（MIC）*。MIC 是当前交换中发送和接收的身份验证令牌的加密哈希值，用于检测身份验证令牌在网络中是否被篡改。
- en: Due to cryptography export restrictions, NTLM supports 40-bit keys as well as
    56-bit and 128-bit keys, based on the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp> flags. If neither
    flag is set, NTLM will use 40-bit keys. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    command hides the underlying binary value of the authentication token, but to
    see the token in hex we can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsBytes</samp>
    parameter to this command, as shown in [Listing 13-2](chapter13.xhtml#Lis13-2).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加密出口限制，NTLM 支持 40 位密钥、56 位密钥和 128 位密钥，具体取决于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp> 标志是否存在。如果这两个标志都未设置，NTLM
    将使用 40 位密钥。<samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    命令隐藏了身份验证令牌的底层二进制值，但为了查看十六进制格式的令牌，我们可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">AsBytes</samp>
    参数传递给该命令，如[示例 13-2](chapter13.xhtml#Lis13-2)所示。
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 13-2: Formatting the authentication token in hex'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-2：以十六进制格式显示身份验证令牌
- en: In hex, we can see the data has a format indicator at the beginning of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NTLMSSP</samp> ❶. If you see this indicator
    in data you’re analyzing, there’s a good chance you’ve come across an NTLM network
    authentication process. I won’t display the hex of the rest of the tokens, as
    it’s easy enough to change the script to view the hex output if you’re interested
    in doing so.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制格式中，我们可以看到数据的开头有一个格式指示符 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLMSSP</samp>
    ❶。如果你在分析的数据中看到这个指示符，很可能你遇到了 NTLM 网络身份验证过程。我不会显示其余令牌的十六进制内容，因为如果你有兴趣，修改脚本以查看十六进制输出是非常容易的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing the Server</samp>
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">初始化服务器</samp>
- en: The client has initialized its authentication context and generated a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token. Now it must send
    this token to the server application so that it can initialize its own authentication
    context. When the server receives the token, it passes it to the LSA using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp> API.
    The LSA inspects the token, determines whether it supports the requested features,
    and generates a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    authentication token in response. This token allows the server to verify that
    the client isn’t replaying values captured from a previous authentication exchange.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端已初始化其身份验证上下文并生成了 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    令牌。现在，它必须将此令牌发送给服务器应用程序，以便服务器可以初始化其自身的身份验证上下文。当服务器收到令牌时，它会通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>
    API 将其传递给 LSA。LSA 检查令牌，确定是否支持请求的功能，并生成 <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    身份验证令牌作为响应。此令牌允许服务器验证客户端是否没有重放从先前身份验证交换中捕获的值。
- en: Let’s use PowerShell to demonstrate the server’s handling of NTLM. In [Listing
    13-3](chapter13.xhtml#Lis13-3), we create the server authentication context in
    the same process as the client’s (remember, however, that the server will typically
    run on a different system).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 PowerShell 演示服务器如何处理 NTLM。在[示例 13-3](chapter13.xhtml#Lis13-3)中，我们在与客户端相同的进程中创建服务器身份验证上下文（但请记住，服务器通常会运行在不同的系统上）。
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 13-3: Initializing the server for NTLM authentication and formatting
    the CHALLENGE authentication token'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-3：初始化 NTLM 身份验证服务器并格式化 CHALLENGE 身份验证令牌
- en: We start by creating the inbound credentials handle. You don’t need to provide
    any credentials to do this; in fact, NTLM would ignore the credentials even if
    you did provide them. Next, we create the server’s authentication context and
    provide the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>
    API by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    PowerShell command. If the LSA accepts the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token, the server context will include its own token, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token. As before, we capture the token for later use and pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    to print out the information it contains.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建入站凭据句柄。创建此句柄时无需提供任何凭据；事实上，即使您提供了凭据，NTLM 也会忽略它们。接下来，我们创建服务器的认证上下文，并通过调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp> PowerShell
    命令，将客户端的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> 令牌提供给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp> API。如果
    LSA 接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> 令牌，服务器上下文将包含其自身的令牌，即
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> 令牌。如前所述，我们捕获该令牌以供后续使用，并将其传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp> 来打印出其中包含的信息。
- en: The token’s flags represent the values that the network authentication process
    supports and are based on the flags the client sent. For example, in [Listing
    13-1](chapter13.xhtml#Lis13-1) we saw that the client set both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp> string format
    flags in its <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token,
    indicating that it can support both Unicode and byte character format strings.
    The server has elected to send strings in Unicode format, so it has cleared the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> flag in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的标志表示网络认证过程支持的值，并且基于客户端发送的标志。例如，在 [Listing 13-1](chapter13.xhtml#Lis13-1)
    中，我们看到客户端在其 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> 令牌中设置了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp>
    字符串格式标志，表示它可以支持 Unicode 和字节字符格式字符串。服务器选择以 Unicode 格式发送字符串，因此它在 <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    令牌中清除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> 标志。
- en: As requested by the client, the output also contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>,
    which in this case is the domain name of the server, indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeDomain</samp>
    flag. If the server were not in a domain network, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>
    would be the server’s computer name, and the token would use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeServer</samp>
    flag instead.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据客户端的要求，输出中还包含了 <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>，在此情况下，它是服务器的域名，由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeDomain</samp> 标志指示。如果服务器不在域网络中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp> 将是服务器的计算机名称，令牌将使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeServer</samp> 标志。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token contains
    a random 8-byte server challenge generated by the LSA. All values calculated in
    the next step depend on the challenge’s value; because it’s different for every
    request, this prevents an attacker from capturing a previous authentication exchange
    and replaying it to the server. The final part of the token is the target information,
    indicated by the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetInfo</samp>
    flag. This contains additional details about the server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> 令牌包含由 LSA 生成的随机
    8 字节服务器挑战。接下来的步骤中计算的所有值都依赖于挑战值；由于它对于每个请求都是不同的，这就防止了攻击者捕获先前的认证交换并将其重放到服务器上。令牌的最后部分是目标信息，通过存在的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetInfo</samp> 标志来表示。这部分包含有关服务器的附加信息。
- en: Note that NTLM can work in a connectionless mode, in which the client never
    sends the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    message. In this case, the authentication process starts with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    message from the server. However, connectionless NTLM authentication is rarely
    used in practice.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，NTLM可以在无连接模式下工作，在这种模式下，客户端永远不会发送初始的<samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>消息。在这种情况下，认证过程从服务器发送的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>消息开始。然而，无连接NTLM认证在实际应用中很少使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Passing the Token Back to
    the Client</samp>
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将令牌传回客户端</samp>
- en: Next, the server must send the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token to the client’s authentication context. In a real network protocol, this
    would happen over the network, but in [Listing 13-4](chapter13.xhtml#Lis13-4)
    we pass the token in the same script.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，服务器必须将<samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>令牌发送到客户端的认证上下文。在实际的网络协议中，这将在网络上发生，但在[列表13-4](chapter13.xhtml#Lis13-4)中，我们将令牌传递到相同的脚本中。
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 13-4: Updating the client for NTLM authentication and formatting the
    AUTHENTICATE token'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-4：为NTLM认证更新客户端并格式化AUTHENTICATE令牌
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaClientContext</samp>
    command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    once again with the original credentials handle and the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token. If <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    accepts the token, the LSA generates the final <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token, which we can then format. This is the only token that depends on the value
    of the password; the other two tokens can be generated without any special knowledge.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaClientContext</samp>命令，它再次调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>，并使用原始的凭证句柄和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>令牌。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>接受该令牌，LSA将生成最终的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌，然后我们可以对其进行格式化。这是唯一一个依赖于密码值的令牌；其他两个令牌则可以在没有任何特殊知识的情况下生成。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token
    starts with the final negotiated flags and the information about the user, including
    their username and domain. Because we’re using a local account, the domain is
    set to the workstation name, <samp class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>.
    Next comes the LM response, which in this case is all zeros ❶. The LM response
    is normally disabled, which is why it’s not specified, and NTLMv2 doesn’t use
    the LM hash at all.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌以最终商定的标志和有关用户的信息开始，包括他们的用户名和域。因为我们使用的是本地账户，域被设置为工作站名称<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>。接下来是LM响应，在本例中是全零❶。LM响应通常被禁用，这就是为什么它没有被指定，而NTLMv2根本不使用LM哈希。
- en: We now continue to the full NTLMv2 response, which contains a lot of information.
    First is the 8-byte NT response ❷, also called the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTProofStr</samp>
    in the protocol’s documentation. We’ll come back to how this value is calculated
    in a moment. After the NT response are various parameters about the protocol,
    including the 8-byte client challenge ❸. NTLMv1 already contained the server challenge
    to prevent replay, but NTLMv2 added the client challenge to make it harder for
    an attacker to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to crack the user’s password.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们继续讲解完整的NTLMv2响应，它包含了大量的信息。首先是8字节的NT响应❷，也叫做协议文档中的<samp class="SANS_TheSansMonoCd_W5Regular_11">NTProofStr</samp>。稍后我们将回顾这个值是如何计算的。在NT响应之后，是一些关于协议的其他参数，包括8字节的客户端挑战❸。NTLMv1已经包含了服务器挑战，以防止重放攻击，但NTLMv2增加了客户端挑战，使得攻击者更难使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌破解用户的密码。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token
    copies most of its target information from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    message, although it contains a few additional entries. The flags indicate that
    the message contains a MIC with the <samp class="SANS_TheSansMonoCd_W5Regular_11">MessageIntegrity</samp>
    value ❹, as you’ll soon see. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleHost</samp>
    flag contains a random ID for the client machine that generated the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token ❺. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp> ❻ values are
    used to prevent credential relaying, an attack we’ll also come back to later;
    in this case, the flags aren’t specified. Last is the MIC, a keyed MD5 hash-based
    message authentication code (HMAC) calculated over the authentication tokens sent
    and received for the current exchange ❼. The key for the hash is calculated during
    the authentication process, and the MIC serves to detect whether the tokens have
    been tampered with.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌从<samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>消息复制了大部分目标信息，尽管它还包含了一些额外的条目。标志位表明该消息包含了带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MessageIntegrity</samp>值❹的MIC，正如你将很快看到的那样。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SingleHost</samp>标志包含了生成<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌的客户端机器的随机ID❺。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>❻值用于防止凭证转发攻击，我们稍后也会讲到；在这种情况下，标志未指定。最后是MIC，它是一个基于MD5哈希的消息认证码（HMAC），该码是通过对当前交换中发送和接收的认证令牌进行计算得到的❼。哈希的密钥是在认证过程中计算出来的，而MIC用于检测令牌是否被篡改。
- en: The client sends the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to the server, which again calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>,
    passing it the token. The LSA runs the calculations needed to verify that the
    NT response matches the expected value and that the MIC is valid, indicating the
    tokens haven’t been tampered with. If both values match the expected values, the
    authentication succeeds.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌发送到服务器，服务器再次调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>，并将令牌传递给它。LSA运行所需的计算，以验证NT响应是否与预期值匹配，以及MIC是否有效，指示令牌没有被篡改。如果两个值与预期的值匹配，则认证成功。
- en: 'There are several differences between the formatted output generated by NTLMv1
    and NTLMv2\. First, if NTLMv1 is in use, the NT response in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token will be a 24-byte binary value rather than the structured response seen
    in [Listing 13-4](chapter13.xhtml#Lis13-4). For example, it might look like the
    following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: NTLMv1和NTLMv2生成的格式化输出之间有几个不同之处。首先，如果使用的是NTLMv1，那么<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌中的NT响应将是一个24字节的二进制值，而不是[示例13-4](chapter13.xhtml#Lis13-4)中看到的结构化响应。例如，它可能如下所示：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also differentiate between NTLMv1 and NTLMv2 Session by looking at
    the flags and LM hash. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    flag is set, you know that NTLMv2 Session is in use; otherwise, the system is
    using NTLMv1\. The LM hash field gets repurposed to contain the client challenge
    in NTLMv2, which might confuse you, as you might assume an LM hash has been negotiated.
    You can tell the difference between a hash and a client challenge because the
    client challenge is only 8 bytes long, as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过查看标志位和LM哈希来区分NTLMv1和NTLMv2会话。如果设置了<samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>标志，你就知道正在使用NTLMv2会话；否则，系统正在使用NTLMv1。LM哈希字段在NTLMv2中被重新用于包含客户端挑战，这可能会让你感到困惑，因为你可能会误以为LM哈希已经进行了协商。你可以通过检查哈希和客户端挑战之间的区别来分辨两者，因为客户端挑战只有8字节长，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The remaining 16 bytes are padded with zeros.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的16个字节会被零填充。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Requesting a Token Object</samp>
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">请求令牌对象</samp>
- en: Now that the authentication process has completed, the server can request that
    the LSA generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object for the authenticated user through the <samp class="SANS_TheSansMonoCd_W5Regular_11">QuerySecurityContextToken</samp>
    API, as shown in [Listing 13-5](chapter13.xhtml#Lis13-5).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在身份验证过程已完成，服务器可以请求 LSA 通过<samp class="SANS_TheSansMonoCd_W5Regular_11">QuerySecurityContextToken</samp>
    API 为已验证的用户生成一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象，如[清单
    13-5](chapter13.xhtml#Lis13-5)所示。
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 13-5: Completing the NTLM authentication process'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-5：完成 NTLM 身份验证过程
- en: We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    again to finalize the authentication process. Once all tokens have been transferred,
    the client and server contexts are placed into a *done state*, meaning they no
    longer need any more information to complete the authentication process. You can
    verify this state using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContext</samp>
    command.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先再次调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>来完成身份验证过程。一旦所有令牌被传输，客户端和服务器上下文将进入*完成状态*，这意味着它们不再需要任何其他信息来完成身份验证过程。你可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContext</samp>命令来验证这个状态。
- en: With the authentication completed, we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaAccessToken</samp>
    command to return the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object for the user. We display the logon session for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    and verify that it used network authentication.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完成身份验证后，我们可以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaAccessToken</samp>命令，返回用户的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象。我们显示该<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>的登录会话，并验证它是否使用了网络身份验证。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Cryptographic
    Derivation Process</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加密派生过程</samp>
- en: The NTLM process never discloses the user’s password in plaintext on the network.
    Even so, NTLM uses the password’s value to derive the final NT response and MIC.
    Let’s use PowerShell to walk through this cryptographic derivation process and
    generate the NT response and MIC. To perform the derivation, we’ll need the user’s
    password, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> authentication
    tokens.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM 过程从不在网络上传输用户的明文密码。尽管如此，NTLM 仍然使用密码的值来派生最终的 NT 响应和 MIC。让我们使用 PowerShell
    来逐步演示这个加密派生过程，并生成 NT 响应和 MIC。为了进行派生，我们需要用户的密码，以及<samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>身份验证令牌。
- en: We also need a function that calculates the MD5 HMAC for a set of bytes. The
    MD5 HMAC is a keyed cryptographic hashing algorithm commonly used to sign data
    so its integrity can be verified. We’ll use this function, defined in [Listing
    13-6](chapter13.xhtml#Lis13-6), multiple times in the derivation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来计算一组字节的 MD5 HMAC。MD5 HMAC 是一种带密钥的加密哈希算法，通常用于签名数据，以便验证其完整性。在派生过程中，我们将多次使用此函数，定义在[清单
    13-6](chapter13.xhtml#Lis13-6)中。
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 13-6: Defining the Get-Md5Hmac function'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-6：定义 Get-Md5Hmac 函数
- en: 'The function is simple: it creates the .NET class <samp class="SANS_TheSansMonoCd_W5Regular_11">HMACMD5</samp>,
    passing it a key ❶, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ComputeHash</samp>
    on the data ❷. If the data is a string, it first converts it to a byte array in
    Unicode encoding.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很简单：它创建了一个 .NET 类<samp class="SANS_TheSansMonoCd_W5Regular_11">HMACMD5</samp>，并传递给它一个密钥
    ❶，然后对数据 ❷调用<samp class="SANS_TheSansMonoCd_W5Regular_11">ComputeHash</samp>。如果数据是一个字符串，它首先会将其转换为
    Unicode 编码的字节数组。
- en: The next function we define calculates the *NT one-way function version 2 (NTOWFv2)*,
    shown in [Listing 13-7](chapter13.xhtml#Lis13-7). This function converts the username,
    domain, and password into a 16-byte key for further use.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的下一个函数计算*NT 单向函数版本 2 (NTOWFv2)*，如[清单 13-7](chapter13.xhtml#Lis13-7)所示。此函数将用户名、域名和密码转换为一个
    16 字节的密钥，供进一步使用。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 13-7: Defining the NT one-way function'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-7：定义 NT 单向函数
- en: First, note that the system hashes the password using the MD4 algorithm ❶. As
    mentioned previously, the SAM database stores these MD4 hashes so that the LSA
    doesn’t need to store their plaintext versions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意系统使用 MD4 算法对密码进行哈希 ❶。如前所述，SAM 数据库存储这些 MD4 哈希，以便 LSA 不需要存储其明文版本。
- en: We supply the MD4 hash of the password as a key to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>
    function, then use this function to hash the uppercase username concatenated to
    the domain ❷. In this case, these values are <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>, so we hash
    the string <samp class="SANS_TheSansMonoCd_W5Regular_11">USERGRAPHITE</samp>.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将密码的MD4哈希作为密钥提供给<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>函数，然后使用此函数对与域名连接的用户名的大写形式进行哈希
    ❷。在此情况下，这些值为<samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>，因此我们对字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">USERGRAPHITE</samp>进行哈希。
- en: To perform this operation, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtOwfv2</samp>
    function we just defined with the username and domain from the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token ❸, which we stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">$authToken</samp>
    variable. The function produces a 16-byte key ❹.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为执行此操作，我们调用刚刚定义的<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtOwfv2</samp>函数，传入来自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>标记的用户名和域名 ❸，这些值我们存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">$authToken</samp>变量中。该函数会生成一个16字节的密钥 ❹。
- en: Now that we have a key based on the user’s password, we’ll use it to calculate
    the NT response value with the function defined in [Listing 13-8](chapter13.xhtml#Lis13-8).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基于用户密码的密钥，我们将使用它通过[Listing 13-8](chapter13.xhtml#Lis13-8)中定义的函数计算NT响应值。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 13-8: Calculating the NtProofStr value'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-8：计算NtProofStr值
- en: We perform the calculation of the NT response using the NTOWFv2 key as well
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> tokens. First we concatenate
    the 8-byte server challenge from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtChallengeResponse</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token,
    minus the supplied 16-byte NT response ❶. Then we calculate the NT value using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp> function,
    with NTOWFv2 as the key ❷. The result ❸ should match the NT response value from
    [Listing 13-4](chapter13.xhtml#Lis13-4) (if you used your actual password rather
    than the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">pwd</samp> placeholder
    used in the listing).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用NTOWFv2密钥以及<samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>标记进行NT响应计算。首先，我们将来自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>标记的8字节服务器挑战与来自<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>标记的<NtChallengeResponse>进行连接，减去提供的16字节NT响应
    ❶。然后，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>函数计算NT值，密钥为NTOWFv2
    ❷。结果 ❸ 应该与[Listing 13-4](chapter13.xhtml#Lis13-4)中的NT响应值匹配（如果您使用的是实际密码而不是列表中使用的<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">pwd</samp>占位符）。
- en: The server can now verify that the client has access to the correct password
    for the user by checking whether the two NT response values match. However, we
    still want to verify that the messages haven’t been tampered with in some way,
    so we need to calculate the MIC. We define the function to do this in [Listing
    13-9](chapter13.xhtml#Lis13-9).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器现在可以通过检查两个NT响应值是否匹配来验证客户端是否有权访问用户的正确密码。然而，我们仍然希望验证消息是否未被以某种方式篡改，因此我们需要计算MIC。我们在[Listing
    13-9](chapter13.xhtml#Lis13-9)中定义了执行此操作的函数。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 13-9: Calculating the message integrity code'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-9：计算消息完整性代码
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp> function takes
    five parameters: the NTOWFv2 key, the NT response, and all three tokens transmitted
    back and forth between the client and server. The first task is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>
    again to calculate a session key ❶. We use the NTOWFv2 key for this HMAC operation
    and supply the NT response as data. Next, we zero the MIC field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token ❷, then concatenate the tokens ❸. We pass the session key and the concatenated
    tokens to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp> to
    generate the MIC ❹. The value of the MIC ❺ should match the one generated in [Listing
    13-4](chapter13.xhtml#Lis13-4).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp> 函数接受五个参数：NTOWFv2
    密钥、NT 响应以及客户端与服务器之间传递的所有三个令牌。首先的任务是再次使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>
    来计算会话密钥 ❶。我们使用 NTOWFv2 密钥进行该 HMAC 操作，并提供 NT 响应作为数据。接下来，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌中的 MIC 字段置为零 ❷，然后将令牌连接起来 ❸。我们将会话密钥和连接后的令牌传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>
    来生成 MIC ❹。MIC 的值 ❺ 应该与在 [清单 13-4](chapter13.xhtml#Lis13-4) 中生成的值相匹配。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pass-Through Authentication</samp>
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">透传认证</samp>
- en: For the client and server to successfully authenticate using NTLM, both parties
    must know the user’s password (or, more precisely, its NT hash). If you’re authenticating
    to a stand-alone machine, the password must be set in the machine’s local SAM
    database. Configuring this value isn’t too difficult in a small network, but on
    a large network consisting of many machines, doing it manually becomes unmanageable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使客户端和服务器能够成功地使用 NTLM 进行认证，双方必须知道用户的密码（或者，更准确地说，是其 NT 哈希值）。如果你正在对一个独立的机器进行认证，密码必须设置在该机器的本地
    SAM 数据库中。在一个小型网络中配置这个值并不困难，但在一个由许多机器组成的大型网络中，手动进行此操作变得难以管理。
- en: On a domain network, the domain controller is responsible for managing the user’s
    NT hash. So how can NTLM function in such an environment? The Netlogon service
    on the domain controller supports the concept of *pass-through authentication*
    to facilitate NTLM authentication on other systems in the domain. [Figure 13-2](chapter13.xhtml#fig13-2)
    provides an example of the NTLM authentication process in a domain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在域网络中，域控制器负责管理用户的 NT 哈希值。那么，NTLM 如何在这样的环境中工作呢？域控制器上的 Netlogon 服务支持 *透传认证* 概念，以便在域内的其他系统上促进
    NTLM 认证。[图 13-2](chapter13.xhtml#fig13-2) 提供了域中 NTLM 认证过程的示例。
- en: '![](../images/Figure13-2.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: An overview of
    NTLM pass-through authentication</samp>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-2：NTLM 透传认证概述</samp>
- en: 'The NTLM authentication process begins normally: the client sends the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token to the server ❶,
    which generates a challenge and returns it to the client in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token ❷. The client then uses the user’s NT hash to generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token and sends it to the server ❸.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM 认证过程正常开始：客户端将 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    令牌发送到服务器 ❶，服务器生成挑战并通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    令牌返回给客户端 ❷。然后客户端使用用户的 NT 哈希值生成 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌，并将其发送到服务器 ❸。
- en: At this point, problems arise. The server doesn’t have the user’s NT hash, so
    it can’t derive necessary cryptographic values such as the NT challenge. Therefore,
    the server packages up the server challenge and the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token and sends these to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp>
    API on the domain controller ❹. You might recall from [Chapter 12](chapter12.xhtml)
    that Windows uses this API for interactive authentication. The API has multiple
    modes, one of which can verify the NTLM authentication values without needing
    the user’s password.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，问题出现了。服务器没有用户的 NT 哈希值，因此无法推导出必要的加密值，例如 NT 挑战。因此，服务器将服务器挑战和 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌打包，并将其发送到域控制器上的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp>
    API ❹。你可能还记得在[第 12 章](chapter12.xhtml)中，Windows 使用该 API 进行交互式认证。该 API 有多种模式，其中一种可以在不需要用户密码的情况下验证
    NTLM 认证值。
- en: Note that the domain controller doesn’t verify the MIC, as this requires all
    three authentication tokens. Instead, the server calculates the session key used
    for verification based on the user’s NT hash and NT challenge value and returns
    it to the requesting server. This allows it to ensure that the authentication
    hasn’t been tampered with.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，域控制器不会验证 MIC，因为这需要所有三个身份验证令牌。相反，服务器根据用户的 NT 哈希值和 NT 挑战值计算用于验证的会话密钥，并将其返回给请求的服务器。这使得服务器能够确保身份验证没有被篡改。
- en: 'The Windows server never has access to the user’s full password or NT hash,
    only the session key. This results in the *double hop problem*: the authenticated
    user can access resources stored locally on the server, but that user cannot be
    used to access resources on other servers on the domain network.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 服务器从未能够访问用户的完整密码或 NT 哈希值，只有会话密钥。这导致了*双跳问题*：经过身份验证的用户可以访问服务器上本地存储的资源，但该用户不能用于访问域网络中其他服务器上的资源。
- en: From a security perspective, this is a good thing, as it prevents a malicious
    service from repurposing a user’s identity. However, it also reduces flexibility,
    as it means that you can’t trivially implement an authenticated proxying service
    without requiring the user to reauthenticate to each service behind that proxy.
    Kerberos solves the double hop problem using delegation, as I’ll describe in more
    detail in [Chapter 14](chapter14.xhtml).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，这是件好事，因为它防止恶意服务重用用户的身份。然而，这也减少了灵活性，因为这意味着你无法轻松实现一个认证代理服务而不要求用户在该代理后面的每个服务中重新认证。Kerberos
    通过委托解决了双跳问题，正如我在[第 14 章](chapter14.xhtml)中会更详细地描述的那样。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Loopback Authentication</samp>
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">本地回环认证</samp>
- en: 'In the previous example, I chose to specify a username and domain when getting
    the outbound authentication credentials handle. While Integrated Windows Authentication
    doesn’t require you to specify either a username or a domain, you need to do so
    if you want to create a network logon session on the local machine. Let’s change
    the script in [Listing 13-1](chapter13.xhtml#Lis13-1) to build the outbound credentials
    without a username or domain:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我选择在获取出站身份验证凭据句柄时指定了用户名和域。虽然集成 Windows 认证并不要求你指定用户名或域，但如果你想在本地机器上创建网络登录会话，则需要这样做。让我们更改[列表
    13-1](chapter13.xhtml#Lis13-1)中的脚本，以便在没有用户名或域的情况下构建出站凭据：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now rerun the authentication session. The formatted tokens should look like
    those in [Listing 13-10](chapter13.xhtml#Lis13-10).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行认证会话。格式化后的令牌应与[列表 13-10](chapter13.xhtml#Lis13-10)中的令牌类似。
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 13-10: The formatted tokens from a local loopback authentication'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-10：来自本地回环认证的格式化令牌
- en: 'You might notice that all three authentication tokens have changed. The first
    change is in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token, which now contains a domain name and workstation name ❶. The next changes
    are in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token:
    a new flag has appeared, <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    ❷, and a previously zeroed <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserved</samp>
    field now has a value ❸. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag signifies that the authentication comes from the local machine, while the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserved</samp> field is a unique
    identifier for the server security context that created the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，所有三个身份验证令牌已经发生变化。第一个变化出现在<samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>令牌中，它现在包含了域名和工作站名称❶。接下来的变化出现在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>令牌中：出现了一个新的标志，<samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>❷，并且之前为零的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Reserved</samp>字段现在有了一个值❸。<samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>标志表示身份验证来自本地机器，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Reserved</samp>字段是创建<samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>令牌的服务器安全上下文的唯一标识符。
- en: The final changes are in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token. While the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag is still present ❹, both the <samp class="SANS_TheSansMonoCd_W5Regular_11">LM
    Response</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NT Response</samp>
    fields are completely empty ❺. This clearly signifies that the authentication
    process has changed. If we check the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s logon session, we see that it’s an interactive session instead of a network
    session ❻. The reason for this is that the LSA has returned a copy of the caller’s
    token to the server, as you can see by comparing the logon ID to the authentication
    ID from the effective token ❼.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改出现在<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌中。尽管<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>标志仍然存在❹，但<samp class="SANS_TheSansMonoCd_W5Regular_11">LM
    Response</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">NT Response</samp>字段完全为空❺。这清楚地表明认证过程已发生变化。如果我们检查最终<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象的登录会话，会发现它是交互式会话，而非网络会话❻。原因在于LSA已将调用者的令牌副本返回给服务器，正如通过比较登录ID与有效令牌中的认证ID所看到的❼。
- en: Let’s take a closer look at the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag. Its value is based on the domain and workstation names in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    authentication token. If these values refer to the local machine, local loopback
    authentication is enabled. There are no other unique identifiers in the initial
    token to key the flag on, and there doesn’t need to be an ongoing outbound authentication
    process for the flag to be selected. Also, the flag is not specified in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token’s flags, so it’s
    not negotiated between the client and server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下<samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>标志。它的值基于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>认证令牌中的域名和工作站名称。如果这些值指向本地机器，则启用本地回环认证。初始令牌中没有其他唯一标识符来设定该标志，且不需要进行持续的外向认证过程来选择该标志。此外，该标志并未在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>令牌的标志中指定，因此它不会在客户端和服务器之间进行协商。
- en: At the time of writing, Microsoft does not document the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag in *MS-NLMP*, presumably because it shouldn’t be supported outside of the
    local machine. However, as you can see, merely providing the right <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token causes local loopback authentication to kick in. Documenting this flag would
    make it easier to diagnose authentication failures that could occur if the flag
    were present over the network.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，微软并未在*MS-NLMP*中文档化<samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>标志，可能是因为它不应该在本地机器之外被支持。然而，正如您所看到的，仅仅提供正确的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>令牌就会触发本地回环认证。文档化该标志可以更容易地诊断可能在网络中出现的认证失败问题。
- en: Why does the LSA implement local loopback authentication? One reason is that
    network authentication would cause the user to be reauthenticated, and some local
    services, such as SMB, allow local interactive users, but not network users, to
    access file shares. Therefore, this local loopback allows the SMB server to see
    a local user and grant access.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么LSA要实现本地回环认证？一个原因是网络认证会导致用户被重新认证，而一些本地服务，如SMB，允许本地交互式用户访问文件共享，但不允许网络用户访问。因此，这种本地回环使得SMB服务器能够看到本地用户并授予访问权限。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Alternative Client
    Credentials</samp>
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">替代客户端凭证</samp>
- en: We’ve seen how to use PowerShell commands to authenticate as the calling user.
    This is normally the behavior you’ll want to implement, as the current user typically
    aims to access some network resource as themselves. However, the underlying APIs
    support several mechanisms that allow you to authenticate as a different user
    over the network. Changing your user identity is useful because it enables you
    to access a network resource without reauthenticating interactively.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用PowerShell命令以调用用户的身份进行认证。这通常是您希望实现的行为，因为当前用户通常旨在以自己身份访问一些网络资源。然而，底层API支持几种机制，允许您通过网络以不同用户的身份进行认证。更改用户身份非常有用，因为它使您能够在不进行交互式重新认证的情况下访问网络资源。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Explicit Credentials</samp>
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用显式凭据</samp>
- en: If you know the new user’s full credentials, you can specify them when creating
    the credentials handle for the client authentication context. To do this, call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp> and
    pass it the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Domain</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Password</samp>
    parameters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道新用户的完整凭据，可以在为客户端身份验证上下文创建凭据句柄时指定这些凭据。为此，调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>
    并传入 <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Domain</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Password</samp> 参数。
- en: However, you probably don’t want to leave a user’s password in PowerShell’s
    command history. One alternative is to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadCredential</samp>
    parameter, which will read the credentials from the user without storing them
    in the command history. [Listing 13-11](chapter13.xhtml#Lis13-11) shows an example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能不希望将用户的密码留在 PowerShell 的命令历史记录中。一种替代方法是指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadCredential</samp>
    参数，该参数会在不将凭据存储在命令历史中的情况下从用户那里读取凭据。[清单 13-11](chapter13.xhtml#Lis13-11) 显示了一个示例。
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 13-11: Creating a credentials handle with user-specified credentials'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-11：使用用户指定的凭据创建凭据句柄
- en: You can now pass the credentials handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>
    to create the client context. You don’t need to change the server side, which
    uses the credentials managed by the LSA.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将凭据句柄传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>
    来创建客户端上下文。你不需要更改服务器端，它将使用 LSA 管理的凭据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Impersonating a Token</samp>
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">模拟一个令牌</samp>
- en: When creating the credentials handle, the LSA usually determines the network
    credentials to use based on the calling user’s identity, which it retrieves from
    the primary token of the process that calls the SSPI API. However, if you have
    a different user’s token, you can impersonate them while creating the credentials
    handle to use a different identity. Run the command in [Listing 13-12](chapter13.xhtml#Lis13-12)
    as an administrator.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建凭据句柄时，LSA 通常根据调用 SSPI API 的进程的主令牌来确定要使用的网络凭据。不过，如果你有其他用户的令牌，你可以在创建凭据句柄时模拟该用户，从而使用不同的身份。以管理员身份运行
    [清单 13-12](chapter13.xhtml#Lis13-12) 中的命令。
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 13-12: Creating the credentials handle for the <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp>
    user'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-12：为 <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp> 用户创建凭据句柄
- en: In [Listing 13-12](chapter13.xhtml#Lis13-12), we create a credentials handle
    for the *SYSTEM* user. The *SYSTEM* user doesn’t have any explicit password you
    can use to authenticate using the approach in [Listing 13-11](chapter13.xhtml#Lis13-11);
    therefore, you must impersonate the token to create a credentials handle for it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 13-12](chapter13.xhtml#Lis13-12) 中，我们为 *SYSTEM* 用户创建了凭据句柄。*SYSTEM* 用户没有显式的密码，无法使用
    [清单 13-11](chapter13.xhtml#Lis13-11) 中的方法进行身份验证；因此，你必须模拟该令牌来为其创建凭据句柄。
- en: You need to impersonate the token only once, when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>
    command. All subsequent calls used to create and update the client context don’t
    require you to impersonate the token.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>
    命令时模拟一次令牌。之后所有用于创建和更新客户端上下文的调用都不需要再次模拟令牌。
- en: If you have the full credentials, another approach you could use is to create
    the token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    logon type, briefly mentioned in [Chapter 12](chapter12.xhtml). This will create
    a token with the same local user identity but replace the network authentication
    credentials, as illustrated in [Listing 13-13](chapter13.xhtml#Lis13-13).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有完整的凭据，另一种方法是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    登录类型来创建令牌，这在 [第 12 章](chapter12.xhtml) 中简要提到过。这将创建一个具有相同本地用户身份的令牌，但会替换网络身份验证凭据，如
    [清单 13-13](chapter13.xhtml#Lis13-13) 中所示。
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 13-13: Creating a credentials handle with a NewCredentials token'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-13：使用 NewCredentials 令牌创建凭据句柄
- en: Here, we create a credentials handle by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command to generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>-type
    token, then impersonating it when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    命令生成一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> 类型的令牌，然后在调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp> 时进行模拟。
- en: You might be wondering why, if you know the full credentials, you wouldn’t just
    specify them directly when creating the credentials handle. In this example, this
    would indeed be the simpler solution. However, you sometimes won’t have direct
    control over the creation of the credentials handle. This can happen if the network
    authentication occurs within another API that uses the caller’s identity to access
    a remote resource. In that case, you can impersonate the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    token while calling the API to use the credentials you specified. Importantly,
    only the network credentials will change due to impersonation; the local identity
    will stay the same, so you won’t accidentally access local resources with the
    wrong user account.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，如果你知道完整的凭据，为什么不在创建凭据句柄时直接指定它们呢？在这个例子中，确实这是更简单的解决方案。然而，有时你无法直接控制凭据句柄的创建。如果网络认证发生在另一个
    API 中，该 API 使用调用者的身份访问远程资源，那么就会出现这种情况。在这种情况下，你可以在调用 API 时模拟 <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    令牌，使用你指定的凭据。重要的是，由于模拟，只有网络凭据会发生变化；本地身份保持不变，因此你不会不小心使用错误的用户帐户访问本地资源。
- en: Let’s finish this chapter by describing a practical attack against the NTLM
    authentication protocol. This attack allows you to repurpose the credentials of
    another user without needing to know the user’s password.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过描述一个针对 NTLM 认证协议的实际攻击来结束本章。此攻击允许你在不需要知道用户密码的情况下，重新利用其他用户的凭据。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The NTLM Relay Attack</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">NTLM 中继攻击</samp>
- en: 'One thing you might notice about NTLM is that, while the LSA performs the authentication,
    it’s up to the client and server applications to transport the authentication
    tokens. How does the LSA ensure that it’s authenticating to the right computer?
    It can’t do this directly: it needs the help of the client and server applications.
    This causes a security vulnerability that an actor could exploit with an attack
    called an *NTLM relay*. In this section, we’ll explore this attack and how Microsoft
    has tried to fix the vulnerability.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 NTLM 的一个特点：尽管 LSA 执行认证，但客户端和服务器应用程序负责传输认证令牌。那么，LSA 如何确保它正在对正确的计算机进行认证呢？它无法直接做到这一点：它需要客户端和服务器应用程序的帮助。这就导致了一个安全漏洞，攻击者可以利用一个叫做
    *NTLM 中继* 的攻击来进行利用。在本节中，我们将探讨这种攻击以及微软如何尝试修复这个漏洞。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Attack Overview</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">攻击概述</samp>
- en: '[Figure 13-3](chapter13.xhtml#fig13-3) shows the basic setup of an NTLM relay
    attack.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-3](chapter13.xhtml#fig13-3) 展示了 NTLM 中继攻击的基本设置。'
- en: '![](../images/Figure13-3.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: An example of
    an NTLM relay attack</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-3：NTLM 中继攻击的示例</samp>
- en: 'Three systems are involved: a Windows client machine, a Windows server, and
    the attacker’s machine. The attacker’s goal is to access the SMB file share on
    the server. However, they don’t have the credentials necessary to successfully
    perform NTLM authentication. The client, on the other hand, does have suitable
    credentials, and because of Interactive Windows Authentication, it will use those
    credentials without user interaction if asked nicely.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个攻击涉及三个系统：一个 Windows 客户端机器、一个 Windows 服务器和攻击者的机器。攻击者的目标是访问服务器上的 SMB 文件共享。然而，他们没有成功执行
    NTLM 认证所需的凭据。另一方面，客户端确实拥有合适的凭据，并且由于交互式 Windows 认证，如果请求得当，它会在不与用户交互的情况下使用这些凭据。
- en: The first step is for the attacker to convince the client machine to connect
    to the attacker’s web server. While the attacker wants to access SMB, the NTLM
    authentication from the client can be over any protocol that supports authentication,
    including HTTP. Convincing the client to make a connection could be as simple
    as adding an image to a web page the client visits that points to the attacker’s
    web server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是攻击者说服客户端机器连接到攻击者的 Web 服务器。虽然攻击者想要访问 SMB，但客户端的 NTLM 身份验证可以通过任何支持身份验证的协议进行，包括
    HTTP。说服客户端建立连接可能像在客户端访问的网页中添加一张指向攻击者 Web 服务器的图片一样简单。
- en: The attacker accepts the client’s HTTP connection and starts the NTLM authentication
    process, which results in the client sending a <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token to the attacker ❶. Instead of processing the token, the attacker now opens
    a new connection to the target SMB server and passes along the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token as if they had created it ❷.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者接受客户端的 HTTP 连接并启动 NTLM 身份验证过程，结果是客户端向攻击者发送一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    令牌 ❶。攻击者不会处理该令牌，而是打开到目标 SMB 服务器的新连接，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    令牌传递给它，就好像是他们自己创建的一样 ❷。
- en: The SMB server will respond with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token, and the attacker can forward this to the client to continue the authentication
    process ❸. The client should respond with an <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to the attacker’s web server, which it can forward to the SMB server ❹.
    Assuming the server accepts the client’s credentials, the attacker has now established
    an authenticated connection to the SMB server without ever knowing the user’s
    password.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SMB 服务器将响应一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    令牌，攻击者可以将其转发给客户端，以继续身份验证过程 ❸。客户端应向攻击者的 Web 服务器响应一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌，攻击者可以将其转发给 SMB 服务器 ❹。假设服务器接受客户端的凭证，攻击者现在已经在不知晓用户密码的情况下，成功建立了与 SMB 服务器的身份验证连接。
- en: 'This attack is a serious security issue. Microsoft has tried to implement various
    fixes, mainly by adding more features to NTLM. However, the problem with these
    fixes is that they’re opt-in, for backward compatibility reasons: NTLM and SMB
    are such old protocols that certain clients and servers don’t support the new
    features. Still, let’s discuss the ways that Windows mitigates the vulnerability.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击是一个严重的安全问题。微软尝试通过增加更多功能到 NTLM 来实现各种修复，主要是为了向后兼容。然而，这些修复的问题在于它们是选择性的：NTLM
    和 SMB 是如此古老的协议，以至于某些客户端和服务器不支持新功能。尽管如此，我们还是来讨论一下 Windows 如何减轻这一漏洞。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Active Server Challenges</samp>
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">活动服务器挑战</samp>
- en: The simplest way of performing an NTLM relay attack is to authenticate back
    to the victim’s machine. For example, in [Figure 13-3](chapter13.xhtml#fig13-3),
    the HTTP client and the SMB server could live on the same Windows machine. If
    the machine is both the client and the server, the authentication credentials
    will always be valid.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 NTLM 中继攻击的最简单方法是通过受害者的机器进行身份验证。例如，在[图 13-3](chapter13.xhtml#fig13-3)中，HTTP
    客户端和 SMB 服务器可以位于同一台 Windows 机器上。如果机器同时是客户端和服务器，那么身份验证凭证将始终有效。
- en: To fix this attack, Windows began maintaining a table of currently active server
    challenges and refusing to create the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token if the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token
    included a server challenge issued by the same machine. There is a small chance
    of a collision occurring between two machines, but with a random 8-byte challenge,
    this will rarely happen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这一攻击，Windows 开始维护一个当前活动的服务器挑战表，并拒绝在 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌中创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> 令牌，前提是该令牌包含来自同一台机器发出的服务器挑战。两台机器之间发生冲突的机会很小，但由于挑战是随机生成的
    8 字节，因此这种情况很少发生。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Signing and Sealing</samp>
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">签名与封装</samp>
- en: 'Another way of combatting the NTLM relay attack is to make the outer protocol
    containing the NTLM authentication, such as SMB, rely on the authentication process
    in some way. This boils down to using the only piece of information the attacker
    doesn’t have: the user’s password.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗 NTLM 中继攻击的另一种方法是使包含 NTLM 认证的外部协议（如 SMB）以某种方式依赖于认证过程。这归结为使用攻击者没有的唯一信息：用户的密码。
- en: The SSPI APIs and NTLM support the inclusion of a randomly generated session
    key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token
    that is encrypted by the user’s password. This session key can then be used to
    generate a MIC, which the documentation refers to as *signing*. The MIC is generated
    for the outer protocol using the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp>
    SSPI API and verified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp>
    API. The key can also be used to encrypt and decrypt arbitrary data using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs, which the
    documentation refers to as *sealing*. Because the attacker can’t decrypt the session
    key without knowing the password, they can’t generate valid signed or encrypted
    data to communicate with the relayed server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: SSPI API 和 NTLM 支持将随机生成的会话密钥包含在由用户密码加密的 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌中。然后，这个会话密钥可以用于生成一个 MIC，文档中称之为 *签名*。MIC 是通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp>
    SSPI API 为外部协议生成的，并通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp>
    API 进行验证。该密钥还可以用于使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> API 加密和解密任意数据，文档中称之为
    *封装*。因为攻击者无法在不知道密码的情况下解密会话密钥，所以他们无法生成有效的签名或加密数据与中继服务器进行通信。
- en: 'To request a session key, you specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> flag when creating
    the client or server context by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestAttribute</samp>
    parameter. For example, when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>,
    you can specify the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求会话密钥，可以在使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestAttribute</samp>
    参数创建客户端或服务器上下文时，指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> 标志。例如，在调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp> 时，可以指定以下命令：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Listing 13-14](chapter13.xhtml#Lis13-14) shows the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token if we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp>
    request attribute flag when creating the client and server contexts.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-14](chapter13.xhtml#Lis13-14) 显示了客户端的 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌，如果我们在创建客户端和服务器上下文时指定了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp>
    请求属性标志。'
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 13-14: Checking the AUTHENTICATE token for the session key'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-14：检查会话密钥的 AUTHENTICATE 令牌
- en: As the output shows, this changes the NTLM process in two important ways. First,
    the NTLM <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyExchange</samp> flag
    has been added ❶. This flag indicates that the client has generated a session
    key. The flags also now include <samp class="SANS_TheSansMonoCd_W5Regular_11">Signing</samp>,
    which indicates to the server that the client wants to allow the signing of content
    based on the session key. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp>
    request attribute flag is used, two <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    flags are set, <samp class="SANS_TheSansMonoCd_W5Regular_11">Signing</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sealing</samp>.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，这两种方法以两种重要的方式改变了 NTLM 过程。首先，NTLM 中新增了 <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyExchange</samp>
    标志 ❶。此标志表示客户端已生成会话密钥。标志中现在还包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">Signing</samp>，它告诉服务器客户端希望基于会话密钥允许内容的签名。如果使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp> 请求属性标志，则设置两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> 标志，分别为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Signing</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sealing</samp>。
- en: If either flag is set, the NTLMv2 challenge contains an encrypted session key
    that the client generated ❷. This is the base key used for all further cryptographic
    operations. The key is encrypted using the RC4 encryption algorithm and a key
    derived from the user’s hash and the NT response.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了任何一个标志，NTLMv2挑战将包含客户端生成的加密会话密钥 ❷。这是用于所有进一步加密操作的基本密钥。该密钥使用RC4加密算法和从用户哈希值以及NT响应派生的密钥进行加密。
- en: If you verify the MIC after enabling signing or sealing, you’ll notice that
    the value generated no longer matches the one in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token. This is because if the encrypted session key is available, it’s used instead
    of the base session key. You can fix this behavior by modifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp>
    function shown in [Listing 13-9](chapter13.xhtml#Lis13-9), adding the bold portion
    in [Listing 13-15](chapter13.xhtml#Lis13-15).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在启用签名或封装后验证MIC，你会注意到生成的值与<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌中的值不再匹配。这是因为如果加密会话密钥可用，它将代替基本会话密钥。你可以通过修改在[列表13-9](chapter13.xhtml#Lis13-9)中显示的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp>函数来修复此行为，添加[列表13-15](chapter13.xhtml#Lis13-15)中加粗的部分。
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 13-15: Modifying the Get-Mic function to decrypt the session key for
    the MIC calculation'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-15：修改Get-Mic函数以解密会话密钥以进行MIC计算
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp> APIs are exposed
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaContextSignature</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp>
    commands, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs are
    exposed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    commands. We’ll cover the use of these encryption commands in the worked example
    at the end of this chapter; for now, [Listing 13-16](chapter13.xhtml#Lis13-16)
    shows a simple use of the signature commands.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp>API通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaContextSignature</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp>命令公开，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp>API则通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>命令公开。我们将在本章末尾的工作示例中介绍这些加密命令的使用；目前，[列表13-16](chapter13.xhtml#Lis13-16)展示了签名命令的简单使用。
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 13-16: Generating and verifying a message signature'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-16：生成和验证消息签名
- en: We start by completing the client-to-server authentication process to set up
    integrity support ❶. We then generate a signature for a simple 4-byte message
    using the client authentication context ❷. This process assumes that the data
    is being sent to the server for verification; we can reverse it by specifying
    a different authentication context. We display the generated signature value as
    hex.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先完成客户端到服务器的身份验证过程，以设置完整性支持 ❶。然后，我们使用客户端认证上下文为一个简单的4字节消息生成签名 ❷。这个过程假设数据正在发送到服务器进行验证；我们可以通过指定不同的认证上下文来反转这一过程。我们以十六进制形式显示生成的签名值。
- en: We then verify the signature with the server authentication context using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp>
    command ❸. The command returns a Boolean value indicating whether the signature
    is valid. For this call, the verification returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    However, if we check the signature a second time ❹, we now get <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    indicating that it is no longer valid. Why is that?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用服务器认证上下文通过<samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp>命令
    ❸来验证签名。该命令返回一个布尔值，指示签名是否有效。在此调用中，验证返回<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。但是，如果我们第二次检查签名
    ❹，现在得到<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，这表明签名不再有效。为什么会这样？
- en: The client and server authentication contexts maintain a *sequence number*,
    which starts at 0 and increments for every signature or encryption operation.
    This sequence number is automatically included when generating or verifying a
    signature, and the server can use it to check whether an old signature has been
    replayed (for example, if an attacker is trying to send the same network data
    twice).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器身份验证上下文保持一个 *序列号*，该序列号从 0 开始，并在每次签名或加密操作时递增。生成或验证签名时，此序列号会自动包含在内，服务器可以使用它检查是否有旧的签名被重放（例如，如果攻击者试图两次发送相同的网络数据）。
- en: In the example in [Listing 13-16](chapter13.xhtml#Lis13-16), we generated the
    client’s signature with a sequence number of 0\. In the first verification, the
    server’s authentication context also has an initial value of 0, so the verification
    succeeds. However, after the verification completes, the server’s sequence number
    is incremented to 1\. So, when we try to verify the same signature again, the
    sequence numbers no longer match, and the verification fails.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 13-16](chapter13.xhtml#Lis13-16) 中的示例中，我们生成了客户端的签名，序列号为 0。第一次验证时，服务器的身份验证上下文也有一个初始值
    0，因此验证成功。然而，验证完成后，服务器的序列号增加到 1。因此，当我们尝试再次验证相同的签名时，序列号不再匹配，验证失败。
- en: The RC4 encryption algorithm used for signing and sealing has numerous weaknesses,
    which are outside the scope of this book. However, it offers some level of mitigation
    against NTLM relay attacks and provides basic integrity and confidentiality protections
    to the outer network protocol if no other key exchange mechanism is in place.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 用于签名和封装的 RC4 加密算法存在许多弱点，这些内容超出了本书的范围。然而，它在一定程度上可以减轻 NTLM 中继攻击，并且如果没有其他密钥交换机制，仍能为外部网络协议提供基本的完整性和机密性保护。
- en: SMB supports signing and encryption derived from the authentication process.
    However, because of the weakness of RC4, SMB doesn’t use the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> APIs; instead,
    it extracts the decrypted session key using the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryContextAttribute</samp>
    SSPI API and uses its own encryption and integrity-checking algorithms. You can
    query for the session key by accessing the <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionKey</samp>
    property on the client or server authentication context, as shown in [Listing
    13-17](chapter13.xhtml#Lis13-17).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: SMB 支持从身份验证过程派生的签名和加密。然而，由于 RC4 的弱点，SMB 不使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> API；相反，它使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryContextAttribute</samp> SSPI
    API 提取解密的会话密钥，并使用自己的加密和完整性检查算法。您可以通过访问客户端或服务器身份验证上下文中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionKey</samp>
    属性来查询会话密钥，如 [Listing 13-17](chapter13.xhtml#Lis13-17) 所示。
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 13-17: Extracting the session keys for the authentication context'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 13-17: 提取身份验证上下文的会话密钥'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Target Names</samp>
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">目标名称</samp>
- en: Another technique for blocking NTLM relay attacks is to add an identifier to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token that
    indicates the name of the target the NTLM authentication is for. Because the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token is protected
    by the MIC, which is derived from the user’s password, the target name is hard
    to tamper with.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止 NTLM 中继攻击的另一种方法是向 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌添加一个标识符，该标识符指示 NTLM 身份验证的目标名称。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌由 MIC 保护，MIC 是从用户的密码派生的，因此目标名称很难被篡改。
- en: In our NTLM relay example, if the client enabled target names, it might set
    the target name to *HTTP/attacker.domain.local*, where *HTTP* represents the type
    of service requested and *attacker.domain.local* is the address to which it’s
    authenticating. The attacker could pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to the SMB server, but because the server runs a different service, *CIFS*,
    and sits on a different network address, *fileserver.domain.local*, the names
    will not match and authentication will fail.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 NTLM 中继示例中，如果客户端启用了目标名称，它可能会将目标名称设置为*HTTP/attacker.domain.local*，其中*HTTP*表示请求的服务类型，*attacker.domain.local*是其认证的地址。攻击者可以将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌传递给 SMB 服务器，但由于该服务器运行的是不同的服务，*CIFS*，并且位于不同的网络地址，*fileserver.domain.local*，名称将不匹配，认证将失败。
- en: 'To specify a target name, set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>
    parameter when creating the client authentication context:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定目标名称，在创建客户端认证上下文时设置<samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>参数：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the target name can be completely arbitrary, but the service type
    or network address can’t be. For example, the name *BLAH* wouldn’t be rejected,
    but the name *BLAH/microsoft.com* would be (unless you happened to be running
    a server on *microsoft.com*). The name format follows that of the service principal
    name (SPN) used in Kerberos authentication. We’ll describe how Kerberos uses SPNs
    in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目标名称可以是完全任意的，但服务类型或网络地址不能。例如，名称*BLAH*不会被拒绝，但名称*BLAH/microsoft.com*会被拒绝（除非你恰好在*microsoft.com*上运行一个服务器）。名称格式遵循
    Kerberos 认证中使用的服务主体名称（SPN）的格式。我们将在下一章中描述 Kerberos 如何使用 SPN。
- en: 'When you run the NTLM authentication, you should now see the target name in
    the NTLMv2 challenge response block:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 NTLM 认证时，你现在应该在 NTLMv2 挑战响应块中看到目标名称：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can extract the target name from the server authentication content with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClientTargetName</samp> property:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过<samp class="SANS_TheSansMonoCd_W5Regular_11">ClientTargetName</samp>属性从服务器认证内容中提取目标名称：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The problem with the target name protection is that it must be enabled to be
    effective. By default, clients won’t set it, and the SMB server does not require
    it to be specified. Also, an attacker can spoof the name, as it’s typically based
    on some network address. For example, the attacker might be able to poison the
    client’s DNS cache or use other local network attacks to hijack the server’s IP
    address.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目标名称保护的问题在于，它必须启用才能生效。默认情况下，客户端不会设置它，SMB 服务器也不要求指定它。此外，攻击者可以伪造名称，因为它通常基于某个网络地址。例如，攻击者可能能够毒化客户端的
    DNS 缓存或使用其他本地网络攻击来劫持服务器的 IP 地址。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Channel Binding</samp>
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">通道绑定</samp>
- en: The final protection against NTLM relay we’ll discuss is *channel binding*,
    which Microsoft also refers to as *Extended Protection for Authentication (EPA)*.
    The purpose of channel binding is to add an additional value to the NTLMv2 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token that the MIC
    will protect from tampering.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的针对 NTLM 中继的最终保护措施是*通道绑定*，微软也称之为*扩展认证保护（EPA）*。通道绑定的目的是向 NTLMv2 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌添加一个额外的值，MIC
    将保护该值免受篡改。
- en: Instead of using an arbitrary name, channel binding allows the client and server
    to specify a binary token related to some property of the outer network protocol.
    One common use of channel binding is in *Transport Layer Security (TLS)*, a generic
    network protocol that encrypts and verifies another streaming protocol. This prevents
    the encrypted protocol’s contents from being disclosed to anyone inspecting network
    traffic and enables tampering detection. It’s used, for example, to secure HTTP
    as HTTPS.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通道绑定不是使用任意名称，而是允许客户端和服务器指定与外部网络协议某个属性相关的二进制令牌。通道绑定的一个常见用途是在*传输层安全性（TLS）*中，TLS
    是一种加密并验证其他流协议的通用网络协议。这可以防止加密协议的内容被任何检查网络流量的人披露，并启用篡改检测。例如，它用于保护 HTTP 作为 HTTPS。
- en: In a TLS communication, the client and server could specify the TLS server’s
    X.509 certificate as the channel binding token. The TLS protocol first verifies
    the certificate and ensures that the connection is really being made to the destination
    server. Then it binds the NTLM authentication to that channel. This prevents attackers
    from hijacking authentication by injecting data into the TLS channel. If the attacker
    instead redirects a TLS connection to their own server, the certificate will be
    different, and will use a different channel binding value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在TLS通信中，客户端和服务器可以指定TLS服务器的X.509证书作为通道绑定令牌。TLS协议首先验证证书，并确保连接确实是与目标服务器建立的。然后它将NTLM身份验证绑定到该通道。这样可以防止攻击者通过向TLS通道注入数据来劫持身份验证。如果攻击者将TLS连接重定向到他们自己的服务器，证书将会不同，且会使用不同的通道绑定值。
- en: 'To enable channel binding, specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>
    parameter in the client and server authentication contexts:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用通道绑定，在客户端和服务器身份验证上下文中指定<samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>参数：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you now run the NTLM authentication process, you’ll find that the channel
    binding value, which used to be all zeros, now has a value similar to the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行NTLM身份验证过程，你会发现通道绑定值，原来是全零，现在变成了类似以下的值：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp> value
    is an MD5 hash of a <samp class="SANS_TheSansMonoCd_W5Regular_11">SEC_CHANNEL_BINDINGS</samp>
    structure, which includes the channel binding data specified to the authentication
    context. The value itself should always be the same for every authentication with
    the same data. For the implementation used in the PowerShell module, you can use
    the function in [Listing 13-18](chapter13.xhtml#Lis13-18) to calculate the hash.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>值是<samp class="SANS_TheSansMonoCd_W5Regular_11">SEC_CHANNEL_BINDINGS</samp>结构的MD5哈希值，该结构包括指定给身份验证上下文的通道绑定数据。该值对于使用相同数据的每次身份验证应该始终相同。对于PowerShell模块中使用的实现，可以使用[清单13-18](chapter13.xhtml#Lis13-18)中的函数来计算哈希值。
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 13-18: Calculating the channel binding hash'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 清单13-18：计算通道绑定哈希
- en: As with target names, systems must opt in to this feature. If the server does
    not specify a channel binding token, the channel binding hash in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token won’t be checked. Only when the server specifies a channel binding token
    that doesn’t match will the authentication process fail.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与目标名称一样，系统必须选择启用此功能。如果服务器没有指定通道绑定令牌，则不会检查<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌中的通道绑定哈希值。只有当服务器指定的通道绑定令牌与之不匹配时，身份验证过程才会失败。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Example</samp>
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">实际示例</samp>
- en: Let’s finish with a worked example using the commands you’ve learned about in
    this chapter. In this example, we’ll develop a simple network protocol that uses
    NTLM and the authentication context mechanisms to authenticate a user over a network,
    providing encryption and integrity verification. As this example will be quite
    complex, I’ll break it into sections.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过本章中介绍的命令来完成一个实际示例。在这个示例中，我们将开发一个简单的网络协议，使用NTLM和身份验证上下文机制通过网络验证用户身份，提供加密和完整性验证。由于这个示例将会相当复杂，我会将其分成几个部分。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overview</samp>
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">概述</samp>
- en: The .NET framework already comes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NegotiateStream</samp>
    class, which uses the SSPI to authenticate and encrypt network communications.
    Nevertheless, you’ll find it instructive to build a similar mechanism yourself.
    The network protocol we’ll develop won’t be robust or even secure; it will merely
    demonstrate a practical use of the commands described in this chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架已经包含了<samp class="SANS_TheSansMonoCd_W5Regular_11">NegotiateStream</samp>类，该类使用SSPI进行网络通信的身份验证和加密。不过，你会发现自己构建类似机制会更具启发性。我们将开发的网络协议既不强大，也不安全；它仅仅是展示本章中所述命令的实际应用。
- en: NTLM’s security properties (and its encryption and integrity verification mechanisms)
    are very weak by modern standards, so if you want a robust encrypted network protocol,
    use TLS instead. TLS is available through the <samp class="SANS_TheSansMonoCd_W5Regular_11">SslStream</samp>
    class in .NET.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM 的安全特性（以及它的加密和完整性验证机制）在现代标准下非常薄弱，因此如果你需要一个强大的加密网络协议，应该改用 TLS。TLS 可以通过 .NET
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">SslStream</samp> 类来实现。
- en: '[Figure 13-4](chapter13.xhtml#fig13-4) shows a basic overview of the protocol
    we’ll build.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-4](chapter13.xhtml#fig13-4)展示了我们将要构建的协议的基本概述。'
- en: '![](../images/Figure13-4.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: An overview of
    the network protocol</samp>'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-4：网络协议概述</samp>
- en: We’ll use TCP to facilitate communications between the client and the server
    ❶. TCP is a reliable protocol built into almost every computing device on the
    planet—but because it’s a streaming protocol, there are no breaks between messages
    you send or receive. We need a way of breaking up the stream so that the client
    and server know when they’ve read a single message. For simplicity, we’ll send
    data as ASCII text, with a newline character at the end to indicate the end of
    a message.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 TCP 来促进客户端和服务器之间的通信❶。TCP 是一种可靠的协议，几乎内置于地球上所有计算设备中——但由于它是流协议，发送或接收的消息之间没有间隔。我们需要一种方法来拆分流，以便客户端和服务器知道何时读取到一条完整的消息。为了简便起见，我们将数据以
    ASCII 文本形式发送，并在消息结尾加上换行符来表示消息的结束。
- en: Once we’ve established the TCP connection, we’ll perform an NTLM authentication
    ❷. As the authentication tokens for NTLM are binary, we’ll encode them using the
    base64 algorithm, which converts binary data into a text string made of 64 ASCII
    characters.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了 TCP 连接，我们将执行 NTLM 身份验证❷。由于 NTLM 的认证令牌是二进制的，我们将使用 base64 算法对其进行编码，base64
    算法将二进制数据转换为由 64 个 ASCII 字符组成的文本字符串。
- en: We can then send messages back and forth between the client and the server ❸.
    We’ll encrypt and decrypt the data using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    PowerShell commands. As the encryption process generates encrypted messages and
    a separate signature, we’ll send them as two separate base64 text lines.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在客户端和服务器之间来回发送消息❸。我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    PowerShell 命令来加密和解密数据。由于加密过程会生成加密消息和一个单独的签名，我们将它们作为两个独立的 base64 文本行发送。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code Module</samp>
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码模块</samp>
- en: The client and server will perform many of the same tasks, such as sending and
    receiving messages, so it makes sense to put that code into a separate module
    that both sides can easily reference. Create a directory for the example code
    and copy [Listing 13-19](chapter13.xhtml#Lis13-19) into its own file with the
    name *network_protocol*_*common.psm1*, as both the server and client implementations
    will need to access it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器将执行许多相同的任务，例如发送和接收消息，因此将这些代码放入一个独立的模块中，便于双方轻松引用是合理的。为示例代码创建一个目录，并将[清单
    13-19](chapter13.xhtml#Lis13-19)复制到一个名为*network_protocol*_*common.psm1*的文件中，因为服务器和客户端实现都需要访问它。
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 13-19: The shared module code for the protocol'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-19：协议的共享模块代码
- en: The module code contains five functions. The first function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp>,
    accepts a connected TCP socket and creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamReader</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamWriter</samp> class.
    These classes allow you to read and write text lines to a binary stream, in this
    case over the network. We also set the socket’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NoDelay</samp>
    property, which disables something called the Nagle algorithm. The details of
    the algorithm are outside the scope of this book, but it ensures that the data
    written to the socket is sent to the network immediately, rather than being buffered.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 模块代码包含五个函数。第一个函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp>，接受一个已连接的TCP套接字，并创建一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">StreamReader</samp>和一个<samp class="SANS_TheSansMonoCd_W5Regular_11">StreamWriter</samp>类。这些类允许你在二进制流中读取和写入文本行，在此情况下是通过网络进行的。我们还设置了套接字的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NoDelay</samp>属性，禁用了所谓的Nagle算法。算法的细节超出了本书的范围，但它确保写入套接字的数据会立即发送到网络，而不是被缓冲。
- en: The next two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-Message</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Receive-Message</samp>, send
    and receive a binary message over the TCP socket. To send a message, we first
    convert the binary data to a base64 string, then write it to the writer object.
    For the receiving function we do the reverse operation, reading a line from the
    TCP socket and converting it back to binary data from base64\. Note that we’re
    printing the messages we’re sending and receiving using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-Verbose</samp>
    PowerShell command. By default, PowerShell won’t show this verbose output; I’ll
    show you how to enable that later.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">Send-Message</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Receive-Message</samp>，用于通过TCP套接字发送和接收二进制消息。发送消息时，我们首先将二进制数据转换为base64字符串，然后写入写入对象。接收函数则执行相反的操作，从TCP套接字读取一行并将其从base64转换回二进制数据。请注意，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Write-Verbose</samp> PowerShell命令打印我们发送和接收的消息。默认情况下，PowerShell不会显示这些详细输出；稍后我会告诉你如何启用这个功能。
- en: The final two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-TextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Receive-TextMessage</samp>,
    send and receive encrypted text messages. To send an encrypted message, we convert
    the message into binary data using the UTF8 text encoding, which allows us to
    use any Unicode character in our string. We then encrypt the binary data using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    command. We must send the encrypted data and signature as separate lines, using
    our existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-Message</samp>
    command. Again, to receive data, we perform the inverse of the sending operation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两个函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">Send-TextMessage</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Receive-TextMessage</samp>，用于发送和接收加密的文本消息。发送加密消息时，我们使用UTF8文本编码将消息转换为二进制数据，这样我们就可以在字符串中使用任何Unicode字符。然后我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>命令对二进制数据进行加密。我们必须将加密后的数据和签名作为单独的行发送，使用我们现有的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Send-Message</samp>命令。同样地，接收数据时，我们执行发送操作的逆过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Server Implementation</samp>
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">服务器实现</samp>
- en: We’ll start by implementing the server, as without a server it will be hard
    to test any client code. [Listing 13-20](chapter13.xhtml#Lis13-20) contains the
    server implementation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实现服务器开始，因为没有服务器就很难测试任何客户端代码。[清单13-20](chapter13.xhtml#Lis13-20)包含了服务器的实现。
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 13-20: A simple server implementation'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 清单13-20：一个简单的服务器实现
- en: Copy this code into its own script file in the same directory as the module
    file in [Listing 13-19](chapter13.xhtml#Lis13-19), and save it as *network_protocol_server.ps1*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码复制到与[清单13-19](chapter13.xhtml#Lis13-19)中的模块文件相同目录下的脚本文件中，并将其保存为*network_protocol_server.ps1*。
- en: We start by defining some parameters ❶. If you use the code as a script, you
    can make it act like a function by having it accept parameters on the command
    line. This makes it easy to change the script’s behavior. In this case, we define
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> parameter, which
    will change what network interfaces we bind the TCP server to, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Port</samp>
    parameter, which is the TCP port number.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一些参数 ❶。如果你将代码作为脚本使用，可以通过让它接受命令行参数来使其像一个函数一样工作。这使得修改脚本的行为变得更加容易。在这个例子中，我们定义了一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> 参数，它会改变我们绑定到的 TCP
    服务器的网络接口，以及一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Port</samp> 参数，它表示
    TCP 端口号。
- en: Next, we import the common module ❷. This ensures that the functions defined
    in [Listing 13-19](chapter13.xhtml#Lis13-19) are available for the server to use.
    Then we set up the bind address ❸. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp>
    is set, then we bind to <samp class="SANS_TheSansMonoCd_W5Regular_11">Any</samp>,
    which represents all network interfaces; if not, we bind only to the loopback
    address, which is accessible only locally.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导入公共模块 ❷。这可以确保 [Listing 13-19](chapter13.xhtml#Lis13-19) 中定义的函数可供服务器使用。然后我们设置绑定地址
    ❸。如果设置了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp>，则我们绑定到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Any</samp>，它代表所有网络接口；如果没有设置，则我们仅绑定到回环地址，该地址仅在本地可访问。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*It’s a common practice to bind to only the loopback address when testing server
    code. This ensures that other computers on the network can’t connect to your server
    and potentially abuse its functionality. Only bind to all network interfaces when
    you’re confident that any code you’ve written is secure, or when on a network
    with no other participants.*'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在测试服务器代码时，绑定到回环地址是一种常见的做法。这可以确保网络中的其他计算机无法连接到你的服务器，防止其滥用服务器功能。只有在确信你编写的代码是安全的，或是在没有其他参与者的网络中，才应该绑定到所有网络接口。*'
- en: Once we’ve determined the address, we create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpListener</samp>
    class and bind to the address and TCP port ❹. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">Start</samp>
    to begin listening for new connections, and we wait for a connection by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptTcpClient</samp>. At this
    point, without a client, the script will stop here. When a connection is made,
    we’ll receive a connected socket object that we can convert to the client using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp> command.
    We then print out the connected client address.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了地址，就创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpListener</samp>
    类的实例，并绑定到地址和 TCP 端口 ❹。我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Start</samp>
    开始监听新的连接，并通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptTcpClient</samp>
    等待连接。在此时，如果没有客户端连接，脚本将停在这里。当连接建立时，我们将收到一个已连接的套接字对象，可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp>
    命令将其转换为客户端。然后我们打印出已连接的客户端地址。
- en: We can now set up a new server authentication context for NTLM ❺, specifying
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp> request
    attribute to grant us the ability to encrypt and decrypt messages. We then negotiate
    the authentication with the client ❻. If the authentication fails or we haven’t
    completed it after receiving the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token, we throw an error to stop the server script.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为 NTLM 设置新的服务器认证上下文 ❺，并指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp>
    请求属性，以便授权我们加密和解密消息。然后，我们与客户端协商认证 ❻。如果认证失败或我们在收到 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌后仍未完成认证，我们将抛出错误以停止服务器脚本。
- en: We also check that the client provides a suitable target name during the authentication
    ❼. It should be of the format *BOOK/<ADDRESS>*, where *<ADDRESS>* is the IP address
    of the server. If the target name doesn’t match, we’ll also throw a fatal error.
    To confirm the identity of the authenticated user, we query the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object from the context and print the user’s name. To inform the client that the
    authentication succeeded, we send a confirmation message ❽. We encrypt this message,
    to ensure the session keys match.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会检查客户端在认证过程中是否提供了合适的目标名称❼。它应该是*BOOK/<ADDRESS>*的格式，其中*<ADDRESS>*是服务器的IP地址。如果目标名称不匹配，我们也会抛出一个致命错误。为了确认认证用户的身份，我们从上下文中查询<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象并打印用户的名字。为了通知客户端认证成功，我们发送一条确认消息❽。我们会对这条消息进行加密，以确保会话密钥匹配。
- en: Finally, we can start receiving text messages from the client ❾. We read a text
    message, which we saw earlier will be decrypted and verified based on the negotiated
    authentication context. To prove it was received correctly, we write the message
    to the console. We then return the message to the client, appending the username
    to the message and uppercasing the text just for good measure.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始从客户端接收文本消息❾。我们读取一条文本消息，之前看到的消息将根据商定的认证上下文进行解密和验证。为了证明消息接收正确，我们将该消息写入控制台。然后，我们将消息返回给客户端，并附加用户名到消息中，且为了确保准确性，将文本转为大写。
- en: If we receive an empty message, we treat this as the signal to close down the
    server; we’ll only accept the one connection. We make sure to clean up our resources,
    such as the TCP server, before leaving the script. Let’s now look at the client
    implementation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到一个空消息，我们将其视为关闭服务器的信号；我们只会接受一个连接。我们会在退出脚本之前确保清理资源，例如TCP服务器。现在，让我们来看看客户端的实现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Client Implementation</samp>
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">客户端实现</samp>
- en: For the most part, the client implements the reverse operations of the server.
    [Listing 13-21](chapter13.xhtml#Lis13-21) shows its code. Copy this into its own
    script file in the same directory as the module file from [Listing 13-19](chapter13.xhtml#Lis13-19),
    with the name *network_protocol_client.ps1*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端大多数情况下实现的是服务器的逆向操作。[列表13-21](chapter13.xhtml#Lis13-21)展示了它的代码。将其复制到与[列表13-19](chapter13.xhtml#Lis13-19)中模块文件相同的目录下，命名为*network_protocol_client.ps1*。
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 13-21: The client implementation'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-21：客户端实现
- en: Again, we start by defining some parameters ❶. In this case, we want to specify
    an IP address to connect to and its TCP port. By default, the client will connect
    to the loopback address on TCP port 6543\. Next, we need to create the TCP socket
    ❷. Because it’s a client, we can directly create a <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpClient</samp>
    object to connect to the address and port. We can then wrap the socket with the
    stream readers and writers, like in the server implementation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们从定义一些参数开始❶。在这种情况下，我们希望指定一个要连接的IP地址和TCP端口。默认情况下，客户端将连接到回环地址的TCP端口6543。接下来，我们需要创建TCP套接字❷。因为这是客户端，我们可以直接创建一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TcpClient</samp>对象来连接地址和端口。然后，我们可以像在服务器实现中一样，用流读取器和写入器包装套接字。
- en: We create a client authentication context so that we can authenticate to the
    server ❸. We’ll use the current user’s credentials for this purpose, but you can
    change this behavior if necessary. We also specify the target name so it matches
    the server’s; if we don’t do this, the server will disconnect us. We verify that
    we can read the <samp class="SANS_TheSansMonoCd_W5Regular_11">OK</samp> message
    sent from the server ❹. If we don’t receive anything or the message does not match
    our expectations, it’s clear the authentication failed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个客户端认证上下文，以便能够对服务器进行认证❸。我们将使用当前用户的凭据，但如果需要，你可以更改此行为。我们还指定目标名称，使其与服务器的匹配；如果不这样做，服务器会断开连接。我们验证是否能读取从服务器发送的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OK</samp>消息❹。如果没有收到任何内容或消息与我们的预期不符，说明认证失败。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You generally shouldn’t return detailed error information to a client in a
    network protocol. Sending a simple OK message, or nothing at all, may not help
    diagnose problems, but it prevents an attacker from finding out why the authentication
    failed. For example, if we sent the client the message BADPASSWORD if the password
    were wrong or BADUSER for an unknown user, an attacker could differentiate the
    two cases and try to brute-force a password for a valid user or enumerate valid
    usernames.*'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*通常，你不应向客户端返回详细的错误信息。在网络协议中发送简单的OK消息或什么都不发送，可能无法帮助诊断问题，但它能防止攻击者发现认证失败的原因。例如，如果我们在密码错误时向客户端发送消息BADPASSWORD，或在用户名未知时发送BADUSER，攻击者就可以区分这两种情况，并尝试对有效用户进行暴力破解密码或枚举有效的用户名。*'
- en: If the authentication completed, we should now have a valid connection, so we
    can start sending messages. We read a text line from the console ❺ and send it
    to the server. We then wait for a reply and print it to the console. If we enter
    an empty line, the loop should exit, and the TCP socket should close. This should
    cause the server to receive an empty message, at which point the server can exit
    as well.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果认证完成，我们现在应该有一个有效的连接，因此可以开始发送消息。我们从控制台读取一行文本❺并将其发送给服务器。然后我们等待服务器的回复，并将其打印到控制台。如果我们输入一个空行，循环应退出，TCP套接字应关闭。这将导致服务器接收到一个空消息，届时服务器也可以退出。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The NTLM Authentication
    Test</samp>
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <sup class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NTLM认证测试</sup>
- en: 'Let’s test the client and server we’ve just written. To do so, you’ll need
    two PowerShell consoles. In the first console, run the server script with the
    following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下我们刚刚编写的客户端和服务器。为此，你需要两个PowerShell控制台。在第一个控制台中，使用以下命令运行服务器脚本：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, in the second console, run the client. When you see the <samp class="SANS_TheSansMonoCd_W5Regular_11">MSG</samp>
    prompt, enter a message, such as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Hello</samp>,
    to send to the server. The output in the client should resemble the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第二个控制台中，运行客户端。当你看到<sup class="SANS_TheSansMonoCd_W5Regular_11">MSG</sup>提示符时，输入一条消息，例如<sup
    class="SANS_TheSansMonoCd_W7Bold_B_11">Hello</sup>，并发送给服务器。客户端的输出应该类似于以下内容：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the server console, the output should show the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器控制台中，输出应该显示以下内容：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, if you press ENTER again in the client without typing a message, both the
    client and the server should exit without any errors.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在客户端再次按下ENTER键而不输入任何消息，客户端和服务器应该都没有任何错误地退出。
- en: 'You can play with the scripts to make them do different things. For example,
    if you want to use a different TCP port, you can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Port</samp>
    parameter to the scripts. The following shows how to set the port to <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>
    for the server; the change would be the same for the client:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过修改脚本来让它们执行不同的操作。例如，如果你想使用不同的TCP端口，可以将<sup class="SANS_TheSansMonoCd_W5Regular_11">Port</sup>参数传递给脚本。以下是如何将端口设置为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">11111</sup>用于服务器；对于客户端，变化相同：
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As a final note, let’s revisit the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-Verbose</samp>
    command in the common module code. As you may have noticed when using the client
    and the server, the verbose output isn’t printed to the console. If you want to
    see the output, you can enable this by changing the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">$VerbosePreference</samp>
    global variable. This variable normally has the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">SilentlyContinue</samp>,
    which ignores verbose output. If you change it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp>,
    the verbose output will appear. [Listing 13-22](chapter13.xhtml#Lis13-22) changes
    this value before connecting the client.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们回顾一下在公共模块代码中使用<sup class="SANS_TheSansMonoCd_W5Regular_11">Write-Verbose</sup>命令的情况。正如你在使用客户端和服务器时可能已经注意到的那样，详细输出并没有打印到控制台。如果你想查看输出，可以通过更改<sup
    class="SANS_TheSansMonoCd_W5Regular_11">$VerbosePreference</sup>全局变量的值来启用此功能。此变量通常设置为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">SilentlyContinue</sup>，该值会忽略详细输出。如果你将其更改为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Continue</sup>，则详细输出将会显示。[清单13-22](chapter13.xhtml#Lis13-22)在连接客户端之前更改了这个值。
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 13-22: Enabling verbose output for the client'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 清单13-22：启用客户端的详细输出
- en: You can observe that we now see part of the first NTLM authentication token
    being sent to the server. When you send messages back and forth between the client
    and server, you can verify that the data is encrypted by looking at the hex output.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观察到，现在我们看到部分第一个 NTLM 认证令牌被发送到服务器。当你在客户端和服务器之间来回发送消息时，可以通过查看十六进制输出验证数据是否被加密。
- en: This worked example was quite lengthy, but it should have given you a better
    idea of how network authentication can work in a real network scenario.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例虽然较长，但它应该让你更好地理解网络认证在实际网络场景中的工作方式。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter described the NTLM authentication protocol and provided scripts
    to demonstrate its authentication process. We looked at negotiating authentication
    tokens, and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    PowerShell command to display the protocol state.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了 NTLM 认证协议，并提供了脚本来演示其认证过程。我们查看了如何协商认证令牌，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    PowerShell 命令来显示协议状态。
- en: I also showed you how to derive some of the cryptographic values generated by
    the NTLM protocol using PowerShell. This included the final NT response value,
    which proves the knowledge of the user’s password, and the message integrity code,
    which protects the NTLM authentication tokens from tampering.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我还向你展示了如何使用 PowerShell 推导出 NTLM 协议生成的一些加密值。这包括最终的 NT 响应值，它证明了用户密码的知识，以及消息完整性码，它保护
    NTLM 认证令牌免受篡改。
- en: To describe the risks associated with NTLM authentication, we covered NTLM relay
    attacks and a few ways in which Windows tries to combat them, such as active server
    challenge records and channel binding. We also covered using the authentication
    context to generate signatures and encrypt messages.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述与 NTLM 认证相关的风险，我们讨论了 NTLM 中继攻击以及 Windows 试图应对这些攻击的一些方法，如主动服务器挑战记录和通道绑定。我们还讲解了如何使用认证上下文生成签名和加密消息。
- en: Now that you better understand network authentication and the APIs used to generate
    authentication tokens, the next chapter focuses on the more complicated Kerberos
    authentication protocol.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你更好地理解了网络认证以及用于生成认证令牌的 API，下一章将聚焦于更复杂的 Kerberos 认证协议。
