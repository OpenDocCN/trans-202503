- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NETWORK
    AUTHENTICATION</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous chapter discussed interactive authentication, which allows a user
    to log in to a computer and interact with a desktop. By contrast, *network authentication*
    occurs when the user has already authenticated to a Windows system but wants to
    use resources on another Windows system, typically over a network.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest approach to performing network authentication might seem to be
    to transfer the user’s credentials to the remote system. The service that receives
    the credentials could then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API and specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp>
    logon type to create a noninteractive logon session. However, this approach isn’t
    very secure. To use <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>,
    a network-facing service must know the user’s full credentials, and providing
    a remote system with these credentials is problematic for many reasons. For one,
    we must trust the remote service to handle the credentials securely. For another,
    if the authentication takes place over a hostile network, an attacker could capture
    the credentials.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate these security issues, Windows implements multiple network authentication
    protocols. These protocols don’t require sending a network service the user’s
    credentials or transferring a plaintext password over the network. (Of course,
    there are always caveats, which we’ll identify over the course of this chapter.)
    You’ll find these network authentication protocols in the security packages we
    discussed in the previous chapter, and you can access them via a generic API,
    which allows an application to easily change the authentication protocol used.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins by describing the *NT LAN Manager (NTLM)* authentication
    protocol, the oldest Windows protocol still in use, in some depth, covering how
    it uses the user’s credentials to prevent their disclosure over the network. Then
    we’ll look at a well-known attack, *NTLM relay*, and the ways Microsoft has tried
    to mitigate it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">NTLM Network Authentication</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NTLM derives from the *LAN Manager (LM)* authentication protocol, which supported
    the Server Message Block (SMB) file sharing protocol as part of the LAN Manager
    operating system. Microsoft reimplemented the authentication protocol in Windows
    3.11 (the infamous Windows for Workgroups), then built upon it further and dubbed
    it NTLM when it introduced Windows NT. In the latest versions of Windows, there
    are three variants of NTLM in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NTLMv1    **The original NTLM version, introduced in Windows NT 3.1'
  prefs: []
  type: TYPE_NORMAL
- en: '**NTLMv2    **A version of NTLM introduced in NT 4 Service Pack 4 that added
    additional security features'
  prefs: []
  type: TYPE_NORMAL
- en: '**NTLMv2 Session    **NTLMv1, but with the additional security features from
    NTLMv2'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll focus on NTLMv2, the only version whose values are accepted by default
    on Windows Vista and above. You might still encounter NTLMv1 or NTLMv2 Session
    in mixed operating system environments (for example, when accessing Linux-based
    network storage devices), but in a modern Windows environment, these should be
    rare.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-1](chapter13.xhtml#fig13-1) shows an overview of the NTLM authentication
    process that occurs between a Windows client application and a Windows server.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: An overview of
    the NTLM authentication protocol</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'NTLM authentication begins when the client application makes a network connection
    to the server. The client and the server then exchange a sequence of binary *authentication
    tokens* generated by the LSAs on the two machines. For the NTLM, these tokens
    consist of three authentication messages: the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    message, which specifies which features the client supports ❶; the server’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> message, which selects
    one of the client’s features and provides a random challenge value to use in the
    exchange ❷; and the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    message, which contains a value that proves the client’s knowledge of the user’s
    password to the server ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, the authentication process occurs between the two LSAs. However,
    it’s up to the application and server to transport these authentication tokens
    over some network protocol. Microsoft describes the authentication protocol in
    *MS-NLMP*, available online. The document omits some features, which I’ll point
    out as we walk through an example.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NTLM Authentication
    Using PowerShell</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s perform network authentication using PowerShell so you can see what information
    the authentication tokens contain. We’ll use a local user account, though a domain
    account would work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing the Client</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The authentication process starts when the client application calls the Security
    Support Provider Interface (SSPI) API <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>.
    The system implements the SSPI APIs to abstract the authentication protocol implemented
    by a security package. This allows applications to more easily change the network
    authentication protocol they use.
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>
    API selects the security package used for network authentication and provides
    explicit credentials for the authentication if needed. It returns a handle for
    use by a second SSPI API, <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>,
    which uses the selected security package but executes in the LSA.
  prefs: []
  type: TYPE_NORMAL
- en: The security package in the LSA processes <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>,
    then requests and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    authentication token to the caller. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token describes which authentication features the client supports and should be
    sent to the server over the network protocol. [Listing 13-1](chapter13.xhtml#Lis13-1)
    performs this client initialization in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-1: Initializing a client for NTLM authentication and formatting
    a NEGOTIATE authentication token'
  prefs: []
  type: TYPE_NORMAL
- en: We start by getting the credentials handle using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>
    command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>.
    By specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Package</samp> parameter, we
    select the use of the NTLM security package. We also specify that these credentials
    are for outbound authentication (that is, from a client to a server). Lastly,
    we specify the username and domain from the current environment.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we do not specify a password; this is because the LSA has already
    cached the password for us in our logon session. The fact that we don’t need to
    specify the password is a key part of *Integrated Windows Authentication (IWA)*,
    which allows users to automatically authenticate to the network authentication
    using their credentials, without prompting them for a password.
  prefs: []
  type: TYPE_NORMAL
- en: With the credentials handle, we create a client authentication context by calling
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>
    command and specifying the handle. Under the hood, this command calls the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp> API.
    If the call to the API succeeds, the client context now contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token. We store a copy of the token for later use, then pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    command to parse its contents and print them to the shell.
  prefs: []
  type: TYPE_NORMAL
- en: The main component of the token is a list of flags that reflect the features
    the client requests, the features the client supports, and which parts of the
    token are valid. In this case, the token has nine flags set, though these can
    change depending on the system’s configuration. [Table 13-1](chapter13.xhtml#tab13-1)
    shows what the flags mean in this context.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-1:</samp> <samp class="SANS_Futura_Std_Book_11">Select
    NTLM Flags</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client supports Unicode strings.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client supports byte character strings (for example, ASCII).</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestTarget</samp> | <samp
    class="SANS_Futura_Std_Book_11">The client requires the server to send a target
    name in the response.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests to use the NTLM hash.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AlwaysSign</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests that the authentication be signed to ensure integrity.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    | <samp class="SANS_Futura_Std_Book_11">The client requests NTLMv2 Session security.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client has sent the operating system and NTLM protocol version.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests a 128-bit signing key.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests a 56-bit signing key.</samp> |'
  prefs: []
  type: TYPE_TB
- en: You might wonder why the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    flag is set. This flag changes NTLMv1 to NTLMv2 Session security, but I mentioned
    earlier that NTLMv1 is disabled by default. The LSA sets the flag anyway, just
    in case the server responds with a request for NTLMv1\. Except for <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp>,
    these flags all indicate the features the client requires. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp>
    flag indicates major, minor, and build values of the operating system version,
    as well as the NTLM protocol version, which has been fixed at 15 since Windows
    Server 2003.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure the integrity of the authentication protocol, NTLM generates an encryption
    key based on the values in the exchange, then uses it to apply a *message integrity
    code (MIC)* to the entire exchange. A MIC is a cryptographic hash of the authentication
    tokens sent and received in the current exchange. It’s used to detect whether
    the authentication tokens have been tampered with over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Due to cryptography export restrictions, NTLM supports 40-bit keys as well as
    56-bit and 128-bit keys, based on the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp> flags. If neither
    flag is set, NTLM will use 40-bit keys. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    command hides the underlying binary value of the authentication token, but to
    see the token in hex we can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsBytes</samp>
    parameter to this command, as shown in [Listing 13-2](chapter13.xhtml#Lis13-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-2: Formatting the authentication token in hex'
  prefs: []
  type: TYPE_NORMAL
- en: In hex, we can see the data has a format indicator at the beginning of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NTLMSSP</samp> ❶. If you see this indicator
    in data you’re analyzing, there’s a good chance you’ve come across an NTLM network
    authentication process. I won’t display the hex of the rest of the tokens, as
    it’s easy enough to change the script to view the hex output if you’re interested
    in doing so.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing the Server</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The client has initialized its authentication context and generated a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token. Now it must send
    this token to the server application so that it can initialize its own authentication
    context. When the server receives the token, it passes it to the LSA using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp> API.
    The LSA inspects the token, determines whether it supports the requested features,
    and generates a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    authentication token in response. This token allows the server to verify that
    the client isn’t replaying values captured from a previous authentication exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use PowerShell to demonstrate the server’s handling of NTLM. In [Listing
    13-3](chapter13.xhtml#Lis13-3), we create the server authentication context in
    the same process as the client’s (remember, however, that the server will typically
    run on a different system).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-3: Initializing the server for NTLM authentication and formatting
    the CHALLENGE authentication token'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating the inbound credentials handle. You don’t need to provide
    any credentials to do this; in fact, NTLM would ignore the credentials even if
    you did provide them. Next, we create the server’s authentication context and
    provide the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>
    API by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    PowerShell command. If the LSA accepts the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token, the server context will include its own token, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token. As before, we capture the token for later use and pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    to print out the information it contains.
  prefs: []
  type: TYPE_NORMAL
- en: The token’s flags represent the values that the network authentication process
    supports and are based on the flags the client sent. For example, in [Listing
    13-1](chapter13.xhtml#Lis13-1) we saw that the client set both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp> string format
    flags in its <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token,
    indicating that it can support both Unicode and byte character format strings.
    The server has elected to send strings in Unicode format, so it has cleared the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> flag in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token.
  prefs: []
  type: TYPE_NORMAL
- en: As requested by the client, the output also contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>,
    which in this case is the domain name of the server, indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeDomain</samp>
    flag. If the server were not in a domain network, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>
    would be the server’s computer name, and the token would use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeServer</samp>
    flag instead.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token contains
    a random 8-byte server challenge generated by the LSA. All values calculated in
    the next step depend on the challenge’s value; because it’s different for every
    request, this prevents an attacker from capturing a previous authentication exchange
    and replaying it to the server. The final part of the token is the target information,
    indicated by the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetInfo</samp>
    flag. This contains additional details about the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note that NTLM can work in a connectionless mode, in which the client never
    sends the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    message. In this case, the authentication process starts with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    message from the server. However, connectionless NTLM authentication is rarely
    used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Passing the Token Back to
    the Client</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, the server must send the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token to the client’s authentication context. In a real network protocol, this
    would happen over the network, but in [Listing 13-4](chapter13.xhtml#Lis13-4)
    we pass the token in the same script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-4: Updating the client for NTLM authentication and formatting the
    AUTHENTICATE token'
  prefs: []
  type: TYPE_NORMAL
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaClientContext</samp>
    command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    once again with the original credentials handle and the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token. If <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    accepts the token, the LSA generates the final <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token, which we can then format. This is the only token that depends on the value
    of the password; the other two tokens can be generated without any special knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token
    starts with the final negotiated flags and the information about the user, including
    their username and domain. Because we’re using a local account, the domain is
    set to the workstation name, <samp class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>.
    Next comes the LM response, which in this case is all zeros ❶. The LM response
    is normally disabled, which is why it’s not specified, and NTLMv2 doesn’t use
    the LM hash at all.
  prefs: []
  type: TYPE_NORMAL
- en: We now continue to the full NTLMv2 response, which contains a lot of information.
    First is the 8-byte NT response ❷, also called the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTProofStr</samp>
    in the protocol’s documentation. We’ll come back to how this value is calculated
    in a moment. After the NT response are various parameters about the protocol,
    including the 8-byte client challenge ❸. NTLMv1 already contained the server challenge
    to prevent replay, but NTLMv2 added the client challenge to make it harder for
    an attacker to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to crack the user’s password.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token
    copies most of its target information from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    message, although it contains a few additional entries. The flags indicate that
    the message contains a MIC with the <samp class="SANS_TheSansMonoCd_W5Regular_11">MessageIntegrity</samp>
    value ❹, as you’ll soon see. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleHost</samp>
    flag contains a random ID for the client machine that generated the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token ❺. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp> ❻ values are
    used to prevent credential relaying, an attack we’ll also come back to later;
    in this case, the flags aren’t specified. Last is the MIC, a keyed MD5 hash-based
    message authentication code (HMAC) calculated over the authentication tokens sent
    and received for the current exchange ❼. The key for the hash is calculated during
    the authentication process, and the MIC serves to detect whether the tokens have
    been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: The client sends the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to the server, which again calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>,
    passing it the token. The LSA runs the calculations needed to verify that the
    NT response matches the expected value and that the MIC is valid, indicating the
    tokens haven’t been tampered with. If both values match the expected values, the
    authentication succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several differences between the formatted output generated by NTLMv1
    and NTLMv2\. First, if NTLMv1 is in use, the NT response in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token will be a 24-byte binary value rather than the structured response seen
    in [Listing 13-4](chapter13.xhtml#Lis13-4). For example, it might look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also differentiate between NTLMv1 and NTLMv2 Session by looking at
    the flags and LM hash. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    flag is set, you know that NTLMv2 Session is in use; otherwise, the system is
    using NTLMv1\. The LM hash field gets repurposed to contain the client challenge
    in NTLMv2, which might confuse you, as you might assume an LM hash has been negotiated.
    You can tell the difference between a hash and a client challenge because the
    client challenge is only 8 bytes long, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The remaining 16 bytes are padded with zeros.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Requesting a Token Object</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that the authentication process has completed, the server can request that
    the LSA generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object for the authenticated user through the <samp class="SANS_TheSansMonoCd_W5Regular_11">QuerySecurityContextToken</samp>
    API, as shown in [Listing 13-5](chapter13.xhtml#Lis13-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-5: Completing the NTLM authentication process'
  prefs: []
  type: TYPE_NORMAL
- en: We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    again to finalize the authentication process. Once all tokens have been transferred,
    the client and server contexts are placed into a *done state*, meaning they no
    longer need any more information to complete the authentication process. You can
    verify this state using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContext</samp>
    command.
  prefs: []
  type: TYPE_NORMAL
- en: With the authentication completed, we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaAccessToken</samp>
    command to return the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object for the user. We display the logon session for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    and verify that it used network authentication.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Cryptographic
    Derivation Process</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The NTLM process never discloses the user’s password in plaintext on the network.
    Even so, NTLM uses the password’s value to derive the final NT response and MIC.
    Let’s use PowerShell to walk through this cryptographic derivation process and
    generate the NT response and MIC. To perform the derivation, we’ll need the user’s
    password, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> authentication
    tokens.
  prefs: []
  type: TYPE_NORMAL
- en: We also need a function that calculates the MD5 HMAC for a set of bytes. The
    MD5 HMAC is a keyed cryptographic hashing algorithm commonly used to sign data
    so its integrity can be verified. We’ll use this function, defined in [Listing
    13-6](chapter13.xhtml#Lis13-6), multiple times in the derivation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-6: Defining the Get-Md5Hmac function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function is simple: it creates the .NET class <samp class="SANS_TheSansMonoCd_W5Regular_11">HMACMD5</samp>,
    passing it a key ❶, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ComputeHash</samp>
    on the data ❷. If the data is a string, it first converts it to a byte array in
    Unicode encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: The next function we define calculates the *NT one-way function version 2 (NTOWFv2)*,
    shown in [Listing 13-7](chapter13.xhtml#Lis13-7). This function converts the username,
    domain, and password into a 16-byte key for further use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-7: Defining the NT one-way function'
  prefs: []
  type: TYPE_NORMAL
- en: First, note that the system hashes the password using the MD4 algorithm ❶. As
    mentioned previously, the SAM database stores these MD4 hashes so that the LSA
    doesn’t need to store their plaintext versions.
  prefs: []
  type: TYPE_NORMAL
- en: We supply the MD4 hash of the password as a key to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>
    function, then use this function to hash the uppercase username concatenated to
    the domain ❷. In this case, these values are <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>, so we hash
    the string <samp class="SANS_TheSansMonoCd_W5Regular_11">USERGRAPHITE</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: To perform this operation, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtOwfv2</samp>
    function we just defined with the username and domain from the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token ❸, which we stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">$authToken</samp>
    variable. The function produces a 16-byte key ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a key based on the user’s password, we’ll use it to calculate
    the NT response value with the function defined in [Listing 13-8](chapter13.xhtml#Lis13-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-8: Calculating the NtProofStr value'
  prefs: []
  type: TYPE_NORMAL
- en: We perform the calculation of the NT response using the NTOWFv2 key as well
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> tokens. First we concatenate
    the 8-byte server challenge from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtChallengeResponse</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token,
    minus the supplied 16-byte NT response ❶. Then we calculate the NT value using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp> function,
    with NTOWFv2 as the key ❷. The result ❸ should match the NT response value from
    [Listing 13-4](chapter13.xhtml#Lis13-4) (if you used your actual password rather
    than the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">pwd</samp> placeholder
    used in the listing).
  prefs: []
  type: TYPE_NORMAL
- en: The server can now verify that the client has access to the correct password
    for the user by checking whether the two NT response values match. However, we
    still want to verify that the messages haven’t been tampered with in some way,
    so we need to calculate the MIC. We define the function to do this in [Listing
    13-9](chapter13.xhtml#Lis13-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-9: Calculating the message integrity code'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp> function takes
    five parameters: the NTOWFv2 key, the NT response, and all three tokens transmitted
    back and forth between the client and server. The first task is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>
    again to calculate a session key ❶. We use the NTOWFv2 key for this HMAC operation
    and supply the NT response as data. Next, we zero the MIC field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token ❷, then concatenate the tokens ❸. We pass the session key and the concatenated
    tokens to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp> to
    generate the MIC ❹. The value of the MIC ❺ should match the one generated in [Listing
    13-4](chapter13.xhtml#Lis13-4).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pass-Through Authentication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the client and server to successfully authenticate using NTLM, both parties
    must know the user’s password (or, more precisely, its NT hash). If you’re authenticating
    to a stand-alone machine, the password must be set in the machine’s local SAM
    database. Configuring this value isn’t too difficult in a small network, but on
    a large network consisting of many machines, doing it manually becomes unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: On a domain network, the domain controller is responsible for managing the user’s
    NT hash. So how can NTLM function in such an environment? The Netlogon service
    on the domain controller supports the concept of *pass-through authentication*
    to facilitate NTLM authentication on other systems in the domain. [Figure 13-2](chapter13.xhtml#fig13-2)
    provides an example of the NTLM authentication process in a domain.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: An overview of
    NTLM pass-through authentication</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The NTLM authentication process begins normally: the client sends the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token to the server ❶,
    which generates a challenge and returns it to the client in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token ❷. The client then uses the user’s NT hash to generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token and sends it to the server ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, problems arise. The server doesn’t have the user’s NT hash, so
    it can’t derive necessary cryptographic values such as the NT challenge. Therefore,
    the server packages up the server challenge and the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token and sends these to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp>
    API on the domain controller ❹. You might recall from [Chapter 12](chapter12.xhtml)
    that Windows uses this API for interactive authentication. The API has multiple
    modes, one of which can verify the NTLM authentication values without needing
    the user’s password.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the domain controller doesn’t verify the MIC, as this requires all
    three authentication tokens. Instead, the server calculates the session key used
    for verification based on the user’s NT hash and NT challenge value and returns
    it to the requesting server. This allows it to ensure that the authentication
    hasn’t been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Windows server never has access to the user’s full password or NT hash,
    only the session key. This results in the *double hop problem*: the authenticated
    user can access resources stored locally on the server, but that user cannot be
    used to access resources on other servers on the domain network.'
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, this is a good thing, as it prevents a malicious
    service from repurposing a user’s identity. However, it also reduces flexibility,
    as it means that you can’t trivially implement an authenticated proxying service
    without requiring the user to reauthenticate to each service behind that proxy.
    Kerberos solves the double hop problem using delegation, as I’ll describe in more
    detail in [Chapter 14](chapter14.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Loopback Authentication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the previous example, I chose to specify a username and domain when getting
    the outbound authentication credentials handle. While Integrated Windows Authentication
    doesn’t require you to specify either a username or a domain, you need to do so
    if you want to create a network logon session on the local machine. Let’s change
    the script in [Listing 13-1](chapter13.xhtml#Lis13-1) to build the outbound credentials
    without a username or domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now rerun the authentication session. The formatted tokens should look like
    those in [Listing 13-10](chapter13.xhtml#Lis13-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-10: The formatted tokens from a local loopback authentication'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that all three authentication tokens have changed. The first
    change is in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token, which now contains a domain name and workstation name ❶. The next changes
    are in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token:
    a new flag has appeared, <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    ❷, and a previously zeroed <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserved</samp>
    field now has a value ❸. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag signifies that the authentication comes from the local machine, while the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserved</samp> field is a unique
    identifier for the server security context that created the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token.'
  prefs: []
  type: TYPE_NORMAL
- en: The final changes are in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token. While the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag is still present ❹, both the <samp class="SANS_TheSansMonoCd_W5Regular_11">LM
    Response</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NT Response</samp>
    fields are completely empty ❺. This clearly signifies that the authentication
    process has changed. If we check the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s logon session, we see that it’s an interactive session instead of a network
    session ❻. The reason for this is that the LSA has returned a copy of the caller’s
    token to the server, as you can see by comparing the logon ID to the authentication
    ID from the effective token ❼.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag. Its value is based on the domain and workstation names in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    authentication token. If these values refer to the local machine, local loopback
    authentication is enabled. There are no other unique identifiers in the initial
    token to key the flag on, and there doesn’t need to be an ongoing outbound authentication
    process for the flag to be selected. Also, the flag is not specified in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token’s flags, so it’s
    not negotiated between the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Microsoft does not document the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag in *MS-NLMP*, presumably because it shouldn’t be supported outside of the
    local machine. However, as you can see, merely providing the right <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token causes local loopback authentication to kick in. Documenting this flag would
    make it easier to diagnose authentication failures that could occur if the flag
    were present over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Why does the LSA implement local loopback authentication? One reason is that
    network authentication would cause the user to be reauthenticated, and some local
    services, such as SMB, allow local interactive users, but not network users, to
    access file shares. Therefore, this local loopback allows the SMB server to see
    a local user and grant access.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Alternative Client
    Credentials</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve seen how to use PowerShell commands to authenticate as the calling user.
    This is normally the behavior you’ll want to implement, as the current user typically
    aims to access some network resource as themselves. However, the underlying APIs
    support several mechanisms that allow you to authenticate as a different user
    over the network. Changing your user identity is useful because it enables you
    to access a network resource without reauthenticating interactively.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Explicit Credentials</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you know the new user’s full credentials, you can specify them when creating
    the credentials handle for the client authentication context. To do this, call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp> and
    pass it the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Domain</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Password</samp>
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: However, you probably don’t want to leave a user’s password in PowerShell’s
    command history. One alternative is to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadCredential</samp>
    parameter, which will read the credentials from the user without storing them
    in the command history. [Listing 13-11](chapter13.xhtml#Lis13-11) shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-11: Creating a credentials handle with user-specified credentials'
  prefs: []
  type: TYPE_NORMAL
- en: You can now pass the credentials handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>
    to create the client context. You don’t need to change the server side, which
    uses the credentials managed by the LSA.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Impersonating a Token</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When creating the credentials handle, the LSA usually determines the network
    credentials to use based on the calling user’s identity, which it retrieves from
    the primary token of the process that calls the SSPI API. However, if you have
    a different user’s token, you can impersonate them while creating the credentials
    handle to use a different identity. Run the command in [Listing 13-12](chapter13.xhtml#Lis13-12)
    as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-12: Creating the credentials handle for the <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp>
    user'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 13-12](chapter13.xhtml#Lis13-12), we create a credentials handle
    for the *SYSTEM* user. The *SYSTEM* user doesn’t have any explicit password you
    can use to authenticate using the approach in [Listing 13-11](chapter13.xhtml#Lis13-11);
    therefore, you must impersonate the token to create a credentials handle for it.
  prefs: []
  type: TYPE_NORMAL
- en: You need to impersonate the token only once, when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>
    command. All subsequent calls used to create and update the client context don’t
    require you to impersonate the token.
  prefs: []
  type: TYPE_NORMAL
- en: If you have the full credentials, another approach you could use is to create
    the token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    logon type, briefly mentioned in [Chapter 12](chapter12.xhtml). This will create
    a token with the same local user identity but replace the network authentication
    credentials, as illustrated in [Listing 13-13](chapter13.xhtml#Lis13-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-13: Creating a credentials handle with a NewCredentials token'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create a credentials handle by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command to generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>-type
    token, then impersonating it when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why, if you know the full credentials, you wouldn’t just
    specify them directly when creating the credentials handle. In this example, this
    would indeed be the simpler solution. However, you sometimes won’t have direct
    control over the creation of the credentials handle. This can happen if the network
    authentication occurs within another API that uses the caller’s identity to access
    a remote resource. In that case, you can impersonate the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    token while calling the API to use the credentials you specified. Importantly,
    only the network credentials will change due to impersonation; the local identity
    will stay the same, so you won’t accidentally access local resources with the
    wrong user account.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish this chapter by describing a practical attack against the NTLM
    authentication protocol. This attack allows you to repurpose the credentials of
    another user without needing to know the user’s password.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The NTLM Relay Attack</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One thing you might notice about NTLM is that, while the LSA performs the authentication,
    it’s up to the client and server applications to transport the authentication
    tokens. How does the LSA ensure that it’s authenticating to the right computer?
    It can’t do this directly: it needs the help of the client and server applications.
    This causes a security vulnerability that an actor could exploit with an attack
    called an *NTLM relay*. In this section, we’ll explore this attack and how Microsoft
    has tried to fix the vulnerability.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Attack Overview</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 13-3](chapter13.xhtml#fig13-3) shows the basic setup of an NTLM relay
    attack.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: An example of
    an NTLM relay attack</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three systems are involved: a Windows client machine, a Windows server, and
    the attacker’s machine. The attacker’s goal is to access the SMB file share on
    the server. However, they don’t have the credentials necessary to successfully
    perform NTLM authentication. The client, on the other hand, does have suitable
    credentials, and because of Interactive Windows Authentication, it will use those
    credentials without user interaction if asked nicely.'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is for the attacker to convince the client machine to connect
    to the attacker’s web server. While the attacker wants to access SMB, the NTLM
    authentication from the client can be over any protocol that supports authentication,
    including HTTP. Convincing the client to make a connection could be as simple
    as adding an image to a web page the client visits that points to the attacker’s
    web server.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker accepts the client’s HTTP connection and starts the NTLM authentication
    process, which results in the client sending a <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token to the attacker ❶. Instead of processing the token, the attacker now opens
    a new connection to the target SMB server and passes along the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token as if they had created it ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The SMB server will respond with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token, and the attacker can forward this to the client to continue the authentication
    process ❸. The client should respond with an <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to the attacker’s web server, which it can forward to the SMB server ❹.
    Assuming the server accepts the client’s credentials, the attacker has now established
    an authenticated connection to the SMB server without ever knowing the user’s
    password.
  prefs: []
  type: TYPE_NORMAL
- en: 'This attack is a serious security issue. Microsoft has tried to implement various
    fixes, mainly by adding more features to NTLM. However, the problem with these
    fixes is that they’re opt-in, for backward compatibility reasons: NTLM and SMB
    are such old protocols that certain clients and servers don’t support the new
    features. Still, let’s discuss the ways that Windows mitigates the vulnerability.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Active Server Challenges</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest way of performing an NTLM relay attack is to authenticate back
    to the victim’s machine. For example, in [Figure 13-3](chapter13.xhtml#fig13-3),
    the HTTP client and the SMB server could live on the same Windows machine. If
    the machine is both the client and the server, the authentication credentials
    will always be valid.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this attack, Windows began maintaining a table of currently active server
    challenges and refusing to create the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token if the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token
    included a server challenge issued by the same machine. There is a small chance
    of a collision occurring between two machines, but with a random 8-byte challenge,
    this will rarely happen.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Signing and Sealing</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another way of combatting the NTLM relay attack is to make the outer protocol
    containing the NTLM authentication, such as SMB, rely on the authentication process
    in some way. This boils down to using the only piece of information the attacker
    doesn’t have: the user’s password.'
  prefs: []
  type: TYPE_NORMAL
- en: The SSPI APIs and NTLM support the inclusion of a randomly generated session
    key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token
    that is encrypted by the user’s password. This session key can then be used to
    generate a MIC, which the documentation refers to as *signing*. The MIC is generated
    for the outer protocol using the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp>
    SSPI API and verified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp>
    API. The key can also be used to encrypt and decrypt arbitrary data using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs, which the
    documentation refers to as *sealing*. Because the attacker can’t decrypt the session
    key without knowing the password, they can’t generate valid signed or encrypted
    data to communicate with the relayed server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To request a session key, you specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> flag when creating
    the client or server context by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestAttribute</samp>
    parameter. For example, when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>,
    you can specify the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 13-14](chapter13.xhtml#Lis13-14) shows the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token if we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp>
    request attribute flag when creating the client and server contexts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-14: Checking the AUTHENTICATE token for the session key'
  prefs: []
  type: TYPE_NORMAL
- en: As the output shows, this changes the NTLM process in two important ways. First,
    the NTLM <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyExchange</samp> flag
    has been added ❶. This flag indicates that the client has generated a session
    key. The flags also now include <samp class="SANS_TheSansMonoCd_W5Regular_11">Signing</samp>,
    which indicates to the server that the client wants to allow the signing of content
    based on the session key. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp>
    request attribute flag is used, two <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    flags are set, <samp class="SANS_TheSansMonoCd_W5Regular_11">Signing</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sealing</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If either flag is set, the NTLMv2 challenge contains an encrypted session key
    that the client generated ❷. This is the base key used for all further cryptographic
    operations. The key is encrypted using the RC4 encryption algorithm and a key
    derived from the user’s hash and the NT response.
  prefs: []
  type: TYPE_NORMAL
- en: If you verify the MIC after enabling signing or sealing, you’ll notice that
    the value generated no longer matches the one in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token. This is because if the encrypted session key is available, it’s used instead
    of the base session key. You can fix this behavior by modifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp>
    function shown in [Listing 13-9](chapter13.xhtml#Lis13-9), adding the bold portion
    in [Listing 13-15](chapter13.xhtml#Lis13-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-15: Modifying the Get-Mic function to decrypt the session key for
    the MIC calculation'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp> APIs are exposed
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaContextSignature</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp>
    commands, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs are
    exposed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    commands. We’ll cover the use of these encryption commands in the worked example
    at the end of this chapter; for now, [Listing 13-16](chapter13.xhtml#Lis13-16)
    shows a simple use of the signature commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-16: Generating and verifying a message signature'
  prefs: []
  type: TYPE_NORMAL
- en: We start by completing the client-to-server authentication process to set up
    integrity support ❶. We then generate a signature for a simple 4-byte message
    using the client authentication context ❷. This process assumes that the data
    is being sent to the server for verification; we can reverse it by specifying
    a different authentication context. We display the generated signature value as
    hex.
  prefs: []
  type: TYPE_NORMAL
- en: We then verify the signature with the server authentication context using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp>
    command ❸. The command returns a Boolean value indicating whether the signature
    is valid. For this call, the verification returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    However, if we check the signature a second time ❹, we now get <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    indicating that it is no longer valid. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: The client and server authentication contexts maintain a *sequence number*,
    which starts at 0 and increments for every signature or encryption operation.
    This sequence number is automatically included when generating or verifying a
    signature, and the server can use it to check whether an old signature has been
    replayed (for example, if an attacker is trying to send the same network data
    twice).
  prefs: []
  type: TYPE_NORMAL
- en: In the example in [Listing 13-16](chapter13.xhtml#Lis13-16), we generated the
    client’s signature with a sequence number of 0\. In the first verification, the
    server’s authentication context also has an initial value of 0, so the verification
    succeeds. However, after the verification completes, the server’s sequence number
    is incremented to 1\. So, when we try to verify the same signature again, the
    sequence numbers no longer match, and the verification fails.
  prefs: []
  type: TYPE_NORMAL
- en: The RC4 encryption algorithm used for signing and sealing has numerous weaknesses,
    which are outside the scope of this book. However, it offers some level of mitigation
    against NTLM relay attacks and provides basic integrity and confidentiality protections
    to the outer network protocol if no other key exchange mechanism is in place.
  prefs: []
  type: TYPE_NORMAL
- en: SMB supports signing and encryption derived from the authentication process.
    However, because of the weakness of RC4, SMB doesn’t use the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> APIs; instead,
    it extracts the decrypted session key using the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryContextAttribute</samp>
    SSPI API and uses its own encryption and integrity-checking algorithms. You can
    query for the session key by accessing the <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionKey</samp>
    property on the client or server authentication context, as shown in [Listing
    13-17](chapter13.xhtml#Lis13-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-17: Extracting the session keys for the authentication context'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Target Names</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another technique for blocking NTLM relay attacks is to add an identifier to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token that
    indicates the name of the target the NTLM authentication is for. Because the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token is protected
    by the MIC, which is derived from the user’s password, the target name is hard
    to tamper with.
  prefs: []
  type: TYPE_NORMAL
- en: In our NTLM relay example, if the client enabled target names, it might set
    the target name to *HTTP/attacker.domain.local*, where *HTTP* represents the type
    of service requested and *attacker.domain.local* is the address to which it’s
    authenticating. The attacker could pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to the SMB server, but because the server runs a different service, *CIFS*,
    and sits on a different network address, *fileserver.domain.local*, the names
    will not match and authentication will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a target name, set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>
    parameter when creating the client authentication context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that the target name can be completely arbitrary, but the service type
    or network address can’t be. For example, the name *BLAH* wouldn’t be rejected,
    but the name *BLAH/microsoft.com* would be (unless you happened to be running
    a server on *microsoft.com*). The name format follows that of the service principal
    name (SPN) used in Kerberos authentication. We’ll describe how Kerberos uses SPNs
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the NTLM authentication, you should now see the target name in
    the NTLMv2 challenge response block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can extract the target name from the server authentication content with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClientTargetName</samp> property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the target name protection is that it must be enabled to be
    effective. By default, clients won’t set it, and the SMB server does not require
    it to be specified. Also, an attacker can spoof the name, as it’s typically based
    on some network address. For example, the attacker might be able to poison the
    client’s DNS cache or use other local network attacks to hijack the server’s IP
    address.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Channel Binding</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final protection against NTLM relay we’ll discuss is *channel binding*,
    which Microsoft also refers to as *Extended Protection for Authentication (EPA)*.
    The purpose of channel binding is to add an additional value to the NTLMv2 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token that the MIC
    will protect from tampering.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using an arbitrary name, channel binding allows the client and server
    to specify a binary token related to some property of the outer network protocol.
    One common use of channel binding is in *Transport Layer Security (TLS)*, a generic
    network protocol that encrypts and verifies another streaming protocol. This prevents
    the encrypted protocol’s contents from being disclosed to anyone inspecting network
    traffic and enables tampering detection. It’s used, for example, to secure HTTP
    as HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: In a TLS communication, the client and server could specify the TLS server’s
    X.509 certificate as the channel binding token. The TLS protocol first verifies
    the certificate and ensures that the connection is really being made to the destination
    server. Then it binds the NTLM authentication to that channel. This prevents attackers
    from hijacking authentication by injecting data into the TLS channel. If the attacker
    instead redirects a TLS connection to their own server, the certificate will be
    different, and will use a different channel binding value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable channel binding, specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>
    parameter in the client and server authentication contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now run the NTLM authentication process, you’ll find that the channel
    binding value, which used to be all zeros, now has a value similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp> value
    is an MD5 hash of a <samp class="SANS_TheSansMonoCd_W5Regular_11">SEC_CHANNEL_BINDINGS</samp>
    structure, which includes the channel binding data specified to the authentication
    context. The value itself should always be the same for every authentication with
    the same data. For the implementation used in the PowerShell module, you can use
    the function in [Listing 13-18](chapter13.xhtml#Lis13-18) to calculate the hash.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-18: Calculating the channel binding hash'
  prefs: []
  type: TYPE_NORMAL
- en: As with target names, systems must opt in to this feature. If the server does
    not specify a channel binding token, the channel binding hash in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token won’t be checked. Only when the server specifies a channel binding token
    that doesn’t match will the authentication process fail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Example</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s finish with a worked example using the commands you’ve learned about in
    this chapter. In this example, we’ll develop a simple network protocol that uses
    NTLM and the authentication context mechanisms to authenticate a user over a network,
    providing encryption and integrity verification. As this example will be quite
    complex, I’ll break it into sections.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overview</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The .NET framework already comes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NegotiateStream</samp>
    class, which uses the SSPI to authenticate and encrypt network communications.
    Nevertheless, you’ll find it instructive to build a similar mechanism yourself.
    The network protocol we’ll develop won’t be robust or even secure; it will merely
    demonstrate a practical use of the commands described in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: NTLM’s security properties (and its encryption and integrity verification mechanisms)
    are very weak by modern standards, so if you want a robust encrypted network protocol,
    use TLS instead. TLS is available through the <samp class="SANS_TheSansMonoCd_W5Regular_11">SslStream</samp>
    class in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-4](chapter13.xhtml#fig13-4) shows a basic overview of the protocol
    we’ll build.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: An overview of
    the network protocol</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use TCP to facilitate communications between the client and the server
    ❶. TCP is a reliable protocol built into almost every computing device on the
    planet—but because it’s a streaming protocol, there are no breaks between messages
    you send or receive. We need a way of breaking up the stream so that the client
    and server know when they’ve read a single message. For simplicity, we’ll send
    data as ASCII text, with a newline character at the end to indicate the end of
    a message.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve established the TCP connection, we’ll perform an NTLM authentication
    ❷. As the authentication tokens for NTLM are binary, we’ll encode them using the
    base64 algorithm, which converts binary data into a text string made of 64 ASCII
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: We can then send messages back and forth between the client and the server ❸.
    We’ll encrypt and decrypt the data using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    PowerShell commands. As the encryption process generates encrypted messages and
    a separate signature, we’ll send them as two separate base64 text lines.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code Module</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The client and server will perform many of the same tasks, such as sending and
    receiving messages, so it makes sense to put that code into a separate module
    that both sides can easily reference. Create a directory for the example code
    and copy [Listing 13-19](chapter13.xhtml#Lis13-19) into its own file with the
    name *network_protocol*_*common.psm1*, as both the server and client implementations
    will need to access it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-19: The shared module code for the protocol'
  prefs: []
  type: TYPE_NORMAL
- en: The module code contains five functions. The first function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp>,
    accepts a connected TCP socket and creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamReader</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamWriter</samp> class.
    These classes allow you to read and write text lines to a binary stream, in this
    case over the network. We also set the socket’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NoDelay</samp>
    property, which disables something called the Nagle algorithm. The details of
    the algorithm are outside the scope of this book, but it ensures that the data
    written to the socket is sent to the network immediately, rather than being buffered.
  prefs: []
  type: TYPE_NORMAL
- en: The next two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-Message</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Receive-Message</samp>, send
    and receive a binary message over the TCP socket. To send a message, we first
    convert the binary data to a base64 string, then write it to the writer object.
    For the receiving function we do the reverse operation, reading a line from the
    TCP socket and converting it back to binary data from base64\. Note that we’re
    printing the messages we’re sending and receiving using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-Verbose</samp>
    PowerShell command. By default, PowerShell won’t show this verbose output; I’ll
    show you how to enable that later.
  prefs: []
  type: TYPE_NORMAL
- en: The final two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-TextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Receive-TextMessage</samp>,
    send and receive encrypted text messages. To send an encrypted message, we convert
    the message into binary data using the UTF8 text encoding, which allows us to
    use any Unicode character in our string. We then encrypt the binary data using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    command. We must send the encrypted data and signature as separate lines, using
    our existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-Message</samp>
    command. Again, to receive data, we perform the inverse of the sending operation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Server Implementation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start by implementing the server, as without a server it will be hard
    to test any client code. [Listing 13-20](chapter13.xhtml#Lis13-20) contains the
    server implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-20: A simple server implementation'
  prefs: []
  type: TYPE_NORMAL
- en: Copy this code into its own script file in the same directory as the module
    file in [Listing 13-19](chapter13.xhtml#Lis13-19), and save it as *network_protocol_server.ps1*.
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining some parameters ❶. If you use the code as a script, you
    can make it act like a function by having it accept parameters on the command
    line. This makes it easy to change the script’s behavior. In this case, we define
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> parameter, which
    will change what network interfaces we bind the TCP server to, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Port</samp>
    parameter, which is the TCP port number.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we import the common module ❷. This ensures that the functions defined
    in [Listing 13-19](chapter13.xhtml#Lis13-19) are available for the server to use.
    Then we set up the bind address ❸. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp>
    is set, then we bind to <samp class="SANS_TheSansMonoCd_W5Regular_11">Any</samp>,
    which represents all network interfaces; if not, we bind only to the loopback
    address, which is accessible only locally.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*It’s a common practice to bind to only the loopback address when testing server
    code. This ensures that other computers on the network can’t connect to your server
    and potentially abuse its functionality. Only bind to all network interfaces when
    you’re confident that any code you’ve written is secure, or when on a network
    with no other participants.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once we’ve determined the address, we create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpListener</samp>
    class and bind to the address and TCP port ❹. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">Start</samp>
    to begin listening for new connections, and we wait for a connection by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptTcpClient</samp>. At this
    point, without a client, the script will stop here. When a connection is made,
    we’ll receive a connected socket object that we can convert to the client using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp> command.
    We then print out the connected client address.
  prefs: []
  type: TYPE_NORMAL
- en: We can now set up a new server authentication context for NTLM ❺, specifying
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp> request
    attribute to grant us the ability to encrypt and decrypt messages. We then negotiate
    the authentication with the client ❻. If the authentication fails or we haven’t
    completed it after receiving the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token, we throw an error to stop the server script.
  prefs: []
  type: TYPE_NORMAL
- en: We also check that the client provides a suitable target name during the authentication
    ❼. It should be of the format *BOOK/<ADDRESS>*, where *<ADDRESS>* is the IP address
    of the server. If the target name doesn’t match, we’ll also throw a fatal error.
    To confirm the identity of the authenticated user, we query the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object from the context and print the user’s name. To inform the client that the
    authentication succeeded, we send a confirmation message ❽. We encrypt this message,
    to ensure the session keys match.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can start receiving text messages from the client ❾. We read a text
    message, which we saw earlier will be decrypted and verified based on the negotiated
    authentication context. To prove it was received correctly, we write the message
    to the console. We then return the message to the client, appending the username
    to the message and uppercasing the text just for good measure.
  prefs: []
  type: TYPE_NORMAL
- en: If we receive an empty message, we treat this as the signal to close down the
    server; we’ll only accept the one connection. We make sure to clean up our resources,
    such as the TCP server, before leaving the script. Let’s now look at the client
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Client Implementation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the most part, the client implements the reverse operations of the server.
    [Listing 13-21](chapter13.xhtml#Lis13-21) shows its code. Copy this into its own
    script file in the same directory as the module file from [Listing 13-19](chapter13.xhtml#Lis13-19),
    with the name *network_protocol_client.ps1*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-21: The client implementation'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we start by defining some parameters ❶. In this case, we want to specify
    an IP address to connect to and its TCP port. By default, the client will connect
    to the loopback address on TCP port 6543\. Next, we need to create the TCP socket
    ❷. Because it’s a client, we can directly create a <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpClient</samp>
    object to connect to the address and port. We can then wrap the socket with the
    stream readers and writers, like in the server implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We create a client authentication context so that we can authenticate to the
    server ❸. We’ll use the current user’s credentials for this purpose, but you can
    change this behavior if necessary. We also specify the target name so it matches
    the server’s; if we don’t do this, the server will disconnect us. We verify that
    we can read the <samp class="SANS_TheSansMonoCd_W5Regular_11">OK</samp> message
    sent from the server ❹. If we don’t receive anything or the message does not match
    our expectations, it’s clear the authentication failed.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You generally shouldn’t return detailed error information to a client in a
    network protocol. Sending a simple OK message, or nothing at all, may not help
    diagnose problems, but it prevents an attacker from finding out why the authentication
    failed. For example, if we sent the client the message BADPASSWORD if the password
    were wrong or BADUSER for an unknown user, an attacker could differentiate the
    two cases and try to brute-force a password for a valid user or enumerate valid
    usernames.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the authentication completed, we should now have a valid connection, so we
    can start sending messages. We read a text line from the console ❺ and send it
    to the server. We then wait for a reply and print it to the console. If we enter
    an empty line, the loop should exit, and the TCP socket should close. This should
    cause the server to receive an empty message, at which point the server can exit
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The NTLM Authentication
    Test</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s test the client and server we’ve just written. To do so, you’ll need
    two PowerShell consoles. In the first console, run the server script with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the second console, run the client. When you see the <samp class="SANS_TheSansMonoCd_W5Regular_11">MSG</samp>
    prompt, enter a message, such as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Hello</samp>,
    to send to the server. The output in the client should resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the server console, the output should show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you press ENTER again in the client without typing a message, both the
    client and the server should exit without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can play with the scripts to make them do different things. For example,
    if you want to use a different TCP port, you can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Port</samp>
    parameter to the scripts. The following shows how to set the port to <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>
    for the server; the change would be the same for the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As a final note, let’s revisit the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-Verbose</samp>
    command in the common module code. As you may have noticed when using the client
    and the server, the verbose output isn’t printed to the console. If you want to
    see the output, you can enable this by changing the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">$VerbosePreference</samp>
    global variable. This variable normally has the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">SilentlyContinue</samp>,
    which ignores verbose output. If you change it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp>,
    the verbose output will appear. [Listing 13-22](chapter13.xhtml#Lis13-22) changes
    this value before connecting the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-22: Enabling verbose output for the client'
  prefs: []
  type: TYPE_NORMAL
- en: You can observe that we now see part of the first NTLM authentication token
    being sent to the server. When you send messages back and forth between the client
    and server, you can verify that the data is encrypted by looking at the hex output.
  prefs: []
  type: TYPE_NORMAL
- en: This worked example was quite lengthy, but it should have given you a better
    idea of how network authentication can work in a real network scenario.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter described the NTLM authentication protocol and provided scripts
    to demonstrate its authentication process. We looked at negotiating authentication
    tokens, and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    PowerShell command to display the protocol state.
  prefs: []
  type: TYPE_NORMAL
- en: I also showed you how to derive some of the cryptographic values generated by
    the NTLM protocol using PowerShell. This included the final NT response value,
    which proves the knowledge of the user’s password, and the message integrity code,
    which protects the NTLM authentication tokens from tampering.
  prefs: []
  type: TYPE_NORMAL
- en: To describe the risks associated with NTLM authentication, we covered NTLM relay
    attacks and a few ways in which Windows tries to combat them, such as active server
    challenge records and channel binding. We also covered using the authentication
    context to generate signatures and encrypt messages.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you better understand network authentication and the APIs used to generate
    authentication tokens, the next chapter focuses on the more complicated Kerberos
    authentication protocol.
  prefs: []
  type: TYPE_NORMAL
