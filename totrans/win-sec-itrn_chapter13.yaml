- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NETWORK
    AUTHENTICATION</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">网络身份验证</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: The previous chapter discussed interactive authentication, which allows a user
    to log in to a computer and interact with a desktop. By contrast, *network authentication*
    occurs when the user has already authenticated to a Windows system but wants to
    use resources on another Windows system, typically over a network.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章讨论了交互式身份验证，它允许用户登录到计算机并与桌面进行交互。相比之下，*网络身份验证*发生在用户已经在Windows系统上进行身份验证，但希望在另一台Windows系统上使用资源时，通常是通过网络进行的。
- en: The simplest approach to performing network authentication might seem to be
    to transfer the user’s credentials to the remote system. The service that receives
    the credentials could then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API and specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp>
    logon type to create a noninteractive logon session. However, this approach isn’t
    very secure. To use <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>,
    a network-facing service must know the user’s full credentials, and providing
    a remote system with these credentials is problematic for many reasons. For one,
    we must trust the remote service to handle the credentials securely. For another,
    if the authentication takes place over a hostile network, an attacker could capture
    the credentials.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 执行网络身份验证的最简单方法可能是将用户的凭据传输到远程系统。接收凭据的服务随后可以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API，并指定<samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp>登录类型来创建一个非交互式登录会话。然而，这种方法并不安全。要使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>，一个面向网络的服务必须知道用户的完整凭据，并且将这些凭据提供给远程系统在许多方面存在问题。首先，我们必须信任远程服务能够安全地处理这些凭据。其次，如果身份验证发生在一个敌对网络上，攻击者可能会捕获这些凭据。
- en: To mitigate these security issues, Windows implements multiple network authentication
    protocols. These protocols don’t require sending a network service the user’s
    credentials or transferring a plaintext password over the network. (Of course,
    there are always caveats, which we’ll identify over the course of this chapter.)
    You’ll find these network authentication protocols in the security packages we
    discussed in the previous chapter, and you can access them via a generic API,
    which allows an application to easily change the authentication protocol used.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这些安全问题，Windows实现了多种网络身份验证协议。这些协议不需要将用户的凭据发送给网络服务，也不需要将明文密码通过网络传输。（当然，也有一些警告，我们将在本章过程中指出。）你将在上一章中讨论的安全包中找到这些网络身份验证协议，并且可以通过通用API访问它们，从而允许应用程序轻松地更改所使用的身份验证协议。
- en: This chapter begins by describing the *NT LAN Manager (NTLM)* authentication
    protocol, the oldest Windows protocol still in use, in some depth, covering how
    it uses the user’s credentials to prevent their disclosure over the network. Then
    we’ll look at a well-known attack, *NTLM relay*, and the ways Microsoft has tried
    to mitigate it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先详细介绍了*NT LAN Manager (NTLM)*身份验证协议，它是仍在使用的最古老的Windows协议，涵盖了它如何使用用户的凭据防止在网络上泄露。接下来我们将讨论一种著名的攻击方式——*NTLM中继*，以及Microsoft为减轻这一攻击所采取的措施。
- en: <samp class="SANS_Futura_Std_Bold_B_11">NTLM Network Authentication</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">NTLM 网络身份验证</samp>
- en: 'NTLM derives from the *LAN Manager (LM)* authentication protocol, which supported
    the Server Message Block (SMB) file sharing protocol as part of the LAN Manager
    operating system. Microsoft reimplemented the authentication protocol in Windows
    3.11 (the infamous Windows for Workgroups), then built upon it further and dubbed
    it NTLM when it introduced Windows NT. In the latest versions of Windows, there
    are three variants of NTLM in use:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM源自于*LAN Manager (LM)*身份验证协议，LAN Manager操作系统支持Server Message Block (SMB)文件共享协议。Microsoft在Windows
    3.11（著名的Windows for Workgroups）中重新实现了该身份验证协议，随后进一步扩展并命名为NTLM，首次出现在Windows NT中。在最新版本的Windows中，使用了三种NTLM变体：
- en: '**NTLMv1    **The original NTLM version, introduced in Windows NT 3.1'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTLMv1    **原始的NTLM版本，首次在Windows NT 3.1中引入'
- en: '**NTLMv2    **A version of NTLM introduced in NT 4 Service Pack 4 that added
    additional security features'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTLMv2    **NTLM的一个版本，于NT 4服务包4中引入，增加了额外的安全功能'
- en: '**NTLMv2 Session    **NTLMv1, but with the additional security features from
    NTLMv2'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTLMv2会话    **NTLMv1，但具有NTLMv2的附加安全特性'
- en: We’ll focus on NTLMv2, the only version whose values are accepted by default
    on Windows Vista and above. You might still encounter NTLMv1 or NTLMv2 Session
    in mixed operating system environments (for example, when accessing Linux-based
    network storage devices), but in a modern Windows environment, these should be
    rare.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点介绍NTLMv2，这是唯一在Windows Vista及更高版本中默认接受的版本。在混合操作系统环境中（例如，当访问基于Linux的网络存储设备时），你仍然可能会遇到NTLMv1或NTLMv2会话，但在现代Windows环境中，这些情况应该是罕见的。
- en: '[Figure 13-1](chapter13.xhtml#fig13-1) shows an overview of the NTLM authentication
    process that occurs between a Windows client application and a Windows server.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-1](chapter13.xhtml#fig13-1)显示了发生在Windows客户端应用程序和Windows服务器之间的NTLM认证过程概览。'
- en: '![](../images/Figure13-1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: An overview of
    the NTLM authentication protocol</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-1：NTLM认证协议概览</samp>
- en: 'NTLM authentication begins when the client application makes a network connection
    to the server. The client and the server then exchange a sequence of binary *authentication
    tokens* generated by the LSAs on the two machines. For the NTLM, these tokens
    consist of three authentication messages: the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    message, which specifies which features the client supports ❶; the server’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> message, which selects
    one of the client’s features and provides a random challenge value to use in the
    exchange ❷; and the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    message, which contains a value that proves the client’s knowledge of the user’s
    password to the server ❸.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM认证从客户端应用程序与服务器建立网络连接开始。客户端和服务器随后交换一系列由两台机器上的LSA生成的二进制*认证令牌*。对于NTLM，这些令牌由三个认证消息组成：客户端的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>消息，它指定客户端支持的功能❶；服务器的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>消息，它选择客户端的一个功能并提供一个随机挑战值，用于交换过程中❷；以及客户端的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>消息，它包含一个证明客户端掌握用户密码的值❸。
- en: At a high level, the authentication process occurs between the two LSAs. However,
    it’s up to the application and server to transport these authentication tokens
    over some network protocol. Microsoft describes the authentication protocol in
    *MS-NLMP*, available online. The document omits some features, which I’ll point
    out as we walk through an example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，认证过程发生在两个LSA之间。然而，应用程序和服务器负责通过某些网络协议传输这些认证令牌。微软在*MS-NLMP*中描述了认证协议，该文档可以在线获得。文档省略了一些功能，我们将在讲解示例时指出这些功能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NTLM Authentication
    Using PowerShell</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用PowerShell进行NTLM认证</samp>
- en: Let’s perform network authentication using PowerShell so you can see what information
    the authentication tokens contain. We’ll use a local user account, though a domain
    account would work just as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用PowerShell进行网络认证，这样你就可以看到认证令牌包含的信息。我们将使用本地用户帐户，尽管域帐户同样可以正常工作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing the Client</samp>
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">初始化客户端</samp>
- en: The authentication process starts when the client application calls the Security
    Support Provider Interface (SSPI) API <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>.
    The system implements the SSPI APIs to abstract the authentication protocol implemented
    by a security package. This allows applications to more easily change the network
    authentication protocol they use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 认证过程在客户端应用程序调用安全支持提供程序接口（SSPI）API <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>时开始。系统实现SSPI
    API以抽象由安全包实现的认证协议。这使得应用程序更容易更改它们使用的网络认证协议。
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>
    API selects the security package used for network authentication and provides
    explicit credentials for the authentication if needed. It returns a handle for
    use by a second SSPI API, <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>,
    which uses the selected security package but executes in the LSA.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个<samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>
    API选择用于网络身份验证的安全包，并在需要时提供明确的身份验证凭据。它返回一个句柄，供第二个SSPI API <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>使用，该API使用选定的安全包，但在LSA中执行。
- en: The security package in the LSA processes <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>,
    then requests and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    authentication token to the caller. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token describes which authentication features the client supports and should be
    sent to the server over the network protocol. [Listing 13-1](chapter13.xhtml#Lis13-1)
    performs this client initialization in PowerShell.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: LSA中的安全包处理<samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>，然后请求并返回一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>身份验证令牌给调用者。<samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>令牌描述客户端支持的身份验证功能，并应通过网络协议发送到服务器。[列表13-1](chapter13.xhtml#Lis13-1)在PowerShell中执行此客户端初始化。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 13-1: Initializing a client for NTLM authentication and formatting
    a NEGOTIATE authentication token'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-1：初始化NTLM身份验证的客户端并格式化NEGOTIATE身份验证令牌
- en: We start by getting the credentials handle using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>
    command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>.
    By specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Package</samp> parameter, we
    select the use of the NTLM security package. We also specify that these credentials
    are for outbound authentication (that is, from a client to a server). Lastly,
    we specify the username and domain from the current environment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>命令来获取凭据句柄，该命令调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>。通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Package</samp>参数指定<samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp>，我们选择使用NTLM安全包。我们还指定这些凭据用于出站身份验证（即从客户端到服务器）。最后，我们指定当前环境中的用户名和域。
- en: Notice that we do not specify a password; this is because the LSA has already
    cached the password for us in our logon session. The fact that we don’t need to
    specify the password is a key part of *Integrated Windows Authentication (IWA)*,
    which allows users to automatically authenticate to the network authentication
    using their credentials, without prompting them for a password.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有指定密码；这是因为LSA已经在我们的登录会话中缓存了密码。我们不需要指定密码这一事实是*集成 Windows 身份验证（IWA）*的关键部分，它允许用户自动使用其凭据进行网络身份验证，而无需提示他们输入密码。
- en: With the credentials handle, we create a client authentication context by calling
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>
    command and specifying the handle. Under the hood, this command calls the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp> API.
    If the call to the API succeeds, the client context now contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token. We store a copy of the token for later use, then pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    command to parse its contents and print them to the shell.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用凭据句柄，我们通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>命令并指定该句柄来创建客户端身份验证上下文。在后台，此命令调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp> API。如果对API的调用成功，客户端上下文现在包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>令牌。我们存储该令牌的副本以备后用，然后将其传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>命令，以解析其内容并将其打印到Shell中。
- en: The main component of the token is a list of flags that reflect the features
    the client requests, the features the client supports, and which parts of the
    token are valid. In this case, the token has nine flags set, though these can
    change depending on the system’s configuration. [Table 13-1](chapter13.xhtml#tab13-1)
    shows what the flags mean in this context.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-1:</samp> <samp class="SANS_Futura_Std_Book_11">Select
    NTLM Flags</samp>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client supports Unicode strings.</samp> |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client supports byte character strings (for example, ASCII).</samp> |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestTarget</samp> | <samp
    class="SANS_Futura_Std_Book_11">The client requires the server to send a target
    name in the response.</samp> |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests to use the NTLM hash.</samp> |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AlwaysSign</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests that the authentication be signed to ensure integrity.</samp>
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    | <samp class="SANS_Futura_Std_Book_11">The client requests NTLMv2 Session security.</samp>
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client has sent the operating system and NTLM protocol version.</samp> |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests a 128-bit signing key.</samp> |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp> | <samp class="SANS_Futura_Std_Book_11">The
    client requests a 56-bit signing key.</samp> |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: You might wonder why the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    flag is set. This flag changes NTLMv1 to NTLMv2 Session security, but I mentioned
    earlier that NTLMv1 is disabled by default. The LSA sets the flag anyway, just
    in case the server responds with a request for NTLMv1\. Except for <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp>,
    these flags all indicate the features the client requires. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp>
    flag indicates major, minor, and build values of the operating system version,
    as well as the NTLM protocol version, which has been fixed at 15 since Windows
    Server 2003.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: To ensure the integrity of the authentication protocol, NTLM generates an encryption
    key based on the values in the exchange, then uses it to apply a *message integrity
    code (MIC)* to the entire exchange. A MIC is a cryptographic hash of the authentication
    tokens sent and received in the current exchange. It’s used to detect whether
    the authentication tokens have been tampered with over the network.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保身份验证协议的完整性，NTLM 基于交换中的值生成加密密钥，然后使用该密钥为整个交换应用*消息完整性码（MIC）*。MIC 是当前交换中发送和接收的身份验证令牌的加密哈希值，用于检测身份验证令牌在网络中是否被篡改。
- en: Due to cryptography export restrictions, NTLM supports 40-bit keys as well as
    56-bit and 128-bit keys, based on the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp> flags. If neither
    flag is set, NTLM will use 40-bit keys. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    command hides the underlying binary value of the authentication token, but to
    see the token in hex we can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsBytes</samp>
    parameter to this command, as shown in [Listing 13-2](chapter13.xhtml#Lis13-2).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加密出口限制，NTLM 支持 40 位密钥、56 位密钥和 128 位密钥，具体取决于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp> 标志是否存在。如果这两个标志都未设置，NTLM
    将使用 40 位密钥。<samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    命令隐藏了身份验证令牌的底层二进制值，但为了查看十六进制格式的令牌，我们可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">AsBytes</samp>
    参数传递给该命令，如[示例 13-2](chapter13.xhtml#Lis13-2)所示。
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 13-2: Formatting the authentication token in hex'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-2：以十六进制格式显示身份验证令牌
- en: In hex, we can see the data has a format indicator at the beginning of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NTLMSSP</samp> ❶. If you see this indicator
    in data you’re analyzing, there’s a good chance you’ve come across an NTLM network
    authentication process. I won’t display the hex of the rest of the tokens, as
    it’s easy enough to change the script to view the hex output if you’re interested
    in doing so.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制格式中，我们可以看到数据的开头有一个格式指示符 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLMSSP</samp>
    ❶。如果你在分析的数据中看到这个指示符，很可能你遇到了 NTLM 网络身份验证过程。我不会显示其余令牌的十六进制内容，因为如果你有兴趣，修改脚本以查看十六进制输出是非常容易的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing the Server</samp>
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">初始化服务器</samp>
- en: The client has initialized its authentication context and generated a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token. Now it must send
    this token to the server application so that it can initialize its own authentication
    context. When the server receives the token, it passes it to the LSA using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp> API.
    The LSA inspects the token, determines whether it supports the requested features,
    and generates a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    authentication token in response. This token allows the server to verify that
    the client isn’t replaying values captured from a previous authentication exchange.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端已初始化其身份验证上下文并生成了 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    令牌。现在，它必须将此令牌发送给服务器应用程序，以便服务器可以初始化其自身的身份验证上下文。当服务器收到令牌时，它会通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>
    API 将其传递给 LSA。LSA 检查令牌，确定是否支持请求的功能，并生成 <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    身份验证令牌作为响应。此令牌允许服务器验证客户端是否没有重放从先前身份验证交换中捕获的值。
- en: Let’s use PowerShell to demonstrate the server’s handling of NTLM. In [Listing
    13-3](chapter13.xhtml#Lis13-3), we create the server authentication context in
    the same process as the client’s (remember, however, that the server will typically
    run on a different system).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 PowerShell 演示服务器如何处理 NTLM。在[示例 13-3](chapter13.xhtml#Lis13-3)中，我们在与客户端相同的进程中创建服务器身份验证上下文（但请记住，服务器通常会运行在不同的系统上）。
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 13-3: Initializing the server for NTLM authentication and formatting
    the CHALLENGE authentication token'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-3：初始化 NTLM 身份验证服务器并格式化 CHALLENGE 身份验证令牌
- en: We start by creating the inbound credentials handle. You don’t need to provide
    any credentials to do this; in fact, NTLM would ignore the credentials even if
    you did provide them. Next, we create the server’s authentication context and
    provide the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>
    API by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    PowerShell command. If the LSA accepts the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token, the server context will include its own token, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token. As before, we capture the token for later use and pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    to print out the information it contains.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建入站凭据句柄。创建此句柄时无需提供任何凭据；事实上，即使您提供了凭据，NTLM 也会忽略它们。接下来，我们创建服务器的认证上下文，并通过调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp> PowerShell
    命令，将客户端的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> 令牌提供给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp> API。如果
    LSA 接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> 令牌，服务器上下文将包含其自身的令牌，即
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> 令牌。如前所述，我们捕获该令牌以供后续使用，并将其传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp> 来打印出其中包含的信息。
- en: The token’s flags represent the values that the network authentication process
    supports and are based on the flags the client sent. For example, in [Listing
    13-1](chapter13.xhtml#Lis13-1) we saw that the client set both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp> string format
    flags in its <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token,
    indicating that it can support both Unicode and byte character format strings.
    The server has elected to send strings in Unicode format, so it has cleared the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> flag in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的标志表示网络认证过程支持的值，并且基于客户端发送的标志。例如，在 [Listing 13-1](chapter13.xhtml#Lis13-1)
    中，我们看到客户端在其 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> 令牌中设置了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp>
    字符串格式标志，表示它可以支持 Unicode 和字节字符格式字符串。服务器选择以 Unicode 格式发送字符串，因此它在 <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    令牌中清除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> 标志。
- en: As requested by the client, the output also contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>,
    which in this case is the domain name of the server, indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeDomain</samp>
    flag. If the server were not in a domain network, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>
    would be the server’s computer name, and the token would use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeServer</samp>
    flag instead.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据客户端的要求，输出中还包含了 <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>，在此情况下，它是服务器的域名，由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeDomain</samp> 标志指示。如果服务器不在域网络中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp> 将是服务器的计算机名称，令牌将使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeServer</samp> 标志。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token contains
    a random 8-byte server challenge generated by the LSA. All values calculated in
    the next step depend on the challenge’s value; because it’s different for every
    request, this prevents an attacker from capturing a previous authentication exchange
    and replaying it to the server. The final part of the token is the target information,
    indicated by the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetInfo</samp>
    flag. This contains additional details about the server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> 令牌包含由 LSA 生成的随机
    8 字节服务器挑战。接下来的步骤中计算的所有值都依赖于挑战值；由于它对于每个请求都是不同的，这就防止了攻击者捕获先前的认证交换并将其重放到服务器上。令牌的最后部分是目标信息，通过存在的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetInfo</samp> 标志来表示。这部分包含有关服务器的附加信息。
- en: Note that NTLM can work in a connectionless mode, in which the client never
    sends the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    message. In this case, the authentication process starts with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    message from the server. However, connectionless NTLM authentication is rarely
    used in practice.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，NTLM可以在无连接模式下工作，在这种模式下，客户端永远不会发送初始的<samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>消息。在这种情况下，认证过程从服务器发送的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>消息开始。然而，无连接NTLM认证在实际应用中很少使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Passing the Token Back to
    the Client</samp>
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将令牌传回客户端</samp>
- en: Next, the server must send the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token to the client’s authentication context. In a real network protocol, this
    would happen over the network, but in [Listing 13-4](chapter13.xhtml#Lis13-4)
    we pass the token in the same script.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，服务器必须将<samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>令牌发送到客户端的认证上下文。在实际的网络协议中，这将在网络上发生，但在[列表13-4](chapter13.xhtml#Lis13-4)中，我们将令牌传递到相同的脚本中。
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 13-4: Updating the client for NTLM authentication and formatting the
    AUTHENTICATE token'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13-4：为NTLM认证更新客户端并格式化AUTHENTICATE令牌
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaClientContext</samp>
    command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    once again with the original credentials handle and the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token. If <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    accepts the token, the LSA generates the final <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token, which we can then format. This is the only token that depends on the value
    of the password; the other two tokens can be generated without any special knowledge.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaClientContext</samp>命令，它再次调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>，并使用原始的凭证句柄和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>令牌。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>接受该令牌，LSA将生成最终的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌，然后我们可以对其进行格式化。这是唯一一个依赖于密码值的令牌；其他两个令牌则可以在没有任何特殊知识的情况下生成。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token
    starts with the final negotiated flags and the information about the user, including
    their username and domain. Because we’re using a local account, the domain is
    set to the workstation name, <samp class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>.
    Next comes the LM response, which in this case is all zeros ❶. The LM response
    is normally disabled, which is why it’s not specified, and NTLMv2 doesn’t use
    the LM hash at all.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌以最终商定的标志和有关用户的信息开始，包括他们的用户名和域。因为我们使用的是本地账户，域被设置为工作站名称<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>。接下来是LM响应，在本例中是全零❶。LM响应通常被禁用，这就是为什么它没有被指定，而NTLMv2根本不使用LM哈希。
- en: We now continue to the full NTLMv2 response, which contains a lot of information.
    First is the 8-byte NT response ❷, also called the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTProofStr</samp>
    in the protocol’s documentation. We’ll come back to how this value is calculated
    in a moment. After the NT response are various parameters about the protocol,
    including the 8-byte client challenge ❸. NTLMv1 already contained the server challenge
    to prevent replay, but NTLMv2 added the client challenge to make it harder for
    an attacker to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to crack the user’s password.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们继续讲解完整的NTLMv2响应，它包含了大量的信息。首先是8字节的NT响应❷，也叫做协议文档中的<samp class="SANS_TheSansMonoCd_W5Regular_11">NTProofStr</samp>。稍后我们将回顾这个值是如何计算的。在NT响应之后，是一些关于协议的其他参数，包括8字节的客户端挑战❸。NTLMv1已经包含了服务器挑战，以防止重放攻击，但NTLMv2增加了客户端挑战，使得攻击者更难使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌破解用户的密码。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token
    copies most of its target information from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    message, although it contains a few additional entries. The flags indicate that
    the message contains a MIC with the <samp class="SANS_TheSansMonoCd_W5Regular_11">MessageIntegrity</samp>
    value ❹, as you’ll soon see. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleHost</samp>
    flag contains a random ID for the client machine that generated the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token ❺. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp> ❻ values are
    used to prevent credential relaying, an attack we’ll also come back to later;
    in this case, the flags aren’t specified. Last is the MIC, a keyed MD5 hash-based
    message authentication code (HMAC) calculated over the authentication tokens sent
    and received for the current exchange ❼. The key for the hash is calculated during
    the authentication process, and the MIC serves to detect whether the tokens have
    been tampered with.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌从<samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>消息复制了大部分目标信息，尽管它还包含了一些额外的条目。标志位表明该消息包含了带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MessageIntegrity</samp>值❹的MIC，正如你将很快看到的那样。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SingleHost</samp>标志包含了生成<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌的客户端机器的随机ID❺。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>❻值用于防止凭证转发攻击，我们稍后也会讲到；在这种情况下，标志未指定。最后是MIC，它是一个基于MD5哈希的消息认证码（HMAC），该码是通过对当前交换中发送和接收的认证令牌进行计算得到的❼。哈希的密钥是在认证过程中计算出来的，而MIC用于检测令牌是否被篡改。
- en: The client sends the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to the server, which again calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>,
    passing it the token. The LSA runs the calculations needed to verify that the
    NT response matches the expected value and that the MIC is valid, indicating the
    tokens haven’t been tampered with. If both values match the expected values, the
    authentication succeeds.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌发送到服务器，服务器再次调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>，并将令牌传递给它。LSA运行所需的计算，以验证NT响应是否与预期值匹配，以及MIC是否有效，指示令牌没有被篡改。如果两个值与预期的值匹配，则认证成功。
- en: 'There are several differences between the formatted output generated by NTLMv1
    and NTLMv2\. First, if NTLMv1 is in use, the NT response in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token will be a 24-byte binary value rather than the structured response seen
    in [Listing 13-4](chapter13.xhtml#Lis13-4). For example, it might look like the
    following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: NTLMv1和NTLMv2生成的格式化输出之间有几个不同之处。首先，如果使用的是NTLMv1，那么<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌中的NT响应将是一个24字节的二进制值，而不是[示例13-4](chapter13.xhtml#Lis13-4)中看到的结构化响应。例如，它可能如下所示：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also differentiate between NTLMv1 and NTLMv2 Session by looking at
    the flags and LM hash. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>
    flag is set, you know that NTLMv2 Session is in use; otherwise, the system is
    using NTLMv1\. The LM hash field gets repurposed to contain the client challenge
    in NTLMv2, which might confuse you, as you might assume an LM hash has been negotiated.
    You can tell the difference between a hash and a client challenge because the
    client challenge is only 8 bytes long, as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过查看标志位和LM哈希来区分NTLMv1和NTLMv2会话。如果设置了<samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp>标志，你就知道正在使用NTLMv2会话；否则，系统正在使用NTLMv1。LM哈希字段在NTLMv2中被重新用于包含客户端挑战，这可能会让你感到困惑，因为你可能会误以为LM哈希已经进行了协商。你可以通过检查哈希和客户端挑战之间的区别来分辨两者，因为客户端挑战只有8字节长，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The remaining 16 bytes are padded with zeros.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的16个字节会被零填充。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Requesting a Token Object</samp>
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">请求令牌对象</samp>
- en: Now that the authentication process has completed, the server can request that
    the LSA generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object for the authenticated user through the <samp class="SANS_TheSansMonoCd_W5Regular_11">QuerySecurityContextToken</samp>
    API, as shown in [Listing 13-5](chapter13.xhtml#Lis13-5).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在身份验证过程已完成，服务器可以请求 LSA 通过<samp class="SANS_TheSansMonoCd_W5Regular_11">QuerySecurityContextToken</samp>
    API 为已验证的用户生成一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象，如[清单
    13-5](chapter13.xhtml#Lis13-5)所示。
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 13-5: Completing the NTLM authentication process'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-5：完成 NTLM 身份验证过程
- en: We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    again to finalize the authentication process. Once all tokens have been transferred,
    the client and server contexts are placed into a *done state*, meaning they no
    longer need any more information to complete the authentication process. You can
    verify this state using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContext</samp>
    command.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先再次调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>来完成身份验证过程。一旦所有令牌被传输，客户端和服务器上下文将进入*完成状态*，这意味着它们不再需要任何其他信息来完成身份验证过程。你可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContext</samp>命令来验证这个状态。
- en: With the authentication completed, we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaAccessToken</samp>
    command to return the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object for the user. We display the logon session for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    and verify that it used network authentication.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完成身份验证后，我们可以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaAccessToken</samp>命令，返回用户的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象。我们显示该<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>的登录会话，并验证它是否使用了网络身份验证。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Cryptographic
    Derivation Process</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加密派生过程</samp>
- en: The NTLM process never discloses the user’s password in plaintext on the network.
    Even so, NTLM uses the password’s value to derive the final NT response and MIC.
    Let’s use PowerShell to walk through this cryptographic derivation process and
    generate the NT response and MIC. To perform the derivation, we’ll need the user’s
    password, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> authentication
    tokens.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM 过程从不在网络上传输用户的明文密码。尽管如此，NTLM 仍然使用密码的值来派生最终的 NT 响应和 MIC。让我们使用 PowerShell
    来逐步演示这个加密派生过程，并生成 NT 响应和 MIC。为了进行派生，我们需要用户的密码，以及<samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>身份验证令牌。
- en: We also need a function that calculates the MD5 HMAC for a set of bytes. The
    MD5 HMAC is a keyed cryptographic hashing algorithm commonly used to sign data
    so its integrity can be verified. We’ll use this function, defined in [Listing
    13-6](chapter13.xhtml#Lis13-6), multiple times in the derivation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来计算一组字节的 MD5 HMAC。MD5 HMAC 是一种带密钥的加密哈希算法，通常用于签名数据，以便验证其完整性。在派生过程中，我们将多次使用此函数，定义在[清单
    13-6](chapter13.xhtml#Lis13-6)中。
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 13-6: Defining the Get-Md5Hmac function'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-6：定义 Get-Md5Hmac 函数
- en: 'The function is simple: it creates the .NET class <samp class="SANS_TheSansMonoCd_W5Regular_11">HMACMD5</samp>,
    passing it a key ❶, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ComputeHash</samp>
    on the data ❷. If the data is a string, it first converts it to a byte array in
    Unicode encoding.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很简单：它创建了一个 .NET 类<samp class="SANS_TheSansMonoCd_W5Regular_11">HMACMD5</samp>，并传递给它一个密钥
    ❶，然后对数据 ❷调用<samp class="SANS_TheSansMonoCd_W5Regular_11">ComputeHash</samp>。如果数据是一个字符串，它首先会将其转换为
    Unicode 编码的字节数组。
- en: The next function we define calculates the *NT one-way function version 2 (NTOWFv2)*,
    shown in [Listing 13-7](chapter13.xhtml#Lis13-7). This function converts the username,
    domain, and password into a 16-byte key for further use.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的下一个函数计算*NT 单向函数版本 2 (NTOWFv2)*，如[清单 13-7](chapter13.xhtml#Lis13-7)所示。此函数将用户名、域名和密码转换为一个
    16 字节的密钥，供进一步使用。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 13-7: Defining the NT one-way function'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-7：定义 NT 单向函数
- en: First, note that the system hashes the password using the MD4 algorithm ❶. As
    mentioned previously, the SAM database stores these MD4 hashes so that the LSA
    doesn’t need to store their plaintext versions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意系统使用 MD4 算法对密码进行哈希 ❶。如前所述，SAM 数据库存储这些 MD4 哈希，以便 LSA 不需要存储其明文版本。
- en: We supply the MD4 hash of the password as a key to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>
    function, then use this function to hash the uppercase username concatenated to
    the domain ❷. In this case, these values are <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>, so we hash
    the string <samp class="SANS_TheSansMonoCd_W5Regular_11">USERGRAPHITE</samp>.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将密码的MD4哈希作为密钥提供给<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>函数，然后使用此函数对与域名连接的用户名的大写形式进行哈希
    ❷。在此情况下，这些值为<samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>，因此我们对字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">USERGRAPHITE</samp>进行哈希。
- en: To perform this operation, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtOwfv2</samp>
    function we just defined with the username and domain from the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token ❸, which we stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">$authToken</samp>
    variable. The function produces a 16-byte key ❹.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为执行此操作，我们调用刚刚定义的<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtOwfv2</samp>函数，传入来自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>标记的用户名和域名 ❸，这些值我们存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">$authToken</samp>变量中。该函数会生成一个16字节的密钥 ❹。
- en: Now that we have a key based on the user’s password, we’ll use it to calculate
    the NT response value with the function defined in [Listing 13-8](chapter13.xhtml#Lis13-8).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基于用户密码的密钥，我们将使用它通过[Listing 13-8](chapter13.xhtml#Lis13-8)中定义的函数计算NT响应值。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 13-8: Calculating the NtProofStr value'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-8：计算NtProofStr值
- en: We perform the calculation of the NT response using the NTOWFv2 key as well
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> tokens. First we concatenate
    the 8-byte server challenge from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtChallengeResponse</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token,
    minus the supplied 16-byte NT response ❶. Then we calculate the NT value using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp> function,
    with NTOWFv2 as the key ❷. The result ❸ should match the NT response value from
    [Listing 13-4](chapter13.xhtml#Lis13-4) (if you used your actual password rather
    than the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">pwd</samp> placeholder
    used in the listing).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用NTOWFv2密钥以及<samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>标记进行NT响应计算。首先，我们将来自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>标记的8字节服务器挑战与来自<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>标记的<NtChallengeResponse>进行连接，减去提供的16字节NT响应
    ❶。然后，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>函数计算NT值，密钥为NTOWFv2
    ❷。结果 ❸ 应该与[Listing 13-4](chapter13.xhtml#Lis13-4)中的NT响应值匹配（如果您使用的是实际密码而不是列表中使用的<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">pwd</samp>占位符）。
- en: The server can now verify that the client has access to the correct password
    for the user by checking whether the two NT response values match. However, we
    still want to verify that the messages haven’t been tampered with in some way,
    so we need to calculate the MIC. We define the function to do this in [Listing
    13-9](chapter13.xhtml#Lis13-9).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器现在可以通过检查两个NT响应值是否匹配来验证客户端是否有权访问用户的正确密码。然而，我们仍然希望验证消息是否未被以某种方式篡改，因此我们需要计算MIC。我们在[Listing
    13-9](chapter13.xhtml#Lis13-9)中定义了执行此操作的函数。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 13-9: Calculating the message integrity code'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-9：计算消息完整性代码
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp> function takes
    five parameters: the NTOWFv2 key, the NT response, and all three tokens transmitted
    back and forth between the client and server. The first task is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>
    again to calculate a session key ❶. We use the NTOWFv2 key for this HMAC operation
    and supply the NT response as data. Next, we zero the MIC field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token ❷, then concatenate the tokens ❸. We pass the session key and the concatenated
    tokens to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp> to
    generate the MIC ❹. The value of the MIC ❺ should match the one generated in [Listing
    13-4](chapter13.xhtml#Lis13-4).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp> 函数接受五个参数：NTOWFv2
    密钥、NT 响应以及客户端与服务器之间传递的所有三个令牌。首先的任务是再次使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>
    来计算会话密钥 ❶。我们使用 NTOWFv2 密钥进行该 HMAC 操作，并提供 NT 响应作为数据。接下来，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌中的 MIC 字段置为零 ❷，然后将令牌连接起来 ❸。我们将会话密钥和连接后的令牌传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp>
    来生成 MIC ❹。MIC 的值 ❺ 应该与在 [清单 13-4](chapter13.xhtml#Lis13-4) 中生成的值相匹配。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pass-Through Authentication</samp>
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">透传认证</samp>
- en: For the client and server to successfully authenticate using NTLM, both parties
    must know the user’s password (or, more precisely, its NT hash). If you’re authenticating
    to a stand-alone machine, the password must be set in the machine’s local SAM
    database. Configuring this value isn’t too difficult in a small network, but on
    a large network consisting of many machines, doing it manually becomes unmanageable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使客户端和服务器能够成功地使用 NTLM 进行认证，双方必须知道用户的密码（或者，更准确地说，是其 NT 哈希值）。如果你正在对一个独立的机器进行认证，密码必须设置在该机器的本地
    SAM 数据库中。在一个小型网络中配置这个值并不困难，但在一个由许多机器组成的大型网络中，手动进行此操作变得难以管理。
- en: On a domain network, the domain controller is responsible for managing the user’s
    NT hash. So how can NTLM function in such an environment? The Netlogon service
    on the domain controller supports the concept of *pass-through authentication*
    to facilitate NTLM authentication on other systems in the domain. [Figure 13-2](chapter13.xhtml#fig13-2)
    provides an example of the NTLM authentication process in a domain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在域网络中，域控制器负责管理用户的 NT 哈希值。那么，NTLM 如何在这样的环境中工作呢？域控制器上的 Netlogon 服务支持 *透传认证* 概念，以便在域内的其他系统上促进
    NTLM 认证。[图 13-2](chapter13.xhtml#fig13-2) 提供了域中 NTLM 认证过程的示例。
- en: '![](../images/Figure13-2.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: An overview of
    NTLM pass-through authentication</samp>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-2：NTLM 透传认证概述</samp>
- en: 'The NTLM authentication process begins normally: the client sends the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token to the server ❶,
    which generates a challenge and returns it to the client in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token ❷. The client then uses the user’s NT hash to generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token and sends it to the server ❸.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM 认证过程正常开始：客户端将 <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    令牌发送到服务器 ❶，服务器生成挑战并通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    令牌返回给客户端 ❷。然后客户端使用用户的 NT 哈希值生成 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌，并将其发送到服务器 ❸。
- en: At this point, problems arise. The server doesn’t have the user’s NT hash, so
    it can’t derive necessary cryptographic values such as the NT challenge. Therefore,
    the server packages up the server challenge and the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token and sends these to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp>
    API on the domain controller ❹. You might recall from [Chapter 12](chapter12.xhtml)
    that Windows uses this API for interactive authentication. The API has multiple
    modes, one of which can verify the NTLM authentication values without needing
    the user’s password.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，问题出现了。服务器没有用户的 NT 哈希值，因此无法推导出必要的加密值，例如 NT 挑战。因此，服务器将服务器挑战和 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌打包，并将其发送到域控制器上的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp>
    API ❹。你可能还记得在[第 12 章](chapter12.xhtml)中，Windows 使用该 API 进行交互式认证。该 API 有多种模式，其中一种可以在不需要用户密码的情况下验证
    NTLM 认证值。
- en: Note that the domain controller doesn’t verify the MIC, as this requires all
    three authentication tokens. Instead, the server calculates the session key used
    for verification based on the user’s NT hash and NT challenge value and returns
    it to the requesting server. This allows it to ensure that the authentication
    hasn’t been tampered with.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The Windows server never has access to the user’s full password or NT hash,
    only the session key. This results in the *double hop problem*: the authenticated
    user can access resources stored locally on the server, but that user cannot be
    used to access resources on other servers on the domain network.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, this is a good thing, as it prevents a malicious
    service from repurposing a user’s identity. However, it also reduces flexibility,
    as it means that you can’t trivially implement an authenticated proxying service
    without requiring the user to reauthenticate to each service behind that proxy.
    Kerberos solves the double hop problem using delegation, as I’ll describe in more
    detail in [Chapter 14](chapter14.xhtml).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Loopback Authentication</samp>
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the previous example, I chose to specify a username and domain when getting
    the outbound authentication credentials handle. While Integrated Windows Authentication
    doesn’t require you to specify either a username or a domain, you need to do so
    if you want to create a network logon session on the local machine. Let’s change
    the script in [Listing 13-1](chapter13.xhtml#Lis13-1) to build the outbound credentials
    without a username or domain:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now rerun the authentication session. The formatted tokens should look like
    those in [Listing 13-10](chapter13.xhtml#Lis13-10).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 13-10: The formatted tokens from a local loopback authentication'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that all three authentication tokens have changed. The first
    change is in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token, which now contains a domain name and workstation name ❶. The next changes
    are in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token:
    a new flag has appeared, <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    ❷, and a previously zeroed <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserved</samp>
    field now has a value ❸. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag signifies that the authentication comes from the local machine, while the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserved</samp> field is a unique
    identifier for the server security context that created the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The final changes are in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token. While the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag is still present ❹, both the <samp class="SANS_TheSansMonoCd_W5Regular_11">LM
    Response</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NT Response</samp>
    fields are completely empty ❺. This clearly signifies that the authentication
    process has changed. If we check the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s logon session, we see that it’s an interactive session instead of a network
    session ❻. The reason for this is that the LSA has returned a copy of the caller’s
    token to the server, as you can see by comparing the logon ID to the authentication
    ID from the effective token ❼.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改出现在<samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>令牌中。尽管<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>标志仍然存在❹，但<samp class="SANS_TheSansMonoCd_W5Regular_11">LM
    Response</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">NT Response</samp>字段完全为空❺。这清楚地表明认证过程已发生变化。如果我们检查最终<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象的登录会话，会发现它是交互式会话，而非网络会话❻。原因在于LSA已将调用者的令牌副本返回给服务器，正如通过比较登录ID与有效令牌中的认证ID所看到的❼。
- en: Let’s take a closer look at the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag. Its value is based on the domain and workstation names in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    authentication token. If these values refer to the local machine, local loopback
    authentication is enabled. There are no other unique identifiers in the initial
    token to key the flag on, and there doesn’t need to be an ongoing outbound authentication
    process for the flag to be selected. Also, the flag is not specified in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token’s flags, so it’s
    not negotiated between the client and server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下<samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>标志。它的值基于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>认证令牌中的域名和工作站名称。如果这些值指向本地机器，则启用本地回环认证。初始令牌中没有其他唯一标识符来设定该标志，且不需要进行持续的外向认证过程来选择该标志。此外，该标志并未在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>令牌的标志中指定，因此它不会在客户端和服务器之间进行协商。
- en: At the time of writing, Microsoft does not document the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>
    flag in *MS-NLMP*, presumably because it shouldn’t be supported outside of the
    local machine. However, as you can see, merely providing the right <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token causes local loopback authentication to kick in. Documenting this flag would
    make it easier to diagnose authentication failures that could occur if the flag
    were present over the network.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，微软并未在*MS-NLMP*中文档化<samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp>标志，可能是因为它不应该在本地机器之外被支持。然而，正如您所看到的，仅仅提供正确的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>令牌就会触发本地回环认证。文档化该标志可以更容易地诊断可能在网络中出现的认证失败问题。
- en: Why does the LSA implement local loopback authentication? One reason is that
    network authentication would cause the user to be reauthenticated, and some local
    services, such as SMB, allow local interactive users, but not network users, to
    access file shares. Therefore, this local loopback allows the SMB server to see
    a local user and grant access.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么LSA要实现本地回环认证？一个原因是网络认证会导致用户被重新认证，而一些本地服务，如SMB，允许本地交互式用户访问文件共享，但不允许网络用户访问。因此，这种本地回环使得SMB服务器能够看到本地用户并授予访问权限。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Alternative Client
    Credentials</samp>
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">替代客户端凭证</samp>
- en: We’ve seen how to use PowerShell commands to authenticate as the calling user.
    This is normally the behavior you’ll want to implement, as the current user typically
    aims to access some network resource as themselves. However, the underlying APIs
    support several mechanisms that allow you to authenticate as a different user
    over the network. Changing your user identity is useful because it enables you
    to access a network resource without reauthenticating interactively.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用PowerShell命令以调用用户的身份进行认证。这通常是您希望实现的行为，因为当前用户通常旨在以自己身份访问一些网络资源。然而，底层API支持几种机制，允许您通过网络以不同用户的身份进行认证。更改用户身份非常有用，因为它使您能够在不进行交互式重新认证的情况下访问网络资源。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Explicit Credentials</samp>
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you know the new user’s full credentials, you can specify them when creating
    the credentials handle for the client authentication context. To do this, call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp> and
    pass it the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Domain</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Password</samp>
    parameters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: However, you probably don’t want to leave a user’s password in PowerShell’s
    command history. One alternative is to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadCredential</samp>
    parameter, which will read the credentials from the user without storing them
    in the command history. [Listing 13-11](chapter13.xhtml#Lis13-11) shows an example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 13-11: Creating a credentials handle with user-specified credentials'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: You can now pass the credentials handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>
    to create the client context. You don’t need to change the server side, which
    uses the credentials managed by the LSA.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Impersonating a Token</samp>
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When creating the credentials handle, the LSA usually determines the network
    credentials to use based on the calling user’s identity, which it retrieves from
    the primary token of the process that calls the SSPI API. However, if you have
    a different user’s token, you can impersonate them while creating the credentials
    handle to use a different identity. Run the command in [Listing 13-12](chapter13.xhtml#Lis13-12)
    as an administrator.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 13-12: Creating the credentials handle for the <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp>
    user'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 13-12](chapter13.xhtml#Lis13-12), we create a credentials handle
    for the *SYSTEM* user. The *SYSTEM* user doesn’t have any explicit password you
    can use to authenticate using the approach in [Listing 13-11](chapter13.xhtml#Lis13-11);
    therefore, you must impersonate the token to create a credentials handle for it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: You need to impersonate the token only once, when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>
    command. All subsequent calls used to create and update the client context don’t
    require you to impersonate the token.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: If you have the full credentials, another approach you could use is to create
    the token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    logon type, briefly mentioned in [Chapter 12](chapter12.xhtml). This will create
    a token with the same local user identity but replace the network authentication
    credentials, as illustrated in [Listing 13-13](chapter13.xhtml#Lis13-13).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 13-13: Creating a credentials handle with a NewCredentials token'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create a credentials handle by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command to generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>-type
    token, then impersonating it when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    命令生成一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> 类型的令牌，然后在调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp> 时进行模拟。
- en: You might be wondering why, if you know the full credentials, you wouldn’t just
    specify them directly when creating the credentials handle. In this example, this
    would indeed be the simpler solution. However, you sometimes won’t have direct
    control over the creation of the credentials handle. This can happen if the network
    authentication occurs within another API that uses the caller’s identity to access
    a remote resource. In that case, you can impersonate the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    token while calling the API to use the credentials you specified. Importantly,
    only the network credentials will change due to impersonation; the local identity
    will stay the same, so you won’t accidentally access local resources with the
    wrong user account.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，如果你知道完整的凭据，为什么不在创建凭据句柄时直接指定它们呢？在这个例子中，确实这是更简单的解决方案。然而，有时你无法直接控制凭据句柄的创建。如果网络认证发生在另一个
    API 中，该 API 使用调用者的身份访问远程资源，那么就会出现这种情况。在这种情况下，你可以在调用 API 时模拟 <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    令牌，使用你指定的凭据。重要的是，由于模拟，只有网络凭据会发生变化；本地身份保持不变，因此你不会不小心使用错误的用户帐户访问本地资源。
- en: Let’s finish this chapter by describing a practical attack against the NTLM
    authentication protocol. This attack allows you to repurpose the credentials of
    another user without needing to know the user’s password.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过描述一个针对 NTLM 认证协议的实际攻击来结束本章。此攻击允许你在不需要知道用户密码的情况下，重新利用其他用户的凭据。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The NTLM Relay Attack</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">NTLM 中继攻击</samp>
- en: 'One thing you might notice about NTLM is that, while the LSA performs the authentication,
    it’s up to the client and server applications to transport the authentication
    tokens. How does the LSA ensure that it’s authenticating to the right computer?
    It can’t do this directly: it needs the help of the client and server applications.
    This causes a security vulnerability that an actor could exploit with an attack
    called an *NTLM relay*. In this section, we’ll explore this attack and how Microsoft
    has tried to fix the vulnerability.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 NTLM 的一个特点：尽管 LSA 执行认证，但客户端和服务器应用程序负责传输认证令牌。那么，LSA 如何确保它正在对正确的计算机进行认证呢？它无法直接做到这一点：它需要客户端和服务器应用程序的帮助。这就导致了一个安全漏洞，攻击者可以利用一个叫做
    *NTLM 中继* 的攻击来进行利用。在本节中，我们将探讨这种攻击以及微软如何尝试修复这个漏洞。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Attack Overview</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">攻击概述</samp>
- en: '[Figure 13-3](chapter13.xhtml#fig13-3) shows the basic setup of an NTLM relay
    attack.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-3](chapter13.xhtml#fig13-3) 展示了 NTLM 中继攻击的基本设置。'
- en: '![](../images/Figure13-3.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: An example of
    an NTLM relay attack</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-3：NTLM 中继攻击的示例</samp>
- en: 'Three systems are involved: a Windows client machine, a Windows server, and
    the attacker’s machine. The attacker’s goal is to access the SMB file share on
    the server. However, they don’t have the credentials necessary to successfully
    perform NTLM authentication. The client, on the other hand, does have suitable
    credentials, and because of Interactive Windows Authentication, it will use those
    credentials without user interaction if asked nicely.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个攻击涉及三个系统：一个 Windows 客户端机器、一个 Windows 服务器和攻击者的机器。攻击者的目标是访问服务器上的 SMB 文件共享。然而，他们没有成功执行
    NTLM 认证所需的凭据。另一方面，客户端确实拥有合适的凭据，并且由于交互式 Windows 认证，如果请求得当，它会在不与用户交互的情况下使用这些凭据。
- en: The first step is for the attacker to convince the client machine to connect
    to the attacker’s web server. While the attacker wants to access SMB, the NTLM
    authentication from the client can be over any protocol that supports authentication,
    including HTTP. Convincing the client to make a connection could be as simple
    as adding an image to a web page the client visits that points to the attacker’s
    web server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The attacker accepts the client’s HTTP connection and starts the NTLM authentication
    process, which results in the client sending a <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token to the attacker ❶. Instead of processing the token, the attacker now opens
    a new connection to the target SMB server and passes along the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp>
    token as if they had created it ❷.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The SMB server will respond with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp>
    token, and the attacker can forward this to the client to continue the authentication
    process ❸. The client should respond with an <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to the attacker’s web server, which it can forward to the SMB server ❹.
    Assuming the server accepts the client’s credentials, the attacker has now established
    an authenticated connection to the SMB server without ever knowing the user’s
    password.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'This attack is a serious security issue. Microsoft has tried to implement various
    fixes, mainly by adding more features to NTLM. However, the problem with these
    fixes is that they’re opt-in, for backward compatibility reasons: NTLM and SMB
    are such old protocols that certain clients and servers don’t support the new
    features. Still, let’s discuss the ways that Windows mitigates the vulnerability.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Active Server Challenges</samp>
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest way of performing an NTLM relay attack is to authenticate back
    to the victim’s machine. For example, in [Figure 13-3](chapter13.xhtml#fig13-3),
    the HTTP client and the SMB server could live on the same Windows machine. If
    the machine is both the client and the server, the authentication credentials
    will always be valid.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: To fix this attack, Windows began maintaining a table of currently active server
    challenges and refusing to create the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token if the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token
    included a server challenge issued by the same machine. There is a small chance
    of a collision occurring between two machines, but with a random 8-byte challenge,
    this will rarely happen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Signing and Sealing</samp>
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another way of combatting the NTLM relay attack is to make the outer protocol
    containing the NTLM authentication, such as SMB, rely on the authentication process
    in some way. This boils down to using the only piece of information the attacker
    doesn’t have: the user’s password.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The SSPI APIs and NTLM support the inclusion of a randomly generated session
    key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token
    that is encrypted by the user’s password. This session key can then be used to
    generate a MIC, which the documentation refers to as *signing*. The MIC is generated
    for the outer protocol using the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp>
    SSPI API and verified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp>
    API. The key can also be used to encrypt and decrypt arbitrary data using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs, which the
    documentation refers to as *sealing*. Because the attacker can’t decrypt the session
    key without knowing the password, they can’t generate valid signed or encrypted
    data to communicate with the relayed server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'To request a session key, you specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> flag when creating
    the client or server context by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestAttribute</samp>
    parameter. For example, when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>,
    you can specify the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Listing 13-14](chapter13.xhtml#Lis13-14) shows the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token if we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp>
    request attribute flag when creating the client and server contexts.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 13-14: Checking the AUTHENTICATE token for the session key'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: As the output shows, this changes the NTLM process in two important ways. First,
    the NTLM <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyExchange</samp> flag
    has been added ❶. This flag indicates that the client has generated a session
    key. The flags also now include <samp class="SANS_TheSansMonoCd_W5Regular_11">Signing</samp>,
    which indicates to the server that the client wants to allow the signing of content
    based on the session key. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp>
    request attribute flag is used, two <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    flags are set, <samp class="SANS_TheSansMonoCd_W5Regular_11">Signing</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sealing</samp>.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: If either flag is set, the NTLMv2 challenge contains an encrypted session key
    that the client generated ❷. This is the base key used for all further cryptographic
    operations. The key is encrypted using the RC4 encryption algorithm and a key
    derived from the user’s hash and the NT response.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: If you verify the MIC after enabling signing or sealing, you’ll notice that
    the value generated no longer matches the one in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token. This is because if the encrypted session key is available, it’s used instead
    of the base session key. You can fix this behavior by modifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp>
    function shown in [Listing 13-9](chapter13.xhtml#Lis13-9), adding the bold portion
    in [Listing 13-15](chapter13.xhtml#Lis13-15).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 13-15: Modifying the Get-Mic function to decrypt the session key for
    the MIC calculation'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp> APIs are exposed
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaContextSignature</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp>
    commands, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs are
    exposed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    commands. We’ll cover the use of these encryption commands in the worked example
    at the end of this chapter; for now, [Listing 13-16](chapter13.xhtml#Lis13-16)
    shows a simple use of the signature commands.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 13-16: Generating and verifying a message signature'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: We start by completing the client-to-server authentication process to set up
    integrity support ❶. We then generate a signature for a simple 4-byte message
    using the client authentication context ❷. This process assumes that the data
    is being sent to the server for verification; we can reverse it by specifying
    a different authentication context. We display the generated signature value as
    hex.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We then verify the signature with the server authentication context using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp>
    command ❸. The command returns a Boolean value indicating whether the signature
    is valid. For this call, the verification returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    However, if we check the signature a second time ❹, we now get <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    indicating that it is no longer valid. Why is that?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The client and server authentication contexts maintain a *sequence number*,
    which starts at 0 and increments for every signature or encryption operation.
    This sequence number is automatically included when generating or verifying a
    signature, and the server can use it to check whether an old signature has been
    replayed (for example, if an attacker is trying to send the same network data
    twice).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: In the example in [Listing 13-16](chapter13.xhtml#Lis13-16), we generated the
    client’s signature with a sequence number of 0\. In the first verification, the
    server’s authentication context also has an initial value of 0, so the verification
    succeeds. However, after the verification completes, the server’s sequence number
    is incremented to 1\. So, when we try to verify the same signature again, the
    sequence numbers no longer match, and the verification fails.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The RC4 encryption algorithm used for signing and sealing has numerous weaknesses,
    which are outside the scope of this book. However, it offers some level of mitigation
    against NTLM relay attacks and provides basic integrity and confidentiality protections
    to the outer network protocol if no other key exchange mechanism is in place.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: SMB supports signing and encryption derived from the authentication process.
    However, because of the weakness of RC4, SMB doesn’t use the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> APIs; instead,
    it extracts the decrypted session key using the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryContextAttribute</samp>
    SSPI API and uses its own encryption and integrity-checking algorithms. You can
    query for the session key by accessing the <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionKey</samp>
    property on the client or server authentication context, as shown in [Listing
    13-17](chapter13.xhtml#Lis13-17).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 13-17: Extracting the session keys for the authentication context'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Target Names</samp>
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another technique for blocking NTLM relay attacks is to add an identifier to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token that
    indicates the name of the target the NTLM authentication is for. Because the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token is protected
    by the MIC, which is derived from the user’s password, the target name is hard
    to tamper with.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: In our NTLM relay example, if the client enabled target names, it might set
    the target name to *HTTP/attacker.domain.local*, where *HTTP* represents the type
    of service requested and *attacker.domain.local* is the address to which it’s
    authenticating. The attacker could pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token to the SMB server, but because the server runs a different service, *CIFS*,
    and sits on a different network address, *fileserver.domain.local*, the names
    will not match and authentication will fail.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a target name, set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>
    parameter when creating the client authentication context:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the target name can be completely arbitrary, but the service type
    or network address can’t be. For example, the name *BLAH* wouldn’t be rejected,
    but the name *BLAH/microsoft.com* would be (unless you happened to be running
    a server on *microsoft.com*). The name format follows that of the service principal
    name (SPN) used in Kerberos authentication. We’ll describe how Kerberos uses SPNs
    in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the NTLM authentication, you should now see the target name in
    the NTLMv2 challenge response block:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can extract the target name from the server authentication content with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClientTargetName</samp> property:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The problem with the target name protection is that it must be enabled to be
    effective. By default, clients won’t set it, and the SMB server does not require
    it to be specified. Also, an attacker can spoof the name, as it’s typically based
    on some network address. For example, the attacker might be able to poison the
    client’s DNS cache or use other local network attacks to hijack the server’s IP
    address.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Channel Binding</samp>
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final protection against NTLM relay we’ll discuss is *channel binding*,
    which Microsoft also refers to as *Extended Protection for Authentication (EPA)*.
    The purpose of channel binding is to add an additional value to the NTLMv2 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token that the MIC
    will protect from tampering.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using an arbitrary name, channel binding allows the client and server
    to specify a binary token related to some property of the outer network protocol.
    One common use of channel binding is in *Transport Layer Security (TLS)*, a generic
    network protocol that encrypts and verifies another streaming protocol. This prevents
    the encrypted protocol’s contents from being disclosed to anyone inspecting network
    traffic and enables tampering detection. It’s used, for example, to secure HTTP
    as HTTPS.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: In a TLS communication, the client and server could specify the TLS server’s
    X.509 certificate as the channel binding token. The TLS protocol first verifies
    the certificate and ensures that the connection is really being made to the destination
    server. Then it binds the NTLM authentication to that channel. This prevents attackers
    from hijacking authentication by injecting data into the TLS channel. If the attacker
    instead redirects a TLS connection to their own server, the certificate will be
    different, and will use a different channel binding value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable channel binding, specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>
    parameter in the client and server authentication contexts:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you now run the NTLM authentication process, you’ll find that the channel
    binding value, which used to be all zeros, now has a value similar to the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp> value
    is an MD5 hash of a <samp class="SANS_TheSansMonoCd_W5Regular_11">SEC_CHANNEL_BINDINGS</samp>
    structure, which includes the channel binding data specified to the authentication
    context. The value itself should always be the same for every authentication with
    the same data. For the implementation used in the PowerShell module, you can use
    the function in [Listing 13-18](chapter13.xhtml#Lis13-18) to calculate the hash.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 13-18: Calculating the channel binding hash'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: As with target names, systems must opt in to this feature. If the server does
    not specify a channel binding token, the channel binding hash in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token won’t be checked. Only when the server specifies a channel binding token
    that doesn’t match will the authentication process fail.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Example</samp>
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s finish with a worked example using the commands you’ve learned about in
    this chapter. In this example, we’ll develop a simple network protocol that uses
    NTLM and the authentication context mechanisms to authenticate a user over a network,
    providing encryption and integrity verification. As this example will be quite
    complex, I’ll break it into sections.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overview</samp>
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The .NET framework already comes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NegotiateStream</samp>
    class, which uses the SSPI to authenticate and encrypt network communications.
    Nevertheless, you’ll find it instructive to build a similar mechanism yourself.
    The network protocol we’ll develop won’t be robust or even secure; it will merely
    demonstrate a practical use of the commands described in this chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: NTLM’s security properties (and its encryption and integrity verification mechanisms)
    are very weak by modern standards, so if you want a robust encrypted network protocol,
    use TLS instead. TLS is available through the <samp class="SANS_TheSansMonoCd_W5Regular_11">SslStream</samp>
    class in .NET.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-4](chapter13.xhtml#fig13-4) shows a basic overview of the protocol
    we’ll build.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-4.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: An overview of
    the network protocol</samp>'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use TCP to facilitate communications between the client and the server
    ❶. TCP is a reliable protocol built into almost every computing device on the
    planet—but because it’s a streaming protocol, there are no breaks between messages
    you send or receive. We need a way of breaking up the stream so that the client
    and server know when they’ve read a single message. For simplicity, we’ll send
    data as ASCII text, with a newline character at the end to indicate the end of
    a message.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve established the TCP connection, we’ll perform an NTLM authentication
    ❷. As the authentication tokens for NTLM are binary, we’ll encode them using the
    base64 algorithm, which converts binary data into a text string made of 64 ASCII
    characters.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We can then send messages back and forth between the client and the server ❸.
    We’ll encrypt and decrypt the data using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    PowerShell commands. As the encryption process generates encrypted messages and
    a separate signature, we’ll send them as two separate base64 text lines.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code Module</samp>
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The client and server will perform many of the same tasks, such as sending and
    receiving messages, so it makes sense to put that code into a separate module
    that both sides can easily reference. Create a directory for the example code
    and copy [Listing 13-19](chapter13.xhtml#Lis13-19) into its own file with the
    name *network_protocol*_*common.psm1*, as both the server and client implementations
    will need to access it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 13-19: The shared module code for the protocol'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The module code contains five functions. The first function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp>,
    accepts a connected TCP socket and creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamReader</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamWriter</samp> class.
    These classes allow you to read and write text lines to a binary stream, in this
    case over the network. We also set the socket’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NoDelay</samp>
    property, which disables something called the Nagle algorithm. The details of
    the algorithm are outside the scope of this book, but it ensures that the data
    written to the socket is sent to the network immediately, rather than being buffered.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The next two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-Message</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Receive-Message</samp>, send
    and receive a binary message over the TCP socket. To send a message, we first
    convert the binary data to a base64 string, then write it to the writer object.
    For the receiving function we do the reverse operation, reading a line from the
    TCP socket and converting it back to binary data from base64\. Note that we’re
    printing the messages we’re sending and receiving using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-Verbose</samp>
    PowerShell command. By default, PowerShell won’t show this verbose output; I’ll
    show you how to enable that later.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The final two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-TextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Receive-TextMessage</samp>,
    send and receive encrypted text messages. To send an encrypted message, we convert
    the message into binary data using the UTF8 text encoding, which allows us to
    use any Unicode character in our string. We then encrypt the binary data using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    command. We must send the encrypted data and signature as separate lines, using
    our existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-Message</samp>
    command. Again, to receive data, we perform the inverse of the sending operation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Server Implementation</samp>
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start by implementing the server, as without a server it will be hard
    to test any client code. [Listing 13-20](chapter13.xhtml#Lis13-20) contains the
    server implementation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 13-20: A simple server implementation'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Copy this code into its own script file in the same directory as the module
    file in [Listing 13-19](chapter13.xhtml#Lis13-19), and save it as *network_protocol_server.ps1*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining some parameters ❶. If you use the code as a script, you
    can make it act like a function by having it accept parameters on the command
    line. This makes it easy to change the script’s behavior. In this case, we define
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> parameter, which
    will change what network interfaces we bind the TCP server to, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Port</samp>
    parameter, which is the TCP port number.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Next, we import the common module ❷. This ensures that the functions defined
    in [Listing 13-19](chapter13.xhtml#Lis13-19) are available for the server to use.
    Then we set up the bind address ❸. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp>
    is set, then we bind to <samp class="SANS_TheSansMonoCd_W5Regular_11">Any</samp>,
    which represents all network interfaces; if not, we bind only to the loopback
    address, which is accessible only locally.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*It’s a common practice to bind to only the loopback address when testing server
    code. This ensures that other computers on the network can’t connect to your server
    and potentially abuse its functionality. Only bind to all network interfaces when
    you’re confident that any code you’ve written is secure, or when on a network
    with no other participants.*'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once we’ve determined the address, we create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpListener</samp>
    class and bind to the address and TCP port ❹. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">Start</samp>
    to begin listening for new connections, and we wait for a connection by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptTcpClient</samp>. At this
    point, without a client, the script will stop here. When a connection is made,
    we’ll receive a connected socket object that we can convert to the client using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp> command.
    We then print out the connected client address.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: We can now set up a new server authentication context for NTLM ❺, specifying
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp> request
    attribute to grant us the ability to encrypt and decrypt messages. We then negotiate
    the authentication with the client ❻. If the authentication fails or we haven’t
    completed it after receiving the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token, we throw an error to stop the server script.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We also check that the client provides a suitable target name during the authentication
    ❼. It should be of the format *BOOK/<ADDRESS>*, where *<ADDRESS>* is the IP address
    of the server. If the target name doesn’t match, we’ll also throw a fatal error.
    To confirm the identity of the authenticated user, we query the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object from the context and print the user’s name. To inform the client that the
    authentication succeeded, we send a confirmation message ❽. We encrypt this message,
    to ensure the session keys match.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can start receiving text messages from the client ❾. We read a text
    message, which we saw earlier will be decrypted and verified based on the negotiated
    authentication context. To prove it was received correctly, we write the message
    to the console. We then return the message to the client, appending the username
    to the message and uppercasing the text just for good measure.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: If we receive an empty message, we treat this as the signal to close down the
    server; we’ll only accept the one connection. We make sure to clean up our resources,
    such as the TCP server, before leaving the script. Let’s now look at the client
    implementation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Client Implementation</samp>
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the most part, the client implements the reverse operations of the server.
    [Listing 13-21](chapter13.xhtml#Lis13-21) shows its code. Copy this into its own
    script file in the same directory as the module file from [Listing 13-19](chapter13.xhtml#Lis13-19),
    with the name *network_protocol_client.ps1*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 13-21: The client implementation'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Again, we start by defining some parameters ❶. In this case, we want to specify
    an IP address to connect to and its TCP port. By default, the client will connect
    to the loopback address on TCP port 6543\. Next, we need to create the TCP socket
    ❷. Because it’s a client, we can directly create a <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpClient</samp>
    object to connect to the address and port. We can then wrap the socket with the
    stream readers and writers, like in the server implementation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: We create a client authentication context so that we can authenticate to the
    server ❸. We’ll use the current user’s credentials for this purpose, but you can
    change this behavior if necessary. We also specify the target name so it matches
    the server’s; if we don’t do this, the server will disconnect us. We verify that
    we can read the <samp class="SANS_TheSansMonoCd_W5Regular_11">OK</samp> message
    sent from the server ❹. If we don’t receive anything or the message does not match
    our expectations, it’s clear the authentication failed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You generally shouldn’t return detailed error information to a client in a
    network protocol. Sending a simple OK message, or nothing at all, may not help
    diagnose problems, but it prevents an attacker from finding out why the authentication
    failed. For example, if we sent the client the message BADPASSWORD if the password
    were wrong or BADUSER for an unknown user, an attacker could differentiate the
    two cases and try to brute-force a password for a valid user or enumerate valid
    usernames.*'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the authentication completed, we should now have a valid connection, so we
    can start sending messages. We read a text line from the console ❺ and send it
    to the server. We then wait for a reply and print it to the console. If we enter
    an empty line, the loop should exit, and the TCP socket should close. This should
    cause the server to receive an empty message, at which point the server can exit
    as well.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The NTLM Authentication
    Test</samp>
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s test the client and server we’ve just written. To do so, you’ll need
    two PowerShell consoles. In the first console, run the server script with the
    following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, in the second console, run the client. When you see the <samp class="SANS_TheSansMonoCd_W5Regular_11">MSG</samp>
    prompt, enter a message, such as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Hello</samp>,
    to send to the server. The output in the client should resemble the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the server console, the output should show the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, if you press ENTER again in the client without typing a message, both the
    client and the server should exit without any errors.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'You can play with the scripts to make them do different things. For example,
    if you want to use a different TCP port, you can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Port</samp>
    parameter to the scripts. The following shows how to set the port to <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp>
    for the server; the change would be the same for the client:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As a final note, let’s revisit the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-Verbose</samp>
    command in the common module code. As you may have noticed when using the client
    and the server, the verbose output isn’t printed to the console. If you want to
    see the output, you can enable this by changing the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">$VerbosePreference</samp>
    global variable. This variable normally has the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">SilentlyContinue</samp>,
    which ignores verbose output. If you change it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp>,
    the verbose output will appear. [Listing 13-22](chapter13.xhtml#Lis13-22) changes
    this value before connecting the client.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 13-22: Enabling verbose output for the client'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: You can observe that we now see part of the first NTLM authentication token
    being sent to the server. When you send messages back and forth between the client
    and server, you can verify that the data is encrypted by looking at the hex output.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: This worked example was quite lengthy, but it should have given you a better
    idea of how network authentication can work in a real network scenario.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter described the NTLM authentication protocol and provided scripts
    to demonstrate its authentication process. We looked at negotiating authentication
    tokens, and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    PowerShell command to display the protocol state.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: I also showed you how to derive some of the cryptographic values generated by
    the NTLM protocol using PowerShell. This included the final NT response value,
    which proves the knowledge of the user’s password, and the message integrity code,
    which protects the NTLM authentication tokens from tampering.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: To describe the risks associated with NTLM authentication, we covered NTLM relay
    attacks and a few ways in which Windows tries to combat them, such as active server
    challenge records and channel binding. We also covered using the authentication
    context to generate signatures and encrypt messages.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Now that you better understand network authentication and the APIs used to generate
    authentication tokens, the next chapter focuses on the more complicated Kerberos
    authentication protocol.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
