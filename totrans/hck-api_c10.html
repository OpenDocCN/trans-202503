<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 10: Exploiting Authorization</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4817cf93-40a6-403c-8355-e951c69da606" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_223" title="223"/>10</span><br/>
<span class="ChapterTitle">Exploiting Authorization</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">In this chapter, we will cover two authorization vulnerabilities: BOLA and BFLA. These vulnerabilities reveal weaknesses in the authorization checks that ensure authenticated users are only able to access their own resources or use functionality that aligns with their permission level. In the process, we’ll discuss how to identify resource IDs, use A-B and A-B-A testing, and speed up your testing with Postman and Burp Suite.</p>
<h2 id="h1-502444c10-0001">Finding BOLAs</h2>
<p class="BodyFirst">BOLA continues to be one of the most prominent API-related vulnerabilities, but it can also be one of the easiest to test for. If you see that the API lists resources following a certain pattern, you can test other instances using that pattern. For instance, say you notice that after making a purchase, the <span epub:type="pagebreak" id="Page_224" title="224"/>app uses an API to provide you with a receipt at the following location: <em>/api/v1/receipt/135</em>. Knowing this, you could then check for other numbers by using 135 as the payload position in Burp Suite or Wfuzz and changing 135 to numbers between 0 and 200. This was exactly what we did in the <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> lab when testing <em>reqres.in</em> for the total number of user accounts.</p>
<p>This section will cover additional considerations and techniques pertinent to hunting for BOLA. When you’re on the hunt for BOLA vulnerabilities, remember that they aren’t only found using GET requests. Attempt to use all possible methods to interact with resources you shouldn’t be authorized to access. Likewise, vulnerable resource IDs aren’t limited to the URL path. Make sure to consider other possible locations to check for BOLA weaknesses, including the body of the request and headers.</p>
<h3 id="h2-502444c10-0001">Locating Resource IDs</h3>
<p class="BodyFirst">So far, this book has illustrated BOLA vulnerabilities using examples like performing sequential requests for resources:</p>
<ol class="none">
<li><code>GET /api/v1/user/account/</code><code class="bold">1111</code></li>
<li><code>GET /api/v1/user/account/</code><code class="bold">1112</code></li>
</ol>
<p>To test for this vulnerability, you could simply brute-force all account numbers within a certain range and check whether requests result in a successful response.</p>
<p>Sometimes, finding instances of BOLA will actually be this straightforward. However, to perform thorough BOLA testing, you’ll need to pay close attention to the information the API provider is using to retrieve resources, as it may not be so obvious. Look for user ID names or numbers, resource ID names or numbers, organization ID names or numbers, emails, phone numbers, addresses, tokens, or encoded payloads used in requests to retrieve resources.</p>
<p>Keep in mind that predictable request values don’t make an API vulnerable to BOLA; the API is considered vulnerable only when it provides an unauthorized user access to the requested resources. Often, insecure APIs will make the mistake of validating that the user is authenticated but fail to check whether that user is authorized to access the requested resources.</p>
<p>As you can see in <a href="#table10-1" id="tableanchor10-1">Table 10-1</a>, there are plenty of ways you can attempt to obtain resources you shouldn’t be authorized to access. These examples are based on actual successful BOLA findings. In each of these requests, the requester used the same UserA token.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-1">Table 10-1</a>: Valid Requests for Resources and the Equivalent BOLA Test</p></figcaption>
<table border="1" id="table-502444c10-0001">
<thead>
<tr>
<td><b>Type</b></td>
<td><b>Valid request</b></td>
<td><b>BOLA test</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Predictable ID</td>
<td><code>GET /api/v1/account/</code><code class="bold">2222</code><br/>
<code>Token: UserA_token</code></td>
<td><code>GET /api/v1/account/</code><code class="bold">3333</code><br/>
<code>Token: UserA_token</code></td>
</tr>
<tr>
<td>ID combo</td>
<td><code>GET /api/v1/</code><code class="bold">UserA</code><code>/data</code>/<code class="bold">2222</code><br/>
<code>Token: UserA_token</code></td>
<td><code>GET /api/v1/</code><code class="bold">UserB</code><code>/data/</code><code class="bold">3333</code><br/>
<code>Token: UserA_token</code></td>
</tr>
<tr>
<td><span epub:type="pagebreak" id="Page_225" title="225"/>Integer as ID</td>
<td><code>POST /api/v1/account/</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"Account":</code> <code class="bold">2222</code><code>}</code></td>
<td><code>POST /api/v1/account/</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"Account": [</code><code class="bold">3333</code><code>]}</code></td>
</tr>
<tr>
<td>Email as user ID</td>
<td><code>POST /api/v1/user/account</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"email": "</code><code class="bold">UserA@email.com</code><code>"}</code></td>
<td><code>POST /api/v1/user/account</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"email": "</code><code class="bold">UserB@email.com</code><code>"}</code></td>
</tr>
<tr>
<td>Group ID</td>
<td><code>GET /api/v1/group/</code><code class="bold">CompanyA</code><br/>
<code>Token: UserA_token</code></td>
<td><code>GET /api/v1/group/</code><code class="bold">CompanyB</code><br/>
<code>Token: UserA_token</code></td>
</tr>
<tr>
<td>Group and user combo</td>
<td><code>POST /api/v1/group/</code><code class="bold">CompanyA</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"email": "</code><code class="bold">userA@CompanyA.com</code><code>"}</code></td>
<td><code>POST /api/v1/group/</code><code class="bold">CompanyB</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"email": "</code><code class="bold">userB@CompanyB.com</code><code>"}</code></td>
</tr>
<tr>
<td>Nested object</td>
<td><code>POST /api/v1/user/checking</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"Account":</code> <code class="bold">2222</code><code>}</code></td>
<td><code>POST /api/v1/user/checking</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"Account":</code><b> </b><code class="bold">{"Account" :3333}}</code></td>
</tr>
<tr>
<td>Multiple objects</td>
<td><code>POST /api/v1/user/checking</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"Account":</code> <code class="bold">2222</code><code>}</code></td>
<td><code>POST /api/v1/user/checking</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"Account":</code> <code class="bold">2222, "Account": 3333, "Account": 5555</code><code>}</code></td>
</tr>
<tr>
<td>Predictable token</td>
<td><code>POST /api/v1/user/account</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"data": "DflK1df7jSdfa</code><code class="bold">1ac</code><code>aa"}</code></td>
<td><code>POST /api/v1/user/account</code><br/>
<code>Token: UserA_token</code><br/>
<code>{"data": "DflK1df7jSdfa</code><b>2df</b><code>aa"}</code></td>
</tr>
</tbody>
</table>
</figure>
<p>Sometimes, just requesting the resource won’t be enough; instead, you’ll need to request the resource as it was meant to be requested, often by supplying both the resource ID and the user’s ID. Thus, due to the nature of how APIs are organized, a proper request for resources may require the <em>ID</em> <em>combo </em>format shown in <a href="#table10-1">Table 10-1</a>. Similarly, you may need to know the group ID along with the resource ID, as in the <em>group and user combo</em> format.</p>
<p><em>Nested objects</em> are a typical structure found in JSON data. These are simply additional objects created within an object. Since nested objects are a valid JSON format, the request will be processed if user input validation does not prevent it. Using a nested object, you could escape or bypass security measures applied to the outer key/value pair by including a separate key/value pair within the nested object that may not have the same security controls applied to it. If the application processes these nested objects, they are an excellent vector for an authorization weakness.</p>
<h3 id="h2-502444c10-0002">A-B Testing for BOLA</h3>
<p class="BodyFirst">What we call <em>A-B testing</em> is the process of creating resources using one account and attempting to retrieve those resources as a different account. This is one of the best ways to identify how resources are identified and what requests are used to obtain them. The A-B testing process looks like this:</p>
<ul>
<li><b>Create resources as UserA.</b> Note how the resources are identified and how the resources are requested.</li>
<li><span epub:type="pagebreak" id="Page_226" title="226"/><b>Swap out your UserA token for another user’s token.</b> In many instances, if there is an account registration process, you will be able to create a second account (UserB).</li>
<li><b>Using UserB’s token, make the request for UserA’s resources.</b> Focus on resources for private information. Test for any resources that UserB should not have access to, such as full name, email, phone number, Social Security number, bank account information, legal information, and transaction data.</li>
</ul>
<p>The scale of this testing is small, but if you can access one user’s resources, you could likely access all user resources of the same privilege level.</p>
<p>A variation on A-B testing is to create three accounts for testing. That way, you can create resources in each of the three different accounts, detect any patterns in the resource identifiers, and check which requests are used to request those resources, as follows:</p>
<ul>
<li><b>Create multiple accounts at each privilege level to which you have access.</b> Keep in mind that your goal is to test and validate security controls, not destroy someone’s business. When performing BFLA attacks, there is a chance you could successfully delete the resources of other users, so it helps to limit a dangerous attack like this to a test account you create.</li>
<li><b>Using your accounts, create a resource with UserA’s account and attempt to interact with it using UserB’s.</b> Use all the methods at your disposal.</li>
</ul>
<h3 id="h2-502444c10-0003">Side-Channel BOLA</h3>
<p class="BodyFirst">One of my favorite methods of obtaining sensitive information from an API is through side-channel disclosure. Essentially, this is any information gleaned from unexpected sources, such as timing data. In past chapters, we discussed how APIs can reveal the existence of resources through middleware like <code>X-Response-Time</code>. Side-channel discoveries are another reason why it is important to use an API as it was intended and develop a baseline of normal responses.</p>
<p>In addition to timing, you could use response codes and lengths to determine if resources exist. For example, if an API responds to nonexistent resources with a 404 Not Found but has a different response for existing resources, such as 405 Unauthorized, you’ll be able to perform a BOLA side-channel attack to discover existing resources such as usernames, account IDs, and phone numbers.</p>
<p><a href="#table10-2" id="tableanchor10-2">Table 10-2</a> gives a few examples of requests and responses that could be useful for side-channel BOLA disclosures. If 404 Not Found is a standard response for nonexistent resources, the other status codes could be used to enumerate usernames, user ID numbers, and phone numbers. These requests provide just a few examples of information that could be gathered when the API has different responses for nonexistent resources and existing <span epub:type="pagebreak" id="Page_227" title="227"/>resources that you are not authorized to view. If these requests successful, they can result in a serious disclosure of sensitive data.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-2">Table 10-2</a>: Examples of Side-Channel BOLA Disclosures</p></figcaption>
<table border="1" id="table-502444c10-0002">
<thead>
<tr>
<td><b>Request</b></td>
<td><b>Response</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>GET /api/user/test987123</code></td>
<td><code>404 Not Found HTTP/1.1</code></td>
</tr>
<tr>
<td><code>GET /api/user/hapihacker</code></td>
<td><code>405 Unauthorized HTTP/1.1</code><br/>
<code>{</code><br/>
<code>}</code></td>
</tr>
<tr>
<td><code>GET /api/user/1337</code></td>
<td><code>405 Unauthorized HTTP/1.1</code><br/>
<code>{</code><br/>
<code>}</code></td>
</tr>
<tr>
<td><code>GET /api/user/phone/2018675309</code></td>
<td><code>405 Unauthorized HTTP/1.1</code><br/>
<code>{</code><br/>
<code>}</code></td>
</tr>
</tbody>
</table>
</figure>
<p>On its own, this BOLA finding may seem minimal, but information like this can prove to be valuable in other attacks. For example, you could leverage information gathered through a side-channel disclosure to perform brute-force attacks to gain entry to valid accounts. You could also use information gathered in a disclosure like this to perform other BOLA tests, such as the ID combo BOLA test shown in <a href="#table10-1">Table 10-1</a>.</p>
<h2 id="h1-502444c10-0002">Finding BFLAs</h2>
<p class="BodyFirst">Hunting for BFLA involves searching for functionality to which you should not have access. A BFLA vulnerability might allow you to update object values, delete data, and perform actions as other users. To check for it, try to alter or delete resources or gain access to functionality that belongs to another user or privilege level.</p>
<p>Note that if you successfully send a DELETE request, you’ll no longer have access to the given resource . . . because you’ll have deleted it. For that reason, avoid testing for DELETE while fuzzing, unless you’re targeting a test environment. Imagine that you send DELETE requests to 1,000 resource identifiers; if the requests succeed, you’ll have deleted potentially valuable information, and your client won’t be happy. Instead, start your BFLA testing on a small scale to avoid causing huge interruptions.</p>
<h3 id="h2-502444c10-0004">A-B-A Testing for BFLA</h3>
<p class="BodyFirst">Like A-B testing for BOLA, A-B-A testing is the process of creating and accessing resources with one account and then attempting to alter the resources with another account. Finally, you should validate any changes with the original account. The A-B-A process should look something like this:</p>
<ul>
<li><b>Create, read, update, or delete resources as UserA.</b> Note how the resources are identified and how the resources are requested.</li>
<li><span epub:type="pagebreak" id="Page_228" title="228"/><b>Swap out your UserA token for UserB’s. </b>In instances where there is an account registration process, create a second test account.</li>
<li><b>Send GET, PUT, POST, and DELETE requests for UserA’s resources using UserB’s token.</b> If possible, alter resources by updating the properties of an object.</li>
<li><b>Check UserA’s resources to validate changes have been made by using UserB’s token.</b> Either by using the corresponding web application or by making API requests using UserA’s token, check the relevant resources. If, for example, the BFLA attack was an attempt to delete UserA’s profile picture, load UserA’s profile to see if the picture is missing.</li>
</ul>
<p>In addition to testing authorization weaknesses at a single privilege level, ensure that you check for weaknesses at other privilege levels. As previously discussed, APIs could have all sorts of different privilege levels, such as basic user, merchant, partner, and admin. If you have access to accounts at the various privilege levels, your A-B-A testing can take on a new layer. Try making UserA an administrator and UserB a basic user. If you’re able to exploit BLFA in that situation, it will have become a privilege escalation attack.</p>
<h3 id="h2-502444c10-0005">Testing for BFLA in Postman</h3>
<p class="BodyFirst">Begin your BFLA testing with authorized requests for UserA’s resources. If you were testing whether you could modify another user’s pictures in a social media app, a simple request like the one shown in <a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a> would do:</p>
<pre><code>GET /api/picture/2
Token: UserA_token</code></pre>
<p class="CodeListingCaption"><a id="listing10-1">Listing 10-1</a>: Sample request for BFLA testing</p>
<p>This request tells us that resources are identified by numeric values in the path. Moreover, the response, shown in <a href="#listing10-2" id="listinganchor10-2">Listing 10-2</a>, indicates that the username of the resource (<code>"UserA"</code>) matches the request token.</p>
<pre><code>200 OK
{
    "_id": 2,
    "name": "development flower",
    "creator_id": 2,
    "username": "UserA",
    "money_made": 0.35,
    "likes": 0
}</code></pre>
<p class="CodeListingCaption"><a id="listing10-2">Listing 10-2</a>: Sample response from a BFLA test</p>
<p>Now, given that this is a social media platform where users can share pictures, it wouldn’t be too surprising if another user had the ability to send a successful GET request for picture 2. This isn’t an instance of BOLA but <span epub:type="pagebreak" id="Page_229" title="229"/>rather a feature. However, UserB shouldn’t be able to delete pictures that belong to UserA. That is where we cross into a BFLA vulnerability.</p>
<p>In Postman, try sending a DELETE request for UserA’s resource containing UserB’s token. As you see in <a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a>, a DELETE request using UserB’s token was able to successfully delete UserA’s picture. To validate that the picture was deleted, send a follow-up GET request for <code>picture_id=2</code>, and you will confirm that UserA’s picture with the ID of 2 no longer exists. This is a very important finding, since a single malicious user could easily delete all other users’ resources.</p>
<figure>
<img alt="screenshot of postman that shows photo 2 has been deleted successfully" class="keyline" src="image_fi/502444c10/F10001.png"/>
<figcaption><p><a id="figure10-1">Figure 10-1</a>: Successful BFLA attack with Postman</p></figcaption>
</figure>
<p>You can simplify the process of finding privilege escalation–related BFLA vulnerabilities if you have access to documentation. Alternatively, you might find administrative actions clearly labeled in a collection, or you might have reverse engineered administrative functionality. If this isn’t the case, you’ll need to fuzz for admin paths.</p>
<p>One of the simplest ways to test for BFLA is to make administrative requests as a low-privileged user. If an API allows administrators to search for users with a POST request, try making that exact admin request to see if any security controls are in place to prevent you from succeeding. Look at the request in <a href="#listing10-3" id="listinganchor10-3">Listing 10-3</a>. In the response (<a href="#listing10-4" id="listinganchor10-4">Listing 10-4</a>), we see that the API did not have any such restrictions.</p>
<pre><code>POST /api/admin/find/user
Token: LowPriv-Token

{"email": "hapi@hacker.com"}
</code></pre>
<p class="CodeListingCaption"><a id="listing10-3">Listing 10-3</a>: Request for user information</p>
<pre><code><span epub:type="pagebreak" id="Page_230" title="230"/>200 OK HTTP/1.1

{
"fname": "hAPI",
"lname": "Hacker",
"is_admin": false,
"balance": "3737.50"
"pin": 8675
}</code></pre>
<p class="CodeListingCaption"><a id="listing10-4">Listing 10-4</a>: Response with user information</p>
<p>The ability to search for users and gain access to another user’s sensitive information was meant to be restricted to only those with an administrative token. However, by making a request to the <em>/admin/find/user</em> endpoint, you can test to see if there is any technical enforcement. Since this is an administrative request, a successful response could also provide sensitive information, such as a user’s full name, balance, and personal identification number (PIN).</p>
<p>If restrictions are in place, try changing the request method. Use a POST request instead of a PUT request, or vice versa. Sometimes an API provider has secured one request method from unauthorized requests but has overlooked another.</p>
<h2 id="h1-502444c10-0003">Authorization Hacking Tips</h2>
<p class="BodyFirst">Attacking a large-scale API with hundreds of endpoints and thousands of unique requests can be fairly time-consuming. The following tactics should help you test for authorization weaknesses across an entire API: using Collection variables in Postman and using the Burp Suite Match and Replace feature.</p>
<h3 id="h2-502444c10-0006">Postman’s Collection Variables</h3>
<p class="BodyFirst">As you would when fuzzing wide, you can use Postman to perform variable changes across a collection, setting the authorization token for your collection as a variable. Begin by testing various requests for your resources to make sure they work properly as UserA. Then replace the token variable with the UserB token. To help you find anomalous responses, use a Collection test to locate 200 response codes or the equivalent for your API.</p>
<p>In Collection Runner, select only the requests that are likely to contain authorization vulnerabilities. Good candidate requests include those that contain private information belonging to UserA. Launch the Collection Runner and review the results. When checking results, look for instances in which the UserB token results in a successful response. These successful responses will likely indicate either BOLA or BFLA vulnerabilities and should be investigated further.</p>
<h3 id="h2-502444c10-0007"><span epub:type="pagebreak" id="Page_231" title="231"/>Burp Suite Match and Replace</h3>
<p class="BodyFirst">When you’re attacking an API, your Burp Suite history will populate with unique requests. Instead of sifting through each request and testing it for authorization vulnerabilities, use the Match and Replace option to perform a large-scale replacement of a variable like an authorization token.</p>
<p>Begin by collecting several requests in your history as UserA, focusing on actions that should require authorization. For instance, focus on requests that involve a user’s account and resources. Next, match and replace the authorization headers with UserB’s and repeat the requests (see <a href="#figure10-2" id="figureanchor10-2">Figure 10-2</a>).</p>
<figure>
<img alt="screenshot of burp suite’s match and replace tool (found under proxy &gt; options) that shows tokena being replaced with tokenb" class="keyline" src="image_fi/502444c10/F10002.png"/>
<figcaption><p><a id="figure10-2">Figure 10-2</a>: Burp Suite’s Match and Replace feature</p></figcaption>
</figure>
<p>Once you find an instance of BOLA or BFLA, try to exploit it for all users and related resources.</p>
<h2 id="h1-502444c10-0004">Summary</h2>
<p class="BodyFirst">In this chapter, we took a close look at techniques for attacking common weaknesses in API authorization. Since each API is unique, it’s important not only to figure out how resources are identified but also to make requests for resources that don’t belong to the account you’re using.</p>
<p>Authorization can lead to some of the most severe consequences. A BOLA vulnerability could allow an attacker to compromise an organization’s most sensitive information, whereas a BFLA vulnerability could allow you to escalate privileges or perform unauthorized actions that could compromise an API provider.</p>
<h2 class="HeadProject" id="h1-502444c10-0005"><span><span epub:type="pagebreak" id="Page_232" title="232"/>Lab #7: Finding Another User’s Vehicle Location</span></h2>
<p class="BodyFirst">In this lab, we’ll search crAPI to discover the resource identifiers in use and test whether we can gain unauthorized access to another user’s data. In doing so, we’ll see the value of combining multiple vulnerabilities to increase the impact of an attack. If you’ve followed along in the other labs, you should have a crAPI Postman collection containing all sorts of requests.</p>
<p>You may notice that the use of resource IDs is fairly light. However, one request does include a unique resource identifier. The “refresh location” button at the bottom of the crAPI dashboard issues the following request:</p>
<pre><code>GET /identity/api/v2/vehicle/<b>fd5a4781-5cb5-42e2-8524-d3e67f5cb3a6</b>/location.</code></pre>
<p>This request takes the user’s GUID and requests the current location of the user’s vehicle. The location of another user’s vehicle sounds like sensitive information worth collecting. We should see if the crAPI developers depend on the complexity of the GUID for authorization or if there are technical controls making sure users can only check the GUID of their own vehicle.</p>
<p>So the question is, how should you perform this test? You might want to put your fuzzing skills from <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> to use, but an alphanumeric GUID of this length would take an impossible amount of time to brute-force. Instead, you can obtain another existing GUID and use it to perform A-B testing. To do this, you will need to register for a second account, as shown in <a href="#figure10-3" id="figureanchor10-3">Figure 10-3</a>.</p>
<figure>
<img alt="screenshot of crapi’s new user sign-up window" class="keyline" src="image_fi/502444c10/F10003.png"/>
<figcaption><p><a id="figure10-3">Figure 10-3</a>: Registering UserB with crAPI</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_233" title="233"/>In <a href="#figure10-3">Figure 10-3</a>, you can see that we’ve created a second account, called UserB. With this account, go through the steps to register a vehicle using MailHog. As you may remember, back in the <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span> lab we performed reconnaissance and discovered some other open ports associated with crAPI. One of these was port 8025, which is where MailHog is located.</p>
<p>As an authenticated user, click the <b>Click Here</b> link on the dashboard, as seen in <a href="#figure10-4" id="figureanchor10-4">Figure 10-4</a>. This will generate an email with your vehicle’s information and send it to your MailHog account.</p>
<figure>
<img alt="screenshot of crapi’s new user dashboard that states “no vehicles found” under vehicles details. within this message is a clickable button labeled “click here.”" class="keyline" src="image_fi/502444c10/F10004.png"/>
<figcaption><p><a id="figure10-4">Figure 10-4</a>: A crAPI new user dashboard</p></figcaption>
</figure>
<p>Update the URL in the address bar to visit port 8025 using the following format: <em>http://yourIPaddress:8025</em>. Once in MailHog, open the “Welcome to crAPI” email (see <a href="#figure10-5" id="figureanchor10-5">Figure 10-5</a>).</p>
<figure>
<img alt="screenshot of “welcome to crapi” email in mailhog that states your vehicle’s vin and pincode" class="keyline" src="image_fi/502444c10/F10005.png"/>
<figcaption><p><a id="figure10-5">Figure 10-5</a>: The crAPI MailHog email service</p></figcaption>
</figure>
<p>Take the VIN and pincode information provided in the email and use that to register your vehicle back on the crAPI dashboard by clicking the <b>Add a Vehicle</b> button. This results in the window shown in <a href="#figure10-6" id="figureanchor10-6">Figure 10-6</a>.</p>
<span epub:type="pagebreak" id="Page_234" title="234"/><figure>
<img alt="screenshot of crapi’s add a vehicle window that has boxes to type in the vehicle’s pin code and vin" class="keyline" src="image_fi/502444c10/F10006.png"/>
<figcaption><p><a id="figure10-6">Figure 10-6</a>: The crAPI Vehicle Verification screen</p></figcaption>
</figure>
<p>Once you’ve registered the UserB vehicle, capture a request using the <b>Refresh Location</b> button. It should look like this:</p>
<pre><code>GET /identity/api/v2/vehicle/d3b4b4b8-6df6-4134-8d32-1be402caf45c/location HTTP/1.1
Host: 192.168.195.130:8888
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
Accept: */*
Content-Type: application/json
Authorization: Bearer <b>UserB-Token</b>
Content-Length: 376</code></pre>
<p>Now that you have UserB’s GUID, you can swap out the UserB Bearer token and send the request with UserA’s bearer token. <a href="#listing10-5" id="listinganchor10-5">Listing 10-5</a> shows the request, and <a href="#listing10-6" id="listinganchor10-6">Listing 10-6</a> shows the response.</p>
<pre><code>GET /identity/api/v2/vehicle/d3b4b4b8-6df6-4134-8d32-1be402caf45c/location HTTP/1.1
Host: 192.168.195.130:8888
Content-Type: application/json
Authorization: Bearer <b>UserA-Token</b></code></pre>
<p class="CodeListingCaption"><a id="listing10-5">Listing 10-5</a>: A BOLA attempt</p>
<pre><code>HTTP/1.1 200

{
"carId":"d3b4b4b8-6df6-4134-8d32-1be402caf45c",
"vehicleLocation":
     {
     "id":2,
     "latitude":"39.0247621",
     "longitude":"-77.1402267"
     },
<span epub:type="pagebreak" id="Page_235" title="235"/>"fullName":"<b>UserB</b>"
}</code></pre>
<p class="CodeListingCaption"><a id="listing10-6">Listing 10-6</a>: Response to the BOLA attempt</p>
<p>Congratulations, you’ve discovered a BOLA vulnerability. Perhaps there is a way to discover the GUIDs of other valid users to take this finding to the next level. Well, remember that, in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, an intercepted GET request to <em>/community/api/v2/community/posts/recent</em> resulted in an excessive data exposure. At first glance, this vulnerability did not seem to have severe consequences. However, we now have plenty of use for the exposed data. Take a look at the following object from that excessive data exposure:</p>
<pre><code>{
"id":"sEcaWGHf5d63T2E7asChJc",
"title":"Title 1",
"content":"Hello world 1",
"author":{
"nickname":"Adam",
"email":"adam007@example.com",
"vehicleid":<b>"2e88a86c-8b3b-4bd1-8117-85f3c8b52ed2",</b>
"profile_pic_url":"",
}</code></pre>
<p>This data reveals a <code>vehicleid</code> that closely resembles the GUID used in the Refresh Location request. Substitute these GUIDs using UserA’s token. <a href="#listing10-7" id="listinganchor10-7">Listing 10-7</a> shows the request, and <a href="#listing10-8" id="listinganchor10-8">Listing 10-8</a> shows the response.</p>
<pre><code>GET /identity/api/v2/vehicle/2e88a86c-8b3b-4bd1-8117-85f3c8b52ed2/location HTTP/1.1
Host: 192.168.195.130:8888
Content-Type: application/json
Authorization: Bearer <b>UserA-Token</b>
Connection: close</code></pre>
<p class="CodeListingCaption"><a id="listing10-7">Listing 10-7</a>: A request for another user’s GUID</p>
<pre><code>HTTP/1.1 200
{
"carId":"2e88a86c-8b3b-4bd1-8117-85f3c8b52ed2",
"vehicleLocation":{
     "id":7,
     "latitude":"37.233333",
     "longitude":"-115.808333"},
"fullName":"Adam"
}</code></pre>
<p class="CodeListingCaption"><a id="listing10-8">Listing 10-8</a>: The response</p>
<p>Sure enough, you can exploit the BOLA vulnerability to discover the location of the user’s vehicle. Now you’re one Google Maps search away from discovering the user’s exact location and gaining the ability to track any user’s vehicle location over time. Combining vulnerability findings, as you do in this lab, will make you a master API hacker.</p>
</section>
</body>
</html>