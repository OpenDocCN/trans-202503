- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UART, JTAG, and SWD Exploitation
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: If you understand the protocols that interact directly with a system’s electronic
    components, you can target IoT devices at the physical level. The *Universal Asynchronous
    Receiver-Transmitter (UART)* is one of the simplest serial protocols, and its
    exploitation provides one of the easiest ways to gain access to IoT devices. Vendors
    typically use it for debugging, which means that you can often obtain root access
    through it. To accomplish this, you’ll need some specialized hardware tools; for
    instance, it’s common for attackers to identify the UART pins on a device’s printed
    circuit board (PCB) using a multimeter or logic analyzer. They then connect a
    USB-to-serial adapter to these pins and open a serial debug console from the attacking
    workstation. Most of the time, if you do this, you’ll be dropped to a root shell.
  prefs: []
  type: TYPE_NORMAL
- en: The *Joint Test Action Group (JTAG)* is an industry standard (defined in IEEE
    1491.1) for debugging and testing increasingly complex PCBs. JTAG interfaces on
    embedded devices allow us to read and write memory contents, including dumping
    the entire firmware, which means it serves as a way to gain complete control of
    a target device. *Serial Wire Debug* (*SWD*) is a very similar, even simpler electrical
    interface than JTAG that we’ll examine here as well.
  prefs: []
  type: TYPE_NORMAL
- en: We spend most of this chapter walking through a lengthy practical exercise;
    you’ll program, debug, and exploit a microcontroller to bypass its authentication
    process using UART and SWD. But first we explain the inner workings of these protocols
    and show you how to identify UART and JTAG pinouts on a PCB using hardware and
    software tools.
  prefs: []
  type: TYPE_NORMAL
- en: UART
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UART is a *serial* protocol, which means it transfers data between components
    one bit at a time. In contrast, *parallel communication* protocols transmit data
    simultaneously through multiple channels. Common serial protocols include RS-232,
    I²C, SPI, CAN, Ethernet, HDMI, PCI Express, and USB.
  prefs: []
  type: TYPE_NORMAL
- en: UART is simpler than many of the protocols you’ve likely encountered. To synchronize
    communications, the UART transmitter and receiver must agree on a specific baud
    rate (the rate of bits transmitted per second). [Figure 7-1](#figure7-1) shows
    the UART packet format.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07001](Images/f07001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: UART packet format'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the line is held high (at a logical 1 value) while UART is in the
    *idle* state. Then, to signal the start of a data transfer, the transmitter sends
    a *start bit* to the receiver, during which the signal is held low (at a logical
    0 value). Next, the transmitter sends five to eight *data bits* containing the
    actual message, followed by an optional parity bit and one or two stop bits (with
    a logical 1 value), depending on the configuration. The *parity bit*, used for
    error checking, is rarely seen in practice. The *stop bit* (or bits) signify the
    end of transmission.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the most common configuration *8N1*: eight data bits, no parity, and
    one stop bit. For example, if we wanted to send the character C, or 0x43 in ASCII,
    in an 8N1 UART configuration, we would send the following bits: `0` (the start
    bit); `0`, `1`, `0`, `0`, `0`, `0`, `1`, `1` (the value of 0x43 in binary), and
    `0` (the stop bit).'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware Tools for Communicating with UART
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use a variety of hardware tools to communicate with UART. One easy option
    is a USB-to-serial adapter, like the one we use in “Hacking a Device Through UART
    and SWD” on page 168\. Other options include adapters with the CP2102 or PL2303
    chips. If you are new to hardware hacking, we recommend getting a multipurpose
    tool that supports protocols other than just UART, such as the Bus Pirate, the
    Adafruit FT232H, the Shikra, or the Attify Badge.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find a list of tools and their descriptions, as well as links to
    buy them, in “Tools for IoT Hacking” at the end of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying UART Ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To exploit a device through UART, you first need to locate its four UART ports,
    or connectors, which typically come in the form of pins or *pads* (plated holes).
    The term *pinout* refers to the diagram of all the ports. We’ll use these terms
    interchangeably throughout this book. A UART pinout has four ports: *TX (Transmit)*,
    *RX (Receive)*, *Vcc (Voltage)*, and *GND (Ground)*. Start by opening the device’s
    external case and removing the PCB. Be warned that this might void your warranty.'
  prefs: []
  type: TYPE_NORMAL
- en: These four ports often appear next to each other on the board. If you’re lucky,
    you might even find markings that indicate the TX and RX ports, as shown in [Figure
    7-2](#figure7-2). In that case, you can be fairly certain that the set of four
    pins are the UART pins.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07002](Images/f07002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: UART pins clearly marked as DBG_TXD and DBG_RXD on the PCB in a
    St. Jude/Abbott Medical Merlin@home Transmitter'
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, you might see four through-hole pads next to each other, like
    those in the TP-Link router in [Figure 7-3](#figure7-3). This might occur because
    vendors have removed the UART header pins from the PCB, which means that you might
    have to either perform some soldering to reach them or use test probes. (*Test
    probes* are physical devices that connect electronic test equipment to a device.
    They include a probe, cable, and terminating connector. We show a few examples
    of test probes in Chapter 8.)
  prefs: []
  type: TYPE_NORMAL
- en: '![f07003](Images/f07003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: A PCB in a TP-Link TL WR840N router. On the bottom left, you can
    see a zoomed-in part of the PCB with the UART pads.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, keep in mind that some devices emulate UART ports by programming the General-Purpose
    Input/Output (GPIO) pins if there isn’t enough space on the board for dedicated
    hardware UART pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'When UART pins aren’t marked as clearly as those shown here, you can typically
    identify them on a device in two ways: by using a multimeter or by using a logic
    analyzer. A *multimeter* measures voltage, current, and resistance. Having a multimeter
    in your arsenal when doing hardware hacking is highly important, because it can
    serve a variety of purposes. For example, we commonly use it to test for *continuity*.
    A continuity test sounds a buzzer when a circuit’s resistance is low enough (less
    than a few ohms), indicating that there’s a continuous path between the two points
    probed by the multimeter’s leads.'
  prefs: []
  type: TYPE_NORMAL
- en: Although a cheap multimeter will do the job, we recommend that you invest in
    a robust and precise multimeter, if you plan to delve deeper into hardware hacking.
    True RMS multimeters are more accurate for measuring AC currents. [Figure 7-4](#figure7-4)
    shows a typical multimeter.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07004](Images/f07004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: Common multimeter. Highlighted is the Continuity Test mode, which
    typically has an icon that looks like a sound wave (because of the buzzer that
    sounds when detecting continuity).'
  prefs: []
  type: TYPE_NORMAL
- en: To identify UART pinouts using a multimeter, start by making sure the device
    is powered off. By convention, you should connect a black test lead to the multimeter’s
    COM jack. Insert a red lead in the VΩ jack.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by identifying the UART GND. Turn the multimeter dial to the Continuity
    Test mode, which typically has an icon that looks like a sound wave. It might
    share a spot on the dial with one or more functions, usually resistance. Place
    the other end of the black lead on any grounded metallic surface (an area that
    has a direct conductive path to earth), be it a part of the tested PCB or not.
  prefs: []
  type: TYPE_NORMAL
- en: Then place the red probe on each of the ports you suspect might be part of the
    UART pinout. When you hear a beeping sound from the multimeter, you’ve found a
    GND pin. Keep in mind that the device might have more than one GND pin and you
    might have found one that isn’t necessarily part of the UART pinout.
  prefs: []
  type: TYPE_NORMAL
- en: Continue by identifying the Vcc port. Turn the multimeter dial to the DC voltage
    mode in and set it up to 20 V of voltage. Keep the multimeter’s black probe on
    a grounded surface. Place the red probe in a suspected pad and turn on the device.
    If the multimeter measures a constant voltage of either 3.3 V or 5 V, you’ve found
    the Vcc pin. If you get other voltages, place the red probe on another port, reboot
    the device, and measure the voltage again. Do the same for every port until you
    identify Vcc.
  prefs: []
  type: TYPE_NORMAL
- en: Next, identify the TX port. Keep the multimeter mode at a DC voltage of 20 V
    or less, and leave the black probe in a grounded surface. Move the red probe to
    the suspected pad and power cycle the device. If the voltage fluctuates for a
    few seconds and then stabilizes at the Vcc value (either 3.3 or 5), you’ve most
    likely found the TX port. This behavior happens because, during bootup, the device
    sends serial data through that TX port for debugging purposes. Once it finishes
    booting, the UART line goes idle. Recall from [Figure 7-1](#figure7-1) that an
    idle UART line remains at a logical high, which means that it has the Vcc value.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve already identified the rest of the UART ports, the nearby fourth pin
    is most likely the RX port. Otherwise, you can identify it because it has the
    lowest voltage fluctuation and lowest overall value of all the UART pins.
  prefs: []
  type: TYPE_NORMAL
- en: To identify the UART pins more accurately, use a *logic analyzer*, a device
    that captures and displays signals from a digital system. Many kinds of logic
    analyzers are available. They range from cheaper ones, such as the HiLetgo or
    the Open Workbench Logic Sniffer, to the more professional Saleae family ([Figure
    7-5](#figure7-5)), which support higher sampler rates and are more robust.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll walk through the process of using a logic analyzer against a target device
    in “Using a Logic Analyzer to Identify the UART Pins” on page 176.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the UART Baud Rate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, you have to identify the baud rate the UART ports use. Otherwise, you
    can’t communicate with the device. Given the absence of a synchronizing clock,
    the baud rate is the only way for the transmitter and receiver to exchange data
    in sync.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07005](Images/f07005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: Saleae is a family of professional logic analyzers.'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to identify the correct baud rate is to look at the TX pin’s
    output and try to read the data. If the data you receive isn’t readable, switch
    to the next possible baud rate until the data becomes readable. You can use a
    USB-to-serial adapter or a multipurpose device like Bus Pirate to do this, paired
    with a helper script, such as *baudrate.py* ([https://github.com/devttys0/baudrate/](https://github.com/devttys0/baudrate/))
    by Craig Heffner, to help automate this process. The most common baud rates are
    9600, 38400, 19200, 57600, and 115200, all of which Heffner’s Python script tests
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: JTAG and SWD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like UART, the JTAG and SWD interfaces on IoT embedded devices can serve as
    a way to gain control of a device. In this section, we’ll cover the basics of
    these interfaces and how you can communicate with them. In “Hacking a Device Through
    UART and SWD” on page 168, we’ll walk through a detailed example of interacting
    with SWD.
  prefs: []
  type: TYPE_NORMAL
- en: JTAG
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As manufacturers started producing smaller, denser components, testing them
    efficiently became harder. Engineers used to test hardware for defects using a
    *bed of nails* process, in which they placed the board on a number of fixtures
    arranged to mate with various parts of the board. When manufacturers began using
    multilayer boards and ball grid array packages, the fixtures could no longer access
    all nodes on the board.
  prefs: []
  type: TYPE_NORMAL
- en: '*JTAG* solved this problem by introducing a more effective alternative to the
    bed of nails test: the boundary scan. The *boundary scan* analyzes certain circuitry,
    including embedded boundary-scan cells and registers for each pin. By leveraging
    these boundary scan cells, engineers can test that a certain point on the circuit
    board correctly connects to another point more easily than they could before.'
  prefs: []
  type: TYPE_NORMAL
- en: Boundary Scan Commands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The JTAG standard defines specific commands for conducting boundary scans,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BYPASS* allows you to test a specific chip without the overhead of passing
    through other chips.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SAMPLE/PRELOAD* takes a sample of the data entering and leaving the device
    when it’s in its normal functioning mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*EXTEST* sets and reads pin states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The device must support these commands to be considered JTAG compliant. Devices
    might also support optional commands, like *IDCODE* (for identifying a device)and
    *INTEST* (for the internal testing of the device), among others. You might come
    across these instructions when you use a tool like the JTAGulator (described later
    in "Identifying JTAG pins" on page 166) for identifying JTAG pins.
  prefs: []
  type: TYPE_NORMAL
- en: The Test Access Port
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Boundary scans include tests of the four-wire *Test Access Port (TAP)*, a general-purpose
    port that provides access to the JTAG test support functions built into a component.
    It uses a 16-stage finite state machine that moves from state to state. Note that
    JTAG doesn’t define any protocol for the data coming in or out of the chip.
  prefs: []
  type: TYPE_NORMAL
- en: 'TAP uses the following five signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test clock input (TCK)** The TCK is the clock that defines how often the
    TAP controller will take a single action (in other words, jump to the next state
    in the state machine). The clock’s speed isn’t specified by the JTAG standard.
    The device performing the JTAG test can determine it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test mode select (TMS) input** TMS controls the finite state machine. On
    each beat of the clock, the device’s JTAG TAP controller checks the voltage on
    the TMS pin. If the voltage is below a certain threshold, the signal is considered
    low and interpreted as 0, whereas if the voltage is above a certain threshold,
    the signal is considered high and interpreted as 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test data input (TDI)** TDI is the pin that sends data into the chip through
    the scan cells. Each vendor is responsible for defining the communication protocol
    over this pin, because JTAG doesn’t define this. The signal presented at TDI is
    sampled on the rising edge of TCK.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test data output (TDO)** TDO is the pin that sends data out of the chip.
    According to the standard, changes in the state of the signal driven through TDO
    should occur only on the falling edge of TCK.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test reset (TRST) input** The optional TRST resets the finite state machine
    to a known good state. It’s active on low (0). Alternatively, if the TMS is held
    at 1 for five consecutive clock cycles, it invokes a reset, the same way the TRST
    pin would, which is why TRST is optional.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How SWD Works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SWD is a two-pin electrical interface that works very similarly to JTAG. Whereas
    JTAG was made primarily for chip and board testing, SWD is an ARM-specific protocol
    designed for debugging. Given the large prevalence of ARM processors in the IoT
    world, SWD has become increasingly important. If you find an SWD interface, you
    can almost always gain complete control of the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SWD interface requires two pins: a bidirectional *SWDIO* signal, which
    is the equivalent of JTAG’s TDI and TDO pins and a clock, and *SWCLK*, which is
    the equivalent of TCK in JTAG. Many devices support the *Serial Wire or JTAG Debug
    Port (SWJ-DP)*, a combined JTAG and SWD interface that enables you to connect
    either a SWD or JTAG probe to the target.'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware Tools for Communicating with JTAG and SWD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A variety of tools allow us to communicate with JTAG and SWD. Popular tools
    include the Bus Blaster FT2232H chip, as well as any tool with the FT232H chip,
    such as the Adafruit FT232H breakout board, the Shikra, or the Attify Badge. The
    Bus Pirate can also support JTAG if you load it with special firmware, but we
    don’t recommend using that functionality because it can be unstable. The Black
    Magic Probe, a specialized tool for JTAG and SWD hacking, has built-in GNU Debugger
    (GDB) support, which is useful because you won’t need intermediary programs like
    the *Open On-Chip Debugger (OpenOCD)* (discussed in “Installing OpenOCD” on page
    171). A professional debugging tool, the *Segger J-Link Debug Probe* supports
    JTAG, SWD, and even SPI, and it comes with proprietary software. If you want to
    communicate with SWD only, you can use a tool like the *ST-Link* programmer, which
    we’ll use later in this chapter in “Hacking a Device Through UART and SWD” on
    page 168\.
  prefs: []
  type: TYPE_NORMAL
- en: You can find additional tools, their descriptions, and links in “Tools for IoT
    Hacking.”
  prefs: []
  type: TYPE_NORMAL
- en: Identifying JTAG Pins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes a PCB has markings indicating the location of a JTAG header ([Figure
    7-6](#figure7-6)). But most times you’ll have to manually identify the header,
    as well as which pins correspond to the four signals (TDI, TDO, TCK, and TMS).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07006](Images/f07006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-6: Sometimes the JTAG header is clearly marked on the PCB, as in this
    mobile Point of Sale (POS) device, where even the individual JTAG pins are labeled
    (TMS, TDO, TDI, TCK).'
  prefs: []
  type: TYPE_NORMAL
- en: You can take several approaches to identify JTAG pins on a target device. The
    fastest but most expensive way to detect JTAG ports is by using the *JTAGulator*,
    a device created specifically for this purpose (although it can also detect UART
    pinouts). The tool, shown in [Figure 7-7](#figure7-7), has 24 channels that you
    can connect to a board’s pins. It performs a brute force of these pins by issuing
    the IDCODE and BYPASS boundary scan commands to every permutation of pins and
    waits for a response. If it receives a response, it displays the channel corresponding
    to each JTAG signal, allowing you to identify the JTAG pinout.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07007](Images/f07007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-7: The JTAGulator ([http://www.grandideastudio.com/jtagulator/](http://www.grandideastudio.com/jtagulator/))
    can help you identify JTAG pins on a target device.'
  prefs: []
  type: TYPE_NORMAL
- en: To use the JTAGulator, connect it to your computer with a USB cable and then
    communicate with it over serial (for example, using the `screen` utility on Linux).
    You’ll see an example of interfacing over serial later in this chapter in “Connecting
    the USB to a Serial Adapter” on page 178\. You can watch a demonstration of the
    JTAGulator by its creator, Joe Grand, at [https://www.youtube.com/watch?v=uVIsbXzQOIU/](https://www.youtube.com/watch?v=uVIsbXzQOIU/).
  prefs: []
  type: TYPE_NORMAL
- en: 'A cheaper but much slower way of identifying JTAG pinouts is by using the *JTAGenum*
    utility ([https://github.com/cyphunk/JTAGenum/](https://github.com/cyphunk/JTAGenum/))
    loaded on an Arduino-compatible microcontroller, like the STM32F103 blue and black
    pill devices we’ll attack later in this chapter in “Hacking a Device Through UART
    and SWD” on page 168\. Using JTAGenum, you’d first define the pins of the probing
    device that you’ll use for the enumeration. For example, for the STM32 blue pill,
    we’ve selected the following pins (but you can change them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You’d have to reference the device’s pinout diagram, and then connect these
    pins with the test points on your target device. Then you’ll have to flash the
    JTAGenum Arduino code ([https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.ino/](https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.ino/))
    on the device and communicate with it over serial (the `s` command will scan for
    JTAG combinations).
  prefs: []
  type: TYPE_NORMAL
- en: A third way to identify JTAG pins is by inspecting the PCB for one of the pinouts
    shown in [Figure 7-8](#figure7-8). In some cases, PCBs might conveniently provide
    the *Tag-Connect interface*, which is a clear indication that the board has a
    JTAG connector, too. You can see what that interface looks like at [https://www.tag-connect.com/info/](https://www.tag-connect.com/info/).
    Additionally, inspecting the datasheets of the chipsets on the PCB might reveal
    pinout diagrams that point to JTAG interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07008](Images/f07008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-8: Finding any of these pin interfaces in the PCB, depending on the
    manufacturer (ARM, STMicroelectronics, or Infineon for OCDS), would be a good
    indication that you’re dealing with a JTAG connector.'
  prefs: []
  type: TYPE_NORMAL
- en: Hacking a Device Through UART and SWD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll exploit a microcontroller’s UART and SWD ports to retrieve
    the device memory and bypass the flashed program’s authentication routine. To
    attack the device, we’ll use two tools: a mini ST-Link programmer and a USB-to-serial
    adapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The *mini ST-Link programmer* ([Figure 7-9](#figure7-9)) lets us interact with
    our target device through SWD.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07009](Images/f07009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-9: The mini ST-Link V2 programmer lets us interact with STM32 cores
    through SWD.'
  prefs: []
  type: TYPE_NORMAL
- en: The *USB-to-serial adapter* ([Figure 7-10](#figure7-10)) lets us communicate
    with the device’s UART pins through our computer’s USB port. This adapter is a
    *transistor-transistor logic (TTL)* device, which means it uses currents of 0
    and 5 volts to represent the values 0 and 1, respectively. Many adapters use the
    FT232R chip, and you can easily find one if you search for USB-to-serial adapters
    online.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07010](Images/f07010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-10: A USB-to-serial (TTL) adapter. This one can also switch between
    5 V and 3.3 V.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need a minimum of ten *jumper wires* to connect the devices by their
    pins. We also recommend getting a *breadboard*, which is a construction base that
    you can use to hold the black pill steady. You should be able to purchase these
    hardware components online. We specifically selected the components used here
    because they’re easy to find and inexpensive. But if you wanted an alternative
    to the ST-Link programmer, you could use the Bus Blaster, and as an alternative
    to the USB-to-serial adapter, you could use the Bus Pirate.
  prefs: []
  type: TYPE_NORMAL
- en: As for the software, we’ll use Arduino to code the authentication program we’ll
    attack; we’ll use OpenOCD with GDB for debugging. The following sections show
    you how to set up this testing and debugging environment.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F103C8T6 (Black Pill) Target Device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The STM32F103xx is a very popular, inexpensive microcontroller family used in
    a large variety of applications in the industrial, medical, and consumer markets.
    It has an ARM Cortex-M3 32-bit RISC core operating at 72 MHz frequency, a flash
    memory of up to 1MB, static random-access memory (SRAM) of up to 96KB, and an
    extensive range of I/Os and peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: The two versions of this device are known as the blue pill and the black pill
    (based on the board’s color). We’ll use the black pill (STM32F103C8T6) as our
    target device. The main difference between the two versions is that the black
    pill consumes less energy and is sturdier than the blue pill. You can easily order
    it online. We recommend getting a board that has presoldered headers and the Arduino
    bootloader flashed. That way, you won’t have to solder the headers and you’ll
    be able to use the device directly through USB. But in this exercise, we’ll show
    you how to load a program to the black pill without the Arduino bootloader.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-11](#figure7-11) shows the device’s pinout diagram. Notice that although
    some pins are 5 V-resistant, others aren’t; so we’ll have to send them no more
    than 3.3 V. If you’re interested in learning more about the internals of the STM32
    microcontroller in general, you can find a very good reference at [https://legacy.cs.indiana.edu/~geobrown/book.pdf](https://legacy.cs.indiana.edu/~geobrown/book.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you don’t connect any 5 V output to any of the black pill’s 3.3 V
    pins, or you’ll most likely burn them.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07011](Images/f07011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-11: STM32F103C8T6 (black pill) pinout diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Debugging Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start by programming our target device using the *Arduino Integrated Development
    Environment (IDE)*. The Arduino is an inexpensive, easy-to-use, open source electronics
    platform that lets you program microcontrollers using its Arduino programming
    language. Its IDE contains a text editor for writing code; a board and library
    manager; built-in functionality for verifying, compiling, and uploading the code
    to an Arduino board; and a serial monitor to display output from the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Arduino Environment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can get the latest version of the Arduino IDE at [https://www.arduino.cc/en/Main/Software/](https://www.arduino.cc/en/Main/Software/).
    For this demonstration, we’ll use version 1.8.9 on Ubuntu 18.04.3 LTS, but the
    operating system you use won’t matter. On Linux, download the package manually
    and follow the instructions at [https://www.arduino.cc/en/guide/linux/](https://www.arduino.cc/en/guide/linux/).
    Alternatively, if you’re using a Debian-based distribution, such as Kali or Ubuntu,
    you can enter the following command in a terminal to install everything you’ll
    need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After installing the IDE, download the latest Arduino STM32 core files from
    GitHub, install them in the *hardware* folder in the Arduino sketches directory,
    and run the *udev rules* installation script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you replace the username after */home/* with your own username.
  prefs: []
  type: TYPE_NORMAL
- en: If the *hardware* folder doesn’t exist, create it. To discover where the Arduino
    sketches are saved, run the Arduino IDE by entering `arduino` in a terminal or
    clicking the Arduino icon on your Desktop. Then click **File**▶**Preferences**
    and note the **Sketchbook location** file path. In this example, it’s */home/<ithilgore>/Arduino*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also need to install the 32-bit version of `libusb-1.0` as follows because
    the `st-link` utility that comes bundled with the Arduino STM32 relies on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In addition, install the Arduino SAM boards (Cortex-M3). These are the cores
    for the Cortex-M3 microcontroller. *Cores* are low-level APIs that make specific
    microcontrollers compatible with your Arduino IDE. You can install these inside
    the Arduino IDE by clicking **Tools**▶**Board**▶**Boards Manager**. Then search
    for **SAM Boards**. Click **Install** on the **Arduino SAM Boards (32-bits ARM
    Cortex-M3)** option that should appear. We used version 1.6.12\.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find the latest installation instructions for Arduino STM32 at
    [https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation/](https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenOCD
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*OpenOCD* is a free and open source testing tool that provides JTAG and SWD
    access through GDB to ARM, MIPS, and RISC-V systems. We’ll use it to debug the
    black pill. To install it in your Linux system, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you also install `libusb-1.0`, which you’ll need to enable support
    for Future Technology Devices International (FTDI) devices. Then compile OpenOCD
    from the source. This allows us to enable support for FTDI devices and the Bus
    Pirate tool.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about OpenOCD, consult its extensive user guide at [http://openocd.org/doc/html/index.html](http://openocd.org/doc/html/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the GNU Debugger
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*GDB* is a portable debugger that runs on Unix-like systems. It supports many
    target processors and programming languages. We’ll use GDB to remotely trace and
    alter the target program’s execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu, you’ll have to install the original `gdb` and `gdb-multiarch`, which
    extends GDB support for multiple target architectures, including ARM (the black
    pill’s architecture). You can do so by entering the following in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Coding a Target Program in Arduino
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll write a program in Arduino that we’ll load onto the black pill and
    target for exploitation. In an actual test, you might not have access to the device’s
    source code, but we’re showing it to you for two reasons. First, you’ll learn
    how Arduino code gets translated to a binary that you can upload onto the device.
    Second, when we perform debugging with OpenOCD and GDB, you’ll get to see how
    the assembly code corresponds to the original source code.
  prefs: []
  type: TYPE_NORMAL
- en: The program ([Listing 7-1](#listing7-1)) uses the serial interface to send and
    receive data. It emulates an authentication process by checking for a password.
    If it receives the right password from the user, it prints `ACCESS GRANTED`. Otherwise,
    it keeps prompting the user to log in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: A serial communication program in Arduino for the STM32F103 chip'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by defining four global variables 1. The `bufsiz` variable holds the
    number of bytes for the character array `buf`,``which stores the bytes coming
    through the serial port from the user or device interacting with the port. The
    `new_data` variable is a boolean that becomes `true` every time the main program
    loop receives a new line of serial data. The boolean variable `start` is `true`
    only upon the first iteration of the main loop, so it prints the first “Login”
    prompt.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
