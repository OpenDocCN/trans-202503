- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UART, JTAG, and SWD Exploitation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: If you understand the protocols that interact directly with a system’s electronic
    components, you can target IoT devices at the physical level. The *Universal Asynchronous
    Receiver-Transmitter (UART)* is one of the simplest serial protocols, and its
    exploitation provides one of the easiest ways to gain access to IoT devices. Vendors
    typically use it for debugging, which means that you can often obtain root access
    through it. To accomplish this, you’ll need some specialized hardware tools; for
    instance, it’s common for attackers to identify the UART pins on a device’s printed
    circuit board (PCB) using a multimeter or logic analyzer. They then connect a
    USB-to-serial adapter to these pins and open a serial debug console from the attacking
    workstation. Most of the time, if you do this, you’ll be dropped to a root shell.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The *Joint Test Action Group (JTAG)* is an industry standard (defined in IEEE
    1491.1) for debugging and testing increasingly complex PCBs. JTAG interfaces on
    embedded devices allow us to read and write memory contents, including dumping
    the entire firmware, which means it serves as a way to gain complete control of
    a target device. *Serial Wire Debug* (*SWD*) is a very similar, even simpler electrical
    interface than JTAG that we’ll examine here as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We spend most of this chapter walking through a lengthy practical exercise;
    you’ll program, debug, and exploit a microcontroller to bypass its authentication
    process using UART and SWD. But first we explain the inner workings of these protocols
    and show you how to identify UART and JTAG pinouts on a PCB using hardware and
    software tools.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: UART
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UART is a *serial* protocol, which means it transfers data between components
    one bit at a time. In contrast, *parallel communication* protocols transmit data
    simultaneously through multiple channels. Common serial protocols include RS-232,
    I²C, SPI, CAN, Ethernet, HDMI, PCI Express, and USB.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: UART is simpler than many of the protocols you’ve likely encountered. To synchronize
    communications, the UART transmitter and receiver must agree on a specific baud
    rate (the rate of bits transmitted per second). [Figure 7-1](#figure7-1) shows
    the UART packet format.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![f07001](Images/f07001.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: UART packet format'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the line is held high (at a logical 1 value) while UART is in the
    *idle* state. Then, to signal the start of a data transfer, the transmitter sends
    a *start bit* to the receiver, during which the signal is held low (at a logical
    0 value). Next, the transmitter sends five to eight *data bits* containing the
    actual message, followed by an optional parity bit and one or two stop bits (with
    a logical 1 value), depending on the configuration. The *parity bit*, used for
    error checking, is rarely seen in practice. The *stop bit* (or bits) signify the
    end of transmission.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the most common configuration *8N1*: eight data bits, no parity, and
    one stop bit. For example, if we wanted to send the character C, or 0x43 in ASCII,
    in an 8N1 UART configuration, we would send the following bits: `0` (the start
    bit); `0`, `1`, `0`, `0`, `0`, `0`, `1`, `1` (the value of 0x43 in binary), and
    `0` (the stop bit).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称最常见的配置为*8N1*：8个数据位、无奇偶校验位和一个停止位。例如，如果我们想在8N1 UART配置中发送字符C，或ASCII码0x43，我们将发送以下位：`0`（起始位）；`0`、`1`、`0`、`0`、`0`、`0`、`1`、`1`（0x43的二进制值）；以及`0`（停止位）。
- en: Hardware Tools for Communicating with UART
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与UART通信的硬件工具
- en: You can use a variety of hardware tools to communicate with UART. One easy option
    is a USB-to-serial adapter, like the one we use in “Hacking a Device Through UART
    and SWD” on page 168\. Other options include adapters with the CP2102 or PL2303
    chips. If you are new to hardware hacking, we recommend getting a multipurpose
    tool that supports protocols other than just UART, such as the Bus Pirate, the
    Adafruit FT232H, the Shikra, or the Attify Badge.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用各种硬件工具与UART进行通信。一种简单的选择是USB到串口适配器，如我们在“通过UART和SWD黑客攻击设备”一节中使用的那种。其他选项包括配备CP2102或PL2303芯片的适配器。如果你是硬件黑客新手，我们建议你获取一款支持除UART以外的其他协议的多功能工具，例如Bus
    Pirate、Adafruit FT232H、Shikra或Attify Badge。
- en: You can also find a list of tools and their descriptions, as well as links to
    buy them, in “Tools for IoT Hacking” at the end of this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在本书末尾的“物联网黑客工具”中找到工具列表及其描述，并附有购买链接。
- en: Identifying UART Ports
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定UART端口
- en: 'To exploit a device through UART, you first need to locate its four UART ports,
    or connectors, which typically come in the form of pins or *pads* (plated holes).
    The term *pinout* refers to the diagram of all the ports. We’ll use these terms
    interchangeably throughout this book. A UART pinout has four ports: *TX (Transmit)*,
    *RX (Receive)*, *Vcc (Voltage)*, and *GND (Ground)*. Start by opening the device’s
    external case and removing the PCB. Be warned that this might void your warranty.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过UART攻击设备，首先需要定位其四个UART端口或连接器，通常以引脚或*焊盘*（镀层孔）的形式出现。术语*引脚图*指的是所有端口的图示。我们将在本书中交替使用这些术语。UART引脚图包含四个端口：*TX（发送）*、*RX（接收）*、*Vcc（电压）*和*GND（地）*。首先打开设备的外壳并拆下PCB。请注意，这可能会使你的保修失效。
- en: These four ports often appear next to each other on the board. If you’re lucky,
    you might even find markings that indicate the TX and RX ports, as shown in [Figure
    7-2](#figure7-2). In that case, you can be fairly certain that the set of four
    pins are the UART pins.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个端口通常会彼此靠近。如果你运气好，甚至可能找到标明TX和RX端口的标记，如[图7-2](#figure7-2)所示。在这种情况下，你可以相当确定这四个引脚就是UART引脚。
- en: '![f07002](Images/f07002.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f07002](Images/f07002.png)'
- en: 'Figure 7-2: UART pins clearly marked as DBG_TXD and DBG_RXD on the PCB in a
    St. Jude/Abbott Medical Merlin@home Transmitter'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：在圣裘德/雅培医疗Merlin@home发射器的PCB板上，UART引脚清晰标记为DBG_TXD和DBG_RXD。
- en: In other cases, you might see four through-hole pads next to each other, like
    those in the TP-Link router in [Figure 7-3](#figure7-3). This might occur because
    vendors have removed the UART header pins from the PCB, which means that you might
    have to either perform some soldering to reach them or use test probes. (*Test
    probes* are physical devices that connect electronic test equipment to a device.
    They include a probe, cable, and terminating connector. We show a few examples
    of test probes in Chapter 8.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，你可能会看到四个互相并排的通孔焊盘，如[图7-3](#figure7-3)中TP-Link路由器的那样。这可能是因为厂商将UART头针从PCB上移除，这意味着你可能需要进行一些焊接操作来接触到它们，或者使用测试探针。（*测试探针*是连接电子测试设备和设备的物理设备，包括探针、电缆和终端连接器。我们将在第8章中展示一些测试探针的示例。）
- en: '![f07003](Images/f07003.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f07003](Images/f07003.png)'
- en: 'Figure 7-3: A PCB in a TP-Link TL WR840N router. On the bottom left, you can
    see a zoomed-in part of the PCB with the UART pads.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：TP-Link TL WR840N路由器中的PCB。在左下角，你可以看到放大的PCB部分，标有UART焊盘。
- en: Also, keep in mind that some devices emulate UART ports by programming the General-Purpose
    Input/Output (GPIO) pins if there isn’t enough space on the board for dedicated
    hardware UART pins.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，某些设备通过编程通用输入输出（GPIO）引脚来模拟UART端口，如果板上没有足够的空间放置专用的硬件UART引脚。
- en: 'When UART pins aren’t marked as clearly as those shown here, you can typically
    identify them on a device in two ways: by using a multimeter or by using a logic
    analyzer. A *multimeter* measures voltage, current, and resistance. Having a multimeter
    in your arsenal when doing hardware hacking is highly important, because it can
    serve a variety of purposes. For example, we commonly use it to test for *continuity*.
    A continuity test sounds a buzzer when a circuit’s resistance is low enough (less
    than a few ohms), indicating that there’s a continuous path between the two points
    probed by the multimeter’s leads.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 UART 引脚没有像这里所示那样清晰标记时，通常可以通过两种方式在设备上识别它们：使用万用表或使用逻辑分析仪。*万用表*可用于测量电压、电流和电阻。进行硬件黑客操作时，拥有万用表非常重要，因为它可以用于多种用途。例如，我们通常用它来测试*通断性*。通断性测试在电路电阻足够低（低于几欧姆）时会发出蜂鸣声，表示万用表探头所接触的两个点之间存在连续路径。
- en: Although a cheap multimeter will do the job, we recommend that you invest in
    a robust and precise multimeter, if you plan to delve deeper into hardware hacking.
    True RMS multimeters are more accurate for measuring AC currents. [Figure 7-4](#figure7-4)
    shows a typical multimeter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然便宜的万用表可以完成工作，但如果您计划深入研究硬件黑客操作，我们建议您投资一款坚固且精确的万用表。真正的 RMS 万用表在测量交流电流时更加精确。[图
    7-4](#figure7-4)展示了一款典型的万用表。
- en: '![f07004](Images/f07004.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f07004](Images/f07004.png)'
- en: 'Figure 7-4: Common multimeter. Highlighted is the Continuity Test mode, which
    typically has an icon that looks like a sound wave (because of the buzzer that
    sounds when detecting continuity).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：常见万用表。突出显示的是通断性测试模式，通常该模式有一个类似声波的图标（因为在检测到通断性时会发出蜂鸣声）。
- en: To identify UART pinouts using a multimeter, start by making sure the device
    is powered off. By convention, you should connect a black test lead to the multimeter’s
    COM jack. Insert a red lead in the VΩ jack.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用万用表识别 UART 引脚，首先确保设备已关闭电源。按照惯例，您应将黑色测试线连接到万用表的 COM 插孔。将红色测试线插入 VΩ 插孔。
- en: Begin by identifying the UART GND. Turn the multimeter dial to the Continuity
    Test mode, which typically has an icon that looks like a sound wave. It might
    share a spot on the dial with one or more functions, usually resistance. Place
    the other end of the black lead on any grounded metallic surface (an area that
    has a direct conductive path to earth), be it a part of the tested PCB or not.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先识别 UART GND 引脚。将万用表旋钮转到通断性测试模式，通常该模式有一个类似声波的图标。它可能与一个或多个功能共享一个位置，通常是电阻。将黑色测试线的另一端放在任何接地的金属表面上（无论是测试的
    PCB 一部分还是其他地方），该表面应有直接的导电路径连接到地面。
- en: Then place the red probe on each of the ports you suspect might be part of the
    UART pinout. When you hear a beeping sound from the multimeter, you’ve found a
    GND pin. Keep in mind that the device might have more than one GND pin and you
    might have found one that isn’t necessarily part of the UART pinout.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将红色探头放在您怀疑可能是 UART 引脚的每个端口上。当您听到万用表发出蜂鸣声时，说明您找到了 GND 引脚。请记住，设备可能有多个 GND 引脚，您可能找到的并不一定是
    UART 引脚的一部分。
- en: Continue by identifying the Vcc port. Turn the multimeter dial to the DC voltage
    mode in and set it up to 20 V of voltage. Keep the multimeter’s black probe on
    a grounded surface. Place the red probe in a suspected pad and turn on the device.
    If the multimeter measures a constant voltage of either 3.3 V or 5 V, you’ve found
    the Vcc pin. If you get other voltages, place the red probe on another port, reboot
    the device, and measure the voltage again. Do the same for every port until you
    identify Vcc.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来识别 Vcc 引脚。将万用表旋钮转到直流电压模式，并设置为 20 V 电压。将万用表的黑色探头保持在接地表面上。将红色探头放在一个怀疑是 Vcc
    引脚的焊盘上，然后打开设备。如果万用表测得恒定电压为 3.3 V 或 5 V，则说明您找到了 Vcc 引脚。如果得到其他电压，请将红色探头放到另一个端口，重新启动设备并再次测量电压。对每个端口都做同样的操作，直到找到
    Vcc 引脚。
- en: Next, identify the TX port. Keep the multimeter mode at a DC voltage of 20 V
    or less, and leave the black probe in a grounded surface. Move the red probe to
    the suspected pad and power cycle the device. If the voltage fluctuates for a
    few seconds and then stabilizes at the Vcc value (either 3.3 or 5), you’ve most
    likely found the TX port. This behavior happens because, during bootup, the device
    sends serial data through that TX port for debugging purposes. Once it finishes
    booting, the UART line goes idle. Recall from [Figure 7-1](#figure7-1) that an
    idle UART line remains at a logical high, which means that it has the Vcc value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve already identified the rest of the UART ports, the nearby fourth pin
    is most likely the RX port. Otherwise, you can identify it because it has the
    lowest voltage fluctuation and lowest overall value of all the UART pins.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: To identify the UART pins more accurately, use a *logic analyzer*, a device
    that captures and displays signals from a digital system. Many kinds of logic
    analyzers are available. They range from cheaper ones, such as the HiLetgo or
    the Open Workbench Logic Sniffer, to the more professional Saleae family ([Figure
    7-5](#figure7-5)), which support higher sampler rates and are more robust.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: We’ll walk through the process of using a logic analyzer against a target device
    in “Using a Logic Analyzer to Identify the UART Pins” on page 176.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the UART Baud Rate
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, you have to identify the baud rate the UART ports use. Otherwise, you
    can’t communicate with the device. Given the absence of a synchronizing clock,
    the baud rate is the only way for the transmitter and receiver to exchange data
    in sync.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![f07005](Images/f07005.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: Saleae is a family of professional logic analyzers.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to identify the correct baud rate is to look at the TX pin’s
    output and try to read the data. If the data you receive isn’t readable, switch
    to the next possible baud rate until the data becomes readable. You can use a
    USB-to-serial adapter or a multipurpose device like Bus Pirate to do this, paired
    with a helper script, such as *baudrate.py* ([https://github.com/devttys0/baudrate/](https://github.com/devttys0/baudrate/))
    by Craig Heffner, to help automate this process. The most common baud rates are
    9600, 38400, 19200, 57600, and 115200, all of which Heffner’s Python script tests
    by default.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: JTAG and SWD
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like UART, the JTAG and SWD interfaces on IoT embedded devices can serve as
    a way to gain control of a device. In this section, we’ll cover the basics of
    these interfaces and how you can communicate with them. In “Hacking a Device Through
    UART and SWD” on page 168, we’ll walk through a detailed example of interacting
    with SWD.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: JTAG
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As manufacturers started producing smaller, denser components, testing them
    efficiently became harder. Engineers used to test hardware for defects using a
    *bed of nails* process, in which they placed the board on a number of fixtures
    arranged to mate with various parts of the board. When manufacturers began using
    multilayer boards and ball grid array packages, the fixtures could no longer access
    all nodes on the board.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 随着制造商开始生产更小、更密集的组件，高效地测试它们变得更加困难。工程师过去使用*针床*过程来测试硬件缺陷，在这种过程中，他们将电路板放置在一些固定装置上，这些装置与电路板的不同部分连接。当制造商开始使用多层电路板和球栅阵列封装时，这些固定装置无法再访问电路板上的所有节点。
- en: '*JTAG* solved this problem by introducing a more effective alternative to the
    bed of nails test: the boundary scan. The *boundary scan* analyzes certain circuitry,
    including embedded boundary-scan cells and registers for each pin. By leveraging
    these boundary scan cells, engineers can test that a certain point on the circuit
    board correctly connects to another point more easily than they could before.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*JTAG*通过引入一种更有效的替代方式——边界扫描，解决了这个问题：边界扫描分析了某些电路，包括每个引脚的嵌入式边界扫描单元和寄存器。通过利用这些边界扫描单元，工程师可以比以前更容易地测试电路板上某个点是否正确连接到另一个点。'
- en: Boundary Scan Commands
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 边界扫描命令
- en: 'The JTAG standard defines specific commands for conducting boundary scans,
    including the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JTAG标准定义了用于进行边界扫描的特定命令，包括以下内容：
- en: '*BYPASS* allows you to test a specific chip without the overhead of passing
    through other chips.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旁路*（BYPASS）允许你在不经过其他芯片的情况下测试特定的芯片。'
- en: '*SAMPLE/PRELOAD* takes a sample of the data entering and leaving the device
    when it’s in its normal functioning mode.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*采样/预加载*（SAMPLE/PRELOAD）在设备处于正常工作模式时，采集进出设备的数据。'
- en: '*EXTEST* sets and reads pin states.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*外部测试*（EXTEST）设置并读取引脚状态。'
- en: The device must support these commands to be considered JTAG compliant. Devices
    might also support optional commands, like *IDCODE* (for identifying a device)and
    *INTEST* (for the internal testing of the device), among others. You might come
    across these instructions when you use a tool like the JTAGulator (described later
    in "Identifying JTAG pins" on page 166) for identifying JTAG pins.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 设备必须支持这些命令才能被认为符合JTAG标准。设备也可能支持一些可选命令，如*IDCODE*（用于识别设备）和*INTEST*（用于设备的内部测试）等。在使用像JTAGulator这样的工具（稍后在“识别JTAG引脚”第166页中描述）来识别JTAG引脚时，你可能会遇到这些指令。
- en: The Test Access Port
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试访问端口
- en: Boundary scans include tests of the four-wire *Test Access Port (TAP)*, a general-purpose
    port that provides access to the JTAG test support functions built into a component.
    It uses a 16-stage finite state machine that moves from state to state. Note that
    JTAG doesn’t define any protocol for the data coming in or out of the chip.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 边界扫描包括对四线*测试访问端口（TAP）*的测试，这是一种通用端口，用于访问内置于组件中的JTAG测试支持功能。它使用一个16级有限状态机，在各个状态之间移动。请注意，JTAG并未定义任何关于芯片输入或输出数据的协议。
- en: 'TAP uses the following five signals:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: TAP使用以下五个信号：
- en: '**Test clock input (TCK)** The TCK is the clock that defines how often the
    TAP controller will take a single action (in other words, jump to the next state
    in the state machine). The clock’s speed isn’t specified by the JTAG standard.
    The device performing the JTAG test can determine it.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试时钟输入（TCK）** TCK是定义TAP控制器每次执行一个操作（换句话说，即跳转到状态机中的下一个状态）频率的时钟。JTAG标准并未规定时钟的速度，执行JTAG测试的设备可以自行确定。'
- en: '**Test mode select (TMS) input** TMS controls the finite state machine. On
    each beat of the clock, the device’s JTAG TAP controller checks the voltage on
    the TMS pin. If the voltage is below a certain threshold, the signal is considered
    low and interpreted as 0, whereas if the voltage is above a certain threshold,
    the signal is considered high and interpreted as 1.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试模式选择（TMS）输入** TMS控制有限状态机。在每个时钟脉冲上，设备的JTAG TAP控制器检查TMS引脚上的电压。如果电压低于某个阈值，则信号被认为是低电平并解释为0；如果电压高于某个阈值，则信号被认为是高电平并解释为1。'
- en: '**Test data input (TDI)** TDI is the pin that sends data into the chip through
    the scan cells. Each vendor is responsible for defining the communication protocol
    over this pin, because JTAG doesn’t define this. The signal presented at TDI is
    sampled on the rising edge of TCK.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试数据输入（TDI）** TDI是将数据通过扫描单元发送到芯片的引脚。每个供应商负责定义该引脚的通信协议，因为JTAG并未定义这一点。在TDI上呈现的信号会在TCK的上升沿进行采样。'
- en: '**Test data output (TDO)** TDO is the pin that sends data out of the chip.
    According to the standard, changes in the state of the signal driven through TDO
    should occur only on the falling edge of TCK.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test reset (TRST) input** The optional TRST resets the finite state machine
    to a known good state. It’s active on low (0). Alternatively, if the TMS is held
    at 1 for five consecutive clock cycles, it invokes a reset, the same way the TRST
    pin would, which is why TRST is optional.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How SWD Works
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SWD is a two-pin electrical interface that works very similarly to JTAG. Whereas
    JTAG was made primarily for chip and board testing, SWD is an ARM-specific protocol
    designed for debugging. Given the large prevalence of ARM processors in the IoT
    world, SWD has become increasingly important. If you find an SWD interface, you
    can almost always gain complete control of the device.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The SWD interface requires two pins: a bidirectional *SWDIO* signal, which
    is the equivalent of JTAG’s TDI and TDO pins and a clock, and *SWCLK*, which is
    the equivalent of TCK in JTAG. Many devices support the *Serial Wire or JTAG Debug
    Port (SWJ-DP)*, a combined JTAG and SWD interface that enables you to connect
    either a SWD or JTAG probe to the target.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Hardware Tools for Communicating with JTAG and SWD
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A variety of tools allow us to communicate with JTAG and SWD. Popular tools
    include the Bus Blaster FT2232H chip, as well as any tool with the FT232H chip,
    such as the Adafruit FT232H breakout board, the Shikra, or the Attify Badge. The
    Bus Pirate can also support JTAG if you load it with special firmware, but we
    don’t recommend using that functionality because it can be unstable. The Black
    Magic Probe, a specialized tool for JTAG and SWD hacking, has built-in GNU Debugger
    (GDB) support, which is useful because you won’t need intermediary programs like
    the *Open On-Chip Debugger (OpenOCD)* (discussed in “Installing OpenOCD” on page
    171). A professional debugging tool, the *Segger J-Link Debug Probe* supports
    JTAG, SWD, and even SPI, and it comes with proprietary software. If you want to
    communicate with SWD only, you can use a tool like the *ST-Link* programmer, which
    we’ll use later in this chapter in “Hacking a Device Through UART and SWD” on
    page 168\.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: You can find additional tools, their descriptions, and links in “Tools for IoT
    Hacking.”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Identifying JTAG Pins
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes a PCB has markings indicating the location of a JTAG header ([Figure
    7-6](#figure7-6)). But most times you’ll have to manually identify the header,
    as well as which pins correspond to the four signals (TDI, TDO, TCK, and TMS).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![f07006](Images/f07006.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-6: Sometimes the JTAG header is clearly marked on the PCB, as in this
    mobile Point of Sale (POS) device, where even the individual JTAG pins are labeled
    (TMS, TDO, TDI, TCK).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: You can take several approaches to identify JTAG pins on a target device. The
    fastest but most expensive way to detect JTAG ports is by using the *JTAGulator*,
    a device created specifically for this purpose (although it can also detect UART
    pinouts). The tool, shown in [Figure 7-7](#figure7-7), has 24 channels that you
    can connect to a board’s pins. It performs a brute force of these pins by issuing
    the IDCODE and BYPASS boundary scan commands to every permutation of pins and
    waits for a response. If it receives a response, it displays the channel corresponding
    to each JTAG signal, allowing you to identify the JTAG pinout.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![f07007](Images/f07007.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-7: The JTAGulator ([http://www.grandideastudio.com/jtagulator/](http://www.grandideastudio.com/jtagulator/))
    can help you identify JTAG pins on a target device.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: To use the JTAGulator, connect it to your computer with a USB cable and then
    communicate with it over serial (for example, using the `screen` utility on Linux).
    You’ll see an example of interfacing over serial later in this chapter in “Connecting
    the USB to a Serial Adapter” on page 178\. You can watch a demonstration of the
    JTAGulator by its creator, Joe Grand, at [https://www.youtube.com/watch?v=uVIsbXzQOIU/](https://www.youtube.com/watch?v=uVIsbXzQOIU/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'A cheaper but much slower way of identifying JTAG pinouts is by using the *JTAGenum*
    utility ([https://github.com/cyphunk/JTAGenum/](https://github.com/cyphunk/JTAGenum/))
    loaded on an Arduino-compatible microcontroller, like the STM32F103 blue and black
    pill devices we’ll attack later in this chapter in “Hacking a Device Through UART
    and SWD” on page 168\. Using JTAGenum, you’d first define the pins of the probing
    device that you’ll use for the enumeration. For example, for the STM32 blue pill,
    we’ve selected the following pins (but you can change them):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You’d have to reference the device’s pinout diagram, and then connect these
    pins with the test points on your target device. Then you’ll have to flash the
    JTAGenum Arduino code ([https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.ino/](https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.ino/))
    on the device and communicate with it over serial (the `s` command will scan for
    JTAG combinations).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: A third way to identify JTAG pins is by inspecting the PCB for one of the pinouts
    shown in [Figure 7-8](#figure7-8). In some cases, PCBs might conveniently provide
    the *Tag-Connect interface*, which is a clear indication that the board has a
    JTAG connector, too. You can see what that interface looks like at [https://www.tag-connect.com/info/](https://www.tag-connect.com/info/).
    Additionally, inspecting the datasheets of the chipsets on the PCB might reveal
    pinout diagrams that point to JTAG interfaces.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![f07008](Images/f07008.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-8: Finding any of these pin interfaces in the PCB, depending on the
    manufacturer (ARM, STMicroelectronics, or Infineon for OCDS), would be a good
    indication that you’re dealing with a JTAG connector.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-8：根据制造商（ARM、STMicroelectronics 或 Infineon 的 OCDS），在 PCB 上找到任何这些引脚接口都可以作为你正在处理
    JTAG 连接器的良好指示。
- en: Hacking a Device Through UART and SWD
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 UART 和 SWD 破解设备
- en: 'In this section, we’ll exploit a microcontroller’s UART and SWD ports to retrieve
    the device memory and bypass the flashed program’s authentication routine. To
    attack the device, we’ll use two tools: a mini ST-Link programmer and a USB-to-serial
    adapter.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用微控制器的 UART 和 SWD 接口来获取设备内存并绕过已闪存程序的认证例程。为了攻击设备，我们将使用两种工具：迷你 ST-Link
    编程器和 USB 到串行适配器。
- en: The *mini ST-Link programmer* ([Figure 7-9](#figure7-9)) lets us interact with
    our target device through SWD.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*迷你 ST-Link 编程器*（[图 7-9](#figure7-9)）让我们通过 SWD 与目标设备进行交互。'
- en: '![f07009](Images/f07009.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![f07009](Images/f07009.png)'
- en: 'Figure 7-9: The mini ST-Link V2 programmer lets us interact with STM32 cores
    through SWD.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-9：迷你 ST-Link V2 编程器让我们通过 SWD 与 STM32 核心进行交互。
- en: The *USB-to-serial adapter* ([Figure 7-10](#figure7-10)) lets us communicate
    with the device’s UART pins through our computer’s USB port. This adapter is a
    *transistor-transistor logic (TTL)* device, which means it uses currents of 0
    and 5 volts to represent the values 0 and 1, respectively. Many adapters use the
    FT232R chip, and you can easily find one if you search for USB-to-serial adapters
    online.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*USB 到串行适配器*（[图 7-10](#figure7-10)）让我们通过计算机的 USB 端口与设备的 UART 引脚进行通信。该适配器是一个
    *晶体管-晶体管逻辑（TTL）* 设备，意味着它使用 0 和 5 伏的电流分别表示 0 和 1。许多适配器使用 FT232R 芯片，你可以通过在线搜索 USB
    到串行适配器轻松找到一个。'
- en: '![f07010](Images/f07010.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![f07010](Images/f07010.png)'
- en: 'Figure 7-10: A USB-to-serial (TTL) adapter. This one can also switch between
    5 V and 3.3 V.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-10：USB 到串行（TTL）适配器。此适配器还可以在 5V 和 3.3V 之间切换。
- en: You’ll need a minimum of ten *jumper wires* to connect the devices by their
    pins. We also recommend getting a *breadboard*, which is a construction base that
    you can use to hold the black pill steady. You should be able to purchase these
    hardware components online. We specifically selected the components used here
    because they’re easy to find and inexpensive. But if you wanted an alternative
    to the ST-Link programmer, you could use the Bus Blaster, and as an alternative
    to the USB-to-serial adapter, you could use the Bus Pirate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要至少十根 *跳线* 来通过引脚连接设备。我们还建议你购买一个 *面包板*，它是一个构建基座，可以用来稳固地固定黑色小药丸。你应该能在网上购买到这些硬件组件。我们特别选择这里使用的组件，因为它们易于找到且价格便宜。但如果你想要替代
    ST-Link 编程器，可以使用 Bus Blaster，替代 USB 到串行适配器，可以使用 Bus Pirate。
- en: As for the software, we’ll use Arduino to code the authentication program we’ll
    attack; we’ll use OpenOCD with GDB for debugging. The following sections show
    you how to set up this testing and debugging environment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于软件，我们将使用 Arduino 编写我们要攻击的认证程序；我们将使用 OpenOCD 和 GDB 进行调试。以下章节将向你展示如何设置这个测试和调试环境。
- en: The STM32F103C8T6 (Black Pill) Target Device
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: STM32F103C8T6（黑色小药丸）目标设备
- en: The STM32F103xx is a very popular, inexpensive microcontroller family used in
    a large variety of applications in the industrial, medical, and consumer markets.
    It has an ARM Cortex-M3 32-bit RISC core operating at 72 MHz frequency, a flash
    memory of up to 1MB, static random-access memory (SRAM) of up to 96KB, and an
    extensive range of I/Os and peripherals.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F103xx 是一个非常受欢迎且廉价的微控制器系列，广泛应用于工业、医疗和消费市场。它拥有一个 72 MHz 频率的 ARM Cortex-M3
    32 位 RISC 核心，最多 1MB 的闪存，最多 96KB 的静态随机存取存储器（SRAM），以及丰富的 I/O 和外设接口。
- en: The two versions of this device are known as the blue pill and the black pill
    (based on the board’s color). We’ll use the black pill (STM32F103C8T6) as our
    target device. The main difference between the two versions is that the black
    pill consumes less energy and is sturdier than the blue pill. You can easily order
    it online. We recommend getting a board that has presoldered headers and the Arduino
    bootloader flashed. That way, you won’t have to solder the headers and you’ll
    be able to use the device directly through USB. But in this exercise, we’ll show
    you how to load a program to the black pill without the Arduino bootloader.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-11](#figure7-11) shows the device’s pinout diagram. Notice that although
    some pins are 5 V-resistant, others aren’t; so we’ll have to send them no more
    than 3.3 V. If you’re interested in learning more about the internals of the STM32
    microcontroller in general, you can find a very good reference at [https://legacy.cs.indiana.edu/~geobrown/book.pdf](https://legacy.cs.indiana.edu/~geobrown/book.pdf).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you don’t connect any 5 V output to any of the black pill’s 3.3 V
    pins, or you’ll most likely burn them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![f07011](Images/f07011.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-11: STM32F103C8T6 (black pill) pinout diagram'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Debugging Environment
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start by programming our target device using the *Arduino Integrated Development
    Environment (IDE)*. The Arduino is an inexpensive, easy-to-use, open source electronics
    platform that lets you program microcontrollers using its Arduino programming
    language. Its IDE contains a text editor for writing code; a board and library
    manager; built-in functionality for verifying, compiling, and uploading the code
    to an Arduino board; and a serial monitor to display output from the hardware.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Arduino Environment
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can get the latest version of the Arduino IDE at [https://www.arduino.cc/en/Main/Software/](https://www.arduino.cc/en/Main/Software/).
    For this demonstration, we’ll use version 1.8.9 on Ubuntu 18.04.3 LTS, but the
    operating system you use won’t matter. On Linux, download the package manually
    and follow the instructions at [https://www.arduino.cc/en/guide/linux/](https://www.arduino.cc/en/guide/linux/).
    Alternatively, if you’re using a Debian-based distribution, such as Kali or Ubuntu,
    you can enter the following command in a terminal to install everything you’ll
    need:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After installing the IDE, download the latest Arduino STM32 core files from
    GitHub, install them in the *hardware* folder in the Arduino sketches directory,
    and run the *udev rules* installation script.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Make sure you replace the username after */home/* with your own username.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: If the *hardware* folder doesn’t exist, create it. To discover where the Arduino
    sketches are saved, run the Arduino IDE by entering `arduino` in a terminal or
    clicking the Arduino icon on your Desktop. Then click **File**▶**Preferences**
    and note the **Sketchbook location** file path. In this example, it’s */home/<ithilgore>/Arduino*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also need to install the 32-bit version of `libusb-1.0` as follows because
    the `st-link` utility that comes bundled with the Arduino STM32 relies on it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In addition, install the Arduino SAM boards (Cortex-M3). These are the cores
    for the Cortex-M3 microcontroller. *Cores* are low-level APIs that make specific
    microcontrollers compatible with your Arduino IDE. You can install these inside
    the Arduino IDE by clicking **Tools**▶**Board**▶**Boards Manager**. Then search
    for **SAM Boards**. Click **Install** on the **Arduino SAM Boards (32-bits ARM
    Cortex-M3)** option that should appear. We used version 1.6.12\.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: You can also find the latest installation instructions for Arduino STM32 at
    [https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation/](https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenOCD
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*OpenOCD* is a free and open source testing tool that provides JTAG and SWD
    access through GDB to ARM, MIPS, and RISC-V systems. We’ll use it to debug the
    black pill. To install it in your Linux system, enter the following commands:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that you also install `libusb-1.0`, which you’ll need to enable support
    for Future Technology Devices International (FTDI) devices. Then compile OpenOCD
    from the source. This allows us to enable support for FTDI devices and the Bus
    Pirate tool.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about OpenOCD, consult its extensive user guide at [http://openocd.org/doc/html/index.html](http://openocd.org/doc/html/index.html).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Installing the GNU Debugger
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*GDB* is a portable debugger that runs on Unix-like systems. It supports many
    target processors and programming languages. We’ll use GDB to remotely trace and
    alter the target program’s execution.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu, you’ll have to install the original `gdb` and `gdb-multiarch`, which
    extends GDB support for multiple target architectures, including ARM (the black
    pill’s architecture). You can do so by entering the following in a terminal:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Coding a Target Program in Arduino
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll write a program in Arduino that we’ll load onto the black pill and
    target for exploitation. In an actual test, you might not have access to the device’s
    source code, but we’re showing it to you for two reasons. First, you’ll learn
    how Arduino code gets translated to a binary that you can upload onto the device.
    Second, when we perform debugging with OpenOCD and GDB, you’ll get to see how
    the assembly code corresponds to the original source code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The program ([Listing 7-1](#listing7-1)) uses the serial interface to send and
    receive data. It emulates an authentication process by checking for a password.
    If it receives the right password from the user, it prints `ACCESS GRANTED`. Otherwise,
    it keeps prompting the user to log in.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-1: A serial communication program in Arduino for the STM32F103 chip'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We begin by defining four global variables 1. The `bufsiz` variable holds the
    number of bytes for the character array `buf`,``which stores the bytes coming
    through the serial port from the user or device interacting with the port. The
    `new_data` variable is a boolean that becomes `true` every time the main program
    loop receives a new line of serial data. The boolean variable `start` is `true`
    only upon the first iteration of the main loop, so it prints the first “Login”
    prompt.``
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
