<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_143"/><strong><span class="big">8</span><br/>CONFIGURING NETWORKING</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Now that you know enough networking to be dangerous, you can configure a network connection. While FreeBSD supports many different protocols, we’ll focus on the nearly ubiquitous Ethernet connection, generally delivered over CAT5 or CAT6 cables.<sup><a href="footnote.xhtml#ch08fn1" id="ch08fn1a">1</a></sup></p>
<p class="indent">We’ll start with the essentials for getting a host on the network and able to access other internet hosts. Raw TCP/IP connectivity isn’t enough, however; you also need the ability to resolve host names to IP addresses, so we’ll cover that next. Then we’ll talk about measuring network activity, performance, VLANs, and aggregating links.</p>
<p class="indent">Before you can do any of that, though, you need some information.</p>
<h3 class="h3" id="lev234"><span epub:type="pagebreak" id="page_144"/><strong>Network Prerequisites</strong></h3>
<p class="noindent">If your network offers Dynamic Host Configuration Protocol (DHCP), you can connect to the network as a client without knowing anything about the network. A static IP address makes much more sense on a server, however. While the installer will configure the network for you, eventually every server needs changes. Both IPv4 and IPv6 require the following information:</p>
<ul>
<li class="noindent">An IP address</li>
<li class="noindent">The netmask for that IP address and protocol</li>
<li class="noindent">The IP address of the default gateway</li>
</ul>
<p class="indent">Armed with this information, attach your system to the network with ifconfig(8) and route(8) and then make the configuration permanent in <em>/etc/rc.conf</em>.</p>
<h4 class="h4" id="lev235"><strong><em>Configuring Changes with ifconfig(8)</em></strong></h4>
<p class="noindent">The ifconfig(8) program displays the interfaces on your computer and lets you configure them. Start by listing the existing interfaces on your system by running ifconfig(8) without any arguments:</p>
<pre># <span class="codestrong1">ifconfig</span><br/><span class="ent">➊</span>em0: flags=8843&lt;<span class="ent">➋</span>UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500<br/>        options=85259b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4,<br/>LRO,WOL_MAGIC,VLAN_HWFILTER,VLAN_HWTSO&gt;<br/>        inet <span class="ent">➌</span>203.0.113.43 netmask 0xfffffff0 broadcast 198.51.100.47<br/>        inet6 <span class="ent">➍</span>fe80::225:90ff:fee8:1270%em0 prefixlen 64 scopeid 0x1<br/>        inet6 <span class="ent">➎</span>2001:db8::bad:c0de:cafe prefixlen 64<br/>        ether <span class="ent">➏</span>00:25:90:db:d5:94<br/>        media: <span class="ent">➐</span>Ethernet autoselect (1000baseTX &lt;full-duplex&gt;)<br/>        status: <span class="ent">➑</span>active<br/><br/>rl0: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500<br/>        options=8&lt;VLAN_MTU&gt;<br/>        ether 00:20:ed:72:3b:5f<br/>        media: Ethernet autoselect (10baseT/UTP)<br/>        status: <span class="ent">➒</span>no carrier<br/><span class="ent">➓</span>lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384<br/>        options=600003&lt;RXCSUM,TXCSUM,RXCSUM_IPV6,TXCSUM_IPV6&gt;<br/>        inet6 ::1 prefixlen 128<br/>        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x2<br/>        inet 127.0.0.1 netmask 0xff000000<br/>        nd6 options=21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;</pre>
<p class="indent">Our first network interface is em0 <span class="ent">➊</span>, or the first network card that uses the em(4) driver. The em(4) man page reveals that this is an Intel PRO/1000 card. You’ll then see basic information about this card <span class="ent">➋</span>, including that it is in the UP state, meaning it’s either working or trying to work. It’s assigned the IPv4 address 203.0.113.43 <span class="ent">➌</span> and the netmask 0xfffffff0 (or <span epub:type="pagebreak" id="page_145"/>255.255.255.240, per <a href="ch07.xhtml#ch07tab2">Table 7-2</a>). This card has two IPv6 addresses, the link-local address (beginning with fe80) <span class="ent">➍</span> and the global IPv6 address <span class="ent">➎</span>. You’ll also see the MAC address <span class="ent">➏</span> and the connection speed <span class="ent">➐</span>. Finally, the <code>status</code> entry shows that this card is active <span class="ent">➑</span>: a cable is plugged in and we have a link light.</p>
<p class="indent">The second card, rl0, has almost none of this information associated with it. One key fact is the <code>no carrier</code> signal <span class="ent">➒</span>: it’s not plugged in and there is no link light. This card is not in use.</p>
<p class="indent">Finally we have the interface lo0 <span class="ent">➓</span>, the loopback. This interface has the IPv4 address 127.0.0.1 and IPv6 address ::1 on every machine. This loopback address is used when the machine talks to itself. This is a standard software interface, which does not have any associated physical hardware. Do not attempt to delete the loopback interface, and do not change its IP address—things will break in an amusing way if you do so. FreeBSD supports other software interfaces, such as disc(4), tap(4), gif(4), and many more.</p>
<h4 class="h4" id="lev236"><strong><em>Adding an IP to an Interface</em></strong></h4>
<p class="noindent">The install process will configure any network cards you have working at install time. If you didn’t configure the network for all of your cards during the setup process, or if you add or remove network cards after finishing the install, you can assign an IP address to your network card with ifconfig(8). You need the card’s assigned IP address and netmask.</p>
<pre># <span class="codestrong1">ifconfig interface-name inet IP-address netmask</span></pre>
<p class="indent">For example, if your network card is em0, your IP address is 203.0.113.250, and your netmask is 255.255.255.0, you would type:</p>
<pre># <span class="codestrong1">ifconfig em0 inet 203.0.113.250 255.255.255.0</span></pre>
<p class="indent">Specify the netmask in dotted-quad notation as above or in hex format (0xffffff00). Perhaps simplest of all is to use slash notation, like this:</p>
<pre># <span class="codestrong1">ifconfig em0 inet 203.0.113.250/24</span></pre>
<p class="indent">To configure an IPv6 address, add the <code>inet6</code> keyword between the interface name and the address.</p>
<pre># <span class="codestrong1">ifconfig em0 inet6 2001:db8::bad:c0de:cafe/64</span></pre>
<p class="indent">The ifconfig(8) program can also perform any other configuration your network cards require, letting you work around hardware bugs in features such as the various sorts of checksum offloading, like setting media type and duplex mode for sub-gigabit interfaces. You’ll find supported options in the man pages for the driver and ifconfig(8). Here, I disable checksum offloading and TCP segmentation offloading on my em0 interface, even while I set the IP address.</p>
<pre><span epub:type="pagebreak" id="page_146"/># <span class="codestrong1">ifconfig em0 inet 203.0.113.250/24 -tso -rxcsum</span></pre>
<p class="indent">To make this persist across reboots, add an entry to <em>/etc/rc.conf</em> that tells the system to configure the card at boot. An IPv4 entry has the form <code>ifconfig_</code><span class="codeitalic">interfacename</span><code>="</code><span class="codeitalic">ifconfig arguments</span><code>"</code>. For example, configuring the idle rl0 card would require an entry much like this:</p>
<pre>ifconfig_rl0 ="inet 203.0.113.250/24"</pre>
<p class="indent">An IPv6 entry has the form <code>ifconfig_</code><span class="codeitalic">interfacename</span><code>_ipv6="</code><span class="codeitalic">ifconfig arguments</span><code>"</code>.</p>
<pre>ifconfig_rl0_ipv6="2001:db8::bad:c0de:cafe/64"</pre>
<p class="indent">Once you have a working configuration for your interface, copy your ifconfig(8) arguments into a <em>/etc/rc.conf</em> entry.</p>
<h4 class="h4" id="lev237"><strong><em>Testing Your Interface</em></strong></h4>
<p class="noindent">Now that your interface has an IP address, try to ping the IPv4 address of your default gateway. If you get a response, as shown in the following example, you’re on the local network. Interrupt the ping with <small>CTRL</small>-C.</p>
<pre># <span class="codestrong1">ping 203.0.113.1</span><br/>PING 203.0.113.1 (203.0.113.1): 56 data bytes<br/>64 bytes from 203.0.113.1: icmp_seq=0 ttl=64 time=1.701 ms<br/>64 bytes from 203.0.113.1: icmp_seq=1 ttl=64 time=1.436 ms<br/>^C<br/>--- 203.0.113.1 ping statistics ---<br/>2 packets transmitted, 2 packets received, 0% packet loss<br/>round-trip min/avg/max/stddev = 1.436/1.569/1.701/0.133 ms</pre>
<p class="indent">For IPv6, use ping6(8) instead of ping(8). If you use router discovery, the default route will almost always be a link-local address.</p>
<pre># <span class="codestrong1">ping6 2001:db8::1</span><br/>PING6(56=40+8+8 bytes) 2001:db8::bad:c0de:cafe --&gt; 2001:db8::1<br/>16 bytes from 2001:db8::1, icmp_seq=0 hlim=64 time=0.191 ms<br/>16 bytes from 2001:db8::1, icmp_seq=1 hlim=64 time=0.186 ms<br/>16 bytes from 2001:db8::1, icmp_seq=2 hlim=64 time=0.197 ms<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">If you don’t get any answers, your network connection isn’t working. Either you have a bad connection (check your cables and link lights) or you have misconfigured your card.</p>
<h4 class="h4" id="lev238"><strong><em>Set Default Route</em></strong></h4>
<p class="noindent">The default route is the address where your system sends all traffic that’s not on the local network. If you can ping the default route’s IPv4 address, set it via route(8).</p>
<pre><span epub:type="pagebreak" id="page_147"/># <span class="codestrong1">route add default 203.0.113.1</span></pre>
<p class="indent">That’s it! You should now be able to ping any public IPv4 address on the internet.</p>
<p class="indent">Adding the default IPv6 route is much the same, but you need to add the <code>-6</code> command line flag to change the IPv6 routing table.</p>
<pre># <span class="codestrong1">route -6 add default 2001:db8::1</span></pre>
<p class="indent">If you didn’t choose nameservers during the system install, you’ll have to use the IP address rather than the hostname.</p>
<p class="indent">Once you have a working default router, make it persist across reboots by adding the proper <code>defaultrouter</code> and <code>ipv6_defaultrouter</code> entries in <em>/etc/rc.conf</em>:</p>
<pre>defaultrouter="203.0.113.1"<br/>ipv6_defaultrouter="2001:db8::1"</pre>
<h4 class="h4" id="lev239"><strong><em>Multiple IP Addresses on One Interface</em></strong></h4>
<p class="noindent">A FreeBSD system can respond to multiple IP addresses on one interface. This is especially useful for jails (see <a href="ch22.xhtml#ch22">Chapter 22</a>). Specify additional IPv4 addresses for an interface with ifconfig(8) and the keywords <code>inet</code> and <code>alias</code>. The netmask on an IPv4 alias is always /32, regardless of the size of the network address block the main address uses.</p>
<pre># <span class="codestrong1">ifconfig em0 inet alias 203.0.113.225/32</span></pre>
<p class="indent">IPv6 aliases use the actual prefix length (slash) of the subnet they’re on. Be sure you use the <code>inet6</code> keyword.</p>
<pre># <span class="codestrong1">ifconfig em0 inet6 alias 2001:db8::bad:c0de:caff/64</span></pre>
<p class="indent">Once you add an alias to the interface, the additional IP address appears in ifconfig(8) output. The main IP always appears first, and aliases follow.</p>
<pre>   # <span class="codestrong1">ifconfig fxp0</span><br/>   fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br/>           options=b&lt;RXCSUM,TXCSUM,VLAN_MTU&gt;<br/>           inet6 fe80::225:90ff:fee8:1270%vtnet0 prefixlen 64 scopeid 0x1<br/><span class="ent">➊</span>          inet6 2001:db8::bad:c0de:cafe prefixlen 64<br/>           inet6 2001:db8::bad:c0de:caff prefixlen 64<br/>           inet 203.0.113.250 netmask 0xffffff00 broadcast 203.0.113.255<br/><span class="ent">➋</span>          inet 203.0.113.225 netmask 0xffffffff broadcast 203.0.113.255<br/>           ether 00:02:b3:63:e4:1d<br/>   --<span class="codeitalic1">snip</span>--</pre>
<p class="indent">Here we see our brand new IPv4 <span class="ent">➊</span> and IPv6 <span class="ent">➋</span> aliases. Hosts that ping your aliased addresses will get a response from this server.</p>
<p class="indent"><span epub:type="pagebreak" id="page_148"/>Once you have the aliases working as you like, make them persist across reboots by adding additional <code>ifconfig</code> statements in <em>/etc/rc.conf</em>:</p>
<pre>ifconfig_em0_alias0="inet 203.0.113.225/32"<br/>ifconfig_em0_alias1="inet6 2001:db8::bad:c0de:caff/64"</pre>
<p class="indent">The only real difference between this entry and the standard <em>rc.conf</em> ’s “here’s my IP address” entry are the <code>alias0</code> and <code>alias1</code> chunks. The <code>alias</code> keyword tells FreeBSD that this is an aliased IP, and the <code>0</code> and <code>1</code> are unique numbers assigned to each alias. Every alias set in <em>/etc/rc.conf</em> must have a unique number, and this number must be sequential. If you skip a number, aliases after the gap won’t be installed at boot. This is the most common interface misconfiguration I’ve seen.</p>
<p class="indent">Many daemons, such as inetd(8) and sshd(8), can be bound to a single address (see <a href="ch20.xhtml#ch20">Chapter 20</a>), so you can run multiple instances of the same program on the same server using multiple addresses.</p>
<div class="sidebar">
<p class="sidebart"><strong>ALIASES AND OUTGOING CONNECTIONS</strong></p>
<p class="spara">All connections from your FreeBSD system use the system’s real IP address. You might have 2,000 addresses bound to one network card, but when you <code>ssh</code> from that machine, the connection comes from the primary IP address. Keep this in mind when writing firewall rules and other access-control filters. Jails initiate all connections from the jail IP address, but we won’t cover jails until <a href="ch22.xhtml#ch22">Chapter 22</a>.</p>
</div>
<h4 class="h4" id="lev240"><strong><em>Renaming Interfaces</em></strong></h4>
<p class="noindent">FreeBSD names its network interfaces after the device driver used by the network card. This is a fine old tradition in the Unix world and common behavior among most industrial operating systems. Some operating systems name their network interfaces by the type of interface—for example, Linux calls its Ethernet interfaces <em>eth0</em>, <em>eth1</em>, and so on. At times, it makes sense to rename an interface, either to comply with an internal standard or to make its function more apparent. For example, I have one device with 12 network interfaces, each plugged into a different network. Each network has a name such as <em>test</em>, <em>QA</em>, and so on. Renaming these network interfaces to match the attached networks makes sense.</p>
<p class="indent">While FreeBSD is flexible on interface names, some software isn’t—it assumes that a network interface name is a short word followed by a number. This isn’t likely to change any time in the near future, so it’s best practice to use a short interface name ending in a digit. Use ifconfig(8)’s <code>name</code> keyword to rename an interface. For example, to rename <em>em1</em> to <em>test1</em>, you would run:</p>
<pre># <span class="codestrong1">ifconfig em1 name test1</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_149"/>Running ifconfig(8) without arguments shows that you have renamed that interface.</p>
<pre>--<span class="codeitalic1">snip</span>--<br/>test1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br/>        options=b&lt;RXCSUM,TXCSUM,VLAN_MTU&gt;<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">Make this change permanent with the <code>ifconfig_</code><span class="codeitalic1">interface</span><code>_name</code> option in <em>/etc/rc.conf</em>.</p>
<pre>ifconfig_em1_name="test1"</pre>
<p class="indent">FreeBSD renames interfaces early in the boot process, before setting IP addresses or other values. This means that any further interface configuration must reference the new interface name rather than the old. Full configuration of a renamed interface with IP addresses and aliases would look something like this:</p>
<pre>ifconfig_em1_name="dmz2"<br/>ifconfig_dmz2="inet 203.0.113.2 netmask 255.255.255.0"<br/>ifconfig_dmz2_alias0="inet 203.0.113.3"</pre>
<h4 class="h4" id="lev241"><strong><em>DHCP</em></strong></h4>
<p class="noindent">Very few networks use DHCP for everything, including servers. A DHCP server will set the server’s IP address, netmask, nameservers, and default gateway for you. If your network administrator configures servers via DHCP, you can tell the network card to take its configuration via DHCP with the following:</p>
<pre>ifconfig_em0="DHCP"</pre>
<h4 class="h4" id="lev242"><strong><em>Reboot!</em></strong></h4>
<p class="noindent">Now that you have your network interfaces fully configured, be sure to reboot to test any changes you made to <em>/etc/rc.conf</em>. If FreeBSD finds an error in <em>/etc/rc.conf</em>, especially in network configuration, you’ll have problems accessing the system remotely. It’s much better to learn that you made a typo under controlled conditions as opposed to the middle of your sleeping hours.</p>
<p class="indent">If you feel like living dangerously, you can run <code>service netif restart</code> with the interface name to reconfigure only a single interface.</p>
<pre># <span class="codestrong1">service netif restart em0</span></pre>
<p class="indent">Skip the interface name, and this will restart all interfaces. It’s not a perfect test, but it will catch a bunch of daftness. A reboot is always the best test.</p>
<h3 class="h3" id="lev243"><span epub:type="pagebreak" id="page_150"/><strong>The Domain Name Service</strong></h3>
<p class="noindent">The <em>Domain Name Service</em>, or <em>DNS</em>, is one of those quiet, behind-the-scenes services that doesn’t get half the attention it deserves. Although most users have never heard of it, DNS makes the internet as we know it work. Also called <em>name service</em>, DNS provides a map between hostnames and IP addresses. It also provides the reverse map, of IP addresses to hostnames. Without DNS, web browsers and email programs couldn’t use the nice and convenient hostnames like <em><a href="http://www.michaelwlucas.com">www.michaelwlucas.com</a></em> or <em><a href="http://www.nostarch.com">www.nostarch.com</a></em>; instead, you’d have to browse the web by typing in appalling things like <em>https://2001:19f0:5c00:9041:225:90ff:fee8:1270</em>. This would greatly reduce the internet’s popularity.<sup><a href="footnote.xhtml#ch08fn2" id="ch08fn2a">2</a></sup> To most end users, a DNS failure is an internet failure, end of story. While we won’t discuss building your own authoritative nameserver, we must cover configuring your server to use DNS.</p>
<p class="indent">A host that trawls the internet to dig up DNS mappings is called a <em>nameserver</em>, or <em>DNS server</em>. DNS servers aren’t difficult to run, but most individuals don’t need one. DNS servers are needed only by organizations who run their own servers (and lunatics who have dozens of hosts in their basement, like me). Nameservers come in two varieties, authoritative and recursive.</p>
<p class="indent"><em>Authoritative</em> nameservers provide DNS mappings for the public to find an organization’s nameservers. As the operator of <em><a href="http://michaelwlucas.com">michaelwlucas.com</a></em>, I must provide authoritative nameservers for that domain and let the public query them. These authoritative nameservers answer queries only about the domains I manage. Configuring an authoritative nameserver is beyond the scope of this book.</p>
<p class="indent"><em>Recursive</em> nameservers service client requests. When you try to browse to <em><a href="https://www.michaelwlucas.com">https://www.michaelwlucas.com</a></em>, your local recursive nameserver searches the internet for my authoritative nameserver. Once the recursive nameserver retrieves the hostname-to-IP mapping, it returns that response to your client. This book shows you how to use recursive nameservers and how to enable your own recursive nameserver.</p>
<p class="indent">The system’s <em>resolver</em> is responsible for configuring how the host performs DNS queries and relaying the responses to programs. Configuring the resolver is a vital part of system administration. Even DNS servers need a configured resolver, because the host won’t know it’s a nameserver unless you tell it so. Configuring a resolver requires answering a few questions:</p>
<ul>
<li class="noindent">Where does the server look for DNS information?</li>
<li class="noindent">What local overrides do you want?</li>
<li class="noindent">What are the local domain names?</li>
<li class="noindent">Which nameservers should be queried?</li>
</ul>
<p class="indent">The answers to these questions are configured in <em>/etc/nsswitch.conf</em> and <em>/etc/resolv.conf</em>.</p>
<h4 class="h4" id="lev244"><span epub:type="pagebreak" id="page_151"/><strong><em>Host/IP Information Sources</em></strong></h4>
<p class="noindent">This should be easy. A server gets its host information from a nameserver, right? I just spent a few paragraphs telling you that, didn’t I?</p>
<p class="indent">The real world isn’t quite that simple, though. Perhaps you have a small home network with only three machines. You want each machine to be able to find each other by hostname, but you don’t want to run a local authoritative nameserver. Or maybe you’re on a large corporate network where completing DNS changes takes weeks, and you have a couple test systems that need to talk to each other. FreeBSD, like all Unix-like operating systems, can get information from both DNS and from the plaintext hosts file <em>/etc/hosts</em>.</p>
<p class="indent">When FreeBSD needs to know the address of a host (or the hostname of an address), by default the query goes first to the hosts file and then the configured nameservers. This means that you can locally override nameserver results, which is very useful for hosts behind a NAT or on large corporate networks with odd requirements. In some cases, you might need to reverse this order to query DNS first and the hosts file second. Set this order in <em>/etc/nsswitch.conf</em>.</p>
<div class="sidebar">
<p class="sidebart"><strong>NAME SERVICE SWITCHING</strong></p>
<p class="spara">The file <em>/etc/nsswitch.conf</em> is used not only by the resolver, but also by all other name services. A networked operating system includes many different name services. The TCP/IP ports in <em>/etc/services</em> are a name service as well as network protocol names and numbers. Determining a user’s UID and GID requires a different sort of name lookup (see <a href="ch09.xhtml#ch09">Chapter 9</a>). <em>/etc/nsswitch.conf</em> determines ordering for all of these queries and more. We’re discussing only hostname lookups here, but <a href="ch20.xhtml#ch20">Chapter 20</a> covers more on name service switching.</p>
</div>
<p class="indent">Each entry in <em>/etc/nsswitch.conf</em> is a single line containing the name of the name service, a colon, and a list of information sources. Here’s the hostname service lookup configuration:</p>
<pre>hosts: files dns</pre>
<p class="indent">The resolver queries the information sources in the order listed. If you have an additional information source, such as nscd(8), list it here. The documentation sources for these add-ons should include the name of the service.</p>
<h4 class="h4" id="lev245"><strong><em>Local Names with /etc/hosts</em></strong></h4>
<p class="noindent">The <em>/etc/hosts</em> file matches internet addresses to hostnames. Once upon a time, before the Domain Name Service, the internet had a single hosts file that provided the hostnames and IP addresses of every node on the internet. Sysadmins submitted their host changes to a central maintainer, <span epub:type="pagebreak" id="page_152"/>who issued a revised hosts file every few months. Sysadmins would then download the hosts file and install it on all of their machines. This worked fine when the whole internet had four systems on it, and was even acceptable when there were hundreds of hosts. As soon as the internet began its exponential growth, however, this scheme became totally unmaintainable.</p>
<p class="indent">While the hosts file is very effective, it works only on the machine it’s installed on and must be maintained by the sysadmin. The public DNS has largely supplanted <em>/etc/hosts</em>, but it’s still useful in environments where you don’t want to run local authoritative DNS<sup><a href="footnote.xhtml#ch08fn3" id="ch08fn3a">3</a></sup> or you’re behind an IPv4 NAT device. Using the hosts file makes perfect sense if you have one or two servers at home, or if someone else manages your authoritative nameservers. Once you have enough hosts that the thought of updating the hosts file makes you ill, it’s time to learn to build an authoritative nameserver.</p>
<p class="indent">Each line in <em>/etc/hosts</em> represents one host. The first entry on each line is an IP address, and the second is the fully qualified domain name of the host, such as <em>mail.michaelwlucas.com</em>. Following these two entries, you can list an arbitrary number of aliases for that host.</p>
<p class="indent">For example, a small company might have a single server handling email, serving FTP, web pages, and DNS, as well as performing a variety of other functions. A desktop on that network might have a hosts file entry like this:</p>
<pre>203.0.113.3     mail.mycompany.com    mail ftp www dns</pre>
<p class="indent">With this <em>/etc/hosts</em> entry, the desktop could find the server with either the full domain name or any of the brief aliases listed. This won’t get you to Facebook, however. For that, you need nameservice.</p>
<h4 class="h4" id="lev246"><strong><em>Configuring Nameservice</em></strong></h4>
<p class="noindent">Tell your host how to query nameservers with the file <em>/etc/resolv.conf</em>. You probably want to provide a local domain or a domain search list and then list the nameservers.</p>
<h5 class="h5" id="lev247"><strong>Local Domain and Search List</strong></h5>
<p class="noindent">If your organization has many machines, typing out complete hostnames can quickly get old. If you’re doing maintenance and need to log into every web server, by the time you get to <em>www87.BertJWRegeerHasTooManyBlastedComputers.com</em> you’ll need treatment for impending carpal tunnel syndrome. You can either provide a local domain or a list of domains to search on the first line of <em>/etc/resolv.conf</em>.</p>
<p class="indent">The <em>domain</em> keyword tells the resolver which local domain to check, by default, for all hostnames. All of my test hosts are in the domain <em><a href="http://michaelwlucas.com">michaelwlucas.com</a></em>, so I could set that as the default domain.</p>
<pre>domain  michaelwlucas.com</pre>
<p class="indent"><span epub:type="pagebreak" id="page_153"/>Once you specify a local domain, the resolver will automatically append the domain to any short hostname. If I type <code>ping www</code>, the resolver will append the local domain and send ping(8) to <em><a href="http://www.michaelwlucas.com">www.michaelwlucas.com</a></em>. If I give a complete hostname, such as <em><a href="http://www.bertjwregeer.com">www.bertjwregeer.com</a></em>, though, the resolver doesn’t add the default domain.</p>
<p class="indent">Maybe I have more than one domain I’d like to search. Use the <em>search</em> keyword to give a list of domain names to try, in order. Like <code>domain</code>, <code>search</code> must be the first line of <em>resolv.conf</em>.</p>
<pre>search  michaelwlucas.com bertjwregeer.com mwl.io</pre>
<p class="indent">When you use a brief hostname, such as <em>www</em>, the resolver appends the first domain name in the search list. If there’s no answer, it repeats the query with the second domain name, and then the third. If I run <code>ping</code> <code>petulance</code>, the resolver searches for <em>petulance.michaelwlucas.com</em>, <em>petulance.bertwjregeer.com</em>, and <em>petulance.mwl.io</em>. If no such host exists in any of these domains, the search fails.</p>
<p class="indent">If you have neither domain nor search entries in <em>/etc/resolv.conf</em>, but the machine’s hostname includes a domain name, the resolver uses the local machine’s domain name.</p>
<h5 class="h5" id="lev248"><strong>The Nameserver List</strong></h5>
<p class="noindent">Now that your resolver knows which domains to try, tell it which nameservers to query. List each in <em>/etc/resolv.conf</em> on its own line, in order of preference. Use the keyword <code>nameserver</code> and the DNS server’s IP address. The resolver queries the listed nameservers in order. A complete <em>resolv.conf</em> might look like this:</p>
<pre>domain mwl.io<br/>nameserver 127.0.0.1<br/>nameserver 203.0.113.8<br/>nameserver 192.0.2.8</pre>
<p class="indent">This resolver is ready to rock.</p>
<p class="indent">Note the first nameserver entry, though. The address 127.0.0.1 is always attached to the local host. This machine is running a local recursive nameserver. You can too!</p>
<h4 class="h4" id="lev249"><strong><em>Caching Nameserver</em></strong></h4>
<p class="noindent">Your host needs to perform a DNS lookup every single time it must contact a host. A busy server makes a whole bunch of queries, and by itself, the resolver doesn’t cache any of these responses. A host needs to connect to Google 500 times in a minute? That’s 500 DNS lookups. While setting up an authoritative DNS server requires a specific skill set, configuring a local recursive server requires only one line in <em>/etc/rc.conf</em>. This lets your FreeBSD host cache its DNS responses while reducing network congestion and improving performance.</p>
<p class="indent"><span epub:type="pagebreak" id="page_154"/>Enable the local nameserver with the <em>rc.conf</em> variable <code>local_unbound_enable</code>.</p>
<pre># <span class="codestrong1">sysrc local_unbound_enable=YES</span><br/>local_unbound_enable: NO -&gt; YES</pre>
<p class="indent">You can now start the local nameserver.</p>
<pre># <span class="codestrong1">service local_unbound start</span></pre>
<p class="indent">When you start the service the first time, <code>unbound</code> configures itself. It extracts your system’s nameservers from <em>/etc/resolv.conf</em> and configures itself to forward all queries to those nameservers. The setup process then edits <em>/etc/resolv.conf</em> to point all queries at the local nameserver, running on the IP address 127.0.0.1.</p>
<p class="indent">When your host makes a DNS query, the resolver queries <code>unbound</code>. The local nameserver checks its cache to see whether it has a valid and unexpired answer for the query. If it doesn’t have a cached response, <code>unbound</code> queries your preferred nameservers.</p>
<p class="indent">I recommend enabling <code>local_unbound</code> on every server that isn’t a DNS server.</p>
<h3 class="h3" id="lev250"><strong>Network Activity</strong></h3>
<p class="noindent">Now that you’re on the network, how can you see what’s going on? There are several ways to look at the network, and we’ll consider each in turn. Unlike many commercial operating systems, FreeBSD commands such as netstat(8) and sockstat(1) give you more information about the network than can possibly be healthy.</p>
<h4 class="h4" id="lev251"><strong><em>Current Network Activity</em></strong></h4>
<p class="noindent">The general-purpose network management program netstat(8) displays different information depending on the flags it’s given. One common question people have is, “How much traffic is my system pushing right now?” The netstat(8) <code>-w</code> (for <em>wait</em>) option displays how many packets and bytes your system is processing. The <code>-w</code> flag takes one argument, the number of seconds between updates. Adding the <code>-d</code> (for <em>drop</em>) flag tells netstat(8) to include information about packets that never made it to the system. Here, we ask netstat(8) to update its display every five seconds:</p>
<pre># <span class="codestrong1">netstat -w 5 -d</span><br/>            input        (Total)           output<br/>   packets  errs idrops      bytes    packets  errs      bytes colls drops<br/>       <span class="ent">➊</span>34   <span class="ent">➋</span>0     <span class="ent">➌</span>0    <span class="ent">➍</span>44068        <span class="ent">➎</span>23   <span class="ent">➏</span>0      <span class="ent">➐</span>1518    <span class="ent">➑</span>0   <span class="ent">➒</span>0 <br/>         33    0       0     42610          23    0        1518      0    0<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">Nothing appears to happen when you enter this command, but in a few seconds, the display prints a single line of information. The first three <span epub:type="pagebreak" id="page_155"/>columns describe inbound traffic, while the next three describe outbound traffic. We see the number of packets received since the last update <span class="ent">➊</span>, the number of interface errors for inbound traffic since the last update <span class="ent">➋</span>, and the number of inbound dropped packets <span class="ent">➌</span>. The input information ends with the number of bytes received since the last update <span class="ent">➍</span>. The next three columns show the number of packets the machine transmitted since the last update <span class="ent">➎</span>, the number of errors in transmission since the last update <span class="ent">➏</span>, and how many bytes we sent <span class="ent">➐</span>. We then see the number of network collisions that have occurred since the last update <span class="ent">➑</span>, and the number of packets that have been dropped <span class="ent">➒</span>. For example, in this display, the system received 34 packets <span class="ent">➊</span> since <code>netstat -w 5 -d</code> started running.</p>
<p class="indent">Five seconds later, netstat(8) prints a second line describing the activity since the first line was printed.</p>
<p class="indent">You can make the output as detailed as you want and run it as long as you like. If you’d like to get updates every second, just run <code>netstat -w 1 -d</code>. If once a minute is good enough for you, <code>netstat -w 60 -d</code> will do the trick. I find a five-second interval most suitable when I’m actively watching the network, but you’ll quickly learn what best fits your network and your problems.</p>
<p class="indent">Hit <small>CTRL</small>-C to stop the report once you’ve had enough.</p>
<h4 class="h4" id="lev252"><strong><em>What’s Listening on Which Port?</em></strong></h4>
<p class="noindent">Another popular question is, “Which ports are open and what programs are listening on them?” FreeBSD includes sockstat(1), a friendly tool to answer this question. It shows both active connections and ports available for client use.</p>
<p class="indent">The sockstat(1) program not only lists ports listening to the network, but also any other ports (or <em>sockets</em>) on the system. Use the <code>-4</code> flag to see IPv4 sockets and <code>-6</code> to view IPv6. Here’s trimmed sockstat(1) output from a <em>very</em> small server:</p>
<div class="image"><img src="../images/f0155-01.jpg" alt="image"/></div>
<p class="indent">The first column gives us the username that’s running the program attached to the port in question. The second column is the name of the command. We then have the process ID of the program and the file descriptor number attached to the socket. The next column shows what transport protocol the socket uses—either <code>tcp4</code> for TCP on TCP/IP version 4, or <code>udp4</code> for UDP on TCP/IP version 4. We then list the local IP address and port number, and finally the remote IP address and port number for each existing connection.</p>
<p class="indent"><span epub:type="pagebreak" id="page_156"/>Take a look at our very first entry. I’m running the program sshd <span class="ent">➊</span>. A man page search takes you to sshd(8), the SSH daemon. The main sshd(8) daemon forked a child process on my behalf to handle my connection, so we see multiple instances of sshd(8) with different process IDs. I’m connected to the local IP address 203.0.113.43 <span class="ent">➋</span> on TCP port 22. The remote end of this connection is at the IP address 24.192.127.92 <span class="ent">➌</span> on port 62937. This is an SSH connection from a remote system to the local computer.</p>
<p class="indent">Other available connections include Sendmail <span class="ent">➍</span>, the mail server, running on port 25. Note that this entry doesn’t have any IP address listed as the foreign address. This socket is listening for incoming connections. Our httpd process <span class="ent">➎</span> is listening for incoming connections on port 80.</p>
<p class="indent">The astute among you might notice that this server has two SSH daemons available for incoming connections, one on port 23 <span class="ent">➏</span> and one on port 22 <span class="ent">➐</span>. As <em>/etc/services</em> shows, SSH normally runs on port 22 while port 23 is reserved for telnet. Anyone who telnets to this machine will be connected to an SSH daemon, which won’t work as they expect. The suspicious among you might suspect that this SSH server was set up to waltz around firewalls that only filter traffic based on source and destination ports and not the actual protocol. (I have no comment on such allegations.)</p>
<p class="indent">The last two entries are for a nameserver, named, awaiting incoming connections on port 53. This nameserver is listening for both UDP <span class="ent">➑</span> and TCP <span class="ent">➒</span> connections and is attached to the single IP address 203.0.113.8.</p>
<h4 class="h4" id="lev253"><strong><em>Port Listeners in Detail</em></strong></h4>
<p class="noindent">While sockstat(1) provides a nice high-level view of network service availability, you can get a little more detailed information about individual connections with netstat(8). To view open network connections, use netstat(8)’s <code>-a</code> flag. The <code>-n</code> flag tells netstat(8) not to bother translating IP addresses to hostnames; not only can this translation slow down the output, it can cause ambiguous output. Finally, the <code>-f inet</code> option tells netstat(8) to worry only about IPv4 network connections, while <code>-f inet6</code> addresses IPv6. Here’s matching netstat output from the same machine we just ran sockstat(1) on:</p>
<pre># <span class="codestrong1">netstat -na -f inet</span><br/>Active Internet connections (including servers)<br/>Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)<br/>tcp4       0     48  203.0.113.43.22        24.192.127.92.62937    ESTABLISHED<br/>tcp4       0      0  *.25                   *.*                    LISTEN<br/>tcp4       0      0  *.23                   *.*                    LISTEN<br/>tcp4       0      0  *.80                   *.*                    LISTEN<br/>tcp4       0      0  *.22                   *.*                    LISTEN<br/>tcp4       0      0  203.0.113.8.53         *.*                    LISTEN<br/>udp4       0      0  203.0.113.8.53         *.*  </pre>
<p class="indent">Here, we get no idea of what program is attached to any port. The first entry in each column is the transport protocol used by the socket—mostly TCP, but the last line shows UDP.</p>
<p class="indent"><span epub:type="pagebreak" id="page_157"/>The <code>Recv-Q</code> and <code>Send-Q</code> columns show the number of bytes waiting to be handled by this connection. If you see nonzero <code>Recv-Q</code> numbers for some connection most of the time, you know that the program listening on that port can’t process incoming data quickly enough to keep up with the network stack. Similarly, if the <code>Send-Q</code> column keeps having nonzero entries, you know that either the network or the remote system can’t accept data as quickly as you’re sending it. Occasional queued packets are normal, but if they don’t go away, you might want to investigate why things are slow. You must watch your own system to learn what’s normal.</p>
<p class="indent">The <code>Local Address</code> is, as you might guess, the IP address and network port number on the local system that the network connection is listening on. The network port appears at the end of the entry and is separated from the IP address by a dot. For example, 203.0.113.43.22 is the IP address 203.0.113.43, port 22. If the entry is an asterisk followed by a period and a port number, that means that the system is listening on that port on all available IP addresses. The system is ready to accept a connection on that port.</p>
<p class="indent">The <code>Foreign Address</code> column shows the remote address and port number of any connection.</p>
<p class="indent">Finally, the <code>(state)</code> column shows the status of the TCP handshake. You don’t need to know all of the possible TCP connection states, so long as you learn what’s normal. <code>ESTABLISHED</code> means that a connection exists and that data is probably flowing. <code>LAST_ACK</code>, <code>FIN_WAIT_1</code>, and <code>FIN_WAIT_2</code> mean that the connection is being closed. <code>SYN_RCVD</code>, <code>ACK</code>, and <code>SYN+ACK</code> are all parts of connection creation (the three-way handshake from <a href="ch07.xhtml#ch07">Chapter 7</a>). <code>LISTEN</code> indicates that the port is ready for incoming connections. In the preceding example, one TCP connection is running and four are ready to accept clients. As UDP is stateless, those connections list no state information.</p>
<p class="indent">By reading this output and combining it with information provided by sockstat(1), you can learn exactly which programs are behaving well and which are suffering bottlenecks.</p>
<p class="indent">If you’re not interested in listening sockets but only those with active connections, use netstat(8)’s <code>-b</code> option instead of <code>-a</code>. Running <code>netstat -nb -f inet</code> displays only connections with foreign systems.</p>
<p class="indent">You can also use netstat -T to display TCP retransmits and out-of-order packets on individual connections. Retransmits and misordered packets are symptoms of dropped packets.</p>
<h4 class="h4" id="lev254"><strong><em>Network Capacity in the Kernel</em></strong></h4>
<p class="noindent">The FreeBSD kernel handles network memory by using mbufs. An <em>mbuf</em> is a chunk of kernel memory used for networking. You’ll keep tripping across mentions of mbufs throughout the FreeBSD network stack documentation, so it’s important to have at least a vague idea of them.</p>
<p class="indent">FreeBSD automatically allocates network capacity at boot time based on the amount of physical RAM in the system. We assume that if you have a system with 64GB RAM, you want to use more memory for networking than on a little box with 1GB RAM. View how FreeBSD uses its resources with <code>netstat -s</code> and <code>netstat -m</code>. Let’s look at the shortest one first.</p>
<p class="indent"><span epub:type="pagebreak" id="page_158"/>To get a generic view of kernel memory used for networking, run <code>netstat -m</code>. The output can be divided into two general categories: how much is used and how many requests failed. The following output is trimmed to include only a few examples of these, but they all follow the same general format:</p>
<pre># <span class="codestrong1">netstat -m</span><br/>--<span class="codeitalic1">snip</span>--<br/><span class="ent">➊</span>32/372/404/<span class="ent">➋</span>25600 mbuf clusters in use (current/cache/total/max)<br/>--<span class="codeitalic1">snip</span>--<br/>0/0/0 requests for mbufs <span class="ent">➌</span>denied (mbufs/clusters/mbuf+clusters)<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">Here we see how many mbuf clusters are used <span class="ent">➊</span>. You’d probably guess that these are related to mbufs, and you’d be right. You don’t have to know exactly what mbuf clusters are; the important thing is that you know how many you can allocate <span class="ent">➋</span> and can see that you’re under that limit.</p>
<p class="indent">Similarly, we can see how many different requests for mbufs the kernel has denied <span class="ent">➌</span>. This system hasn’t rejected any requests for mbufs, which means that we aren’t having performance problems due to memory shortages. If your system starts rejecting mbuf requests because it’s out of memory, you’re in trouble. See “Optimizing Network Performance” next.</p>
<p class="indent">While <code>netstat -m</code> produces a dozen lines of output, <code>netstat -s</code> runs for pages and pages. It provides per-protocol performance statistics. Much like <code>netstat -m</code>, you can break up these statistics into categories of how much was done and how many problems you had. Run both of these commands occasionally on your systems and review the results so you know what passes for normal on your servers and can recognize abnormal numbers when you have problems.</p>
<h3 class="h3" id="lev255"><strong>Optimizing Network Performance</strong></h3>
<p class="noindent">Now that you can see what’s going on, how could you improve FreeBSD’s network performance? There’s a simple rule of thumb when considering optimizing: <em>don’t</em>. Network performance is generally limited only by your hardware. Many applications can’t process data as quickly as your network can provide. If you think that you need to optimize your performance, you’re probably looking in the wrong spot. Check <a href="ch21.xhtml#ch21">Chapter 21</a> for hints on investigating performance bottlenecks.</p>
<p class="indent">Generally speaking, network performance should be adjusted only when you experience network problems. This means that you should have output from <code>netstat -m</code> or <code>netstat -s</code> indicating that the kernel is having resource problems. If the kernel starts denying requests for resources or dropping connection requests, look at the hints in this section. If you have issues or if you think you should be getting better performance, look at the hardware first.</p>
<h4 class="h4" id="lev256"><span epub:type="pagebreak" id="page_159"/><strong><em>Optimizing Network Hardware</em></strong></h4>
<p class="noindent">Not all network hardware is created equal. While anyone in IT hears this frequently, FreeBSD’s open nature makes this obvious. For example, here’s a comment from the source code of the rl(4) network card driver:</p>
<pre>The RealTek 8139 PCI NIC redefines the meaning of 'low end.' This is<br/>probably the worst PCI ethernet controller ever made, with the possible<br/>exception of the FEAST chip made by SMC. The 8139 supports bus-master<br/>DMA, but it has a terrible interface that nullifies any performance<br/>gains that bus-master DMA usually offers.</pre>
<p class="indent">This can be summarized as, “This card sucks and blows at the same time. Buy another card.” While this is the most vitriolic comment that I’ve seen in the FreeBSD source code, and this particular hardware is very hard to find today, the drivers for certain other cards say the same thing in a more polite manner. Optimizing network performance with low-end hardware is like putting a high-performance racing transmission in your 1974 Gremlin. Replacing your cheap network card will probably fix your problems. Generally speaking, Intel makes decent network cards; they maintain a FreeBSD driver for their wired network cards and provide support so that the FreeBSD community can help maintain the drivers. (Wireless cards are another story.) Similarly, many companies that build server-grade machines make a point of using server-grade network cards. Some companies provide a FreeBSD driver but do not provide documentation for their hardware. This means that the driver probably works, but you’re entirely dependent upon the vendor’s future fondness of FreeBSD for your updates. Companies that specialize in inexpensive consumer network equipment are not your best choice for high-performance cards—after all, the average home user has no idea how to pick a network card, so they go by price alone. If in doubt, check the FreeBSD-questions mailing list archives for recent network card recommendations.</p>
<p class="indent">Similarly, switch quality varies wildly. The claim that a switch speaks the protocol used in gigabit connections doesn’t mean that you can actually push gigabit speed through every port! I have a 100Mb switch that bottlenecks at 15Mbps and a “gigabit” switch that seems to choke at about 50Mbps. I recommend that you think of a switch’s speed as a protocol or a language: I could claim that I speak Russian, but 30 years after my studies ceased, my speech bottlenecks at about three words a minute. My Russian language interface is of terrible quality. Again, switches designed for home use are not your best choice in a production environment.</p>
<p class="indent">If getting decent hardware doesn’t solve your problems, read on.</p>
<h4 class="h4" id="lev257"><strong><em>Memory Usage</em></strong></h4>
<p class="noindent">FreeBSD uses the amount of memory installed in a system to decide how much memory space to reserve for mbufs. Don’t adjust the number of mbufs you create unless <code>netstat -m</code> tells you that you’re short on mbuf <span epub:type="pagebreak" id="page_160"/>space. If you have an mbuf problem, the real fix is to add memory to your machine. This will make FreeBSD recompute the number of mbufs created at boot and solve your problem. Otherwise, you’ll just shift the problem to a different part of the system or a different application. You might configure gobs of memory for network connections and find that you’ve smothered your database server. If you’re sure you want to proceed, though, here’s how you do it.</p>
<p class="indent">Two sysctl values control mbuf allocation, <code>kern.maxusers</code> and <code>kern.ipc.nmbclusters</code>. The first, <code>kern.maxusers</code>, is a boot-time tunable. Your system automatically determines an appropriate <code>kern.maxusers</code> value from the system hardware at boot time. Adjusting this value is probably the best way to scale your system as a whole. In older versions of FreeBSD, <code>kern.maxusers</code> preallocated memory for networking and refused to release it for other tasks, so increasing <code>kern.maxusers</code> could badly impact other parts of the system. Modern FreeBSD does not preallocate network memory, however, so this is just an upper limit on networking memory. If <code>kern.maxusers</code> is too small, you’ll get warnings in <em>/var/log/messages</em> (see <a href="ch21.xhtml#ch21">Chapter 21</a>).</p>
<p class="indent">The sysctl <code>kern.ipc.nmbclusters</code> specifically controls the number of mbufs allocated by the system for data sitting in socket buffers, waiting to be sent to or read by an application. Although this is runtime tunable, it’s best to set it early at boot by defining it in <em>/etc/sysctl.conf</em> (see <a href="ch06.xhtml#ch06">Chapter 6</a>). If you set this too high, however, you can actually starve the kernel of memory for other tasks and panic the machine.</p>
<pre># <span class="codestrong1">sysctl kern.ipc.nmbclusters</span><br/>kern.ipc.nmbclusters: 25600</pre>
<p class="indent">Mbufs are allocated in units called <em>nmbclusters</em> (sometimes called <em>mbuf clusters</em>). While the size of an mbuf varies, one cluster is about 2KB. You can use simple math to figure out how much RAM your current nmbcluster setting requires and then calculate sensible values for your system and applications. This example machine has 25,600 nmbclusters, which means the kernel can use up to about 50MB RAM for networking purposes. This is negligible on my test laptop’s gig of RAM, but it might be unsuitable on an embedded system.</p>
<p class="indent">To calculate an appropriate number of mbuf clusters, run <code>netstat -m</code> when the server is really busy. The second line of the output will give you the number of mbufs in use and the total number available. If your server at its busiest doesn’t use nearly as many nmbclusters as it has available, you’re barking up the wrong tree—stop futzing with mbufs and replace your hardware already.<sup><a href="footnote.xhtml#ch08fn4" id="ch08fn4a">4</a></sup> For example:</p>
<pre><span class="ent">➊</span>32/<span class="ent">➋</span>372/<span class="ent">➌</span>404/<span class="ent">➍</span>25600 mbuf clusters in use (current/cache/total/max)</pre>
<p class="indent"><span epub:type="pagebreak" id="page_161"/>This system is currently using 32 nmbclusters <span class="ent">➊</span> on this machine and has cached 372 previously used nmbclusters <span class="ent">➋</span>. With this total of 404 clusters <span class="ent">➌</span> in memory at this time, our capacity of 25,600 clusters <span class="ent">➍</span> is 1.5 percent utilized. If this is your real system load, actually reducing the number of nmbclusters might make sense.</p>
<p class="indent">My personal rule of thumb is that a server should have enough mbufs to handle twice its standard high load. If your server uses 25,000 nmbclusters during peak hours, it should have at least 50,000 available to handle those brief irregular peaks.</p>
<div class="sidebar">
<p class="sidebart"><strong>ONCE-IN-A-LIFETIME VS. STANDARD LOAD</strong></p>
<p class="spara">Always distinguish planning for once-in-a-lifetime events from planning for normal load. When the US Government’s Affordable Care Act health insurance registration site went live, millions of users immediately tried to sign up. The first few days, the site was fiendishly slow. After a week, the hardware handled the load without trouble. This was certainly correct capacity planning.</p>
</div>
<h4 class="h4" id="lev258"><strong><em>Maximum Incoming Connections</em></strong></h4>
<p class="noindent">The FreeBSD kernel provides capacity to handle a certain number of incoming new TCP connections. This doesn’t refer to connections that the server previously received and is handling, but rather to clients who are attempting to initiate connections simultaneously. For example, the web pages currently being delivered to clients don’t count, but the incoming requests that have reached the kernel but not the web server process do. It’s a <em>very</em> narrow window, but some sites do overflow it.</p>
<p class="indent">The sysctl <code>kern.ipc.somaxconn</code> dictates how many simultaneous connection attempts the system will try to handle. This defaults to 128, which might not be enough for a highly loaded web server. If you’re running a high-capacity server where you expect more than 128 new requests to be arriving simultaneously, you probably need to increase this sysctl. If users start complaining that they can’t connect, this might be your culprit. Of course, very few applications will accept that many simultaneous new connections; you’ll probably have to tune your app well before you hit this point.</p>
<h4 class="h4" id="lev259"><strong><em>Polling</em></strong></h4>
<p class="noindent">Some gigabit cards can improve their performance with <em>polling</em>. Polling takes the time-honored idea of interrupts and IRQs and boots it out the window, replacing it with regular checks for network activity. In the classic interrupt-driven model, whenever a packet arrives at the network card, the card demands attention from the CPU by generating an interrupt. The CPU stops whatever it’s doing and handles that data. This is grand, <span epub:type="pagebreak" id="page_162"/>and even desirable, when the card doesn’t process a huge amount of traffic. Once a system starts handling large amounts of data, however, the card generates interrupts continuously. Instead of constantly interrupting, the system is more efficient if the kernel grabs network data from the card at regular intervals. This regular checking is called <em>polling</em>. Generally speaking, polling is useful only if you push large amounts of traffic.</p>
<p class="indent">Polling isn’t available as a kernel module as of this writing, since it requires modifications to device drivers. This also means that not all network cards support polling, so be sure to check polling(4) for the complete list. Enable polling by adding <code>DEVICE_POLLING</code> to your kernel configuration. After your reboot, enable polling on a per-interface basis with ifconfig(8).</p>
<pre># <span class="codestrong1">ifconfig em0 polling</span></pre>
<p class="indent">Similarly, disable polling with the argument <code>-polling</code>. The ifconfig(8) command also displays if polling is enabled on an interface. As you can enable and disable polling on the fly, enable polling when your system is under a heavy load and see whether performance improves.</p>
<p class="indent">Polling is used only on older cards. 10GB cards and faster can’t poll.</p>
<h4 class="h4" id="lev260"><strong><em>Other Optimizations</em></strong></h4>
<p class="noindent">FreeBSD has about 200 networking-related sysctls. You have all the tools you need to optimize your system so greatly that it no longer passes any traffic at all. Be very careful when playing with network optimizations. Many settings that seem to fix problems actually fix only one set of problems while introducing a whole new spectrum of issues.</p>
<p class="indent">Some software vendors (i.e., Samba) recommend particular network sysctl changes. Try them cautiously, and watch for unexpected side effects on other programs before accepting them as your new default. TCP/IP is a terribly, terribly complicated protocol, and FreeBSD’s defaults and autotuning reflect years of experience, testing, and sysadmin suffering.</p>
<p class="indent">Also remember that FreeBSD is over two decades old. Mailing list and forum posts from more than a few years ago are probably not useful in network tuning.</p>
<h3 class="h3" id="lev261"><strong>Network Adapter Teaming</strong></h3>
<p class="noindent">As network servers become more and more vital to business, redundancy becomes more important. We have redundant hard drives in a server and redundant bandwidth into a data center, but what about redundant bandwidth into a server? On a smaller scale, as you move around your office, you might move your laptop between wired and wireless connections. It would be really nice not to lose your existing SSH sessions because you unplugged a cable.</p>
<p class="indent"><span epub:type="pagebreak" id="page_163"/>FreeBSD can treat two network cards as a single entity, allowing you to have multiple connections with a single switch. This is commonly called <em>network adapter teaming</em>, <em>bonding</em>, or <em>link aggregation</em>. FreeBSD implements adapter teaming through lagg(4), the link aggregation interface.</p>
<div class="sidebar">
<p class="sidebart"><strong>TRUNKING, TEAMING, AND VLANS</strong></p>
<p class="spara">Some vendors use the word <em>trunk</em> to describe link aggregation. Other vendors use the word <em>trunk</em> to describe one cable with multiple networks (VLANs). FreeBSD avoids this argument by not using the word <em>trunk</em>. If someone starts discussing trunks in your presence, ask them what kind they’re talking about.</p>
</div>
<p class="indent">The kernel module lagg(4) provides a lagg0 virtual interface. You assign physical interfaces to the lagg0 interface, making them part of the aggregated link. While you could use lagg(4) with only one physical interface, aggregating links only makes sense when you have two or more physical interfaces to assign to the aggregated link. The lagg(4) module allows you to implement seamless roaming between wired and wireless networks, failover, and several different aggregation protocols.</p>
<h4 class="h4" id="lev262"><strong><em>Aggregation Protocols</em></strong></h4>
<p class="noindent">Not all network switches support all link aggregation protocols. FreeBSD has basic implementation of some complicated high-end protocols and also includes very basic failover setups. The three I recommend are Fast EtherChannel, LACP, and failover. (There are more schemes, which you can read about in lagg(4).)</p>
<p class="indent">Cisco’s <em>Fast EtherChannel (FEC)</em> is a reliable link aggregation protocol, but it works only on high- to medium-end Cisco switches running particular versions of Cisco’s operating system. If you have an unmanaged switch, Fast EtherChannel is not a viable choice. Fast EtherChannel is complicated to configure (on the switch), so I recommend FEC only when it is already your corporate standard for link aggregation.</p>
<p class="indent">The <em>Link Aggregation Control Protocol (LACP)</em> is an industry standard for link aggregation. The physical interfaces are bonded into a single virtual interface with approximately the same bandwidth as all of the individual links combined. LACP provides excellent fault tolerance, and almost all switches support it. I recommend LACP unless you have a specific requirement for Fast EtherChannel or a switch that chokes when you use LACP.</p>
<p class="indent">If you do have a switch that chokes on LACP, use <em>failover</em>. The failover method sends traffic through one physical interface at a time. If that interface goes down, the connection fails over to the next connection in the pool. While you don’t get aggregated bandwidth, you do get the ability to attach your server to multiple switches for fault tolerance. Use failover to let your laptop roam between wired and wireless connections.</p>
<h4 class="h4" id="lev263"><span epub:type="pagebreak" id="page_164"/><strong><em>Configuring lagg(4)</em></strong></h4>
<p class="noindent">The lagg interface is virtual, meaning there is no physical part of the machine that you could point to and say, “That is interface lagg0.” Before you can configure the interface, you must create it. FreeBSD lets you create interfaces with <code>ifconfig</code> <span class="codeitalic1">interfacename</span><code> create</code>, but you can also do this in <em>/etc/rc.conf</em> with the <code>cloned_interfaces</code> statement.</p>
<p class="indent">Configuring a lagg(4) interface in <em>rc.conf</em> has three steps: creating the interface, bringing up the physical interfaces, and aggregating them. Here, we create a single lagg0 interface out of two Intel gigabit Ethernet cards, em0 and em1.</p>
<pre>cloned_interfaces="lagg0"<br/>ifconfig_em0="up"<br/>ifconfig_em1="up"<br/>ifconfig_lagg0="laggproto lacp laggport em0 laggport em1 inet 203.0.113.1/24"</pre>
<p class="indent">First, you list lagg0 as a cloned interface, so FreeBSD will create this interface at boot. Then, bring interfaces em0 and em1 up, but don’t configure them. Finally, tell the lagg0 interface what aggregation protocol to use (LACP), what physical interfaces belong to it, and its network information. These few lines of configuration give you a high-availability Ethernet connection.</p>
<h3 class="h3" id="lev264"><strong>Virtual LANs</strong></h3>
<p class="noindent">A <em>virtual LAN</em>, or <em>VLAN</em>, lets you get multiple Ethernet segments on a single piece of wire. You’ll sometimes see VLANs called <em>802.1q</em>, <em>tagging</em>, or a combination of these terms. You can use these multiple networks by configuring additional logical interfaces attached to a physical interface. The physical wire can still carry only so much data, however, so all VLANs and the regular network (or <em>native VLAN</em> ) that share the wire use a common pool of bandwidth. If you need a FreeBSD host on multiple Ethernet segments simultaneously, this is one way to do it without running more cable.</p>
<p class="indent">VLAN frames that arrive at your network card are like regular Ethernet frames, tagged with an additional header that says “This is part of VLAN number whatever.” Each VLAN is identified by a tag from 1 to 4096. The native VLAN arrives without any tagging whatsoever. The network often (but not always) calls this <em>VLAN 1</em> internally.</p>
<p class="indent">Configuring a VLAN on your FreeBSD host doesn’t magically connect the host to the VLAN. The network must be configured to send those VLANs to your host. You must work with the network team to get access to the VLANs.</p>
<h4 class="h4" id="lev265"><strong><em>Configuring VLAN Devices</em></strong></h4>
<p class="noindent">Use ifconfig(8) to create VLAN interfaces. You must know the physical interface and the VLAN tag.</p>
<pre># <span class="codestrong1">ifconfig</span> <span class="codestrongitalic1">interface.tag</span><span class="codestrong1"> create vlan</span> <span class="codestrongitalic1">tag</span><span class="codestrong1"> vlandev</span> <span class="codestrongitalic1">interface</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_165"/>Here, I create an interface for VLAN 2 and attach it to the interface em0.</p>
<pre># <span class="codestrong1">ifconfig em0.2 create vlan 2 vlandev em0</span></pre>
<p class="indent">I can now configure interface em0.2 as I would a physical interface.</p>
<pre># <span class="codestrong1">ifconfig em0.2 inet 192.0.2.236/28</span></pre>
<p class="indent">In reality, I’d probably do all of this in a single command.</p>
<pre># <span class="codestrong1">ifconfig em0.2 create vlan 2 vlandev em0 inet 192.0.2.236/28</span></pre>
<p class="indent">That’s everything. Now use ifconfig(8) to display your new interface.</p>
<pre># ifconfig em0.2<br/>em0.2: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500<br/>        options=503&lt;RXCSUM,TXCSUM,TSO4,LRO&gt;<br/>        ether 00:25:90:db:d5:94<br/>        inet 198.22.65.236 netmask 0xffffff00 broadcast 255.255.255.240<br/>        inet6 fe80::225:90ff:fedb:d594%em0.2 prefixlen 64 scopeid 0x6<br/>        nd6 options=21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;<br/>     <span class="ent">➊</span> media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)<br/>        status: active<br/>     <span class="ent">➋</span> vlan: 2 vlanpcp: 0 parent interface: em0<br/>     <span class="ent">➌</span> groups: vlan</pre>
<p class="indent">This looks almost exactly like any other physical interface. The media information <span class="ent">➊</span> comes directly from the underlying interface. You’ll see a label with VLAN information <span class="ent">➋</span> and a note that this is grouped with the other VLAN interfaces <span class="ent">➌</span>.</p>
<h4 class="h4" id="lev266"><strong><em>Configuring VLANs at Boot</em></strong></h4>
<p class="noindent">Configure VLANs at boot with <em>rc.conf</em> variables. First, use a <code>vlan_</code> variable tagged with the interface name to list the VLANs attached to that interface. Here, I tell FreeBSD to enable VLAN 2 and 3 on interface em0 and assign an IP configuration to each.</p>
<pre>vlans_em0="2 3"<br/>ifconfig_em0_2="inet 192.0.2.236/28"<br/>ifconfig_em0_3="inet 198.51.100.50/24"</pre>
<p class="indent">If the underlying interface has no configuration, you need to at least bring it up. The VLAN interfaces won’t work unless the physical interface is on.</p>
<pre>ifconfig_em0="up"</pre>
<p class="indent">You now have virtual LANs at boot. Congratulations!</p>
<p class="indent">Now that you have a working network, let’s get a little more local and look at basic system security.<span epub:type="pagebreak" id="page_166"/></p>
</body></html>