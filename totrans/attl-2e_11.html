<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_293"/><span class="big">11</span><br/>INTERNATIONALIZATION</h2>&#13;
<p class="quote"><em>Like all great travelers I have seen more than I remember, and remember more than I have seen.<br/>—Benjamin Disraeli, Vivian Grey</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">When it comes to making software available in other languages, native English speakers are a little arrogant—but who can blame us? We’ve been taught almost from childhood, through every experience we’ve had in this industry, that English is the only important language—so much so that we don’t even think about it anymore. All computer science–oriented research and academic discussions in communities of any consequence are in English. Even our programming languages have English keywords.</p>&#13;
<p class="indent">Some might counter that this is because most programming languages are invented by English speakers. Not even close! Take for instance Niklaus Wirth of Switzerland, a native German speaker, who invented or had a hand in the invention of several important programming languages, including Euler, Pascal, and Modula. Not popular enough for you? Bjarne Stroustrup, Danish by birth, invented C++. Guido van Rossum, born and raised in the Netherlands, invented Python. Rasmus Lerdorf, who was born in Denmark and later moved to Canada, wrote PHP. Ruby was written by Yukihiro Matsumoto in Japan.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_294"/>My point is, it never occurs to developers—even non-native English speakers—to invent programming languages that use, for example, German keywords. Why not? Probably because no one would use them if they did—not even Germans. New programming languages are often conceived in academic or corporate research environments, and the industry journals, forums, and standardization organizations that facilitate the discussion of the pros and cons of these inventions are written or managed almost exclusively in English—for pragmatic reasons, of course. No one is really saying that English is the best language. Rather, we need a common medium in which to publish, and English, being one of the most widely spoken languages on Earth, just sort of fell into that role.</p>&#13;
<p class="indent">What we miss because of this English-only attitude is that there are entire communities of non-English-speaking software users out there who struggle to understand applications written entirely in English. It’s as uncomfortable for them to use these applications as it is for English-only speakers to look at a web page in Chinese or Russian.</p>&#13;
<p class="indent">Larger companies often provide language packs to allow these communities to use software offerings in their native languages. Some of these commercial native-language offerings are extensive, providing support even for the more difficult Arabic and Asian languages.<sup><a id="ch11fn_1" href="footnote.xhtml#ch11fn1">1</a></sup> However, most smaller commercial and open source software package authors don’t even try because, they say, it’s too expensive, too difficult, or just not important enough to their communities or markets. The first of these arguments <em>may</em> have some merit in the corporate world. Let’s talk about our options for solving these problems and, hence, for expanding our communities.</p>&#13;
<h3 class="h3" id="ch11sec1">Obligatory Disclaimer</h3>&#13;
<p class="noindent">Before I dive into this topic, I’ll state up front that multivolume works could (and should) be written on software internationalization and localization. The topic is simply huge. I will not even come close to covering everything in a couple of chapters. My goal here is to give an introduction to a topic that may seem daunting from the outside. If you’re already familiar with these concepts, you’ll probably be disgusted by the amount of material I don’t cover. Please understand that these chapters are not for you, although you may find some ideas of value in them. Rather, these chapters are for the beginner with little experience in this area.</p>&#13;
<p class="indent">In this chapter, I’ll cover what’s in the C standard and what works with the UTF-8 codeset, and I’ll go a bit beyond. I’ll also cover major portions of the <em>GNU gettext</em> library because integration of <em>gettext</em> into Autotools projects is, in fact, the point of this chapter, but I won’t cover third-party <span epub:type="pagebreak" id="page_295"/>libraries and solutions, though I do mention them where appropriate. Neither will I cover wide-character string manipulation and multibyte-to-wide-character (and vice versa) transformations; there are plenty of resources out there that cover these topics in detail.</p>&#13;
<p class="indent">I just stated that I’ll cover <em>major portions</em> of <em>gettext</em>, meaning that there are parts I’ll leave out because they’re used only under special conditions. Once you have the basics down, you can easily pick up the rest, as needed, from the manual.</p>&#13;
<p class="indent">Speaking of the manual, like many software manuals, the <em>gettext</em> manual is more a reference than a tutorial for beginners. You may have tried to read the <em>gettext</em> manual, intending to become familiar with internationalization and localization though this channel, and walked away thinking, “Either this is a terrible manual or I’m just way out of my depth here.” I know I did at one point. If so, you’d be somewhat correct on both counts. First, it’s pretty apparent that the manual was written by non-English speakers. Is that such a surprise? We’ve already decided that native English speakers don’t really care that much, in general, about this topic. Some of the idioms used in the manual are simply not familiar to English speakers, and some of the phraseology is clearly foreign. But, provenance aside, the manual is also not organized in a manner helpful to someone trying to become familiar with the topic. As I was doing research for this chapter, I found several online tutorials that would be much more helpful than the manual for programmers just trying to figure out where to start.</p>&#13;
<p class="indent">So, let’s begin by first covering some definitions.</p>&#13;
<h3 class="h3" id="ch11sec2">Internationalization (I18n)</h3>&#13;
<p class="noindent"><em>Internationalization</em>, sometimes referred to as <em>i18n</em> in the literature because it’s easier to write,<sup><a id="ch11fn_2" href="footnote.xhtml#ch11fn2">2</a></sup> is the process of preparing a software package to be published in other languages or for other cultures. This preparation includes writing (or refactoring) the software in such a way as to be easily configured to display human-readable text in other languages, or according to other cultural customs and standards. The text I’m referring to here includes strings, numbers, dates and times, currency values, postal addresses, salutations and greetings, paper sizes, measurements, and any other aspect of human communications you can think of that may be done differently in different languages and cultures.</p>&#13;
<p class="indent">Internationalization is specifically <em>not</em> about converting embedded text from one language to another. Rather, it’s about preparing your software so that static and generated text can easily be displayed in a target language or in formats that conform to target cultural norms. People of British culture, for instance, expect to see dates, decimal numbers, and local currency <span epub:type="pagebreak" id="page_296"/>displayed differently than do Americans, even though both speak English natively. So internationalization encompasses not only language support but also general culture support.</p>&#13;
<p class="indent">To be clear, this preparation is not about building a version of your software specifically for Spanish speakers, for example. That topic is reserved for <a href="ch12.xhtml">Chapter 12</a>, where I’ll discuss the concept of <em>localization</em>. Rather, internationalization is about designing or modifying your software such that it <em>can</em> be easily used by Spanish speakers. This means first locating and tagging the strings in your software that should be translated and finding the places in your code where times and dates, currency, numbers, and other locale-specific content is formatted for display. Then you need to make those bits of static text and text-generation code configurable based on a global or specified locale. Of course, it also means configuring your software to be aware of the current system locale and switch into it automatically.</p>&#13;
<p class="indent">There are two areas of software internationalization that are different enough that we should discuss them separately:</p>&#13;
<ul>&#13;
<li class="noindent">Dynamic, runtime-generated text messages</li>&#13;
<li class="noindent">Static text messages that are hardcoded into your application</li>&#13;
</ul>&#13;
<p class="indent">Let’s cover generated messages first, since we often get some help in this area from programming language standard libraries. Most such libraries provide some form of support for locale management, and C is no exception. C++ provides the same sort of functionality in an object-oriented manner.<sup><a id="ch11fn_3" href="footnote.xhtml#ch11fn3">3</a></sup> Once you understand what’s available in C, the C++ version is pretty easy to pick up on your own, so we’ll cover the functionality provided by the C standard library here.</p>&#13;
<p class="indent">I’ll also introduce you to the extended interfaces provided by the POSIX 2008 and X/Open standards because, as we’ll see, the functionality provided by the standard C library, while usable, is a bit weak, and the POSIX and X/Open standard functionality is pretty widely available. Finally, GNU extensions to the C standard can make your application shine in other cultures, as long as you’re willing to break away from the standards a bit.</p>&#13;
<h4 class="h4" id="ch11sec2-1"><em>Instrumenting Source Code for Dynamic Messages</em></h4>&#13;
<p class="noindent">The standard C library offers the <code>setlocale</code> and <code>localeconv</code> functions exposed by the <em>locale.h</em> header file, as shown in the synopsis in <a href="ch11.xhtml#ch11ex1">Listing 11-1</a>.</p>&#13;
<pre>#include &lt;locale.h&gt;&#13;
&#13;
char *setlocale(int <span class="codeitalic1">category</span>, const char *<span class="codeitalic1">locale</span>);&#13;
struct lconv *localeconv(void);</pre>&#13;
<p class="caption" id="ch11ex1"><em>Listing 11-1: A synopsis of the standard C library <code>setlocale</code> and <code>localeconv</code> functions</em></p>&#13;
<p class="indentb"><span epub:type="pagebreak" id="page_297"/>The task of <code>setlocale</code> is to tell the standard C library which locale to use for a given class of library functionality. This function accepts a <em><code>category</code></em>—an enumeration value representing a segment of locale-specific functionality in the library that should be changed from the current locale to a new target <em><code>locale</code></em>. The available standard category enumeration values are as follows.</p>&#13;
<p class="noindent"><strong><code>LC_ALL</code></strong></p>&#13;
<p class="bqparan"><code>LC_ALL</code> represents all categories. Changing the value of this category sets all of the available categories to the specified locale. This is the most common and recommended value to use, unless you have a very specific reason for not setting all categories to the same locale.</p>&#13;
<p class="noindentt"><strong><code>LC_COLLATE</code></strong></p>&#13;
<p class="bqparan">Changing <code>LC_COLLATE</code> affects the way collation functions like <code>strcoll</code> and <code>strxfrm</code> work. Different languages and cultures collate and sort based on different character- or glyph-ordering rules. Setting the collation locale changes the rules used by the library’s text collation functions.</p>&#13;
<p class="noindentt"><strong><code>LC_CTYPE</code></strong></p>&#13;
<p class="bqparan">Changing <code>LC_CTYPE</code> affects the way the character attribute functions defined in <em>ctype.h</em> operate (except for <code>isdigit</code> and <code>isxdigit</code>). It also affects the multibyte and wide-character versions of these functions.</p>&#13;
<p class="noindentt"><strong><code>LC_MONETARY</code></strong></p>&#13;
<p class="bqparan">Changing <code>LC_MONETARY</code> affects the monetary-formatting information returned by <code>localeconv</code> (which we’ll discuss later in this section), as well as the resulting strings returned by the X/Open standard and POSIX extension <code>strfmon</code>.</p>&#13;
<p class="noindentt"><strong><code>LC_NUMERIC</code></strong></p>&#13;
<p class="bqparan">Changing <code>LC_NUMERIC</code> affects the decimal point character in formatted input and output operations performed by functions like <code>printf</code> and <code>scanf</code> and the values related to decimal formatting returned by <code>localeconv</code>, as well as the resulting strings returned by the X/Open standard and POSIX extension <code>strfmon</code>.</p>&#13;
<p class="noindentt"><strong><code>LC_TIME</code></strong></p>&#13;
<p class="bqparan">Changing <code>LC_TIME</code> affects the way time and date strings are formatted by <code>strftime</code>.</p>&#13;
<p class="indentt">The return value of <code>setlocale</code> is a string representing the previous locale, or set of locales if all categories are not set the same. If you’re only interested in determining the current locale, you can pass <code>NULL</code> in the <em><code>locale</code></em> parameter and <code>setlocale</code> will not change anything. If you have set any of the individual categories independently to different locale values, the returned string’s format, when passing <code>LC_ALL</code>, is implementation defined and therefore not quite as useful as it might otherwise be. Nevertheless, most implementations will allow you to pass this string back into <code>setlocale</code>, using <code>LC_ALL</code>, to reset category-specific locales to those of a previously retrieved state.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_298"/>Once the desired locale has been set up, <code>localeconv</code> may be called to return a pointer to a structure containing <em>some</em> of the attributes of the current locale. Why not all of them? Because the designers of this API—otherwise intelligent people—were on pain medication or something when they created it. Seriously, the <em>GNU C Library</em> manual has something to say about it:</p>&#13;
<p class="bqpara">Together with the <code>setlocale</code> function the ISO C people invented the <code>localeconv</code> function. It is a masterpiece of poor design. It is expensive to use, not extensible, and not generally usable as it provides access to only <code>LC_MONETARY</code> and <code>LC_NUMERIC</code> related information. Nevertheless, if it is applicable to a given situation it should be used since it is very portable.<sup><a id="ch11fn_4" href="footnote.xhtml#ch11fn4">4</a></sup></p>&#13;
<p class="indentt">In addition to these criticisms, I’ll add that it’s not thread safe; the contents of the structure are subject to modification (by another thread calling <code>setlocale</code>) while you’re accessing it. Nevertheless, the rules are clear about how it can get modified—only by calls to <code>setlocale</code> with a non-<code>NULL</code> <em><code>locale</code></em> parameter value—so it is usable, but it’s neither elegant nor complete. As the preceding excerpt indicates, you should try to use <code>localeconv</code> if you don’t need additional information for your application, because it’s part of the C standard and is, therefore, extremely portable.</p>&#13;
<p class="indent">To be completely fair, the fields in the structure returned by <code>localeconv</code> are those that presumably require some direct programmer intervention to use correctly, given the functionality provided by the C standard library. For example, the <code>printf</code> family of functions provides no special format specifiers for locale-specific number and currency values, so information related to the <code>LC_NUMERIC</code> and <code>LC_MONETARY</code> categories must be made available to the developer in some fashion in order to make proper use of these categories in a program designed to print numbers and currency amounts in locale-specific formats. It also means, of course, that without third-party libraries or extensions to the C standard, you’ll be writing some tedious text-formatting functions that vary their output based on the rules returned by <code>localeconv</code>.</p>&#13;
<p class="indent">On the other hand, the <code>LC_COLLATE</code>, <code>LC_TIME</code>, and <code>LC_CTYPE</code> categories all directly affect various existing standard library functionality, making it presumably unnecessary for the program author to have direct access to the locale attributes used by these library functions.<sup><a id="ch11fn_5" href="footnote.xhtml#ch11fn5">5</a></sup></p>&#13;
<h5 class="h5"><strong>Setting and Using Locales</strong></h5>&#13;
<p class="noindent">The C and C++ standards require that all implementations of the standard library be initialized in every process with the default “C” locale so that <span epub:type="pagebreak" id="page_299"/>all programs not explicitly selecting a locale will act in a predictable and consistent manner. Therefore, the first thing you must do to internationalize your software is to change the locale. The easiest and most consistent way to change the locale within your application is to call <code>setlocale</code> with a <em><code>category</code></em> value of <code>LC_ALL</code> somewhere near the start of the program. But what string should we pass as a <em><code>locale</code></em> argument? Well, that’s the beauty of this function—you don’t need to pass any specific locale string at all. Passing an empty string disables the <em>default locale</em>, allowing the library to select the <em>environment locale</em> that’s in effect on the host. This allows your users to determine how your program will display times and dates, decimal numbers, and currency values and how collation and character set management will work.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex2">Listing 11-2</a> shows the code for a program that configures the standard C library to use the host environment locale and then displays the standard locale attributes available from <code>localeconv</code> to the console.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The example programs in this chapter can be found in the online GitHub repository named</em> NSP-Autotools/gettext, <em>found at</em> <a href="https://github.com/NSP-Autotools/gettext/">https://github.com/NSP-Autotools/gettext/</a>. <em>The small utility programs presented in this chapter are found in the</em> small-utils <em>directory in that repository, and a makefile is provided that will build them all by default. Use a command like <em><code>make lc</code></em>, for instance, to build just the <em><code>lc</code></em> program presented in <a href="ch11.xhtml#ch11ex2">Listing 11-2</a>.</em></p>&#13;
</div>&#13;
<p class="margin">Git tag 11.0</p>&#13;
<pre>#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;stdbool.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;limits.h&gt;&#13;
#include &lt;locale.h&gt;&#13;
&#13;
static void print_grouping(const char *prefix, const char *grouping)&#13;
{&#13;
    const char *cg;&#13;
    printf("%s", prefix);&#13;
    for (cg = grouping; *cg &amp;&amp; *cg != CHAR_MAX; cg++)&#13;
        printf("%c %d", cg == grouping ? ':' : ',', *cg);&#13;
    printf("%s\n", *cg == 0 ? " (repeated)" : "");&#13;
}&#13;
&#13;
static void print_monetary(bool p_cs_precedes, bool p_sep_by_space,&#13;
        bool n_cs_precedes, bool n_sep_by_space,&#13;
        int p_sign_posn, int n_sign_posn)&#13;
{&#13;
    static const char * const sp_str[] =&#13;
    {&#13;
        "surround symbol and quantity with parentheses",&#13;
        "before quantity and symbol",&#13;
        "after quantity and symbol",&#13;
        "right before symbol",&#13;
        "right after symbol"&#13;
    };&#13;
<span epub:type="pagebreak" id="page_300"/>    printf("     Symbol comes %s a positive (or zero) amount\n",&#13;
             p_cs_precedes ? "BEFORE" : "AFTER");&#13;
    printf("     Symbol %s separated from a positive (or zero) amount by a space\n",&#13;
             p_sep_by_space ? "IS" : "is NOT");&#13;
    printf("     Symbol comes %s a negative amount\n",&#13;
             n_cs_precedes ? "BEFORE" : "AFTER");&#13;
    printf("     Symbol %s separated from a negative amount by a space\n",&#13;
             n_sep_by_space ? "IS" : "is NOT");&#13;
    printf("     Positive (or zero) amount sign position: %s\n",&#13;
             sp_str[p_sign_posn == CHAR_MAX? 4: p_sign_posn]);&#13;
    printf("     Negative amount sign position: %s\n",&#13;
             sp_str[n_sign_posn == CHAR_MAX? 4: n_sign_posn]);&#13;
}&#13;
&#13;
int main(void)&#13;
{&#13;
    struct lconv *lc;&#13;
    char *isym;&#13;
&#13;
    setlocale(LC_ALL, "");    // enable environment locale&#13;
    lc = localeconv();        // obtain locale attributes&#13;
&#13;
    printf("Numeric:\n");&#13;
    printf("  Decimal point: [%s]\n", lc-&gt;decimal_point);&#13;
    printf("  Thousands separator: [%s]\n", lc-&gt;thousands_sep);&#13;
&#13;
    print_grouping("    Grouping", lc-&gt;grouping);&#13;
&#13;
    printf("\nMonetary:\n");&#13;
    printf("  Decimal point: [%s]\n", lc-&gt;mon_decimal_point);&#13;
    printf("  Thousands separator: [%s]\n", lc-&gt;mon_thousands_sep);&#13;
&#13;
    print_grouping("    Grouping", lc-&gt;mon_grouping);&#13;
&#13;
    printf("    Positive amount sign: [%s]\n", lc-&gt;positive_sign);&#13;
    printf("    Negative amount sign: [%s]\n", lc-&gt;negative_sign);&#13;
    printf("    Local:\n");&#13;
    printf("      Symbol: [%s]\n", lc-&gt;currency_symbol);&#13;
    printf("      Fractional digits: %d\n", (int)lc-&gt;frac_digits);&#13;
&#13;
    print_monetary(lc-&gt;p_cs_precedes, lc-&gt;p_sep_by_space,&#13;
            lc-&gt;n_cs_precedes, lc-&gt;n_sep_by_space,&#13;
            lc-&gt;p_sign_posn, lc-&gt;n_sign_posn);&#13;
&#13;
    printf("  International:\n");&#13;
    isym = lc-&gt;int_curr_symbol;&#13;
    printf("    Symbol (ISO 4217): [%3.3s], separator: [%s]\n",&#13;
            isym, strlen(isym) &gt; 3 ? isym + 3 : "");&#13;
    printf("    Fractional digits: %d\n", (int)lc-&gt;int_frac_digits);&#13;
&#13;
#ifdef __USE_ISOC99&#13;
    print_monetary(lc-&gt;int_p_cs_precedes, lc-&gt;int_p_sep_by_space,&#13;
            lc-&gt;int_n_cs_precedes, lc-&gt;int_n_sep_by_space,&#13;
            lc-&gt;int_p_sign_posn, lc-&gt;int_n_sign_posn);&#13;
<span epub:type="pagebreak" id="page_301"/>#endif&#13;
    return 0;&#13;
}</pre>&#13;
<p class="caption" id="ch11ex2"><em>Listing 11-2:</em> lc.c: <em>A program to display all locale attributes retrieved from <code>localeconv</code></em></p>&#13;
<p class="indent">The <code>struct lconv</code> structure contains both <code>char *</code> and <code>char</code> fields. The <code>char *</code> fields mostly refer to strings whose values are determined according to the current locale. Some of the <code>char</code> fields are intended to be taken as Boolean values, while the rest are designed to be read as small integer values. The code shown in <a href="ch11.xhtml#ch11ex2">Listing 11-2</a> should indicate pretty clearly which are Boolean and which are small integers. The documentation for your compiler’s standard library should also make it clear.</p>&#13;
<p class="indent">The only weird ones are the <code>grouping</code> and <code>mon_grouping</code> fields, which indicate how digits in numbers and currency values (respectively) should be grouped, with groups separated by the corresponding <em>thousands separator</em> string. The <code>grouping</code> and <code>mon_grouping</code> fields are <code>char *</code> fields designed to be read not as strings but as arrays of small integers. They’re terminated with either a zero or the value <code>CHAR_MAX</code> (defined in <em>limits.h</em>). If they’re terminated with zero, the final grouping value is repeated forever; otherwise, the final grouping includes the remaining digits in the value.</p>&#13;
<p class="indent">Finally, note the call to the internal <code>print_monetary</code> routine that’s wrapped in a check for <code>__USE_ISOC99</code> (near the bottom of the listing). The international forms of these currency attributes were added with the C99 standard. Everyone should be up to C99 by now, so this is not generally an issue. I added the conditional compilation check because, for this utility program, it’s possible and appropriate. For an application trying to use these fields, you should probably just insist that C99 be required to build the application.</p>&#13;
<p class="indent">Building and executing this program from a US English Linux system generates the following console output:</p>&#13;
<pre>$ <span class="codestrong1">gcc lc.c -o lc</span>&#13;
$ <span class="codestrong1">./lc</span>&#13;
Numeric:&#13;
  Decimal point: [.]&#13;
  Thousands separator: [,]&#13;
  Grouping: 3, 3 (repeated)&#13;
&#13;
Monetary:&#13;
  Decimal point: [.]&#13;
  Thousands separator: [,]&#13;
  Grouping: 3, 3 (repeated)&#13;
  Positive amount sign: []&#13;
  Negative amount sign: [-]&#13;
  Local:&#13;
    Symbol: [$]&#13;
    Fractional digits: 2&#13;
    Symbol comes BEFORE a positive (or zero) amount&#13;
    Symbol is NOT separated from a positive (or zero) amount by a space&#13;
    Symbol comes BEFORE a negative amount&#13;
<span epub:type="pagebreak" id="page_302"/>    Symbol is NOT separated from a negative amount by a space&#13;
    Positive (or zero) amount sign position: before quantity and symbol&#13;
    Negative amount sign position: before quantity and symbol&#13;
  International:&#13;
    Symbol (ISO 4217): [USD], separator: [ ]&#13;
    Fractional digits: 2&#13;
    Symbol comes BEFORE a positive (or zero) amount&#13;
    Symbol IS separated from a positive amount by a space&#13;
    Symbol comes BEFORE a negative amount&#13;
    Symbol IS separated from a negative amount by a space&#13;
    Positive (or zero) amount sign position: before quantity and symbol&#13;
    Negative amount sign position: before quantity and symbol&#13;
$</pre>&#13;
<p class="indent">To change the environment locale, set the <code>LC_ALL</code> environment variable to the name of the locale you want to use. The values you can use are the locales that are generated and installed on your system.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can also set individual locale categories using environment variables with the same names as the category names. For example, to change the locale to Spanish (in Spain), but only for the <em><code>LC_TIME</code></em> category, you could set the <em><code>LC_TIME</code></em> environment variable to <em><code>es_ES.utf8</code></em>. This works for all the standard categories defined earlier.<sup><a id="ch11fn_6" href="footnote.xhtml#ch11fn6">6</a></sup></em></p>&#13;
</div>&#13;
<p class="indent">To find out which locales are available, run the <code>locale</code> utility with the <code>-a</code> option, in this manner:</p>&#13;
<pre>$ <span class="codestrong1">locale -a</span>&#13;
C&#13;
C.UTF-8&#13;
en_AG&#13;
en_AG.utf8&#13;
en_AU.utf8&#13;
en_BW.utf8&#13;
en_CA.utf8&#13;
en_DK.utf8&#13;
en_GB.utf8&#13;
en_HK.utf8&#13;
en_US.utf8&#13;
en_ZA.utf8&#13;
en_ZM&#13;
en_ZM.utf8&#13;
en_ZW.utf8&#13;
ja_JP.utf8&#13;
POSIX&#13;
sv_SE.utf8&#13;
$</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_303"/><em>My example console listings are performed on a Debian-based system. If you’re using a Fedora-based distribution, for example, you should expect to see different results, as Fedora has significantly different default functionality with respect to installed language packs and how the <em><code>locale</code></em> utility works. I’ll discuss Red Hat specifics later on in the chapter where it really matters.</em></p>&#13;
</div>&#13;
<p class="indent">Normally, a US English installation of Linux will have several locales configured that begin with the string <code>en</code>. I’ve generated Swedish (<code>sv_SE.utf8</code>) and Japanese (<code>ja_JP.utf8</code>) locales on my Debian-based system, as well, in order to show examples of output when the environment is configured for non-English languages and cultures.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I also use the French (<em><code>fr_FR.utf8</code></em>) locale later in the chapter. You may wish to pre-build or preinstall all of these locales using whatever mechanism is provided by your distribution to make it easier to follow along with my examples on your system. Of course, if you are not a native English speaker, you’re probably already using a different locale by default. In this case, you might also want to build or install the <em><code>en_US.utf8</code></em> locale—though, not surprisingly, this locale generally comes preinstalled even on systems not built or sold in the United States.</em></p>&#13;
</div>&#13;
<p class="indent">You may have noticed the <code>C</code>, <code>C.UTF-8</code>, and <code>POSIX</code> locales in the preceding list. The <code>C</code> locale, as already mentioned, is the default locale for programs that do not set the locale explicitly. The <code>POSIX</code> locale is currently defined as an alias for the <code>C</code> locale.</p>&#13;
<h5 class="h5">Generating and Installing Locales</h5>&#13;
<p class="noindent">The process of generating and installing a locale is pretty specific to a distribution, but there are a few common implementations. On a Debian- or Ubuntu-based system, for instance, you can look at the <em>/usr/share/i18n/SUPPORTED</em> file to see which locales can be generated and installed from sources on your system:</p>&#13;
<pre>$ <span class="codestrong1">cat /usr/share/i18n/SUPPORTED</span>&#13;
aa_DJ.UTF-8 UTF-8&#13;
aa_DJ ISO-8859-1&#13;
aa_ER UTF-8&#13;
<span class="codeitalic1">--snip--</span>&#13;
zh_TW BIG5&#13;
zu_ZA.UTF-8 UTF-8&#13;
zu_ZA ISO-8859-1&#13;
$</pre>&#13;
<p class="indent">There are 480 locale names in this file on my Linux Mint system. The general format of a locale name, as defined by the X/Open standard, is as follows:</p>&#13;
<pre><span class="codeitalic1">language</span>[_<span class="codeitalic1">territory</span>][.<span class="codeitalic1">codeset</span>][@<span class="codeitalic1">modifier</span>]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_304"/>There are up to four parts of a locale name. The first part, <em><code>language</code></em>, is required. The remaining parts, <em><code>territory</code></em>, <em><code>codeset</code></em>, and <em><code>modifier</code></em>, are optional. For example, the locale name for US English using the UTF-8 character set is <code>en_US.utf8</code>. The <em><code>language</code></em> is represented in the form of a two-letter ISO 639 language code.<sup><a id="ch11fn_7" href="footnote.xhtml#ch11fn7">7</a></sup> For instance, <code>en</code> refers to the English language, which could be American, Canadian, British, or some other dialect of English.</p>&#13;
<p class="indent">The <em><code>territory</code></em> portion indicates the location of the language and takes the form of a two-letter ISO 3166 country code.<sup><a id="ch11fn_8" href="footnote.xhtml#ch11fn8">8</a></sup> For example, <code>US</code> is for the United States, <code>CA</code> is for Canada, and <code>GB</code> is for Great Britain.</p>&#13;
<p class="indent">The portion after the dot (<code>.</code>) indicates the <em><code>codeset</code></em> or character encoding, formatted as a standard ISO character-encoding name like UTF-8 or ISO-8859-1.<sup><a id="ch11fn_9" href="footnote.xhtml#ch11fn9">9</a></sup> The most common character encoding is UTF-8 (represented in the locale name as <code>utf8</code>) since it can represent all characters in the world. It doesn’t represent all of them efficiently, however; some languages don’t use <code>utf8</code> because they require several bytes per character in this encoding.</p>&#13;
<p class="indent">The <em><code>modifier</code></em> portion is not often used.<sup><a id="ch11fn_10" href="footnote.xhtml#ch11fn10">10</a></sup> One possible use is to generate a locale that differs only in case sensitivity, or in some other attribute that is not a normal locale attribute. For instance, when setting <code>LC_MESSAGES=en@</code><code>boldquot</code>, you get an English message set that differs from the normal English message set only in that quoted text is bolded. Another historically common case is where the <code>en_IE@eu</code><code>ro</code> locale is distinguished only by a difference in the currency symbol used. Suffice it to say that the differences applied by using a locale with a particular modifier are designed for very special use cases.</p>&#13;
<p class="indent">To generate and install a particular locale on a Debian- or Ubuntu-based system, you can add a file to the <em>/var/lib/locales/supported.d</em> directory containing the line from <em>SUPPORTED</em> representing the locale you want to add. The name of the file added to the <em>supported.d</em> directory is not particularly important, although I advise not using filenames that are too far from something reasonably similar to what you find already in this directory structure. It’s only important that a file exists in that directory and that it contains the exact contents of the desired line from <em>SUPPORTED</em>.</p>&#13;
<p class="indent">For instance, to add <code>sv_SE.utf8</code>, I’d find the line in <em>SUPPORTED</em> that represents this language, add a file to <em>supported.d</em> containing this line, and then run the <code>locale-gen</code> program, in this manner:</p>&#13;
<pre>$ <span class="codestrong1">cat /usr/share/i18n/SUPPORTED | grep sv_SE</span>&#13;
sv_SE.UTF-8 UTF-8&#13;
<span epub:type="pagebreak" id="page_305"/><span class="ash">sv_SE ISO-8859-1</span>&#13;
<span class="ash">sv_SE.ISO-8859-15 ISO-8859-15</span>&#13;
$&#13;
$ <span class="codestrong1">echo "sv_SE.UTF-8 UTF-8" | sudo tee -a /var/lib/locales/supported.d/sv</span>&#13;
[sudo] password for jcalcote: *****&#13;
sv_SE.UTF-8 UTF-8&#13;
$ <span class="codestrong1">sudo locale-gen</span>&#13;
Generating locales (this might take a while)...&#13;
  <span class="ash">en_AG.UTF-8... done</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
  <span class="ash">en_ZW.UTF-8... done</span>&#13;
  <span class="ash">a_JP.UTF-8... done</span>&#13;
  sv_SE.UTF-8... done&#13;
Generation complete.&#13;
$&#13;
$ <span class="codestrong1">locale -a</span>&#13;
<span class="ash">C</span>&#13;
<span class="ash">C.UTF-8</span>&#13;
<span class="ash">en_AG</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">ja_JP.utf8</span>&#13;
<span class="ash">POSIX</span>&#13;
sv_SE.utf8&#13;
$</pre>&#13;
<p class="indent">Each line in <em>SUPPORTED</em> contains a locale database entry name, followed by a codeset name. For Swedish, the entry we’re interested in is <code>sv_SE.UTF-8</code>, with the <code>UTF-8</code> codeset. I chose to add a file called <em>sv</em> to <em>/var/lib /locales/supported.d</em>. You may add as many lines as you want to the file; each line will be processed as a separate locale. Because the files in <em>/var/lib/locale</em> are owned by root, you’ll need to have root-level permissions to create or write to them. I used a common trick involving the <code>tee</code> and <code>echo</code> commands to add the line I wanted to <em>supported.d/sv</em> as root.<sup><a id="ch11fn_11" href="footnote.xhtml#ch11fn11">11</a></sup> You could also just use a text editor started with <code>sudo</code>, of course.</p>&#13;
<p class="indent">To generate a locale on a Red Hat– or CentOS-based system, you can use the <code>localedef</code> utility in this manner:</p>&#13;
<pre>$ <span class="codestrong1">localedef --list-archive</span>&#13;
<span class="ash">aa_DJ</span>&#13;
<span class="ash">aa_DJ.iso88591</span>&#13;
<span class="ash">aa_DJ.utf8</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
sv_SE.utf8&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">zu_ZA</span>&#13;
<span class="ash">zu_ZA.iso88591</span>&#13;
<span class="ash">zu_ZA.utf8</span>&#13;
$&#13;
$ <span class="codestrong1">sudo localedef -i sv_SE -f UTF-8 sv_SE.UTF-8</span>&#13;
$&#13;
<span epub:type="pagebreak" id="page_306"/>$ <span class="codestrong1">locale -a | grep sv_SE.utf8</span>&#13;
sv_SE.utf8&#13;
$</pre>&#13;
<p class="indent">The <code>-i</code> option on the <code>localedef</code> command line signifies the input file, which is taken from the output of the <code>localedef --list-archive</code> command. The <code>-f</code> option indicates the codeset to use.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I’ve found that recent Red Hat (and therefore CentOS) systems generally come preinstalled with many locales. You may find, upon using <em><code>locale -a</code></em>, that you do not need to generate any locales. Anything that shows up in <em><code>locale -a</code></em> is immediately usable as a locale in the <em><code>LANG</code></em> and <em><code>LC_*</code></em> environment variables. Fedora systems, on the other hand, require the installation of language-specific langpacks, even if the locale shows up in the list displayed by <em><code>locale -a</code></em>. Swedish, for instance, requires the installation of glibc-langpack-sv. Additionally, the language sources do not seem to be installed on Fedora. Therefore, the <em><code>localedef</code></em> command will not work on that platform, but installation of the langpack will provide a precompiled version of the locale.</em></p>&#13;
</div>&#13;
<p class="indent">Now that we have a Swedish locale available to us, let’s see what’s displayed when we execute the <code>lc</code> program built from the code in <a href="ch11.xhtml#ch11ex2">Listing 11-2</a> when using that locale:</p>&#13;
<pre>$ <span class="codestrong1">LC_ALL=sv_SE.utf8 ./lc</span>&#13;
Numeric:&#13;
  Decimal point: [,]&#13;
  Thousands separator: [ ]&#13;
  Grouping: 3, 3 (repeated)&#13;
&#13;
Monetary:&#13;
  Decimal point: [,]&#13;
  Thousands separator: [ ]&#13;
  Grouping: 3, 3 (repeated)&#13;
  Positive amount sign: []&#13;
  Negative amount sign: [-]&#13;
  Local:&#13;
    Symbol: [kr]&#13;
    Fractional digits: 2&#13;
    Symbol comes AFTER a positive (or zero) amount&#13;
    Symbol IS separated from positive (or zero) amount by a space&#13;
    Symbol comes AFTER a negative value&#13;
    Symbol IS separated from negative value by a space&#13;
    Positive (or zero) amount sign position: before quantity and symbol&#13;
    Negative amount sign position: before quantity and symbol&#13;
  International:&#13;
    Symbol (ISO 4217): [SEK], separator: [ ]&#13;
    Fractional digits: 2&#13;
    Symbol comes AFTER a positive value&#13;
    Symbol IS separated from positive value by a space&#13;
    Symbol comes AFTER a negative value&#13;
    Symbol IS separated from negative value by a space&#13;
    Positive (or zero) amount sign position: before quantity and symbol&#13;
    Negative amount sign position: before quantity and symbol&#13;
$</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_307"/>Unfortunately, as I mentioned earlier, <code>localeconv</code> only returns information on the numeric (<code>LC_NUMERIC</code>) and monetary (<code>LC_MONETARY</code>) categories, which isn’t quite as bad as it sounds because the remaining ones are handled nearly automatically for you by the library. Regardless, there are other options for accessing the complete set of locale attributes, which we’ll discuss later in this chapter.</p>&#13;
<h5 class="h5">Formatting Time and Date for Display</h5>&#13;
<p class="noindent">The standard C library quietly handles time and date behind the scenes, depending on which format specifiers you use in the format string passed to <code>strftime</code>. Here’s the prototype for <code>strftime</code>:</p>&#13;
<pre>#include &lt;time.h&gt;&#13;
&#13;
size_t strftime(char *<span class="codeitalic1">s</span>, size_t <span class="codeitalic1">max</span>, const char *<span class="codeitalic1">format</span>, const struct tm *<span class="codeitalic1">tm</span>);</pre>&#13;
<p class="indent">Briefly, the <code>strftime</code> function places up to <em><code>max</code></em> bytes in the buffer pointed to by <em><code>s</code></em>. The content is determined by the text and format specifiers in <em><code>format</code></em>. Only a single time value format can be specified in <em><code>format</code></em>, and its value is obtained from <em><code>tm</code></em>. Since this is a standard library function, you can refer to any standard C library manual for details on the way format specifiers work in this function.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex3">Listing 11-3</a> provides the source code for a small program that prints the current time and date in a general format supported in some form by all languages and territories.<sup><a id="ch11fn_12" href="footnote.xhtml#ch11fn12">12</a></sup></p>&#13;
<pre>#include &lt;stdio.h&gt;&#13;
#include &lt;locale.h&gt;&#13;
#include &lt;time.h&gt;&#13;
&#13;
int main(void)&#13;
{&#13;
    time_t t = time(0);&#13;
    char buf[128];&#13;
&#13;
    setlocale(LC_ALL, "");  // enable environmental locale&#13;
&#13;
    strftime(buf, sizeof buf, "%c", gmtime(&amp;t));&#13;
    printf("Calendar time: %s\n", buf);&#13;
    return 0;&#13;
}</pre>&#13;
<p class="caption" id="ch11ex3"><em>Listing 11-3:</em> td.c: <em>A small program to print the calendar date and time in the environment locale</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_308"/>Building and executing this program displays something like the following output on the console; your times and dates will very likely not match mine:</p>&#13;
<pre>$ <span class="codestrong1">gcc td.c -o td</span>&#13;
$ <span class="codestrong1">LC_ALL=C ./td</span>&#13;
Calendar time: Tue Jul    2 03:57:56 2019&#13;
$ <span class="codestrong1">./td</span>&#13;
Calendar time: Tue 02 Jul 2019 03:57:58 AM GMT&#13;
$ <span class="codestrong1">LC_ALL=sv_SE.utf8 ./td</span>&#13;
Calendar time: tis    2 jul 2019 03:57:59&#13;
$</pre>&#13;
<p class="indent">I set <code>LC_ALL=C</code> on the first execution to show how you can execute your localized programs using the default C locale. This can be a handy debugging aid for testing your internationalized software.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The C locale is not the “American” locale. Rather, it’s referred to as the minimal locale. If you execute the <em><code>lc</code></em> program with <em><code>LC_ALL=C</code></em>, you’ll find that many of the options are blank. The standard library expects and handles such blank options in an appropriate manner.</em></p>&#13;
</div>&#13;
<p class="indent">Compare the English and Swedish outputs. The day and month names are in the locale language. For July, the month name happens to be the same in English and Swedish. However, notice the case difference in both day names and month names. In English, the names are capitalized, while in Swedish, they are not. Another difference is the 12-hour AM/PM time format in English and the 24-hour time format in Swedish. Swedish and C omit the leading zero on the day, whereas the US locale does not. Finally, the US time is followed by the Greenwich mean time zone name, <code>GMT</code>. There is only one time zone in Sweden—Central European Time, <code>CET</code>—and this fact is reflected in the simplicity of Sweden’s standard general time and date format.</p>&#13;
<p class="indent">All of these differences are defined by the environment locale, but a quick glance at the code in <a href="ch11.xhtml#ch11ex3">Listing 11-3</a> shows that I’m merely using the <code>%c</code> format specifier in the call to <code>strftime</code> in all cases. The effective locale is causing this format specifier to output general time and date information in a format specific to the locale.</p>&#13;
<p class="indent">Not all of the format specifiers accepted by <code>strftime</code> are as helpful, however. For example, while using a format string like <code>"%X %D"</code> may seem like a good approach, it will not yield correct results in all locales. The <code>%X</code> specifier formats the time in a locale-specific manner, but <code>%D</code> formats the date in a very US-English way. Additionally, full time-date strings are formatted in different locales with the time and date portions in different orders. Later in the chapter, I’ll show you how to work around these issues with <code>nl_langinfo</code>.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_309"/>Collation and Character Classes</h5>&#13;
<p class="noindent">Now let’s consider the less obvious categories—those whose information is not returned in <code>struct lconv</code>: <code>LC_COLLATE</code> and <code>LC_CTYPE</code>.</p>&#13;
<p class="indent"><code>LC_COLLATE</code> affects the way the functions <code>strcoll</code> and <code>strxfrm</code> work. It’s more difficult for an English speaker to comprehend these functions’ inner workings because, in the English language, locale-specific comparisons of characters just happen to collate in the same order as their lexicographical orderings in the <em>ASCII</em> table.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The original</em> American Standard Code for Information Interchange (ASCII) <em>was invented in 1963 by the</em> American Standards Association (ASA). <em>At first, it included only US English capital letters and numbers. In 1967, it was amended to include control characters and lowercase US English letters. Since the standard limited code length to 7 bits, it included only 128 characters, using the codes 0 through 127. This 7-bit limitation was imposed because the eighth bit in each byte was commonly used for error correction during data transmission. In 1981, IBM incorporated the ASCII code into the lower half of an 8-bit, 256-character code it named</em> code <a href="ch16.xhtml#page_437">page 437</a> <em>and incorporated this code into the firmware of its IBM PC line of personal computers. In this chapter, when I mention the</em> ASCII table, <em>I’m actually referring to</em> code <a href="ch16.xhtml#page_437">page 437</a>. <em>Technically, ASCII is still limited to 128 characters.</em></p>&#13;
</div>&#13;
<p class="indent">This is not the case in many other languages. For instance, in English and Spanish, the accented vowels sort properly immediately after their unaccented counterparts, while in Japanese, neither vowels nor accented vowels exist in the alphabet, so they sort according to their ordinal values in the ASCII table. Since all the accented vowels are in the upper half of the ASCII table and all non-accented vowels are in the lower half, it should be clear that the sort order of a list of Spanish words will be different when using an English or Spanish language locale than it will for any locales based on languages that don’t have Latin characters in their alphabet.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex4">Listing 11-4</a> contains a short program that uses the C <code>qsort</code> function to sort a list of Spanish words using different comparison routines.</p>&#13;
<pre>#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;locale.h&gt;&#13;
#include &lt;string.h&gt;&#13;
&#13;
#define ECOUNT(x) (sizeof(x)/sizeof(*(x)))&#13;
&#13;
int lex_count = 0;&#13;
int loc_count = 0;&#13;
&#13;
static int compare_lex(const void *a, const void *b)&#13;
{&#13;
    lex_count++;&#13;
    return strcmp(*(const char **)a, *(const char **)b);&#13;
}&#13;
<span epub:type="pagebreak" id="page_310"/>static int compare_loc(const void *a, const void *b)&#13;
{&#13;
    loc_count++;&#13;
    return strcoll(*(const char **)a, *(const char **)b);&#13;
}&#13;
&#13;
static void print_list(const char * const *list, size_t sz)&#13;
{&#13;
    for (int i = 0; i &lt; sz; i++)&#13;
        printf("%s%s", i ? ", " : "", list[i]);&#13;
    printf("\n");&#13;
}&#13;
&#13;
int main()&#13;
{&#13;
    const char *words[] = {"rana", "rastrillo", "radio", "rápido", "ráfaga"};&#13;
&#13;
    setlocale(LC_ALL, "");    // enable environment locale&#13;
&#13;
    printf("Unsorted                : ");&#13;
    print_list(words, ECOUNT(words));&#13;
&#13;
    qsort(words, ECOUNT(words), sizeof *words, &amp;compare_lex);&#13;
&#13;
    printf("Lex (strcmp)        : ");&#13;
    print_list(words, ECOUNT(words));&#13;
&#13;
    qsort(words, ECOUNT(words), sizeof *words, &amp;compare_loc);&#13;
&#13;
    printf("Locale (strcoll): ");&#13;
    print_list(words, ECOUNT(words));&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="caption" id="ch11ex4"><em>Listing 11-4:</em> sc.c: <em>A short program that illustrates sort order differences between locales</em></p>&#13;
<p class="indent">First, the unsorted <code>words</code> list is printed to the console; then, the pointers in the <code>words</code> list are sorted with <code>qsort</code> using the <code>compare_lex</code> function, which uses <code>strcmp</code> to determine the collation order of the letters in each pair of words compared. The <code>strcmp</code> function doesn’t know anything about locales. It simply uses the order of the words’ letters in the ASCII table. Then the sorted list is printed to the console.</p>&#13;
<p class="indent">Next, <code>qsort</code> is called once again on <code>words</code>—this time using <code>compare_loc</code>, which uses <code>strcoll</code> to determine the sort order of the word pairs. The <code>strcoll</code> function uses the current locale to determine the relative order of the letters in the words being compared. The re-sorted list is then printed to the console.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_311"/>Building and executing this program with different locales displays the following output:</p>&#13;
<pre>$ <span class="codestrong1">gcc sc.c -o sc</span>&#13;
$ <span class="codestrong1">./sc</span>&#13;
Unsorted        : rana, rastrillo, radio, rápido, ráfaga,&#13;
Lex (strcmp)    : radio, rana, rastrillo, ráfaga, rápido,&#13;
Locale (strcoll): radio, ráfaga, rana, rápido, rastrillo,&#13;
$ <span class="codestrong1">LC_ALL=es_ES.utf8 ./sc</span>&#13;
Unsorted        : rana, rastrillo, radio, rápido, ráfaga,&#13;
Lex (strcmp)    : radio, rana, rastrillo, ráfaga, rápido,&#13;
Locale (strcoll): radio, ráfaga, rana, rápido, rastrillo,&#13;
$ <span class="codestrong1">LC_ALL=ja_JP.utf8 ./sc</span>&#13;
Unsorted        : rana, rastrillo, radio, rápido, ráfaga,&#13;
Lex (strcmp)    : radio, rana, rastrillo, ráfaga, rápido,&#13;
Locale (strcoll): radio, rana, rastrillo, ráfaga, rápido,&#13;
$</pre>&#13;
<p class="indent">English and Spanish sort accented vowels the same way. The <code>C</code> locale, represented by the results obtained using <code>strcmp</code>, always sorts strictly according to the ASCII table. Japanese, however, sorts differently than the Latin languages because Japanese makes no assumptions about how characters (accented or otherwise) not found in its alphabet should be ordered.</p>&#13;
<p class="indent">Internally, <code>strcoll</code> uses an algorithm to transform the characters in the comparison strings into numeric values that order naturally in the current locale; then it compares these byte arrays using the <code>strcmp</code> function. The algorithm used by <code>strcoll</code> can be pretty heavyweight because, for each set of two strings it compares, it transforms the locale-specific multibyte character sequences of these string pairs into sequences of bytes that can be compared lexicographically, by codeset ordinal values, and then internally compares those byte sequences using <code>strcmp</code>.</p>&#13;
<p class="indent">If you know you’re going to be comparing the same string or set of strings, it can be much more efficient to use the <code>strxfrm</code> function first, which exposes the transformation algorithm that <code>strcoll</code> uses internally. You can then simply use <code>strcmp</code> against these transformed strings to obtain the same collation you’d get from <code>strcoll</code> against untransformed strings.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex5">Listing 11-5</a> illustrates this process by converting the contents of <a href="ch11.xhtml#ch11ex4">Listing 11-4</a> to use <code>strxfrm</code> on the words in the <code>words</code> array, writing the transformed words into a two-dimensional array large enough to hold the transformed strings.</p>&#13;
<pre>   #include &lt;stdio.h&gt;&#13;
   #include &lt;stdlib.h&gt;&#13;
   #include &lt;locale.h&gt;&#13;
   #include &lt;string.h&gt;&#13;
&#13;
   #define ECOUNT(x) (sizeof(x)/sizeof(*(x)))&#13;
&#13;
<span class="ent">➊</span> typedef struct element&#13;
   {&#13;
       const char *input;&#13;
<span epub:type="pagebreak" id="page_312"/>       const char *xfrmd;&#13;
   } element;&#13;
&#13;
   static int compare(const void *a, const void *b)&#13;
   {&#13;
       const element *e1 = a;&#13;
       const element *e2 = b;&#13;
    <span class="ent">➋</span> return strcmp(e1-&gt;xfrmd, e2-&gt;xfrmd);&#13;
   }&#13;
&#13;
   static void print_list(const element *list, size_t sz)&#13;
   {&#13;
       for (int i = 0; i &lt; sz; i++)&#13;
        <span class="ent">➌</span> printf("%s, ", list[i].input);&#13;
       printf("\n");&#13;
   }&#13;
&#13;
   int main()&#13;
   {&#13;
       element words[] =&#13;
       {&#13;
           {"rana"}, {"rastrillo"}, {"radio"}, {"rápido"}, {"ráfaga"}&#13;
       };&#13;
&#13;
       setlocale(LC_ALL, "");   // enable environment locale&#13;
&#13;
       // point each xfrmd field at corresponding input field&#13;
       for (int i = 0; i &lt; ECOUNT(words); i++)&#13;
        <span class="ent">➍</span> words[i].xfrmd = words[i].input;&#13;
&#13;
       printf("Unsorted            : ");&#13;
       print_list(words, ECOUNT(words));&#13;
&#13;
       qsort(words, ECOUNT(words), sizeof *words, &amp;compare);&#13;
&#13;
       printf("Lex (strcmp)        : ");&#13;
       print_list(words, ECOUNT(words));&#13;
&#13;
       for (int i = 0; i &lt; ECOUNT(words); i++)&#13;
       {&#13;
           char buf[128];&#13;
           strxfrm(buf, words[i].input, sizeof buf);&#13;
        <span class="ent">➎</span> words[i].xfrmd = strdup(buf);&#13;
       }&#13;
&#13;
       qsort(words, ECOUNT(words), sizeof *words, &amp;compare);&#13;
&#13;
       printf("Locale (strxfrm/cmp): ");&#13;
       print_list(words, ECOUNT(words));&#13;
&#13;
       return 0;&#13;
}</pre>&#13;
<p class="caption" id="ch11ex5"><em>Listing 11-5:</em> sx.c: <em>The <code>sc</code> program, rewritten to use <code>strxfrm</code></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_313"/>There are several items of note here. The <code>strxfrm</code> function returns a zero-terminated byte buffer that looks and acts like an ordinary C string. There are no internal null characters; it can be acted upon by other string functions in the standard C library, but it’s not necessarily intelligible from a human-readability standpoint. Because of this weird characteristic, the transform buffer contents can only be used for comparison purposes during sorting. The original input value must be used for display. Therefore, we need to keep track of, and sort as pairs, the input buffer and the transform buffer for each word in our list. The <code>element</code> structure at <span class="ent">➊</span> manages this for us.</p>&#13;
<p class="indent">Since we no longer need to use <code>strcoll</code>, I’ve removed the <code>compare_loc</code> function and renamed <code>compare_lex</code> to <code>compare</code>, and I’ve changed the code to compare the <code>xfrmd</code> fields of the <code>element</code> structures passed in (at <span class="ent">➋</span>). Note, however, that the <code>print_list</code> function still prints the <code>input</code> field of the elements (at <span class="ent">➌</span>). This works because the <code>words</code> array has been converted to an array of pairs, where each element of the array contains both the original and the transformed words.</p>&#13;
<p class="indent">In order to make this code work with the original flow of <code>main</code> in <em>sc.c</em>, immediately after setting the locale, <em>sx.c</em> iterates over <code>words</code> (at <span class="ent">➍</span>), setting each element’s <code>xfrmd</code> pointer to the same value as its <code>input</code> pointer. This allows us to see what happens when using <code>strcmp</code> on untransformed strings during the first call to <code>qsort</code>.</p>&#13;
<p class="indent">At <span class="ent">➎</span>, after printing the results of that first sort operation, the program iterates over <code>words</code> again, this time calling <code>strxfrm</code> on each input string and pointing the corresponding <code>xfrmd</code> field at a <code>strdup</code> copy of the transform buffer, <code>buf</code>.<sup><a id="ch11fn_13" href="footnote.xhtml#ch11fn13">13</a></sup></p>&#13;
<p class="indent">Building and executing the code in <a href="ch11.xhtml#ch11ex5">Listing 11-5</a> should show us the same output we got when we ran the code from <a href="ch11.xhtml#ch11ex4">Listing 11-4</a>:</p>&#13;
<pre>$ <span class="codestrong1">gcc sx.c -o sx</span>&#13;
$ <span class="codestrong1">./sx</span>&#13;
Unsorted            : rana, rastrillo, radio, rápido, ráfaga,&#13;
Lex (strcmp)        : radio, rana, rastrillo, ráfaga, rápido,&#13;
Locale (strxfrm/cmp): radio, ráfaga, rana, rápido, rastrillo,&#13;
$ <span class="codestrong1">LC_ALL=es_ES.utf8 ./sx</span>&#13;
Unsorted            : rana, rastrillo, radio, rápido, ráfaga,&#13;
Lex (strcmp)        : radio, rana, rastrillo, ráfaga, rápido,&#13;
Locale (strxfrm/cmp): radio, ráfaga, rana, rápido, rastrillo,&#13;
$ <span class="codestrong1">LC_ALL=ja_JP.utf8 ./sx</span>&#13;
Unsorted            : rana, rastrillo, radio, rápido, ráfaga,&#13;
Lex (strcmp)        : radio, rana, rastrillo, ráfaga, rápido,&#13;
Locale (strxfrm/cmp): radio, rana, rastrillo, ráfaga, rápido,&#13;
$</pre>&#13;
<p class="indent">It’s a bit more complicated—the value of this version is not immediately apparent when sorting five words, but the time savings over transforming the strings within <code>strcoll</code> is significant when sorting hundreds of strings, even with the overhead of allocating and freeing the transform buffers.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_314"/><em>This sample takes shortcuts in order to highlight the important points of <em><code>strxfrm</code></em>. A real program would check the result of <em><code>strxfrm</code></em>, which returns the number of bytes required by the transformation (minus the terminating null character). If the value is larger than the buffer size specified, the program should reallocate and call <em><code>strxfrm</code></em> again. There is no reasonable way to predetermine the required buffer size for any given locale and codeset. I made my buffer large enough to handle just about any possibility, so I skipped this check for the sake of code readability, but this is not a recommended practice.</em></p>&#13;
</div>&#13;
<p class="indent">Now let’s turn our attention to the <code>LC_CTYPE</code> locale category. Changing this locale category affects the way most of the character classification functions in <em>ctype.h</em> work, including <code>isalnum</code>, <code>isalpha</code>, <code>isctrl</code>, <code>isgraph</code>, <code>islower</code>, <code>isprint</code>, <code>ispunct</code>, <code>isspace</code>, and <code>isupper</code> (but specifically not <code>isdigit</code> or <code>isxdigit</code>). It also affects the way <code>toupper</code> and <code>tolower</code> work—sort of. The fact is, the functions in <em>ctype.h</em> are broken in many ways with respect to internationalization. The problem is they rely on algorithmic mechanisms to convert character case, which work fine as long as you stick with the ASCII table. As soon as you leave this familiar playing field, however, all bets are off. Sometimes they work,    and sometimes they don’t. The most consistent way to make them work is to use wide characters, because the wide-character versions of these functions are newer in the C and C++ standards and the UTF-16 and UTF-32 codesets allow for similar algorithmic conversion for an expanded set of characters. However, even when wide characters are used, there are still cases where the algorithmic approach fails to convert properly, as some languages have digraphs that come in three forms: lowercase, uppercase, and title case. There’s just no algorithmic way to deal properly with these types of situations.</p>&#13;
<p class="indent">The source code in <a href="ch11.xhtml#ch11ex6">Listing 11-6</a> shows one way to properly convert a Spanish word from uppercase to lowercase.</p>&#13;
<pre>#include &lt;stdio.h&gt;&#13;
#include &lt;locale.h&gt;&#13;
#include &lt;wctype.h&gt;&#13;
#include &lt;wchar.h&gt;&#13;
&#13;
int main()&#13;
{&#13;
    const wchar_t *orig = L"BAÑO";&#13;
    wchar_t xfrm[64];&#13;
&#13;
    setlocale(LC_ALL, "");  // enable environment locale&#13;
&#13;
    int i = 0;&#13;
    while (i &lt; wcslen(orig))&#13;
    {&#13;
        xfrm[i] = towlower(orig[i]);&#13;
        i++;&#13;
    }&#13;
<span epub:type="pagebreak" id="page_315"/>        xfrm[i] = 0;&#13;
        printf("orig: %ls, xfrm: %ls\n", orig, xfrm);&#13;
&#13;
        return 0;&#13;
}</pre>&#13;
<p class="caption" id="ch11ex6"><em>Listing 11-6:</em> ct.c: <em>Converting a Spanish word using wide characters</em></p>&#13;
<p class="indent">The output is as follows:</p>&#13;
<pre>$ <span class="codestrong1">gcc ct.c -o ct</span>&#13;
$ .<span class="codestrong1">/ct</span>&#13;
orig: BAÑO, xfrm: baño&#13;
$</pre>&#13;
<p class="indent">This program doesn’t work if you change to <code>char</code> buffers and use UTF-8. It barely works using wide characters. If you set <code>LC_ALL=C</code>, it prints only <code>orig:</code> because, had we checked the return value of <code>printf</code> in <a href="ch11.xhtml#ch11ex6">Listing 11-6</a> (as we should do—especially when dealing with character set conversions like this), we’d have seen it return a <code>-1</code>, which is what it returns when it fails to convert a wide-character string to a multibyte string using <code>%ls</code>.</p>&#13;
<p class="indent">Rather than cover all the nuances of what does and doesn’t work in the <code>LC_CTYPE</code> category, I’ll just say that if you have to do a lot of this sort of conversion and character classification, I’d highly recommend using a third-party library like IBM’s <em>International Components for Unicode (ICU)</em><sup><a id="ch11fn_14" href="footnote.xhtml#ch11fn14">14</a></sup> or GNU libunistring<sup><a id="ch11fn_15" href="footnote.xhtml#ch11fn15">15</a></sup> (both of which, to put it succinctly, just do the right thing in all cases). ICU is a large library, and there’s a bit of a learning curve, but it’s worth the effort if you need it. GNU libunistring is a little easier to get your head around, but it still presents a lot of new functionality. There are also wrapper libraries like <em>Boost::locale</em>,<sup><a id="ch11fn_16" href="footnote.xhtml#ch11fn16">16</a></sup> if you’re using C++, that make accessing ICU a bit simpler, although <em>Boost::locale</em>, itself, is pretty complex.</p>&#13;
<h5 class="h5">X/Open and POSIX Standard Extensions</h5>&#13;
<p class="noindent">It’s a shame there is not a standard C library function to format numeric and currency amounts by locale in the same manner that <code>strftime</code> formats time and date by locale. There is, however, an extension provided by the X/Open and POSIX standards and implemented in the GNU C library—the <code>strfmon</code> function, whose prototype is as follows:</p>&#13;
<pre>#include &lt;monetary.h&gt;&#13;
&#13;
ssize_t strfmon(char *<span class="codeitalic1">s</span>, size_t <span class="codeitalic1">max</span>, const char *<span class="codeitalic1">format</span>, ...);</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_316"/>It works very much like <code>strftime</code>, placing the formatted value string in the <em><code>max</code></em>-sized buffer pointed to by <em><code>s</code></em>. The <em><code>format</code></em> string works like the format strings in the <code>printf</code> family of functions and like that of <code>strftime</code>. The format specifiers are specific to this function but, like those of the other functions, begin with percent sign (<code>%</code>) and end with a format character. Several supported modifier characters may be used between the percent and the format character. The two valid format characters are <code>i</code> for international and <code>n</code> for local.</p>&#13;
<p class="indent">This function is designed to format currency amounts and follows all the <code>localeconv</code>-provided <code>LC_CURRENCY</code> rules, but it can also be used to format decimal numbers according to <code>localeconv</code>-provided <code>LC_NUMERIC</code> rules. <a href="ch11.xhtml#ch11ex7">Listing 11-7</a> provides example code for formatting a currency value in local and international formats without any special modifiers and for formatting a decimal number. Unlike <code>strftime</code>, <code>strfmon</code> can format multiple values.</p>&#13;
<pre>#include &lt;stdio.h&gt;&#13;
#include &lt;locale.h&gt;&#13;
#include &lt;monetary.h&gt;&#13;
&#13;
int main()&#13;
{&#13;
    double amount = 12654.376;&#13;
    char buf[256];&#13;
&#13;
    setlocale(LC_ALL, "");  // enable environment locale&#13;
&#13;
    strfmon(buf, sizeof buf, "Local: %n, Int'l: %i, Decimal: %!6.2n",&#13;
            amount, amount, amount);&#13;
    printf("%s\n", buf);&#13;
    return 0;&#13;
}</pre>&#13;
<p class="caption" id="ch11ex7"><em>Listing 11-7:</em> amount.c: <em>An example of calling <code>strfmon</code> to format currency and decimal values</em></p>&#13;
<p class="indent">Let’s build and execute this program to see what’s displayed when using different locales:</p>&#13;
<pre>$ <span class="codestrong1">gcc amount.c -o amount</span>&#13;
$ <span class="codestrong1">LC_ALL=C ./amount</span>&#13;
Local: 12654.38, Int'l: 12654.38, Decimal: 12654.38&#13;
$ <span class="codestrong1">./amount</span>&#13;
Local: $12,654.38, Int'l: USD 12,654.38, Decimal: 12,654.38&#13;
$ <span class="codestrong1">LC_ALL=sv_SE.utf8 ./amount</span>&#13;
Local: 12 654,38 kr, Int'l: 12 654,38 SEK, Decimal: 12 654,38&#13;
$ <span class="codestrong1">LC_ALL=ja_JP.utf8 ./amount</span>&#13;
Local: ¥12,654, Int'l: JPY 12,654, Decimal: 12,654.38&#13;
$</pre>&#13;
<p class="indent">All the characteristics displayed by the <code>lc</code> program in <a href="ch11.xhtml#ch11ex2">Listing 11-2</a> for monetary and numeric categories are taken into account by <code>strfmon</code> in the same manner the standard <code>strftime</code> function does for time and date <span epub:type="pagebreak" id="page_317"/>characteristics. For instance, in both English and Japanese, the currency symbols are displayed before the values, while the Swedish currency symbols, <code>kr</code> and <code>SEK</code>, follow the value. The decimal separator is a comma in Sweden (and many other European locales), and Japanese yen values do not display a fractional part.</p>&#13;
<p class="indent">The exclamation mark (<code>!</code>) modifier in the decimal format specifier is used to suppress display of the currency symbol. By explicitly specifying a format precision, we can override the default Japanese locale characteristic that indicates that monetary values should not have a fractional part. The <code>strfmon</code> function was obviously designed for formatting currency values but, as we can see here, it can just as well be used to format plain old numeric decimal and integer values.</p>&#13;
<h5 class="h5">Overcoming localeconv’s Shortcomings</h5>&#13;
<p class="noindent">The X/Open and POSIX standards also provide a better and more functional version of <code>localeconv</code> called <code>nl_langinfo</code>. Here is the prototype for this function:</p>&#13;
<pre>#include &lt;langinfo.h&gt;&#13;
&#13;
char *nl_langinfo(nl_item <span class="codeitalic1">item</span>);</pre>&#13;
<p class="indent">The advantages of this interface over the standard library interface are numerous. First, it’s more efficient, only acquiring and returning the field you request on an as-needed basis, rather than filling and returning the entire locale attribute structure for each request. The <code>nl_langinfo</code> function is used to acquire a single attribute, specified by <em><code>item</code></em>, of the global environment locale.</p>&#13;
<p class="indent">If your application is required to manage multiple locales simultaneously, check out the POSIX interface for managing multiple discrete locales within the same application. I won’t cover them in detail here because they manage the same set of locale categories as the interfaces I’ve already shown you. Instead, see the POSIX 2008 standard for information on the <code>newlocale</code>, <code>duplocale</code>, <code>uselocale</code>, and <code>freelocale</code> functions, in connection with the <code>nl_langinfo_l</code> function, which accepts a second argument of type <code>locale_t</code> returned by <code>newlocale</code>. I will mention that the <code>uselocale</code> function can be used to set the locale of the current thread. All of the functions I’ve mentioned so far are implemented by the GNU C library.</p>&#13;
<p class="indent">The GNU C library also provides support for additional classes of locale information, including <code>LC_MESSAGES</code>, <code>LC_PAPER</code>, <code>LC_NAME</code>, <code>LC_ADDRESS</code>, <code>LC_TELEPHONE</code>, <code>LC_MEASUREMENT</code>, and <code>LC_IDENTIFICATION</code>. The <code>LC_MESSAGES</code> category has been standardized by POSIX and is the basis for <em>gettext</em>, which I’ll discuss shortly. The others are not standardized in C or POSIX, but they’ve been incorporated for many years into so many aspects of Linux, including Linux ports of the X Window System, that it’s hard to conceive of them being replaced or removed in the foreseeable future. Hence, I recommend their use if you do not intend to port your software outside of GNU tools.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_318"/>These additional categories are not accessible though <code>localeconv</code> and the <code>struct lconv</code> structure. Rather, you’ll need to use <code>nl_langinfo</code> to access the values in the locale that are associated with these categories.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex8">Listing 11-8</a> is the same program found in <a href="ch11.xhtml#ch11ex2">Listing 11-2</a>, except that this version uses <code>nl_langinfo</code> to display the locale information available through that interface. It’s intentionally organized to display the content that’s common to both interfaces in exactly the same format.</p>&#13;
<pre>#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;stdbool.h&gt;&#13;
#include &lt;limits.h&gt;&#13;
#include &lt;stdint.h&gt;&#13;
#include &lt;locale.h&gt;&#13;
#include &lt;langinfo.h&gt;&#13;
&#13;
static void print_grouping(const char *prefix, const char *grouping)&#13;
{&#13;
    const char *cg;&#13;
    printf("%s", prefix);&#13;
    for (cg = grouping; *cg &amp;&amp; *cg != CHAR_MAX; cg++)&#13;
        printf("%c %d", cg == grouping ? ':' : ',', *cg);&#13;
    printf("%s\n", *cg == 0 ? " (repeated)" : "");&#13;
}&#13;
&#13;
static void print_monetary(bool p_cs_precedes, bool p_sep_by_space,&#13;
        bool n_cs_precedes, bool n_sep_by_space,&#13;
        int p_sign_posn, int n_sign_posn)&#13;
{&#13;
    static const char * const sp_str[] =&#13;
    {&#13;
        "surround symbol and quantity with parentheses",&#13;
        "before quantity and symbol",&#13;
        "after quantity and symbol",&#13;
        "right before symbol",&#13;
        "right after symbol"&#13;
    };&#13;
    printf("    Symbol comes %s a positive (or zero) amount\n",&#13;
            p_cs_precedes ? "BEFORE" : "AFTER");&#13;
    printf("    Symbol %s separated from a positive (or zero) amount by a space\n",&#13;
            p_sep_by_space ? "IS" : "is NOT");&#13;
    printf("    Symbol comes %s a negative amount\n",&#13;
            n_cs_precedes ? "BEFORE" : "AFTER");&#13;
    printf("    Symbol %s separated from a negative amount by a space\n",&#13;
            n_sep_by_space ? "IS" : "is NOT");&#13;
    printf("    Positive (or zero) amount sign position: %s\n",&#13;
            sp_str[p_sign_posn == CHAR_MAX? 4: p_sign_posn]);&#13;
    printf("    Negative amount sign position: %s\n",&#13;
            sp_str[n_sign_posn == CHAR_MAX? 4: n_sign_posn]);&#13;
}&#13;
<span epub:type="pagebreak" id="page_319"/>#ifdef OUTER_LIMITS&#13;
&#13;
#define ECOUNT(x) (sizeof(x)/sizeof(*(x)))&#13;
&#13;
static const char *_get_measurement_system(int system_id)&#13;
{&#13;
    static const char * const measurement_systems[] = { "Metric", "English" };&#13;
    int idx = system_id - 1;&#13;
    return idx &lt; ECOUNT(measurement_systems)&#13;
            ? measurement_systems[idx] : "unknown";&#13;
}&#13;
&#13;
#endif&#13;
&#13;
int main(void)&#13;
{&#13;
    char *isym;&#13;
&#13;
    setlocale(LC_ALL, "");&#13;
&#13;
    printf("Numeric\n");&#13;
    printf("  Decimal: [%s]\n", nl_langinfo(DECIMAL_POINT));&#13;
    printf("  Thousands separator: [%s]\n", nl_langinfo(THOUSANDS_SEP));&#13;
&#13;
    print_grouping("  Grouping", nl_langinfo(GROUPING));&#13;
&#13;
    printf("\nMonetary\n");&#13;
    printf("  Decimal point: [%s]\n", nl_langinfo(MON_DECIMAL_POINT));&#13;
    printf("  Thousands separator: [%s]\n", nl_langinfo(MON_THOUSANDS_SEP));&#13;
    printf("  Grouping");&#13;
&#13;
    print_grouping("  Grouping", nl_langinfo(MON_GROUPING));&#13;
&#13;
    printf("  Positive amount sign: [%s]\n", nl_langinfo(POSITIVE_SIGN));&#13;
    printf("  Negative amount sign: [%s]\n", nl_langinfo(NEGATIVE_SIGN));&#13;
    printf("  Local:\n");&#13;
    printf("    Symbol: [%s]\n", nl_langinfo(CURRENCY_SYMBOL));&#13;
    printf("    Fractional digits: %d\n", *nl_langinfo(FRAC_DIGITS));&#13;
&#13;
    print_monetary(*nl_langinfo(P_CS_PRECEDES), *nl_langinfo(P_SEP_BY_SPACE),&#13;
            *nl_langinfo(N_CS_PRECEDES), *nl_langinfo(N_SEP_BY_SPACE),&#13;
            *nl_langinfo(P_SIGN_POSN), *nl_langinfo(N_SIGN_POSN));&#13;
&#13;
    printf("  International:\n");&#13;
    isym = nl_langinfo(INT_CURR_SYMBOL);&#13;
    printf("    Symbol (ISO 4217): [%3.3s], separator: [%s]\n",&#13;
           isym, strlen(isym) &gt; 3 ? isym + 3 : "");&#13;
    printf("    Fractional digits: %d\n", *nl_langinfo(INT_FRAC_DIGITS));&#13;
&#13;
    print_monetary(*nl_langinfo(INT_P_CS_PRECEDES), *nl_langinfo(INT_P_SEP_BY_SPACE),&#13;
            *nl_langinfo(INT_N_CS_PRECEDES), *nl_langinfo(INT_N_SEP_BY_SPACE),&#13;
            *nl_langinfo(INT_P_SIGN_POSN), *nl_langinfo(INT_N_SIGN_POSN));&#13;
<span epub:type="pagebreak" id="page_320"/>    printf("\nTime\n");&#13;
    printf("  AM: [%s]\n", nl_langinfo(AM_STR));&#13;
    printf("  PM: [%s]\n", nl_langinfo(PM_STR));&#13;
    printf("  Date &amp; time format: [%s]\n", nl_langinfo(D_T_FMT));&#13;
    printf("  Date format: [%s]\n", nl_langinfo(D_FMT));&#13;
    printf("  Time format: [%s]\n", nl_langinfo(T_FMT));&#13;
    printf("  Time format (AM/PM): [%s]\n", nl_langinfo(T_FMT_AMPM));&#13;
    printf("  Era: [%s]\n", nl_langinfo(ERA));&#13;
    printf("  Year (era): [%s]\n", nl_langinfo(ERA_YEAR));&#13;
    printf("  Date &amp; time format (era): [%s]\n", nl_langinfo(ERA_D_T_FMT));&#13;
    printf("  Date format (era): [%s]\n", nl_langinfo(ERA_D_FMT));&#13;
    printf("  Time format (era): [%s]\n", nl_langinfo(ERA_T_FMT));&#13;
    printf("  Alt digits: [%s]\n", nl_langinfo(ALT_DIGITS));&#13;
&#13;
    printf("   Days (abbr)");&#13;
    for (int i = 0; i &lt; 7; i++)&#13;
        printf("%c %s", i == 0 ? ':' : ',', nl_langinfo(ABDAY_1 + i));&#13;
    printf("\n");&#13;
&#13;
    printf("  Days (full)");&#13;
    for (int i = 0; i &lt; 7; i++)&#13;
        printf("%c %s", i == 0 ? ':' : ',', nl_langinfo(DAY_1 + i));&#13;
    printf("\n");&#13;
&#13;
    printf("  Months (abbr)");&#13;
    for (int i = 0; i &lt; 12; i++)&#13;
        printf("%c %s", i == 0 ? ':' : ',', nl_langinfo(ABMON_1 + i));&#13;
    printf("\n");&#13;
&#13;
    printf("  Months (full)");&#13;
    for (int i = 0; i &lt; 12; i++)&#13;
        printf("%c %s", i == 0 ? ':' : ',', nl_langinfo(MON_1 + i));&#13;
    printf("\n");&#13;
&#13;
    printf("\nMessages\n");&#13;
    printf("  Codeset: %s\n", nl_langinfo(CODESET));&#13;
&#13;
#ifdef OUTER_LIMITS&#13;
&#13;
    printf("\nQueries\n");&#13;
    printf("  YES expression: %s\n", nl_langinfo(YESEXPR));&#13;
    printf("  NO expression:  %s\n", nl_langinfo(NOEXPR));&#13;
&#13;
    printf("\nPaper\n");&#13;
    printf("  Height:  %dmm\n", (int)(intptr_t)nl_langinfo(_NL_PAPER_HEIGHT));&#13;
    printf("  Width:   %dmm\n", (int)(intptr_t)nl_langinfo(_NL_PAPER_WIDTH));&#13;
    printf("  Codeset: %s\n", nl_langinfo(_NL_PAPER_CODESET));&#13;
&#13;
    printf("\nName\n");&#13;
    printf("  Format: %s\n", nl_langinfo(_NL_NAME_NAME_FMT));&#13;
    printf("  Gen:    %s\n", nl_langinfo(_NL_NAME_NAME_GEN));&#13;
    printf("  Mr:     %s\n", nl_langinfo(_NL_NAME_NAME_MR));&#13;
    printf("  Mrs:    %s\n", nl_langinfo(_NL_NAME_NAME_MRS));&#13;
    printf("  Miss:   %s\n", nl_langinfo(_NL_NAME_NAME_MISS));&#13;
    printf("  Ms:     %s\n", nl_langinfo(_NL_NAME_NAME_MS));&#13;
<span epub:type="pagebreak" id="page_321"/>    printf("\nAddress\n");&#13;
    printf("  Country name:   %s\n", nl_langinfo(_NL_ADDRESS_COUNTRY_NAME));&#13;
    printf("  Country post:   %s\n", nl_langinfo(_NL_ADDRESS_COUNTRY_POST));&#13;
    printf("  Country abbr2:  %s\n", nl_langinfo(_NL_ADDRESS_COUNTRY_AB2));&#13;
    printf("  Country abbr3:  %s\n", nl_langinfo(_NL_ADDRESS_COUNTRY_AB3));&#13;
    printf("  Country num:    %d\n",&#13;
            (int)(intptr_t)nl_langinfo(_NL_ADDRESS_COUNTRY_NUM));&#13;
    printf("  Country ISBN:   %s\n", nl_langinfo(_NL_ADDRESS_COUNTRY_ISBN));&#13;
    printf("  Language name:  %s\n", nl_langinfo(_NL_ADDRESS_LANG_NAME));&#13;
    printf("  Language abbr:  %s\n", nl_langinfo(_NL_ADDRESS_LANG_AB));&#13;
    printf("  Language term:  %s\n", nl_langinfo(_NL_ADDRESS_LANG_TERM));&#13;
    printf("  Language lib:   %s\n", nl_langinfo(_NL_ADDRESS_LANG_LIB));&#13;
    printf("  Codeset:        %s\n", nl_langinfo(_NL_ADDRESS_CODESET));&#13;
&#13;
    printf("\nTelephone\n");&#13;
    printf("  Int'l format:    %s\n", nl_langinfo(_NL_TELEPHONE_TEL_INT_FMT));&#13;
    printf("  Domestic format: %s\n", nl_langinfo(_NL_TELEPHONE_TEL_DOM_FMT));&#13;
    printf("  Int'l select:    %s\n", nl_langinfo(_NL_TELEPHONE_INT_SELECT));&#13;
    printf("  Int'l prefix:    %s\n", nl_langinfo(_NL_TELEPHONE_INT_PREFIX));&#13;
    printf("  Codeset:         %s\n", nl_langinfo(_NL_TELEPHONE_CODESET));&#13;
&#13;
   printf("\nMeasurement\n");&#13;
   printf("  System:  %s\n",_get_measurement_system(&#13;
           (int)*nl_langinfo(_NL_MEASUREMENT_MEASUREMENT)));&#13;
   printf("  Codeset: %s\n", nl_langinfo(_NL_MEASUREMENT_CODESET));&#13;
&#13;
   printf("\nIdentification\n");&#13;
   printf("  Title:       %s\n", nl_langinfo(_NL_IDENTIFICATION_TITLE));&#13;
   printf("  Source:      %s\n", nl_langinfo(_NL_IDENTIFICATION_SOURCE));&#13;
   printf("  Address:     %s\n", nl_langinfo(_NL_IDENTIFICATION_ADDRESS));&#13;
   printf("  Contact:     %s\n", nl_langinfo(_NL_IDENTIFICATION_CONTACT));&#13;
   printf("  Email:       %s\n", nl_langinfo(_NL_IDENTIFICATION_EMAIL));&#13;
   printf("  Telephone:   %s\n", nl_langinfo(_NL_IDENTIFICATION_TEL));&#13;
   printf("  Language:    %s\n", nl_langinfo(_NL_IDENTIFICATION_LANGUAGE));&#13;
   printf("  Territory:   %s\n", nl_langinfo(_NL_IDENTIFICATION_TERRITORY));&#13;
   printf("  Audience:    %s\n", nl_langinfo(_NL_IDENTIFICATION_AUDIENCE));&#13;
   printf("  Application: %s\n", nl_langinfo(_NL_IDENTIFICATION_APPLICATION));&#13;
   printf("  Abbr:        %s\n", nl_langinfo(_NL_IDENTIFICATION_ABBREVIATION));&#13;
   printf("  Revision:    %s\n", nl_langinfo(_NL_IDENTIFICATION_REVISION));&#13;
   printf("  Date:        %s\n", nl_langinfo(_NL_IDENTIFICATION_DATE));&#13;
   printf("  Category:    %s\n", nl_langinfo(_NL_IDENTIFICATION_CATEGORY));&#13;
   printf("  Codeset:     %s\n", nl_langinfo(_NL_IDENTIFICATION_CODESET));&#13;
&#13;
#endif // OUTER_LIMITS&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="caption" id="ch11ex8"><em>Listing 11-8:</em> nl.c: <em>Using <code>nl_langinfo</code> to display available locale information</em></p>&#13;
<p class="indent">To build this code, you need to add a couple of definitions to the command line: <code>_GNU_SOURCE</code> and <code>OUTER_LIMITS</code>. The first definition belongs to the GNU C library and allows <em>nl.c</em> to access the extended international <span epub:type="pagebreak" id="page_322"/>monetary fields that were not part of the C standard until C99. The second is my own invention that allows you to build the program without the extended categories provided by the GNU C library:</p>&#13;
<pre>$ <span class="codestrong1">gcc -D_GNU_SOURCE -DOUTER_LIMITS nl.c -o nl</span>&#13;
$ <span class="codestrong1">./nl</span>&#13;
<span class="ash">Numeric</span>&#13;
  <span class="ash">Decimal: [.]</span>&#13;
  <span class="ash">Thousands separator: [,]</span>&#13;
  <span class="ash">Grouping: 3, 3 (repeated)</span>&#13;
&#13;
<span class="ash">Monetary</span>&#13;
  <span class="ash">Decimal point: [.]</span>&#13;
  <span class="ash">Thousands separator: [,]</span>&#13;
  <span class="ash">Grouping    Grouping: 3, 3 (repeated)</span>&#13;
  <span class="ash">Positive amount sign: []</span>&#13;
  <span class="ash">Negative amount sign: [-]</span>&#13;
  <span class="ash">Local:</span>&#13;
    <span class="ash">Symbol: [$]</span>&#13;
    <span class="ash">Fractional digits: 2</span>&#13;
    <span class="ash">Symbol comes BEFORE a positive (or zero) amount</span>&#13;
    <span class="ash">Symbol is NOT separated from a positive (or zero) amount by a space</span>&#13;
    <span class="ash">Symbol comes BEFORE a negative amount</span>&#13;
    <span class="ash">Symbol is NOT separated from a negative amount by a space</span>&#13;
    <span class="ash">Positive (or zero) amount sign position: before quantity and symbol</span>&#13;
    <span class="ash">Negative amount sign position: before quantity and symbol</span>&#13;
  <span class="ash">International:</span>&#13;
    <span class="ash">Symbol (ISO 4217): [USD], separator: [ ]</span>&#13;
    <span class="ash">Fractional digits: 2</span>&#13;
    <span class="ash">Symbol comes BEFORE a positive (or zero) amount</span>&#13;
    <span class="ash">Symbol IS separated from a positive (or zero) amount by a space</span>&#13;
    <span class="ash">Symbol comes BEFORE a negative amount</span>&#13;
    <span class="ash">Symbol IS separated from a negative amount by a space</span>&#13;
    <span class="ash">Positive (or zero) amount sign position: before quantity and symbol</span>&#13;
    <span class="ash">Negative amount sign position: before quantity and symbol</span>&#13;
&#13;
Time&#13;
  AM: [AM]&#13;
  PM: [PM]&#13;
  Date &amp; time format: [%a %d %b %Y %r %Z]&#13;
  Date format: [%m/%d/%Y]&#13;
  Time format: [%r]&#13;
  Time format (AM/PM): [%I:%M:%S %p]&#13;
  Era: []&#13;
  Year (era): []&#13;
  Date &amp; time format (era): []&#13;
  Date format (era): []&#13;
  Time format (era): []&#13;
  Alt digits: []&#13;
  Days (abbr): Sun, Mon, Tue, Wed, Thu, Fri, Sat&#13;
  Days (full): Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday&#13;
  Months (abbr): Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec&#13;
  Months (full): January, February, March, April, May, June, July, August,&#13;
September, October, November, December&#13;
<span epub:type="pagebreak" id="page_323"/>Messages&#13;
  Codeset: UTF-8&#13;
&#13;
Queries&#13;
  YES expression: ^[yY].*&#13;
  NO expression:  ^[nN].*&#13;
&#13;
Paper&#13;
  Height:  279mm&#13;
  Width:   216mm&#13;
  Codeset: UTF-8&#13;
&#13;
Name&#13;
  Format: %d%t%g%t%m%t%f&#13;
  Gen:&#13;
  Mr:       Mr.&#13;
  Mrs:      Mrs.&#13;
  Miss:     Miss.&#13;
  Ms:       Ms.&#13;
&#13;
Address&#13;
  Country name:  USA&#13;
  Country post:  USA&#13;
  Country abbr2: US&#13;
  Country abbr3: USA&#13;
  Country num:   840&#13;
  Country ISBN:  0&#13;
  Language name: English&#13;
  Language abbr: en&#13;
  Language term: eng&#13;
  Language lib:  eng&#13;
  Codeset:       UTF-8&#13;
&#13;
Telephone&#13;
  Int'l format:    +%c (%a) %l&#13;
  Domestic format: (%a) %l&#13;
  Int'l select:    11&#13;
  Int'l prefix:    1&#13;
  Codeset:         UTF-8&#13;
&#13;
Measurement&#13;
  System:  English&#13;
  Codeset: UTF-8&#13;
&#13;
Identification&#13;
  Title:         English locale for the USA&#13;
  Source:        Free Software Foundation, Inc.&#13;
  Address:       http://www.gnu.org/software/libc/&#13;
  Contact:&#13;
  Email:         bug-glibc-locales@gnu.org&#13;
  Telephone:&#13;
  Language:      English&#13;
  Territory:     USA&#13;
  Audience:&#13;
  Application:&#13;
<span epub:type="pagebreak" id="page_324"/>  Abbr:&#13;
  Revision:        1.0&#13;
  Date:            2000-06-24&#13;
  Category:        en_US:2000&#13;
  Codeset:         UTF-8&#13;
$</pre>&#13;
<p class="indent">The highlighted section of the preceding output shows the portion of <code>nl</code>’s output that goes beyond the <code>lc</code> program from <a href="ch11.xhtml#ch11ex2">Listing 11-2</a>. The additional locale categories are defined as follows.</p>&#13;
<p class="noindentt"><strong><code>LC_MESSAGES</code></strong></p>&#13;
<p class="bqparan">This category provides one additional item value, <code>CODESET</code>, which defines the codeset used by this locale. This item is categorized under “Messages” because it’s intended to be helpful when translating static text messages in application code. The value can also be used as an environment variable on Linux systems in order to help select the static message catalog to be used.</p>&#13;
<p class="noindentt"><strong><code>LC_PAPER</code></strong></p>&#13;
<p class="bqparan">The paper category provides two items, <code>_NL_PAPER_HEIGHT</code> and <code>_NL_PAPER_WIDTH</code>, which return paper dimensional values in millimeters for the most commonly used printer paper in the locale. This can be very helpful when formatting print output or when auto-selecting paper sizes—<em>letter</em> and <em>A04</em>, for example. Be aware that the pointer values returned from these item enumeration values should be treated like native-word-sized integer values, rather than as actual pointers. See the <em>nl.c</em> code in <a href="ch11.xhtml#ch11ex8">Listing 11-8</a> for details.</p>&#13;
<p class="noindentt"><strong><code>LC_NAME</code></strong></p>&#13;
<p class="bqparan">The name category provides information on formatting salutations such as Mr., Mrs., Miss, and Ms. in the locale. The items in this category allow your software to automatically select how to state such salutations in the current language and territory.</p>&#13;
<p class="noindentt"><strong><code>LC_ADDRESS</code></strong></p>&#13;
<p class="bqparan">The address category provides items that return geographical information for the locale, such as country name, postal code, and two- and three-letter country name abbreviations. It also returns the language name and library used by the locale.</p>&#13;
<p class="noindentt"><strong><code>LC_TELEPHONE</code></strong></p>&#13;
<p class="bqparan">The telephone category provides format-specifier strings usable within the <em>printf</em> family of functions to display telephone numbers in a style that’s common in the current locale.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_325"/><strong><code>LC_MEASUREMENT</code></strong></p>&#13;
<p class="bqparan">The measurement category provides a single item for returning the system of measurement used in the current locale. The <code>_NL_MEASUREMENT_MEASUREMENT</code> item returns a string whose first character is a short integer value: <code>0</code> for Metric or <code>1</code> for English.</p>&#13;
<p class="noindentt"><strong><code>LC_IDENTIFICATION</code></strong></p>&#13;
<p class="bqparan">The identification category is actually locale metadata. That is, the fields of this category return information about the territory, author, and process used to create the current locale (for example, the locale author’s name, email address, phone number, and so on). It also returns versioning information about the locale. Be aware that the pointer value returned from <code>_NL_ADDRESS_COUNTRY_NUM</code> should be treated like a native-word-sized integer value rather than a pointer. See the <em>nl.c</em> code in <a href="ch11.xhtml#ch11ex8">Listing 11-8</a> for details.</p>&#13;
<p class="indentt">You can access the same information using the <code>-k</code> option with the <code>locale</code> command line program that comes preinstalled on your Linux distro, as follows:</p>&#13;
<pre>$ <span class="codestrong1">locale -k LC_PAPER</span>&#13;
height=279&#13;
width=216&#13;
paper-codeset="UTF-8"&#13;
$</pre>&#13;
<p class="indent">You can query the GNU C library <code>nl_langinfo</code> function for individual time- and date-formatting attributes such as AM and PM strings, various more granular format-specifier strings, and full and abbreviated days of the week and months of the year in the current locale.</p>&#13;
<p class="indent">The GNU C library <code>nl_langinfo</code> implementation even returns regular expressions intended to be used for matching query responses. The regular expressions returned from the <code>YESEXPR</code> and <code>NOEXPR</code> item enumeration values can be used to match <em>yes</em> or <em>no</em> answers to questions prompted by software.</p>&#13;
<h4 class="h4" id="ch11sec2-2"><em>Instrumenting Source Code for Static Messages</em></h4>&#13;
<p class="noindent">Instrumenting access to locale-specific static text messages in your source code is also part of the process of internationalizing software, so we’ll cover instrumentation of static text display messages here. Then we’ll move on to how to generate and consume language packs in <a href="ch12.xhtml">Chapter 12</a>, where I’ll discuss localization.</p>&#13;
<p class="indent">It should be clear by now that something needs to be done with the static portion of the “<em><code>greeting</code></em>, from <em><code>progname</code></em>!” text we printed from Jupiter (for example). I’m not going to take Jupiter any further, but it does provide a concise example of something that needs to change in our programs when the locale changes. The process of instrumenting source code for translating static display messages involves scanning your source code for all string <span epub:type="pagebreak" id="page_326"/>literals that can be displayed to a user during the execution of a program and then doing something that makes it possible for the program to use a version of that string that specifically targets the current locale.</p>&#13;
<p class="indent">There are a few open source (and several third-party commercial) libraries that can be used to accomplish this task, but we’re going to focus on the GNU <em>gettext</em> library. The <em>gettext</em> library is very simple from a software perspective. In its simplest form, there’s one function for tagging a message to be translated and two functions for selecting the message catalog to be used for display. The tagging function is named <code>gettext</code>, and its prototype is shown in <a href="ch11.xhtml#ch11ex9">Listing 11-9</a>.</p>&#13;
<pre>#include &lt;libintl.h&gt;&#13;
&#13;
char *gettext(const char *<span class="codeitalic1">msgid</span>);</pre>&#13;
<p class="caption" id="ch11ex9"><em>Listing 11-9: The prototype for the <code>gettext</code> function</em></p>&#13;
<p class="indent">This function accepts a message identifier in the <em><code>msgid</code></em> parameter and returns the display message to the user. The message identifier can be any string but is usually the display message itself, in US-ASCII. The reason for this is that if the message catalog cannot be found, <code>gettext</code> returns the <em><code>msgid</code></em> value itself, which will then be used by the program in the same way the translated message would have been used, had it been found. Thus, the <code>gettext</code> function cannot fail in a manner that will cause the program to not work in some reasonable fashion under any conceivable set of conditions.</p>&#13;
<p class="indent">This convention makes it very simple to both instrument existing programs and write new programs that use locale-based message catalogs. You simply need to find all of the static text messages within the program source files and wrap them in calls to <code>gettext</code>.</p>&#13;
<p class="indent">Occasionally, it’s necessary to provide the translator with more contextual information than just the string. For a common example, when providing message IDs for menu items such as the <code>Open</code> submenu option in the <code>File</code> menu, the programmer may have communicated to the translator that the programmer has provided the entire menu hierarchy in a format such as <code>|File|Open</code>. When the translator sees this, they know that only the portion following the last vertical bar symbol should be translated. But if there is no translation for the current locale, the message ID will be the full string. In this case, the programmer must write the code to check for a leading vertical bar. If it’s found, only the portion following the last vertical bar should actually be displayed.</p>&#13;
<p class="indent">The code in <a href="ch11.xhtml#ch11ex10">Listing 11-10</a> shows a very short (and somehow familiar) example program that uses <code>gettext</code>.</p>&#13;
<pre>#include &lt;stdio.h&gt;&#13;
#include &lt;libintl.h&gt;&#13;
&#13;
#define _(x) gettext(x)&#13;
&#13;
int main()&#13;
<span epub:type="pagebreak" id="page_327"/>{&#13;
     printf(_("Hello, world!\n"));&#13;
     return 0;&#13;
}</pre>&#13;
<p class="caption" id="ch11ex10"><em>Listing 11-10:</em> gt.c: <em>A short program that illustrates the use of the gettext library</em></p>&#13;
<p class="indent">The <code>printf</code> function sends the return value of <code>gettext</code> to <code>stdout</code>. The <code>gettext</code> function is exported by the GNU C library, so no additional libraries are required to use it. When using <code>gettext</code> without GNU C, just link the <em>intl</em> library (shared object or static archive).</p>&#13;
<p class="indent">We could call <code>gettext</code> directly in <code>printf</code>, but the underscore (<code>_</code>) macro is a common idiom used when internationalizing software for two reasons: First, it decreases the visual impact of instrumenting an existing code base for <em>gettext</em>. Second, it allows us a single point of replacement if we choose to wrap <code>gettext</code> with additional functionality or if we decide to use a more functional variant of <code>gettext</code> (for example, <code>dgettext</code> and <code>dcgettext</code>). I haven’t discussed these variants here, but you can find out more about them in the <em>GNU C Library</em> manual.<sup><a id="ch11fn_17" href="footnote.xhtml#ch11fn17">17</a></sup></p>&#13;
<h5 class="h5">Message Catalog Selection</h5>&#13;
<p class="noindent">Selection of the message catalog is done in two phases: the programmer phase and the user phase. The programmer phase is handled by the functions <code>textdomain</code> and <code>bindtextdomain</code>. The prototypes for these functions (also exported by the GNU C library) are shown in <a href="ch11.xhtml#ch11ex11">Listing 11-11</a>.</p>&#13;
<pre>#include &lt;libintl.h&gt;&#13;
&#13;
char *textdomain(const char *<span class="codeitalic1">domainname</span>);&#13;
char *bindtextdomain(const char *<span class="codeitalic1">domainname</span>, const char *<span class="codeitalic1">dirname</span>);</pre>&#13;
<p class="caption" id="ch11ex11"><em>Listing 11-11: The prototypes for <code>textdomain</code> and <code>bindtextdomain</code></em></p>&#13;
<p class="indent">The <code>textdomain</code> function allows the software author to determine the message catalog domain that is in use at any given point within the program. The domain represents a given message catalog containing some portion of the messages in a program. All strings extracted from the source code belonging to a specific domain end up in the message catalog for that domain.</p>&#13;
<p class="indent">A package may have several domains. The typical boundary between domains, and therefore between message catalogs, is an executable module— either a program or a library. For example, the <em>curl</em> package installs the command line <code>curl</code> program and the <em>libcurl.so</em> shared library. The <em>curl</em> library is designed to be used by both the <code>curl</code> program and by other third-party programs and libraries. If the <em>curl</em> package were internationalized, the package author might decide to use the <em>curl</em> domain for the <code>curl</code> program and the <em>libcurl</em> domain for the library so that third-party applications that use <em>libcurl</em> aren’t required to have the <code>curl</code> message catalog installed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_328"/>The example used by the <em>GNU C Library</em> manual<sup><a id="ch11fn_18" href="footnote.xhtml#ch11fn18">18</a></sup> is one where <em>libc</em> itself uses <code>libc</code> as the domain name, but programs using <em>libc</em> would use their own domain. Simply put, the <em><code>domainname</code></em> parameter in these functions directly corresponds to a message catalog filename.</p>&#13;
<p class="indent">The <code>dirname</code> parameter in <code>bindtextdomain</code> is used to specify a base directory in which to search for the well-defined message catalog directory structure, which I’ll discuss shortly. Normally, the value passed in this parameter is the absolute path in the Automake <code>datadir</code> variable, suffixed with <em>/locale</em>. Recall that <code>datadir</code> contains, by default, <code>$(prefix)</code><em>/share</em> and <code>prefix</code> contains <em>/usr/local</em>, so the full path used here would be <em>/usr/local/share/locale</em>. For distribution-provided packages, <code>prefix</code> is more often simply <em>/usr</em>, so the full path would then become <em>/usr/share/locale</em>. It’s therefore up to the maintainer to ensure that <code>datadir</code> is available within the software (using techniques discussed in <a href="ch03.xhtml">Chapter 3</a>) and referenced in the argument passed to this parameter.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex12">Listing 11-12</a> shows how to add the code necessary to select the proper message catalog based on the current locale. Of course, we must first make the program aware of the current locale in the usual manner by calling <code>setlocale</code>.</p>&#13;
<pre><span class="ash">#include &lt;stdio.h&gt;</span>&#13;
#include &lt;locale.h&gt;&#13;
<span class="ash">#include &lt;libintl.h&gt;</span>&#13;
&#13;
#ifndef LOCALE_DIR&#13;
# define LOCALE_DIR "/usr/local/share/locale"&#13;
#endif&#13;
&#13;
#ifdef TEST_L10N&#13;
# include &lt;stdlib.h&gt;&#13;
# undef LOCALE_DIR&#13;
# define LOCALE_DIR getenv("PWD")&#13;
#endif&#13;
&#13;
<span class="ash">#define _(x) gettext(x)</span>&#13;
&#13;
<span class="ash">int main()</span>&#13;
<span class="ash">{</span>&#13;
     const char *localedir = LOCALE_DIR;&#13;
&#13;
     setlocale(LC_ALL, "");&#13;
     bindtextdomain("gt", localedir);&#13;
     textdomain("gt");&#13;
&#13;
     <span class="ash">printf(_("Hello, world!\n"));</span>&#13;
&#13;
     <span class="ash">return 0;</span>&#13;
<span class="ash">}</span></pre>&#13;
<p class="caption" id="ch11ex12"><em>Listing 11-12:</em> gt.c: <em>Enhancements to enable the current locale and select the message catalog</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_329"/>I’m using <em>gt</em> as the domain name here because that’s the name of the program. If this program were part of a package wherein all the components used the same domain, then the package name might be a better choice.</p>&#13;
<p class="indent">The directory name passed into <code>bindtextdomain</code>’s second parameter is derived from a future <em>config.h</em> inclusion. We’ll add that later when we incorporate this program into an Autotools build system. If we define <code>TEST_L10N</code> on the compiler command line, the directory name resolves to the value of the <code>PWD</code> environment variable, allowing us to test our program in any location containing the locale directory structure. (We’ll replace this hack later with a more Autotool-ish mechanism in <a href="ch12.xhtml">Chapter 12</a>.)</p>&#13;
<p class="indent">That’s really all there is to instrumenting your code for message catalog lookup. In the next section, I’ll discuss how to generate and build message catalogs, which is part of the process of localizing a software package. I’ll also talk about the internal workings of the <em>gettext</em> library, which allows the user to select (during the user phase) the message catalog that should be used by their choice of environment variable settings.</p>&#13;
<h3 class="h3" id="ch11sec3">Summary</h3>&#13;
<p class="noindent">In this chapter, my goal was to give you enough background that you could easily continue learning about internationalizing your software projects. I’ve covered the C standard library functionality that’s designed to help you internationalize your software.</p>&#13;
<p class="indent">In the next chapter, we’ll continue our exploration of this topic by diving into localization. We’ll also discover how to tie all of this into the Autotools so that language packs get built and installed with <code>make</code> commands generated by Automake.<span epub:type="pagebreak" id="page_330"/></p>&#13;
</body></html>