["```\n$ go get github.com/miekg/dns\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n\n    \"github.com/miekg/dns\"\n)\n\nfunc main() {\n ❶ var msg dns.Msg\n ❷ fqdn := dns.Fqdn(\"stacktitan.com\")\n ❸ msg.SetQuestion(fqdn, dns.TypeA)\n ❹ dns.Exchange(&msg, \"8.8.8.8:53\")\n}\n```", "```\n$ sudo tcpdump -i eth0 -n udp port 53\n```", "```\n$ go run main.go\n```", "```\n$ sudo tcpdump -i eth0 -n udp port 53\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes\n23:55:16.523741 IP 192.168.7.51.53307 > 8.8.8.8.53:❶ 25147+ A?❷ stacktitan.com. (32)\n23:55:16.650905 IP 8.8.8.8.53 > 192.168.7.51.53307: 25147 1/0/0 A 104.131.56.170 (48) ❸\n```", "```\ntype Msg struct {\n    MsgHdr\n    Compress    bool       `json:\"-\"` // If true, the message will be compressed...\n ❶ Question    []Question            // Holds the RR(s) of the question section.\n ❷ Answer      []RR                  // Holds the RR(s) of the answer section.\n    Ns          []RR                  // Holds the RR(s) of the authority section.\n    Extra       []RR                  // Holds the RR(s) of the additional section.\n}\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n\n    \"github.com/miekg/dns\"\n)\n\nfunc main() {\n    var msg dns.Msg\n    fqdn := dns.Fqdn(\"stacktitan.com\")\n    msg.SetQuestion(fqdn, dns.TypeA)\n ❶ in, err := dns.Exchange(&msg, \"8.8.8.8:53\")\n    if err != nil {\n        panic(err)\n    }\n ❷ if len(in.Answer) < 1 {\n        fmt.Println(\"No records\")\n        return\n    }\n    for _, answer := range in.Answer {\n        if a❸, ok:= answer.(*dns.A)❹; ok {\n         ❺ fmt.Println(a.A)\n        }\n    }\n}\n```", "```\npackage main\n\nimport (\n    \"flag\"\n)\n\nfunc main() {\n    var (\n        flDomain      = flag.String(\"domain\", \"\", \"The domain to perform guessing against.\") ❶\n        flWordlist    = flag.String(\"wordlist\", \"\", \"The wordlist to use for guessing.\")\n        flWorkerCount = flag.Int(\"c\", 100, \"The amount of workers to use.\") ❷\n        flServerAddr  = flag.String(\"server\", \"8.8.8.8:53\", \"The DNS server to use.\")\n    )\n    flag.Parse() ❸\n}\n```", "```\nif *flDomain == \"\" || *flWordlist == \"\" {\n    fmt.Println(\"-domain and -wordlist are required\")\n    os.Exit(1)\n}\nfmt.Println(*flWorkerCount, *flServerAddr)\n```", "```\ntype result struct {\n    IPAddress string\n    Hostname string\n}\n```", "```\nfunc lookupA(fqdn, serverAddr string) ([]string, error) {\n    var m dns.Msg\n    var ips []string\n    m.SetQuestion(dns.Fqdn(fqdn), dns.TypeA)\n    in, err := dns.Exchange(&m, serverAddr)\n    if err != nil {\n        return ips, err\n    }\n    if len(in.Answer) < 1 {\n        return ips, errors.New(\"no answer\")\n    }\n    for _, answer := range in.Answer {\n        if a, ok := answer.(*dns.A); ok {\n            ips = append(ips, a.A.String())\n        }\n    }\n    return ips, nil\n}\n\nfunc lookupCNAME(fqdn, serverAddr string) ([]string, error) {\n    var m dns.Msg\n    var fqdns []string\n    m.SetQuestion(dns.Fqdn(fqdn), dns.TypeCNAME)\n    in, err := dns.Exchange(&m, serverAddr)\n    if err != nil {\n        return fqdns, err\n    }\n    if len(in.Answer) < 1 {\n        return fqdns, errors.New(\"no answer\")\n    }\n    for _, answer := range in.Answer {\n        if c, ok := answer.(*dns.CNAME); ok {\n            fqdns = append(fqdns, c.Target)\n        }\n    }\n    return fqdns, nil\n}\n```", "```\nfunc lookup(fqdn, serverAddr string) []result {\n ❶ var results []result\n ❷ var cfqdn = fqdn // Don't modify the original.\n    for {\n     ❸ cnames, err := lookupCNAME(cfqdn, serverAddr)\n     ❹ if err == nil && len(cnames) > 0 {\n         ❺ cfqdn = cnames[0]\n         ❻ continue // We have to process the next CNAME.\n        }\n     ❼ ips, err := lookupA(cfqdn, serverAddr)\n        if err != nil {\n            break // There are no A records for this hostname.\n        }\n     ❽ for _, ip := range ips {\n            results = append(results, result{IPAddress: ip, Hostname: fqdn})\n        }\n     ❾ break // We have processed all the results.\n    }\n    return results\n}\n```", "```\ntype empty struct{} ❶\n\nfunc worker(tracker chan empty, fqdns chan string, gather chan []result, serverAddr string) {\n    for fqdn := range fqdns { ❷\n        results := lookup(fqdn, serverAddr)\n        if len(results) > 0 {\n            gather <- results ❸\n        }\n    }\n    var e empty\n    tracker <- e ❹\n}\n```", "```\nvar results []result\nfqdns := make(chan string, *flWorkerCount)\ngather := make(chan []result)\ntracker := make(chan empty)\n```", "```\nfh, err := os.Open(*flWordlist)\nif err != nil {\n    panic(err)\n}\ndefer fh.Close()\nscanner := bufio.NewScanner(fh)\n```", "```\n❶ for i := 0; i < *flWorkerCount; i++ {\n       go worker(tracker, fqdns, gather, *flServerAddr)\n   }\n\n❷ for scanner.Scan() {\n       fqdns <- fmt.Sprintf(\"%s.%s\", scanner.Text()❸, *flDomain)\n   }\n```", "```\ngo func() {\n    for r := range gather {\n     ❶ results = append(results, r...❷)\n    }\n    var e empty\n ❸ tracker <- e\n}()\n```", "```\n❶ close(fqdns)\n❷ for i := 0; i < *flWorkerCount; i++ {\n       <-tracker\n   }\n❸ close(gather)\n❹ <-tracker\n```", "```\nw := tabwriter.NewWriter(os.Stdout, 0, 8, 4, ' ', 0)\nfor _, r := range results {\n    fmt.Fprintf(w, \"%s\\t%s\\n\", r.Hostname, r.IPAddress)\n}\nw.Flush()\n```", "```\nPackage main\n\nimport (\n    \"bufio\"\n    \"errors\"\n    \"flag\"\n    \"fmt\"\n    \"os\"\n    \"text/tabwriter\"\n\n    \"github.com/miekg/dns\"\n)\n\nfunc lookupA(fqdn, serverAddr string) ([]string, error) {\n    var m dns.Msg\n    var ips []string\n    m.SetQuestion(dns.Fqdn(fqdn), dns.TypeA)\n    in, err := dns.Exchange(&m, serverAddr)\n    if err != nil {\n        return ips, err\n    }\n    if len(in.Answer) < 1 {\n        return ips, errors.New(\"no answer\")\n    }\n    for _, answer := range in.Answer {\n        if a, ok := answer.(*dns.A); ok {\n            ips = append(ips, a.A.String())\n            return ips, nil\n        }\n    }\n    return ips, nil\n}\n\nfunc lookupCNAME(fqdn, serverAddr string) ([]string, error) {\n    var m dns.Msg\n    var fqdns []string\n    m.SetQuestion(dns.Fqdn(fqdn), dns.TypeCNAME)\n    in, err := dns.Exchange(&m, serverAddr)\n    if err != nil {\n        return fqdns, err\n    }\n    if len(in.Answer) < 1 {\n return fqdns, errors.New(\"no answer\")\n    }\n    for _, answer := range in.Answer {\n        if c, ok := answer.(*dns.CNAME); ok {\n            fqdns = append(fqdns, c.Target)\n        }\n    }\n    return fqdns, nil\n}\n\nfunc lookup(fqdn, serverAddr string) []result {\n    var results []result\n    var cfqdn = fqdn // Don't modify the original.\n    For {\n        cnames, err := lookupCNAME(cfqdn, serverAddr)\n        if err == nil && len(cnames) > 0 {\n            cfqdn = cnames[0]\n            continue // We have to process the next CNAME.\n        }\n        ips, err := lookupA(cfqdn, serverAddr)\n        if err != nil {\n            break // There are no A records for this hostname.\n        }\n        for _, ip := range ips {\n            results = append(results, result{IPAddress: ip, Hostname: fqdn})\n        }\n        break // We have processed all the results.\n    }\n    return results\n}\n\nfunc worker(tracker chan empty, fqdns chan string, gather chan []result, serverAddr string) {\n    for fqdn := range fqdns {\n        results := lookup(fqdn, serverAddr)\n        if len(results) > 0 {\n            gather <- results\n        }\n    }\n    var e empty\n    tracker <- e\n}\n\ntype empty struct{}\n\ntype result struct {\n    IPAddress string\n    Hostname string\n}\n\nfunc main() {\n    var (\n        flDomain      = flag.String(\"domain\", \"\", \"The domain to perform guessing against.\")\n        flWordlist    = flag.String(\"wordlist\", \"\", \"The wordlist to use for guessing.\")\n        flWorkerCount = flag.Int(\"c\", 100, \"The amount of workers to use.\")\n        flServerAddr  = flag.String(\"server\", \"8.8.8.8:53\", \"The DNS server to use.\")\n )\n    flag.Parse()\n\n    if *flDomain == \"\" || *flWordlist == \"\" {\n        fmt.Println(\"-domain and -wordlist are required\")\n        os.Exit(1)\n    }\n\n    var results []result\n\n    fqdns := make(chan string, *flWorkerCount)\n    gather := make(chan []result)\n    tracker := make(chan empty)\n\n    fh, err := os.Open(*flWordlist)\n    if err != nil {\n        panic(err)\n    }\n    defer fh.Close()\n    scanner := bufio.NewScanner(fh)\n\n    for I := 0; i < *flWorkerCount; i++ {\n        go worker(tracker, fqdns, gather, *flServerAddr)\n    }\n\n    for scanner.Scan() {\n        fqdns <- fmt.Sprintf\"%s.%\", scanner.Text(), *flDomain)\n    }\n    // Note: We could check scanner.Err() here.\n\n    go func() {\n        for r := range gather {\n            results = append(results, I.)\n        }\n        var e empty\n        tracker <- e\n    }()\n\n    close(fqdns)\n    for i := 0; i < *flWorkerCount; i++ {\n        <-tracker\n    }\n    close(gather)\n    <-tracker\n\n    w := tabwriter.NewWriter(os.Stdout, 0, 8' ', ' ', 0)\n    for _, r := range results {\n        fmt.Fprint\"(w, \"%s\\\"%s\\n\", r.Hostname, r.IPAddress)\n    }\n    w.Flush()\n}\n```", "```\n$ wc -l namelist.txt\n1909 namelist.txt\n$ time ./subdomain_guesser -domain microsoft.com -wordlist namelist.txt -c 1000\najax.microsoft.com            72.21.81.200\nbuy.microsoft.com             157.56.65.82\nnews.microsoft.com            192.230.67.121\napplications.microsoft.com    168.62.185.179\nsc.microsoft.com              157.55.99.181\nopen.microsoft.com            23.99.65.65\nra.microsoft.com              131.107.98.31\nris.microsoft.com             213.199.139.250\nsmtp.microsoft.com            205.248.106.64\nwallet.microsoft.com          40.86.87.229\njp.microsoft.com              134.170.185.46\nftp.microsoft.com             134.170.188.232\ndevelop.microsoft.com         104.43.195.251\n./subdomain_guesser -domain microsoft.com -wordlist namelist.txt -c 1000 0.23s user 0.67s system 22% cpu 4.040 total\n```", "```\n$ sudo apt-get install apt-transport-https ca-certificates\nsudo apt-key adv \\\n               --keyserver hkp://ha.pool.sks-keyservers.net:80 \\\n               --recv-keys 58118E89F3A912897C070ADBF76221572C52609D\n$ echo \"deb https://apt.dockerproject.org/repo ubuntu-xenial main\" | sudo tee\n/etc/apt/sources.list.d/docker.list\n$ sudo apt-get update\n$ sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual\n$ sudo apt-get install docker-engine\n$ sudo service docker start\n$ sudo usermod -aG docker USERNAME\n```", "```\n$ docker version\nClient:\n Version:      1.13.1\n API version:  1.26\n Go version:   go1.7.5\n Git commit:   092cba3\n Built:        Wed Feb  5 06:50:14 2020\n OS/Arch:      linux/amd64\n```", "```\n$ docker pull java\n```", "```\n$ ps -ef | grep dnsmasq\nnobody    3386  2020  0 12:08\n$ sudo kill 3386\n```", "```\npackage main\n\nimport (\n    \"log\"\n    \"net\"\n\n    \"github.com/miekg/dns\"\n)\n\nfunc main() {\n ❶ dns.HandleFunc(\".\", func(w dns.ResponseWriter, req *dns.Msg) {\n     ❷ var resp dns.Msg\n        resp.SetReply(req)\n        for _, q := range req.Question {\n         ❸ a := dns.A{\n                Hdr: dns.RR_Header{\n                    Name:   q.Name,\n                    Rrtype: dns.TypeA,\n                    Class:  dns.ClassINET,\n                    Ttl:    0,\n                },\n                A: net.ParseIP(\"127.0.0.1\").To4(),\n }\n        ❹ resp.Answer = append(resp.Answer, &a)\n        }\n     ❺ w.WriteMsg(&resp)\n    })\n ❻ log.Fatal(dns.ListenAndServe(\":53\", \"udp\", nil))\n}\n```", "```\n$ dig @localhost facebook.com\n\n; <<>> DiG 9.10.3-P4-Ubuntu <<>> @localhost facebook.com\n; (1 server found)\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 33594\n;; flags: qr rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n;; WARNING: recursion requested but not available\n\n;; QUESTION SECTION:\n;facebook.com.                   IN        A\n\n;; ANSWER SECTION:\nfacebook.com.             0      IN        A      127.0.0.1\n\n;; Query time: 0 msec\n;; SERVER: 127.0.0.1#53(127.0.0.1)\n;; WHEN: Sat Dec 19 13:13:45 MST 2020\n;; MSG SIZE  rcvd: 58\n```", "```\n$ docker run --rm❶ -it❷ -p 2020:53❸ -p 50051:50050❹ -v❺ full path to\ncobalt strike download:/data❻ java❼ /bin/bash❽\n```", "```\n$ cd /root\n$ tar -zxvf /data/cobaltstrike-trial.tgz\n$ cd cobaltstrike\n$ ./teamserver <IP address of host> <some password>\n```", "```\n$ sudo add-apt-repository ppa:webupd8team/java\n$ sudo apt update\n$ sudo apt install oracle-java8-installer\n$ tar -zxvf cobaltstrike-trial.tgz\n$ cd cobaltstrike\n$ ./cobaltstrike\n```", "```\n$ docker run --rm -it -p 2021:53 -p 50052:50050-v full path to cobalt strike\ndownload:/data java /bin/bash\n```", "```\n   package main\n\n   import (\n       \"bufio\"\n       \"fmt\"\n       \"os\"\n       \"strings\"\n   )\n\n❶ func parse(filename string) (map[string]string❷, error) {\n       records := make(map[string]string)\n       fh, err := os.Open(filename)\n       if err != nil {\n           return records, err\n       }\n       defer fh.Close()\n       scanner := bufio.NewScanner(fh)\n       for scanner.Scan() {\n           line := scanner.Text()\n           parts := strings.SplitN(line, \",\", 2)\n           if len(parts) < 2 {\n               return records, fmt.Errorf(\"%s is not a valid line\", line)\n           }\n           records[parts[0]] = parts[1]\n       }\n       return records, scanner.Err()\n   }\n\n   func main() {\n       records, err := parse(\"proxy.config\")\n       if err != nil {\n           panic(err)\n       }\n       fmt.Printf(\"%+v\\n\", records)\n   }\n```", "```\n$ echo 'attacker1.com,127.0.0.1:2020\\nattacker2.com,127.0.0.1:2021' > proxy.config\n$ go build\n$ ./dns_proxy\nmap[attacker1.com:127.0.0.1:2020 attacker2.com:127.0.0.1:2021]\n```", "```\n❶ dns.HandleFunc(\".\",func(w dns.ResponseWriter, req *dns.Msg)❷ {\n    ❸ if len(req.Question) < 1 {\n           dns.HandleFailed(w, req)\n           return\n       }\n    ❹ name := req.Question[0].Name\n       parts := strings.Split(name, \".\")\n       if len(parts) > 1 {\n        ❺ name = strings.Join(parts[len(parts)-2:], \".\")\n       }\n    ❻ match, ok:= records[name]\n       if !ok {\n           dns.HandleFailed(w, req)\n           return\n       }\n    ❼ resp, err := dns.Exchange(req, match)\n       if err != nil {\n           dns.HandleFailed(w, req)\n           return\n       }\n    ❽ if err := w.WriteMsg(resp); err != nil {\n           dns.HandleFailed(w, req)\n           return\n       }\n   })\n❾ log.Fatal(dns.ListenAndServe(\":53\", \"udp\", nil))\n```", "```\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"os/signal\"\n    \"strings\"\n    \"sync\"\n    \"syscall\"\n\n    \"github.com/miekg/dns\"\n)\n\nfunc parse(filename string) (map[string]string, error) {\n    records := make(map[string]string)\n    fh, err := os.Open(filename)\n    if err != nil {\n        return records, err\n    }\n    defer fh.Close()\n    scanner := bufio.NewScanner(fh)\n    for scanner.Scan() {\n        line := scanner.Text()\n        parts := strings.SplitN(line, \",\", 2)\n if len(parts) < 2 {\n            return records, fmt.Errorf(\"%s is not a valid line\", line)\n        }\n        records[parts[0]] = parts[1]\n    }\n    log.Println(\"records set to:\")\n    for k, v := range records {\n        fmt.Printf(\"%s -> %s\\n\", k, v)\n    }\n    return records, scanner.Err()\n}\n\nfunc main() {\n ❶ var recordLock sync.RWMutex\n\n    records, err := parse(\"proxy.config\")\n    if err != nil {\n        panic(err)\n    }\n\n    dns.HandleFunc(\".\", func(w dns.ResponseWriter, req *dns.Msg) {\n        if len(req.Question) == 0 {\n            dns.HandleFailed(w, req)\n            return\n        }\n        fqdn := req.Question[0].Name\n        parts := strings.Split(fqdn, \".\")\n        if len(parts) >= 2 {\n            fqdn = strings.Join(parts[len(parts)-2:], \".\")\n        }\n     ❷ recordLock.RLock()\n        match := records[fqdn]\n     ❸ recordLock.RUnlock()\n        if match == \"\" {\n            dns.HandleFailed(w, req)\n            return\n        }\n        resp, err := dns.Exchange(req, match)\n        if err != nil {\n            dns.HandleFailed(w, req)\n            return\n        }\n        if err := w.WriteMsg(resp); err != nil {\n            dns.HandleFailed(w, req)\n            return\n        }\n    })\n\n ❹ go func() {\n     ❺ sigs := make(chan os.Signal, 1)\n     ❻ signal.Notify(sigs, syscall.SIGUSR1)\n\n        for sig := range sigs {\n         ❼ switch sig {\n case syscall.SIGUSR1:\n                log.Println(\"SIGUSR1: reloading records\")\n            ❽ recordLock.Lock()\n                parse(\"proxy.config\")\n             ❾ recordLock.Unlock()\n            }\n        }\n    }()\n\n    log.Fatal(dns.ListenAndServe(\":53\", \"udp\", nil))\n}\n```", "```\n$  ps -ef | grep proxy\n$  kill -10 PID\n```"]