["```\n#include <string>\n#include <filesystem>\n\nTEST_CASE(\"std::filesystem::path supports == and .empty()\") {\n  std::filesystem::path empty_path; ➊\n  std::filesystem::path shadow_path{ \"/etc/shadow\" }; ➋\n  REQUIRE(empty_path.empty()); ➌\n  REQUIRE(shadow_path == std::string{ \"/etc/shadow\" }); ➍\n}\n```", "```\n#include <iostream>\n#include <filesystem>\n\nusing namespace std;\n\nint main() {\n  const filesystem::path kernel32{ R\"(C:\\Windows\\System32\\kernel32.dll)\" }; ➊\n  cout << \"Root name: \" << kernel32.root_name() ➋\n    << \"\\nRoot directory: \" << kernel32.root_directory() ➌\n    << \"\\nRoot path: \" << kernel32.root_path() ➍\n    << \"\\nRelative path: \" << kernel32.relative_path() ➎\n    << \"\\nParent path: \" << kernel32.parent_path() ➏\n    << \"\\nFilename: \" << kernel32.filename() ➐\n    << \"\\nStem: \" << kernel32.stem() ➑\n    << \"\\nExtension: \" << kernel32.extension() ➒\n    << endl;\n}\n-----------------------------------------------------------------------\nRoot name: \"C:\" ➋\nRoot directory: \"\\\\\" ➌\nRoot path: \"C:\\\\\" ➍\nRelative path: \"Windows\\\\System32\\\\kernel32.dll\" ➎\nParent path: \"C:\\\\Windows\\\\System32\" ➏\nFilename: \"kernel32.dll\" ➐\nStem: \"kernel32\" ➑\nExtension: \".dll\" ➒\n```", "```\n#include <iostream>\n#include <filesystem>\n\nusing namespace std;\n\nint main() {\n  filesystem::path path{ R\"(C:/Windows/System32/kernel32.dll)\" };\n  cout << path << endl; ➊\n\n  path.make_preferred();\n  cout << path << endl; ➋\n\n  path.replace_filename(\"win32kfull.sys\");\n  cout << path << endl; ➌\n\n  path.remove_filename();\n  cout << path << endl; ➍\n\n  path.clear();\n  cout << \"Is empty: \" << boolalpha << path.empty() << endl; ➎\n}\n-----------------------------------------------------------------------\n\"C:/Windows/System32/kernel32.dll\" ➊\n\"C:\\\\Windows\\\\System32\\\\kernel32.dll\" ➋\n\"C:\\\\Windows\\\\System32\\\\win32kfull.sys\" ➌\n\"C:\\\\Windows\\\\System32\\\\\" ➍\nIs empty: true ➎\n```", "```\n#include <filesystem>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n  try {\n    const auto temp_path = filesystem::temp_directory_path(); ➊\n    const auto relative = filesystem::relative(temp_path); ➋\n    cout << boolalpha\n      << \"Temporary directory path: \" << temp_path ➌\n      << \"\\nTemporary directory absolute: \" << temp_path.is_absolute() ➍\n      << \"\\nCurrent path: \" << filesystem::current_path() ➎\n      << \"\\nTemporary directory's relative path: \" << relative ➏\n      << \"\\nRelative directory absolute: \" << relative.is_absolute() ➐\n      << \"\\nChanging current directory to temp.\";\n    filesystem::current_path(temp_path); ➑\n    cout << \"\\nCurrent directory: \" << filesystem::current_path(); ➒\n  } catch(const exception& e) {\n    cerr << \"Error: \" << e.what(); ➓\n  }\n}\n-----------------------------------------------------------------------\nTemporary directory path: \"C:\\\\Users\\\\lospi\\\\AppData\\\\Local\\\\Temp\\\\\" ➌\nTemporary directory absolute: true ➍\nCurrent path: \"c:\\\\Users\\\\lospi\\\\Desktop\" ➎\nTemporary directory's relative path: \"..\\\\AppData\\\\Local\\\\Temp\" ➏\nRelative directory absolute: false ➐\nChanging current directory to temp. ➑\nCurrent directory: \"C:\\\\Users\\\\lospi\\\\AppData\\\\Local\\\\Temp\" ➒\n```", "```\n#include <iostream>\n#include <filesystem>\n\nusing namespace std;\n\nvoid describe(const filesystem::path& p) { ➊\n  cout << boolalpha << \"Path: \" << p << endl;\n  try {\n    cout << \"Is directory: \" << filesystem::is_directory(p) << endl; ➋\n cout << \"Is regular file: \" << filesystem::is_regular_file(p) << endl; ➌\n  } catch (const exception& e) {\n    cerr << \"Exception: \" << e.what() << endl;\n  }\n}\n\nint main() {\n  filesystem::path win_path{ R\"(C:/Windows/System32/kernel32.dll)\" };\n  describe(win_path); ➍\n  win_path.remove_filename();\n  describe(win_path); ➎\n\n  filesystem::path nix_path{ R\"(/bin/bash)\" };\n  describe(nix_path); ➏\n  nix_path.remove_filename();\n  describe(nix_path); ➐\n}\n```", "```\nPath: \"C:/Windows/System32/kernel32.dll\" ➍\nIs directory: false ➍\nIs regular file: true ➍\nPath: \"C:/Windows/System32/\" ➎\nIs directory: true ➎\nIs regular file: false ➎\nPath: \"/bin/bash\" ➏\nIs directory: false ➏\nIs regular file: false ➏\nPath: \"/bin/\" ➐\nIs directory: false ➐\nIs regular file: false ➐\n```", "```\nPath: \"C:/Windows/System32/kernel32.dll\" ➍\nIs directory: false ➍\nIs regular file: false ➍\nPath: \"C:/Windows/System32/\" ➎\nIs directory: false ➎\nIs regular file: false ➎\nPath: \"/bin/bash\" ➏\nIs directory: false ➏\nIs regular file: true ➏\nPath: \"/bin/\" ➐\nIs directory: true ➐\nIs regular file: false ➐\n```", "```\n#include <iostream>\n#include <filesystem>\n\nusing namespace std;\nusing namespace std::filesystem;\nusing namespace std::chrono;\n void write_info(const path& p) {\n  if (!exists(p)) { ➊\n    cout << p << \" does not exist.\" << endl;\n    return;\n  }\n  const auto last_write = last_write_time(p).time_since_epoch();\n  const auto in_hours = duration_cast<hours>(last_write).count();\n  cout << p << \"\\t\" << in_hours << \"\\t\" << file_size(p) << \"\\n\"; ➋\n}\n\nint main() {\n  const path win_path{ R\"(C:/Windows/System32/kernel32.dll)\" }; ➌\n  const auto reamde_path = temp_directory_path() / \"REAMDE\"; ➍\n  try {\n    write_info(win_path); ➎\n    write_info(reamde_path); ➏\n\n    cout << \"Copying \" << win_path.filename()\n         << \" to \" << reamde_path.filename() << \"\\n\";\n    copy_file(win_path, reamde_path);\n    write_info(reamde_path); ➐\n\n    cout << \"Resizing \" << reamde_path.filename() << \"\\n\";\n    resize_file(reamde_path, 1024);\n    write_info(reamde_path); ➑\n\n    cout << \"Removing \" << reamde_path.filename() << \"\\n\";\n    remove(reamde_path);\n    write_info(reamde_path); ➒\n  } catch(const exception& e) {\n    cerr << \"Exception: \" << e.what() << endl;\n  }\n}\n-----------------------------------------------------------------------\n\"C:/Windows/System32/kernel32.dll\"      3657767 720632 ➎\n\"C:\\\\Users\\\\lospi\\\\AppData\\\\Local\\\\Temp\\\\REAMDE\" does not exist. ➏\nCopying \"kernel32.dll\" to \"REAMDE\"\n\"C:\\\\Users\\\\lospi\\\\AppData\\\\Local\\\\Temp\\\\REAMDE\"        3657767 720632 ➐\nResizing \"REAMDE\"\n\"C:\\\\Users\\\\lospi\\\\AppData\\\\Local\\\\Temp\\\\REAMDE\"        3659294 1024 ➑\nRemoving \"REAMDE\"\n\"C:\\\\Users\\\\lospi\\\\AppData\\\\Local\\\\Temp\\\\REAMDE\" does not exist. ➒\n```", "```\n#include <iostream>\n#include <filesystem>\n#include <iomanip>\n\nusing namespace std;\nusing namespace std::filesystem;\nusing namespace std::chrono;\n\nvoid describe(const directory_entry& entry) { ➊\n  try {\n    if (entry.is_directory()) { ➋\n      cout << \"           *\";\n    } else {\n      cout << setw(12) << entry.file_size();\n    }\n    const auto lw_time =\n      duration_cast<seconds>(entry.last_write_time().time_since_epoch());\n    cout << setw(12) << lw_time.count()\n      << \" \" << entry.path().filename().string()\n      << \"\\n\"; ➌\n  } catch (const exception& e) {\n    cout << \"Error accessing \" << entry.path().string()\n         << \": \" << e.what() << endl; ➍\n  }\n}\n\nint main(int argc, const char** argv) {\n  if (argc != 2) {\n    cerr << \"Usage: listdir PATH\";\n    return -1; ➎\n  }\n  const path sys_path{ argv[1] }; ➏\n  cout << \"Size         Last Write  Name\\n\";\n  cout << \"------------ ----------- ------------\\n\"; ➐\n  for (const auto& entry : directory_iterator{ sys_path }) ➑\n    describe(entry); ➒\n}\n-----------------------------------------------------------------------\n> listdir c:\\Windows\nSize         Last Write  Name\n------------ ----------- ------------\n * 13177963504 addins\n * 13171360979 appcompat\n--snip--\n * 13173551028 WinSxS\n 316640 13167963236 WMSysPr9.prx\n 11264 13167963259 write.exe\n```", "```\n#include <iostream>\n#include <filesystem>\n\nusing namespace std;\nusing namespace std::filesystem;\n\nstruct Attributes {\n  Attributes& operator+=(const Attributes& other) {\n    this->size_bytes += other.size_bytes;\n    this->n_directories += other.n_directories;\n    this->n_files += other.n_files;\n    return *this;\n  }\n  size_t size_bytes;\n  size_t n_directories;\n  size_t n_files;\n}; ➊\n\nvoid print_line(const Attributes& attributes, string_view path) {\n  cout << setw(14) << attributes.size_bytes\n       << setw(7) << attributes.n_files\n       << setw(7) << attributes.n_directories\n       << \" \" << path << \"\\n\"; ➋\n}\n\nAttributes explore(const directory_entry& directory) {\n  Attributes attributes{};\n  for(const auto& entry : recursive_directory_iterator{ directory.path() }) { ➌\n      if (entry.is_directory()) {\n        attributes.n_directories++; ➍\n      } else {\n        attributes.n_files++;\n attributes.size_bytes += entry.file_size(); ➎\n      }\n  }\n  return attributes;\n}\n\nint main(int argc, const char** argv) {\n  if (argc != 2) {\n    cerr << \"Usage: treedir PATH\";\n    return -1; ➏\n  }\n  const path sys_path{ argv[1] };\n  cout << \"Size           Files  Dirs   Name\\n\";\n  cout << \"-------------- ------ ------ ------------\\n\";\n  Attributes root_attributes{};\n  for (const auto& entry : directory_iterator{ sys_path }) { ➐\n    try {\n      if (entry.is_directory()) {\n        const auto attributes = explore(entry); ➑\n        root_attributes += attributes;\n        print_line(attributes, entry.path().string());\n        root_attributes.n_directories++;\n      } else {\n        root_attributes.n_files++;\n        error_code ec;\n        root_attributes.size_bytes += entry.file_size(ec); ➒\n        if (ec) cerr << \"Error reading file size: \"\n                     << entry.path().string() << endl;\n      }\n    } catch(const exception&) {\n    }\n  }\n  print_line(root_attributes, argv[1]); ➓\n}\n-----------------------------------------------------------------------\n> treedir C:\\Windows\nSize         Files  Dirs Name\n------------ ----- ----- ------------\n 802      1      0 C:\\Windows\\addins\n 8267330      9      5 C:\\Windows\\apppatch\n--snip--\n 11396916465  73383  20480 C:\\Windows\\WinSxS\n 21038460348 110950  26513 C:\\Windows ➓\n```", "```\n#include <iostream>\n#include <fstream>\n#include <filesystem>\n#include <unordered_set>\n\nusing namespace std;\nusing namespace std::filesystem;\n\nint main(int argc, const char** argv) {\n  if (argc != 2) {\n    cerr << \"Usage: pecheck PATH\";\n    return -1; ➊\n  }\n  const unordered_set<string> pe_extensions{\n    \".acm\", \".ax\",  \".cpl\", \".dll\", \".drv\",\n    \".efi\", \".exe\", \".mui\", \".ocx\", \".scr\",\n    \".sys\", \".tsp\"\n  }; ➋\n  const path sys_path{ argv[1] };\n  cout << \"Searching \" << sys_path << \" recursively.\\n\";\n  size_t n_searched{};\n  auto iterator = recursive_directory_iterator{ sys_path,\n                                 directory_options::skip_permission_denied }; ➌\n  for (const auto& entry : iterator) { ➍\n    try {\n if (!entry.is_regular_file()) continue;\n      const auto& extension = entry.path().extension().string();\n      const auto is_pe = pe_extensions.find(extension) != pe_extensions.end();\n      if (!is_pe) continue; ➎\n      ifstream file{ entry.path() }; ➏\n      char first{}, second{};\n      if (file) file >> first;\n      if (file) file >> second; ➐\n      if (first != 'M' || second != 'Z')\n        cout << \"Invalid PE found: \" << entry.path().string() << \"\\n\"; ➑\n      ++n_searched;\n    } catch(const exception& e) {\n      cerr << \"Error reading \" << entry.path().string()\n           << \": \" << e.what() << endl;\n    }\n  }\n  cout << \"Searched \" << n_searched << \" PEs for magic bytes.\" << endl; ➒\n}\n----------------------------------------------------------------------\nlisting_17_9.exe c:\\Windows\\System32\nSearching \"c:\\\\Windows\\\\System32\" recursively.\nSearched 8231 PEs for magic bytes.\n```"]