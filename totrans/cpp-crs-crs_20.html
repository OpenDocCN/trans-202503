<html><head></head><body>
<h2 class="h2" id="ch17"><span epub:type="pagebreak" id="page_551"/><strong><span class="big">17</span><br/>FILESYSTEMS</strong></h2>&#13;
<p class="quote"><em>“So, you’re the UNIX guru.” At the time, Randy was still stupid enough to be flattered by this attention, when he should have recognized them as bone-chilling words.<br/>—Neal Stephenson</em>, Cryptonomicon</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">This chapter teaches you how to use the stdlib’s Filesystem library to perform operations on filesystems, such as manipulating and inspecting files, enumerating directories, and interoperating with file streams.</p>&#13;
<p class="indent">The stdlib and Boost contain Filesystem libraries. The stdlib’s Filesystem library grew out of Boost’s, and accordingly they’re largely interchangeable. This chapter focuses on the stdlib implementation. If you’re interested in learning more about Boost, refer to the Boost Filesystem documentation. Boost and stdlib’s implementations are mostly identical.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The C++ Standard has a history of subsuming Boost libraries. This allows the C++ community to gain experience with new features in Boost before going through the more arduous process of including the features in the C++ Standard.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch17lev1sec1"><span epub:type="pagebreak" id="page_552"/><strong>Filesystem Concepts</strong></h3>&#13;
<p class="noindent">Filesystems model several important concepts. The central entity is the file. A <em>file</em> is a filesystem object that supports input and output and holds data. Files exist in containers called <em>directories</em>, which can be nested within other directories. For simplicity, directories are considered files. The directory containing a file is called that file’s <em>parent directory</em>.</p>&#13;
<p class="indent">A path is a string that identifies a specific file. Paths begin with an optional <em>root name</em>, which is an implementation-specific string, such as <em>C:</em> or <em>//localhost</em> on Windows followed by an optional root directory, which is another implementation-specific string, such as <code>/</code> on Unix-like systems. The remainder of the path is a sequence of directories separated by implementation-defined separators. Optionally, paths terminate in a non-directory file. Paths can contain the special names “<code>.</code>” and “<code>..</code>”, which mean current directory and parent directory, respectively.</p>&#13;
<p class="indent">A <em>hard link</em> is a directory entry that assigns a name to an existing file, and a <em>symbolic link</em> (or <em>symlink</em>) assigns a name to a path (which might or might not exist). A path whose location is specified in relation to another path (usually the current directory) is called a <em>relative path</em>, and a <em>canonical path</em> unambiguously identifies a file’s location, doesn’t contain the special names “<strong>.</strong>” and “<strong>..</strong>”, and doesn’t contain any symbolic links. An <em>absolute path</em> is any path that unambiguously identifies a file’s location. A major difference between a canonical path and an absolute path is that a canonical path cannot contain the special names “<strong>.</strong>” and “<strong>..</strong>”.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>The stdlib filesystem might not be available if the target platform doesn’t offer a hierarchical filesystem.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch17lev1sec2"><strong>std::filesystem::path</strong></h3>&#13;
<p class="noindent">The <code>std::filesystem::path</code> is the Filesystem library’s class for modeling a path, and you have many options for constructing paths. Perhaps the two most common are the default constructor, which constructs an empty path, and the constructor taking a string type, which creates the path indicated by the characters in the string. Like all other filesystem classes and functions, the <code>path</code> class resides in the <code>&lt;filesystem&gt;</code> header.</p>&#13;
<p class="indent">In this section, you’ll learn how to construct a path from a <code>string</code> representation, decompose it into constituent parts, and modify it. In many common system- and application-programming contexts, you’ll need to interact with files. Because each operating system has a unique representation for filesystems, the stdlib’s Filesystem library is a welcome abstraction that allows you to write cross-platform code easily.</p>&#13;
<h4 class="h4" id="ch17lev2sec1"><strong><em>Constructing Paths</em></strong></h4>&#13;
<p class="noindent">The <code>path</code> class supports comparison with other <code>path</code> objects and with <code>string</code> objects using the <code>operator==</code>. But if you just want to check whether the <code>path</code> is <span epub:type="pagebreak" id="page_553"/>empty, it offers an <code>empty</code> method that returns a Boolean. <a href="ch17.xhtml#ch17ex01">Listing 17-1</a> illustrates how to construct two <code>path</code>s (one empty and one non-empty) and test them.</p>&#13;
<pre>#include &lt;string&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
TEST_CASE("std::filesystem::path supports == and .empty()") {&#13;
  std::filesystem::path empty_path; <span class="ent">➊</span>&#13;
  std::filesystem::path shadow_path{ "/etc/shadow" }; <span class="ent">➋</span>&#13;
  REQUIRE(empty_path.empty()); <span class="ent">➌</span>&#13;
  REQUIRE(shadow_path == std::string{ "/etc/shadow" }); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch17ex01"/><em>Listing 17-1: Constructing <code>std::filesystem::path</code></em></p>&#13;
<p class="indent">You construct two paths: one with the default constructor <span class="ent">➊</span> and one referring to <code>/etc/shadow</code> <span class="ent">➋</span>. Because you default construct it, the <code>empty</code> method of <code>empty_path</code> returns <code>true</code> <span class="ent">➌</span>. The <code>shadow_path</code> equals a <code>string</code> containing <code>/etc/shadow</code>, because you construct it with the same contents <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch17lev2sec2"><strong>Decomposing Paths</strong></h4>&#13;
<p class="noindent">The <code>path</code> class contains some decomposition methods that are, in effect, specialized string manipulators that allow you to extract components of the path, for example:</p>&#13;
<ul>&#13;
<li class="noindent"><code>root_name()</code> returns the root name.</li>&#13;
<li class="noindent"><code>root_directory()</code> returns the root directory.</li>&#13;
<li class="noindent"><code>root_path()</code> returns the root path.</li>&#13;
<li class="noindent"><code>relative_path()</code> returns a path relative to the root.</li>&#13;
<li class="noindent"><code>parent_path()</code> returns the parent path.</li>&#13;
<li class="noindent"><code>filename()</code> returns the filename component.</li>&#13;
<li class="noindent"><code>stem()</code> returns the filename stripped of its extension.</li>&#13;
<li class="noindent"><code>extension()</code> returns the extension.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch17.xhtml#ch17ex02">Listing 17-2</a> provides the values returned by each of these methods for a path pointing to a very important Windows system library, <code>kernel32.dll</code>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  const filesystem::path kernel32{ R"(C:\Windows\System32\kernel32.dll)" }; <span class="ent">➊</span>&#13;
  cout &lt;&lt; "Root name: " &lt;&lt; kernel32.root_name() <span class="ent">➋</span>&#13;
    &lt;&lt; "\nRoot directory: " &lt;&lt; kernel32.root_directory() <span class="ent">➌</span>&#13;
    &lt;&lt; "\nRoot path: " &lt;&lt; kernel32.root_path() <span class="ent">➍</span>&#13;
    &lt;&lt; "\nRelative path: " &lt;&lt; kernel32.relative_path() <span class="ent">➎</span>&#13;
    &lt;&lt; "\nParent path: " &lt;&lt; kernel32.parent_path() <span class="ent">➏</span>&#13;
    &lt;&lt; "\nFilename: " &lt;&lt; kernel32.filename() <span class="ent">➐</span>&#13;
    &lt;&lt; "\nStem: " &lt;&lt; kernel32.stem() <span class="ent">➑</span>&#13;
    &lt;&lt; "\nExtension: " &lt;&lt; kernel32.extension() <span class="ent">➒</span>&#13;
    &lt;&lt; endl;&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Root name: "C:" <span class="ent">➋</span></span>&#13;
<span class="color1">Root directory: "\\" <span class="ent">➌</span></span>&#13;
<span class="color1">Root path: "C:\\" <span class="ent">➍</span></span>&#13;
<span class="color1">Relative path: "Windows\\System32\\kernel32.dll" <span class="ent">➎</span></span>&#13;
<span class="color1">Parent path: "C:\\Windows\\System32" <span class="ent">➏</span></span>&#13;
<span class="color1">Filename: "kernel32.dll" <span class="ent">➐</span></span>&#13;
<span class="color1">Stem: "kernel32" <span class="ent">➑</span></span>&#13;
<span class="color1">Extension: ".dll" <span class="ent">➒</span></span></pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_554"/><a id="ch17ex02"/><em>Listing 17-2: A program printing various decompositions of a path</em></p>&#13;
<p class="indent">You construct a path to kernel32 using a raw string literal to avoid having to escape the backslashes <span class="ent">➊</span>. You extract the root name <span class="ent">➋</span>, the root directory <span class="ent">➌</span>, and the root path of kernel32 <span class="ent">➍</span> and output them to stdout. Next, you extract the relative path, which displays the path relative to the root <code>C:\</code> <span class="ent">➎</span>. The parent path is the path of <code>kernel32.dll</code>’s parent, which is simply the directory containing it <span class="ent">➏</span>. Finally, you extract the filename <span class="ent">➐</span>, its stem <span class="ent">➑</span>, and its extension <span class="ent">➒</span>.</p>&#13;
<p class="indent">Notice that you don’t need to run <a href="ch17.xhtml#ch17ex02">Listing 17-2</a> on any particular operating system. None of the decomposition methods require that the path actually point to an existing file. You simply extract components of the path’s contents, not the pointed-to file. Of course, different operating systems will yield different results, especially with respect to the delimiters (which are, for example, forward slashes on Linux).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em><a href="ch17.xhtml#ch17ex02">Listing 17-2</a> illustrates that <code>std::filesystem::path</code> has an <code>operator&lt;&lt;</code> that prints quotation marks at the beginning and end of its path. Internally, it uses <code>std::quoted</code>, a class template in the <span class="codeitalic">&lt;iomanip&gt;</span> header that facilitates the insertion and extraction of quoted strings. Also, recall that you must escape the backslash in a string literal, which is why you see two rather than one in the paths embedded in the source code.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch17lev2sec3"><strong><em>Modifying Paths</em></strong></h4>&#13;
<p class="noindent">In addition to decomposition methods, <code>path</code> offers several <em>modifier methods</em>, which allow you to modify various characteristics of a path:</p>&#13;
<ul>&#13;
<li class="noindent"><code>clear()</code> empties the <code>path</code>.</li>&#13;
<li class="noindent"><code>make_preferred()</code> converts all the directory separators to the implementation-preferred directory separator. For example, on Windows this converts the generic separator / to the system-preferred separator \.</li>&#13;
<li class="noindent"><code>remove_filename()</code> removes the filename portion of the path.</li>&#13;
<li class="noindent"><code>replace_filename(p)</code> replaces the <code>path’s</code> filename with that of another path <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_555"/><code>replace_extension(p)</code> replaces the <code>path’s</code> extension with that of another path <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><code>remove_extension()</code> removes the extension portion of the path.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch17.xhtml#ch17ex03">Listing 17-3</a> illustrates how to manipulate a path using several modifier methods.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  filesystem::path path{ R"(C:/Windows/System32/kernel32.dll)" };&#13;
  cout &lt;&lt; path &lt;&lt; endl; <span class="ent">➊</span>&#13;
&#13;
  path.make_preferred();&#13;
  cout &lt;&lt; path &lt;&lt; endl; <span class="ent">➋</span>&#13;
&#13;
  path.replace_filename("win32kfull.sys");&#13;
  cout &lt;&lt; path &lt;&lt; endl; <span class="ent">➌</span>&#13;
&#13;
  path.remove_filename();&#13;
  cout &lt;&lt; path &lt;&lt; endl; <span class="ent">➍</span>&#13;
&#13;
  path.clear();&#13;
  cout &lt;&lt; "Is empty: " &lt;&lt; boolalpha &lt;&lt; path.empty() &lt;&lt; endl; <span class="ent">➎</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">"C:/Windows/System32/kernel32.dll" <span class="ent">➊</span></span>&#13;
<span class="color1">"C:\\Windows\\System32\\kernel32.dll" <span class="ent">➋</span></span>&#13;
<span class="color1">"C:\\Windows\\System32\\win32kfull.sys" <span class="ent">➌</span></span>&#13;
<span class="color1">"C:\\Windows\\System32\\" <span class="ent">➍</span></span>&#13;
<span class="color1">Is empty: true <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch17ex03"/><em>Listing 17-3: Manipulating a path using modifier methods. (Output is from a Windows 10 x64 system.)</em></p>&#13;
<p class="indent">As in <a href="ch17.xhtml#ch17ex02">Listing 17-2</a>, you construct a <code>path</code> to kernel32, although this one is non-<code>const</code> because you’re about to modify it <span class="ent">➊</span>. Next, you convert all the directory separators to the system’s preferred directory separator using <code>make_preferred</code>. <a href="ch17.xhtml#ch17ex03">Listing 17-3</a> shows output from a Windows 10 x64 system, so it has converted from slashes (<code>/</code>) to backslashes (<code>\</code>) <span class="ent">➋</span>. Using <code>replace_file</code><code>name</code>, you replace the filename from <code>kernel32.dll</code> to <code>win32kfull.sys</code> <span class="ent">➌</span>. Notice again that the file described by this path doesn’t need to exist on your system; you’re just manipulating the path. Finally, you remove the filename using the <code>remove_filename</code> method <span class="ent">➍</span> and then empty the <code>path</code>’s contents entirely using clear <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch17lev2sec4"><strong><em>Summary of Filesystem Path Methods</em></strong></h4>&#13;
<p class="noindent"><a href="ch17.xhtml#ch17tab01">Table 17-1</a> contains a partial listing of the available methods of <code>path</code>. Note that <code>p</code>, <code>p1</code>, and <code>p2</code> are <code>path</code> objects and <code>s</code> is a <code>stream</code> in the table.</p>&#13;
<p class="tabcap" id="ch17tab01"><span epub:type="pagebreak" id="page_556"/><strong>Table 17-1:</strong> A Summary of <code>std::filestystem::path</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>path{}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs an empty path.</p></td></tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>Path{</code> <span class="codestrong">s</span><code>, [</code><span class="codestrong">f</span><code>] }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a path from the string type <span class="codestrong">s</span>; <span class="codestrong">f</span> is an optional <code>path::format</code> type that defaults to the implementation-defined pathname format.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><code>Path{</code> <span class="codestrong">p</span> <code>}</code></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <code>=</code> <span class="codestrong">p2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copy construction/assignment.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>Path{ move(</code><span class="codestrong">p</span><code>) }</code></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <code>= move(</code><span class="codestrong">p2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Move construction/assignment.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.assign(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Assigns <span class="codestrong">p</span> to <span class="codestrong">s</span>, discarding current contents.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.append(</code><span class="codestrong">s</span><code>)</code></p>&#13;
<p class="taba"><span class="codestrong">p</span> <code>/</code> <span class="codestrong">s</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Appends <span class="codestrong">s</span> to <span class="codestrong">p</span>, including the appropriate separator, <code>path::preferred_separator</code>.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.concat(</code><span class="codestrong">s</span><code>)</code></p>&#13;
<p class="taba"><span class="codestrong">p</span> <code>+</code> <span class="codestrong">s</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Appends <span class="codestrong">s</span> to <span class="codestrong">p</span> without including a separator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.clear()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Erases the contents.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.empty()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns true if <span class="codestrong">p</span> is empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.make_preferred()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Converts all the directory separators to the implementation-preferred directory separator.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.remove_filename()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the filename portion.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p1</span><code>.replace_filename(</code><span class="codestrong">p2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the filename of <span class="codestrong">p1</span> with that of <span class="codestrong">p2</span>.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p1</span><code>.replace_extension(</code><span class="codestrong">p2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the extension of <span class="codestrong">p1</span> with that of <span class="codestrong">p2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.root_name()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the root name.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.root_directory()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the root directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.root_path()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the root path.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.relative_path()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the relative path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.parent_path()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the parent path.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.filename()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the filename.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.stem()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the stem.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.extension()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the extension.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.has_root_name()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns true if <span class="codestrong">p</span> has a root name.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.has_root_directory()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns true if <span class="codestrong">p</span> has a root directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.has_root_path()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns true if <span class="codestrong">p</span> has a root path.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.has_relative_path()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns true if <span class="codestrong">p</span> has a relative path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.has_parent_path()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns true if <span class="codestrong">p</span> has a parent path.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.has_filename()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns true if <span class="codestrong">p</span> has a filename.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.has_stem()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns true if <span class="codestrong">p</span> has a stem.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.has_extension()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns true if <span class="codestrong">p</span> has an extension.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><code>.c_str()</code></p>&#13;
<p class="taba"><span class="codestrong">p</span><code>.native()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><span epub:type="pagebreak" id="page_557"/><p class="taba">Returns the native-string representation of <span class="codestrong">p</span>.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><code>.begin()</code></p>&#13;
<p class="taba"><span class="codestrong">p</span><code>.end()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Accesses the elements of a path sequentially as a half-open range.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span> <code>&lt;&lt;</code> <span class="codestrong">p</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Writes <span class="codestrong">p</span> into <span class="codestrong">s</span>.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span> <code>&gt;&gt;</code> <span class="codestrong">p</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Reads <span class="codestrong">s</span> into <span class="codestrong">p</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p1</span><code>.swap(</code><span class="codestrong">p2</span><code>)</code></p>&#13;
<p class="taba"><code>swap(</code><span class="codestrong">p1</span><code>,</code> <span class="codestrong">p2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Exchanges each element of <span class="codestrong">p1</span> with the elements of <span class="codestrong">p2</span>.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">p1</span> <code>==</code> <span class="codestrong">p2</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <code>!=</code> <span class="codestrong">p2</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <code>&gt;</code> <span class="codestrong">p2</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <code>&gt;=</code> <span class="codestrong">p2</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <code>&lt;</code> <span class="codestrong">p2</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <code>&lt;=</code> <span class="codestrong">p2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Lexicographically compares two paths <span class="codestrong">p1</span> and <span class="codestrong">p2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch17lev1sec3"><strong>Files and Directories</strong></h3>&#13;
<p class="noindent">The <code>path</code> class is the central element of the Filesystem library, but none of its methods actually interact with the filesystem. Instead, the <code>&lt;filesystem&gt;</code> header contains non-member functions to do this. Think of <code>path</code> objects as the way you declare which filesystem components you want to interact with and think of the <code>&lt;filesystem&gt;</code> header as containing the functions that perform work on those components.</p>&#13;
<p class="indent">These functions have friendly error-handling interfaces and allow you to break paths into, for example, directory name, filename, and extension. Using these functions, you have many tools for interacting with the files in your environment without having to use an operating-specific application programming interface.</p>&#13;
<h4 class="h4" id="ch17lev2sec5"><strong><em>Error Handling</em></strong></h4>&#13;
<p class="noindent">Interacting with the environment’s filesystem involves the potential for errors, such as files not found, insufficient permissions, or unsupported operations. Therefore, each non-member function in the Filesystem library that interacts with the filesystem must convey error conditions to the caller. These non-member functions provide two options: throw an exception or set an error variable.</p>&#13;
<p class="indent">Each function has two overloads: one that allows you to pass a reference to a <code>std::system_error</code> and one that omits this parameter. If you provide the reference, the function will set the <code>system_error</code> equal to an error condition, should one occur. If you don’t provide this reference, the function will throw a <code>std::filesystem::filesystem_error</code> (an exception type inheriting from <code>std::system_error</code>) instead.</p>&#13;
<h4 class="h4" id="ch17lev2sec6"><span epub:type="pagebreak" id="page_558"/><strong><em>Path-Composing Functions</em></strong></h4>&#13;
<p class="noindent">As an alternative to using the constructor of <code>path</code>, you can construct various kinds of paths:</p>&#13;
<ul>&#13;
<li class="noindent"><code>absolute(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> returns an absolute path referencing the same location as <span class="codestrong">p</span> but where <code>is_absolute()</code> is true.</li>&#13;
<li class="noindent"><code>canonical(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> returns a canonical path referencing the same location as <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><code>current_path([</code><span class="codestrong">ec</span><code>])</code> returns the current path.</li>&#13;
<li class="noindent"><code>relative(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">base</span><code>], [</code><span class="codestrong">ec</span><code>])</code> returns a path where <span class="codestrong">p</span> is made relative to <code>base</code>.</li>&#13;
<li class="noindent"><code>temp_directory_path([</code><span class="codestrong">ec</span><code>])</code> returns a directory for temporary files. The result is guaranteed to be an existing directory.</li>&#13;
</ul>&#13;
<p class="indent">Note that <code>current_path</code> supports an overload so you can set the current directory (as in <span class="codestrong">cd</span> or <span class="codestrong">chdir</span> on Posix). Simply provide a path argument, as in <code>current_path(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code>.</p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17ex04">Listing 17-4</a> illustrates several of these functions in action.</p>&#13;
<pre>#include &lt;filesystem&gt;&#13;
#include &lt;iostream&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  try {&#13;
    const auto temp_path = filesystem::temp_directory_path(); <span class="ent">➊</span>&#13;
    const auto relative = filesystem::relative(temp_path); <span class="ent">➋</span>&#13;
    cout &lt;&lt; boolalpha&#13;
      &lt;&lt; "Temporary directory path: " &lt;&lt; temp_path <span class="ent">➌</span>&#13;
      &lt;&lt; "\nTemporary directory absolute: " &lt;&lt; temp_path.is_absolute() <span class="ent">➍</span>&#13;
      &lt;&lt; "\nCurrent path: " &lt;&lt; filesystem::current_path() <span class="ent">➎</span>&#13;
      &lt;&lt; "\nTemporary directory's relative path: " &lt;&lt; relative <span class="ent">➏</span>&#13;
      &lt;&lt; "\nRelative directory absolute: " &lt;&lt; relative.is_absolute() <span class="ent">➐</span>&#13;
      &lt;&lt; "\nChanging current directory to temp.";&#13;
    filesystem::current_path(temp_path); <span class="ent">➑</span>&#13;
    cout &lt;&lt; "\nCurrent directory: " &lt;&lt; filesystem::current_path(); <span class="ent">➒</span>&#13;
  } catch(const exception&amp; e) {&#13;
    cerr &lt;&lt; "Error: " &lt;&lt; e.what(); <span class="ent">➓</span>&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Temporary directory path: "C:\\Users\\lospi\\AppData\\Local\\Temp\\" <span class="ent">➌</span></span>&#13;
<span class="color1">Temporary directory absolute: true <span class="ent">➍</span></span>&#13;
<span class="color1">Current path: "c:\\Users\\lospi\\Desktop" <span class="ent">➎</span></span>&#13;
<span class="color1">Temporary directory's relative path: "..\\AppData\\Local\\Temp" <span class="ent">➏</span></span>&#13;
<span class="color1">Relative directory absolute: false <span class="ent">➐</span></span>&#13;
<span class="color1">Changing current directory to temp. <span class="ent">➑</span></span>&#13;
<span class="color1">Current directory: "C:\\Users\\lospi\\AppData\\Local\\Temp" <span class="ent">➒</span></span></pre>&#13;
<p class="listing"><a id="ch17ex04"/><em>Listing 17-4: A program using several path composing functions. (Output is from a Windows 10 x64 system.)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_559"/>You construct a path using <code>temp_directory_path</code>, which returns the system’s directory for temporary files <span class="ent">➊</span>, and then use <code>relative</code> to determine its relative path <span class="ent">➋</span>. After printing the temporary path <span class="ent">➌</span>, <code>is_absolute</code> illustrates that this path is absolute <span class="ent">➍</span>. Next, you print the current path <span class="ent">➎</span> and the temporary directory’s path relative to the current path <span class="ent">➏</span>. Because this path is relative, <code>is_absolute</code> returns <code>false</code> <span class="ent">➐</span>. Once you change the path to the temporary path <span class="ent">➑</span>, you then print the current directory <span class="ent">➒</span>. Of course, your output will look different from the output in <a href="ch17.xhtml#ch17ex04">Listing 17-4</a>, and you might even get an <code>exception</code> if your system doesn’t support certain operations <span class="ent">➓</span>. (Recall the warning at the beginning of the chapter: the C++ Standard allows that some environments might not support some or all of the filesystem library.)</p>&#13;
<h4 class="h4" id="ch17lev2sec7"><strong><em>Inspecting File Types</em></strong></h4>&#13;
<p class="noindent">You can inspect a file’s attributes given a path by using the following functions:</p>&#13;
<ul>&#13;
<li class="noindent"><code>is_block_file(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> determines if <span class="codestrong">p</span> is a <em>block file</em>, a special file in some operating systems (for example, block devices in Linux that allow you to transfer randomly accessible data in fixed-size blocks).</li>&#13;
<li class="noindent"><code>is_character_file(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> determines if <span class="codestrong">p</span> is a <em>character file</em>, a special file in some operating systems (for example, character devices in Linux that allow you to send and receive single characters).</li>&#13;
<li class="noindent"><code>is_regular_file(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> determines <span class="codestrong">p</span> is a regular file.</li>&#13;
<li class="noindent"><code>is_symlink(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> determines if <span class="codestrong">p</span> is a symlink, which is a reference to another file or directory.</li>&#13;
<li class="noindent"><code>is_empty(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> determines if <span class="codestrong">p</span> is either an empty file or an empty directory.</li>&#13;
<li class="noindent"><code>is_directory(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> determines if <span class="codestrong">p</span> is a directory.</li>&#13;
<li class="noindent"><code>is_fifo(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> determines if <span class="codestrong">p</span> is a <em>named pipe</em>, a special kind of interprocess communication mechanism in many operating systems.</li>&#13;
<li class="noindent"><code>is_socket(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> determines if <span class="codestrong">p</span> is a <em>socket</em>, another special kind of interprocess communication mechanism in many operating systems.</li>&#13;
<li class="noindent"><code>is_other(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> determines if <span class="codestrong">p</span> is some kind of file other than a regular file, a directory, or a symlink.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch17.xhtml#ch17ex05">Listing 17-5</a> uses <code>is_directory</code> and <code>is_regular_file</code> to inspect four different paths.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
void describe(const filesystem::path&amp; p) { <span class="ent">➊</span>&#13;
  cout &lt;&lt; boolalpha &lt;&lt; "Path: " &lt;&lt; p &lt;&lt; endl;&#13;
  try {&#13;
    cout &lt;&lt; "Is directory: " &lt;&lt; filesystem::is_directory(p) &lt;&lt; endl; <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_560"/>    cout &lt;&lt; "Is regular file: " &lt;&lt; filesystem::is_regular_file(p) &lt;&lt; endl; <span class="ent">➌</span>&#13;
  } catch (const exception&amp; e) {&#13;
    cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; endl;&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  filesystem::path win_path{ R"(C:/Windows/System32/kernel32.dll)" };&#13;
  describe(win_path); <span class="ent">➍</span>&#13;
  win_path.remove_filename();&#13;
  describe(win_path); <span class="ent">➎</span>&#13;
&#13;
  filesystem::path nix_path{ R"(/bin/bash)" };&#13;
  describe(nix_path); <span class="ent">➏</span>&#13;
  nix_path.remove_filename();&#13;
  describe(nix_path); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch17ex05"/><em>Listing 17-5: A program inspecting four iconic Windows and Linux paths with <code>is_director</code><code>y</code> and <code>is_regular_file</code>.</em></p>&#13;
<p class="indent">On a Windows 10 x64 machine, running the program in <a href="ch17.xhtml#ch17ex05">Listing 17-5</a> yielded the following output:</p>&#13;
<pre>Path: "C:/Windows/System32/kernel32.dll" <span class="ent">➍</span>&#13;
Is directory: false <span class="ent">➍</span>&#13;
Is regular file: true <span class="ent">➍</span>&#13;
Path: "C:/Windows/System32/" <span class="ent">➎</span>&#13;
Is directory: true <span class="ent">➎</span>&#13;
Is regular file: false <span class="ent">➎</span>&#13;
Path: "/bin/bash" <span class="ent">➏</span>&#13;
Is directory: false <span class="ent">➏</span>&#13;
Is regular file: false <span class="ent">➏</span>&#13;
Path: "/bin/" <span class="ent">➐</span>&#13;
Is directory: false <span class="ent">➐</span>&#13;
Is regular file: false <span class="ent">➐</span></pre>&#13;
<p class="indent">And on an Ubuntu 18.04 x64 machine, running the program in <a href="ch17.xhtml#ch17ex05">Listing 17-5</a> yielded the following output:</p>&#13;
<pre>Path: "C:/Windows/System32/kernel32.dll" <span class="ent">➍</span>&#13;
Is directory: false <span class="ent">➍</span>&#13;
Is regular file: false <span class="ent">➍</span>&#13;
Path: "C:/Windows/System32/" <span class="ent">➎</span>&#13;
Is directory: false <span class="ent">➎</span>&#13;
Is regular file: false <span class="ent">➎</span>&#13;
Path: "/bin/bash" <span class="ent">➏</span>&#13;
Is directory: false <span class="ent">➏</span>&#13;
Is regular file: true <span class="ent">➏</span>&#13;
Path: "/bin/" <span class="ent">➐</span>&#13;
Is directory: true <span class="ent">➐</span>&#13;
Is regular file: false <span class="ent">➐</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_561"/>First, you define the <code>describe</code> function, which takes a single <code>path</code> <span class="ent">➊</span>. After printing the path, you also print whether the path is a directory <span class="ent">➋</span> or a regular file <span class="ent">➌</span>. Within <code>main</code>, you pass four different paths to <code>describe</code>:</p>&#13;
<ul>&#13;
<li class="noindent"><code>C:/Windows/System32/kernel32.dll</code> <span class="ent">➍</span></li>&#13;
<li class="noindent"><code>C:/Windows/System32/</code> <span class="ent">➎</span></li>&#13;
<li class="noindent"><code>/bin/bash</code> <span class="ent">➏</span></li>&#13;
<li class="noindent"><code>/bin/</code> <span class="ent">➐</span></li>&#13;
</ul>&#13;
<p class="indent">Note that the result is operating system specific.</p>&#13;
<h4 class="h4" id="ch17lev2sec8"><strong><em>Inspecting Files and Directories</em></strong></h4>&#13;
<p class="noindent">You can inspect various filesystem attributes using the following functions:</p>&#13;
<ul>&#13;
<li class="noindent"><code>current_path([</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">ec</span><code>])</code>, which, if <span class="codestrong">p</span> is provided, sets the program’s current path to <span class="codestrong">p</span>; otherwise, it returns the program’s current path.</li>&#13;
<li class="noindent"><code>exists(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> returns whether a file or directory exists at <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><code>equivalent(</code><span class="codestrong">p1, p2</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> returns whether <span class="codestrong">p1</span> and <span class="codestrong">p2</span> refer to the same file or directory.</li>&#13;
<li class="noindent"><code>file_size(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> returns the size in bytes of the regular file at <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><code>hard_link_count(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> returns the number of hard links for <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><code>last_write_time(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">t</span><code>] [</code><span class="codestrong">ec</span><code>])</code>, which, if <span class="codestrong">t</span><code>ec</code><code>t</code> is provided, sets <span class="codestrong">p</span>’s last modified time to <span class="codestrong">t</span>; otherwise, it returns the last time <span class="codestrong">p</span> was modified. (<span class="codestrong">t</span> is a <code>std::chrono::time_point</code>.)</li>&#13;
<li class="noindent"><code>permissions(</code><span class="codestrong">p, prm</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> sets <span class="codestrong">p</span>’s permissions. <span class="codestrong">prm</span> is of type <code>std::filesystem::perms</code>, which is an enum class modeled after POSIX permission bits. (Refer to [fs.enum.perms].)</li>&#13;
<li class="noindent"><code>read_symlink(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> returns the target of the symlink <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><code>space(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> returns space information about the filesystem <span class="codestrong">p</span> occupies in the form of a <code>std::filesystem::space_info</code>. This POD contains three fields: capacity (the total size), <code>free</code> (the free space), and <code>available</code> (the free space available to a non-privileged process). All are an unsigned integer type, measured in bytes.</li>&#13;
<li class="noindent"><code>status(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> returns the type and attributes of the file or directory <span class="codestrong">p</span> in the form of a <code>std::filesystem::file_status</code>. This class contains a <code>type</code> method that accepts no parameters and returns an object of type <code>std::filesystem::file_type</code>, which is an enum class that takes values describing a file’s type, such as <code>not_found, regular, directory</code>. The <code>symlink file_status</code> class also offers a <code>permissions</code> method that accepts no parameters and returns an object of type <code>std::filesystem::perms</code>. (Refer to [fs.class.file_status] for details.)</li>&#13;
<li class="noindent"><code>symlink_status(</code><span class="codestrong">p</span>, <code>[</code><span class="codestrong">ec</span><code>])</code> is like a status that won’t follow symlinks.</li>&#13;
</ul>&#13;
<p class="indent">If you’re familiar with Unix-like operating systems, you’ve no doubt used the <code>ls</code> (short for “list”) program many times to enumerate files and <span epub:type="pagebreak" id="page_562"/>directories. On DOS-like operating systems (including Windows), you have the analogous <code>dir</code> command. You’ll use several of these functions later in the chapter (in <a href="ch17.xhtml#ch17ex07">Listing 17-7</a>) to build your own simple listing program.</p>&#13;
<p class="indent">Now that you know how to inspect files and directories, let’s turn to how you can manipulate the files and directories your paths refer to.</p>&#13;
<h4 class="h4" id="ch17lev2sec9"><strong><em>Manipulating Files and Directories</em></strong></h4>&#13;
<p class="noindent">Additionally, the Filesystem library contains a number of methods for manipulating files and directories:</p>&#13;
<ul>&#13;
<li class="noindent"><code>copy(</code><span class="codestrong">p1, p2</span>, <code>[</code><span class="codestrong">opt</span><code>], [</code><span class="codestrong">ec</span><code>])</code> copies files or directories from <span class="codestrong">p1</span> to <span class="codestrong">p2</span>. You can provide a <code>std::filesystem::copy_options</code> <code>opt</code> to customize the behavior of <code>copy_file</code>. This <code>enum</code> class can take several values, including none (report an error if the destination already exists), <code>skip_existing</code> (to keep existing), <code>overwrite_existing</code> (to overwrite), and <code>update_existing</code> (to overwrite if <span class="codestrong">p1</span> is newer). (Refer to <strong>[</strong>fs.enum.copy.opts<strong>]</strong> for details.)</li>&#13;
<li class="noindent"><code>copy_file(</code><span class="codestrong">p1, p2</span>, <code>[</code><span class="codestrong">opt</span><code>], [</code><span class="codestrong">ec</span><code>])</code> is like copy except it will generate anerror if <span class="codestrong">p1</span> is anything but a regular file.</li>&#13;
<li class="noindent"><code>copy_file</code><code>(</code><span class="codestrong">p1</span><code>,</code> <span class="codestrong">p2</span><code>, [</code><span class="codestrong">opt</span><code>], [</code><span class="codestrong">ec</span><code>])</code> is like copy except it will generate an error if <span class="codestrong">p1</span> is anything but a regular file.</li>&#13;
<li class="noindent"><code>create_directory</code><code>(</code><span class="codestrong">p</span><code>, [</code><span class="codestrong">ec</span><code>])</code> creates the directory <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><code>create_directories</code><code>(</code><span class="codestrong">p</span><code>, [</code><span class="codestrong">ec</span><code>])</code> is like calling <code>create_directory</code> recursively, so if a nested path contains parents that don’t exist, use this form.</li>&#13;
<li class="noindent"><code>create_hard_link</code><code>(</code><span class="codestrong">tgt</span><code>,</code> <span class="codestrong">lnk</span><code>, [</code><span class="codestrong">ec</span><code>])</code> creates a hard link to <span class="codestrong">tgt</span> at <span class="codestrong">lnk</span>.</li>&#13;
<li class="noindent"><code>create_symlink</code><code>(</code><span class="codestrong">tgt</span><code>,</code> <span class="codestrong">lnk</span><code>, [</code><span class="codestrong">ec</span><code>])</code> creates a symlink to <span class="codestrong">tgt</span> at <span class="codestrong">lnk</span>.</li>&#13;
<li class="noindent"><code>create_directory_symlink</code><code>(</code><span class="codestrong">tgt</span><code>,</code> <span class="codestrong">lnk</span><code>, [</code><span class="codestrong">ec</span><code>])</code> should be used for directories instead of <code>create_symlink</code>.</li>&#13;
<li class="noindent"><code>remove</code><code>(</code><span class="codestrong">p</span><code>, [</code><span class="codestrong">ec</span><code>])</code> removes a file or empty directory <span class="codestrong">p</span> (without following symlinks).</li>&#13;
<li class="noindent"><code>remove_all</code><code>(</code><span class="codestrong">p</span><code>, [</code><span class="codestrong">ec</span><code>])</code> removes a file or directory recursively <span class="codestrong">p</span> (without following symlinks).</li>&#13;
<li class="noindent"><code>rename</code><code>(</code><span class="codestrong">p1</span><code>,</code> <span class="codestrong">p2</span><code>, [</code><span class="codestrong">ec</span><code>])</code> renames <span class="codestrong">p1</span> to <span class="codestrong">p2</span>.</li>&#13;
<li class="noindent"><code>resize_file</code><code>(</code><span class="codestrong">p</span><code>,</code> <span class="codestrong">new_size</span><code>, [</code><span class="codestrong">ec</span><code>])</code> changes the size of <span class="codestrong">p</span> (if it’s a regular file) to <span class="codestrong">new_size</span>. If this operation grows the file, zeros fill the new space. Otherwise, the operation trims <span class="codestrong">p</span> from the end.</li>&#13;
</ul>&#13;
<p class="indent">You can create a program that copies, resizes, and deletes a file using several of these methods. <a href="ch17.xhtml#ch17ex06">Listing 17-6</a> illustrates this by defining a function that prints file size and modification time. In <code>main</code>, the program creates and modifies two <code>path</code> objects, and it invokes that function after each modification.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
using namespace std;&#13;
using namespace std::filesystem;&#13;
using namespace std::chrono;&#13;
<span epub:type="pagebreak" id="page_563"/>&#13;
void write_info(const path&amp; p) {&#13;
  if (!exists(p)) { <span class="ent">➊</span>&#13;
    cout &lt;&lt; p &lt;&lt; " does not exist." &lt;&lt; endl;&#13;
    return;&#13;
  }&#13;
  const auto last_write = last_write_time(p).time_since_epoch();&#13;
  const auto in_hours = duration_cast&lt;hours&gt;(last_write).count();&#13;
  cout &lt;&lt; p &lt;&lt; "\t" &lt;&lt; in_hours &lt;&lt; "\t" &lt;&lt; file_size(p) &lt;&lt; "\n"; <span class="ent">➋</span>&#13;
}&#13;
&#13;
int main() {&#13;
  const path win_path{ R"(C:/Windows/System32/kernel32.dll)" }; <span class="ent">➌</span>&#13;
  const auto reamde_path = temp_directory_path() / "REAMDE"; <span class="ent">➍</span>&#13;
  try {&#13;
    write_info(win_path); <span class="ent">➎</span>&#13;
    write_info(reamde_path); <span class="ent">➏</span>&#13;
&#13;
    cout &lt;&lt; "Copying " &lt;&lt; win_path.filename()&#13;
         &lt;&lt; " to " &lt;&lt; reamde_path.filename() &lt;&lt; "\n";&#13;
    copy_file(win_path, reamde_path);&#13;
    write_info(reamde_path); <span class="ent">➐</span>&#13;
&#13;
    cout &lt;&lt; "Resizing " &lt;&lt; reamde_path.filename() &lt;&lt; "\n";&#13;
    resize_file(reamde_path, 1024);&#13;
    write_info(reamde_path); <span class="ent">➑</span>&#13;
&#13;
    cout &lt;&lt; "Removing " &lt;&lt; reamde_path.filename() &lt;&lt; "\n";&#13;
    remove(reamde_path);&#13;
    write_info(reamde_path); <span class="ent">➒</span>&#13;
  } catch(const exception&amp; e) {&#13;
    cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; endl;&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">"C:/Windows/System32/kernel32.dll"      3657767 720632 <span class="ent">➎</span></span>&#13;
<span class="color1">"C:\\Users\\lospi\\AppData\\Local\\Temp\\REAMDE" does not exist. <span class="ent">➏</span></span>&#13;
<span class="color1">Copying "kernel32.dll" to "REAMDE"</span>&#13;
<span class="color1">"C:\\Users\\lospi\\AppData\\Local\\Temp\\REAMDE"        3657767 720632 <span class="ent">➐</span></span>&#13;
<span class="color1">Resizing "REAMDE"</span>&#13;
<span class="color1">"C:\\Users\\lospi\\AppData\\Local\\Temp\\REAMDE"        3659294 1024 <span class="ent">➑</span></span>&#13;
<span class="color1">Removing "REAMDE"</span>&#13;
<span class="color1">"C:\\Users\\lospi\\AppData\\Local\\Temp\\REAMDE" does not exist. <span class="ent">➒</span></span></pre>&#13;
<p class="listing"><a id="ch17ex06"/><em>Listing 17-6: A program illustrating several methods for interacting with the filesystem. (Output is from a Windows 10 x64 system.)</em></p>&#13;
<p class="indent">The <code>write_info</code> function takes a single <code>path</code> parameter. You check whether this path exists <span class="ent">➊</span>, printing an error message and returning immediately if it doesn’t. If the <code>path</code> does exist, you print a message indicating its last modification time (in hours since epoch) and its file size <span class="ent">➋</span>.</p>&#13;
<p class="indent">Within <code>main</code>, you create a path <code>win_path</code> to <code>kernel32.dll</code> <span class="ent">➌</span> and a path to a nonexistent file called <code>REAMDE</code> in the filesystem’s temporary file directory at <code>reamde_path</code> <span class="ent">➍</span>. (Recall from <a href="ch17.xhtml#ch17tab01">Table 17-1</a> that you can use <code>operator/</code> to <span epub:type="pagebreak" id="page_564"/>concatenate two path objects.) Within a <code>try</code>-<code>catch</code> block, you invoke <code>write_info</code> on both paths <span class="ent">➎➏</span>. (If you’re using a non-Windows machine, you’ll get different output. You can modify <code>win_path</code> to an existing file on your system to follow along.)</p>&#13;
<p class="indent">Next, you copy the file at <code>win_path</code> to <code>reamde_path</code> and invoke <code>write_info</code> on it <span class="ent">➐</span>. Notice that, as opposed to earlier <span class="ent">➏</span>, the file at <code>reamde_path</code> exists and it has the same last write time and file size as <code>kernel32.dll</code>.</p>&#13;
<p class="indent">You then resize the file at <code>reamde_path</code> to 1024 bytes and invoke <code>write_info</code> <span class="ent">➑</span>. Notice that the last write time increased from 3657767 to 3659294 and the file size decreased from 720632 to 1024.</p>&#13;
<p class="indent">Finally, you remove the file at <code>reamde_path</code> and invoke <code>write_info</code> <span class="ent">➒</span>, which tells you that the file again no longer exists.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>How filesystems resize files behind the scenes varies by operating system and is beyond the scope of this book. But you can think of how a resize operation might work conceptually as the <code>resize</code> operation on a <code>std::vector</code>. All the data at the end of the file that doesn’t fit into the file’s new size is discarded by the operating system.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch17lev1sec4"><strong>Directory Iterators</strong></h3>&#13;
<p class="noindent">The Filesystem library provides two classes for iterating over the elements of a directory: <code>std::filesystem::directory_iterator</code> and <code>std::filesystem::recursive_directory_iterator</code>. A <code>directory_iterator</code> won’t enter subdirectories, but the <code>recursive_directory_iterator</code> will. This section introduces the <code>directory_iterator</code>, but the <code>recursive_directory_iterator</code> is a drop-in replacement and supports all the following operations.</p>&#13;
<h4 class="h4" id="ch17lev2sec10"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">The default constructor of <code>directory_iterator</code> produces the end iterator. (Recall that an input end iterator indicates when an input range is exhausted.) Another constructor accepts path, which indicates the directory you want to enumerate. Optionally, you can provide <code>std::filesystem::directory_options</code>, which is an <code>enum</code> class bitmask with the following constants:</p>&#13;
<ul>&#13;
<li class="noindent"><code>none</code> directs the iterator to skip directory symlinks. If the iterator encounters a permission denial, it produces an error.</li>&#13;
<li class="noindent"><code>follow_directory_symlink</code> follows symlinks.</li>&#13;
<li class="noindent"><code>skip_permission_denied</code> skips directories if the iterator encounters a permission denial.</li>&#13;
</ul>&#13;
<p class="indent">Additionally, you can provide a <code>std::error_code</code>, which, like all other Filesystem library functions that accept an <code>error_code</code>, will set this parameter rather than throwing an exception if an error occurs during construction.</p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17tab02">Table 17-2</a> summarizes these options for constructing a <code>directory_iterator</code>. Note that <code>p</code> is <code>path</code> and <code>d</code> is <code>directory</code>, <code>op</code> is <code>directory_options</code>, and <code>ec</code> is <code>error_code</code> in the table.</p>&#13;
<p class="tabcap" id="ch17tab02"><span epub:type="pagebreak" id="page_565"/><strong>Table 17-2:</strong> A Summary of <code>std::filestystem::directory_iterator</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th">Operation</p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th">Notes</p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>directory_iterator{}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs the end iterator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>directory_iterator{</code> <span class="codestrong">p</span><code>, [</code><span class="codestrong">op</span><code>], [</code><span class="codestrong">ec</span><code>] }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a directory iterator referring to the directory <span class="codestrong">p</span>. The argument <span class="codestrong">op</span> defaults to <code>none</code>. If provided, <span class="codestrong">ec</span> receives error conditions rather than throwing an exception.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>directory_iterator {</code> <span class="codestrong">d</span> <code> }</code></p>&#13;
<p class="taba"><span class="codestrong">d1</span> <code>=</code> <span class="codestrong">d2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copies construction/assignment.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>directory_iterator { move(</code><span class="codestrong">d</span><code>) }</code></p>&#13;
<p class="taba"><span class="codestrong">d1</span> <code> = move(</code><span class="codestrong">d2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Moves construction/assignment.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch17lev2sec11"><strong>Directory Entries</strong></h4>&#13;
<p class="indent">The input iterators <code>directory_iterator</code> and <code>recursive_directory_iterator</code> produce a <code>std::filesystem::directory_entry</code> element for each entry they encounter. The <code>directory_entry</code> class stores a <code>path</code>, as well as some attributes about that <code>path</code> exposed as methods. <a href="ch17.xhtml#ch17tab03">Table 17-3</a> lists these methods. Note that <code>de</code> is a <code>directory_entry</code> in the table.</p>&#13;
<p class="tabcap"><a id="ch17tab03"/><strong>Table 17-3:</strong> A Summary of <code>std::filesystem::directory_entry</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th">Operation</p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th">Description</p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><code>.path()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the referenced path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><code>.exists()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if the referenced path exists on the filesystem.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><code>.is_block_file()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <code>true</code> if the referenced path is a block device.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><code>.is_character_file()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if the referenced path is a character device.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><code>.is_directory()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <code>true</code> if the referenced path is a directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><code>.is_fifo()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if the referenced path is a named pipe.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><code>.is_regular_file()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <code>true</code> if the referenced path is a regular file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><code>.is_socket()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if the referenced path is a socket.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><code>.is_symlink()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <code>true</code> if the referenced path is a symlink</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><code>.is_other()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if the referenced path is something else.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><code>.file_size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the size of the referenced path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><code>.hard_link_count()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the number of hard links to the referenced path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><code>.last_write_time([</code><span class="codestrong">t</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If <code>t</code> is provided, sets the last modified time of the referenced path; otherwise, it returns the last modified time.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">de</span><code>.status()</code><br/><span class="codestrong">de</span><code>.symlink_status()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns a <code>std::filesystem::file_status</code> for the referenced path.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can employ <code>directory_iterator</code> and several of the operations in <a href="ch17.xhtml#ch17tab03">Table 17-3</a> to create a simple directory-listing program, as <a href="ch17.xhtml#ch17ex07">Listing 17-7</a> illustrates.</p>&#13;
<pre><span epub:type="pagebreak" id="page_566"/>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
#include &lt;iomanip&gt;&#13;
&#13;
using namespace std;&#13;
using namespace std::filesystem;&#13;
using namespace std::chrono;&#13;
&#13;
void describe(const directory_entry&amp; entry) { <span class="ent">➊</span>&#13;
  try {&#13;
    if (entry.is_directory()) { <span class="ent">➋</span>&#13;
      cout &lt;&lt; "           *";&#13;
    } else {&#13;
      cout &lt;&lt; setw(12) &lt;&lt; entry.file_size();&#13;
    }&#13;
    const auto lw_time =&#13;
      duration_cast&lt;seconds&gt;(entry.last_write_time().time_since_epoch());&#13;
    cout &lt;&lt; setw(12) &lt;&lt; lw_time.count()&#13;
      &lt;&lt; " " &lt;&lt; entry.path().filename().string()&#13;
      &lt;&lt; "\n"; <span class="ent">➌</span>&#13;
  } catch (const exception&amp; e) {&#13;
    cout &lt;&lt; "Error accessing " &lt;&lt; entry.path().string()&#13;
         &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; endl; <span class="ent">➍</span>&#13;
  }&#13;
}&#13;
&#13;
int main(int argc, const char** argv) {&#13;
  if (argc != 2) {&#13;
    cerr &lt;&lt; "Usage: listdir PATH";&#13;
    return -1; <span class="ent">➎</span>&#13;
  }&#13;
  const path sys_path{ argv[1] }; <span class="ent">➏</span>&#13;
  cout &lt;&lt; "Size         Last Write  Name\n";&#13;
  cout &lt;&lt; "------------ ----------- ------------\n"; <span class="ent">➐</span>&#13;
  for (const auto&amp; entry : directory_iterator{ sys_path }) <span class="ent">➑</span>&#13;
    describe(entry); <span class="ent">➒</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="codestrong1">&gt; listdir c:\Windows</span>&#13;
<span class="color1">Size         Last Write  Name</span>&#13;
<span class="color1">------------ ----------- ------------</span>&#13;
<span class="color1">           * 13177963504 addins</span>&#13;
<span class="color1">           * 13171360979 appcompat</span>&#13;
<span class="color1"><span class="codeitalic1">--snip--</span></span>&#13;
<span class="color1">           * 13173551028 WinSxS</span>&#13;
<span class="color1">      316640 13167963236 WMSysPr9.prx</span>&#13;
<span class="color1">       11264 13167963259 write.exe</span></pre>&#13;
<p class="listing"><a id="ch17ex07"/><em>Listing 17-7: A file- and directory-listing program that uses <code>std::filesystem::directory_iterator</code> to enumerate a given directory. (Output is from a Windows 10 x64 system.)</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You should modify the program’s name from <code>listdir</code> to whatever value matches your compiler’s output.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_567"/>You first define a <code>describe</code> function that takes a <code>path</code> reference <span class="ent">➊</span>, which checks whether the path is a directory <span class="ent">➋</span> and prints an asterisk for a directory and a corresponding size for a file. Next, you determine the entry’s last modification in seconds since epoch and print it along with the entry’s associated filename <span class="ent">➌</span>. If any exception occurs, you print an error message and return <span class="ent">➍</span>.</p>&#13;
<p class="indent">Within <code>main</code>, you first check that the user invoked your program with a single argument and return with a negative number if not <span class="ent">➎</span>. Next, you construct a path using the single argument <span class="ent">➏</span>, print some fancy headers for your output <span class="ent">➐</span>, iterate over each <code>entry</code> in the directory <span class="ent">➑</span>, and pass it to <code>describe</code> <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch17lev2sec12"><strong><em>Recursive Directory Iteration</em></strong></h4>&#13;
<p class="noindent">The <code>recursive_directory_iterator</code> is a drop-in replacement for <code>directory_iterator</code> in the sense that it supports all the same operations but will enumerate subdirectories. You can use these iterators in combination to build a program that computes the size and quantity of files and subdirectories for a given directory. <a href="ch17.xhtml#ch17ex08">Listing 17-8</a> illustrates how.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
using namespace std;&#13;
using namespace std::filesystem;&#13;
&#13;
struct Attributes {&#13;
  Attributes&amp; operator+=(const Attributes&amp; other) {&#13;
    this-&gt;size_bytes += other.size_bytes;&#13;
    this-&gt;n_directories += other.n_directories;&#13;
    this-&gt;n_files += other.n_files;&#13;
    return *this;&#13;
  }&#13;
  size_t size_bytes;&#13;
  size_t n_directories;&#13;
  size_t n_files;&#13;
}; <span class="ent">➊</span>&#13;
&#13;
void print_line(const Attributes&amp; attributes, string_view path) {&#13;
  cout &lt;&lt; setw(14) &lt;&lt; attributes.size_bytes&#13;
       &lt;&lt; setw(7) &lt;&lt; attributes.n_files&#13;
       &lt;&lt; setw(7) &lt;&lt; attributes.n_directories&#13;
       &lt;&lt; " " &lt;&lt; path &lt;&lt; "\n"; <span class="ent">➋</span>&#13;
}&#13;
&#13;
Attributes explore(const directory_entry&amp; directory) {&#13;
  Attributes attributes{};&#13;
  for(const auto&amp; entry : recursive_directory_iterator{ directory.path() }) { <span class="ent">➌</span>&#13;
      if (entry.is_directory()) {&#13;
        attributes.n_directories++; <span class="ent">➍</span>&#13;
      } else {&#13;
        attributes.n_files++;&#13;
<span epub:type="pagebreak" id="page_568"/>        attributes.size_bytes += entry.file_size(); <span class="ent">➎</span>&#13;
      }&#13;
  }&#13;
  return attributes;&#13;
}&#13;
&#13;
int main(int argc, const char** argv) {&#13;
  if (argc != 2) {&#13;
    cerr &lt;&lt; "Usage: treedir PATH";&#13;
    return -1; <span class="ent">➏</span>&#13;
  }&#13;
  const path sys_path{ argv[1] };&#13;
  cout &lt;&lt; "Size           Files  Dirs   Name\n";&#13;
  cout &lt;&lt; "-------------- ------ ------ ------------\n";&#13;
  Attributes root_attributes{};&#13;
  for (const auto&amp; entry : directory_iterator{ sys_path }) { <span class="ent">➐</span>&#13;
    try {&#13;
      if (entry.is_directory()) {&#13;
        const auto attributes = explore(entry); <span class="ent">➑</span>&#13;
        root_attributes += attributes;&#13;
        print_line(attributes, entry.path().string());&#13;
        root_attributes.n_directories++;&#13;
      } else {&#13;
        root_attributes.n_files++;&#13;
        error_code ec;&#13;
        root_attributes.size_bytes += entry.file_size(ec); <span class="ent">➒</span>&#13;
        if (ec) cerr &lt;&lt; "Error reading file size: "&#13;
                     &lt;&lt; entry.path().string() &lt;&lt; endl;&#13;
      }&#13;
    } catch(const exception&amp;) {&#13;
    }&#13;
  }&#13;
  print_line(root_attributes, argv[1]); <span class="ent">➓</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">&gt; treedir C:\Windows</span>&#13;
<span class="color1">Size         Files  Dirs Name</span>&#13;
<span class="color1">------------ ----- ----- ------------</span>&#13;
<span class="color1">           802      1      0 C:\Windows\addins</span>&#13;
<span class="color1">       8267330      9      5 C:\Windows\apppatch</span>&#13;
<span class="color1"><span class="codeitalic1">--snip--</span></span>&#13;
<span class="color1">   11396916465  73383  20480 C:\Windows\WinSxS</span>&#13;
<span class="color1">   21038460348 110950  26513 C:\Windows <span class="ent">➓</span></span></pre>&#13;
<p class="listing"><a id="ch17ex08"/><em>Listing 17-8: A file- and directory-listing program that uses <code>std::filesystem::recursive_directory_iterator</code> to list the number of files and total size of a given path’s subdirectory.    (Output is from a Windows 10 x64 system.)</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You should modify the program’s name from <code>treedir</code> to whatever value matches your compiler’s output.</em></p>&#13;
</div>&#13;
<p class="indent">After declaring the <code>Attributes</code> class for storing accounting data <span class="ent">➊</span>, you define a <code>print_line</code> function that presents an <code>Attributes</code> instance in a user-friendly way alongside a path string <span class="ent">➋</span>. Next, you define an <code>explore</code> function <span epub:type="pagebreak" id="page_569"/>that accepts a <code>directory_entry</code> reference and iterates over it recursively <span class="ent">➌</span>. If the resulting <code>entry</code> is a directory, you increment the directory count <span class="ent">➍</span>; otherwise, you increment the file count and total size <span class="ent">➎</span>.</p>&#13;
<p class="indent">Within <code>main</code>, you check that the program invoked with exactly two arguments. If not, you return with an error code -1 <span class="ent">➏</span>. You employ a (non-recursive) <code>directory_iterator</code> to enumerate the contents of the target path referred by <code>sys_path</code> <span class="ent">➐</span>. If an <code>entry</code> is a directory, you invoke <code>explore</code> to determine its attributes <span class="ent">➑</span>, which you subsequently print to the console. You also increment the <code>n_directories</code> member of <code>root_attributes</code> to keep account. If the <code>entry</code> isn’t a directory, you add to the <code>n_files</code> and <code>size_bytes</code> members of <code>root_attributes</code> accordingly <span class="ent">➒</span>.</p>&#13;
<p class="indent">Once you’ve completed iterating over all <code>sys_path</code> subelements, you print <code>root_attributes</code> as the final line <span class="ent">➓</span>. The final line of output in <a href="ch17.xhtml#ch17ex08">Listing 17-8</a>, for example, shows that this particular Windows directory contains 110,950 files occupying 21,038,460,348 bytes (about 21GB) and 26,513 subdirectories.</p>&#13;
<h3 class="h3" id="ch17lev1sec5"><strong>fstream Interoperation</strong></h3>&#13;
<p class="noindent">You can construct file streams (<code>basic_ifstream</code>, <code>basic_ofstream</code>, or <code>basic_</code><code>fstream</code>) using <code>std::filesystem::path</code> or <code>std::filesystem::directory_entry</code> in addition to string types.</p>&#13;
<p class="indent">For example, you can iterate over a directory and construct an <code>ifstream</code> to read each file you encounter. <a href="ch17.xhtml#ch17ex09">Listing 17-9</a> illustrates how to check for the magic <code>MZ</code> bytes at the beginning of each Windows portable executable file (a <em>.sys</em>, a <em>.dll</em>, a <em>.exe</em>, and so on) and report any file that violates this rule.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;fstream&gt;&#13;
#include &lt;filesystem&gt;&#13;
#include &lt;unordered_set&gt;&#13;
&#13;
using namespace std;&#13;
using namespace std::filesystem;&#13;
&#13;
int main(int argc, const char** argv) {&#13;
  if (argc != 2) {&#13;
    cerr &lt;&lt; "Usage: pecheck PATH";&#13;
    return -1; <span class="ent">➊</span>&#13;
  }&#13;
  const unordered_set&lt;string&gt; pe_extensions{&#13;
    ".acm", ".ax",  ".cpl", ".dll", ".drv",&#13;
    ".efi", ".exe", ".mui", ".ocx", ".scr",&#13;
    ".sys", ".tsp"&#13;
  }; <span class="ent">➋</span>&#13;
  const path sys_path{ argv[1] };&#13;
  cout &lt;&lt; "Searching " &lt;&lt; sys_path &lt;&lt; " recursively.\n";&#13;
  size_t n_searched{};&#13;
  auto iterator = recursive_directory_iterator{ sys_path,&#13;
                                 directory_options::skip_permission_denied }; <span class="ent">➌</span>&#13;
  for (const auto&amp; entry : iterator) { <span class="ent">➍</span>&#13;
    try {&#13;
<span epub:type="pagebreak" id="page_570"/>      if (!entry.is_regular_file()) continue;&#13;
      const auto&amp; extension = entry.path().extension().string();&#13;
      const auto is_pe = pe_extensions.find(extension) != pe_extensions.end();&#13;
      if (!is_pe) continue; <span class="ent">➎</span>&#13;
      ifstream file{ entry.path() }; <span class="ent">➏</span>&#13;
      char first{}, second{};&#13;
      if (file) file &gt;&gt; first;&#13;
      if (file) file &gt;&gt; second; <span class="ent">➐</span>&#13;
      if (first != 'M' || second != 'Z')&#13;
        cout &lt;&lt; "Invalid PE found: " &lt;&lt; entry.path().string() &lt;&lt; "\n"; <span class="ent">➑</span>&#13;
      ++n_searched;&#13;
    } catch(const exception&amp; e) {&#13;
      cerr &lt;&lt; "Error reading " &lt;&lt; entry.path().string()&#13;
           &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; endl;&#13;
    }&#13;
  }&#13;
  cout &lt;&lt; "Searched " &lt;&lt; n_searched &lt;&lt; " PEs for magic bytes." &lt;&lt; endl; <span class="ent">➒</span>&#13;
}&#13;
----------------------------------------------------------------------&#13;
<span class="color1">listing_17_9.exe c:\Windows\System32</span>&#13;
<span class="color1">Searching "c:\\Windows\\System32" recursively.</span>&#13;
<span class="color1">Searched 8231 PEs for magic bytes.</span></pre>&#13;
<p class="listing"><a id="ch17ex09"/><em>Listing 17-9: Searching the Windows System32 directory for Windows portable executable files</em></p>&#13;
<p class="indent">In <code>main</code>, you check for exactly two arguments and return an error code as appropriate <span class="ent">➊</span>. You construct an <code>unordered_set</code> containing all the extensions associated with portable executable files <span class="ent">➋</span>, which you’ll use to check file extensions. You use a <code>recursive_directory_iterator</code> with the <code>directory_options::skip_permission_denied</code> option to enumerate all the files in the specified path <span class="ent">➌</span>. You iterate over each entry <span class="ent">➍</span>, skipping over anything that’s not a regular file, and you determine whether the entry is a portable executable by attempting to <code>find</code> it in <code>pe_extensions</code>. If the entry doesn’t have such an extension, you skip over the file <span class="ent">➎</span>.</p>&#13;
<p class="indent">To open the file, you simply pass the path of the <code>entry</code> into the constructor of <code>ifstream</code> <span class="ent">➏</span>. You then use the resulting input file stream to read the first two bytes of the file into <code>first</code> and <code>second</code> <span class="ent">➐</span>. If these first two characters aren’t <code>MZ</code>, you print a message to the console <span class="ent">➑</span>. Either way, you increment a counter called <code>n_searched</code>. After exhausting the directory iterator, you print a message indicating <code>n_searched</code> to the user before returning from <code>main</code> <span class="ent">➒</span>.</p>&#13;
<h3 class="h3" id="ch17lev1sec6"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned about the stdlib filesystem facilities, including paths, files, directories, and error handling. These facilities enable you to write cross-platform code that interacts with the files in your environment. The chapter culminated with some important operations, directory iterators, and interoperation with file streams.</p>&#13;
<div class="box5" id="bm02">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_571"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>17-1.</strong> Implement a program that takes two arguments: a path and an extension. The program should search the given path recursively and print any file with the specified extension.</p>&#13;
<p class="noindent"><strong>17-2.</strong> Improve the program in <a href="ch17.xhtml#ch17ex08">Listing 17-8</a> so it can take an optional second argument. If the first argument begins with a hyphen (<code>-</code>), the program reads all contiguous letters immediately following the hyphen and parses each letter as an option. The second argument then becomes the path to search. If the list of options contains an <em>R</em>, perform a recursive directory. Otherwise, don’t use a recursive directory iterator.</p>&#13;
<p class="noindent"><strong>17-3.</strong> Refer to the documentation for the <em>dir</em> or <em>ls</em> command and implement as many of the options as possible in your new, improved version of <a href="ch17.xhtml#ch17ex08">Listing 17-8</a>.</p>&#13;
</div>&#13;
<div class="box6" id="bm03">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>Windows NT File System Internals: A Developer’s Guide</em> by Rajeev Nagar (O’Reilly, 1997)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>The Linux Programming Interface: A Linux and UNIX System Programming Handbook</em> by Michael Kerrisk (No Starch Press, 2010)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>