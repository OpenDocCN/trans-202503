<html><head></head><body>
<h2 class="h2" id="ch17"><span epub:type="pagebreak" id="page_551"/><strong><span class="big">17</span><br/>FILESYSTEMS</strong></h2>&#13;
<p class="quote"><em>“So, you’re the UNIX guru.” At the time, Randy was still stupid enough to be flattered by this attention, when he should have recognized them as bone-chilling words.<br/>—Neal Stephenson</em>, Cryptonomicon</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">This chapter teaches you how to use the stdlib’s Filesystem library to perform operations on filesystems, such as manipulating and inspecting files, enumerating directories, and interoperating with file streams.</p>&#13;
<p class="indent">The stdlib and Boost contain Filesystem libraries. The stdlib’s Filesystem library grew out of Boost’s, and accordingly they’re largely interchangeable. This chapter focuses on the stdlib implementation. If you’re interested in learning more about Boost, refer to the Boost Filesystem documentation. Boost and stdlib’s implementations are mostly identical.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The C++ Standard has a history of subsuming Boost libraries. This allows the C++ community to gain experience with new features in Boost before going through the more arduous process of including the features in the C++ Standard.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch17lev1sec1"><span epub:type="pagebreak" id="page_552"/><strong>Filesystem Concepts</strong></h3>&#13;
<p class="noindent">Filesystems model several important concepts. The central entity is the file. A <em>file</em> is a filesystem object that supports input and output and holds data. Files exist in containers called <em>directories</em>, which can be nested within other directories. For simplicity, directories are considered files. The directory containing a file is called that file’s <em>parent directory</em>.</p>&#13;
<p class="indent">A path is a string that identifies a specific file. Paths begin with an optional <em>root name</em>, which is an implementation-specific string, such as <em>C:</em> or <em>//localhost</em> on Windows followed by an optional root directory, which is another implementation-specific string, such as <span class="literal">/</span> on Unix-like systems. The remainder of the path is a sequence of directories separated by implementation-defined separators. Optionally, paths terminate in a non-directory file. Paths can contain the special names “<span class="literal">.</span>” and “<span class="literal">..</span>”, which mean current directory and parent directory, respectively.</p>&#13;
<p class="indent">A <em>hard link</em> is a directory entry that assigns a name to an existing file, and a <em>symbolic link</em> (or <em>symlink</em>) assigns a name to a path (which might or might not exist). A path whose location is specified in relation to another path (usually the current directory) is called a <em>relative path</em>, and a <em>canonical path</em> unambiguously identifies a file’s location, doesn’t contain the special names “<strong>.</strong>” and “<strong>..</strong>”, and doesn’t contain any symbolic links. An <em>absolute path</em> is any path that unambiguously identifies a file’s location. A major difference between a canonical path and an absolute path is that a canonical path cannot contain the special names “<strong>.</strong>” and “<strong>..</strong>”.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>The stdlib filesystem might not be available if the target platform doesn’t offer a hierarchical filesystem.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch17lev1sec2"><strong>std::filesystem::path</strong></h3>&#13;
<p class="noindent">The <span class="literal">std::filesystem::path</span> is the Filesystem library’s class for modeling a path, and you have many options for constructing paths. Perhaps the two most common are the default constructor, which constructs an empty path, and the constructor taking a string type, which creates the path indicated by the characters in the string. Like all other filesystem classes and functions, the <span class="literal">path</span> class resides in the <span class="literal">&lt;filesystem&gt;</span> header.</p>&#13;
<p class="indent">In this section, you’ll learn how to construct a path from a <span class="literal">string</span> representation, decompose it into constituent parts, and modify it. In many common system- and application-programming contexts, you’ll need to interact with files. Because each operating system has a unique representation for filesystems, the stdlib’s Filesystem library is a welcome abstraction that allows you to write cross-platform code easily.</p>&#13;
<h4 class="h4" id="ch17lev2sec1"><strong><em>Constructing Paths</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">path</span> class supports comparison with other <span class="literal">path</span> objects and with <span class="literal">string</span> objects using the <span class="literal">operator==</span>. But if you just want to check whether the <span class="literal">path</span> is <span epub:type="pagebreak" id="page_553"/>empty, it offers an <span class="literal">empty</span> method that returns a Boolean. <a href="ch17.xhtml#ch17ex01">Listing 17-1</a> illustrates how to construct two <span class="literal">path</span>s (one empty and one non-empty) and test them.</p>&#13;
<pre>#include &lt;string&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
TEST_CASE("std::filesystem::path supports == and .empty()") {&#13;
  std::filesystem::path empty_path; <span class="ent">➊</span>&#13;
  std::filesystem::path shadow_path{ "/etc/shadow" }; <span class="ent">➋</span>&#13;
  REQUIRE(empty_path.empty()); <span class="ent">➌</span>&#13;
  REQUIRE(shadow_path == std::string{ "/etc/shadow" }); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch17ex01"/><em>Listing 17-1: Constructing <span class="literal">std::filesystem::path</span></em></p>&#13;
<p class="indent">You construct two paths: one with the default constructor <span class="ent">➊</span> and one referring to <span class="literal">/etc/shadow</span> <span class="ent">➋</span>. Because you default construct it, the <span class="literal">empty</span> method of <span class="literal">empty_path</span> returns <span class="literal">true</span> <span class="ent">➌</span>. The <span class="literal">shadow_path</span> equals a <span class="literal">string</span> containing <span class="literal">/etc/shadow</span>, because you construct it with the same contents <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch17lev2sec2"><strong>Decomposing Paths</strong></h4>&#13;
<p class="noindent">The <span class="literal">path</span> class contains some decomposition methods that are, in effect, specialized string manipulators that allow you to extract components of the path, for example:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">root_name()</span> returns the root name.</li>&#13;
<li class="noindent"><span class="literal">root_directory()</span> returns the root directory.</li>&#13;
<li class="noindent"><span class="literal">root_path()</span> returns the root path.</li>&#13;
<li class="noindent"><span class="literal">relative_path()</span> returns a path relative to the root.</li>&#13;
<li class="noindent"><span class="literal">parent_path()</span> returns the parent path.</li>&#13;
<li class="noindent"><span class="literal">filename()</span> returns the filename component.</li>&#13;
<li class="noindent"><span class="literal">stem()</span> returns the filename stripped of its extension.</li>&#13;
<li class="noindent"><span class="literal">extension()</span> returns the extension.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch17.xhtml#ch17ex02">Listing 17-2</a> provides the values returned by each of these methods for a path pointing to a very important Windows system library, <span class="literal">kernel32.dll</span>.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  const filesystem::path kernel32{ R"(C:\Windows\System32\kernel32.dll)" }; <span class="ent">➊</span>&#13;
  cout &lt;&lt; "Root name: " &lt;&lt; kernel32.root_name() <span class="ent">➋</span>&#13;
    &lt;&lt; "\nRoot directory: " &lt;&lt; kernel32.root_directory() <span class="ent">➌</span>&#13;
    &lt;&lt; "\nRoot path: " &lt;&lt; kernel32.root_path() <span class="ent">➍</span>&#13;
    &lt;&lt; "\nRelative path: " &lt;&lt; kernel32.relative_path() <span class="ent">➎</span>&#13;
    &lt;&lt; "\nParent path: " &lt;&lt; kernel32.parent_path() <span class="ent">➏</span>&#13;
    &lt;&lt; "\nFilename: " &lt;&lt; kernel32.filename() <span class="ent">➐</span>&#13;
    &lt;&lt; "\nStem: " &lt;&lt; kernel32.stem() <span class="ent">➑</span>&#13;
    &lt;&lt; "\nExtension: " &lt;&lt; kernel32.extension() <span class="ent">➒</span>&#13;
    &lt;&lt; endl;&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Root name: "C:" <span class="ent">➋</span></span>&#13;
<span class="color1">Root directory: "\\" <span class="ent">➌</span></span>&#13;
<span class="color1">Root path: "C:\\" <span class="ent">➍</span></span>&#13;
<span class="color1">Relative path: "Windows\\System32\\kernel32.dll" <span class="ent">➎</span></span>&#13;
<span class="color1">Parent path: "C:\\Windows\\System32" <span class="ent">➏</span></span>&#13;
<span class="color1">Filename: "kernel32.dll" <span class="ent">➐</span></span>&#13;
<span class="color1">Stem: "kernel32" <span class="ent">➑</span></span>&#13;
<span class="color1">Extension: ".dll" <span class="ent">➒</span></span></pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_554"/><a id="ch17ex02"/><em>Listing 17-2: A program printing various decompositions of a path</em></p>&#13;
<p class="indent">You construct a path to kernel32 using a raw string literal to avoid having to escape the backslashes <span class="ent">➊</span>. You extract the root name <span class="ent">➋</span>, the root directory <span class="ent">➌</span>, and the root path of kernel32 <span class="ent">➍</span> and output them to stdout. Next, you extract the relative path, which displays the path relative to the root <span class="literal">C:\</span> <span class="ent">➎</span>. The parent path is the path of <span class="literal">kernel32.dll</span>’s parent, which is simply the directory containing it <span class="ent">➏</span>. Finally, you extract the filename <span class="ent">➐</span>, its stem <span class="ent">➑</span>, and its extension <span class="ent">➒</span>.</p>&#13;
<p class="indent">Notice that you don’t need to run <a href="ch17.xhtml#ch17ex02">Listing 17-2</a> on any particular operating system. None of the decomposition methods require that the path actually point to an existing file. You simply extract components of the path’s contents, not the pointed-to file. Of course, different operating systems will yield different results, especially with respect to the delimiters (which are, for example, forward slashes on Linux).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em><a href="ch17.xhtml#ch17ex02">Listing 17-2</a> illustrates that <span class="literal">std::filesystem::path</span> has an <span class="literal">operator&lt;&lt;</span> that prints quotation marks at the beginning and end of its path. Internally, it uses <span class="literal">std::quoted</span>, a class template in the <span class="codeitalic">&lt;iomanip&gt;</span> header that facilitates the insertion and extraction of quoted strings. Also, recall that you must escape the backslash in a string literal, which is why you see two rather than one in the paths embedded in the source code.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch17lev2sec3"><strong><em>Modifying Paths</em></strong></h4>&#13;
<p class="noindent">In addition to decomposition methods, <span class="literal">path</span> offers several <em>modifier methods</em>, which allow you to modify various characteristics of a path:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">clear()</span> empties the <span class="literal">path</span>.</li>&#13;
<li class="noindent"><span class="literal">make_preferred()</span> converts all the directory separators to the implementation-preferred directory separator. For example, on Windows this converts the generic separator / to the system-preferred separator \.</li>&#13;
<li class="noindent"><span class="literal">remove_filename()</span> removes the filename portion of the path.</li>&#13;
<li class="noindent"><span class="literal">replace_filename(p)</span> replaces the <span class="literal">path’s</span> filename with that of another path <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_555"/><span class="literal">replace_extension(p)</span> replaces the <span class="literal">path’s</span> extension with that of another path <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><span class="literal">remove_extension()</span> removes the extension portion of the path.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch17.xhtml#ch17ex03">Listing 17-3</a> illustrates how to manipulate a path using several modifier methods.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  filesystem::path path{ R"(C:/Windows/System32/kernel32.dll)" };&#13;
  cout &lt;&lt; path &lt;&lt; endl; <span class="ent">➊</span>&#13;
&#13;
  path.make_preferred();&#13;
  cout &lt;&lt; path &lt;&lt; endl; <span class="ent">➋</span>&#13;
&#13;
  path.replace_filename("win32kfull.sys");&#13;
  cout &lt;&lt; path &lt;&lt; endl; <span class="ent">➌</span>&#13;
&#13;
  path.remove_filename();&#13;
  cout &lt;&lt; path &lt;&lt; endl; <span class="ent">➍</span>&#13;
&#13;
  path.clear();&#13;
  cout &lt;&lt; "Is empty: " &lt;&lt; boolalpha &lt;&lt; path.empty() &lt;&lt; endl; <span class="ent">➎</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">"C:/Windows/System32/kernel32.dll" <span class="ent">➊</span></span>&#13;
<span class="color1">"C:\\Windows\\System32\\kernel32.dll" <span class="ent">➋</span></span>&#13;
<span class="color1">"C:\\Windows\\System32\\win32kfull.sys" <span class="ent">➌</span></span>&#13;
<span class="color1">"C:\\Windows\\System32\\" <span class="ent">➍</span></span>&#13;
<span class="color1">Is empty: true <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch17ex03"/><em>Listing 17-3: Manipulating a path using modifier methods. (Output is from a Windows 10 x64 system.)</em></p>&#13;
<p class="indent">As in <a href="ch17.xhtml#ch17ex02">Listing 17-2</a>, you construct a <span class="literal">path</span> to kernel32, although this one is non-<span class="literal">const</span> because you’re about to modify it <span class="ent">➊</span>. Next, you convert all the directory separators to the system’s preferred directory separator using <span class="literal">make_preferred</span>. <a href="ch17.xhtml#ch17ex03">Listing 17-3</a> shows output from a Windows 10 x64 system, so it has converted from slashes (<span class="literal">/</span>) to backslashes (<span class="literal">\</span>) <span class="ent">➋</span>. Using <span class="literal">replace_file</span><span class="literal">name</span>, you replace the filename from <span class="literal">kernel32.dll</span> to <span class="literal">win32kfull.sys</span> <span class="ent">➌</span>. Notice again that the file described by this path doesn’t need to exist on your system; you’re just manipulating the path. Finally, you remove the filename using the <span class="literal">remove_filename</span> method <span class="ent">➍</span> and then empty the <span class="literal">path</span>’s contents entirely using clear <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch17lev2sec4"><strong><em>Summary of Filesystem Path Methods</em></strong></h4>&#13;
<p class="noindent"><a href="ch17.xhtml#ch17tab01">Table 17-1</a> contains a partial listing of the available methods of <span class="literal">path</span>. Note that <span class="literal">p</span>, <span class="literal">p1</span>, and <span class="literal">p2</span> are <span class="literal">path</span> objects and <span class="literal">s</span> is a <span class="literal">stream</span> in the table.</p>&#13;
<p class="tabcap" id="ch17tab01"><span epub:type="pagebreak" id="page_556"/><strong>Table 17-1:</strong> A Summary of <span class="literal">std::filestystem::path</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">path{}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs an empty path.</p></td></tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Path{</span> <span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">f</span><span class="literal">] }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a path from the string type <span class="codestrong">s</span>; <span class="codestrong">f</span> is an optional <span class="literal">path::format</span> type that defaults to the implementation-defined pathname format.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Path{</span> <span class="codestrong">p</span> <span class="literal">}</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <span class="literal">=</span> <span class="codestrong">p2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copy construction/assignment.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Path{ move(</span><span class="codestrong">p</span><span class="literal">) }</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <span class="literal">= move(</span><span class="codestrong">p2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Move construction/assignment.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.assign(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Assigns <span class="codestrong">p</span> to <span class="codestrong">s</span>, discarding current contents.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.append(</span><span class="codestrong">s</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="codestrong">p</span> <span class="literal">/</span> <span class="codestrong">s</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Appends <span class="codestrong">s</span> to <span class="codestrong">p</span>, including the appropriate separator, <span class="literal">path::preferred_separator</span>.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.concat(</span><span class="codestrong">s</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="codestrong">p</span> <span class="literal">+</span> <span class="codestrong">s</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Appends <span class="codestrong">s</span> to <span class="codestrong">p</span> without including a separator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.clear()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Erases the contents.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.empty()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns true if <span class="codestrong">p</span> is empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.make_preferred()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Converts all the directory separators to the implementation-preferred directory separator.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.remove_filename()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the filename portion.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p1</span><span class="literal">.replace_filename(</span><span class="codestrong">p2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the filename of <span class="codestrong">p1</span> with that of <span class="codestrong">p2</span>.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p1</span><span class="literal">.replace_extension(</span><span class="codestrong">p2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the extension of <span class="codestrong">p1</span> with that of <span class="codestrong">p2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.root_name()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the root name.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.root_directory()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the root directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.root_path()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the root path.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.relative_path()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the relative path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.parent_path()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the parent path.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.filename()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the filename.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.stem()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the stem.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.extension()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the extension.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.has_root_name()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns true if <span class="codestrong">p</span> has a root name.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.has_root_directory()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns true if <span class="codestrong">p</span> has a root directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.has_root_path()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns true if <span class="codestrong">p</span> has a root path.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.has_relative_path()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns true if <span class="codestrong">p</span> has a relative path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.has_parent_path()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns true if <span class="codestrong">p</span> has a parent path.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.has_filename()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns true if <span class="codestrong">p</span> has a filename.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.has_stem()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns true if <span class="codestrong">p</span> has a stem.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.has_extension()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns true if <span class="codestrong">p</span> has an extension.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p</span><span class="literal">.c_str()</span></p>&#13;
<p class="taba"><span class="codestrong">p</span><span class="literal">.native()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><span epub:type="pagebreak" id="page_557"/><p class="taba">Returns the native-string representation of <span class="codestrong">p</span>.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">p</span><span class="literal">.begin()</span></p>&#13;
<p class="taba"><span class="codestrong">p</span><span class="literal">.end()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Accesses the elements of a path sequentially as a half-open range.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span> <span class="literal">&lt;&lt;</span> <span class="codestrong">p</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Writes <span class="codestrong">p</span> into <span class="codestrong">s</span>.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span> <span class="literal">&gt;&gt;</span> <span class="codestrong">p</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Reads <span class="codestrong">s</span> into <span class="codestrong">p</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">p1</span><span class="literal">.swap(</span><span class="codestrong">p2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">swap(</span><span class="codestrong">p1</span><span class="literal">,</span> <span class="codestrong">p2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Exchanges each element of <span class="codestrong">p1</span> with the elements of <span class="codestrong">p2</span>.</p></td>&#13;
</tr>&#13;
<tr><td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">p1</span> <span class="literal">==</span> <span class="codestrong">p2</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <span class="literal">!=</span> <span class="codestrong">p2</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <span class="literal">&gt;</span> <span class="codestrong">p2</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <span class="literal">&gt;=</span> <span class="codestrong">p2</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <span class="literal">&lt;</span> <span class="codestrong">p2</span></p>&#13;
<p class="taba"><span class="codestrong">p1</span> <span class="literal">&lt;=</span> <span class="codestrong">p2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Lexicographically compares two paths <span class="codestrong">p1</span> and <span class="codestrong">p2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch17lev1sec3"><strong>Files and Directories</strong></h3>&#13;
<p class="noindent">The <span class="literal">path</span> class is the central element of the Filesystem library, but none of its methods actually interact with the filesystem. Instead, the <span class="literal">&lt;filesystem&gt;</span> header contains non-member functions to do this. Think of <span class="literal">path</span> objects as the way you declare which filesystem components you want to interact with and think of the <span class="literal">&lt;filesystem&gt;</span> header as containing the functions that perform work on those components.</p>&#13;
<p class="indent">These functions have friendly error-handling interfaces and allow you to break paths into, for example, directory name, filename, and extension. Using these functions, you have many tools for interacting with the files in your environment without having to use an operating-specific application programming interface.</p>&#13;
<h4 class="h4" id="ch17lev2sec5"><strong><em>Error Handling</em></strong></h4>&#13;
<p class="noindent">Interacting with the environment’s filesystem involves the potential for errors, such as files not found, insufficient permissions, or unsupported operations. Therefore, each non-member function in the Filesystem library that interacts with the filesystem must convey error conditions to the caller. These non-member functions provide two options: throw an exception or set an error variable.</p>&#13;
<p class="indent">Each function has two overloads: one that allows you to pass a reference to a <span class="literal">std::system_error</span> and one that omits this parameter. If you provide the reference, the function will set the <span class="literal">system_error</span> equal to an error condition, should one occur. If you don’t provide this reference, the function will throw a <span class="literal">std::filesystem::filesystem_error</span> (an exception type inheriting from <span class="literal">std::system_error</span>) instead.</p>&#13;
<h4 class="h4" id="ch17lev2sec6"><span epub:type="pagebreak" id="page_558"/><strong><em>Path-Composing Functions</em></strong></h4>&#13;
<p class="noindent">As an alternative to using the constructor of <span class="literal">path</span>, you can construct various kinds of paths:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">absolute(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> returns an absolute path referencing the same location as <span class="codestrong">p</span> but where <span class="literal">is_absolute()</span> is true.</li>&#13;
<li class="noindent"><span class="literal">canonical(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> returns a canonical path referencing the same location as <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><span class="literal">current_path([</span><span class="codestrong">ec</span><span class="literal">])</span> returns the current path.</li>&#13;
<li class="noindent"><span class="literal">relative(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">base</span><span class="literal">], [</span><span class="codestrong">ec</span><span class="literal">])</span> returns a path where <span class="codestrong">p</span> is made relative to <span class="literal">base</span>.</li>&#13;
<li class="noindent"><span class="literal">temp_directory_path([</span><span class="codestrong">ec</span><span class="literal">])</span> returns a directory for temporary files. The result is guaranteed to be an existing directory.</li>&#13;
</ul>&#13;
<p class="indent">Note that <span class="literal">current_path</span> supports an overload so you can set the current directory (as in <span class="codestrong">cd</span> or <span class="codestrong">chdir</span> on Posix). Simply provide a path argument, as in <span class="literal">current_path(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span>.</p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17ex04">Listing 17-4</a> illustrates several of these functions in action.</p>&#13;
<pre>#include &lt;filesystem&gt;&#13;
#include &lt;iostream&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
int main() {&#13;
  try {&#13;
    const auto temp_path = filesystem::temp_directory_path(); <span class="ent">➊</span>&#13;
    const auto relative = filesystem::relative(temp_path); <span class="ent">➋</span>&#13;
    cout &lt;&lt; boolalpha&#13;
      &lt;&lt; "Temporary directory path: " &lt;&lt; temp_path <span class="ent">➌</span>&#13;
      &lt;&lt; "\nTemporary directory absolute: " &lt;&lt; temp_path.is_absolute() <span class="ent">➍</span>&#13;
      &lt;&lt; "\nCurrent path: " &lt;&lt; filesystem::current_path() <span class="ent">➎</span>&#13;
      &lt;&lt; "\nTemporary directory's relative path: " &lt;&lt; relative <span class="ent">➏</span>&#13;
      &lt;&lt; "\nRelative directory absolute: " &lt;&lt; relative.is_absolute() <span class="ent">➐</span>&#13;
      &lt;&lt; "\nChanging current directory to temp.";&#13;
    filesystem::current_path(temp_path); <span class="ent">➑</span>&#13;
    cout &lt;&lt; "\nCurrent directory: " &lt;&lt; filesystem::current_path(); <span class="ent">➒</span>&#13;
  } catch(const exception&amp; e) {&#13;
    cerr &lt;&lt; "Error: " &lt;&lt; e.what(); <span class="ent">➓</span>&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Temporary directory path: "C:\\Users\\lospi\\AppData\\Local\\Temp\\" <span class="ent">➌</span></span>&#13;
<span class="color1">Temporary directory absolute: true <span class="ent">➍</span></span>&#13;
<span class="color1">Current path: "c:\\Users\\lospi\\Desktop" <span class="ent">➎</span></span>&#13;
<span class="color1">Temporary directory's relative path: "..\\AppData\\Local\\Temp" <span class="ent">➏</span></span>&#13;
<span class="color1">Relative directory absolute: false <span class="ent">➐</span></span>&#13;
<span class="color1">Changing current directory to temp. <span class="ent">➑</span></span>&#13;
<span class="color1">Current directory: "C:\\Users\\lospi\\AppData\\Local\\Temp" <span class="ent">➒</span></span></pre>&#13;
<p class="listing"><a id="ch17ex04"/><em>Listing 17-4: A program using several path composing functions. (Output is from a Windows 10 x64 system.)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_559"/>You construct a path using <span class="literal">temp_directory_path</span>, which returns the system’s directory for temporary files <span class="ent">➊</span>, and then use <span class="literal">relative</span> to determine its relative path <span class="ent">➋</span>. After printing the temporary path <span class="ent">➌</span>, <span class="literal">is_absolute</span> illustrates that this path is absolute <span class="ent">➍</span>. Next, you print the current path <span class="ent">➎</span> and the temporary directory’s path relative to the current path <span class="ent">➏</span>. Because this path is relative, <span class="literal">is_absolute</span> returns <span class="literal">false</span> <span class="ent">➐</span>. Once you change the path to the temporary path <span class="ent">➑</span>, you then print the current directory <span class="ent">➒</span>. Of course, your output will look different from the output in <a href="ch17.xhtml#ch17ex04">Listing 17-4</a>, and you might even get an <span class="literal">exception</span> if your system doesn’t support certain operations <span class="ent">➓</span>. (Recall the warning at the beginning of the chapter: the C++ Standard allows that some environments might not support some or all of the filesystem library.)</p>&#13;
<h4 class="h4" id="ch17lev2sec7"><strong><em>Inspecting File Types</em></strong></h4>&#13;
<p class="noindent">You can inspect a file’s attributes given a path by using the following functions:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">is_block_file(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> determines if <span class="codestrong">p</span> is a <em>block file</em>, a special file in some operating systems (for example, block devices in Linux that allow you to transfer randomly accessible data in fixed-size blocks).</li>&#13;
<li class="noindent"><span class="literal">is_character_file(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> determines if <span class="codestrong">p</span> is a <em>character file</em>, a special file in some operating systems (for example, character devices in Linux that allow you to send and receive single characters).</li>&#13;
<li class="noindent"><span class="literal">is_regular_file(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> determines <span class="codestrong">p</span> is a regular file.</li>&#13;
<li class="noindent"><span class="literal">is_symlink(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> determines if <span class="codestrong">p</span> is a symlink, which is a reference to another file or directory.</li>&#13;
<li class="noindent"><span class="literal">is_empty(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> determines if <span class="codestrong">p</span> is either an empty file or an empty directory.</li>&#13;
<li class="noindent"><span class="literal">is_directory(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> determines if <span class="codestrong">p</span> is a directory.</li>&#13;
<li class="noindent"><span class="literal">is_fifo(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> determines if <span class="codestrong">p</span> is a <em>named pipe</em>, a special kind of interprocess communication mechanism in many operating systems.</li>&#13;
<li class="noindent"><span class="literal">is_socket(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> determines if <span class="codestrong">p</span> is a <em>socket</em>, another special kind of interprocess communication mechanism in many operating systems.</li>&#13;
<li class="noindent"><span class="literal">is_other(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> determines if <span class="codestrong">p</span> is some kind of file other than a regular file, a directory, or a symlink.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch17.xhtml#ch17ex05">Listing 17-5</a> uses <span class="literal">is_directory</span> and <span class="literal">is_regular_file</span> to inspect four different paths.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
using namespace std;&#13;
&#13;
void describe(const filesystem::path&amp; p) { <span class="ent">➊</span>&#13;
  cout &lt;&lt; boolalpha &lt;&lt; "Path: " &lt;&lt; p &lt;&lt; endl;&#13;
  try {&#13;
    cout &lt;&lt; "Is directory: " &lt;&lt; filesystem::is_directory(p) &lt;&lt; endl; <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_560"/>    cout &lt;&lt; "Is regular file: " &lt;&lt; filesystem::is_regular_file(p) &lt;&lt; endl; <span class="ent">➌</span>&#13;
  } catch (const exception&amp; e) {&#13;
    cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; endl;&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  filesystem::path win_path{ R"(C:/Windows/System32/kernel32.dll)" };&#13;
  describe(win_path); <span class="ent">➍</span>&#13;
  win_path.remove_filename();&#13;
  describe(win_path); <span class="ent">➎</span>&#13;
&#13;
  filesystem::path nix_path{ R"(/bin/bash)" };&#13;
  describe(nix_path); <span class="ent">➏</span>&#13;
  nix_path.remove_filename();&#13;
  describe(nix_path); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch17ex05"/><em>Listing 17-5: A program inspecting four iconic Windows and Linux paths with <span class="literal">is_director</span><span class="literal">y</span> and <span class="literal">is_regular_file</span>.</em></p>&#13;
<p class="indent">On a Windows 10 x64 machine, running the program in <a href="ch17.xhtml#ch17ex05">Listing 17-5</a> yielded the following output:</p>&#13;
<pre>Path: "C:/Windows/System32/kernel32.dll" <span class="ent">➍</span>&#13;
Is directory: false <span class="ent">➍</span>&#13;
Is regular file: true <span class="ent">➍</span>&#13;
Path: "C:/Windows/System32/" <span class="ent">➎</span>&#13;
Is directory: true <span class="ent">➎</span>&#13;
Is regular file: false <span class="ent">➎</span>&#13;
Path: "/bin/bash" <span class="ent">➏</span>&#13;
Is directory: false <span class="ent">➏</span>&#13;
Is regular file: false <span class="ent">➏</span>&#13;
Path: "/bin/" <span class="ent">➐</span>&#13;
Is directory: false <span class="ent">➐</span>&#13;
Is regular file: false <span class="ent">➐</span></pre>&#13;
<p class="indent">And on an Ubuntu 18.04 x64 machine, running the program in <a href="ch17.xhtml#ch17ex05">Listing 17-5</a> yielded the following output:</p>&#13;
<pre>Path: "C:/Windows/System32/kernel32.dll" <span class="ent">➍</span>&#13;
Is directory: false <span class="ent">➍</span>&#13;
Is regular file: false <span class="ent">➍</span>&#13;
Path: "C:/Windows/System32/" <span class="ent">➎</span>&#13;
Is directory: false <span class="ent">➎</span>&#13;
Is regular file: false <span class="ent">➎</span>&#13;
Path: "/bin/bash" <span class="ent">➏</span>&#13;
Is directory: false <span class="ent">➏</span>&#13;
Is regular file: true <span class="ent">➏</span>&#13;
Path: "/bin/" <span class="ent">➐</span>&#13;
Is directory: true <span class="ent">➐</span>&#13;
Is regular file: false <span class="ent">➐</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_561"/>First, you define the <span class="literal">describe</span> function, which takes a single <span class="literal">path</span> <span class="ent">➊</span>. After printing the path, you also print whether the path is a directory <span class="ent">➋</span> or a regular file <span class="ent">➌</span>. Within <span class="literal">main</span>, you pass four different paths to <span class="literal">describe</span>:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">C:/Windows/System32/kernel32.dll</span> <span class="ent">➍</span></li>&#13;
<li class="noindent"><span class="literal">C:/Windows/System32/</span> <span class="ent">➎</span></li>&#13;
<li class="noindent"><span class="literal">/bin/bash</span> <span class="ent">➏</span></li>&#13;
<li class="noindent"><span class="literal">/bin/</span> <span class="ent">➐</span></li>&#13;
</ul>&#13;
<p class="indent">Note that the result is operating system specific.</p>&#13;
<h4 class="h4" id="ch17lev2sec8"><strong><em>Inspecting Files and Directories</em></strong></h4>&#13;
<p class="noindent">You can inspect various filesystem attributes using the following functions:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">current_path([</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">ec</span><span class="literal">])</span>, which, if <span class="codestrong">p</span> is provided, sets the program’s current path to <span class="codestrong">p</span>; otherwise, it returns the program’s current path.</li>&#13;
<li class="noindent"><span class="literal">exists(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> returns whether a file or directory exists at <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><span class="literal">equivalent(</span><span class="codestrong">p1, p2</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> returns whether <span class="codestrong">p1</span> and <span class="codestrong">p2</span> refer to the same file or directory.</li>&#13;
<li class="noindent"><span class="literal">file_size(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> returns the size in bytes of the regular file at <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><span class="literal">hard_link_count(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> returns the number of hard links for <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><span class="literal">last_write_time(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">t</span><span class="literal">] [</span><span class="codestrong">ec</span><span class="literal">])</span>, which, if <span class="codestrong">t</span><span class="literal">ec</span><span class="literal">t</span> is provided, sets <span class="codestrong">p</span>’s last modified time to <span class="codestrong">t</span>; otherwise, it returns the last time <span class="codestrong">p</span> was modified. (<span class="codestrong">t</span> is a <span class="literal">std::chrono::time_point</span>.)</li>&#13;
<li class="noindent"><span class="literal">permissions(</span><span class="codestrong">p, prm</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> sets <span class="codestrong">p</span>’s permissions. <span class="codestrong">prm</span> is of type <span class="literal">std::filesystem::perms</span>, which is an enum class modeled after POSIX permission bits. (Refer to [fs.enum.perms].)</li>&#13;
<li class="noindent"><span class="literal">read_symlink(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> returns the target of the symlink <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><span class="literal">space(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> returns space information about the filesystem <span class="codestrong">p</span> occupies in the form of a <span class="literal">std::filesystem::space_info</span>. This POD contains three fields: capacity (the total size), <span class="literal">free</span> (the free space), and <span class="literal">available</span> (the free space available to a non-privileged process). All are an unsigned integer type, measured in bytes.</li>&#13;
<li class="noindent"><span class="literal">status(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> returns the type and attributes of the file or directory <span class="codestrong">p</span> in the form of a <span class="literal">std::filesystem::file_status</span>. This class contains a <span class="literal">type</span> method that accepts no parameters and returns an object of type <span class="literal">std::filesystem::file_type</span>, which is an enum class that takes values describing a file’s type, such as <span class="literal">not_found, regular, directory</span>. The <span class="literal">symlink file_status</span> class also offers a <span class="literal">permissions</span> method that accepts no parameters and returns an object of type <span class="literal">std::filesystem::perms</span>. (Refer to [fs.class.file_status] for details.)</li>&#13;
<li class="noindent"><span class="literal">symlink_status(</span><span class="codestrong">p</span>, <span class="literal">[</span><span class="codestrong">ec</span><span class="literal">])</span> is like a status that won’t follow symlinks.</li>&#13;
</ul>&#13;
<p class="indent">If you’re familiar with Unix-like operating systems, you’ve no doubt used the <span class="literal">ls</span> (short for “list”) program many times to enumerate files and <span epub:type="pagebreak" id="page_562"/>directories. On DOS-like operating systems (including Windows), you have the analogous <span class="literal">dir</span> command. You’ll use several of these functions later in the chapter (in <a href="ch17.xhtml#ch17ex07">Listing 17-7</a>) to build your own simple listing program.</p>&#13;
<p class="indent">Now that you know how to inspect files and directories, let’s turn to how you can manipulate the files and directories your paths refer to.</p>&#13;
<h4 class="h4" id="ch17lev2sec9"><strong><em>Manipulating Files and Directories</em></strong></h4>&#13;
<p class="noindent">Additionally, the Filesystem library contains a number of methods for manipulating files and directories:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">copy(</span><span class="codestrong">p1, p2</span>, <span class="literal">[</span><span class="codestrong">opt</span><span class="literal">], [</span><span class="codestrong">ec</span><span class="literal">])</span> copies files or directories from <span class="codestrong">p1</span> to <span class="codestrong">p2</span>. You can provide a <span class="literal">std::filesystem::copy_options</span> <span class="literal">opt</span> to customize the behavior of <span class="literal">copy_file</span>. This <span class="literal">enum</span> class can take several values, including none (report an error if the destination already exists), <span class="literal">skip_existing</span> (to keep existing), <span class="literal">overwrite_existing</span> (to overwrite), and <span class="literal">update_existing</span> (to overwrite if <span class="codestrong">p1</span> is newer). (Refer to <strong>[</strong>fs.enum.copy.opts<strong>]</strong> for details.)</li>&#13;
<li class="noindent"><span class="literal">copy_file(</span><span class="codestrong">p1, p2</span>, <span class="literal">[</span><span class="codestrong">opt</span><span class="literal">], [</span><span class="codestrong">ec</span><span class="literal">])</span> is like copy except it will generate anerror if <span class="codestrong">p1</span> is anything but a regular file.</li>&#13;
<li class="noindent"><span class="literal">copy_file</span><span class="literal">(</span><span class="codestrong">p1</span><span class="literal">,</span> <span class="codestrong">p2</span><span class="literal">, [</span><span class="codestrong">opt</span><span class="literal">], [</span><span class="codestrong">ec</span><span class="literal">])</span> is like copy except it will generate an error if <span class="codestrong">p1</span> is anything but a regular file.</li>&#13;
<li class="noindent"><span class="literal">create_directory</span><span class="literal">(</span><span class="codestrong">p</span><span class="literal">, [</span><span class="codestrong">ec</span><span class="literal">])</span> creates the directory <span class="codestrong">p</span>.</li>&#13;
<li class="noindent"><span class="literal">create_directories</span><span class="literal">(</span><span class="codestrong">p</span><span class="literal">, [</span><span class="codestrong">ec</span><span class="literal">])</span> is like calling <span class="literal">create_directory</span> recursively, so if a nested path contains parents that don’t exist, use this form.</li>&#13;
<li class="noindent"><span class="literal">create_hard_link</span><span class="literal">(</span><span class="codestrong">tgt</span><span class="literal">,</span> <span class="codestrong">lnk</span><span class="literal">, [</span><span class="codestrong">ec</span><span class="literal">])</span> creates a hard link to <span class="codestrong">tgt</span> at <span class="codestrong">lnk</span>.</li>&#13;
<li class="noindent"><span class="literal">create_symlink</span><span class="literal">(</span><span class="codestrong">tgt</span><span class="literal">,</span> <span class="codestrong">lnk</span><span class="literal">, [</span><span class="codestrong">ec</span><span class="literal">])</span> creates a symlink to <span class="codestrong">tgt</span> at <span class="codestrong">lnk</span>.</li>&#13;
<li class="noindent"><span class="literal">create_directory_symlink</span><span class="literal">(</span><span class="codestrong">tgt</span><span class="literal">,</span> <span class="codestrong">lnk</span><span class="literal">, [</span><span class="codestrong">ec</span><span class="literal">])</span> should be used for directories instead of <span class="literal">create_symlink</span>.</li>&#13;
<li class="noindent"><span class="literal">remove</span><span class="literal">(</span><span class="codestrong">p</span><span class="literal">, [</span><span class="codestrong">ec</span><span class="literal">])</span> removes a file or empty directory <span class="codestrong">p</span> (without following symlinks).</li>&#13;
<li class="noindent"><span class="literal">remove_all</span><span class="literal">(</span><span class="codestrong">p</span><span class="literal">, [</span><span class="codestrong">ec</span><span class="literal">])</span> removes a file or directory recursively <span class="codestrong">p</span> (without following symlinks).</li>&#13;
<li class="noindent"><span class="literal">rename</span><span class="literal">(</span><span class="codestrong">p1</span><span class="literal">,</span> <span class="codestrong">p2</span><span class="literal">, [</span><span class="codestrong">ec</span><span class="literal">])</span> renames <span class="codestrong">p1</span> to <span class="codestrong">p2</span>.</li>&#13;
<li class="noindent"><span class="literal">resize_file</span><span class="literal">(</span><span class="codestrong">p</span><span class="literal">,</span> <span class="codestrong">new_size</span><span class="literal">, [</span><span class="codestrong">ec</span><span class="literal">])</span> changes the size of <span class="codestrong">p</span> (if it’s a regular file) to <span class="codestrong">new_size</span>. If this operation grows the file, zeros fill the new space. Otherwise, the operation trims <span class="codestrong">p</span> from the end.</li>&#13;
</ul>&#13;
<p class="indent">You can create a program that copies, resizes, and deletes a file using several of these methods. <a href="ch17.xhtml#ch17ex06">Listing 17-6</a> illustrates this by defining a function that prints file size and modification time. In <span class="literal">main</span>, the program creates and modifies two <span class="literal">path</span> objects, and it invokes that function after each modification.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
using namespace std;&#13;
using namespace std::filesystem;&#13;
using namespace std::chrono;&#13;
<span epub:type="pagebreak" id="page_563"/>&#13;
void write_info(const path&amp; p) {&#13;
  if (!exists(p)) { <span class="ent">➊</span>&#13;
    cout &lt;&lt; p &lt;&lt; " does not exist." &lt;&lt; endl;&#13;
    return;&#13;
  }&#13;
  const auto last_write = last_write_time(p).time_since_epoch();&#13;
  const auto in_hours = duration_cast&lt;hours&gt;(last_write).count();&#13;
  cout &lt;&lt; p &lt;&lt; "\t" &lt;&lt; in_hours &lt;&lt; "\t" &lt;&lt; file_size(p) &lt;&lt; "\n"; <span class="ent">➋</span>&#13;
}&#13;
&#13;
int main() {&#13;
  const path win_path{ R"(C:/Windows/System32/kernel32.dll)" }; <span class="ent">➌</span>&#13;
  const auto reamde_path = temp_directory_path() / "REAMDE"; <span class="ent">➍</span>&#13;
  try {&#13;
    write_info(win_path); <span class="ent">➎</span>&#13;
    write_info(reamde_path); <span class="ent">➏</span>&#13;
&#13;
    cout &lt;&lt; "Copying " &lt;&lt; win_path.filename()&#13;
         &lt;&lt; " to " &lt;&lt; reamde_path.filename() &lt;&lt; "\n";&#13;
    copy_file(win_path, reamde_path);&#13;
    write_info(reamde_path); <span class="ent">➐</span>&#13;
&#13;
    cout &lt;&lt; "Resizing " &lt;&lt; reamde_path.filename() &lt;&lt; "\n";&#13;
    resize_file(reamde_path, 1024);&#13;
    write_info(reamde_path); <span class="ent">➑</span>&#13;
&#13;
    cout &lt;&lt; "Removing " &lt;&lt; reamde_path.filename() &lt;&lt; "\n";&#13;
    remove(reamde_path);&#13;
    write_info(reamde_path); <span class="ent">➒</span>&#13;
  } catch(const exception&amp; e) {&#13;
    cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; endl;&#13;
  }&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">"C:/Windows/System32/kernel32.dll"      3657767 720632 <span class="ent">➎</span></span>&#13;
<span class="color1">"C:\\Users\\lospi\\AppData\\Local\\Temp\\REAMDE" does not exist. <span class="ent">➏</span></span>&#13;
<span class="color1">Copying "kernel32.dll" to "REAMDE"</span>&#13;
<span class="color1">"C:\\Users\\lospi\\AppData\\Local\\Temp\\REAMDE"        3657767 720632 <span class="ent">➐</span></span>&#13;
<span class="color1">Resizing "REAMDE"</span>&#13;
<span class="color1">"C:\\Users\\lospi\\AppData\\Local\\Temp\\REAMDE"        3659294 1024 <span class="ent">➑</span></span>&#13;
<span class="color1">Removing "REAMDE"</span>&#13;
<span class="color1">"C:\\Users\\lospi\\AppData\\Local\\Temp\\REAMDE" does not exist. <span class="ent">➒</span></span></pre>&#13;
<p class="listing"><a id="ch17ex06"/><em>Listing 17-6: A program illustrating several methods for interacting with the filesystem. (Output is from a Windows 10 x64 system.)</em></p>&#13;
<p class="indent">The <span class="literal">write_info</span> function takes a single <span class="literal">path</span> parameter. You check whether this path exists <span class="ent">➊</span>, printing an error message and returning immediately if it doesn’t. If the <span class="literal">path</span> does exist, you print a message indicating its last modification time (in hours since epoch) and its file size <span class="ent">➋</span>.</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you create a path <span class="literal">win_path</span> to <span class="literal">kernel32.dll</span> <span class="ent">➌</span> and a path to a nonexistent file called <span class="literal">REAMDE</span> in the filesystem’s temporary file directory at <span class="literal">reamde_path</span> <span class="ent">➍</span>. (Recall from <a href="ch17.xhtml#ch17tab01">Table 17-1</a> that you can use <span class="literal">operator/</span> to <span epub:type="pagebreak" id="page_564"/>concatenate two path objects.) Within a <span class="literal">try</span>-<span class="literal">catch</span> block, you invoke <span class="literal">write_info</span> on both paths <span class="ent">➎➏</span>. (If you’re using a non-Windows machine, you’ll get different output. You can modify <span class="literal">win_path</span> to an existing file on your system to follow along.)</p>&#13;
<p class="indent">Next, you copy the file at <span class="literal">win_path</span> to <span class="literal">reamde_path</span> and invoke <span class="literal">write_info</span> on it <span class="ent">➐</span>. Notice that, as opposed to earlier <span class="ent">➏</span>, the file at <span class="literal">reamde_path</span> exists and it has the same last write time and file size as <span class="literal">kernel32.dll</span>.</p>&#13;
<p class="indent">You then resize the file at <span class="literal">reamde_path</span> to 1024 bytes and invoke <span class="literal">write_info</span> <span class="ent">➑</span>. Notice that the last write time increased from 3657767 to 3659294 and the file size decreased from 720632 to 1024.</p>&#13;
<p class="indent">Finally, you remove the file at <span class="literal">reamde_path</span> and invoke <span class="literal">write_info</span> <span class="ent">➒</span>, which tells you that the file again no longer exists.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>How filesystems resize files behind the scenes varies by operating system and is beyond the scope of this book. But you can think of how a resize operation might work conceptually as the <span class="literal">resize</span> operation on a <span class="literal">std::vector</span>. All the data at the end of the file that doesn’t fit into the file’s new size is discarded by the operating system.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch17lev1sec4"><strong>Directory Iterators</strong></h3>&#13;
<p class="noindent">The Filesystem library provides two classes for iterating over the elements of a directory: <span class="literal">std::filesystem::directory_iterator</span> and <span class="literal">std::filesystem::recursive_directory_iterator</span>. A <span class="literal">directory_iterator</span> won’t enter subdirectories, but the <span class="literal">recursive_directory_iterator</span> will. This section introduces the <span class="literal">directory_iterator</span>, but the <span class="literal">recursive_directory_iterator</span> is a drop-in replacement and supports all the following operations.</p>&#13;
<h4 class="h4" id="ch17lev2sec10"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">The default constructor of <span class="literal">directory_iterator</span> produces the end iterator. (Recall that an input end iterator indicates when an input range is exhausted.) Another constructor accepts path, which indicates the directory you want to enumerate. Optionally, you can provide <span class="literal">std::filesystem::directory_options</span>, which is an <span class="literal">enum</span> class bitmask with the following constants:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">none</span> directs the iterator to skip directory symlinks. If the iterator encounters a permission denial, it produces an error.</li>&#13;
<li class="noindent"><span class="literal">follow_directory_symlink</span> follows symlinks.</li>&#13;
<li class="noindent"><span class="literal">skip_permission_denied</span> skips directories if the iterator encounters a permission denial.</li>&#13;
</ul>&#13;
<p class="indent">Additionally, you can provide a <span class="literal">std::error_code</span>, which, like all other Filesystem library functions that accept an <span class="literal">error_code</span>, will set this parameter rather than throwing an exception if an error occurs during construction.</p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17tab02">Table 17-2</a> summarizes these options for constructing a <span class="literal">directory_iterator</span>. Note that <span class="literal">p</span> is <span class="literal">path</span> and <span class="literal">d</span> is <span class="literal">directory</span>, <span class="literal">op</span> is <span class="literal">directory_options</span>, and <span class="literal">ec</span> is <span class="literal">error_code</span> in the table.</p>&#13;
<p class="tabcap" id="ch17tab02"><span epub:type="pagebreak" id="page_565"/><strong>Table 17-2:</strong> A Summary of <span class="literal">std::filestystem::directory_iterator</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th">Operation</p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th">Notes</p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">directory_iterator{}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructs the end iterator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">directory_iterator{</span> <span class="codestrong">p</span><span class="literal">, [</span><span class="codestrong">op</span><span class="literal">], [</span><span class="codestrong">ec</span><span class="literal">] }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Constructs a directory iterator referring to the directory <span class="codestrong">p</span>. The argument <span class="codestrong">op</span> defaults to <span class="literal">none</span>. If provided, <span class="codestrong">ec</span> receives error conditions rather than throwing an exception.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">directory_iterator {</span> <span class="codestrong">d</span> <span class="literal"> }</span></p>&#13;
<p class="taba"><span class="codestrong">d1</span> <span class="literal">=</span> <span class="codestrong">d2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copies construction/assignment.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">directory_iterator { move(</span><span class="codestrong">d</span><span class="literal">) }</span></p>&#13;
<p class="taba"><span class="codestrong">d1</span> <span class="literal"> = move(</span><span class="codestrong">d2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Moves construction/assignment.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch17lev2sec11"><strong>Directory Entries</strong></h4>&#13;
<p class="indent">The input iterators <span class="literal">directory_iterator</span> and <span class="literal">recursive_directory_iterator</span> produce a <span class="literal">std::filesystem::directory_entry</span> element for each entry they encounter. The <span class="literal">directory_entry</span> class stores a <span class="literal">path</span>, as well as some attributes about that <span class="literal">path</span> exposed as methods. <a href="ch17.xhtml#ch17tab03">Table 17-3</a> lists these methods. Note that <span class="literal">de</span> is a <span class="literal">directory_entry</span> in the table.</p>&#13;
<p class="tabcap"><a id="ch17tab03"/><strong>Table 17-3:</strong> A Summary of <span class="literal">std::filesystem::directory_entry</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th">Operation</p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th">Description</p></td>&#13;
</tr></thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><span class="literal">.path()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the referenced path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><span class="literal">.exists()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if the referenced path exists on the filesystem.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><span class="literal">.is_block_file()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <span class="literal">true</span> if the referenced path is a block device.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><span class="literal">.is_character_file()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if the referenced path is a character device.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><span class="literal">.is_directory()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <span class="literal">true</span> if the referenced path is a directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><span class="literal">.is_fifo()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if the referenced path is a named pipe.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><span class="literal">.is_regular_file()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <span class="literal">true</span> if the referenced path is a regular file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><span class="literal">.is_socket()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if the referenced path is a socket.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><span class="literal">.is_symlink()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <span class="literal">true</span> if the referenced path is a symlink</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><span class="literal">.is_other()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if the referenced path is something else.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><span class="literal">.file_size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the size of the referenced path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">de</span><span class="literal">.hard_link_count()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the number of hard links to the referenced path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">de</span><span class="literal">.last_write_time([</span><span class="codestrong">t</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If <span class="literal">t</span> is provided, sets the last modified time of the referenced path; otherwise, it returns the last modified time.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">de</span><span class="literal">.status()</span><br/><span class="codestrong">de</span><span class="literal">.symlink_status()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns a <span class="literal">std::filesystem::file_status</span> for the referenced path.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can employ <span class="literal">directory_iterator</span> and several of the operations in <a href="ch17.xhtml#ch17tab03">Table 17-3</a> to create a simple directory-listing program, as <a href="ch17.xhtml#ch17ex07">Listing 17-7</a> illustrates.</p>&#13;
<pre><span epub:type="pagebreak" id="page_566"/>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
#include &lt;iomanip&gt;&#13;
&#13;
using namespace std;&#13;
using namespace std::filesystem;&#13;
using namespace std::chrono;&#13;
&#13;
void describe(const directory_entry&amp; entry) { <span class="ent">➊</span>&#13;
  try {&#13;
    if (entry.is_directory()) { <span class="ent">➋</span>&#13;
      cout &lt;&lt; "           *";&#13;
    } else {&#13;
      cout &lt;&lt; setw(12) &lt;&lt; entry.file_size();&#13;
    }&#13;
    const auto lw_time =&#13;
      duration_cast&lt;seconds&gt;(entry.last_write_time().time_since_epoch());&#13;
    cout &lt;&lt; setw(12) &lt;&lt; lw_time.count()&#13;
      &lt;&lt; " " &lt;&lt; entry.path().filename().string()&#13;
      &lt;&lt; "\n"; <span class="ent">➌</span>&#13;
  } catch (const exception&amp; e) {&#13;
    cout &lt;&lt; "Error accessing " &lt;&lt; entry.path().string()&#13;
         &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; endl; <span class="ent">➍</span>&#13;
  }&#13;
}&#13;
&#13;
int main(int argc, const char** argv) {&#13;
  if (argc != 2) {&#13;
    cerr &lt;&lt; "Usage: listdir PATH";&#13;
    return -1; <span class="ent">➎</span>&#13;
  }&#13;
  const path sys_path{ argv[1] }; <span class="ent">➏</span>&#13;
  cout &lt;&lt; "Size         Last Write  Name\n";&#13;
  cout &lt;&lt; "------------ ----------- ------------\n"; <span class="ent">➐</span>&#13;
  for (const auto&amp; entry : directory_iterator{ sys_path }) <span class="ent">➑</span>&#13;
    describe(entry); <span class="ent">➒</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="codestrong1">&gt; listdir c:\Windows</span>&#13;
<span class="color1">Size         Last Write  Name</span>&#13;
<span class="color1">------------ ----------- ------------</span>&#13;
<span class="color1">           * 13177963504 addins</span>&#13;
<span class="color1">           * 13171360979 appcompat</span>&#13;
<span class="color1"><span class="codeitalic1">--snip--</span></span>&#13;
<span class="color1">           * 13173551028 WinSxS</span>&#13;
<span class="color1">      316640 13167963236 WMSysPr9.prx</span>&#13;
<span class="color1">       11264 13167963259 write.exe</span></pre>&#13;
<p class="listing"><a id="ch17ex07"/><em>Listing 17-7: A file- and directory-listing program that uses <span class="literal">std::filesystem::directory_iterator</span> to enumerate a given directory. (Output is from a Windows 10 x64 system.)</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You should modify the program’s name from <span class="literal">listdir</span> to whatever value matches your compiler’s output.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_567"/>You first define a <span class="literal">describe</span> function that takes a <span class="literal">path</span> reference <span class="ent">➊</span>, which checks whether the path is a directory <span class="ent">➋</span> and prints an asterisk for a directory and a corresponding size for a file. Next, you determine the entry’s last modification in seconds since epoch and print it along with the entry’s associated filename <span class="ent">➌</span>. If any exception occurs, you print an error message and return <span class="ent">➍</span>.</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you first check that the user invoked your program with a single argument and return with a negative number if not <span class="ent">➎</span>. Next, you construct a path using the single argument <span class="ent">➏</span>, print some fancy headers for your output <span class="ent">➐</span>, iterate over each <span class="literal">entry</span> in the directory <span class="ent">➑</span>, and pass it to <span class="literal">describe</span> <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch17lev2sec12"><strong><em>Recursive Directory Iteration</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">recursive_directory_iterator</span> is a drop-in replacement for <span class="literal">directory_iterator</span> in the sense that it supports all the same operations but will enumerate subdirectories. You can use these iterators in combination to build a program that computes the size and quantity of files and subdirectories for a given directory. <a href="ch17.xhtml#ch17ex08">Listing 17-8</a> illustrates how.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;filesystem&gt;&#13;
&#13;
using namespace std;&#13;
using namespace std::filesystem;&#13;
&#13;
struct Attributes {&#13;
  Attributes&amp; operator+=(const Attributes&amp; other) {&#13;
    this-&gt;size_bytes += other.size_bytes;&#13;
    this-&gt;n_directories += other.n_directories;&#13;
    this-&gt;n_files += other.n_files;&#13;
    return *this;&#13;
  }&#13;
  size_t size_bytes;&#13;
  size_t n_directories;&#13;
  size_t n_files;&#13;
}; <span class="ent">➊</span>&#13;
&#13;
void print_line(const Attributes&amp; attributes, string_view path) {&#13;
  cout &lt;&lt; setw(14) &lt;&lt; attributes.size_bytes&#13;
       &lt;&lt; setw(7) &lt;&lt; attributes.n_files&#13;
       &lt;&lt; setw(7) &lt;&lt; attributes.n_directories&#13;
       &lt;&lt; " " &lt;&lt; path &lt;&lt; "\n"; <span class="ent">➋</span>&#13;
}&#13;
&#13;
Attributes explore(const directory_entry&amp; directory) {&#13;
  Attributes attributes{};&#13;
  for(const auto&amp; entry : recursive_directory_iterator{ directory.path() }) { <span class="ent">➌</span>&#13;
      if (entry.is_directory()) {&#13;
        attributes.n_directories++; <span class="ent">➍</span>&#13;
      } else {&#13;
        attributes.n_files++;&#13;
<span epub:type="pagebreak" id="page_568"/>        attributes.size_bytes += entry.file_size(); <span class="ent">➎</span>&#13;
      }&#13;
  }&#13;
  return attributes;&#13;
}&#13;
&#13;
int main(int argc, const char** argv) {&#13;
  if (argc != 2) {&#13;
    cerr &lt;&lt; "Usage: treedir PATH";&#13;
    return -1; <span class="ent">➏</span>&#13;
  }&#13;
  const path sys_path{ argv[1] };&#13;
  cout &lt;&lt; "Size           Files  Dirs   Name\n";&#13;
  cout &lt;&lt; "-------------- ------ ------ ------------\n";&#13;
  Attributes root_attributes{};&#13;
  for (const auto&amp; entry : directory_iterator{ sys_path }) { <span class="ent">➐</span>&#13;
    try {&#13;
      if (entry.is_directory()) {&#13;
        const auto attributes = explore(entry); <span class="ent">➑</span>&#13;
        root_attributes += attributes;&#13;
        print_line(attributes, entry.path().string());&#13;
        root_attributes.n_directories++;&#13;
      } else {&#13;
        root_attributes.n_files++;&#13;
        error_code ec;&#13;
        root_attributes.size_bytes += entry.file_size(ec); <span class="ent">➒</span>&#13;
        if (ec) cerr &lt;&lt; "Error reading file size: "&#13;
                     &lt;&lt; entry.path().string() &lt;&lt; endl;&#13;
      }&#13;
    } catch(const exception&amp;) {&#13;
    }&#13;
  }&#13;
  print_line(root_attributes, argv[1]); <span class="ent">➓</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">&gt; treedir C:\Windows</span>&#13;
<span class="color1">Size         Files  Dirs Name</span>&#13;
<span class="color1">------------ ----- ----- ------------</span>&#13;
<span class="color1">           802      1      0 C:\Windows\addins</span>&#13;
<span class="color1">       8267330      9      5 C:\Windows\apppatch</span>&#13;
<span class="color1"><span class="codeitalic1">--snip--</span></span>&#13;
<span class="color1">   11396916465  73383  20480 C:\Windows\WinSxS</span>&#13;
<span class="color1">   21038460348 110950  26513 C:\Windows <span class="ent">➓</span></span></pre>&#13;
<p class="listing"><a id="ch17ex08"/><em>Listing 17-8: A file- and directory-listing program that uses <span class="literal">std::filesystem::recursive_directory_iterator</span> to list the number of files and total size of a given path’s subdirectory.    (Output is from a Windows 10 x64 system.)</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You should modify the program’s name from <span class="literal">treedir</span> to whatever value matches your compiler’s output.</em></p>&#13;
</div>&#13;
<p class="indent">After declaring the <span class="literal">Attributes</span> class for storing accounting data <span class="ent">➊</span>, you define a <span class="literal">print_line</span> function that presents an <span class="literal">Attributes</span> instance in a user-friendly way alongside a path string <span class="ent">➋</span>. Next, you define an <span class="literal">explore</span> function <span epub:type="pagebreak" id="page_569"/>that accepts a <span class="literal">directory_entry</span> reference and iterates over it recursively <span class="ent">➌</span>. If the resulting <span class="literal">entry</span> is a directory, you increment the directory count <span class="ent">➍</span>; otherwise, you increment the file count and total size <span class="ent">➎</span>.</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you check that the program invoked with exactly two arguments. If not, you return with an error code -1 <span class="ent">➏</span>. You employ a (non-recursive) <span class="literal">directory_iterator</span> to enumerate the contents of the target path referred by <span class="literal">sys_path</span> <span class="ent">➐</span>. If an <span class="literal">entry</span> is a directory, you invoke <span class="literal">explore</span> to determine its attributes <span class="ent">➑</span>, which you subsequently print to the console. You also increment the <span class="literal">n_directories</span> member of <span class="literal">root_attributes</span> to keep account. If the <span class="literal">entry</span> isn’t a directory, you add to the <span class="literal">n_files</span> and <span class="literal">size_bytes</span> members of <span class="literal">root_attributes</span> accordingly <span class="ent">➒</span>.</p>&#13;
<p class="indent">Once you’ve completed iterating over all <span class="literal">sys_path</span> subelements, you print <span class="literal">root_attributes</span> as the final line <span class="ent">➓</span>. The final line of output in <a href="ch17.xhtml#ch17ex08">Listing 17-8</a>, for example, shows that this particular Windows directory contains 110,950 files occupying 21,038,460,348 bytes (about 21GB) and 26,513 subdirectories.</p>&#13;
<h3 class="h3" id="ch17lev1sec5"><strong>fstream Interoperation</strong></h3>&#13;
<p class="noindent">You can construct file streams (<span class="literal">basic_ifstream</span>, <span class="literal">basic_ofstream</span>, or <span class="literal">basic_</span><span class="literal">fstream</span>) using <span class="literal">std::filesystem::path</span> or <span class="literal">std::filesystem::directory_entry</span> in addition to string types.</p>&#13;
<p class="indent">For example, you can iterate over a directory and construct an <span class="literal">ifstream</span> to read each file you encounter. <a href="ch17.xhtml#ch17ex09">Listing 17-9</a> illustrates how to check for the magic <span class="literal">MZ</span> bytes at the beginning of each Windows portable executable file (a <em>.sys</em>, a <em>.dll</em>, a <em>.exe</em>, and so on) and report any file that violates this rule.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;fstream&gt;&#13;
#include &lt;filesystem&gt;&#13;
#include &lt;unordered_set&gt;&#13;
&#13;
using namespace std;&#13;
using namespace std::filesystem;&#13;
&#13;
int main(int argc, const char** argv) {&#13;
  if (argc != 2) {&#13;
    cerr &lt;&lt; "Usage: pecheck PATH";&#13;
    return -1; <span class="ent">➊</span>&#13;
  }&#13;
  const unordered_set&lt;string&gt; pe_extensions{&#13;
    ".acm", ".ax",  ".cpl", ".dll", ".drv",&#13;
    ".efi", ".exe", ".mui", ".ocx", ".scr",&#13;
    ".sys", ".tsp"&#13;
  }; <span class="ent">➋</span>&#13;
  const path sys_path{ argv[1] };&#13;
  cout &lt;&lt; "Searching " &lt;&lt; sys_path &lt;&lt; " recursively.\n";&#13;
  size_t n_searched{};&#13;
  auto iterator = recursive_directory_iterator{ sys_path,&#13;
                                 directory_options::skip_permission_denied }; <span class="ent">➌</span>&#13;
  for (const auto&amp; entry : iterator) { <span class="ent">➍</span>&#13;
    try {&#13;
<span epub:type="pagebreak" id="page_570"/>      if (!entry.is_regular_file()) continue;&#13;
      const auto&amp; extension = entry.path().extension().string();&#13;
      const auto is_pe = pe_extensions.find(extension) != pe_extensions.end();&#13;
      if (!is_pe) continue; <span class="ent">➎</span>&#13;
      ifstream file{ entry.path() }; <span class="ent">➏</span>&#13;
      char first{}, second{};&#13;
      if (file) file &gt;&gt; first;&#13;
      if (file) file &gt;&gt; second; <span class="ent">➐</span>&#13;
      if (first != 'M' || second != 'Z')&#13;
        cout &lt;&lt; "Invalid PE found: " &lt;&lt; entry.path().string() &lt;&lt; "\n"; <span class="ent">➑</span>&#13;
      ++n_searched;&#13;
    } catch(const exception&amp; e) {&#13;
      cerr &lt;&lt; "Error reading " &lt;&lt; entry.path().string()&#13;
           &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; endl;&#13;
    }&#13;
  }&#13;
  cout &lt;&lt; "Searched " &lt;&lt; n_searched &lt;&lt; " PEs for magic bytes." &lt;&lt; endl; <span class="ent">➒</span>&#13;
}&#13;
----------------------------------------------------------------------&#13;
<span class="color1">listing_17_9.exe c:\Windows\System32</span>&#13;
<span class="color1">Searching "c:\\Windows\\System32" recursively.</span>&#13;
<span class="color1">Searched 8231 PEs for magic bytes.</span></pre>&#13;
<p class="listing"><a id="ch17ex09"/><em>Listing 17-9: Searching the Windows System32 directory for Windows portable executable files</em></p>&#13;
<p class="indent">In <span class="literal">main</span>, you check for exactly two arguments and return an error code as appropriate <span class="ent">➊</span>. You construct an <span class="literal">unordered_set</span> containing all the extensions associated with portable executable files <span class="ent">➋</span>, which you’ll use to check file extensions. You use a <span class="literal">recursive_directory_iterator</span> with the <span class="literal">directory_options::skip_permission_denied</span> option to enumerate all the files in the specified path <span class="ent">➌</span>. You iterate over each entry <span class="ent">➍</span>, skipping over anything that’s not a regular file, and you determine whether the entry is a portable executable by attempting to <span class="literal">find</span> it in <span class="literal">pe_extensions</span>. If the entry doesn’t have such an extension, you skip over the file <span class="ent">➎</span>.</p>&#13;
<p class="indent">To open the file, you simply pass the path of the <span class="literal">entry</span> into the constructor of <span class="literal">ifstream</span> <span class="ent">➏</span>. You then use the resulting input file stream to read the first two bytes of the file into <span class="literal">first</span> and <span class="literal">second</span> <span class="ent">➐</span>. If these first two characters aren’t <span class="literal">MZ</span>, you print a message to the console <span class="ent">➑</span>. Either way, you increment a counter called <span class="literal">n_searched</span>. After exhausting the directory iterator, you print a message indicating <span class="literal">n_searched</span> to the user before returning from <span class="literal">main</span> <span class="ent">➒</span>.</p>&#13;
<h3 class="h3" id="ch17lev1sec6"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned about the stdlib filesystem facilities, including paths, files, directories, and error handling. These facilities enable you to write cross-platform code that interacts with the files in your environment. The chapter culminated with some important operations, directory iterators, and interoperation with file streams.</p>&#13;
<div class="box5" id="bm02">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_571"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>17-1.</strong> Implement a program that takes two arguments: a path and an extension. The program should search the given path recursively and print any file with the specified extension.</p>&#13;
<p class="noindent"><strong>17-2.</strong> Improve the program in <a href="ch17.xhtml#ch17ex08">Listing 17-8</a> so it can take an optional second argument. If the first argument begins with a hyphen (<span class="literal">-</span>), the program reads all contiguous letters immediately following the hyphen and parses each letter as an option. The second argument then becomes the path to search. If the list of options contains an <em>R</em>, perform a recursive directory. Otherwise, don’t use a recursive directory iterator.</p>&#13;
<p class="noindent"><strong>17-3.</strong> Refer to the documentation for the <em>dir</em> or <em>ls</em> command and implement as many of the options as possible in your new, improved version of <a href="ch17.xhtml#ch17ex08">Listing 17-8</a>.</p>&#13;
</div>&#13;
<div class="box6" id="bm03">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>Windows NT File System Internals: A Developer’s Guide</em> by Rajeev Nagar (O’Reilly, 1997)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>The Linux Programming Interface: A Linux and UNIX System Programming Handbook</em> by Michael Kerrisk (No Starch Press, 2010)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>