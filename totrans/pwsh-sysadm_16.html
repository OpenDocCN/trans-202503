<html><head></head><body>
<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_193"/><span class="big">14</span><br/>CREATING A SERVER INVENTORY SCRIPT</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">So far in this book, you’ve focused on learning PowerShell as a language, getting familiar with its syntax and commands. But more than a language, PowerShell is a tool. Now that you have a grip on the ins and outs of PowerShell, it’s time for the fun stuff!</span></p>&#13;
<p class="indent">The real power of PowerShell lies in its tool-making abilities. In this context, a <em>tool</em> refers to a PowerShell script, a module, a function, or something that helps you perform a management task. Whether that task is creating a report, gathering information about a computer, creating a company user account, or something more complex, you’ll learn how to automate it with PowerShell.</p>&#13;
<p class="indent">In this chapter, I’ll show you how to collect data with PowerShell so you can make more-informed decisions. Specifically, you’ll build a server inventory project. You’ll learn to create a script with parameters, feed it server names, and discover a wealth of information to peruse: operating system specs as well as hardware information including storage size, free storage, memory, and more.</p>&#13;
<h3 class="h3" id="ch14lev1"><span epub:type="pagebreak" id="page_194"/>Prerequisites</h3>&#13;
<p class="noindent">Before you begin this chapter, you need to have a domain-joined Windows computer, read permission to Active Directory computer objects, an Active Directory organizational unit (OU) of computer accounts, and the Remote Server Administration Toolkit (RSAT) software package, which you can download from <a href="https://www.microsoft.com/en-us/download/details.aspx?id=45520"><em>https://www.microsoft.com/en-us/download/details.aspx?id=45520</em></a>.</p>&#13;
<h3 class="h3" id="ch14lev2">Creating the Project Script(s)</h3>&#13;
<p class="noindent">Since you’ll be building scripts in this chapter and not just executing code at the console, you first need to create a new PowerShell script. Create a script called <em>Get-ServerInformation.ps1</em>. I’ve put mine in <em>C:\</em>. You’ll be adding code to this script throughout the chapter.</p>&#13;
<h3 class="h3" id="ch14lev3">Defining the Final Output</h3>&#13;
<p class="noindent">Before you start coding, it’s good practice to make a “back of the napkin” plan of what you want the output to look like when you’re done. This simple sketch is a great way to measure progress, especially when building large scripts.</p>&#13;
<p class="indent">For this server inventory script, we’ll say that when the script ends, you’d like output to the PowerShell console that looks like this:</p>&#13;
<pre>ServerName  IPAddress  OperatingSystem  AvailableDriveSpace (GB)  Memory (GB)  UserProfilesSize (MB)  StoppedServices&#13;
MYSERVER    x.x.x.x    Windows....      10                        4            50.4                   service1,service2,service3</pre>&#13;
<p class="indent">Now that you know what you want to see, let’s make it happen.</p>&#13;
<h3 class="h3" id="ch14lev4">Discovery and Script Input</h3>&#13;
<p class="noindent">The first step is deciding how to tell your script what to query. You’ll be collecting information from multiple servers. As stated in the “Prerequisites” section, you’ll use Active Directory to find your server names.</p>&#13;
<p class="indent">Of course, you could query server names from text files, from an array of server names stored in a PowerShell script, from the Registry, from a Windows Management Instrumentation (WMI) repository, from databases—it doesn’t matter. As long as somehow, some way, your script ends up with an array of strings representing server names, you’re good to go. For this project, however, you’ll use servers from Active Directory.</p>&#13;
<p class="indent">In this example, all the servers are in a single OU. If you try this on your own and you find that they’re not, that’s okay; you’ll just have to loop through your OUs and read the computer objects in each. But here, your first task is reading all the computer objects in the OU. In this environment, all the servers are in the <code>Servers</code> OU. Your domain is called <code>powerlab.local</code>. To retrieve <span epub:type="pagebreak" id="page_195"/>computer objects from AD, use the <code>Get-ADComputer</code> command, as shown in <a href="ch14.xhtml#ch14list1">Listing 14-1</a>. This command should return all the AD computer objects for the servers you’re interested in.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$serversOuPath = 'OU=Servers,DC=powerlab,DC=local'</span>&#13;
PS&gt; <span class="codestrong1">$servers = Get-ADComputer -SearchBase $serversOuPath -Filter *</span>&#13;
PS&gt; <span class="codestrong1">$servers</span>&#13;
&#13;
DistinguishedName : CN=SQLSRV1,OU=Servers,DC=Powerlab,DC=local&#13;
DNSHostName       : SQLSRV1.Powerlab.local&#13;
Enabled           : True&#13;
Name              : SQLSRV1&#13;
ObjectClass       : computer&#13;
ObjectGUID        : c288d6c1-56d4-4405-ab03-80142ac04b40&#13;
SamAccountName    : SQLSRV1$&#13;
SID               : S-1-5-21-763434571-1107771424-1976677938-1105&#13;
UserPrincipalName :&#13;
&#13;
DistinguishedName : CN=WEBSRV1,OU=Servers,DC=Powerlab,DC=local&#13;
DNSHostName       : WEBSRV1.Powerlab.local&#13;
Enabled           : True&#13;
Name              : WEBSRV1&#13;
ObjectClass       : computer&#13;
ObjectGUID        : 3bd2da11-4abb-4eb6-9c71-7f2c58594a98&#13;
SamAccountName    : WEBSRV1$&#13;
SID               : S-1-5-21-763434571-1107771424-1976677938-1106&#13;
UserPrincipalName :</pre>&#13;
<p class="caption" id="ch14list1"><em>Listing 14-1: Using <code>Get-AdComputer</code> to return server data</em></p>&#13;
<p class="indent">Notice that instead of directly setting the <code>SearchBase</code> parameter argument, you define a variable. You should get used to doing this. In fact, every time you have a specific configuration like this, it’s always a good idea to put it into a variable, because you never know when you’ll need to use that value again. You also return the output of <code>Get-ADComputer</code> to a variable. Since you’ll be working with these servers later, you want to have the names to reference.</p>&#13;
<p class="indent">The <code>Get-ADComputer</code> command returns the whole AD objects, but you’re looking for just the server names. You can narrow this down by using <code>Select-Object</code> to return only the <code>Name</code> property:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$servers = Get-ADComputer -SearchBase $serversOuPath -Filter * |&#13;
Select-Object -ExpandProperty Name</span>&#13;
PS&gt; <span class="codestrong1">$servers</span>&#13;
SQLSRV1&#13;
WEBSRV1</pre>&#13;
<p class="indent">Now that you have a basic idea of how to query an individual server, let’s look at how to query all of them.</p>&#13;
<h3 class="h3" id="ch14lev5"><span epub:type="pagebreak" id="page_196"/>Querying Each Server</h3>&#13;
<p class="noindent">To query each server, you need to make a loop that’ll make it possible to query every server in your array exactly once.</p>&#13;
<p class="indent">It’s never a good idea to assume that your code will work immediately (it usually doesn’t). Instead, I like to start slow and test each piece as I’m building it. In this case, instead of trying to do everything in one go, use <code>Write-Host</code> to ensure that the script is returning the server names you expect:</p>&#13;
<pre>foreach ($server in $servers) {&#13;
    Write-Host $server&#13;
}</pre>&#13;
<p class="indent">By now, you should have a script called <em>Get-ServerInformation.ps1</em> that looks like <a href="ch14.xhtml#ch14list2">Listing 14-2</a>.</p>&#13;
<pre>$serversOuPath = 'OU=Servers,DC=powerlab,DC=local'&#13;
$servers = Get-ADComputer -SearchBase $serversOuPath -Filter * | Select-Object -ExpandProperty Name&#13;
foreach ($server in $servers) {&#13;
    Write-Host $server&#13;
}</pre>&#13;
<p class="caption" id="ch14list2"><em>Listing 14-2: Your script so far</em></p>&#13;
<p class="indent">Once you run the script, you get a few server names. Your output may look different, depending on which servers you used:</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\Get-ServerInformation.ps1</span>&#13;
SQLSRV1&#13;
WEBSRV1</pre>&#13;
<p class="indent">Great! You have a loop setup that iterates over each server name in your array. Your first task is complete.</p>&#13;
<h3 class="h3" id="ch14lev6">Thinking Ahead: Combining Different Types of Information</h3>&#13;
<p class="noindent">One of the keys to success with PowerShell is good planning and organization. Part of this is knowing what to expect. For many beginners, who don’t have much experience with the kinds of results PowerShell will give, this is a problem: they know what they want to happen (hopefully), but they don’t know what <em>could</em> happen. As a result, they create scripts that zigzag among data sources, getting data from one, and then the other, and then the first, and then the third, linking them all together, and doing it all again. There are easier ways to do things, and I would be doing you a disservice if I didn’t pause to explain them.</p>&#13;
<p class="indent">Looking at the output in <a href="ch14.xhtml#ch14list1">Listing 14-1</a>, you can see that you’ll need a few commands to pull information from various sources (WMI, the filesystem, Windows services). Each source will return a different kind of object, and you’ll have an absolute mess if you try to combine them thoughtlessly.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_197"/>Jumping ahead a little, let’s get a glimpse of what the output would look like if you tried to pull the service name and memory without any formatting or output attention. You might get something like this:</p>&#13;
<pre>Status   Name               DisplayName&#13;
------   ----               -----------&#13;
Running  wuauserv           Windows Update&#13;
&#13;
__GENUS              : 2&#13;
__CLASS              : Win32_PhysicalMemory&#13;
__SUPERCLASS         : CIM_PhysicalMemory&#13;
__DYNASTY            : CIM_ManagedSystemElement&#13;
__RELPATH            : Win32_PhysicalMemory.Tag="Physical Memory 0"&#13;
__PROPERTY_COUNT     : 30&#13;
__DERIVATION         : {CIM_PhysicalMemory, CIM_Chip, CIM_PhysicalComponent, CIM_PhysicalElement...}&#13;
__SERVER             : DC&#13;
__NAMESPACE          : root\cimv2&#13;
__PATH               : \\DC\root\cimv2:Win32_PhysicalMemory.Tag="Physical Memory 0"</pre>&#13;
<p class="indent">Here, you’re querying a service and trying to get memory from a server at the same time. The objects are different, the properties on those objects are different, and if you merge all the output and dump it, it looks terrible.</p>&#13;
<p class="indent">Let’s see how to avoid this kind of output. Since you’ll be combining different kinds of output, and you need something that fits our exact specifications, you have to create your own type of output. Don’t worry, this isn’t as complicated as you might think. In <a href="ch02.xhtml#ch2">Chapter 2</a>, you learned how to create <code>PSCustomObject</code> types. These generic objects in PowerShell allow you to add your own properties—perfect for what you’re doing here.</p>&#13;
<p class="indent">You know the headers of the output you need (and, as I’m sure you know by now, these “headers” will always be object properties). Let’s create a custom object with the properties you’d like to see in the output. For obvious reasons, I’ve called this object <code>$output</code>; you’ll return it after you populate its properties:</p>&#13;
<pre>$output = [pscustomobject]@{&#13;
    'ServerName'                  = $null&#13;
    'IPAddress'                   = $null&#13;
    'OperatingSystem'             = $null&#13;
    'AvailableDriveSpace (GB)'    = $null&#13;
    'Memory (GB)'                 = $null&#13;
    'UserProfilesSize (MB)'       = $null&#13;
    'StoppedServices'             = $null&#13;
}</pre>&#13;
<p class="indent">You’ll notice that the hashtable keys are surrounded by single quotes. This isn’t mandatory if there’s no space in the key. However, because I am using spaces in some key names, I decided to standardize on single quotes across all of the keys. It’s generally not recommended to use spaces in object property names in lieu of using custom formatting, but that is outside the scope of this book. For more information on custom formatting, refer to the <em>about_Format.ps1xml</em> help topic.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_198"/>If you copy this to the console, and return it with the formatting cmdlet, <code>Format-Table</code>, you can see the headers you’re looking for:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$output | Format-Table -AutoSize</span>&#13;
&#13;
ServerName IPAddress OperatingSystem AvailableDriveSpace (GB) Memory (GB) UserProfilesSize (MB) StoppedServices</pre>&#13;
<p class="indent">The <code>Format-Table</code> command is one of a few format commands in PowerShell that are meant to be used as the last command in the pipeline. They transform current output and display it differently. In this instance, you’re telling PowerShell to transform your object output into a table format and autosize the rows based on the width of the console.</p>&#13;
<p class="indent">Once you define your custom output object, you can go back to your loop and make sure each server is returned in this format. Since you already know the server name, you can set that property right away, as in <a href="ch14.xhtml#ch14list3">Listing 14-3</a>.</p>&#13;
<pre>$serversOuPath = 'OU=Servers,DC=powerlab,DC=local'&#13;
$servers = Get-ADComputer -SearchBase $serversOuPath -Filter * | Select-Object -ExpandProperty Name&#13;
foreach ($server in $servers) {&#13;
    $output = @{&#13;
        'ServerName'                  = $server&#13;
        'IPAddress'                   = $null&#13;
        'OperatingSystem'             = $null&#13;
        'AvailableDriveSpace (GB)'    = $null&#13;
        'Memory (GB)'                 = $null&#13;
        'UserProfilesSize (MB)'       = $null&#13;
        'StoppedServices'             = $null&#13;
    }&#13;
    [pscustomobject]$output&#13;
}</pre>&#13;
<p class="caption" id="ch14list3"><em>Listing 14-3: Putting your <code>output</code> object in your loop and setting the server name</em></p>&#13;
<p class="indent">Notice that you created <code>output</code> as a hashtable and cast it as a <code>PSCustomObject</code> only after you filled it with data. You do this because it’s simpler to keep the property values in a hashtable than in a <code>PSCustomObject</code>; you care about <code>output</code> being an object of that type only when it’s being output so that when you bring in other sources of information, they will all be the same object type.</p>&#13;
<p class="indent">You can see all the property names that your <code>PSCustomObject</code> has, along with the names of the servers you’re querying, with this code:</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\Get-ServerInformation.ps1 | Format-Table -AutoSize</span>&#13;
&#13;
ServerName UserProfilesSize (MB) AvailableDriveSpace (GB) OperatingSystem StoppedServices IPAddress Memory (GB)&#13;
---------- --------------------- ------------------------ --------------- --------------- --------- -----------&#13;
SQLSRV1&#13;
WEBSRV1</pre>&#13;
<p class="indent">As you can see, you have data. It may not seem like much, but you’re well on your way!</p>&#13;
<h3 class="h3" id="ch14lev7"><span epub:type="pagebreak" id="page_199"/>Querying Remote Files</h3>&#13;
<p class="noindent">Now that you know how you’re going to store your data, you just need to get it. This means pulling the information you need from each server and returning only the properties you care about. Let’s start with the value for <code>UserProfileSize</code> (MB). To do this, let’s figure out a way to find out how much space is being consumed by all these profiles located in the <em>C:\Users</em> folder on each server.</p>&#13;
<p class="indent">Because of the way you set up the loop, you need to figure out how to do this for only one server. Since you know the folder path is <em>C:\Users</em>, let’s first see if you can query all the files under all the server’s user profile folders.</p>&#13;
<p class="indent">When you run <code>Get-ChildItem -Path \\WEBSRV1\c$\Users -Recurse -File</code> and have access to that file share, you can immediately see it’s returning all the files and folders in all user profiles, but you don’t see anything related to size. Let’s pipe the output to <code>Select-Object</code> to return all properties:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-ChildItem -Path \\WEBSRV1\c$\Users -Recurse -File | Select-Object -Property *</span>&#13;
&#13;
PSPath            : Microsoft.PowerShell.Core\FileSystem::\WEBSRV1\c$\Users\Adam\file.log&#13;
PSParentPath      : Microsoft.PowerShell.Core\FileSystem::\\WEBSRV1\c$\Users\Adam&#13;
PSChildName       : file.log&#13;
PSProvider        : Microsoft.PowerShell.Core\FileSystem&#13;
PSIsContainer     : False&#13;
Mode              : -a----&#13;
VersionInfo       : File:             \\WEBSRV1\c$\Users\Adam\file.log&#13;
                    InternalName:&#13;
                    OriginalFilename:&#13;
                    FileVersion:&#13;
                    FileDescription:&#13;
                    Product:&#13;
                    ProductVersion:&#13;
                    Debug:            False&#13;
                    Patched:          False&#13;
                    PreRelease:       False&#13;
                    PrivateBuild:     False&#13;
                    SpecialBuild:     False&#13;
                    Language:&#13;
BaseName          : file&#13;
Target            :&#13;
LinkType          :&#13;
Name              : file.log&#13;
Length            : 8926&#13;
DirectoryName     : \\WEBSRV1\c$\Users\Adam&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">The <code>Length</code> property shows how large the file is in bytes. Knowing this, you’ll have to figure out how to add up the <code>Length</code> values of each file in the server’s <em>C:\Users</em> folder. Luckily, PowerShell makes this easy with one of its <span epub:type="pagebreak" id="page_200"/>cmdlets: <code>Measure-Object</code>. This cmdlet accepts input from the pipeline and automatically adds up the values of a specific property:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-ChildItem -Path '\\WEBSRV1\c$\Users\' -File -Recurse | Measure-Object -Property Length -Sum</span>&#13;
&#13;
Count    : 15&#13;
Average  :&#13;
Sum      : 600554&#13;
Maximum  :&#13;
Minimum  :&#13;
Property : Length</pre>&#13;
<p class="indent">You now have a property (<code>Sum</code>) that you can use to represent the total user profile size in your output. At this point, it’s just a matter of incorporating the code into your loop and setting the appropriate property in your <code>$output</code> hashtable. Since you need only the <code>Sum</code> property from the object returned by <code>Measure-Object</code>, you’ll enclose the command in parentheses and reference the <code>Sum</code> property as in <a href="ch14.xhtml#ch14list4">Listing 14-4</a>.</p>&#13;
<pre>Get-ServerInformation.ps1&#13;
-------------------&#13;
$serversOuPath = 'OU=Servers,DC=powerlab,DC=local'&#13;
$servers = Get-ADComputer -SearchBase $serversOuPath -Filter * | Select-Object -ExpandProperty Name&#13;
foreach ($server in $servers) {&#13;
    $output = @{&#13;
        'ServerName'                  = $null&#13;
        'IPAddress'                   = $null&#13;
        'OperatingSystem'             = $null&#13;
        'AvailableDriveSpace (GB)'    = $null&#13;
        'Memory (GB)'                 = $null&#13;
        'UserProfileSize (MB)'        = $null&#13;
        'StoppedServices'             = $null&#13;
    }&#13;
    $output.ServerName = $server&#13;
    $output.'UserProfileSize (MB)' = (Get-ChildItem -Path '\\WEBSRV1\c$\Users\' -File -Recurse |&#13;
    Measure-Object -Property Length -Sum).Sum&#13;
    [pscustomobject]$output&#13;
}</pre>&#13;
<p class="caption" id="ch14list4"><em>Listing 14-4: Updating your script to store <code>UserProfilesSize</code></em></p>&#13;
<p class="indent">If you run the script, you get the following:</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\Get-ServerInformation.ps1 | Format-Table -AutoSize</span>&#13;
&#13;
ServerName UserProfilesSize (MB) AvailableDriveSpace (GB) OperatingSystem StoppedServices IPAddress Memory (GB)&#13;
---------- --------------------- ------------------------ --------------- --------------- --------- -----------&#13;
SQLSRV1                   636245&#13;
WEBSRV1                   600554</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_201"/>As you can see, you now have the total size of the user profiles—but it’s not in megabytes. You calculated the sum of <code>Length</code>, and <code>Length</code> is in bytes. PowerShell makes conversions like this easy: if you simply divide the number by <code>1MB</code>, you’ll have your number. You might see the resulting values represented with decimal points. You can take a final step and ensure that you have a whole number by casting the output to an integer, which will “round” the number to a whole megabyte value:</p>&#13;
<pre>$userProfileSize = (Get-ChildItem -Path "\\$server\c$\Users\" -File |&#13;
Measure-Object -Property Length -Sum).Sum&#13;
$output.'UserProfilesSize (MB)' = [int]($userProfileSize / 1MB)</pre>&#13;
<h3 class="h3" id="ch14lev8">Querying Windows Management Instrumentation</h3>&#13;
<p class="noindent">You have five more values to fill. For four of them, you’ll use a built-in Microsoft feature called <em>Windows Management Instrumentation (WMI)</em>. Based on the industry standard Common Information Model (CIM), WMI is a repository containing real-time information about thousands of attributes relating to the operating system and the hardware it’s running on. The information is separated into various namespaces, classes, and properties. If you’re looking for information about a computer, chances are, you’ll be using WMI a lot.</p>&#13;
<p class="indent">For this particular script, you’ll pull information about hard drive space, the operating system version, the server’s IP address, and the amount of memory the server contains.</p>&#13;
<p class="indent">PowerShell has two commands to query WMI: <code>Get-WmiObject</code> and <code>Get-CimInstance</code>. The <code>Get-WmiObject</code> command is older and not as flexible as <code>Get-CimInstance</code> (if you want the technical details: this is mainly because <code>Get-WmiObject</code> uses only DCOM to connect to remote computers, while <code>Get-CimInstance</code>, by default, uses WSMAN and can optionally use DCOM as well). As of right now, Microsoft appears to be putting all its effort into <code>Get-CimInstance</code>, so that’s the command you’ll use. For a detailed breakdown of CIM versus WMI, check out this blog post: <a href="https://blogs.technet.microsoft.com/heyscriptingguy/2016/02/08/should-i-use-cim-or-wmi-with-windows-powershell/"><em>https://blogs.technet.microsoft.com</em><em>/heyscriptingguy/2016/02/08/should-i-use-cim-or-wmi-with-windows-powershell/</em></a>.</p>&#13;
<p class="indent">The hardest part of querying WMI is figuring out where the information you’re looking for is hidden. Normally, you’d do this research on your own (and I encourage you to try it here), but for time’s sake, let me offer you the answer sheet to this script: all storage resource usage is in <code>Win32_LogicalDisk</code>, information about the operating system is in <code>Win32_OperatingSystem</code>, Windows services are all represented in <code>Win32_Service</code>, any network adapter information is in <code>Win32_NetworkAdapterConfiguration</code>, and memory information is in <code>Win32_PhysicalMemory</code>.</p>&#13;
<p class="indent">Now let’s see how to use <code>Get-CimInstance</code> to query these WMI classes for the properties you’re looking for.</p>&#13;
<h4 class="h4" id="ch14lev8sec12"><span epub:type="pagebreak" id="page_202"/>Disk Free Space</h4>&#13;
<p class="noindent">Let’s start with the available hard drive space, found in <code>Win32_LogicalDisk</code>. As with <code>UserProfilesSize</code>, you’ll start with one server and then generalize in your loop. Here, you can see that you lucked out; you don’t even need to use <code>Select-Object</code> to dig into all the properties—<code>FreeSpace</code> is right there:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-CimInstance -ComputerName sqlsrv1 -ClassName Win32_LogicalDisk</span>&#13;
&#13;
DeviceID DriveType ProviderName VolumeName Size        FreeSpace   PSComputerName&#13;
-------- --------- ------------ ---------- ----        ---------   --------------&#13;
C:       3                                 42708496384 34145906688 sqlsrv1</pre>&#13;
<p class="indent">Knowing that <code>Get-CimInstance</code> returns an object, you can simply access the property that you need to get only the amount of free space:</p>&#13;
<pre>PS&gt; <span class="codestrong1">(Get-CimInstance -ComputerName sqlsrv1 -ClassName Win32_LogicalDisk).FreeSpace</span>&#13;
34145906688</pre>&#13;
<p class="indent">You have the value but, like last time, it’s in bytes (this is a common thing in WMI). You can do the same conversion trick as before, except now you want gigabytes so you’ll divide by <code>1GB</code>. When you update the script by dividing the <code>FreeSpace</code> property by <code>1GB</code>, you get output that looks something like this:</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\Get-ServerInformation.ps1 | Format-Table -AutoSize</span>&#13;
&#13;
ServerName UserProfilesSize (MB) AvailableDriveSpace (GB) OperatingSystem StoppedServices IPAddress Memory (GB)&#13;
---------- --------------------- ------------------------ --------------- --------------- --------- -----------&#13;
SQLSRV1                   636245          31.800853729248&#13;
WEBSRV1                   603942         34.5973815917969</pre>&#13;
<p class="indent">You don’t need to see the free space out to 12 digits, so you can do a little rounding by using the <code>Round()</code> method on the <code>[Math]</code> class, making the output look much better:</p>&#13;
<pre>$output.'AvailableDriveSpace (GB)' = [Math]::Round(((Get-CimInstance -ComputerName $server&#13;
-ClassName Win32_LogicalDisk).FreeSpace / 1GB),1)&#13;
&#13;
ServerName UserProfilesSize (MB) AvailableDriveSpace (GB) OperatingSystem StoppedServices IPAddress Memory (GB)&#13;
---------- --------------------- ------------------------ --------------- --------------- --------- -----------&#13;
SQLSRV1                   636245                     31.8&#13;
WEBSRV1                   603942                     34.6</pre>&#13;
<p class="indent">Now the values are much easier to read. Three down, four to go.</p>&#13;
<h4 class="h4" id="ch14lev8sec13">Operating System Information</h4>&#13;
<p class="noindent">By now you should see the general pattern: query a single server, find the appropriate property, and add the query to your <code>foreach</code> loop.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_203"/>From now on, you’ll simply add lines to your <code>foreach</code> loop. The process of narrowing down the class, class property, and the property value is the same for any value you’ll be querying from WMI. Just follow this same general pattern:</p>&#13;
<pre>$output.'<span class="codeitalic1">PropertyName</span>' = (Get-CimInstance -ComputerName <span class="codeitalic1">ServerName</span> &#13;
-ClassName <span class="codeitalic1">WMIClassName</span>).<span class="codeitalic1">WMIClassPropertyName</span></pre>&#13;
<p class="indent">Adding the next value gives you a script that looks like <a href="ch14.xhtml#ch14list5">Listing 14-5</a>.</p>&#13;
<pre>Get-ServerInformation.ps1&#13;
-------------------&#13;
$serversOuPath = 'OU=Servers,DC=powerlab,DC=local'&#13;
$servers = Get-ADComputer -SearchBase $serversOuPath -Filter * |&#13;
Select-Object -ExpandProperty Name&#13;
foreach ($server in $servers) {&#13;
    $output = @{&#13;
        'ServerName'                  = $null&#13;
        'IPAddress'                   = $null&#13;
        'OperatingSystem'             = $null&#13;
        'AvailableDriveSpace (GB)'    = $null&#13;
        'Memory (GB)'                 = $null&#13;
        'UserProfilesSize (MB)'       = $null&#13;
        'StoppedServices'             = $null&#13;
    }&#13;
    $output.ServerName = $server&#13;
    $output.'UserProfilesSize (MB)' = (Get-ChildItem -Path "\\$server\c$\&#13;
    Users\" -File | Measure-Object -Property Length -Sum).Sum / 1MB&#13;
    $output.'AvailableDriveSpace (GB)' = [Math]::Round(((Get-CimInstance&#13;
    -ComputerName $server -ClassName Win32_LogicalDisk).FreeSpace / 1GB),1)&#13;
    $output.'OperatingSystem' = (Get-CimInstance -ComputerName $server&#13;
    -ClassName Win32_OperatingSystem).Caption&#13;
    [pscustomobject]$output&#13;
}</pre>&#13;
<p class="caption" id="ch14list5"><em>Listing 14-5: Your script updated to include a query for <code>OperatingSystem</code></em></p>&#13;
<p class="indent">Now run your script:</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\Get-ServerInformation.ps1 | Format-Table -AutoSize</span>&#13;
&#13;
ServerName UserProfilesSize (MB) AvailableDriveSpace (GB) OperatingSystem                           StoppedServices IPAddress Memory (GB)&#13;
---------- --------------------- ------------------------ ---------------                           --------------- --------- -----------&#13;
SQLSRV1                   636245         31.8005790710449 Microsoft Windows Server 2016 Standard&#13;
WEBSRV1                   603942         34.5973815917969 Microsoft Windows Server 2012 R2 Standard</pre>&#13;
<p class="indent">You’ve gotten some useful OS information. Let’s take the next step and figure out how to query some information on memory.</p>&#13;
<h4 class="h4" id="ch14lev8sec14">Memory</h4>&#13;
<p class="noindent">Moving onto the next piece of information to gather (<code>Memory</code>), you’ll use the <code>Win32_PhysicalMemory</code> class. Testing your query on a single server again gives <span epub:type="pagebreak" id="page_204"/>the information you’re looking for. In this case, the memory information you need is stored in <code>Capacity</code>:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-CimInstance -ComputerName sqlsrv1 -ClassName Win32_PhysicalMemory</span>&#13;
&#13;
Caption              : Physical Memory&#13;
Description          : Physical Memory&#13;
InstallDate          :&#13;
Name                 : Physical Memory&#13;
Status               :&#13;
CreationClassName    : Win32_PhysicalMemory&#13;
Manufacturer         : Microsoft Corporation&#13;
Model                :&#13;
OtherIdentifyingInfo :&#13;
<span class="codeitalic1">--snip--</span>&#13;
Capacity             : 2147483648&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">Each instance under <code>Win32_PhysicalMemory</code> represents a <em>bank</em> of RAM. You can think of a bank as a physical stick of RAM in a server. It just so happens that my SQLSRV1 server has only one bank of memory. However, you will undoubtedly find servers with many more.</p>&#13;
<p class="indent">Since you’re looking for total memory in a server, you’ll have to follow the same routine you used to get profile size. You’ll have to add up the value of <code>Capacity</code> across all the instances. Lucky for us, the <code>Measure-Object</code> cmdlet works across any number of object types. As long as the property is a number, it can add them all up.</p>&#13;
<p class="indent">Again, since <code>Capacity</code> was represented in bytes, you’ll convert it to the appropriate label:</p>&#13;
<pre>PS&gt; <span class="codestrong1">(Get-CimInstance -ComputerName sqlsrv1 -ClassName Win32_PhysicalMemory |&#13;
Measure-Object -Property Capacity -Sum).Sum /1GB</span>&#13;
2</pre>&#13;
<p class="indent">As you can see in <a href="ch14.xhtml#ch14list6">Listing 14-6</a>, your script grows and grows!</p>&#13;
<pre>Get-ServerInformation.ps1&#13;
-------------------&#13;
$serversOuPath = 'OU=Servers,DC=powerlab,DC=local'&#13;
$servers = Get-ADComputer -SearchBase $serversOuPath -Filter * | Select-Object&#13;
-ExpandProperty Name&#13;
foreach ($server in $servers) {&#13;
    $output = @{&#13;
        'ServerName'                  = $null&#13;
        'IPAddress'                   = $null&#13;
        'OperatingSystem'             = $null&#13;
        'AvailableDriveSpace (GB)'    = $null&#13;
        'Memory (GB)'                 = $null&#13;
        'UserProfilesSize (MB)'       = $null&#13;
        'StoppedServices'             = $null&#13;
    }&#13;
<span epub:type="pagebreak" id="page_205"/>    $output.ServerName = $server&#13;
    $output.'UserProfilesSize (MB)' = (Get-ChildItem -Path "\\$server\c$\&#13;
    Users\" -File | Measure-Object -Property Length -Sum).Sum / 1MB&#13;
    $output.'AvailableDriveSpace (GB)' = [Math]::Round(((Get-CimInstance&#13;
    -ComputerName $server -ClassName Win32_LogicalDisk).FreeSpace / 1GB),1)&#13;
    $output.'OperatingSystem' = (Get-CimInstance -ComputerName $server&#13;
    -ClassName Win32_OperatingSystem).Caption&#13;
    $output.'Memory (GB)' = (Get-CimInstance -ComputerName $server -ClassName&#13;
    Win32_PhysicalMemory | Measure-Object -Property Capacity -Sum).Sum /1GB&#13;
    [pscustomobject]$output&#13;
}</pre>&#13;
<p class="caption" id="ch14list6"><em>Listing 14-6: Your script with the query for <code>Memory</code></em></p>&#13;
<p class="indent">Let’s look at the output so far:</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\Get-ServerInformation.ps1 | Format-Table -AutoSize</span>&#13;
&#13;
ServerName UserProfilesSize (MB) AvailableDriveSpace (GB) OperatingSystem                           StoppedServices IPAddress Memory (GB)&#13;
---------- --------------------- ------------------------ ---------------                           --------------- --------- -----------&#13;
SQLSRV1                   636245                     31.8 Microsoft Windows Server 2016 Standard                                        2&#13;
WEBSRV1                   603942                     34.6 Microsoft Windows Server 2012 R2 Standard                                     2</pre>&#13;
<p class="indent">With that, you have only two fields left to fill!</p>&#13;
<h4 class="h4" id="ch14lev8sec15">Network Information</h4>&#13;
<p class="noindent">The final piece of WMI information is the IP address, which you’ll grab from <code>Win32_NetworkAdapterConfiguration</code>. I saved the task of finding the IP address for last because, unlike the other data entries, finding the IP address of the server isn’t as cut and dried as finding a value and then adding it to your <code>$output</code> hashtable. You’ll have to do some filtering to narrow it down.</p>&#13;
<p class="indent">Let’s first see what the output looks like using the same method you’ve used so far:</p>&#13;
<pre>PS&gt;<span class="codestrong1"> Get-CimInstance -ComputerName SQLSRV1 -ClassName Win32_NetworkAdapterConfiguration</span>&#13;
&#13;
ServiceName    DHCPEnabled    Index    Description   PSComputerName&#13;
-----------    -----------    -----    -----------   --------------&#13;
kdnic          True           0        Microsoft...  SQLSRV1&#13;
netvsc         False          1        Microsoft...  SQLSRV1&#13;
tunnel         False          2        Microsoft...  SQLSRV1</pre>&#13;
<p class="indent">You’ll see right away that the default output doesn’t show the IP address, not that that has stopped you before. But, somewhat trickier, here the command doesn’t return a single instance. This server has three network adapters on it. How do you select the one that has the IP address you’re looking for?</p>&#13;
<p class="indent">First, you have to see all the properties by using <code>Select-Object</code>. Using <code>Get-CimInstance -ComputerName SQLSRV1 -ClassName Win32_NetworkAdapterConfiguration | Select-Object -Property *</code>, you can scroll through the <span epub:type="pagebreak" id="page_206"/>(substantial) output. Depending on the network adapters installed on the server, you may notice fields that don’t have anything for the <code>IPAddress</code> property. This is common because network adapters do not have an IP address. However, when you do find one with an IP address bound to it, it should look similar to the following code, where you can see the <code>IPAddress</code> property <span class="ent">❶</span> has (in this instance) an IPv4 address of 192.168.0.40 and a couple of IPv6 addresses:</p>&#13;
<pre>   DHCPLeaseExpires             :&#13;
   Index                        : 1&#13;
   Description                  : Microsoft Hyper-V Network Adapter&#13;
   DHCPEnabled                  : False&#13;
   DHCPLeaseObtained            :&#13;
   DHCPServer                   :&#13;
   DNSDomain                    : Powerlab.local&#13;
   DNSDomainSuffixSearchOrder   : {Powerlab.local}&#13;
   DNSEnabledForWINSResolution  : False&#13;
   DNSHostName                  : SQLSRV1&#13;
   DNSServerSearchOrder         : {192.168.0.100}&#13;
   DomainDNSRegistrationEnabled : True&#13;
   FullDNSRegistrationEnabled   : True&#13;
<span class="ent">❶</span> IPAddress                     : {192.168.0.40... &#13;
   IPConnectionMetric           : 20&#13;
   IPEnabled                    : True&#13;
   IPFilterSecurityEnabled      : False&#13;
   <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">The script needs to be dynamic and support lots of network adapter configurations. It’s important that the script is able to handle other types of network adapters other than the <code>Microsoft Hyper-V Network Adapter</code> you’re working with here. You’ll need to find a standard criterion to filter on so that it can apply to all servers.</p>&#13;
<p class="indent">The <code>IPEnabled</code> property is the key. When this property is set to <code>True</code>, the TCP/IP protocol is bound to this network adapter, which is a prerequisite to having an IP address. If you can narrow down the NIC that has the <code>IPEnabled</code> property set to <code>True</code>, you’ll have the adapter you’re looking for.</p>&#13;
<p class="indent">When filtering WMI instances, it’s always best to use the <code>Filter</code> parameter on <code>Get-CimInstance</code>. There’s a saying in the PowerShell community: <em>filter left</em>. Basically, it means that if you can, always filter output as far to the left as possible—meaning filter as early as possible so that you’re not sending unnecessary objects through the pipeline. Don’t use <code>Where-Object</code> unless you have to. The performance will be much faster instead if the pipeline isn’t clogged with unneeded objects.</p>&#13;
<p class="indent">The <code>Filter</code> parameter on <code>Get-CimInstance</code> uses <em>Windows Query Language (WQL)</em>, which is a small subset of <em>Structured Query Language (SQL)</em>. The <code>Filter</code> parameter accepts the same <code>WHERE</code> clause syntax that WQL does. Take this example: if, in WQL, you want all the <code>Win32_NetworkAdapterConfiguration</code> class instances with the <code>IPEnabled</code> property set to <code>True</code>, you could use <code>SELECT *</code> <code>FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled = 'True'</code>. Since you’re <span epub:type="pagebreak" id="page_207"/>already specifying the class name for the <code>ClassName</code> parameter argument in <code>Get-CimInstance</code>, you need to specify <code>IPEnabled = 'True'</code> for <code>Filter</code>:</p>&#13;
<pre>Get-CimInstance -ComputerName SQLSRV1 -ClassName Win32_NetworkAdapterConfiguration&#13;
-Filter "IPEnabled = 'True'" | Select-Object -Property *</pre>&#13;
<p class="indent">This should return only network adapters that are <code>IPEnabled</code> (meaning they have an IP address).</p>&#13;
<p class="indent">Now that you have a single WMI instance, and now that you know the property you’re looking for (<code>IPAddress</code>), let’s see what it looks like when querying a single server. You’ll use the same <span class="codeitalic">object.property</span> syntax you’ve been using:</p>&#13;
<pre>PS&gt; <span class="codestrong1">(Get-CimInstance -ComputerName SQLSRV1 -ClassName Win32_NetworkAdapterConfiguration&#13;
-Filter "IPEnabled = 'True'").IPAddress</span>&#13;
&#13;
192.168.0.40&#13;
fe80::e4e1:c511:e38b:4f05&#13;
2607:fcc8:acd9:1f00:e4e1:c511:e38b:4f05</pre>&#13;
<p class="indent">Ouch! Looks like it has IPv4 and IPv6 references in there. You’ll have to filter out more elements. Because WQL can’t filter deeper than the property value, you’ll need to parse out the IPv4 address.</p>&#13;
<p class="indent">Doing some investigation, you can see that all the addresses are enclosed with curly brackets separated by a comma:</p>&#13;
<pre>IPAddress : {192.168.0.40, fe80::e4e1:c511:e38b:4f05, 2607:fcc8:acd9:1f00:e4e1:c511:e38b:4f05}</pre>&#13;
<p class="indent">This is a good indication that this property isn’t stored as one big string but rather as an array. To confirm that this is an array, you can try using an index to see whether you can get only the IPv4 address:</p>&#13;
<pre>PS&gt; <span class="codestrong1">(Get-CimInstance -ComputerName SQLSRV1 -ClassName Win32_NetworkAdapterConfiguration&#13;
-Filter "IPEnabled = 'True'").IPAddress[0]</span>&#13;
&#13;
192.168.0.40</pre>&#13;
<p class="indent">You’re in luck! The <code>IPAddress</code> property <em>is</em> an array. At this point, you have your value, and you can add your full command to your script, as shown in <a href="ch14.xhtml#ch14list7">Listing 14-7</a>.</p>&#13;
<pre>Get-ServerInformation.ps1&#13;
-------------------&#13;
$serversOuPath = 'OU=Servers,DC=powerlab,DC=local'&#13;
$servers = Get-ADComputer -SearchBase $serversOuPath -Filter * |&#13;
Select-Object -ExpandProperty Name&#13;
foreach ($server in $servers) {&#13;
    $output = @{&#13;
        'ServerName'                  = $null&#13;
        'IPAddress'                   = $null&#13;
<span epub:type="pagebreak" id="page_208"/>        'OperatingSystem'             = $null&#13;
        'AvailableDriveSpace (GB)'    = $null&#13;
        'Memory (GB)'                 = $null&#13;
        'UserProfilesSize (MB)'       = $null&#13;
        'StoppedServices'             = $null&#13;
    }&#13;
    $output.ServerName = $server&#13;
    $output.'UserProfilesSize (MB)' = (Get-ChildItem -Path "\\$server\c$\&#13;
    Users\" -File | Measure-Object -Property Length -Sum).Sum / 1MB&#13;
    $output.'AvailableDriveSpace (GB)' = [Math]::Round(((Get-CimInstance&#13;
    -ComputerName $server -ClassName Win32_LogicalDisk).FreeSpace / 1GB),1)&#13;
    $output.'OperatingSystem' = (Get-CimInstance -ComputerName $server&#13;
    -ClassName Win32_OperatingSystem).Caption&#13;
    $output.'Memory (GB)' = (Get-CimInstance -ComputerName $server -ClassName&#13;
    Win32_PhysicalMemory | Measure-Object -Property Capacity -Sum).Sum /1GB&#13;
    $output.'IPAddress' = (Get-CimInstance -ComputerName $server -ClassName&#13;
    Win32_NetworkAdapterConfiguration -Filter "IPEnabled = 'True'").IPAddress[0]&#13;
    [pscustomobject]$output&#13;
}</pre>&#13;
<p class="caption" id="ch14list7"><em>Listing 14-7: Updated code that now handles <code>IPAddress</code></em></p>&#13;
<p class="indent">Now you run this:</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\Get-ServerInformation.ps1 | Format-Table -AutoSize</span>&#13;
&#13;
ServerName UserProfilesSize (MB) AvailableDriveSpace (GB) OperatingSystem                          StoppedServices IPAddress     Memory (GB)&#13;
---------- --------------------- ------------------------ ---------------                          --------------- ---------     -----------&#13;
SQLSRV1                   636245                     31.8 Microsoft Windows Server 2016 Standard                   192.168.0.40  2&#13;
WEBSRV1                   603942                     34.6 Microsoft Windows Server 2012 R2 Standard                192.168.0.70  2</pre>&#13;
<p class="indent">Now that you have all the WMI information you need, there’s only one thing left to do.</p>&#13;
<h3 class="h3" id="ch14lev9">Windows Services</h3>&#13;
<p class="noindent">The last piece of data to gather is a list of the services on the server that are stopped. You’ll follow our basic algorithm, testing on a single server first. To do that, you’ll use the <code>Get-Service</code> command on the server, which will return all of the services being used. You’ll then pipe that output to a <code>Where-Object</code> command that will filter only for services that have a status of <code>Stopped</code>. All in all, the command will look like this: <code>Get-Service -ComputerName sqlsrv1 | Where-Object { $_.Status -eq 'Stopped' }</code>.</p>&#13;
<p class="indent">This command is returning whole objects with all their properties. But you’re just looking for service names, so you’ll use the same technique you’ve been using—referencing the property name—and return a list of only service names.</p>&#13;
<pre><span epub:type="pagebreak" id="page_209"/>PS&gt; <span class="codestrong1">(Get-Service -ComputerName sqlsrv1 | Where-Object { $_.Status -eq 'Stopped' }).DisplayName</span>&#13;
Application Identity&#13;
Application Management&#13;
AppX Deployment Service (AppXSVC)&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">Adding this to your script, you get <a href="ch14.xhtml#ch14list8">Listing 14-8</a>.</p>&#13;
<pre>Get-ServerInformation.ps1&#13;
-------------------&#13;
$serversOuPath = 'OU=Servers,DC=powerlab,DC=local'&#13;
$servers = Get-ADComputer -SearchBase $serversOuPath -Filter * |&#13;
Select-Object -ExpandProperty Name&#13;
foreach ($server in $servers) {&#13;
    $output = @{&#13;
        'ServerName'                  = $null&#13;
        'IPAddress'                   = $null&#13;
        'OperatingSystem'             = $null&#13;
        'AvailableDriveSpace (GB)'    = $null&#13;
        'Memory (GB)'                 = $null&#13;
        'UserProfilesSize (MB)'       = $null&#13;
        'StoppedServices'             = $null&#13;
    }&#13;
    $output.ServerName = $server&#13;
    $output.'UserProfilesSize (MB)' = (Get-ChildItem -Path "\\$server\c$\&#13;
    Users\" -File | Measure-Object -Property Length -Sum).Sum / 1MB&#13;
    $output.'AvailableDriveSpace (GB)' = [Math]::Round(((Get-CimInstance&#13;
    -ComputerName $server -ClassName Win32_LogicalDisk).FreeSpace / 1GB),1)&#13;
    $output.'OperatingSystem' = (Get-CimInstance -ComputerName $server&#13;
    -ClassName Win32_OperatingSystem).Caption&#13;
    $output.'Memory (GB)' = (Get-CimInstance -ComputerName $server -ClassName&#13;
    Win32_PhysicalMemory | Measure-Object -Property Capacity -Sum).Sum /1GB&#13;
    $output.'IPAddress' = (Get-CimInstance -ComputerName $server -ClassName&#13;
    Win32_NetworkAdapterConfiguration -Filter "IPEnabled = 'True'").IPAddress[0]&#13;
    $output.StoppedServices = (Get-Service -ComputerName $server |&#13;
    Where-Object { $_.Status -eq 'Stopped' }).DisplayName&#13;
    [pscustomobject]$output&#13;
}</pre>&#13;
<p class="caption" id="ch14list8"><em>Listing 14-8: Updating and using your script to print the stopped services</em></p>&#13;
<p class="indent">Run the following code to test your script:</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\Get-ServerInformation.ps1 | Format-Table -AutoSize</span>&#13;
&#13;
ServerName UserProfilesSize (MB) AvailableDriveSpace (GB) OperatingSystem                           StoppedServices&#13;
---------- --------------------- ------------------------ ---------------                           ---------------&#13;
SQLSRV1                   636245                     31.8 Microsoft Windows Server 2016 Standard    {Application Identity,&#13;
                                                                                                    Application Management,&#13;
                                                                                                    AppX Deployment Servi...&#13;
WEBSRV1                   603942                     34.6 Microsoft Windows Server 2012 R2 Standard {Application Experience,&#13;
                                                                                                    Application Management,&#13;
                                                                                                    Background Intellig...</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_210"/>As far as stopped services go, everything looks okay—but where did the other properties go? At this point, the console window has no room left. Removing the <code>Format-Table</code> reference allows you to see all the values:</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\Get-ServerInformation.ps1 </span>&#13;
&#13;
ServerName               : SQLSRV1&#13;
UserProfilesSize (MB)    : 636245&#13;
AvailableDriveSpace (GB) : 31.8&#13;
OperatingSystem          : Microsoft Windows Server 2016 Standard&#13;
StoppedServices          : {Application Identity, Applic... &#13;
IPAddress                : 192.168.0.40&#13;
Memory (GB)              : 2&#13;
&#13;
ServerName               : WEBSRV1&#13;
UserProfilesSize (MB)    : 603942&#13;
AvailableDriveSpace (GB) : 34.6&#13;
OperatingSystem          : Microsoft Windows Server 2012 R2 Standard&#13;
StoppedServices          : {Application Experience, Application Management, &#13;
                           Background Intelligent Transfer Service, Computer &#13;
                           Browser...}&#13;
IPAddress                : 192.168.0.70&#13;
Memory (GB)              : 2</pre>&#13;
<p class="indent">Looks good!</p>&#13;
<h3 class="h3" id="ch14lev10">Script Cleanup and Optimization</h3>&#13;
<p class="noindent">Rather than declare victory and move on, let’s reflect a little. Writing code is an iterative process. It’s entirely possible that you start out with a goal, accomplish that goal, and still end up with bad code—there’s more to a good program than simply doing what needs to be done. The script does exactly what you want it to do now, but you could do it in a better way. How?</p>&#13;
<p class="indent">Recall the DRY method: <em>don’t repeat yourself</em>. You can see a lot of repetition in this script. You have lots of <code>Get-CimInstance</code> references where you’re using the same parameters over and over again. You’re also making a lot of calls to WMI for the same server. These look like good places to make the code more efficient.</p>&#13;
<p class="indent">First of all, the CIM cmdlets have a <code>CimSession</code> parameter. This parameter allows you to create a single CIM session once and then reuse it. Rather than creating a temporary session, using it, and tearing it down again, you can create a single session, use it all you want, and then tear it down, as shown in <a href="ch14.xhtml#ch14list9">Listing 14-9</a>. The concept is similar to the <code>Invoke-Command</code> command’s <code>Session</code> parameter that we covered in <a href="ch08.xhtml#ch8">Chapter 8</a>.</p>&#13;
<pre>Get-ServerInformation.ps1&#13;
-------------------&#13;
$serversOuPath = 'OU=Servers,DC=powerlab,DC=local'&#13;
$servers = Get-ADComputer -SearchBase $serversOuPath -Filter * |&#13;
Select-Object -ExpandProperty Name&#13;
foreach ($server in $servers) {&#13;
<span epub:type="pagebreak" id="page_211"/>    $output = @{&#13;
        'ServerName'                  = $null&#13;
        'IPAddress'                   = $null&#13;
        'OperatingSystem'             = $null&#13;
        'AvailableDriveSpace (GB)'    = $null&#13;
        'Memory (GB)'                 = $null&#13;
        'UserProfilesSize (MB)'       = $null&#13;
        'StoppedServices'             = $null&#13;
    }&#13;
    $cimSession = New-CimSession -ComputerName $server&#13;
    $output.ServerName = $server&#13;
    $output.'UserProfilesSize (MB)' = (Get-ChildItem -Path "\\$server\c$\&#13;
    Users\" -File | Measure-Object -Property Length -Sum).Sum&#13;
    $output.'AvailableDriveSpace (GB)' = [Math]::Round(((Get-CimInstance&#13;
    -CimSession $cimSession -ClassName Win32_LogicalDisk).FreeSpace / 1GB),1)&#13;
    $output.'OperatingSystem' = (Get-CimInstance -CimSession $cimSession&#13;
    -ClassName Win32_OperatingSystem).Caption&#13;
    $output.'Memory (GB)' = (Get-CimInstance -CimSession $cimSession&#13;
    -ClassName Win32_PhysicalMemory | Measure-Object -Property Capacity -Sum)&#13;
    .Sum /1GB&#13;
    $output.'IPAddress' = (Get-CimInstance -CimSession $cimSession -ClassName&#13;
    Win32_NetworkAdapterConfiguration -Filter "IPEnabled = 'True'").IPAddress[0]&#13;
    $output.StoppedServices = (Get-Service -ComputerName $server |&#13;
    Where-Object { $_.Status -eq 'Stopped' }).DisplayName&#13;
    Remove-CimSession -CimSession $cimSession&#13;
    [pscustomobject]$output&#13;
}</pre>&#13;
<p class="caption" id="ch14list9"><em>Listing 14-9: Updating your code to create, and reuse, a single session</em></p>&#13;
<p class="indent">Now you’re reusing a single CIM session rather than multiple ones. But you’re still referencing it a lot in different commands’ parameters. To make this even better, you can create a hashtable and assign it a key called <code>CIMSession</code> and a value of the CIM session you just created. Once you have a common set of parameters saved in a hashtable, you can reuse it across all <code>Get-CimInstance</code> references.</p>&#13;
<p class="indent">This technique is known as <em>splatting</em>, and you can do it by specifying the hashtable you just created while calling each of the <code>Get-CimInstance</code> references via the <code>@</code> symbol followed by the hashtable name, as shown in <a href="ch14.xhtml#ch14list10">Listing 14-10</a>.</p>&#13;
<pre>Get-ServerInformation.ps1&#13;
-------------------&#13;
$serversOuPath = 'OU=Servers,DC=powerlab,DC=local'&#13;
$servers = Get-ADComputer -SearchBase $serversOuPath -Filter * |&#13;
Select-Object -ExpandProperty Name&#13;
foreach ($server in $servers) {&#13;
    $output = @{&#13;
        'ServerName'                  = $null&#13;
        'IPAddress'                   = $null&#13;
        'OperatingSystem'             = $null&#13;
        'AvailableDriveSpace (GB)'    = $null&#13;
        'Memory (GB)'                 = $null&#13;
        'UserProfilesSize (MB)'       = $null&#13;
        'StoppedServices'             = $null&#13;
<span epub:type="pagebreak" id="page_212"/>    }&#13;
    $getCimInstParams = @{&#13;
        CimSession = New-CimSession -ComputerName $server&#13;
    }&#13;
    $output.ServerName = $server&#13;
    $output.'UserProfilesSize (MB)' = (Get-ChildItem -Path "\\$server\c$\&#13;
    Users\" -File | Measure-Object -Property Length -Sum).Sum&#13;
    $output.'AvailableDriveSpace (GB)' = [Math]::Round(((Get-CimInstance&#13;
    @getCimInstParams -ClassName Win32_LogicalDisk).FreeSpace / 1GB),1)&#13;
    $output.'OperatingSystem' = (Get-CimInstance @getCimInstParams -ClassName&#13;
    Win32_OperatingSystem).Caption&#13;
    $output.'Memory (GB)' = (Get-CimInstance @getCimInstParams -ClassName&#13;
    Win32_PhysicalMemory | Measure-Object -Property Capacity -Sum).Sum /1GB&#13;
    $output.'IPAddress' = (Get-CimInstance @getCimInstParams -ClassName&#13;
    Win32_NetworkAdapterConfiguration -Filter "IPEnabled = 'True'").IPAddress[0]&#13;
    $output.StoppedServices = (Get-Service -ComputerName $server |&#13;
    Where-Object { $_.Status -eq 'Stopped' }).DisplayName&#13;
    Remove-CimSession -CimSession $getCimInstParams.CimSession&#13;
    [pscustomobject]$output&#13;
}</pre>&#13;
<p class="caption" id="ch14list10"><em>Listing 14-10: Creating the <code>CIMSession</code> parameter to reuse</em></p>&#13;
<p class="indent">At this point, you’re probably used to passing parameters to commands in the <code>dash&lt;</code><span class="codeitalic">parameter name</span><code>&gt;</code><span class="codeitalic"/> <code>&lt;</code><span class="codeitalic">parameter value</span><code>&gt;</code> format. This works but it becomes inefficient, especially if you’re passing the same parameters to commands over and over again. Instead, you can use splatting as you’ve done here, by creating a hashtable and then simply passing that single hashtable to each command that requires the same parameter.</p>&#13;
<p class="indent">Now you’ve eliminated the <code>$cimSession</code> variable altogether.</p>&#13;
<h3 class="h3" id="ch14lev11">Summary</h3>&#13;
<p class="noindent">In this chapter, you’ve taken essential information from all the previous chapters and applied it to a situation you might find in the real world. A script that queries information is one of the first types of scripts I usually recommend creating. It teaches you a lot about PowerShell, and there’s little chance of screwing anything up!</p>&#13;
<p class="indent">You moved iteratively through this chapter, going from a goal to a solution to an even better solution. This is a process you’ll follow over and over again as you work with PowerShell. Define your goal, start small, get your framework laid out (a <code>foreach</code> loop, in this case), and start adding code piece by piece, overcoming one obstacle at a time until it all comes together.</p>&#13;
<p class="indent">Once you finish your script, keep in mind that you haven’t really finished until you review your code: see how to make it more efficient, use fewer resources, and get faster. Experience will make optimizing easier. You’ll build the perspective you need until optimizing becomes second nature. When you’re finished optimizing, sit back, bask in your success, and get ready to start your next project!</p>&#13;
</body></html>