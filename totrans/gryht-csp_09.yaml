- en: '10'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: AUTOMATING CLAMAV
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化ClamAV
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: ClamAV is an open source antivirus solution that is used primarily for scanning
    emails and attachments on email servers to identify potential viruses before they
    reach and infect computers on the network. But that certainly isn’t its only use
    case. In this chapter, we’ll use ClamAV to create an automated virus scanner that
    we can use to scan files for malware and to identify viruses with the help of
    ClamAV’s database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ClamAV是一个开源的杀毒解决方案，主要用于在邮件服务器上扫描电子邮件及其附件，识别潜在的病毒，以便它们在到达并感染网络中的计算机之前被发现。但这并不是它唯一的使用场景。在本章中，我们将使用ClamAV创建一个自动化病毒扫描器，用于扫描文件中的恶意软件，并借助ClamAV的数据库识别病毒。
- en: You’ll learn to automate ClamAV in a couple of ways. One is to interface with
    libclamav, the native library that drives ClamAV’s command line utilities such
    as clamscan, a file scanner you may be familiar with. The second way is to interface
    with the clamd daemon through sockets in order to perform scans on computers without
    ClamAV installed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何以几种方式自动化ClamAV。其中一种方法是与libclamav接口，这个本地库驱动着ClamAV的命令行工具，如clamscan，一个你可能熟悉的文件扫描器。第二种方法是通过套接字与clamd守护进程接口，以便在没有安装ClamAV的计算机上执行扫描。
- en: Installing ClamAV
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 安装ClamAV
- en: ClamAV is written in C, which creates some complications when automating with
    C#. It’s available for Linux through common package managers such as yum and apt,
    as well as for Windows and OS X. Many modern Unix distributions include a ClamAV
    package, but that version might not be compatible with Mono and .NET.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ClamAV是用C语言编写的，这在与C#自动化时会带来一些复杂性。它可以通过常见的包管理器（如yum和apt）在Linux上使用，同时也适用于Windows和OS
    X。许多现代Unix发行版都包含ClamAV包，但该版本可能与Mono和.NET不兼容。
- en: 'Installing ClamAV on a Linux system should go something like this: $ sudo apt-get
    install clamav If you’re running a Red Hat or Fedora-based Linux flavor that ships
    with yum, run something like this: $ sudo yum install clamav clamav-scanner clamav-update
    If you need to enable an extra repository in order to install ClamAV via yum,
    enter the following: $ sudo yum install -y epel-release These commands install
    a version of ClamAV to match your system’s architecture.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统上安装ClamAV的过程应该是这样的：$ sudo apt-get install clamav 如果你使用的是基于Red Hat或Fedora的Linux版本，并且系统自带yum，你可以运行如下命令：$
    sudo yum install clamav clamav-scanner clamav-update 如果你需要启用额外的仓库才能通过yum安装ClamAV，可以输入以下命令：$
    sudo yum install -y epel-release 这些命令会安装与系统架构相匹配的ClamAV版本。
- en: NOTE
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Mono and .NET can’t interface with native, unmanaged libraries unless the architecture
    of both are compatible. For example, 32-bit Mono and .NET won’t run the same way
    with ClamAV compiled for a 64-bit Linux or Windows machine. You will need to install
    or compile native ClamAV libraries to match the Mono or .NET 32-bit architecture.
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Mono和.NET不能与本地非托管库接口，除非它们的架构兼容。例如，32位的Mono和.NET在编译为64位Linux或Windows机器的ClamAV上无法正常运行。你需要安装或编译与Mono或.NET
    32位架构匹配的本地ClamAV库。
- en: The default ClamAV package from the package manager might not have the correct
    architecture for Mono/.NET. If it doesn’t, you’ll need to specifically install
    ClamAV to match the Mono/.NET architecture. You can write a program to verify
    your Mono/.NET version by checking the value of IntPtr.Size. An output of 4 indicates
    a 32-bit version, whereas an output of 8 is a 64-bit version. If you are running
    Mono or Xamarin on Linux, OS X, or Windows, you can easily check this, as shown
    in [Listing 10-1](#filepos710244).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器中的默认ClamAV包可能不适合Mono/.NET的架构。如果不匹配，你需要专门安装与Mono/.NET架构匹配的ClamAV。你可以编写程序通过检查IntPtr.Size的值来验证你的Mono/.NET版本。输出为4表示32位版本，而输出为8表示64位版本。如果你在Linux、OS
    X或Windows上运行Mono或Xamarin，你可以轻松检查，如[列表 10-1](#filepos710244)所示。
- en: $ echo "IntPtr.Size" | csharp
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ echo "IntPtr.Size" | csharp
- en: '4'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '4'
- en: 'Listing 10-1: A one-liner to check the architecture of Mono/.NET'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-1：检查Mono/.NET架构的单行命令
- en: Mono and Xamarin ship with an interactive interpreter for C# (called csharp),
    similar to the python interpreter, or irb for Ruby. By echoing the IntPtr.Size
    string into the interpreter using stdin, you can print the value of the Size property,
    which in this case is 4 and indicates a 32-bit architecture. If your output is
    also 4, you would need to install 32-bit ClamAV. It might be easiest to set up
    a VM with the architecture you expect. Because the instructions to compile ClamAV
    differ across Linux, OS X, and Windows, installing 32-bit ClamAV is outside the
    scope of this book if you need to do it. However, there are many online tutorials
    that can walk you through the steps for your particular operating system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Mono 和 Xamarin 提供了一个用于 C# 的交互式解释器（称为 csharp），类似于 Python 解释器或 Ruby 的 irb。通过使用标准输入（stdin）将
    IntPtr.Size 字符串传递到解释器中，你可以打印出 Size 属性的值，在本例中是 4，表示 32 位架构。如果你的输出也是 4，那么你需要安装 32
    位的 ClamAV。设置一个你预期架构的虚拟机可能是最简单的方式。由于在 Linux、OS X 和 Windows 上编译 ClamAV 的指令不同，如果你需要安装
    32 位的 ClamAV，它超出了本书的讨论范围。不过，网上有很多教程可以指导你根据自己的操作系统完成安装步骤。
- en: You can also use the Unix file utility to check whether your ClamAV library
    is a 32- or 64-bit version, as shown in [Listing 10-2](#filepos711880).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 Unix 的 file 工具来检查你的 ClamAV 库是 32 位版本还是 64 位版本，如[列表 10-2](#filepos711880)所示。
- en: $ file /usr/lib/x86_64-linux-gnu/libclamav.so.7.1.1
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ file /usr/lib/x86_64-linux-gnu/libclamav.so.7.1.1
- en: 'libclamav.so.7.1.1: ELF ➊64-bit LSB shared object, x86-64, version 1 (GNU/Linux),'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'libclamav.so.7.1.1: ELF ➊64 位 LSB 共享对象，x86-64，版本 1（GNU/Linux），'
- en: 'dynamically linked, not stripped Listing 10-2: Using  file  to view the libclamav
    architecture'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 动态链接，未剥离 列表 10-2：使用 file 查看 libclamav 架构
- en: Using file, we can see whether the libclamav library has been compiled for a
    32-bit or 64-bit architecture. On my computer, [Listing 10-2](#filepos711880)
    shows that the library is a 64-bit version ➊. But in [Listing 10-1](#filepos710244),
    IntPtr.Size returned 4, not 8! This means my libclamav (64-bit) and Mono (32-bit)
    architectures are mismatched. I must either recompile ClamAV to be 32-bit in order
    to use it with my Mono installation or install a 64-bit Mono runtime.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 file 命令，我们可以查看 libclamav 库是为 32 位还是 64 位架构编译的。我的计算机上，[列表 10-2](#filepos711880)
    显示该库是 64 位版本 ➊。但在[列表 10-1](#filepos710244)中，IntPtr.Size 返回的是 4，而不是 8！这意味着我的 libclamav（64
    位）和 Mono（32 位）架构不匹配。我必须重新编译 ClamAV 为 32 位版本，才能与我的 Mono 安装一起使用，或者安装 64 位的 Mono
    运行时。
- en: The ClamAV Native Library vs. the clamd Network Daemon
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ClamAV 本地库与 clamd 网络守护进程
- en: We’ll start by automating ClamAV using the native library libclamav. This allows
    us to use a local copy of ClamAV and its signatures to perform virus scanning;
    however, this requires that the ClamAV software and signatures be properly installed
    and updated on the system or device. The engine can be memory and CPU intensive,
    using up disk space for antivirus signatures. Sometimes these requirements can
    take up more resources on a machine than a programmer might like, so offloading
    the scanning to another machine makes sense.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用本地库 libclamav 自动化 ClamAV 开始。这允许我们使用本地副本的 ClamAV 及其病毒库进行病毒扫描；然而，这要求 ClamAV
    软件和病毒库必须正确安装并保持更新。引擎可能会占用大量内存和 CPU，使用磁盘空间存储病毒签名。有时这些需求会占用机器比程序员希望的更多资源，因此将扫描任务卸载到另一台机器上是合理的选择。
- en: You may rather want to perform your antivirus scanning in a central spot—perhaps
    when an email server sends or receives an email—in which case you won’t easily
    be able to use libclamav. Instead, you could use the clamd daemon to offload antivirus
    scanning from the email server to a dedicated virus-scanning server. You only
    need to keep one server’s antivirus signatures up-to-date, and you won’t run as
    great a risk of bogging down your email server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更希望在一个中心位置执行病毒扫描——例如，当电子邮件服务器发送或接收邮件时——在这种情况下，你可能无法轻松使用 libclamav。相反，你可以使用
    clamd 守护进程，将病毒扫描从邮件服务器卸载到专用的病毒扫描服务器。你只需保持一个服务器的病毒签名是最新的，而且你也不会大幅增加让邮件服务器崩溃的风险。
- en: Automating with ClamAV’s Native Library
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ClamAV 的本地库进行自动化
- en: Once you have ClamAV installed and running properly, you are ready to automate
    it. First, we’ll automate ClamAV using libclamav directly with P/Invoke (introduced
    in [Chapter 1](index_split_006.html#filepos69411)), which allows managed assemblies
    to call functions from native, unmanaged libraries. Although you’ll have a handful
    of supporting classes to implement, integrating ClamAV into your application is
    relatively straightforward overall.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你正确安装并运行了 ClamAV，你就可以开始自动化它了。首先，我们将直接使用 libclamav 通过 P/Invoke（在 [第 1 章](index_split_006.html#filepos69411)
    中介绍）自动化 ClamAV，P/Invoke 允许托管程序集调用本机、非托管库中的函数。尽管你需要实现一些支持类，但总体而言，将 ClamAV 集成到应用程序中是相对直接的。
- en: Setting Up the Supporting Enumerations and Classes
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 设置支持的枚举和类
- en: We’ll use a few helper classes and enumerations in the code. All the helper
    classes are very simple—most are fewer than 10 lines of code. However, they make
    the glue that holds the methods and classes together.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码中使用一些辅助类和枚举。所有辅助类都非常简单——大多数只有不到 10 行代码。然而，它们构成了将方法和类连接在一起的“胶水”。
- en: The Supporting Enumerations
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的枚举
- en: The ClamDatabaseOptions enumeration, shown in [Listing 10-3](#filepos715815),
    is used in the ClamAV engine to set options for the virus-lookup database we’ll
    use.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ClamDatabaseOptions 枚举，如 [列表 10-3](#filepos715815) 所示，用于在 ClamAV 引擎中设置我们将使用的病毒查找数据库的选项。
- en: '[Flags]'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[Flags]'
- en: public enum ClamDatabaseOptions
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public enum ClamDatabaseOptions
- en: '{'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: CL_DB_PHISHING = 0x2,
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_DB_PHISHING = 0x2，
- en: CL_DB_PHISHING_URLS = 0x8,
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_DB_PHISHING_URLS = 0x8，
- en: CL_DB_BYTECODE = 0x2000,
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_DB_BYTECODE = 0x2000，
- en: ➊CL_DB_STDOPT = (CL_DB_PHISHING | CL_DB_PHISHING_URLS | CL_DB_BYTECODE),
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊CL_DB_STDOPT = (CL_DB_PHISHING | CL_DB_PHISHING_URLS | CL_DB_BYTECODE)，
- en: '}'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-3: The  ClamDatabaseOptions  enum that defines the ClamAV database
    options'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-3：定义 ClamAV 数据库选项的 ClamDatabaseOptions 枚举
- en: The ClamDatabaseOptions enum uses values taken directly from the ClamAV C source
    for the database options. The three options enable the signatures for phishing
    emails and for phishing URLs, as well as the dynamic bytecode signatures used
    in heuristic scanning. Combined, these three make up ClamAV’s standard database
    options, which are used to scan for viruses or malware. By using the bitwise OR
    operator to combine the three option values, we come up with a bitmask of the
    combined options we want to use defined in an enum ➊. Using bitmasks is a popular
    way of storing flags or options in a very efficient way.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ClamDatabaseOptions 枚举使用直接从 ClamAV C 源代码中获取的值来定义数据库选项。这三个选项启用钓鱼电子邮件的签名、钓鱼网址的签名，以及在启发式扫描中使用的动态字节码签名。综合这三者，构成了
    ClamAV 的标准数据库选项，用于扫描病毒或恶意软件。通过使用按位 OR 操作符将这三个选项值组合起来，我们得到了一个我们想要使用的组合选项的位掩码，定义在枚举
    ➊ 中。使用位掩码是一种非常高效的存储标志或选项的流行方式。
- en: Another enum we must implement is the ClamReturnCode enum, which corresponds
    to known return codes from ClamAV and is shown in [Listing 10-4](#filepos717397).
    Again, these values were taken directly from the ClamAV source code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须实现的另一个枚举是 ClamReturnCode 枚举，它对应于 ClamAV 的已知返回代码，如 [列表 10-4](#filepos717397)
    所示。再次说明，这些值是直接从 ClamAV 源代码中获取的。
- en: public enum ClamReturnCode
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public enum ClamReturnCode
- en: '{'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➊CL_CLEAN = 0x0,
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊CL_CLEAN = 0x0，
- en: ➋CL_SUCCESS = 0x0,
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋CL_SUCCESS = 0x0，
- en: ➌CL_VIRUS = 0x1
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌CL_VIRUS = 0x1
- en: '}'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-4: An enumeration to store the ClamAV return codes we are interested
    in'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-4：存储我们感兴趣的 ClamAV 返回代码的枚举
- en: This isn’t a complete list of return codes by any means. I am only including
    the return codes I expect to see in the examples we’ll be writing. These are the
    clean ➊ and success ➋ codes, which indicate a scanned file had no viruses or that
    an action was successful, respectively, and the virus code ➌, which reports back
    that a virus was detected in a scanned file. If you run into any error codes not
    defined in the ClamReturnCode enum, you can look them up in the ClamAV source
    code in clamav.h. These codes are defined in the cl_error_t struct in the header
    file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是一个完整的返回代码列表。我只包括了在我们编写的示例中预期会看到的返回代码。这些是清洁代码 ➊ 和成功代码 ➋，分别表示扫描的文件没有病毒或某个操作成功，病毒代码
    ➌ 则表示在扫描文件中检测到病毒。如果你遇到 ClamReturnCode 枚举中未定义的错误代码，可以在 ClamAV 源代码的 clamav.h 中查找它们。这些代码在头文件中的
    cl_error_t 结构中定义。
- en: Our ClamReturnCode enum has three values, only two of which are distinct. Both
    CL_CLEAN and CL_SUCCESS share the same value of 0x0 because 0x0 means both that
    everything is running as expected and that a scanned file is clean. The other
    value, 0x1, is returned when a virus is detected.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 ClamReturnCode 枚举有三个值，其中只有两个是不同的。CL_CLEAN 和 CL_SUCCESS 都共享相同的值 0x0，因为 0x0
    既表示一切按预期运行，也表示扫描的文件是干净的。另一个值 0x1 则表示检测到病毒。
- en: The last enum we need to define is the ClamScanOptions enum, the most complicated
    of the enums we need. It’s shown in [Listing 10-5](#filepos719807).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义的最后一个枚举是 ClamScanOptions 枚举，这是我们需要的最复杂的枚举。它在[清单 10-5](#filepos719807)中显示。
- en: '[Flags]'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[Flags]'
- en: public enum ClamScanOptions
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public enum ClamScanOptions
- en: '{'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: CL_SCAN_ARCHIVE = 0x1,
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_SCAN_ARCHIVE = 0x1,
- en: CL_SCAN_MAIL = 0x2,
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_SCAN_MAIL = 0x2,
- en: CL_SCAN_OLE2 = 0x4,
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_SCAN_OLE2 = 0x4,
- en: CL_SCAN_HTML = 0x10,
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_SCAN_HTML = 0x10,
- en: ➊CL_SCAN_PE = 0x20,
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊CL_SCAN_PE = 0x20,
- en: CL_SCAN_ALGORITHMIC = 0x200,
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_SCAN_ALGORITHMIC = 0x200,
- en: ➋CL_SCAN_ELF = 0x2000,
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋CL_SCAN_ELF = 0x2000,
- en: CL_SCAN_PDF = 0x4000,
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_SCAN_PDF = 0x4000,
- en: ➌CL_SCAN_STDOPT = (CL_SCAN_ARCHIVE | CL_SCAN_MAIL |
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌CL_SCAN_STDOPT = (CL_SCAN_ARCHIVE | CL_SCAN_MAIL |
- en: CL_SCAN_OLE2 | CL_SCAN_PDF | CL_SCAN_HTML | CL_SCAN_PE |
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_SCAN_OLE2 | CL_SCAN_PDF | CL_SCAN_HTML | CL_SCAN_PE |
- en: CL_SCAN_ALGORITHMIC | CL_SCAN_ELF)
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CL_SCAN_ALGORITHMIC | CL_SCAN_ELF)
- en: '}'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-5: The class to hold the options for a ClamAV scan'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 10-5: 用于保存 ClamAV 扫描选项的类'
- en: As you can see, ClamScanOptions looks like a more complex version of ClamDatabaseOptions.
    It defines a variety of file types that can be scanned (Windows PE executables
    ➊, Unix ELF executables ➋, PDFs, and so on) along with a set of standard options
    ➌. As with the previous enumerations, these enumeration values were taken directly
    from the ClamAV source code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，ClamScanOptions 看起来是 ClamDatabaseOptions 的复杂版本。它定义了可以扫描的各种文件类型（Windows
    PE 可执行文件 ➊、Unix ELF 可执行文件 ➋、PDF 等），以及一组标准选项 ➌。与之前的枚举一样，这些枚举值直接取自 ClamAV 源代码。
- en: The ClamResult Supporting Class
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ClamResult 支持类
- en: Now we need only implement the ClamResult class, shown in [Listing 10-6](#filepos721117),
    to round out the support required to drive libclamav.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要实现 ClamResult 类（见[清单 10-6](#filepos721117)），以完成 libclamav 的支持功能。
- en: public class ClamResult
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class ClamResult
- en: '{'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public ➊ClamReturnCode ReturnCode { get; set; }
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊ClamReturnCode ReturnCode { get; set; }
- en: public string VirusName { get; set; }
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string VirusName { get; set; }
- en: public string FullPath { get; set; }
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string FullPath { get; set; }
- en: '}'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-6: The class that holds results of a ClamAV scan'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 10-6: 用于保存 ClamAV 扫描结果的类'
- en: 'This one is super simple! The first property is a ClamReturnCode ➊ that stores
    the return code of a scan (which should usually be CL_VIRUS). We also have two
    string properties: one to hold the name of the virus ClamAV reports back and one
    to hold the path to the file if we need it later. We’ll use this class to store
    the results of each file scan as one object.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单！第一个属性是 ClamReturnCode ➊，用于存储扫描的返回代码（通常应该是 CL_VIRUS）。我们还拥有两个字符串属性：一个用于存储
    ClamAV 返回的病毒名称，另一个用于存储文件路径，以便后续使用。我们将使用这个类来保存每个文件扫描的结果作为一个对象。
- en: Accessing ClamAV’s Native Library Functions
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 ClamAV 的本地库函数
- en: In order to keep some separation of the native functions we’ll be consuming
    from libclamav and the rest of the C# code and classes, we define a single class
    that holds all the ClamAV functions we’ll use (see [Listing 10-7](#filepos723716)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们从 libclamav 调用的本地函数与其余 C# 代码和类之间的分离，我们定义了一个类来封装所有我们将使用的 ClamAV 函数（见[清单
    10-7](#filepos723716)）。
- en: static class ClamBindings
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static class ClamBindings
- en: '{'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: const string ➊_clamLibPath = "/Users/bperry/clamav/libclamav/.libs/libclamav.7.dylib";
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: const string ➊_clamLibPath = "/Users/bperry/clamav/libclamav/.libs/libclamav.7.dylib";
- en: '[➋DllImport(_clamLibPath)]'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[➋DllImport(_clamLibPath)]'
- en: public extern static ➌ClamReturnCode cl_init(uint options);
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public extern static ➌ClamReturnCode cl_init(uint options);
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[DllImport(_clamLibPath)]'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[DllImport(_clamLibPath)]'
- en: public extern static IntPtr cl_engine_new();
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public extern static IntPtr cl_engine_new();
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[DllImport(_clamLibPath)]'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[DllImport(_clamLibPath)]'
- en: public extern static ClamReturnCode cl_engine_free(IntPtr engine);
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public extern static ClamReturnCode cl_engine_free(IntPtr engine);
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[DllImport(_clamLibPath)]'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[DllImport(_clamLibPath)]'
- en: public extern static IntPtr cl_retdbdir();
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public extern static IntPtr cl_retdbdir();
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[DllImport(_clamLibPath)]'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[DllImport(_clamLibPath)]'
- en: public extern static ClamReturnCode cl_load(string path, IntPtr engine,
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public extern static ClamReturnCode cl_load(string path, IntPtr engine,
- en: ref uint signo, uint options);
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ref uint signo, uint options);
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[DllImport(_clamLibPath)]'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[DllImport(_clamLibPath)]'
- en: public extern static ClamReturnCode cl_scanfile(string path, ref IntPtr virusName,
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public extern static ClamReturnCode cl_scanfile(string path, ref IntPtr virusName,
- en: ref ulong scanned, IntPtr engine, uint options);
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ref ulong scanned, IntPtr engine, uint options);
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[DllImport(_clamLibPath)]'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[DllImport(_clamLibPath)]'
- en: public extern static ClamReturnCode cl_engine_compile(IntPtr engine);
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public extern static ClamReturnCode cl_engine_compile(IntPtr engine);
- en: '}'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-7: The  ClamBindings  class, which holds all the ClamAV functions'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-7: ClamBindings 类，包含所有 ClamAV 函数'
- en: The ClamBindings class first defines a string that is the full path ➊ to the
    ClamAV library we’ll be interfacing with. In this example, I am pointing to an
    OS X .dylib that I compiled from source to match the architecture of my Mono installation.
    Depending on how you compiled or installed ClamAV, the path to the native ClamAV
    library may differ on your system. On Windows, the file will be a .dll file in
    the /Program Files directory if you used the ClamAV installer. On OS X, it will
    be a .dylib file, and on Linux it will be a .so file. On the latter systems, you
    could use find to locate the correct library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ClamBindings 类首先定义了一个字符串，表示我们将要接口的 ClamAV 库的完整路径 ➊。在这个例子中，我指向的是我从源代码编译的一个 OS
    X .dylib 文件，以匹配我的 Mono 安装的架构。根据你编译或安装 ClamAV 的方式，原生 ClamAV 库的路径在你的系统上可能有所不同。如果你使用
    ClamAV 安装程序，在 Windows 上，这个文件将是一个位于 /Program Files 目录中的 .dll 文件。在 OS X 上，它将是一个
    .dylib 文件，在 Linux 上则是 .so 文件。在后两种系统上，你可以使用 find 命令定位正确的库。
- en: 'On Linux, something like this would print the path to any libclamav libraries:
    $ find / -name libclamav*so$'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，类似以下命令会打印出任何 libclamav 库的路径：$ find / -name libclamav*so$
- en: 'On OS X, use this: $ find / -name libclamav*dylib$'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OS X 上，使用此命令：$ find / -name libclamav*dylib$
- en: The DllImport attribute ➋ tells the Mono/.NET runtime to look for the given
    function in the library we specified in the argument. This way, we are able to
    directly call on ClamAV functions inside our program. We’ll cover what the functions
    shown in [Listing 10-7](#filepos723716) do when we implement the ClamEngine class
    next. You can also see that we’re already using the ClamReturnCode class ➌, which
    is returned when some of ClamAV’s native functions are called.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: DllImport 属性 ➋ 告诉 Mono/.NET 运行时在我们在参数中指定的库中查找给定的函数。这样，我们就能直接在程序中调用 ClamAV 函数。接下来，我们将介绍在实现
    ClamEngine 类时，[列表 10-7](#filepos723716) 中显示的函数的功能。你还可以看到我们已经在使用 ClamReturnCode
    类 ➌，它是在调用某些 ClamAV 本地函数时返回的。
- en: Compiling the ClamAV Engine
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 ClamAV 引擎
- en: The ClamEngine class in [Listing 10-8](#filepos727882) will do most of the real
    work of scanning and reporting on potentially malicious files.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-8](#filepos727882)中的 ClamEngine 类将执行大部分实际的扫描和潜在恶意文件报告工作。'
- en: 'public class ClamEngine : IDisposable'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class ClamEngine : IDisposable'
- en: '{'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: private ➊IntPtr engine;
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private ➊IntPtr engine;
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➋ClamEngine()
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➋ClamEngine()
- en: '{'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ClamReturnCode ret = ClamBindings.➌cl_init((uint)ClamDatabaseOptions.CL_DB_STDOPT);
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ClamReturnCode ret = ClamBindings.➌cl_init((uint)ClamDatabaseOptions.CL_DB_STDOPT);
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (ret != ClamReturnCode.CL_SUCCESS)
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (ret != ClamReturnCode.CL_SUCCESS)
- en: throw new Exception("Expected CL_SUCCESS, got " + ret);
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("预期返回 CL_SUCCESS，但得到 " + ret);
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: engine = ClamBindings.➍cl_engine_new();
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: engine = ClamBindings.➍cl_engine_new();
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: try
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string ➎dbDir = Marshal.PtrToStringAnsi(ClamBindings.cl_retdbdir());
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string ➎dbDir = Marshal.PtrToStringAnsi(ClamBindings.cl_retdbdir());
- en: uint ➏signatureCount = 0;
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: uint ➏signatureCount = 0;
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ret = ClamBindings.➐cl_load(dbDir, engine, ref signatureCount,
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ret = ClamBindings.➐cl_load(dbDir, engine, ref signatureCount,
- en: (uint)ClamScanOptions.CL_SCAN_STDOPT);
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (uint)ClamScanOptions.CL_SCAN_STDOPT);
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (ret != ClamReturnCode.CL_SUCCESS)
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (ret != ClamReturnCode.CL_SUCCESS)
- en: throw new Exception("Expected CL_SUCCESS, got " + ret);
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("预期返回 CL_SUCCESS，但得到 " + ret);
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ret = (ClamReturnCode)ClamBindings.➑cl_engine_compile(engine);
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ret = (ClamReturnCode)ClamBindings.➑cl_engine_compile(engine);
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (ret != ClamReturnCode.CL_SUCCESS)
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (ret != ClamReturnCode.CL_SUCCESS)
- en: throw new Exception("Expected CL_SUCCESS, got " + ret);
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("预期返回 CL_SUCCESS，但得到 " + ret);
- en: '}'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: catch
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: catch
- en: '{'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ret = ClamBindings.cl_engine_free(engine);
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ret = ClamBindings.cl_engine_free(engine);
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (ret != ClamReturnCode.CL_SUCCESS)
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (ret != ClamReturnCode.CL_SUCCESS)
- en: Console.Error.WriteLine("Freeing allocated engine failed");
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.Error.WriteLine("释放分配的引擎失败");
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: throw;
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw;
- en: '}'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-8: The  ClamEngine  class, which scans and reports on files'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-8: ClamEngine 类，用于扫描和报告文件'
- en: First, we declare a class-level IntPtr variable ➊, called engine, which will
    point to our ClamAV engine for the other methods in the class to use. Although
    C# doesn’t need a pointer to reference the exact address of an object in memory,
    C does. C has pointers that are of the intptr_t data type, and IntPtr is the C#
    version of a C pointer. Since the ClamAV engine will be passed back and forth
    between .NET and C, we need a pointer to refer to the address in memory where
    it is stored when we pass it to C. This is what happens when we create engine,
    which we’ll assign a value inside the constructor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个类级别的 IntPtr 变量 ➊，名为 engine，它将指向我们的 ClamAV 引擎，供类中的其他方法使用。虽然 C# 不需要指针来引用对象在内存中的确切地址，但
    C 需要。C 有指针，类型为 intptr_t，而 IntPtr 是 C# 版的 C 指针。由于 ClamAV 引擎将在 .NET 和 C 之间来回传递，我们需要一个指针来引用它在内存中存储的地址，以便将其传递给
    C。这就是创建 engine 变量时发生的事情，我们将在构造函数中为其赋值。
- en: Next, we define the constructor. The constructor for the ClamEngine class ➋
    doesn’t require any arguments. To initialize ClamAV to begin allocating engines
    to scan with, we call cl_init() ➌ from the ClamBindings class by passing the signature
    database options we want to use when loading the signatures. Just in case ClamAV
    doesn’t initialize, we check the return code of cl_init() and throw an exception
    if initialization failed. If ClamAV initializes successfully, we allocate a new
    engine with cl_engine_new() ➍, which takes no arguments and returns the pointer
    to the new ClamAV engine that we store in the engine variable for later use.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义构造函数。ClamEngine 类的构造函数 ➋ 不需要任何参数。为了初始化 ClamAV 开始分配用于扫描的引擎，我们通过传递加载签名时要使用的签名数据库选项来调用
    ClamBindings 类中的 cl_init() ➌。为了防止 ClamAV 初始化失败，我们检查 cl_init() 的返回代码，如果初始化失败，则抛出异常。如果
    ClamAV 初始化成功，我们使用 cl_engine_new() ➍ 分配一个新引擎，该方法不接受任何参数，并返回指向新 ClamAV 引擎的指针，我们将其存储在
    engine 变量中以供后续使用。
- en: Once we have an engine allocated, we need to load the antivirus signatures to
    scan with. The cl_retdbdir() function returns the path to the definition database
    ClamAV is configured to use and stores it in the dbDir variable ➎. Because cl_retdbdir()
    returns a C pointer string, we convert it to a regular string by using the function
    PtrToStringAnsi() on the Marshal class, a class used to convert data types from
    managed types to unmanaged (and vice versa). Once we store the database path,
    we define an integer, signatureCount ➏, which is passed to cl_load() and assigned
    the number of signatures that were loaded from the database.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配了引擎，我们需要加载病毒签名以供扫描。cl_retdbdir() 函数返回 ClamAV 配置使用的定义数据库路径，并将其存储在 dbDir 变量中
    ➎。由于 cl_retdbdir() 返回的是 C 指针字符串，我们通过使用 Marshal 类中的 PtrToStringAnsi() 函数将其转换为常规字符串，Marshal
    类用于在托管类型和非托管类型之间转换数据类型。一旦存储了数据库路径，我们定义一个整数变量 signatureCount ➏，该变量被传递给 cl_load()
    并赋值为从数据库中加载的签名数量。
- en: We use cl_load() ➐ from the ClamBindings class to load the signature database
    into the engine. We pass the ClamAV database directory dbDir and the new engine
    as arguments, along with a few other values. The last argument passed to cl_load()
    is an enumeration value for the types of files we want to support scanning (such
    as HTML, PDF, or other specific types of files). We use the class we created earlier,
    ClamScanOptions, to define our scan options as CL_SCAN_STDOPT so that we use the
    standard scan options. After we have loaded the virus database (which can take
    several seconds, depending on the options), we check whether the return code is
    equal to CL_SUCCESS again; if it is, we finally compile the engine by passing
    it to the cl_engine_ compile() function ➑, which prepares the engine to begin
    scanning files. Then we check whether we received a CL_SUCCESS return code one
    last time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 ClamBindings 类中的 cl_load() ➐ 方法将签名数据库加载到引擎中。我们将 ClamAV 数据库目录 dbDir 和新引擎作为参数传递，还传递一些其他值。传递给
    cl_load() 的最后一个参数是一个枚举值，用于指定我们希望支持扫描的文件类型（例如 HTML、PDF 或其他特定类型的文件）。我们使用之前创建的类 ClamScanOptions
    来定义扫描选项，设置为 CL_SCAN_STDOPT，这样我们就使用标准的扫描选项。在加载完病毒数据库后（根据选项，可能需要几秒钟），我们再次检查返回代码是否等于
    CL_SUCCESS；如果是，我们最终通过将其传递给 cl_engine_compile() 函数 ➑ 来编译引擎，准备引擎开始扫描文件。然后，我们最后一次检查是否收到了
    CL_SUCCESS 返回代码。
- en: Scanning Files
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描文件
- en: In order to scan files easily, we’ll wrap cl_scanfile() (the ClamAV library
    function that scans a file and reports back the result) with our own method, which
    we’ll call ScanFile(). This allows us to prepare the arguments we need to pass
    to cl_scanfile() and allows us to process and return the results from ClamAV as
    one ClamResult object. This is shown in [Listing 10-9](#filepos733721).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化文件扫描，我们将cl_scanfile()（ClamAV库中的扫描文件并返回结果的函数）封装为我们自己的方法，命名为ScanFile()。这样我们就可以准备传递给cl_scanfile()的参数，并能够处理并返回来自ClamAV的结果，作为一个ClamResult对象返回。此过程在[Listing
    10-9](#filepos733721)中展示。
- en: public ClamResult ScanFile(string filepath, uint options = (uint)ClamScanOptions.➊CL_SCAN_STDOPT)
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ClamResult ScanFile(string filepath, uint options = (uint)ClamScanOptions.➊CL_SCAN_STDOPT)
- en: '{'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➋ulong scanned = 0;
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋ulong scanned = 0;
- en: ➌IntPtr vname = (IntPtr)null;
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌IntPtr vname = (IntPtr)null;
- en: ClamReturnCode ret = ClamBindings.➍cl_scanfile(filepath, ref vname, ref scanned,
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ClamReturnCode ret = ClamBindings.➍cl_scanfile(filepath, ref vname, ref scanned,
- en: engine, options);
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: engine, options);
- en: if (ret == ClamReturnCode.CL_VIRUS)
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (ret == ClamReturnCode.CL_VIRUS)
- en: '{'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string virus = Marshal.➎PtrToStringAnsi(vname);
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string virus = Marshal.➎PtrToStringAnsi(vname);
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➏ClamResult result = new ClamResult();
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➏ClamResult result = new ClamResult();
- en: result.ReturnCode = ret;
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result.ReturnCode = ret;
- en: result.VirusName = virus;
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result.VirusName = virus;
- en: result.FullPath = filepath;
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: result.FullPath = filepath;
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return result;
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return result;
- en: '}'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: else if (ret == ClamReturnCode.CL_CLEAN)
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if (ret == ClamReturnCode.CL_CLEAN)
- en: return new ClamResult() { ReturnCode = ret, FullPath = filepath };
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return new ClamResult() { ReturnCode = ret, FullPath = filepath };
- en: else
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: 'throw new Exception("Expected either CL_CLEAN or CL_VIRUS, got: " + ret);'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'throw new Exception("Expected either CL_CLEAN or CL_VIRUS, got: " + ret);'
- en: '}'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-9: The  ScanFile()  method, which scans and returns a  ClamResult  object'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-9: ScanFile()方法，它扫描并返回一个ClamResult对象'
- en: The ScanFile() method we implement takes two arguments, but we only need the
    first, which is the path of the file to scan. The user can define scan options
    with the second argument, but if a second argument isn’t specified, then the standard
    scan options ➊ we defined in ClamScanOptions will be used to scan the file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的ScanFile()方法接受两个参数，但我们只需要第一个参数，即要扫描的文件路径。用户可以通过第二个参数定义扫描选项，但如果未指定第二个参数，则会使用我们在ClamScanOptions中定义的标准扫描选项➊来扫描文件。
- en: We start the ScanFile() method by defining some variables to use. The scanned
    ulong type variable is initially set to 0 ➋. We won’t actually use this variable
    after scanning the file, but the cl_scanfile() function requires it in order to
    be called correctly. The next variable we define is another IntPtr, which we call
    vname (for virus name) ➌. We set this initially to be null, but we’ll later assign
    a C string pointer to it that points to a virus name in the ClamAV database whenever
    a virus is found.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义一些变量来开始ScanFile()方法的实现。扫描用的ulong类型变量最初设置为0➋。在扫描完文件后，我们实际上不会再使用这个变量，但cl_scanfile()函数需要这个变量才能正确调用。我们定义的下一个变量是另一个IntPtr，我们称之为vname（病毒名称）➌。最初将其设置为null，但稍后我们会为它分配一个C字符串指针，当检测到病毒时，该指针指向ClamAV数据库中的病毒名称。
- en: We use the cl_scanfile() function ➍ we defined in ClamBindings to scan the file
    and pass it a handful of arguments. The first argument is the file path we want
    to scan, followed by the variable that will be assigned the name of the detected
    virus, if any. The last two arguments are the engine we will be scanning with
    and the scan options we want use to perform the virus scan. The middle argument,
    scanned, is required to call cl_scanfile() but isn’t useful for us here. We won’t
    use it again after passing it as an argument to this function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用ClamBindings中定义的cl_scanfile()函数➍来扫描文件，并传递给它一些参数。第一个参数是我们要扫描的文件路径，接着是一个变量，如果检测到病毒，这个变量将被赋值为病毒名称。最后两个参数分别是我们将用于扫描的引擎和扫描选项。中间的参数scanned是调用cl_scanfile()所必需的，但对我们来说并没有实际用途。我们在将它作为参数传递给该函数后就不会再使用它。
- en: The rest of the method packages the scan information nicely for the programmer’s
    use. If the return code of cl_scanfile() indicates a virus was found, we use PtrToStringAnsi()
    ➎ to return the string that the vname variable points to in memory. Once we have
    the virus name, we create a new ClamResult class ➏ and assign it three properties
    using the cl_scanfile() return code, the virus name, and the path to the scanned
    file. Then, we return the ClamResult class to the caller. If the return code is
    CL_CLEAN, we return a new ClamResult class with a ReturnCode of CL_CLEAN. If it
    is neither CL_CLEAN nor CL_VIRUS, however, we throw an exception because we got
    a return code we didn’t expect.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的其余部分将扫描信息包装成便于程序员使用的形式。如果 cl_scanfile() 的返回代码表明发现了病毒，我们使用 PtrToStringAnsi()
    ➎ 返回 vname 变量在内存中指向的字符串。一旦得到病毒名称，我们创建一个新的 ClamResult 类 ➏ 并使用 cl_scanfile() 返回代码、病毒名称和扫描文件的路径为其赋值三个属性。然后，我们将
    ClamResult 类返回给调用者。如果返回代码是 CL_CLEAN，我们将返回一个带有 CL_CLEAN 返回代码的新 ClamResult 类。然而，如果它既不是
    CL_CLEAN 也不是 CL_VIRUS，我们会抛出异常，因为我们得到了一个我们没有预料的返回代码。
- en: Cleaning Up
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 清理工作
- en: The last method left to implement in the ClamEngine class is Dispose(), shown
    in [Listing 10-10](#filepos737830), which automatically cleans up after a scan
    in the context of a using statement and is required by the IDisposable interface.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ClamEngine 类中最后需要实现的方法是 Dispose()，如[列表 10-10](#filepos737830)所示，它在使用语句的上下文中自动清理扫描后的工作，并且是
    IDisposable 接口所要求的。
- en: public void Dispose()
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public void Dispose()
- en: '{'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ClamReturnCode ret = ClamBindings.➊cl_engine_free(engine);
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ClamReturnCode ret = ClamBindings.➊cl_engine_free(engine);
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (ret != ClamReturnCode.CL_SUCCESS)
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (ret != ClamReturnCode.CL_SUCCESS)
- en: Console.Error.WriteLine("Freeing allocated engine failed");
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.Error.WriteLine("释放分配的引擎失败");
- en: '}'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-10: The  Dispose()  method, which automatically cleans up engines'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-10：Dispose() 方法，自动清理引擎
- en: We implement the Dispose() method because if we don’t free our ClamAV engine
    when we are done with it, it could become a memory leak. One drawback of working
    with C libraries from a language like C# is that, because C# has garbage collection,
    many programmers don’t actively think about cleaning up after themselves. However,
    C does not have garbage collection. If we allocate something in C, we need to
    free it when we are done with it. This is what the cl_engine_free() function ➊
    does. To be diligent, we’ll also check to make sure that the engine was successfully
    freed by comparing the return code to CL_SUCCESS. If they are the same, all is
    good. Otherwise, we throw an exception because we should be able to free an engine
    we allocated, and if we can’t, this may point to a problem in the code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现 Dispose() 方法是因为，如果在使用完 ClamAV 引擎后不释放它，可能会导致内存泄漏。使用像 C# 这样的语言与 C 库进行工作有一个缺点，因为
    C# 有垃圾回收机制，很多程序员不会主动考虑清理资源。然而，C 语言没有垃圾回收机制。如果我们在 C 中分配了某些内容，使用完后就需要手动释放。这就是 cl_engine_free()
    函数 ➊ 的作用。为了确保我们做到谨慎，我们还会检查引擎是否已成功释放，通过将返回代码与 CL_SUCCESS 进行比较。如果它们相同，一切正常。否则，我们会抛出异常，因为我们应该能够释放已分配的引擎，如果做不到，这可能表明代码中存在问题。
- en: Testing the Program by Scanning the EICAR File
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扫描 EICAR 文件来测试程序
- en: Now we can bring it all together to scan something to test out our bindings.
    The EICAR file is an industry-recognized text file used to test antivirus products.
    It isn’t harmful, but any functioning antivirus product should detect it as a
    virus, so we’ll use it to test our program. In [Listing 10-11](#filepos739889),
    we use the Unix cat command to print the contents of a test file used specifically
    for testing antivirus—the EICAR file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将所有内容整合起来，扫描一些文件来测试我们的绑定。EICAR 文件是一个行业公认的文本文件，用于测试防病毒产品。它无害，但任何正常工作的防病毒产品应该将其识别为病毒，因此我们将用它来测试我们的程序。在[列表
    10-11](#filepos739889)中，我们使用 Unix 的 cat 命令打印用于专门测试防病毒的测试文件的内容——EICAR 文件。
- en: $ cat ~/eicar.com.txt
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ cat ~/eicar.com.txt
- en: X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
- en: 'Listing 10-11: Printing the contents of the EICAR antivirus test file'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-11：打印 EICAR 防病毒测试文件的内容
- en: The short program in [Listing 10-12](#filepos741124) will scan any files specified
    as arguments and print the results.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-12](#filepos741124) 中的简短程序将扫描作为参数指定的任何文件并打印结果。'
- en: public static void Main(string[] args)
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (➊ClamEngine e = new ClamEngine())
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (➊ClamEngine e = new ClamEngine())
- en: '{'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: foreach (string file in args)
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (string file in args)
- en: '{'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ClamResult result = e.➋ScanFile(file); //pretty simple!
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ClamResult result = e.➋ScanFile(file); //非常简单！
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (result != null && result.ReturnCode == ClamReturnCode.➌CL_VIRUS)
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 (result != null && result.ReturnCode == ClamReturnCode.➌CL_VIRUS)
- en: 'Console.WriteLine("Found: " + result.VirusName);'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("Found: " + result.VirusName);'
- en: else
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: Console.WriteLine("File Clean!");
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("文件干净！");
- en: '}'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '} //engine is disposed of here and the allocated engine freed automatically'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '} // 引擎在这里被释放，分配的引擎会自动被清理'
- en: '}'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-12: The  Main()  method of our program to automate ClamAV'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-12：自动化 ClamAV 的程序的 Main() 方法
- en: We begin by creating our ClamEngine class ➊ in the context of a using statement
    so that we automatically clean up the engine when we are finished. We then iterate
    over each argument passed to Main() and assume it is a file path that we can scan
    with ClamAV. We pass each file path to the ScanFile() method ➋ and then check
    the result returned by ScanFile() to see if ClamAV has returned the CL_VIRUS return
    code ➌. If so, we print the virus name to the screen, as shown in [Listing 10-13](#filepos742346).
    Otherwise, we print the text File Clean!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建我们的 ClamEngine 类 ➊，并在 using 语句中使用它，这样在完成时可以自动清理引擎。接着，我们遍历传递给 Main() 的每个参数，并假设它是一个文件路径，我们可以用
    ClamAV 扫描它。我们将每个文件路径传递给 ScanFile() 方法 ➋，然后检查 ScanFile() 返回的结果，看看 ClamAV 是否返回了
    CL_VIRUS 返回代码 ➌。如果是，我们将病毒名称打印到屏幕上，如 [列表 10-13](#filepos742346) 所示。否则，我们打印文本“文件干净！”
- en: $ mono ./ch10_automating_clamav_fs.exe ~/eicar.com.txt
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ mono ./ch10_automating_clamav_fs.exe ~/eicar.com.txt
- en: '➊ Found: Eicar-Test-Signature Listing 10-13: Running our ClamAV program on
    the EICAR file results in a virus identification.'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊ 找到：Eicar 测试签名 列表 10-13：运行我们的 ClamAV 程序在 EICAR 文件上时，会识别到病毒。
- en: 'If the program prints Found: Eicar-Test-Signature ➊, then it works! This means
    that ClamAV scanned the EICAR file, matched it against the EICAR definition it
    has in its database, and returned the virus name for us. A great exercise for
    expanding this program would be to use a FileWatcher class that allows you to
    define directories to watch for any changes and then automatically scans the files
    that are changed or created in those folders.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '如果程序打印出 Found: Eicar-Test-Signature ➊，那就表示它工作正常！这意味着 ClamAV 扫描了 EICAR 文件，并将其与数据库中的
    EICAR 定义进行了匹配，然后返回了病毒名称。一个扩展该程序的好方法是使用 FileWatcher 类，允许你定义要监视的目录，并在文件发生更改或创建时自动扫描这些文件。'
- en: We now have a working program that scans files with ClamAV. However, there may
    be instances when you can’t effectively ship ClamAV with the application due to
    licensing (ClamAV is licensed with the GNU Public License) or technical reasons,
    but you still need a way to scan files for viruses on your network. We’ll go over
    one other method to automate ClamAV that will solve this problem in a more centralized
    way.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以使用 ClamAV 扫描文件的工作程序。然而，可能有一些情况，由于许可问题（ClamAV 采用 GNU 公共许可证）或技术原因，你不能有效地将
    ClamAV 与应用程序一起打包，但你仍然需要一种方法来扫描网络中的文件是否有病毒。我们将介绍另一种自动化 ClamAV 的方法，这将以更集中的方式解决这个问题。
- en: Automating with clamd
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 clamd 自动化
- en: 'The clamd daemon provides a great way to add virus scanning to an application
    that accepts file uploads from users or something similar. It operates over the
    TCP, but with no SSL by default! It is also very lightweight, but it has to be
    run on a server on your network, which results in some limitations. The clamd
    service allows you to have a long-lived process running for scanning files instead
    of needing to manage and allocate the ClamAV engine as in the previous automation.
    Because it’s a server version of ClamAV, you can use clamd to scan files for computers
    without even installing the application. This can be convenient when you only
    want to manage virus definitions in one place or you have resource limitations
    and want to offload the virus scanning to another machine, as discussed earlier.
    Getting automation working for clamd is exceedingly simple in C#. It requires
    two small classes: a session and a manager.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: clamd 守护进程为需要接受用户上传文件或类似功能的应用程序提供了一个很好的病毒扫描方法。它通过 TCP 操作，但默认情况下不使用 SSL！它还非常轻量，但必须在网络中的服务器上运行，这会带来一些限制。clamd
    服务允许你使用长时间运行的进程来扫描文件，而不是像之前的自动化方式那样管理和分配 ClamAV 引擎。由于它是 ClamAV 的服务器版本，你可以使用 clamd
    在不安装应用程序的情况下扫描计算机上的文件。当你只想集中管理病毒定义，或者当你有资源限制并希望将病毒扫描任务卸载到其他机器时，这非常方便，就像前面讨论的那样。在
    C# 中，设置 clamd 的自动化非常简单。只需要两个小类：一个会话类和一个管理类。
- en: Installing the clamd Daemon
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 clamd 守护进程
- en: 'On most platforms, installing ClamAV from the package manager might not install
    the clamd daemon. For instance, on Ubuntu, you will need to install the clamav-daemon
    package separately with apt, as shown here: $ sudo apt-get install clamav-daemon
    On Red Hat or Fedora, you’d install a slightly different package name: $ sudo
    yum install clamav-server'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数平台上，从包管理器安装 ClamAV 可能不会安装 clamd 守护进程。例如，在 Ubuntu 上，你需要使用 apt 单独安装 clamav-daemon
    包，如下所示：$ sudo apt-get install clamav-daemon；在 Red Hat 或 Fedora 上，你需要安装一个稍微不同的包：$
    sudo yum install clamav-server
- en: Starting the clamd Daemon
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 clamd 守护进程
- en: To use clamd after installing the daemon, you need to start the daemon, which
    listens on port 3310 and address 127.0.0.1 by default. You can do this with the
    clamd command, as shown in [Listing 10-14](#filepos745792).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 安装守护进程后，要使用 clamd，你需要启动守护进程，默认情况下，它会监听端口 3310 和地址 127.0.0.1。你可以使用 clamd 命令启动它，如
    [Listing 10-14](#filepos745792) 所示。
- en: '$ clamd  Listing 10-14: Starting the clamd daemon'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '$ clamd  Listing 10-14: 启动 clamd 守护进程'
- en: NOTE
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE
- en: If you install clamd with a package manager, it may be configured by default
    to listen on a local UNIX socket rather than on a network interface. If you are
    having trouble connecting to the clamd daemon using a TCP socket, make sure that
    clamd is configured to listen on a network interface!
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你通过包管理器安装 clamd，它可能默认配置为监听本地 UNIX 套接字，而不是网络接口。如果你在使用 TCP 套接字连接到 clamd 守护进程时遇到问题，请确保
    clamd 配置为监听网络接口！
- en: You may not get any feedback when you run the command. No news is good news!
    If clamd starts with no messages, then you have successfully started it. We can
    test whether clamd is running properly with netcat by connecting to the listening
    port and seeing what happens when we manually run commands on it, such as by getting
    the current clamd version and scanning a file, as in [Listing 10-15](#filepos747467).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行命令时，可能不会得到任何反馈。没有消息就是好消息！如果 clamd 启动时没有任何消息，那么你已经成功启动它了。我们可以通过 netcat 测试
    clamd 是否正常运行，通过连接到监听端口并查看当我们手动运行命令时会发生什么，例如获取当前的 clamd 版本并扫描文件，如 [Listing 10-15](#filepos747467)
    所示。
- en: $ echo VERSION | nc -v 127.0.0.1 3310
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ echo VERSION | nc -v 127.0.0.1 3310
- en: ClamAV 0.99/20563/Thu Jun 11 15:05:30 2015
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ClamAV 0.99/20563/Thu Jun 11 15:05:30 2015
- en: $ echo "SCAN /tmp/eicar.com.txt" | nc -v 127.0.0.1 3310
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ echo "SCAN /tmp/eicar.com.txt" | nc -v 127.0.0.1 3310
- en: '/tmp/eicar.com.txt: Eicar-Test-Signature FOUND'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '/tmp/eicar.com.txt: Eicar-Test-Signature FOUND'
- en: 'Listing 10-15: Running simple commands for  clamd  using the  netcat  TCP utility'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-15: 使用 netcat TCP 工具运行简单的 clamd 命令'
- en: Connecting to clamd and sending the VERSION command should print the ClamAV
    version. You can also send the SCAN command with a file path as the argument,
    and it should return the scan results. Writing code to automate this is easy.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到 clamd 并发送 VERSION 命令应该会打印 ClamAV 版本。你也可以发送 SCAN 命令，并将文件路径作为参数，它应该返回扫描结果。编写自动化代码非常简单。
- en: Creating a Session Class for clamd
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为 clamd 创建会话类
- en: The ClamdSession class requires almost no deep dive into how the code in the
    class works because it’s so simple. We create some properties to hold the host
    and port that clamd runs on, an Execute() method that takes a clamd() command
    and executes it, and a TcpClient class to create a new TCP stream to write the
    commands to, as shown in [Listing 10-16](#filepos750465). The TcpClient class
    was first introduced in [Chapter 4](index_split_009.html#filepos344540) when we
    built custom payloads. We also used it in [Chapter 7](index_split_012.html#filepos509064)
    when we automated the OpenVAS vulnerability scanner.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ClamdSession 类几乎不需要深入了解类中代码的工作原理，因为它非常简单。我们创建了一些属性来保存 clamd 运行的主机和端口，执行 clamd()
    命令并执行的 Execute() 方法，以及一个 TcpClient 类来创建一个新的 TCP 流并将命令写入流中，如 [Listing 10-16](#filepos750465)
    所示。TcpClient 类最早是在 [第 4 章](index_split_009.html#filepos344540) 中介绍的，当时我们构建了自定义有效负载。我们也在
    [第 7 章](index_split_012.html#filepos509064) 中使用了它，自动化了 OpenVAS 漏洞扫描器。
- en: public class ClamdSession
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class ClamdSession
- en: '{'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: private string _host = null;
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private string _host = null;
- en: private int _port;
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private int _port;
- en: ''
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➊ClamdSession(string host, int port)
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊ClamdSession(string host, int port)
- en: '{'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _host = host;
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _host = host;
- en: _port = port;
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _port = port;
- en: '}'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ➋Execute(string command)
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ➋Execute(string command)
- en: '{'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string resp = string.Empty;
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string resp = string.Empty;
- en: using (➌TcpClient client = new TcpClient(_host, _port))
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (➌TcpClient client = new TcpClient(_host, _port))
- en: '{'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (NetworkStream stream = client.➍GetStream())
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (NetworkStream stream = client.➍GetStream())
- en: '{'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: byte[] data = System.Text.Encoding.ASCII.GetBytes(command);
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] data = System.Text.Encoding.ASCII.GetBytes(command);
- en: stream.➎Write(data, 0, data.Length);
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: stream.➎Write(data, 0, data.Length);
- en: ''
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➏using (StreamReader rdr = new StreamReader(stream))
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➏using (StreamReader rdr = new StreamReader(stream))
- en: resp = rdr.ReadToEnd();
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = rdr.ReadToEnd();
- en: '}'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➐return resp;
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➐返回 resp;
- en: '}'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-16: The class to create a new  clamd  session'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-16: 创建一个新的 clamd 会话的类'
- en: The ClamdSession constructor ➊ takes two arguments—the host and the port to
    connect to—and then assigns those to local class variables for the Execute() method
    to use. In the past, all of our session classes have implemented the IDisposable
    interface, but we really don’t need to do that with the ClamdSession class. We
    don’t need to clean anything up when we are done because clamd is a daemon that
    runs on a port and is a background process that can continue to run, so this saves
    us a bit of complexity.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ClamdSession 构造函数 ➊ 接受两个参数——要连接的主机和端口，然后将这些值赋给本地类变量，供 Execute() 方法使用。过去，我们的所有会话类都实现了
    IDisposable 接口，但实际上 ClamdSession 类不需要这样做。我们完成工作后不需要清理任何内容，因为 clamd 是一个在端口上运行的守护进程，可以继续运行，因此这简化了我们的工作。
- en: 'The Execute() method ➋ takes a single argument: the command to run on the clamd
    instance. Our ClamdManager class will only implement a few of the possible clamd
    commands available, so you should find researching the clamd protocol commands
    highly useful to see what other powerful commands are available to automate. To
    get the commands running and start reading the clamd response, we first create
    a new TcpClient class ➌ that uses the host and passes the port to the constructor
    as the TcpClient arguments. We then call GetStream() ➍ to make a connection to
    the clamd instance that we can write our command to. Using the Write() method
    ➎, we write our command to the stream and then create a new StreamReader class
    to read the response ➏. Finally, we return the response to the caller ➐.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Execute() 方法 ➋ 接受一个参数：要在 clamd 实例上运行的命令。我们的 ClamdManager 类将只实现一些可能的 clamd 命令，因此你应该研究
    clamd 协议命令，以了解可以自动化的其他强大命令。为了启动命令并开始读取 clamd 响应，我们首先创建一个新的 TcpClient 类 ➌，它使用主机并将端口作为
    TcpClient 参数传递给构造函数。然后我们调用 GetStream() ➍ 来连接到 clamd 实例，以便将命令写入该连接。通过使用 Write()
    方法 ➎，我们将命令写入流中，然后创建一个新的 StreamReader 类来读取响应 ➏。最后，我们将响应返回给调用者 ➐。
- en: Creating a clamd Manager Class
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 clamd 管理器类
- en: The simplicity of the ClamdSession class, which we define in [Listing 10-17](#filepos753845),
    makes the ClamdManager class super simple as well. It just creates a constructor
    and two methods to execute the commands from [Listing 10-15](#filepos747467) that
    we had executed manually.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ClamdSession 类的简单性（如 [Listing 10-17](#filepos753845) 所定义）使得 ClamdManager 类也非常简单。它只需要创建一个构造函数和两个方法来执行我们之前手动执行的
    [Listing 10-15](#filepos747467) 中的命令。
- en: public class ClamdManager
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class ClamdManager
- en: '{'
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: private ClamdSession _session = null;
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private ClamdSession _session = null;
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➊ClamdManager(ClamdSession session)
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊ClamdManager(ClamdSession session)
- en: '{'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _session = session;
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _session = session;
- en: '}'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ➋GetVersion()
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ➋获取版本()
- en: '{'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.Execute("VERSION");
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.Execute("VERSION");
- en: '}'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ➌Scan(string path)
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ➌扫描(string path)
- en: '{'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.Execute("SCAN " + path);
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.Execute("SCAN " + path);
- en: '}'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-17: The manager class for  clamd'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 10-17: clamd 的管理器类'
- en: The ClamdManager constructor ➊ takes a single argument—the session that will
    be executing the commands—and assigns it to a local class variable called _session
    that the other methods can use.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ClamdManager 构造函数 ➊ 接受一个参数——将执行命令的会话，并将其赋值给一个名为 _session 的本地类变量，其他方法可以使用该变量。
- en: The first method we create is the GetVersion() method ➋, which executes the
    clamd VERSION command by passing the string VERSION to Execute(), which we defined
    in the clamd session class. This command returns the version information to the
    caller. The second method, Scan() ➌, takes a file path as the argument, which
    it passes to Execute() with the clamd SCAN command. Now that we have both the
    session and manager classes, we can stick everything together.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个方法是 GetVersion() 方法 ➋，它通过将字符串 VERSION 传递给 Execute() 方法来执行 clamd VERSION
    命令，该方法在 clamd 会话类中定义。该命令将版本信息返回给调用者。第二个方法 Scan() ➌，接受一个文件路径作为参数，它将该路径与 clamd SCAN
    命令一起传递给 Execute() 方法。现在我们有了会话类和管理器类，我们可以将一切组合在一起。
- en: Testing with clamd
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 clamd 测试
- en: Putting everything together takes only a handful of lines of code for a Main()
    method, as shown in [Listing 10-18](#filepos755884).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容组合在一起只需要为 Main() 方法写几行代码，如 [Listing 10-18](#filepos755884) 所示。
- en: public static void Main(string[] args)
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ClamdSession session = new ➊ClamdSession("127.0.0.1", 3310);
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ClamdSession session = new ➊ClamdSession("127.0.0.1", 3310);
- en: ClamdManager manager = new ClamdManager(session);
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ClamdManager manager = new ClamdManager(session);
- en: ''
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine(manager.➋GetVersion());
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine(manager.➋GetVersion());
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌foreach (string path in args)
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌foreach (string path in args)
- en: Console.WriteLine(manager.Scan(path));
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine(manager.Scan(path));
- en: '}'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 10-18: The  Main()  method to automate  clamd'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-18：自动化clamd的Main()方法
- en: We create the ClamdSession() ➊ by passing 127.0.0.1 as the host to connect to
    and 3310 as the port on the host. Then we pass the new ClamdSession to the ClamdManager
    constructor. With a new ClamdManager(), we can print the version ➋ of the clamd
    instance; then we loop over ➌ each argument passed to the program and try to scan
    the file and print the results to the screen for the user. In our case, we will
    only test against one file, the EICAR test file. However, you could put as many
    files to scan as your command shell allows.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将127.0.0.1作为连接主机和3310作为主机端口来创建ClamdSession() ➊。然后我们将新的ClamdSession传递给ClamdManager构造函数。使用新的ClamdManager()，我们可以打印clamd实例的版本➋；然后我们遍历➌传递给程序的每个参数，尝试扫描文件并将结果打印到屏幕上供用户查看。在我们的例子中，我们只会测试一个文件——EICAR测试文件。然而，你可以根据命令行的允许，将任意多个文件添加到扫描队列中。
- en: The file we will scan needs to be on the server running the clamd daemon, so
    in order make this work across the network, you need a way to send the file to
    the server in a place clamd can read it. This could be a remote network share
    or other way of getting the file to the server. In this example, we have clamd
    listening on 127.0.0.1 (localhost), and it has scanning access to my home directory
    on my Mac, which is demonstrated in [Listing 10-19](#filepos757812).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扫描的文件需要位于运行clamd守护进程的服务器上，因此，为了在网络中工作，你需要一种方法将文件发送到服务器上的clamd可以读取的地方。这可以是一个远程网络共享或其他将文件传送到服务器的方式。在这个例子中，我们让clamd监听127.0.0.1（本地地址），并且它可以扫描我在Mac上的主目录，这一点在[清单
    10-19](#filepos757812)中得到了展示。
- en: $ ./ch10_automating_clamav_clamd.exe ~/eicar.com.txt
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./ch10_automating_clamav_clamd.exe ~/eicar.com.txt
- en: ClamAV 0.99/20563/Thu Jun 11 15:05:30 2015
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ClamAV 0.99/20563/Thu Jun 11 15:05:30 2015
- en: '/Users/bperry/eicar.com.txt: Eicar-Test-Signature FOUND'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '/Users/bperry/eicar.com.txt: 找到Eicar-Test-Signature'
- en: 'Listing 10-19: The  clamd  automating program scanning the hard-coded EICAR
    file'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-19：自动化clamd程序扫描硬编码的EICAR文件
- en: You’ll notice that using clamd is much faster than using the libclamav automation.
    This is because a bulk of the time spent in the libclamav program was dedicated
    to allocating and compiling the engine, rather than actually scanning our file.
    The clamd daemon only has to allocate the engine once at startup; therefore, when
    we submit our file to be scanned, the results are much, much faster. We can test
    this by running the applications with the time command, which will print the time
    it takes for the programs to run, as shown in [Listing 10-20](#filepos759534).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，使用clamd要比使用libclamav自动化快得多。这是因为libclamav程序花费的时间大部分用于分配和编译引擎，而不是实际扫描我们的文件。而clamd守护进程只需在启动时分配引擎一次；因此，当我们提交文件进行扫描时，结果会更快。我们可以通过运行带有time命令的应用程序来测试这一点，该命令会打印程序运行所需的时间，如[清单
    10-20](#filepos759534)所示。
- en: $ time ./ch10_automating_clamav_fs.exe ~/eicar.com.txt
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ time ./ch10_automating_clamav_fs.exe ~/eicar.com.txt
- en: 'Found: Eicar-Test-Signature'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 找到：Eicar-Test-Signature
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: real ➊0m11.872s
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际时间 ➊0m11.872s
- en: user 0m11.508s
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户 0m11.508s
- en: sys 0m0.254s
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 系统 0m0.254s
- en: $ time ./ch10_automating_clamav_clamd.exe ~/eicar.com.txt
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ time ./ch10_automating_clamav_clamd.exe ~/eicar.com.txt
- en: ClamAV 0.99/20563/Thu Jun 11 15:05:30 2015
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ClamAV 0.99/20563/Thu Jun 11 15:05:30 2015
- en: '/Users/bperry/eicar.com.txt: Eicar-Test-Signature FOUND'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '/Users/bperry/eicar.com.txt: 找到Eicar-Test-Signature'
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: real ➋0m0.111s
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际时间 ➋0m0.111s
- en: user 0m0.087s
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户 0m0.087s
- en: 'sys 0m0.011s Listing 10-20: A comparison of the time it took for the ClamAV
    and  clamd  applications to scan the same file'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 系统 0m0.011s 清单 10-20：ClamAV和clamd应用程序扫描同一文件所需时间的比较
- en: Notice that our first program took 11 seconds ➊ to scan the EICAR test file
    but the second program using clamd took less than a second ➋.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的第一个程序扫描EICAR测试文件花费了11秒钟➊，而第二个使用clamd的程序则只用了不到一秒钟➋。
- en: Conclusion
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: ClamAV is a powerful and flexible antivirus solution for home and office use.
    In this chapter, we were able to drive ClamAV in two distinct ways.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ClamAV是一个功能强大且灵活的杀毒解决方案，适用于家庭和办公使用。在本章中，我们成功地以两种不同的方式使用了ClamAV。
- en: First, we implemented some small bindings for the native libclamav library.
    This allowed us to allocate, scan with, and free our ClamAV engines at will, but
    at the cost of needing to ship a copy of libclamav and allocate an expensive engine
    each time we ran our program. We then implemented two classes that allowed us
    to drive a remote clamd instance to retrieve ClamAV version information and to
    scan a given file path on the clamd server. This effectively gave our program
    a nice speed boost, but at the cost of requiring that the file to be scanned be
    on the server running clamd.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为原生 libclamav 库实现了一些小型绑定。这让我们可以根据需要分配、扫描并释放 ClamAV 引擎，但代价是每次运行程序时都需要附带一份
    libclamav 副本并分配一个昂贵的引擎。接着，我们实现了两个类，允许我们驱动远程 clamd 实例来获取 ClamAV 版本信息，并扫描 clamd
    服务器上的指定文件路径。这有效地为我们的程序提供了显著的速度提升，但代价是要求待扫描的文件必须位于运行 clamd 的服务器上。
- en: The ClamAV project is a great example of a large company (Cisco) really supporting
    open source software that benefits everyone. You’ll find that extending these
    bindings to better protect and defend your applications, users, and network is
    a great exercise.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ClamAV 项目是一个很好的例子，展示了大公司（思科）如何真正支持开源软件，造福每个人。你会发现，扩展这些绑定来更好地保护和防御你的应用程序、用户和网络，是一个非常好的练习。
