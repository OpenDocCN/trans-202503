- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: A Brief Survey of the Linux Desktop and Printing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Linux桌面与打印的简要概述
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter is a quick introduction to the components found in a typical Linux
    desktop system. Of all of the different kinds of software on Linux systems, the
    desktop arena is one of the wildest and most colorful, because there are so many
    environments and applications from which to choose, and most distributions make
    it relatively easy for you to try them out.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了典型Linux桌面系统中的组件。在所有Linux系统上的不同类型的软件中，桌面领域是最为多样和丰富多彩的，因为有这么多环境和应用程序可以选择，而且大多数发行版都使你可以相对容易地尝试它们。
- en: Unlike other parts of a Linux system, such as storage and networking, creating
    a desktop structure doesn’t involve an extensive hierarchy of layers. Instead,
    each component performs a specific task, communicating with other components as
    necessary. Some components do share common building blocks (in particular, libraries
    for graphical toolkits), and you can think of those as simple abstraction layers,
    but that’s about as deep as it goes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与Linux系统的其他部分（如存储和网络）不同，创建桌面结构并不涉及一个复杂的层次结构。相反，每个组件执行特定的任务，并根据需要与其他组件进行通信。有些组件确实共享一些共同的构建块（特别是图形工具包的库），你可以将它们视为简单的抽象层，但这也就是它的深度了。
- en: 'This chapter offers a high-level discussion of desktop components in general,
    but we’ll look at two pieces in a little more detail: the core infrastructure
    behind most desktops, and *D-Bus*, an interprocess communication service used
    in many parts of the system. We’ll limit the hands-on discussion and examples
    to a few diagnostic utilities that, although not terribly useful day to day (most
    GUIs don’t require you to enter shell commands in order to interact with them),
    will help you understand the underlying mechanics of the system and perhaps provide
    some entertainment along the way. We’ll also take a quick look at printing, as
    desktop workstations often share a common printer.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了对桌面组件的一般讨论，但我们将更详细地探讨其中的两个部分：大多数桌面背后的核心基础设施，以及*D-Bus*，一个在系统许多部分使用的进程间通信服务。我们将把实践讨论和示例限制在一些诊断工具上，尽管这些工具在日常使用中并不特别有用（大多数图形用户界面不需要你输入命令行指令来与之交互），但它们将帮助你理解系统的底层机制，并可能在过程中带来一些娱乐。我们还将简要介绍打印功能，因为桌面工作站通常共享一台公共打印机。
- en: 14.1 Desktop Components
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 桌面组件
- en: Linux desktop configurations offer a great deal of flexibility. Most of what
    the Linux user experiences (the “look and feel” of the desktop) comes from applications
    or building blocks of applications. If you don’t like a particular application,
    you can usually find an alternative. And if what you’re looking for doesn’t exist,
    you can write it yourself. Linux developers tend to have a wide variety of preferences
    for how a desktop should act, which makes for a lot of choices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Linux桌面配置提供了极大的灵活性。Linux用户所体验的大部分内容（桌面的“外观和感觉”）来自于应用程序或应用程序的构建块。如果你不喜欢某个特定的应用程序，通常可以找到替代品。如果你想要的东西不存在，你可以自己编写。Linux开发者对桌面应如何表现有各种各样的偏好，这也带来了大量的选择。
- en: In order to work together, all applications need to have something in common.
    At the time of this writing, the core of the Linux desktop is in a transitional
    state. From the beginning until recently, Linux desktops used X (*X Window System*,
    also known as *Xorg*, after its maintaining organization). However, this is now
    changing; many distributions have transitioned to a software set based on the
    *Wayland* protocol to build a windowing system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使得应用程序能够协同工作，所有应用程序需要有一些共同点。在本文写作时，Linux桌面的核心正处于过渡状态。从一开始到最近，Linux桌面使用的是X（*X
    Window System*，也称为*Xorg*，源于其维护组织）。然而，这种情况现在正在发生变化；许多发行版已过渡到基于*Wayland*协议的软件集来构建窗口系统。
- en: To understand what’s driving this change in the underlying technology, let’s
    take a step back and look at a few graphics basics.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解是什么驱动了基础技术的变化，让我们退后一步，回顾一下图形学的一些基础。
- en: 14.1.1  Framebuffers
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1  帧缓冲
- en: At the bottom of any graphical display mechanism is the *framebuffer*, a chunk
    of memory that the graphics hardware reads and transmits to the screen for display.
    A few individual bytes in the framebuffer represent each pixel of the display,
    so the idea is that if you want to change the way something looks, you need to
    write new values to the framebuffer memory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有图形显示机制的底层是*帧缓存*，这是一个内存块，图形硬件读取并传输到屏幕上进行显示。帧缓存中的几个字节代表显示器的每个像素，因此，如果你想改变某个事物的显示效果，就需要将新值写入帧缓存内存。
- en: One problem that a windowing system must solve is how to manage writing to the
    framebuffer. On any contemporary system, windows (or sets of windows) belong to
    individual processes, doing all of their graphics updates independently. So if
    the user is allowed to move windows around and overlap some on top of others,
    how does an application know where to draw its graphics, and how do you make sure
    that one application isn’t allowed to overwrite the graphics of other windows?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口系统必须解决的一个问题是如何管理对帧缓存的写入。在任何现代系统中，窗口（或窗口集）属于各自的进程，并独立进行所有图形更新。因此，如果用户被允许移动窗口并让它们部分重叠，应用程序如何知道在哪里绘制图形，如何确保一个应用程序不会覆盖其他窗口的图形？
- en: 14.1.2  The X Window System
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2  X窗口系统
- en: The approach that the X Window System takes is to have a server (called the
    *X server*) that acts as a sort of “kernel” of the desktop to manage everything
    from rendering windows to configuring displays to handling input from devices,
    such as keyboards and mice. The X server doesn’t dictate the way anything should
    act or appear. Instead, X *client* programs handle the user interface. Basic X
    client applications, such as terminal windows and web browsers, make connections
    to the X server and ask to draw windows. In response, the X server figures out
    where to place the windows and where to render client graphics, and it takes a
    certain amount of responsibility for rendering graphics to the framebuffer. The
    X server also channels input to a client when appropriate.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: X窗口系统采用的方法是拥有一个服务器（称为*X服务器*），它充当桌面的“内核”，管理从渲染窗口到配置显示屏、处理来自设备（如键盘和鼠标）的输入等所有事务。X服务器并不规定任何事物应该如何操作或显示。相反，X
    *客户端*程序负责处理用户界面。基本的X客户端应用程序，如终端窗口和网页浏览器，会与X服务器建立连接，并请求绘制窗口。作为回应，X服务器确定窗口放置的位置以及在哪里渲染客户端图形，并承担一定的责任来渲染图形到帧缓存。X服务器还会在适当的时候将输入传递给客户端。
- en: Because it acts as an intermediary for everything, the X server can be a significant
    bottleneck. In addition, it includes a lot of functionality that’s no longer used,
    and it’s also quite old, dating back to the 1980s. Somehow, it has been flexible
    enough to accommodate many new features that have extended its lifespan. We’ll
    describe the basics of how to interact with the X Window System later in this
    chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于X服务器充当所有事务的中介，它可能成为一个重要的瓶颈。此外，它包含许多已经不再使用的功能，而且它的历史相当悠久，最早可追溯到1980年代。尽管如此，它的灵活性足以容纳许多扩展功能，延长了它的生命周期。我们将在本章稍后介绍如何与X窗口系统交互的基本方法。
- en: 14.1.3  Wayland
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3  Wayland
- en: Unlike X, Wayland is significantly decentralized by design. There’s no large
    display server managing the framebuffer for a number of graphical clients, and
    there’s no centralized authority for rendering graphics. Instead, each client
    gets its own memory buffer (think of this as sort of a sub-framebuffer) for its
    own window, and a piece of software called a *compositor* combines all of the
    clients’ buffers into the necessary form for copying to the screen’s framebuffer.
    Because there is normally hardware support for this task, the compositor can be
    quite efficient.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与X不同，Wayland在设计上显著去中心化。没有一个大型显示服务器为多个图形客户端管理帧缓存，也没有集中式的图形渲染权威。相反，每个客户端都有自己的内存缓冲区（可以将其视为一种子帧缓存）用于自己的窗口，并且有一款名为*合成器*的软件，将所有客户端的缓冲区合并成必要的形式，再将其复制到屏幕的帧缓存中。由于通常有硬件支持这个任务，合成器的效率可以相当高。
- en: In some ways, the graphics model in Wayland isn’t too different from the practice
    that most X clients have been performing for years. Instead of getting any assistance
    from the X server, most clients render all of their own data as a bitmap and then
    send the bitmap to the X server. To acknowledge this somewhat, X has a compositing
    extension that has been in use for several years now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，Wayland中的图形模型与大多数X客户端多年来一直执行的实践并没有太大不同。大多数客户端并没有从X服务器获得任何帮助，而是将它们自己的数据作为位图进行渲染，然后将该位图发送到X服务器。为了承认这一点，X拥有一个合成扩展，该扩展已经使用了好几年。
- en: For the task of channeling input to the correct application, most Wayland setups
    and many X servers use a library called *libinput* to standardize events to clients.
    This library is not required by the Wayland protocol, but on desktop systems,
    it’s nearly universal. We’ll discuss libinput in Section 14.3.2.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在将输入通道传递到正确的应用程序任务中，大多数Wayland设置和许多X服务器使用一个名为*libinput*的库来将事件标准化到客户端。这个库并不是Wayland协议所要求的，但在桌面系统上，它几乎是通用的。我们将在14.3.2节中讨论libinput。
- en: 14.1.4  Window Managers
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4  窗口管理器
- en: A major difference between X and Wayland systems is in the *window manager*,
    the piece of software that determines how to arrange windows on the screen and
    is central to the user experience. In X, the window manager is a client that acts
    as a helper to the server; it draws the windows’ decorations (such as title bars
    and close buttons), handles input events to those decorations, and tells the server
    where to move windows.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: X和Wayland系统之间的一个主要区别在于*窗口管理器*，即决定如何安排屏幕上窗口的那部分软件，它对用户体验至关重要。在X中，窗口管理器是一个客户端，作为服务器的辅助程序；它绘制窗口的装饰（如标题栏和关闭按钮），处理输入事件并告诉服务器移动窗口的位置。
- en: However, in Wayland, the window manager *is* the server, more or less. It is
    responsible for compositing all of the client window buffers into the display
    framebuffer, and it handles the channeling of input device events. As a result,
    it is required to do more work than a window manager in X, but much of that code
    can be common between window manager implementations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Wayland中，窗口管理器*实际上*就是服务器。它负责将所有客户端窗口缓冲区合成到显示帧缓冲区中，并处理输入设备事件的传递。因此，它需要做的工作比X中的窗口管理器要多，但其中许多代码在不同窗口管理器实现之间是可以共享的。
- en: Many window manager implementations exist in both systems, but X has far more
    by virtue of its longevity. However, most of the popular window managers, such
    as Mutter (in GNOME) and Kwin (from KDE) have also been extended to include Wayland
    compositing support. Regardless of the underlying technology, it’s not likely
    that there will ever be a standard Linux window manager; because user tastes and
    requirements are diverse and constantly changing, new window managers appear all
    the time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 两个系统中都有许多窗口管理器实现，但X由于其长久的存在，拥有更多窗口管理器。然而，许多流行的窗口管理器，如Mutter（在GNOME中）和Kwin（来自KDE）也已扩展以支持Wayland合成。不管底层技术如何，似乎永远不会有一个标准的Linux窗口管理器；因为用户的口味和需求多种多样且不断变化，新窗口管理器不断涌现。
- en: 14.1.5  Toolkits
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.5  工具包
- en: Desktop applications include certain common elements, such as buttons and menus,
    called *widgets*. To speed up development and provide a common look, programmers
    use graphical *toolkits* to provide those elements. On operating systems like
    Windows or macOS, the vendor provides a common toolkit, and most programmers use
    that. On Linux, the GTK+ toolkit is one of the most common, but you’ll also frequently
    see widgets built on the Qt framework and others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序包括某些常见元素，如按钮和菜单，称为*小部件*。为了加速开发并提供统一的外观，程序员使用图形*工具包*来提供这些元素。在Windows或macOS等操作系统中，供应商提供了一个通用的工具包，大多数程序员都会使用它。在Linux上，GTK+工具包是最常见的之一，但你也会经常看到基于Qt框架和其他工具包构建的小部件。
- en: Toolkits usually consist of shared libraries and support files, such as images
    and theme information.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 工具包通常由共享库和支持文件组成，如图像和主题信息。
- en: 14.1.6  Desktop Environments
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.6  桌面环境
- en: Although toolkits provide the user with a uniform outward appearance, some details
    of a desktop require a degree of cooperation between different applications. For
    example, one application may wish to share data with another or update a common
    notification bar on a desktop. To provide for those needs, toolkits and other
    libraries are bundled into larger packages called *desktop environments*. GNOME,
    KDE, and Xfce are some common Linux desktop environments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管工具包为用户提供了统一的外观，但桌面的一些细节仍需要不同应用之间的协作。例如，一个应用可能希望与另一个应用共享数据，或者更新桌面上的公共通知栏。为了满足这些需求，工具包和其他库被打包成更大的软件包，称为*桌面环境*。GNOME、KDE和Xfce是一些常见的Linux桌面环境。
- en: Toolkits are at the core of most desktop environments, but to create a unified
    desktop, environments must also include numerous support files, such as icons
    and configurations, that make up themes. All of this is bound together with documents
    that describe design conventions, such as how application menus and titles should
    appear and how applications should react to certain system events.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 工具包是大多数桌面环境的核心，但要创建一个统一的桌面，环境还必须包括许多支持文件，例如图标和配置文件，这些文件构成了主题。所有这些都通过描述设计规范的文档结合在一起，比如应用程序菜单和标题应如何显示，以及应用程序应如何响应某些系统事件。
- en: 14.1.7  Applications
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.7 应用程序
- en: At the top of the desktop are applications, such as web browsers and the terminal
    window. X applications can range from crude (such as the ancient `xclock` program)
    to complex (such as the Chrome web browser and LibreOffice suite). These applications
    normally stand alone, but they often use interprocess communication to become
    aware of pertinent events. For example, an application can express interest when
    you attach a new storage device or when you receive new email or an instant message.
    This communication usually occurs over D-Bus, described in Section 14.5.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面顶部是一些应用程序，例如网页浏览器和终端窗口。X应用程序的范围可以从简单的（例如古老的`xclock`程序）到复杂的（例如Chrome浏览器和LibreOffice套件）。这些应用通常是独立运行的，但它们通常会使用进程间通信来察觉相关事件。例如，当你插入一个新的存储设备或收到新的电子邮件或即时消息时，应用程序可以表达兴趣。这种通信通常通过D-Bus进行，具体描述见第14.5节。
- en: 14.2 Are You Running Wayland or X?
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 你正在运行Wayland还是X？
- en: As we start with our hands-on discussion, you need to determine which graphical
    system you have. Just open a shell and check the value of the `$WAYLAND_DISPLAY`
    environment variable. If the value is something like `wayland-0`, you’re running
    Wayland. If it’s not set, you’re running X (probably; there are exceptions, but
    you’re not likely to come across them with this test).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始我们的实践讨论之前，你需要确定你拥有的是哪种图形系统。只需打开一个shell并检查`$WAYLAND_DISPLAY`环境变量的值。如果值是类似`wayland-0`的东西，那说明你正在运行Wayland。如果该变量没有设置，那你可能在运行X（大概率是这样；虽然也有例外，但通过这个测试你不太可能遇到）。
- en: These two systems are not mutually exclusive. If your system uses Wayland, it
    is also probably running an X compatibility server. It’s also possible to start
    a Wayland compositor inside X, but that can get a little strange (more on this
    later).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个系统并不是互相排斥的。如果你的系统使用Wayland，它也很可能在运行一个X兼容服务器。也可以在X内启动Wayland合成器，但那可能会有点奇怪（稍后会详细介绍）。
- en: 14.3 A Closer Look at Wayland
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 更深入了解Wayland
- en: We’ll start with Wayland because it’s the emerging standard, currently used
    by default on many distributions. Unfortunately, in part due to its design and
    young age, there aren’t as many tools for prodding into Wayland as there are for
    X. We’ll do what we can.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Wayland开始，因为它是新兴标准，目前在许多发行版中默认使用。不幸的是，由于其设计和年轻的历史，关于Wayland的工具不像X那样丰富。我们会尽力而为。
- en: But first, let’s talk about what Wayland *is* and *isn’t*. The name *Wayland*
    refers to a communications protocol between a compositing window manager and graphical
    client program. If you go looking for a big Wayland core package, you won’t find
    one, but you will find the Wayland library that most clients use to speak to the
    protocol (at least for now).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们来谈谈Wayland*是什么*以及*不是*。*Wayland*这个名称指的是合成窗口管理器与图形客户端程序之间的通信协议。如果你去寻找一个大的Wayland核心包，你是找不到的，但你会找到大多数客户端用来与该协议进行通信的Wayland库（至少目前是这样）。
- en: There’s also a reference compositing window manager called Weston and a few
    associated clients and utilities. What *reference* means here is that Weston contains
    the necessary functionality of a compositor, but it’s not meant for use by the
    general public because it has a bare-bones interface. The idea is that developers
    of compositing window managers can look at the Weston source code to see how to
    implement critical functions correctly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个参考性的合成窗口管理器，叫做 Weston，以及一些相关的客户端和工具。这里的 *参考* 意思是 Weston 包含了合成器所需的基本功能，但它不适合普通用户使用，因为它的界面非常简陋。这个设计的目的是让合成窗口管理器的开发者可以查看
    Weston 的源代码，了解如何正确实现关键功能。
- en: 14.3.1  The Compositing Window Manager
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1  合成窗口管理器
- en: 'Odd as it might sound, you might not know which Wayland compositing window
    manager you’re actually running. You might be able to find the name from an information
    option in the interface, but there’s no set place to look. However, you can nearly
    always find the running compositor process by tracking down the Unix domain socket
    that it uses to communicate with clients. The socket is the display name in the
    `WAYLAND_DISPLAY` environment variable, which is usually `wayland-0` and typically
    found in */run/user/<uid>*, where *<uid>* is your user ID (if not, check the `$XDG_RUNTIME_DIR`
    environment variable). Running as root, you can find the process listening on
    this socket with the `ss` command, but the output will look a little crazy:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来有些奇怪，但你可能并不知道自己实际运行的是哪个 Wayland 合成窗口管理器。你也许能通过界面中的信息选项找到它的名称，但没有固定的位置可以查看。然而，你几乎总是可以通过追踪它与客户端通信所使用的
    Unix 域套接字来找到正在运行的合成器进程。这个套接字就是 `WAYLAND_DISPLAY` 环境变量中的显示名称，通常是 `wayland-0`，并且通常可以在
    */run/user/<uid>* 路径下找到，其中 *<uid>* 是你的用户 ID（如果没有，检查 `$XDG_RUNTIME_DIR` 环境变量）。以
    root 用户身份运行时，你可以通过 `ss` 命令找到监听此套接字的进程，但输出可能看起来有些混乱：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, you just need to pick through it; you can see here that the compositor
    process is `gnome-shell`, PID 1522\. Unfortunately, yet another layer of indirection
    is going on here; the GNOME shell is a plug-in of Mutter, which is the compositing
    window manager used in the GNOME desktop environment. (Here, calling the GNOME
    shell a plug-in is just a fancy way of saying that it calls Mutter as a library.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你只需要筛选一下；你可以看到，这里合成器进程是`gnome-shell`，PID 1522。遗憾的是，这里又有一层间接性；GNOME shell
    是 Mutter 的插件，而 Mutter 是 GNOME 桌面环境中使用的合成窗口管理器。（在这里，称 GNOME shell 为插件只是意味着它将 Mutter
    作为库来调用。）
- en: In the context of a Wayland compositor, you can think of the *display* as the
    viewable space, represented by the framebuffer. A display can span more than one
    monitor if more than one is connected to a computer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Wayland 合成器的上下文中，你可以将 *显示* 理解为可视区域，由帧缓冲区表示。一个显示可以跨多个显示器，如果计算机连接了多个显示器的话。
- en: Although it’s rare, you can run more than one compositor at once. One way to
    do this is to run compositors on separate virtual terminals. In this case, the
    first compositor would normally have the display name set to `wayland-0`, the
    second `wayland-1`, and so on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然比较罕见，但你可以同时运行多个合成器。实现这一点的一种方式是将合成器分别运行在不同的虚拟终端上。在这种情况下，第一个合成器通常会将显示名称设置为 `wayland-0`，第二个为
    `wayland-1`，依此类推。
- en: You can gain a bit of insight into your compositor with the `weston-info` command,
    which shows a few characteristics of the interfaces that the compositor has available.
    However, you shouldn’t expect very much beyond information on your display and
    some input devices.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `weston-info` 命令来获得一些关于合成器的见解，该命令显示合成器可用的接口的一些特性。不过，你不应期望看到太多，除了显示和一些输入设备的信息。
- en: 14.3.2  libinput
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2  libinput
- en: In order to get the input from devices, such as a keyboard, from the kernel
    to clients, a Wayland compositor needs to collect that input and direct it to
    an appropriate client in a standardized form. The libinput library includes the
    support necessary to collect the input from the various */dev/input* kernel devices
    and massage them. In Wayland, the compositor doesn’t usually just pass an input
    event as is; it translates the event into the Wayland protocol before sending
    to a client.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将来自设备（如键盘）的输入从内核传递到客户端，Wayland 合成器需要收集这些输入并以标准化的形式将其传递给适当的客户端。libinput 库提供了必要的支持，能够从各种
    */dev/input* 内核设备中收集输入并进行处理。在 Wayland 中，合成器通常不会直接将输入事件原样传递；它会将事件翻译成 Wayland 协议后再发送给客户端。
- en: Normally, something like libinput wouldn’t be terribly interesting to talk about,
    but it comes with a small utility, also called `libinput`, that allows you to
    inspect input devices and events as they are presented by the kernel.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像 libinput 这样的工具不会特别引人注目，但它带有一个小工具，也叫 `libinput`，允许你检查由内核呈现的输入设备和事件。
- en: 'Try the following to look at the available input devices (you’ll probably get
    a lot of output, so be prepared to page through it):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下方法查看可用的输入设备（你可能会得到很多输出，因此要准备好翻页查看）：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this partial view, you can see the type of device (keyboard) and where the
    kernel `evdev` device is (*/dev/input/event3*). That device shows up when you
    listen for events like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个局部视图中，你可以看到设备的类型（键盘）以及内核 `evdev` 设备的位置（*/dev/input/event3*）。当你监听这些事件时，该设备会出现：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run this command, move the mouse pointer around and press some keys.
    You’ll get some output describing these events.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此命令时，移动鼠标指针并按下某些键。你将获得一些描述这些事件的输出。
- en: Remember that the libinput library is just a system for capturing kernel events.
    As such, it is used not only under Wayland, but also under the X Window System.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，libinput 库只是一个用于捕捉内核事件的系统。因此，它不仅在 Wayland 下使用，也在 X 窗口系统下使用。
- en: 14.3.3  X Compatibility in Wayland
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3  Wayland 中的 X 兼容性
- en: Before discussing the X Window System in general, let’s first explore its compatibility
    with Wayland. There are countless applications for X, and any effort to move from
    it to Wayland would be greatly hindered by a lack of X support. There are two
    simultaneous approaches to bridge the gap.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 X 窗口系统之前，让我们先探索它与 Wayland 的兼容性。X 有无数的应用程序，任何从 X 迁移到 Wayland 的尝试都将因缺乏 X 支持而受到极大的阻碍。有两种同步的方法可以弥合这个差距。
- en: The first approach is to add Wayland support to the application, creating a
    native Wayland application. Most graphical applications that run on X already
    use toolkits such as the ones found in GNOME and KDE. Because the work of adding
    Wayland support to these toolkits has already been done, it’s not much of a stretch
    to make an X application into a native Wayland application. In addition to paying
    attention to support for window decorations and input device configuration, a
    developer need only deal with the rare stray X library dependencies in an application.
    For many major applications, this work is already complete.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是为应用程序添加 Wayland 支持，从而创建一个原生的 Wayland 应用程序。大多数在 X 上运行的图形应用程序已经使用了像 GNOME
    和 KDE 中的工具包。由于为这些工具包添加 Wayland 支持的工作已经完成，所以将一个 X 应用程序转变为原生的 Wayland 应用程序并不困难。除了关注窗口装饰和输入设备配置的支持外，开发者只需要处理应用程序中那些稀有的
    X 库依赖。对于许多主要的应用程序，这项工作已经完成。
- en: The alternative is to run an X application through a compatibility layer in
    Wayland. This is accomplished with an entire X server running as a Wayland client.
    Called `Xwayland`, this server is really just another layer jammed underneath
    X clients, run by default by most compositor startup sequences. The `Xwayland`
    server needs to translate input events and maintain its window buffers separately.
    Introducing another middleman like this always slows things down slightly, but
    it’s mostly inconsequential.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过 Wayland 中的兼容层运行 X 应用程序。这是通过作为 Wayland 客户端运行整个 X 服务器来实现的。这个服务器叫做 `Xwayland`，其实只是另一个被嵌入在
    X 客户端下的层，默认情况下由大多数合成器启动序列运行。`Xwayland` 服务器需要翻译输入事件，并单独维护其窗口缓冲区。引入像这样的中间人总会稍微减慢速度，但大多数情况下，这并没有什么实质性影响。
- en: Going in reverse doesn’t work as well. You can’t run Wayland clients on X in
    the same way (theoretically, it’s possible to write such a system, but there’s
    not much point). However, you can run a compositor inside an X window. For example,
    if you’re running X, you can just run `weston` on the command line to bring up
    a compositor. You can open a terminal window and any other Wayland app inside,
    and you can even run X clients inside the compositor if you’ve started `Xwayland`
    properly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 反向操作则不太奏效。你不能像在 X 上运行 Wayland 客户端那样运行它（理论上，写出这样的系统是可能的，但没有太大意义）。然而，你可以在 X 窗口内运行一个合成器。例如，如果你正在运行
    X，可以在命令行中运行 `weston` 来启动一个合成器。你可以在合成器内打开终端窗口和任何其他 Wayland 应用程序，甚至可以在正确启动了 `Xwayland`
    后，在合成器内运行 X 客户端。
- en: However, if you leave this compositor running and go back to your regular X
    session, you might find that certain utilities don’t work as you expected, and
    they might also show up in the compositor window when you expected them to show
    up as an X window. The reason for this is that many applications on systems such
    as GNOME and KDE are now built with both X and Wayland support. They will look
    for a Wayland compositor first, and by default, the code in `libwayland` that
    looks for a display defaults to `wayland-0` if the `WAYLAND_DISPLAY` environment
    variable isn’t set. An application that finds a working compositor will use it
    if it can.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你保持这个合成器运行并返回到你的常规 X 会话，你可能会发现某些工具无法按预期工作，甚至可能会出现在合成器窗口中，而你预期它们应该出现在 X
    窗口中。原因是许多 GNOME 和 KDE 等系统上的应用程序现在都同时支持 X 和 Wayland。它们首先会寻找一个 Wayland 合成器，如果`WAYLAND_DISPLAY`环境变量没有设置，`libwayland`中的代码默认会查找`wayland-0`。找到一个可用的合成器时，应用程序会使用它。
- en: The best way to avoid this is simply not to run a compositor inside X or at
    the same time as an X server.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况的最好方法是简单地不要在 X 内部或与 X 服务器同时运行合成器。
- en: 14.4 A Closer Look at the X Window System
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 更深入了解 X 窗口系统
- en: In contrast with Wayland-based systems, the X Window System ([http://www.x.org/](http://www.x.org/))
    has historically been very large, with the base distribution including the X server,
    client support libraries, and clients. Due to the emergence of desktop environments
    such as GNOME and KDE, the role of X has changed over time, with the focus now
    more on the core server that manages rendering and input devices, as well as a
    simplified client library.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于 Wayland 的系统相比，X 窗口系统（[http://www.x.org/](http://www.x.org/)）历来非常庞大，基本发行版包括
    X 服务器、客户端支持库和客户端。由于 GNOME 和 KDE 等桌面环境的出现，X 的角色随着时间的推移发生了变化，现在的重点更多放在管理渲染和输入设备的核心服务器上，并简化了客户端库。
- en: 'The X server is easy to identify on your system. It’s called `X` or `Xorg`.
    Check for it in a process listing; you’ll usually see it running with a number
    of options like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: X 服务器在你的系统上很容易识别。它被称为`X`或`Xorg`。查看进程列表，你通常会看到它运行时带有一些选项，像这样：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `:0` shown here is called the *X display*, an identifier representing one
    or more monitors that you access with a common keyboard and/or mouse. Usually,
    the display just corresponds to the single monitor attached to your computer,
    but you can put multiple monitors under the same display. For processes running
    under an X session, the `DISPLAY` environment variable is set to the display identifier.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的`:0`称为*X 显示器*，是一个标识符，代表你通过共同的键盘和/或鼠标访问的一个或多个显示器。通常，显示器对应于连接到计算机的单个显示器，但你也可以将多个显示器放置在同一个显示器下。对于在
    X 会话下运行的进程，`DISPLAY`环境变量会设置为显示器标识符。
- en: On Linux, an X server runs on a virtual terminal. In this example, the `vt7`
    argument shows that it’s been told to run on */dev/tty7* (normally, the server
    starts on the first virtual terminal available). You can run more than one X server
    at a time on Linux by running them on separate virtual terminals, with each server
    having a unique display identifier. You can switch between the servers with the
    ctrl-alt-fn keys or the `chvt` command.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，X 服务器运行在虚拟终端上。在这个例子中，`vt7`参数表明它被指示在*/dev/tty7*上运行（通常，服务器会在第一个可用的虚拟终端上启动）。你可以通过在不同的虚拟终端上运行多个
    X 服务器来同时运行多个 X 服务器，每个服务器都有一个唯一的显示标识符。你可以通过按 ctrl-alt-fn 键或使用`chvt`命令在服务器之间切换。
- en: 14.4.1  Display Managers
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.1  显示管理器
- en: You normally wouldn’t start the X server on the command line, because starting
    the server doesn’t define any clients that are supposed to run on it. If you start
    the server by itself, you’ll just get a blank screen. Instead, the most common
    way to start an X server is with a *display manager*, a program that starts the
    server and puts a login box on the screen. When you log in, the display manager
    starts a set of clients, such as a window manager and file manager, so that you
    can start to use the machine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你不会在命令行上启动 X 服务器，因为启动服务器并不会定义任何应该在其上运行的客户端。如果你单独启动服务器，你只会看到一个空白屏幕。相反，启动 X
    服务器最常见的方法是使用*显示管理器*，这是一种启动服务器并在屏幕上显示登录框的程序。当你登录时，显示管理器会启动一组客户端程序，比如窗口管理器和文件管理器，这样你就可以开始使用机器了。
- en: Many different display managers are available, such as `gdm` (for GNOME) and
    `kdm` (for KDE). The `lightdm` in the argument list for the preceding X server
    invocation is a cross-platform display manager meant to be able to start GNOME
    or KDE sessions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的显示管理器可用，如`gdm`（用于 GNOME）和`kdm`（用于 KDE）。在前述 X 服务器调用的参数列表中的`lightdm`是一个跨平台的显示管理器，旨在能够启动
    GNOME 或 KDE 会话。
- en: If you insist on starting an X session from a virtual console instead of using
    a display manager, you can run the `startx` or `xinit` command. However, the session
    you get will likely be a very simple one that looks completely unlike that of
    a display manager, because the mechanics and startup files are different.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你坚持从虚拟控制台启动 X 会话，而不是使用显示管理器，可以运行`startx`或`xinit`命令。然而，得到的会话可能非常简单，看起来完全不像显示管理器的界面，因为其机制和启动文件不同。
- en: 14.4.2  Network Transparency
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.2  网络透明性
- en: One feature of X is network transparency. Because clients talk to the server
    using a protocol, it’s possible to run clients across a network to a server running
    on a different machine directly over the network, with the X server listening
    for TCP connections on port 6000\. Clients connecting to that port could authenticate
    and then send windows to the server.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: X 的一个特点是网络透明性。由于客户端通过协议与服务器通信，可以在网络上跨不同机器直接运行客户端，X 服务器监听 TCP 端口 6000 上的连接。连接到该端口的客户端可以进行身份验证，并将窗口发送到服务器。
- en: Unfortunately, this method doesn’t normally offer any encryption and is insecure
    as a result. To close this hole, most distributions now disable the X server’s
    network listener (with the `-nolisten tcp` option to the server). However, you
    can still run X clients from a remote machine with SSH tunneling, as described
    in Chapter 10, by connecting the X server’s Unix domain socket to a socket on
    the remote machine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法通常不提供加密，因此存在安全隐患。为了弥补这一漏洞，大多数发行版现在会禁用 X 服务器的网络监听（通过向服务器添加`-nolisten
    tcp`选项）。然而，你仍然可以通过 SSH 隧道从远程机器运行 X 客户端，正如第 10 章所描述的那样，将 X 服务器的 Unix 域套接字连接到远程机器上的套接字。
- en: 14.4.3 Ways of Exploring X Clients
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.3 探索 X 客户端的方式
- en: Although one doesn’t normally think of working with a graphical user interface
    from the command line, several utilities allow you to explore the parts of the
    X Window System. In particular, you can inspect clients as they run.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常不会想到从命令行操作图形用户界面，但有几个工具可以让你探索 X 窗口系统的各个部分。特别是，你可以检查正在运行的客户端。
- en: 'One of the simplest tools is `xwininfo`. When run without any arguments, it
    asks you to click on a window:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的工具之一是`xwininfo`。当没有任何参数运行时，它会提示你点击一个窗口：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After you click, it prints a list of information about the window, such as
    its location and size:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 点击后，它会打印有关窗口的信息列表，如其位置和大小：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the window ID here. The X server and window managers use this identifier
    to keep track of windows. To get a list of all window IDs and clients, use the
    `xlsclients -l` command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的窗口 ID。X 服务器和窗口管理器使用这个标识符来跟踪窗口。要获取所有窗口 ID 和客户端的列表，可以使用`xlsclients -l`命令。
- en: 14.4.4  X Events
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.4  X 事件
- en: X clients get their input and other information about the state of the server
    through a system of events. X events work like other asynchronous interprocess
    communication events, such as udev events and D-Bus events. The X server receives
    information from a source, such as an input device, and then redistributes that
    input as an event to any interested X client.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: X 客户端通过事件系统获取输入和服务器状态的其他信息。X 事件像其他异步进程间通信事件一样工作，例如 udev 事件和 D-Bus 事件。X 服务器接收来自输入设备等来源的信息，然后将这些输入作为事件重新分发给任何感兴趣的
    X 客户端。
- en: 'You can experiment with events via the `xev` command. Running it opens a new
    window that you can mouse into, click, and type. As you do so, `xev` generates
    output describing the X events that it receives from the server. For example,
    here’s sample output for mouse movement:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`xev`命令来实验事件。运行它会打开一个新窗口，你可以将鼠标移动到窗口中，点击并输入。当你这么做时，`xev`会生成描述它从服务器接收到的
    X 事件的输出。例如，下面是鼠标移动的示例输出：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice the coordinates in parentheses. The first pair represents the x- and
    y-coordinates of the mouse pointer inside the window, and the second (`root:`)
    is the location of the pointer on the entire display.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意括号中的坐标。第一对坐标表示鼠标指针在窗口中的 x 和 y 坐标，第二对（`root:`）表示指针在整个显示器上的位置。
- en: Other low-level events include keypresses and button clicks, but more advanced
    ones indicate whether the mouse has entered or exited the window, or whether the
    window has gained or lost focus from the window manager. For example, here are
    corresponding exit and unfocus events.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其他低级事件包括按键和按钮点击，但更高级的事件则表示鼠标是否进入或退出窗口，或者窗口是否获得或失去来自窗口管理器的焦点。例如，下面是相应的退出和失去焦点事件。
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One common use of `xev` is to extract keycodes and key symbols for different
    keyboards when remapping the keyboard. Here’s the output from pressing the L key;
    the keycode here is 46:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`xev` 的一个常见用途是提取不同键盘的键码和按键符号，特别是在重新映射键盘时。以下是按下 L 键时的输出；这里的键码是 46：'
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can also attach `xev` to an existing window ID with the `-id` `id` option.
    Replace `id` with the ID you get from `xwininfo` (it will be a hexadecimal number
    starting with `0x`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 `xev` 附加到现有的窗口 ID 上，使用 `-id` `id` 选项。用从 `xwininfo` 获取的 ID 替换 `id`（它将是一个以
    `0x` 开头的十六进制数字）。
- en: 14.4.5  X Input and Preference Settings
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.5  X 输入和首选项设置
- en: One of the most potentially baffling characteristics of X is that there’s often
    more than one way to set preferences, and some methods may not work. For example,
    one common keyboard preference on Linux systems is to remap the caps lock key
    to a ctrl key. There are a number of ways to do this, from making small adjustments
    with the old `xmodmap` command to providing an entirely new keyboard map with
    the `setxkbmap` utility. How do you know which one (if any) to use? It’s a matter
    of knowing which pieces of the system have responsibility, but determining this
    can be difficult. Keep in mind that a desktop environment may provide its own
    settings and overrides. With this said, here are a few pointers on the underlying
    infrastructure.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: X 的一个潜在困惑特性是，设置首选项通常有多种方式，而且某些方法可能无法生效。例如，Linux 系统上一种常见的键盘设置是将 Caps Lock 键重新映射为
    Ctrl 键。实现此操作有多种方法，从使用旧的`xmodmap`命令进行小幅调整，到通过`setxkbmap`工具提供一个全新的键盘映射。你如何知道该使用哪一种（如果有的话）呢？这取决于了解系统中哪些部分负责处理，但要确定这一点可能会很困难。请记住，桌面环境可能会提供自己的设置并进行覆盖。话虽如此，以下是一些关于底层基础设施的提示。
- en: Input Devices (General)
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入设备（一般）
- en: The X server uses the *X Input Extension* to manage input from many different
    devices. There are two basic types of input device—keyboard and pointer (mouse)—and
    you can attach as many devices as you like. To handle more than one of the same
    type of device simultaneously, the X Input Extension creates a *virtual core*
    device that funnels device input to the X server.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: X 服务器使用 *X 输入扩展* 来管理来自多个设备的输入。有两种基本类型的输入设备——键盘和指针（鼠标）——你可以连接任意多的设备。为了同时处理多个相同类型的设备，X
    输入扩展创建了一个 *虚拟核心* 设备，将设备输入引导到 X 服务器。
- en: 'To see the device configuration on your machine, run the `xinput --list` command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你机器上的设备配置，可以运行 `xinput --list` 命令：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each device has an associated ID that you can use with `xinput` and other commands.
    In this output, IDs 2 and 3 are the core devices, and IDs 8 and 9 are the real
    devices. Notice that the power buttons on the machine are also treated as X input
    devices.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都有一个关联的 ID，你可以在 `xinput` 和其他命令中使用该 ID。在此输出中，ID 2 和 3 是核心设备，ID 8 和 9 是实际设备。注意，机器上的电源按钮也被视为
    X 输入设备。
- en: Most X clients listen for input from the core devices, because there’s no reason
    for them to be concerned about which particular device initiates an event. In
    fact, most clients know nothing about the X Input Extension. However, a client
    can use the extension to single out a particular device.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 X 客户端监听来自核心设备的输入，因为它们无需关心是哪个特定设备触发了事件。事实上，大多数客户端对 X 输入扩展一无所知。然而，客户端可以使用该扩展来单独指定某个设备。
- en: 'Each device has a set of associated *properties*. To view the properties, use
    `xinput` with the device number:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都有一组相关的 *属性*。要查看这些属性，可以使用带设备编号的 `xinput`：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can change a number of properties with the `--set-prop` option. See the
    xinput(1) manual page for more information.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `--set-prop` 选项更改多个属性。有关更多信息，请参阅 xinput(1) 手册页。
- en: Mouse
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 鼠标
- en: 'You can manipulate device-related settings with the `xinput` command, and many
    of the most useful options pertain to the mouse (pointer). You can change many
    settings directly as properties, but it’s usually easier with the specialized
    `--set-ptr-feedback` and `--set-button-map` options to `xinput`. For example,
    if you have a three-button mouse at `dev` on which you’d like to reverse the order
    of buttons (this is handy for left-handed users), try this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`xinput`命令操作与设备相关的设置，许多最有用的选项与鼠标（指针）相关。你可以直接将许多设置作为属性进行更改，但通常使用专门的`--set-ptr-feedback`和`--set-button-map`选项来操作`xinput`会更容易。例如，如果你有一个三按钮鼠标，位于`dev`上，并且你想要反转按钮的顺序（这对左撇子用户很有用），可以尝试这样做：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Keyboard
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 键盘
- en: The many different keyboard layouts available internationally present particular
    difficulties for integration into any windowing system. X has always had an internal
    keyboard-mapping capability in its core protocol that you can manipulate with
    the `xmodmap` command, but any halfway recent system uses XKB (the X keyboard
    extension) to gain finer control.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不同国家/地区提供的多种键盘布局在集成到任何窗口系统时会带来特别的困难。X一直在其核心协议中提供一个内部的键盘映射功能，你可以使用`xmodmap`命令进行操作，但任何较新的系统都会使用XKB（X键盘扩展）来获得更精细的控制。
- en: 'XKB is complicated, so much so that many people still use `xmodmap` when they
    need to make quick changes. The basic idea behind XKB is that you can define a
    keyboard map, compile it with the `xkbcomp` command, and then load and activate
    that map in the X server with the `setxkbmap` command. This system has two especially
    interesting features:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: XKB很复杂，以至于许多人在需要快速更改时仍然使用`xmodmap`。XKB的基本概念是，你可以定义一个键盘映射，用`xkbcomp`命令编译它，然后使用`setxkbmap`命令将该映射加载并激活到X服务器中。这个系统有两个特别有趣的特点：
- en: You can define partial maps to supplement existing maps. This is particularly
    handy for tasks such as changing your caps lock key into a ctrl key, and it is
    used by many graphical keyboard preference utilities in desktop environments.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以定义部分映射来补充现有的映射。这对于一些任务非常有用，例如将Caps Lock键改为Ctrl键，许多桌面环境中的图形键盘偏好设置工具都会用到它。
- en: You can define individual maps for each attached keyboard.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为每个附加的键盘定义单独的映射。
- en: Desktop Background
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 桌面背景
- en: The *root window* of your X server is the background of the display. The old
    X command `xsetroot` allows you to set the background color and other characteristics
    of the root window, but it has no effect on most machines because the root window
    is never visible. Instead, most desktop environments place a big window in the
    back of all of your other windows in order to enable features such as “active
    wallpaper” and desktop file browsing. There are ways to change the background
    from the command line (for example, with the `gsettings` command in some GNOME
    installations), but if you actually *want* to do this, you probably have too much
    time on your hands.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你的X服务器的*根窗口*是显示器的背景。旧的X命令`xsetroot`允许你设置根窗口的背景颜色和其他特性，但由于根窗口通常不可见，它在大多数机器上没有效果。相反，大多数桌面环境将一个大的窗口放置在所有其他窗口的后面，以启用诸如“动态壁纸”和桌面文件浏览等功能。有一些方法可以通过命令行更改背景（例如，在一些GNOME安装中使用`gsettings`命令），但如果你真的*想*这样做，你可能是有点闲暇时间。
- en: xset
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: xset
- en: Probably the oldest preference command is `xset`. It’s not used much anymore,
    but you can run a quick `xset q` to get the status of a few features. Perhaps
    the most useful are the screensaver and *Display Power Management Signaling (DPMS)*
    settings.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最古老的偏好命令是`xset`。虽然它现在用得不多，但你可以快速运行`xset q`来查看一些功能的状态。最有用的功能可能是屏幕保护程序和*显示电源管理信号（DPMS）*设置。
- en: 14.5 D-Bus
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5 D-Bus
- en: One of the most important developments to come out of the Linux desktop is the
    *Desktop Bus (D-Bus)*, a message-passing system. D-Bus is important because it
    serves as an interprocess communication mechanism that allows desktop applications
    to talk to each other, and because most Linux systems use it to notify processes
    of system events, such as inserting a USB drive.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux桌面中涌现出的最重要的进展之一是*桌面总线（D-Bus）*，一个消息传递系统。D-Bus之所以重要，是因为它作为一个进程间通信机制，允许桌面应用程序相互通信，并且因为大多数Linux系统都使用它来通知进程系统事件，比如插入USB驱动器。
- en: D-Bus itself consists of a library that standardizes interprocess communication
    with a protocol and supporting functions for any two processes to talk to each
    other. By itself, this library doesn’t offer much more than a fancy version of
    normal IPC facilities, such as Unix domain sockets. What makes D-Bus useful is
    a central “hub” called `dbus-daemon`. Processes that need to react to events can
    connect to `dbus-daemon` and register to receive certain kinds of events. Connecting
    processes also create the events. For example, the process `udisks-daemon` monitors
    udev for disk events and sends them to `dbus-daemon`, which then retransmits the
    events to applications interested in disk events.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus 本身由一个库组成，该库通过协议标准化了进程间通信，并提供支持功能，使任何两个进程能够互相通信。单独来看，这个库不过是普通 IPC（进程间通信）设施的一个高级版本，例如
    Unix 域套接字。D-Bus 的真正价值在于一个名为 `dbus-daemon` 的中心“枢纽”。需要响应事件的进程可以连接到 `dbus-daemon`
    并注册接收某些类型的事件。连接的进程也会生成这些事件。例如，进程 `udisks-daemon` 监控 udev 中的磁盘事件，并将它们发送给 `dbus-daemon`，然后后者会将事件转发给对磁盘事件感兴趣的应用程序。
- en: 14.5.1  System and Session Instances
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.1  系统与会话实例
- en: D-Bus has become an integral part of the Linux system, and it now reaches beyond
    the desktop. For example, both systemd and Upstart have D-Bus channels of communication.
    However, adding dependencies to desktop tools inside the core system goes against
    a design rule of Linux.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus 已成为 Linux 系统的核心部分，并且现在已超越桌面应用。例如，systemd 和 Upstart 都有 D-Bus 通信渠道。然而，将桌面工具的依赖添加到核心系统中违背了
    Linux 的设计原则。
- en: To address this problem, there are actually two kinds of `dbus-daemon` instances
    (processes) that can run. The first is the *system instance*, which is started
    by init at boot time with the `--system` option. The system instance usually runs
    as a D-Bus user, and its configuration file is */etc/dbus-1/system.conf* (though
    you probably shouldn’t change the configuration). Processes can connect to the
    system instance through the */var/run/dbus/system_bus_socket* Unix domain socket.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，实际上有两种 `dbus-daemon` 实例（进程）可以运行。第一种是 *系统实例*，它由 init 在启动时通过 `--system`
    选项启动。系统实例通常以 D-Bus 用户身份运行，其配置文件是 */etc/dbus-1/system.conf*（不过你可能不应该修改该配置）。进程可以通过
    */var/run/dbus/system_bus_socket* Unix 域套接字连接到系统实例。
- en: Independent of the system D-Bus instance is an optional *session instance* that
    runs only when you start a desktop session. Desktop applications that you run
    connect to this instance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 独立于系统 D-Bus 实例，还有一个可选的 *会话实例*，它只在你启动桌面会话时运行。你运行的桌面应用程序会连接到这个实例。
- en: 14.5.2  D-Bus Message Monitoring
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.2  D-Bus 消息监控
- en: 'One of the best ways to see the difference between system and session `dbus-daemon`
    instances is to monitor the events that go over the bus. Try using the `dbus-monitor`
    utility in system mode like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 查看系统和会话 `dbus-daemon` 实例之间差异的最好方法之一是监控总线上的事件。尝试在系统模式下使用 `dbus-monitor` 工具，如下所示：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The startup message here indicates that the monitor connected and acquired a
    name. You shouldn’t see much activity when you run it like this, because the system
    instance usually isn’t very busy. To see something happen, try plugging in a USB
    storage device.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 启动消息表明监视器已经连接并获得了一个名称。当你这样运行时，通常不会看到太多活动，因为系统实例通常不会很忙。为了看到一些活动，尝试插入一个 USB 存储设备。
- en: 'By comparison, session instances have much more to do. Assuming you’ve logged
    in to a desktop session, try this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，会话实例的工作要复杂得多。假设你已经登录到桌面会话，尝试以下操作：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now try using a desktop application, such as a file manager; if your desktop
    is D-Bus–aware, you should get a flurry of messages indicating various changes.
    Keep in mind that not all applications will produce messages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用桌面应用程序，例如文件管理器；如果你的桌面环境支持 D-Bus，你应该会看到一系列指示各种变化的消息。请记住，并非所有应用程序都会生成消息。
- en: 14.6 Printing
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.6 打印
- en: 'Printing a document on Linux is a multistage process:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上打印文档是一个多阶段过程：
- en: The program doing the printing usually converts the document into PostScript
    form. This step is optional.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行打印的程序通常会将文档转换为 PostScript 格式。这一步是可选的。
- en: The program sends the document to a print server.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序将文档发送给打印服务器。
- en: The print server receives the document and places it on a print queue.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印服务器接收文档并将其放入打印队列。
- en: When the document’s turn in the queue arrives, the print server sends the document
    to a print filter.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文档在队列中的顺序到来时，打印服务器将文档发送给打印过滤器。
- en: If the document is not in PostScript form, a print filter might perform a conversion.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文档不是 PostScript 格式，打印过滤器可能会进行转换。
- en: If the destination printer does not understand PostScript, a printer driver
    converts the document to a printer-compatible format.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目标打印机不理解PostScript，打印机驱动程序会将文档转换为与打印机兼容的格式。
- en: The printer driver adds optional instructions to the document, such as paper
    tray and duplexing options.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印机驱动程序会向文档添加可选指令，例如纸盘和双面打印选项。
- en: The print server uses a backend to send the document to the printer.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印服务器使用后端将文档发送到打印机。
- en: The most confusing part of this process is why so much revolves around PostScript.
    PostScript is actually a programming language, so when you print a file using
    it, you’re sending a program to the printer. PostScript serves as a standard for
    printing in Unix-like systems, much as the *.tar* format serves as an archiving
    standard. (Some applications now use PDF output, but this is relatively easy to
    convert.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程最令人困惑的部分是为什么如此多的内容都围绕着PostScript展开。PostScript实际上是一种编程语言，因此当你使用它打印文件时，你实际上是在将一个程序发送到打印机。PostScript作为Unix-like系统中打印的标准，就像*.tar*格式作为归档标准一样。（现在一些应用程序使用PDF输出，但这相对容易转换。）
- en: We’ll talk more about the print format shortly, but first let’s look at the
    queuing system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会详细讨论打印格式，但首先让我们来看一下排队系统。
- en: 14.6.1  CUPS
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.1  CUPS
- en: The standard printing system in Linux is *CUPS* ([http://www.cups.org/](http://www.cups.org/)),
    which is the same system used on macOS. The CUPS server daemon is called `cupsd`,
    and you can use the `lpr` command as a simple client to send files to the daemon.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的标准打印系统是*CUPS*（[http://www.cups.org/](http://www.cups.org/)），它与macOS上使用的系统相同。CUPS服务器守护进程称为`cupsd`，你可以使用`lpr`命令作为简单客户端将文件发送到守护进程。
- en: One significant feature of CUPS is that it implements the *Internet Print Protocol
    (IPP)*, a system that allows for HTTP-like transactions among clients and servers
    on TCP port 631\. In fact, if you have CUPS running on your system, you can probably
    connect to *http://localhost:631/* to see your current configuration and check
    on any printer jobs. Most network printers and print servers support IPP, as does
    Windows, which can make setting up remote printers a relatively simple task.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: CUPS的一个显著特点是它实现了*互联网打印协议（IPP）*，这是一种允许客户端和服务器在TCP端口631上进行类似HTTP的事务的系统。事实上，如果你的系统上运行着CUPS，你可能可以连接到*http://localhost:631/*来查看当前配置并检查打印任务。大多数网络打印机和打印服务器都支持IPP，Windows也是如此，这使得设置远程打印机成为一项相对简单的任务。
- en: You probably won’t be able to administer the system from the web interface,
    because the default setup isn’t very secure. Instead, your distribution likely
    has a graphical settings interface to add and modify printers. These tools manipulate
    the configuration files, normally found in */etc/cups*. It’s usually best to let
    those tools do the work for you, because configuration can be complicated. Even
    if you do run into a problem and need to configure manually, it’s usually best
    to create a printer using the graphical tools so that you have somewhere to start.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能无法通过网页界面管理系统，因为默认设置并不非常安全。相反，你的发行版很可能有一个图形设置界面来添加和修改打印机。这些工具会操作配置文件，通常位于*/etc/cups*目录下。通常最好让这些工具为你工作，因为配置可能会很复杂。即使你确实遇到问题并需要手动配置，通常最好通过图形工具创建一个打印机，这样你就有了一个起点。
- en: 14.6.2  Format Conversion and Print Filters
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.2  格式转换与打印过滤器
- en: Many printers, including nearly all low-end models, do not understand PostScript
    or PDF. To support one of these printers, a Linux printing system must convert
    documents to a format specific to the printer. CUPS sends the document to a *Raster
    Image Processor (RIP)* to produce a bitmap. The RIP almost always uses the Ghostscript
    (`gs`) program to do most of the real work, but it’s somewhat complicated, because
    the bitmap must fit the format of the printer. Therefore, the printer drivers
    that CUPS uses consult the *PostScript Printer Definition (PPD)* file for the
    specific printer to figure out settings such as resolution and paper sizes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 许多打印机，包括几乎所有低端型号，都不理解PostScript或PDF。为了支持这些打印机，Linux打印系统必须将文档转换为特定打印机的格式。CUPS将文档发送到*光栅图像处理器（RIP）*来生成位图。RIP几乎总是使用Ghostscript（`gs`）程序来完成大部分实际工作，但这有点复杂，因为位图必须适应打印机的格式。因此，CUPS使用的打印机驱动程序会查阅特定打印机的*PostScript打印机定义（PPD）*文件，以确定分辨率和纸张大小等设置。
- en: 14.7 Other Desktop Topics
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.7 其他桌面主题
- en: One interesting characteristic of the Linux desktop environment is that you
    can generally choose which pieces you want to use and stop using the ones that
    you dislike. For a survey of the many various desktop projects, have a look at
    the mailing lists and project links at *https://www.freedesktop.org/*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 桌面环境的一个有趣特点是，你通常可以选择自己想使用的部分，并且停止使用那些你不喜欢的部分。对于各种桌面项目的调查，可以查看 *https://www.freedesktop.org/*
    上的邮件列表和项目链接。
- en: Another major development in the Linux desktop is the Chromium OS open source
    project and its Google Chrome OS counterpart found on Chromebook PCs. This is
    a Linux system that uses much of the desktop technology described in this chapter
    but is centered on the Chromium/Chrome web browsers. Much of what’s found on a
    traditional desktop has been stripped away in Chrome OS.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 桌面领域的另一个重要进展是 Chromium OS 开源项目及其在 Chromebook PC 上的 Google Chrome OS 对应系统。这是一个
    Linux 系统，使用了本章中描述的许多桌面技术，但其核心是 Chromium/Chrome 网络浏览器。许多传统桌面系统中的功能在 Chrome OS 中被去除。
- en: Though desktop environments can be fun to look at and experiment on, we’ll need
    to leave the discussion here. However, if this chapter piqued your interest and
    you think you might like to work on them, you’ll need to know how developer tools
    work, which is where we’re headed next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管桌面环境在视觉上可能很有趣且值得尝试，但我们需要在这里结束讨论。然而，如果这一章引发了你的兴趣，并且你认为自己可能想要在这些方面工作，那么你就需要了解开发者工具的工作原理，而这正是我们接下来要探讨的内容。
