<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 3: The GraphQL Attack Surface</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c77cce49-9403-4fd1-99ba-33d115574b0c" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_41" title="41"/><a class="XrefDestination" id="3"/><span class="XrefDestination" id="xref-502840c03-001"/>3</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="TheGraphqlattacksurface"/><span class="XrefDestination" id="xref-502840c03-002"/>The GraphQL Attack Surface</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">In this chapter, we first explore GraphQL’s language and type system through the eyes of a hacker. Then we provide an overview of the common weaknesses in GraphQL. We hope you have your imaginary black hat handy, because you’re about to learn how a feature can turn into a weakness, how a misconfiguration can turn into an information leak, and how implementation design flaws can lead to DoS opportunities.</p>
<h2 id="h1-502840c03-0001"><a class="XrefDestination" id="WhatIsanAttackSurface?"/><span class="XrefDestination" id="xref-502840c03-003"/>What Is an Attack Surface?</h2>
<p class="BodyFirst">An <em>attack surface</em> is the sum of all possible attack vectors an adversary can use to compromise the confidentiality, integrity, and availability of a system. For example, imagine a physical building with a front door, a side door, and <span epub:type="pagebreak" id="Page_42" title="42"/>multiple windows. As attackers, we view each of these windows and doors as a possible opportunity to gain unauthorized access to the building.</p>
<p>Typically, a system has a higher risk of an attack succeeding when its attack surface is large, such as when it consists of many applications, databases, servers, endpoints, and so on. The more windows and doors a building has, the higher the probability that one of those entry points is unlocked or insecure.</p>
<p>Attack surfaces change over time, especially as systems and their environments evolve. This is particularly true in cloud environments, where infrastructure is elastic. For example, a server could live for only a limited amount of time, or an IP address could change, sometimes multiple times a day.</p>
<p>Let’s review all the windows and doors in GraphQL and highlight possible attack vectors we can use to unlock them. Understanding these concepts will aid you in the next chapters, where we dive deeper into offensive security.</p>
<h2 id="h1-502840c03-0002"><a class="XrefDestination" id="TheGraphQLLanguage"/><span class="XrefDestination" id="xref-502840c03-004"/>The Language</h2>
<p class="BodyFirst">For the purposes of discussing GraphQL’s attack surface, we will break its specification into two sections: its language and its type system. We begin by covering the language, used to make requests to a GraphQL API server, from a client’s point of view. Next, we’ll review its type system from a server’s point of view. You can learn about these concepts and other GraphQL internals by using the GraphQL specification; here, we intend to distill only the parts that will equip you with enough knowledge to test GraphQL attack vectors in future chapters.</p>
<p>The GraphQL language comprises many useful components that clients can leverage. At first glance, the way these elements are represented within requests may appear confusing. <a href="#figure3-1" id="figureanchor3-1">Figure 3-1</a> is a sample GraphQL query whose components are explained in <a href="#table3-1" id="tableanchor3-1">Table 3-1</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502840c03/F03001.png"/>
<figcaption><p><a id="figure3-1">Figure 3-1</a>: A sample GraphQL query</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_43" title="43"/>As you can see, GraphQL queries are uniquely structured, and it is important to understand the various parts. <a href="#table3-1">Table 3-1</a> provides a description of each component.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table3-1">Table 3-1</a>: The Components of a GraphQL Query</p></figcaption>
<table border="1" id="table-502840c03-0001">
<thead>
<tr>
<td><b>#</b></td>
<td><b>Component</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Operation type</td>
<td>Type that defines the method of interaction with the server (query, mutation, or subscription)</td>
</tr>
<tr>
<td>2</td>
<td>Operation name</td>
<td>Arbitrary client-created label used to provide a unique name to an operation</td>
</tr>
<tr>
<td>3</td>
<td>Top-level field</td>
<td>Function that returns a single unit of information or object requested within an operation (may contain nested fields)</td>
</tr>
<tr>
<td>4</td>
<td>Argument (of a top-level field)</td>
<td>Parameter name used to send information to a field to tailor the behavior and results of that field</td>
</tr>
<tr>
<td>5</td>
<td>Value</td>
<td>Data related to an argument sent to a field</td>
</tr>
<tr>
<td>6</td>
<td>Field</td>
<td>Nested function that returns a single unit of information or object requested within an operation</td>
</tr>
<tr>
<td>7</td>
<td>Directive</td>
<td>Feature used to decorate fields to change their validation or execution behavior, altering a value returned by a GraphQL server</td>
</tr>
<tr>
<td>8</td>
<td>Argument (of a directive)</td>
<td>Parameter name used to send information to a field or object to tailor its behavior and results</td>
</tr>
<tr>
<td>9</td>
<td>Argument (of a field)</td>
<td>Parameter name used to send information to a field to tailor the behavior and results of the field</td>
</tr>
</tbody>
</table>
</figure>
<p>The following sections explore these components, as well as a few additional GraphQL features, with a focus on how they contribute to GraphQL’s attack surface.</p>
<h3 id="h2-502840c03-0001"><a class="XrefDestination" id="OperationTypesQueries,Mutations,andSubscriptions"/><span class="XrefDestination" id="xref-502840c03-005"/>Queries, Mutations, and Subscriptions</h3>
<p class="BodyFirst">We discussed the root operation types query, mutation, and subscription in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span> and showed an example of using the query type to retrieve data. (For that reason, we won’t revisit the query type here.) As hackers, the real fun often happens when we can modify data. Creating, updating, and deleting data within a target platform empowers us to expose business logic flaws.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	We recommend using the GraphQL security lab we deployed in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> to follow along with this chapter’s example requests. Use Altair to send the requests to DVGA (<em>http://localhost:5013/graphql</em>).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-502840c03-0001"><span epub:type="pagebreak" id="Page_44" title="44"/><a class="XrefDestination" id="Mutations"/><span class="XrefDestination" id="xref-502840c03-006"/>Mutations</h4>
<p class="BodyFirst">In GraphQL, we can unlock data modification powers by using <em>mutations</em>. Here is an example of a mutation query:</p>
<pre><code>mutation {
  editPaste(id: 1, content: "My first mutation!") {
    paste {
       id
       title
       content
    }
  }
}</code></pre>
<p>We define the mutation operation by using the <code>mutation</code> keyword. Then we call the top-level <code>editPaste</code> field, which accepts the arguments <code>id</code> and <code>content</code>. (We will discuss arguments later in this chapter.) This mutation essentially takes the paste with the <code>id</code> of <code>1</code> and updates its content. We then request the updated paste. This is an example of a mutation that changes and reads data simultaneously.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	As in REST, where an HTTP GET request is conventionally used to read information but could also be used to modify data, it is possible for a GraphQL implementation to ignore the spec and implement query operations in a way that allows data writes. In <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, we will explore why writing data using a GraphQL query can be a bad idea.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-502840c03-0002"><a class="XrefDestination" id="Subscriptions"/><span class="XrefDestination" id="xref-502840c03-007"/>Subscriptions</h4>
<p class="BodyFirst">The <em>subscription</em> operation works bidirectionally: it allows clients to retrieve real-time data from a server, and allows servers to send updates to clients. Subscriptions are not as common as queries and mutations, but many servers do use them, so it is important to know how they work.</p>
<p>Subscriptions are carried over a transport protocol, most commonly <em>WebSocket</em>, a real-time communication protocol that allows clients and servers to exchange messages at any given time over a long-lived connection. However, because the GraphQL specification doesn’t define which transport protocol to use for subscriptions, you might see consumers use other ones.</p>
<p>When a client and server want to communicate over WebSocket, they perform a handshake that upgrades the existing HTTP connection to a WebSocket one. WebSocket internals are outside the scope of this book, but you can learn more about this technology by reading PortSwigger’s technical blog post on the topic at <a class="LinkURL" href="https://portswigger.net/web-security/websockets/what-are-websockets">https://portswigger.net/web-security/websockets/what-are-websockets</a>.</p>
<p>Because DVGA supports subscriptions over WebSocket, we can observe the handshake between DVGA’s frontend interface and the <span epub:type="pagebreak" id="Page_45" title="45"/>GraphQL server. Clients can use subscriptions to fetch information from the DVGA server, such as newly created pastes. For example, when you browse to the Public Pastes page on <em>http://localhost:5013</em>, you should see an outgoing HTTP request that looks like the following in the browser’s developer tools Network tab:</p>
<pre><code>GET <b>/subscriptions</b> HTTP/1.1
Host: 0.0.0.0:5013
Connection: Upgrade
Pragma: no-cache
Cache-Control: no-cache
Upgrade: websocket
Origin: http://localhost:5013
<b>Sec-WebSocket-Version: 13</b>
Sec-WebSocket-Key: MV5U83GH1UG8AlEb18lHiA==</code></pre>
<p>The GraphQL server response to this handshake request looks like this:</p>
<pre><code>HTTP/1.1 <b>101 Switching Protocols</b>
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: aRnlpG8XwzRHPVxYmGVdqJv3D7U=</code></pre>
<p>As you can see, the handshake caused the client and server to switch from HTTP to WebSocket, as indicated by the response code of <code>101 Switching Protocols</code>. The <code>Sec-WebSocket-Accept</code> response header informs the client that the server has accepted the protocol switch.</p>
<p>After the handshake completes, DVGA will send a subscription request over the newly established WebSocket connection:</p>
<pre><code>subscription {
  paste {
     id
     title
     content
  }
}</code></pre>
<p>We define the subscription operation by using the <code>subscription</code> keyword, then request the <code>paste</code> top-level field and select the <code>id</code>, <code>title</code>, and <code>content</code> fields. This subscription allows clients to subscribe to the <code>paste</code> field; whenever a new paste is created in DVGA, the GraphQL server will notify all subscribers of the event. This removes the need for the client to constantly ask the server for updates, which is especially useful because the server may not have anything new to return at that exact moment.</p>
<p>If you want to try sending this subscription request to DVGA by using Altair, you’ll need to assign a subscription URL. You can do so in Altair by clicking the two-arrow icon on the left sidebar and entering the WebSocket URL <b><i>ws://localhost:5013/subscriptions</i></b>. Next, to receive data from the DVGA subscription, you’ll need to create a paste. You can either use the DVGA <span epub:type="pagebreak" id="Page_46" title="46"/>user interface to create it via the Public Pastes page or send a mutation, like the following one, from another Altair tab:</p>
<pre><code>mutation {
  createPaste(title: "New paste", content: "Test", public: false) {
    paste {
      id
      title
      content
    }
  }
}</code></pre>
<p>WebSocket connections are prone to <em>cross-site WebSocket hijacking (CSWSH)</em> vulnerabilities, which happen when the server does not validate the origin of a client in the handshake process. WebSocket connections can also be vulnerable to <em>man-in-the-middle</em> <em>(MITM)</em> attacks when the transport of messages isn’t carried over an encrypted channel such as Transport Layer Security (TLS). The existence of such vulnerabilities could have a security impact on actions carried over GraphQL subscriptions. In <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, we’ll cover WebSocket-based attacks in more detail.</p>
<h3 id="h2-502840c03-0002"><a class="XrefDestination" id="OperationNames"/><span class="XrefDestination" id="xref-502840c03-008"/>Operation Names</h3>
<p class="BodyFirst">GraphQL <em>operation names</em> are labels used to uniquely identify an operation in certain contexts. They appear in the executable documents that clients send to a GraphQL service. These documents can contain a list of one or more operations. For example, the document in <a href="#listing3-1" id="listinganchor3-1">Listing 3-1</a> shows a single query operation requesting a <code>pastes</code> top-level field with a nested <code>title</code> field.</p>
<pre><code>query {
  pastes {
    title
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-1">Listing 3-1</a>: An executable query document</p>
<p>If a document contains only one operation, and that operation is a query defining no variables and containing no directives, then that operation may be represented in its shorthand form, without the <code>query</code> keyword, as shown in <a href="#listing3-2" id="listinganchor3-2">Listing 3-2</a>.</p>
<pre><code>{
  pastes {
    title
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-2">Listing 3-2</a>: A shorthand query document</p>
<p><span epub:type="pagebreak" id="Page_47" title="47"/>However, a document may also contain multiple operations. If the document has more than one operation of the same type, operation names must be used.</p>
<p>Clients define these operation names, which means they can be completely random, making them a great way to potentially fool an analyst reviewing logs of GraphQL applications. For example, imagine that a client sends a document using the operation name <code>getPastes</code>, but instead of returning a list of paste objects, they in fact delete all pastes.</p>
<p><a href="#listing3-3" id="listinganchor3-3">Listing 3-3</a> provides an example of a document with <code>getPasteTitles</code> and <code>getPasteContent</code> set as query operation names. Although these operation names are appropriate given the requested content, they could just as well have been completely unrelated to the queries’ actions. Only the underlying operation logic and selection fields determine the request’s output.</p>
<pre><code>query getPasteTitles {
  pastes {
    title
  }
}

query getPasteContent {
  pastes {
    content
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-3">Listing 3-3</a>: A query document with multiple operations, each one labeled with an operation name</p>
<p>Because operation names are client-driven inputs, they could also potentially be used as attack vectors for injection. Some implementations of GraphQL allow special characters in operation names. The applications might store these names in their audit logs, third-party applications, or other systems. These could cause mayhem if not properly sanitized.</p>
<p>Another interesting observation you might make after looking at Listings 3-1, 3-2 and 3-3 is that a client can request the exact same information by using different documents. This level of freedom offers clients a lot of power; however, it increases the number of possible requests, which in turn increases the application’s attack surface. Parsers that don’t take into consideration the various ways a query can be constructed are prone to unexpected errors.</p>
<h3 id="h2-502840c03-0003"><a class="XrefDestination" id="Fields"/><span class="XrefDestination" id="xref-502840c03-009"/>Fields</h3>
<p class="BodyFirst">A <em>field</em> is a single piece of information available within an operation’s <em>selection set</em>, or the list encapsulated between the curly brackets (<code>{}</code>). In the following example, <code>id</code>, <code>title</code>, and <code>content</code> are fields:</p>
<pre><code>{
  id
  title
  content
}</code></pre>
<p><span epub:type="pagebreak" id="Page_48" title="48"/>Because these three fields sit at the root level of the shorthand query, they are also known as <em>top-level fields</em>. Fields may also contain their own selection set, allowing for the representation of complex data relationships. In the following example, the top-level <code>owner</code> field has its own selection set with one nested field:</p>
<pre><code>{
  id
  title
  content
  owner {
    name
  }
}</code></pre>
<p>So, selection sets are made up of fields, and fields can have their own selection sets with their own fields. Do any security issues jump out at you? In <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>, we’ll explore how circular field relationships may result in recursive and expensive requests that can degrade performance and potentially crash a GraphQL server.</p>
<p>Fields are very important when it comes to interacting with GraphQL services. Not knowing what fields are available can be pretty limiting. Luckily, implementations have deployed a handy tool for us, known as <em>field suggestions</em>. When a client misspells a field, the error message returned by a server that implements field suggestions will reference the field it believes the client was trying to call. For example, if we sent a query for a paste with the field name of <code>titl</code> in DVGA (notice the typo), the server will respond with suggested alternatives:</p>
<pre><code>"Cannot query field \"titl\" on type \"PasteObject\". Did you mean \"title\"?"</code></pre>
<p>This field suggestion feature makes GraphQL a convenient, friendly, and simple tool not only for API consumers but also for hackers. We can exploit this feature to find fields we may not have known about otherwise. We’ll discuss this information disclosure technique in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>.</p>
<h3 id="h2-502840c03-0004"><a class="XrefDestination" id="Arguments"/><span class="XrefDestination" id="xref-502840c03-010"/>Arguments</h3>
<p class="BodyFirst">Like REST APIs, GraphQL allows clients to send <em>arguments</em> for various fields in their queries to tailor the results they return. If you take another look at <a href="#figure3-1">Figure 3-1</a>, you’ll notice that arguments can be implemented at various levels—namely, in fields and directives.</p>
<p>In the following query, the <code>users</code> field has an <code>id</code> argument with a value of <code>1</code>. Without the <code>id</code> argument, this query would return the entire list of users in DVGA. The argument filters this list to those with the same identifier:</p>
<pre><code>query {
  users(id: 1) {
    id
<span epub:type="pagebreak" id="Page_49" title="49"/>    username
  }
}</code></pre>
<p>As expected, the response to this request will return a single user object, its ID, and its username:</p>
<pre><code>{
  "data": {
    "users": [
      {
        "id": "1",
        "username": "admin"
      }
    ]
  }
}</code></pre>
<p>Arguments can also be passed to nested fields. Consider this query:</p>
<pre><code>query {
  users(id: 1)  {
    username(capitalize: true)
  }
}</code></pre>
<p>The nested <code>username</code> field now has an argument called <code>capitalize</code>. This argument accepts a Boolean value, here set to <code>true</code>. In DVGA, this argument will make GraphQL capitalize the first character of the username field and return it in the response, converting <code>admin</code> into <code>Admin</code>, for example:</p>
<pre><code>{
  "data": {
    "users": [
      {
        "username": "Admin"
      }
    ]
  }
}</code></pre>
<p>Arguments are <em>unordered</em>, which means that changing their order does not change the logic of the query. In the following example, whether you pass the <code>limit</code> argument or the <code>public</code> argument first doesn’t change the query’s meaning:</p>
<pre><code>query {
  pastes(<b>limit: 1, public: true</b>){
    id
  }
}</code></pre>
<p><span epub:type="pagebreak" id="Page_50" title="50"/>The way these arguments are processed and validated is completely up to the application, and implementation differences could lead to vulnerabilities. For example, because GraphQL is strongly typed, passing an integer value to an argument that expects a string value will result in a validation error. If you instead pass it a string, the validation at the GraphQL level will pass, but the application should still verify the format of this input. If the value is an email address, for instance, the application might check the value against an email-format regular expression or look for the at (<code>@</code>) symbol.</p>
<p>If an application uses a library that provides custom scalar types for email addresses, the library itself could perform this validation, making it harder for the application maintainers to make mistakes. External GraphQL libraries, such as graphql-scalars (<a class="LinkURL" href="https://github.com/Urigo/graphql-scalars">https://github.com/Urigo/graphql-scalars</a>) for JavaScript, provide useful custom scalar types for specific use cases, such as timestamps, IP addresses, website URLs, and more. Of course, vulnerabilities in custom scalar types could still exist. For example, a vulnerability found in Python’s ipaddress library (CVE-2021-29921) could enable an attacker to bypass IP-based access controls.</p>
<p>As you can see, arguments give clients a lot of power to manipulate the behavior of their requests and are another great attack vector. Because the value of an argument is client driven, it can potentially be stuffed with malicious content in injection-based attacks. In <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, we highlight tools and techniques used to exploit arguments if their values are not properly sanitized for injection purposes.</p>
<h3 id="h2-502840c03-0005"><a class="XrefDestination" id="Aliases"/><span class="XrefDestination" id="xref-502840c03-011"/>Aliases</h3>
<p class="BodyFirst"><em>Aliases</em> allow clients to change a field’s response key to something other than the original field’s name. For example, here we use <code>myalias</code> as an alias for the <code>title</code> field name:</p>
<pre><code>query {
   pastes {
      <b>myalias:</b>title
   }
}</code></pre>
<p>The response will contain the <code>myalias</code> key instead of the original <code>title</code> field name:</p>
<pre><code>{
  "data": {
    "pastes": [
      {
        <b>"myalias":</b> "My Title!"
      }
    ]
  }
}</code></pre>
<p><span epub:type="pagebreak" id="Page_51" title="51"/>Aliases can come in handy when you’re dealing with identical response keys. Consider the query in <a href="#listing3-4" id="listinganchor3-4">Listing 3-4</a>.</p>
<pre><code>query {
  pastes(public: false) {
    title
  }
  pastes(public: true) {
    title
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-4">Listing 3-4</a>: Duplicate queries with different argument values</p>
<p>In this query, we use the <code>pastes</code> field twice. In each query, we pass it the <code>public</code> argument with different values (<code>false</code> and <code>true</code>). The <code>public</code> argument is a way to filter for specific pastes based on their permissions: a public paste is viewable by all clients, while a private paste can be viewed by only the original author. Copy the query from <a href="#listing3-4">Listing 3-4</a> into Altair and send it to the DVGA. You should see the following output:</p>
<pre><code>{
  "errors": [
    {
      "message": "Fields \"pastes\" conflict because they have differing arguments.
      Use different aliases on the fields to fetch both if this was intentional.",
<var>--snip--</var>
}</code></pre>
<p>The GraphQL server tells us that a conflict occurred while using this query. Since we’ve sent the same query using different arguments, GraphQL is unable to process them together. This is where aliases are helpful: we can rename our queries so the server will treat them differently. <a href="#listing3-5" id="listinganchor3-5">Listing 3-5</a> shows how to use aliases to avoid key conflicts.</p>
<pre><code>Query {
  <b>queryOne:</b>pastes(public: false) {
    title
  }
  <b>queryTwo:</b>pastes(public: true) {
    title
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-5">Listing 3-5</a>: Aliasing two queries</p>
<p>In the following response, you will notice two JSON keys, <code>queryOne</code> and <code>queryTwo</code>, for each alias we specified in the query at <a href="#listing3-5">Listing 3-5</a>. You can think of each JSON key as a separate response to a distinct query:</p>
<pre><code>{
  "data": {
    "queryOne": [
<span epub:type="pagebreak" id="Page_52" title="52"/>      {
        "title": "My Title!"
      }
    ],
    "queryTwo": [
      {
        "title": "Testing Testing"
      }
    ]
  }
}</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	While aliases can typically contain alphanumeric characters, most GraphQL servers will return a syntax error when aliases contain special characters.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>So far, aliases look pretty innocent. Rest assured that we can weaponize them. In <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>, we will teach you how to leverage aliases for a variety of DoS attacks, and in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, we’ll use them to defeat authentication controls.</p>
<h3 id="h2-502840c03-0006"><a class="XrefDestination" id="Fragments"/><span class="XrefDestination" id="xref-502840c03-012"/>Fragments</h3>
<p class="BodyFirst"><em>Fragments</em> allow clients to reuse the same set of fields in a GraphQL query for readability and to avoid field repetition. Instead of repeating the fields, you can define a fragment once and use it whenever you need that particular set of fields.</p>
<p>Fragments are defined using the <code>fragment</code> keyword, followed by any name you desire, and declared using the <code>on</code> keyword on an object type name:</p>
<pre><code>fragment CommonFields on PasteObject {
  title
  content
}</code></pre>
<p>In this example, we define a fragment named <code>CommonFields</code>. Using the <code>on</code> keyword, we declare that this fragment is related to the <code>PasteObject</code>, which can give us access to fields that you are already familiar with by now, such as <code>title</code> and <code>content</code>. <a href="#listing3-6" id="listinganchor3-6">Listing 3-6</a> shows how to use this fragment in a query:</p>
<pre><code>query {
  pastes {
    <b>...CommonFields</b>
  }
}

fragment CommonFields on PasteObject {
   title
   content
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-6">Listing 3-6</a>: Defining the <code>CommonFields</code> fragment and using it in a query</p>
<p><span epub:type="pagebreak" id="Page_53" title="53"/>Using three dots (<code>...</code>), also called a <em>spread operator</em>, we can reference the <code>CommonFields</code> fragment in different parts of a query to access paste-related fields such as <code>title</code> and <code>content</code>. There is no limit to the number of times a fragment can be referenced in a query.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The GraphQL Working Groups have been having ongoing discussions about introducing arguments to fragments (<a class="LinkURL" href="https://github.com/graphql/graphql-spec/issues/204">https://github.com/graphql/graphql-spec/issues/204</a>). As of this writing, we don’t know if or when fragment arguments will be introduced.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>From a penetration testing perspective, fragments can be constructed such that they reference one another, allowing for a circular fragment condition that could lead to DoS conditions. You will learn how to abuse this in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p>
<h3 id="h2-502840c03-0007"><a class="XrefDestination" id="Variables"/><span class="XrefDestination" id="xref-502840c03-013"/>Variables</h3>
<p class="BodyFirst">You can supply <em>variables</em> to operations as argument values by declaring them within the GraphQL document. Variables are useful because they avoid costly string building during runtime.</p>
<p>Variables are defined at the top of an operation, after the operation name. <a href="#listing3-7" id="listinganchor3-7">Listing 3-7</a> shows a query that uses a variable.</p>
<pre><code>query publicPastes($status: Boolean!){
  pastes(public: $status){
    id
    title
    content
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-7">Listing 3-7</a>: The <code>status</code> variable passed to the <code>public</code> argument of the <code>pastes</code> object</p>
<p>Using the dollar sign (<code>$</code>) symbol, we provide the variable name <code>status</code> and its type, <code>Boolean</code>. The <code>!</code> after the variable type means that the variable is required for the operation.</p>
<p>To set the variable’s value, you can either provide a default value when defining the variable type or send a JSON object with the variable name and value in the document. In Altair, you can define variables within the Variables pane located directly below the left-hand Query pane, as shown in <a href="#figure3-2" id="figureanchor3-2">Figure 3-2</a>.</p>
<p>In this example, we pass a variable named <code>status</code> with a Boolean value of <code>false</code>. This value will be used wherever the variable exists in the document. Variables provide an easier way to reuse the values we pass to arguments in fields or directives.</p>
<span epub:type="pagebreak" id="Page_54" title="54"/><figure>
<img alt="" class="" src="image_fi/502840c03/f03002.png"/>
<figcaption><p><a id="figure3-2">Figure 3-2</a>: The Altair Variables pane (in the bottom-left corner)</p></figcaption>
</figure>
<h3 id="h2-502840c03-0008"><a class="XrefDestination" id="Directives"/><span class="XrefDestination" id="xref-502840c03-014"/>Directives</h3>
<p class="BodyFirst"><em>Directives</em> allow you to <em>decorate</em>, or change the behavior of, a field within a document. The behavior change could affect the way the particular field gets validated, processed, or executed by the application. Directives can be seen as arguments’ big brother, as they allow for higher-level control, such as conditionally including or skipping fields based on certain logic. They come in two flavors: query level and schema level. Both types are declared with <code>@</code> and can leverage arguments (much like fields).</p>
<p>Implementations typically provide several out-of-the-box directives, and GraphQL API developers can also create their own custom directives as they please. Unlike operation names or aliases, clients can use only the directives defined by the server. <a href="#table3-2" id="tableanchor3-2">Table 3-2</a> shows the common default directives you will often see in the wild, their use, and the location in which they are defined.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table3-2">Table 3-2</a>: Common Schema and Query-Level Directives</p></figcaption>
<table border="1" id="table-502840c03-0002">
<thead>
<tr>
<td><b>#</b></td>
<td><b>Name</b></td>
<td><b>Description</b></td>
<td><b>Location</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>@skip</code></td>
<td>Conditionally omits a field from the response</td>
<td>Query</td>
</tr>
<tr>
<td>2</td>
<td><code>@include</code></td>
<td>Conditionally includes a field in the response</td>
<td>Query</td>
</tr>
<tr>
<td>3</td>
<td><code>@deprecated</code></td>
<td>Signals a deprecation of a schema component</td>
<td>Schema</td>
</tr>
<tr>
<td>4</td>
<td><code>@specifiedBy</code></td>
<td>Specifies a custom scalar type (such as RFCs)</td>
<td>Schema</td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" id="Page_55" title="55"/>Clients can apply the <code>@skip</code> directive to a field to dynamically omit it from the response. When the <code>if</code> condition in the directive’s argument is <code>true</code>, the field won’t be included. Consider the query in <a href="#listing3-8" id="listinganchor3-8">Listing 3-8</a>.</p>
<pre><code>query pasteDetails($pasteOnly: Boolean!){
  pastes{
    id
    title
    content
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> owner @skip(if: $pasteOnly) {
      name
    }
  }
}

<var>--snip--</var>

{
  "pasteOnly": true
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-8">Listing 3-8</a>: Using the <code>@skip</code> directive to omit owner information from a query</p>
<p>We can see the use of the <code>@skip</code> directive, which includes an <code>if</code> condition, check for the value of the <code>$pasteOnly</code> Boolean variable <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If this variable is set to <code>true</code>, the entire <code>owner</code> field (as well as its nested fields) will be skipped and hidden from the response.</p>
<p>The <code>@include</code> query directive is the opposite of the <code>@skip</code> directive. It will include only a field and its nested fields if the argument passed to it is set to <code>true</code>.</p>
<p>The <code>@deprecated</code> directive is different from the <code>@skip</code> and <code>@include</code> directives because clients do not use it in query documents. Known as a <em>schema-level directive</em>, <code>@deprecated</code> is used only in GraphQL schema definitions. It appears at the end of a field or type definition as a way to document that the field or type is no longer supported.</p>
<p>The <code>@deprecated</code><code/> directive has an optional <code>reason</code> string argument that allows developers to specify a message to clients or developers who attempt to use the field. This information will appear in places such as the responses to the introspection query and the documentation section of GraphQL IDE tools such as GraphiQL Explorer and GraphQL Playground. <a href="#listing3-9" id="listinganchor3-9">Listing 3-9</a> is an example schema that shows how the <code>@deprecated</code> directive can be used.</p>
<pre><code>type PasteObject {
<var>--snip--</var>
  userAgent: String
  ipAddr: String @deprecated(reason: "We no longer log IP addresses")
  owner: OwnerObject
<var>--snip--</var>
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-9">Listing 3-9</a>: A deprecated schema-directive defined in an SDL</p>
<p><span epub:type="pagebreak" id="Page_56" title="56"/>Finally, the more recently added <code>@specifiedBy</code> schema-level directive is used to provide a human-readable specification URL for a custom scalar type. We will discuss how <code>@specifiedBy</code> is typically used in <span class="xref" itemid="xref_target_“Scalars” on page 58">“Scalars” on page 58</span>.</p>
<p>The <code>@skip</code>, <code>@include</code>, <code>@deprecated</code>, and <code>@specifiedBy</code> directives are required; GraphQL server implementations must support them to be considered spec compliant.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	As the GraphQL specification develops and more features are introduced, we expect more default directives to be implemented over time. Discussions are ongoing about adding two more query-level directives, <code>@stream</code> and <code>@defer</code>, which clients would use to communicate the relative priority of their requested data and split data across multiple responses. More information can be found in the GraphQL Working Groups GitHub repository under RFCs (<a class="LinkURL" href="https://github.com/graphql/graphql-wg/blob/main/rfcs/DeferStream.md">https://github.com/graphql/graphql-wg/blob/main/rfcs/DeferStream.md</a>).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Custom directives empower GraphQL implementations to develop new features or augment functionality not currently supported, or widely used, by the ecosystem. One example of a widely adopted custom directive is <code>@computed</code>. This powerful schema-level directive saves implementers from having to create resolver functions for fields that can be computed from the values of other fields in the schema. <a href="#listing3-10" id="listinganchor3-10">Listing 3-10</a> shows how the <code>@computed</code> directive can merge the <code>firstName</code> and <code>lastName</code> fields into the <code>fullName</code> field.</p>
<pre><code>type User {
  firstName: String
  lastName: String
  fullName: String <b>@computed(value: "$firstName $lastName")</b>
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-10">Listing 3-10</a>: A computed directive used for the merger of two fields</p>
<p>The power of directives is also their greatest weakness: they are essentially unregulated. Other than describing their general syntax, the GraphQL spec doesn’t mention much about directives, allowing every server implementation the freedom to design their own architecture. Not every GraphQL server implementation will support the same directives. However, implementations that use directives to alter the underlying behavior of the GraphQL language could introduce risks if implemented incorrectly.</p>
<p>The use of custom directives to expand GraphQL opens implementations to customized attack vectors that we hackers can exploit. A vulnerability in a custom directive used by a popular GraphQL implementation could impact hundreds of organizations. In <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>, we will explore how to use directives to attack GraphQL servers.</p>
<h2 id="h1-502840c03-0003"><a class="XrefDestination" id="DataTypes"/><span class="XrefDestination" id="xref-502840c03-015"/>Data Types</h2>
<p class="BodyFirst">GraphQL’s <em>types</em> define the custom objects and data structures that make up a GraphQL schema. There are six kinds of types: object, scalar, enum, <span epub:type="pagebreak" id="Page_57" title="57"/>union, interface, and input. In this section, we will define each type and explain what it is used for.</p>
<p>We reference the types defined in DVGA’s schema as examples. If you’d like more context, you can use Altair to download the full SDL file for DVGA. To download it, click the <b>Docs</b> link next to the Send Request button and select the ellipsis (...) button to expose the Export SDL option, shown in <a href="#figure3-3" id="figureanchor3-3">Figure 3-3</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502840c03/f03003.png"/>
<figcaption><p><a id="figure3-3">Figure 3-3</a>: Altair’s Export SDL feature</p></figcaption>
</figure>
<h3 id="h2-502840c03-0009"><a class="XrefDestination" id="Objects"/><span class="XrefDestination" id="xref-502840c03-016"/>Objects</h3>
<p class="BodyFirst">Custom <em>object types</em> are groups of one or more fields that define domain- or application-specific objects. Consider the snippet of DVGA’s schema in <a href="#listing3-11" id="listinganchor3-11">Listing 3-11</a>.</p>
<pre><code>type PasteObject {
  id: ID!
  title: String
  content: String
  public: Boolean
  userAgent: String
  ipAddr: String
  ownerId: Int
  burn: Boolean
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> owner: OwnerObject
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-11">Listing 3-11</a>: The DVGA <code>PasteObject</code> type</p>
<p>We define a new custom object type, called <code>PasteObject</code>. This object has fields described between curly brackets. You may recognize a few of these fields, as we used them in a GraphQL query earlier in this chapter. Each of these fields uses GraphQL’s out-of-the-box scalar types except for the <code>owner</code> field, which is also a custom object type.</p>
<p>If you look at the <code>id</code> field, you’ll notice that it contains the exclamation mark (<code>!</code>) character. This means that every <code>Paste</code><code/> object requires an <code>ID</code>, whereas every other field can be null. These required fields are known as <em>non-null wrapping types</em>. Also notice the one-way-link relationship between <span epub:type="pagebreak" id="Page_58" title="58"/>our <code>Paste</code> and <code>Owner</code> object nodes <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We discussed such relationships in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>. In practice, this means that we can request an <code>Owner</code> object and its associated fields through a <code>Paste</code> object.</p>
<h3 id="h2-502840c03-0010"><a class="XrefDestination" id="Scalars"/><span class="XrefDestination" id="xref-502840c03-017"/>Scalars</h3>
<p class="BodyFirst"><em>Scalars</em> include several core built-in value types, such as <code>ID</code>, <code>Int</code>, <code>Float</code>, <code>String</code>, and <code>Boolean</code>. Unlike object types, they don’t have their own fields.</p>
<p>Implementations can also define their own custom scalars. Consider <a href="#listing3-12" id="listinganchor3-12">Listing 3-12</a>, which shows how DVGA could introduce a new field within the <code>Paste</code> object called <code>createdAt</code>.</p>
<pre><code><b>scalar DateTime</b>

type PasteObject {
  id: ID!
  title: String
  content: String
  public: Boolean
  userAgent: String
  ipAddr: String
  ownerId: Int
  burn: Boolean
  owner: OwnerObject
  <b>createdAt: DateTime!</b>
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-12">Listing 3-12</a>: A scalar SDL definition</p>
<p>Just like the <code>ID</code> field, this <code>createdAt</code> field could be automatically assigned upon paste creation with a custom scalar type known as <code>DateTime</code>. This custom scalar can help us ensure proper serialization, formatting, and validation.</p>
<p>Custom scalars may also use the <code>@specifiedBy</code> built-in directive to describe their specification URL for clients. For example, a custom scalar type <code>UUID</code> may set its specification URL to the relevant Internet Engineering Task Force (IETF) specification:</p>
<pre><code>scalar UUID @specifiedBy(url:<b> </b>"https://tools.ietf.org/html/rfc4122")</code></pre>
<h3 id="h2-502840c03-0011"><a class="XrefDestination" id="Enums"/><span class="XrefDestination" id="xref-502840c03-018"/>Enums</h3>
<p class="BodyFirst"><em>Enums</em>, or <em>enumeration</em> types, are fields used to return a single string value from a list of possible values. For example, an application may want to allow a client to choose how to sort a list of usernames in the response. To do so, they might create an enum named <code>UserSortEnum</code> to represent types of sorting (such as by username, email, password, or the date a user joined):</p>
<pre><code>enum UserSortEnum {
  ID
  EMAIL
<span epub:type="pagebreak" id="Page_59" title="59"/>  USERNAME
  DATE_JOINED
}</code></pre>
<p>This <code>UserSortEnum</code> enum can then be used as the type for an argument such as <code>order</code>, exposed via an input type named <code>UserOrderedType</code>. (We discuss input types later in this chapter.) <a href="#listing3-13" id="listinganchor3-13">Listing 3-13</a> shows how such a schema might look.</p>
<pre><code>enum UserSortEnum {
  ID
  EMAIL
  USERNAME
  DATE_JOINED
}

input UserOrderType {
  sort: UserSortEnum!
}

type UserObject {
  id: Int!
  username: String!
}

type Query {
  users(limit: Int, order: UserOrderType): UserObject!
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-13">Listing 3-13</a>: A user sorting based on an input type that uses an enum</p>
<p>In this example, we define the <code>UserSortEnum</code> with a few enum fields, such as <code>ID</code>, <code>EMAIL</code>, <code>USERNAME</code>, and <code>DATE_JOINED</code>. We then define an input type named <code>UserOrderType</code>, which contains a field named <code>sort</code> of type <code>UserSortEnum</code>. We expose a query named <code>users</code>, which takes two arguments, <code>limit</code> and <code>order</code>, where <code>order</code> is of type <code>UserOrderType</code>. This allows clients to return a list of users sorted based on any of the defined enums. Such a query may look like the following:</p>
<pre><code>query {
  users(limit: 100, order: {<b>sort: ID</b>})
}</code></pre>
<p>Allowing the client to sort using the options listed in <code>UserSortEnum</code> can be risky. For example, if the client can sort users by their <code>ID</code>, an attacker might have access to the identity of the first user created in the system. This user is likely a super-admin or built-in application account, and so could help focus the attack on high-value accounts with potentially broader permissions than other accounts.</p>
<h3 id="h2-502840c03-0012"><span epub:type="pagebreak" id="Page_60" title="60"/><a class="XrefDestination" id="Unions"/><span class="XrefDestination" id="xref-502840c03-019"/>Unions</h3>
<p class="BodyFirst">A <em>union</em> is a type that returns one of many object types. A client can leverage unions to send a single request to a GraphQL server and get a list of objects. Consider <a href="#listing3-14" id="listinganchor3-14">Listing 3-14</a>, which shows a query using a search feature in DVGA. This feature allows a client to search for a keyword that returns multiple <code>Users</code> and <code>Paste</code> objects:</p>
<pre><code>query {
  search(keyword: "p") {
    <b>... on UserObject {</b>
<b>      username</b>
<b>    }</b>
<b>    ... on PasteObject {</b>
<b>      title</b>
<b>      content</b>
<b>    }</b>
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-14">Listing 3-14</a>: The DVGA search feature</p>
<p>This search feature empowers clients to find both pastes and users that match the keyword with just a single request. Pretty neat! The response to the query can be seen in the following code. It returns a list of matching paste and user fields that have the letter <em>p</em> in either their username or title:</p>
<pre><code>{
  "data": {
    "search": [
      {
        "title": "This is my first <b>p</b>aste",
        "content": "What does your room look like?"
      },
      {
        "id": "2",
        "username": "o<b>p</b>erator"
      }
    ]
  }
}</code></pre>
<p>To accept and resolve a request like this, a schema can use a union type. In <a href="#listing3-15" id="listinganchor3-15">Listing 3-15</a>, we define a <code>union</code> named <code>SearchResults</code>.</p>
<pre><code><b>union SearchResults = UserObject | PasteObject</b>

type UserObject {
  id: ID!
  username: String!
}

type PasteObject {
  id: ID!
<span epub:type="pagebreak" id="Page_61" title="61"/>  title: String
  content: String
<var>--snip--</var>
}

type Query {
  <b>search(keyword: String): [SearchResults!]</b>
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-15">Listing 3-15</a>: A union definition</p>
<p>As you can see, the <code>SearchResults</code> union type merges the user and paste objects into a single type. That type can then be used in a single search query operation that accepts a <code>keyword</code> string argument.</p>
<h3 id="h2-502840c03-0013"><a class="XrefDestination" id="Interfaces"/><span class="XrefDestination" id="xref-502840c03-020"/>Interfaces</h3>
<p class="BodyFirst">Another way to return multiple types within the same field is through interfaces. <em>Interfaces</em> define a list of fields that must be included across all object types that implement them. In the union request example covered in the previous section, you saw how we could retrieve the <code>username</code> field of any <code>User</code> object, as well as the <code>title</code> and <code>content</code> fields of any <code>Paste</code> object, as long as these matched the search pattern. Interfaces do not work like this; they require the same fields to be present in both objects in order for the objects to be joined in a response to the client.</p>
<p>To implement our search functionality using interfaces instead of unions, we could use the schema shown in <a href="#listing3-16" id="listinganchor3-16">Listing 3-16</a>.</p>
<pre><code><b>interface SearchItem {</b>
  <b>keywords: [String!]</b>
<b>}</b>

type UserObject <b>implements SearchItem</b> {
  id: ID!
  username: String!
  <b>keywords: [String!]</b>
}

type PasteObject <b>implements SearchItem</b> {
  id: ID!
  title: String
  content: String
  <b>keywords: [String!]</b>
<var>--snip--</var>
}

type Query {
  search(keyword: String): [SearchItem!]!
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-16">Listing 3-16</a>: An interface SDL definition</p>
<p><span epub:type="pagebreak" id="Page_62" title="62"/>We create an interface type called <code>SearchItem</code> with a <code>keywords</code> string list field. Any object type that wants to implement this interface will need to include the <code>keywords</code> field. We then define this field within both the <code>UserObject</code> and <code>PasteObject</code> objects. Now a client could send a search query much like the one outlined in <a href="#listing3-15">Listing 3-15</a> to retrieve all user and paste objects that use a particular keyword.</p>
<p>Interfaces could pose a problem in applications that poorly implement authorization. One way to implement authorization in GraphQL is by using custom schema-level directives. Because an interface defines fields to be used by other objects, any sensitive field that isn’t properly decorated could be exposed unintentionally. Large SDL files can have thousands of lines, and there is always a chance a developer might forget to add the relevant authorization directives. You’ll learn more about authorization in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>.</p>
<h3 id="h2-502840c03-0014"><a class="XrefDestination" id="Inputs"/><span class="XrefDestination" id="xref-502840c03-021"/>Inputs</h3>
<p class="BodyFirst">Arguments are able to accept values of different types, such as scalars, but when we need to pass large and complex inputs to the server, we can leverage an input type to simplify our requests. <em>Input types</em> are essentially the same as object types, but they can be used only as inputs for arguments. They help organize client requests and make it easier for clients to reuse inputs in multiple arguments. Mature GraphQL deployments use input types to better structure their APIs and make their schema documentation easier to read.</p>
<p>Let’s see input types in action. In <a href="#listing3-17" id="listinganchor3-17">Listing 3-17</a>, we declare an <code>$input</code> variable and assign the type as <code>UserInput!</code>. Then we pass this input variable into the <code>userData</code> argument for our <code>createUser</code> mutation.</p>
<pre><code>mutation newUser(<b>$input: UserInput!</b>) {
  createUser(<b>userData: $input</b>) {
    user {
      username
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-17">Listing 3-17</a>: An input type in a mutation</p>
<p>As you learned in <span class="xref" itemid="xref_target_“Variables” on page 53">“Variables” on page 53</span>, to submit inputs to the application, we’ll need to create a JSON object that represents our <code>UserInput!</code> and assign it to the input key, as shown in <a href="#listing3-18" id="listinganchor3-18">Listing 3-18</a>.</p>
<pre><code>{
  "input": {
    "username": "tom",
    "password": "secret",
    "email": "tom@example.com"
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-18">Listing 3-18</a>: An input definition</p>
<p><span epub:type="pagebreak" id="Page_63" title="63"/>In tools such as Altair or GraphiQL Explorer, <a href="#listing3-18">Listing 3-18</a>’s JSON will be defined in the Variables pane of the client.</p>
<p>Input types provide clients with a possible way to defeat type validations, which may or may not have broken validation logic. For example, earlier in this chapter we discussed how custom scalar types could fail to validate values sent by clients, such as IP addresses or email addresses. Validation issues related to email addresses could allow attackers to bypass registration forms and login processes or perform injections.</p>
<h2 id="h1-502840c03-0004"><a class="XrefDestination" id="Introspection"/><span class="XrefDestination" id="xref-502840c03-022"/>Introspection</h2>
<p class="BodyFirst">After reviewing GraphQL’s language and type system, you should have noticed stark differences in what GraphQL APIs and REST APIs can offer clients. GraphQL puts a lot of power in the hands of the client by default. But wait, there’s more!</p>
<p>Arguably one of GraphQL’s most powerful features is <em>introspection</em>, the built-in tool that empowers clients to discover actions they can take using a GraphQL API. Introspection lets clients query a GraphQL server for information about its underlying schema, which includes data like queries, mutations, subscriptions, directives, types, fields, and more. As hackers, this feature can be a gold mine in supporting our reconnaissance, profiling, data collection, and attack-vector analysis efforts. Let’s dive into how we can use it.</p>
<p>The GraphQL introspection system has seven introspection types that we can use to query the schema. <a href="#table3-3" id="tableanchor3-3">Table 3-3</a> lists these introspection types.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table3-3">Table 3-3</a>: The Introspection System Types</p></figcaption>
<table border="1" id="table-502840c03-0003">
<thead>
<tr>
<td><b>Introspection type</b></td>
<td><b>Usage</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>__Schema</code></td>
<td>Provides all information about the schema of a GraphQL service</td>
</tr>
<tr>
<td><code>__Type</code></td>
<td>Provides all information about a type</td>
</tr>
<tr>
<td><code>__TypeKind</code></td>
<td>Provides the different kinds of types (scalars, objects, interface, union, enum, and so on)</td>
</tr>
<tr>
<td><code>__Field</code></td>
<td>Provides all information for each field of an object or interface type</td>
</tr>
<tr>
<td><code>__InputValue</code></td>
<td>Provides field and directive argument information</td>
</tr>
<tr>
<td><code>__EnumValue</code></td>
<td>Provides one of the possible values of an enum</td>
</tr>
<tr>
<td><code>__Directive</code></td>
<td>Provides all information on both custom and built-in directives</td>
</tr>
</tbody>
</table>
</figure>
<p>Consider <a href="#listing3-19" id="listinganchor3-19">Listing 3-19</a>, which uses the <code>__Schema</code> introspection type against DVGA.</p>
<pre><code>query {
  <b>__schema</b> {
    types {
<span epub:type="pagebreak" id="Page_64" title="64"/>      name
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-19">Listing 3-19</a>: An introspection query for schema types</p>
<p>The <code>__schema</code> introspection top-level field will query all the information available to us through the GraphQL schema we are interacting with. We further refine our investigation by telling the query to look for all <code>types</code> and to select their <code>name</code> fields.</p>
<p>Here is how GraphQL displays the introspection response to this request:</p>
<pre><code>{
  "data": {
    "__schema": {
      "types": [
    <var>--snip--</var>
        {
          "name": <b>"PasteObject"</b>
        },
        {
          "name": <b>"ID"</b>
        }
    <var>--snip--</var>
        {
          "name": <b>"String"</b>
        },
        {
          "name": <b>"OwnerObject"</b>
        },
        {
          "name": <b>"UserObject"</b>
        }
    <var>--snip--</var>
     ]
   }
}</code></pre>
<p>Here, we can see many returned type names. A few should be familiar to you, such as <code>ID</code>, <code>String</code>, and <code>PasteObject</code>. We know that <code>ID</code> and <code>String</code> are GraphQL’s built-in scalar types, but names like <code>PasteObject</code>, <code>OwnerObject</code>, and <code>UserObject</code> should immediately catch our attention as we probe the schema for goodies, because these are custom object types introduced by the developers and not built-in GraphQL types. Let’s dive deeper into these.</p>
<p>We can use <code>__type</code> to further investigate information about types we find interesting. <a href="#listing3-20" id="listinganchor3-20">Listing 3-20</a> provides us with a powerful query to discover all fields and their types within a custom object type of our choosing.</p>
<pre><code>query {
  <b>__type(name: "PasteObject")</b> {
    name
<span epub:type="pagebreak" id="Page_65" title="65"/>    <b>kind</b>
<b>    fields </b>{
      name
      type {
        name
        kind
      }
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing3-20">Listing 3-20</a>: An introspection query for discovering fields within an object of interest</p>
<p>In this case, we decided to dive deeper into the <code>PasteObject</code> type. You will notice that we are selecting not just the name of the type but also its <code>kind</code>, which returns the <code>__TypeKind</code> introspection type for the object. We’re also selecting all of the <code>PasteObject</code> fields and their names, types, and kinds. Let’s take a look at the response:</p>
<pre><code>"__type": {
      "name": "PasteObject",
      "kind": "OBJECT",
      "fields": [
        {
          "name": "id",
          "type": {
            "name": null,
            "kind": "NON_NULL"
          }
        },
        {
          "name": "title",
          "type": {
            "name": "String",
            "kind": "SCALAR"
          }
        },
<var>        --snip--</var>
        {
          "name": "content",
          "type": {
            "name": "String",
            "kind": "SCALAR"
          }
        },
        {
          "name": "owner",
          "type": {
            "name": "OwnerObject",
            "kind": "OBJECT"
          }
        }
      ]
 }</code></pre>
<p><span epub:type="pagebreak" id="Page_66" title="66"/>The structure of the introspection query we made matches that of the response we received. We now have the entire list of fields we can request, as well as their types.</p>
<p>Sensitive fields, intended for staff or internal use only, may easily become revealed to the public if they are included in the GraphQL schema and introspection is enabled. But introspection isn’t only about field discovery; it is the equivalent of being handed a REST API Swagger (OpenAPI) definition file. It allows us to discover the queries, mutations, and subscriptions that are supported, the arguments they accept, and how to construct and execute them. Having this intelligence at our fingertips may allow us to discover and craft malicious operations.</p>
<p>We will dive into more introspection fun in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, which focuses on information disclosure tools and techniques.</p>
<h2 id="h1-502840c03-0005"><a class="XrefDestination" id="ValidationandExecution"/><span class="XrefDestination" id="xref-502840c03-023"/>Validation and Execution</h2>
<p class="BodyFirst">All GraphQL query requests are tested for their validity against the schema and type system before they are executed and resolved by the server. For instance, when a client sends a query for certain fields, the GraphQL implementation’s validations will check the schema to verify that all the requested fields exist on the given type. If a field doesn’t exist within the schema or isn’t associated with a given type, the query will be flagged as invalid and won’t execute.</p>
<p>The GraphQL spec outlines several validation types. These include document, operation, field, argument, fragment, value, directive, and variable validations. The example we just mentioned is a field validation; other validations, such as directive validations, can check if a directive sent by the client is recognized in the schema and supported by the implementation.</p>
<p>There are significant differences in the way GraphQL implementations interpret and conform to the GraphQL spec, and especially in the way they handle responses to invalid requests. This variation is what fingerprinting tools like Graphw00f (covered in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>) aim to detect. Because the thoroughness of a server’s validation stage reveals information about its security maturity, it’s important to analyze these implementation weaknesses. This is where the GraphQL Threat Matrix comes in handy.</p>
<p>The GraphQL Threat Matrix (<a class="LinkURL" href="https://github.com/nicholasaleks/graphql-threat-matrix">https://github.com/nicholasaleks/graphql-threat-matrix</a>) is a security framework for GraphQL developed by the authors of this book. It is used by bug bounty hunters, security researchers, and hackers to assist with uncovering vulnerabilities across multiple GraphQL implementations. <a href="#figure3-4" id="figureanchor3-4">Figure 3-4</a> shows its interface.</p>
<p>The matrix analyzes, tracks, and compares the most common implementations, looking at their supported validations, default security configurations, features, and notable vulnerabilities. The matrix is useful for both hackers and defenders. Knowing how to attack an implementation is crucial, but making data-driven decisions about which implementation to choose in the first place is just as important.</p>
<span epub:type="pagebreak" id="Page_67" title="67"/><figure>
<img alt="" class="" src="image_fi/502840c03/f03004.png"/>
<figcaption><p><a id="figure3-4">Figure 3-4</a>: The GraphQL Threat Matrix</p></figcaption>
</figure>
<p>Once successfully validated, a GraphQL request is executed by the server. Resolver functions, which we covered in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, are responsible for returning a response for a requested field.</p>
<h2 id="h1-502840c03-0006"><a class="XrefDestination" id="CommonGraphQLWeaknesses"/><span class="XrefDestination" id="xref-502840c03-024"/>Common Weaknesses</h2>
<p class="BodyFirst">In this section, we will provide a high-level overview of the common weaknesses found in GraphQL. In later chapters, we will perform penetration testing against each vulnerability class, as well as review related exploit code.</p>
<h3 id="h2-502840c03-0015"><a class="XrefDestination" id="SpecificationRuleandImplementationWeaknesses"/><span class="XrefDestination" id="xref-502840c03-025"/>Specification Rule and Implementation Weaknesses</h3>
<p class="BodyFirst">GraphQL’s specification defines rules, design principles, and standard practices. If you ever want to develop your own GraphQL implementation, this is the document your implementation should conform to, including the way it formats its responses, validates arguments, and so on.</p>
<p>Here are two examples of rules taken from the GraphQL specification:</p>
<blockquote class="blockquote">
<p class="Blockquote">Arguments may be provided in any syntactic order and maintain identical semantic meaning.</p>

<p class="Blockquote">The <em>data</em> entry in the response will be the result of the execution of the requested operation.</p></blockquote>
<p><span epub:type="pagebreak" id="Page_68" title="68"/>These two rules are pretty simple. The first one explains that the order of arguments provided in a query shouldn’t change the server’s response, and the second rule explains that a GraphQL server response must be returned as part of the <em>data</em> JSON field.</p>
<p>Yet complying with these rules is the developer’s responsibility, which is where discrepancies may happen. In fact, the GraphQL spec doesn’t care about how implementations conform to the spec:</p>
<blockquote class="blockquote">
<p class="Blockquote">Conformance requirements expressed as algorithms can be fulfilled by an implementation of this specification in any way as long as the perceived result is equivalent.</p>
</blockquote>
<p>To highlight an example of the behavioral differences between certain implementations, take a look at graphql-php (<a class="LinkURL" href="https://github.com/webonyx/graphql-php">https://github.com/webonyx/graphql-php</a>). This open source implementation is written in PHP and based on GraphQL’s reference implementation library GraphQL.js (<a class="LinkURL" href="https://github.com/graphql/graphql-js">https://github.com/graphql/graphql-js</a>).</p>
<p>However, when you look at how graphql-php handles aliases, you will notice that it differs from many other implementations; it allows clients to submit aliases with special characters, such as <code>$</code>. These subtle differences between implementations not only help hackers fingerprint the underlying technology behind a GraphQL API service (as you will learn in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>) but also may allow us to craft special payloads to impact services using certain implementations. Finally, these varying execution behaviors mean that a vulnerability detected in one implementation may not necessarily impact others.</p>
<p>As a hacker, you will often find yourself referencing an application’s design document to better understand how it is meant to function compared with how it functions in practice. Often, you’ll find discrepancies. For example, imagine that an application design document defines the following rule:</p>
<blockquote class="blockquote">
<p class="Blockquote">The application must be able to receive a URL from a client, fetch it over the network, and return a response to the client.</p>
</blockquote>
<p>This rule isn’t very specific; it doesn’t explain how to secure this function and what the developer should be cautious of when implementing it. However, many things can go wrong in a feature that fetches content from a user-controlled URL. An attacker might be able to do any of the following:</p>
<ul class="disc">
<li>Specify a private IP address (for example, 10.1.1.1) in the URL, which effectively allows access to internal resources on the server where the application lives.</li>
<li>Specify a remote URL that includes malicious code. The server will download the code and host malware on the server.</li>
<li>Specify a URL pointing to a very large file, exhausting server resources and impacting other users’ ability to use the application.</li>
</ul>
<p>This is just a partial list of harmful possibilities. If the developer doesn’t take these scenarios into consideration during implementation, anyone who uses their application will be exposed to these vulnerabilities.</p>
<p><span epub:type="pagebreak" id="Page_69" title="69"/>Building bug-free software is hard (and likely impossible to avoid completely). The more you know about an application and the deeper you dig into it, the higher your chances of finding a vulnerability.</p>
<h3 id="h2-502840c03-0016"><a class="XrefDestination" id="DenialofService"/><span class="XrefDestination" id="xref-502840c03-026"/>Denial of Service</h3>
<p class="BodyFirst">One of the most prevalent vulnerability classes in GraphQL is DoS-based vulnerabilities. These vulnerabilities can degrade a targeted system’s performance or exhaust its resources completely, making it unable to fulfill client queries or even crash. In this chapter, we hinted at how field and object relationships, aliases, directives, and fragments could all potentially be used as attack vectors against a GraphQL service, because these capabilities provide API clients with an enormous amount of control over the query structure and execution behavior.</p>
<p>In <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>, you’ll learn how this power can also enable clients to construct very complex queries that effectively degrade a GraphQL server’s performance if the right security countermeasures are not put in place. We will review four ways that a client can create expensive queries. These may overwhelm the GraphQL server and lead to DoS conditions.</p>
<h3 id="h2-502840c03-0017"><a class="XrefDestination" id="InformationDisclosure"/><span class="XrefDestination" id="xref-502840c03-027"/>Information Disclosure</h3>
<p class="BodyFirst">A common weakness in many web applications is the unintended disclosure of data to the public, or to a group of users that isn’t authorized to access it. Information leakages have many causes, and systems entrusted with protecting sensitive information such as PII should deploy numerous layers of detection and prevention controls to protect information from being exposed.</p>
<p>When it comes to GraphQL, hackers can fingerprint and collect data from its API in several ways. In <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, we’ll teach you how to leverage introspection queries to hunt for fields that may contain sensitive information. We’ll equip you with tools that take advantage of how field suggestions and error messages work to help uncover hidden data models and maneuver around GraphQL environments where introspection may be disabled.</p>
<h3 id="h2-502840c03-0018"><a class="XrefDestination" id="AuthenticationandAuthorizationFlaws"/><span class="XrefDestination" id="xref-502840c03-028"/>Authentication and Authorization Flaws</h3>
<p class="BodyFirst">Authentication and authorization are complex security controls in any API system architecture. The fact that the GraphQL spec refrains from providing authentication and authorization guidance for implementations doesn’t help. This void often leads engineers to implement their own authentication and authorization mechanisms based on open source, in-house, or third-party solutions.</p>
<p>Most of the authentication and authorization vulnerabilities you’ll find in GraphQL stem from the same issues you’d find in traditional APIs, such as failure to adequately protect against brute-force attacks, logic flaws, or poor coding that allows controls to be entirely bypassed. In <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, we’ll review several common GraphQL authentication and authorization strategies and teach you how to defeat them with aliases, batch queries, and good, old-fashioned logic flaws.</p>
<h3 id="h2-502840c03-0019"><span epub:type="pagebreak" id="Page_70" title="70"/><a class="XrefDestination" id="Injections"/><span class="XrefDestination" id="xref-502840c03-029"/>Injections</h3>
<p class="BodyFirst">Injection vulnerabilities can have devastating impacts on application data, and while frameworks have gotten better at protecting against them by offering reusable security methods, they are still prevalent today. Much like its counterparts REST and SOAP, GraphQL isn’t immune to the Open Web Application Security Project (OWASP) Top 10, a list of the most common web vulnerabilities, and can become vulnerable to injection-based attacks if untrusted information from a client is accepted and processed by the application.</p>
<p>GraphQL’s language supports multiple avenues for a malicious client to send injection data to a server, such as query arguments, field arguments, directive arguments, and mutations. Implementations of GraphQL also vary in their conformance with the GraphQL spec, leading to differences in the way they may handle, sanitize, and validate the data coming to them from clients. In <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, you will learn about specific GraphQL injection vulnerabilities and their various entry points into backend systems.</p>
<h2 id="h1-502840c03-0007"><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-502840c03-030"/>Summary</h2>
<p class="BodyFirst">By now, you should understand what GraphQL is and what some of its attack vectors may look like. You should also be quite comfortable with GraphQL’s language, having reviewed the anatomy of a query and dissected its internal components, such as operations, fields, and arguments. You also began to leverage the GraphQL lab you built in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> by using Altair to send numerous queries to DVGA. From a server’s perspective, you were introduced to the major components that make up GraphQL’s type system and the role these types play in supporting the structure of GraphQL schemas and introspection queries.</p>
<p>Finally, we created a base camp from which we can launch our future GraphQL hacking attacks. We hinted at the weaknesses and loopholes in the GraphQL spec and in how implementations interpret and extend unregulated functionality beyond the spec. Keep following this trail of breadcrumbs as you continue your GraphQL hacker journey.</p>
</section>
</body>
</html>