<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch5">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch5">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_69" aria-label=" Page 69. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">NEXT.JS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In <span class="chapterintro_Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, you used React to create responsive user interface components. But because React is just a library, building a full-stack application requires additional tools. In this chapter, we use Next.js, the leading web application framework built on top of React. To create an app with Next.js, you need to know only a few essential concepts. This chapter covers them.</p>&#13;
<p class="TX">Next.js streamlines the creation of an application’s frontend, middleware, and backend. On the frontend, it uses React. It also adds native CSS modules to define styles, and custom Next.js modules to perform routing, image handling, and additional frontend tasks. When it comes to the middleware and the backend, Next.js uses a built-in server to provide the entry points for HTTP requests and a clean API in which to work with request and response objects.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_70" aria-label=" Page 70. "/>We’ll cover its filesystem-based approach to routing, discuss ways to build and render the web pages we deliver to clients, explore adding CSS files to style pages, and refactor our Express.js server to work with Next.js. This chapter uses the traditional <i>pages</i> directory to teach you these basic concepts. To learn about Next.js’s alternative <i>app</i> directory, see <span class="Xref"><a href="appendix-B.xhtml">Appendix B</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-32"/><samp class="SANS_Futura_Std_Bold_B_11">Setting Up Next.js</samp></h3>&#13;
<p class="TNI">Next.js is part of the npm ecosystem. While you could manually install all of its required modules by running <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install next react react-dom</samp> and subsequently create all of your project’s files and folders by yourself, there is a much simpler way to set things up: running the <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp> command.</p>&#13;
<p class="TX">Let’s create a sample application to use throughout this chapter. Follow these steps to set up a new empty folder called <i>sample-next</i> and build your first Next.js application inside it. Keep the default answers from the setup wizard, and choose to use the traditional <i>pages</i> directory instead of the <i>app</i> directory:</p>&#13;
&#13;
<pre class="pre-84"><code>$ <b>mkdir sample-next</b>&#13;
$ <b>cd ./sample-next</b>&#13;
$ <b>npx create-next-app@latest </b><b>-</b><b>-typescript </b><b>-</b><b>-use-npm</b>&#13;
--<var>snip</var>--&#13;
What is your project named? ... <b>my-app</b>&#13;
--<var>snip</var>--&#13;
Creating a new Next.js app in /Users/.../my-app.&#13;
&#13;
Installing dependencies:&#13;
- react&#13;
- react-dom&#13;
- next&#13;
&#13;
Installing devDependencies:&#13;
- eslint&#13;
- eslint-config-next&#13;
- typescript&#13;
- @types/react&#13;
- @types/node&#13;
- @types/react-dom&#13;
</code></pre>&#13;
<p class="TX">We create a new folder, switch to it, and then initialize a new Next.js project. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> command instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">npm</samp> because, as you learned in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, npx doesn’t require us to install anything as a dependency or development dependency. We mentioned that a typical use case for it is scaffolding, which is precisely what we’re doing here.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp> command has a few options, of which only two are relevant to us: the <samp class="SANS_TheSansMonoCd_W5Regular_11">--typescript</samp> option creates a Next.js project that supports TypeScript, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">--use-npm</samp> flag selects npm as a package manager.</p>&#13;
<p class="TX">We accept the default project name, <samp class="SANS_TheSansMonoCd_W5Regular_11">my-app</samp>, and all the other default settings. The script creates a folder based on the project name containing the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_71" aria-label=" Page 71. "/><i>package.json</i> file and a complete sample project with all necessary files and folders. Finally, it installs the dependencies and development dependencies through npm.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Instead of setting up a new project, you can use the online playgrounds at</i> <a href="https://codesandbox.io/s/"><span class="note_LinkURL_Italic">https://<wbr/>codesandbox<wbr/>.io<wbr/>/s<wbr/>/</span></a> <i>or</i> <a href="https://stackblitz.com"><span class="note_LinkURL_Italic">https://<wbr/>stackblitz<wbr/>.com</span></a> <i>to run the Next.js code examples from this chapter. Just opt for the</i> <span class="note_Italic">pages</span> <i>directory setup instead of</i> <span class="note_Italic">app</span> <i>there as well.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-64"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Project Structure</samp></h4>&#13;
<p class="TNI">Let’s explore the boilerplate Next.js app’s project structure. Enter the following commands to run it:</p>&#13;
&#13;
<pre class="pre-85"><code>$ <b>cd my-app</b>&#13;
$ <b>npm run dev</b>&#13;
&#13;
&gt; my-app@0.1.0 dev&#13;
&gt; next dev&#13;
&#13;
ready - started server on 0.0.0.0:3000, url: http://localhost:3000&#13;
</code></pre>&#13;
<p class="TX">Visit the provided URL in your browser. You should see a default page similar to the one in <a href="chapter5.xhtml#fig5-1">Figure 5-1</a> (this welcome page could change depending on your Next.js version).</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig5-1" src="../images/Figure5-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-1: The boilerplate Next.js app viewed in a browser</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now open the <i>my-app</i> folder that the scaffolding script created, and look around. The <i>my-app</i> folder contains a lot of folders, but only three are currently important to you: <i>public</i>, <i>styles</i>, and <i>pages</i>.</p>&#13;
<p class="TX">The <i>public</i> folder holds all static assets, such as custom font files, all images, and files the app makes available for download. We’ll link to these assets from the app’s HTML and CSS files. The <i>pages</i> folder contains all of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_72" aria-label=" Page 72. "/>the app’s routes. Each of its files is an endpoint belonging to a page route or an API route (in the <i>api</i> subfolder).</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Recent versions of Next.js additionally include an</i> <span class="note_Italic">app</span> <i>directory that you can choose to use for routing as an alternative to the</i> <span class="note_Italic">pages</span> <i>directory. Because the</i> <span class="note_Italic">app</span> <i>directory uses more advanced concepts, this chapter covers the simpler</i> <span class="note_Italic">pages</span> <i>architectural style. However, you can learn more about the</i> <span class="note_Italic">app</span> <i>directory in <a href="appendix-B.xhtml">Appendix B</a>, where we’ll cover its use in detail.</i></p>&#13;
<p class="TX">In the <i>my-app</i> folder, we also find the <i>_app.tsx</i> file, which is Next.js’s equivalent to the <i>App.tsx</i> file we used in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>. This is the entry point for the whole application and the place where we’ll add our global styles, components, and context providers. Finally, the <i>styles</i> folder contains the global CSS files and modules for locally scoped, component-specific files.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-65"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Development Scripts</samp></h4>&#13;
<p class="TNI">The technologies our app uses, including TypeScript, React, and JSX, don’t run directly in the browser. They all require a build pipeline with a reasonably complex transpiler. Next.js provides four command line scripts to simplify development.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next dev</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> commands starts the application at <i>http://localhost:3000</i> in development mode. As a result, Next.js rebuilds and reloads the rendered application in the browser window as soon as we change a file. In addition to this <i>hot-code</i> reloading, the development server also displays errors and warning messages to aid the application’s development. The installation wizard adds the server to <i>package.json</i>’s script section, so we can start it with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> as well.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next build</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run build</samp> commands create the optimized build of our application. They remove unused code and reduce the file size of our scripts, styles, and all other assets. You’ll use them for the live deployment. The <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next start</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run start</samp> commands run the optimized application at <i>http://localhost:3000</i> in production mode on the built-in server or in a serverless environment. This production build relies on a previously created build. Hence, we must have first run the <samp class="SANS_TheSansMonoCd_W5Regular_11">build</samp> command.</p>&#13;
<p class="TX">Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next export</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run export</samp> commands create a stand-alone version of your application that is independent of the built-in Next.js server and can run on any infrastructure. This version of your app won’t be able to use features that require Next.js on the server side, however. Consult the official Next.js documentation at <a href="https://nextjs.org"><i>https://<wbr/>nextjs<wbr/>.org</i></a> for a guide to using it.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H1" id="sec4"><span id="h1-33"/><samp class="SANS_Futura_Std_Bold_B_11">Routing the Application</samp></h3>&#13;
<p class="TNI">When we built our sample Express.js server, we created an explicit routing file that mapped each of the app’s endpoints to distinct functions that performed corresponding behavior. Next.js offers a different, perhaps simpler, routing system; it automatically creates the app’s routes <span role="doc-pagebreak" epub:type="pagebreak" id="pg_73" aria-label=" Page 73. "/>based on the files in the <i>pages</i> directory. If a file in this folder exports a React component (in the case of a web page) or an async function (in the case of an API), it becomes a valid endpoint, as either an HTML page or an API.</p>&#13;
<p class="TX">In this section, we’ll revisit the routes we created in our Express.js server and remake them using Next.js’s routing technique.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-66"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simple Page Routes</samp></h4>&#13;
<p class="TNI">For our Express.js server, we manually created a <i>/hello</i> route in the <i>index.ts</i> file. When visited, it returned <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp> Let’s convert this route to a page-based one in Next.js. The simplest kind of page route consists of a file placed directly in the <i>pages</i> directory. For example, the <i>pages/index.tsx</i> file, created by default, maps to <i>http://localhost:3000</i>. To create a simple <i>/hello</i> route, make a new file, <i>hello.tsx</i>, in that directory. Now add to it the code from <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a>.</p>&#13;
<span id="Lis5-1"/>&#13;
<pre class="pre-86"><code>import type {NextPage} from "next";&#13;
&#13;
const Hello: NextPage = () =&gt; {&#13;
    return (&lt;&gt;Hello World!&lt;/&gt;);&#13;
}&#13;
&#13;
export default Hello;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-1: The</span> <span class="Futura_Std_Book_11">pages/hello.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">Our Express.js server used the <samp class="SANS_TheSansMonoCd_W5Regular_11">routeHello</samp> function to return the <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp> string. Here we need to add a little more code to export a React component. First we import the custom type <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> from the Next.js module and use it to create a constant, <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello</samp>. We assign the constant a fat arrow function that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>, which is nothing but a custom wrapper for React components. In this case, we return JSX that renders the <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp> string. Finally, we export the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> as the file’s default export.</p>&#13;
<p class="TX">Run the server and navigate to <i>http://localhost:3000/hello</i>. The page you see should show <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp> as its content.</p>&#13;
<p class="TX">The page looks different from the one in the sample Express.js server. That’s because Next.js automatically renders all global styles defined in the <i>_app.tsx</i> file to each page. Hence, the font looks different, even though we didn’t explicitly define any styles in the <i>hello.tsx</i> file.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-67"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nested Page Routes</samp></h4>&#13;
<p class="TNI"><i>Nested</i> routes, such as <i>/components/weather</i> from the sample Express.js server, are logical subroutes of other routes. In other words, <i>weather</i> is nested inside the <i>components</i> entry point. You’ve probably already guessed how we create a nested route with Next.js’s page-routing pattern. Yes, we merely create a subfolder, and Next.js maps the folder structure to the URL schema.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_74" aria-label=" Page 74. "/>Create a new folder, <i>components</i>, inside the <i>pages</i> folder and add a new file, <i>weather.tsx</i>, there. <a href="chapter5.xhtml#fig5-2">Figure 5-2</a> depicts the relationship between the URL <i>components/weather</i> and the file structure <i>pages/components/weather.tsx</i>.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig5-2" src="../images/Figure5-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-2: The relationship between the URL</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">and the file structure</samp> <samp class="SANS_Futura_Std_Book_11">pages/components/weather.tsx</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Our <i>pages</i> folder is the root of the URL, and each nested folder becomes a URL segment. The file that exports the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> is the <i>leaf segment</i>, or the final part of the URL. For this file, we reuse the weather component code we wrote in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, shown in <a href="chapter5.xhtml#Lis5-2">Listing 5-2</a>.</p>&#13;
<span id="Lis5-2"/>&#13;
<pre class="pre-87"><code>import type {NextPage} from "next";&#13;
import React, {useState, useEffect} from "react";&#13;
&#13;
const PageComponentWeather: NextPage = () =&gt; {&#13;
&#13;
    interface WeatherProps {&#13;
        weather: string;&#13;
    }&#13;
&#13;
    const WeatherComponent = (props: WeatherProps) =&gt; {&#13;
&#13;
        const [count, setCount] = useState(0);&#13;
        useEffect(() =&gt; {&#13;
            setCount(1);&#13;
        }, []);&#13;
&#13;
        return (&#13;
            &lt;h1 onClick={() =&gt; setCount(count + 1)}&gt;&#13;
                The weather is {props.weather},&#13;
                and the counter shows {count}&#13;
            &lt;/h1&gt;&#13;
        );&#13;
    };&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_75" aria-label=" Page 75. "/>    return (&lt;WeatherComponent weather="sunny" /&gt;);&#13;
};&#13;
&#13;
export default PageComponentWeather;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-2: The</span> <span class="Futura_Std_Book_11">pages/components/weather.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">The only difference from the functional component created in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> is that we wrap the code in a function that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>, which we then export as the default export. This is consistent with the page we created in <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a> and follows Next.js’s pattern requirement.</p>&#13;
<p class="TX">Visit the new page at <i>http://localhost:3000/components/weather</i> in the browser. It should look similar to <a href="chapter5.xhtml#fig5-3">Figure 5-3</a>.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig5-3" src="../images/Figure5-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-3: The</samp> <samp class="SANS_Futura_Std_Book_11">pages/components/weather.tsx</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">file is rendered at the</samp> <samp class="SANS_Futura_Std_Book_11">/components/weather</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">URL in the browser.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You should recognize the click-handler functionality you saw in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a>.</span></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-68"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">API Routes</samp></h4>&#13;
<p class="TNI">In addition to a user-friendly interface, a full-stack application might also need a machine-readable interface. For example, the Food Finder application you’ll create in <span class="Xref"><a href="part2.xhtml">Part II</a></span> will provide an API to external services so that a mobile app or a third-party widget can display our wish list. As JavaScript-driven full-stack developers, the most common API formats we’ll use are GraphQL and REST, and we talk about these in depth in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. Here we will create REST APIs, which we like for their simplicity.</p>&#13;
<p class="TX">With Next.js, we can design and create APIs via the same patterns we use for pages. Each file in the <i>pages/api/</i> folder is a single API endpoint, and we can define nested API routes in the same way we define nested page routes. However, unlike page routes, API routes are not React components. Instead, they are async functions that take two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiRequest</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiResponse</samp>, and return a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiResponse</samp> and JSON data.</p>&#13;
<p class="TX">There are two caveats you need to remember when it comes to API routes. First, they do not specify a <i>Cross-Origin Resource Sharing (CORS)</i> header by default. This set of HTTP headers, most notably the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access -Control-Allow-Origin</samp> header, lets a server define the origins from which client-side scripts can request resources. If you want client-side scripts running in websites on third-party domains to access your API endpoints, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_76" aria-label=" Page 76. "/>you’ll need to add additional middleware to enable CORS directly in the Next.js server. Otherwise, external requests will prompt a CORS error. This isn’t specific to Next.js; Express.js and most other server frameworks require you to do the same.</p>&#13;
<p class="TX">The second caveat is that static exports done by running <samp class="SANS_TheSansMonoCd_W5Regular_11">next export</samp> do not support API routes. They rely on the built-in Next.js server and cannot run as static files.</p>&#13;
<p class="TX">We used one API route, <i>api/names</i>, in the Express.js server. Now let’s refactor the code and convert it to a Next.js API route. As before, create a new file, <i>names.ts</i>, and place it in the <i>api</i> folder. Because API routes return an async function instead of JSX, we use the <i>.ts</i> extension, not the <i>.tsx</i> extension used for JSX code. Paste the code from <a href="chapter5.xhtml#Lis5-3">Listing 5-3</a> into the file.</p>&#13;
<span id="Lis5-3"/>&#13;
<pre class="pre-88"><code>import type {NextApiRequest, NextApiResponse} from "next";&#13;
&#13;
type responseItemType = {&#13;
    id: string;&#13;
    name: string;&#13;
};&#13;
&#13;
export default async function handler(&#13;
    req: NextApiRequest,&#13;
    res: NextApiResponse&#13;
): Promise&lt;NextApiResponse&lt;responseItemType[]&gt; | void&gt; {&#13;
    const url = "https://www.usemodernfullstack.dev/api/v1/users";&#13;
    let data;&#13;
    try {&#13;
        const response = await fetch(url);&#13;
        data = (await response.json()) as responseItemType[];&#13;
    } catch (err) {&#13;
        return res.status(500);&#13;
    }&#13;
    const names = data.map((item) =&gt; {&#13;
        return {id: item.id, name: item.name};&#13;
    });&#13;
    return res.status(200).json(names);&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-3: The</span> <span class="Futura_Std_Book_11">pages/api/names.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">First we import the custom types for the API request and response from the Next.js package. Then we define the custom type for the API response. In <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, we created the same type for typing the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> call in the <i>routes.ts</i> file. We’re using the same code and <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> call here, so we’ve reused the type as well. We then create and directly export the API handler function mentioned earlier. You learned in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> that async functions need to return a promise as their return type. Therefore, we wrap this API response in a promise.</p>&#13;
<p class="TX">The code in the function’s body is similar to the code in the <samp class="SANS_TheSansMonoCd_W5Regular_11">routeAPINames</samp> function from <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>. It makes an API request to fetch the user data, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_77" aria-label=" Page 77. "/>converts the received data into the desired return format, and finally returns the data. However, we need to make a few modifications. First, instead of returning an error string, we return an API response with no content and a generic status code of <i>500</i>, for an <i>Internal Server Error</i>.</p>&#13;
<p class="TX">The second adjustment involves the data mapping. Previously, we returned a string that rendered in the browser. Now, instead of this string, we return a JSON object. Therefore, we modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp> function to create an array of objects. Finally, we change the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement to return the API response with the <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp> object as JSON and a status code of <i>200: OK</i>.</p>&#13;
<p class="TX">Now open the new API route in the browser at <i>http://localhost:3000/api/names</i>. You should see the API response shown in <a href="chapter5.xhtml#fig5-4">Figure 5-4</a>.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig5-4" src="../images/Figure5-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-4: The</samp> <samp class="SANS_Futura_Std_Book_11">pages/api/names.ts</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">file rendered from</samp> <samp class="SANS_Futura_Std_Book_11">/api/names</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">in the browser</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-69"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic URLs</samp></h4>&#13;
<p class="TNI">You now know how to create page and API routes, which are the foundation of any full-stack application. However, you might be wondering how to create <i>dynamic</i> URLs, which change based on input. We often use dynamic URLs for profile pages, where the user’s name becomes part of the URL. In fact, we implemented a dynamic URL in the Express.js server’s weather API when we defined the route <i>/api/weather/:zipcode</i> in the <i>index.ts</i> file. There, <i>zipcode</i> was a dynamic parameter, or a dynamic leaf segment, whose value was provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">req.params.zipcode</samp> function.</p>&#13;
<p class="TX">Next.js uses a slightly different pattern for dynamic URLs. Because it creates the routes based on folders and files, we need to define dynamic segments through their filenames by wrapping the variable portion in square brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>). The dynamic route <i>/api/weather/:zipcode</i> from the Express.js server would thus translate to the file <i>/api/weather/[zipcode].ts</i>.</p>&#13;
<p class="TX">Let’s create a dynamic route in our sample Next.js application that mimics the <i>/api/weather/:zipcode</i> route from the Express.js server. Make a new folder, <i>weather</i>, in the <i>api</i> folder, and place a file named <i>[zipcode].ts</i> in it. Then paste the code from <a href="chapter5.xhtml#Lis5-4">Listing 5-4</a> into the file.</p>&#13;
<span id="Lis5-4"/>&#13;
<pre class="pre-89"><code>import type {NextApiRequest, NextApiResponse} from "next";&#13;
&#13;
type WeatherDetailType = {&#13;
    zipcode: string;&#13;
    weather: string;&#13;
    temp?: number;&#13;
};&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_78" aria-label=" Page 78. "/>export default async function handler(&#13;
    req: NextApiRequest,&#13;
    res: NextApiResponse&#13;
): Promise&lt;NextApiResponse&lt;WeatherDetailType&gt; | void&gt; {&#13;
&#13;
    return res.status(200).json({&#13;
        zipcode: req.query.zipcode,&#13;
        weather: "sunny",&#13;
        temp: 35&#13;
    });&#13;
&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-4: The</span> <span class="Futura_Std_Book_11">api/weather/[zipcode].ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">This code should be familiar to you, as it follows the basic outline of an API route in Next.js. We import the necessary types, then define a custom type, <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>, and use it as the type for the data returned by the function. (By the way, this is the same type definition we created in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>.) In the function’s body, we return the response with a status code of <i>200: OK</i> and a JSON object. We fill the <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> property with the ZIP code from the dynamic URL parameter, retrieved with <samp class="SANS_TheSansMonoCd_W5Regular_11">req.query .zipcode</samp>.</p>&#13;
<p class="TX">When you run the server, the browser should show the JSON response with the dynamic URL parameter in the response type. If you navigate to <i>http://localhost:3000/api/weather/12345</i>, you should see the API response. If you change the “12345” part of the URL and request the data again, the response data should change accordingly.</p>&#13;
<p class="TX">Note that the dynamic route <i>/api/weather/[zipcode].ts</i> matches <i>/api/weather/12345</i> and <i>/api/weather/54321</i> but not sub-paths of those routes, such as <i>/api/weather/location/12345</i> or <i>/api/weather/location/54321</i>. For this, you’ll need to use a <i>catch all</i> API route, which includes all paths that are inside the current path. You can create a catch all route by adding three dots (<samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>) in front of the filename. For example, the catch all route <i>/api/weather/[...zipcode].ts</i> could handle all four API endpoints mentioned in this paragraph.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-34"/><samp class="SANS_Futura_Std_Bold_B_11">Styling the Application</samp></h3>&#13;
<p class="TNI">To add styles to our Next.js application, we create regular CSS files, written without the vendor prefixes used in other frameworks. Later, Next.js’s postprocessor will add necessary properties to generate backward-compatible styles. While CSS syntax is beyond the scope of this book, this section describes how to use Next.js’s two kinds of CSS styles: global styles and locally scoped component styles, defined in CSS modules.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-70"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_79" aria-label=" Page 79. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Global Styles</samp></h4>&#13;
<p class="TNI">Global styles affect all pages of an app. We stumbled across this behavior when we rendered the <i>hello.tsx</i> file; the page used CSS even though we hadn’t added any style information ourselves.</p>&#13;
<p class="TX">Practically speaking, global styles are just regular CSS files. They aren’t modified during the build, and their class names are guaranteed to stay the same. Therefore, we can use them as regular CSS classes across the application. We import these CSS files in the app’s entry point, the <i>pages/_app.tsx</i> file. Take a look at those in the boilerplate project. You should see a line of code similar to <a href="chapter5.xhtml#Lis5-5">Listing 5-5</a>.</p>&#13;
<span id="Lis5-5"/>&#13;
<pre class="pre-90"><code>import "@/styles/globals.css";</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-5: Importing global styles in the</span> <span class="Futura_Std_Book_11">_app.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">Of course, you can adjust the filename and location of the imported styles or import multiple files. Try playing around by adding a few styles in the <i>global.css</i> file and some regular CSS classes to the HTML elements in the <i>hello.tsx</i> file. Then visit the page at <i>htttp://localhost:3000/hello</i> to see how it changed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-71"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Component Styles</samp></h4>&#13;
<p class="TNI">In <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, you saw that React lets us create user interfaces out of independent, reusable components. Global styles aren’t the best approach for styling independent components, as they require us to keep track of the names we’ve already used in various components, and if we import components from a previous project, we risk having the CSS classes collide with one another.</p>&#13;
<p class="TX">We need the CSS classes to be scoped to individual modules to work efficiently with modularized components. There are multiple architectural patterns for implementing this. For example, using the Block Element Modifier methodology, you can manually scope the styles to a component or a user interface block.</p>&#13;
<p class="TX">Luckily, we don’t need to bother with such a clumsy solution. Next.js lets us use CSS modules that are scoped during the build process. These CSS modules follow the naming convention <span class="symbol_Italic">&lt;</span><i>component</i><span class="symbol_Italic">&gt;</span>.<i>module.css</i>. The compiler automatically prefixes each CSS class name inside the module with the component’s name and a unique identifier. This enables you to use the same style names for multiple components without issue.</p>&#13;
<p class="TX">The actual CSS you write won’t have these prefixes. For example, look at the <i>Home.module.css</i> file inside the <i>styles</i> folder, shown in <a href="chapter5.xhtml#Lis5-6">Listing 5-6</a>.</p>&#13;
<span id="Lis5-6"/>&#13;
<pre class="pre-91"><code>.container {&#13;
    padding: 0 2rem;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-6: Regular CSS code in</span> <span class="Futura_Std_Book_11">styles/Home.module.css</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_80" aria-label=" Page 80. "/>One problem is that, because the build process modifies the class names and prefixes them, we can’t directly use these styles in our other files. Instead, we must import the styles and treat them like a JavaScript object. Then we can refer to them as a property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp> object. For example, the <i>pages/index.tsx</i> file in <a href="chapter5.xhtml#Lis5-7">Listing 5-7</a> uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp> class from <a href="chapter5.xhtml#Lis5-6">Listing 5-6</a>, providing an example of how to use scoped styles.</p>&#13;
<span id="Lis5-7"/>&#13;
<pre class="pre-92"><code>import styles from "../styles/Home.module.css"&#13;
--<var>snip</var>--&#13;
const Home: NextPage = () =&gt; {&#13;
    return (&#13;
        &lt;div className={styles.container}&gt;&#13;
        --<var>snip</var>--&#13;
        &lt;/div&gt;&#13;
    );&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-7: Using styles from the CSS module</span> <span class="Futura_Std_Book_11">styles/Home.module.css</span> <span class="Futura_Std_Book_Oblique_BI_11">in the</span> <span class="Futura_Std_Book_11">index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">This code imports the CSS file into a constant called <samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp>. Now all the CSS class names will be available as properties of the <samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp> object. In JSX, we use variables wrapped in curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>), so we add a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp> class as <samp class="SANS_TheSansMonoCd_W5Regular_11">{styles.container}</samp>.</p>&#13;
<p class="TX">You can now build APIs and custom-styled pages out of React components. The next section introduces useful custom components that Next.js provides to enhance your full-stack application.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H1" id="sec12"><span id="h1-35"/><samp class="SANS_Futura_Std_Bold_B_11">Built-in Next.js Components</samp></h3>&#13;
<p class="TNI">Next.js provides a set of custom components. Each of these addresses one specific use case: for example, accessing internal page properties such as the page title or SEO metadata (<samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp>), improving the app’s overall rendering performance and user experience (<samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>), or enabling the application’s routing (<samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>). We’ll use the Next.js components covered in this chapter in the full-stack application in <span class="Xref"><a href="part2.xhtml">Part II</a></span>, where you can see them applied in practice. For additional attributes and niche use cases, refer to the Next.js documentation.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-72"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The next/head Component</samp></h4>&#13;
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> component exports a custom Next.js-specific <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> component. We use it to set a page’s HTML title and meta elements, which are found inside an HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">head</samp> component. To improve SEO ranking and enhance usability, each page should have its own metadata. <a href="chapter5.xhtml#Lis5-8">Listing 5-8</a> shows an example of the <i>hello.tsx</i> page from <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a> with a customized title and meta element.</p>&#13;
<p class="TX">It is important to remember that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> elements are not merged across pages. Next.js’s client-side routing removes the content of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> element during the page transition.</p>&#13;
<span id="Lis5-8"/>&#13;
<pre class="pre-93"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_81" aria-label=" Page 81. "/>import type {NextPage} from "next";&#13;
<b>import Head from "next/head";</b>&#13;
&#13;
const Hello: NextPage = () =&gt; {&#13;
    return (&#13;
        &lt;div&gt;&#13;
            <b>&lt;Head&gt;</b>&#13;
                <b>&lt;title&gt;Hello World Page Title&lt;/title&gt;</b>&#13;
                <b>&lt;meta property="og:title" content="Hello World" key="title" /&gt;</b>&#13;
            <b>&lt;/Head&gt;</b>&#13;
            &lt;div&gt;Hello World!&lt;/div&gt;&#13;
        &lt;/div&gt;&#13;
    );&#13;
};&#13;
&#13;
export default Hello;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-8: The</span> <span class="Futura_Std_Book_11">pages/hello.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file with a customized title and meta element</span></p>&#13;
<p class="TX">We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> element from the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> component and add it to the returned JSX element, placing it above the existing content and wrapping both in another <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> element because we need to return one element instead of two.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-73"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The next/link Component</samp></h4>&#13;
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> component exports a <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> component. This component is built on top of the React <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> element. We use it instead of an HTML anchor tag when we want to link to another page in the application, enabling client-side transitions between pages. When clicked, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> component updates the browser DOM with the new DOM, scrolls to the top of the new page, and adjusts the browser history. Furthermore, it provides built-in performance optimizations, prefetching the linked page and its data as soon as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> component enters the <i>viewport</i> (the currently visible part of the website). This background prefetch enables smooth page transitions. <a href="chapter5.xhtml#Lis5-9">Listing 5-9</a> adds the Next.js <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> element to the page from the previous listing.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_82" aria-label=" Page 82. "/>&#13;
<span id="Lis5-9"/>&#13;
<pre class="pre-94"><code>import type {NextPage} from "next";&#13;
import Head from "next/head";&#13;
<b>import Link from "next/link";</b>&#13;
&#13;
const Hello: NextPage = () =&gt; {&#13;
    return (&#13;
        &lt;div&gt;&#13;
            &lt;Head&gt;&#13;
                &lt;title&gt;Hello World Page Title&lt;/title&gt;&#13;
                &lt;meta property="og:title" content="Hello World" key="title" /&gt;&#13;
            &lt;/Head&gt;&#13;
            &lt;div&gt;Hello World!&lt;/div&gt;&#13;
            &lt;div&gt;&#13;
                Use the HTML anchor for an&#13;
                <b>&lt;a href="https://nostarch.com" &gt; external link&lt;/a&gt;</b>&#13;
                and the Link component for an&#13;
                <b>&lt;Link href=</b><b>"/components/weather"&gt; internal page</b>&#13;
                <b>&lt;/Link&gt;</b>&#13;
                .&#13;
            &lt;/div&gt;&#13;
        &lt;/div&gt;&#13;
    );&#13;
};&#13;
&#13;
export default Hello;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-9: The</span> <span class="Futura_Std_Book_11">pages/hello.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file with an external link and an internal</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">next/link</samp> <span class="Futura_Std_Book_Oblique_BI_11">element</span></p>&#13;
<p class="TX">We import the component, then add it to the returned JSX element. For comparison purposes, we use a regular HTML anchor to link to the No Starch Press home page and the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> to connect to the weather component page in our Next.js application. In the app, try clicking both links to see the difference.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-74"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The next/image Component</samp></h4>&#13;
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp> component exports an <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp> component used to display images. This component is built on top of the native HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;img&gt;</samp> element. It handles common layout requirements, such as filling all available space and scaling images. The component can load modern image formats, such as <i>AVIF</i> and <i>WebP</i>, and serve the image with the correct size for the client’s screen. Furthermore, you have the option to use blurred placeholder images and lazy-load the actual image as soon as it enters the viewport; this enforces the visual stability of your website by preventing <i>cumulative layout shifts</i>, which occur when an image renders after the page, causing the page content to shift down. Cumulative layout shifts are considered a bad user experience, and they can make the user lose their focus. <a href="chapter5.xhtml#Lis5-10">Listing 5-10</a> provides a basic example of the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp> component.</p>&#13;
<span id="Lis5-10"/>&#13;
<pre class="pre-95"><code>import type {NextPage} from "next";&#13;
import Head from "next/head";&#13;
import Link from "next/link";&#13;
<b>import Image from "next/image";</b>&#13;
&#13;
const Hello: NextPage = () =&gt; {&#13;
    return (&#13;
        &lt;div&gt;&#13;
            &lt;Head&gt;&#13;
                &lt;title&gt;Hello World Page Title&lt;/title&gt;&#13;
                &lt;meta property="og:title" content="Hello World" key="title" /&gt;&#13;
            &lt;/Head&gt;&#13;
            &lt;div&gt;Hello World!&lt;/div&gt;&#13;
            &lt;div&gt;&#13;
                Use the HTML anchor for an &lt;a href="https://nostarch.com"&gt;&#13;
                external link&lt;/a&gt; and the Link component for an&#13;
                &lt;Link href="/components/weather"&gt; internal page&lt;/Link&gt;.&#13;
                <b>&lt;Image</b>&#13;
                    <b>src</b><b>="/vercel.svg"</b>&#13;
                    <b>alt="Vercel Logo"</b>&#13;
                    <b>width={72}</b>&#13;
                    <b>height={16}</b>&#13;
                <b>/&gt;</b>&#13;
            &lt;/div&gt;&#13;
        &lt;/div&gt;&#13;
    );&#13;
};&#13;
export default Hello;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-10: The</span> <span class="Futura_Std_Book_11">pages/hello.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file using the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">next/image</samp> <span class="Futura_Std_Book_Oblique_BI_11">element</span></p>&#13;
<p class="TX">Here we display the Vercel logo from our application’s <i>public</i> folder. First we import the component from the <i>next/image</i> package. Then we add it to the page content. The syntax and the properties of our minimal example are similar to the HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">img</samp> element. You can read more about the component’s advanced properties in the official documentation at <a href="https://nextjs.org/docs/api-reference/next/image"><i>https://<wbr/>nextjs<wbr/>.org<wbr/>/docs<wbr/>/api<wbr/>-reference<wbr/>/next<wbr/>/image</i></a>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H1" id="sec16"><span id="h1-36"/><samp class="SANS_Futura_Std_Bold_B_11">Pre-rendering and Publishing</samp></h3>&#13;
<p class="TNI">While you can start building full-stack Next.js applications with the information you’ve learned so far, you’ll find it useful to know one more advanced topic: the different ways to render and publish your application and their implications for its performance.</p>&#13;
<p class="TX">Next.js provides three options for pre-rendering your app with its built-in server. The first, <i>static site generation (SSG)</i>, generates the HTML at build time. Thus, each request will always return the same HTML, which remains static and is never re-created. The second option, <i>server-side rendering (SSR)</i>, generates new HTML files on each request, and the third, <i>incremental static regeneration (ISR)</i>, combines both approaches.</p>&#13;
<p class="TX">Next.js lets us choose our pre-rendering option on a per-page basis, meaning the full-stack application can contain pages with SSG, SSR, and ISR, as well as client-side rendering for some React components. You can also create a complete static export of your site by running <samp class="SANS_TheSansMonoCd_W5Regular_11">next export</samp>. The exported application will run independently on all infrastructures, as it doesn’t need the built-in Next.js server.</p>&#13;
<p class="TX">To gain experience with these rendering approaches, we’ll create a new page that displays the data from our names API for each rendering option. Create a new folder, <i>utils</i>, next to the <i>pages</i> folder and add an empty file, <i>fetch-names.ts</i>, to it. Then add the code in <a href="chapter5.xhtml#Lis5-11">Listing 5-11</a>. This utility function calls the remote API and returns the dataset.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_83" aria-label=" Page 83. "/>&#13;
<span id="Lis5-11"/>&#13;
<pre class="pre-96"><code>type responseItemType = {&#13;
    id: string;&#13;
    name: string;&#13;
};&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_84" aria-label=" Page 84. "/>export const fetchNames = async () =&gt; {&#13;
    const url = "https://www.usemodernfullstack.dev/api/v1/users";&#13;
    let data: responseItemType[] | [] = [];&#13;
    let names: responseItemType[] | [];&#13;
    try {&#13;
        const response = await fetch(url);&#13;
        data = (await response.json()) as responseItemType[];&#13;
    } catch (err) {&#13;
        names = [];&#13;
    }&#13;
    names = data.map((item) =&gt; {return {id: item.id, name: item.name}});&#13;
&#13;
    return names;&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-11: The async utility in</span> <span class="Futura_Std_Book_11">utils/fetch-names.ts</span></p>&#13;
<p class="TX">After defining a custom type, we create a function and directly export it. This function contains the code from the previously created <i>names.ts</i> file, with two adjustments: first we need to define the data array as possibly empty; next, we return an empty array instead of an error string if the API call fails. This change means that we don’t need to verify the type before iterating over the array when we generate the JSX string.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H2" id="sec17"><span id="h2-75"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Server-Side Rendering</samp></h4>&#13;
<p class="TNI">Using SSR, Next.js’s built-in Node.js server creates an application’s HTML in response to each request. You should use this technique if your page depends on fresh data from an external API. Unfortunately, SSR is slower in production, because the pages aren’t easily cacheable.</p>&#13;
<p class="TX">To use SSR for a page, export an additional async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>, from that page. Next.js calls this function on every request and passes the fetched data to the page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> argument to pre-render it before sending it to the client.</p>&#13;
<p class="TX">Try this out by creating a new file, <i>names-ssr.tsx</i>, in the <i>pages</i> folder. Paste the code from <a href="chapter5.xhtml#Lis5-12">Listing 5-12</a> into the file.</p>&#13;
<span id="Lis5-12"/>&#13;
<pre class="pre-97"><code>import type {&#13;
    <b>GetServerSideProps,</b>&#13;
    <b>GetServerSidePropsContext,</b>&#13;
    <b>InferGetServerSidePropsType,</b>&#13;
    NextPage,&#13;
    PreviewData&#13;
} from "next";&#13;
import {ParsedUrlQuery} from "querystring";&#13;
import {fetchNames} from "../utils/fetch-names";&#13;
&#13;
type responseItemType = {&#13;
    id: string;&#13;
    name: string;&#13;
};&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_85" aria-label=" Page 85. "/>const NamesSSR: NextPage = <b>(props: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;</b><b>)</b> =&gt; {&#13;
&#13;
    const output = props.names.map((item: responseItemType, idx: number) =&gt; {&#13;
        return (&#13;
            &lt;li key={`name-${idx}`}&gt;&#13;
                {item.id} : {item.name}&#13;
            &lt;/li&gt;&#13;
        );&#13;
    });&#13;
&#13;
    return (&#13;
        &lt;ul&gt;&#13;
            {output}&#13;
        &lt;/ul&gt;&#13;
    );&#13;
};&#13;
&#13;
<b>export const getServerSideProps: GetServerSideProps</b> = async (&#13;
    context: GetServerSidePropsContext&lt;ParsedUrlQuery, PreviewData&gt;&#13;
) =&gt; {&#13;
&#13;
    let names: responseItemType[] | [] = [];&#13;
    try {&#13;
        names = await fetchNames();&#13;
    } catch(err) {}&#13;
    return {&#13;
        props: {&#13;
          names&#13;
        }&#13;
    };&#13;
};&#13;
&#13;
export default NamesSSR;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-12: A basic page that displays data with SSR,</span> <span class="Futura_Std_Book_11">page/names-ssr.tsx</span></p>&#13;
<p class="TX">To use Next.js’s SSR, we export the additional async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>. We also import necessary functionality from the <i>next</i> and <i>querystring</i> packages and the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetchNames</samp> function we created earlier. Then we define the custom type for the response to the API request. It’s the same custom type we used in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>.</p>&#13;
<p class="TX">Next, we create the page and store the export as the default one. The page returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> and takes the default properties for this page type. We iterate over the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> parameter’s <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp> array and create a JSX string that we render and return to the browser. Then we define the <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp> function, which gets the data from the API. We return the created dataset from the async function and pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> inside the page properties.</p>&#13;
<p class="TX">Navigate to the new page at <i>http://localhost:3000/names-ssr</i>. You should see the list of the usernames.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-76"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_86" aria-label=" Page 86. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Site Generation</samp></h4>&#13;
<p class="TNI">SSG creates the HTML files only once and reuses them for every request. It is the recommended option, because pre-rendered pages are easy to cache and fast to deliver. For example, a content delivery network can easily pick up your static files.</p>&#13;
<p class="TX">Usually, SSG applications have a lower <i>time to first paint</i>, or the time it takes after a user requests the page (by, for example, clicking a link) until the content appears in the browser. SSG also reduces <i>blocking time</i>, or the time it takes until the user can actually interact with the page’s content. Good scores in these metrics indicate a responsive website, and they are part of Google’s scoring algorithm. Hence, these pages have increased SEO rankings.</p>&#13;
<p class="TX">If your page relies on external data, you can still use SSG by exporting an additional async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>, from the page’s file. Next.js calls this function at build time, passes the fetched data to the page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> argument, and pre-renders the page with SSG. Of course, this works only if the external data isn’t dynamic.</p>&#13;
<p class="TX">Try creating the same page as in the SSR example, this time with SSG. Add a new file, <i>names-ssg.tsx</i>, in the <i>pages</i> folder and then paste in the code shown in <a href="chapter5.xhtml#Lis5-13">Listing 5-13</a>.</p>&#13;
<span id="Lis5-13"/>&#13;
<pre class="pre-98"><code>import type {&#13;
    <b>GetStaticProps,</b>&#13;
    <b>GetStaticPropsContext,</b>&#13;
    <b>InferGetStaticPropsType,</b>&#13;
    NextPage,&#13;
    PreviewData,&#13;
} from "next";&#13;
import {ParsedUrlQuery} from "querystring";&#13;
import {fetchNames} from "../utils/fetch-names";&#13;
&#13;
type responseItemType = {&#13;
    id: string,&#13;
    name: string,&#13;
};&#13;
&#13;
const <b>NamesSSG</b>: NextPage = <b>(props: InferGetStaticPropsType&lt;typeof getStaticProps&gt;)</b> =&gt; {&#13;
     &#13;
    const output = props.names.map((item: responseItemType, idx: number) =&gt; {&#13;
        return (&#13;
            &lt;li key={`name-${idx}`}&gt;&#13;
                {item.id} : {item.name}&#13;
            &lt;/li&gt;&#13;
        );&#13;
    });&#13;
     &#13;
    return (&#13;
        &lt;ul&gt;&#13;
            {output}&#13;
        &lt;/ul&gt;&#13;
    );&#13;
};&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_87" aria-label=" Page 87. "/><b>export const getStaticProps: GetStaticProps = async (</b>&#13;
    context: <b>GetStaticPropsContext&lt;ParsedUrlQuery, PreviewData&gt;</b>&#13;
) =&gt; {&#13;
&#13;
    let names: responseItemType[] | [] = [];&#13;
    try {&#13;
        <b>names = await fetchNames();</b>&#13;
    } catch (err) {}&#13;
     &#13;
    return {&#13;
        props: {&#13;
            names&#13;
        }&#13;
    };&#13;
};&#13;
&#13;
export default NamesSSG;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-13: A page that displays data with SSG,</span> <span class="Futura_Std_Book_11">page/names-ssg.tsx</span></p>&#13;
<p class="TX">The code is mostly identical to <a href="chapter5.xhtml#Lis5-9">Listing 5-9</a>. We just need to change the SSR-specific code to use SSG. Therefore, we export <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp> and adjust the types accordingly.</p>&#13;
<p class="TX">When you visit the page, it should look similar to the SSR page. But instead of requesting fresh data on each visit to <i>http://localhost:3000/names-ssg</i>, the data is requested only once, on page build.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2" id="sec19"><span id="h2-77"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Incremental Static Regeneration</samp></h4>&#13;
<p class="TNI">ISR is a hybrid of SSG and SSR that runs purely on the server side. It generates the HTML on the server during the initial build and sends this pre-generated HTML the first time a page is requested. After a specified time has passed, Next.js will fetch the data and regenerate the page on the server in the background. In the process, it invalidates the internal server cache and updates it with the new page. Every subsequent request will receive the up-to-date page. Like SSG, ISR is less costly than SSR and increases a page’s SEO ranking.</p>&#13;
<p class="TX">To enable ISR in SSG pages, we need to add a property to revalidate <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProp</samp>’s return object. We define the validity of the data in seconds, as shown in <a href="chapter5.xhtml#Lis5-14">Listing 5-14</a>.</p>&#13;
<span id="Lis5-14"/>&#13;
<pre class="pre-99"><code>return {&#13;
        props: {&#13;
        names,&#13;
        revalidate: 30&#13;
    }&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-14: Changing</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">getServerSideProps</samp> <span class="Futura_Std_Book_Oblique_BI_11">to enable ISR</span></p>&#13;
<p class="TX">We add the <samp class="SANS_TheSansMonoCd_W5Regular_11">revalidate</samp> property with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">30</samp>. As a result, the custom Next.js server will invalidate the current HTML 30 seconds after the first page request.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h4 class="H2" id="sec20"><span id="h2-78"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_88" aria-label=" Page 88. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Client-Side Rendering</samp></h4>&#13;
<p class="TNI">A completely different approach, <i>client-side rendering</i> involves first generating the HTML with SSR or SSG and sending it to the client. The client then fetches additional data at runtime and renders it in the browser DOM. Client-side rendering is a good choice when working with highly flexible, constantly changing datasets, such as real-time stock market or currency prices. Other sites use it to send a skeleton version of the page to the client and later enhance it with more content. However, client-side rendering lowers your SEO performance, as its data can’t be indexed.</p>&#13;
<p class="TX"><a href="chapter5.xhtml#Lis5-15">Listing 5-15</a> shows the page we created earlier, configured for client-side rendering. Create a new file, <i>names-csr.tsx</i>, in the <i>pages</i> folder and then add the code to it.</p>&#13;
<span id="Lis5-15"/>&#13;
<pre class="pre-100"><code>import type {&#13;
    NextPage&#13;
} from "next";&#13;
import {<b>useEffect, useState</b>} from "react";&#13;
import {fetchNames} from "../utils/fetch-names";&#13;
&#13;
type responseItemType = {&#13;
    id: string,&#13;
    name: string,&#13;
};&#13;
&#13;
const NamesCSR: NextPage = () =&gt; {&#13;
    const [data, setData] = <b>useState&lt;responseItemType[] | []&gt;</b>();&#13;
    <b>useEffect</b>(() =&gt; {&#13;
        const fetchData = async () =&gt; {&#13;
            let names;&#13;
            try {&#13;
                names = await fetchNames();&#13;
            } catch (err) {&#13;
                console.log("ERR", err);&#13;
            }&#13;
            setData(names);&#13;
        };&#13;
        fetchData();&#13;
    }<b>);</b>&#13;
&#13;
    const output = data?.map((item: responseItemType, idx: number) =&gt; {&#13;
        return (&#13;
            &lt;li key={`name-${idx}`}&gt;&#13;
                {item.id} : {item.name}&#13;
            &lt;/li&gt;&#13;
        );&#13;
    });&#13;
&#13;
    return (&#13;
        &lt;ul&gt;&#13;
            {output}&#13;
        &lt;/ul&gt;&#13;
    );&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_89" aria-label=" Page 89. "/>};&#13;
&#13;
export default NamesCSR;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-15: The client-side rendered page,</span> <span class="Futura_Std_Book_11">page/names-csr.tsx</span></p>&#13;
<p class="TX">This code differs significantly from the previous examples. Here we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hooks. The latter one will fetch the data after the page is already available. As soon as the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetchNames</samp> function returns the data, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> hook and the reactive <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> state variable to update the browser DOM.</p>&#13;
<p class="TX">We cannot declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook as an async function, because it returns either an undefined value or a function, whereas an async function returns a promise, and therefore TSC would throw an error. To avoid this, we need to wrap the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> call in an async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">fetchData</samp>, and then call that function.</p>&#13;
<p class="TX">The page configured for client-side rendering should look similar to the other versions. But when you visit <i>http://localhost:3000/names-csr</i>, you might see a white flash. This is the page waiting for the asynchronous API request.</p>&#13;
<p class="TX">To get a better feel for the different rendering types, modify the code for each example in this section to use the API <i><a href="https://www.usemodernfullstack.dev/api/v1/now">https://www.usemodernfullstack.dev/api/v1/now</a></i>, which returns an object with the timestamp of the request.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h4 class="H2" id="sec21"><span id="h2-79"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static HTML Exporting</samp></h4>&#13;
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">next export</samp> command generates a static HTML version of your web application. This version is independent of the built-in Node.js-based Next.js web server and can run on any infrastructure, such as an Apache, NGINX, or IIS server.</p>&#13;
<p class="TX">To use this command, your page must implement <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>, as in SSG. This command won’t support the <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp> function, ISR, or API routes.</p>&#13;
<p class="HeadProject"><span id="Exe5"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5: Refactor Express.js and React to Next.js</samp></p>&#13;
<p class="TNI">Let’s refactor the React and Express.js applications from the previous chapters into a Next.js application that we’ll expand in the upcoming chapters. As a first step, we’ll summarize the functionality we need to build. Our application has an API route, <i>api/names</i>, that returns usernames, and another API route, <i>api/weather/:zipcode</i>, that returns a static JSON object and the URL parameter. We used it to understand dynamic URLs. In addition, we created pages at <i>/hello</i> and <i>component/weather</i>.</p>&#13;
<p class="TX">Throughout this chapter, we’ve already refactored these various elements to work with Next.js’s routing style. In this exercise, we’ll put it all together. Follow the steps in <span class="Xref">“Setting Up Next.js” on page 70</span> to initialize the Next.js application. Within the <i>sample-next</i> folder, name your application <i>refactored-app</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h4 class="H2" id="sec22"><span id="h2-80"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_90" aria-label=" Page 90. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Storing Custom Interfaces and Types</samp></h4>&#13;
<p class="TNI">We create a new file, <i>custom.d.ts</i>, in the root of the project to store our custom interface and type definitions (<a href="chapter5.xhtml#Lis5-16">Listing 5-16</a>). It is similar to the one we used in <span class="Xref"><a href="chapter3.xhtml">Chapters 3</a></span> and <span class="Xref"><a href="chapter4.xhtml">4</a></span>. The main difference is that we add custom types for the Next.js application.</p>&#13;
<span id="Lis5-16"/>&#13;
<pre class="pre-101"><code>interface WeatherProps {&#13;
    weather: string;&#13;
}&#13;
&#13;
type WeatherDetailType = {&#13;
    zipcode: string;&#13;
    weather: string;&#13;
    temp?: number;&#13;
};&#13;
&#13;
type responseItemType = {&#13;
    id: string;&#13;
    name: string;&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 5-16: The</span> <span class="Futura_Std_Book_11">custom.d.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We’ll use the custom interface <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherProps</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> argument of the page that displays the weather components, <i>components/weather</i>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp> is for the API route <i>api/weather/:zipcode</i>, which uses a dynamically fetched ZIP code. Finally, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp> in the API route <i>api/names</i> to type the fetch response.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h4 class="H2" id="sec23"><span id="h2-81"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the API Routes</samp></h4>&#13;
<p class="TNI">Next, we re-create the two API routes from the Express.js server. Earlier sections of this chapter showed this refactored code. For the <i>api/names</i> route, create a new file, <i>names.ts</i>, in the <i>api</i> folder, then add the code from <a href="chapter5.xhtml#Lis5-3">Listing 5-3</a>. Refer to that section for a detailed explanation of the code.</p>&#13;
<p class="TX">Migrate the dynamic route <i>api/weather/:zipcode</i> from the Express.js server to the Next.js application by creating a <i>[zipcode].js</i> file in the <i>api</i> folder and adding the code from <a href="chapter5.xhtml#Lis5-4">Listing 5-4</a>, shown in <span class="Xref">“Dynamic URLs” on page 77</span>. You can refer to that section for more details.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h4 class="H2" id="sec24"><span id="h2-82"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Page Routes</samp></h4>&#13;
<p class="TNI">Now we work on the pages. First, for the simple page <i>hello.tsx</i>, we create a new file in the <i>pages</i> folder and add the code from <a href="chapter5.xhtml#Lis5-10">Listing 5-10</a>. This code renders the <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp> example and uses the custom Next.js components <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>, all of which are explained in detail in <span class="Xref">“Built-in Next.js Components” on page 80</span>.</p>&#13;
<p class="TX">The second page is the nested route <i>pages/components/weather.tsx</i>. As before, we create a new file, <i>weather.tsx</i>, in a folder called <i>components</i>, within the <i>pages</i> folder. Add the code from <a href="chapter5.xhtml#Lis5-2">Listing 5-2</a>. This listing uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_91" aria-label=" Page 91. "/>and <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hooks to create a reactive user interface. We can remove the custom interface definition for the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherProps</samp> from this file. The <i>custom.d.ts</i> file already adds them to TSC.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h4 class="H2" id="sec25"><span id="h2-83"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Application</samp></h4>&#13;
<p class="TNI">Start the application with the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> command. Now you can visit the same routes we created for the Express.js server and see that they are functionally the same. Congratulations! You created your first Next.js-based full-stack application. Play around with the code and try using global and component CSS to style your pages.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h3 class="H1" id="sec26"><span id="h1-37"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">Next.js adds the missing functionality needed to create full-stack applications with React. After scaffolding a sample project and exploring the default file structure, you learned how to create page and API routes in the framework. You also learned about global- and component-level CSS, Next.js’s four built-in command line scripts, and its most useful custom components.</p>&#13;
<p class="TX">We also discussed the different ways to render content and pages with Next.js and when to choose each option. Finally, you used the code from this chapter to quickly migrate the Express.js application you built in the previous chapters to Next.js. To continue your adventures in this useful framework, I recommend the official tutorials at <a href="https://nextjs.org"><i>https://<wbr/>nextjs<wbr/>.org</i></a>.</p>&#13;
<p class="TX">In the next chapter, we’ll explore two types of web APIs: the standard RESTful APIs and modern GraphQL.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>