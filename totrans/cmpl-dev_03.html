<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch2">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch2">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_15" aria-label=" Page 15. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">MODERN JAVASCRIPT</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In <span class="chapterintro_Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, you used basic JavaScript to create a web server with Node.js. Now we’ll take a closer look at the language’s more advanced features and how you can effectively use them to create full-stack web applications.</p>&#13;
<p class="TX">You’ll sometimes hear the term <i>ES.Next</i> used to refer to new versions of JavaScript. In this book, we use ES.Next as a broad label for modern JavaScript and its concepts. Most runtime environments have implemented the features covered here. Otherwise, you can transpile them with Babel.js, creating backward-compatible JavaScript that emulates the new features for older runtimes.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-12"/><samp class="SANS_Futura_Std_Bold_B_11">ES.Next Modules</samp></h3>&#13;
<p class="TNI">ES.Next modules allow you to separate code into files to improve maintenance and testability. They encapsulate a piece of logic into easily reusable code, and because variables and functions are limited to the module’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_16" aria-label=" Page 16. "/>scope, you can use the same variable name in different modules without running into conflicts. (We discuss the concept of scopes in <span class="Xref">“Declaring Variables” on page 17</span>.)</p>&#13;
<p class="TX">The official ES.Next modules replaced various unofficial module formats, such as UMD and AMD, which you would load with a <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp> statement. For example, you used <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp> to include the Express.js package for the Node.js server code in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>. Instead, ES.Next modules use <samp class="SANS_TheSansMonoCd_W5Regular_11">export</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statements to export functions from one module’s scope and import them for use somewhere else. In other words, modules allow you to create functions and variables and expose them to a new scope.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-18"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Named and Default Exports</samp></h4>&#13;
<p class="TNI">There are two kinds of Next.js exports: <i>named</i> and <i>default</i>. These exports use slightly different syntaxes when you import them later. Default exports require you to define new function names on import. For named exports, renaming is optional and done with the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> statement.</p>&#13;
<p class="TX">It’s considered a best practice to use named exports over default exports, because named exports define a clear and unique interface for the module’s functionality. When we use default exports, the user risks importing the same function under different names. TypeScript, which we’ll cover in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, recommends that we use default exports if the module has one clear purpose and a single export. In contrast, it recommends using named exports whenever the module exports more than one item.</p>&#13;
<p class="TX">You should know the syntax of default exports so that you can work with third-party modules that use them. Unlike named exports, there can be only one default export per file, marked by the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> keyword (<a href="chapter2.xhtml#Lis2-1">Listing 2-1</a>).</p>&#13;
<span id="Lis2-1"/>&#13;
<pre class="pre-20"><code>const getFoo = function () {&#13;
    return 'foo';&#13;
};&#13;
&#13;
export default getFoo;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-1: Default exports</span></p>&#13;
<p class="TX">In this listing, we define an anonymous function and store it in the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">getFoo</samp>. Then we export the constant with the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> keyword to make it the module’s default export.</p>&#13;
<p class="TX">You can export named exports inline or at the end of the file, with curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>). <a href="chapter2.xhtml#Lis2-2">Listing 2-2</a> shows several named exports.</p>&#13;
<span id="Lis2-2"/>&#13;
<pre class="pre-21"><code>export const getFooBar = function () {&#13;
    return 'foo bar';&#13;
};&#13;
&#13;
const getBar = function () {&#13;
    return 'bar';&#13;
};&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_17" aria-label=" Page 17. "/>const getBaz = function () {&#13;
    return 'baz';&#13;
};&#13;
&#13;
export {getBar, getBaz};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-2: Named exports</span></p>&#13;
<p class="TX">Here we define an anonymous function, store it in the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">getFooBar</samp>, and immediately export it as <samp class="SANS_TheSansMonoCd_W5Regular_11">getFooBar</samp>. Then we define two more anonymous functions and export them as named exports in curly brackets.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-19"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Importing Modules</samp></h4>&#13;
<p class="TNI">The syntax to import an ES.Next module depends on the type of export you created. Named exports do need to be imported using curly brackets, whereas default exports do not. In <a href="chapter2.xhtml#Lis2-3">Listing 2-3</a>, we import the default export <samp class="SANS_TheSansMonoCd_W5Regular_11">getFoo</samp> by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statement followed by the local name we assign to it. Finally, we conclude the import with a reference to the file that contains the code.</p>&#13;
<span id="Lis2-3"/>&#13;
<pre class="pre-22"><code>import getFoo from "default.js";</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-3: Importing default exports</span></p>&#13;
<p class="TX">We follow a similar pattern for the named exports in <a href="chapter2.xhtml#Lis2-4">Listing 2-4</a>, except that we need to refer to the original function names inside curly brackets. To rename the functions locally, we would need to explicitly do so with an <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> statement, and there is usually no reason to do so.</p>&#13;
<span id="Lis2-4"/>&#13;
<pre class="pre-23"><code>import {getFooBar, getBar, getBaz} from "named.js";</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-4: Importing named exports</span></p>&#13;
<p class="TX">Now you can use the imported functions in your code, as they are available in the scope to which you imported them.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H1" id="sec4"><span id="h1-13"/><samp class="SANS_Futura_Std_Bold_B_11">Declaring Variables</samp></h3>&#13;
<p class="TNI">JavaScript offers three different ways to declare a variable: <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>. This section discusses the use cases for each of them. Often, you’ll be given the advice to avoid <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> because it is “outdated.” You can rest assured that it’s not, and you must understand each of these variable declaration methods in order to choose the right tool for the job.</p>&#13;
<p class="TX">These variables differ in their <i>scope</i>, which defines the code area in which we can access and use them. JavaScript has multiple levels of scope: global, module, function, and block. <i>Block</i> scope, which applies to any block of code enclosed in curly brackets, is the smallest unit of scope. Every time you use curly brackets, you create a new block scope. In comparison, you make a <i>function</i> scope when you define a function. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_18" aria-label=" Page 18. "/>The scope is limited to the code area inside a specific function. The <i>module</i> scope applies only to a specific module, whereas the <i>global</i> scope applies to the entire program. Variables defined in the global scope are available in every part of your code.</p>&#13;
<p class="TX">As you’ll see in the following code listings, a variable is always available in its own scope and all of its child scopes. Hence, you should remember that, for example, a function scope can contain multiple block scopes. The same variable name can be defined twice in one program as long as each variable occurs in different scopes.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-20"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hoisted Variables</samp></h4>&#13;
<p class="TNI">Traditional JavaScript declares variables with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword. The scope of these variables is the current execution context (usually the enclosing function). If declared outside any function, the variable’s scope is global, and the variable creates a property on the global object.</p>&#13;
<p class="TX">Unlike for all other variables, the runtime environment moves, or <i>hoists</i>, the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> to the top of its scope upon execution. Therefore, you can call these variables in your code before you define them. <a href="chapter2.xhtml#Lis2-5">Listing 2-5</a> shows a short example of hoisting.</p>&#13;
<span id="Lis2-5"/>&#13;
<pre class="pre-24"><code>function scope() {&#13;
    foo = 1;&#13;
    var foo;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-5: Using a hoisted variable before it is defined</span></p>&#13;
<p class="TX">In this listing, we assign a value to a variable before declaring it in the following line. In languages like Java and C, we can’t use variables before we declare them, and any attempt to do so will throw an error. However, because of hoisting in JavaScript, the parser moves all variable declarations defined with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword to the top of the scope. Thus, the code is equivalent to that in <a href="chapter2.xhtml#Lis2-6">Listing 2-6</a>.</p>&#13;
<span id="Lis2-6"/>&#13;
<pre class="pre-25"><code>function scope() {&#13;
    var foo;&#13;
    foo = 1;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-6: Defining a variable before using it</span></p>&#13;
<p class="TX">Because of hoisting, block scope does not apply to variables declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword. They are always hoisted. To illustrate this, take a look at <a href="chapter2.xhtml#Lis2-7">Listing 2-7</a>, where we declare a global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>, a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> inside the function scope, and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> inside a block scope, all with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_19" aria-label=" Page 19. "/>&#13;
<span id="Lis2-7"/>&#13;
<pre class="pre-26"><code>var globalVar = "global";&#13;
function scope() {&#13;
    var foo = "1";&#13;
    if (true) {&#13;
        var bar = "2";&#13;
    }&#13;
    console.log(globalVar);&#13;
    console.log(window.globalVar);&#13;
    console.log(foo);&#13;
    console.log(bar);&#13;
}&#13;
scope();&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-7: The scope of</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">var</samp></p>&#13;
<p class="TX">We run the <samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp> function and see that <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">window.globalVar</samp> are the same; the parser hoists both variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>, to the top of the function scope. Thus, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> is available outside the block scope, and the function scope writes both variables’ values, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, to the console.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-21"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Scope-Abiding Variables</samp></h4>&#13;
<p class="TNI">Modern JavaScript introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp> keyword to supplement <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>. With <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>, we can declare variables that are block-scoped and can be accessed only after they have been declared. For this reason, they are considered <i>non-hoisted</i> variables. Block-scoped variables are limited to the scope of the block statement inside which they are defined. Unlike global variables defined with <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>, a global <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp> variable isn’t added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">window</samp> object.</p>&#13;
<p class="TX">Let’s look at the scope of a variable declared with <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>. In <a href="chapter2.xhtml#Lis2-8">Listing 2-8</a>, we declare a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> inside a function scope, a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> inside a block scope, and a global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>.</p>&#13;
&#13;
<span id="Lis2-8"/>&#13;
<pre class="pre-27"><code>let globalVar = "global";&#13;
function scope() {&#13;
    let foo = "1";&#13;
    if (true) {&#13;
        let bar = "2";&#13;
    }&#13;
    console.log(globalVar);&#13;
    console.log(window.globalVar);&#13;
    console.log(foo);&#13;
    console.log(bar);&#13;
}&#13;
scope();&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-8: The scope of</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">let</samp></p>&#13;
<p class="TX">Each variable is available only in its respective scope. The parser does not hoist them, and therefore, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> is not available outside the block statement. If you try to reference it elsewhere, the parser will throw an error and notify you that <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> is not defined.</p>&#13;
<p class="TX">We execute the function, and unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> code, it writes only the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> to the console. When we try to access <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>, we receive an error, <samp class="SANS_TheSansMonoCd_W5Regular_11">Uncaught ReferenceError: bar is not defined</samp>. For <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>, we see the value <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> printed on the console, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">window.globalVar</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">undefined</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-22"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_20" aria-label=" Page 20. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant-Like Data</samp></h4>&#13;
<p class="TNI">Modern JavaScript introduced another new keyword, <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>, for declaring constants such as data types. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> does not create properties of the global object when declared globally. They, too, are considered non-hoisted, as they cannot be accessed before being declared.</p>&#13;
<p class="TX">Constants in JavaScript are different from those in many other languages, where they function as immutable data types. In JavaScript, constants only <i>look</i> immutable. In fact, they are read-only references to their value. Therefore, you cannot directly reassign another value to the variable identifier for primitive data types. However, objects or arrays are non-primitive data types, so even when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>, you can mutate their values through methods or direct property access.</p>&#13;
<p class="TX">In <a href="chapter2.xhtml#Lis2-9">Listing 2-9</a>, we declare both a primitive and a non-primitive data type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> keyword and try to change their content.</p>&#13;
<span id="Lis2-9"/>&#13;
<pre class="pre-28"><code>const primitiveDataType = 1;&#13;
try {&#13;
    primitiveDataType = 2;&#13;
} catch (err) {&#13;
    console.log(err);&#13;
}&#13;
&#13;
const nonPrimitiveDataType = [];&#13;
nonPrimitiveDataType.push(1);&#13;
&#13;
console.log(nonPrimitiveDataType);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-9: Using</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">const</samp> <span class="Futura_Std_Book_Oblique_BI_11">to declare primitive and non-primitive types</span></p>&#13;
<p class="TX">We declare and assign a value to two constant-like data structures. Now when we try to reassign a value to the primitive data structure, the runtime throws the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Attempted to assign to readonly property</samp>. Because we used <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>, we cannot reassign its value. In contrast, we can modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">nonPrimitiveDataType</samp> array (done here with the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> method) and append a value without running into an error. The array should now contain one item with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>; hence, we see <samp class="SANS_TheSansMonoCd_W5Regular_11">[1]</samp> in the console.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H1" id="sec8"><span id="h1-14"/><samp class="SANS_Futura_Std_Bold_B_11">Arrow Functions</samp></h3>&#13;
<p class="TNI">Modern JavaScript introduced arrow functions as alternatives to regular functions. There are two concepts you need to know about arrow functions. First, they use a different syntax than regular functions. Defining an arrow function is much quicker, requiring just a few characters and one line of code. The second important, but not so obvious, change is that they use something called a lexical scope, making them more intuitive and less error prone.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H2" id="sec9"><span id="h2-23"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_21" aria-label=" Page 21. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing Arrow Functions</samp></h4>&#13;
<p class="TNI">Instead of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">function</samp> keyword to declare an arrow function, we use the equal-to and greater-than signs to form an arrow (<samp class="SANS_TheSansMonoCd_W5Regular_11">=&gt;</samp>). This syntax, also called the <i>fat arrow</i>, reduces noise and results in more compact code. Therefore, modern JavaScript prefers this syntax when passing functions as arguments.</p>&#13;
<p class="TX">In addition, if an arrow function has only one parameter and one statement, we can omit the curly brackets and the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword. In this compact form, we call the function a <i>concise body</i> function. <a href="chapter2.xhtml#Lis2-10">Listing 2-10</a> shows the definition of a traditional function followed by an arrow function.</p>&#13;
<span id="Lis2-10"/>&#13;
<pre class="pre-29"><code>const traditional = function (x) {&#13;
    return x * x;&#13;
}&#13;
&#13;
const conciseBody = x =&gt; x * x;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-10: A traditional function and an arrow function with the concise body syntax</span></p>&#13;
<p class="TX">We first define a standard function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">function</samp> keyword and familiar <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. Then we write the same functionality as an arrow function with the concise body syntax. Here we omit the curly brackets and use an implied <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, without the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-24"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding Lexical Scope</samp></h4>&#13;
<p class="TNI">Unlike regular functions, arrow functions do not bind their scope to the object that calls the function. Instead, they use a <i>lexical scope</i>, in which the surrounding scope determines the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> keyword. Therefore, the scope to which <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> refers in an arrow function always represents the object <i>defining</i> the arrow function instead of the object <i>calling</i> the function. <a href="chapter2.xhtml#Lis2-11">Listing 2-11</a> illustrates the concepts of lexical and defining scopes.</p>&#13;
<span id="Lis2-11"/>&#13;
<pre class="pre-30"><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> this.scope = "lexical scope";&#13;
&#13;
const scopeOf = {&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> scope: "defining scope",&#13;
&#13;
    traditional: function () {&#13;
      <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> return this.scope;&#13;
    },&#13;
&#13;
    arrow: () =&gt; {&#13;
        return this.scope;&#13;
    },&#13;
};&#13;
&#13;
console.log(scopeOf.traditional());&#13;
console.log(scopeOf.arrow());&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-11: An arrow function’s scope</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_22" aria-label=" Page 22. "/>We first declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp> property on the lexical scope <span class="AnnotationCode" aria-label="annotation1">❶</span>; this is the defining object. Then we create an object with a property of the same name inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">defining scope</samp> <span class="AnnotationCode" aria-label="annotation2">❷</span>. Next, we define two functions, both of which use <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> to return the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">this.scope</samp> <span class="AnnotationCode" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Upon calling them, you can see the difference between the two references. Whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">this.scope</samp> in the arrow function refers to the property defined in the lexical scope, the traditional function’s <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> refers to the second property we defined. Consequently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">scopeOf.traditional</samp> function outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">defining scope</samp>, whereas the <samp class="SANS_TheSansMonoCd_W5Regular_11">scopeOf.arrow</samp> function outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">lexical scope</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-25"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Practical Use Cases</samp></h4>&#13;
<p class="TNI">Because functions are first-class citizens in JavaScript, we can pass them as arguments to other functions. In <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, you used this pattern to define callbacks in Node.js or previously when you worked with event handlers in the browser. But when you use regular functions as callbacks, the code quickly gets cluttered with function statements and curly brackets, even if the actual code in the callback is quite simple. Arrow functions allow for a clean and simple syntax in callbacks. In <a href="chapter2.xhtml#Lis2-12">Listing 2-12</a>, we use a callback on the array <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp> method and define it as a traditional function and as an arrow function.</p>&#13;
<span id="Lis2-12"/>&#13;
<pre class="pre-31"><code>let numbers = [-2, -1, 0, 1, 2];&#13;
&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">let traditional = numbers.filter(function(num) {</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">      return num &gt;= 0;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    }</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">);</samp>&#13;
&#13;
let arrow = numbers.filter(num =&gt; num &gt;= 0);&#13;
&#13;
console.log(traditional);&#13;
console.log(arrow);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-12: Passing a fat arrow function as a parameter</span></p>&#13;
<p class="TX">The first version of the callback is a traditional function, whereas the second implementation uses an arrow function with a concise body syntax. Both return the same array: <samp class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2]</samp>. We see that the actual functionality, to remove all negative numbers from the array, is a simple check to see if the current item is greater than or equal to zero. The traditional function is harder to understand, as it requires additional characters. Once you fully grasp the arrow syntax, you’ll enhance the readability of your code and, in turn, improve the code quality.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H1" id="sec12"><span id="h1-15"/><samp class="SANS_Futura_Std_Bold_B_11">Creating Strings</samp></h3>&#13;
<p class="TNI">Modern JavaScript introduces untagged and tagged template literals. <i>Template literals</i> are a simple way to add variables and expressions to a string. This string <span role="doc-pagebreak" epub:type="pagebreak" id="pg_23" aria-label=" Page 23. "/>interpolation can span multiple lines and include single and double quotation marks without requiring escaping. We enclose template literals in backticks (<samp class="SANS_TheSansMonoCd_W5Regular_11">`</samp>) and indicate a variable or expression in the template by using a dollar sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>) and curly brackets.</p>&#13;
<p class="TX">An <i>untagged</i> template literal is just a string enclosed in backticks. The parser interpolates the variables and expressions and returns a string. As a full-stack developer, you’ll use this pattern every time you want to add variables to a string or concatenate multiple strings. <a href="chapter2.xhtml#Lis2-13">Listing 2-13</a> shows an example of an untagged template literal. They can span multiple lines without the need for any control characters.</p>&#13;
<span id="Lis2-13"/>&#13;
<pre class="pre-32"><code>let a = 1;&#13;
let b = 2;&#13;
let string = `${a} + ${b} = ${a + b}`;&#13;
console.log(string);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-13: An untagged template literal</span></p>&#13;
<p class="TX">The parser will substitute the placeholders and evaluate the expression in the template literal to the string <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.</p>&#13;
<p class="TX">As soon as an expression precedes a template literal, it becomes <i>tagged</i>. In these cases, the function receives both a template literal and the substitution values as arguments and then performs an action with both of them before returning a value. This returned value can be of any primitive or non-primitive type. In <a href="chapter2.xhtml#Lis2-14">Listing 2-14</a>, we use a tagged template literal with a custom function to add or subtract numbers and explain the process using words.</p>&#13;
<span id="Lis2-14"/>&#13;
<pre class="pre-33"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">function tag(literal, ...values) {</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    console.log("literal", literal);</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    console.log("values", values);</samp>&#13;
&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    let result;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">switch (literal[1]) {</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">        case " plus ":</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">            result = values[0] + values[1];</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">            break;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">        case " minus ":</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">            result = values[0] - values[1];</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">            break;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    }</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    return `${values[0]}${literal[1]}${values[1]} is ${result}`;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>&#13;
&#13;
let a = 1;&#13;
let b = 2;&#13;
let output = tag`What is ${a} plus ${b}?`;&#13;
&#13;
console.log(output);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-14: A basic tagged template literal</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_24" aria-label=" Page 24. "/>Here the parser calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">tag</samp> expression and then passes the template literal and substitution values as arguments to the function. The function constructs a string from the parameters and returns it.</p>&#13;
<p class="TX">Let’s take a deeper look at our code. In our <samp class="SANS_TheSansMonoCd_W5Regular_11">tag</samp> expression, the first argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">literal</samp>, is an array that is split at the variables, like this: <samp class="SANS_TheSansMonoCd_W5Regular_11">['What is ', ' minus ', '?']</samp>. The argument <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> is also an array, and it contains the values of the template literal variables we passed to the function: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2]</samp>. We use a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">switch/case</samp> statement to calculate the result based on the literal and values. Finally, we return a new string with the answer to the “question” and see <samp class="SANS_TheSansMonoCd_W5Regular_11">1 plus 2 is 3</samp> on the console.</p>&#13;
<p class="TX">With their simple interface for complex string substitutions, tagged template literals provide an elegant way to create a <i>domain-specific language (DSL)</i> in JavaScript. A DSL is a language targeted to solve a particular task in a particular domain. It’s in contrast to a general-purpose language, such as JavaScript, which we can use to solve a wide array of software-related problems. A familiar example of a DSL is HTML, which we use in the web development domain to mark up text but which we cannot use for mathematical operations or reading file contents. You will define your own DSL for full-stack development with GraphQL schemas. When you define your first GraphQL schema in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, you’ll understand that its DSL is nothing more than a tagged template literal.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H1" id="sec13"><span id="h1-16"/><samp class="SANS_Futura_Std_Bold_B_11">Asynchronous Scripts</samp></h3>&#13;
<p class="TNI">JavaScript is single-threaded, which means that it can run only one task at a time. Therefore, long-running tasks can block the application. A simple solution is <i>asynchronous</i> programming, a pattern where you start a long-running task without blocking the whole application. While your script waits for a result, the rest of the application can still respond to interactions or user interface events and perform other calculations.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-26"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Avoiding Traditional Callbacks</samp></h4>&#13;
<p class="TNI">Traditional JavaScript implements asynchronous code with callback functions executed after another function returns a result. You’ve probably already used callbacks when your code has needed to react to an event instead of running immediately. One common use case for this technique in full-stack web development is performing I/O operations in Node.js or calling remote APIs. <a href="chapter2.xhtml#Lis2-15">Listing 2-15</a> provides an example of an I/O operation. We import the Node.js <samp class="SANS_TheSansMonoCd_W5Regular_11">fs</samp> module, which handles filesystem operations, and use a callback function to display the file’s contents as soon as the operation concludes.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_25" aria-label=" Page 25. "/>&#13;
<span id="Lis2-15"/>&#13;
<pre class="pre-34"><code>const fs = require("fs");&#13;
&#13;
const callback = (err, data) =&gt; {&#13;
    if (err) {&#13;
        return console.log("error");&#13;
    }&#13;
    console.log(`File content ${data}`);&#13;
};&#13;
&#13;
fs.readFile(" file.txt", callback);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-15: Reading a file in Node.js with a callback function</span></p>&#13;
<p class="TX">Reading a file is a common example of asynchronous scripting. We don’t want the application to be blocked while waiting for the file content to be ready; however, we also need to use the file’s content in a specific part of the application.</p>&#13;
<p class="TX">Here we create the callback function and pass it as a parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fs.readFile</samp> function. This function reads a file from the filesystem and executes the callback as soon as the I/O operation fails or succeeds. The callback receives the file data and an optional error object, which we write to the console for now.</p>&#13;
<p class="TX">Callbacks are a clumsy solution to asynchronous scripting. As soon as you have multiple dependent callback functions, you end up in so-called callback hell, where every callback function takes another callback function as an argument. The result is a pyramid of functions that are difficult to read and prone to errors. Modern JavaScript introduced promises and <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> as an alternative to callbacks.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-27"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Promises</samp></h4>&#13;
<p class="TNI"><i>Promises</i> provide a much cleaner syntax for chainable asynchronous tasks. Similar to callbacks, they defer further tasks until a previous action has completed or failed. Essentially, promises are function calls that do not return an immediate result. Instead, they promise to return the result at some later point. If there is an error, the promise is rejected instead of resolved.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp> object has two properties: the state and the result. When the state is pending, the result is undefined. However, as soon as the promise resolves, the state changes to fulfilled, and the result reflects the return value. If the promise is rejected instead, the state is also set to rejected, and the result contains an error object.</p>&#13;
<p class="TX">Promises follow a unique syntax. To use them, you first create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp> or call a function that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp>. Then you consume the <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp> object, and finally you clean up. This is done by registering the consuming functions <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp>. The promise initially calls <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> as soon as the state changes from pending to fulfilled and passes the returned data to it. Each following <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> method receives the return value of the previous one, allowing you to create a single task chain that works with and manipulates these return values.</p>&#13;
<p class="TX">The promise chain invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp> method only if an error occurs either initially or later in the chain of tasks. In addition, a state change (of this particular promise) to <samp class="SANS_TheSansMonoCd_W5Regular_11">rejected</samp> also invokes it. In any case, the parser calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp> method after the stack of <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> methods has completed or the <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp> method was invoked. You use the <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp> method for cleanup tasks <span role="doc-pagebreak" epub:type="pagebreak" id="pg_26" aria-label=" Page 26. "/>such as unlocking the user interface or closing database connections. It’s similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp> call of a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> statement.</p>&#13;
<p class="TX">You can use promises in any function. In <a href="chapter2.xhtml#Lis2-16">Listing 2-16</a>, we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API to request JSON data.</p>&#13;
<span id="Lis2-16"/>&#13;
<pre class="pre-35"><code>function fetchData(url) {&#13;
    fetch(url)&#13;
        .then((response) =&gt; response.json())&#13;
        .then((json) =&gt; console.log(json))&#13;
        .catch((error) =&gt; {&#13;
            console.error(`Error : ${error}`);&#13;
        });&#13;
}&#13;
fetchData("https://www.usemodernfullstack.dev/api/v1/users");&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-16: Fetching remote data with promises</span></p>&#13;
<p class="TX">Like I/O operations on the filesystem, network requests are long-running tasks that block the application. Therefore, we should use asynchronous patterns to load remote datasets. As in <a href="chapter2.xhtml#Lis2-15">Listing 2-15</a>, we need to wait until the operation is complete before we can process the requested data or handle an error.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API is promise-based by default. As soon as the promise resolves and the state changes to fulfilled, the following <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> function receives the response object. We then parse the data and pass the JSON object to the next function in the <i>promise chain</i>, a sequence of functions connected with a dot (<samp class="SANS_TheSansMonoCd_W5Regular_11">.then</samp>). If there is an error, the promise is rejected. In this case, we <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp> the error and write it to the console.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2" id="sec16"><span id="h2-28"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simplifying Asynchronous Scripts</samp></h4>&#13;
<p class="TNI">Modern JavaScript introduces a new, simpler pattern for handling asynchronous requests: the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> keywords. Instead of relying on chained functions, we can write code whose structure is similar to regular synchronous code by employing these keywords.</p>&#13;
<p class="TX">When using this pattern, you mark functions explicitly as asynchronous with <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>. Then you use <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> instead of the promise-based syntax for your asynchronous code. In <a href="chapter2.xhtml#Lis2-17">Listing 2-17</a>, we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API with <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> to perform another long-running task and fetch JSON data from a remote location. This code is functionally the same as <a href="chapter2.xhtml#Lis2-16">Listing 2-16</a>, and you should see that its syntax is more intuitive and cleaner than the chain of <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> calls.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_27" aria-label=" Page 27. "/>&#13;
<span id="Lis2-17"/>&#13;
<pre class="pre-36"><code>async function fetchData (url) {&#13;
    try {&#13;
        const response = await fetch(url);&#13;
        const json = await response.json();&#13;
        console.log(json);&#13;
    } catch (error) {&#13;
        console.error(`Error : ${error}`);&#13;
    }&#13;
}&#13;
&#13;
fetchData("https://www.usemodernfullstack.dev/api/v1/users");&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-17: Fetching remote data with</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">async</samp><span class="Futura_Std_Book_Oblique_BI_11">/</span><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">await</samp></p>&#13;
<p class="TX">First we declare the function as <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp> to enable the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> keyword inside the function. Then we use <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> to wait for the response of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> call. Unlike the promise syntax we used before, <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> simplifies the code. It awaits the response object and returns it. Thus, the code block looks similar to regular synchronous code.</p>&#13;
<p class="TX">This pattern requires us to handle errors manually. Unlike with promises, there is no default reject function. Therefore, we must wrap <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> statements in a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> block to handle error states gracefully.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H1" id="sec17"><span id="h1-17"/><samp class="SANS_Futura_Std_Bold_B_11">Looping Through an Array</samp></h3>&#13;
<p class="TNI">Modern JavaScript introduced a whole set of new array functions. The most important one for full-stack web development is <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>. It allows us to run a function on each array item and return a new array with the modified items, preserving the original array. Developers commonly use it in React to generate a list or populate JSX with datasets from arrays. You will use this pattern extensively once we introduce React in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>.</p>&#13;
<p class="TX">In <a href="chapter2.xhtml#Lis2-18">Listing 2-18</a>, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp> to iterate over an array of numbers and create an arrow function as a callback.</p>&#13;
<span id="Lis2-18"/>&#13;
<pre class="pre-37"><code>const original = [1,2,3,4];&#13;
const multiplied = original.map((item) =&gt; item * 10);&#13;
console.log(`original array: ${original}`);&#13;
console.log(`multiplied array: ${multiplied}`);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-18: Using</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">array.map</samp> <span class="Futura_Std_Book_Oblique_BI_11">to manipulate each item of an array</span></p>&#13;
<p class="TX">We iterate over the array items and pass each of them to the callback function. Here we multiply each item by 10, and then <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp> returns an array with the multiplied items.</p>&#13;
<p class="TX">When we log the initial array and the returned array, we see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp> array still contains the actual, unchanged numbers (<samp class="SANS_TheSansMonoCd_W5Regular_11">1,2,3,4</samp>). Only the <samp class="SANS_TheSansMonoCd_W5Regular_11">multiplied</samp> array contains the new, modified items (<samp class="SANS_TheSansMonoCd_W5Regular_11">10,20,30,40</samp>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h3 class="H1" id="sec18"><span id="h1-18"/><samp class="SANS_Futura_Std_Bold_B_11">Dispersing Arrays and Objects</samp></h3>&#13;
<p class="TNI">Modern JavaScript’s spread operator is written as three dots (<samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>). It <i>spreads out</i>, or expands, the values of an array or the properties of an object into their own variables or constants.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_28" aria-label=" Page 28. "/>Technically, the spread operator copies its content to variables that allocate their own memory. In <a href="chapter2.xhtml#Lis2-19">Listing 2-19</a>, we use the spread operator to assign the multiple values of an object to several constants. You’ll use this pattern in nearly all React code to access component properties.</p>&#13;
<span id="Lis2-19"/>&#13;
<pre class="pre-38"><code>let object = {fruit: "apple", color: "green"};&#13;
let {fruit, color} = {...object};&#13;
&#13;
console.log(`fruit: ${fruit}, color: ${color}`);&#13;
&#13;
color = "red";&#13;
console.log(`object.color: ${object.color}, color: ${color}`);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-19: Dispersing an object into constants with the spread operator</span></p>&#13;
<p class="TX">We first create an object with two properties, <samp class="SANS_TheSansMonoCd_W5Regular_11">fruit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>. Then we use the spread operator to expand the object into variables and log them to the console. The variables’ names are the same as the object properties’ names. However, we can now access the values directly from the variables instead of referring to the object. We do so in the template literal and see <samp class="SANS_TheSansMonoCd_W5Regular_11">fruit: apple, color: green</samp> as the console output.</p>&#13;
<p class="TX">Also, as these variables allocate their own memory, they are complete clones. Therefore, modifying the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp> won’t change the original value: <samp class="SANS_TheSansMonoCd_W5Regular_11">object.color</samp> still returns <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp> when we log both variables to the console.</p>&#13;
<p class="TX">Using the spread operator to clone an array or object is useful because JavaScript treats arrays as references to its values. When you assign an array or object to a new variable or constant, this merely copies the reference to the original; it does not clone the array or object by allocating memory. Therefore, changing the copy also changes the original. Using spread instead of the equals operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) allocates memory and keeps no reference to the original value. Hence, it’s an excellent solution for cloning an array or object, as shown in <a href="chapter2.xhtml#Lis2-20">Listing 2-20</a>.</p>&#13;
<span id="Lis2-20"/>&#13;
<pre class="pre-39"><code>let originalArray = [1,2,3];&#13;
let clonedArray = [...originalArray];&#13;
&#13;
clonedArray[0] = "one";&#13;
clonedArray[1] = "two";&#13;
clonedArray[2] = "three";&#13;
&#13;
console.log (`originalArray: ${originalArray}, clonedArray: ${clonedArray}`);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-20: Cloning an array with the spread operator</span></p>&#13;
<p class="TX">Here we use the spread operator to copy the values from the original array to the cloned array in the same operation. Then we modify the cloned array’s items. Finally, we write the two arrays to the console and see that the original array differs from the cloned array.</p>&#13;
<p class="HeadProject"><span id="Exe2"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_29" aria-label=" Page 29. "/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 2: Extend Express.js with Modern JavaScript</samp></p>&#13;
<p class="TNI">Modern JavaScript provides the tools you need to write clean and efficient code. In <span class="Xref"><a href="part2.xhtml">Part II</a></span>, you’ll use it in the Food Finder application. For now, let’s apply your new knowledge to optimize the simple Express.js server you created in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2" id="sec19"><span id="h2-29"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Editing the package.json File</samp></h4>&#13;
<p class="TNI">We’ll replace the server’s <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp> call with named modules for different routes. To do so, we need to explicitly specify that our project uses native modules. Otherwise, Node.js will throw an error. Modify your <i>package.json</i> file so that it looks like <a href="chapter2.xhtml#Lis2-21">Listing 2-21</a>.</p>&#13;
<span id="Lis2-21"/>&#13;
<pre class="pre-40"><code>{&#13;
    "name": "sample-express",&#13;
    "version": "1.0.0",&#13;
    "description": "sample express server",&#13;
    "license": "ISC",&#13;
    <b>"type": "module",</b>&#13;
    "dependencies": {&#13;
        "express":"^4.18.2",&#13;
        <b>"node-fetch": "^3.2.6"</b>&#13;
    },&#13;
    "devDependencies": {}&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-21: The modified</span> <span class="Futura_Std_Book_11">package.json</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">Add the property <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">module</samp>. Also, you’ll want to install the <i>node-fetch</i> package to make an asynchronous API call in one of your routes. Run <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install node-fetch</samp> to do so.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h4 class="H2" id="sec20"><span id="h2-30"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing an ES.Next Module with Asynchronous Code</samp></h4>&#13;
<p class="TNI">Create the file <i>routes.js</i> in the <i>sample-express</i> folder, next to the <i>index.js</i> file, and add the code in <a href="chapter2.xhtml#Lis2-22">Listing 2-22</a>.</p>&#13;
<span id="Lis2-22"/>&#13;
<pre class="pre-41"><code>import fetch from "node-fetch";&#13;
&#13;
const routeHello = () =&gt; "Hello World!";&#13;
&#13;
const routeAPINames = async () =&gt; {&#13;
    const url = "https://www.usemodernfullstack.dev/api/v1/users";&#13;
    let data;&#13;
    try {&#13;
        const response = await fetch(url);&#13;
        data = await response.json();&#13;
    } catch (err) {&#13;
        return err;&#13;
    }&#13;
    const names = data&#13;
        .map((item) =&gt; `id: ${item.id}, name: ${item.name}`)&#13;
        .join("&lt;br&gt;");&#13;
    return names;&#13;
};&#13;
&#13;
export {routeHello, routeAPINames};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-22: The</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">route</samp> <span class="Futura_Std_Book_Oblique_BI_11">module in the</span> <span class="Futura_Std_Book_11">routes.js</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">First we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> module for making asynchronous requests. Then we create the first route, for our existing <i>/hello</i> endpoint. Its behavior should be the same as before; using a fat arrow function with a concise body syntax, it returns the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp></p>&#13;
<p class="TX">Next, we create a route for a new <i>/api/names</i> endpoint. This endpoint will add a page to our web server displaying a list of usernames and IDs. But first we explicitly define an <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp> function so that we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> syntax for our <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> call. Then we define the API endpoint in a constant and another variable to store asynchronous data. We need to define these before we use them because the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> calls happen inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> block, and these variables are block-scoped. If we defined them inside the block, we wouldn’t be able to use them later.</p>&#13;
<p class="TX">We call the API and await the response data, which we convert to JSON as soon as the call succeeds. The <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> variable now holds an array of objects. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp> to iterate over the data and create the strings we want to display. Then we join all array items with break tags (<samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;br&gt;</samp>) to display them in rows and return the string.</p>&#13;
<p class="TX">Finally, we export the two routes under their names.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h4 class="H2" id="sec21"><span id="h2-31"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Modules to the Server</samp></h4>&#13;
<p class="TNI">Modify the file <i>index.js</i> in the <i>sample-express</i> folder to match <a href="chapter2.xhtml#Lis2-23">Listing 2-23</a>. We use native modules for importing the <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp> module and the routes we created in <a href="chapter2.xhtml#Lis2-22">Listing 2-22</a>.</p>&#13;
<span id="Lis2-23"/>&#13;
<pre class="pre-42"><code><b>import {routeHello, routeAPINames} from "./routes.js";</b>&#13;
<b>import express from "express";</b>&#13;
&#13;
const server = express();&#13;
const port = 3000;&#13;
&#13;
server.get("/hello", function (req, res) {&#13;
    <b>const response = routeHello(req, res);</b>&#13;
    res.send(response);&#13;
});&#13;
&#13;
server.get("/api/names", <b>async</b> function (req, res) {&#13;
    let response;&#13;
    try {&#13;
        <b>response = await routeAPINames(req, res);</b>&#13;
    } catch (err) {&#13;
        console.log(err);&#13;
    }&#13;
    res.send(response);&#13;
});&#13;
&#13;
server.listen(port, function () {&#13;
    console.log("Listening on " + port);&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 2-23: The basic Express.js server with modern JavaScript</span></p>&#13;
<p class="TX">First we import <samp class="SANS_TheSansMonoCd_W5Regular_11">routes</samp> with the syntax for named imports. Then we replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp> call for the <i>express</i> package with an <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statement. The <i>/hello</i> endpoint we created earlier calls the route we imported, and the server sends <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp> as the response to the browser.</p>&#13;
<p class="TX">Finally, we create a new endpoint, <i>/api/names</i>, that contains asynchronous code. Therefore, we mark the handler as <i>async</i> and await the route inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> block.</p>&#13;
<p class="TX">Start the server from your command line:</p>&#13;
&#13;
<pre class="pre-43"><code>$ <b>node index.js</b>&#13;
Listening on 3000&#13;
</code></pre>&#13;
<p class="TX">Now visit <i>http://localhost:3000/api/names</i> in your browser, as shown in <a href="#fig2-1">Figure 2-1</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig2-1" src="../images/Figure2-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 2-1: The response the browser receives from the Node.js web server</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You should see the new list of user IDs and names.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h3 class="H1" id="sec22"><span id="h1-19"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">This chapter taught you enough modern JavaScript and ES.Next to create a full-stack application. We covered how to use JavaScript modules to create maintainable packages and import and export code, the different ways to declare variables and constants, the arrow function, and tagged and untagged template literals. We wrote asynchronous code with promises and <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>. We also covered <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>, the spread operator, and their usefulness for your full-stack code. Finally, you used your new knowledge to update the sample Node.js server from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> with modern JavaScript concepts.</p>&#13;
<p class="TX">Modern JavaScript has many more features than this chapter covers. From the freely available resources, I recommend the JavaScript tutorials at <a href="https://www.javascripttutorial.net"><i>https://<wbr/>www<wbr/>.javascripttutorial<wbr/>.net</i></a>.</p>&#13;
<p class="TX">In the next chapter, we cover TypeScript, a superset of JavaScript with support for types.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>