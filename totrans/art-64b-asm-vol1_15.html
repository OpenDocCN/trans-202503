<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="747" id="Page_747"/>13</span><br/>
<span class="ChapterTitle">Macros and the MASM Compile-Time Language</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This chapter discusses the MASM compile-time language, including the very important <em>macro expansion facilities</em>. A <em>macro</em> is an identifier that the assembler will expand into additional text (often many lines of text), allowing you to abbreviate large amounts of code with a single identifier. MASM’s macro facility is actually a <em>computer language inside a computer language</em>; that is, you can write short little programs inside a MASM source file whose purpose is to generate other MASM source code to be assembled by MASM. </p>
<p>This <em>language inside a language</em>, also known as a <em>compile-time language</em>, consists of macros (the compile-time language equivalent of a procedure), conditionals (<code>if</code> statements), loops, and other statements. This chapter covers many of the MASM compile-time language features and shows how you can use them to reduce the effort needed to write assembly language code.</p>
<h2 id="h1-501089c13-0001"><span epub:type="pagebreak" title="748" id="Page_748"/>	13.1	Introduction to the Compile-Time Language</h2>
<p class="BodyFirst">MASM is actually two languages rolled into a single program. The <em>runtime language</em> is the standard x86-64/MASM assembly language you’ve been reading about in all the previous chapters. This is called the runtime language because the programs you write execute when you run the executable file. MASM contains an interpreter for a second language, the MASM <em>compile-time language (CTL)</em>. MASM source files contain instructions for both the MASM CTL and the runtime program, and MASM executes the CTL program during assembly (compilation). Once MASM completes assembly, the CTL program terminates (see <a href="#figure13-1" id="figureanchor13-1">Figure 13-1</a>).</p>
<figure>
<img src="image_fi/501089c13/f13001.png" alt="f13001" class=""/>
<figcaption><p><a id="figure13-1">Figure 13-1</a>: Compile-time versus runtime execution</p></figcaption>
</figure>
<p>The CTL application is not a part of the runtime executable that MASM emits, although the CTL application can <em>write </em>part of the runtime program for you, and, in fact, this is the major purpose of the CTL. Using automatic code generation, the CTL gives you the ability to easily and elegantly emit repetitive code. By learning how to use the MASM CTL and applying it properly, you can develop assembly language applications as rapidly as high-level language applications (even faster because MASM’s CTL lets you create very high-level-language constructs).</p>
<h2 id="h1-501089c13-0002">	13.2	The echo and .err Directives</h2>
<p class="BodyFirst">You may recall that <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span> began with the typical first program most people write when learning a new language, the “Hello, world!” program. <a href="#listing13-1" id="listinganchor13-1">Listing 13-1</a> provides the basic “Hello, world!” program written in the MASM compile-time language.</p>
<pre><code>; Listing 13-1
 
; CTL "Hello, world!" program.

<span epub:type="pagebreak" title="749" id="Page_749"/>echo    Listing 13-1: Hello, world!
end</code></pre>
<p class="CodeListingCaption"><a id="listing13-1">Listing 13-1</a>: The CTL “Hello, world!” program</p>
<p>The only CTL statement in this program is the <code>echo</code> statement.<sup class="FootnoteReference"><a id="c13-footnoteref-1" href="#c13-footnote-1">1</a></sup> The <code>end</code> statement is needed just to keep MASM happy.</p>
<p>The <code>echo</code> statement displays the textual representation of its argument list during the assembly of a MASM program. Therefore, if you compile the preceding program with the command</p>
<pre><code>ml64 /c listing13-1.asm</code></pre>
<p class="BodyContinued">the MASM assembler will immediately print the following text:</p>
<pre><code>Listing 13-1: Hello, world! </code></pre>
<p>Other than displaying the text associated with the <code>echo</code> parameter list, the <code>echo</code> statement has no effect on the assembly of the program. It is invaluable for debugging CTL programs, displaying the progress of the assembly, and displaying assumptions and default actions that take place during assembly. </p>
<p>Though assembly language calls to <code>print</code> also emit text to the standard output, there is a big difference between the following two groups of statements in a MASM source file:</p>
<pre><code>echo "Hello World"

call print
byte "Hello World", nl,0 </code></pre>
<p>The first statement prints <code>"Hello World"</code> (and a newline) during the assembly process and has no effect on the executable program. The last two lines don’t affect the assembly process (other than the emission of code to the executable file). However, when you run the executable file, the second set of statements prints the string <code>Hello World</code> followed by a newline sequence.</p>
<p>The <code>.err</code> directive, like <code>echo</code>, will display a string to the console during assembly, though this must be a text string (delimited by <code>&lt;</code> and <code>&gt;</code>). The <code>.err</code> statement displays the text as part of a MASM error diagnostic. Furthermore, the <code>.err</code> statement increments the error count, and this will cause MASM to stop the assembly (without assembling or linking) after processing the current source file. You would normally use the <code>.err</code> statement to display an error message during assembly if your CTL code discovers something that prevents it from creating valid code. For example:</p>
<pre><code>.err &lt;Statement must have exactly one operand&gt;</code></pre>
<h2 id="h1-501089c13-0003"><span epub:type="pagebreak" title="750" id="Page_750"/>	13.3	Compile-Time Constants and Variables</h2>
<p class="BodyFirst">Just as the runtime language does, the compile-time language supports constants and variables. You declare compile-time constants by using the <code>textequ</code> or <code>equ</code> directives. You declare compile-time variables by using the <code>=</code> directive (compile-time assignment statement). For example:</p>
<pre><code>inc_by equ 1
ctlVar = 0
ctlVar = ctlVar + inc_by</code></pre>
<h2 id="h1-501089c13-0004">	13.4	Compile-Time Expressions and Operators</h2>
<p class="BodyFirst">The MASM CTL supports constant expressions in the CTL assignment statement. See <span class="xref" itemid="xref_target_“MASM Constant Declarations” in Chapter 4">“MASM Constant Declarations” in Chapter 4</span> for a discussion of constant expressions (which are also the CTL expressions and operators).</p>
<p>In addition to the operators and functions appearing in that chapter, MASM includes several additional CTL operators, functions, and directives you will find useful. The following subsections describe these.</p>
<h3 id="h2-501089c13-0001">13.4.1	The MASM Escape (!) Operator</h3>
<p class="BodyFirst">The first operator is the <code>!</code> operator. When placed in front of another symbol, this operator tells MASM to treat that character as text rather than as a special symbol. For example, <code>!;</code> creates a text constant consisting of the semicolon character, rather than a comment that causes MASM to ignore all text after the <code>;</code> symbol (for C/C++ programmers, this is similar to the backslash escape character, <code>\</code>, in a string constant).</p>
<h3 id="h2-501089c13-0002">13.4.2	The MASM Evaluation (%) Operator</h3>
<p class="BodyFirst">The second useful CTL operator is <code>%</code>. The percent operator causes MASM to evaluate the expression following it and replace that expression with its value. For example, consider the following code sequence:</p>
<pre><code>num10   =        10
text10  textequ  &lt;10&gt;
tn11    textequ  %num10 + 1</code></pre>
<p>If you assemble this sequence in an assembly language source file and direct MASM to produce an assembly listing, it will report the following for these three symbols:</p>
<pre><code>num10  <span class="LiteralGray">. . . . . . . . . . . . .</span>        Number   0000000Ah
text10 <span class="LiteralGray">. . . . . . . . . . . . .</span>        Text     10
tn11 <span class="LiteralGray">. . . . . . . . . . . . . .</span>        Text     11</code></pre>
<p><span epub:type="pagebreak" title="751" id="Page_751"/>The <code>num10</code> is properly reported as a numeric value (decimal 10), <code>text10</code> as a text symbol (containing the string <code>10</code>), and <code>tn11</code> as a text symbol (as you would expect, because this code sequence uses the <code>textequ</code> directive to define it). However, rather than containing the string <code>%num10 + 1</code>, MASM evaluates the expression <code>num10 + 1</code> to produce the numeric value 11, which MASM then converts to text data. (By the way, to put a percent sign in a text string, use the text sequence <code>&lt;!%&gt;</code>.)</p>
<p>If you place the <code>%</code> operator in the first column of a source line, MASM will translate all numeric expressions on that line to textual form. This is handy with the <code>echo</code> directive. It causes <code>echo</code> to display the value of numeric equates rather than simply displaying the equate names.</p>
<h3 id="h2-501089c13-0003">13.4.3	The catstr Directive</h3>
<p class="BodyFirst">The <code>catstr</code> function has the following syntax:</p>
<pre><code><var>identifier</var>   catstr  <var>string1</var>, <var>string2</var>, ...</code></pre>
<p>The identifier is an (up to this point) undefined symbol. The <var>string1</var> and <var>string2</var> operands are textual data surrounded by <code>&lt;</code> and <code>&gt;</code> symbols. This statement stores the concatenation of the two strings into <var>identifier</var>. Note that <var>identifier</var> is a text object, not a string object. If you specify the identifier in your code, MASM will substitute the text string for the identifier and try to process that text data as though it were part of your source code input.</p>
<p>The <code>catstr</code> statement allows two or more operands separated by commas. The <code>catstr</code> directive will concatenate the text values in the order they appear in the operand field. The following statement generates the textual data <code>Hello, World!</code>:</p>
<pre><code>helloWorld catstr &lt;Hello&gt;, &lt;, &gt;, &lt;World!!&gt;</code></pre>
<p>Two exclamation marks are necessary in this example, because <code>!</code> is an operator telling MASM to treat the next symbol as text rather than as an operator. With only one <code>!</code> symbol, MASM thinks that you’re attempting to include a <code>&gt;</code> symbol as part of the string and reports an error (because there is no closing <code>&gt;</code>). Putting <code>!!</code> in the text string tells MASM to treat the second <code>!</code> symbol as a text character.</p>
<h3 id="h2-501089c13-0004">13.4.4	The instr Directive</h3>
<p class="BodyFirst">The <code>instr</code> directive searches for the presence of one string within another. The syntax for the directive is</p>
<pre><code><var>identifier</var>  instr  <var>start</var>, <var>source</var>, <var>search</var></code></pre>
<p class="BodyContinued">where <var>identifier</var> is a symbol into which MASM will put the offset of the <var>search</var> string within the <var>source</var> string. The search begins at position <var>start</var> within <var>source</var>. Unconventionally, the first character in <var>source</var> has the <span epub:type="pagebreak" title="752" id="Page_752"/>position 1 (not 0). The following example searches for <code>World</code> within the string <code>Hello World</code> (starting at character position 1, which is the index of the <code>H</code> character):</p>
<pre><code>WorldPosn  instr 1, &lt;Hello World&gt;, &lt;World&gt;</code></pre>
<p>This statement defines <code>WorldPosn</code> as a number with the value 7 (as the string <code>World</code> is at position 7 in <code>Hello World</code> if you start counting from position 1).</p>
<h3 id="h2-501089c13-0005">13.4.5	The sizestr Directive</h3>
<p class="BodyFirst">The <code>sizestr</code> directive computes the length of a string.<sup class="FootnoteReference"><a id="c13-footnoteref-2" href="#c13-footnote-2">2</a></sup> The syntax for the directive is</p>
<pre><code><var>identifier</var>  sizestr  <var>string</var></code></pre>
<p class="BodyContinued">where <var>identifier</var> is the symbol into which MASM will store the string’s length, and <var>string</var> is the string literal whose length this directive computes. As an example,</p>
<pre><code>hwLen sizestr &lt;Hello World&gt;</code></pre>
<p class="BodyContinued">defines the symbol <code>hwLen</code> as a number and sets it to the value 11.</p>
<h3 id="h2-501089c13-0006">13.4.6	The substr Directive</h3>
<p class="BodyFirst">The <code>substr</code> directive extracts a substring from a larger string. The syntax for this directive is</p>
<pre><code><var>identifier</var> substr <var>source</var>, <var>start</var>, <var>len</var></code></pre>
<p class="BodyContinued">where <var>identifier</var> is the symbol that MASM will create (type <code>TEXT</code>, initialized with the substring characters), <var>source</var> is the source string from which MASM will extract the substring, <var>start</var> is the starting position in the string to begin the extraction, and <var>len</var> is the length of the substring to extract. The <var>len</var> operand is optional; if it is absent, MASM will assume you want to use the remainder of the string (starting at position <var>start</var>) for the substring. Here’s an example that extracts <code>Hello</code> from the string <code>Hello World</code>:</p>
<pre><code>hString substr &lt;Hello World&gt;, 1, 5</code></pre>
<h2 id="h1-501089c13-0005">	13.5	Conditional Assembly (Compile-Time Decisions)</h2>
<p class="BodyFirst">MASM’s compile-time language provides an if statement, <code>if</code>, that lets you make decisions at assembly time. The <code>if</code> statement has two main purposes. The traditional use of <code>if</code> is to support <em>conditional assembly</em>, allowing you to include or exclude code during an assembly, depending on the status of <span epub:type="pagebreak" title="753" id="Page_753"/>various symbols or constant values in your program. The second use is to support the standard if-statement decision-making process in the MASM compile-time language. This section discusses these two uses for the MASM <code>if</code> statement.</p>
<p>The simplest form of the MASM compile-time <code>if</code> statement uses the following syntax:</p>
<pre><code>if <var>constant_boolean_expression</var>  
      <var>Text</var>  
endif </code></pre>
<p>At compile time, MASM evaluates the expression after the <code>if</code>. This must be a constant expression that evaluates to an integer value. If the expression evaluates to true (nonzero), MASM continues to process the text in the source file as though the <code>if</code> statement were not present. However, if the expression evaluates to false (zero), MASM treats all the text between the <code>if</code> and the corresponding <code>endif</code> clause as though it were a comment (that is, it ignores this text), as shown in <a href="#figure13-2" id="figureanchor13-2">Figure 13-2</a>.</p>
<figure>
<img src="image_fi/501089c13/f13002.png" alt="f13002" class=""/>
<figcaption><p><a id="figure13-2">Figure 13-2</a>: Operation of a MASM compile-time <span class="LiteralInCaption"><code>if</code></span> statement</p></figcaption>
</figure>
<p>The identifiers in a compile-time expression must all be constant identifiers or a MASM compile-time function call (with appropriate parameters). Because MASM evaluates these expressions at assembly time, they cannot contain runtime variables.</p>
<p>The MASM <code>if</code> statement supports optional <code>elseif</code> and <code>else</code> clauses that behave in an intuitive fashion. The complete syntax for the <code>if</code> statement looks like the following:</p>
<pre><code>if <var>constant_boolean_expression1</var>
      <var>Text</var>  
elseif <var>constant_boolean_expression2</var>
      <var>Text</var>  
else 
      <var>Text</var>  
endif </code></pre>
<p>If the first Boolean expression evaluates to true, MASM processes the text up to the <code>elseif</code> clause. It then skips all text (that is, treats it like a comment) until it encounters the <code>endif</code> clause. MASM continues processing the text after the <code>endif</code> clause in the normal fashion.</p>
<p><span epub:type="pagebreak" title="754" id="Page_754"/>If the first Boolean expression evaluates to false, MASM skips all the text until it encounters an <code>elseif</code>, <code>else</code>, or <code>endif</code> clause. If it encounters an <code>elseif</code> clause (as in the preceding example), MASM evaluates the Boolean expression associated with that clause. If it evaluates to true, MASM processes the text between the <code>elseif</code> and the <code>else</code> clauses (or to the <code>endif</code> clause if the <code>else</code> clause is not present). If, during the processing of this text, MASM encounters another <code>elseif</code> or, as in the preceding example, an <code>else</code> clause, then MASM ignores all further text until it finds the corresponding <code>endif</code>. If both the first and second Boolean expressions in the previous example evaluate to false, MASM skips their associated text and begins processing the text in the <code>else</code> clause. </p>
<p>You can create a nearly infinite variety of <code>if</code> statement sequences by including zero or more <code>elseif</code> clauses and optionally supplying the <code>else</code> clause. </p>
<p>A traditional use of conditional assembly is to develop software that you can easily configure for several environments. For example, the <code>fcomip</code> instruction makes floating-point comparisons easy, but this instruction is available only on Pentium Pro and later processors. To use this instruction on the processors that support it and fall back to the standard floating-point comparison on the older processors, most engineers use conditional assembly to embed the separate sequences in the same source file (instead of writing and maintaining two versions of the program). The following example demonstrates how to do this:</p>
<pre><code>; Set true (1) to use FCOMI<var>xx</var> instrs.

PentProOrLater = 0
          . 
          . 
          . 
        if PentProOrLater

          fcomip st(0), st(1) ; Compare ST1 to ST0 and set flags

        else 

          fcomp               ; Compare ST1 to ST0
          fstsw ax            ; Move the FPU condition code bits
          sahf                ; into the FLAGS register

        endif </code></pre>
<p>As currently written, this code fragment will compile the three-instruction sequence in the <code>else</code> clause and ignore the code between the <code>if</code> and <code>else</code> clauses (because the constant <code>PentProOrLater</code> is false). By changing the value of <code>PentProOrLater</code> to true, you can tell MASM to compile the single <code>fcomip</code> instruction rather than the three-instruction sequence.</p>
<p>Though you need to maintain only a single source file, conditional assembly does not let you create a single <em>executable</em> that runs efficiently on all processors. When using this technique, you will still have to create two executable programs (one for Pentium Pro and later processors, one for <span epub:type="pagebreak" title="755" id="Page_755"/>the earlier processors) by compiling your source file twice: during the first assembly, you must set the <code>PentProOrLater</code> constant to false; during the second assembly, you must set it to true.</p>
<p>If you are familiar with conditional assembly in other languages, such as C/C++, you may be wondering if MASM supports a statement like C’s <code>#ifdef</code> statement. The answer is yes, it does. Consider the following modification to the preceding code that uses this directive:</p>
<pre><code>; Note: uncomment the following line if you are compiling this 
; code for a Pentium Pro or later CPU. 

; PentProOrLater = 0       ; Value and type are irrelevant
          . 
          . 
          . 
ifdef PentProOrLater 

     fcomip st(0), st(1)   ; Compare ST1 to ST0 and set flags

else 

     fcomp                 ; Compare ST1 to ST0
     fstsw ax              ; Move the FPU condition code bits
     sahf                  ; into the FLAGS register

endif </code></pre>
<p>Another common use of conditional assembly is to introduce debugging and testing code into your programs. A typical debugging technique that many MASM programmers use is to insert print statements at strategic points throughout their code; this enables them to trace through their code and display important values at various checkpoints. </p>
<p>A big problem with this technique, however, is that they must remove the debugging code prior to completing the project. Two further problems are as follows:</p>
<ul>
<li>Programmers often forget to remove some debugging statements, and this creates defects in the final program.</li>
<li>After removing a debugging statement, these programmers often discover that they need that same statement to debug a different problem at a later time. Hence, they are constantly inserting and removing the same statements over and over again.</li>
</ul>
<p>Conditional assembly can provide a solution to this problem. By defining a symbol (say, <code>debug</code>) to control debugging output in your program, you can activate or deactivate <em>all</em> debugging output by modifying a single line of source code. The following code fragment demonstrates this:</p>
<pre><code>; Set to true to activate debug output.

debug   =    0
<span epub:type="pagebreak" title="756" id="Page_756"/>          . 
          . 
          . 
     if debug

        echo *** DEBUG build

        mov  edx, i
        call print
        byte "At point A, i=%d", nl, 0 

     else

     echo *** RELEASE build

     endif </code></pre>
<p>As long as you surround all debugging output statements with an <code>if</code> statement like the preceding one, you don’t have to worry about debugging output accidentally appearing in your final application. By setting the <code>debug</code> symbol to false, you can automatically disable all such output. Likewise, you don’t have to remove all your debugging statements from your programs after they’ve served their immediate purpose. By using conditional assembly, you can leave these statements in your code because they are so easy to deactivate. Later, if you decide you need to view this same debugging information during assembly, you can reactivate it by setting the <code>debug</code> symbol to true.</p>
<p>Although program configuration and debugging control are two of the more common, traditional uses for conditional assembly, don’t forget that the <code>if</code> statement provides the basic conditional statement in the MASM CTL. You will use the <code>if</code> statement in your compile-time programs the same way you would use an <code>if</code> statement in MASM or another language. Later sections in this chapter present lots of examples of using the <code>if</code> statement in this capacity.</p>
<h2 id="h1-501089c13-0006">	13.6	Repetitive Assembly (Compile-Time Loops)</h2>
<p class="BodyFirst">MASM’s <code>while..endm</code>,<code> for..endm</code>, and <code>forc..endm</code> statements provide compile-time loop constructs.<sup class="FootnoteReference"><a id="c13-footnoteref-3" href="#c13-footnote-3">3</a></sup> The <code>while</code> statement tells MASM to process the same sequence of statements repetitively during assembly. This is handy for constructing data tables as well as providing a traditional looping structure for compile-time programs.</p>
<p>The <code>while</code> statement uses the following syntax:</p>
<pre><code>while <var>constant_boolean_expression</var>
      <var>Text  </var>
endm </code></pre>
<p><span epub:type="pagebreak" title="757" id="Page_757"/>When MASM encounters the <code>while</code> statement during assembly, it evaluates the constant Boolean expression. If the expression evaluates to false, MASM will skip over the text between the <code>while</code> and the <code>endm</code> clauses (the behavior is similar to the <code>if</code> statement if the expression evaluates to false). If the expression evaluates to true, MASM will process the statements between the <code>while</code> and <code>endm</code> clauses and then “jump back” to the start of the <code>while</code> statement in the source file and repeat this process, as shown in <a href="#figure13-3" id="figureanchor13-3">Figure 13-3</a>.</p>
<figure>
<img src="image_fi/501089c13/f13003.png" alt="f13003" class=""/>
<figcaption><p><a id="figure13-3">Figure 13-3</a>: MASM compile-time <span class="LiteralInCaption"><code>while</code></span> statement operation</p></figcaption>
</figure>
<p>To understand how this process works, consider the program in <a href="#listing13-2" id="listinganchor13-2">Listing 13-2</a>.</p>
<pre><code>; Listing 13-2
 
; CTL while loop demonstration program.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 13-2", 0
           
            .data
ary         dword   2, 3, 5, 8, 13

            include getTitle.inc
            include print.inc
            
            .code
            
; Here is the "asmMain" function.
        
            public  asmMain
asmMain     proc
            push    rbx
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56           ; Shadow storage

<span epub:type="pagebreak" title="758" id="Page_758"/>i           =       0            
            while   i LT lengthof ary ; 5  

            mov     edx, i            ; This is a constant!
            mov     r8d, ary[i * 4]   ; Index is a constant
            call    print
            byte    "array[%d] = %d", nl, 0
              
i           =       i + 1
            endm 
             
allDone:    leave
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing13-2">Listing 13-2</a>: <code>w</code><code>hile</code><code>..</code><code>endm</code> demonstration</p>
<p>Here’s the build command and program output for <a href="#listing13-2">Listing 13-2</a>:</p>
<pre><code>C:\&gt;<b>build listing13-2</b>

C:\&gt;<b>echo off</b>
 Assembling: listing13-2.asm
c.cpp

C:\&gt;<b>listing13-2</b>
Calling Listing 13-2:
array[0] = 2
array[1] = 3
array[2] = 5
array[3] = 8
array[4] = 13
Listing 13-2 terminated</code></pre>
<p>The <code>while</code> loop repeats five times during assembly. On each repetition of the loop, the MASM assembler processes the statements between the <code>while</code> and <code>endm</code> directives. Therefore, the preceding program is really equivalent to the code fragment shown in <a href="#listing13-3" id="listinganchor13-3">Listing 13-3</a>.</p>
<pre><code>.
.
.
mov     edx, 0          ; This is a constant!
mov     r8d, ary[0]     ; Index is a constant
call    print
byte    "array[%d] = %d", nl, 0

mov     edx, 1          ; This is a constant!
mov     r8d, ary[4]     ; Index is a constant
call    print
byte    "array[%d] = %d", nl, 0

<span epub:type="pagebreak" title="759" id="Page_759"/>mov     edx, 2          ; This is a constant!
mov     r8d, ary[8]     ; Index is a constant
call    print
byte    "array[%d] = %d", nl, 0

mov     edx, 3          ; This is a constant!
mov     r8d, ary[12]    ; Index is a constant
call    print
byte    "array[%d] = %d", nl, 0

mov     edx, 4          ; This is a constant!
mov     r8d, ary[16]    ; Index is a constant
call    print
byte    "array[%d] = %d", nl, 0</code></pre>
<p class="CodeListingCaption"><a id="listing13-3">Listing 13-3</a>: Program equivalent to the code in <a href="#listing13-2">Listing 13-2</a></p>
<p>As you can see in this example, the <code>while</code> statement is convenient for constructing repetitive-code sequences, especially for unrolling loops.</p>
<p>MASM provides two forms of the <code>for..endm</code> loop. These two loops take the following general form:</p>
<pre><code>for <var>identifier</var>, &lt;<var>arg1</var>, <var>arg2</var>, ..., <var>argn</var>&gt; 
  . 
  . 
  . 
endm 

forc <var>identifier</var>, &lt;<var>string</var>&gt;
  . 
  . 
  . 
endm </code></pre>
<p>The first form of the <code>for</code> loop (plain <code>for</code>) repeats the code once for each of the arguments specified between the <code>&lt;</code> and <code>&gt;</code> brackets. On each repetition of the loop, it sets <var>identifier</var> to the text of the current argument: on the first iteration of the loop, <var>identifier</var> is set to <var>arg1</var>, and on the second iteration it is set to <var>arg2</var>, and so on, until the last iteration, when it is set to <var>argn</var>. For example, the following <code>for</code> loop will generate code that pushes the RAX, RBX, RCX, and RDX registers onto the stack:</p>
<pre><code>for  reg, &lt;rax, rbx, rcx, rdx&gt;
push reg
endm</code></pre>
<p>This <code>for</code> loop is equivalent to the following code:</p>
<pre><code>push rax
push rbx
push rcx
push rdx</code></pre>
<p><span epub:type="pagebreak" title="760" id="Page_760"/>The <code>forc</code> compile-time loop repeats the body of its loop for each character appearing in the string specified by the second argument. For example, the following <code>forc</code> loop generates a hexadecimal byte value for each character in the string:</p>
<pre><code>        forc   hex, &lt;0123456789ABCDEF&gt;
hexNum  catstr &lt;0&gt;,&lt;hex&gt;,&lt;h&gt;
        byte   hexNum
        endm</code></pre>
<p>The <code>for</code> loop will turn out to be a lot more useful than <code>forc</code>. Nevertheless, <code>forc</code> is handy on occasion. Most of the time when you’re using these loops, you’ll be passing them a variable set of arguments rather than a fixed string. As you’ll soon see, these loops are handy for processing macro parameters.</p>
<h2 id="h1-501089c13-0007">	13.7	Macros (Compile-Time Procedures)</h2>
<p class="BodyFirst"><em>Macros</em> are objects that a language processor replaces with other text during compilation. Macros are great devices for replacing long, repetitive sequences of text with much shorter sequences of text. In addition to the traditional role that macros play (for example, <code>#define</code> in C/C++), MASM’s macros also serve as the equivalent of a compile-time language procedure or function. </p>
<p>Macros are one of MASM’s main features. The following sections explore MASM’s macro-processing facilities and the relationship between macros and other MASM CTL control constructs.</p>
<h2 id="h1-501089c13-0008">	13.8	Standard Macros</h2>
<p class="BodyFirst">MASM supports a straightforward macro facility that lets you define macros in a manner that is similar to declaring a procedure. A typical, simple macro declaration takes the following form:</p>
<pre><code><var>macro_name</var> macro <var>arguments</var> 
      <var>Macro body</var>
          endm</code></pre>
<p>The following code is a concrete example of a macro declaration:</p>
<pre><code>neg128 macro 

       neg rdx 
       neg rax 
       sbb rdx, 0 

       endm </code></pre>
<p>Execution of this macro’s code will compute the two’s complement of the 128-bit value in RDX:RAX (see the description of extended-precision <code>neg</code> in <span class="xref" itemid="xref_target_“Extended-Precision Negation Operations” in Chapter 8">“Extended-Precision Negation Operations” in Chapter 8</span>).</p>
<p><span epub:type="pagebreak" title="761" id="Page_761"/>To execute the code associated with <code>neg128</code>, you specify the macro’s name at the point you want to execute these instructions. For example:</p>
<pre><code>mov    rax, qword ptr i128 
mov    rdx, qword ptr i128[8] 
neg128 </code></pre>
<p>This intentionally looks just like any other instruction; the original purpose of macros was to create synthetic instructions to simplify assembly language programming.</p>
<p>Though you don’t need to use a <code>call</code> instruction to invoke a macro, from the point of view of your program, invoking a macro executes a sequence of instructions just like calling a procedure. You could implement this simple macro as a procedure by using the following procedure declaration:</p>
<pre><code>neg128p  proc 

         neg   rdx
         neg   rax
         sbb   rdx, 0
         ret

neg128p  endp</code></pre>
<p>The following two statements will both negate the value in RDX:RAX:</p>
<pre><code>neg128
call   neg128p </code></pre>
<p>The difference between these two (the macro invocation versus the procedure call) is that macros expand their text inline, whereas a procedure call emits a call to the corresponding procedure elsewhere in the text. That is, MASM replaces the invocation <code>neg128</code> directly with the following text:</p>
<pre><code>neg  rdx
neg  rax
sbb  rdx, 0</code></pre>
<p>On the other hand, MASM replaces the procedure <code>call neg128p</code> with the machine code for the <code>call</code> instruction:</p>
<pre><code>call neg128p</code></pre>
<p>You should choose macro versus procedure call based on efficiency. Macros are slightly faster than procedure calls because you don’t execute the <code>call</code> and corresponding <code>ret</code> instructions, but they can make your program larger because a macro invocation expands to the text of the macro’s body on each invocation. If the macro body is large and you invoke the macro several times throughout your program, it will make your final executable much larger. Also, if the body of your macro executes more than <span epub:type="pagebreak" title="762" id="Page_762"/>a few simple instructions, the overhead of a <code>call</code> and <code>ret</code> sequence has little impact on the overall execution time of the code, so the execution time savings are nearly negligible. On the other hand, if the body of a procedure is very short (like the preceding <code>neg128</code> example), the macro implementation can be faster and doesn’t expand the size of your program by much. A good rule of thumb is as follows:</p>
<blockquote class="review">
<p class="Blockquote">Use <em>macros</em> for short, time-critical program units. Use <em>procedures</em> for longer blocks of code and when execution time is not as critical.</p></blockquote>
<p>Macros have many other disadvantages over procedures. Macros cannot have local (automatic) variables, macro parameters work differently than procedure parameters, macros don’t support (runtime) recursion, and macros are a little more difficult to debug than procedures (just to name a few disadvantages). Therefore, you shouldn’t really use macros as a substitute for procedures except when performance is absolutely critical.</p>
<h2 id="h1-501089c13-0009">	13.9	Macro Parameters</h2>
<p class="BodyFirst">Like procedures, macros allow you to define <em>parameters</em> that let you supply different data on each macro invocation, which lets you write generic macros whose behavior can vary depending on the parameters you supply. By processing these macro parameters at compile time, you can write sophisticated macros.</p>
<p>Macro parameter declaration syntax is straightforward. You supply a list of parameter names as the operands in a macro declaration:</p>
<pre><code>neg128  macro reg64HO, reg64LO

        neg   reg64HO
        neg   reg64LO
        sbb   reg64HO, 0

        endm </code></pre>
<p>When you invoke a macro, you supply the actual parameters as arguments to the macro invocation:</p>
<pre><code>neg128  rdx, rax</code></pre>
<h3 id="h2-501089c13-0007">13.9.1	Standard Macro Parameter Expansion</h3>
<p class="BodyFirst">MASM automatically associates the type <code>text</code> with macro parameters. This means that during a macro expansion, MASM substitutes the text you supply as the actual parameter everywhere the formal parameter name appears. The semantics of <em>pass by textual substitution</em> are a little different from <em>pass by value</em> or <em>pass by reference</em>, so exploring those differences here is worthwhile.</p>
<p><span epub:type="pagebreak" title="763" id="Page_763"/>Consider the following macro invocations, using the <code>neg128</code> macro from the previous section:</p>
<pre><code>neg128 rdx, rax
neg128 rbx, rcx </code></pre>
<p>These two invocations expand into the following code:</p>
<pre><code>; neg128 rdx, rax 

     neg rdx 
     neg rax 
     sbb rdx, 0

; neg128 rbx, rcx 

     neg rbx 
     neg rcx 
     sbb rbx, 0 </code></pre>
<p>Macro invocations do not make a local copy of the parameters (as <em>pass by value</em> does), nor do they pass the address of the actual parameter to the macro. Instead, a macro invocation of the form <code>neg128 rdx, rax</code> is equivalent to the following:</p>
<pre><code>reg64HO  textequ &lt;rdx&gt; 
reg64LO  textequ &lt;rax&gt; 

         neg    reg64HO  
         neg    reg64LO  
         sbb    reg64HO, 0 </code></pre>
<p>The text objects immediately expand their string values inline, producing the former expansion for <code>neg128 rdx, rax</code>.</p>
<p>Macro parameters are not limited to memory, register, or constant operands as are instruction or procedure operands. Any text is fine as long as its expansion is legal wherever you use the formal parameter. Similarly, formal parameters may appear anywhere in the macro body, not just where memory, register, or constant operands are legal. Consider the following macro declaration and sample invocations that demonstrate how you can expand a formal parameter into a whole instruction:</p>
<pre><code>chkError macro instr, jump, target

         instr 
         jump  target 

         endm

     chkError &lt;cmp eax, 0&gt;, jnl, RangeError  ; Example 1
          .
          .
          . 
<span epub:type="pagebreak" title="764" id="Page_764"/>     chkError &lt;test bl, 1&gt;, jnz, ParityError ; Example 2

; Example 1 expands to:

     cmp  eax, 0 
     jnl  RangeError 

; Example 2 expands to:

     test bl, 1 
     jnz  ParityError</code></pre>
<p>We use the <code>&lt;</code> and <code>&gt;</code> brackets to treat the full <code>cmp</code> and <code>test</code> instructions as a single string (normally, the comma in these instructions would split them into two macro parameters). </p>
<p>In general, MASM assumes that all text between commas constitutes a single macro parameter. If MASM encounters any opening bracketing symbols (left parentheses, left braces, or left angle brackets), then it will include all text up to the appropriate closing symbol, ignoring any commas that may appear within the bracketing symbols. Of course, MASM does not consider commas (and bracketing symbols) within a string constant as the end of an actual parameter. So the following macro and invocation are perfectly legal:</p>
<pre><code>_print macro strToPrint 

       call print
       byte strToPrint, nl, 0 

      endm 
       . 
       . 
       . 
      _print "Hello, world!"</code></pre>
 
<p>MASM treats the string <code>Hello, world!</code> as a single parameter because the comma appears inside a literal string constant, just as your intuition suggests.</p>
<p>You can run into some issues when MASM expands your macro parameters, because parameters are expanded as text, not values. Consider the following macro declaration and invocation:</p>
<pre><code>Echo2nTimes macro n, theStr
echoCnt     =     0
            while echoCnt LT n * 2

            call  print
            byte  theStr, nl, 0

echoCnt     =     echoCnt + 1
            endm
            endm
<span epub:type="pagebreak" title="765" id="Page_765"/>             . 
             . 
             . 
            Echo2nTimes  3 + 1, "Hello"</code></pre>
<p>This example displays <code>Hello</code> five times during assembly rather than the eight times you might intuitively expect. This is because the preceding <code>while</code> statement expands to</p>
<pre><code>while  echoCnt LT 3 + 1 * 2</code></pre>
<p>The actual parameter for <code>n</code> is <code>3 + 1</code>; because MASM expands this text directly in place of <code>n</code>, you get an erroneous text expansion. At compile time MASM computes <code>3 + 1 * 2</code> as the value 5 rather than as the value 8 (which you would get if the MASM passed this parameter by value rather than by textual substitution).</p>
<p>The common solution to this problem when passing numeric parameters that may contain compile-time expressions is to surround the formal parameter in the macro with parentheses; for example, you would rewrite the preceding macro as follows:</p>
<pre><code>Echo2nTimes macro n, theStr
echoCnt     =     0
            while echoCnt LT (n) * 2

            call  print
            byte  theStr, nl, 0

echoCnt     =     echoCnt + 1
            endm  ; while
            endm  ; macro</code></pre>
<p>Now, the invocation expands to the following code that produces the intuitive result:</p>
<pre><code>while  echoCnt LT (3 + 1) * 2 
call   print
byte   theStr, nl, 0
endm</code></pre>
<p>If you don’t have control over the macro definition (perhaps it’s part of a library module you use, and you can’t change the macro definition because doing so could break existing code), there is another solution to this problem: use the MASM <code>%</code> operator before the argument in the macro invocation so that the CTL interpreter evaluates the expression before expanding the parameters. For example:</p>
<pre><code>Echo2nTimes  %3 + 1, "Hello"</code></pre>
<p>This will cause MASM to properly generate eight calls to the <code>print</code> procedure (and associated data).</p>
<h3 id="h2-501089c13-0008"><span epub:type="pagebreak" title="766" id="Page_766"/>13.9.2	Optional and Required Macro Parameters</h3>
<p class="BodyFirst">As a general rule, MASM treats macro arguments as optional arguments. If you define a macro that specifies two arguments and invoke that argument with only one argument, MASM will not (normally) complain about the invocation. Instead, it will simply substitute the empty string for the expansion of the second argument. In some cases, this is acceptable and possibly even desirable. </p>
<p>However, suppose you left off the second parameter in the <code>neg128</code> macro given earlier. That would compile to a <code>neg</code> instruction with a missing operand and MASM would report an error; for example: </p>
<pre><code>neg128      macro   <var>arg1</var>, <var>arg2</var>      ; Line 6
            neg     <var>arg1</var>            ; Line 7
            neg     <var>arg2</var>            ; Line 8
            sbb     <var>arg1</var>, 0         ; Line 9
            endm                    ; Line 10
                                    ; Line 11
            neg128  rdx             ; Line 12</code></pre>
<p>Here’s the error that MASM reports:</p>
<pre><code>listing14.asm(12) : error A2008:syntax error : in instruction
 neg128(2): Macro Called From
  listing14.asm(12): Main Line Code</code></pre>
<p>The <code>(12)</code> is telling us that the error occurred on line 12 in the source file. The <code>neg128(2)</code> line is telling us that the error occurred on line 2 of the <code>neg128</code> macro. It’s a bit difficult to see what is actually causing the problem here.</p>
<p>One solution is to use conditional assembly inside the macro to test for the presence of both parameters. At first, you might think you could use code like this:</p>
<pre><code>neg128  macro reg64HO, reg64LO

        if   reg64LO eq &lt;&gt;
        .err &lt;neg128 requires 2 operands&gt;
        endif

        neg  reg64HO
        neg  reg64LO
        sbb  reg64O, 0
        endm
         .
         .
         .
        neg128 rdx </code></pre>
<p><span epub:type="pagebreak" title="767" id="Page_767"/>Unfortunately, this fails for a couple of reasons. First of all, the <code>eq</code> operator doesn’t work with text operands. MASM will expand the text operands before attempting to apply this operator, so the <code>if</code> statement in the preceding example effectively becomes</p>
<pre><code>        if   eq</code></pre>
<p class="BodyContinued">because MASM substitutes the empty string for both the operands around the <code>eq</code> operator. This, of course, generates a syntax error. Even if there were non-blank textual operands around the <code>eq</code> operator, this would still fail because <code>eq</code> expects numeric operands. MASM solves this issue by introducing several additional conditional <code>if</code> statements intended for use with text operands and macro arguments. <a href="#table13-1" id="tableanchor13-1">Table 13-1</a> lists these additional <code>if</code> statements.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table13-1">Table 13-1</a>: Text-Handling Conditional <code>if</code> Statements</p></figcaption>
<table id="table-501089c13-0001" border="1">
<thead>
<tr>
<td><b>Statement</b></td>
<td><b>Text operand(s)</b></td>
<td><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>ifb</code><sup class="FootnoteReference"><a id="c13-footnoteref-11" href="#c13-footnote-11">*</a></sup></td>
<td><var>arg</var></td>
<td>If blank: true if <var>arg</var> evaluates to an empty string.</td>
</tr>
<tr>
<td><code>ifnb</code></td>
<td><var>arg</var></td>
<td>If not blank: true if <var>arg</var> evaluates to a non-empty string.</td>
</tr>
<tr>
<td><code>ifdif</code></td>
<td><var>arg1</var><code>, </code><var>arg2</var></td>
<td>If different: true if <var>arg1</var> and <var>arg2</var> are different (case-sensitive).</td>
</tr>
<tr>
<td><code>ifdifi</code></td>
<td><var>arg1</var><code>, </code><var>arg2</var></td>
<td>If different: true if <var>arg1</var> and <var>arg2</var> are different (case-insensitive).</td>
</tr>
<tr>
<td><code>ifidn</code></td>
<td><var>arg1</var><code>, </code><var>arg2</var></td>
<td>If identical: true if <var>arg1</var> and <var>arg2</var> are exactly the same (case-sensitive).</td>
</tr>
<tr>
<td><code>ifidni</code></td>
<td><var>arg2</var><code>, </code><var>arg2</var></td>
<td>If identical: true if <var>arg1</var> and <var>arg2</var> are exactly the same (case-insensitive).</td>
</tr>
</tbody>
<tfoot>
<tr>
<td colspan="3"><p class="TableFootnote"><sup class="FootnoteReference"><a id="c13-footnote-11" href="#c13-footnoteref-11">*</a></sup> <code>ifb </code><var>arg</var> is shorthand for <code>ifidn &lt;</code><var>arg</var><code>&gt;, &lt;&gt;</code>.</p></td>
</tr>
</tfoot>
</table>
</figure>
<p>You use these conditional <code>if</code> statements exactly like the standard <code>if</code> statement. You can also follow these <code>if</code> statements with an <code>elseif</code> or <code>else</code> clause, but there are no <code>elseifb</code>, <code>elseifnb</code>, . . . , variants of these <code>if</code> statements (only a standard <code>elseif</code> with a Boolean expression may follow these statements).</p>
<p>The following snippet demonstrates how to use the <code>ifb</code> statement to ensure that the <code>neg128</code> macro has exactly two arguments. There is no need to check whether <code>reg64HO</code> is also blank; if <code>reg64HO</code> is blank, <code>reg64LO</code> will also be blank, and the <code>ifb</code> statement will report the appropriate error:</p>
<pre><code>neg128  macro reg64HO, reg64LO

        ifb  &lt;reg64LO&gt;
        .err &lt;neg128 requires 2 operands&gt;
        endif

<span epub:type="pagebreak" title="768" id="Page_768"/>        neg  reg64HO
        neg  reg64LO
        sbb  reg64HO, 0
        endm</code></pre>
<p>Be very careful about using <code>ifb</code> in your programs. It is easy to pass in a text symbol to a macro and wind up testing whether the name of that symbol is blank rather than the text itself. Consider the following:</p>
<pre><code>symbol      textequ &lt;&gt;
            neg128  rax, symbol     ; Generates an error</code></pre>
<p>The <code>neg128</code> invocation has two arguments, and the second one is not blank, so the <code>ifb</code> directive is happy with the argument list. However, inside the macro when <code>neg128</code> expands <code>reg64LO</code> after the <code>neg</code> instruction, the expansion is the empty string, producing an error (which is what the <code>ifb</code> was supposed to prevent).</p>
<p>A different way to handle missing macro arguments is to explicitly tell MASM that an argument is required with the <code>:req</code> suffix on the macro definition line. Consider the following definition for the <code>neg128</code> macro:</p>
<pre><code>neg128  macro reg64HO:req, reg64LO:req
        neg   reg64HO
        neg   reg64LO
        sbb   reg64HO, 0
        endm</code></pre>
<p>With the <code>:req</code> option present, MASM reports the following if you are missing one or more of the macro arguments:</p>
<pre><code>listing14.asm(12) : error A2125:missing macro argument</code></pre>
<h3 id="h2-501089c13-0009">13.9.3	Default Macro Parameter Values</h3>
<p class="BodyFirst">One way to handle missing macro arguments is to define default values for those arguments. Consider the following definition for the <code>neg128</code> macro:</p>
<pre><code>neg128  macro reg64HO:=&lt;rdx&gt;, reg64LO:=&lt;rax&gt;
        neg   reg64HO
        neg   reg64LO
        sbb   reg64HO, 0
        endm</code></pre>
<p>The <code>:=</code> operator tells MASM to substitute the text constant to the right of the operator for the associated macro argument if an actual value is not present on the macro invocation line. Consider the following two invocations of <code>neg128</code>:</p>
<pre><code>neg128       ; Defaults to "RDX, RAX" for the args
neg128 rbx   ; Uses RBX:RAX for the 128-bit register pair</code></pre>
<h3 id="h2-501089c13-0010"><span epub:type="pagebreak" title="769" id="Page_769"/>13.9.4	Macros with a Variable Number of Parameters</h3>
<p class="BodyFirst">It is possible to tell MASM to allow a variable number of arguments in a macro invocation: </p>
<pre><code>varParms  macro varying:vararg 

     <var> Macro body</var>

          endm 
           . 
           . 
           . 
          varParms 1 
          varParms 1, 2 
          varParms 1, 2, 3 
          varParms </code></pre>
<p>Within the macro, MASM will create a text object of the form <code>&lt;</code><var>arg1</var><code>, </code><var>arg2</var><code>, ..., </code><var>argn</var><code>&gt;</code> and assign this text object to the associated parameter name (<code>varying</code>, in the preceding example). You can use the MASM <code>for</code> loop to extract the individual values of the varying argument. For example:</p>
<pre><code>varParms  macro varying:vararg 
          for   curArg, &lt;varying&gt;
          byte  curArg
          endm  ; End of FOR loop
          endm  ; End of macro
  
          varParms 1 
          varParms 1, 2 
          varParms 1, 2, 3
          varParms &lt;5 dup (?)&gt; </code></pre>
<p>Here’s the listing output for an assembly containing this example source code:</p>
<pre><code> 00000000                        .data
                       varParms  macro varying:vararg
                                 for   curArg, &lt;varying&gt;
                                 byte  curArg
                                 endm  ; End of FOR loop
                                 endm  ; End of macro

                                 varParms 1
 00000000  01         2          byte  1
                                 varParms 1, 2
 00000001  01         2          byte  1
 00000002  02         2          byte  2
                                 varParms 1, 2, 3
 00000003  01         2          byte  1
 00000004  02         2          byte  2
<span epub:type="pagebreak" title="770" id="Page_770"/> 00000005  03         2          byte  3
                                 varParms &lt;5 dup (?)&gt;
 00000006  00000005 [ 2          byte  5 dup (?)
            00
           ]</code></pre>
<p>A macro can have, at most, one <code>vararg</code> parameter. If a macro has more than one parameter and also has a <code>vararg</code> parameter, the <code>vararg</code> parameter must be the last argument.</p>
<h3 id="h2-501089c13-0011">13.9.5	The Macro Expansion (&amp;) Operator</h3>
<p class="BodyFirst">Inside a macro, you can use the <code>&amp;</code> operator to replace a macro name (or other text symbol) with its actual value. This operator is active anywhere, even with string literals. Consider the following examples:</p>
<pre><code>expand      macro   parm
            byte    '&amp;parm', 0
            endm    
            
            .data
            expand  a</code></pre>
<p>The macro invocation in this example expands to the following code:</p>
<pre><code>byte 'a', 0</code></pre>
<p>If, for some reason, you need the string <code>'&amp;parm'</code> to be emitted within a macro (that has <code>parm</code> as one of its parameters), you will have to work around the expansion operator. Note that <code>'!&amp;parm'</code> will not escape the <code>&amp;</code> operator. One solution that works in this specific case is to rewrite the <code>byte</code> directive:</p>
<pre><code>expand      macro   parm
            byte    '&amp;', 'parm', 0
            endm </code></pre>
<p>Now the <code>&amp;</code> operator is not causing the expansion of <code>parm</code> inside a string.</p>
<h2 id="h1-501089c13-0010">	13.10	Local Symbols in a Macro</h2>
<p class="BodyFirst">Consider the following macro declaration:</p>
<pre><code>jzc    macro  target

       jnz    NotTarget 
       jc     target 
NotTarget: 
       endm </code></pre>
<p><span epub:type="pagebreak" title="771" id="Page_771"/>This macro simulates an instruction that jumps to the specified target location if the zero flag is set <em>and</em> the carry flag is set. Conversely, if either the zero flag or the carry flag is clear, this macro transfers control to the instruction immediately following the macro invocation.</p>
<p>There is a serious problem with this macro. Consider what happens if you use this macro more than once in your program:</p>
<pre><code>jzc Dest1 
  . 
  . 
  . 
jzc Dest2 
  . 
  . 
  . </code></pre>
<p>The preceding macro invocations expand to the following code:</p>
<pre><code>         jnz NotTarget 
         jc Dest1 
NotTarget: 
          . 
          . 
          . 
         jnz NotTarget 
         jc Dest2 
NotTarget: 
          . 
          . 
          . </code></pre>
<p>These two macro invocations both emit the same label, <code>NotTarget</code>, during macro expansion. When MASM processes this code, it will complain about a duplicate symbol definition. </p>
<p>MASM’s solution to this problem is to allow the use of <em>local symbols</em> within a macro. Local macro symbols are unique to a specific invocation of a macro. You must explicitly tell MASM which symbols must be local by using the <code>local</code> directive:</p>
<pre><code><var>macro_name</var>    macro  <var>optional_parameters</var> 
              local  <var>list_of_local_names</var>
         <var>Macro body</var>
              endm </code></pre>
<p>The <var>list_of_local_names</var> is a sequence of one or more MASM identifiers separated by commas. Whenever MASM encounters one of these names in a particular macro invocation, it automatically substitutes a unique name for that identifier. For each macro invocation, MASM substitutes a different name for the local symbol.</p>
<p><span epub:type="pagebreak" title="772" id="Page_772"/>You can correct the problem with the <code>jzc</code> macro by using the following macro code:</p>
<pre><code>jzc      macro   target
         local   NotTarget

         jnz     NotTarget
         jc      target
NotTarget: 

         endm </code></pre>
<p>Now whenever MASM processes this macro, it will automatically associate a unique symbol with each occurrence of <code>NotTarget</code>. This will prevent the duplicate symbol error that occurs if you do not declare <code>NotTarget</code> as a local symbol.</p>
<p>MASM generates symbols of the form <code>??</code><var>nnnn</var>, where <var>nnnn</var> is a (unique) four-digit hexadecimal number, for each local symbol. So, if you see symbols such as <code>??0000</code> in your assembly listings, you know where they came from.</p>
<p>A macro definition can have multiple <code>local</code> directives, each with its own list of local names. However, if you have multiple <code>local</code> statements in a macro, they should all immediately follow the <code>macro</code> directive.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Unlike local symbols in a procedure, you do not attach a type to a local macro symbol. The <code>local</code> directive in a macro declaration accepts only a list of identifiers; the type of the symbols will always be <code>text</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501089c13-0011">	13.11	The exitm Directive</h2>
<p class="BodyFirst">The MASM <code>exitm</code> directive (which may appear only within a macro) tells MASM to immediately terminate the processing of the macro. MASM will ignore any additional lines of text within the macro. If you think of a macro as a procedure, <code>exitm</code> is the return statement.</p>
<p>The <code>exitm</code> directive is useful in a conditional assembly sequence. Perhaps after checking for the presence (or absence) of certain macro arguments, you might want to stop processing the macro to avoid additional errors from MASM. For example, consider the earlier <code>neg128</code> macro:</p>
<pre><code>neg128  macro reg64HO, reg64LO

        ifb   &lt;reg64LO&gt;
        .err  &lt;neg128 requires 2 operands&gt;
        exitm
        endif

        neg   reg64HO
        neg   reg64LO
        sbb   reg64HO, 0
        endm</code></pre>
<p><span epub:type="pagebreak" title="773" id="Page_773"/>Without the <code>exitm</code> directive inside the conditional assembly, this macro would attempt to assemble the <code>neg reg64LO</code> instruction, generating another error because <code>reg64LO</code> expands to the empty string.</p>
<h2 id="h1-501089c13-0012">	13.12	MASM Macro Function Syntax</h2>
<p class="BodyFirst">Originally, MASM’s macro design allowed programmers to create substitute mnemonics. A programmer could use a macro to replace a machine instruction or other statement (or sequence of statements) in an assembly language source file. Macros could create only <em>whole lines</em> of output text in the source file. This prevented programmers from using macro invocation such as the following:</p>
<pre><code>mov rax, <var>some_macro_invocation</var>(<var>arguments</var>)</code></pre>
<p>Today, MASM supports additional syntax that allows you to create <em>macro functions</em>. A MASM macro function definition looks exactly like a normal macro definition with one addition: you use an <code>exitm</code> directive with a textual argument to return a <em>function result</em> from the macro. Consider the <code>upperCase</code> macro function in <a href="#listing13-4" id="listinganchor13-4">Listing 13-4</a>.</p>
<pre><code>; Listing 13-4
 
; CTL while loop demonstration program.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 13-4", 0
           
; upperCase macro function.
 
; Converts text argument to a string, converting
; all lowercase characters to uppercase.

upperCase   macro   theString
            local   resultString, thisChar, sep
resultStr   equ     &lt;&gt; ; Initialize function result with ""
sep         textequ &lt;&gt; ; Initialize separator char with ""

            forc    curChar, theString
            
; Check to see if the character is lowercase.
; Convert it to uppercase if it is, otherwise
; output it to resultStr as is. Concatenate the
; current character to the end of the result string
; (with a ", " separator, if this isn't the first
; character appended to resultStr).

<span epub:type="pagebreak" title="774" id="Page_774"/>            if      ('&amp;curChar' GE 'a') and ('&amp;curChar' LE 'z')
resultStr   catstr  resultStr, sep, %'&amp;curChar'-32
            else
resultStr   catstr  resultStr, sep, %'&amp;curChar'
            endif
            
; First time through, sep is the empty string. For all
; other iterations, sep is the comma separator between
; values.

sep         textequ &lt;, &gt;
            endm    ; End for
            
            exitm   &lt;resultStr&gt;
            endm    ; End macro

; Demonstration of the upperCase macro function:
            
            .data
chars       byte    "Demonstration of upperCase"
            byte    "macro function:"
            byte    upperCase(&lt;abcdEFG123&gt;), nl, 0
            
            .code
            externdef printf:proc
            
; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp
                    
; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbx
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56         ; Shadow storage

            lea     rcx, chars      ; Prints characters converted to uppercase
            call    printf

allDone:    leave
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing13-4">Listing 13-4</a>: Sample macro function</p>
<p><span epub:type="pagebreak" title="775" id="Page_775"/>Whenever you invoke a MASM macro function, you must always follow the macro name with a pair of parentheses enclosing the macro’s arguments. Even if the macro has no arguments, an empty pair of parentheses must be present. This is how MASM differentiates standard macros and macro functions.</p>
<p>Earlier versions of MASM included functions for directives such as <code>sizestr</code> (using the name <code>@sizestr</code>). Recent versions of MASM have removed these functions. However, you can easily write your own macro functions to replace these missing functions. Here’s a quick replacement for the <code>@sizestr</code> function:</p>
<pre><code>; @sizestr - Replacement for the MASM @sizestr function
;            that Microsoft removed from MASM.

@sizestr    macro   theStr
            local   theLen
theLen      sizestr &lt;theStr&gt;
            exitm   &lt;&amp;theLen&gt;
            endm</code></pre>
<p>The <code>&amp;</code> operator in the <code>exitm</code> directive forces the <code>@sizestr</code> macro to expand the text associated with <code>theLen</code> local symbol inside the <code>&lt;</code> and <code>&gt;</code> string delimiters before returning the value to whomever invoked the macro function. Without the <code>&amp;</code> operator, the <code>@sizestr</code> macro will return text of the form <code>??0002</code> (the unique symbol MASM creates for the local symbol <code>theLen</code>).</p>
<h2 id="h1-501089c13-0013">	13.13	Macros as Compile-Time Procedures and Functions</h2>
<p class="BodyFirst">Although programmers typically use macros to expand to a sequence of machine instructions, there is absolutely no requirement that a macro body contain any executable instructions. Indeed, many macros contain only compile-time language statements (for example, <code>if</code>, <code>while</code>, <code>for</code>, <code>=</code> assignments, and the like). By placing only compile-time language statements in the body of a macro, you can effectively write compile-time procedures and functions using macros.</p>
<p>The following <code>unique</code> macro is a good example of a compile-time function that returns a string result:</p>
<pre><code>unique macro 
       local  theSym
       exitm  &lt;theSym&gt;
       endm</code></pre>
<p>Whenever your code references this macro, MASM replaces the macro invocation with the text <code>theSym</code>. MASM generates unique symbols such as <code>??0000</code> for local macro symbols. Therefore, each invocation of the <code>unique</code> macro will generate a sequence of symbols such as <code>??0000</code>, <code>??0001</code>, <code>??0002</code>, and so forth.</p>
<h2 id="h1-501089c13-0014"><span epub:type="pagebreak" title="776" id="Page_776"/>	13.14	Writing Compile-Time “Programs”</h2>
<p class="BodyFirst">The MASM compile-time language allows you to write short programs <em>that write other programs</em>—in particular, to automate the creation of large or complex assembly language sequences. The following subsections provide simple examples of such compile-time programs.</p>
<h3 id="h2-501089c13-0012">13.14.1	Constructing Data Tables at Compile Time</h3>
<p class="BodyFirst">Earlier, this book suggested that you could write programs to generate large, complex lookup tables for your assembly language programs (see the discussion of tables in <span class="xref" itemid="xref_target_“Generating Tables” in Chapter 10">“Generating Tables” in Chapter 10</span>). <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span> provides C++ programs that generate tables to paste into assembly programs. In this section, we will use the MASM compile-time language to construct data tables during assembly of the program that uses the tables.</p>
<p>One common use for the compile-time language is to build ASCII character lookup tables for alphabetic case manipulation with the <code>xlat</code> instruction at runtime. <a href="#listing13-5" id="listinganchor13-5">Listing 13-5</a> demonstrates how to construct an uppercase conversion table and a lowercase conversion table.<sup class="FootnoteReference"><a id="c13-footnoteref-4" href="#c13-footnote-4">4</a></sup> Note the use of a macro as a compile-time procedure to reduce the complexity of the table-generating code.</p>
<pre><code>; Listing 13-5
 
; Creating lookup tables with macros.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 13-5", 0
fmtStr1     byte    "testString converted to UC:", nl
            byte    "%s", nl, 0
            
fmtStr2     byte    "testString converted to LC:", nl
            byte    "%s", nl, 0

testString  byte    "This is a test string ", nl
            byte    "Containing UPPERCASE ", nl
            byte    "and lowercase chars", nl, 0

emitChRange macro   start, last
            local   index, resultStr
index       =       start
            while   index lt last
            byte    index
<span epub:type="pagebreak" title="777" id="Page_777"/>index       =       index + 1
            endm
            endm

; Lookup table that will convert lowercase
; characters to uppercase. The byte at each
; index contains the value of that index,
; except for the bytes at indexes "a" to "z".
; Those bytes contain the values "A" to "Z".
; Therefore, if a program uses an ASCII
; character's numeric value as an index
; into this table and retrieves that byte,
; it will convert the character to uppercase.

lcToUC      equ             this byte
            emitChRange     0, 'a'
            emitChRange     'A', %'Z'+1
            emitChRange     %'z'+1, 0ffh

; As above, but this table converts uppercase
; to lowercase characters.
            
UCTolc      equ             this byte
            emitChRange     0, 'A'
            emitChRange     'a', %'z'+1
            emitChRange     %'Z'+1, 0ffh

            .data

; Store the destination strings here:

toUC        byte    256 dup (0)
TOlc        byte    256 dup (0)     

            .code
            externdef printf:proc
            
; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbx
            push    rdi
            push    rsi
            push    rbp
            mov     rbp, rsp
<span epub:type="pagebreak" title="778" id="Page_778"/>            sub     rsp, 56         ; Shadow storage
            
; Convert the characters in testString to uppercase:

            lea     rbx, lcToUC
            lea     rsi, testString
            lea     rdi, toUC
            jmp     getUC
            
toUCLp:     xlat
            mov     [rdi], al
            inc     rsi
            inc     rdi
getUC:      mov     al, [rsi]
            cmp     al, 0
            jne     toUCLp
            
; Display the converted string:

            lea     rcx, fmtStr1
            lea     rdx, toUC
            call    printf
                    
; Convert the characters in testString to lowercase:

            lea     rbx, UCTolc
            lea     rsi, testString
            lea     rdi, TOlc
            jmp     getLC
            
toLCLp:     xlat
            mov     [rdi], al
            inc     rsi
            inc     rdi
getLC:      mov     al, [rsi]
            cmp     al, 0
            jne     toLCLp
            
; Display the converted string:

            lea     rcx, fmtStr2
            lea     rdx, TOlc
            call    printf
                              
allDone:    leave
            pop     rsi
            pop     rdi
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing13-5">Listing 13-5</a>: Generating case-conversion tables with the compile-time language</p>
<p><span epub:type="pagebreak" title="779" id="Page_779"/>Here’s the build command and sample output for the program in <a href="#listing13-5">Listing 13-5</a>:</p>
<pre><code>C:\&gt;<b>build listing13-5</b>

C:\&gt;<b>echo off</b>
 Assembling: listing13-5.asm
c.cpp

C:\&gt;<b>listing13-5</b>
Calling Listing 13-5:
testString converted to UC:
THIS IS A TEST STRING
CONTAINING UPPERCASE
AND LOWERCASE CHARS

testString converted to LC:
this is a test string
containing uppercase
and lowercase chars

Listing 13-5 terminated</code></pre>
<h3 id="h2-501089c13-0013">13.14.2	Unrolling Loops</h3>
<p class="BodyFirst"><span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> points out that you can unroll loops to improve the performance of certain assembly language programs. However, this requires a lot of extra typing, especially if you have many loop iterations. Fortunately, MASM’s compile-time language facilities, especially the <code>while</code> loop, come to the rescue. With a small amount of extra typing plus one copy of the loop body, you can unroll a loop as many times as you please.</p>
<p>If you simply want to repeat the same code sequence a certain number of times, unrolling the code is especially trivial. All you have to do is wrap a MASM <code>while..endm</code> loop around the sequence and count off the specified number of iterations. For example, if you wanted to print <code>Hello World</code> 10 times, you could encode this as follows:</p>
<pre><code>count = 0
while count LT 10
     call print
     byte "Hello World", nl, 0 

count = count + 1
endm</code></pre>
<p>Although this code looks similar to a high-level language <code>while</code> loop, remember the fundamental difference: the preceding code simply consists of 10 straight calls to <code>print</code> in the program. Were you to encode this using an actual loop, there would be only one call to <code>print</code> and lots of additional logic to loop back and execute that single call 10 times.</p>
<p>Unrolling loops becomes slightly more complicated if any instructions in that loop refer to the value of a loop control variable or another value, <span epub:type="pagebreak" title="780" id="Page_780"/>which changes with each iteration of the loop. A typical example is a loop that zeroes the elements of an integer array:</p>
<pre><code>        xor eax, eax   ; Set EAX and RBX to 0
        xor rbx, rbx
        lea rcx, array
whlLp:  cmp rbx, 20
        jae loopDone
        mov [rcx][rbx * 4], eax
        inc rbx
        jmp whlLp

loopDone: </code></pre>
<p>In this code fragment, the loop uses the value of the loop control variable (in RBX) to index into <code>array</code>. Simply copying <code>mov [rcx][ebx * 4], eax </code>20 times is not the proper way to unroll this loop. You must substitute an appropriate constant index in the range 0 to 76 (the corresponding loop indices, times 4) in place of <code>rbx * 4</code> in this example. Correctly unrolling this loop should produce the following code sequence:</p>
<pre><code>mov  [rcx][0 * 4], eax
mov  [rcx][1 * 4], eax
mov  [rcx][2 * 4], eax
mov  [rcx][3 * 4], eax
mov  [rcx][4 * 4], eax
mov  [rcx][5 * 4], eax
mov  [rcx][6 * 4], eax
mov  [rcx][7 * 4], eax
mov  [rcx][8 * 4], eax
mov  [rcx][9 * 4], eax
mov [rcx][10 * 4], eax 
mov [rcx][11 * 4], eax 
mov [rcx][12 * 4], eax 
mov [rcx][13 * 4], eax 
mov [rcx][14 * 4], eax 
mov [rcx][15 * 4], eax 
mov [rcx][16 * 4], eax 
mov [rcx][17 * 4], eax 
mov [rcx][18 * 4], eax 
mov [rcx][19 * 4], eax </code></pre>
<p> You can easily do this using the following compile-time code sequence:</p>
<pre><code>iteration = 0
while iteration LT 20 
     mov [rcx][iteration * 4], eax
     iteration = iteration + 1
endm </code></pre>
<p>If the statements in a loop use the loop control variable’s value, it is possible to unroll such loops only if those values are known at compile time. You cannot unroll loops when user input (or other runtime information) controls the number of iterations.</p>
<p><span epub:type="pagebreak" title="781" id="Page_781"/>Of course, if the code sequence loaded RCX with the address of <code>array</code> immediately prior to this loop, you could also use the following <code>while</code> loop to save the use of the RCX register:</p>
<pre><code>iteration = 0
while iteration LT 20 
     mov array[iteration * 4], eax
     iteration = iteration + 1
endm </code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	This macro expansion still uses the PC-relative addressing mode, so you don’t have to use the <code>LARGEADDRESSAWARE:NO</code> option.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501089c13-0015">	13.15	Simulating HLL Procedure Calls</h2>
<p class="BodyFirst">Calling procedures (functions) in assembly language is a real chore. Loading registers with parameters, pushing values onto the stack, and other activities are a complete distraction. High-level language procedure calls are far more readable and easier to write than the same calls to an assembly language function. Macros provide a good mechanism to call procedures and functions in a high-level-like manner.</p>
<h3 id="h2-501089c13-0014">13.15.1	HLL-Like Calls with No Parameters</h3>
<p class="BodyFirst">Of course, the most trivial example is a call to an assembly language procedure that has no arguments at all:</p>
<pre><code>someProc  macro
          call    _someProc
          endm

_someProc proc
            .
            .
            .
_someProc endp
            .
            .
            .
          someProc   ; Call the procedure</code></pre>
<p>This simple example demonstrates a couple of conventions this book will use for calling procedures via macro invocation:</p>
<ul>
<li>If the procedure and all calls to the procedure occur within the same source file, place the macro definition immediately before the procedure to make it easy to find. (<span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span> discusses the placement of the macro if you call the procedure from several different source files.)</li>
<li>If you would normally name the procedure <code>someProc</code>, change the procedure’s name to <code>_someProc</code> and then use <code>someProc</code> as the macro name.</li>
</ul>
<p><span epub:type="pagebreak" title="782" id="Page_782"/>While the advantage to using a macro invocation of the form <code>someProc</code> versus a call to the procedure using <code>call someProc</code> might seem somewhat dubious, keeping all procedure calls consistent (by using macro invocations for all of them) helps make your programs more readable.</p>
<h3 id="h2-501089c13-0015">13.15.2	HLL-Like Calls with One Parameter</h3>
<p class="BodyFirst">The next step up in complexity is to call a procedure with a single parameter. Assuming you’re using the Microsoft ABI and passing the parameter in RCX, the simplest solution is something like the following:</p>
<pre><code>someProc  macro   parm1
          mov     rcx, parm1
          call    _someProc
          endm
           .
           .
           .
          someProc Parm1Value</code></pre>
<p>This macro works well if you’re passing a 64-bit integer by value. If the parameter is an 8-, 16-, or 32-bit value, you would swap CL, CX, or ECX for RCX in the <code>mov</code> instruction.<sup class="FootnoteReference"><a id="c13-footnoteref-5" href="#c13-footnote-5">5</a></sup></p>
<p>If you’re passing the first argument by reference, you would swap an <code>lea</code> instruction for the <code>mov</code> instruction in this example. As reference parameters are always 64-bit values, the <code>lea</code> instruction would usually take this form:</p>
<pre><code>lea     rcx, <var>parm1</var></code></pre>
<p>Finally, if you’re passing a <code>real4</code> or <code>real8</code> value as the parameter, you’d swap one of the following instructions for the <code>mov</code> instruction in the previous macro:</p>
<pre><code>movss  xmm0, parm1  ; Use this for real4 parameters
movsd  xmm0, parm1  ; Use this for real8 parameters</code></pre>
<p>As long as the actual parameter is a memory variable or an appropriate integer constant, this simple macro definition works quite well, covering a very large percentage of the real-world cases.</p>
<p>For example, to call the C Standard Library <code>printf()</code> function with a single argument (the format string) using the current macro scheme, you’d write the macro as follows:<sup class="FootnoteReference"><a id="c13-footnoteref-6" href="#c13-footnote-6">6</a></sup></p>
<pre><code>cprintf  macro  parm1
         lea    rcx, parm1
         call   printf
         endm</code></pre>
<p><span epub:type="pagebreak" title="783" id="Page_783"/>So you can invoke this macro as</p>
<pre><code>cprintf fmtStr</code></pre>
<p class="BodyContinued">where <code>fmtStr</code> is (presumably) the name of a <code>byte</code> object in your <code>.data </code>section containing the <code>printf</code> format string. </p>
<p>For a more high-level-like syntax for our procedure calls, we should allow something like the following:</p>
<pre><code>cprintf "This is a printf format string"</code></pre>
<p>Unfortunately, the way the macro is currently written, this will generate the following (syntactically incorrect) statement:</p>
<pre><code>lea   rcx, "This is a printf format string"</code></pre>
<p>We could modify this macro to allow this invocation by rewriting it as follows:</p>
<pre><code>cprintf  macro  parm1
         local  fmtStr
         .data
fmtStr   byte   parm1, nl, 0
         .code
         lea    rcx, fmtStr
         call   printf
         endm</code></pre>
<p>Invoking this macro by using a string constant as the argument expands to the following code:</p>
<pre><code>         .data
fmtStr   byte   "This is a printf format string", nl, 0
         .code
         lea    rcx, fmtStr  ; Technically, fmtStr will really be something
         call   printf       ; like ??0001</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Inserting a<code> .data</code> segment into your code sequence is perfectly okay. When the <code>.code</code> directive comes along, MASM will continue emitting the new object code at the program counter offset in effect when it encounters the <code>.data</code> directive.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The only problem with this new form of the macro is that it no longer accepts invocations such as</p>
<pre><code>cprintf fmtStr</code></pre>
<p class="BodyContinued">where <code>fmtStr</code> is a byte object in the <code>.data</code> section. We’d really like to have a macro that can accept <em>both</em> forms.</p>
<h3 id="h2-501089c13-0016"><span epub:type="pagebreak" title="784" id="Page_784"/>13.15.3	Using opattr to Determine Argument Types</h3>
<p class="BodyFirst">The trick to this is the <code>opattr</code> operator (see <span class="xref" itemid="xref_target_Table 4-1 in Chapter 4"><a href="c04.xhtml#table4-1">Table 4-1</a> in Chapter 4</span>). This operator returns an integer value with certain bits set based on the type of expression that follows. In particular, bit 2 will be set if the expression following is relocatable or otherwise references memory. Therefore, this bit will be set if a variable such as <code>fmtStr</code> appears as the argument, and it will be clear if you pass a string literal as the argument (<code>opattr</code> actually returns the value 0 for string literals that are longer than 8 characters, just so you know). Now consider the code in <a href="#listing13-6" id="listinganchor13-6">Listing 13-6</a>.</p>
<pre><code>; Listing 13-6
 
; opattr demonstration.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 13-6", 0
           
fmtStr      byte    nl, "Hello, World! #2", nl, 0

            .code
            externdef printf:proc
            
; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

; cprintf macro:
 
;           cprintf fmtStr
;           cprintf "Format String"

cprintf     macro   fmtStrArg
            local   fmtStr, attr, isConst
            
attr        =       opattr fmtStrArg
isConst     =       (attr and 4) eq 4
            if      (attr eq 0) or isConst
            .data   
fmtStr      byte    fmtStrArg, nl, 0
            .code
            lea     rcx, fmtStr
            
            else
            
<span epub:type="pagebreak" title="785" id="Page_785"/>            lea     rcx, fmtStrArg
            
            endif
            call    printf
            endm
 
atw         =       opattr "Hello World"
bin         =       opattr "abcdefghijklmnopqrstuvwxyz"
            
; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbx
            push    rdi
            push    rsi
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56         ; Shadow storage

            cprintf "Hello World!"
            cprintf fmtStr
             
allDone:    leave
            pop     rsi
            pop     rdi
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing13-6">Listing 13-6</a>: <code>opattr</code> operator in a macro</p>
<p>Here’s the build command and sample output for <a href="#listing13-6">Listing 13-6</a>:</p>
<pre><code>C:\&gt;<b>build listing13-6</b>

C:\&gt;<b>echo off</b>
 Assembling: listing13-6.asm
c.cpp

C:\&gt;<b>listing13-6</b>
Calling Listing 13-6:
Hello World!
Hello, World! #2
Listing 13-6 terminated</code></pre>
<p>This <code>cprintf</code> macro is far from perfect. For example, the C/C++ <code>printf()</code> function allows multiple arguments that this macro does not handle. But this macro does demonstrate how to handle two different calls to <code>printf</code> based on the type of the argument you pass <code>cprintf</code>.</p>
<h3 id="h2-501089c13-0017"><span epub:type="pagebreak" title="786" id="Page_786"/>13.15.4	HLL-Like Calls with a Fixed Number of Parameters</h3>
<p class="BodyFirst">Expanding the macro-calling mechanism from one parameter to two or more (assuming a fixed number of parameters) is fairly easy. All you need to do is add more formal parameters and handle those arguments in your macro definition. <a href="#listing13-7" id="listinganchor13-7">Listing 13-7</a> is a modification of <span class="xref" itemid="xref_target_Listing 9-11 in Chapter 9"><a href="c09.xhtml#listing9-11">Listing 9-11</a> in Chapter 9</span> that uses macro invocations for calls to <code>r10ToStr</code>, <code>e10ToStr</code>, and some fixed calls to <code>printf</code> (for brevity, as this is a very long program, only the macros and a few invocations are included).</p>
<pre><code>           .
           .     ; About 1200 lines from Listing 9-10.
           .

; r10ToStr - Macro to create an HLL-like call for the 
;            _r10ToStr procedure.

; Parameters:

;   r10    - Must be the name of a real4, real8, or 
;            real10 variable.
;   dest   - Must be the name of a byte buffer to hold 
;            string result.

;   wdth   - Output width for the string. Either an
;            integer constant or a dword variable.

;   dPts   - Number of positions after the decimal
;            point. Either an integer constant or
;            a dword variable.

;   fill   - Fill char. Either a character constant
;            or a byte variable.

;   mxLen  - Maximum length of output string. Either
;            an integer constant or a dword variable.

r10ToStr     macro   r10, dest, wdth, dPts, fill, mxLen
             fld     r10
            
; dest is a label associated with a string variable:

             lea     rdi, dest
            
; wdth is either a constant or a dword var:

             mov     eax, wdth
            
; dPts is either a constant or a dword var
; holding the number of decimal point positions:

            mov     edx, dPts
            
<span epub:type="pagebreak" title="787" id="Page_787"/>; Process fill character. If it's a constant, 
; directly load it into ECX (which zero-extends
; into RCX). If it's a variable, then move with
; zero extension into ECX (which also zero-
; extends into RCX).
 
; Note: bit 2 from opattr is 1 if fill is 
; a constant.
            
            if      ((opattr fill) and 4) eq 4
            mov     ecx, fill
            else
            movzx   ecx, fill
            endif

; mxLen is either a constant or a dword var.
            
            mov     r8d, mxLen
            call    _r10ToStr
            endm

; e10ToStr - Macro to create an HLL-like call for the 
;            _e10ToStr procedure.

; Parameters:

;   e10   - Must be the name of a real4, real8, or 
;           real10 variable.
;   dest  - Must be the name of a byte buffer to hold 
;           string result.

;   wdth  - Output width for the string. Either an
;           integer constant or a dword variable.

;   xDigs - Number of exponent digits.

;   fill  - Fill char. Either a character constant
;           or a byte variable.

;   mxLen - Maximum length of output string. Either
;           an integer constant or a dword variable.

e10ToStr    macro   e10, dest, wdth, xDigs, fill, mxLen
            fld     e10
            
; dest is a label associated with a string variable:

            lea     rdi, dest
            
; wdth is either a constant or a dword var:

            mov     eax, wdth
            
<span epub:type="pagebreak" title="788" id="Page_788"/>; xDigs is either a constant or a dword var
; holding the number of decimal point positions:

            mov     edx, xDigs
            
; Process fill character. If it's a constant, 
; directly load it into ECX (which zero-extends
; into RCX). If it's a variable, then move with
; zero extension into ECX (which also zero-
; extends into RCX).

; Note: bit 2 from opattr is 1 if fill is 
; a constant.
            
            if      ((opattr fill) and 4) eq 4
            mov     ecx, fill
            else
            movzx   ecx, fill
            endif

; mxLen is either a constant or a dword var.
            
            mov     r8d, mxLen
            call    _e10ToStr
            endm
 
; puts - A macro to print a string using printf.
 
; Parameters:
 
;   fmt    - Format string (must be a byte
;            variable or string constant).

;   theStr - String to print (must be a
;            byte variable, a register,
;            or a string constant).

puts         macro   fmt, theStr
             local   strConst, bool
            
             lea     rcx, fmt
            
             if      ((opattr theStr) and 2)
            
; If memory operand:

             lea     rdx, theStr
            
             elseif  ((opattr theStr) and 10h)
            
; If register operand:

             mov     rdx, theStr
            
             else 
            
<span epub:type="pagebreak" title="789" id="Page_789"/>; Assume it must be a string constant.

            .data
strConst    byte    theStr, 0
            .code
            lea     rdx, strConst
            
            endif
            
            call    printf
            endm
        
            public  asmMain
asmMain     proc
            push    rbx
            push    rsi
            push    rdi
            push    rbp
            mov     rbp, rsp
            sub     rsp, 64         ; Shadow storage
            
; F output:

            r10ToStr r10_1, r10str_1, 30, 16, '*', 32
            jc      fpError
            puts    fmtStr1, r10str_1
            
            r10ToStr r10_1, r10str_1, 30, 15, '*', 32
            jc      fpError
            puts    fmtStr1, r10str_1
             .
             .    ; Similar code to Listing 9-10 with macro
             .    ; invocations rather than procedure calls.
; E output:

            e10ToStr e10_1, r10str_1, 26, 3, '*', 32
            jc      fpError
            puts    fmtStr3, r10str_1

            e10ToStr e10_2, r10str_1, 26, 3, '*', 32
            jc      fpError
            puts    fmtStr3, r10str_1
             .
             .    ; Similar code to Listing 9-10 with macro
             .    ; invocations rather than procedure calls.</code></pre>
<p class="CodeListingCaption"><a id="listing13-7">Listing 13-7</a>: Macro call implementation for converting floating-point values to strings</p>
<p>Compare the HLL-like calls to these three functions against the original procedure calls in <a href="c09.xhtml#listing9-11">Listing 9-11</a>:</p>
<pre><code>; F output:

fld     r10_1
lea     rdi, r10str_1
<span epub:type="pagebreak" title="790" id="Page_790"/>mov     eax, 30         ; fWidth
mov     edx, 16         ; decimalPts
mov     ecx, '*'        ; Fill
mov     r8d, 32         ; maxLength
call    r10ToStr
jc      fpError

lea     rcx, fmtStr1
lea     rdx, r10str_1
call    printf

fld     r10_1
lea     rdi, r10str_1
mov     eax, 30         ; fWidth
mov     edx, 15         ; decimalPts
mov     ecx, '*'        ; Fill
mov     r8d, 32         ; maxLength
call    r10ToStr
jc      fpError

lea     rcx, fmtStr1
lea     rdx, r10str_1
call    printf
.
.   ; Additional code from Listing 9-10.
.
; E output:

fld     e10_1
lea     rdi, r10str_1
mov     eax, 26         ; fWidth
mov     edx, 3          ; expDigits
mov     ecx, '*'        ; Fill
mov     r8d, 32         ; maxLength
call    e10ToStr
jc      fpError

lea     rcx, fmtStr3
lea     rdx, r10str_1
call    printf

fld     e10_2
lea     rdi, r10str_1
mov     eax, 26         ; fWidth
mov     edx, 3          ; expDigits
mov     ecx, '*'        ; Fill
mov     r8d, 32         ; maxLength
call    e10ToStr
jc      fpError

lea     rcx, fmtStr3
lea     rdx, r10str_1
call    printf
<span epub:type="pagebreak" title="791" id="Page_791"/>.
.   ; Additional code from Listing 9-10.
.</code></pre>
<p>Clearly, the macro version is easier to read (and, as it turns out, easier to debug and maintain too). </p>
<h3 id="h2-501089c13-0018">13.15.5	HLL-Like Calls with a Varying Parameter List</h3>
<p class="BodyFirst">Some procedures expect a varying number of parameters; the C/C++ <code>printf()</code> function is a good example. Some procedures, though they might support only a fixed number of arguments, could be better written using a varying argument list. For example, consider the <code>print</code> procedure that has appeared throughout the examples in this book; its string parameter (which follows the call to <code>print</code> in the code stream) is, technically, a single-string argument. Consider the following macro implementation for a call to <code>print</code>:</p>
<pre><code>print       macro   arg
            call    _print
            byte    arg, 0
            endm </code></pre>
<p>You could invoke this macro as follows:</p>
<pre><code>print  "Hello, World!"</code></pre>
<p>The only problem with this macro is that you will often want to supply multiple arguments in its invocation, such as this:</p>
<pre><code>print  "Hello, World!", nl, "It's a great day!", nl</code></pre>
<p>Unfortunately, this macro will not accept this list of parameters. However, this seems like a natural use of the <code>print</code> macro, so it makes a lot of sense to modify the <code>print</code> macro to handle multiple arguments and combine them as a single string after the call to the <code>_print</code> function. <a href="#listing13-8" id="listinganchor13-8">Listing 13-8</a> provides such an implementation.</p>
<pre><code>; Listing 13-8

; HLL-like procedure calls with
; a varying parameter list.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 13-8", 0

            .code
            externdef printf:proc
            
<span epub:type="pagebreak" title="792" id="Page_792"/>            include getTitle.inc
            
; Note: don't include print.inc here
; because this code uses a macro for
; print.

; print macro - HLL-like calling sequence for the _print
;               function (which is, itself, a shell for
;               the printf function).

; If print appears on a line by itself (no; arguments), 
; then emit a string consisting of a single newline 
; character (and zero-terminating byte). If there are 
; one or more arguments, emit each argument and append 
; a single 0 byte after all the arguments.

; Examples:

;           print
;           print   "Hello, World!"
;           print   "Hello, World!", nl

print       macro   arg1, optArgs:vararg
            call    _print
            
            ifb     &lt;arg1&gt;

; If print is used by itself, print a
; newline character:
            
            byte    nl, 0
            
            else
            
; If we have one or more arguments, then
; emit each of them:
            
            byte    arg1

            for     oa, &lt;optArgs&gt;
            
            byte    oa
            
            endm

; Zero-terminate the string.

            byte    0
            
            endif
            endm
 
_print      proc
            push    rax
            push    rbx
<span epub:type="pagebreak" title="793" id="Page_793"/>            push    rcx
            push    rdx
            push    r8
            push    r9
            push    r10
            push    r11
            
            push    rbp
            mov     rbp, rsp
            sub     rsp, 40
            and     rsp, -16
            
            mov     rcx, [rbp + 72]   ; Return address
            call    printf
            
            mov     rcx, [rbp + 72]
            dec     rcx
skipTo0:    inc     rcx
            cmp     byte ptr [rcx], 0
            jne     skipTo0
            inc     rcx
            mov     [rbp + 72], rcx
            
            leave
            pop     r11
            pop     r10
            pop     r9
            pop     r8
            pop     rdx
            pop     rcx
            pop     rbx
            pop     rax
            ret
_print      endp
              
p           macro   arg
            call    _print
            byte    arg, 0
            endm      
            
; Here is the "asmMain" function.
        
            public  asmMain
asmMain     proc
            push    rbx
            push    rdi
            push    rsi
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56         ; Shadow storage

            print   "Hello world"
            print
            print   "Hello, World!", nl
            
<span epub:type="pagebreak" title="794" id="Page_794"/>allDone:    leave
            pop     rsi
            pop     rdi
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing13-8">Listing 13-8</a>: Varying arguments’ implementation of <code>print</code> macro</p>
<p>Here’s the build command and output for the program in <a href="#listing13-8">Listing 13-8</a>:</p>
<pre><code>C:\&gt;<b>build listing13-8</b>

C:\&gt;<b>echo off</b>
 Assembling: listing13-8.asm
c.cpp

C:\&gt;<b>listing13-8</b>
Calling Listing 13-8:
Hello world
Hello, World!
Listing 13-8 terminated</code></pre>
<p>With this new <code>print</code> macro, you can now call the _<code>print</code> procedure in an HLL-like fashion by simply listing the arguments in the <code>print</code> invocation:</p>
<pre><code>print "Hello World", nl, "How are you today?", nl</code></pre>
<p>This will generate a byte directive that concatenates all the individual string components.</p>
<p>Note, by the way, that it is possible to pass a string containing multiple arguments to the original (single-argument) version of <code>print</code>. By rewriting the macro invocation</p>
<pre><code>print "Hello World", nl</code></pre>
<p class="BodyContinued">as</p>
<pre><code>print &lt;"Hello World", nl&gt;</code></pre>
<p class="BodyContinued">you get the desired output. MASM treats everything between the <code>&lt;</code> and <code>&gt;</code> brackets as a single argument. However, it’s a bit of a pain to have to constantly put these brackets around multiple arguments (and your code is inconsistent, as single arguments don’t require them). The <code>print</code> macro implementation with varying arguments is a much better solution.</p>
<h2 id="h1-501089c13-0016">	13.16	The invoke Macro</h2>
<p class="BodyFirst">At one time, MASM provided a special directive, <code>invoke</code>, that you could use to call a procedure and pass it parameters (it worked with the <code>proc</code> directive <span epub:type="pagebreak" title="795" id="Page_795"/>to determine the number and type of parameters a procedure expected). When Microsoft modified MASM to support 64-bit code, it removed the <code>invoke</code> statement from the MASM language. </p>
<p>However, some enterprising programmers have written MASM macros to simulate the <code>invoke</code> directive in 64-bit versions of MASM. The <code>invoke</code> macro not only is useful in its own right but also provides a great example of how to write advanced macros to call procedures. For more information on the <code>invoke</code> macro, visit <a href="https://www.masm32.com/" class="LinkURL">https://www.masm32.com/</a> and download the MASM32 SDK. This includes a set of macros (and other utilities) for 64-bit programs, including the <code>invoke</code> macro.</p>
<h2 id="h1-501089c13-0017">	13.17	Advanced Macro Parameter Parsing</h2>
<p class="BodyFirst">The previous sections provided examples of macro parameter processing used to determine the type of a macro argument in order to determine the type of code to emit. By carefully examining the attributes of an argument, a macro can make various choices concerning how to deal with that argument. This section presents some more advanced techniques you can use when processing macro arguments.</p>
<p>Clearly, the <code>opattr</code> compile-time operator is one of the most important tools you can use when looking at macro arguments. This operator uses the following syntax:</p>
<pre><code>opattr <var>expression</var></code></pre>
<p>Note that a generic address expression follows <code>opattr</code>; you are not limited to a single symbol.</p>
<p>The <code>opattr</code> operator returns an integer value that is a bit mask specifying the <code>opattr</code> attributes of the associated expression. If the expression following <code>opattr</code> contains forward-referenced symbols or is an illegal expression, <code>opattr</code> returns 0. Microsoft’s documentation indicates that <code>opattr</code> returns the values shown in <a href="#table13-2" id="tableanchor13-2">Table 13-2</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table13-2">Table 13-2</a>: <code>opattr</code> Return Values</p></figcaption>
<table id="table-501089c13-0002" border="1">
<thead>
<tr>
<td><b>Bit</b></td>
<td colspan="2"><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td colspan="2">There is a code label in the expression.</td>
</tr>
<tr>
<td>1</td>
<td colspan="2">The expression is relocatable.</td></tr>
<tr>
<td>2</td>
<td colspan="2">The expression is a constant expression.</td></tr>
<tr>
<td>3</td>
<td colspan="2">The expression is uses direct (PC-relative) addressing.</td></tr>
<tr>
<td>4</td>
<td colspan="2">The expression is a register.</td></tr>
<tr>
<td>5</td>
<td colspan="2">The expression contains no undefined symbols (obsolete).</td></tr>
<tr>
<td>6</td>
<td colspan="2">The expression is a stack-segment memory expression.</td></tr>
<tr>
<td>7</td>
<td colspan="2">The expression references an external symbol.</td></tr>
<tr>
<td><span epub:type="pagebreak" title="796" id="Page_796"/>8–11</td>
<td colspan="2">Language type<sup class="FootnoteReference"><a id="c13-footnoteref-12" href="#c13-footnote-12">*</a></sup></td></tr>
<tr>
<td/>
<td>Value</td>
<td>Language</td>
</tr>
<tr>
<td/>
<td>0</td>
<td>No language type</td>
</tr>
<tr>
<td/>
<td>1</td>
<td>C</td>
</tr>
<tr>
<td/>
<td>2</td>
<td>SYSCALL</td>
</tr>
<tr>
<td/>
<td>3</td>
<td>STDCALL</td>
</tr>
<tr>
<td/>
<td>4</td>
<td>Pascal</td>
</tr>
<tr>
<td/>
<td>5</td>
<td>FORTRAN</td>
</tr>
<tr>
<td/>
<td>6</td>
<td>BASIC</td>
</tr>
</tbody>
<tfoot>
<tr>
<td colspan="3"><p class="TableFootnote"><sup class="FootnoteReference"><a id="c13-footnote-12" href="#c13-footnoteref-12">*</a></sup> 64-bit code generally doesn’t support a language type, so these bits are usually 0.</p>
</td>
</tr>
</tfoot>
</table>
</figure>
<p>Quite honestly, Microsoft’s documentation does not do the best job explaining how MASM sets the bits. For example, consider the following MASM statements:</p>
<pre><code>codeLabel:
opcl       =  opattr codeLabel ; Sets opcl to 25h or 0010_0101b
opconst    =  opattr 0         ; Sets opconst to 36 or 0010_0100b</code></pre>
<p>The <code>opconst</code> has bits 2 and 5 set, just as you would expect from <a href="#table13-2">Table 13-2</a>. However, <code>opcl</code> has bits 0, 2, and 5 set; 0 and 5 make sense, but bit 2 (the expression is a constant expression) does not make sense. If, in a macro, you were to test only bit 2 to determine if the operand is a constant (as, I must admit, I have done in earlier examples in this chapter), you could get into trouble when bit 2 is set and you assume that it is a constant. </p>
<p>Probably the wisest thing to do is to mask off bits 0 to 7 (or maybe just bits 0 to 6) and compare the result against an 8-bit value rather than a simple mask. <a href="#table13-3" id="tableanchor13-3">Table 13-3</a> lists some common values you can test against.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table13-3">Table 13-3</a>: 8-Bit Values for <code>opattr</code> Results</p></figcaption>
<table id="table-501089c13-0003" border="1">
<thead>
<tr>
<td><b>Value</b></td>
<td><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Undefined (forward-referenced) symbol or illegal expression</td>
</tr>
<tr>
<td>34 / 22h</td>
<td>Memory access of the form <code>[</code><var>reg</var><code> + </code><var>const</var><code>]</code></td>
</tr>
<tr>
<td>36 / 24h</td>
<td>Constant</td>
</tr>
<tr>
<td>37 / 25h</td>
<td>Code label (proc name or symbol with a <code>:</code> suffix) or <code>offset </code><var>code_label</var> form</td>
</tr>
<tr>
<td>38 / 26h</td>
<td>Expression of the form <code>offset </code><var>label</var>, where <var>label</var> is a variable in the <code>.data</code> section</td>
</tr>
<tr>
<td>42 / 2Ah</td>
<td>Global symbol (for example, symbol in <code>.data</code> section)</td>
</tr>
<tr>
<td>43 / 2Bh</td>
<td>Memory access of the form <code>[</code><var>reg</var><code> + </code><var>code_label</var><code>]</code>, where <var>code_label</var> is a proc name or symbol with <code>:</code> suffix</td>
</tr>
<tr>
<td><span epub:type="pagebreak" title="797" id="Page_797"/>48 / 30h</td>
<td>Register (general-purpose, MM, XMM, YMM, ZMM, floating-point/ST, or other special-purpose register)</td>
</tr>
<tr>
<td>98 / 62h</td>
<td>Stack-relative memory access (memory addresses of the form <code>[rsp + </code><var>xxx</var><code>]</code> and <code>[rbp + </code><var>xxx</var><code>]</code>)</td>
</tr>
<tr>
<td>165 / 0A5h</td>
<td>External code symbol (37 / 25h with bit 7 set)</td>
</tr>
<tr>
<td>171 / ABh</td>
<td>External data symbol (43 / 2Bh with bit 7 set)</td>
</tr>
</tbody>
</table>
</figure>
<p>Perhaps the biggest issue with <code>opattr</code>, as has already been pointed out, is that it believes that constant expressions are integers that can fit into 64 bits. This creates a problem for two important constant types: string literals (longer than 8 characters) and floating-point constants. <code>opattr</code> returns 0 for both.<sup class="FootnoteReference"><a id="c13-footnoteref-7" href="#c13-footnote-7">8</a></sup></p>
<h3 id="h2-501089c13-0019">13.17.1	Checking for String Literal Constants</h3>
<p class="BodyFirst">Although <code>opattr</code> won’t help us determine whether an operand is a string, we can use MASM’s string-processing operations to test the first character of an operand to see if it is a quote. The following code does just that:</p>
<pre><code>; testStr is a macro function that tests its
; operand to see if it is a string literal.
            
testStr     macro   strParm
            local   firstChar
            
            ifnb    &lt;strParm&gt;
firstChar   substr  &lt;strParm&gt;, 1, 1

            ifidn   firstChar,&lt;!"&gt;
            
; First character was ", so assume it's
; a string.

            exitm   &lt;1&gt;
            endif   ; ifidn
            endif   ; ifnb
            
; If we get to this point in the macro,
; we definitely do not have a string.

            exitm   &lt;0&gt;
            endm</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p> 	This macro looks only for a leading quote (<code>"</code>), but MASM strings can also be delimited by apostrophes. I’ll leave it up to you to expand this macro to handle apostrophes as well as quotes.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="798" id="Page_798"/>Consider the following two invocations of the <code>testStr</code> macro:</p>
<pre><code>isAStr  = testStr("String Literal")
notAStr = testStr(someLabel)</code></pre>
<p>MASM will set the symbol <code>isAStr</code> to the value 1, and <code>notAStr</code> to the value 0.</p>
<h3 id="h2-501089c13-0020">13.17.2	Checking for Real Constants</h3>
<p class="BodyFirst"><em>Real constants</em> are another literal type that MASM’s <code>opattr</code> operator doesn’t support. Again, writing a macro to test for a real constant can resolve that issue. Sadly, parsing real numbers isn’t as easy as checking for a string constant: there is no single leading character that we can use to say, “Hey, we’ve got a floating-point constant here.” The macro will have to explicitly parse the operand character by character and validate it.</p>
<p>To begin with, here is a grammar that defines a MASM floating-point constant:</p>
<pre><code>Sign     ::= (+|-) 
Digit    ::= [0-9]
Mantissa ::= (Digit)+ | '.' Digit)+ | (Digit)+ '.' Digit*
Exp      ::= (e|E) Sign? Digit? Digit? Digit?
Real     ::= Sign? Mantissa Exp?</code></pre>
<p>A real number consists of an optional sign followed by a mantissa and an optional exponent. A mantissa contains at least one digit; it can also contain a decimal point with a digit to its left or right (or both). However, a mantissa cannot consist of a decimal point by itself.</p>
<p>The macro function to test for a real constant should be callable as follows:</p>
<pre><code>isReal = getReal(<var>some_text</var>)</code></pre>
<p class="BodyContinued">where <var>some_text</var> is the textual data we want to test to see if it’s a real constant. The macro for <code>getReal</code> could be the following:</p>
<pre><code>; getReal - Parses a real constant.

; Returns:
;    true  - If the parameter contains a syntactically
;            correct real number (and no extra characters).
;    false - If there are any illegal characters or
;            other syntax errors in the numeric string.

getReal      macro   origParm
             local   parm, curChar, result
            
; Make a copy of the parameter so we don't
; delete the characters in the original string.

parm         textequ &amp;origParm

<span epub:type="pagebreak" title="799" id="Page_799"/>; Must have at least one character:

            ifb     parm
            exitm   &lt;0&gt;
            endif
            
; Extract the optional sign:

            if      isSign(parm)
curChar     textequ extract1st(parm)        ; Skip sign char
            endif
            
; Get the required mantissa:

            if      getMant(parm) eq 0
            exitm   &lt;0&gt;                     ; Bad mantissa
            endif

; Extract the optional exponent:

result      textequ getExp(parm)    
            exitm   &lt;&amp;result&gt;       
            
            endm    ; getReal</code></pre>
<p>Testing for real constants is a complex process, so it’s worthwhile to go through this macro (and all subservient macros) step by step:</p>
<ol class="decimal">
<li value="1">Make a copy of the original parameter string. During processing, <code>getReal</code> will delete characters from the parameter string while parsing the string. This macro makes a copy to prevent disturbing the original text string passed in to it.</li>
<li value="2">Check for a blank parameter. If the caller passes in an empty string, the result is not a valid real constant and <code>getReal</code> must return false. It’s important to check for the empty string right away because the rest of the code makes the assumption that the string is at least one character long.</li>
<li value="3">Call the <code>getSign</code> macro function. This function (its definition appears a little later) returns true if the first character of its argument is a <code>+</code> or <code>-</code> symbol; otherwise, it returns false. </li>
<li value="4">If the first character is a sign character, invoke the <code>extract1st</code> macro:
<pre><code>curChar     textequ extract1st(parm)        ; Skip sign char</code></pre>
<p class="ListBody">The <code>extract1st</code> macro returns the first character of its argument as the function result (which this statement assigns to the <code>curChar</code> symbol) and then deletes the first character of its argument. So if the original string passed to <code>getReal</code> was <code>+1</code>, this statement puts <code>+</code> into <code>curChar</code> and deletes the first character in <code>parm</code> (producing the string <code>1</code>). The definition for <code>extract1st</code> appears a little later in this section.</p>
<p class="ListBody"><span epub:type="pagebreak" title="800" id="Page_800"/><code>getReal</code> doesn’t actually use the sign character assigned to <code>curChar</code>. The purpose of this <code>extract1st</code> invocation was strictly for the side effect of deleting the first character in <code>parm</code>.</p></li>
<li value="5">Invoke <code>getMant</code>. This macro function will return true if the prefix of its string argument is a valid mantissa. It will return false if the mantissa does not contain at least one numeric digit. Note that <code>getMant</code> will stop processing the string on the first non-mantissa character it encounters (including a second decimal point, if there are two or more decimal points in the mantissa). The <code>getMant</code> function doesn’t care about illegal characters; it leaves it up to <code>getReal</code> to look at the remaining characters after the return from <code>getMant</code> to determine if the whole string is valid. As a side effect, <code>getMant</code> deletes all leading characters from the parameter string that it processes.</li>
<li value="6">Invoke the <code>getExp</code> macro function to process any (optional) trailing exponent. The <code>getExp</code> macro is also responsible for ensuring that no garbage characters follow (which results in a parse failure).</li>
</ol>
<p>The <code>isSign</code> macro is fairly straightforward. Here’s its implementation:</p>
<pre><code>; isSign - Macro function that returns true if the
;          first character of its parameter is a
;          "+" or "-".

isSign      macro   parm
            local   FirstChar
            ifb     &lt;parm&gt;
            exitm   &lt;0&gt;
            endif

FirstChar   substr  parm, 1, 1
            ifidn   FirstChar, &lt;+&gt;
            exitm   &lt;1&gt;
            endif
            ifidn   FirstChar, &lt;-&gt;
            exitm   &lt;1&gt;
            endif
            exitm   &lt;0&gt;
            endm</code></pre>
<p>This macro uses the <code>substr</code> operation to extract the first character from the parameter and then compares this against the sign characters (<code>+</code> or <code>-</code>). It returns true if it is a sign character, and false otherwise. </p>
<p>The <code>extract1st</code> macro function removes the first character from the argument passed to it and returns that character as the function result. As a side effect, this macro function also deletes the first character from the parameter passed to it. Here’s <code>extract1st</code>’s implementation:</p>
<pre><code>extract1st  macro   parm
            local   FirstChar
            ifb     &lt;%parm&gt;
<span epub:type="pagebreak" title="801" id="Page_801"/>            exitm   &lt;&gt;
            endif
FirstChar   substr  parm, 1, 1
            if      @sizestr(%parm) GE 2
parm        substr  parm, 2
            else
parm        textequ &lt;&gt;
            endif

            exitm   &lt;FirstChar&gt;
            endm</code></pre>
<p>The <code>ifb</code> directive checks whether the parameter string is empty. If it is, <code>extract1st</code> immediately returns the empty string without further modification to its parameter.</p>
<p>Note the <code>%</code> operator before the <code>parm</code> argument. The <code>parm</code> argument actually expands to the name of the string variable holding the real constant. This turns out to be something like <code>??0005</code> because of the copy made of the original parameter in the <code>getReal</code> function. Were you to simply specify <code>ifb &lt;parm&gt;</code>,<code> </code>the <code>ifb</code> directive would see <code>&lt;??0005&gt;</code>, which is not blank. Placing the <code>%</code> operator before the <code>parm</code> symbol tells MASM to evaluate the expression (which is just the <code>??0005</code> symbol) and replace it by the text it evaluates to (which, in this case, is the actual string). </p>
<p>If the string is not blank, <code>extract1st</code> uses the <code>substr</code> directive to extract the first character from the string and assigns this character to the <code>FirstChar</code> symbol. The <code>extract1st</code> macro function will return this value as the function result.</p>
<p>Next, the <code>extract1st</code> function has to delete the first character from the parameter string. It uses the <code>@sizestr</code> function (whose definition appears a little earlier in this chapter) to determine whether the character string contains at least two characters. If so, <code>extract1st</code> uses the <code>substr</code> directive to extract all the characters from the parameter, starting at the second character position. It assigns this substring back to the parameter passed in. If <code>extract1st</code> is processing the last character in the string (that is, if <code>@sizestr</code> returns 1), then the code cannot use the <code>substr</code> directive because the index would be out of range. The <code>else</code> section of the <code>if</code> directive returns an empty string if <code>@sizestr</code> returns a value less than 2.</p>
<p>The next <code>getReal</code> subservient macro function is <code>getMant</code>. This macro is responsible for parsing the mantissa component of the floating-point constant. The implementation is the following:</p>
<pre><code>getMant     macro   parm
            local   curChar, sawDecPt, rpt
sawDecPt    =       0
curChar     textequ extract1st(parm)        ; Get 1st char
            ifidn   curChar, &lt;.&gt;            ; Check for dec pt
sawDecPt    =       1
curChar     textequ extract1st(parm)        ; Get 2nd char
            endif
            
<span epub:type="pagebreak" title="802" id="Page_802"/>; Must have at least one digit:

            if      isDigit(curChar) eq 0
            exitm   &lt;0&gt;                     ; Bad mantissa
            endif
            
; Process zero or more digits. If we haven't already
; seen a decimal point, allow exactly one of those.
 
; Do loop at least once if there is at least one
; character left in parm:

rpt         =       @sizestr(%parm)
            while   rpt
            
; Get the 1st char from parm and see if
; it is a decimal point or a digit:

curChar     substr  parm, 1, 1
            ifidn   curChar, &lt;.&gt;
rpt         =       sawDecPt eq 0
sawDecPt    =       1
            else
rpt         =       isDigit(curChar)
            endif

; If char was legal, then extract it from parm:

            if      rpt
curChar     textequ extract1st(parm)        ; Get next char
            endif
            
; Repeat as long as we have more chars and the
; current character is legal:

rpt         =       rpt and (@sizestr(%parm) gt 0)
            endm    ; while
            
; If we've seen at least one digit, we've got a valid
; mantissa. We've stopped processing on the first 
; character that is not a digit or the 2nd "." char.

            exitm   &lt;1&gt;
            endm    ; getMant</code></pre>
<p>A mantissa must have at least one decimal digit. It can have zero or one occurrence of a decimal point (which may appear before the first digit, at the end of the mantissa, or in the middle of a string of digits). The <code>getMant</code> macro function uses the local symbol <code>sawDecPt</code> to keep track of whether it has seen a decimal point already. The function begins by initializing <code>sawDecPt</code> to false (0).</p>
<p>A valid mantissa must have at least one character (because it must have at least one decimal digit). So the next thing <code>getMant</code> does is extract the first <span epub:type="pagebreak" title="803" id="Page_803"/>character from the parameter string (and place this character in <code>curChar</code>). If the first character is a period (decimal point), the macro sets <code>sawDecPt</code> to true.</p>
<p>The <code>getMant</code> function uses a <code>while</code> directive to process all the remaining characters in the mantissa. A local variable, <code>rpt</code>, controls the execution of the <code>while</code> loop. The code at the beginning of <code>getMant</code> sets <code>rpt</code> to true if the first character is a period or a decimal digit. The <code>isDigit</code> macro function tests the first character of its argument and returns true if it’s one of the characters 0 to 9. The definition for <code>isDigit</code> will appear shortly.</p>
<p>If the first character in the parameter was a dot (<code>.</code>) or a decimal digit, the <code>getMant</code> function removes that character from the beginning of the string and executes the body of the <code>while</code> loop for the first time if the new parameter string length is greater than zero.</p>
<p>The <code>while</code> loop grabs the first character from the current parameter string (without deleting it just yet) and tests it against a decimal digit or a <code>.</code> character. If it’s a decimal digit, the loop will remove that character from the parameter string and repeat. If the current character is a period, the code first checks whether it has already seen a decimal point (using <code>sawDecPt</code>). If this is a second decimal point, the function returns true (later code will deal with the second <code>.</code> character). If the code has not already seen a decimal point, the loop sets <code>sawDecPt</code> to true and continues with the loop execution.</p>
<p>The <code>while</code> loop repeats as long as it sees decimal digits, a single decimal point, or a string with length greater than zero. Once the loop completes, the <code>getMant</code> function returns true. The only way <code>getMant</code> returns false is if it does not see at least one decimal digit (either at the beginning of the string or immediately after the decimal point at the beginning of the string). </p>
<p>The <code>isDigit</code> macro function is a brute-force function that tests its first character against the 10 decimal digits. This function does not remove any characters from its parameter argument. The source code for <code>isDigit</code> is the following:</p>
<pre><code>isDigit     macro   parm
            local   FirstChar
            if      @sizestr(%parm) eq 0
            exitm   &lt;0&gt;
            endif
            
FirstChar   substr  parm, 1, 1
            ifidn   FirstChar, &lt;0&gt;
            exitm   &lt;1&gt;
            endif
            ifidn   FirstChar, &lt;1&gt;
            exitm   &lt;1&gt;
            endif
            ifidn   FirstChar, &lt;2&gt;
            exitm   &lt;1&gt;
            endif
            ifidn   FirstChar, &lt;3&gt;
            exitm   &lt;1&gt;
            endif
            ifidn   FirstChar, &lt;4&gt;
            exitm   &lt;1&gt;
<span epub:type="pagebreak" title="804" id="Page_804"/>            endif
            ifidn   FirstChar, &lt;5&gt;
            exitm   &lt;1&gt;
            endif
            ifidn   FirstChar, &lt;6&gt;
            exitm   &lt;1&gt;
            endif
            ifidn   FirstChar, &lt;7&gt;
            exitm   &lt;1&gt;
            endif
            ifidn   FirstChar, &lt;8&gt;
            exitm   &lt;1&gt;
            endif
            ifidn   FirstChar, &lt;9&gt;
            exitm   &lt;1&gt;
            endif
            exitm   &lt;0&gt;
            endm</code></pre>
<p>The only thing worth commenting on is the <code>%</code> operator in <code>@sizestr</code> (for reasons explained earlier).</p>
<p>Now we arrive at the last helper function appearing in <code>getReal</code>: the <code>getExp</code> (<em>get exponent</em>) macro function. Here’s its implementation:</p>
<pre><code>getExp      macro   parm
            local   curChar
            
; Return success if no exponent present.

            if      @sizestr(%parm) eq 0
            exitm   &lt;1&gt;
            endif

; Extract the next character, return failure
; if it is not an "e" or "E" character:
            
curChar     textequ extract1st(parm)
            if      isE(curChar) eq 0
            exitm   &lt;0&gt;
            endif

; Extract the next character:
            
curChar     textequ extract1st(parm)

; If an optional sign character appears,
; remove it from the string:

            if      isSign(curChar)
curChar     textequ extract1st(parm)        ; Skip sign char
            endif                           ; isSign
            
; Must have at least one digit:

            if      isDigit(curChar) eq 0
<span epub:type="pagebreak" title="805" id="Page_805"/>            exitm   &lt;0&gt;
            endif
            
; Optionally, we can have up to three additional digits:

            if      @sizestr(%parm) gt 0
curChar     textequ extract1st(parm)        ; Skip 1st digit
            if      isDigit(curChar) eq 0
            exitm   &lt;0&gt;
            endif
            endif

            if      @sizestr(%parm) gt 0
curChar     textequ extract1st(parm)        ; Skip 2nd digit
            if      isDigit(curChar) eq 0
            exitm   &lt;0&gt;
            endif
            endif

            if      @sizestr(%parm) gt 0
curChar     textequ extract1st(parm)        ; Skip 3rd digit
            if      isDigit(curChar) eq 0
            exitm   &lt;0&gt;
            endif
            endif

; If we get to this point, we have a valid exponent.

            exitm   &lt;1&gt;     
            endm    ; getExp</code></pre>
<p>Exponents are optional in a real constant. Therefore, the first thing this macro function does is check whether it has been passed an empty string. If so, it immediately returns success. Once again, the <code>ifb &lt;%parm&gt;</code> directive must have the <code>%</code> operator before the <code>parm</code> argument.</p>
<p>If the parameter string is not empty, the first character in the string must be an <code>E</code> or <code>e</code> character. This function returns false if this is not the case. Checking for an <code>E</code> or <code>e</code> is done with the <code>isE</code> helper function, whose implementation is the following (note the use of <code>ifidni</code>, which is case-insensitive):</p>
<pre><code>isE         macro   parm
            local   FirstChar
            if      @sizestr(%parm) eq 0
            exitm   &lt;0&gt;
            endif
            
FirstChar   substr  parm, 1, 1
            ifidni   FirstChar, &lt;e&gt;
            exitm   &lt;1&gt;
            endif
            exitm   &lt;0&gt;
            endm</code></pre>
<p><span epub:type="pagebreak" title="806" id="Page_806"/>Next, the <code>getExp</code> function looks for an optional sign character. If it encounters one, it deletes the sign character from the beginning of the string.</p>
<p>At least one decimal digit, and at most four decimal digits, must follow the <code>e</code> or <code>E</code> and sign characters. The remaining code in <code>getExp</code> handles that.</p>
<p><a href="#listing13-9" id="listinganchor13-9">Listing 13-9</a> is a demonstration of the macro snippets appearing throughout this section. Note that this is a pure compile-time program; all its activity takes place while MASM assembles this source code. It does not generate any executable machine code.</p>
<pre><code>; Listing 13-9

; This is a compile-time program.
; It does not generate any executable code.

; Several useful macro functions:

; mout       - Like echo, but allows "%" operators.

; testStr    - Tests an operand to see if it
;              is a string literal constant.

; @sizestr   - Handles missing MASM function.

; isDigit    - Tests first character of its
;              argument to see if it's a decimal
;              digit.

; isSign     - Tests first character of its
;              argument to see if it's a "+"
;              or a "-" character.

; extract1st - Removes the first character
;              from its argument (side effect)
;              and returns that character as
;              the function result.

; getReal    - Parses the argument and returns
;              true if it is a reasonable-
;              looking real constant.

; Test strings and invocations for the
; getReal macro:

 <var>Note: actual macro code appears in previous code snippets</var>
<var>   and has been removed from this listing </var><var>for brevity</var> 
            
mant1       textequ &lt;1&gt;
mant2       textequ &lt;.2&gt;
mant3       textequ &lt;3.4&gt;
rv4         textequ &lt;1e1&gt;
rv5         textequ &lt;1.e1&gt;
rv6         textequ &lt;1.0e1&gt;
rv7         textequ &lt;1.0e + 1&gt;
<span epub:type="pagebreak" title="807" id="Page_807"/>rv8         textequ &lt;1.0e - 1&gt;
rv9         textequ &lt;1.0e12&gt;
rva         textequ &lt;1.0e1234&gt;
rvb         textequ &lt;1.0E123&gt;
rvc         textequ &lt;1.0E + 1234&gt;
rvd         textequ &lt;1.0E - 1234&gt;
rve         textequ &lt;-1.0E - 1234&gt;
rvf         textequ &lt;+1.0E - 1234&gt;
badr1       textequ &lt;&gt;
badr2       textequ &lt;a&gt;
badr3       textequ &lt;1.1.0&gt;
badr4       textequ &lt;e1&gt;
badr5       textequ &lt;1ea1&gt;
badr6       textequ &lt;1e1a&gt;

% echo get_Real(mant1) = getReal(mant1) 
% echo get_Real(mant2) = getReal(mant2)
% echo get_Real(mant3) = getReal(mant3)
% echo get_Real(rv4)   = getReal(rv4)
% echo get_Real(rv5)   = getReal(rv5)
% echo get_Real(rv6)   = getReal(rv6)
% echo get_Real(rv7)   = getReal(rv7)
% echo get_Real(rv8)   = getReal(rv8)
% echo get_Real(rv9)   = getReal(rv9)
% echo get_Real(rva)   = getReal(rva)
% echo get_Real(rvb)   = getReal(rvb)
% echo get_Real(rvc)   = getReal(rvc)
% echo get_Real(rvd)   = getReal(rvd)
% echo get_Real(rve)   = getReal(rve)
% echo get_Real(rvf)   = getReal(rvf)
% echo get_Real(badr1) = getReal(badr1)
% echo get_Real(badr2) = getReal(badr2)
% echo get_Real(badr3) = getReal(badr3)
% echo get_Real(badr4) = getReal(badr4)
% echo get_Real(badr5) = getReal(badr5)
% echo get_Real(badr5) = getReal(badr5)
        end</code></pre>
<p class="CodeListingCaption"><a id="listing13-9">Listing 13-9</a>: Compile-time program with test code for <code>getReal</code> macro</p>
<p>Here’s the build command and (compile-time) program output:</p>
<pre><code>C:\&gt;<b>ml64 /c listing13-9.asm</b>
Microsoft (R) Macro Assembler (x64) Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

 Assembling: listing13-9.asm
get_Real(1) = 1
get_Real(.2) = 1
get_Real(3.4) = 1
get_Real(1e1)  = 1
get_Real(1.e1) = 1
get_Real(1.0e1) = 1
get_Real(1.0e + 1) = 1
<span epub:type="pagebreak" title="808" id="Page_808"/>get_Real(1.0e - 1) = 1
get_Real(1.0e12) = 1
get_Real(1.0e1234) = 1
get_Real(1.0E123) = 1
get_Real(1.0E + 1234) = 1
get_Real(1.0E - 1234) = 1
get_Real(-1.0E - 1234) = 1
get_Real(+1.0E - 1234) = 1
get_Real() = 0
get_Real(a) = 0
get_Real(1.1.0) = 0
get_Real(e1) = 0
get_Real(1ea1) = 0
get_Real(1ea1) = 0</code></pre>
<h3 id="h2-501089c13-0021">13.17.3	Checking for Registers</h3>
<p class="BodyFirst">Although the <code>opattr</code> operator provides a bit to tell you that its operand is an x86-64 register, that’s the only information <code>opattr</code> provides. In particular, <code>opattr</code>’s return value won’t tell you which register it has seen; whether it’s a general-purpose, XMM, YMM, ZMM, MM, ST, or other register; or the size of that register. Fortunately, with a little work on your part, you can determine all this information by using MASM’s conditional assembly statements and other operators.</p>
<p>To begin with, here’s a simple macro function, <code>isReg</code>, that returns 1 or 0 depending on whether its operand is a register. This is a simple shell around the <code>opattr</code> operator that returns the setting of bit 4:</p>
<pre><code>isReg       macro   parm
            local   result
result      textequ %(((opattr &amp;parm) and 10h) eq 10h)
            exitm   &lt;&amp;result&gt;
            endm</code></pre>
<p>While this function provides some convenience, it doesn’t really provide any information that the <code>opattr</code> operator already provides. We want to know what register appears in the operand as well as the size of that register. </p>
<p>Listing 13-10 (available online at <a href="http://artofasm.randallhyde.com/" class="LinkURL">http://artofasm.randallhyde.com/</a>) provides a wide range of useful macro functions and equates for processing register operands in your own macros. The following paragraphs describe some of the more useful equates and macros.</p>
<p>Listing 13-10 contains a set of equates that map register names to numeric values. These equates use symbols of the form <code>reg</code><var>XXX</var>, where <var>XXX</var> is the register name (all uppercase). Examples include the following: <code>regAL</code>, <code>regSIL</code>, <code>regR8B</code>, <code>regAX</code>, <code>regBP</code>, <code>regR8W</code>, <code>regEAX</code>, <code>regEBP</code>, <code>regR8D</code>, <code>regRAX</code>, <code>regRSI</code>, <code>regR15</code>, <code>regST</code>, <code>regST0</code>, <code>regMM0</code>, <code>regXMM0</code>, and <code>regYMM0</code>.</p>
<p>There is also a special equate for the symbol <code>regNone</code> that represents a non-register entity. These equates give numeric values in the range 1 to 117 to each of these symbols (<code>regNone</code> is given the value 0).</p>
<p><span epub:type="pagebreak" title="809" id="Page_809"/>The purpose behind all these equates (and, in general, assigning numeric values to registers) is to make it easier to test for specific registers (or ranges of registers) within your macros by using conditional assembly.</p>
<p>A useful set of macros appearing in Listing 13-10 converts textual forms of the register names (that is, AL, AX, EAX, RAX, and so forth) to their numeric form (<code>regAL</code>, <code>regAX</code>, <code>regEAX</code>, <code>regRAX</code>, and so on). The most generic macro function to do this is <code>whichReg(</code><var>register</var><code>)</code>. This function accepts a text object and returns the appropriate <code>reg</code><var>XXX</var> value for that text. If the text passed as an argument is not one of the valid general-purpose, FPU, MMX, XMM, or YMM registers, <code>whichReg</code> returns the value <code>regNone</code>. Here are some examples of calls to <code>whichReg</code>:</p>
<pre><code>alVal  =       whichReg(al)
axTxt  textequ &lt;ax&gt;
axVal  =       whichReg(axTxt)

aMac   macro   parameter
       local   regVal
regVal =       whichReg(parameter)
       if      regVal eq regNone
       .err    &lt;Expected a register argument&gt;
       exitm
       endif
         .
         .
         .
       endm</code></pre>
<p>The <code>whichReg</code> macro function accepts any of the x86-64 general-purpose, FPU, MMX, XMM, or YMM registers. In many situations, you might want to limit the set of registers to a particular subset of these. Therefore, Listing 13-11 (also available online at <a href="http://artofasm.randallhyde.com/" class="LinkURL">http://artofasm.randallhyde.com/</a>) provides the following macro functions:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>isGPReg(</code></span><var class="bold">text</var><code class="bold">)</code></span>  Returns a nonzero register value for any of the general-purpose (8-, 16-, 32-, or 64-bit) registers. Returns <code>regNone</code> (0) if the argument is not one of these registers.</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>is8BitReg(</code></span><var class="bold">text</var><code class="bold">)</code></span>  Returns a nonzero register value for any of the general-purpose 8-bit registers. Otherwise, it returns <code>regNone</code> (0).</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>is16BitReg(</code></span><var class="bold">text</var><code class="bold">)</code></span>  Returns a nonzero register value for any of the general-purpose 16-bit registers. Otherwise, it returns <code>regNone</code> (0).</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>is32BitReg(</code></span><var class="bold">text</var><code class="bold">)</code></span>  Returns a nonzero register value for any of the general-purpose 32-bit registers. Otherwise, it returns <code>regNone</code> (0).</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>is64BitReg(</code></span><var class="bold">text</var><code class="bold">)</code></span>  Returns a nonzero register value for any of the general-purpose 64-bit registers. Otherwise, it returns <code>regNone</code> (0).</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>isFPReg(</code></span><var class="bold">text</var><code class="bold">)</code></span>  Returns a nonzero register value for any of the FPU registers (<code>ST</code>, and <code>ST(0)</code> to<code> ST(7)</code>). Otherwise, it returns <code>regNone</code> (0).</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>isMMReg(</code></span><var class="bold">text</var><code class="bold">)</code></span>  Returns a nonzero register value for any of the MMX registers (<code>MM0</code> to <code>MM7</code>). Otherwise, it returns <code>regNone</code> (0).</li>
<li><span epub:type="pagebreak" title="810" id="Page_810"/><span class="RunInHead"><span class="LiteralBold"><code>isXMMReg</code></span><code class="bold">(</code><var class="bold">text</var><code class="bold">)</code></span>  Returns a nonzero register value for any of the XMM registers (<code>XMM0</code> to <code>XMM15</code>). Otherwise, it returns <code>regNone</code> (0).</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>isYMMReg</code></span><code class="bold">(</code><var class="bold">text</var><code class="bold">)</code></span>  Returns a nonzero register value for any of the YMM registers (<code>YMM0</code> to <code>YMM15</code>). Otherwise, it returns <code>regNone</code> (0).</li>
</ol>
<p>If you need other register classifications, it’s easy to write your own macro functions to return an appropriate value. For example, if you want to test whether a particular register is one of the Windows ABI parameter registers (RCX, RDX, R8, or R9), you could create a macro function like the following:</p>
<pre><code>isWinParm  macro  theReg
           local  regVal, isParm
regVal      =     whichReg(theReg)
isParm      =     (regVal eq regRCX) or (regVal eq regRDX)
isParm      =     isParm or (regVal eq regR8)
isParm      =     isParm or (regVal eq regR9)

            if    isParm
            exitm &lt;%regVal&gt;
            endif
            exitm &lt;%regNone&gt;
            endm</code></pre>
<p>If you’ve converted a register in text form to its numeric value, at some point you might need to convert that numeric value back to text so you can use that register as part of an instruction. The <code>toReg(</code><var>reg_num</var><code>)</code> macro in Listing 13-10 accomplishes this. If you supply it a value in the range 1 to 117 (the numeric values for the registers), this macro will return the text that corresponds to that register value. For example:</p>
<pre><code>mov toReg(1), 0    ; Equivalent to mov al, 0</code></pre>
<p>(Note that <code>regAL</code> = 1.)</p>
<p>If you pass <code>regNone</code> to the <code>toReg</code> macro, <code>toReg</code> returns an empty string. Any value outside the range 0 to 117 will produce an undefined symbol error message.</p>
<p>When working in macros, where you’ve passed a register as an argument, you may find that you need to convert that register to a larger size (for example, convert AL to AX, EAX, or RAX; convert AX to EAX or RAX; or convert EAX to RAX). Listing 13-11 provides several macros to do the up conversion. These macro functions accept a register number as their parameter input and produce a textual result holding the actual register name:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>reg8To16</code></span></span>  Converts an 8-bit general-purpose register to its 16-bit equivalent<sup class="FootnoteReference"><a id="c13-footnoteref-8" href="#c13-footnote-8">8</a></sup></li>
<li><span class="RunInHead"><span class="LiteralBold"><code>reg8To32</code></span></span>  Converts an 8-bit general-purpose register to its 32-bit equivalent </li>
<li><span epub:type="pagebreak" title="811" id="Page_811"/><span class="RunInHead"><span class="LiteralBold"><code>reg8To64</code></span></span>  Converts an 8-bit general-purpose register to its 64-bit equivalent </li>
<li><span class="RunInHead"><span class="LiteralBold"><code>reg16To32</code></span></span>  Converts a 16-bit general-purpose register to its 32-bit equivalent</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>reg16To64</code></span></span>  Converts a 16-bit general-purpose register to its 64-bit equivalent </li>
<li><span class="RunInHead"><span class="LiteralBold"><code>reg32To64</code></span></span>  Converts a 32-bit general-purpose register to its 64-bit equivalent</li>
</ol>
<p>Another useful macro function in Listing 13-10 is the <code>regSize(</code><var>reg_value</var><code>)</code> macro. This function returns the size (in bytes) of the register value passed as an argument. Here are some example calls:</p>
<pre><code>alSize    =  regSize(regAL)   ; Returns 1
axSize    =  regSize(regAX)   ; Returns 2
eaxSize   =  regSize(regEAX)  ; Returns 4
raxSize   =  regSize(regRAX)  ; Returns 8
stSize    =  regSize(regST0)  ; Returns 10
mmSize    =  regSize(regMM0)  ; Returns 8
xmmSize   =  regSize(regXMM0) ; Returns 16
ymmSize   =  regSize(regYMM0) ; Returns 32</code></pre>
<p>The macros and equates in Listing 13-10 come in handy when you are writing macros to handle generic code. For example, suppose you want to create a <code>putInt</code> macro that accepts an arbitrary 8-, 16-, or 32-bit register operand and that will print that register’s value as an integer. You would like to be able to pass any arbitrary (general-purpose) register and sign-extend it, if necessary, before printing. <a href="#listing13-12" id="listinganchor13-12">Listing 13-12</a> is one possible implementation of this macro.</p>
<pre><code>; Listing 13-12
 
; Demonstration of putInt macro.
 
; putInt - This macro expects an 8-, 16-, or 32-bit
;          general-purpose register argument. It will
;          print the value of that register as an
;          integer.

putInt      macro   theReg
            local   regVal, sz
regVal      =       isGPReg(theReg)

; Before we do anything else, make sure
; we were actually passed a register:

            if      regVal eq regNone
            .err    &lt;Expected a register&gt;
            endif

; Get the size of the register so we can
; determine if we need to sign-extend its
<span epub:type="pagebreak" title="812" id="Page_812"/>; value:
            
sz          =       regSize(regVal)

; If it was a 64-bit register, report an
; error:

            if      sz gt 4
            .err    64-bit register not allowed
            endif

; If it's a 1- or 2-byte register, we will need
; to sign-extend the value into EDX:
            
            if      (sz eq 1) or (sz eq 2)
            movsx   edx, theReg
            
; If it's a 32-bit register, but is not EDX, we need
; to move it into EDX (don't bother emitting
; the instruction if the register is EDX;
; the data is already where we want it):
 
            elseif  regVal ne regEDX
            mov     edx, theReg
            endif
            
; Print the value in EDX as an integer:

            call    print
            byte    "%d", 0
            endm

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 13-12", 0

 <var>Note: several thousand lines of code omitted here</var>
<var>    for brevity. This includes most of the text from</var>
<var>    </var><var/><var>Listing 13-11 plus the putInt macro</var>

            .code
            
            include getTitle.inc
            include print.inc
            public  asmMain
asmMain     proc
            push    rbx
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56         ; Shadow storage
            
<span epub:type="pagebreak" title="813" id="Page_813"/>            call    print
            byte    "Value 1:", 0
            mov     al, 55
            putInt  al
            
            call    print
            byte    nl, "Value 2:", 0
            mov     cx, 1234
            putInt  cx
            
            call    print
            byte    nl, "Value 3:", 0
            mov     ebx, 12345678
            putInt  ebx
            
            call    print
            byte    nl, "Value 4:", 0
            mov     edx, 1
            putInt  edx
            call    print
            byte    nl, 0

allDone:    leave
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing13-12">Listing 13-12</a>: <code>putInt</code> macro function test program</p>
<p>Here’s the build command and sample output for <a href="#listing13-12">Listing 13-12</a>:</p>
<pre><code>C:\&gt;<b>build listing13-12</b>

C:\&gt;<b>echo off</b>
 Assembling: listing13-12.asm
c.cpp

C:\&gt;<b>listing13-11</b>
Calling Listing 13-12:
Value 1:55
Value 2:1234
Value 3:12345678
Value 4:1
Listing 13-12 terminated</code></pre>
<p>Though <a href="#listing13-12">Listing 13-12</a> is a relatively simple example, it should give you a good idea of how you could make use of the macros in Listing 13-10.</p>
<h3 id="h2-501089c13-0022">13.17.4	Compile-Time Arrays</h3>
<p class="BodyFirst">A compile-time <em>constant array</em> is an array that exists only at compile time—data for the array does not exist at runtime. Sadly, MASM doesn’t provide <span epub:type="pagebreak" title="814" id="Page_814"/>direct support for this useful CTL data type. Fortunately, it’s possible to use other MASM CTL features to simulate compile-time arrays.</p>
<p>This section considers two ways to simulate compile-time arrays: text strings and a list of equates (one equate per array element). The list of equates is probably the easiest implementation, so this section considers that first.</p>
<p>In Listing 13-11 (available online), a very useful function converts all the text in a string to uppercase (<code>toUpper</code>). The register macros use this macro to convert register names to uppercase characters (so that register name comparisons are case-insensitive). The <code>toUpper</code> macro is relatively straightforward. It extracts each character of a string and checks whether that character’s value is in the range <code>a</code> to <code>z</code>, and if it is, it uses that character’s value as an index into an array (indexed from <code>a</code> to <code>z</code>) to extract the corresponding array element value (which will have the values <code>A</code> to <code>Z</code> for each element of the array). Here’s the <code>toUpper</code> macro:</p>
<pre><code>; toUpper - Converts alphabetic characters to uppercase
;           in a text string.

toUpper     macro   lcStr
            local   result

; Build the result string in "result":

result      textequ &lt;&gt;

; For each character in the source string, 
; convert it to uppercase.

            forc    eachChar, &lt;lcStr&gt;

; See if we have a lowercase character:

            if      ('&amp;eachChar' ge 'a') and ('&amp;eachChar' le 'z')
            
; If lowercase, convert it to the symbol "lc_*" where "*"
; is the lowercase character. The equates below will map
; this character to uppercase:

eachChar    catstr  &lt;lc_&gt;,&lt;eachChar&gt;
result      catstr  result, &amp;eachChar

            else
            
; If it wasn't a lowercase character, just append it
; to the end of the string:

result      catstr  result, &lt;eachChar&gt;

            endif
            endm            ; forc
<span epub:type="pagebreak" title="815" id="Page_815"/>            exitm   result  ; Return result string
            endm            ; toUpper</code></pre>
<p>The “magic” statements, which handle the array access, are these two statements:</p>
<pre><code>eachChar    catstr  &lt;lc_&gt;,&lt;eachChar&gt;
result      catstr  result, &amp;eachChar</code></pre>
<p>The <code>eachChar catstr</code> operation produces a string of the form <code>lc_a, lc_b,</code> . . . , <code>lc_z</code> whenever this macro encounters a lowercase character. The <code>result catstr</code> operation expands a label of the form <code>lc_a</code>, . . . , to its value and concatenates the result to the end of the <code>result</code> string (which is a register name). Immediately after the <code>toUpper</code> macro in Listing 13-11, you will find the following equates:</p>
<pre><code>lc_a        textequ &lt;A&gt;
lc_b        textequ &lt;B&gt;
lc_c        textequ &lt;C&gt;
lc_d        textequ &lt;D&gt;
lc_e        textequ &lt;E&gt;
lc_f        textequ &lt;F&gt;
lc_g        textequ &lt;G&gt;
lc_h        textequ &lt;H&gt;
lc_i        textequ &lt;I&gt;
lc_j        textequ &lt;J&gt;
lc_k        textequ &lt;K&gt;
lc_l        textequ &lt;L&gt;
lc_m        textequ &lt;M&gt;
lc_n        textequ &lt;N&gt;
lc_o        textequ &lt;O&gt;
lc_p        textequ &lt;P&gt;
lc_q        textequ &lt;Q&gt;
lc_r        textequ &lt;R&gt;
lc_s        textequ &lt;S&gt;
lc_t        textequ &lt;T&gt;
lc_u        textequ &lt;U&gt;
lc_v        textequ &lt;V&gt;
lc_w        textequ &lt;W&gt;
lc_x        textequ &lt;X&gt;
lc_y        textequ &lt;Y&gt;
lc_z        textequ &lt;Z&gt;</code></pre>
<p>Therefore, <code>lc_a</code> will expand to the character <code>A</code>, <code>lc_b</code> will expand to the character <code>B</code>, and so forth. This sequence of equates forms the lookup table (array) that <code>toUpper</code> uses. The array should be called <code>lc_</code>, and the index into the array is the suffix of the array’s name (<code>a</code> to <code>z</code>). The <code>toUpper</code> macro accesses element<code> lc_[</code><var>character</var><code>]</code> by appending <var>character</var> to <code>lc_</code> and then expanding the text equate <code>lc_</code><var>character</var> (expansion happens by applying the <code>&amp;</code> operator to the <code>eachChar</code> string the macro produces).</p>
<p><span epub:type="pagebreak" title="816" id="Page_816"/>Note the following two things. First, the array index doesn’t have to be an integer (or ordinal) value. Any arbitrary string of characters will suffice.<sup class="FootnoteReference"><a id="c13-footnoteref-9" href="#c13-footnote-9">9</a></sup> Second, if you supply an index that isn’t within bounds (<code>a</code> to <code>z</code>), the <code>toUpper</code> macro will attempt to expand a symbol of the form <code>lc_</code><var>xxxx</var> that results in an undefined identifier. Therefore, MASM will report an undefined symbol error should you attempt to supply an index that is not within range. This will not be an issue for the <code>toUpper</code> macro because <code>toUpper</code> validates the index (using a conditional <code>if</code> statement) prior to constructing the <code>lc_</code><var>xxxx</var> symbol.</p>
<p>Listing 13-11 also provides an example of another way to implement a compile-time array: using a text string to hold array elements and using <code>substr</code> to extract elements of the array from that string. The <code>is</code><var>XX</var><code>BitReg</code> macros (<code>is8BitReg</code>, <code>is16BitReg</code>, and so forth) pass along a couple of arrays of data to the more generic <code>lookupReg</code> macro. Here’s the <code>is16BitReg</code> macro:<sup class="FootnoteReference"><a id="c13-footnoteref-10" href="#c13-footnote-10">10</a></sup></p>
<pre><code>all16Regs   catstr &lt;AX&gt;,
                   &lt;BX&gt;,
                   &lt;CX&gt;,
                   &lt;DX&gt;,
                   &lt;SI&gt;,
                   &lt;DI&gt;,
                   &lt;BP&gt;,
                   &lt;SP&gt;,
                   &lt;R8W&gt;,
                   &lt;R10W&gt;,
                   &lt;R11W&gt;,
                   &lt;R12W&gt;,
                   &lt;R13W&gt;,
                   &lt;R14W&gt;,
                   &lt;R15W&gt;

all16Lens   catstr &lt;2&gt;, &lt;0&gt;,           ; AX
                   &lt;2&gt;, &lt;0&gt;,           ; BX
                   &lt;2&gt;, &lt;0&gt;,           ; CX 
                   &lt;2&gt;, &lt;0&gt;,           ; DX
                   &lt;2&gt;, &lt;0&gt;,           ; SI
                   &lt;2&gt;, &lt;0&gt;,           ; DI
                   &lt;2&gt;, &lt;0&gt;,           ; BP
                   &lt;2&gt;, &lt;0&gt;,           ; SP
                   &lt;3&gt;, &lt;0&gt;, &lt;0&gt;,      ; R8W
                   &lt;3&gt;, &lt;0&gt;, &lt;0&gt;,      ; R9W
                   &lt;4&gt;, &lt;0&gt;, &lt;0&gt;, &lt;0&gt;, ; R10W
                   &lt;4&gt;, &lt;0&gt;, &lt;0&gt;, &lt;0&gt;, ; R11W
                   &lt;4&gt;, &lt;0&gt;, &lt;0&gt;, &lt;0&gt;, ; R12W
                   &lt;4&gt;, &lt;0&gt;, &lt;0&gt;, &lt;0&gt;, ; R13W
                   &lt;4&gt;, &lt;0&gt;, &lt;0&gt;, &lt;0&gt;, ; R14W
                   &lt;4&gt;, &lt;0&gt;, &lt;0&gt;, &lt;0&gt;  ; R15W

<span epub:type="pagebreak" title="817" id="Page_817"/>is16BitReg  macro   parm
            exitm   lookupReg(parm, all16Regs, all16Lens)
            endm    ; is16BitReg</code></pre>
<p>The <code>all16Regs</code> string is a list of register names (all concatenated together into one string). The <code>lookupReg</code> macro will search for a user-supplied register (<code>parm</code>) in this string of register names by using the MASM <code>instr</code> directive. If <code>instr</code> does not find the register in the list of names, <code>parm</code> is not a valid 16-bit register and <code>instr</code> returns the value 0. If it does locate the string held by <code>parm</code> in <code>all16Regs</code>, then <code>instr</code> returns the (nonzero) index into <code>all16Regs</code> where the match occurs. By itself, a nonzero index does not indicate that <code>lookupReg</code> has found a valid 16-bit register. For example, if the user supplies <code>PR</code> as a register name, the <code>instr</code> directive will return a nonzero index into the <code>all16Regs</code> string (the index of the last character of the <code>SP</code> register, with the <code>R</code> coming from the first character of the <code>R8W</code> register name). Likewise, if the caller passes the string <code>R8</code> to <code>is16BitReg</code>, the <code>instr</code> directive will return the index to the first character of the <code>R8W</code> entry, but R8 is not a valid 16-bit register.</p>
<p>Although <code>instr</code> can reject a register name (by returning 0), additional validation is necessary if <code>instr</code> returns a nonzero value; this is where the <code>all16Lens</code> array comes in. The <code>lookupReg</code> macro uses the index that <code>instr</code> returns as an index into the <code>all16Lens</code> array. If the entry is 0, the index into <code>all16Regs</code> is not a valid register index (it’s an index to a string that is not at the start of a register name). If the index into <code>all16Lens</code> points at a nonzero value, <code>lookupReg</code> compares this value against the length of the <code>parm</code> string. If they are equal, <code>parm</code> holds an actual 16-bit register name; if they are not equal, <code>parm</code> is too long or too short and is not a valid 16-bit register name. Here’s the full <code>lookupReg</code> macro:</p>
<pre><code>; lookupReg - Given a (suspected) register and a lookup table, convert
;             that register to the corresponding numeric form.

lookupReg   macro   theReg, regList, regIndex
            local   regUpper, regConst, inst, regLen, indexLen

; Convert (possible) register to uppercase:

regUpper    textequ toUpper(theReg)
regLen      sizestr &lt;&amp;theReg&gt;

; Does it exist in regList? If not, it's not a register.

inst        instr   1, regList, &amp;regUpper
            if      inst ne 0

regConst    substr  &amp;regIndex, inst, 1
            if      &amp;regConst eq regLen
            
; It's a register (in text form). Create an identifier of
; the form "reg<var>XX</var>" where "<var>XX</var>" represents the register name.

<span epub:type="pagebreak" title="818" id="Page_818"/>regConst    catStr  &lt;reg&gt;,regUpper

            ifdef   &amp;regConst

; Return "reg<var>XX</var>" as function result. This is the numeric value
; for the register.

            exitm   regConst
            endif
            endif
            endif

; If the parameter string wasn't in regList, then return
; "regNone" as the function result:

            exitm   &lt;regNone&gt;
            endm    ; lookupReg</code></pre>
<p>Note that <code>lookupReg</code> also uses the register value constants (<code>regNone</code>,<code> regAL</code>, <code>regBL</code>, and so on) as an associative compile-time array (see the <code>regConst</code> definitions). </p>
<h2 id="h1-501089c13-0018">	13.18	Using Macros to Write Macros</h2>
<p class="BodyFirst">One advanced use of macros is to have a macro invocation create one or more new macros. If you nest a macro declaration inside another macro, invoking that (enclosing) macro will expand the enclosed macro definition and define that macro at that point. Of course, if you invoke the outside (enclosing) macro more than once, you could wind up with a duplicate macro definition unless you take care in the construction of the new macro (that is, by assigning it a new name with each new invocation of the outside macro). In a few cases, being able to generate macros on the fly can be useful.</p>
<p>Consider the compile-time array examples from the previous section. If you want to create a compile-time array by using the <em>multiple equates</em> method, you will have to manually define equates for all the array elements before you can use that array. This can be tedious, especially if the array has a large number of elements. Fortunately, it’s easy to create a macro to automate this process for you. </p>
<p>The following macro declaration accepts two arguments: the name of an array to create and the number of elements to put into the array. This macro generates a list of definitions (using the <code>=</code> directive, rather than the <code>textequ</code> directive) with each element initialized to 0:</p>
<pre><code>genArray    macro   arrayName, elements
            local   index, eleName, getName
            
; Loop over each element of the array:

index       =       0
            while   index lt &amp;elements
            
<span epub:type="pagebreak" title="819" id="Page_819"/>; Generate a textequ statement to define a single
; element of the array, for example:

; ary<var>XX</var> = 0

; where "<var>XX</var>" is the index (0 to (elements - 1)).

eleName     catstr  &lt;&amp;arrayName&gt;,%index,&lt; = 0&gt;

; Expand the text just created with the catstr directive.

            eleName
            
; Move on to next array index:

index       =       index + 1
            endm    ; while
            
            endm    ; genArray</code></pre>
<p>For example, the following macro invocation creates 10 array elements, named <code>ary0</code> to <code>ary9</code>:</p>
<pre><code>genArray ary, 10</code></pre>
<p>You can access the array elements directly by using the names <code>ary0</code>, <code>ary1</code>, <code>ary2</code>, . . . ,<code> ary9</code>. If you want to access these array elements programmatically (perhaps in a compile-time <code>while</code> loop), you would have to use the <code>catstr</code> directive to create a text equate that has the array name (<code>ary</code>) concatenated with the index. Wouldn’t it be more convenient to have a macro function that creates this text equate for you? It’s easy enough to write a macro that does this:</p>
<pre><code>ary_get     macro   index
            local   element
element     catstr  &lt;ary&gt;,%index
            exitm   &lt;element&gt;
            endm</code></pre>
<p>With this macro, you can easily access elements of the <code>ary</code> array by using the macro invocation <code>ary_get(</code><var>index</var><code>)</code>. You could also write a macro to store a value into a specified element of the <code>ary</code> array:</p>
<pre><code>ary_set     macro   index, value
            local   assign
assign      catstr  &lt;ary&gt;, %index, &lt; = &gt;, %value
            assign
            endm</code></pre>
<p>These two macros are so useful, you’d probably want to include them with each array you create with the <code>genArray</code> macro. So why not have the <code/><span epub:type="pagebreak" title="820" id="Page_820"/>genArray macro write these macros for you? <a href="#listing13-13" id="listinganchor13-13">Listing 13-13</a> provides an implementation of <code>genArray</code> that does exactly this.</p>
<pre><code>; Listing 13-13

; This is a compile-time program.
; It does not generate any executable code.

        option  casemap:none

genArray    macro   arrayName, elements
            local   index, eleName, getName
            
; Loop over each element of the array:

index       =       0
            while   index lt &amp;elements
            
; Generate a textequ statement to define a single
; element of the array, for example:

; ary<var>XX</var> = 0

; where "<var>XX</var>" is the index (0 to (elements - 1)).

eleName     catstr  &lt;&amp;arrayName&gt;,%index,&lt; = 0&gt;

; Expand the text just created with the catstr directive:

            eleName
            
; Move on to next array index:

index       =       index + 1
            endm    ; while
            
; Create a macro function to retrieve a value from
; the array:

getName     catstr  &lt;&amp;arrayName&gt;,&lt;_get&gt;

getName     macro   theIndex
            local   element
element     catstr  &lt;&amp;arrayName&gt;,%theIndex
            exitm   &lt;element&gt;
            endm
            
; Create a macro to assign a value to
; an array element.

setName     catstr  &lt;&amp;arrayName&gt;,&lt;_set&gt;

setName     macro   theIndex, theValue
            local   assign
assign      catstr  &lt;&amp;arrayName&gt;, %theIndex, &lt; = &gt;, %theValue
<span epub:type="pagebreak" title="821" id="Page_821"/>            assign
            endm

            endm    ; genArray

; mout - Replacement for echo. Allows "%" operator
;        in operand field to expand text symbols.

mout        macro   valToPrint
            local   cmd
cmd         catstr  &lt;echo &gt;, &lt;valToPrint&gt;
            cmd
            endm

; Create an array ("ary") with ten elements:

            genArray ary, 10
            
; Initialize each element of the array to
; its index value:

index       = 0
            while   index lt 10
            ary_set index, index
index       =       index + 1
            endm
            
; Print out the array values:

index       =       0
            while   index lt 10
            
value       =       ary_get(index)
            mout    ary[%index] = %value
index       =       index + 1
            endm
            
            end</code></pre>
<p class="CodeListingCaption"><a id="listing13-13">Listing 13-13</a>: A macro that writes another pair of macros</p>
<p>Here’s the build command and sample output for the compile-time program in <a href="#listing13-13">Listing 13-13</a>:</p>
<pre><code>C:\&gt;<b>ml64 /c /Fl listing13-13.asm</b>
Microsoft (R) Macro Assembler (x64) Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

 Assembling: listing13-13.asm
ary[0] = 0
ary[1] = 1
ary[2] = 2
ary[3] = 3
ary[4] = 4
ary[5] = 5
<span epub:type="pagebreak" title="822" id="Page_822"/>ary[6] = 6
ary[7] = 7
ary[8] = 8
ary[9] = 9</code></pre>
<h2 id="h1-501089c13-0019">	13.19	Compile-Time Program Performance</h2>
<p class="BodyFirst">When writing compile-time programs, keep in mind that MASM is interpreting these programs during assembly. This can have a huge impact on the time it takes MASM to assemble your source files. Indeed, it is quite possible to create infinite loops that will cause MASM to (seemingly) hang up during assembly. Consider the following trivial example:</p>
<pre><code>true        =     1
            while true
            endm</code></pre>
<p>Any attempt to assemble a MASM source file containing this sequence will lock up the system until you press <span class="KeyCaps">ctrl-C</span> (or use another mechanism to abort the assembly process).</p>
<p>Even without infinite loops, it is easy to create macros that take a considerable amount of time to process. If you use such macros hundreds (or even thousands) of times in a source file (as is common for some complex print-type macros), it could take a while for MASM to process your source files. Be aware of this (and be patient if MASM seems to hang up—it could simply be your compile-time programs taking a while to do their job).</p>
<p>If you think a compile-time program has entered an infinite loop, the <code>echo</code> directive (or macros like <code>mout</code>, appearing throughout this chapter) can help you track down the infinite loop (or other bugs) in your compile-time programs.</p>
<h2 id="h1-501089c13-0020">	13.20	For More Information</h2>
<p class="BodyFirst">Although this chapter has spent a considerable amount of time describing various features of MASM’s macro support and compile-time language features, the truth is this chapter has barely described what’s possible with MASM. Sadly, Microsoft’s documentation all but ignores the macro facilities of MASM. Probably the best place to learn about advanced macro programming with MASM is the MASM32 forum at <a href="http://www.masm32.com/board/index.php" class="LinkURL">http://www.masm32.com/board/index.php</a>.</p>
<p>Although it is an older book, covering MASM version 6, <em>The Waite Group’s Microsoft Macro Assembler Bible</em> by Nabajyoti Barkakati and this author (Sams, 1992) does go into detail about the use of MASM’s macro facilities (as well as other directives that are poorly documented these days). Also, the MASM 6.<em>x</em> manual can still be found online at various sites. While this manual is woefully outdated with respect to the latest versions of MASM <span epub:type="pagebreak" title="823" id="Page_823"/>(it does not, for example, cover any of the 64-bit instructions or addressing modes), it does a decent job of describing MASM’s macro facilities and many of MASM’s directives. Just keep in mind when reading the older documentation that Microsoft has <em>disabled</em> many features that used to be present in MASM.</p>
<h2 id="h1-501089c13-0021">	13.21	Test Yourself</h2>
<ol class="decimal">
<li value="1">What does <em>CTL</em> stand for?</li>
<li value="2">When do CTL programs execute?</li>
<li value="3">What directive would you use to print a message (not an error) during assembly?</li>
<li value="4">What directive would you use to print an error message during assembly? </li>
<li value="5">What directive would you use to create a CTL variable? </li>
<li value="6">What is the MASM macro escape character operator?</li>
<li value="7">What does the MASM <code>%</code> operator do?</li>
<li value="8">What does the MASM macro <code>&amp;</code> operator do? </li>
<li value="9">What does the <code>catstr</code> directive do?</li>
<li value="10">What does the MASM <code>instr</code> directive do?</li>
<li value="11">What does the <code>sizestr</code> directive do?</li>
<li value="12">What does the <code>substr</code> directive do?</li>
<li value="13">What are the main (four) conditional assembly directives?</li>
<li value="14">What directives could you use to create compile-time loops?</li>
<li value="15">What directive would you use to extract the characters from a MASM text object in a loop?</li>
<li value="16">What directives do you use to define a macro?</li>
<li value="17">How do you invoke a macro in a MASM source file? </li>
<li value="18">How do you specify macro parameters in a macro declaration? </li>
<li value="19">How do you specify that a macro parameter is required?</li>
<li value="20">How do you specify that a macro parameter is optional? </li>
<li value="21">How do you specify a variable number of macro arguments?</li>
<li value="22">Explain how you can manually test whether a macro parameter is present (without using the <code>:req</code> suffix). </li>
<li value="23">How can you define local symbols in a macro? </li>
<li value="24">What directive would you use (generally inside a conditional assembly sequence) to immediately terminate macro expansion without processing any additional statements in the macro? </li>
<li value="25">How would you return a textual value from a macro function? </li>
<li value="26">What operator could you use to test a macro parameter to see if it is a machine register versus a memory variable?</li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c13-footnote-1" href="#c13-footnoteref-1">1.</a></sup> <span class="LiteralFootnote"><code>%out</code></span> is a synonym for <span class="LiteralFootnote"><code>echo</code></span> (just in case you see <span class="LiteralFootnote"><code>%out</code></span> in any MASM source files).</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c13-footnote-2" href="#c13-footnoteref-2">2.</a></sup> If you’re wondering, MASM already uses the <span class="LiteralFootnote"><code>length</code></span> reserved word for other purposes.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c13-footnote-3" href="#c13-footnoteref-3">3.</a></sup> <span class="LiteralFootnote"><code>endm</code></span> stands for <em>end macro</em>, in case you’re wondering. MASM considers all CTL looping instructions variants of the MASM macro facility. <span class="LiteralFootnote"><code>irp</code></span> and <span class="LiteralFootnote"><code>irpc</code></span> are synonyms for <span class="LiteralFootnote"><code>for</code></span> and <span class="LiteralFootnote"><code>forc</code></span>, respectively.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c13-footnote-4" href="#c13-footnoteref-4">4.</a></sup> On modern processors, using a lookup table is probably not the most efficient way to convert between alphabetic cases. However, this is just an example of filling in the table using the compile-time language. The principles are correct, even if the code is not exactly the best it could be.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c13-footnote-5" href="#c13-footnoteref-5">5.</a></sup> Some people will even use <span class="LiteralFootnote"><code>movzx ecx, parm1</code></span> for 8- or 16-bit values to ensure the HO bits of ECX and RCX are all 0 upon entry into the procedure.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c13-footnote-6" href="#c13-footnoteref-6">6.</a></sup> We don’t get to pick the name of the function here. We must call the <span class="LiteralFootnote"><code>printf</code></span> function; we cannot arbitrarily name it <span class="LiteralFootnote"><code>_printf</code></span> in our code. Therefore, this macro uses the identifier <span class="LiteralFootnote"><code>cprintf</code></span> (for <em>call printf</em>).</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c13-footnote-7" href="#c13-footnoteref-7">7.</a></sup> MASM will treat a sequence of one to eight characters as an integer value. So short strings (eight characters or less) work fine as expressions.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c13-footnote-8" href="#c13-footnoteref-8">8.</a></sup> Registers AH, BH, CH, and DH get converted to the same registers as AL, BL, CL, and DL, respectively.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c13-footnote-9" href="#c13-footnoteref-9">9.</a></sup> Technically, this type of data structure is a <em>dictionary</em>, or <em>associative array</em>. However, it serves as a perfectly good array for our purposes.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c13-footnote-10" href="#c13-footnoteref-10">10.</a></sup> This macro has a couple of slight modifications (using <span class="LiteralFootnote"><code>catstr</code></span> rather than <span class="LiteralFootnote"><code>textequ</code></span>) to make it more readable within this book. Functionally, it is the same as the macro appearing in the actual source code.</p></aside>
</section>
</section>
</body></html>