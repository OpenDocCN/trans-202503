- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MAKING
    THE MOST OF THE TYPE SYSTEM</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Clear and readable source code matters much more to humans than it does to computers.
    Whether we’re trying to debug existing code or learning to use a new feature,
    we inevitably find ourselves reading through source code. It’s important to ensure
    that our code is as readable as possible so that its meaning is clear to other
    readers. Code that’s hard to follow or easily misunderstood is a breeding ground
    for errors.
  prefs: []
  type: TYPE_NORMAL
- en: One way to improve the clarity of our code is to use the type system to our
    advantage by creating our own types and giving them names that clearly describe
    their purpose. Good names are important for all the types in a system, but it’s
    easy to neglect the simple value types that represent an application’s most granular
    information.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll examine a short but unclear piece of code and improve
    it over several iterations through a series of techniques that will help you learn
    how to use the type system effectively. By the end of the chapter, you’ll have
    a better understanding of how custom value types contribute to easy-to-understand
    code and how to incorporate a rich set of types into your designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How custom types can help express meaning and make code more self-documenting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to encapsulate domain-specific behavior to reduce errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where to use some syntax features from C# v9.0 and v10.0 for compact and readable
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make using custom types easy and natural in commonplace code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To begin, let’s look at a simple example of value types in action and why they’re
    such an important feature of our designs
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Value of Good Names</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choosing good names for identifiers can be difficult but has a major impact
    on the clarity of our code. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method in [Listing 1-1](#list1-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: An example of
    bad variable naming</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The method’s three parameters—<samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>—are
    poorly named, and their purpose isn’t immediately clear. We’ll use this code throughout
    the chapter to explore a variety of ways to improve it and better define its intent.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method is to calculate the position of a projectile on its ballistic arc, given
    an initial angle and velocity, and the time elapsed since the projectile was launched.
    If you’re familiar with the equations for projectile motion, you may recognize
    the algorithm, but the variable names provide no clue whatsoever to their purpose.
    When called, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method calculates the coordinate value of the projectile relative to its launch
    point, as illustrated in [Figure 1-1](#fig1-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-1.png)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1:</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Projectile
    displacement</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The angle, initial speed, and time labels in [Figure 1-1](#fig1-1) correspond
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> parameters for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, respectively. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    values correspond to the components of the tuple returned by that method. The
    projectile is launched with an initial speed, at a particular angle, and follows
    a well-defined ballistic arc. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method calculates the projectile’s position on that arc after a given amount of
    time has passed.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go into the algorithm being used here, as our focus is merely on making
    the purpose of this method more immediately clear. The first barrier to our understanding
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    is the meaning of its parameters and return value.
  prefs: []
  type: TYPE_NORMAL
- en: I have deliberately exaggerated the issue with single-letter names, but I’ve
    seen similar examples in the real world and thought, *What on earth do those parameters
    represent?* Even if we carefully inspect how the parameters have been used, determining
    their meaning requires being familiar with the equations. That is just poor code
    craft. Not all of us have kept up with our ballistics studies.
  prefs: []
  type: TYPE_NORMAL
- en: We want to make it as easy as possible for the reader to determine the purpose
    of the method, whether they’re familiar with the topic or not. The quickest way
    to accomplish this is to ensure that the parameter names better reflect what they
    represent. In particular, code should avoid relying on specialist jargon. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> here stands for *theta*,
    which is typically used in physics to represent the magnitude of an angle, but
    even if we replaced <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> with
    the full word <samp class="SANS_TheSansMonoCd_W5Regular_11">theta</samp>, readers
    unfamiliar with this mathematical convention would be unlikely to make that connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using potentially obscure single-letter names, let’s give the parameters
    names that properly signify their meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By renaming <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> as <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">angle</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">elapsedTime</samp>, we’ve made
    their purpose clearer. Changing velocity to speed might seem a minor change, but
    the names we use *matter*. While the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    for *velocity* is common, <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    is a more accurate description of this value’s purpose. *Velocity* is a technical
    term with a specific meaning in physics; it represents *both* magnitude (speed)
    and direction. If we name code elements as accurately and properly as we can,
    we reduce the risk of those names being misunderstood.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting good names is a first step toward making code clearer and easier to
    read. However, we can do much more to improve our code’s clarity and remove ambiguity
    about what those identifiers represent. We might reasonably ask, for example,
    in what units the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    parameters are measured. We’ll address that later in the chapter, but first we
    need a more sophisticated mechanism than the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type allows.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding Clarity Through Types</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method’s
    parameters are of the same type: <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    This makes it easy for anyone, including ourselves, to accidentally mix up argument
    values when calling the method—without any warning from the compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type itself
    is not the specific culprit here; we’d have the same problem if the parameters
    were all <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> or all <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> types. Even if each parameter
    were of a different built-in numeric type, plenty of potential for problems would
    still remain because of the presence of the implicit promotion rules between them.
    Moreover, clarifying the parameter names doesn’t necessarily help the calling
    code, especially if the method is called with plain constant values like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Hard-coded values such as those used in this example are called *magic numbers*
    because there’s no explanation of their meaning or purpose. We could replace the
    magic numbers with better-named variables to make their purpose clearer, but the
    caller of the method might still supply the arguments in the wrong order.
  prefs: []
  type: TYPE_NORMAL
- en: One common way for the calling code to address such out-of-order errors is to
    specify the parameter name for each argument. Let’s see that in practice before
    looking at how to use different types to distinguish between the argument values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Named Arguments</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Embedding the parameter name for each argument being passed to a method makes
    the purpose of those arguments much more visible in the calling code, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method specifies which parameter receives each value being supplied. The caller
    must match the parameter names of the method but can order them in any way they
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Naming the arguments makes the order in which they’re passed irrelevant. The
    compiler will ensure that each argument value gets passed to the right parameter
    according to its name, not its position.
  prefs: []
  type: TYPE_NORMAL
- en: This technique puts the responsibility of clarity onto the *caller* of the method.
    If the caller forgets or doesn’t bother to name the arguments, the compiler won’t
    warn them. The compiler will also give no warning if the caller mixes up the value
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>.
    The code will compile, and the program will run, but it will almost certainly
    give incorrect results. Worse, the code might give a result that is almost correct
    for one specific set of arguments and then fail at the worst possible moment when
    different values are passed. The causes of errors like this can be difficult to
    track down.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Custom Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problems we’re seeing with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method stem from using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type to represent several distinct concepts. This is a variation of the *Primitive
    Obsession* code smell, which describes any code that has an overreliance on primitive
    types—that is, those types that are built into the language, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Measurements and quantities such as speed commonly have numerical representations,
    but the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type is too
    general; it can be used to represent a wide variety of values, including <samp
    class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    in our example, making it possible for the caller of the code to provide the wrong
    values. The <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> quantities are measured in
    different ways to mean different things. Using a raw <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    does not express the distinctions between them clearly enough. An angle of 45
    degrees is a very different value from a speed of 45 meters per second.
  prefs: []
  type: TYPE_NORMAL
- en: The well-known solution to primitive obsession is to provide our own types with
    distinct purposes and to ensure that no implicit conversions exist between them.
    This enables the compiler to identify any arguments that are used inappropriately.
    Instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to
    store quantities of <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, [Listing 1-2](#list1-2)
    defines two types that more positively convey their differences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-2: Defining our own
    types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our user-defined structs <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> are still quite
    primitive; they’re merely wrappers around a public property (<samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>, respectively)
    that allows us to read or write the value being represented in each case. We’ll
    improve this design, but for now it meets the immediate need: to distinguish values
    of angle from values of speed by their type rather than just by the parameter
    names.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-3](#list1-3) demonstrates how we use these new types for the parameters
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-3: Using custom types
    as parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The C# Standard Library does not provide any abstractions for angles or speeds,
    but it does have the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    type, which is ideal for the <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    parameter. Now the *type* of each parameter describes its value, so the parameter
    names have less responsibility. Any attempt to provide the arguments in the incorrect
    order, like substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>, will cause the
    compiler to complain with a fairly obvious error message about not being able
    to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encapsulation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using distinct types for the values in a design emphasizes each value’s role
    rather than its representation, making the code more self-documenting for human
    readers and allowing better error checking by the compiler. We’ve achieved our
    stated goal of preventing arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    from being positioned incorrectly, but right now <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> are simple types
    that just *have* a value, rather than *being* a particular kind of value.
  prefs: []
  type: TYPE_NORMAL
- en: These types do not encapsulate their values in any way because their values
    are exposed as the publicly mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> properties. Those
    properties are currently the only way to create instances of those types, as we
    do in [Listing 1-4](#list1-4), where we use object initialization to set the property
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-4: Using object initialization
    to create inline argument instances</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using the public properties to set the values here is unnecessarily verbose.
    [Listing 1-5](#list1-5) simplifies the syntax by adding constructors so we can
    create new instances directly with a value instead of having to set a public property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-5: Adding constructors
    for Speed and Angle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, when we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    we construct the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances with their
    values instead of setting their properties ❶. Now that the type names are more
    descriptive, the order of the arguments is not ambiguous, so naming the arguments
    is no longer so important.
  prefs: []
  type: TYPE_NORMAL
- en: These constructors use the *expression body syntax*, introduced for methods
    in C# v6.0 and available since C# v7.0 for constructors. With this syntax, instead
    of a block enclosed by braces <samp class="SANS_TheSansMonoCd_W5Regular_11">{…}</samp>,
    the expression is a single assignment separated from the constructor’s signature
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">=></samp> symbol. Since <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    each have only a single property to initialize, the expression-bodied constructors
    are concise and convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Compare the final line with [Listing 1-4](#list1-4). The changes to <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in [Listing 1-5](#list1-5)
    allow us to construct the values we want instead of using the object initializer
    in each case. This reduces the amount of typing the caller has to do but, more
    importantly, expresses more directly that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> *is* a value instead
    of just *having* a value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Immutability</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, our values are all mutable, but once we’ve given an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> a value in its constructor,
    we don’t need to allow that value to change. If we require an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    with a different value, we can create a new instance with that value.
  prefs: []
  type: TYPE_NORMAL
- en: We achieve this immutability by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> property
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> to make it a read-only
    property. Then the only way to provide a value is via the constructor, and that
    value is permanent and immutable. We’ll do the same for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, as shown
    in [Listing 1-6](#list1-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-6: Making Speed immutable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance can’t change, we also make it <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>.
    The compiler will then ensure that no members of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    can modify the state and will fail to compile any attempt to change an instance.
  prefs: []
  type: TYPE_NORMAL
- en: Designing our types to be immutable makes our code easier to reason about during
    code inspection because we don’t need to consider the various ways that instances
    of our type might change. This is especially important in multithreaded programs,
    but making value types read-only can also improve performance in some circumstances
    by enabling the compiler to use certain optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Validation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having introduced constructors for our types, we can use those constructors
    to check for invalid arguments and raise exceptions if the user passes illegal
    values. For example, sensible values for a speed must be nonnegative. In [Listing
    1-7](#list1-7), we check that the value given the constructor is not less than
    0 and throw an exception if it is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-7: Prohibiting out-of-range
    values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    validates the value provided, and since the constructor is the only way to provide
    a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, we ensure
    that only legal <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values
    can be created. We should use the constructor to prohibit other illegal argument
    values, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp>,
    and perhaps even add an upper limit of the speed of light. If we attempt to create
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> with an illegal value,
    we get a run-time exception.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp>
    type is defined in the Standard Library and is a good example of a descriptively
    named type. Note that in [Listing 1-7](#list1-7), we name the arguments for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp>
    constructor, *which takes two plain* <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">string</samp>
    *parameters* (<samp class="SANS_TheSansMonoCd_W5Regular_11">paramName:</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">message:</samp>). Otherwise,
    the order of those arguments is easily muddled, especially since the similarly
    named <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentException</samp> takes
    the same parameters in the reverse order!
  prefs: []
  type: TYPE_NORMAL
- en: 'Validating the parameter value in <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor is one example of encapsulation: we’ve put the validation logic in
    one place instead of scattering it among any methods that use it. Now, any methods
    that use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance
    automatically benefit from the range check performed by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A major benefit of creating our own types is that we encapsulate their responsibilities,
    thereby reducing the responsibilities of the methods that use them. Minimizing
    duplicated code is yet another way we make our code clearer, easier to use, and
    much less difficult to maintain.*'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    establishes a *class invariant*—a condition that must hold for the lifetime of
    any instance of the type—specifying that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value is never less than 0\. The invariant can never be broken because we made
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> immutable. Once a valid
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance is created,
    its value never changes, and it’s impossible to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with an invalid value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By encapsulating the validation within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type, we can also test the class invariant independently of any algorithms that
    depend on it. In [Listing 1-8](#list1-8), we attempt to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with a negative value to test that the constructor throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-8: Testing constraints
    on Speed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because the validation code is encapsulated within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type, we need only this one test for it. We don’t need to separately test that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, or any other
    method using <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, rejects
    invalid speed values. All the testing for <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    can focus on ensuring that the algorithm is correct, without being concerned about
    parameter validation.
  prefs: []
  type: TYPE_NORMAL
- en: Using types for domain concepts, then, has several advantages. Code using our
    types is clearer because of the self-describing characteristics of the type. We
    separate concerns, making the program easier to understand and the testing more
    focused and specific. This makes the tests simpler, and easier to maintain when
    the code being tested needs to change.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Refactoring</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve addressed the issues with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method’s parameters, let’s look at its method body to see if we can make further
    improvements by refactoring the implementation. [Listing 1-9](#list1-9) shows
    our current code for <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-9: The current Displacement
    implementation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code works correctly, but we have some issues to take care of. We’ve made
    the code more verbose by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    types as parameters, requiring us to access properties of those parameters to
    obtain their values. Note that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    property here; one common error is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> object
    when the intention is to obtain the total number of seconds being represented,
    but <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp> returns only
    the seconds component of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>.
    Given a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> representing
    1 minute precisely, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp>
    property would return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    while the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    would be <samp class="SANS_TheSansMonoCd_W5Regular_11">60</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    would be clearer if we could use the variables *directly* in the algorithm, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm also relies on three hard-coded values. Magic numbers like this
    often indicate that we need to provide names to clarify their purpose. It’s common
    to find the same magic number used in more than one place, so if the value changed
    for any reason, we’d need to hunt for every use and make sure we updated them
    all.
  prefs: []
  type: TYPE_NORMAL
- en: While we can see that multiplying by <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>
    is the same as dividing by <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    the meaning of <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp> is much
    less obvious. The value <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> used in the call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Pow</samp> are simply arithmetic
    values; giving them names might obscure their purpose rather than clarifying it.
    The value <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>, on the other
    hand, stands out as having a more significant purpose. Once again, to understand
    the meaning of this number, we need prior knowledge that <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>
    is an approximation of the effects of Earth’s gravity on an object. We’ll address
    this issue first with the simple fix of naming this value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Magic Numbers
    with Named Constants</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replacing magic numbers in code with a descriptive name clarifies their meaning
    to readers unfamiliar with the algorithm’s details. One way to do this is to create
    a new value type, similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    to represent the measurement. However, when we need only a few well-known values,
    using named constants to represent them is often simpler. For now, we need only
    a single value (for Earth’s gravity). [Listing 1-10](#list1-10) shows one way
    we could indicate that value’s purpose by giving it a meaningful name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-10: Simple encoding
    of magic numbers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: While the named constant for gravity is the simplest replacement for the magic
    number, we’re passing up an opportunity to benefit from a more general type named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Acceleration</samp> or something
    similar. Doing so would give us the greatest flexibility but would also increase
    complexity and maintenance. Keeping code simple has its own benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should, however, keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    values like this are baked into our code by the compiler, so if we change the
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">Gravity.Earth</samp> but
    compile against a prebuilt assembly that uses the same constant, the overall program
    could use two different values for the same constant. In the interests of brevity
    and simplicity, we’ll keep the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    value and replace the hard-coded number in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Gravity.Earth</samp> constant
    so human readers know immediately what it means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now if we want to use a more precise approximation of gravity, we only need
    to change the constant’s value instead of searching for all uses of the magic
    number <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>, with the caveat
    that we must remember to recompile any other modules that use that constant.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simplifying Properties
    and Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    is now much more explicit about the meanings of the variables it uses. [Listing
    1-11](#list1-11) shows its current implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-11: Displacement
    using explicit property access</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, accessing the properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    makes the implementation quite verbose. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method would be tidier and easier still to read if we could access these properties
    directly in the operations where they were used. The <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    variable’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property
    is being multiplied by <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    ❶, and <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp> is used
    to call both <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> ❷ and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> ❸. Each use of our
    types requires us to explicitly obtain the corresponding property value in order
    to multiply two values together, and to pass them as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t change the behavior of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    variable to allow it to be multiplied by a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> can be multiplied
    by a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> value. If we
    could use <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances
    as if they were <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values,
    we would avoid having to explicitly use their properties in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    making the method less cluttered; that is, we would be able to multiply <samp
    class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    without using the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed.Amount</samp>
    property. Likewise, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    type, we could call methods such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, which both
    expect a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> argument,
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> variable directly
    if we could treat <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> instances
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the whole expression would be a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>,
    which is the result type from multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    by a number, so we’d need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    property at some point. Still, removing the need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> properties of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    would simplify and shorten the method’s implementation.
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve that outcome is by defining our own implicit conversion operators.
    This approach is superficially appealing because it is simple to implement, but
    it has several drawbacks. Let’s examine some of those potential problems.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implicit Conversions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We define an implicit conversion for our own types by implementing an implicit
    conversion operator method and specifying the target type we need, as shown for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in [Listing 1-12](#list1-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-12: Defining an implicit
    conversion for Speed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The target type here is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    and we simply return the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property. We also add a similar conversion operator for <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    (not shown here) that returns its <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    property. Now we no longer need to explicitly use <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp>
    when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, and we can multiply
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> by the <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    value without needing to get the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed.Amount</samp>
    property. Compare [Listing 1-13](#list1-13) with the earlier version in [Listing
    1-11](#list1-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-13: Using implicit
    conversions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    is now much more compact—but we’ve introduced some hidden problems.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Unexpected Interactions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Implicit conversions weaken the interface to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> by allowing them
    to participate everywhere that a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    might be used, which means they can be used in expressions where it’s not appropriate.
    For example, dividing a speed by an angle would be a legal expression, as demonstrated
    in [Listing 1-14](#list1-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-14: Unplanned behavior
    resulting from an implicit conversion</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This expression is valid owing to the implicit conversions from both <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    but the result is meaningless, and we get no warning from the compiler. In addition,
    implicit conversions are usually invisible in our code. If we pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value to <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> instead
    of an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, the resulting
    calculation errors could be hard to find.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Discarded Invariants</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the benefits we realized by introducing a custom type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    was that we could encapsulate validation logic in <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the implicit conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> means that code
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> result can
    breach the constraints on the allowable range of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    In [Listing 1-15](#list1-15), we subtract one <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from another smaller value, leaving us with a result that’s less than 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-15: Unchecked constraints
    resulting from an implicit conversion</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This subtraction expression, which is between two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values as a result of the implicit conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, will run just
    fine. The result is negative and thus out of range for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but it’s a perfectly legal <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    value.
  prefs: []
  type: TYPE_NORMAL
- en: To address this out-of-range value, we need to restrict the permitted operations
    on <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    so they make sense for those measurements. This was the whole purpose of introducing
    a class invariant for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to ensure that instances of it always have a valid value. Furthermore, we want
    to prohibit operations that make no sense, ideally in a way that would allow the
    compiler to tell us when something is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> as specific types so
    that we could tell them apart, and because using a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    was simply too general to represent those measurements. However, the implicit
    conversions make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> indistinguishable from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We can still achieve our objective of making our types easy to use in arithmetic
    expressions, but we need to keep control over which operations those types can
    perform. We’ll allow specific operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> without sacrificing
    their natural usage or compromising the encapsulation of the types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overloading Arithmetic
    Operators</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our initial motivation for introducing implicit conversions for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    was to support the multiplication operation between a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp> property
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> value. Currently,
    we must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to make that calculation,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic operations such as <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    for multiplication are predefined for the built-in numeric types like <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    We can define the meaning of these symbols for our own types by providing arithmetic
    operator overloads.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-16](#list1-16) shows the multiplication operator overload for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-16: Supporting multiplication
    in Speed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We use a target-typed <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    expression, introduced in C# v9.0, to create the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>
    to return. The compiler knows that the expected type is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    as it’s being directly returned, so we don’t need to explicitly specify the type
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">new Speed(…)</samp>. The compiler
    will infer the type according to the value expected by the left side of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to multiply a speed value by a number makes intuitive sense; something
    might be traveling at double the speed of something else, for example. We implement
    the operator by creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from the product of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property and the value passed to the operator’s parameter. The constructor for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> will check that the
    result is within the allowed range of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and will throw an exception if the result is out of range. We can demonstrate
    that this works with a simple test, such as [Listing 1-17](#list1-17), where we
    attempt to multiply a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a negative number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-17: Testing the multiplication
    operator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and then
    verify that when we try multiplying it by <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>,
    the constructor throws an exception. We also ensure that when we halve the value,
    the operation succeeds with the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: We can define operator overloads for other arithmetic operations and specify
    precisely the expressions in which <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is permitted to take part. Values commonly overload arithmetic operators, where
    it is appropriate to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Not all values are arithmetic in nature, so we need to carefully consider whether
    to support those operations for a type. For example, creating our own value type
    to represent a UK postal code would be perfectly natural, but multiplying a postal
    code by a number or by another postal code makes no sense whatsoever, because
    postal codes are not arithmetic values. Examples of other nonarithmetic values
    include US ZIP codes and colors.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values
    should naturally take part in some, but not all, arithmetic expressions. It makes
    sense to be able to double a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but not to multiply two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values together. We can use custom arithmetic operator overloads to control which
    expressions should be permitted, and by adding explicit support for them, we make
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining a Need
    for New Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever we refactor a piece of code, we may discover a requirement or opportunity
    to introduce a new type. The need for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types was fairly
    plain because we introduced them to replace primitive parameter variables. Not
    all missing abstractions are so obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we multiply a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a number, the result is a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    multiplies a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> value, which
    is not simply a number. Here we split that calculation into separate parts to
    make it clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As noted earlier, multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a number intuitively produces a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    Both <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    here are therefore instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    because of our implementation of the multiplication operator, but note that the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    value is not just any number but rather a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    instance representing a *time*. Mathematically, the result of this expression
    is not a speed at all: multiplying a speed by a time produces a *distance*, which
    we can represent directly in our code by introducing a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    type, as shown in [Listing 1-18](#list1-18).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-18: The Distance
    type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a new overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> that multiplies
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> directly by a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> and produces a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
    Even better, we can define this overload in addition to the multiplication operator
    we’ve already defined that takes a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and returns a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    [Listing 1-19](#list1-19) shows both operator overloads.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-19: Overloading operator*</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Overloading is versatile. We can overload a method with different types of parameters,
    and each overload can return a different type. The rules for overloading consider
    only the method signature—that is, the number and types of the parameters. We
    can therefore return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from the overload taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> from
    the method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Refining the New Type</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we need to add behavior to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    type so that it will work correctly in our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    implementation. Multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> gives us a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> value, which we
    use in further arithmetic expressions of its own, shown in [Listing 1-20](#list1-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-20: The Distance
    type in use</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The expressions for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are both now multiplying
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> value by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values returned from <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>.
    This code will fail to compile because <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    needs its own overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: As with <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values, multiplying
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> by a simple number
    produces a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
    The results of <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, apart from being
    out of our control, are scalar values, so when we multiply them by a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>,
    the result is another <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> also requires
    an overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator-</samp>
    so that the subtraction operation used in the calculation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    value will compile. As with the multiplication, the expression on the right of
    the subtraction gives a scalar value, so we add the multiplication and subtraction
    operators for <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> in
    [Listing 1-21](#list1-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-21: Arithmetic operations
    for Distance values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: With these overloads, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> values naturally
    together to produce <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    values. Those values, in turn, work seamlessly with the other required expressions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Design Imperfection</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    returns a tuple of two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values. However, with our changes, the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values being returned
    have become instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    rather than plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values. This introduces another terminology problem with respect to the return
    value: in physics, a distance, like a speed, is always either 0 or a positive
    value. Combining a distance with the result of a trigonometric function like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> is a coordinate position, rather
    than a distance, and can be negative.'
  prefs: []
  type: TYPE_NORMAL
- en: We identified the <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    type from the result of multiplying a speed by a time, but there is no straightforward
    way to distinguish the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> from a plain
    number like <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>, denying
    us the opportunity to add an overload of the multiplication operator in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> to return a new type,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>, rather
    than another <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>. We
    have reached the limits of exploiting the types we have chosen for modeling real-world
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: An obstacle like this may be the symptom of a deeper design smell, an indication
    that the problem might be resolved by a change in design perspective. In this
    instance, we may be able to achieve a more complete solution by reworking <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>’s algorithm in terms
    of a full-fledged <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    type instead of the relatively primitive <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types. Exploring
    that solution is fairly complex, however, and best left to a text dedicated to
    modeling physics problems, leaving us with a pragmatic decision to make.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>
    type, or something similar, to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
    This approach suffers from the drawback that the arithmetic operations we defined
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> do not apply
    so naturally to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>.
    Moreover, if <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> is
    useful elsewhere in an application, it makes complete sense that when we multiply
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>,
    the result is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>,
    not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to do nothing and permit <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    to have negative values in the context of our application. While <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    would then be an imperfect representation of its counterpart in physics, this
    approach benefits from simple and natural uses in other areas. In [Listing 1-22](#list1-22),
    we change the return type of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> values directly,
    which further simplifies the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-22 The new Displacement
    method</samp>
  prefs: []
  type: TYPE_NORMAL
- en: We could have retained the existing return type by returning the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables. For example, if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> is already widely
    used, altering the type it returns might be intrusive. Nonetheless, introducing
    the richer <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type
    more widely in an application has benefits similar to replacing the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    parameters in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> types.
  prefs: []
  type: TYPE_NORMAL
- en: However we decide to best serve the requirements of the application and its
    users, we can make more pressing improvements to the types used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>.
    We’re still explicitly using <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    when we call methods in the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    static class. Before we attempt to address that, we need to think carefully about
    which units of measurement each type represents.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encoding Units</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Measurements like speeds, angles, and distances can have multiple representations,
    according to the units we’re using for them. As our code stands, our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    types do not make those units clear. For example, is speed in meters per second
    or miles per hour? Are the angles measured in degrees or radians? Using the wrong
    unit of measurement can introduce errors that are particularly hard to diagnose.
  prefs: []
  type: TYPE_NORMAL
- en: All the equations used in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    assume that speed is measured in meters per second. This is a reasonable default,
    because meters per second is the universal International System of Units (SI)
    unit of speed, but it is implied. If we used a value for speed in kilometers per
    hour, we’d certainly get unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we don’t currently specify the units for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    type. Code that deals with trigonometry commonly uses radians as the unit of measurement,
    and all the trigonometric functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    class, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>, expect
    angle values in radians. Most people, however, think of angles in degrees, and
    confusing the two is a common source of error.
  prefs: []
  type: TYPE_NORMAL
- en: 'This exposes the issue of usability: should our code require units that are
    more convenient for their implementation or more intuitive for the user? Let’s
    consider this question and investigate whether it’s possible to achieve both aims
    simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: C# has several features we can use to encode units, and one common approach
    is to represent the different units by using an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>.
    At first glance, this might seem the obvious solution, but it can cause issues.
    We’ll explore this option and then investigate an alternative solution using static
    methods to create our types with the required units.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Itemizing Units with
    enums</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *enumerated type*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>,
    is a set of related strongly typed constants. Using an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    allows us to specify all the units our type supports. [Listing 1-23](#list1-23)
    modifies our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type to
    use an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> to account for
    units.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-23: Specifying units
    for Speed by using an enum</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Units</samp>
    enumeration is a public type nested within <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    telling us that a speed can be represented in meters per second, kilometers per
    second, or kilometers per hour.
  prefs: []
  type: TYPE_NORMAL
- en: '> <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*While it’s tempting to abbreviate all the names, shortening MetersPerSecond
    to Ms might be confused with* milliseconds*, so it’s best to spell out the unit
    in this case.*'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    takes a number for the magnitude, and the user must provide one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    values for the required units. The user can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>
    property later to discover which units were used when a particular <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance was created. By supporting several units of measurement, we make <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> more generally useful in
    other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Representing supported units with an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    is superficially appealing because it seems simple to implement. However, this
    approach suffers from drawbacks that become apparent when we need to decide how
    to handle two values that have different units.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value Comparisons and Unit
    Conversions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to consider conversions between units in several places in our <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> implementation. For instance,
    these two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values use
    different units but nevertheless represent the same speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> variables
    do not compare equal by default, because their <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> properties have different
    values. We can address that problem by customizing the behavior of equality comparisons
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, perhaps by converting
    both values to meters per second and comparing those values for equality. However,
    we have other, more subtle problems to solve too.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we added operator overloads to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to support multiplying them by a scalar value or a time. Adding support for other
    arithmetic operations, including adding two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>s,
    would be reasonable. We’d have to convert both values to a common unit in order
    to add them together, but what unit should the result be in?
  prefs: []
  type: TYPE_NORMAL
- en: One option would be to always scale every <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value to meters per second—as we do in [Listing 1-24](#list1-24) by using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor to convert
    the parameter value according to the required units—but this approach introduces
    different problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-24: Scaling to a
    common value</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property is
    assigned the value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression, available as of C# v8.0, which uses the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>
    parameter value to scale the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    value to meters per second. The final <samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>
    selector in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> is
    an example of a discard pattern and is used if the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>
    doesn’t match any of the previous types. Here, we throw an exception in these
    circumstances, which might occur if we updated the <samp class="SANS_TheSansMonoCd_W5Regular_11">Units
    enum</samp> with a new element without updating the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>
    parameter only to determine how to scale the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    parameter. The units are not stored, so there’s no <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>
    property either, because a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is always reported in meters per second.
  prefs: []
  type: TYPE_NORMAL
- en: Storing all instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    using the same units solves the problem of equality comparisons and arithmetic
    operations, but it has other drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Limitations of Using enums
    for Units</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Being able to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instances using various units is one thing, but users of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type will also likely expect to be able to obtain the value in different units.
    The necessary conversions are straightforward to implement: [Listing 1-25](#list1-25)
    repurposes <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> as a method
    to convert from the internal meters per second value to the units required.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-25: Obtaining converted
    values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expressions,
    like those in [Listings 1-24](#list1-24) and [1-25](#list1-25), are a characteristic
    of code that uses enumerations to distinguish different types. Those conversions
    can be cumbersome and would be a maintenance headache if we added new units.
  prefs: []
  type: TYPE_NORMAL
- en: 'Always converting <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values to meters per second in the constructor presents an additional problem:
    the amount used to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is altered when we use units other than <samp class="SANS_TheSansMonoCd_W5Regular_11">MetersPerSecond</samp>.
    To demonstrate the issue, consider [Listing 1-26](#list1-26), where we copy a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value by using its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property and the same
    units used to create the original.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-26: Testing equality
    of copied values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most people would expect this test to pass, but it fails because <samp class="SANS_TheSansMonoCd_W5Regular_11">original.Amount</samp>
    was converted to meters per second by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor. The solution is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>
    method to make the copy, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Converting all <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values
    to the common unit of meters per second simplifies the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, but it’s less convenient
    for users wishing to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values measured in a different unit.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, although representing <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    values in radians is convenient when we need to use an angle in a trigonometric
    method, it’s much less convenient for users. As mentioned earlier, most humans
    naturally think of angles in degrees rather than radians, and while the conversion
    is relatively simple, it’s not part of the Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore still need to bridge the gap between what’s intuitive for a user
    and what our code uses internally. Next, we look at an alternative approach to
    enumerations: using static methods that make our types convenient for humans to
    use and also work seamlessly with standard methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Creation Methods</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of using a constructor with an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    parameter to represent units, we can employ the *Class Factory Method* pattern,
    which replaces public constructors with static methods to simplify creating instances.
    These methods have names that reflect the units they represent instead of requiring
    a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> value to
    identify those units.
  prefs: []
  type: TYPE_NORMAL
- en: In our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type, we use
    the class factory methods in [Listing 1-27](#list1-27) to convert the input value
    to the units used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    internally, and return a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with that converted value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-27: Using class factory
    methods to encode units</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have three separate ways to create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    each returning a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value
    converted from the units indicated by the name of the method. When we require
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance, we
    use the method representing the units we want, as demonstrated in [Listing 1-28](#list1-28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-28: Creating Speed
    values with our new class factory methods</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now there’s no need for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor to be public. If we allow our users to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instances directly with <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>,
    they’ll bypass the class factory methods and lose the benefits of the conversions.
    To avoid that, in [Listing 1-29](#list1-29) we make the constructor private.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-29: Making our Speed
    constructor private</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor still contains the validation logic, but now it can be called
    only by our class factory methods, with the argument suitably scaled to meters
    per second. We can’t prevent instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from being default-initialized, but that results in the value being <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    a value that is the same regardless of the units. Note that this is not always
    true, so we need to be alert for cases where this does *not* hold. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> degrees Celsius is not
    the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> degrees Fahrenheit
    for temperature.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Symmetry in Design</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our class factory methods allow us to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values from values measured in different units, the internal representation of
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value is in meters
    per second. To improve usability, we need to provide corresponding conversions
    in the other direction, so users of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    can choose the units they want when they obtain the value. In [Listing 1-30](#list1-30),
    we add properties to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from its internal value to the unit encoded in the name of the property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-30: Viewing Speed
    in different units</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduce a private data member that can be used from each of these properties.
    Doing so avoids *property forwarding* (one property invoking another to obtain
    the needed value) but also allows us to use an expression body for all three properties.
    This is largely an aesthetic choice; the most obvious alternative employing property
    forwarding is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Whichever approach we choose, we have, in effect, renamed the vague <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property as <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>,
    whose purpose is to return the internal value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    The new name better expresses the property’s meaning, matches the naming convention
    used for the other properties, and mirrors the class factory method <samp class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: By using similar naming conventions for the <samp class="SANS_TheSansMonoCd_W5Regular_11">From…</samp>
    methods and the <samp class="SANS_TheSansMonoCd_W5Regular_11">In…</samp> properties,
    we improve the clarity of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    interface. When we see a method such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmPerHour</samp>,
    we naturally expect a corresponding method or property that provides the reverse
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: The class factory methods and corresponding properties provide a compact way
    of expressing units in either direction, and they force us to consciously make
    clear what we mean when we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Units Explicit</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    does not directly use the units of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    because they are encapsulated in the multiplication operator we created for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> *does* use the
    units of an angle, although those units are currently implied in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.Size</samp>
    property, as shown in [Listing 1-31](#list1-31).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-31: Angles in Displacement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> require a measurement
    of an angle in radians, the SI unit for measuring angles. In [Listing 1-32](#list1-32),
    we rename the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> property
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> to make the
    units explicit, and add the conversions to and from degrees as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-32: Adding unit conversions
    to Angle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    we’ve added class factory methods to create an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    in either degrees or radians, with corresponding properties to obtain the value
    in either unit. Now we can use an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    easily with methods that require a value in radians, and using <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    is also much more convenient for users, who tend to think in degrees.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Choosing the Most
    Natural Usage</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> methods take a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    argument, so we need to explicitly access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.InRadians</samp>
    property to call those methods. We can’t change the parameter type of those methods
    because they’re part of the Standard Library, but we can add similarly named methods
    to the interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>,
    which would allow us to encapsulate the explicit need to express the units. We
    can take three main approaches, each with its advantages and drawbacks, and each
    implemented by forwarding an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    value in radians to its counterpart static <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> static class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most direct approach is to introduce <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> instance methods
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, passing the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> field value to the corresponding
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This approach works because we’ve chosen radians as the underlying unit for
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and we provide methods
    to convert to and from degrees. [Listing 1-33](#list1-33) shows how we would use
    these instance methods in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method. Compare this with [Listing 1-31](#list1-31), where we called <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-33: Invoking our
    new instance trigonometric methods</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Our second option is to provide our own static class mirroring the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    class with static <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods that take an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> rather than a plain
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> for their parameters.
    Each method would need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property because it would not have access to the private <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    field. While this approach follows a common convention established by the static
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> class, we lose the more
    compact usage of calling a member method.
  prefs: []
  type: TYPE_NORMAL
- en: The third alternative is to define *extension methods*, which are used as if
    they’re instance methods but are defined in a separate static class. [Listing
    1-34](#list1-34) defines <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> extension methods
    to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>’s interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-34: Defining extension
    methods for Angle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    methods in the static <samp class="SANS_TheSansMonoCd_W5Regular_11">AngleExtensions</samp>
    class use the special syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">this
    Angle</samp> for their parameter, which tells the compiler that the method is
    an extension for an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.
    Each method simply forwards the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property of the angle to its counterpart method in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    namespace. We use the extension methods in exactly the same way we called the
    instance method versions in [Listing 1-33](#list1-33).
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of both the static and extension method implementations that is
    sometimes overlooked is that neither version depends on the internal representation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>. The instance member
    methods could also be implemented in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property, but by extracting methods into separate types if they don’t rely on
    the private implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>,
    we make the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    smaller and easier to comprehend. [Chapter 6](chapter6.xhtml) explores this topic
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Whichever approach we choose, we’ll encapsulate the explicit need to access
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.InRadians</samp> property
    in order to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    trigonometric methods, making it easy for anyone to use our <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Types Implied
    by Units</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Class factory methods such as those we’ve introduced for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> are a common way
    of simplifying the creation of value types. This technique is used by the Standard
    Library in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> type,
    which has methods such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FromSeconds</samp>
    paired with a <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    property. The methods encode the units in their names, so creating value instances
    is very direct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When we initialize these variables, we’re being explicit about the expected
    type as well as the units, but a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">234.0kmh</samp>
    must be a speed. We can’t express this directly, but we can get close by using
    extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: The value <samp class="SANS_TheSansMonoCd_W5Regular_11">234.0</samp> is a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and while we can’t change
    its built-in definition, we can create extension methods for the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type, as [Listing 1-35](#list1-35) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-35: Extending the
    interface of double</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each extension method returns a new instance of the type implied by the units
    in the method’s name, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">Kmh</samp>
    method returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> created
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed.FromKmPerHour</samp>
    class factory method. We use the new extension methods for <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid having to explicitly add the decimal point for the whole numbers,
    we could add overloads that extend <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    too. While this technique can be useful to allow a compact syntax for *literal*
    values, it works less well with variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: However we choose to represent the units of measurement, they are a fundamental
    and intrinsic part of those types. Without units, a number is merely a number,
    even if the name of the type is descriptive. If we make the units of our value
    types easy to define and, just as importantly, make it easy to convert between
    common units, our custom value types will be easier to use and understand.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Fully Formed Encapsulated Value</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Long parameter lists are a hallmark of unclear code. They often indicate that
    a method doesn’t have one clear responsibility and so would benefit from being
    refactored. Some or all of the parameters may be related in some way, indicating
    a missing abstraction. In either case, reducing method parameter lists is another
    way to improve the clarity of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    used throughout this chapter does have a single, clear responsibility and has
    only three parameters. However, two of those parameters are related: a velocity
    is a combination of a speed and a direction. We’ve defined rich types to represent
    speeds and angles that we can now combine to represent velocity with its own type.
    [Listing 1-36](#list1-36) shows our new <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    struct.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-36: Defining an encapsulated
    Velocity type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    no longer needs separate speed and angle values, because they’re now handled by
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    has two related benefits. First, methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    that required two parameters to represent a velocity now need only one. Second,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> is a new abstraction
    to represent a distinct concept. We can give <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    its own specific set of behaviors and semantics and test the semantics independently
    of anything else.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Deciding Whether to Abstract Types</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Introducing a new type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    is not always the most appropriate approach. For example, consider the return
    value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: With our discussion of using types to represent concepts, abstracting the tuple
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> values as a new
    type may seem attractive. But we should consider several factors, including how
    the values will be used, whether there’s any domain-specific behavior we want
    to associate with an independent type, and whether adding a new type will increase
    clarity or obscure it.
  prefs: []
  type: TYPE_NORMAL
- en: If a value is used in only a few places, creating a custom type to represent
    it may not be worthwhile, unless doing so will also reduce code duplication. If
    there’s behavior that we want to encapsulate, we’ll benefit from locating that
    behavior in one place and being able to test it in one place too.
  prefs: []
  type: TYPE_NORMAL
- en: Whether we can give a useful name to the new type is another important consideration.
    For example, the tuple of two <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    values is similar to a coordinate point, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values representing
    distance traveled in two dimensions from a point of origin. However, the name
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> would be misleading,
    because the elements of a coordinate are positions or points rather than distances.
    Now that we’ve created a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    type, however, we might consider revisiting the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    to try to resolve the design problems noted earlier when we introduced the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type. Our example doesn’t
    warrant the extra complexity that would involve, so instead, we’ll take a simpler
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the value returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    the names of the tuple components are more important than giving a name to a new
    type. Rather than defining a completely new type to return from <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    we can take advantage of rich tuple support in C# v7.0 and onward to directly
    “unpack” the return value into named variables, as shown in [Listing 1-37](#list1-37).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-37: Unpacking tuple
    values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this example we use *tuple deconstruction*, giving each member of the returned
    tuple value its own name. The compiler deduces the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">range</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">elevation</samp> variables from
    the values in the tuple, so in this example they’re both instances of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type. This has the advantages
    of being both compact and descriptive enough for many purposes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*We define abstraction as selective ignorance—concentrating on the ideas that
    are relevant to the task at hand, and ignoring everything else. [...] If abstractions
    are well designed and well chosen, we believe that we can use them even if we
    don’t understand all the details of how they work. We do not need to be automotive
    engineers to drive a car.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Andrew Koenig and Barbara Moo, *Accelerated C*++
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: C# provides a few primitive types, especially for numerical values, and it can
    be tempting to use them as they are. However, a method that just takes a long
    list of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> parameters
    can be difficult to decipher. This problem is not restricted to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>;
    methods with a long list of <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> parameters suffer
    from the same pitfalls, but the cure is broadly the same.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in types are intended to be applicable to a wide range of problems
    and to be used as the building blocks for more sophisticated types. C# is, after
    all, an object-oriented language, and it allows us to model our problems with
    domain-specific types.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing primitive values with our own types has several practical benefits.
    It can reduce accidental misuse and defects in the code by ensuring that arguments
    to methods are explicit. This allows us to take advantage of the compiler’s type
    checking. If we mistakenly transpose arguments, our code will fail to compile.
    This kind of early failure prevents those mistakes from causing problems at run
    time or, worse, making it into a live production system and causing us considerable
    embarrassment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating even simple types also allows us to provide descriptive names that
    make our code more self-describing. In turn, this spares us from having to produce
    a lot of separate explanatory documentation, which has a tendency to become stale.
  prefs: []
  type: TYPE_NORMAL
- en: By separating the behavior of a type from the algorithms that use it, and encapsulating
    that behavior in the type itself, we can test it independently of those algorithms.
    The type is more cohesive, and the algorithms are clearer and often simpler. Those
    algorithms themselves become easier for us to test, without having to also test
    the assumptions and implementations captured by the domain type abstractions.
  prefs: []
  type: TYPE_NORMAL
