- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MAKING
    THE MOST OF THE TYPE SYSTEM</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">充分利用类型系统</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Clear and readable source code matters much more to humans than it does to computers.
    Whether we’re trying to debug existing code or learning to use a new feature,
    we inevitably find ourselves reading through source code. It’s important to ensure
    that our code is as readable as possible so that its meaning is clear to other
    readers. Code that’s hard to follow or easily misunderstood is a breeding ground
    for errors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰且易读的源代码对人类比对计算机更为重要。无论是调试现有代码还是学习使用新功能，我们不可避免地会阅读源代码。确保代码尽可能易读是很重要的，这样其他读者能清楚地理解它的含义。难以理解或容易被误解的代码是错误的温床。
- en: One way to improve the clarity of our code is to use the type system to our
    advantage by creating our own types and giving them names that clearly describe
    their purpose. Good names are important for all the types in a system, but it’s
    easy to neglect the simple value types that represent an application’s most granular
    information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 改善代码清晰度的一种方式是通过创建我们自己的类型并赋予它们明确描述其目的的名称，从而充分利用类型系统。良好的命名对于系统中的所有类型都至关重要，但我们很容易忽视那些表示应用程序最细粒度信息的简单值类型。
- en: In this chapter, we’ll examine a short but unclear piece of code and improve
    it over several iterations through a series of techniques that will help you learn
    how to use the type system effectively. By the end of the chapter, you’ll have
    a better understanding of how custom value types contribute to easy-to-understand
    code and how to incorporate a rich set of types into your designs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一段简短但不清晰的代码，并通过多次迭代改进它，采用一系列技巧，帮助你学习如何有效地使用类型系统。到本章结束时，你将更好地理解自定义值类型如何为易于理解的代码做出贡献，并学会如何将丰富的类型集成到你的设计中。
- en: 'We’ll explore the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下内容：
- en: How custom types can help express meaning and make code more self-documenting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过自定义类型来表达意义，并使代码更具自文档性
- en: How to encapsulate domain-specific behavior to reduce errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何封装特定领域的行为以减少错误
- en: Where to use some syntax features from C# v9.0 and v10.0 for compact and readable
    code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 C# v9.0 和 v10.0 中的一些语法特性，使代码更加简洁且易读
- en: How to make using custom types easy and natural in commonplace code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在日常代码中轻松自然地使用自定义类型
- en: To begin, let’s look at a simple example of value types in action and why they’re
    such an important feature of our designs
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一个简单的值类型示例，了解它们为什么是我们设计中如此重要的特性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Value of Good Names</samp>
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">良好命名的重要性</samp>
- en: Choosing good names for identifiers can be difficult but has a major impact
    on the clarity of our code. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method in [Listing 1-1](#list1-1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 选择好的标识符名称可能很困难，但对代码的清晰度有着重大影响。考虑一下[清单 1-1](#list1-1)中的<sampt class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>方法。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: An example of
    bad variable naming</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-1：一个糟糕变量命名的示例</samp>
- en: The method’s three parameters—<samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>—are
    poorly named, and their purpose isn’t immediately clear. We’ll use this code throughout
    the chapter to explore a variety of ways to improve it and better define its intent.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的三个参数——<samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>——命名不佳，且它们的目的并不立即明确。我们将在本章中通过多次改进，利用各种方法来提升代码的质量，明确其意图。
- en: The purpose of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method is to calculate the position of a projectile on its ballistic arc, given
    an initial angle and velocity, and the time elapsed since the projectile was launched.
    If you’re familiar with the equations for projectile motion, you may recognize
    the algorithm, but the variable names provide no clue whatsoever to their purpose.
    When called, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method calculates the coordinate value of the projectile relative to its launch
    point, as illustrated in [Figure 1-1](#fig1-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1:</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Projectile
    displacement</samp>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The angle, initial speed, and time labels in [Figure 1-1](#fig1-1) correspond
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> parameters for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, respectively. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    values correspond to the components of the tuple returned by that method. The
    projectile is launched with an initial speed, at a particular angle, and follows
    a well-defined ballistic arc. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method calculates the projectile’s position on that arc after a given amount of
    time has passed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go into the algorithm being used here, as our focus is merely on making
    the purpose of this method more immediately clear. The first barrier to our understanding
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    is the meaning of its parameters and return value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: I have deliberately exaggerated the issue with single-letter names, but I’ve
    seen similar examples in the real world and thought, *What on earth do those parameters
    represent?* Even if we carefully inspect how the parameters have been used, determining
    their meaning requires being familiar with the equations. That is just poor code
    craft. Not all of us have kept up with our ballistics studies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: We want to make it as easy as possible for the reader to determine the purpose
    of the method, whether they’re familiar with the topic or not. The quickest way
    to accomplish this is to ensure that the parameter names better reflect what they
    represent. In particular, code should avoid relying on specialist jargon. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> here stands for *theta*,
    which is typically used in physics to represent the magnitude of an angle, but
    even if we replaced <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> with
    the full word <samp class="SANS_TheSansMonoCd_W5Regular_11">theta</samp>, readers
    unfamiliar with this mathematical convention would be unlikely to make that connection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using potentially obscure single-letter names, let’s give the parameters
    names that properly signify their meaning:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By renaming <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> as <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">angle</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">elapsedTime</samp>, we’ve made
    their purpose clearer. Changing velocity to speed might seem a minor change, but
    the names we use *matter*. While the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    for *velocity* is common, <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    is a more accurate description of this value’s purpose. *Velocity* is a technical
    term with a specific meaning in physics; it represents *both* magnitude (speed)
    and direction. If we name code elements as accurately and properly as we can,
    we reduce the risk of those names being misunderstood.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Selecting good names is a first step toward making code clearer and easier to
    read. However, we can do much more to improve our code’s clarity and remove ambiguity
    about what those identifiers represent. We might reasonably ask, for example,
    in what units the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    parameters are measured. We’ll address that later in the chapter, but first we
    need a more sophisticated mechanism than the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type allows.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding Clarity Through Types</samp>
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method’s
    parameters are of the same type: <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    This makes it easy for anyone, including ourselves, to accidentally mix up argument
    values when calling the method—without any warning from the compiler.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type itself
    is not the specific culprit here; we’d have the same problem if the parameters
    were all <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> or all <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> types. Even if each parameter
    were of a different built-in numeric type, plenty of potential for problems would
    still remain because of the presence of the implicit promotion rules between them.
    Moreover, clarifying the parameter names doesn’t necessarily help the calling
    code, especially if the method is called with plain constant values like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Hard-coded values such as those used in this example are called *magic numbers*
    because there’s no explanation of their meaning or purpose. We could replace the
    magic numbers with better-named variables to make their purpose clearer, but the
    caller of the method might still supply the arguments in the wrong order.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: One common way for the calling code to address such out-of-order errors is to
    specify the parameter name for each argument. Let’s see that in practice before
    looking at how to use different types to distinguish between the argument values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Named Arguments</samp>
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Embedding the parameter name for each argument being passed to a method makes
    the purpose of those arguments much more visible in the calling code, as shown
    here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method specifies which parameter receives each value being supplied. The caller
    must match the parameter names of the method but can order them in any way they
    like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Naming the arguments makes the order in which they’re passed irrelevant. The
    compiler will ensure that each argument value gets passed to the right parameter
    according to its name, not its position.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: This technique puts the responsibility of clarity onto the *caller* of the method.
    If the caller forgets or doesn’t bother to name the arguments, the compiler won’t
    warn them. The compiler will also give no warning if the caller mixes up the value
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>.
    The code will compile, and the program will run, but it will almost certainly
    give incorrect results. Worse, the code might give a result that is almost correct
    for one specific set of arguments and then fail at the worst possible moment when
    different values are passed. The causes of errors like this can be difficult to
    track down.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Custom Types</samp>
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problems we’re seeing with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method stem from using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type to represent several distinct concepts. This is a variation of the *Primitive
    Obsession* code smell, which describes any code that has an overreliance on primitive
    types—that is, those types that are built into the language, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Measurements and quantities such as speed commonly have numerical representations,
    but the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type is too
    general; it can be used to represent a wide variety of values, including <samp
    class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    in our example, making it possible for the caller of the code to provide the wrong
    values. The <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> quantities are measured in
    different ways to mean different things. Using a raw <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    does not express the distinctions between them clearly enough. An angle of 45
    degrees is a very different value from a speed of 45 meters per second.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The well-known solution to primitive obsession is to provide our own types with
    distinct purposes and to ensure that no implicit conversions exist between them.
    This enables the compiler to identify any arguments that are used inappropriately.
    Instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to
    store quantities of <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, [Listing 1-2](#list1-2)
    defines two types that more positively convey their differences.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-2: Defining our own
    types</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Our user-defined structs <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> are still quite
    primitive; they’re merely wrappers around a public property (<samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>, respectively)
    that allows us to read or write the value being represented in each case. We’ll
    improve this design, but for now it meets the immediate need: to distinguish values
    of angle from values of speed by their type rather than just by the parameter
    names.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-3](#list1-3) demonstrates how we use these new types for the parameters
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-3: Using custom types
    as parameters</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The C# Standard Library does not provide any abstractions for angles or speeds,
    but it does have the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    type, which is ideal for the <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    parameter. Now the *type* of each parameter describes its value, so the parameter
    names have less responsibility. Any attempt to provide the arguments in the incorrect
    order, like substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>, will cause the
    compiler to complain with a fairly obvious error message about not being able
    to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encapsulation</samp>
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using distinct types for the values in a design emphasizes each value’s role
    rather than its representation, making the code more self-documenting for human
    readers and allowing better error checking by the compiler. We’ve achieved our
    stated goal of preventing arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    from being positioned incorrectly, but right now <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> are simple types
    that just *have* a value, rather than *being* a particular kind of value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: These types do not encapsulate their values in any way because their values
    are exposed as the publicly mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> properties. Those
    properties are currently the only way to create instances of those types, as we
    do in [Listing 1-4](#list1-4), where we use object initialization to set the property
    values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-4: Using object initialization
    to create inline argument instances</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Using the public properties to set the values here is unnecessarily verbose.
    [Listing 1-5](#list1-5) simplifies the syntax by adding constructors so we can
    create new instances directly with a value instead of having to set a public property.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-5: Adding constructors
    for Speed and Angle</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Here, when we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    we construct the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances with their
    values instead of setting their properties ❶. Now that the type names are more
    descriptive, the order of the arguments is not ambiguous, so naming the arguments
    is no longer so important.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: These constructors use the *expression body syntax*, introduced for methods
    in C# v6.0 and available since C# v7.0 for constructors. With this syntax, instead
    of a block enclosed by braces <samp class="SANS_TheSansMonoCd_W5Regular_11">{…}</samp>,
    the expression is a single assignment separated from the constructor’s signature
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">=></samp> symbol. Since <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    each have only a single property to initialize, the expression-bodied constructors
    are concise and convenient.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Compare the final line with [Listing 1-4](#list1-4). The changes to <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in [Listing 1-5](#list1-5)
    allow us to construct the values we want instead of using the object initializer
    in each case. This reduces the amount of typing the caller has to do but, more
    importantly, expresses more directly that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> *is* a value instead
    of just *having* a value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Immutability</samp>
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, our values are all mutable, but once we’ve given an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> a value in its constructor,
    we don’t need to allow that value to change. If we require an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    with a different value, we can create a new instance with that value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: We achieve this immutability by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> property
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> to make it a read-only
    property. Then the only way to provide a value is via the constructor, and that
    value is permanent and immutable. We’ll do the same for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, as shown
    in [Listing 1-6](#list1-6).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-6: Making Speed immutable</samp>'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance can’t change, we also make it <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>.
    The compiler will then ensure that no members of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    can modify the state and will fail to compile any attempt to change an instance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Designing our types to be immutable makes our code easier to reason about during
    code inspection because we don’t need to consider the various ways that instances
    of our type might change. This is especially important in multithreaded programs,
    but making value types read-only can also improve performance in some circumstances
    by enabling the compiler to use certain optimizations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设计类型为不可变使得在代码检查时更容易推理代码，因为我们不需要考虑类型实例可能发生变化的各种方式。这在多线程程序中特别重要，但在某些情况下，通过使值类型只读，也可以通过让编译器使用某些优化来提高性能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Validation</samp>
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">值验证</samp>
- en: Having introduced constructors for our types, we can use those constructors
    to check for invalid arguments and raise exceptions if the user passes illegal
    values. For example, sensible values for a speed must be nonnegative. In [Listing
    1-7](#list1-7), we check that the value given the constructor is not less than
    0 and throw an exception if it is.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了类型的构造函数后，我们可以使用这些构造函数来检查无效参数，并在用户传入非法值时抛出异常。例如，速度的合理值必须是非负的。在[列表 1-7](#list1-7)中，我们检查传给构造函数的值是否小于
    0，如果是，则抛出异常。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-7: Prohibiting out-of-range
    values</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 1-7：禁止超范围值</samp>
- en: The constructor of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    validates the value provided, and since the constructor is the only way to provide
    a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, we ensure
    that only legal <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values
    can be created. We should use the constructor to prohibit other illegal argument
    values, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp>,
    and perhaps even add an upper limit of the speed of light. If we attempt to create
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> with an illegal value,
    we get a run-time exception.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的构造函数验证了提供的值，并且由于构造函数是唯一提供
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 值的方式，我们确保只能创建合法的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 值。我们应该使用构造函数来禁止其他非法的参数值，例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp>，并且也许还可以添加一个光速的上限。如果我们尝试创建一个带有非法值的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>，我们将得到一个运行时异常。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp>
    type is defined in the Standard Library and is a good example of a descriptively
    named type. Note that in [Listing 1-7](#list1-7), we name the arguments for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp>
    constructor, *which takes two plain* <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">string</samp>
    *parameters* (<samp class="SANS_TheSansMonoCd_W5Regular_11">paramName:</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">message:</samp>). Otherwise,
    the order of those arguments is easily muddled, especially since the similarly
    named <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentException</samp> takes
    the same parameters in the reverse order!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp>
    类型在标准库中定义，是一个命名非常具描述性的类型的良好示例。注意，在[列表 1-7](#list1-7)中，我们为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp>
    构造函数命名了参数，*它接受两个普通的* <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">string</samp>
    *参数*（<samp class="SANS_TheSansMonoCd_W5Regular_11">paramName:</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">message:</samp>）。否则，这些参数的顺序容易混淆，特别是由于同名的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentException</samp> 将相同的参数顺序颠倒了！
- en: 'Validating the parameter value in <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor is one example of encapsulation: we’ve put the validation logic in
    one place instead of scattering it among any methods that use it. Now, any methods
    that use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance
    automatically benefit from the range check performed by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 构造函数中验证参数值是封装的一个示例：我们将验证逻辑集中在一个地方，而不是将其分散到任何使用它的方法中。现在，任何使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 实例的方法都会自动受益于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 构造函数执行的范围检查。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*A major benefit of creating our own types is that we encapsulate their responsibilities,
    thereby reducing the responsibilities of the methods that use them. Minimizing
    duplicated code is yet another way we make our code clearer, easier to use, and
    much less difficult to maintain.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    establishes a *class invariant*—a condition that must hold for the lifetime of
    any instance of the type—specifying that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value is never less than 0\. The invariant can never be broken because we made
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> immutable. Once a valid
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance is created,
    its value never changes, and it’s impossible to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with an invalid value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing</samp>
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By encapsulating the validation within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type, we can also test the class invariant independently of any algorithms that
    depend on it. In [Listing 1-8](#list1-8), we attempt to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with a negative value to test that the constructor throws an exception.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-8: Testing constraints
    on Speed</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Because the validation code is encapsulated within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type, we need only this one test for it. We don’t need to separately test that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, or any other
    method using <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, rejects
    invalid speed values. All the testing for <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    can focus on ensuring that the algorithm is correct, without being concerned about
    parameter validation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Using types for domain concepts, then, has several advantages. Code using our
    types is clearer because of the self-describing characteristics of the type. We
    separate concerns, making the program easier to understand and the testing more
    focused and specific. This makes the tests simpler, and easier to maintain when
    the code being tested needs to change.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Refactoring</samp>
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve addressed the issues with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method’s parameters, let’s look at its method body to see if we can make further
    improvements by refactoring the implementation. [Listing 1-9](#list1-9) shows
    our current code for <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-9: The current Displacement
    implementation</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: This code works correctly, but we have some issues to take care of. We’ve made
    the code more verbose by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    types as parameters, requiring us to access properties of those parameters to
    obtain their values. Note that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    property here; one common error is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> object
    when the intention is to obtain the total number of seconds being represented,
    but <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp> returns only
    the seconds component of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>.
    Given a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> representing
    1 minute precisely, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp>
    property would return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    while the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    would be <samp class="SANS_TheSansMonoCd_W5Regular_11">60</samp>.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    would be clearer if we could use the variables *directly* in the algorithm, like
    this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The algorithm also relies on three hard-coded values. Magic numbers like this
    often indicate that we need to provide names to clarify their purpose. It’s common
    to find the same magic number used in more than one place, so if the value changed
    for any reason, we’d need to hunt for every use and make sure we updated them
    all.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: While we can see that multiplying by <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>
    is the same as dividing by <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    the meaning of <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp> is much
    less obvious. The value <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> used in the call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Pow</samp> are simply arithmetic
    values; giving them names might obscure their purpose rather than clarifying it.
    The value <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>, on the other
    hand, stands out as having a more significant purpose. Once again, to understand
    the meaning of this number, we need prior knowledge that <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>
    is an approximation of the effects of Earth’s gravity on an object. We’ll address
    this issue first with the simple fix of naming this value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Magic Numbers
    with Named Constants</samp>
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replacing magic numbers in code with a descriptive name clarifies their meaning
    to readers unfamiliar with the algorithm’s details. One way to do this is to create
    a new value type, similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    to represent the measurement. However, when we need only a few well-known values,
    using named constants to represent them is often simpler. For now, we need only
    a single value (for Earth’s gravity). [Listing 1-10](#list1-10) shows one way
    we could indicate that value’s purpose by giving it a meaningful name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-10: Simple encoding
    of magic numbers</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: While the named constant for gravity is the simplest replacement for the magic
    number, we’re passing up an opportunity to benefit from a more general type named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Acceleration</samp> or something
    similar. Doing so would give us the greatest flexibility but would also increase
    complexity and maintenance. Keeping code simple has its own benefits.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'We should, however, keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    values like this are baked into our code by the compiler, so if we change the
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">Gravity.Earth</samp> but
    compile against a prebuilt assembly that uses the same constant, the overall program
    could use two different values for the same constant. In the interests of brevity
    and simplicity, we’ll keep the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    value and replace the hard-coded number in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Gravity.Earth</samp> constant
    so human readers know immediately what it means:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now if we want to use a more precise approximation of gravity, we only need
    to change the constant’s value instead of searching for all uses of the magic
    number <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>, with the caveat
    that we must remember to recompile any other modules that use that constant.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simplifying Properties
    and Values</samp>
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    is now much more explicit about the meanings of the variables it uses. [Listing
    1-11](#list1-11) shows its current implementation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-11: Displacement
    using explicit property access</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, accessing the properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    makes the implementation quite verbose. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method would be tidier and easier still to read if we could access these properties
    directly in the operations where they were used. The <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    variable’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property
    is being multiplied by <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    ❶, and <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp> is used
    to call both <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> ❷ and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> ❸. Each use of our
    types requires us to explicitly obtain the corresponding property value in order
    to multiply two values together, and to pass them as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We can’t change the behavior of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    variable to allow it to be multiplied by a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> can be multiplied
    by a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> value. If we
    could use <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances
    as if they were <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values,
    we would avoid having to explicitly use their properties in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    making the method less cluttered; that is, we would be able to multiply <samp
    class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    without using the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed.Amount</samp>
    property. Likewise, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    type, we could call methods such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, which both
    expect a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> argument,
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> variable directly
    if we could treat <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> instances
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The result of the whole expression would be a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>,
    which is the result type from multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    by a number, so we’d need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    property at some point. Still, removing the need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> properties of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    would simplify and shorten the method’s implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve that outcome is by defining our own implicit conversion operators.
    This approach is superficially appealing because it is simple to implement, but
    it has several drawbacks. Let’s examine some of those potential problems.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implicit Conversions</samp>
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We define an implicit conversion for our own types by implementing an implicit
    conversion operator method and specifying the target type we need, as shown for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in [Listing 1-12](#list1-12).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-12: Defining an implicit
    conversion for Speed</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The target type here is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    and we simply return the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property. We also add a similar conversion operator for <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    (not shown here) that returns its <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    property. Now we no longer need to explicitly use <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp>
    when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, and we can multiply
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> by the <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    value without needing to get the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed.Amount</samp>
    property. Compare [Listing 1-13](#list1-13) with the earlier version in [Listing
    1-11](#list1-11).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-13: Using implicit
    conversions</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    is now much more compact—but we’ve introduced some hidden problems.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Unexpected Interactions</samp>
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Implicit conversions weaken the interface to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> by allowing them
    to participate everywhere that a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    might be used, which means they can be used in expressions where it’s not appropriate.
    For example, dividing a speed by an angle would be a legal expression, as demonstrated
    in [Listing 1-14](#list1-14).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-14: Unplanned behavior
    resulting from an implicit conversion</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: This expression is valid owing to the implicit conversions from both <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    but the result is meaningless, and we get no warning from the compiler. In addition,
    implicit conversions are usually invisible in our code. If we pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value to <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> instead
    of an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, the resulting
    calculation errors could be hard to find.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Discarded Invariants</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the benefits we realized by introducing a custom type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    was that we could encapsulate validation logic in <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the implicit conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> means that code
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> result can
    breach the constraints on the allowable range of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    In [Listing 1-15](#list1-15), we subtract one <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from another smaller value, leaving us with a result that’s less than 0.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-15: Unchecked constraints
    resulting from an implicit conversion</samp>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: This subtraction expression, which is between two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values as a result of the implicit conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, will run just
    fine. The result is negative and thus out of range for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but it’s a perfectly legal <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: To address this out-of-range value, we need to restrict the permitted operations
    on <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    so they make sense for those measurements. This was the whole purpose of introducing
    a class invariant for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to ensure that instances of it always have a valid value. Furthermore, we want
    to prohibit operations that make no sense, ideally in a way that would allow the
    compiler to tell us when something is wrong.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: We introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> as specific types so
    that we could tell them apart, and because using a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    was simply too general to represent those measurements. However, the implicit
    conversions make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> indistinguishable from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We can still achieve our objective of making our types easy to use in arithmetic
    expressions, but we need to keep control over which operations those types can
    perform. We’ll allow specific operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> without sacrificing
    their natural usage or compromising the encapsulation of the types.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overloading Arithmetic
    Operators</samp>
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our initial motivation for introducing implicit conversions for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    was to support the multiplication operation between a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp> property
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> value. Currently,
    we must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to make that calculation,
    as shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Arithmetic operations such as <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    for multiplication are predefined for the built-in numeric types like <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    We can define the meaning of these symbols for our own types by providing arithmetic
    operator overloads.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-16](#list1-16) shows the multiplication operator overload for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-16: Supporting multiplication
    in Speed</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: We use a target-typed <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    expression, introduced in C# v9.0, to create the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>
    to return. The compiler knows that the expected type is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    as it’s being directly returned, so we don’t need to explicitly specify the type
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">new Speed(…)</samp>. The compiler
    will infer the type according to the value expected by the left side of the expression.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Being able to multiply a speed value by a number makes intuitive sense; something
    might be traveling at double the speed of something else, for example. We implement
    the operator by creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from the product of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property and the value passed to the operator’s parameter. The constructor for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> will check that the
    result is within the allowed range of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and will throw an exception if the result is out of range. We can demonstrate
    that this works with a simple test, such as [Listing 1-17](#list1-17), where we
    attempt to multiply a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a negative number.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-17: Testing the multiplication
    operator</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and then
    verify that when we try multiplying it by <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>,
    the constructor throws an exception. We also ensure that when we halve the value,
    the operation succeeds with the expected result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: We can define operator overloads for other arithmetic operations and specify
    precisely the expressions in which <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is permitted to take part. Values commonly overload arithmetic operators, where
    it is appropriate to do so.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Not all values are arithmetic in nature, so we need to carefully consider whether
    to support those operations for a type. For example, creating our own value type
    to represent a UK postal code would be perfectly natural, but multiplying a postal
    code by a number or by another postal code makes no sense whatsoever, because
    postal codes are not arithmetic values. Examples of other nonarithmetic values
    include US ZIP codes and colors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values
    should naturally take part in some, but not all, arithmetic expressions. It makes
    sense to be able to double a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but not to multiply two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values together. We can use custom arithmetic operator overloads to control which
    expressions should be permitted, and by adding explicit support for them, we make
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> easier to use.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining a Need
    for New Types</samp>
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever we refactor a piece of code, we may discover a requirement or opportunity
    to introduce a new type. The need for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types was fairly
    plain because we introduced them to replace primitive parameter variables. Not
    all missing abstractions are so obvious.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'If we multiply a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a number, the result is a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    multiplies a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> value, which
    is not simply a number. Here we split that calculation into separate parts to
    make it clearer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As noted earlier, multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a number intuitively produces a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    Both <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    here are therefore instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    because of our implementation of the multiplication operator, but note that the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    value is not just any number but rather a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    instance representing a *time*. Mathematically, the result of this expression
    is not a speed at all: multiplying a speed by a time produces a *distance*, which
    we can represent directly in our code by introducing a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    type, as shown in [Listing 1-18](#list1-18).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-18: The Distance
    type</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a new overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> that multiplies
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> directly by a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> and produces a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
    Even better, we can define this overload in addition to the multiplication operator
    we’ve already defined that takes a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and returns a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    [Listing 1-19](#list1-19) shows both operator overloads.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-19: Overloading operator*</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Overloading is versatile. We can overload a method with different types of parameters,
    and each overload can return a different type. The rules for overloading consider
    only the method signature—that is, the number and types of the parameters. We
    can therefore return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from the overload taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> from
    the method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    instance.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Refining the New Type</samp>
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we need to add behavior to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    type so that it will work correctly in our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    implementation. Multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> gives us a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> value, which we
    use in further arithmetic expressions of its own, shown in [Listing 1-20](#list1-20).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-20: The Distance
    type in use</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The expressions for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are both now multiplying
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> value by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values returned from <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>.
    This code will fail to compile because <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    needs its own overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: As with <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values, multiplying
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> by a simple number
    produces a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
    The results of <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, apart from being
    out of our control, are scalar values, so when we multiply them by a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>,
    the result is another <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> also requires
    an overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator-</samp>
    so that the subtraction operation used in the calculation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    value will compile. As with the multiplication, the expression on the right of
    the subtraction gives a scalar value, so we add the multiplication and subtraction
    operators for <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> in
    [Listing 1-21](#list1-21).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-21: Arithmetic operations
    for Distance values</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: With these overloads, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> values naturally
    together to produce <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    values. Those values, in turn, work seamlessly with the other required expressions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Design Imperfection</samp>
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    returns a tuple of two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values. However, with our changes, the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values being returned
    have become instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    rather than plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values. This introduces another terminology problem with respect to the return
    value: in physics, a distance, like a speed, is always either 0 or a positive
    value. Combining a distance with the result of a trigonometric function like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> is a coordinate position, rather
    than a distance, and can be negative.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: We identified the <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    type from the result of multiplying a speed by a time, but there is no straightforward
    way to distinguish the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> from a plain
    number like <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>, denying
    us the opportunity to add an overload of the multiplication operator in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> to return a new type,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>, rather
    than another <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>. We
    have reached the limits of exploiting the types we have chosen for modeling real-world
    concepts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: An obstacle like this may be the symptom of a deeper design smell, an indication
    that the problem might be resolved by a change in design perspective. In this
    instance, we may be able to achieve a more complete solution by reworking <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>’s algorithm in terms
    of a full-fledged <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    type instead of the relatively primitive <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types. Exploring
    that solution is fairly complex, however, and best left to a text dedicated to
    modeling physics problems, leaving us with a pragmatic decision to make.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: One option is to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>
    type, or something similar, to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
    This approach suffers from the drawback that the arithmetic operations we defined
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> do not apply
    so naturally to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>.
    Moreover, if <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> is
    useful elsewhere in an application, it makes complete sense that when we multiply
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>,
    the result is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>,
    not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to do nothing and permit <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    to have negative values in the context of our application. While <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    would then be an imperfect representation of its counterpart in physics, this
    approach benefits from simple and natural uses in other areas. In [Listing 1-22](#list1-22),
    we change the return type of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> values directly,
    which further simplifies the implementation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-22 The new Displacement
    method</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: We could have retained the existing return type by returning the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables. For example, if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> is already widely
    used, altering the type it returns might be intrusive. Nonetheless, introducing
    the richer <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type
    more widely in an application has benefits similar to replacing the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    parameters in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> types.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: However we decide to best serve the requirements of the application and its
    users, we can make more pressing improvements to the types used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>.
    We’re still explicitly using <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    when we call methods in the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    static class. Before we attempt to address that, we need to think carefully about
    which units of measurement each type represents.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encoding Units</samp>
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Measurements like speeds, angles, and distances can have multiple representations,
    according to the units we’re using for them. As our code stands, our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    types do not make those units clear. For example, is speed in meters per second
    or miles per hour? Are the angles measured in degrees or radians? Using the wrong
    unit of measurement can introduce errors that are particularly hard to diagnose.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: All the equations used in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    assume that speed is measured in meters per second. This is a reasonable default,
    because meters per second is the universal International System of Units (SI)
    unit of speed, but it is implied. If we used a value for speed in kilometers per
    hour, we’d certainly get unexpected results.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we don’t currently specify the units for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    type. Code that deals with trigonometry commonly uses radians as the unit of measurement,
    and all the trigonometric functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    class, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>, expect
    angle values in radians. Most people, however, think of angles in degrees, and
    confusing the two is a common source of error.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'This exposes the issue of usability: should our code require units that are
    more convenient for their implementation or more intuitive for the user? Let’s
    consider this question and investigate whether it’s possible to achieve both aims
    simultaneously.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: C# has several features we can use to encode units, and one common approach
    is to represent the different units by using an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>.
    At first glance, this might seem the obvious solution, but it can cause issues.
    We’ll explore this option and then investigate an alternative solution using static
    methods to create our types with the required units.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Itemizing Units with
    enums</samp>
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *enumerated type*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>,
    is a set of related strongly typed constants. Using an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    allows us to specify all the units our type supports. [Listing 1-23](#list1-23)
    modifies our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type to
    use an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> to account for
    units.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-23: Specifying units
    for Speed by using an enum</samp>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In this code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Units</samp>
    enumeration is a public type nested within <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    telling us that a speed can be represented in meters per second, kilometers per
    second, or kilometers per hour.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '> <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '*While it’s tempting to abbreviate all the names, shortening MetersPerSecond
    to Ms might be confused with* milliseconds*, so it’s best to spell out the unit
    in this case.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    takes a number for the magnitude, and the user must provide one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    values for the required units. The user can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>
    property later to discover which units were used when a particular <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance was created. By supporting several units of measurement, we make <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> more generally useful in
    other applications.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Representing supported units with an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    is superficially appealing because it seems simple to implement. However, this
    approach suffers from drawbacks that become apparent when we need to decide how
    to handle two values that have different units.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value Comparisons and Unit
    Conversions</samp>
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to consider conversions between units in several places in our <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> implementation. For instance,
    these two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values use
    different units but nevertheless represent the same speed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> variables
    do not compare equal by default, because their <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> properties have different
    values. We can address that problem by customizing the behavior of equality comparisons
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, perhaps by converting
    both values to meters per second and comparing those values for equality. However,
    we have other, more subtle problems to solve too.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we added operator overloads to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to support multiplying them by a scalar value or a time. Adding support for other
    arithmetic operations, including adding two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>s,
    would be reasonable. We’d have to convert both values to a common unit in order
    to add them together, but what unit should the result be in?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: One option would be to always scale every <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value to meters per second—as we do in [Listing 1-24](#list1-24) by using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor to convert
    the parameter value according to the required units—but this approach introduces
    different problems.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-24: Scaling to a
    common value</samp>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property is
    assigned the value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression, available as of C# v8.0, which uses the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>
    parameter value to scale the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    value to meters per second. The final <samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>
    selector in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> is
    an example of a discard pattern and is used if the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>
    doesn’t match any of the previous types. Here, we throw an exception in these
    circumstances, which might occur if we updated the <samp class="SANS_TheSansMonoCd_W5Regular_11">Units
    enum</samp> with a new element without updating the constructor.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>
    parameter only to determine how to scale the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    parameter. The units are not stored, so there’s no <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>
    property either, because a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is always reported in meters per second.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Storing all instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    using the same units solves the problem of equality comparisons and arithmetic
    operations, but it has other drawbacks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Limitations of Using enums
    for Units</samp>
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Being able to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instances using various units is one thing, but users of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type will also likely expect to be able to obtain the value in different units.
    The necessary conversions are straightforward to implement: [Listing 1-25](#list1-25)
    repurposes <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> as a method
    to convert from the internal meters per second value to the units required.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-25: Obtaining converted
    values</samp>'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expressions,
    like those in [Listings 1-24](#list1-24) and [1-25](#list1-25), are a characteristic
    of code that uses enumerations to distinguish different types. Those conversions
    can be cumbersome and would be a maintenance headache if we added new units.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Always converting <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values to meters per second in the constructor presents an additional problem:
    the amount used to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is altered when we use units other than <samp class="SANS_TheSansMonoCd_W5Regular_11">MetersPerSecond</samp>.
    To demonstrate the issue, consider [Listing 1-26](#list1-26), where we copy a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value by using its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property and the same
    units used to create the original.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-26: Testing equality
    of copied values</samp>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Most people would expect this test to pass, but it fails because <samp class="SANS_TheSansMonoCd_W5Regular_11">original.Amount</samp>
    was converted to meters per second by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor. The solution is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>
    method to make the copy, like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Converting all <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values
    to the common unit of meters per second simplifies the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, but it’s less convenient
    for users wishing to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values measured in a different unit.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, although representing <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    values in radians is convenient when we need to use an angle in a trigonometric
    method, it’s much less convenient for users. As mentioned earlier, most humans
    naturally think of angles in degrees rather than radians, and while the conversion
    is relatively simple, it’s not part of the Standard Library.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore still need to bridge the gap between what’s intuitive for a user
    and what our code uses internally. Next, we look at an alternative approach to
    enumerations: using static methods that make our types convenient for humans to
    use and also work seamlessly with standard methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Creation Methods</samp>
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of using a constructor with an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    parameter to represent units, we can employ the *Class Factory Method* pattern,
    which replaces public constructors with static methods to simplify creating instances.
    These methods have names that reflect the units they represent instead of requiring
    a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> value to
    identify those units.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type, we use
    the class factory methods in [Listing 1-27](#list1-27) to convert the input value
    to the units used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    internally, and return a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with that converted value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-27: Using class factory
    methods to encode units</samp>'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have three separate ways to create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    each returning a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value
    converted from the units indicated by the name of the method. When we require
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance, we
    use the method representing the units we want, as demonstrated in [Listing 1-28](#list1-28).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-28: Creating Speed
    values with our new class factory methods</samp>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Now there’s no need for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor to be public. If we allow our users to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instances directly with <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>,
    they’ll bypass the class factory methods and lose the benefits of the conversions.
    To avoid that, in [Listing 1-29](#list1-29) we make the constructor private.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-29: Making our Speed
    constructor private</samp>'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The constructor still contains the validation logic, but now it can be called
    only by our class factory methods, with the argument suitably scaled to meters
    per second. We can’t prevent instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from being default-initialized, but that results in the value being <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    a value that is the same regardless of the units. Note that this is not always
    true, so we need to be alert for cases where this does *not* hold. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> degrees Celsius is not
    the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> degrees Fahrenheit
    for temperature.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Symmetry in Design</samp>
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our class factory methods allow us to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values from values measured in different units, the internal representation of
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value is in meters
    per second. To improve usability, we need to provide corresponding conversions
    in the other direction, so users of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    can choose the units they want when they obtain the value. In [Listing 1-30](#list1-30),
    we add properties to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from its internal value to the unit encoded in the name of the property.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-30: Viewing Speed
    in different units</samp>'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduce a private data member that can be used from each of these properties.
    Doing so avoids *property forwarding* (one property invoking another to obtain
    the needed value) but also allows us to use an expression body for all three properties.
    This is largely an aesthetic choice; the most obvious alternative employing property
    forwarding is shown here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Whichever approach we choose, we have, in effect, renamed the vague <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property as <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>,
    whose purpose is to return the internal value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    The new name better expresses the property’s meaning, matches the naming convention
    used for the other properties, and mirrors the class factory method <samp class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp>.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: By using similar naming conventions for the <samp class="SANS_TheSansMonoCd_W5Regular_11">From…</samp>
    methods and the <samp class="SANS_TheSansMonoCd_W5Regular_11">In…</samp> properties,
    we improve the clarity of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    interface. When we see a method such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmPerHour</samp>,
    we naturally expect a corresponding method or property that provides the reverse
    conversion.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The class factory methods and corresponding properties provide a compact way
    of expressing units in either direction, and they force us to consciously make
    clear what we mean when we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Units Explicit</samp>
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    does not directly use the units of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    because they are encapsulated in the multiplication operator we created for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> *does* use the
    units of an angle, although those units are currently implied in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.Size</samp>
    property, as shown in [Listing 1-31](#list1-31).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-31: Angles in Displacement</samp>'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> require a measurement
    of an angle in radians, the SI unit for measuring angles. In [Listing 1-32](#list1-32),
    we rename the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> property
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> to make the
    units explicit, and add the conversions to and from degrees as well.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-32: Adding unit conversions
    to Angle</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    we’ve added class factory methods to create an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    in either degrees or radians, with corresponding properties to obtain the value
    in either unit. Now we can use an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    easily with methods that require a value in radians, and using <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    is also much more convenient for users, who tend to think in degrees.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Choosing the Most
    Natural Usage</samp>
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> methods take a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    argument, so we need to explicitly access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.InRadians</samp>
    property to call those methods. We can’t change the parameter type of those methods
    because they’re part of the Standard Library, but we can add similarly named methods
    to the interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>,
    which would allow us to encapsulate the explicit need to express the units. We
    can take three main approaches, each with its advantages and drawbacks, and each
    implemented by forwarding an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    value in radians to its counterpart static <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> static class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The most direct approach is to introduce <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> instance methods
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, passing the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> field value to the corresponding
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> method, like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This approach works because we’ve chosen radians as the underlying unit for
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and we provide methods
    to convert to and from degrees. [Listing 1-33](#list1-33) shows how we would use
    these instance methods in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method. Compare this with [Listing 1-31](#list1-31), where we called <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>
    directly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-33: Invoking our
    new instance trigonometric methods</samp>'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Our second option is to provide our own static class mirroring the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    class with static <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods that take an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> rather than a plain
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> for their parameters.
    Each method would need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property because it would not have access to the private <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    field. While this approach follows a common convention established by the static
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> class, we lose the more
    compact usage of calling a member method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The third alternative is to define *extension methods*, which are used as if
    they’re instance methods but are defined in a separate static class. [Listing
    1-34](#list1-34) defines <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> extension methods
    to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>’s interface.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-34: Defining extension
    methods for Angle</samp>'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    methods in the static <samp class="SANS_TheSansMonoCd_W5Regular_11">AngleExtensions</samp>
    class use the special syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">this
    Angle</samp> for their parameter, which tells the compiler that the method is
    an extension for an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.
    Each method simply forwards the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property of the angle to its counterpart method in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    namespace. We use the extension methods in exactly the same way we called the
    instance method versions in [Listing 1-33](#list1-33).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of both the static and extension method implementations that is
    sometimes overlooked is that neither version depends on the internal representation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>. The instance member
    methods could also be implemented in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property, but by extracting methods into separate types if they don’t rely on
    the private implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>,
    we make the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    smaller and easier to comprehend. [Chapter 6](chapter6.xhtml) explores this topic
    in more detail.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Whichever approach we choose, we’ll encapsulate the explicit need to access
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.InRadians</samp> property
    in order to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    trigonometric methods, making it easy for anyone to use our <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    type.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Types Implied
    by Units</samp>
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Class factory methods such as those we’ve introduced for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> are a common way
    of simplifying the creation of value types. This technique is used by the Standard
    Library in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> type,
    which has methods such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FromSeconds</samp>
    paired with a <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    property. The methods encode the units in their names, so creating value instances
    is very direct:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When we initialize these variables, we’re being explicit about the expected
    type as well as the units, but a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">234.0kmh</samp>
    must be a speed. We can’t express this directly, but we can get close by using
    extension methods.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The value <samp class="SANS_TheSansMonoCd_W5Regular_11">234.0</samp> is a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and while we can’t change
    its built-in definition, we can create extension methods for the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type, as [Listing 1-35](#list1-35) shows.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-35: Extending the
    interface of double</samp>'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Each extension method returns a new instance of the type implied by the units
    in the method’s name, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">Kmh</samp>
    method returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> created
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed.FromKmPerHour</samp>
    class factory method. We use the new extension methods for <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To avoid having to explicitly add the decimal point for the whole numbers,
    we could add overloads that extend <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    too. While this technique can be useful to allow a compact syntax for *literal*
    values, it works less well with variables like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However we choose to represent the units of measurement, they are a fundamental
    and intrinsic part of those types. Without units, a number is merely a number,
    even if the name of the type is descriptive. If we make the units of our value
    types easy to define and, just as importantly, make it easy to convert between
    common units, our custom value types will be easier to use and understand.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Fully Formed Encapsulated Value</samp>
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Long parameter lists are a hallmark of unclear code. They often indicate that
    a method doesn’t have one clear responsibility and so would benefit from being
    refactored. Some or all of the parameters may be related in some way, indicating
    a missing abstraction. In either case, reducing method parameter lists is another
    way to improve the clarity of our code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    used throughout this chapter does have a single, clear responsibility and has
    only three parameters. However, two of those parameters are related: a velocity
    is a combination of a speed and a direction. We’ve defined rich types to represent
    speeds and angles that we can now combine to represent velocity with its own type.
    [Listing 1-36](#list1-36) shows our new <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    struct.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-36: Defining an encapsulated
    Velocity type</samp>'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    no longer needs separate speed and angle values, because they’re now handled by
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Wrapping <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    has two related benefits. First, methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    that required two parameters to represent a velocity now need only one. Second,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> is a new abstraction
    to represent a distinct concept. We can give <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    its own specific set of behaviors and semantics and test the semantics independently
    of anything else.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Deciding Whether to Abstract Types</samp>
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Introducing a new type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    is not always the most appropriate approach. For example, consider the return
    value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With our discussion of using types to represent concepts, abstracting the tuple
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> values as a new
    type may seem attractive. But we should consider several factors, including how
    the values will be used, whether there’s any domain-specific behavior we want
    to associate with an independent type, and whether adding a new type will increase
    clarity or obscure it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: If a value is used in only a few places, creating a custom type to represent
    it may not be worthwhile, unless doing so will also reduce code duplication. If
    there’s behavior that we want to encapsulate, we’ll benefit from locating that
    behavior in one place and being able to test it in one place too.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Whether we can give a useful name to the new type is another important consideration.
    For example, the tuple of two <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    values is similar to a coordinate point, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values representing
    distance traveled in two dimensions from a point of origin. However, the name
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> would be misleading,
    because the elements of a coordinate are positions or points rather than distances.
    Now that we’ve created a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    type, however, we might consider revisiting the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    to try to resolve the design problems noted earlier when we introduced the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type. Our example doesn’t
    warrant the extra complexity that would involve, so instead, we’ll take a simpler
    approach.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In the value returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    the names of the tuple components are more important than giving a name to a new
    type. Rather than defining a completely new type to return from <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    we can take advantage of rich tuple support in C# v7.0 and onward to directly
    “unpack” the return value into named variables, as shown in [Listing 1-37](#list1-37).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-37: Unpacking tuple
    values</samp>'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: In this example we use *tuple deconstruction*, giving each member of the returned
    tuple value its own name. The compiler deduces the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">range</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">elevation</samp> variables from
    the values in the tuple, so in this example they’re both instances of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type. This has the advantages
    of being both compact and descriptive enough for many purposes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*We define abstraction as selective ignorance—concentrating on the ideas that
    are relevant to the task at hand, and ignoring everything else. [...] If abstractions
    are well designed and well chosen, we believe that we can use them even if we
    don’t understand all the details of how they work. We do not need to be automotive
    engineers to drive a car.*'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Andrew Koenig and Barbara Moo, *Accelerated C*++
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: C# provides a few primitive types, especially for numerical values, and it can
    be tempting to use them as they are. However, a method that just takes a long
    list of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> parameters
    can be difficult to decipher. This problem is not restricted to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>;
    methods with a long list of <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> parameters suffer
    from the same pitfalls, but the cure is broadly the same.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The built-in types are intended to be applicable to a wide range of problems
    and to be used as the building blocks for more sophisticated types. C# is, after
    all, an object-oriented language, and it allows us to model our problems with
    domain-specific types.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Replacing primitive values with our own types has several practical benefits.
    It can reduce accidental misuse and defects in the code by ensuring that arguments
    to methods are explicit. This allows us to take advantage of the compiler’s type
    checking. If we mistakenly transpose arguments, our code will fail to compile.
    This kind of early failure prevents those mistakes from causing problems at run
    time or, worse, making it into a live production system and causing us considerable
    embarrassment.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Creating even simple types also allows us to provide descriptive names that
    make our code more self-describing. In turn, this spares us from having to produce
    a lot of separate explanatory documentation, which has a tendency to become stale.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: By separating the behavior of a type from the algorithms that use it, and encapsulating
    that behavior in the type itself, we can test it independently of those algorithms.
    The type is more cohesive, and the algorithms are clearer and often simpler. Those
    algorithms themselves become easier for us to test, without having to also test
    the assumptions and implementations captured by the domain type abstractions.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
