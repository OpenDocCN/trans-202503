- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MAKING
    THE MOST OF THE TYPE SYSTEM</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">充分利用类型系统</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Clear and readable source code matters much more to humans than it does to computers.
    Whether we’re trying to debug existing code or learning to use a new feature,
    we inevitably find ourselves reading through source code. It’s important to ensure
    that our code is as readable as possible so that its meaning is clear to other
    readers. Code that’s hard to follow or easily misunderstood is a breeding ground
    for errors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰且易读的源代码对人类比对计算机更为重要。无论是调试现有代码还是学习使用新功能，我们不可避免地会阅读源代码。确保代码尽可能易读是很重要的，这样其他读者能清楚地理解它的含义。难以理解或容易被误解的代码是错误的温床。
- en: One way to improve the clarity of our code is to use the type system to our
    advantage by creating our own types and giving them names that clearly describe
    their purpose. Good names are important for all the types in a system, but it’s
    easy to neglect the simple value types that represent an application’s most granular
    information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 改善代码清晰度的一种方式是通过创建我们自己的类型并赋予它们明确描述其目的的名称，从而充分利用类型系统。良好的命名对于系统中的所有类型都至关重要，但我们很容易忽视那些表示应用程序最细粒度信息的简单值类型。
- en: In this chapter, we’ll examine a short but unclear piece of code and improve
    it over several iterations through a series of techniques that will help you learn
    how to use the type system effectively. By the end of the chapter, you’ll have
    a better understanding of how custom value types contribute to easy-to-understand
    code and how to incorporate a rich set of types into your designs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一段简短但不清晰的代码，并通过多次迭代改进它，采用一系列技巧，帮助你学习如何有效地使用类型系统。到本章结束时，你将更好地理解自定义值类型如何为易于理解的代码做出贡献，并学会如何将丰富的类型集成到你的设计中。
- en: 'We’ll explore the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下内容：
- en: How custom types can help express meaning and make code more self-documenting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过自定义类型来表达意义，并使代码更具自文档性
- en: How to encapsulate domain-specific behavior to reduce errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何封装特定领域的行为以减少错误
- en: Where to use some syntax features from C# v9.0 and v10.0 for compact and readable
    code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 C# v9.0 和 v10.0 中的一些语法特性，使代码更加简洁且易读
- en: How to make using custom types easy and natural in commonplace code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在日常代码中轻松自然地使用自定义类型
- en: To begin, let’s look at a simple example of value types in action and why they’re
    such an important feature of our designs
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一个简单的值类型示例，了解它们为什么是我们设计中如此重要的特性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Value of Good Names</samp>
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">良好命名的重要性</samp>
- en: Choosing good names for identifiers can be difficult but has a major impact
    on the clarity of our code. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method in [Listing 1-1](#list1-1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 选择好的标识符名称可能很困难，但对代码的清晰度有着重大影响。考虑一下[清单 1-1](#list1-1)中的<sampt class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>方法。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: An example of
    bad variable naming</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-1：一个糟糕变量命名的示例</samp>
- en: The method’s three parameters—<samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>—are
    poorly named, and their purpose isn’t immediately clear. We’ll use this code throughout
    the chapter to explore a variety of ways to improve it and better define its intent.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的三个参数——<samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>——命名不佳，且它们的目的并不立即明确。我们将在本章中通过多次改进，利用各种方法来提升代码的质量，明确其意图。
- en: The purpose of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method is to calculate the position of a projectile on its ballistic arc, given
    an initial angle and velocity, and the time elapsed since the projectile was launched.
    If you’re familiar with the equations for projectile motion, you may recognize
    the algorithm, but the variable names provide no clue whatsoever to their purpose.
    When called, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method calculates the coordinate value of the projectile relative to its launch
    point, as illustrated in [Figure 1-1](#fig1-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">位移</samp>方法的目的是计算给定初始角度和速度以及自投射物发射以来所经过的时间后，投射物在其弹道弧线上的位置。如果你熟悉抛物线运动的方程式，你可能会认出这个算法，但变量名完全无法透露它们的目的。当调用时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">位移</samp>方法会计算投射物相对于发射点的坐标值，如[图1-1](#fig1-1)所示。
- en: '![](../images/Figure1-1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-1.png)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1:</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Projectile
    displacement</samp>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-1：</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">投射物位移</samp>
- en: The angle, initial speed, and time labels in [Figure 1-1](#fig1-1) correspond
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> parameters for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, respectively. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    values correspond to the components of the tuple returned by that method. The
    projectile is launched with an initial speed, at a particular angle, and follows
    a well-defined ballistic arc. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method calculates the projectile’s position on that arc after a given amount of
    time has passed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-1](#fig1-1)中的角度、初速度和时间标签分别对应<`samp` class="SANS_TheSansMonoCd_W5Regular_11">t</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">v</samp>和<`samp` class="SANS_TheSansMonoCd_W5Regular_11">s</samp>这些参数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<`samp` class="SANS_TheSansMonoCd_W5Regular_11">y</samp>值对应于该方法返回的元组的分量。投射物以初速度和特定角度发射，并遵循一个明确的弹道弧线。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">位移</samp>方法计算投射物在经过一段时间后在该弧线上的位置。'
- en: We won’t go into the algorithm being used here, as our focus is merely on making
    the purpose of this method more immediately clear. The first barrier to our understanding
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    is the meaning of its parameters and return value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这里使用的算法，因为我们的重点仅仅是让这个方法的目的更加直观易懂。我们理解<`samp` class="SANS_TheSansMonoCd_W5Regular_11">位移</samp>方法的第一个障碍是它的参数和返回值的含义。
- en: I have deliberately exaggerated the issue with single-letter names, but I’ve
    seen similar examples in the real world and thought, *What on earth do those parameters
    represent?* Even if we carefully inspect how the parameters have been used, determining
    their meaning requires being familiar with the equations. That is just poor code
    craft. Not all of us have kept up with our ballistics studies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意夸大了单字母名称的问题，但在现实中我见过类似的例子，想过，*这些参数到底代表什么？* 即使我们仔细检查这些参数的使用方式，想要理解它们的含义，仍然需要熟悉方程式。这真的是很糟糕的代码风格。并不是所有人都还记得自己的弹道学学习。
- en: We want to make it as easy as possible for the reader to determine the purpose
    of the method, whether they’re familiar with the topic or not. The quickest way
    to accomplish this is to ensure that the parameter names better reflect what they
    represent. In particular, code should avoid relying on specialist jargon. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> here stands for *theta*,
    which is typically used in physics to represent the magnitude of an angle, but
    even if we replaced <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> with
    the full word <samp class="SANS_TheSansMonoCd_W5Regular_11">theta</samp>, readers
    unfamiliar with this mathematical convention would be unlikely to make that connection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望让读者尽可能容易地判断方法的目的，无论他们是否熟悉该主题。实现这一目标的最快方法是确保参数名称更好地反映它们所代表的内容。特别是，代码应避免依赖专业术语。这里的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> 代表 *theta*，通常用于物理学中表示角度的大小，但即使我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> 替换为完整的单词 <samp class="SANS_TheSansMonoCd_W5Regular_11">theta</samp>，那些不熟悉这个数学约定的读者也不太可能理解这个联系。
- en: 'Instead of using potentially obscure single-letter names, let’s give the parameters
    names that properly signify their meaning:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用可能不清楚的单字母名称，不如为参数起个正确表示其含义的名称：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By renaming <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> as <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">angle</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">elapsedTime</samp>, we’ve made
    their purpose clearer. Changing velocity to speed might seem a minor change, but
    the names we use *matter*. While the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    for *velocity* is common, <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    is a more accurate description of this value’s purpose. *Velocity* is a technical
    term with a specific meaning in physics; it represents *both* magnitude (speed)
    and direction. If we name code elements as accurately and properly as we can,
    we reduce the risk of those names being misunderstood.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> 重命名为 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">angle</samp>，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> 重命名为 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">speed</samp>，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> 重命名为 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">elapsedTime</samp>，我们使它们的目的更加明确。将速度改为速度看似是一个小变化，但我们使用的名称*很重要*。虽然
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> 用于表示*速度*很常见，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    更准确地描述了该值的目的。*Velocity* 是物理学中具有特定含义的术语；它代表*大小*（速度）和方向。我们尽可能准确、恰当地命名代码元素，可以减少这些名称被误解的风险。
- en: Selecting good names is a first step toward making code clearer and easier to
    read. However, we can do much more to improve our code’s clarity and remove ambiguity
    about what those identifiers represent. We might reasonably ask, for example,
    in what units the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    parameters are measured. We’ll address that later in the chapter, but first we
    need a more sophisticated mechanism than the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type allows.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的名称是使代码更清晰、易于阅读的第一步。然而，我们可以做得更多，以提高代码的清晰度，并消除关于这些标识符所代表内容的歧义。例如，我们可能会合理地问，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> 这些参数是以什么单位来衡量的。我们将在本章稍后讨论这个问题，但首先我们需要比
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型更复杂的机制。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding Clarity Through Types</samp>
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">通过类型添加清晰性</samp>
- en: 'All the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method’s
    parameters are of the same type: <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    This makes it easy for anyone, including ourselves, to accidentally mix up argument
    values when calling the method—without any warning from the compiler.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 方法的参数都是相同的类型：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。这使得任何人，包括我们自己，在调用方法时很容易不小心混淆参数值——编译器不会发出任何警告。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type itself
    is not the specific culprit here; we’d have the same problem if the parameters
    were all <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> or all <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> types. Even if each parameter
    were of a different built-in numeric type, plenty of potential for problems would
    still remain because of the presence of the implicit promotion rules between them.
    Moreover, clarifying the parameter names doesn’t necessarily help the calling
    code, especially if the method is called with plain constant values like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型本身并不是这里的罪魁祸首；如果参数全是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 或全是 <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    类型，我们也会遇到同样的问题。即使每个参数都是不同的内置数值类型，由于它们之间存在隐式提升规则，仍然存在很多潜在的问题。此外，明确参数名称不一定有助于调用代码，尤其是当方法被传入像这样纯常量值时：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Hard-coded values such as those used in this example are called *magic numbers*
    because there’s no explanation of their meaning or purpose. We could replace the
    magic numbers with better-named variables to make their purpose clearer, but the
    caller of the method might still supply the arguments in the wrong order.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 像这个例子中使用的硬编码值被称为 *魔法数字*，因为它们的意义或目的没有解释。我们可以用更具描述性的变量替换魔法数字，以使它们的目的更加明确，但方法的调用者仍然可能以错误的顺序传递参数。
- en: One common way for the calling code to address such out-of-order errors is to
    specify the parameter name for each argument. Let’s see that in practice before
    looking at how to use different types to distinguish between the argument values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码处理这种顺序错误的一个常见方法是为每个参数指定参数名称。在我们查看如何使用不同类型来区分参数值之前，先来看看这个方法在实践中的应用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Named Arguments</samp>
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">命名参数</samp>
- en: 'Embedding the parameter name for each argument being passed to a method makes
    the purpose of those arguments much more visible in the calling code, as shown
    here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个传递给方法的参数嵌入参数名称，可以使这些参数的目的在调用代码中更加清晰，正如这里所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method specifies which parameter receives each value being supplied. The caller
    must match the parameter names of the method but can order them in any way they
    like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 方法的调用指定了每个传入的值对应哪个参数。调用者必须匹配方法的参数名称，但可以按任何他们喜欢的顺序排列这些参数：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Naming the arguments makes the order in which they’re passed irrelevant. The
    compiler will ensure that each argument value gets passed to the right parameter
    according to its name, not its position.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数使得传递参数的顺序变得不再重要。编译器将确保每个参数值根据其名称而不是位置传递到正确的参数中。
- en: This technique puts the responsibility of clarity onto the *caller* of the method.
    If the caller forgets or doesn’t bother to name the arguments, the compiler won’t
    warn them. The compiler will also give no warning if the caller mixes up the value
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>.
    The code will compile, and the program will run, but it will almost certainly
    give incorrect results. Worse, the code might give a result that is almost correct
    for one specific set of arguments and then fail at the worst possible moment when
    different values are passed. The causes of errors like this can be difficult to
    track down.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技巧将清晰性的责任转移给了方法的*调用者*。如果调用者忘记或懒得命名参数，编译器不会警告他们。如果调用者将 <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> 的值搞混，编译器也不会发出警告。代码会编译并运行，但几乎肯定会给出错误的结果。更糟糕的是，代码可能会对一组特定的参数给出几乎正确的结果，然后在传入不同值时，最糟糕的时刻发生故障。这类错误的原因可能很难追踪。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Custom Types</samp>
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">自定义类型</samp>
- en: The problems we’re seeing with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method stem from using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type to represent several distinct concepts. This is a variation of the *Primitive
    Obsession* code smell, which describes any code that has an overreliance on primitive
    types—that is, those types that are built into the language, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 方法中遇到的问题，源于使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型来表示几个不同的概念。这是 *原始迷恋*（Primitive
    Obsession）代码异味的一种变体，描述的是任何过度依赖原始类型的代码——即那些语言内置的类型，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>。
- en: Measurements and quantities such as speed commonly have numerical representations,
    but the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type is too
    general; it can be used to represent a wide variety of values, including <samp
    class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    in our example, making it possible for the caller of the code to provide the wrong
    values. The <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> quantities are measured in
    different ways to mean different things. Using a raw <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    does not express the distinctions between them clearly enough. An angle of 45
    degrees is a very different value from a speed of 45 meters per second.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如速度等测量和量度通常具有数值表示，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型过于通用；它可以用来表示各种各样的值，包括我们示例中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">角度</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">速度</samp>，这使得代码调用者可能提供错误的值。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">角度</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">速度</samp>
    是以不同的方式来度量，代表不同的意义。使用原始的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    并不能清晰地表达它们之间的区别。45度的角度与每秒45米的速度是非常不同的两个值。
- en: The well-known solution to primitive obsession is to provide our own types with
    distinct purposes and to ensure that no implicit conversions exist between them.
    This enables the compiler to identify any arguments that are used inappropriately.
    Instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to
    store quantities of <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, [Listing 1-2](#list1-2)
    defines two types that more positively convey their differences.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 解决原始迷恋（Primitive Obsession）问题的著名方法是为我们的自定义类型赋予明确的目的，并确保它们之间不存在隐式转换。这使得编译器能够识别任何不恰当地使用的参数。与其使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 来存储 <samp class="SANS_TheSansMonoCd_W5Regular_11">角度</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">速度</samp> 的值，[Listing 1-2](#list1-2)
    定义了两个类型，更清楚地传达它们的区别。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-2: Defining our own
    types</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-2：定义我们自己的类型</samp>
- en: 'Our user-defined structs <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> are still quite
    primitive; they’re merely wrappers around a public property (<samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>, respectively)
    that allows us to read or write the value being represented in each case. We’ll
    improve this design, but for now it meets the immediate need: to distinguish values
    of angle from values of speed by their type rather than just by the parameter
    names.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义的结构体 <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 仍然相当原始；它们仅仅是对公共属性（分别是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>）的封装，允许我们读取或写入每个表示的值。我们将改进这个设计，但现在它能满足当前的需求：通过类型而非仅仅通过参数名称来区分角度值和速度值。
- en: '[Listing 1-3](#list1-3) demonstrates how we use these new types for the parameters
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 1-3](#list1-3) 演示了我们如何使用这些新类型作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    方法的参数。'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-3: Using custom types
    as parameters</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-3：使用自定义类型作为参数</samp>
- en: The C# Standard Library does not provide any abstractions for angles or speeds,
    but it does have the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    type, which is ideal for the <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    parameter. Now the *type* of each parameter describes its value, so the parameter
    names have less responsibility. Any attempt to provide the arguments in the incorrect
    order, like substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>, will cause the
    compiler to complain with a fairly obvious error message about not being able
    to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: C# 标准库没有提供关于角度或速度的抽象，但它提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    类型，非常适合用于 <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> 参数。现在，每个参数的*类型*描述了其值，因此参数名称的责任减少了。任何试图以错误的顺序提供参数，比如将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> 替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>，都会导致编译器报错，并显示一个非常明显的错误信息，提示无法将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encapsulation</samp>
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">封装</samp>
- en: Using distinct types for the values in a design emphasizes each value’s role
    rather than its representation, making the code more self-documenting for human
    readers and allowing better error checking by the compiler. We’ve achieved our
    stated goal of preventing arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    from being positioned incorrectly, but right now <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> are simple types
    that just *have* a value, rather than *being* a particular kind of value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计中使用不同的类型来表示值，强调了每个值的作用，而不是它的表现形式，这使得代码对人类读者更加自文档化，并允许编译器进行更好的错误检查。我们已经达成了防止
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 参数顺序错误的目标，但目前
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    仍然是简单类型，它们*拥有*一个值，而不是*作为*某种特定类型的值。
- en: These types do not encapsulate their values in any way because their values
    are exposed as the publicly mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> properties. Those
    properties are currently the only way to create instances of those types, as we
    do in [Listing 1-4](#list1-4), where we use object initialization to set the property
    values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型并没有以任何方式封装它们的值，因为它们的值作为公开可变的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> 属性暴露出来。目前，这些属性是创建这些类型实例的唯一方式，正如我们在
    [清单 1-4](#list1-4) 中所做的那样，我们使用对象初始化来设置属性值。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-4: Using object initialization
    to create inline argument instances</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-4：使用对象初始化来创建内联参数实例</samp>
- en: Using the public properties to set the values here is unnecessarily verbose.
    [Listing 1-5](#list1-5) simplifies the syntax by adding constructors so we can
    create new instances directly with a value instead of having to set a public property.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用公共属性来设置值显得不必要的冗长。[清单 1-5](#list1-5) 通过添加构造函数简化了语法，使我们可以直接用一个值来创建新的实例，而无需设置公共属性。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-5: Adding constructors
    for Speed and Angle</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-5：为 Speed 和 Angle 添加构造函数</samp>
- en: Here, when we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    we construct the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances with their
    values instead of setting their properties ❶. Now that the type names are more
    descriptive, the order of the arguments is not ambiguous, so naming the arguments
    is no longer so important.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    时，我们通过它们的值构造 <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 实例，而不是设置它们的属性 ❶。现在类型名称更加描述性，参数的顺序不再模糊，因此命名参数的重要性不再那么大。
- en: These constructors use the *expression body syntax*, introduced for methods
    in C# v6.0 and available since C# v7.0 for constructors. With this syntax, instead
    of a block enclosed by braces <samp class="SANS_TheSansMonoCd_W5Regular_11">{…}</samp>,
    the expression is a single assignment separated from the constructor’s signature
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">=></samp> symbol. Since <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    each have only a single property to initialize, the expression-bodied constructors
    are concise and convenient.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构造函数使用了*C# v6.0引入的表达式主体语法*，该语法自C# v7.0以来适用于构造函数。使用这种语法时，表达式不是用花括号<samp class="SANS_TheSansMonoCd_W5Regular_11">{…}</samp>括起来的代码块，而是一个单一的赋值表达式，且与构造函数签名通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=></samp>符号分隔。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>每个只有一个属性需要初始化，因此表达式主体构造函数简洁且方便。
- en: Compare the final line with [Listing 1-4](#list1-4). The changes to <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in [Listing 1-5](#list1-5)
    allow us to construct the values we want instead of using the object initializer
    in each case. This reduces the amount of typing the caller has to do but, more
    importantly, expresses more directly that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> *is* a value instead
    of just *having* a value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将最后一行与[清单 1-4](#list1-4)进行比较。在[清单 1-5](#list1-5)中对<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的更改，使我们能够构造所需的值，而不是在每个情况下使用对象初始化器。这减少了调用者需要输入的代码量，但更重要的是，它更直接地表达了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>*是*一个值，而不仅仅是*拥有*一个值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Immutability</samp>
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">不可变性</samp>
- en: Currently, our values are all mutable, but once we’ve given an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> a value in its constructor,
    we don’t need to allow that value to change. If we require an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    with a different value, we can create a new instance with that value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的值都是可变的，但一旦我们在构造函数中给<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>赋予一个值，就不需要允许该值再发生变化。如果我们需要一个具有不同值的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>，我们可以创建一个新的实例来表示这个值。
- en: We achieve this immutability by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> property
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> to make it a read-only
    property. Then the only way to provide a value is via the constructor, and that
    value is permanent and immutable. We’ll do the same for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, as shown
    in [Listing 1-6](#list1-6).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过移除<samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>访问器来实现这种不可变性，使得<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>的<samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>属性变为只读属性。然后，提供值的唯一方式是通过构造函数，并且该值是永久且不可变的。我们将对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的<samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>属性做同样的处理，如[清单
    1-6](#list1-6)所示。
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-6: Making Speed immutable</samp>'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-6：使 Speed 不可变</samp>
- en: To ensure that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance can’t change, we also make it <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>.
    The compiler will then ensure that no members of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    can modify the state and will fail to compile any attempt to change an instance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>实例无法更改，我们还将其设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>。这样，编译器将确保<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的成员不能修改状态，并且任何尝试更改实例的操作都会导致编译失败。
- en: Designing our types to be immutable makes our code easier to reason about during
    code inspection because we don’t need to consider the various ways that instances
    of our type might change. This is especially important in multithreaded programs,
    but making value types read-only can also improve performance in some circumstances
    by enabling the compiler to use certain optimizations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设计类型为不可变使得在代码检查时更容易推理代码，因为我们不需要考虑类型实例可能发生变化的各种方式。这在多线程程序中特别重要，但在某些情况下，通过使值类型只读，也可以通过让编译器使用某些优化来提高性能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Validation</samp>
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">值验证</samp>
- en: Having introduced constructors for our types, we can use those constructors
    to check for invalid arguments and raise exceptions if the user passes illegal
    values. For example, sensible values for a speed must be nonnegative. In [Listing
    1-7](#list1-7), we check that the value given the constructor is not less than
    0 and throw an exception if it is.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了类型的构造函数后，我们可以使用这些构造函数来检查无效参数，并在用户传入非法值时抛出异常。例如，速度的合理值必须是非负的。在[列表 1-7](#list1-7)中，我们检查传给构造函数的值是否小于
    0，如果是，则抛出异常。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-7: Prohibiting out-of-range
    values</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 1-7：禁止超范围值</samp>
- en: The constructor of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    validates the value provided, and since the constructor is the only way to provide
    a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, we ensure
    that only legal <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values
    can be created. We should use the constructor to prohibit other illegal argument
    values, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp>,
    and perhaps even add an upper limit of the speed of light. If we attempt to create
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> with an illegal value,
    we get a run-time exception.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的构造函数验证了提供的值，并且由于构造函数是唯一提供
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 值的方式，我们确保只能创建合法的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 值。我们应该使用构造函数来禁止其他非法的参数值，例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double.NaN</samp>，并且也许还可以添加一个光速的上限。如果我们尝试创建一个带有非法值的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>，我们将得到一个运行时异常。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp>
    type is defined in the Standard Library and is a good example of a descriptively
    named type. Note that in [Listing 1-7](#list1-7), we name the arguments for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp>
    constructor, *which takes two plain* <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">string</samp>
    *parameters* (<samp class="SANS_TheSansMonoCd_W5Regular_11">paramName:</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">message:</samp>). Otherwise,
    the order of those arguments is easily muddled, especially since the similarly
    named <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentException</samp> takes
    the same parameters in the reverse order!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp>
    类型在标准库中定义，是一个命名非常具描述性的类型的良好示例。注意，在[列表 1-7](#list1-7)中，我们为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRangeException</samp>
    构造函数命名了参数，*它接受两个普通的* <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">string</samp>
    *参数*（<samp class="SANS_TheSansMonoCd_W5Regular_11">paramName:</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">message:</samp>）。否则，这些参数的顺序容易混淆，特别是由于同名的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ArgumentException</samp> 将相同的参数顺序颠倒了！
- en: 'Validating the parameter value in <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor is one example of encapsulation: we’ve put the validation logic in
    one place instead of scattering it among any methods that use it. Now, any methods
    that use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance
    automatically benefit from the range check performed by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 构造函数中验证参数值是封装的一个示例：我们将验证逻辑集中在一个地方，而不是将其分散到任何使用它的方法中。现在，任何使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 实例的方法都会自动受益于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 构造函数执行的范围检查。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*A major benefit of creating our own types is that we encapsulate their responsibilities,
    thereby reducing the responsibilities of the methods that use them. Minimizing
    duplicated code is yet another way we make our code clearer, easier to use, and
    much less difficult to maintain.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建我们自己的类型的一个主要好处是，我们将它们的责任封装起来，从而减少了使用它们的方法的责任。最小化重复代码是我们让代码更清晰、更易用、更容易维护的另一种方式。*'
- en: The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    establishes a *class invariant*—a condition that must hold for the lifetime of
    any instance of the type—specifying that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value is never less than 0\. The invariant can never be broken because we made
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> immutable. Once a valid
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance is created,
    its value never changes, and it’s impossible to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with an invalid value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的构造函数建立了一个 *类不变量*——即在类型的任何实例的生命周期内都必须满足的条件——指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的值永远不小于 0。由于我们使 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 不可变，这个不变量永远不会被打破。一旦创建了一个有效的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 实例，其值永远不会改变，而且不可能创建一个具有无效值的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 实例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing</samp>
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">测试</samp>
- en: By encapsulating the validation within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type, we can also test the class invariant independently of any algorithms that
    depend on it. In [Listing 1-8](#list1-8), we attempt to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with a negative value to test that the constructor throws an exception.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将验证封装在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 类型中，我们也可以独立于任何依赖它的算法来测试类的不变量。在
    [列表 1-8](#list1-8) 中，我们尝试创建一个具有负值的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    实例，以测试构造函数是否会抛出异常。
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-8: Testing constraints
    on Speed</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 1-8：测试速度的约束条件</samp>
- en: Because the validation code is encapsulated within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type, we need only this one test for it. We don’t need to separately test that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>, or any other
    method using <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, rejects
    invalid speed values. All the testing for <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    can focus on ensuring that the algorithm is correct, without being concerned about
    parameter validation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因为验证代码被封装在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 类型中，我们只需要对它进行这一项测试。我们不需要单独测试
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>，或者任何其他使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的方法，是否会拒绝无效的速度值。所有关于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 的测试都可以专注于确保算法的正确性，而不必担心参数验证。
- en: Using types for domain concepts, then, has several advantages. Code using our
    types is clearer because of the self-describing characteristics of the type. We
    separate concerns, making the program easier to understand and the testing more
    focused and specific. This makes the tests simpler, and easier to maintain when
    the code being tested needs to change.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型表示领域概念有几个优势。因此，使用我们自己类型的代码更加清晰，因为类型具有自描述的特性。我们分离了关注点，使得程序更易于理解，测试更聚焦和具体。这使得测试更简单，当被测试的代码需要更改时，也更容易维护。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Refactoring</samp>
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">重构</samp>
- en: Now that we’ve addressed the issues with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method’s parameters, let’s look at its method body to see if we can make further
    improvements by refactoring the implementation. [Listing 1-9](#list1-9) shows
    our current code for <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经解决了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    方法参数的问题，接下来让我们看一下它的方法体，看看是否可以通过重构实现进一步改进。[列表 1-9](#list1-9) 显示了我们当前的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    代码。
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-9: The current Displacement
    implementation</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 1-9：当前位移实现</samp>
- en: This code works correctly, but we have some issues to take care of. We’ve made
    the code more verbose by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    types as parameters, requiring us to access properties of those parameters to
    obtain their values. Note that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    property here; one common error is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> object
    when the intention is to obtain the total number of seconds being represented,
    but <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp> returns only
    the seconds component of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>.
    Given a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> representing
    1 minute precisely, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp>
    property would return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    while the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    would be <samp class="SANS_TheSansMonoCd_W5Regular_11">60</samp>.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以正常工作，但我们有一些问题需要处理。由于我们使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    类型作为参数，我们需要访问这些参数的属性才能获取它们的值，导致代码变得更加冗长。请注意，我们在这里使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    属性；一个常见的错误是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> 对象的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp> 属性，然而其目的是获取总秒数，但
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp> 只返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    的秒部分。如果给定一个表示 1 分钟的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>，那么
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Seconds</samp> 属性将返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp> 的值将为 <samp class="SANS_TheSansMonoCd_W5Regular_11">60</samp>。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    would be clearer if we could use the variables *directly* in the algorithm, like
    this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够直接在算法中使用变量，像这样，<samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    方法将更加清晰：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The algorithm also relies on three hard-coded values. Magic numbers like this
    often indicate that we need to provide names to clarify their purpose. It’s common
    to find the same magic number used in more than one place, so if the value changed
    for any reason, we’d need to hunt for every use and make sure we updated them
    all.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法还依赖于三个硬编码值。像这样的“魔法数字”通常意味着我们需要为它们提供名称来澄清它们的目的。通常会在多个地方使用相同的魔法数字，所以如果值发生变化，我们需要查找每个使用该值的地方，并确保更新所有相关部分。
- en: While we can see that multiplying by <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>
    is the same as dividing by <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    the meaning of <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp> is much
    less obvious. The value <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> used in the call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Pow</samp> are simply arithmetic
    values; giving them names might obscure their purpose rather than clarifying it.
    The value <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>, on the other
    hand, stands out as having a more significant purpose. Once again, to understand
    the meaning of this number, we need prior knowledge that <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>
    is an approximation of the effects of Earth’s gravity on an object. We’ll address
    this issue first with the simple fix of naming this value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以看到将 <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> 相乘与除以 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp> 是等效的，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>
    的含义就不那么明显了。<samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> 和用于调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Pow</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    只是算术值；给它们命名可能会掩盖它们的用途，而不是澄清它们的含义。另一方面，<samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>
    的值则显得更为重要。要理解这个数字的含义，我们需要知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>
    是地球引力对物体作用的近似值。我们首先通过简单地为这个值命名来解决这个问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Magic Numbers
    with Named Constants</samp>
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">用命名常量替换魔法数字</samp>
- en: Replacing magic numbers in code with a descriptive name clarifies their meaning
    to readers unfamiliar with the algorithm’s details. One way to do this is to create
    a new value type, similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    to represent the measurement. However, when we need only a few well-known values,
    using named constants to represent them is often simpler. For now, we need only
    a single value (for Earth’s gravity). [Listing 1-10](#list1-10) shows one way
    we could indicate that value’s purpose by giving it a meaningful name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用描述性的名称替换代码中的魔法数字，可以帮助读者理解它们的含义，尤其是对于那些不熟悉算法细节的人。实现这一点的一种方法是创建一个新的值类型，类似于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>，来表示度量。然而，当我们只需要一些众所周知的值时，使用命名常量来表示它们通常更简单。现在，我们只需要一个值（地球的重力）。[清单
    1-10](#list1-10) 显示了一种方法，我们可以通过给它赋予有意义的名称来指明该值的用途。
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-10: Simple encoding
    of magic numbers</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-10：魔法数字的简单编码</samp>
- en: While the named constant for gravity is the simplest replacement for the magic
    number, we’re passing up an opportunity to benefit from a more general type named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Acceleration</samp> or something
    similar. Doing so would give us the greatest flexibility but would also increase
    complexity and maintenance. Keeping code simple has its own benefits.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管重力的命名常量是替换魔法数字的最简单方法，但我们错过了一个机会，即使用更通用的类型（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">Acceleration</samp>）或类似类型。这样做可以为我们提供最大的灵活性，但也会增加复杂性和维护难度。保持代码简单有它自己的好处。
- en: 'We should, however, keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    values like this are baked into our code by the compiler, so if we change the
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">Gravity.Earth</samp> but
    compile against a prebuilt assembly that uses the same constant, the overall program
    could use two different values for the same constant. In the interests of brevity
    and simplicity, we’ll keep the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    value and replace the hard-coded number in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Gravity.Earth</samp> constant
    so human readers know immediately what it means:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该记住，像 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 这样的值是由编译器内嵌到代码中的，因此如果我们更改了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Gravity.Earth</samp> 的值，但仍然编译针对一个使用相同常量的预构建程序集，那么整个程序可能会使用该常量的两个不同值。为了简洁和简单，我们将保持
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 值，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    中的硬编码数字替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Gravity.Earth</samp>
    常量，这样读者可以立即知道它的含义：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now if we want to use a more precise approximation of gravity, we only need
    to change the constant’s value instead of searching for all uses of the magic
    number <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>, with the caveat
    that we must remember to recompile any other modules that use that constant.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想使用更精确的重力近似值，我们只需要改变常量的值，而不必去查找所有使用魔法数字 <samp class="SANS_TheSansMonoCd_W5Regular_11">9.81</samp>
    的地方，但需要注意的是，我们必须记得重新编译任何其他使用该常量的模块。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simplifying Properties
    and Values</samp>
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">简化属性和值</samp>
- en: Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    is now much more explicit about the meanings of the variables it uses. [Listing
    1-11](#list1-11) shows its current implementation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 方法现在更明确地说明了它使用的变量的含义。[清单
    1-11](#list1-11) 显示了它的当前实现。
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-11: Displacement
    using explicit property access</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-11：使用显式属性访问的 Displacement</samp>
- en: As noted earlier, accessing the properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    makes the implementation quite verbose. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method would be tidier and easier still to read if we could access these properties
    directly in the operations where they were used. The <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    variable’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property
    is being multiplied by <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    ❶, and <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp> is used
    to call both <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> ❷ and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> ❸. Each use of our
    types requires us to explicitly obtain the corresponding property value in order
    to multiply two values together, and to pass them as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> 的属性使得实现变得相当冗长。如果我们能够在使用这些属性的操作中直接访问它们，那么
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 方法会更加简洁，且更易读。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> 变量的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    属性被与 <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    相乘 ❶，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp> 被用于调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> ❷ 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>
    ❸。每次使用我们的类型时，我们都需要显式地获取对应的属性值，以便将两个值相乘，并将它们作为参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> 方法。
- en: We can’t change the behavior of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    variable to allow it to be multiplied by a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> can be multiplied
    by a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> value. If we
    could use <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances
    as if they were <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values,
    we would avoid having to explicitly use their properties in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    making the method less cluttered; that is, we would be able to multiply <samp
    class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    without using the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed.Amount</samp>
    property. Likewise, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    type, we could call methods such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, which both
    expect a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> argument,
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp> variable directly
    if we could treat <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> instances
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能改变 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> 变量的行为，使其能够与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 相乘，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    可以与 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 值相乘。如果我们能够像使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 值一样使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    实例，我们就可以避免在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    中显式地使用它们的属性，从而使方法更加简洁；也就是说，我们可以在不使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">speed.Amount</samp>
    属性的情况下相乘 <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>。同样，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 类型时，我们可以直接调用像 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>
    这样的函数，它们都期望传入一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 参数，前提是我们能够像使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 值一样直接使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>
    变量。
- en: The result of the whole expression would be a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>,
    which is the result type from multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    by a number, so we’d need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    property at some point. Still, removing the need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> properties of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    would simplify and shorten the method’s implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 整个表达式的结果将是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>，这是将一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> 乘以一个数字后的结果类型，因此我们需要在某个时刻访问
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp> 属性。不过，移除对 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> 属性的访问，将简化并缩短该方法的实现。
- en: One way to achieve that outcome is by defining our own implicit conversion operators.
    This approach is superficially appealing because it is simple to implement, but
    it has several drawbacks. Let’s examine some of those potential problems.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一结果的一种方法是定义我们自己的隐式转换运算符。这个方法表面上看起来很有吸引力，因为它简单易实现，但也有几个缺点。让我们来看看这些潜在的问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implicit Conversions</samp>
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">隐式转换</samp>
- en: We define an implicit conversion for our own types by implementing an implicit
    conversion operator method and specifying the target type we need, as shown for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in [Listing 1-12](#list1-12).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现隐式转换运算符方法并指定所需的目标类型，来为我们自己的类型定义隐式转换，如 [Listing 1-12](#list1-12) 中为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 所示。
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-12: Defining an implicit
    conversion for Speed</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-12：为 Speed 定义隐式转换</samp>
- en: The target type here is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    and we simply return the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property. We also add a similar conversion operator for <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    (not shown here) that returns its <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    property. Now we no longer need to explicitly use <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp>
    when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, and we can multiply
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> by the <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    value without needing to get the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed.Amount</samp>
    property. Compare [Listing 1-13](#list1-13) with the earlier version in [Listing
    1-11](#list1-11).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，我们只需要返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> 属性的值。我们还为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    添加了类似的转换运算符（这里没有显示），它返回其 <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    属性。现在，我们不再需要在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> 时显式使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp>，并且我们可以直接将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> 乘以 <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    的值，而无需获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">speed.Amount</samp> 属性。请对比
    [Listing 1-13](#list1-13) 与之前的 [Listing 1-11](#list1-11)。
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-13: Using implicit
    conversions</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-13：使用隐式转换</samp>
- en: Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    is now much more compact—but we’ve introduced some hidden problems.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 实现要紧凑得多，但我们也引入了一些隐藏的问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Unexpected Interactions</samp>
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">意外的相互作用</samp>
- en: Implicit conversions weaken the interface to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> by allowing them
    to participate everywhere that a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    might be used, which means they can be used in expressions where it’s not appropriate.
    For example, dividing a speed by an angle would be a legal expression, as demonstrated
    in [Listing 1-14](#list1-14).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换通过允许 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 在任何可能使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    的地方参与，削弱了它们的接口，这意味着它们可以在不合适的表达式中被使用。例如，将速度除以角度是一个合法的表达式，正如 [Listing 1-14](#list1-14)
    所示。
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-14: Unplanned behavior
    resulting from an implicit conversion</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-14: 隐式转换导致的未预期行为</samp>'
- en: This expression is valid owing to the implicit conversions from both <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    but the result is meaningless, and we get no warning from the compiler. In addition,
    implicit conversions are usually invisible in our code. If we pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value to <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> instead
    of an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, the resulting
    calculation errors could be hard to find.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式是合法的，因为存在从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    的隐式转换，但结果没有意义，而且编译器没有发出警告。此外，隐式转换通常在代码中是不可见的。如果我们将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    值传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>，那么计算错误可能会很难发现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Discarded Invariants</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">丢弃的恒定值</samp>
- en: One of the benefits we realized by introducing a custom type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    was that we could encapsulate validation logic in <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 引入自定义类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 后，我们意识到的一个好处是可以在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的构造函数中封装验证逻辑。
- en: Allowing the implicit conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> means that code
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> result can
    breach the constraints on the allowable range of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    In [Listing 1-15](#list1-15), we subtract one <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from another smaller value, leaving us with a result that’s less than 0.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 允许将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 隐式转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    意味着使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 结果的代码可能会违反对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 可接受范围的约束。在 [Listing
    1-15](#list1-15) 中，我们将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    从另一个较小的值中减去，得到的结果小于 0。
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-15: Unchecked constraints
    resulting from an implicit conversion</samp>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-15: 隐式转换导致的未检查约束</samp>'
- en: This subtraction expression, which is between two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values as a result of the implicit conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, will run just
    fine. The result is negative and thus out of range for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but it’s a perfectly legal <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个减法表达式，因隐式转换将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，而两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    值之间的运算可以正常执行。结果为负数，因此对于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    来说超出了范围，但它是一个完全合法的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    值。
- en: To address this out-of-range value, we need to restrict the permitted operations
    on <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    so they make sense for those measurements. This was the whole purpose of introducing
    a class invariant for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to ensure that instances of it always have a valid value. Furthermore, we want
    to prohibit operations that make no sense, ideally in a way that would allow the
    compiler to tell us when something is wrong.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个越界值问题，我们需要限制对<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>的允许操作，以确保它们对于这些测量值是合理的。这也是引入<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>类不变式的整个目的，确保其实例始终具有有效的值。此外，我们希望禁止那些没有意义的操作，理想情况下能让编译器在出现问题时提醒我们。
- en: We introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> as specific types so
    that we could tell them apart, and because using a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    was simply too general to represent those measurements. However, the implicit
    conversions make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> indistinguishable from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>作为特定类型引入，以便区分它们，并且使用普通的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>类型显然过于笼统，无法代表这些测量值。然而，隐式转换使得<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>变得难以区分。
- en: We can still achieve our objective of making our types easy to use in arithmetic
    expressions, but we need to keep control over which operations those types can
    perform. We’ll allow specific operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> without sacrificing
    their natural usage or compromising the encapsulation of the types.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以实现使我们的类型在算术表达式中易于使用的目标，但我们需要控制这些类型可以执行哪些操作。我们将允许对<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>进行特定操作，同时不牺牲它们的自然用法或破坏类型的封装性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overloading Arithmetic
    Operators</samp>
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">重载算术运算符</samp>
- en: 'Our initial motivation for introducing implicit conversions for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    was to support the multiplication operation between a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp> property
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> value. Currently,
    we must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> to make that calculation,
    as shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入隐式转换的初衷是为了支持<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>值的<samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>属性之间的乘法运算。目前，我们必须使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的<samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>属性来进行此计算，如下所示：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Arithmetic operations such as <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    for multiplication are predefined for the built-in numeric types like <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    We can define the meaning of these symbols for our own types by providing arithmetic
    operator overloads.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 像<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>这样的算术运算（乘法）已经为内建的数字类型（如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>）预定义了。我们可以通过提供算术运算符重载，为我们自己的类型定义这些符号的意义。
- en: '[Listing 1-16](#list1-16) shows the multiplication operator overload for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-16](#list1-16)显示了<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的乘法运算符重载。'
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-16: Supporting multiplication
    in Speed</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-16：在 Speed 中支持乘法</samp>
- en: We use a target-typed <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    expression, introduced in C# v9.0, to create the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>
    to return. The compiler knows that the expected type is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    as it’s being directly returned, so we don’t need to explicitly specify the type
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">new Speed(…)</samp>. The compiler
    will infer the type according to the value expected by the left side of the expression.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 C# v9.0 中引入的目标类型的 <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    表达式来创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp> 返回的值。编译器知道期望的类型是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>，因为它被直接返回，因此我们不需要显式地指定类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">new Speed(…)</samp>。编译器会根据表达式左侧期望的值推断类型。
- en: Being able to multiply a speed value by a number makes intuitive sense; something
    might be traveling at double the speed of something else, for example. We implement
    the operator by creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from the product of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property and the value passed to the operator’s parameter. The constructor for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> will check that the
    result is within the allowed range of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and will throw an exception if the result is out of range. We can demonstrate
    that this works with a simple test, such as [Listing 1-17](#list1-17), where we
    attempt to multiply a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a negative number.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将速度值与一个数字相乘是直观的；例如，某物的速度可能是另一物的两倍。我们通过从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    属性与传递给运算符参数的值的乘积创建一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    来实现该运算符。<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的构造函数会检查结果是否在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的允许范围内，如果结果超出范围，则抛出异常。我们可以通过一个简单的测试来证明这一点，例如
    [Listing 1-17](#list1-17)，在该测试中，我们尝试将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    与一个负数相乘。
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-17: Testing the multiplication
    operator</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-17: 测试乘法运算符</samp>'
- en: We create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and then
    verify that when we try multiplying it by <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>,
    the constructor throws an exception. We also ensure that when we halve the value,
    the operation succeeds with the expected result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>，然后验证当我们尝试将其乘以
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> 时，构造函数会抛出异常。我们还确保在将值减半时，操作能够成功，并得到预期结果。
- en: We can define operator overloads for other arithmetic operations and specify
    precisely the expressions in which <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is permitted to take part. Values commonly overload arithmetic operators, where
    it is appropriate to do so.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为其他算术运算定义运算符重载，并精确指定允许参与运算的表达式，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    是允许参与的。值通常会重载算术运算符，适当的时候可以这样做。
- en: Not all values are arithmetic in nature, so we need to carefully consider whether
    to support those operations for a type. For example, creating our own value type
    to represent a UK postal code would be perfectly natural, but multiplying a postal
    code by a number or by another postal code makes no sense whatsoever, because
    postal codes are not arithmetic values. Examples of other nonarithmetic values
    include US ZIP codes and colors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的值都是算术性质的，因此我们需要仔细考虑是否支持某个类型的这些运算。例如，创建我们自己的值类型来表示英国邮政编码是完全自然的，但将邮政编码与数字或另一个邮政编码相乘则毫无意义，因为邮政编码不是算术值。其他非算术值的示例包括美国邮政编码和颜色。
- en: By contrast, <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values
    should naturally take part in some, but not all, arithmetic expressions. It makes
    sense to be able to double a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but not to multiply two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values together. We can use custom arithmetic operator overloads to control which
    expressions should be permitted, and by adding explicit support for them, we make
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> easier to use.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 值应该自然地参与某些，但不是所有的算术表达式。将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 乘以 2 是有意义的，但将两个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 值相乘则没有意义。我们可以使用自定义的算术运算符重载来控制哪些表达式应该被允许，通过明确支持它们，使得
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 更容易使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining a Need
    for New Types</samp>
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">确定需要新类型</samp>
- en: Whenever we refactor a piece of code, we may discover a requirement or opportunity
    to introduce a new type. The need for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types was fairly
    plain because we introduced them to replace primitive parameter variables. Not
    all missing abstractions are so obvious.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们重构一段代码时，可能会发现引入新类型的需求或机会。<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 类型的需求比较明显，因为我们引入它们是为了替代原始的参数变量。并不是所有缺失的抽象都是如此显而易见。
- en: 'If we multiply a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a number, the result is a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    but our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    multiplies a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp> value, which
    is not simply a number. Here we split that calculation into separate parts to
    make it clearer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 乘以一个数字，结果是一个新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>，但我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    方法将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 乘以 <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime</samp>
    值，而后者不仅仅是一个数字。这里我们将计算拆分成多个部分，以便更清晰地理解：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As noted earlier, multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a number intuitively produces a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    Both <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    here are therefore instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    because of our implementation of the multiplication operator, but note that the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    value is not just any number but rather a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    instance representing a *time*. Mathematically, the result of this expression
    is not a speed at all: multiplying a speed by a time produces a *distance*, which
    we can represent directly in our code by introducing a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    type, as shown in [Listing 1-18](#list1-18).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 乘以一个数字直观地会产生一个新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 都是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    的实例，这是因为我们实现了乘法运算符，但请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">elapsedTime.TotalSeconds</samp>
    值不仅仅是一个数字，而是一个表示 *时间* 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    实例。从数学角度看，这个表达式的结果根本不是速度：将速度与时间相乘会产生一个 *距离*，我们可以通过引入一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    类型在代码中直接表示这一点，如 [Listing 1-18](#list1-18) 所示。
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-18: The Distance
    type</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-18: 距离类型</samp>'
- en: We can now create a new overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> that multiplies
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> directly by a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> and produces a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
    Even better, we can define this overload in addition to the multiplication operator
    we’ve already defined that takes a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and returns a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    [Listing 1-19](#list1-19) shows both operator overloads.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 创建一个新的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp> 重载，直接将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    乘以 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> 并生成一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>。更棒的是，我们可以在我们已经定义的运算符之外，定义这个重载，这样它就能处理一个普通的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 并返回一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>。
    [清单 1-19](#list1-19) 展示了这两个运算符重载。
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-19: Overloading operator*</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-19：重载运算符 * </samp>
- en: Overloading is versatile. We can overload a method with different types of parameters,
    and each overload can return a different type. The rules for overloading consider
    only the method signature—that is, the number and types of the parameters. We
    can therefore return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from the overload taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> from
    the method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    instance.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重载是非常灵活的。我们可以使用不同类型的参数重载一个方法，并且每个重载可以返回不同的类型。重载规则仅考虑方法签名——即参数的数量和类型。因此，我们可以从接受
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 的重载中返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>，并从接受
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> 实例的方法中返回一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Refining the New Type</samp>
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">完善新类型</samp>
- en: Next, we need to add behavior to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    type so that it will work correctly in our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    implementation. Multiplying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> gives us a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> value, which we
    use in further arithmetic expressions of its own, shown in [Listing 1-20](#list1-20).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> 类型添加行为，使其在我们的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 实现中能够正确工作。将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 乘以 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    会得到一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> 值，我们可以在后续的算术表达式中使用它，如
    [清单 1-20](#list1-20) 所示。
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-20: The Distance
    type in use</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-20：正在使用的 Distance 类型</samp>
- en: The expressions for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are both now multiplying
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> value by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values returned from <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>.
    This code will fail to compile because <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    needs its own overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    的表达式都在将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> 值乘以从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>
    返回的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 值。这段代码将无法编译，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> 需要有自己的 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator*</samp>
    重载。
- en: As with <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values, multiplying
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> by a simple number
    produces a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
    The results of <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>, apart from being
    out of our control, are scalar values, so when we multiply them by a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>,
    the result is another <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 值类似，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    乘以一个简单的数字会产生一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>
    的结果，除了不受我们控制外，都是标量值，因此当我们将它们与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    相乘时，结果仍然是另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> also requires
    an overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator-</samp>
    so that the subtraction operation used in the calculation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    value will compile. As with the multiplication, the expression on the right of
    the subtraction gives a scalar value, so we add the multiplication and subtraction
    operators for <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> in
    [Listing 1-21](#list1-21).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> 还需要重载 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator-</samp>，以便计算
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 值时使用的减法操作能够编译。与乘法运算类似，减法右侧的表达式给出的是一个标量值，因此我们在
    [清单 1-21](#list1-21) 中为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    添加了乘法和减法运算符。
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-21: Arithmetic operations
    for Distance values</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-21：距离值的算术运算</samp>
- en: With these overloads, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> values naturally
    together to produce <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    values. Those values, in turn, work seamlessly with the other required expressions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些重载，我们可以自然地将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> 值结合起来，以生成 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> 值。这些值反过来又能与其他所需的表达式无缝配合。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Design Imperfection</samp>
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">处理设计缺陷</samp>
- en: 'Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    returns a tuple of two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values. However, with our changes, the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values being returned
    have become instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    rather than plain <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values. This introduces another terminology problem with respect to the return
    value: in physics, a distance, like a speed, is always either 0 or a positive
    value. Combining a distance with the result of a trigonometric function like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> is a coordinate position, rather
    than a distance, and can be negative.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 方法返回一个包含两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 值的元组。然而，通过我们的改动，返回的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    值已经变成了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> 的实例，而不是普通的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 值。这引入了另一个关于返回值的术语问题：在物理学中，像速度一样，距离总是为
    0 或正值。将一个距离与三角函数的结果（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp>）结合时，得到的是一个坐标位置，而非距离，可能是负值。
- en: We identified the <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    type from the result of multiplying a speed by a time, but there is no straightforward
    way to distinguish the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> from a plain
    number like <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>, denying
    us the opportunity to add an overload of the multiplication operator in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> to return a new type,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>, rather
    than another <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>. We
    have reached the limits of exploiting the types we have chosen for modeling real-world
    concepts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: An obstacle like this may be the symptom of a deeper design smell, an indication
    that the problem might be resolved by a change in design perspective. In this
    instance, we may be able to achieve a more complete solution by reworking <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>’s algorithm in terms
    of a full-fledged <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    type instead of the relatively primitive <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types. Exploring
    that solution is fairly complex, however, and best left to a text dedicated to
    modeling physics problems, leaving us with a pragmatic decision to make.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: One option is to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>
    type, or something similar, to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>.
    This approach suffers from the drawback that the arithmetic operations we defined
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> do not apply
    so naturally to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>.
    Moreover, if <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> is
    useful elsewhere in an application, it makes complete sense that when we multiply
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>,
    the result is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>,
    not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Position</samp>.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to do nothing and permit <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    to have negative values in the context of our application. While <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    would then be an imperfect representation of its counterpart in physics, this
    approach benefits from simple and natural uses in other areas. In [Listing 1-22](#list1-22),
    we change the return type of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> values directly,
    which further simplifies the implementation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是不做任何改动，允许 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    在我们的应用程序中拥有负值。虽然在这种情况下 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    可能无法完美地表示其在物理学中的对应物，但这种方法在其他领域的使用简单自然。在[列表 1-22](#list1-22)中，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    的返回类型更改为直接使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> 值，从而进一步简化了实现。
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-22 The new Displacement
    method</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 1-22 新的位移方法</samp>
- en: We could have retained the existing return type by returning the <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables. For example, if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> is already widely
    used, altering the type it returns might be intrusive. Nonetheless, introducing
    the richer <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type
    more widely in an application has benefits similar to replacing the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    parameters in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> types.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以保留现有的返回类型，通过返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 变量的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    属性。例如，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 已经被广泛使用，那么更改其返回类型可能会带来干扰。尽管如此，在应用程序中更广泛地引入更丰富的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> 类型，类似于将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 参数替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>
    类型，也具有其好处。
- en: However we decide to best serve the requirements of the application and its
    users, we can make more pressing improvements to the types used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>.
    We’re still explicitly using <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    when we call methods in the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    static class. Before we attempt to address that, we need to think carefully about
    which units of measurement each type represents.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何决定最好地满足应用程序及其用户的需求，我们都可以对 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    类型做出更紧迫的改进。当我们在调用标准的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    静态类的方法时，我们仍然显式使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.Size</samp>。在我们尝试解决这个问题之前，我们需要仔细思考每个类型代表的计量单位。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encoding Units</samp>
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">编码单位</samp>
- en: Measurements like speeds, angles, and distances can have multiple representations,
    according to the units we’re using for them. As our code stands, our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    types do not make those units clear. For example, is speed in meters per second
    or miles per hour? Are the angles measured in degrees or radians? Using the wrong
    unit of measurement can introduce errors that are particularly hard to diagnose.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 测量值如速度、角度和距离可以有多种表示方式，这取决于我们使用的单位。根据目前的代码，我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    类型并没有明确表示这些单位。例如，速度是以米每秒还是英里每小时为单位？角度是以度还是弧度为单位？使用错误的计量单位可能会引入很难诊断的错误。
- en: All the equations used in <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    assume that speed is measured in meters per second. This is a reasonable default,
    because meters per second is the universal International System of Units (SI)
    unit of speed, but it is implied. If we used a value for speed in kilometers per
    hour, we’d certainly get unexpected results.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> 中使用的所有方程都假设速度以米每秒为单位。这是一个合理的默认值，因为米每秒是国际单位制（SI）中速度的标准单位，但它是隐含的。如果我们使用公里每小时作为速度单位，肯定会得到意料之外的结果。
- en: Similarly, we don’t currently specify the units for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    type. Code that deals with trigonometry commonly uses radians as the unit of measurement,
    and all the trigonometric functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    class, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>, expect
    angle values in radians. Most people, however, think of angles in degrees, and
    confusing the two is a common source of error.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们目前没有为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 类型指定单位。处理三角函数的代码通常使用弧度作为度量单位，且
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> 类中的所有三角函数（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>）都期望角度值为弧度。然而，大多数人习惯将角度视为度数，将两者混淆是常见的错误来源。
- en: 'This exposes the issue of usability: should our code require units that are
    more convenient for their implementation or more intuitive for the user? Let’s
    consider this question and investigate whether it’s possible to achieve both aims
    simultaneously.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这暴露了可用性的问题：我们的代码应该要求单位更方便实现，还是更直观易懂呢？让我们来考虑这个问题，看看是否有可能同时实现这两个目标。
- en: C# has several features we can use to encode units, and one common approach
    is to represent the different units by using an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>.
    At first glance, this might seem the obvious solution, but it can cause issues.
    We’ll explore this option and then investigate an alternative solution using static
    methods to create our types with the required units.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: C# 有多个功能可以用来编码单位，其中一种常见的方法是通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    来表示不同的单位。乍一看，这似乎是显而易见的解决方案，但它可能会导致一些问题。我们将探讨这个选项，并进一步研究使用静态方法创建具有所需单位的类型的替代解决方案。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Itemizing Units with
    enums</samp>
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用枚举列出单位</samp>
- en: An *enumerated type*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>,
    is a set of related strongly typed constants. Using an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    allows us to specify all the units our type supports. [Listing 1-23](#list1-23)
    modifies our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type to
    use an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> to account for
    units.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举类型*，或 <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>，是一组相关的强类型常量。使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> 允许我们指定我们的类型支持的所有单位。[示例
    1-23](#list1-23) 修改了我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    类型，以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> 来考虑单位。'
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-23: Specifying units
    for Speed by using an enum</samp>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 1-23：通过使用枚举指定 Speed 的单位</samp>
- en: In this code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Units</samp>
    enumeration is a public type nested within <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    telling us that a speed can be represented in meters per second, kilometers per
    second, or kilometers per hour.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，<samp class="SANS_TheSansMonoCd_W5Regular_11">Units</samp> 枚举是一个公共类型，嵌套在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 内，告诉我们速度可以用米每秒、千米每秒或千米每小时表示。
- en: '> <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '> <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>'
- en: '*While it’s tempting to abbreviate all the names, shortening MetersPerSecond
    to Ms might be confused with* milliseconds*, so it’s best to spell out the unit
    in this case.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然缩写所有名称很有诱惑力，但将 MetersPerSecond 缩写为 Ms 可能会与*毫秒*（milliseconds）混淆，所以最好在这种情况下写出单位全名。*'
- en: The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    takes a number for the magnitude, and the user must provide one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    values for the required units. The user can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>
    property later to discover which units were used when a particular <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance was created. By supporting several units of measurement, we make <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> more generally useful in
    other applications.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的构造函数接受一个数字作为大小，用户必须提供一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> 值来指定所需单位。用户可以稍后使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">In</samp> 属性来了解某个特定 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    实例在创建时使用的单位。通过支持多种测量单位，我们使得 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    在其他应用中更加通用。
- en: Representing supported units with an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    is superficially appealing because it seems simple to implement. However, this
    approach suffers from drawbacks that become apparent when we need to decide how
    to handle two values that have different units.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> 表示支持的单位看起来很有吸引力，因为它似乎简单易实现。然而，这种方法存在缺点，尤其是在我们需要决定如何处理具有不同单位的两个值时，这些问题变得显而易见。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value Comparisons and Unit
    Conversions</samp>
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">值比较与单位转换</samp>
- en: 'We need to consider conversions between units in several places in our <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> implementation. For instance,
    these two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values use
    different units but nevertheless represent the same speed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的实现中考虑多个地方的单位转换。例如，这两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 值使用不同的单位，但它们实际上表示相同的速度：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> variables
    do not compare equal by default, because their <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> properties have different
    values. We can address that problem by customizing the behavior of equality comparisons
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, perhaps by converting
    both values to meters per second and comparing those values for equality. However,
    we have other, more subtle problems to solve too.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 变量默认情况下不会相等，因为它们的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>
    属性有不同的值。我们可以通过自定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的相等性比较行为来解决这个问题，也许可以通过将两个值都转换为米/秒并比较这些值的相等性来实现。但我们还有其他更微妙的问题需要解决。
- en: Earlier, we added operator overloads to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to support multiplying them by a scalar value or a time. Adding support for other
    arithmetic operations, including adding two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>s,
    would be reasonable. We’d have to convert both values to a common unit in order
    to add them together, but what unit should the result be in?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 添加了运算符重载，支持将其与标量值或时间相乘。为其他算术操作（包括将两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 相加）添加支持是合理的。我们需要将两个值转换为一个共同的单位，以便相加，但结果应该使用什么单位呢？
- en: One option would be to always scale every <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value to meters per second—as we do in [Listing 1-24](#list1-24) by using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor to convert
    the parameter value according to the required units—but this approach introduces
    different problems.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是总是将每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 值缩放到每秒米（米/秒），就像我们在
    [Listing 1-24](#list1-24) 中所做的那样，通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    的构造函数根据所需单位转换参数值，但这种方法也会引入不同的问题。
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-24: Scaling to a
    common value</samp>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-24: 缩放到共同的值</samp>'
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property is
    assigned the value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression, available as of C# v8.0, which uses the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>
    parameter value to scale the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    value to meters per second. The final <samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>
    selector in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> is
    an example of a discard pattern and is used if the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>
    doesn’t match any of the previous types. Here, we throw an exception in these
    circumstances, which might occur if we updated the <samp class="SANS_TheSansMonoCd_W5Regular_11">Units
    enum</samp> with a new element without updating the constructor.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个<samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>属性被分配为一个<samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>表达式的值，该表达式从C#
    v8.0开始可用，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>参数值的类型来缩放<samp
    class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>值到米每秒。<samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>中的最终<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_</samp>选择器是丢弃模式的示例，只有当<samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>类型与之前的类型不匹配时才会使用。在这种情况下，如果我们更新了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Units enum</samp>并且没有更新构造函数，则会抛出异常。
- en: Note that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>
    parameter only to determine how to scale the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    parameter. The units are not stored, so there’s no <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>
    property either, because a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is always reported in meters per second.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">unit</samp>参数仅用于确定如何缩放<samp
    class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>参数。单位不会被存储，因此也没有<samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>属性，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>总是以米每秒为单位报告。
- en: Storing all instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    using the same units solves the problem of equality comparisons and arithmetic
    operations, but it has other drawbacks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同单位存储所有<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>实例解决了相等比较和算术运算的问题，但它也有其他缺点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Limitations of Using enums
    for Units</samp>
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用枚举表示单位的局限性</samp>
- en: 'Being able to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instances using various units is one thing, but users of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type will also likely expect to be able to obtain the value in different units.
    The necessary conversions are straightforward to implement: [Listing 1-25](#list1-25)
    repurposes <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp> as a method
    to convert from the internal meters per second value to the units required.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用不同单位创建<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>实例是一回事，但<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>类型的用户也可能期望能够以不同的单位获取值。必要的转换很容易实现：[清单
    1-25](#list1-25)将<samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>重新用作方法，将内部的米每秒值转换为所需的单位。
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-25: Obtaining converted
    values</samp>'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 1-25：获取转换后的值</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expressions,
    like those in [Listings 1-24](#list1-24) and [1-25](#list1-25), are a characteristic
    of code that uses enumerations to distinguish different types. Those conversions
    can be cumbersome and would be a maintenance headache if we added new units.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>表达式，如[清单 1-24](#list1-24)和[1-25](#list1-25)中的那些，是使用枚举区分不同类型的代码的特征。如果我们添加了新的单位，这些转换可能会变得繁琐，且会给维护带来麻烦。
- en: 'Always converting <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values to meters per second in the constructor presents an additional problem:
    the amount used to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is altered when we use units other than <samp class="SANS_TheSansMonoCd_W5Regular_11">MetersPerSecond</samp>.
    To demonstrate the issue, consider [Listing 1-26](#list1-26), where we copy a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value by using its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp> property and the same
    units used to create the original.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-26: Testing equality
    of copied values</samp>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Most people would expect this test to pass, but it fails because <samp class="SANS_TheSansMonoCd_W5Regular_11">original.Amount</samp>
    was converted to meters per second by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor. The solution is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">In</samp>
    method to make the copy, like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Converting all <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values
    to the common unit of meters per second simplifies the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, but it’s less convenient
    for users wishing to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values measured in a different unit.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, although representing <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    values in radians is convenient when we need to use an angle in a trigonometric
    method, it’s much less convenient for users. As mentioned earlier, most humans
    naturally think of angles in degrees rather than radians, and while the conversion
    is relatively simple, it’s not part of the Standard Library.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore still need to bridge the gap between what’s intuitive for a user
    and what our code uses internally. Next, we look at an alternative approach to
    enumerations: using static methods that make our types convenient for humans to
    use and also work seamlessly with standard methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp>.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Creation Methods</samp>
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of using a constructor with an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    parameter to represent units, we can employ the *Class Factory Method* pattern,
    which replaces public constructors with static methods to simplify creating instances.
    These methods have names that reflect the units they represent instead of requiring
    a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> value to
    identify those units.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type, we use
    the class factory methods in [Listing 1-27](#list1-27) to convert the input value
    to the units used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    internally, and return a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with that converted value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-27: Using class factory
    methods to encode units</samp>'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have three separate ways to create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    each returning a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value
    converted from the units indicated by the name of the method. When we require
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance, we
    use the method representing the units we want, as demonstrated in [Listing 1-28](#list1-28).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-28: Creating Speed
    values with our new class factory methods</samp>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Now there’s no need for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    constructor to be public. If we allow our users to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instances directly with <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>,
    they’ll bypass the class factory methods and lose the benefits of the conversions.
    To avoid that, in [Listing 1-29](#list1-29) we make the constructor private.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-29: Making our Speed
    constructor private</samp>'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The constructor still contains the validation logic, but now it can be called
    only by our class factory methods, with the argument suitably scaled to meters
    per second. We can’t prevent instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from being default-initialized, but that results in the value being <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    a value that is the same regardless of the units. Note that this is not always
    true, so we need to be alert for cases where this does *not* hold. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> degrees Celsius is not
    the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> degrees Fahrenheit
    for temperature.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Symmetry in Design</samp>
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our class factory methods allow us to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values from values measured in different units, the internal representation of
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value is in meters
    per second. To improve usability, we need to provide corresponding conversions
    in the other direction, so users of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    can choose the units they want when they obtain the value. In [Listing 1-30](#list1-30),
    we add properties to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    from its internal value to the unit encoded in the name of the property.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-30: Viewing Speed
    in different units</samp>'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduce a private data member that can be used from each of these properties.
    Doing so avoids *property forwarding* (one property invoking another to obtain
    the needed value) but also allows us to use an expression body for all three properties.
    This is largely an aesthetic choice; the most obvious alternative employing property
    forwarding is shown here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Whichever approach we choose, we have, in effect, renamed the vague <samp class="SANS_TheSansMonoCd_W5Regular_11">Amount</samp>
    property as <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>,
    whose purpose is to return the internal value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    The new name better expresses the property’s meaning, matches the naming convention
    used for the other properties, and mirrors the class factory method <samp class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp>.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: By using similar naming conventions for the <samp class="SANS_TheSansMonoCd_W5Regular_11">From…</samp>
    methods and the <samp class="SANS_TheSansMonoCd_W5Regular_11">In…</samp> properties,
    we improve the clarity of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    interface. When we see a method such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmPerHour</samp>,
    we naturally expect a corresponding method or property that provides the reverse
    conversion.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The class factory methods and corresponding properties provide a compact way
    of expressing units in either direction, and they force us to consciously make
    clear what we mean when we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Units Explicit</samp>
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    does not directly use the units of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    because they are encapsulated in the multiplication operator we created for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp>.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> *does* use the
    units of an angle, although those units are currently implied in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.Size</samp>
    property, as shown in [Listing 1-31](#list1-31).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-31: Angles in Displacement</samp>'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> require a measurement
    of an angle in radians, the SI unit for measuring angles. In [Listing 1-32](#list1-32),
    we rename the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> property
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> to make the
    units explicit, and add the conversions to and from degrees as well.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-32: Adding unit conversions
    to Angle</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    we’ve added class factory methods to create an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    in either degrees or radians, with corresponding properties to obtain the value
    in either unit. Now we can use an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    easily with methods that require a value in radians, and using <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    is also much more convenient for users, who tend to think in degrees.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Choosing the Most
    Natural Usage</samp>
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math.Sin</samp> methods take a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    argument, so we need to explicitly access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.InRadians</samp>
    property to call those methods. We can’t change the parameter type of those methods
    because they’re part of the Standard Library, but we can add similarly named methods
    to the interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>,
    which would allow us to encapsulate the explicit need to express the units. We
    can take three main approaches, each with its advantages and drawbacks, and each
    implemented by forwarding an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    value in radians to its counterpart static <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> static class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The most direct approach is to introduce <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> instance methods
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, passing the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> field value to the corresponding
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> method, like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This approach works because we’ve chosen radians as the underlying unit for
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and we provide methods
    to convert to and from degrees. [Listing 1-33](#list1-33) shows how we would use
    these instance methods in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method. Compare this with [Listing 1-31](#list1-31), where we called <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Cos</samp>
    directly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-33: Invoking our
    new instance trigonometric methods</samp>'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Our second option is to provide our own static class mirroring the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    class with static <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> methods that take an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> rather than a plain
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> for their parameters.
    Each method would need to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property because it would not have access to the private <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    field. While this approach follows a common convention established by the static
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> class, we lose the more
    compact usage of calling a member method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The third alternative is to define *extension methods*, which are used as if
    they’re instance methods but are defined in a separate static class. [Listing
    1-34](#list1-34) defines <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> extension methods
    to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>’s interface.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-34: Defining extension
    methods for Angle</samp>'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp>
    methods in the static <samp class="SANS_TheSansMonoCd_W5Regular_11">AngleExtensions</samp>
    class use the special syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">this
    Angle</samp> for their parameter, which tells the compiler that the method is
    an extension for an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.
    Each method simply forwards the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property of the angle to its counterpart method in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    namespace. We use the extension methods in exactly the same way we called the
    instance method versions in [Listing 1-33](#list1-33).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of both the static and extension method implementations that is
    sometimes overlooked is that neither version depends on the internal representation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>. The instance member
    methods could also be implemented in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property, but by extracting methods into separate types if they don’t rely on
    the private implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>,
    we make the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    smaller and easier to comprehend. [Chapter 6](chapter6.xhtml) explores this topic
    in more detail.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Whichever approach we choose, we’ll encapsulate the explicit need to access
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle.InRadians</samp> property
    in order to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp>
    trigonometric methods, making it easy for anyone to use our <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    type.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Types Implied
    by Units</samp>
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Class factory methods such as those we’ve introduced for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> are a common way
    of simplifying the creation of value types. This technique is used by the Standard
    Library in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeSpan</samp> type,
    which has methods such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FromSeconds</samp>
    paired with a <samp class="SANS_TheSansMonoCd_W5Regular_11">TotalSeconds</samp>
    property. The methods encode the units in their names, so creating value instances
    is very direct:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When we initialize these variables, we’re being explicit about the expected
    type as well as the units, but a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">234.0kmh</samp>
    must be a speed. We can’t express this directly, but we can get close by using
    extension methods.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The value <samp class="SANS_TheSansMonoCd_W5Regular_11">234.0</samp> is a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and while we can’t change
    its built-in definition, we can create extension methods for the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type, as [Listing 1-35](#list1-35) shows.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-35: Extending the
    interface of double</samp>'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Each extension method returns a new instance of the type implied by the units
    in the method’s name, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">Kmh</samp>
    method returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> created
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed.FromKmPerHour</samp>
    class factory method. We use the new extension methods for <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To avoid having to explicitly add the decimal point for the whole numbers,
    we could add overloads that extend <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    too. While this technique can be useful to allow a compact syntax for *literal*
    values, it works less well with variables like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However we choose to represent the units of measurement, they are a fundamental
    and intrinsic part of those types. Without units, a number is merely a number,
    even if the name of the type is descriptive. If we make the units of our value
    types easy to define and, just as importantly, make it easy to convert between
    common units, our custom value types will be easier to use and understand.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Fully Formed Encapsulated Value</samp>
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Long parameter lists are a hallmark of unclear code. They often indicate that
    a method doesn’t have one clear responsibility and so would benefit from being
    refactored. Some or all of the parameters may be related in some way, indicating
    a missing abstraction. In either case, reducing method parameter lists is another
    way to improve the clarity of our code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    used throughout this chapter does have a single, clear responsibility and has
    only three parameters. However, two of those parameters are related: a velocity
    is a combination of a speed and a direction. We’ve defined rich types to represent
    speeds and angles that we can now combine to represent velocity with its own type.
    [Listing 1-36](#list1-36) shows our new <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    struct.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-36: Defining an encapsulated
    Velocity type</samp>'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp> method
    no longer needs separate speed and angle values, because they’re now handled by
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Wrapping <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    has two related benefits. First, methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    that required two parameters to represent a velocity now need only one. Second,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> is a new abstraction
    to represent a distinct concept. We can give <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    its own specific set of behaviors and semantics and test the semantics independently
    of anything else.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Deciding Whether to Abstract Types</samp>
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Introducing a new type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    is not always the most appropriate approach. For example, consider the return
    value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With our discussion of using types to represent concepts, abstracting the tuple
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> values as a new
    type may seem attractive. But we should consider several factors, including how
    the values will be used, whether there’s any domain-specific behavior we want
    to associate with an independent type, and whether adding a new type will increase
    clarity or obscure it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: If a value is used in only a few places, creating a custom type to represent
    it may not be worthwhile, unless doing so will also reduce code duplication. If
    there’s behavior that we want to encapsulate, we’ll benefit from locating that
    behavior in one place and being able to test it in one place too.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Whether we can give a useful name to the new type is another important consideration.
    For example, the tuple of two <samp class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp>
    values is similar to a coordinate point, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values representing
    distance traveled in two dimensions from a point of origin. However, the name
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> would be misleading,
    because the elements of a coordinate are positions or points rather than distances.
    Now that we’ve created a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    type, however, we might consider revisiting the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>
    to try to resolve the design problems noted earlier when we introduced the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type. Our example doesn’t
    warrant the extra complexity that would involve, so instead, we’ll take a simpler
    approach.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In the value returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    the names of the tuple components are more important than giving a name to a new
    type. Rather than defining a completely new type to return from <samp class="SANS_TheSansMonoCd_W5Regular_11">Displacement</samp>,
    we can take advantage of rich tuple support in C# v7.0 and onward to directly
    “unpack” the return value into named variables, as shown in [Listing 1-37](#list1-37).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-37: Unpacking tuple
    values</samp>'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: In this example we use *tuple deconstruction*, giving each member of the returned
    tuple value its own name. The compiler deduces the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">range</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">elevation</samp> variables from
    the values in the tuple, so in this example they’re both instances of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Distance</samp> type. This has the advantages
    of being both compact and descriptive enough for many purposes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*We define abstraction as selective ignorance—concentrating on the ideas that
    are relevant to the task at hand, and ignoring everything else. [...] If abstractions
    are well designed and well chosen, we believe that we can use them even if we
    don’t understand all the details of how they work. We do not need to be automotive
    engineers to drive a car.*'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Andrew Koenig and Barbara Moo, *Accelerated C*++
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: C# provides a few primitive types, especially for numerical values, and it can
    be tempting to use them as they are. However, a method that just takes a long
    list of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> parameters
    can be difficult to decipher. This problem is not restricted to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>;
    methods with a long list of <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> parameters suffer
    from the same pitfalls, but the cure is broadly the same.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The built-in types are intended to be applicable to a wide range of problems
    and to be used as the building blocks for more sophisticated types. C# is, after
    all, an object-oriented language, and it allows us to model our problems with
    domain-specific types.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Replacing primitive values with our own types has several practical benefits.
    It can reduce accidental misuse and defects in the code by ensuring that arguments
    to methods are explicit. This allows us to take advantage of the compiler’s type
    checking. If we mistakenly transpose arguments, our code will fail to compile.
    This kind of early failure prevents those mistakes from causing problems at run
    time or, worse, making it into a live production system and causing us considerable
    embarrassment.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Creating even simple types also allows us to provide descriptive names that
    make our code more self-describing. In turn, this spares us from having to produce
    a lot of separate explanatory documentation, which has a tendency to become stale.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: By separating the behavior of a type from the algorithms that use it, and encapsulating
    that behavior in the type itself, we can test it independently of those algorithms.
    The type is more cohesive, and the algorithms are clearer and often simpler. Those
    algorithms themselves become easier for us to test, without having to also test
    the assumptions and implementations captured by the domain type abstractions.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
