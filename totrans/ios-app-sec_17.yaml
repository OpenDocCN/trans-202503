- en: '**13**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13**'
- en: '**ENCRYPTION AND AUTHENTICATION**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密与身份验证**'
- en: 'While Apple’s cryptographic APIs are fairly robust, many developers don’t know
    how to use them effectively. There are two major built-in encryption components
    that you have control over: the Keychain and the Data Protection API. These components
    share some of the same encryption keys and have similar protection attributes,
    and I’ll cover them in this chapter. I’ll also provide a look at lower-level crypto
    primitives and the (limited) circumstances in which you would want to use them.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管苹果的加密API相当强大，但许多开发者不知道如何有效使用它们。你可以控制两个主要的内建加密组件：钥匙串和数据保护API。这些组件共享一些相同的加密密钥，并具有类似的保护属性，本章将介绍它们。我还将探讨低级加密原语及其（有限的）使用场景。
- en: '**Using the Keychain**'
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用钥匙串**'
- en: 'The Keychain is meant to be used when you have small snippets of sensitive
    data to store, including passwords, personal data, and so on. The Keychain itself
    is encrypted using the Device Key, combined with a user passcode if available.
    The Keychain’s API consists of four main operations: `SecItemAdd`, `SecItemUpdate`,
    `SecItemCopyMatching`, and `SecItemDelete`. These operations add items to the
    Keychain, update existing items, retrieve items, and delete them from the Keychain,
    respectively.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 钥匙串用于存储少量敏感数据，包括密码、个人数据等。钥匙串本身使用设备密钥进行加密，并结合用户密码（如果有的话）。钥匙串的API包括四个主要操作：`SecItemAdd`、`SecItemUpdate`、`SecItemCopyMatching`和`SecItemDelete`。这些操作分别用于将项目添加到钥匙串、更新现有项目、检索项目和从钥匙串中删除项目。
- en: That said, I *really* wish I’d never see the GenericKeychain^([1](footnote.html#fn109))
    sample code again. Everyone seems to base their Keychain code on it (which is
    reasonable), but this code predates any of the modern Keychain protections that
    actually prevent secret data from being stolen off your device by a physical attacker.
    In this section, you’ll learn about those protections and how to take advantage
    of them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我*真的*希望我永远不再看到GenericKeychain^([1](footnote.html#fn109))示例代码。每个人似乎都将他们的钥匙串代码建立在这个基础上（这是合理的），但这段代码早于任何现代的钥匙串保护措施，这些保护措施实际上可以防止物理攻击者从你的设备上窃取机密数据。在本节中，你将了解这些保护措施以及如何利用它们。
- en: '***The Keychain in User Backups***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户备份中的钥匙串***'
- en: 'When users perform full backups of their devices, they have two security-related
    options: Unencrypted and Encrypted. *Unencrypted* backups can be restored only
    to the same device they were received from. *Encrypted* backups let the user select
    a passphrase to encrypt their backup data with. This allows the backup to be restored
    to any device (except for items marked with `ThisDeviceOnly`) and backs up the
    full contents of the Keychain as well. If you don’t want your Keychain item to
    be stored in backups, you can use the Keychain’s data protection attributes.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户执行设备的完整备份时，他们有两个与安全相关的选项：未加密和加密。*未加密*备份只能还原到其原始设备。*加密*备份允许用户选择一个密码来加密备份数据。这使得备份可以还原到任何设备（除了标记为`ThisDeviceOnly`的项目），并且会备份钥匙串的完整内容。如果不希望将钥匙串项目存储在备份中，可以使用钥匙串的数据保护属性。
- en: '***Keychain Protection Attributes***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***钥匙串保护属性***'
- en: '*Keychain protection attributes* specify when Keychain data is allowed to be
    stored in memory and requested by the OS or an application. When adding items
    such as passwords or personal data to the Keychain, it’s important to specify
    a protection attribute because this explicitly states when the data should be
    available. Not specifying a protection attribute should be considered a bug.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*钥匙串保护属性*指定何时可以将钥匙串数据存储在内存中，并由操作系统或应用程序请求。将密码或个人数据等项目添加到钥匙串时，指定保护属性非常重要，因为这明确说明了数据应该何时可用。未指定保护属性应视为一个错误。'
- en: Specify attributes when first storing an item in the Keychain by using the `SecItemAdd`
    method. You’ll need to pass in one of a predefined set of values (see [Table 13-1](ch13.html#ch13tab1))
    for `kSecAttrAccessible`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次将项目存储到钥匙串时，通过使用`SecItemAdd`方法来指定属性。你需要传递预定义值集中的一个（见[表13-1](ch13.html#ch13tab1)）作为`kSecAttrAccessible`的值。
- en: 'Three main types of access can be specified via this attribute:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过此属性指定三种主要的访问类型：
- en: '**Always accessible** The key is always available, regardless of whether the
    phone is locked.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终可访问** 无论手机是否锁定，密钥始终可用。'
- en: '**Accessible when unlocked** The key is accessible when the device is unlocked;
    otherwise, attempts to access it will fail.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**解锁时可访问** 当设备解锁时，密钥是可访问的；否则，访问尝试将失败。'
- en: '**Accessible after first unlocked** The key is accessible after the device
    has booted and been unlocked for the first time.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一次解锁后可访问** 密钥在设备启动并第一次解锁后可访问。'
- en: For each of the three main types of Keychain protection, there is an additional
    counterpart suffixed with `ThisDeviceOnly`. This means that the Key-chain item
    will not be backed up to iCloud, will be backed up to iTunes only if using encrypted
    backups, and cannot be restored onto another device.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三种主要的密钥链保护类型，每种类型都有一个额外的后缀为 `ThisDeviceOnly` 的对应项。这意味着密钥链项将不会备份到 iCloud，只会在使用加密备份时备份到
    iTunes，并且不能恢复到其他设备上。
- en: '**Table 13-1:** Keychain Protection Attributes and Their Associated Meanings'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-1：** 密钥链保护属性及其相关含义'
- en: '| **Keychain protection attribute** | **Meaning** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **密钥链保护属性** | **含义** |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `kSecAttrAccessibleAfterFirstUnlock` | The key is inaccessible after boot,
    until the user enters a passcode for the first time. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `kSecAttrAccessibleAfterFirstUnlock` | 设备启动后，密钥在用户第一次输入密码之前不可访问。 |'
- en: '| `kSecAttrAccessibleAlways` | The key is always accessible, as long as the
    device is booted. Note that this is deprecated in iOS 9 because it has no real
    advantage over `kSecAttrAccessibleAfterFirstUnlock`. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `kSecAttrAccessibleAlways` | 密钥始终可访问，只要设备已启动。请注意，在 iOS 9 中此项已被弃用，因为它相较于 `kSecAttrAccessibleAfterFirstUnlock`
    并没有实际优势。 |'
- en: '| `kSecAttrAccessibleAlwaysThisDeviceOnly` | The key is always accessible,
    but it cannot be ported to other iOS devices. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `kSecAttrAccessibleAlwaysThisDeviceOnly` | 密钥始终可访问，但无法移植到其他 iOS 设备上。 |'
- en: '| `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly` | This is the same as
    the previous key, but this key remains on only this device. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly` | 这与前一个密钥相同，但该密钥仅保留在此设备上。
    |'
- en: '| `kSecAttrAccessibleWhenUnlocked` | Whenever the device is unlocked (that
    is, after the user has entered a passcode), the key is accessible. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `kSecAttrAccessibleWhenUnlocked` | 每当设备解锁（即用户输入密码后），密钥可访问。 |'
- en: '| `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` | This is the same as the
    previous key, but this key remains only on this device (except for full, encrypted
    backups). |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` | 这与前一个密钥相同，但该密钥仅保留在此设备上（除非是完整的加密备份）。
    |'
- en: '| `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly` | This is the same as the
    previous key, but this key will be available only to users who have a passcode
    set and will be removed from the device if that passcode is unset. It will not
    be included in any backups. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly` | 这与前一个密钥相同，但此密钥仅对设置了密码的用户可用，如果取消设置密码，该密钥将从设备中移除，并且不会包含在任何备份中。
    |'
- en: 'When Keychain protections were first introduced, the default value was `kSecAttrAccessibleAlways`,
    creating an obvious security problem. *Accessible* in this case should be taken
    to mean “available to a physical attacker”: if someone steals your device, they’ll
    be able to read the contents of the Keychain. Generally, this is done by performing
    a temporary jailbreak and extracting the keys; using `kSecAttrAccessibleAfterFirstUnlock`
    instead will usually prevent this since a reboot is often required to perform
    the jailbreak. However, a code execution attack (such as someone exploiting a
    bug in a Wi-Fi driver) would give access to a device while it’s still running.
    In this case, `kSecAttrAccessibleWhenUnlocked` would be needed to prevent compromise
    of the keys, meaning that the attacker would need to determine the user’s passcode
    to extract secrets.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在密钥链保护首次引入时，默认值为 `kSecAttrAccessibleAlways`，这会产生明显的安全问题。在这种情况下，*可访问* 应理解为“对物理攻击者可用”：如果有人偷了你的设备，他们将能够读取密钥链中的内容。通常，这通过执行临时越狱并提取密钥来完成；改用
    `kSecAttrAccessibleAfterFirstUnlock` 通常可以防止这种情况，因为通常需要重启设备才能执行越狱。然而，代码执行攻击（例如有人利用
    Wi-Fi 驱动程序中的漏洞）可以在设备仍然运行时获得访问权限。在这种情况下，需要使用 `kSecAttrAccessibleWhenUnlocked` 来防止密钥泄露，这意味着攻击者需要确定用户的密码才能提取秘密。
- en: '**NOTE**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Unfortunately, brute-forcing a four-digit PIN on iOS is ridiculously fast.
    Not only can this be done with a temporary jailbreak,*^([2](footnote.html#fn110))
    *but my colleagues have successfully built cute robots to physically brute-force
    PINs in less than a day.*^([3](footnote.html#fn111))'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*不幸的是，在 iOS 上暴力破解四位数 PIN 码的速度快得惊人。不仅可以通过临时越狱实现此操作，*^([2](footnote.html#fn110))
    *而且我的同事们已经成功制造了可爱的机器人，在不到一天的时间内通过物理暴力破解 PIN 码。*^([3](footnote.html#fn111))'
- en: Currently, the default attribute is `kSecAttrAccessibleWhenUnlocked`, which
    is a reasonably restrictive default. However, Apple’s public documentation disagrees
    about what the default attribute is supposed to be, so just in case, you should
    set this attribute explicitly on all Keychain items. For your own code, consider
    using `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` if appropriate; when examining
    third-party source code, ensure that restrictive protection attributes are used.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，默认属性是`kSecAttrAccessibleWhenUnlocked`，这是一个相对限制性的默认值。然而，苹果的公开文档对于默认属性应该是什么存在分歧，因此，为了保险起见，你应该在所有钥匙串项目中显式设置该属性。对于你自己的代码，考虑在合适的情况下使用`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`；在检查第三方源代码时，确保使用限制性的保护属性。
- en: In iOS 8, the `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly` protection attribute
    was added. Developers have long requested an API that requires a user to have
    a passcode set. This new attribute doesn’t directly accomplish that, but developers
    can use it to make decisions based on whether a passcode is set. When you attempt
    to add an item to the Keychain specifying the `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`
    attribute, it will fail if the user does not have a passcode set. You can use
    this failure as a point at which to make a decision about whether to fall back
    to another Keychain protection attribute, alert the user, or just store less sensitive
    data locally.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 8中，添加了`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`保护属性。开发者长期以来一直要求提供一个需要用户设置密码的API。这个新属性并不能直接实现这一要求，但开发者可以利用它来根据是否设置了密码来做出决策。当你尝试向钥匙串中添加指定`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`属性的项目时，如果用户没有设置密码，操作将失败。你可以利用这个失败作为一个决策点，决定是否回退到另一个钥匙串保护属性、提醒用户，或者只是将不太敏感的数据存储在本地。
- en: If the user does have a passcode set, the addition will be successful; however,
    if the user ever decides to disable the passcode, the Class Keys used to decrypt
    the item will be discarded, preventing the item from being decrypted by the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户设置了密码，添加操作将成功；然而，如果用户决定禁用密码，解密该项目所用的类密钥将会被丢弃，从而阻止应用程序解密该项目。
- en: '***Basic Keychain Usage***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基本钥匙串使用***'
- en: There are several classes of Keychain items, as listed in [Table 13-2](ch13.html#ch13tab2).
    Unless you’re dealing with certificates, `kSecClassGenericPassword` can generally
    be used for most sensitive data, so let’s look at some useful methods on that
    class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类别的钥匙串项目，如[表13-2](ch13.html#ch13tab2)所列。除非你在处理证书，否则通常可以使用`kSecClassGenericPassword`来存储大多数敏感数据，接下来我们将看看该类别中一些有用的方法。
- en: '**Table 13-2:** Keychain Item Classes'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-2：**钥匙串项目类别'
- en: '| **Item class** | **Meaning** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **项目类别** | **含义** |'
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `kSecClassGenericPassword` | A plain-old password |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `kSecClassGenericPassword` | 一个普通的密码 |'
- en: '| `kSecClassInternetPassword` | A password specifically used for an Internet
    service |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `kSecClassInternetPassword` | 专用于互联网服务的密码 |'
- en: '| `kSecClassCertificate` | A cryptographic certificate |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `kSecClassCertificate` | 一个加密证书 |'
- en: '| `kSecClassKey` | A cryptographic key |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `kSecClassKey` | 一个加密密钥 |'
- en: '| `kSecClassIdentity` | A key pair, comprising a public certificate and private
    key |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `kSecClassIdentity` | 一个密钥对，包括公钥证书和私钥 |'
- en: '[Listing 13-1](ch13.html#ch13ex1) shows an example of how to use the Keychain
    to add a basic password item, using `SecItemAdd`. It sets up a dictionary to hold
    a Keychain *query*, which contains the appropriate key-value pairs to identify
    the password, sets a password policy, and specifies the password itself.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表13-1](ch13.html#ch13ex1)展示了如何使用钥匙串通过`SecItemAdd`添加基本密码项目的示例。它设置了一个字典来保存钥匙串*查询*，该查询包含了识别密码的适当键值对，设置了密码策略，并指定了密码本身。'
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: Adding an item to the Keychain*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-1：向钥匙串添加项目*'
- en: Here, the `kSecClassGenericPassword` class is set for the Keychain item, along
    with a user-readable label, a long description, the account (username), and an
    identifier for the service (to prevent duplicates). The code also sets the password
    and an accessibility attribute.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`kSecClassGenericPassword`类别被设置为钥匙串项目，另外还包括一个用户可读的标签、长描述、账户（用户名）以及服务标识符（用于防止重复）。代码还设置了密码和访问控制属性。
- en: '`SecItemUpdate` works similarly. [Listing 13-2](ch13.html#ch13ex2) shows `SecItemUpdate`
    in action with an example that updates the user’s password, which is stored in
    `kSecValueData`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecItemUpdate`的工作方式类似。[列表13-2](ch13.html#ch13ex2)展示了`SecItemUpdate`的使用示例，其中更新了存储在`kSecValueData`中的用户密码。'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 13-2: Updating a Keychain item with* `SecItemUpdate`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-2：使用* `SecItemUpdate` *更新钥匙串项目*'
- en: When updating a Keychain item with `SecItemUpdate`, you have to set two dictionaries.
    One should specify the basic Keychain identification information (at least the
    class, account, and service information), and the other should contain the attribute
    to update.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`SecItemUpdate`更新钥匙串条目时，你必须设置两个字典。一个字典应指定基本的钥匙串标识信息（至少包括类、账户和服务信息），另一个字典应包含要更新的属性。
- en: '`SecItemCopyMatching` can be used to query the Keychain to find one or more
    entries matching a given set of criteria. Typically, you’d construct a search
    dictionary using the class, account, and service attributes you use when creating
    or updating a Keychain item. Then, you’d instantiate an `NSDictionary` that will
    hold the search results and perform the actual `SecItemCopyMatching` call, passing
    in the search dictionary and a reference to the result dictionary. An example
    can be found in [Listing 13-3](ch13.html#ch13ex3).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecItemCopyMatching`可以用来查询钥匙串，查找符合给定条件的一个或多个条目。通常，你会使用类、账户和服务属性来构建一个搜索字典，这些属性在创建或更新钥匙串条目时使用。然后，你将实例化一个`NSDictionary`，该字典将保存搜索结果，并执行实际的`SecItemCopyMatching`调用，传入搜索字典和结果字典的引用。可以在[列表
    13-3](ch13.html#ch13ex3)中找到示例。'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 13-3: Querying the Keychain using* `SecItemCopyMatching`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-3：使用`SecItemCopyMatching`查询钥匙串*'
- en: With the Keychain data in the `result` dictionary, you can then use this information
    to perform your security-sensitive tasks such as authenticating to a remote service
    or decrypting data. Note that if you construct a query based on attributes that
    don’t include the account and service (which uniquely identify Keychain items),
    you may get a return dictionary that contains more than one Keychain item. This
    dictionary can be limited with `kSecMatchLimit` (that is, by setting it to a value
    of 1), but this could lead to unpredictable behavior if you’re trying to search
    for a single piece of data like a password.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`result`字典中获取到钥匙串数据后，你可以使用这些信息执行诸如向远程服务认证或解密数据等安全敏感的任务。请注意，如果你构建的查询没有包含账户和服务属性（这两个属性唯一标识钥匙串条目），你可能会得到一个包含多个钥匙串条目的返回字典。这个字典可以通过`kSecMatchLimit`来限制（即将其设置为
    1），但如果你正在尝试搜索像密码这样的单个数据，这可能会导致不可预测的行为。
- en: You can probably guess at this point what a `SecItemDelete` call will look like—see
    the example in [Listing 13-4](ch13.html#ch13ex4) for the actual code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经猜到，`SecItemDelete`调用的样子是什么——可以在[列表 13-4](ch13.html#ch13ex4)中看到实际代码。
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 13-4: Deleting a Keychain item using* `SecItemDelete`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-4：使用`SecItemDelete`删除钥匙串条目*'
- en: Note that if you don’t uniquely identify your Keychain item, all matching items
    that your application has access to will be deleted.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你没有唯一地标识你的钥匙串条目，所有你的应用程序可以访问的匹配项都会被删除。
- en: '***Keychain Wrappers***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***钥匙串封装器***'
- en: When working with the Keychain, you’ll probably end up writing a number of wrapper
    functions to make it more convenient since most applications use only a subset
    of the Keychain API’s functionality. There are actually a number of prewritten
    Keychain wrappers available from third parties; I tend to prefer Lockbox^([4](footnote.html#fn112))
    for its simplicity and functionality. Lockbox provides a set of class methods
    for storing strings, dates, arrays, and sets. You can see the procedure for storing
    a secret string in [Listing 13-5](ch13.html#ch13ex5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用钥匙串时，你可能最终会写许多封装函数，以使其更方便，因为大多数应用程序只使用钥匙串 API 功能的一个子集。事实上，第三方已经提供了许多预写的钥匙串封装器；我倾向于使用
    Lockbox^([4](footnote.html#fn112))，因为它简单且功能强大。Lockbox 提供了一组类方法，用于存储字符串、日期、数组和集合。你可以查看在[列表
    13-5](ch13.html#ch13ex5)中存储秘密字符串的过程。
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 13-5: Setting a Keychain item with Lockbox*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-5：使用 Lockbox 设置钥匙串条目*'
- en: The key name will be prefixed with your application’s bundle ID automatically,
    and this value will be used as for both the account and service keys. Retrieving
    data from the Keychain works as shown in [Listing 13-6](ch13.html#ch13ex6).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 键名将自动以你的应用程序的包 ID 为前缀，并且这个值将作为账户和服务键的值。检索钥匙串中的数据的过程如[列表 13-6](ch13.html#ch13ex6)所示。
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-6: Retrieving a string from the Keychain using Lockbox*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-6：使用 Lockbox 从钥匙串中检索字符串*'
- en: Whichever wrapper you choose or write, ensure that it has the ability to set
    `kSecAttrAccessible` attributes because much available sample code neglects this
    feature.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择或编写哪个封装器，请确保它具有设置`kSecAttrAccessible`属性的能力，因为许多现有的示例代码忽略了这个功能。
- en: '***Shared Keychains***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***共享钥匙串***'
- en: iOS has the capability to share Keychain data among multiple applications from
    the same developer by using Keychain access groups. For example, if you have a
    “buyer” app and a “seller” app for an online marketplace, you can let your users
    share the same username and password between the two applications. Unfortunately,
    this mechanism is widely misunderstood, which has led people to do horrifying
    things such as using named pasteboards to share items that should be specific
    to the Keychain.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 具有通过使用 Keychain 访问组在同一开发者的多个应用程序之间共享 Keychain 数据的能力。例如，如果你有一个“买家”应用和一个“卖家”应用，用于在线市场，你可以让用户在这两个应用之间共享相同的用户名和密码。不幸的是，这种机制被广泛误解，导致人们做出一些可怕的事情，比如使用命名的剪贴板共享应该专属于
    Keychain 的项目。
- en: '**NOTE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To use Keychain access groups, your applications* must *share the same bundle
    seed ID. This can be specified only upon creation of a new App ID.*^([5](footnote.html#fn113))'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*要使用 Keychain 访问组，你的应用程序*必须*共享相同的包种子 ID。这只能在创建新的 App ID 时指定。*^([5](footnote.html#fn113))'
- en: For your application to take advantage of access groups, you’ll need to create
    an Entitlements property list (see [Figure 13-1](ch13.html#ch13fig1)) containing
    an array called `keychain-access-groups`, with a String entry for each shared
    Key-chain item.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的应用程序利用访问组，你需要创建一个 Entitlements 属性列表（参见 [图 13-1](ch13.html#ch13fig1)），其中包含一个名为
    `keychain-access-groups` 的数组，每个共享的 Keychain 项目都有一个字符串条目。
- en: '![image](graphics/f13-01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f13-01.jpg)'
- en: '*Figure 13-1: Define a Keychain access group consisting of your bundle seed
    ID and your company prefix, followed by a common name for the Keychain item.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：定义一个由你的包种子 ID 和公司前缀组成的 Keychain 访问组，后跟 Keychain 项目的通用名称。*'
- en: The Keychain item will consist of the bundle seed ID, followed by your reverse-DNS
    notation developer identifier and a symbolic name that both applications can refer
    to the entitlement with (see [Listing 13-7](ch13.html#ch13ex7)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Keychain 项目将由包种子 ID、你的反向 DNS 标注开发者标识符以及两个应用程序都能引用该权限的符号名称组成（参见 [列表 13-7](ch13.html#ch13ex7)）。
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-7: Setting the access group of a Keychain item*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-7：设置 Keychain 项目的访问组*'
- en: Here, `DTHIELISEC` is the bundle seed ID. Your bundle ID will also be a 10-character
    alphanumeric string. You’ll need to pass in the value of your new entitlement
    as the value of the `kSecAttrAccessGroup` key when creating a Keychain item via
    the `SecItemAdd` function. Note that you can have only one Keychain access group
    on a Keychain item.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DTHIELISEC`是包种子 ID。你的包 ID 也将是一个 10 个字符的字母数字字符串。在通过 `SecItemAdd` 函数创建 Keychain
    项目时，你需要将新权限的值作为 `kSecAttrAccessGroup` 键的值传入。请注意，一个 Keychain 项目只能有一个 Keychain 访问组。
- en: '**NOTE**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Technically, if you create a Keychain access group and don’t specify it when
    creating a Keychain item, the first string in the* `*keychain-access-groups*`
    *array will be used as the default entitlement. So if you’re using only one access
    group, you don’t have to specify the group when doing a* `*SecItemAdd*`*—but you
    should anyway.*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，如果你创建了一个 Keychain 访问组，但在创建 Keychain 项目时没有指定该组，则会使用`*keychain-access-groups*`数组中的第一个字符串作为默认权限。因此，如果你只使用一个访问组，在执行`*SecItemAdd*`时无需指定该组——但最好还是指定。*'
- en: '***iCloud Synchronization***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***iCloud 同步***'
- en: iOS 7 introduced a mechanism to allow Keychain items to be synchronized with
    iCloud, letting users share Keychain items across multiple devices. By default,
    this is not enabled on application-created Keychain items, but it can be enabled
    by setting `kSecAttrSynchronizable` to true.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 7 引入了一种机制，允许 Keychain 项目与 iCloud 同步，使用户能够在多个设备间共享 Keychain 项目。默认情况下，应用程序创建的
    Keychain 项目并未启用此功能，但可以通过将 `kSecAttrSynchronizable` 设置为 true 来启用。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because this item is now potentially synchronized between multiple Keychains,
    updates to the item (including deletion) will propagate to all other locations
    as well. Ensure that your application can handle having Keychain items removed
    or changed by the system. Also note that you can’t specify an incompatible `kSecAttrAccessible`
    attribute when using this option. For instance, specifying `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`
    doesn’t work because `ThisDeviceOnly` specifies that the item should never be
    backed up, either to iCloud, to a laptop or desktop, or to any other synchronization
    provider.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为此项现在可能会在多个钥匙串之间同步，所以对该项的更新（包括删除）将传播到所有其他位置。确保你的应用能够处理系统删除或更改钥匙串项的情况。还需注意，使用此选项时不能指定不兼容的
    `kSecAttrAccessible` 属性。例如，指定 `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` 是不行的，因为
    `ThisDeviceOnly` 指定该项永远不应备份，无论是备份到 iCloud，还是备份到笔记本或桌面电脑，或任何其他同步提供商。
- en: '**The Data Protection API**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据保护 API**'
- en: As an extra layer of protection, Apple introduced the Data Protection API (not
    to be confused with Microsoft’s Data Protection API), which allows developers
    to specify when file decryption keys are available. This lets you control access
    to the file itself, similar to the `kSecAttrAccessible` attribute of Keychain
    items. The Data Protection API uses the user’s passcode in conjunction with a
    Class Key to encrypt keys specific to each protected file and discards the Class
    Key in memory when those files should not be accessible (that is, when the device
    is locked). When a PIN is enabled, the passcode settings screen will indicate
    that Data Protection is enabled, as in [Figure 13-2](ch13.html#ch13fig2).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的保护层，苹果引入了数据保护 API（与微软的 Data Protection API 不同），该 API 允许开发者指定何时可以访问文件解密密钥。它允许你控制对文件本身的访问，类似于钥匙串项的
    `kSecAttrAccessible` 属性。数据保护 API 使用用户的密码和类密钥结合来加密每个受保护文件的特定密钥，并在这些文件不应被访问时（即设备锁定时）将类密钥丢弃在内存中。当启用了
    PIN 时，密码设置界面会显示数据保护已启用，如 [图 13-2](ch13.html#ch13fig2) 所示。
- en: '![image](graphics/f13-02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f13-02.jpg)'
- en: '*Figure 13-2: Passcode settings with Data Protection enabled*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：启用数据保护的密码设置*'
- en: '***Protection Levels***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保护级别***'
- en: There are several levels of protection that a developer can request with the
    Data Protection API, which are roughly analogous to the `kSecAttrAccessible` attributes
    one sets on Keychain items. Let’s explore those now.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过数据保护 API 请求多个保护级别，这些级别大致类似于在钥匙串项上设置的`kSecAttrAccessible`属性。现在让我们来探讨这些级别。
- en: '**The CompleteUntilFirstUserAuthentication Protection Level**'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**CompleteUntilFirstUserAuthentication 保护级别**'
- en: '`CompleteUntilFirstUserAuthentication` is the default file protection attribute
    for iOS 5 and later. It will be applied to all applicable files unless another
    attribute has been explicitly specified. It’s functionally similar to `FileProtectionComplete`,
    except the file is always available after the user first unlocks the device after
    a reboot. This doesn’t offer a ton of protection if someone gains remote code
    execution on your running device or if there’s a Sandbox bypass, but it does protect
    you from some attacks that require a reboot.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompleteUntilFirstUserAuthentication` 是 iOS 5 及更高版本的默认文件保护属性。除非明确指定了其他属性，否则它将应用于所有适用的文件。其功能上类似于
    `FileProtectionComplete`，但文件在用户首次解锁设备（重启后）后始终可用。如果有人获得了在运行设备上执行远程代码的权限，或者发生了沙盒绕过，那么它的保护作用就不大，但它确实能防止一些需要重启才能进行的攻击。'
- en: '**The Complete Protection Level**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**完全保护级别**'
- en: '`Complete` is the safest file protection class available, if you can get away
    with using it. Complete protection ensures that after a short delay, locking the
    device discards the Class Key from memory and renders file contents unreadable.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Complete` 是可用的最安全的文件保护类，如果你能使用它的话。完全保护确保在短暂延迟后，锁定设备会将类密钥从内存中丢弃，使文件内容无法读取。'
- en: This protection level is expressed with the `NSFileProtectionComplete` attribute
    of `NSFileManager` and the `NSDataWritingFileProtectionComplete` flag for `NSData`
    objects. For `NSData` objects, you can start by setting the `NSDataWritingFileProtectionComplete`
    flag, as shown in [Listing 13-8](ch13.html#ch13ex8).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此保护级别通过 `NSFileManager` 的 `NSFileProtectionComplete` 属性以及 `NSData` 对象的 `NSDataWritingFileProtectionComplete`
    标志来表达。对于 `NSData` 对象，你可以从设置 `NSDataWritingFileProtectionComplete` 标志开始，如 [示例 13-8](ch13.html#ch13ex8)
    所示。
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 13-8: Setting the* `NSDataWritingFileProtectionComplete` *flag on
    an* `NSData` *object*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-8：在* `NSData` *对象上设置* `NSDataWritingFileProtectionComplete` *标志*'
- en: Once you’ve set `NSDataWritingFileProtectionComplete` on your `NSData` object,
    you can use `NNSFileManager` to set the `NSFileProtectionComplete` flag.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在 `NSData` 对象上设置了 `NSDataWritingFileProtectionComplete`，您可以使用 `NSFileManager`
    来设置 `NSFileProtectionComplete` 标志。
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 13-9: Setting the* `NSFileProtectionComplete` *flag using* `NSFileManager`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-9：使用 `NSFileManager` 设置* `NSFileProtectionComplete` *标志*'
- en: You can also add file protection attributes on SQLite databases that you create,
    using the weirdly long `SQLITE_OPEN_READWRITE_SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN`
    argument, as shown in [Listing 13-10](ch13.html#ch13ex10).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为您创建的 SQLite 数据库添加文件保护属性，使用长得奇怪的 `SQLITE_OPEN_READWRITE_SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN`
    参数，如 [清单 13-10](ch13.html#ch13ex10) 所示。
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 13-10: Setting protection attributes on SQLite databases*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-10：为 SQLite 数据库设置保护属性*'
- en: Think about how your app works before trying to use complete protection. If
    you have a process that will need continuous read/write access to a file, this
    protection mode will not be appropriate.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用完整保护之前，请先考虑一下您的应用程序如何工作。如果您的进程需要持续的读/写访问文件，那么这种保护模式将不适用。
- en: '**The CompleteUnlessOpen Protection Level**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**完整保护级别（除非打开）**'
- en: The `CompleteUnlessOpen` protection level is slightly more complicated. You’ll
    set it with the `NSFileProtectionCompleteUnlessOpen` flag when using `NSFileManager`
    and set it with `NSDataWritingFileProtectionCompleteUnlessOpen` when manipulating
    `NSData` stores. It is not, as its name might suggest, a mechanism that disables
    file protection if a file is currently held open by an application. `CompleteUnlessOpen`
    actually ensures that open files can still be written to after the device is locked
    and allows new files to be written to disk. Any existing files with this class
    cannot be opened when the device is locked unless they were already open beforehand.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompleteUnlessOpen` 保护级别稍微复杂一些。使用 `NSFileManager` 时，您会设置 `NSFileProtectionCompleteUnlessOpen`
    标志，操作 `NSData` 存储时则设置 `NSDataWritingFileProtectionCompleteUnlessOpen`。它并不像名字所示那样在文件被应用程序打开时禁用文件保护。`CompleteUnlessOpen`
    实际上确保即使设备被锁定，已打开的文件仍可以写入，并且允许新的文件写入磁盘。任何已经具有此类保护的文件，在设备锁定时无法打开，除非它们之前已经被打开。'
- en: The way this works is by generating a key pair and using it to calculate and
    derive a shared secret, which wraps the file key. [Figure 13-3](ch13.html#ch13fig3)
    illustrates this process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其工作原理是通过生成一对密钥，并使用它来计算和派生共享密钥，从而包裹文件密钥。[图 13-3](ch13.html#ch13fig3) 展示了这一过程。
- en: '![image](graphics/f13-03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f13-03.jpg)'
- en: '*Figure 13-3: Key generation and wrapping. Note that the file private key ➌
    is transient and is discarded after the wrapped file key is stored in the file
    metadata.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：密钥生成和包装。请注意，文件私钥 ➌ 是暂时的，在包裹的文件密钥存储在文件元数据中后会被丢弃。*'
- en: 'Let’s walk through this file protection process step by step:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地走过这个文件保护过程：
- en: As with all files, a file key ➊ is generated to encrypt the file’s contents.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有文件一样，会生成文件密钥 ➊ 用于加密文件内容。
- en: An additional key pair is generated^([6](footnote.html#fn114)) to produce the
    file public key ➋ and the file private key ➌.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成另一个密钥对^([6](footnote.html#fn114))来生成文件公钥 ➋ 和文件私钥 ➌。
- en: The file private key ➌ and the Protected Unless Open class public key ➍ are
    used to calculate a shared secret ➎.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件私钥 ➌ 和受保护除非打开类公钥 ➍ 用于计算共享密钥 ➎。
- en: An SHA-1 hash of this secret ➏ is used to encrypt the file key.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该共享密钥 ➏ 的 SHA-1 哈希用于加密文件密钥。
- en: This encrypted file key ➐ is stored in the file’s metadata, along with the file
    public key.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个加密文件密钥 ➐ 被存储在文件的元数据中，以及文件公钥一起。
- en: The system throws away the file private key.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统会丢弃文件私钥。
- en: Upon closing the file, the unencrypted file key is erased from memory.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件时，未加密的文件密钥会从内存中删除。
- en: When the file needs to be opened again, the Protected Unless Open class private
    key and the file public key are used to calculate the shared secret.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文件需要重新打开时，受保护除非打开类私钥和文件公钥将用于计算共享密钥。
- en: The SHA-1 hash of this key is then used to decrypt the file key.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该密钥的 SHA-1 哈希值随后用于解密文件密钥。
- en: The upshot of this process is that you can still write data while the device
    is locked, without having to worry that an attacker will be able to read that
    data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一过程的结果是，您仍然可以在设备锁定时写入数据，而无需担心攻击者能够读取这些数据。
- en: '***The DataProtectionClass Entitlement***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据保护类权限***'
- en: If your application is not going to need to read or write any files while in
    the background or when the device is locked, you can add an entitlement to the
    project with a value of `NSFileProtectionComplete`. This will ensure that all
    protectable data files written to disk will be accessible only when the device
    is unlocked, which is the equivalent of setting `kSecAttrAccessibleWhenUnlocked`
    on every applicable file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序在后台或设备锁定时不需要读取或写入任何文件，可以为项目添加一个值为`NSFileProtectionComplete`的授权。这将确保所有写入磁盘的可保护数据文件仅在设备解锁时可访问，这等同于在每个适用的文件上设置`kSecAttrAccessibleWhenUnlocked`。
- en: '**NOTE**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*While this will affect files managed with* `*NSFileManager*`, `*NSData*`*,
    SQLite, and Core Data files, other types of files (for example, plists, caches,
    and so on) will not be protected.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管这将影响通过* `*NSFileManager*`、`*NSData*`、SQLite和Core Data文件管理的文件，但其他类型的文件（例如，plist文件、缓存等）将不会受到保护。*'
- en: In Xcode 5 and later, the Data Protection entitlement is enabled by default
    on new projects; however, old projects will not be automatically migrated. Enabling
    entitlement itself is fairly simple—just flip the switch as shown in [Figure 13-4](ch13.html#ch13fig4).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode 5及以后的版本中，数据保护授权在新项目中默认启用；然而，旧项目不会自动迁移。启用授权本身相当简单——只需按照[图13-4](ch13.html#ch13fig4)所示切换开关。
- en: '![image](graphics/f13-04.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f13-04.jpg)'
- en: '*Figure 13-4: Enable the Data Protection entitlement in Xcode 5.*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：在Xcode 5中启用数据保护授权。*'
- en: Note that applications that were installed before iOS 7 do not automatically
    have Data Protection enabled. They either need to be updated or must have specifically
    requested a Data Protection attribute in the past.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在iOS 7之前安装的应用程序默认未启用数据保护。它们要么需要更新，要么过去曾明确请求过数据保护属性。
- en: '***Checking for Protected Data Availability***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查受保护数据的可用性***'
- en: For applications that do all their work in the foreground, Data Protection should
    work transparently. For applications that need to work in the background while
    the device is locked, your application will need to determine the availability
    of protected data before using it. This can be done via three different mechanisms.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在前台执行所有操作的应用程序，数据保护应该能透明地工作。对于需要在设备锁定时在后台运行的应用程序，你的应用程序需要在使用受保护数据之前确定其可用性。可以通过三种不同的机制来实现。
- en: '**Implementing Delegate Methods**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实现委托方法**'
- en: To be notified and take particular actions when data’s availability changes,
    your application should implement the `applicationProtectedDataWillBecomeUnavailable`
    and `applicationProtectedDataDidBecomeAvailable` delegate methods, as in [Listing
    13-11](ch13.html#ch13ex11).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在数据可用性变化时接收通知并采取相应的措施，你的应用程序应该实现`applicationProtectedDataWillBecomeUnavailable`和`applicationProtectedDataDidBecomeAvailable`委托方法，正如[清单13-11](ch13.html#ch13ex11)所示。
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 13-11: Delegate methods for detecting Data Protection availability
    changes*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-11：检测数据保护可用性变化的委托方法*'
- en: Use these delegate methods to ensure that tasks requiring protected data files
    clean up gracefully and to notify you when the files will be active again.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些委托方法来确保需要受保护数据文件的任务能够优雅地清理，并在文件重新激活时通知你。
- en: '**Using the Notification Center**'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用通知中心**'
- en: The `NSNotificationCenter` API essentially allows for an in-app broadcast mechanism,
    where one part of the app can listen for an event notification that can be called
    from other places in the code. To use the Notification Center to detect these
    state changes, you can register for the `UIApplicationProtectedDataWillBecomeUnavailable`
    and `UIApplicationProtectedDataDidBecomeAvailable` notifications, as shown in
    [Listing 13-12](ch13.html#ch13ex12).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSNotificationCenter` API 本质上提供了一种应用内广播机制，应用的一部分可以监听事件通知，而这些事件通知可以从代码的其他地方调用。要使用通知中心检测这些状态变化，你可以注册接收`UIApplicationProtectedDataWillBecomeUnavailable`和`UIApplicationProtectedDataDidBecomeAvailable`通知，正如[清单13-12](ch13.html#ch13ex12)所示。'
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 13-12: Using the Notification Center to detect data availability changes*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-12：使用通知中心检测数据可用性变化*'
- en: At ➊, an instance of the default Notification Center is instantiated and then
    an observer ➋ is added that specifies the selector to call when the event specified
    by `name:` occurs. Then you can simply implement that selector as part of the
    same class ➌ and put any logic that you want to perform upon receipt of the event
    there.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Data Protection Using UIApplication**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can also easily detect whether Data Protection is engaged at any given time,
    as shown in [Listing 13-13](ch13.html#ch13ex13).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 13-13: Using the* `protectedDataAvailable` *property*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Just check the Boolean result of the `isProtectedDataAvailable` instance method
    of `UIApplication`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption with CommonCrypto**'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First things first: you are (probably) not a cryptographer.^([7](footnote.html#fn115))
    I’m not a cryptographer. It’s easy to think that you understand the subtleties
    of an encryption algorithm or to copy and paste crypto code from somewhere online,
    but you will generally mess up if you try to do crypto yourself.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: That said, you should be aware of the CommonCrypto framework, if only so you
    can tell when other developers are trying to play cryptographer. There are some
    lower-level primitives for encryption and decryption operations, but the only
    one that you have any excuse for playing with is CCCrypt. [Listing 13-14](ch13.html#ch13ex14)
    shows one example of how you might use it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 13-14: Method signature for CCCrypt*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CCCrypt` method takes 11 arguments: control over the algorithm, key length,
    initialization vector, operation mode, and so on. Each one is a potential place
    to make a cryptographic mistake. In my experience, there are several common pitfalls
    that developers run into with CCCrypt, which I’ll describe here. Don’t make the
    same mistakes!'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '***Broken Algorithms to Avoid***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CCCrypt supports known bad encryption algorithms, such as DES, and if you use
    one, your app will almost certainly be susceptible to cryptographic attacks and
    brute-forcing. Even if you’re using the more modern AES, CCCrypt will let you
    switch from the default Cipher Block Chaining (CBC) mode to Electronic Code Book
    (ECB) using CCOptions, which is another bad idea. Using ECB mode causes identical
    blocks of plaintext to encrypt to identical blocks of ciphertext.^([8](footnote.html#fn116))
    This is a problem because if attackers know one piece of encrypted data, they
    can infer the contents of other blocks. This can typically be solved with a salt
    or initialization vector, but they can have problems as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '***Broken Initialization Vectors***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The specification for AES’s CBC mode requires a nonsecret initialization vector
    (IV) to be supplied to the algorithm. The IV helps to randomize the encryption
    and produce distinct ciphertexts even if the same plaintext is encrypted multiple
    times. That way, you don’t need to generate a new key every time to prevent disclosure
    of identical blocks of data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: It’s important that you never reuse an IV under the same key, however, or two
    plaintext messages that begin with the same bytes will have ciphertext beginning
    with the same sequence of block values. This would reveal information about the
    encrypted messages to an attacker. As such, it’s important to use a random IV
    for each cryptographic operation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是永远不要在相同的密钥下重用IV，否则两个以相同字节开始的明文消息将会有相同的密文开头，这将向攻击者泄露加密消息的信息。因此，为每次加密操作使用随机IV是非常重要的。
- en: You should also always make sure your call to AES CBC mode encryption functions
    don’t pass in a null initialization vector. If they do, then multiple sets of
    messages will be encrypted using the same key and IV, resulting in the situation
    I just described.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该始终确保调用AES CBC模式加密函数时，不传递空的初始化向量。如果传递了空IV，那么多个消息集将使用相同的密钥和IV进行加密，导致我刚才描述的情况。
- en: 'As you can see, using a static IV or a null IV has the same result: small blocks
    of ciphertext containing the same data will appear identical. An example of where
    this might be a problem would be a password manager, where encrypted keys are
    stored; if an attacker can read this data and determine that some of the ciphertexts
    are identical, they will know that the same password is used for multiple websites.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用静态IV或空IV的结果是相同的：包含相同数据的小块密文将显得相同。一个可能出现问题的例子是密码管理器，在其中存储加密密钥；如果攻击者能够读取这些数据并确定一些密文相同，他们就会知道多个网站使用了相同的密码。
- en: '***Broken Entropy***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***损坏的熵***'
- en: In the worst case, you may come across code that uses `rand` to attempt to obtain
    random bytes (`rand` being cryptographically insecure and not meant for use in
    cryptographic operations). The official Cocoa way to obtain entropy is via `SecRandomCopyBytes`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，你可能会遇到使用`rand`来尝试获取随机字节的代码（`rand`在密码学上不安全，不适用于加密操作）。官方的Cocoa获取熵的方式是通过`SecRandomCopyBytes`。
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code effectively acts as a wrapper of */dev/random*, reading entropy from
    the kernel’s built-in entropy pool. Note that the `kSecRandomDefault` constant
    is not available on OS X, so if you’re writing code to be portable, simply specify
    `NULL` as the first argument. (Under iOS, this is equivalent to using `kSecRandomDefault`.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上充当了*/dev/random*的封装器，从内核的内建熵池中读取熵。请注意，`kSecRandomDefault`常量在OS X上不可用，因此，如果你正在编写可移植的代码，只需将第一个参数指定为`NULL`。
    （在iOS下，这相当于使用`kSecRandomDefault`。）
- en: '***Poor Quality Keys***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***低质量密钥***'
- en: People often mistakenly use a user-supplied password as an encryption key. Especially
    on mobile devices, this results in a fairly weak, low-entropy encryption key.
    Sometimes, it’s as bad as a four-digit PIN. When using user-supplied input to
    determine an encryption key, a key derivation algorithm such as PBKDF2 should
    be used. The CommonCrypto framework provides this with `CCKeyDerivationPBKDF`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常常错误地将用户提供的密码用作加密密钥，特别是在移动设备上，这会导致一个相当弱、低熵的加密密钥。有时，这甚至和一个四位数的PIN一样糟糕。当使用用户输入来确定加密密钥时，应该使用像PBKDF2这样的密钥派生算法。CommonCrypto框架通过`CCKeyDerivationPBKDF`提供了这个功能。
- en: 'PBKDF2 is a key derivation function that uses a passphrase plus repeated iterations
    of a hashing algorithm to generate a suitable cryptographic key. The repeated
    iterations intentionally cause the routine to take longer to complete, making
    offline brute-force attacks against the passphrase far less feasible. `CCKeyDerivationPBKDF`
    supports the following algorithms for iterators:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: PBKDF2是一种密钥派生函数，它使用一个密码短语以及重复的哈希算法迭代来生成合适的加密密钥。重复的迭代故意让该过程需要更长的时间完成，从而使离线暴力破解密码短语的攻击变得不可行。`CCKeyDerivationPBKDF`支持以下迭代算法：
- en: • `kCCPRFHmacAlgSHA1`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCCPRFHmacAlgSHA1`
- en: • `kCCPRFHmacAlgSHA224`
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCCPRFHmacAlgSHA224`
- en: • `kCCPRFHmacAlgSHA256`
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCCPRFHmacAlgSHA256`
- en: • `kCCPRFHmacAlgSHA384`
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCCPRFHmacAlgSHA384`
- en: • `kCCPRFHmacAlgSHA512`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCCPRFHmacAlgSHA512`
- en: If at all possible, you should be using at least SHA-256 or above. SHA-1 should
    be considered deprecated at this point because advances have been made to speed
    up cracking of SHA-1 hashes in recent years.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，你应该使用至少SHA-256或更高版本。SHA-1应该被视为过时，因为近年来已经取得进展，能够加速破解SHA-1哈希。
- en: '**Performing Hashing Operations**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**执行哈希操作**'
- en: 'In some circumstances, you may need to perform a hashing operation to determine
    whether two blobs of data match, without comparing the entire contents. This is
    frequently used to verify a file against a “known good” version or to verify sensitive
    information without storing the information itself. To perform a simple hashing
    operation on a string, you can use the `CC_SHA` family of methods as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要执行哈希操作，以判断两个数据块是否匹配，而无需比较整个内容。这通常用于验证文件是否与“已知的良好”版本相符，或验证敏感信息而不存储信息本身。要对字符串执行简单的哈希操作，可以使用
    `CC_SHA` 系列方法，如下所示：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code simply defines a secret and its length and makes a char `hash` to
    contain the result of the hashing operation. At ➊, the call to `CC_SHA_256` takes
    whatever has been put into `data`, calculates the hash, and stores the result
    in `hash`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地定义了一个密钥和它的长度，并创建了一个 char 类型的 `hash` 来保存哈希操作的结果。在 ➊ 处，调用 `CC_SHA_256`
    会将 `data` 中的数据进行哈希计算，并将结果存储在 `hash` 中。
- en: You may also be used to using OpenSSL for hashing functions. iOS does not include
    OpenSSL, but it does include some compatibility shims for using OpenSSL-dependent
    hashing code. These are defined in *CommonDigest.h*, shown in [Listing 13-15](ch13.html#ch13ex15).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经习惯了使用 OpenSSL 来进行哈希运算。iOS 没有包含 OpenSSL，但它包括了一些兼容层，用来支持 OpenSSL 依赖的哈希代码。这些在*CommonDigest.h*中定义，如[列表
    13-15](ch13.html#ch13ex15)所示。
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 13-15: OpenSSL compatibility hooks for CommonCrypto hashing functions*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-15：OpenSSL 兼容的 CommonCrypto 哈希函数挂钩*'
- en: So as long as you define `COMMON_DIGEST_FOR_OPENSSL`, OpenSSL-style hashing
    operations should work transparently. You can see an example in [Listing 13-16](ch13.html#ch13ex16).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只要你定义了 `COMMON_DIGEST_FOR_OPENSSL`，OpenSSL 风格的哈希操作应该能够透明地工作。你可以在[列表 13-16](ch13.html#ch13ex16)中看到一个示例。
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 13-16: OpenSSL-style chunked SHA hashing*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-16：OpenSSL 风格的分块 SHA 哈希*'
- en: '[Listing 13-16](ch13.html#ch13ex16) uses `SHA1_Update` and `SHA1_Final`, which
    is more appropriate for hashing a large file, where reading the file in chunks
    reduces overall memory usage.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-16](ch13.html#ch13ex16) 使用了 `SHA1_Update` 和 `SHA1_Final`，这更适合用于哈希大文件，在这种情况下，分块读取文件可以减少整体内存使用。'
- en: '**Ensuring Message Authenticity with HMACs**'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过 HMAC 确保消息的真实性**'
- en: It’s important to make sure that encrypted message data hasn’t been tampered
    with or corrupted and that it was produced by a party in possession of a secret
    key. You can use a keyed *Hash Message Authentication Code (HMAC)* as a mechanism
    to guarantee the authenticity and integrity of a message. In an iOS application,
    you could use this to verify the authenticity of messages sent between applications
    or to have a remote server verify that requests were produced by the correct application.
    (Just take care that the key is generated and stored in such a way that it is
    unique to the device and well-protected.)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 确保加密后的消息数据没有被篡改或损坏，并且是由持有密钥的方生成的，这一点非常重要。你可以使用带有密钥的*哈希消息认证码（HMAC）*作为机制，来保证消息的真实性和完整性。在
    iOS 应用中，你可以使用 HMAC 来验证应用间发送的消息的真实性，或者让远程服务器验证请求是否由正确的应用生成。（只需要确保密钥的生成和存储方式能确保它是设备唯一的并且得到妥善保护。）
- en: To calculate an HMAC, you just need a key and some data to pass to the `CCHmac`
    function, as shown in [Listing 13-17](ch13.html#ch13ex17).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 HMAC，你只需要一个密钥和一些数据，传递给 `CCHmac` 函数，如[列表 13-17](ch13.html#ch13ex17)所示。
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 13-17: Calculating an HMAC*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-17：计算 HMAC*'
- en: Note that [Listing 13-17](ch13.html#ch13ex17) is simplified to show the basic
    mechanism; embedding a static key in your source code is not a recommended practice.
    In most cases, this key should be dynamically generated and stored in the Keychain.
    The operation is fairly simple. At ➊, the key for the hash is passed in as a UTF-8
    encoded string (this is the part that should be stored in the Keychain). At ➋,
    the data to be hashed is passed in, also as a UTF-8 string. Then an `NSMutableData`
    object is constructed ➌ to store the hash for later use and all three components
    are passed to the `CCHmac` function at ➍.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，[列表 13-17](ch13.html#ch13ex17) 被简化了，只展示了基本的机制；将静态密钥嵌入源代码中并不是推荐的做法。在大多数情况下，这个密钥应该是动态生成的，并存储在钥匙串中。操作过程相对简单。在
    ➊ 处，哈希的密钥以 UTF-8 编码的字符串形式传入（这部分应存储在钥匙串中）。在 ➋ 处，将要哈希的数据作为 UTF-8 字符串传入。然后创建一个 `NSMutableData`
    对象 ➌ 用来存储哈希结果，最后将三个组件一起传递给 `CCHmac` 函数，在 ➍ 处进行处理。
- en: '**Wrapping CommonCrypto with RNCryptor**'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**包装 CommonCrypto 与 RNCryptor**'
- en: 'If you need to use the encryption functionality exposed by CommonCrypto, RNCryptor
    is a good framework.^([9](footnote.html#fn117)) This wraps CommonCrypto and helps
    perform the most common function needed from it: encrypting data via AES with
    a user-supplied key. RNCryptor also helps you by providing sane defaults. The
    basic examples given in the instructions should be sufficient for most usage.
    See [Listing 13-18](ch13.html#ch13ex18) for basic usage.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用 CommonCrypto 提供的加密功能，RNCryptor 是一个不错的框架。^([9](footnote.html#fn117))
    它封装了 CommonCrypto，并帮助执行最常用的功能：通过用户提供的密钥使用 AES 加密数据。RNCryptor 还通过提供合理的默认设置来帮助你。说明中给出的基本示例应该足以应对大多数使用场景。有关基本用法，请参见
    [清单 13-18](ch13.html#ch13ex18)。
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 13-18: Encryption with RNCryptor*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-18：使用 RNCryptor 加密*'
- en: Simply pass in your data to the `encryptData` method, along with a constant
    specifying the encryption settings you want to use, a key (pulled from the Keychain
    or from user input), and an `NSError` object to store the result.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将数据传递给 `encryptData` 方法，并提供一个常量，指定你想要使用的加密设置、一个密钥（可以从钥匙串中获取或由用户输入）以及一个 `NSError`
    对象来存储结果。
- en: Decrypting data ([Listing 13-19](ch13.html#ch13ex19)) is more or less the inverse
    of encrypting, except that you do not need to provide the `kRNCryptorAES256Settings`
    constant because this is read from the header of the encrypted data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 解密数据（[清单 13-19](ch13.html#ch13ex19)）几乎是加密的反向操作，只是你不需要提供 `kRNCryptorAES256Settings`
    常量，因为该常量已从加密数据的头部读取。
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 13-19: Decrypting RNCryptor-encrypted data*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-19：解密 RNCryptor 加密的数据*'
- en: Encrypting streams or larger amounts of data while keeping memory usage sane
    is slightly more involved (see *[https://github.com/rnapier/RNCryptor](https://github.com/rnapier/RNCryptor)*
    for current examples), but the examples shown here cover the most common use case
    you’ll likely encounter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密流或大量数据的同时保持内存使用合理要稍微复杂一些（请参见 *[https://github.com/rnapier/RNCryptor](https://github.com/rnapier/RNCryptor)*
    获取当前示例），但这里展示的示例涵盖了你可能遇到的最常见用例。
- en: '**NOTE**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An older version of RNCryptor suffered from a vulnerability*^([10](footnote.html#fn118))
    *that could allow an attacker to manipulate a portion of the decrypted data by
    altering the ciphertext, so make sure that your code is using the most up-to-date
    version of RNCryptor.*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*RNCryptor 的旧版本存在一个漏洞*^([10](footnote.html#fn118)) *，攻击者可以通过修改密文来篡改解密后的部分数据，因此请确保你的代码使用的是最新版本的
    RNCryptor。*'
- en: '**Local Authentication: Using the TouchID**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**本地认证：使用 TouchID**'
- en: In iOS 8, Apple opened up the Local Authentication API so that third-party apps
    could use the fingerprint reader as an authenticator. The Local Authentication
    API is used by instantiating the `LAContext` class and passing it an authentication
    policy to evaluate; currently, only one policy is available, which is to identify
    the owner biometrically. [Listing 13-20](ch13.html#ch13ex20) shows this process
    in detail. Note that using this API doesn’t give developers access to the fingerprint—it
    just gives a success or failure from the reader hardware.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 8 中，苹果开放了本地认证 API，使第三方应用可以将指纹识别器作为身份验证工具。本地认证 API 通过实例化 `LAContext` 类并传入一个认证策略来评估；目前，只有一种策略可用，即通过生物特征识别身份。清单
    [13-20](ch13.html#ch13ex20) 详细展示了这个过程。请注意，使用此 API 并不会让开发者访问指纹数据，它只是提供一个来自读卡器硬件的成功或失败结果。
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 13-20: Authenticating the user via a fingerprint*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-20：通过指纹认证用户*'
- en: First, this code creates an `LAContext` object ➊ and an `NSError` object ➋ to
    contain the results of the operation. There also needs to be a reason to present
    to the user when the UI asks for their fingerprint ➌. After creating these things,
    the code checks whether it can evaluate the `LAPolicyDeviceOwnerAuthenticationWithBiometrics`
    policy at ➍.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码创建一个 `LAContext` 对象 ➊ 和一个 `NSError` 对象 ➋ 来保存操作结果。还需要为用户展示指纹界面时提供一个理由 ➌。创建这些之后，代码会检查是否可以在
    ➍ 处评估 `LAPolicyDeviceOwnerAuthenticationWithBiometrics` 策略。
- en: If evaluation is possible, then the policy is evaluated ➎; the reason and a
    block to handle the results of the evaluation are also passed to the `evaluatePolicy`
    method. If the fingerprint authenticates successfully, you can have the application
    allow whatever action it’s performing to continue ➏. If the fingerprint is invalid,
    then depending on how you choose to write your application, it can fall back to
    a different method of authentication or authentication can fail entirely ➐.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以进行评估，则会评估该策略 ➎；评估的原因和一个处理评估结果的块也会传递给`evaluatePolicy`方法。如果指纹验证成功，您可以允许应用程序继续执行当前操作
    ➏。如果指纹无效，那么根据您编写应用程序的方式，它可能会回退到其他身份验证方法，或者身份验证可能完全失败 ➐。
- en: If the call to `canEvaluatePolicy` at ➍ fails, then the execution ends up at
    ➑. This is most likely to happen if the user’s device doesn’t support the finger-print
    reader, fingerprint functionality has been disabled, or no fingerprints have been
    enrolled.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 ➍ 调用`canEvaluatePolicy`失败，则执行会进入 ➑。这种情况最有可能发生在用户的设备不支持指纹识别器、指纹功能被禁用，或者没有注册指纹时。
- en: '***How Safe Are Fingerprints?***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指纹有多安全？***'
- en: As with most other forms of biometric authentication, fingerprint authentication
    is an imperfect approach. It’s convenient, but given that you leave your fingerprints
    all over the place, it’s not difficult to re-create a mold that would effectively
    simulate your finger. In the United States, law enforcement is legally allowed
    to use fingerprints to unlock devices, whereas they cannot compel someone to divulge
    their passcode.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他生物识别身份验证形式一样，指纹身份验证是一种不完美的方法。它很方便，但由于你随处留下指纹，因此很容易重建一个模具，有效地模拟你的手指。在美国，执法部门有法律权利使用指纹解锁设备，而不能强迫某人透露他们的密码。
- en: 'There are a couple of things that developers can do to address these shortcomings.
    The most obvious is to provide the user with an option to use a PIN instead of
    using the TouchID, or perhaps in addition to the TouchID. Another thing that can
    help mitigate fingerprint cloning attacks is to implement a system similar to
    the one that Apple uses to handle the lock screen: after three unsuccessful attempts,
    revert to a PIN or require the user’s password. Because successfully getting a
    cloned fingerprint is an unreliable process, this may help prevent a successful
    fraudulent fingerprint authentication.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以做几件事来解决这些不足之处。最明显的是提供一个选项，让用户可以使用PIN码代替TouchID，或者可能在TouchID之外同时使用PIN码。另一个有助于减轻指纹克隆攻击的方法是实施一个类似于苹果用于处理锁屏的系统：在三次失败尝试后，恢复使用PIN码或要求用户输入密码。由于成功获取克隆指纹是一个不可靠的过程，这可能有助于防止成功的欺诈指纹认证。
- en: '**Closing Thoughts**'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: Encryption and authentication features aren’t always the most straightforward
    to use, but given the importance of user data privacy, both from a legal and reputational
    standpoint, correct deployment of these features is crucial. This chapter should
    have given you a reasonable idea of the strategies you might encounter or need
    to deploy. Protecting user privacy is a broader topic than just encryption, though—you’ll
    be turning your attention to that in the next chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 加密和身份验证功能并不总是最简单易用的，但考虑到用户数据隐私的重要性，无论从法律还是声誉角度来看，正确部署这些功能至关重要。本章应当已经让你对可能遇到或需要部署的策略有了合理的了解。然而，保护用户隐私是一个比加密更广泛的话题——你将在下一章中关注这一点。
