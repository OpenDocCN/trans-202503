- en: '22'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: COORDINATE SYSTEMS AND FIELDS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter we’ll begin exploring Faraday and Maxwell’s electromagnetic
    theory, which broke from Coulomb’s particle-based ideas by introducing the notion
    of a field. The Faraday-Maxwell theory is the best theory we have for explaining
    electrical, magnetic, and optical phenomena. As a field theory, the Faraday-Maxwell
    theory supported the locality ideas of relativity 40 years before Einstein wrote
    about it, served as an inspiration for other field theories like general relativity,
    and became the prototype for contemporary gauge field theories of particle physics.
    The field idea now plays an important role in many areas of physics, such as continuum
    mechanics, fluid dynamics, and quantum field theory. That a field is a function
    is one reason why functional programming serves physics so well.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible, and elegant, to give an exposition of electromagnetic theory
    in four-dimensional spacetime (and functional languages like Haskell are especially
    well suited to the task), but we’ll follow the more common practice of using three-dimensional
    notation since physical insight and geometric insight into four-dimensional relativistic
    spacetime language take some time to acquire. Accordingly, this chapter describes
    coordinate systems for three-dimensional space, defines a data type for position
    in three-dimensional space, and introduces the idea of a *field*, which is a function
    whose input is a position in three-dimensional space.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll gain a bit of insight by looking first at polar coordinates, the most
    common coordinates for a two-dimensional plane after Cartesian. Then, we’ll look
    at cylindrical and spherical coordinates, the two most common coordinate systems
    for three-dimensional space after Cartesian coordinates. We’ll make a new data
    type for positions in three-dimensional space that accommodates Cartesian, cylindrical,
    and spherical coordinates as well as any other coordinate system we might want
    to use. We’ll introduce scalar and vector fields, and data types for them, so
    that we have the basic mathematical framework to talk about things like charge
    density (a scalar field) and electric field (a vector field).
  prefs: []
  type: TYPE_NORMAL
- en: Polar Coordinates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Polar coordinates are a way of assigning two numbers to each point in the plane
    so that one of the numbers is the distance from the origin to the point. Polar
    coordinates are a natural choice for situations with rotational symmetry about
    a point in the plane, although their use need not be confined to such situations.
    We’ll use the variables *s* and *ϕ* for polar coordinates. The names *s* and *ϕ*
    are from Griffiths’ electrodynamics text [**[19](bib.xhtml#bib19)**].
  prefs: []
  type: TYPE_NORMAL
- en: 'The Cartesian coordinates *x* and *y* are related to the polar coordinates
    *s* and *ϕ* by the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* = *s* cos *ϕ*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *s* sin *ϕ*'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate *s* is the distance from the origin to a point in the plane,
    and the coordinate *ϕ* is the angle between the x-axis and a line joining the
    origin to a point (see [Figure 22-1](ch22.xhtml#ch22fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/423fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-1: Polar coordinates*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 22-1](ch22.xhtml#ch22fig1), we’ve also introduced polar coordinate
    unit vectors. The unit vector ![Image](Images/scap.jpg) points away from the origin.
    (This is a well-defined direction at every point in the plane except for the origin
    itself.) Equivalently, the unit vector ![Image](Images/scap.jpg) points in the
    direction for which *ϕ* stays constant and *s* increases. Analogously, the unit
    vector ![Image](Images/sdcap.jpg) points in the direction for which *s* stays
    constant and *ϕ* increases. We can write the polar coordinate unit vectors ![Image](Images/scap.jpg)
    and ![Image](Images/sdcap.jpg) in terms of the Cartesian coordinate unit vectors
    ![Image](Images/xcap.jpg) and ![Image](Images/ycap.jpg) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/423equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike the Cartesian unit vectors ![Image](Images/xcap.jpg) and ![Image](Images/ycap.jpg),
    the polar unit vectors ![Image](Images/scap.jpg) and ![Image](Images/sdcap.jpg)
    point in different directions at different points in the plane. The picture on
    the right of [Figure 22-5](ch22.xhtml#ch22fig5) later in this chapter shows the
    unit vector ![Image](Images/sdcap.jpg) at different points in the xy-plane, and
    you can see how its direction changes.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of polar coordinates in two dimensions makes it easy to define
    cylindrical coordinates in three dimensions, to which we now turn.
  prefs: []
  type: TYPE_NORMAL
- en: Cylindrical Coordinates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cylindrical coordinates are an extension of polar coordinates into three dimensions
    and are a natural choice of coordinates for situations with rotational and translational
    symmetry about some axis. We can use the cylindrical coordinates *s*, *ϕ*, and
    *z* to represent the location of a point in three-dimensional space, as shown
    in [Figure 22-2](ch22.xhtml#ch22fig2). The coordinate *s* is the distance from
    the z-axis to the point in space, the coordinate *ϕ* is the angle between the
    xz-plane and the plane containing the z-axis and the point, and the coordinate
    *z* means the same thing as in Cartesian coordinates: the distance from the xy-plane.
    Cylindrical coordinates are closely related to polar coordinates in that cylindrical
    coordinates describe the xy-plane in a polar fashion but continue to use the Cartesian
    z-coordinate.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/424fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-2: Cylindrical coordinates*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Cartesian coordinates *x*, *y*, and *z* are related to the cylindrical
    coordinates *s*, *ϕ*, and *z* by the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/424equ01.jpg)![Image](Images/424equ02.jpg)![Image](Images/424equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Also shown in [Figure 22-2](ch22.xhtml#ch22fig2) are the cylindrical coordinate
    unit vectors. The unit vector ![Image](Images/scap.jpg) points away from the z-axis.
    (This is a well-defined direction at every point in space except for points on
    the z-axis.) Equivalently, the unit vector ![Image](Images/scap.jpg) points in
    the direction for which *ϕ* and *z* stay constant and *s* increases. The unit
    vector ![Image](Images/sdcap.jpg) points in the direction for which *s* and *z*
    stay constant and *ϕ* increases. Finally, the unit vector ![Image](Images/zcap.jpg)
    points in the direction for which *s* and *ϕ* stay constant and *z* increases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the cylindrical coordinate unit vectors ![Image](Images/scap.jpg),
    ![Image](Images/sdcap.jpg), and ![Image](Images/zcap.jpg) in terms of the Cartesian
    coordinate unit vectors ![Image](Images/xcap.jpg), ![Image](Images/ycap.jpg),
    and ![Image](Images/zcap.jpg) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/425equ01.jpg)![Image](Images/425equ02.jpg)![Image](Images/425equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve talked about the system of cylindrical coordinates and shown
    how it’s an alternative to Cartesian coordinates for describing points in three-dimensional
    space, let’s discuss one more three-dimensional coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Spherical Coordinates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spherical coordinates are a natural choice in situations with rotational symmetry
    about a point in space, but, like all of the three-dimensional coordinate systems
    described in this chapter, they are also a general system of coordinates capable
    of describing arbitrary positions in 3D space. We can use the spherical coordinates
    *r*, *θ*, and *ϕ* to represent the location of a point in space, as shown in [Figure
    22-3](ch22.xhtml#ch22fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/425fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-3: Spherical coordinates*'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate *r* is the distance from the origin to the point in space, the
    coordinate *θ* is the angle between the z-axis and a line from the origin to the
    point, and the coordinate *ϕ* is the angle between the xz-plane and the plane
    containing the z-axis and the point. (The coordinate *ϕ* has the same meaning
    in spherical coordinates that it has in cylindrical coordinates.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The Cartesian coordinates *x*, *y*, and *z* are related to the spherical coordinates
    *r*, *θ*, and *ϕ* by the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/426equ01.jpg)![Image](Images/426equ02.jpg)![Image](Images/426equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Also shown in [Figure 22-3](ch22.xhtml#ch22fig3) are the spherical coordinate
    unit vectors. The unit vector ![Image](Images/rcap.jpg) points away from the origin.
    (This is a well-defined direction at every point in space except for the origin
    itself.) Equivalently, the unit vector ![Image](Images/rcap.jpg) points in the
    direction for which *θ* and *ϕ* stay constant and *r* increases. The unit vector
    ![Image](Images/thcap.jpg) points in the direction for which *r* and *ϕ* stay
    constant and *θ* increases. Finally, the unit vector ![Image](Images/sdcap.jpg)
    points in the direction for which *r* and *θ* stay constant and *ϕ* increases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write ![Image](Images/rcap.jpg) in terms of the Cartesian unit vectors,
    we divide the position vector ![Image](Images/426equ04.jpg) by its magnitude ![Image](Images/426equ05.jpg).
    The expression for ![Image](Images/sdcap.jpg) is the same as it was for cylindrical
    coordinates. An expression for ![Image](Images/thcap.jpg) can be found from ![Image](Images/426equ09.jpg).
    We can write the spherical coordinate unit vectors ![Image](Images/rcap.jpg),
    ![Image](Images/thcap.jpg), and ![Image](Images/sdcap.jpg) in terms of the Cartesian
    coordinate unit vectors ![Image](Images/xcap.jpg), ![Image](Images/ycap.jpg),
    and ![Image](Images/zcap.jpg) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/426equ06.jpg)![Image](Images/426equ07.jpg)![Image](Images/426equ08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve completed our introduction to spherical coordinates, and to all
    of the coordinate systems we intend to use, our next mission is to define a new
    type for positions in three-dimensional space that will work well with all of
    our three-dimensional coordinate systems. However, before we do that, let’s lay
    down some introductory code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introductory Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 22-1](ch22.xhtml#ch22list1) shows the first lines of code for the
    `CoordinateSystems` module we’ll develop in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 22-1: Opening lines of code for the CoordinateSystems module*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we import functions and types that we’ve previously written from the `SimpleVec`,
    `Mechanics3D`, and `MOExamples` modules. We’ll use the `Vis` module for visualizing
    scalar and vector fields, and we’ll use the `V3` type from `SpatialMath` since
    it’s the native vector type for the `Vis` module. The `Diagrams` `.Prelude` and
    `Diagrams.Backend.Cairo` modules are part of the diagrams package, which we’ll
    use for vector field visualization. The appendix contains information on installing
    the diagrams package.
  prefs: []
  type: TYPE_NORMAL
- en: A Type for Position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’d like to have a Haskell type to describe the position of a point in space.
    We’d also like to be able to specify points in three-dimensional space in Cartesian,
    cylindrical, or spherical coordinates, and to access previously defined positions
    in any of the coordinate systems, including a system different from the one used
    to define it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the New Type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How can we use Haskell to describe a point in space? We have three options.
    Option A is to use a triple `(R,R,R)` of Cartesian coordinates. This is fine for
    many purposes. It has the advantage of simplicity, but it has the disadvantage
    that we already know we’re interested in using cylindrical and spherical coordinates,
    which are also triples of numbers. This puts us in the dangerous position of mistaking
    a Cartesian (*x*,*y*,*z*) triple for a spherical (*r*,*θ*,*ϕ*) triple. The compiler
    can help us avoid this mistake, but only if we make intelligent use of the type
    system. Option A is workable but dangerous. We can make better use of the computer
    to help us avoid mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Option B is to use the `Vec` type for position, as we did in mechanics. The
    `Vec` type clearly has Cartesian components, so it’s harder to get confused compared
    with Option A. If we run into a triple `(R,R,R)` somewhere in code we’ve previously
    written, the type does not tell us whether it’s a Cartesian triple or a spherical
    triple. On the other hand, if we run into a `Vec`, we know it is a Cartesian triple
    under the hood. Option B is workable. One downside of Option B is that position
    is not really a vector because vectors are, by definition, things that can be
    added, and it doesn’t make sense to add positions. If we think of position as
    a vector, it is a vector from some fixed origin. But adding vectors means putting
    them tip-to-tail, and this isn’t really allowed for position “vectors” whose tails
    are fixed at the origin. The other disadvantage of using `Vec` for position (Option
    B) is that the Haskell type system cannot help us to distinguish position from
    any other `Vec` (such as velocity, acceleration, or momentum).
  prefs: []
  type: TYPE_NORMAL
- en: Option C is to use Haskell’s facilities to make a brand-new data type ourselves,
    which can’t be confused with any other data type. This is not the simplest option,
    but it will give us the power of working with the three coordinate systems we’re
    interested in, and it will give us the advantage that the compiler will not allow
    us to confuse position with velocity. We’ll pursue Option C.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll construct a new type in Haskell with the `data` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Position` that appears immediately to the right of the `data` keyword is
    the name we give to the new type. The `Cart` that appears to the right of the
    equal sign is the type’s one data constructor, so named to remind us that we are
    storing the position information in Cartesian coordinates, regardless of the coordinate
    system in which any particular `Position` is defined or used.
  prefs: []
  type: TYPE_NORMAL
- en: With the new `Position` data type, we have a way to store three numbers that
    the compiler will not confuse with any other way of storing three numbers (like
    a `Vec`). But the real usefulness of `Position` is that we can now define three
    ways of *making* a `Position` (one for each coordinate system) and three ways
    of *using* a `Position` (again, one for each coordinate system).
  prefs: []
  type: TYPE_NORMAL
- en: Making a Position
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we showed how Cartesian, cylindrical, and
    spherical coordinates can be used to describe a position in space. Each coordinate
    system uses three numbers to specify a position. A coordinate system is a function
    from three real numbers to space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here are the definitions for the three coordinate systems. For Cartesian coordinates,
    we just stick the coordinates behind the data constructor Cart. For cylindrical
    coordinates (*s*,*ϕ*,*z*), we convert to Cartesian using Equations 22.1 and 22.2
    and then apply the Cart constructor to the Cartesian values. For spherical coordinates
    (*r*,*θ*,*ϕ*), we again apply the data constructor to the converted Cartesian
    values using Equations 22.7, 22.8, and 22.9.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The functions cartesian, cylindrical, and spherical are our three ways of making
    a `Position`. Before we turn to the three ways of using a `Position`, we’ll define
    three helper functions that are almost the same as cartesian, cylindrical, and
    spherical. These three functions have the shortened names cart, cyl, and sph,
    and the only difference is that they take their arguments in a curried style,
    one right after the other, rather than as a triple. They are convenient helping
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The function `cart` is a helping function to take three numbers (*x*, *y*, *z*)
    and form the appropriate position using Cartesian coordinates. The definition
    of `cart` is given in point-free style, meaning we omitted the parameters because
    they are identical on both sides of the equation.
  prefs: []
  type: TYPE_NORMAL
- en: The function `cyl` is a helping function to take three numbers (*s*, *ϕ*, *z*)
    and form the appropriate position using cylindrical coordinates. We just call
    the function `cylindrical` to do the real work. The function `sph` is a helping
    function to take three numbers (*r*, *θ*, *ϕ*) and form the appropriate position
    using spherical coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the `cart` function to define the `origin`, which is the position
    where all three Cartesian coordinates are 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using a Position
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We said earlier that we would like to be able to look at an existing `Position`
    in Cartesian, cylindrical, or spherical coordinates, regardless of the coordinate
    system used to define the position. The following three functions show how to
    *use* a position to obtain a triple in the desired coordinate system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The mathematical content of these three functions is merely to convert Cartesian
    coordinates to any of the three systems. However, the worth of these functions
    lies in their type. They allow us to express a `Position` in any of the three
    coordinate systems, giving the numerical values of the coordinates so they can
    be used for something. The value of the `Position` data type is that it abstracts
    away from a specific coordinate system, allowing us to use any coordinate system
    without getting confused about what a set of three numbers might mean. In practice,
    then, we’ll keep our `Position`s for as long as we can, converting to a particular
    coordinate system only when we need access to particular coordinate values.
  prefs: []
  type: TYPE_NORMAL
- en: In physics language, both position and displacement have the dimension of length
    and the SI unit of meter. The next section endeavors to clarify the relationship
    between position and displacement.
  prefs: []
  type: TYPE_NORMAL
- en: Displacement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *displacement* is a vector that points from a source position to a target
    position. We have argued earlier that position in physics in not really a vector.
    Physicists use the term *displacement* when they want to refer to a vector with
    the dimension of length.
  prefs: []
  type: TYPE_NORMAL
- en: It is useful and natural to want a type `Displacement` for these vectors with
    the dimension of length. As usual, we have the choice of whether to make a brand-new
    type using the `data` keyword or to merely make a type synonym using the `type`
    keyword. The former option protects us from confusing displacement with any other
    vector, but at the cost of introducing a new data constructor, while the latter
    option is convenient but provides no such protection. We choose the latter option
    and make `Displacement` a type synonym for `Vec`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The displacement function allows us to “subtract” positions (recall we cannot
    add positions) to get a vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since a displacement vector points from the source position to the target position,
    we subtract the Cartesian source coordinates from the target coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The shiftPosition function allows us to add a displacement to a position to
    get a new position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the `shiftPosition` function in the next chapter to define some geometric
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Having introduced coordinate systems, a type for position, and the distinction
    between position and displacement, we now turn to the last major idea of the chapter—that
    of a field.
  prefs: []
  type: TYPE_NORMAL
- en: The Scalar Field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some physical quantities, like volume charge density and electric potential,
    are best described by giving a number for each point in space. These physical
    quantities are called *scalar fields*. The word *field* in physics means a function
    of physical space or spacetime; in other words, something that can take a different
    value at each point in space. (The word *field* in mathematics means something
    else.) A scalar field is a field in which the value assigned at each point in
    space is a scalar (that is, a number). Temperature is another example of a scalar
    field. The temperature in one place (Annville, Pennsylvania, for example) is usually
    different from the temperature at another place (Vero Beach, Florida, say).
  prefs: []
  type: TYPE_NORMAL
- en: Since a scalar field associates a number with each position in space, it makes
    sense to define a scalar field type to be a function from space to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we’re using a coordinate system, we can define scalar fields for each of
    the coordinates. For example, we can have a scalar field that associates each
    position in space with the value of its x-coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the coordinate scalar field that is associated with the spherical coordinate
    *r*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 9](ch09.xhtml), we defined functions that extract components from
    a triple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can use these functions to express the y-coordinate scalar field as the scalar
    field associated with the second Cartesian coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can define any of the coordinate scalar fields in this way.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 22-4](ch22.xhtml#ch22fig4) shows a visualization of the scalar field
    `ySF` using a coordinate system in which *x* comes out of the page, *y* increases
    to the right, and *z* increases upward. Associated with each position in space
    is its y-value, so the numbers increase to the right but do not change moving
    upward or out of the page. Later in the chapter, we will show how to make scalar
    field visualizations like that in [Figure 22-4](ch22.xhtml#ch22fig4).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/433fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-4: A screenshot of the y-coordinate scalar field ySF produced with
    the program ySF3D. The mouse and keyboard can be used to zoom in or out and rotate
    the visualization, a standard feature of the Vis module.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because charge density is a scalar field, the scalar field will play an important
    role in [Chapter 24](ch24.xhtml) when we define charge distributions.
  prefs: []
  type: TYPE_NORMAL
- en: The second type of field used in physics, and possibly the more important, is
    the vector field, to which we turn next.
  prefs: []
  type: TYPE_NORMAL
- en: The Vector Field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *vector field* associates a vector with each point in space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapters 25](ch25.xhtml) and [27](ch27.xhtml), we’ll discuss electric fields
    and magnetic fields, respectively, which are vector fields.
  prefs: []
  type: TYPE_NORMAL
- en: When we’re using a coordinate system, we can define vector fields that come
    from coordinates. The unit vectors used with cylindrical and spherical coordinates,
    such as ![Image](Images/scap.jpg), ![Image](Images/sdcap.jpg), ![Image](Images/rcap.jpg),
    and ![Image](Images/thcap.jpg), are really *unit vector fields* because their
    directions change depending on their location in space.
  prefs: []
  type: TYPE_NORMAL
- en: The vector fields ![Image](Images/scap.jpg) and ![Image](Images/sdcap.jpg) are
    defined using Equations 22.4 and 22.5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 22-5](ch22.xhtml#ch22fig5) shows visualizations of the vector field
    `phiHat`. Associated with each position in space is a vector, whose tail is located
    at the point in space, and whose magnitude and direction show the value of the
    vector at that point. The picture on the left shows the vector field in three
    dimensions, where *x* comes out of the page, *y* increases to the right, and *z*
    increases upward. The z-axis is the central axis of symmetry for the `phiHat`
    vector field. The picture on the right shows the vector field in the xy-plane.
    Since `phiHat` is a unit vector field, all of the vectors in these pictures have
    the same length. The pictures make clear how the unit vector field ![Image](Images/sdcap.jpg)
    points in different directions at different points in space. Later in the chapter
    I will show how to produce visualizations like this.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/434fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-5: Two ways of visualizing the vector field ![Image](Images/sdcap.jpg),
    or phiHat. The left shows a screenshot of the image produced by phiHat3D. The
    right shows an image in the xy-plane produced by phiHatPNG.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are definitions for the unit vector fields ![Image](Images/rcap.jpg) and
    ![Image](Images/thcap.jpg), using Equations 22.10 and 22.11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We regard ![Image](Images/icap.jpg), ![Image](Images/jcap.jpg), and ![Image](Images/kcap.jpg)
    as simple unit vectors (`Vec`s), but we define ![Image](Images/xcap.jpg), ![Image](Images/ycap.jpg),
    and ![Image](Images/zcap.jpg) as unit vector fields (`VectorField`s), analogous
    to ![Image](Images/scap.jpg), ![Image](Images/sdcap.jpg), ![Image](Images/rcap.jpg),
    and ![Image](Images/thcap.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: One important vector field that is not a unit vector field is the vector field
    **r**, which associates each position with the displacement vector from the origin
    to that position. We’ll give the name `rVF` to this vector field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The function `displacement` takes a source `Position` and a target `Position`
    and returns the displacement vector from the source to the target. By omitting
    the target position in the definition, the function `rVF` takes a target position
    as input and produces a displacement vector as output, which is just the `VectorField`
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 22-6](ch22.xhtml#ch22fig6) shows visualizations of the vector field
    `rVF`. Both pictures show the vector field in the xy-plane. The picture on the
    left places the tail of each vector at the position it is associated with, and
    it displays vectors with greater magnitude as arrows with longer length. The picture
    on the right places the center of each vector at the position it is associated
    with, and it displays vectors with greater magnitude as darker arrows.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/436fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-6: Two ways of visualizing the vector field **r**, or rVF, in the
    xy-plane. The left image is produced by rVFpng; the right image is produced by
    rVFGrad.*'
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, we’ll introduce functions that produce pictures, like
    those in [Figure 22-6](ch22.xhtml#ch22fig6), when given a vector field as input;
    however, producing pictures is only one of several things we can do with vector
    fields. Vector fields admit two kinds of derivatives, called *divergence* and
    *curl*, that express how the vectors of a vector field change in space. There
    are several integrals of vector fields over lines, surfaces, and volumes that
    are used to extract information and assert relationships among physical quantities.
    It is useful in physics to think of the vector field as a single mathematical
    entity. One of the advantages of a functional language for physics is the ease
    with which a vector field can be handled and written about as a single entity.
    This book aspires to make vector fields more accessible by presenting functions
    that allow you to play with vector fields.
  prefs: []
  type: TYPE_NORMAL
- en: Electric and magnetic fields are the most important vector fields in electromagnetic
    theory, although current density is also a vector field that appears in the famous
    Maxwell equations. We’ll discuss the electric field in [Chapter 25](ch25.xhtml),
    current density in [Chapter 26](ch26.xhtml), and the magnetic field in [Chapter
    27](ch27.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalar and vector fields can be added. The following are some functions to
    do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use these functions in [Chapter 25](ch25.xhtml) to add electric potential
    and electric field produced by multiple sources. For now, let’s turn to the question
    of how to visualize scalar and vector fields.
  prefs: []
  type: TYPE_NORMAL
- en: Functions for Visualizing Scalar Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A scalar field associates a number with each point in space. There are lots
    of ways to visualize a scalar field. We’ll develop two: one using Vis and one
    using text.'
  prefs: []
  type: TYPE_NORMAL
- en: 3D Visualization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One simple way to visualize a scalar field is to ask Vis to display numbers
    for the values of the scalar field at a list of positions. The function `sf3D`
    takes a list of positions and a scalar field as input and returns the action of
    displaying a 3D picture on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We name the incoming list of positions `ps` and the incoming scalar field `sf`.
    We use a list comprehension to make a list of pictures, one for each position
    `p` in `ps`. Each picture is a piece of text showing the value of the scalar field
    at that position. The value `sf p` is the `R` expressing the value of the scalar
    field `sf` at position `p`. The value `round $ sf p :: Int` is the `Int` obtained
    by rounding the scalar field value. We round so that the numbers take up only
    a small amount of space and don’t overlap each other in the final picture. The
    value `show (round $ sf p :: Int)` is the `String` we give to `Vis`’s constructor
    `V.Text3d` to be shown on the screen. The value `v3FromPos p` is the `V3` (Vis’s
    native vector type) giving the position where the text should be displayed. The
    definition of `v3FromPos` is similar to that of `v3FromVec` from [Chapter 16](ch16.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `V.VisObjects` constructor sews the list of pictures together into a single
    picture, which we orient to use my favorite coordinate system with `orient` and
    display with the `V.display` function using a set of options called `whiteBackground`,
    which we’ll define next.
  prefs: []
  type: TYPE_NORMAL
- en: The option set `whiteBackground` differs from the option set `V.defaultOpts`
    only in that the background color has been set to white.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This definition uses record syntax to specify that all fields of the `V.Options`
    data type should have the same values as those in `V.defaultOpts`, except for
    `V.optBackgroundColor`, which is set to white.
  prefs: []
  type: TYPE_NORMAL
- en: If you find you’d like to control the camera position from code, you can add
    options to do that. For example, the option set `whiteBackground'` sets the viewpoint
    to be a distance of 40 Vis units from the center.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of how to use this scalar field visualization function for
    the *y* scalar field `ySF`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 22-4](ch22.xhtml#ch22fig4) from earlier in this chapter shows the resulting
    picture. Perhaps the most useful feature of a 3D scalar field visualization like
    that in [Figure 22-4](ch22.xhtml#ch22fig4) is that it helps us to develop a visual
    and geometric understanding of what a scalar field is by imagining a number at
    each point in space. Once we have this geometric idea under our belts, and we
    wish to look in detail at a specific scalar field, it’s often simpler and more
    convenient to use a 2D visualization, which we’ll describe next.'
  prefs: []
  type: TYPE_NORMAL
- en: 2D Visualization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A 3D visualization of a scalar field can become unwieldy and hard to read, so
    it’s useful to have tools to view the scalar values on a 2D plane or surface.
    Our 2D visualization functions will allow the user to specify any plane or surface
    to focus on. We can do this by specifying how two numbers, representing horizontal
    and vertical position on the 2D visualization, map into three-dimensional space—in
    other words, by giving a function `(R,R) -> Position`. The functions that follow
    refer locally to this function as `toPos`. The function `sfTable` allows the user
    to visualize a scalar field by specifying a surface on which to view the values
    of the scalar field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first input to `sfTable`, locally called `toPos`, specifies the surface
    of interest. If we wanted to specify the xz-plane, for example, we’d send the
    function `\(x,z) -> cart x 0 z` in for `toPos`.
  prefs: []
  type: TYPE_NORMAL
- en: The second and third inputs to `sfTable`, locally called `ss` and `ts`, give
    the horizontal and vertical two-dimensional coordinates at which scalar values
    will be displayed. For a visualization of the xz-plane, the horizontal values
    could be x-values and vertical values could be z-values. The fourth input is the
    scalar field to be visualized.
  prefs: []
  type: TYPE_NORMAL
- en: The function works by sampling and displaying the values of the scalar field
    at the given points. We use the function `toPos` to produce a `Position` from
    an `(s,t)` pair of horizontal and vertical two-dimensional coordinates. We then
    apply the scalar field `sf` to this position, which is rounded so as not to take
    up too much space on the screen. The list of vertical coordinates is reversed
    so that the vertical values start at the bottom of the table and proceed to the
    top. We use the `Table` data type from [Chapter 20](ch20.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using `sfTable` to visualize the y-coordinate scalar field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can use a 2D scalar field visualization to show the temperature in a room
    or the electric potential in a capacitor, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Functions for Visualizing Vector Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A vector field associates a vector with each position in space. In this section,
    we’ll write three functions for visualizing a vector field: `vf3D`, `vfPNG`, and
    `vfGrad`.'
  prefs: []
  type: TYPE_NORMAL
- en: These functions essentially have type `VectorField -> IO ()`, meaning they take
    a vector field as input and do something, either displaying a picture on the screen
    or producing a graphics file on the hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: 3D Visualization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Vis` module can produce a 3D visualization of a vector field. The basic
    idea is to choose a list of positions at which vectors will be displayed. We use
    the vector field to compute the vector at each listed position and then display
    that vector with its tail at that position. The vector field will often have units
    that are different from the units of position (meters), so we need a scale factor
    to specify the number of vector field units that should be displayed per meter
    of space. Here is the code for the function `vf3D` that does this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The function `vf3D` takes a scale factor, a list of positions, and a vector
    field as input, and it produces a picture on the screen that can be enlarged and
    rotated with the mouse. As in `sf3D`, this function uses a list comprehension
    to make a list of pictures, one for each position `p` in `ps`. Each picture is
    a black arrow, produced by the `visVec` function defined below, representing the
    vector at position `p`, appropriately scaled and translated to the correct location.
    The `V.VisObjects` constructor sews the list of pictures together into a single
    picture, which is oriented to use my favorite coordinate system with `orient`
    and displayed with the `V.display` function using the option set `whiteBackground`,
    defined earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `visVec` function takes a color and a vector as input and produces a picture
    of an arrow as output. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function uses `Vis`’s `V.Arrow` constructor to make a picture of a vector.
    The first argument to `V.Arrow` is a pair of numbers. The first number is the
    requested length of the arrow, for which we choose `vmag`, the magnitude of the
    input vector. The second number is an aspect ratio for the desired ratio of arrow
    length to arrow shaft diameter. I chose `20*vmag` because I want the arrows to
    have a uniform shaft diameter. The shaft diameter is the arrow length `vmag` divided
    by the aspect ratio `20*vmag`, which is 1/20, independent of the arrow length.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument to `V.Arrow` is a vector in `Vis`’s native `V3` type, which
    specifies the direction of the arrow. We send `v3FromVec v`, our input vector
    converted to type `V3`. The third and final argument to `V.Arrow` is a color,
    and we simply pass on the input color `visVec` is given.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program uses the `vf3D` function to produce a visualization of
    the ![Image](Images/sdcap.jpg) unit vector field, defined as `phiHat` earlier
    in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The left side of [Figure 22-5](ch22.xhtml#ch22fig5) from earlier in the chapter
    shows a screenshot of the image `phiHat3D` produces. The image on the screen is
    interactive and can be rotated and zoomed with the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a 3D visualization of a vector field can appear cluttered, so we want
    tools to show a slice of a vector field in two dimensions. The right side of [Figure
    22-5](ch22.xhtml#ch22fig5) shows such a 2D visualization, and we’ll turn next
    to how to make this kind of picture.
  prefs: []
  type: TYPE_NORMAL
- en: 2D Visualization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How can we hope to visualize a 3D vector field in two dimensions? In general,
    we can’t. Even if we limit our attention to a plane in three-dimensional space,
    say the xy-plane, the vectors could have a z-component so that they can’t be represented
    in the xy-plane. Nevertheless, there are enough examples of vector fields that
    have planes in which the vectors point *in the plane* that 2D visualization is
    a worthwhile endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: As with 2D scalar field visualization, the function we write will take an argument,
    locally called `toPos`, with type `(R,R) -> Position`, that maps the two-dimensional
    coordinates we supply to 3D `Position`s. After we gather a collection of vectors
    at positions in the plane, we need a second function to specify how these 3D vectors
    are to be regarded as 2D vectors in the plane. We can do this with a function
    `Vec -> (R,R)` that we will name with the local variable `fromVec`.
  prefs: []
  type: TYPE_NORMAL
- en: We could use gloss for our 2D vector field visualization, but because we may
    want a platform for the asynchronous animation we first explored in [Chapter 20](ch20.xhtml),
    we’ll instead pursue a graphics library called diagrams that produces PNG files
    that could be sewn together into an asynchronous animation. The function `vfPNG`
    we are about to write takes a `VectorField` as input, along with some other parameters,
    and produces a PNG file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The function takes five items as input before the vector field we want to display.
    The first two items are the functions, locally named `toPos` and `fromVec`, that
    manage the connection between 2D and 3D vector fields. The third item is a filename
    for the PNG file. The fourth is a scale factor, in (vector field) units per meter,
    to control the length of displayed vectors. The fifth item is a list of 2D points
    at which we want vectors displayed. Finally, the sixth item is the vector field
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: The local function `vf2d` is a composition of five functions. It takes a 2D
    point as input and produces a 2D vector as output, with a type that diagrams likes
    for the positioning of arrows. Starting with a 2D position `(R,R)`, the function
    `vf2d` begins by applying `toPos`, the function the user of `vfPNG` provided to
    transform a 2D position into a `Position`. The vector field `vf` is then applied
    to produce a `Vec`. This vector is scaled by the scale factor `unitsPerMeter`,
    after which the function `fromVec` transforms the `Vec` into a pair of real numbers
    representing a 2D vector. Finally, diagrams’s function `r2` transforms a pair
    of real numbers `(R,R)` into diagrams’s 2D vector type.
  prefs: []
  type: TYPE_NORMAL
- en: The local variable `pic` is for the picture to be displayed, which is made by
    combining a list of arrow pictures formed with a list comprehension. Each arrow
    picture is made with diagrams’s `arrowAt` function, which places the tail of the
    2D vector in its second argument at the 2D position in its first argument. The
    diagrams package makes a distinction between a 2D position, formed from a pair
    of numbers with its `p2` function, and a 2D vector, formed from a pair of numbers
    with its `r2` function.
  prefs: []
  type: TYPE_NORMAL
- en: The last line in `vfPNG` produces the PNG file with diagrams’s `renderCairo`
    function, which takes a filename, a pixel size, and a picture as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the xy-plane happens to be our plane of interest, we can write a helping
    function by supplying `vfPNG` with its first two arguments. The function `vfPNGxy`
    has these first two arguments supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The function that `vfPNG` locally calls `toPos` is specified here as the function
    that maps the pair `(x,y)` into the xy-plane. The function that `vfPNG` locally
    calls `fromVec` projects the 3D vector into the xy-plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program produces a PNG file for the vector field ![Image](Images/sdcap.jpg),
    or `phiHat`, the unit vector field in cylindrical and spherical coordinates corresponding
    to the coordinate *ϕ*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The right side of [Figure 22-5](ch22.xhtml#ch22fig5) earlier in the chapter
    shows the vector field ![Image](Images/sdcap.jpg) produced by `phiHatPNG`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is code to produce a PNG picture of the vector field `rVF` introduced
    earlier in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The left side of [Figure 22-6](ch22.xhtml#ch22fig6) earlier in the chapter shows
    the resulting picture.
  prefs: []
  type: TYPE_NORMAL
- en: Physicists use the notation **r** in at least three ways. It can stand for a
    single position vector, which we would call a `Vec`. It can stand for a position
    function, like what we worked with in [Part II](part02.xhtml), returning a position
    when given a time. In [Part II](part02.xhtml), this position function would have
    type `R -> Vec` because position was regarded as a vector back then. Now that
    we have a data type for position, such a function has type `R -> Position`. A
    third use of the symbol **r** is for the vector field we just introduced. This
    has type `VectorField`, which is a type synonym for `Position -> Vec`. The type
    system helps clarify that these three uses of the symbol **r** are distinct.
  prefs: []
  type: TYPE_NORMAL
- en: Before we leave the topic of vector field visualization, we need to look at
    one more visualization method.
  prefs: []
  type: TYPE_NORMAL
- en: Gradient Visualization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we visualize electric and magnetic fields, which we will do a few chapters
    from now, the magnitudes of the vectors can change enormously over short distances.
    Thus, displaying the magnitude of the vector as the length of an arrow can produce
    a burdensome picture. An alternative is to use shading to indicate magnitude,
    with short fat arrows to indicate direction. I call this style of vector field
    visualization *gradient visualization*.
  prefs: []
  type: TYPE_NORMAL
- en: The function `vfGrad` we define below takes a vector field, along with some
    other parameters, and produces a PNG file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to `vfGrad` is a monotonic function `curve` that maps the
    unit interval [0,[1](bib.xhtml#bib1)] onto itself. The purpose of this argument
    is to make some accommodation for the possibility that a vector field may have
    very large magnitudes at some positions and rather small magnitudes elsewhere.
    The largest magnitude vectors will be colored black and those closest to zero
    will be colored white. Sometimes a linear scaling results in a picture in which
    there are black vectors close to a source and white vectors everywhere else. In
    those cases, a power law such as cube root or fifth root can boost the smaller
    magnitudes so that a continuous transition from black to white becomes evident.
    We can achieve a linear scaling with the identity function `id` and a fifth root
    scaling with the section `(**0.2)`.
  prefs: []
  type: TYPE_NORMAL
- en: The next arguments, with local names `toPos` and `fromVec`, are the same as
    in the function `vfPNG`. However, `toPos` plays a double role in this function
    because `vfGrad` does not ask for a list of positions at which to show vectors.
    Instead, `vfGrad` displays the square from (–1, –1) to (1, 1). This square must
    be mapped to some square in three-dimensional space, the vectors at which will
    be displayed. If we wanted to see the square in the xy-plane with corners at Cartesian
    coordinates (–10, –10, 0) and (10, 10, 0), we would send the function `\(x,y)
    -> cart (10*x) (10*y) 0` in for `toPos`.
  prefs: []
  type: TYPE_NORMAL
- en: The argument `fileName` is a filename for the PNG file. The argument `n` is
    an integer specifying the number of arrows to use in each direction. Sending in
    20, for example, will produce an image of 20 arrows by 20 arrows. The last input
    `vf` is the vector field itself.
  prefs: []
  type: TYPE_NORMAL
- en: The function `vfGrad` consists of several local definitions that build a picture
    `pic` ➐, followed by the same `renderCairo` line ➑ used in `vfPNG` to make the
    PNG file. The first three lines ➊ ➋ ➌ in the `let` clause serve to choose the
    points `pts` at which the vector field will be sampled and displayed. The next
    line ➍ defines `array` (type `[((R,R),(R,R))]`) as a list of pairs of points and
    2D vectors. We calculate the 2D vector at `pt` by applying `toPos` to convert
    `pt` to a 3D `Position`, applying the vector field `vf`, then using `fromVec`
    to convert the 3D vector to a 2D vector, and finally applying `magRad`, defined
    next, to express the 2D vector in magnitude-angle form.
  prefs: []
  type: TYPE_NORMAL
- en: The local variable `maxMag` ➎ searches the list `array` to find the maximum
    magnitude of all of the vectors in the list. Vectors with this magnitude will
    be colored black. The local function `scaledArrow` ➏ describes how to make a picture
    of a single arrow from a magnitude `m` and angle `th`. It normalizes the magnitude
    `m` by dividing it by the maximum magnitude `maxMag`, resulting in a normalized
    magnitude between 0 and 1\. This normalized magnitude is then scaled, or curved,
    by the function `curve`, a monotonic function mapping the unit interval [0,[1](bib.xhtml#bib1)]
    to itself. The normalized and scaled magnitude then passes with the angle to the
    `arrowMagRad` function, defined next, to get a picture of the arrow. Finally,
    the code scales the size of the arrow based on the number of arrows requested.
    We form the final picture `pic` ➐ with a list comprehension by placing each of
    the arrows at the appropriate position.
  prefs: []
  type: TYPE_NORMAL
- en: The function `magRad` converts a pair of Cartesian coordinates to polar coordinates,
    with the angle in radians.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The function `arrowMagRad` produces a picture of an arrow based on a normalized
    magnitude in the range 0 to 1 and an angle in radians.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The function defines the shape of the arrow as a polygon and chooses the color
    based on the normalized magnitude. A normalized magnitude of 1 results in a black
    arrow, 0 results in white, and numbers in between result in some shade of gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of gradient visualization for the vector field **r**, or
    `rVF`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The right side of [Figure 22-6](ch22.xhtml#ch22fig6) earlier in the chapter
    shows the vector field **r**, or `rVF` produced by `rVFGrad`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced the idea of a field, which is a function from a position
    in three-dimensional space. Scalar fields and vector fields are the two most important
    types of field for electromagnetic theory. We introduced several ways of visualizing
    scalar and vector fields as well as coordinate systems for three-dimensional space,
    in particular for cylindrical and spherical coordinates. We then wrote a new data
    type for position.
  prefs: []
  type: TYPE_NORMAL
- en: Since electromagnetic theory is geometric, the next chapter introduces data
    types for geometric objects like curves, surfaces, and volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 22.1.** Show that the polar coordinate unit vectors form an orthonormal
    system. Orthonormal means both orthogonal (different vectors are perpendicular
    to each other) and normalized (each vector has length one). In other words, show
    that'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/446equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Exercise 22.2.** Write ![Image](Images/xcap.jpg) and ![Image](Images/ycap.jpg)
    in terms of ![Image](Images/scap.jpg) and ![Image](Images/sdcap.jpg). Your results
    should contain *s*, *ϕ*, ![Image](Images/scap.jpg), and ![Image](Images/sdcap.jpg)
    but not *x* or *y*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 22.3.** Show that the spherical coordinate unit vectors form an
    orthonormal system. In other words, show that'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/446equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Exercise 22.4.** Write ![Image](Images/xcap.jpg), ![Image](Images/ycap.jpg),
    and ![Image](Images/zcap.jpg) in terms of ![Image](Images/rcap.jpg), ![Image](Images/thcap.jpg),
    and ![Image](Images/sdcap.jpg). Your results can contain *r*, *θ*, *ϕ*, ![Image](Images/rcap.jpg),
    ![Image](Images/thcap.jpg), and ![Image](Images/sdcap.jpg) but not *x*, *y*, or
    *z*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 22.5.** Define a coordinate scalar field'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: for the *θ* coordinate in spherical coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 22.6.** Use 3D visualization to make an image of the vector field
    ![Image](Images/thcap.jpg), or `thetaHat`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 22.7.** Use the `vf3D` function to visualize the vector field **r**,
    or `rVF`. You may need to use a scale factor greater than 1 so the arrows don’t
    overlap each other. A larger scale factor shrinks the arrows because the scale
    factor is in units per meter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 22.8.** Use gradient vector field visualization to make an image
    of the vector field ![Image](Images/thcap.jpg), or `thetaHat`, in the xz-plane.
    In the first `undefined` below, you must say how to map a pair of coordinates
    to a `Position`, knowing that you are interested in the xz-plane. In the second
    `undefined`, you must say how to map a `Vec` to a pair of numbers describing the
    two components of the vector to be displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 22.9.** Use gradient vector field visualization to make an image
    of the vector field ![Image](Images/sdcap.jpg), or `phiHat`, in the xy-plane.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
