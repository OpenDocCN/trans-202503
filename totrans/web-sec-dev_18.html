<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_153"/><strong><span class="big">16</span></strong><br/><strong>DON’T BE AN ACCESSORY</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="image" width="190" height="190"/></div>&#13;
<p class="noindent">Malicious actors have a lot of places to hide on the internet. Hackers routinely impersonate other people and use compromised servers to evade detection. This chapter explores various ways that your web presence may be helping attackers get away with malicious acts, even when you aren’t the target of their attacks.</p>&#13;
<p class="indent">Making sure you aren’t being an accessory will win you good internet citizen points. More practically, if hackers are using your system as a jumping-off point for attacking others, you will quickly find your domain and IP addresses getting blacklisted from key services, and you may even end up being cut off by your hosting provider.</p>&#13;
<p class="indent">This chapter covers several vulnerabilities that can make you an accessory to malicious acts on the internet. The first couple of vulnerabilities are used by hackers to send harmful emails: scammers frequently use <em>email address spoofing</em> to disguise who is sending an email, and use <em>open redirects</em> on websites to disguise malicious links in email.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>Next, you’ll see how your site can be hosted within a frame on someone else’s page and be used as part of a <em>clickjacking</em> attack. In this type of attack, your site is used in a bait-and-switch scheme to trick users into clicking something harmful.</p>&#13;
<p class="indent">You saw in the preceding chapter how hackers can use vulnerabilities in XML parsers in order to trigger network requests. If an attacker can craft malicious HTTP requests that trigger outbound network access from your server, you are enabling <em>server-side request forgery</em> attacks. You will learn common ways this type of attack can be launched and how to protect against it.</p>&#13;
<p class="indent">Finally, you will look at the risk of malware being installed on your servers for use in a <em>botnet</em>. You may unknowingly be hosting zombie code that can be controlled remotely by an attacker!</p>&#13;
<h3 class="h3" id="ch00lev1sec237"><strong>Email Fraud</strong></h3>&#13;
<p class="noindent">Email is sent using the <em>Simple Mail Transfer Protocol (SMTP)</em>. One major oversight in the original design of SMTP is that it does not have a mechanism for authentication: the sender of an email is able to attach <em>any</em> email address they want in the <span class="literal">From</span> header, and until relatively recently, there was no way for the receiving agent to verify that the sender is who they claim to be.</p>&#13;
<p class="indent">As a result, of course, we all receive massive amounts of spam email. Experts estimate that around <em>half</em> of all email sent is spam—nearly 15 billion spam emails are sent every day. Spam email generally contains unwanted (and often misleading) marketing material that is a nuisance to the recipient.</p>&#13;
<p class="indent">Related to spam email is <em>phishing</em> email: the sender attempts to trick the recipient into revealing sensitive personal information such as passwords or credit card details. A common trick is to email a victim with what looks like a password reset email for a website they use, but have the reset link to a <em>doppelganger domain</em>—a domain whose name looks superficially similar to the real domain name that hosts a fake version of the site. The fake site will harvest the user’s credentials on behalf of the attacker, and then redirect the user to the real site so the victim is none the wiser.</p>&#13;
<p class="indent">An even more vicious form of this type of attack is <em>spearphishing</em>, whereby the content of a malicious email is tailored to a small audience. Fraudsters sending this type of email often conduct detailed research on their victims in order to be able to name-drop or impersonate colleagues. <em>CEO fraud</em>—through which a scammer pretends to be a C-level officer and emails another employee to request a wire transfer—netted hackers over $26 billion between 2016 and 2019 according to the FBI. And that’s just counting the victims who reported the loss to law enforcement.</p>&#13;
<p class="indent">Thankfully, mail service providers have developed sophisticated algorithms for detecting spam and phishing email. Gmail, for instance, will scan each incoming email and quickly decide whenever it is legitimate, sending anything that looks suspicious to the junk folder. Spam filters use many inputs when classifying email: keywords in the email and the subject line, the email domain, and the presence of any suspicious outgoing links in the body of the mail.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_155"/>Your website and organization likely send email from a custom domain, so the onus is on <em>you</em> to prevent your email from being marked as spam and to protect your users from malicious email that pretends to be from your domain. You have a couple of ways to do this: by implementing a Sender Policy Framework and by using DomainKeys Identified Mail when you generate email.</p>&#13;
<h4 class="h4" id="ch00lev1sec238"><strong><em>Implement a Sender Policy Framework</em></strong></h4>&#13;
<p class="noindent">Implementing a <em>Sender Policy Framework (SPF)</em> entails whitelisting the IP addresses that are authorized to send email from your web domain in the DNS. Because SMTP sits on top of the TCP, the IP address that an email is sent from cannot be spoofed in the same way as the <span class="literal">From</span> header. By explicitly whitelisting IP addresses in your domain name records, mail receiving agents will be able to verify that incoming mail originated from a permitted source.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list1">Listing 16-1</a> shows how to specify a Sender Policy Framework in your DNS records.</p>&#13;
<p class="programs">v=spf1<span class="ent">❶</span> ip4:192.0.2.0/24 ip4:198.51.100.123<span class="ent">❷</span> a<span class="ent">❸</span> -all<span class="ent">❹</span></p>&#13;
<p class="caption"><a id="ch16list1"/><em>Listing 16-1: A DNS record to whitelist a range of IP addresses authorized to send email from a given domain as part of your SPF</em></p>&#13;
<p class="indent">This record would be added as a <em>.txt</em> record in your domain name records. In this syntax, the <span class="literal">v=</span> argument <span class="ent">❶</span> defines the version of SPF used. The <span class="literal">ip4</span> <span class="ent">❷</span> and <span class="literal">a</span> <span class="ent">❸</span> flags specify the systems permitted to send messages for the given domain: in this case, a range of IP addresses, and the IP address corresponding to the domain (indicated by the <span class="literal">a</span> flag) itself. The <span class="literal">-all</span> flag <span class="ent">❹</span> at the end of the record tells mail providers that if the preceding mechanisms did not match, the message should be rejected.</p>&#13;
<h4 class="h4" id="ch00lev1sec239"><strong><em>Implement DomainKeys Identified Mail</em></strong></h4>&#13;
<p class="noindent"><em>DomainKeys</em> can be used to generate a digital signature for outgoing mail, to prove an email was legitimately sent from your domain and that it wasn’t modified in transit. <em>DomainKeys Identified Mail (DKIM)</em> uses public-key cryptography, signing outgoing messages from a domain with a private key and allowing recipients to validate the signature by using a public key hosted in DNS. Only the sender knows the private signing key, so only they can generate legitimate signatures. A mail receiving agent will recalculate the signature by combining the email’s content and the public signing key hosted on your domain. If the recalculated signature does not match the signature attached to the mail, the email will be rejected.</p>&#13;
<p class="indent">To implement DKIM, you need to add a DomainKey in a <em>.txt</em> record to your domain. <a href="ch16.xhtml#ch16list2">Listing 16-2</a> shows an example.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_156"/>k=rsa;<span class="ent">❶</span> p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDmzRmJRQxLEuyYiyMg4suA<span class="ent">❷</span></p>&#13;
<p class="caption"><a id="ch16list2"/><em>Listing 16-2: A (public) domain key is hosted in the DNS system, and the corresponding private key needs to be shared with the application generating email for the domain.</em></p>&#13;
<p class="indent">In this example, <span class="literal">k</span> indicates the key type <span class="ent">❶</span>, and <span class="literal">p</span> is the public key used to recalculate the signature <span class="ent">❷</span>.</p>&#13;
<h4 class="h4" id="ch00lev1sec240"><strong><em>Securing Your Email: Practical Steps</em></strong></h4>&#13;
<p class="noindent">Your organization likely generates email from multiple locations. Email sent to a user in response to their actions on your website—called transactional email—will be triggered by your web server software, and often is generated via email services such as SendGrid or Mailgun. Email written by hand will be sent either by a webmail service (for example, Gmail) or from email server software hosted on your network (for example, Microsoft Exchange or Postfix). Your team may also be using email marketing or newsletter services such as Mailchimp or TinyLetter to send email.</p>&#13;
<p class="indent">Consult the documentation of your service providers or email server to see how to generate and add the DNS entries needed to implement SPF and DKIM. In fact, you may <em>already</em> be using DKIM, because many transactional email and marketing services require you to add the relevant DNS entries when you sign up to the service. As you lock down IP ranges and domains as part of your SPF implementation, remember to consider <em>all</em> the software that is sending email from your domain!</p>&#13;
<h3 class="h3" id="ch00lev1sec241"><strong>Disguising Malicious Links in Email</strong></h3>&#13;
<p class="noindent">Spam algorithms look for malicious links in email, and to support this, webmail providers keep up-to-date blacklists of domains that are known to be harmful. Scanning for links to such domains is a common and effective way to block dangerous email.</p>&#13;
<p class="indent">As such, scammers have had to come up with new tricks to disguise harmful links, to prevent their email from being flagged and sent directly to the junk folder. One way to do this is to use a URL-shortening service like Bitly, which will encode a URL in a shorter form and redirect the user when they visit the link. However, in the ever-escalating spam wars, email scanning algorithms now <em>unroll</em> links to known URL-shortening services and check whether the final destination is harmful.</p>&#13;
<p class="indent">Hackers have found a subtler way to disguise malicious links in email. If your website can be used to disguise a link to an arbitrary URL on the internet—if you implement an <em>open redirect</em> anywhere on your site—you may be helping hackers disguise malicious links in the same way as a URL-shortening service. Not only are you making your users vulnerable to phishing scams, but the <em>genuine</em> email you send is liable to be blacklisted by spam-detection algorithms.</p>&#13;
<h4 class="h4" id="ch00lev1sec242"><span epub:type="pagebreak" id="page_157"/><strong><em>Open Redirects</em></strong></h4>&#13;
<p class="noindent">In HTTP, a <em>redirect</em> occurs when a web server responds with a <span class="literal">301</span> (temporary redirect) or <span class="literal">302</span> (permanent redirect) response code, and supplies a URL that the browser should navigate to instead. One of the most common uses of redirects is to send an unauthenticated user to the login page if they attempt to visit a site. In this scenario, the site typically issues a second redirect <em>back</em> to the original URL after the user has authenticated themselves.</p>&#13;
<p class="indent">To enable this second redirect, the web server has to remember the original destination as the user logs in. Frequently, this is done by encoding the final destination URL within a query parameter in the login URL. If a hacker can encode an arbitrary URL in this query parameter—in other words, if the second redirect can send the user to a whole different website on the internet—you have what is known as an <em>open redirect</em>.</p>&#13;
<h4 class="h4" id="ch00lev1sec243"><strong><em>Preventing Open Redirects</em></strong></h4>&#13;
<p class="noindent">Most sites won’t ever need to redirect to an external URL. If any part of your website encodes a URL within another URL for the purpose of redirecting the user to that destination, you should make sure that these encoded URLs are <em>relative</em> URLs rather than <em>absolute</em> URLs: encoded links should point within your site, rather than externally.</p>&#13;
<p class="indent">Relative URLs begin with a forward slash (<em>/</em>), which is easy to check for. Hackers have found a few ways to disguise absolute URLs to look like relative URLs, so your code needs to account for that. <a href="ch16.xhtml#ch16list3">Listing 16-3</a> shows how to check that a URL is a relative URL via simple pattern-matching logic.</p>&#13;
<p class="programs">import re<br/>def is_relative(url):<br/>  return re.match(r"^\/[^\/\\]"<span class="ent">❶</span>, url)</p>&#13;
<p class="caption"><a id="ch16list3"/><em>Listing 16-3: A function to check that a link is relative (internal to a website), using a regular expression in Python</em></p>&#13;
<p class="indent">This pattern <span class="ent">❶</span> states that the URL must begin with a forward slash, and the following character must not be another forward slash or a backslash (<em>\</em>). The second character is checked to protect against URLs such as <em><a href="http://www.google.com">www.google.com</a></em>, which are interpreted by browsers as absolute URLs; they will be automatically prefixed by <em>http</em> or <em>https</em> depending on what protocol the page is currently using.</p>&#13;
<p class="indent">Another approach to preventing open redirects is to avoid encoding URLs within query parameters <em>altogether</em>. If you are encoding a URL for an eventual redirect following login, consider dropping the URL in a temporary cookie instead of a query parameter. An attacker is unable to forge a cookie in a victim’s browser quite as easily, so you will close the door to abusive linking.</p>&#13;
<h4 class="h4" id="ch00lev1sec244"><span epub:type="pagebreak" id="page_158"/><strong><em>Other Considerations</em></strong></h4>&#13;
<p class="noindent">Some types of websites do require external links to be posted by users. For instance, if you run a social news site, your users will often post links to external URLs. If this applies to your site, use the <em>Google Safe Browsing</em> API to check each URL against a blacklist of harmful sites.</p>&#13;
<p class="indent">After you have secured your email and redirect code, it’s important to make sure your web pages can’t be wrapped in other people’s malicious websites. Let’s look at how to protect your users against clickjacking attacks.</p>&#13;
<h3 class="h3" id="ch00lev1sec245"><strong>Clickjacking</strong></h3>&#13;
<p class="noindent">HTML permits a web page to contain another web page, by using an <span class="literal">&lt;iframe&gt;</span> tag. This allows content from different web domains to be mixed in a controlled fashion, because JavaScript running on the page within the frame cannot access the containing page. The <span class="literal">&lt;iframe&gt;</span> tags are commonly used to embed third-party content in a web page—OAuth and CAPTCHA widgets often use them to secure cookies.</p>&#13;
<p class="indent">As with anything useful on the internet, hackers have found ways to abuse <span class="literal">&lt;iframe&gt;</span> tags. Modern CSS allows page elements to be layered on top of each other using the <span class="literal">z-index</span> attribute; elements with a higher <span class="literal">z-index</span> will hide elements with a lower <span class="literal">z-index</span> and receive click events first. Page elements can also be made transparent using the <span class="literal">opacity</span> attribute. By combining these techniques, a hacker can position a transparent <span class="literal">&lt;div&gt;</span> over an <span class="literal">&lt;iframe&gt;</span> element, and then trick a victim into clicking whatever content is stored in the <span class="literal">&lt;div&gt;</span> rather than the underlying content they believe they are clicking.</p>&#13;
<p class="indent">This click-hijacking—<em>clickjacking</em>—has been used in a variety of ways. In some cases, victims have been tricked into switching on their webcam so the attacker can watch them remotely. Another variation of this technique is <em>likejacking</em>, whereby a victim is tricked into liking something on Facebook without their knowledge. Selling likes on the dark web for promotional purposes is a big money-spinner for a hacker.</p>&#13;
<h4 class="h4" id="ch00lev1sec246"><strong><em>Preventing Clickjacking</em></strong></h4>&#13;
<p class="noindent">If you run a website, you should make sure your site isn’t used as bait in a clickjacking attack. Most sites never need to be hosted in <span class="literal">&lt;iframe&gt;</span> tags, so you should tell the browser that directly. Modern browsers support the <span class="literal">Content-Security-Policy</span> header that allows the response from the server to specify that the page should have no <span class="literal">frame-ancestors</span>, as shown in <a href="ch16.xhtml#ch16list4">Listing 16-4</a>.</p>&#13;
<p class="programs">Content-Security-Policy: frame-ancestors 'none'</p>&#13;
<p class="caption"><a id="ch16list4"/><em>Listing 16-4: A header that tells the browser never to host your website in a frame</em></p>&#13;
<p class="indent">Implementing this policy tells the browser to never put your website in a frame.</p>&#13;
<p class="indent">If for some reason your site does need to be contained within an <span class="literal">&lt;iframe&gt;</span>, you should tell the browsers <em>which</em> sites are permitted to host such <span epub:type="pagebreak" id="page_159"/>a frame. You can do this by using the same <span class="literal">Content-Security-Policy</span> header to specify that the website can be its own frame ancestor. <a href="ch16.xhtml#ch16list5">Listing 16-5</a> shows how to use the keyword <span class="literal">self</span> to permit your site to host iframes pointing to other parts of the same site.</p>&#13;
<p class="programs">Content-Security-Policy: frame-ancestors 'self'</p>&#13;
<p class="caption"><a id="ch16list5"/><em>Listing 16-5: A header that permits a site to host iframes of itself</em></p>&#13;
<p class="indent">Finally, if you need third-party websites to be able to host your site in a frame, you can whitelist individual web domains, as shown in <a href="ch16.xhtml#ch16list6">Listing 16-6</a>.</p>&#13;
<p class="programs">Content-Security-Policy: frame-ancestors example.com google.com</p>&#13;
<p class="caption"><a id="ch16list6"/><em>Listing 16-6: A header that permits a site to be hosted in an iframe by</em> <a href="http://example.com">example.com</a> <em>and</em> <a href="http://google.com">google.com</a></p>&#13;
<p class="indent">Now that you’ve looked at how to protect against clickjacking, let’s see how attackers will try to launch malicious network requests from your server.</p>&#13;
<h3 class="h3" id="ch00lev1sec247"><strong>Server-Side Request Forgery</strong></h3>&#13;
<p class="noindent">Hackers making malicious HTTP requests often seek to disguise where those requests are launched from. For instance, denial-of-service attacks—covered in the next chapter—are more effective when coming from many different IP addresses. If your web server makes outgoing HTTP requests, and a hacker can control which URLs those requests are sent to, you are vulnerable to a server-side request forgery (SSRF) attack, and a hacker can use your server to send malicious requests.</p>&#13;
<p class="indent">There are some legitimate reasons to make outbound network requests from your server. If you use any kind of third-party API, these are typically made available as web services over HTTPS. You might, for example, use server-side APIs to send transactional email, index content for searching, record unexpected errors in an error-reporting system, or process payments. Problems occur, however, when an attacker is able to manipulate the server into calling a URL of their choosing.</p>&#13;
<p class="indent">Typically, SSRF vulnerabilities occur when the outbound URL of an HTTP request sent <em>from</em> the web server is insecurely constructed from a part of an HTTP request sent <em>to</em> the server. A hacker will check a site for SSRF vulnerabilities by <em>spidering</em> through it, navigating to every page, and using hacking tools to replace every HTTP parameter they encounter with a URL under their control. If they detect any HTTP requests to their trap URL, they know the requests must have been triggered from your server, and that you are vulnerable to SSRF.</p>&#13;
<p class="indent">Hackers will also check to see if any part of your site accepts XML content, and use XML external entity attacks in an attempt to commit SSRF. <a href="ch15.xhtml#ch15">Chapter 15</a> discussed this attack vector.</p>&#13;
<h4 class="h4" id="ch00lev1sec248"><span epub:type="pagebreak" id="page_160"/><strong><em>Protecting Against Server-Side Forgery</em></strong></h4>&#13;
<p class="noindent">You can protect yourself against server-side forgery at several levels. The first, and most important step, is to audit any parts of your code that make outbound HTTP requests. You will almost always know ahead of time which domains need to be invoked as part of API calls, so the construction of URLs for API calls should use web domains recorded in your configuration or code rather than coming from the client. One way of ensuring this is to use the <em>software development kit (SDK)</em> that is usually made freely available with most APIs.</p>&#13;
<p class="indent">Because you should be following the practice of defense in depth—protecting yourself from vulnerabilities in multiple, overlapping ways—it makes sense to install safeguards against SSRF at the network level too. Whitelisting the individual domains that you need access to in your firewall, and banning all others, is a good way to catch any security issues you may have overlooked during code review.</p>&#13;
<p class="indent">Finally, consider employing penetration testing to detect SSRF vulnerabilities in your code. This can be done by employing an external team to find vulnerabilities in your website or by using an automated online tool to do the same. Effectively, you will be using the same tools that hackers use to detect vulnerabilities, before they get the chance to do so themselves.</p>&#13;
<h3 class="h3" id="ch00lev1sec249"><strong>Botnets</strong></h3>&#13;
<p class="noindent">Hackers are always looking for spare computing power to power their attacks. If a hacker manages to compromise your server, they will frequently install a <em>bot</em>—a piece of malware that they can control using remote commands. Most bots operate as part of a peer-to-peer network of individual bots—a <em>botnet</em>—that communicate with each other by using an encrypted protocol.</p>&#13;
<p class="indent">Bots are often used to infect regular consumer devices like laptops. Managing to install a bot on a server is big prize, however, because significantly more computing power will be available to the bot. Scammers will pay a good price on the dark web for access keys that allow them to control botnets. They commonly use this spare computing power to mine bitcoin or commit <em>click fraud</em>—that is, artificially inflate page-view numbers of websites. Botnets are also used to generate spam email or to commit denial-of-service attacks (covered in the next chapter).</p>&#13;
<h4 class="h4" id="ch00lev1sec250"><strong><em>Protecting Against Malware Infection</em></strong></h4>&#13;
<p class="noindent">Clearly, you want to avoid having any bot malware installed on the server. <a href="ch06.xhtml#ch06">Chapter 6</a> discussed command injection and file upload vulnerabilities that could allow a hacker to install a bot on your server. Make sure you follow that chapter’s advice to secure such vulnerabilities.</p>&#13;
<p class="indent">Additionally, you should also proactively protect your servers from infections. Running up-to-date antivirus software will help you quickly spot any kind of malware. Monitoring your outgoing network access will highlight suspicious activity: installed bots will periodically poll other IPs <span epub:type="pagebreak" id="page_161"/>looking for other bots. You should also consider running an <em>integrity checker</em> on your web servers—a piece of software that checks for unexpected file changes on sensitive directories.</p>&#13;
<p class="indent">If you are using virtualized services or containers, you have an advantage here: any rebuild of the system will typically wipe away malicious software that was installed. Rebuilding from an image periodically will do a lot to keep your system safe from bot infestations.</p>&#13;
<h3 class="h3" id="ch00lev1sec251"><strong>Summary</strong></h3>&#13;
<p class="noindent">Avoid being an accessory to attacks on others on the internet by doing the following:</p>&#13;
<ul>&#13;
<li><p class="noindent">Protect the email you send by implementing SPF and DKIM headers in your domain name records.</p></li>&#13;
<li><p class="noindent">Make sure you have no open redirects on your site.</p></li>&#13;
<li><p class="noindent">Prevent your site from being hosted in an <span class="literal">&lt;iframe&gt;</span> tag by setting a content security policy.</p></li>&#13;
<li><p class="noindent">Audit your code to ensure that the server cannot be tricked into sending HTTP requests to an external URL of an attacker’s choosing, and whitelist outbound network access to avoid being used in server-side request forgery attacks.</p></li>&#13;
<li><p class="noindent">Use virtualized servers, virus scanners, or vulnerability scanning tools to check for and remove bots.</p></li>&#13;
</ul>&#13;
<p class="indent">In the next chapter, you will look at a brute-force technique that hackers can use to take your web server offline: the denial-of-service attack.<span epub:type="pagebreak" id="page_162"/></p>&#13;
</div>



  </body></html>