- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    CANVAS ELEMENT</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the more interactive elements in HTML is the canvas element. This element
    acts like a painter’s canvas: it provides space for you to draw images within
    the browser window using JavaScript. What’s more, by repeatedly erasing old images
    and drawing new ones, you can create animations on the canvas. In this sense,
    the canvas element is more like the screen at a movie theater, where the image
    is updated many times every second to create the appearance of motion.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you’ll learn how to create canvas elements and how to use the
    Canvas API, which gives you a way to manipulate the canvas via JavaScript. You’ll
    write JavaScript to draw static images to the canvas. Then you’ll build a simple
    interactive drawing application. Finally, you’ll learn the basics of creating
    2D animations on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a Canvas</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To include a canvas element on a web page, you add it to the body element in
    the page’s *index.html* file. All you need are the opening and closing HTML tags,
    <canvas></canvas>, as the canvas element doesn’t have any required attributes.
    However, it’s a good idea to give the canvas an id, so you can easily access it
    using JavaScript. It’s also common to set the element’s width and height attributes
    so you can establish the size of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Images that appear in the canvas are generated using JavaScript, not HTML. Any
    HTML between the opening and closing tags will appear only if the browser doesn’t
    support the canvas element, so this can be used as a fallback for older or text-only
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an HTML file that includes a canvas element. We’ll also include
    a script element linking to a JavaScript file, where we’ll write code to generate
    images on the canvas. We’ll use the same HTML file throughout the chapter to draw
    different kinds of images. Create a new directory called *chapter9*, and make
    a new file in that directory called *index.html*. Enter the content shown in [Listing
    9-1](#Lis9-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: An</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    with a canvas element</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This is our familiar HTML template, similar to the *index.html* files we’ve
    created in previous chapters, but with a canvas element instead of an h1 element.
    The width and height attributes specify the size of the canvas in pixels. By default,
    the canvas is transparent, so you won’t actually see anything yet if you load
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Making Static Drawings</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a canvas element, we’re ready to draw on it using JavaScript
    and the Canvas API. We’ll start by drawing a solid rectangle. Then we’ll look
    at how to create other static drawings. Create a new file called *script.js* in
    the *chapter9* directory, and enter the code shown in [Listing 9-2](#Lis9-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: Drawing a rectangle
    in</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we get a reference to the canvas element using the document .querySelector
    method. The canvas element has a method called getContext, which we use to get
    the canvas’s *drawing context*. The drawing context is an object that provides
    the entire Canvas API as a set of methods and properties (like fillRect and fillStyle,
    respectively, both used in [Listing 9-2](#Lis9-2)). These methods and properties
    are what we’ll use to draw images on the canvas. In this case, we pass the string
    "2d" to the getContext method to request the two-dimensional drawing context.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can draw 3D graphics on the canvas by passing the string "webgl" or "webgpu"
    to the getContext method instead of "2d", but both of those are much more complicated
    than 2D graphics and are outside the scope of this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we tell the drawing context that we want the fill color for new elements
    to be blue, using the fillStyle property. Finally, we draw a filled rectangle
    using the current fill color with the fillRect method. This method takes four
    arguments: the x- and y-coordinates of the top-left corner of the rectangle, and
    the width and height of the rectangle in pixels. The coordinates work the same
    way as the coordinates for the whole browser window: x values increase as you
    move from left to right across the canvas, and y values increase from top to bottom,
    with (0, 0) representing the top-left corner of the canvas.'
  prefs: []
  type: TYPE_NORMAL
- en: Open *index.html* in your browser. You should see a solid blue rectangle, as
    shown in [Figure 9-1](chapter9.xhtml#fig9-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_9-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: The blue rectangle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Any subsequent calls to fillRect will use the same fillStyle, so they’ll also
    produce blue rectangles (until you set a new fillStyle, that is). You can confirm
    this by drawing some more rectangles to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing Outlined
    Rectangles</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As well as fillRect for making a rectangle filled with a color, the Canvas API
    provides the strokeRect method for outlining (*stroking*) a rectangle. To try
    it out, modify *script.js* as shown in [Listing 9-3](#Lis9-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: Using</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">strokeRect to outline a rectangle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we specify the width of the outline with the lineWidth property, setting
    it to 2 pixels wide. Then we use strokeStyle and strokeRect, rather than fillStyle
    and fillRect, to create an outlined rectangle with no fill color. The strokeRect
    method takes the same arguments as fillRect: the x- and y-coordinates of the top-left
    corner, and the width and height of the rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: When you reload *index.html*, you should see the rectangle is now outlined in
    red, with no fill, as shown in [Figure 9-2](chapter9.xhtml#fig9-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_9-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: A red-outlined
    rectangle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When you set styles on the drawing context, such as the line width or line color,
    those settings apply only to subsequent additions to the canvas. That is, they
    don’t retroactively affect anything that’s already been drawn. In this sense,
    the canvas really is very much like a physical canvas, where the current style
    is determined by the color of paint and type of brush you’re using at the moment.
    To demonstrate, we’ll draw several rectangles with different colors. Add the code
    in [Listing 9-4](#Lis9-4) to the end of *script.js*, after the code for drawing
    the red rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-4: Drawing more rectangles</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code draws a series of nested rectangles, each offset by 10 pixels from
    the previous one and each 20 pixels smaller than the previous one. Before we draw
    each successive rectangle, we change the color of the outline by updating the
    strokeStyle property.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh *index.html*, and you should see something like the image in [Figure
    9-3](chapter9.xhtml#fig9-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_9-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: Concentric rectangles</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each rectangle is a different color, indicating that the style changes didn’t
    impact anything that had already been drawn.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing Other Shapes
    Using Paths</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All other shapes besides rectangles are drawn on the canvas as *paths*. A path
    is a series of points connected by straight or curved lines, and then either stroked
    with an outline or filled in with a color. As an example, we’ll draw a path between
    three different points and then fill it in to make a red triangle. Replace the
    contents of *script.js* with the code in [Listing 9-5](#Lis9-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-5: Drawing a triangle
    with path methods</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a path takes three steps. First, you declare that you want to start
    drawing a new path with beginPath. Then, you use various methods to define where
    the path will be. Finally, you use fill or stroke to fill or stroke the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we use two different methods to define the path: moveTo and lineTo.
    The moveTo method moves an imaginary pen to a particular point on the canvas defined
    by x- and y-coordinates, without drawing a line. We use this method to define
    the starting point of our path, (100, 100), which will be the bottom-left corner
    of the triangle. The lineTo method does the same as moveTo, but it draws a line
    as it moves. Thus, lineTo(150, 15) draws a line from (100, 100) to (150, 15),
    and so on. Finally, we fill the shape with the fill method. When you refresh the
    page, you should see a red triangle, as shown in [Figure 9-4](chapter9.xhtml#fig9-4).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_9-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: Drawing a filled
    triangle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing circles follows a similar pattern, but uses a method called arc instead
    of moveTo and lineTo. The arc method draws an *arc*, a section of the circumference
    of a circle. You can produce any length of arc with the arc method, but here we’ll
    use it to produce an entire circle.
  prefs: []
  type: TYPE_NORMAL
- en: Update *script.js* with the code in [Listing 9-6](#Lis9-6). The first and third
    steps of the path drawing code are the same, but we replace the second step with
    the code for drawing a circle rather than a triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-6: Drawing a circle
    with path methods</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The arc method takes a whopping six arguments. The first two are the x- and
    y-coordinates of the center of the circle. In this case we’re centering the circle
    at the coordinates (150, 100). The third argument is the circle’s radius in pixels,
    which we set to 50. The next two arguments give the starting and ending angles
    of the arc in radians: we provide 0 for the starting angle and Math.PI * 2 for
    the ending angle to produce a full circle. The final argument specifies whether
    the arc should be drawn clockwise (false) or counterclockwise (true) from the
    starting angle to the ending angle. In this case, we pick clockwise, but since
    we’re drawing a full circle, the direction is irrelevant.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Radians *are a way of measuring angles. In degrees, a full revolution of a circle
    goes from 0 to 360\. In radians, a revolution goes from 0 to 2π.*
  prefs: []
  type: TYPE_NORMAL
- en: When you refresh the page now, you should see a red circle, as shown in [Figure
    9-5](chapter9.xhtml#fig9-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_9-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: Drawing a filled
    circle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same technique to draw a stroked circle instead by using the
    stroke method rather than the fill method. What’s more, you can make compound
    shapes like rounded rectangles by combining calls to the lineTo and arc methods.
    The Canvas API also allows for drawing more complex curves with the quadraticCurveTo
    and bezierCurveTo methods. Search the Mozilla Developer Network (MDN) Web Docs
    ([*https://<wbr>developer<wbr>.mozilla<wbr>.org*](https://developer.mozilla.org))
    for more details about these other methods.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Interacting with the Canvas</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The canvas gets a lot more interesting when the user can interact with it. The
    canvas element itself doesn’t have any notion of interactivity built in. However,
    we can add that interactivity with JavaScript by writing event handlers that listen
    for certain user actions and trigger Canvas API methods that update the canvas
    in response.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll build a very basic drawing application using a canvas
    element with a click handler. The handler will listen for clicks on the canvas,
    and call a method that draws a circle at the position where the click happened.
    We’ll also create a slider so the user can set the opacity of the circles, and
    a button to clear the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s add the necessary HTML elements to create a slider and a button.
    Make the modifications shown in [Listing 9-7](#Lis9-7) to *index.html*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-7: Adding some additional
    elements to</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here we add a new div element containing three other HTML elements. The div
    element is there to group the elements inside it together and to position them
    below the canvas (without the div they’d appear to the right of the canvas).
  prefs: []
  type: TYPE_NORMAL
- en: The first element inside the div is a button element. It creates a clickable
    button. Any content between the opening and closing tags will appear as text on
    the button, so our button will have the text *Clear*. Later, we’ll write a JavaScript
    function that clears any circles on the canvas when the user clicks the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next inside the div is an input element, which is used for taking values from
    the user. The input element doesn’t allow any child elements, so it doesn’t need
    a closing tag. In this case the input is of type range, which means it will display
    as a slider. This slider will be used to set the opacity of new circles drawn
    on the canvas. It has several attributes defining its functionality: min defines
    the minimum value the slider will produce, max defines the maximum value, value
    defines the initial value the slider is set to, and step is the size of each movement
    (enabling you to control the number of allowed values). This slider is set to
    range from 0 to 1 in steps of 0.1, and it starts at 1, which corresponds to full
    opacity.'
  prefs: []
  type: TYPE_NORMAL
- en: The last element in the div is a label element, which applies a label to another
    element. The for attribute of the label determines which element the label should
    be applied to; its value has to match the id of another element. In this case,
    we assign the label to the slider by specifying opacity as the target id. This
    will cause the slider to be labeled *Opacity*, which is the text content of the
    label element. Thanks to the label element’s for attribute, the browser understands
    that the label and input elements are related, and certain actions performed on
    the label will apply to the input. For example, if you hover over the label, the
    input will display as hovered, and if you click the label, the input will get
    keyboard focus (in this case, pressing the left or right arrow key will decrease
    or increase the value of the slider, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: Load *index.html* in your browser, and you should see something similar to [Figure
    9-6](chapter9.xhtml#fig9-6) (the exact appearance of these elements may vary depending
    on your browser and operating system).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_9-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: The new button
    and input elements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the HTML elements, we can write the JavaScript that will make
    this application interactive. First, we’ll add some general declarations and the
    code for drawing circles when the user clicks on the canvas. Update *script.js*
    with the code shown in [Listing 9-8](#Lis9-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-8: Drawing a circle
    on click</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First we store the width and height of the canvas element in two variables,
    width and height. We’ll need these variables later, in our function for clearing
    the canvas. The width and height properties of the JavaScript canvas object come
    straight from the HTML canvas element’s width and height properties (which are
    both set to 300 in *index.html*). We also initialize the variable opacity to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a helper function called drawCircle. This function takes an
    x- and a y-coordinate and draws a filled circle at that location. We use the same
    path drawing methods demonstrated in [Listing 9-6](#Lis9-6) to draw the circle.
    The x and y parameters determine the circle’s center, and we set its radius to
    10 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: One key difference from the previous drawing examples is that we’re setting
    fillStyle to an *RGBA* color instead of a named color like "red" or "blue" ❶.
    RGBA is a way of defining colors using four numbers corresponding to the red,
    green, blue, and alpha channels. The first three indicate the amount of each primary
    color of light. Their values can range from 0 to 255, and they can be combined
    to produce any color you might want. Setting all three to 0 produces black, and
    setting all three to 255 produces white. *Alpha* is another word for opacity,
    and it defines how opaque or transparent the color should be, ranging from 0 (completely
    transparent) to 1 (completely opaque).
  prefs: []
  type: TYPE_NORMAL
- en: In the Canvas API, you set RGBA colors using the string "rgba(…)" with the four
    values in the parentheses, separated by commas. For example, setting fillStyle
    to the string "rgba(0, 255, 0, 0.9)" would make bright green circles that are
    slightly transparent. In our case, we wrap the RGBA string in backticks so we
    can use a placeholder for the alpha value to allow the user to change the opacity
    with the slider.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we add a click event handler to the canvas element using add EventListener.
    The handler calls the drawCircle function we just created, passing the offsetX
    and offsetY properties of the click event as the function’s parameters. The offsetX
    and offsetY properties give the distance of the click event from the top-left
    corner of the clicked element itself (rather than from the top-left corner of
    the whole browser window), so they’re ideal for determining exactly where on the
    canvas the click happened.
  prefs: []
  type: TYPE_NORMAL
- en: Reload *index.html* in your browser and try clicking on the canvas. Wherever
    you click, a small green circle should appear, as shown in [Figure 9-7](chapter9.xhtml#fig9-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_9-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: Drawing green circles
    with mouse clicks</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To complete the drawing application, we need to wire up the Clear button and
    the Opacity slider. Add the code in [Listing 9-9](#Lis9-9) to the end of *script.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-9: Wiring up the
    Clear and Opacity controls</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First we add a click event handler to the Clear button. This calls a Canvas
    API method called clearRect, which clears a rectangular section of the canvas.
    Just like when drawing a rectangle, you define the rectangle to be cleared using
    the x- and y-coordinates of its top-left corner, followed by its width and height.
    Here we use (0, 0, width, height) to specify that we want to clear a rectangle
    that starts at the top-left corner of the canvas and is as wide and high as the
    canvas itself. Thus, ctx.clearRect(0, 0, width, height); clears the entire canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add a change event handler to the Opacity slider. The change event
    is triggered on input elements when their value changes, so this handler will
    be called whenever the slider is set to a new position. We get the input element
    with e.target and get the element’s current value with .value. Then we update
    the opacity variable with this value. Because the drawCircle function uses the
    value of opacity as the alpha component of the RGBA color, any new circles will
    use the latest value set with the Opacity slider.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you reload *index.html* in your browser, you should have a fully functioning
    (if basic) drawing application! You can use the Opacity slider to change the opacity
    of new circles and the Clear button to clear the canvas and start drawing again.
    Try drawing overlapping circles with the Opacity slider set halfway to see how
    they overlay.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Animating the Canvas</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted at the beginning of this chapter, you can animate the canvas by drawing
    on it and updating the image multiple times per second. In this section, we’ll
    code a very simple animation to show the basics of how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Animating the canvas generally follows this basic pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Update state
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Clear canvas
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Draw image
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Wait a short time
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Repeat
  prefs: []
  type: TYPE_NORMAL
- en: '*State* here means some variable(s) storing information about the current frame
    of the animation. This could be the current location of an object in motion, the
    direction the object is moving in, and so on. In our example, the state will be
    the x- and y-coordinates of a circle. When it’s time to update the state, we’ll
    increment the x- and y-coordinates by 1, meaning that the circle’s position will
    gradually move diagonally down and to the right. Drawing the image will entail
    drawing a small circle centered at the updated x- and y-coordinates. We clear
    the canvas before drawing the circle to ensure that the image from the previous
    cycle is removed. We’ll tackle the last two steps (waiting and repeating) by using
    the setInterval function to call our code every 100 ms, or 10 times a second.'
  prefs: []
  type: TYPE_NORMAL
- en: We can continue to work with the same HTML and JavaScript files. The only change
    to make to *index.html* is to remove the div and its nested elements that we added
    in [Listing 9-7](#Lis9-7), as they’re not needed anymore. After removing those
    elements, update *script.js* based on the code in [Listing 9-10](#Lis9-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-10: Creating an animation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We create two new variables, x and y, representing the location of the circle
    that we’ll animate. These variables store the current state of the animation and
    will be updated at regular intervals. The drawCircle function itself is mostly
    unchanged, although the fillStyle is different. Now that we’re not setting an
    opacity, we can use the simpler rgb(…)-format string for setting the red, green,
    and blue values. With "rgb(…)", the opacity of the color is always 100 percent.
  prefs: []
  type: TYPE_NORMAL
- en: After drawCircle we declare the update function, where we update the x and y
    variables, incrementing each by 1. Next we declare the draw function, which clears
    the canvas and then calls drawCircle to draw a circle at the current x- and y-coordinates.
    Finally, we call setInterval to orchestrate the animation. You may recall from
    [Chapter 5](chapter5.xhtml) that setInterval takes a function and a time interval
    in milliseconds, and repeatedly calls that function once every time interval.
    Here we’re calling an anonymous function every 100 ms. The anonymous function
    itself calls update and draw to create each frame of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Reload *index.html* in your browser, and you should see a small circle gradually
    move across the canvas from the top-left to the bottom-right corner. Even after
    the circle leaves the canvas, the x- and y-coordinates will keep increasing, but
    the canvas ignores anything drawn outside of its bounds.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of drawing on the canvas element, as
    well as some techniques for creating interactive applications and animations using
    the canvas. We’ll build on some of these techniques later in this book as we learn
    how to make a canvas-based game.
  prefs: []
  type: TYPE_NORMAL
