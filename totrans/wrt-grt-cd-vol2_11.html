<html><head></head><body>
		<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_331"/><strong><span class="big">11</span></strong><br/><strong>RECORD, UNION, AND CLASS DATA TYPES</strong></h2>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">Records, unions, and classes are popular composite data types found in many modern programming languages. Incorrectly used, these data types can have a very negative impact on the performance of your software. Correctly used, however, they can actually improve the performance of your applications (compared with using alternative data structures). In this chapter we’ll explore how you can make the most of these data types to maximize the efficiency of your programs. The topics this chapter covers include:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Definitions for the record, union, and class data types</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Declaration syntax for records, unions, and classes in various languages</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Record variables and instantiation</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Compile-time initialization of records</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Memory representation of record, union, and class data</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Using records to improve runtime memory performance</p>&#13;
				</li>&#13;
			<li><span epub:type="pagebreak" id="page_332"/>&#13;
			<p class="noindent">Dynamic record types</p>&#13;
			</li>&#13;
			<li>&#13;
				<p class="noindent">Namespaces</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Variant data types and their implementation as a union</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Virtual method tables for classes and their implementation</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Inheritance and polymorphism in classes</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">The performance cost associated with classes and objects</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Before we get into the details of how you can implement these data types to produce code that is more efficient, easier to read, and easier to maintain, let’s begin with some definitions.</p>&#13;
		<h3 class="h3" id="ch00lev1sec92"><strong>11.1 Records</strong></h3>&#13;
		<p class="noindent">The Pascal <em>record</em> and the C/C++ <em>structure</em> are terms used to describe comparable composite data structures. Language design textbooks sometimes refer to these types as <em>Cartesian products</em> or <em>tuples</em>. The Pascal terminology is probably best, because it avoids confusion with the term <em>data structure</em>, so we’ll use <em>record</em> here. Regardless of what you call them, records are a great tool for organizing your application data, and a good understanding of how languages implement them will help you write more efficient code.</p>&#13;
		<p class="indent">An array is <em>homogeneous</em>, meaning that its elements are all of the same type. A record, on the other hand, is <em>heterogeneous</em>—its elements can have differing types. The purpose of a record is to let you encapsulate logically related values into a single object.</p>&#13;
		<p class="indent">Arrays let you select a particular element via an integer index. With records, you must select an element, known as a <em>field</em>, by the field’s name. Each of the field names within the record must be unique; that is, you can’t use the same name more than once in the same record. However, all field names are local to their record, so you may reuse those names elsewhere in the program.<sup><a id="ch11fn_1"/><a href="footnotes.xhtml#ch11fn1">1</a></sup></p>&#13;
		<h4 class="h4" id="ch00lev2sec128"><strong>11.1.1 Declaring Records in Various Languages</strong></h4>&#13;
		<p class="noindent">Before discussing how various languages implement record data types, we’ll take a quick look at the declaration syntax for some of them, including Pascal, C/C++/C#, Swift, and HLA.</p>&#13;
		<h5 class="h5" id="ch00lev3sec65"><strong>11.1.1.1 Record Declarations in Pascal/Delphi</strong></h5>&#13;
		<p class="noindent">Here’s a typical record declaration for a <span class="literal">student</span> data type in Pascal/Delphi:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    student =<br/>        record<br/>            Name:     string [64];<br/><span epub:type="pagebreak" id="page_333"/>            Major:    smallint;    // 2-byte integer in Delphi<br/>            SSN:      string[11];<br/>            Mid1:     smallint;<br/>            Mid2:     smallint;<br/>            Final:    smallint;<br/>            Homework: smallint;<br/>            Projects: smallint;<br/>        end;</pre>&#13;
		<p class="indent">A record declaration consists of the keyword <span class="literal">record</span>, followed by a sequence of <em>field declarations</em>, and ending with the keyword <span class="literal">end</span>. The field declarations are syntactically identical to variable declarations in the Pascal language.</p>&#13;
		<p class="indent">Many Pascal compilers allocate all of the fields in contiguous memory locations. This means that Pascal will reserve the first 65 bytes for the name,<sup><a id="ch11fn_2"/><a href="footnotes.xhtml#ch11fn2">2</a></sup> the next 2 bytes hold the major code, the next 12 bytes the Social Security number, and so on.</p>&#13;
		<h5 class="h5" id="ch00lev3sec66"><strong>11.1.1.2 Record Declarations in C/C++</strong></h5>&#13;
		<p class="noindent">Here’s the same declaration in C/C++:</p>&#13;
		<pre class="programs">&#13;
			typedef<br/>    struct<br/>    {<br/>        // Room for a 64-character zero-terminated string:<br/><br/>        char Name[65];<br/><br/>        // Typically a 2-byte integer in C/C++:<br/><br/>        short Major;<br/><br/>        // Room for an 11-character zero-terminated string:<br/><br/>        char SSN[12];<br/><br/>        short Mid1;<br/>        short Mid2;<br/>        short Final;<br/>        short Homework;<br/>        short Projects;<br/><br/>    } student;</pre>&#13;
		<p class="indent">Record (structure) declarations in C/C++ begin with the keyword <span class="literal">typedef</span> followed by the <span class="literal">struct</span> keyword, a set of <em>field declarations</em> enclosed by a pair of braces, and a structure name. As with Pascal, most C/C++ compilers assign memory offsets to the fields in the order of their declaration in the record.</p>&#13;
		<h5 class="h5" id="ch00lev3sec67"><span epub:type="pagebreak" id="page_334"/><strong>11.1.1.3 Record Declarations in C#</strong></h5>&#13;
		<p class="noindent">C# structure declarations are very similar to C/C++:</p>&#13;
		<pre class="programs">&#13;
			struct student<br/> {<br/>    // Room for a 64-character zero-terminated string:<br/><br/>    public char[] Name;<br/><br/>    // Typically a 2-byte integer in C/C++:<br/><br/>    public short Major;<br/><br/>    // Room for an 11-character zero-terminated string:<br/><br/>    public char[] SSN;<br/><br/>    public short Mid1;<br/>    public short Mid2;<br/>    public short Final;<br/>    public short Homework;<br/>    public short Projects;<br/> };</pre>&#13;
		<p class="indent">Record (structure) declarations in C# begin with the keyword <span class="literal">struct</span>, a structure name, and a set of <em>field declarations</em> enclosed by a pair of braces. As with Pascal, most C# compilers assign memory offsets to the fields in the order of their declaration in the record.</p>&#13;
		<p class="indent">This example defines the <span class="literal">Name</span> and <span class="literal">SSN</span> fields as arrays of characters in order to match the other record declaration examples in this chapter. In an actual C# program you’d probably want to use the <span class="literal">string</span> data type rather than an array of characters for these fields. However, keep in mind that C# uses dynamically allocated arrays; thus, the memory layout for the C# structure will differ from those for C/C++, Pascal, and HLA.</p>&#13;
		<h5 class="h5" id="ch00lev3sec68"><strong>11.1.1.4 Record Declarations in Java</strong></h5>&#13;
		<p class="noindent">Java doesn’t support a pure record, but class declarations with only data members serve the same purpose (see the section “Class Declarations in C# and Java” on <a href="ch11.xhtml#page_366">page 366</a>).</p>&#13;
		<h5 class="h5" id="ch00lev3sec69"><strong>11.1.1.5 Record Declarations in HLA</strong></h5>&#13;
		<p class="noindent">In HLA, you can create record types using the <span class="literal">record</span>/<span class="literal">endrecord</span> declaration. You would encode the record from the previous sections as follows:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    student:<br/>        record<br/>            sName:    char[65];<br/>            Major:    int16;<br/><span epub:type="pagebreak" id="page_335"/>            SSN:      char[12];<br/>            Mid1:     int16;<br/>            Mid2:     int16;<br/>            Final:    int16;<br/>            Homework: int16;<br/>            Projects: int16;<br/>        endrecord;</pre>&#13;
		<p class="indent">As you can see, the HLA declaration is very similar to the Pascal declaration. Note that, to stay consistent with the Pascal declaration, this example uses character arrays rather than strings for the <span class="literal">sName</span> and <span class="literal">SSN</span> (Social Security number) fields. In a typical HLA record declaration, you’d probably use a <span class="literal">string</span> type for at least the <span class="literal">sName</span> field (keeping in mind that a string variable is only a 4-byte pointer).</p>&#13;
		<h5 class="h5" id="ch00lev3sec70"><strong>11.1.1.6 Record (Tuple) Declarations in Swift</strong></h5>&#13;
		<p class="noindent">Although Swift does not support the concept of a record, you can simulate one using a Swift <em>tuple</em>. Tuples are a useful construct for creating a composite/aggregate data type without the overhead of a class. (Note, however, that Swift does not store record/tuple elements in memory in the same manner as other programming languages.)</p>&#13;
		<p class="indent">A Swift tuple is simply a list of values. Syntactically, a tuple takes the following form:</p>&#13;
		<pre class="programs">&#13;
			( <span class="codeitalic1">value<sub>1</sub></span>, <span class="codeitalic1">value<sub>2</sub></span>, ..., <span class="codeitalic1">value<sub>n</sub></span> )</pre>&#13;
		<p class="indent">The types of the values within the tuple don’t have to be identical.</p>&#13;
		<p class="indent">Swift typically uses tuples to return multiple values from functions. Consider the following short Swift code fragment:</p>&#13;
		<pre class="programs">&#13;
			func returns3Ints()-&gt;(Int, Int, Int )<br/>{<br/>    return(1, 2, 3)<br/>}<br/>var (r1, r2, r3) = returns3Ints();<br/>print( r1, r2, r3 )</pre>&#13;
		<p class="indent">The <span class="literal">returns3Ints</span> function returns three values (<span class="literal">1</span>, <span class="literal">2</span>, and <span class="literal">3</span>). The statement</p>&#13;
		<pre class="programs">var (r1, r2, r3) = returns3Ints();</pre>&#13;
		<p class="indent">stores those three integer values into <span class="literal">r1</span>, <span class="literal">r2</span>, and <span class="literal">r3</span>, respectively.</p>&#13;
		<p class="indent">You can also assign tuples to a single variable and access “fields” of the tuple using integer indexes as the field names:</p>&#13;
		<pre class="programs">&#13;
			let rTuple = ( "a", "b", "c" )<br/>print( rTuple.0, rTuple.1, rTuple.2 ) // Prints "a b c"</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_336"/>Using field names like <span class="literal">.0</span> is inadvisable, as it results in hard-to-maintain code. You can create records out of tuples, but referring to the fields using integer indices is rarely suitable in real-world programs.</p>&#13;
		<p class="indent">Fortunately, Swift allows you to assign labels to tuple fields and refer to those fields by the label name rather than an integer index, via the <span class="literal">typealias</span> keyword:</p>&#13;
		<pre class="programs">&#13;
			typealias record = ( field1:Int, field2:Int, field3:Float64 )<br/><br/>var r = record(1, 2, 3.0 )<br/>print( r.field1, r.field2, r.field3 )  // prints "1 2 3.0"</pre>&#13;
		<p class="indent">Keep in mind that the storage of the tuple in memory might not map to the same layout as a record or structure in other languages. Like arrays in Swift, tuples are an opaque type, without a guaranteed definition of how Swift will store them in memory.</p>&#13;
		<h4 class="h4" id="ch00lev2sec129"><strong>11.1.2 Instantiating a Record</strong></h4>&#13;
		<p class="noindent">Generally, a record declaration does not reserve storage for a record object; instead, it specifies a data type that you can use as a template when declaring record variables. <em>Instantiation</em> refers to this process of using a record template, or type, to create a record variable.</p>&#13;
		<p class="indent">Consider the HLA type declaration for <span class="literal">student</span> from the previous section. This type declaration doesn’t allocate any storage for a record variable; it simply provides the structure for the record object to use. To create an actual <span class="literal">student</span> variable, you must set aside some storage for the record variable, either at compile time or at runtime. In HLA, you can set aside storage for a <span class="literal">student</span> object at compile time by using variable declarations such as:</p>&#13;
		<pre class="programs">&#13;
			var<br/>    automaticStudent :student;<br/><br/>static<br/>    staticStudent :student;</pre>&#13;
		<p class="indent">The <span class="literal">var</span> declaration tells HLA to reserve sufficient storage for a <span class="literal">student</span> object in the current activation record when the program enters the current procedure. The <span class="literal">static</span> statement tells HLA to reserve sufficient storage for a <span class="literal">student</span> object in the static data section; this is done at compilation time.</p>&#13;
		<p class="indent">You can also allocate storage for a record object dynamically using memory allocation functions. For example, in the C language you can use <span class="literal">malloc()</span>to allocate storage for a <span class="literal">student</span> object like so:</p>&#13;
		<pre class="programs">&#13;
			student *ptrToStudent;<br/>        .<br/>        .<br/>        .<br/>    ptrToStudent = malloc( sizeof( student ));</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_337"/>A record is simply a collection of (otherwise) unrelated variables. So why not just create separate variables? In C, for example, why not just write:</p>&#13;
		<pre class="programs">&#13;
			// Room for a 64-character zero-terminated string:<br/><br/>char someStudent_Name[65];<br/><br/>// Typically a 2-byte integer in C/C++:<br/><br/>short someStudent_Major;<br/><br/>// Room for an 11-character zero-terminated string:<br/><br/>char someStudent_SSN[12];<br/><br/>short someStudent_Mid1;<br/>short someStudent_Mid2;<br/>short someStudent_Final;<br/>short someStudent_Homework;<br/>short someStudent_Projects;</pre>&#13;
		<p class="indent">There are several reasons why this approach isn’t ideal. On the software engineering side of things, there are maintenance issues to consider. For example, what happens if you create several sets of <span class="literal">student</span> variables and then decide you want to add a field? Now you’ve got to go back and edit every set of declarations you’ve created—not a pretty sight. With structure/record declarations, however, you only need to make one change to the type declaration, and all the variable declarations automatically get the new field. Also, consider what happens if you want to create an array of <span class="literal">student</span> objects.</p>&#13;
		<p class="indent">Software engineering issues aside, collecting disparate fields into a record is a good idea for efficiency reasons. Many compilers allow you to treat a whole record as a single object for the purposes of assignment, parameter passing, and so on. In Pascal, for example, if you have two variables, <span class="literal">s1</span> and <span class="literal">s2</span>, of type <span class="literal">student</span>, you can assign all the values of one <span class="literal">student</span> object to the other with a single assignment statement like this:</p>&#13;
		<pre class="programs">s2 := s1;</pre>&#13;
		<p class="indent">Not only is this more convenient than assigning the individual fields, but the compiler can often generate better code by using a block move operation. Consider the following C++ code and the associated x86 assembly language output:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>// A good-sized but otherwise arbitrary structure that<br/>// demonstrates how a C++ compiler can handle structure<br/>// assignments.<br/><br/>typedef struct<br/>{<br/><span epub:type="pagebreak" id="page_338"/>    int x;<br/>    int y;<br/>    char *z;<br/>    int a[16];<br/>}aStruct;<br/><br/><br/>int main( int argc, char **argv )<br/>{<br/>    static aStruct s1;<br/>    aStruct s2;<br/>    int i;<br/><br/>    // Give s1 some nonzero values so<br/>    // that the optimizer doesn't simply<br/>    // substitute zeros everywhere fields<br/>    // of s1 are referenced:<br/><br/>    s1.x = 5;<br/>    s1.y = argc;<br/>    s1.z = *argv;<br/><br/>    // Do a whole structure assignment<br/>    // (legal in C++!)<br/><br/>    s2 = s1;<br/><br/>    // Make an arbitrary change to S2<br/>    // so that the compiler's optimizer<br/>    // won't eliminate the code to build<br/>    // s2 and just use s1 because s1 and<br/>    // s2 have the same values.<br/><br/>    s2.a[2] = 2;<br/><br/>    // The following loop exists, once again,<br/>    // to thwart the optimizer from eliminating<br/>    // s2 from the code:<br/><br/>    for( i=0; i&lt;16; ++i)<br/>    {<br/>        printf( "%d\n", s2.a[i] );<br/>    }<br/><br/>    // Now demonstrate a field-by-field assignment<br/>    // so we can see the code the compiler generates:<br/><br/>    s1.y = s2.y;<br/>    s1.x = s2.x;<br/>    s1.z = s2.z;<br/>    for( i=0; i&lt;16; ++i )<br/>    {<br/>        s1.a[i] = s2.a[i];<br/>    }<br/>    for( i=0; i&lt;16; ++i)<br/><span epub:type="pagebreak" id="page_339"/>    {<br/>        printf( "%d\n", s2.a[i] );<br/>    }<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent">Here’s the relevant portion of the x86-64 assembly code that Microsoft’s Visual C++ compiler produces (with the <span class="literal">/O2</span> optimization option):</p>&#13;
		<pre class="programs">&#13;
			; Storage for the s1 array in the BSS segment:<br/><br/>_BSS    SEGMENT<br/>?s1@?1??main@@9@9 DB 050H DUP (?)                       ; `main'::`2'::s1<br/>_BSS    ENDS<br/>;<br/>s2$1$ = 32<br/>s2$2$ = 48<br/>s2$3$ = 64<br/>s2$ = 80<br/>__$ArrayPad$ = 160<br/>argc$ = 192<br/>argv$ = 200<br/><br/>; Note: on entry to main, rcx = argc, rdx = argv<br/><br/>main    PROC                                            ; COMDAT<br/>; File c:\users\rhyde\test\t\t\t.cpp<br/>; Line 20<br/>$LN27:<br/>        mov     r11, rsp<br/>        mov     QWORD PTR [r11+24], rbx<br/>        push    rdi<br/>;<br/>; Allocate storage for the local variables<br/>; (including s2):<br/><br/>        sub     rsp, 176                                ; 000000b0H<br/>        mov     rax, QWORD PTR __security_cookie<br/>        xor     rax, rsp<br/>        mov     QWORD PTR __$ArrayPad$[rsp], rax<br/><br/>        xor     ebx, ebx   ; ebx = 0<br/>        mov     edi, ebx  ; edi = 0<br/><br/>     ; s1.z = *argv<br/>        mov     rax, QWORD PTR [rdx] ;rax = *argv<br/>        mov     QWORD PTR ?s1@?1??main@@9@9+8, rax<br/><br/>     ; s1.x = 5<br/>        mov     DWORD PTR ?s1@?1??main@@9@9, 5<br/><br/>     ;s1.y = argc<br/>        mov     DWORD PTR ?s1@?1??main@@9@9+4, ecx<br/><span epub:type="pagebreak" id="page_340"/>;     s2 = s1;<br/>;<br/>;       xmm1=s1.a[0..1]<br/>        movaps  xmm1, XMMWORD PTR ?s1@?1??main@@9@9+16<br/>        movaps  XMMWORD PTR s2$[rsp+16], xmm1 ;s2.a[0..1] = xmm1<br/>        movaps  xmm0, XMMWORD PTR ?s1@?1??main@@9@9<br/>        movaps  XMMWORD PTR s2$[rsp], xmm0<br/>        movaps  xmm0, XMMWORD PTR ?s1@?1??main@@9@9+32<br/>        movaps  XMMWORD PTR s2$[rsp+32], xmm0<br/>        movups  XMMWORD PTR s2$1$[rsp], xmm0<br/>        movaps  xmm0, XMMWORD PTR ?s1@?1??main@@9@9+48<br/>        movaps  XMMWORD PTR [r11-56], xmm0<br/>        movups  XMMWORD PTR s2$2$[rsp], xmm0<br/>        movaps  xmm0, XMMWORD PTR ?s1@?1??main@@9@9+64<br/>        movaps  XMMWORD PTR [r11-40], xmm0<br/>        movups  XMMWORD PTR s2$3$[rsp], xmm0<br/><br/>    ; s2.a[2] = 2<br/><br/>        mov     DWORD PTR s2$[rsp+24], 2<br/>        npad    14<br/><br/>;    for (i = 0; i&lt;16; ++i)<br/>;    {<br/><br/>$LL4@main:<br/>; Line 53<br/>        mov     edx, DWORD PTR s2$[rsp+rdi*4+16]<br/>        lea     rcx, OFFSET FLAT:??_C@_03PMGGPEJJ@?$CFd?6?$AA@<br/>        call    printf<br/>        inc     rdi<br/>        cmp     rdi, 16<br/>        jl      SHORT $LL4@main<br/><br/>.;     } //endfor<br/><br/>; Line 59 // s1.y = s2.y<br/>        mov     eax, DWORD PTR s2$[rsp+4]<br/>        mov     DWORD PTR ?s1@?1??main@@9@9+4, eax<br/><br/>       ;s1.x = s2.x<br/>        mov     eax, DWORD PTR s2$[rsp]<br/>        mov     DWORD PTR ?s1@?1??main@@9@9, eax<br/><br/>       ; s1.z = s2.z<br/>        mov     rax, QWORD PTR s2$[rsp+8]<br/>        mov     QWORD PTR ?s1@?1??main@@9@9+8, rax<br/><br/>;    for (i = 0; i&lt;16; ++i)<br/>;    {<br/>;        printf("%d\n", s2.a[i]);<br/>;    }<br/><span epub:type="pagebreak" id="page_341"/>; Line 64<br/>        movups  xmm1, XMMWORD PTR s2$1$[rsp]<br/>        movaps  xmm0, XMMWORD PTR s2$[rsp+16]<br/>        movups  XMMWORD PTR ?s1@?1??main@@9@9+32, xmm1<br/>        movups  xmm1, XMMWORD PTR s2$3$[rsp]<br/>        movups  XMMWORD PTR ?s1@?1??main@@9@9+16, xmm0<br/>        movups  xmm0, XMMWORD PTR s2$2$[rsp]<br/>        movups  XMMWORD PTR ?s1@?1??main@@9@9+64, xmm1<br/>        movups  XMMWORD PTR ?s1@?1??main@@9@9+48, xmm0<br/>        npad    7<br/><br/>$LL10@main:<br/>; Line 68<br/>        mov     edx, DWORD PTR s2$[rsp+rbx*4+16]<br/>        lea     rcx, OFFSET FLAT:??_C@_03PMGGPEJJ@?$CFd?6?$AA@<br/>        call    printf<br/>        inc     rbx<br/>        cmp     rbx, 16<br/>        jl      SHORT $LL10@main<br/><br/>; Return 0<br/>; Line 70<br/>        xor     eax, eax<br/>; Line 71<br/>        mov     rcx, QWORD PTR __$ArrayPad$[rsp]<br/>        xor     rcx, rsp<br/>        call    __security_check_cookie<br/>        mov     rbx, QWORD PTR [rsp+208]<br/>        add     rsp, 176                                ; 000000b0H<br/>        pop     rdi<br/>        ret     0<br/>main    ENDP</pre>&#13;
		<p class="indent">The important thing to note in this example is that the Visual C++ compiler emits a sequence of <span class="literal">movaps</span> and <span class="literal">movups</span> instructions whenever you assign whole structures. However, it may degenerate to a sequence of individual <span class="literal">mov</span> instructions for each of the fields when you do a field-by-field assignment of two structures. Likewise, if you had not encapsulated all the fields into a structure, then assigning the variables associated with your “structure” via a block copy operation wouldn’t have been possible.</p>&#13;
		<p class="indent">Combining fields together into a record has many advantages, including:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">It is much easier to maintain the record structure (that is, add, remove, rename, and change fields).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Compilers can do additional type and semantic checking on records, thereby helping catch logic errors in your programs when you use a record improperly.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Compilers can treat records as monolithic objects, generating more efficient code (for example, <span class="literal">movsd</span> and <span class="literal">movaps</span> instructions) than they can when working with individual field variables.</p>&#13;
				</li>&#13;
			<li><span epub:type="pagebreak" id="page_342"/>&#13;
			<p class="noindentt">Most compilers respect the order of declaration in a record, allocating successive fields to consecutive memory locations. This is important when interfacing data structures from two different languages. There is no guarantee for the organization of separate variables in memory in most languages.</p>&#13;
			</li>&#13;
			<li>&#13;
				<p class="noindent">You can use records to improve cache memory performance and reduce virtual memory thrashing (as you’ll soon see).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Records can contain pointer fields that contain the address of other (like-typed) record objects. This isn’t possible when you use bulk variables in memory.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">You’ll see some other advantages of records in the following sections.</p>&#13;
		<h4 class="h4" id="ch00lev2sec130"><strong>11.1.3 Initializing Record Data at Compile Time</strong></h4>&#13;
		<p class="noindent">Some languages—for example, C/C++ and HLA—allow you to initialize record variables at compile time. For static objects, this spares your application the code and time needed to manually initialize each field of a record. For example, consider the following C code, which provides initializers for both static and automatic structure variables:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/><br/>// Arbitrary structure that consumes a nontrival<br/>// amount of space:<br/><br/>typedef struct<br/>{<br/>    int x;<br/>    int y;<br/>    char *z;<br/>    int a[4];<br/>}initStruct;<br/><br/>// The following exists just to thwart<br/>// the optimizer and make it think that<br/>// all the fields of the structure are<br/>// needed.<br/><br/>extern void thwartOpt( initStruct *i );<br/><br/>int main( int argc, char **argv )<br/>{<br/>    static initStruct staticStruct = {1,2,"Hello", {3,4,5,6}};<br/>    initStruct autoStruct = {7,8,"World", {9,10,11,12}};<br/><br/>    thwartOpt( &amp;staticStruct );<br/>    thwartOpt( &amp;autoStruct );<br/>    return 0;<br/><br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_343"/>When compiled with Visual C++ using the <span class="literal">/O2</span> and <span class="literal">/Fa</span> command-line options, this example emits the following x86-64 machine code (edited manually to eliminate irrelevant output):</p>&#13;
		<pre class="programs">&#13;
			; Static structure declaration.<br/>; Note how each of the fields is<br/>; initialized with the initial values<br/>; specified in the C source file:<br/><br/>; String used in static initStruct:<br/><br/>CONST   SEGMENT<br/>??_C@_05COLMCDPH@Hello?$AA@ DB 'Hello', 00H       ; `string'<br/>CONST   ENDS<br/><br/>_DATA   SEGMENT<br/>; `main'::`2'::staticStruct<br/>?staticStruct@?1??main@@9@9 DD 01H ;x field<br/>        DD      02H ;y field<br/>        DQ      FLAT:??_C@_05COLMCDPH@Hello?$AA@  ; z field<br/>        DD      03H ;a[0] field<br/>        DD      04H ;a[1] field<br/>        DD      05H ;a[2] field<br/>        DD      06H ;a[3] field<br/>_DATA   ENDS<br/><br/>; String used to initialize autoStruct:<br/><br/>CONST   SEGMENT<br/>??_C@_05MFLOHCHP@World?$AA@ DB 'World', 00H       ; `string'<br/>CONST   ENDS<br/>;<br/>_TEXT   SEGMENT<br/>autoStruct$ = 32<br/>__$ArrayPad$ = 64<br/>argc$ = 96<br/>argv$ = 104<br/>main    PROC                                      ; COMDAT<br/>; File c:\users\rhyde\test\t\t\t.cpp<br/>; Line 26<br/>$LN9: ;Main program startup code:<br/>        sub     rsp, 88                           ; 00000058H<br/>        mov     rax, QWORD PTR __security_cookie<br/>        xor     rax, rsp<br/>        mov     QWORD PTR __$ArrayPad$[rsp], rax<br/><br/>; Line 28<br/>;<br/>; Initialize autoStruct:<br/><br/>        lea     rax, OFFSET FLAT:??_C@_05MFLOHCHP@World?$AA@<br/>        mov     DWORD PTR autoStruct$[rsp], 7 ;autoStruct.x<br/>        mov     QWORD PTR autoStruct$[rsp+8], rax<br/>        mov     DWORD PTR autoStruct$[rsp+4], 8 ;autoStruct.y<br/><span epub:type="pagebreak" id="page_344"/>        lea     rcx, QWORD PTR autoStruct$[rsp+16] ;autoStruct.a<br/>        mov     eax, 9<br/>        lea     edx, QWORD PTR [rax-5] ;edx = 4<br/>$LL3@main:<br/>; autoStruct.a[0] = 9, 10, 11, 12 (this is a loop)<br/>        mov     DWORD PTR [rcx], eax<br/>        inc     eax<br/><br/>; point RCX at next element of autoStruct.a<br/>        lea     rcx, QWORD PTR [rcx+4]<br/>        sub     rdx, 1<br/>        jne     SHORT $LL3@main<br/><br/>; Line 30<br/>; thwartOpt(&amp;staticStruct );<br/><br/>        lea     rcx, OFFSET FLAT:?staticStruct@?1??main@@9@9<br/>        call    thwartOpt<br/><br/>; Line 31<br/>; thwartOpt( &amp;autoStruct );<br/><br/>        lea     rcx, QWORD PTR autoStruct$[rsp]<br/>        call    thwartOpt<br/>; Line 32<br/>; Return 0<br/>        xor     eax, eax ;EAX = 0<br/>; Line 34<br/>        mov     rcx, QWORD PTR __$ArrayPad$[rsp]<br/>        xor     rcx, rsp<br/>        call    __security_check_cookie<br/>        add     rsp, 88                                 ; 00000058H<br/>        ret     0<br/>main    ENDP<br/>_TEXT   ENDS<br/>        END</pre>&#13;
		<p class="indent">Look carefully at the machine code the compiler emits for the initialization of the <span class="literal">autoStruct</span> variable. In contrast to static initialization, the compiler cannot initialize memory at compile time because it doesn’t know the addresses of the various fields of the automatic record that the system allocates at runtime. Unfortunately, this particular compiler generates a field-by-field sequence of assignments to initialize the fields of the structure. While this is relatively fast, it can consume quite a bit of memory, especially if you’ve got a large structure. If you want to reduce the size of the automatic structure variable initialization, one possibility is to create an initialized static structure and assign it to the automatic variable upon each entry into the function in which you’ve declared the automatic variable. Consider the following C++ and 80x86 assembly code:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/>typedef struct<br/>{<br/><span epub:type="pagebreak" id="page_345"/>    int x;<br/>    int y;<br/>    char *z;<br/>    int a[4];<br/>}initStruct;<br/><br/>// The following exists just to thwart<br/>// the optimizer and make it think that<br/>// all the fields of the structure are<br/>// needed.<br/><br/>extern void thwartOpt( initStruct *i );<br/><br/>int main( int argc, char **argv )<br/>{<br/>    static initStruct staticStruct = {1,2,"Hello", {3,4,5,6}};<br/><br/>    // initAuto is a "readonly" structure used to initialize<br/>    // autoStruct upon entry into this function:<br/><br/>    static initStruct initAuto = {7,8,"World", {9,10,11,12}};<br/><br/>    // Allocate autoStruct on the stack and assign the initial<br/>    // values kept in initAuto to this new structure:<br/><br/>    initStruct autoStruct = initAuto;<br/><br/>    thwartOpt( &amp;staticStruct );<br/>    thwartOpt( &amp;autoStruct );<br/>    return 0;<br/><br/>}</pre>&#13;
		<p class="indent">Here’s the corresponding x86-64 assembly code that Visual C++ emits:</p>&#13;
		<pre class="programs">&#13;
			; Static initialized data for the staticStruct structure:<br/><br/>_DATA   SEGMENT<br/><br/>; Initialized data for staticStruct:<br/><br/>?staticStruct@?1??main@@9@9 DD 01H                      ; `main'::`2'::staticStruct<br/>        DD      02H<br/>        DQ      FLAT:??_C@_05COLMCDPH@Hello?$AA@<br/>        DD      03H<br/>        DD      04H<br/>        DD      05H<br/>        DD      06H<br/><br/>; Initialization data to be copied to autoStruct:<br/><br/>?initAuto@?1??main@@9@9 DD 07H                          ; `main'::`2'::initAuto<br/><span epub:type="pagebreak" id="page_346"/>        DD      08H<br/>        DQ      FLAT:??_C@_05MFLOHCHP@World?$AA@<br/>        DD      09H<br/>        DD      0aH<br/>        DD      0bH<br/>        DD      0cH<br/>_DATA   ENDS<br/><br/>_TEXT   SEGMENT<br/>autoStruct$ = 32<br/>__$ArrayPad$ = 64<br/>argc$ = 96<br/>argv$ = 104<br/>main    PROC                                    ; COMDAT<br/>; File c:\users\rhyde\test\t\t\t.cpp<br/>; Line 23<br/>$LN4:<br/>; Main startup code:<br/><br/>        sub     rsp, 88                         ; 00000058H<br/>        mov     rax, QWORD PTR __security_cookie<br/>        xor     rax, rsp<br/>        mov     QWORD PTR __$ArrayPad$[rsp], rax<br/>; Line 34<br/>; Initialize autoStruct by copying the data from the static<br/>; initializer to the automatic variable:<br/><br/>        movups  xmm0, XMMWORD PTR ?initAuto@?1??main@@9@9<br/>        movups  xmm1, XMMWORD PTR ?initAuto@?1??main@@9@9+16<br/>        movups  XMMWORD PTR autoStruct$[rsp], xmm0<br/>        movups  XMMWORD PTR autoStruct$[rsp+16], xmm1<br/><br/>; thwartOpt( &amp;staticStruct );<br/><br/>        lea     rcx, OFFSET FLAT:?staticStruct@?1??main@@9@9<br/>        call    thwartOpt  ; Arg is passed in RCX.<br/><br/>; thwartOpt( &amp;autoStruct );<br/><br/>        lea     rcx, QWORD PTR autoStruct$[rsp]<br/>        call    thwartOpt<br/><br/>; Return 0;<br/>        xor     eax, eax<br/>; Line 40<br/>        mov     rcx, QWORD PTR __$ArrayPad$[rsp]<br/>        xor     rcx, rsp<br/>        call    __security_check_cookie<br/>        add     rsp, 88                         ; 00000058H<br/>        ret     0<br/>main    ENDP<br/>_TEXT   ENDS<br/>        END</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_347"/>As you can see in this assembly code, it takes only a four-instruction sequence to copy the data from the statically initialized record into the automatically allocated record. This code is quite a bit shorter. Note, however, that it isn’t necessarily faster. Copying data from one structure to another involves memory-to-memory moves, which can be quite slow if all the memory locations are not currently cached. Moving immediate constants directly to the individual fields is often faster, though it may take many instructions to accomplish this.</p>&#13;
		<p class="indent">This example should remind you that if you attach an initializer to an automatic variable, the compiler will have to emit some code to handle that initialization at runtime. Unless your variables need to be reinitialized on each entry to your function, consider using static record objects instead.</p>&#13;
		<h4 class="h4" id="ch00lev2sec131"><strong>11.1.4 Storing Records in Memory</strong></h4>&#13;
		<p class="noindent">The following Pascal example demonstrates a typical <span class="literal">student</span> record variable declaration:</p>&#13;
		<pre class="programs">&#13;
			var<br/>    John: student;</pre>&#13;
		<p class="indent">Given the earlier declaration for the Pascal <span class="literal">student</span> data type, this allocates 81 bytes of storage laid out in memory as shown in <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>. If the label <span class="literal">John</span> corresponds to the <em>base address</em> of this record, then the <span class="literal">Name</span> field is at offset <span class="literal">John+0</span>, the <span class="literal">Major</span> field is at offset <span class="literal">John+65</span>, the <span class="literal">SSN</span> field is at offset <span class="literal">John+67</span>, and so on.</p>&#13;
		<div class="image" id="ch11fig1">&#13;
			<img alt="Image" src="../images/11fig01.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-1: Student data structure storage in memory</em></p>&#13;
		<p class="indent">Most programming languages let you refer to a record field by its name rather than by its numeric offset into the record (indeed, only a few low-end assemblers require that you reference fields by numeric offset; it’s safe to say that such assemblers don’t really support records). The typical syntax for a field access uses the <em>dot operator</em> to select a field from a record variable. Given the variable <span class="literal">John</span> from the previous example, here’s how you could access various fields in this record:</p>&#13;
		<pre class="programs">&#13;
			John.Mid1 = 80;           // C/C++ example<br/>John.Final := 93;         (* Pascal example *)<br/>mov( 75, John.Projects ); // HLA example</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_348"/><a href="ch11.xhtml#ch11fig1">Figure 11-1</a> suggests that all fields of a record appear in memory in the order of their declaration, and this is usually the case (although in theory, a compiler can freely place the fields anywhere in memory that it chooses). The first field usually appears at the lowest address in the record, the second field appears at the next-highest address, the third field follows the second field in memory, and so on.</p>&#13;
		<p class="indent"><a href="ch11.xhtml#ch11fig1">Figure 11-1</a> also suggests that compilers pack the fields into adjacent memory locations with no gaps between the fields. While this is true for many languages, it’s certainly not the most common memory organization for a record. For performance reasons, most compilers align the fields of a record on appropriate memory boundaries. The exact details vary by language, compiler implementation, and CPU, but a typical compiler places fields at an offset within the record’s storage area that is “natural” for that particular field’s data type. On the 80x86, for example, compilers that follow the Intel ABI (application binary interface) allocate single-byte objects at any offset within the record, words only at even offsets, and double word or larger objects on double word boundaries. Although not all 80x86 compilers support the Intel ABI, most do, which allows records to be shared among functions and procedures written in different languages on the 80x86. Other CPU manufacturers provide their own ABI for their processors, and programs that adhere to an ABI can share binary data at runtime with other programs that adhere to the same ABI.</p>&#13;
		<p class="indent">In addition to aligning the fields of a record at reasonable offset boundaries, most compilers also ensure that the length of the entire record is a multiple of 2, 4, 8, or 16 bytes. As you’ve seen in previous chapters, they accomplish this by adding padding bytes at the end of the record to fill out the record’s size. This ensures that the record’s length is a multiple of the largest scalar (nonarray/nonrecord) object in the record.<sup><a id="ch11fn_3"/><a href="footnotes.xhtml#ch11fn3">3</a></sup> For example, if a record has fields whose lengths are 1, 2, 4, and 8 bytes long, then an 80x86 compiler will generally pad the record’s length so that it is a multiple of 8. This allows you to create an array of records and be assured that each record in the array starts at a reasonable address in memory.</p>&#13;
		<p class="indent">Although some CPUs don’t allow access to objects in memory at misaligned addresses, many compilers allow you to disable the automatic alignment of fields within a record. Generally, the compiler will have an option you can use to globally disable this feature. Many of these compilers also provide a <span class="literal">pragma</span>, <span class="literal">alignas</span>, or <span class="literal">packed</span> keyword that lets you turn off field alignment on a record-by-record basis. Disabling the automatic field alignment feature may allow you to save some memory by eliminating the padding bytes between the fields (and at the end of the record)—again, provided that field misalignment is acceptable on your CPU. The cost, of course, is that the program may run a little more slowly when it needs to access misaligned values in memory.</p>&#13;
		<p class="indent">One reason to use a packed record is to gain manual control over the alignment of the record’s fields. For example, suppose you have a couple of <span epub:type="pagebreak" id="page_349"/>functions written in two different languages, and both of these functions need to access some data in a record. Further, suppose that the two compilers for these functions do not use the same field alignment algorithm. A record declaration like the following (in Pascal) may not be compatible with the way both functions access the record data:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    aRecord = record<br/><br/>        (* assume Pascal compiler supports a<br/>        ** byte, word, and dword type<br/>        *)<br/><br/>        bField : byte;<br/>        wField : word;<br/>        dField : dword;<br/><br/>    end; (* record *)</pre>&#13;
		<p class="indent">The problem here is that the first compiler could use the offsets 0, 2, and 4 for the <span class="literal">bField</span>, <span class="literal">wField</span>, and <span class="literal">dField</span> fields, respectively, while the second compiler might use offsets 0, 4, and 8.</p>&#13;
		<p class="indent">Suppose, however, that the first compiler allows you to specify the <span class="literal">packed</span> keyword before the <span class="literal">record</span> keyword, causing the compiler to store each field immediately following the previous one. Although using the <span class="literal">packed</span> keyword doesn’t make the records compatible with both functions, it does allow you to manually add padding fields to the record declaration, as follows:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    aRecord = packed record<br/>        bField   :byte;  (* Offset 0 *)<br/><br/>        (* add padding to dword align wField *)<br/><br/>        padding0 :array[0..2] of byte;<br/><br/>        wField   :word; (* offset 4 *)<br/><br/>        (* add padding to dword align dField *)<br/><br/>        padding1 :word;<br/><br/>        dField   :dword;  (* offset 8 *)<br/><br/>    end; (* record *)</pre>&#13;
		<p class="indent">Manually adding padding can make maintaining your code a real chore. However, if incompatible compilers need to share data, it’s a trick worth knowing. For the exact details on packed records, consult your language’s reference manual.</p>&#13;
		<h4 class="h4" id="ch00lev2sec132"><span epub:type="pagebreak" id="page_350"/><strong>11.1.5 Using Records to Improve Memory Performance</strong></h4>&#13;
		<p class="noindent">For someone who wants to write great code, records provide an important benefit: the ability to control variable placement in memory. This capability enables you to better control cache usage by those variables, which in turn can help you write code that executes much faster.</p>&#13;
		<p class="indent">Consider, for a moment, the following C global/static variable declarations:</p>&#13;
		<pre class="programs">&#13;
			int i;<br/>int j = 5;<br/>int cnt = 0;<br/>char a = 'a';<br/>char b;</pre>&#13;
		<p class="indent">You might think that the compiler would allocate storage for these variables in consecutive memory locations. However, few (if any) languages guarantee this. C certainly doesn’t and, in fact, C compilers like Microsoft’s Visual C++ compiler don’t allocate these variables in sequential memory locations. Consider the Visual C++ assembly language output for the preceding variable declarations:</p>&#13;
		<pre class="programs">&#13;
			PUBLIC  j<br/>PUBLIC  cnt<br/>PUBLIC  a<br/>_DATA   SEGMENT<br/>COMM    i:DWORD<br/>_DATA   ENDS<br/>_BSS    SEGMENT<br/>cnt     DD      01H DUP (?)<br/>_BSS    ENDS<br/>_DATA   SEGMENT<br/>COMM    b:BYTE<br/>_DATA   ENDS<br/>_DATA   SEGMENT<br/>j       DD      05H<br/>a       DB      061H<br/>_DATA   ENDS</pre>&#13;
		<p class="indent">Even if you don’t understand the purpose of all the directives here, it’s clear that Visual C++ has rearranged all the variable declarations in memory. Therefore, you cannot count on adjacent declarations in your source file yielding adjacent storage cells in memory. Indeed, there is nothing to stop the compiler from allocating one or more variables in a machine register.</p>&#13;
		<p class="indent">You might be wondering why you’d be concerned about the placement of variables in memory. After all, one of the main reasons for using named variables as an abstraction for memory is to avoid having to think about low-level memory allocation strategies. There are times, however, when being able to control variable placement in memory is important. For example, if you want to maximize program performance, you should try to place sets of variables that you access together in adjacent memory locations. This way, those variables will tend to sit in the same cache line, and you won’t pay a <span epub:type="pagebreak" id="page_351"/>heavy latency cost for accessing variables not currently held in the cache. Furthermore, by placing variables you use together adjacent to one another in memory, you’ll use fewer cache lines and, therefore, have less thrashing.</p>&#13;
		<p class="indent">Universally, programming languages that support the traditional notion of records maintain the fields of their records in adjacent memory locations; therefore, if you have some reason to keep different variables in adjacent memory locations (so that they share cache lines as much as possible), putting your variables into a record is a reasonable approach. However, the key word here is <em>traditional</em>—if your language uses a dynamic record type, you’ll need a different approach.</p>&#13;
		<h4 class="h4" id="ch00lev2sec133"><strong>11.1.6 Working with Dynamic Record Types and Databases</strong></h4>&#13;
		<p class="noindent">Some dynamic languages employ a dynamic type system, and object types can change at runtime. We’ll explore dynamic types a little later in this chapter, but suffice it to say that if your language uses a dynamic type record structure, then all bets are off concerning the placement of fields in memory. Chances are pretty good that the fields will not be sitting in adjacent memory locations. Then again, if you’re using a dynamic language, the fact that you’re sacrificing a little performance because you’re not getting maximal benefit from your cache will be the least of your worries.</p>&#13;
		<p class="indent">A classic example of a dynamic record is the data you read from a database engine. The engine itself has no preconceived (that is, compile time) notion of what structure the database records will take. Instead, the database itself provides metadata that tells the database the record structure. The database engine reads this metadata from the database, uses it to organize the field data into a single record, and then returns this data to the database application. In a dynamic language, the actual field data is typically spread out across memory, and the database application references that data indirectly.</p>&#13;
		<p class="indent">Of course, if you’re using a dynamic language, you have much greater concerns about performance than the placement or organization of your record fields in memory. Dynamic languages, such as database engines, execute many instructions processing the metadata (or otherwise determining the type of their data operands), so losing a few cycles to cache thrashing here and there is unlikely to matter much. For more information about the overhead associated with a dynamic typing system, see “Variant Types” on <a href="ch11.xhtml#page_356">page 356</a>.</p>&#13;
		<h3 class="h3" id="ch00lev1sec93"><strong>11.2 Discriminant Unions</strong></h3>&#13;
		<p class="noindent">A discriminant union (or just union) is very similar to a record. A <em>discriminant</em> is something that distinguishes or separates items in a quantity. In the case of a discriminant union, it means that different field names are used to distinguish the various ways that a given memory location’s data type can be interpreted.</p>&#13;
		<p class="indent">Like records, unions in typical languages that support them have fields that you access using dot notation. In fact, in many languages, about the <span epub:type="pagebreak" id="page_352"/>only syntactical difference between records and unions is the use of the keyword <span class="literal">union</span> rather than <span class="literal">record</span> or <span class="literal">struct</span>. Semantically, however, there’s a big difference between a record and a union. In a record, each field has its own offset from the base address of the record, and the fields do not overlap. In a union, however, all fields have the same offset, 0, and all the fields of the union overlap. As a result, the size of a record is the sum of the sizes of all the fields (plus, possibly, some padding bytes), whereas a union’s size is the size of its largest field (plus, possibly, some padding bytes at the end).</p>&#13;
		<p class="indent">Because the fields of a union overlap, changing the value of one field changes the values of all the other fields as well. This typically means that the use of a union’s field is mutually exclusive—that is, you can use only one field at any given time. As a result, unions aren’t as generally applicable as records, but they still have many uses. As you’ll see later in this chapter, you can use unions to save memory by reusing memory for different values, to coerce data types, and to create variant data types. For the most part, though, programs use unions to share memory between different variable objects whose use never overlaps (that is, the variables’ use is mutually exclusive).</p>&#13;
		<p class="indent">For example, imagine that you have a 32-bit double word variable, and you find yourself constantly extracting out the LO or the HO 16-bit word. In most HLLs, this would require a 32-bit read and then an AND operation to mask out the unwanted word. If that wasn’t enough, if you want the HO word, you have to then shift the result to the right 16 bits. With a union, you can overlay the 32-bit double word and a two-element 16-bit word array and access the words directly. You’ll see how to do this in “Using Unions in Other Ways” on <a href="ch11.xhtml#page_355">page 355</a>.</p>&#13;
		<h4 class="h4" id="ch00lev2sec134"><strong>11.2.1 Declaring Unions in Various Languages</strong></h4>&#13;
		<p class="noindent">The C/C++, Pascal, and HLA languages provide discriminant union type declarations. The Java language doesn’t provide the equivalent of a union. Swift has a special version of the <span class="literal">Enum</span> declaration that provides variant record capabilities, but it does not store members of such declarations at the same address in memory. So, for the purposes of this discussion, we’ll assume Swift doesn’t provide union declarations.</p>&#13;
		<h5 class="h5" id="ch00lev3sec71"><strong>11.2.1.1 Union Declarations in C/C++</strong></h5>&#13;
		<p class="noindent">Here’s an example of a union declaration in C/C++:</p>&#13;
		<pre class="programs">&#13;
			typedef union<br/>{<br/>    unsigned int  i;<br/>    float         r;<br/>    unsigned char c[4];<br/><br/>} unionType;</pre>&#13;
		<p class="indent">Assuming the C/C++ compiler in use allocates 4 bytes for unsigned integers, the size of a <span class="literal">unionType</span> object will be 4 bytes (because all three fields are 4-byte objects).</p>&#13;
		<h5 class="h5" id="ch00lev3sec72"><span epub:type="pagebreak" id="page_353"/><strong>11.2.1.2 Union Declarations in Pascal/Delphi</strong></h5>&#13;
		<p class="noindent">Pascal and Delphi use <em>case-variant records</em> to create a discriminant union. The syntax for a case-variant record is as follows:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    typeName =<br/>        record<br/><br/>            &lt;&lt;nonvariant/union record fields go here&gt;&gt;<br/><br/>            case <span class="codeitalic1">tag</span> of<br/>                <span class="codeitalic1">const1</span>:( <span class="codeitalic1">field_declaration</span> );<br/>                <span class="codeitalic1">const2</span>:( <span class="codeitalic1">field_declaration</span> );<br/>                    .<br/>                    .<br/>                    .<br/>                <span class="codeitalic1">constn</span>:( <span class="codeitalic1">field_declaration</span> )<br/><br/>        end;</pre>&#13;
		<p class="indent">The <span class="codeitalic">tag</span> item can be either a type identifier (such as <span class="literal">boolean</span>, <span class="literal">char</span>, or some user-defined type), or it can be a field declaration of the form <span class="literal"><span class="codeitalic1">identifier</span>:<span class="codeitalic1">type</span></span>. If it takes the latter form, then <span class="codeitalic">identifier</span> becomes another field of the record (and not a member of the variant section) and has the specified type. In addition, the Pascal compiler could generate code that raises an exception whenever the application attempts to access any of the variant fields except the one allowed by the value of the <span class="codeitalic">tag</span> field. In practice, almost no Pascal compilers do this check. Still, keep in mind that the Pascal language standard suggests that compilers <em>should</em> do it, so some compilers might.</p>&#13;
		<p class="indent">Here’s an example of two different case-variant record declarations in Pascal:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    noTagRecord=<br/>        record<br/>            <span class="codeitalic1">someField</span>: <span class="codeitalic1">integer</span>;<br/>            case boolean of<br/>                true:( i:integer );<br/>                false:( b:array[0..3] of char)<br/>        end; (* record *)<br/><br/>    hasTagRecord=<br/>        record<br/>            case which:0..2 of<br/>                0:( i:integer );<br/>                1:( r:real );<br/>                2:( c:array[0..3] of char )<br/>        end; (* record *)</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_354"/>As you can see in the <span class="literal">hasTagRecord</span> union, a Pascal case-variant record does not require any normal record fields. This is true even if you do not have a tag field.</p>&#13;
		<h5 class="h5" id="ch00lev3sec73"><strong>11.2.1.3 Union Declarations in HLA</strong></h5>&#13;
		<p class="noindent">HLA supports unions as well. Here’s a typical union declaration in HLA:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    unionType:<br/>        union<br/>            i: int32;<br/>            r: real32;<br/>            c: char[4];<br/>        endunion;</pre>&#13;
		<h4 class="h4" id="ch00lev2sec135"><strong>11.2.2 Storing Unions in Memory</strong></h4>&#13;
		<p class="noindent">Remember that the big difference between a union and a record is the fact that records allocate storage for each field at different offsets, whereas unions overlay each of the fields at the same offset in memory. For example, consider the following HLA record and union declarations:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    numericRec:<br/>        record<br/>            i: int32;<br/>            u: uns32;<br/>            r: real64;<br/>        endrecord;<br/><br/>    numericUnion:<br/>        union<br/>            i: int32;<br/>            u: uns32;<br/>            r: real64;<br/>        endunion;</pre>&#13;
		<p class="indent">If you declare a variable, say <span class="literal">n</span>, of type <span class="literal">numericRec</span>, you access the fields as <span class="literal">n.i</span>, <span class="literal">n.u</span>, and <span class="literal">n.r</span>, exactly as though you had declared the <span class="literal">n</span> variable to be type <span class="literal">numericUnion</span>. However, the size of a <span class="literal">numericRec</span> object is 16 bytes, because the record contains two double word fields and a quad word (<span class="literal">real64</span>) field. The size of a <span class="literal">numericUnion</span> variable, however, is 8 bytes. <a href="ch11.xhtml#ch11fig2">Figure 11-2</a> shows the memory arrangement of the <span class="literal">i</span>, <span class="literal">u</span>, and <span class="literal">r</span> fields in both the record and union.</p>&#13;
		<div class="image" id="ch11fig2">&#13;
			<span epub:type="pagebreak" id="page_355"/>&#13;
			<img alt="Image" src="../images/11fig02.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-2: Layout of a union versus a record variable</em></p>&#13;
		<h4 class="h4" id="ch00lev2sec136"><strong>11.2.3 Using Unions in Other Ways</strong></h4>&#13;
		<p class="noindent">In addition to conserving memory, programmers often use unions to create aliases in their code. An <em>alias</em> is a different name for the same memory object. Although aliases are often a source of confusion in a program and should be used sparingly, sometimes using them is convenient. For example, in some section of your program you might need to constantly use type coercion to refer to a particular object. To avoid this, you could use a union variable with each field representing one of the different types you want to use for the object. Consider the following HLA code fragment:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    CharOrUns:<br/>        union<br/>            c:char;<br/>            u:uns32;<br/>        endunion;<br/><br/>static<br/>    v:CharOrUns;</pre>&#13;
		<p class="indent">With a declaration like this one, you can manipulate an <span class="literal">uns32</span> object by accessing <span class="literal">v.u</span>. If, at some point, you need to treat the LO byte of this <span class="literal">uns32</span> variable as a character, you can do so by simply accessing the <span class="literal">v.c</span> variable, as follows:</p>&#13;
		<pre class="programs">&#13;
			mov( eax, v.u );<br/>stdout.put( "v, as a character, is '", v.c, "'" nl );</pre>&#13;
		<p class="indent">Another common practice is to use unions to disassemble a larger object into its constituent bytes. Consider the following C/C++ code fragment:</p>&#13;
		<pre class="programs">&#13;
			typedef union<br/>{<br/>    unsigned int u;<br/>    unsigned char bytes[4];<br/><span epub:type="pagebreak" id="page_356"/>} asBytes;<br/><br/>asBytes composite;<br/>        .<br/>        .<br/>        .<br/>    composite.u = 1234567890;<br/>    printf<br/>    (<br/>        "HO byte of composite.u is %u, LO byte is %u\n",<br/>        composite.bytes[3],<br/>        composite.bytes[0]<br/>    );</pre>&#13;
		<p class="indent">Although composing and decomposing data types this way is a useful trick to employ every now and then, keep in mind that this code isn’t portable. The HO and LO bytes of a multibyte object appear at different addresses on big endian versus little endian machines. As a result, this code fragment works fine on little endian machines, but fails to display the correct bytes on big endian CPUs. Any time you use unions to decompose larger objects, you should be aware of this limitation. Still, this trick is usually much more efficient than using shift lefts, shift rights, and AND operations, so you’ll see it used quite a bit.</p>&#13;
		<h3 class="h3" id="ch00lev1sec94"><strong>11.3 Variant Types</strong></h3>&#13;
		<p class="noindent">A variant object has a <em>dynamic</em> type—that is, the object’s type can vary at runtime. This spares the programmer from having to decide on a data type when designing the program and allows the end user to enter whatever data they like as the program operates. Programs written in a dynamically typed language are typically far more compact than languages written in a traditional statically typed language. This makes dynamically typed languages very popular for rapid prototyping, interpretive, and very high-level languages. A few mainstream languages (including Visual Basic and Delphi) also support variant types. In this section, we’ll look at how compilers implement variant types and discuss the efficiency costs associated with them.</p>&#13;
		<p class="indent">To implement a variant type, most languages use a union to reserve storage for all the different types the variant object supports. This means that a variant object will consume at least as much space as the largest primitive data type it supports. In addition to the storage required to keep its value, the variant object will also need storage to keep track of its current type. If the language allows variants to assume an array type, even more storage may be necessary to specify how many elements are in the array (or the bounds on each dimension, if the language allows multidimensional variant arrays). The bottom line is that a variant consumes a fair amount of memory, even if the actual data consumes only a single byte.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_357"/>Perhaps the best way to illustrate how a variant data type works is to implement one manually. Consider the following Delphi case-variant record declaration:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    dataTypes =<br/>           (<br/>               vBoolean, paBoolean, vChar, paChar,<br/>               vInteger, paInteger, vReal, paReal,<br/>               vString, paString<br/>           );<br/><br/>       varType =<br/>           record<br/>               <span class="codeitalic1">elements</span> : <span class="codeitalic1">integer</span>;<br/>               case theType: dataTypes of<br/>                   vBoolean:  ( b:boolean );<br/>                   paBoolean: ( pb:array[0..0] of ^boolean );<br/>                   vChar:     ( c:char );<br/>                   paChar:    ( pc:array [0..0] of ^char );<br/>                   vInteger:  ( i:integer );<br/>                   paInteger: ( pi:array[0..0] of ^integer );<br/>                   vReal:     ( r:real );<br/>                   paReal:    ( pr:array[0..0] of ^real );<br/>                   vString:   ( s:string[255] );<br/>                   paString:  ( ps:array[0..0] of ^string[255] )<br/>          end;</pre>&#13;
		<p class="indent">In this record, <span class="codeitalic">elements</span> will contain the number of elements in the array if the object is a single-dimensional array (this particular data structure does not support multidimensional arrays). If, on the other hand, the object is a scalar variable, then the <span class="codeitalic">elements</span> value will be irrelevant. The <span class="literal">theType</span> field specifies the current type of the object. If this field contains one of the enumerated constants <span class="literal">vBoolean</span>, <span class="literal">vChar</span>, <span class="literal">vInteger</span>, <span class="literal">vReal</span>, or <span class="literal">vString</span>, the object is a scalar variable; if it contains one of the constants <span class="literal">paBoolean</span>, <span class="literal">paChar</span>, <span class="literal">paInteger</span>, <span class="literal">paReal</span>, or <span class="literal">paString</span>, then the object is a single-dimensional array of the specified type.</p>&#13;
		<p class="indent">The fields in the case-variant section of the Pascal record hold the variant’s value if it is a scalar object, or they hold a pointer to an array of objects if the variant is an array object. Technically, Pascal requires that you specify the bounds of the array in its declaration. But fortunately, Delphi lets you turn off bounds checking (as well as allowing you to allocate memory for an array of arbitrary size), hence the dummy array bounds in this example.</p>&#13;
		<p class="indent">Manipulating two variant objects that have the same type is easy. For example, suppose you want to add two variant values together. First, you’d determine the current type of both objects and whether the addition operation even makes sense for the data types.<sup><a id="ch11fn_4"/><a href="footnotes.xhtml#ch11fn4">4</a></sup> Once you’ve decided that the <span epub:type="pagebreak" id="page_358"/>addition operation is reasonable, it’s easy enough to use a <span class="literal">case</span> (or <span class="literal">switch</span>) statement based on the tag field of the two variant types:</p>&#13;
		<pre class="programs">&#13;
			// Handle the addition operation:<br/><br/>// Load variable theType with either left.theType<br/>// or right.theType (which, presumably, contain<br/>// the same value at this point).<br/><br/>case( theType ) of<br/><br/>    vBoolean: writeln( "Cannot add two Boolean values!" );<br/>    vChar: writeln( "Cannot add two character values!" );<br/>    vString: writeln( "Cannot add two string values!" );<br/>    vInteger: intResult := left.vInteger + right.vInteger;<br/>    vReal: realResult := left.vReal + right.vReal;<br/>    paBoolean: writeln( "Cannot add two Boolean arrays!" );<br/>    paChar: writeln( "Cannot add two character arrays!" );<br/>    paInteger: writeln( "Cannot add two integer arrays!" );<br/>    paReal: writeln( "Cannot add two real arrays!" );<br/>    paString: writeln( "Cannot add two Boolean arrays!" );<br/><br/>end;</pre>&#13;
		<p class="indent">If the left and right operands are not the same type, then the operation is a bit more complex. Some mixed-type operations are legal. For example, adding an integer operand and a real operand together is reasonable (it produces a real type result in most languages). Other operations may be legal only if the values of the operands can be added. For example, it’s reasonable to add a string and an integer together if the string happens to contain a string of digits that could be converted to an integer prior to the addition (likewise for string and real operands). What is needed here is a two-dimensional <span class="literal">case</span>/<span class="literal">switch</span> statement. Unfortunately, outside of assembly language, you won’t find such a creature.<sup><a id="ch11fn_5"/><a href="footnotes.xhtml#ch11fn5">5</a></sup> However, you can simulate one easily enough by nesting <span class="literal">case</span>/<span class="literal">switch</span> statements:</p>&#13;
		<pre class="programs">&#13;
			case( left.theType ) of<br/><br/>    vInteger:<br/>        case( right.theType ) of<br/>            vInteger:<br/>                (* code to handle integer + integer operands *)<br/>            vReal:<br/>                (* code to handle integer + real operands *)<br/>            vBoolean:<br/>                (* code to handle integer + boolean operands *)<br/>            vChar:<br/>                (* code to handle integer + char operands *)<br/><span epub:type="pagebreak" id="page_359"/>            vString:<br/>                (* code to handle integer + string operands *)<br/>            paInteger:<br/>                (* code to handle integer + intArray operands *)<br/>            paReal:<br/>                (* code to handle integer + realArray operands *)<br/>            paBoolean:<br/>                (* code to handle integer + booleanArray operands *)<br/>            paChar:<br/>                (* code to handle integer + charArray operands *)<br/>            paString:<br/>                (* code to handle integer + stringArray operands *)<br/>        end;<br/><br/>    vReal:<br/>        case( right.theType ) of<br/>            (* cases for each of the right operand types<br/>                REAL + type *)<br/>        end;<br/><br/>    Boolean:<br/>        case( right.theType ) of<br/>            (* cases for each of the right operand types:<br/>                BOOLEAN + type *)<br/>        end;<br/><br/>    vChar:<br/>        case( right.theType ) of<br/>            (* cases for each of the right operand types:<br/>                CHAR + type *)<br/>        end;<br/><br/>    vString:<br/>        case( right.theType ) of<br/>            (* cases for each of the right operand types:<br/>                STRING + type *)<br/>        end;<br/><br/>    paInteger:<br/>        case( right.theType ) of<br/>            (* cases for each of the right operand types:<br/>                intArray + type *)<br/>        end;<br/><br/>    paReal:<br/>        case( right.theType ) of<br/>            (* cases for each of the right operand types:<br/>                realArray + type *)<br/>        end;<br/><br/>    paBoolean:<br/>        case( right.theType ) of<br/>            (* cases for each of the right operand types:<br/>                booleanArray + type *)<br/>        end;<br/><br/><span epub:type="pagebreak" id="page_360"/>    paChar:<br/>        case( right.theType ) of<br/>            (* cases for each of the right operand types:<br/>                charArray + type *)<br/>        end;<br/><br/>    paString:<br/>        case( right.theType ) of<br/>            (* cases for each of the right operand types:<br/>                stringArray + type *)<br/>        end;<br/><br/>end;</pre>&#13;
		<p class="indent">Once you expand all the code alluded to in these comments, you’ll have quite a few statements. And this is just for one operator! Obviously, it takes considerable work to implement all the basic arithmetic, string, character, and Boolean operations—and expanding this code inline whenever you need to add two variant values together is out of the question. Generally, you’d write a function like <span class="literal">vAdd()</span> that would accept two variant parameters and produce a variant result (or raise some sort of exception if the addition of the operands is illegal).</p>&#13;
		<p class="indent">The takeaway here is not that the code to do variant addition is long—the real problem is performance. It’s not at all unreasonable to expect a variant addition operation to require dozens, if not hundreds, of machine instructions to accomplish. By contrast, it takes only two or three machine instructions to add two integer or floating-point values together. Therefore, you can expect operations involving variant objects to run approximately one to two orders of magnitude slower than the standard operations. This, in fact, is one of the major reasons why “typeless” languages (usually very high-level languages) are so slow. When you truly need a variant type, the performance is often just as good (or even better) than the alternative code you’d have to write to get around using one. However, if you’re using variant objects to hold values whose type you know when you first write the program, you’ll pay a heavy performance penalty for not using typed objects.</p>&#13;
		<p class="indent">In object-oriented languages such as C++, Java, Swift, and Delphi (Object Pascal), there’s a better solution for variant calculations: inheritance and polymorphism. A big problem with the <span class="literal">union</span>/<span class="literal">switch</span> statement version is that it can be a major pain to extend the variant type by adding a new type to it. For example, suppose you want to add a new complex data type supporting complex numbers. You’d have to locate every function you’ve written (typically one for each operator) and add a new <span class="literal">case</span> to the <span class="literal">switch</span> statement. This can be a maintenance nightmare (especially if you don’t have access to the original source code). However, by using objects, you can create a new class (such as <span class="literal">ComplexNumber</span>) that overrides the existing base class (perhaps <span class="literal">Numeric</span>) without having to modify any of the existing code (for other numeric types and operations). For more information on this method, see <em>Write Great Code, Volume 4: Designing Great Code</em>.</p>&#13;
		<h3 class="h3" id="ch00lev1sec95"><span epub:type="pagebreak" id="page_361"/><strong>11.4 Namespaces</strong></h3>&#13;
		<p class="noindent">As your programs become larger, and particularly as these large programs use third-party software libraries to reduce development time, it becomes increasingly likely that name conflicts will arise in your source files. A name conflict occurs when you want to use a specific identifier at one point in your program, but that name is already in use elsewhere (for example, in a library you’re using). At some point in a very large project, you may dream up a new name to resolve a naming conflict only to discover that the new name is also already in use. Software engineers call this <em>namespace pollution</em>. Like environmental pollution, the problem is easy to live with when it’s small and localized. As your programs get larger, however, dealing with the fact that “all the good identifiers are already used up” is a real challenge.</p>&#13;
		<p class="indent">At first blush, it might seem that this problem is exaggerated; after all, a programmer can always think of a different name. However, programmers who write great code often adhere to certain naming conventions so that their source code is consistent and easy to read (I’ll come back to this subject in <em>Write Great Code, Volume 5: Great Coding</em>). Constantly devising new names, even if they aren’t all that bad, tends to produce inconsistencies in the source code that make programs harder to read. It would be nice to choose whatever name you like for your identifiers and not have to worry about conflicts with other code or libraries. Enter namespaces.</p>&#13;
		<p class="indent">A <em>namespace</em> is a mechanism by which you can associate a set of identifiers with a namespace identifier. In many respects, a namespace is like a record declaration. Indeed, you can use a <span class="literal">record</span> (or <span class="literal">struct</span>) declaration as a poor man’s namespace in languages that don’t support namespaces directly (with a few major restrictions). For example, consider the following Pascal variable declarations:</p>&#13;
		<pre class="programs">&#13;
			var<br/>    myNameSpace:<br/>        record<br/>            i: integer;<br/>            j: integer;<br/>            name: string[64];<br/>            date: string[10];<br/>            grayCode: integer;<br/>        end;<br/><br/>    yourNameSpace:<br/>        record<br/>            i: integer;<br/>            j: integer;<br/>            profits: real;<br/>            weekday: integer;<br/>        end;</pre>&#13;
		<p class="indent">As you can see, the <span class="literal">i</span> and <span class="literal">j</span> fields in these two records are distinct variables. There will never be a naming conflict because the program must <span epub:type="pagebreak" id="page_362"/>qualify these two field names with the record variable name. That is, you refer to these variables using the following names:</p>&#13;
		<pre class="programs">&#13;
			myNameSpace.i, myNameSpace.j,<br/>yourNameSpace.i, yourNameSpace.j</pre>&#13;
		<p class="indent">The record variable that prefixes the fields uniquely identifies each of these field names. This is clear to anyone who has ever written code that uses a record or structure. Therefore, in languages that don’t support namespaces, you can use records (or classes) in their place.</p>&#13;
		<p class="indent">There is one major problem with creating namespaces by using records or structures, though: many languages let you declare only variables within a record. Namespace declarations (like those available in C++ and HLA) specifically allow you to include other types of objects as well. In HLA, for example, a namespace declaration takes the following form:</p>&#13;
		<pre class="programs">&#13;
			namespace nsIdentifier;<br/><br/>    &lt;&lt; constant, type, variable, procedure,<br/>            and other declarations &gt;&gt;<br/><br/>end nsIdentifier;</pre>&#13;
		<p class="indent">A class declaration (if available in your chosen language) can overcome some of these problems. At the very least, most languages allow procedure or function declarations within a class, but many allow constant and type declarations as well.</p>&#13;
		<p class="indent">Namespaces are a declaration section unto themselves. In particular, they do not have to go in a <span class="literal">var</span> or <span class="literal">static</span> (or any other) section. You can create constants, types, variables, static objects, procedures, and so on, all within a namespace.</p>&#13;
		<p class="indent">To access namespace objects in HLA, you use the familiar dot notation that records, classes, and unions use. To access a name in a C++ namespace, you use the <span class="literal">::</span> operator.</p>&#13;
		<p class="indent">As long as the namespace identifier is unique and all the fields within the namespace are unique to that namespace, you won’t have any problems. By carefully partitioning a project into various namespaces, you can easily avoid most of the problems that occur because of namespace pollution.</p>&#13;
		<p class="indent">Another interesting aspect to namespaces is that they are extensible. For example, consider the following declarations in C++:</p>&#13;
		<pre class="programs">&#13;
			namespace aNS<br/>{<br/>    int i;<br/>    int j;<br/>}<br/><br/>int i;  // Outside the namespace, so this is unique.<br/>int j;  // ditto.<br/><span epub:type="pagebreak" id="page_363"/>namespace aNS<br/>{<br/>    int k;<br/>}</pre>&#13;
		<p class="indent">This example code is perfectly legal. The second declaration of <span class="literal">aNS</span> does not conflict with the first: it extends the <span class="literal">aNS</span> namespace to include identifier <span class="literal">aNS::k</span> as well as <span class="literal">aNS::i</span> and <span class="literal">aNS::j</span>. This feature is very handy when, for example, you want to extend a set of library routines and header files without modifying the original header files for that library (assuming the library names all appear within a namespace).</p>&#13;
		<p class="indent">From an implementation point of view, there’s really no difference between a namespace and a set of declarations appearing outside a namespace. The compiler typically deals with both types of declarations in a nearly identical fashion, with the only difference being that the program prefixes all objects located within the namespace with the namespace’s identifier.</p>&#13;
		<h3 class="h3" id="ch00lev1sec96"><strong>11.5 Classes and Objects</strong></h3>&#13;
		<p class="noindent">The <em>class</em> data type is the bedrock of modern object-oriented programming (OOP). In most OOP languages, the class is closely related to the record or structure. However, unlike records (which have a surprisingly uniform implementation across most languages), class implementations tend to vary. Nevertheless, many contemporary OOP languages achieve their results using similar approaches, so this section demonstrates a few concrete examples from C++, Java, Swift, HLA, and Delphi (Object Pascal). Users of other languages will find their languages work similarly.</p>&#13;
		<h4 class="h4" id="ch00lev2sec137"><strong>11.5.1 Classes vs. Objects</strong></h4>&#13;
		<p class="noindent">Many programmers confuse the terms <em>class</em> and <em>object</em>. A class is a data type; it is a template for how the compiler organizes memory with respect to the class’s fields. An object is an instantiation of a class—that is, an object is a variable of some class type that has memory allocated to hold the data associated with the class’s fields. For a given class, there is only one class definition. You may, however, have several objects (variables) of that class type.</p>&#13;
		<h4 class="h4" id="ch00lev2sec138"><strong>11.5.2 Simple Class Declarations in C++</strong></h4>&#13;
		<p class="noindent">Classes and structures are syntactically and semantically similar in C++. Indeed, there is only one syntactical difference between them: the use of the <span class="literal">class</span> keyword versus the <span class="literal">struct</span> keyword. Consider the following two valid type declarations in C++:</p>&#13;
		<pre class="programs">&#13;
			struct student<br/>{<br/><span epub:type="pagebreak" id="page_364"/>        // Room for a 64-character zero-terminated string:<br/><br/>        char Name[65];<br/><br/>        // Typically a 2-byte integer in C/C++:<br/><br/>        short Major;<br/><br/>        // Room for an 11-character zero-terminated string:<br/><br/>        char SSN[12];<br/><br/>        // Each of the following is typically a 2-byte integer<br/><br/>        short Mid1;<br/>        short Mid2;<br/>        short Final;<br/>        short Homework;<br/>        short Projects;<br/>};<br/><br/><br/>class myClass<br/>{<br/>public:<br/><br/>// Room for a 64-character zero-terminated string:<br/><br/>        char Name[65];<br/><br/>        // Typically a 2-byte integer in C/C++:<br/><br/>        short Major;<br/><br/>        // Room for an 11-character zero-terminated string:<br/><br/>        char SSN[12];<br/><br/>        // Each of the following is typically a 2-byte integer<br/><br/>        short Mid1;<br/>        short Mid2;<br/>        short Final;<br/>        short Homework;<br/>        short Projects;<br/>};</pre>&#13;
		<p class="indent">Although these two data structures contain the same fields, and you would access those fields the same way, their memory implementation is slightly different. A typical memory layout for the structure appears in <a href="ch11.xhtml#ch11fig3">Figure 11-3</a>, which can be compared with the memory layout for the class shown in <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>. (<a href="ch11.xhtml#ch11fig3">Figure 11-3</a> is the same as <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>, but appears here for easy comparison with <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>.)</p>&#13;
		<div class="image" id="ch11fig3">&#13;
			<span epub:type="pagebreak" id="page_365"/>&#13;
			<img alt="Image" src="../images/11fig03.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-3: The <span class="codeitalic">student</span> structure storage in memory</em></p>&#13;
		<div class="image" id="ch11fig4">&#13;
			<img alt="Image" src="../images/11fig04.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-4: The <span class="codeitalic">student</span> class storage in memory</em></p>&#13;
		<p class="indent">The <em>VMT pointer</em> is a field that appears if the class contains any class member functions (aka <em>methods</em>). Some C++ compilers do not emit a VMT pointer field if there are no member functions, in which case the <span class="literal">class</span> and <span class="literal">struct</span> objects will have the same layout in memory.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep">VMT <em>stands for</em> virtual method table <em>and will be discussed further in the section “Virtual Method Tables” on <a href="ch11.xhtml#page_367">page 367</a>.</em></p>&#13;
		</div>&#13;
		<p class="indent">Although a C++ class declaration could contain only data fields, classes generally contain member function definitions as well as data members. In the <span class="literal">myClass</span> example, you might have the following member functions:</p>&#13;
		<pre class="programs">&#13;
			class myClass<br/>{<br/>public:<br/><br/>// Room for a 64-character zero-terminated string:<br/><br/>        char Name[65];<br/><br/>        // Typically a 2-byte integer in C/C++:<br/><br/>        short Major;<br/><br/>        // Room for an 11-character zero-terminated string:<br/><br/>        char SSN[12];<br/><br/>        // Each of the following is typically a 2-byte integer<br/><br/>        short Mid1;<br/>        short Mid2;<br/><span epub:type="pagebreak" id="page_366"/>        short Final;<br/>        short Homework;<br/>        short Projects;<br/><br/>        // Member functions:<br/><br/>        double computeGrade( void );<br/>        double testAverage( void );<br/>};</pre>&#13;
		<p class="indent">The <span class="literal">computeGrade()</span> function might compute the total grade in the course (based on relative weights attached to the midterms, final, homework, and project scores). The <span class="literal">testAverage()</span> function might return the average of all the test scores.</p>&#13;
		<h4 class="h4" id="ch00lev2sec139"><strong>11.5.3 Class Declarations in C# and Java</strong></h4>&#13;
		<p class="noindent">C# and Java classes look very similar to C/C++ class declarations. Here’s a sample C# class declaration (which also works for Java):</p>&#13;
		<pre class="programs">&#13;
			class student<br/>{<br/>        // Room for a 64-character zero-terminated string:<br/><br/>        public char[] Name;<br/><br/>        // Typically a 2-byte integer in C/C++:<br/><br/>        public short Major;<br/><br/>        // Room for an 11-character zero terminated string:<br/><br/>        public char[] SSN;<br/><br/>        public short Mid1;<br/>        public short Mid2;<br/>        public short Final;<br/>        public short Homework;<br/>        public short Projects;<br/><br/>        public double computeGrade()<br/>        {<br/>            return Mid1 * 0.15 + Mid2 * 0.15 + Final *<br/>                   0.2 + Homework * 0.25 + Projects * 0.25;<br/>        }<br/>        public double testAverage()<br/>        {<br/>            return (Mid1 + Mid2 + Final) / 3.0;<br/>        }<br/>    };</pre>&#13;
		<h4 class="h4" id="ch00lev2sec140"><span epub:type="pagebreak" id="page_367"/><strong>11.5.4 Class Declarations in Delphi (Object Pascal)</strong></h4>&#13;
		<p class="noindent">Delphi (Object Pascal) classes look very similar to Pascal records. Classes use the <span class="literal">class</span> keyword instead of <span class="literal">record</span>, and you can include function prototype declarations in the class.</p>&#13;
		<pre class="programs">&#13;
			type<br/>  student =<br/>    class<br/>      Name:     string [64];<br/>      Major:    smallint;    // 2-byte integer in Delphi<br/>      SSN:      string[11];<br/>      Mid1:     smallint;<br/>      Mid2:     smallint;<br/>      Final:    smallint;<br/>      Homework: smallint;<br/>      Projects: smallint;<br/><br/>      function computeGrade:real;<br/>      function testAverage:real;<br/>  end;</pre>&#13;
		<h4 class="h4" id="ch00lev2sec141"><strong>11.5.5 Class Declarations in HLA</strong></h4>&#13;
		<p class="noindent">HLA classes look very similar to HLA records. Classes use the <span class="literal">class</span> keyword instead of <span class="literal">record</span>, and you can include function (method) prototype declarations in the class.</p>&#13;
		<pre class="programs">&#13;
			type<br/>    student:<br/>        class<br/>          var<br/>            sName:    char[65];<br/>            Major:    int16;<br/>            SSN:      char[12];<br/>            Mid1:     int16;<br/>            Mid2:     int16;<br/>            Final:    int16;<br/>            Homework: int16;<br/>            Projects: int16;<br/><br/>            method computeGrade;<br/>            method testAverage;<br/><br/>        endclass;</pre>&#13;
		<h4 class="h4" id="ch00lev2sec142"><strong>11.5.6 Virtual Method Tables</strong></h4>&#13;
		<p class="noindent">As you saw in <a href="ch11.xhtml#ch11fig3">Figures 11-3</a> and <a href="ch11.xhtml#ch11fig4">11-4</a>, the difference between the class definition and the structure definition is that the former contains a VMT field. VMT, which stands for <em>virtual method table</em>, is an array of pointers to all the member functions, or <em>methods</em>, within an object’s class. Virtual methods <span epub:type="pagebreak" id="page_368"/>(<em>virtual member functions</em> in C++) are special class-related functions that you declare as fields in the class. In the current student example, the class doesn’t actually have any virtual methods, so most C++ compilers would eliminate the VMT field, but some OOP languages will still allocate storage for the VMT pointer within the class.</p>&#13;
		<p class="indent">Here’s a little C++ class that actually has a virtual member function and, therefore, also has a VMT:</p>&#13;
		<pre class="programs">&#13;
			class myclass<br/>{<br/>    public:<br/>        int a;<br/>        int b;<br/>        virtual int f( void );<br/>};</pre>&#13;
		<p class="indent">When C++ calls a standard function, it directly calls that function. Virtual member functions are another story, as you can see in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>.</p>&#13;
		<div class="image" id="ch11fig5">&#13;
			<img alt="Image" src="../images/11fig05.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-5: A virtual method table in C++</em></p>&#13;
		<p class="indent">Calling a virtual member function requires <em>two</em> indirect accesses. First, the program has to fetch the VMT pointer from the class object and use that to indirectly fetch a particular virtual function address from the VMT. Then the program has to make an indirect call to the virtual member function via the pointer it retrieved from the VMT. As an example, consider the following C++ function:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/><br/>// A C++ class with two trivial<br/>// member functions (so the VMT<br/>// will have two entries).<br/><br/>class myclass<br/>{<br/>    public:<br/>        int a;<br/>        int b;<br/>        virtual int f( void );<br/><span epub:type="pagebreak" id="page_369"/>        virtual int g( void );<br/>};<br/><br/>// Some trivial member functions.<br/>// We're really only interested<br/>// in looking at the calls, so<br/>// these functions will suffice<br/>// for now.<br/><br/>int myclass::f( void )<br/>{<br/>    return b;<br/>}<br/><br/>int myclass::g( void )<br/>{<br/>    return a;<br/>}<br/><br/><br/>// A main function that creates<br/>// a new instance of myclass and<br/>// then calls the two member functions<br/><br/>int main( int argc, char **argv )<br/>{<br/>    myclass *c;<br/><br/>    // Create a new object:<br/><br/>    c = new myclass;<br/><br/>    // Call both member functions:<br/><br/>    c-&gt;a = c-&gt;f() + c-&gt;g();<br/>    return 0;<br/><br/>}</pre>&#13;
		<p class="indent">Here’s the corresponding x86-64 assembly code that Visual C++ generates:</p>&#13;
		<pre class="programs">&#13;
			; Here is the VMT for myclass. It contains<br/>; three entries:<br/>; a pointer to the constructor for myclass,<br/>; a pointer to the myclass::f member function,<br/>; and a pointer to the myclass::g member function.<br/><br/>CONST   SEGMENT<br/>??_7myclass@@6B@ DQ FLAT:??_R4myclass@@6B@ ; myclass::`vftable'<br/>        DQ      FLAT:?f@myclass@@UEAAHXZ<br/>        DQ      FLAT:?g@myclass@@UEAAHXZ<br/>CONST   ENDS<br/>;<br/><span epub:type="pagebreak" id="page_370"/>    .<br/>    .<br/>    .<br/>;<br/>; Allocate storage for a new instance of myclass:<br/>; 16 = two 4-byte ints plus 8-byte VMT pointer<br/>        mov     ecx, 16<br/><br/>        call    ??2@YAPEAX_K@Z             ; operator new<br/>        mov     rdi, rax                   ; Save pointer to allocated object<br/>        test    rax, rax                   ; Did NEW FAIL (returning NULL)?<br/>        je      SHORT $LN3@main<br/><br/>; Initialize VMT field with the address of the VMT:<br/><br/>        lea     rax, OFFSET FLAT:??_7myclass@@6B@<br/>        mov     QWORD PTR [rdi], rax<br/>        jmp     SHORT $LN4@main<br/>$LN3@main:<br/>        xor     edi, edi                   ; For failure, put NULL in EDI<br/><br/>; At this point, RDI contains the "THIS" pointer<br/>; that refers to the object in question. In this<br/>; particular code sequence, "THIS" is the address<br/>; of the object whose storage we allocated above.<br/><br/>; Get the VMT into RAX (first indirect access<br/>; needed to make a virtual member function call)<br/><br/>        mov     rax, QWORD PTR [rdi]<br/><br/>        mov     rcx, rdi                   ; Pass THIS in RCX<br/>        call    QWORD PTR [rax+8]          ; Call c-&gt;f()<br/>        mov     ebx, eax                   ; Save function result<br/><br/>        mov     rdx, QWORD PTR [rdi]       ; Load VMT into RDX<br/>        mov     rcx, rdi                   ; Pass THIS in RCX<br/>        call    QWORD PTR [rdx]            ; Call c-&gt;g()<br/><br/>; Compute sum of function results:<br/><br/>        add     ebx, eax<br/>        mov     DWORD PTR [rdi+8], ebx     ; Save sum in c-&gt;a</pre>&#13;
		<p class="indent">This example amply demonstrates why object-oriented programs generally run a little more slowly than standard procedural programs: extra indirection when calling virtual methods. C++ attempts to address this inefficiency by providing <em>static member functions</em>, but they lose many of the benefits of virtual member functions that make object-oriented programming possible.</p>&#13;
		<h4 class="h4" id="ch00lev2sec143"><span epub:type="pagebreak" id="page_371"/><strong>11.5.7 Abstract Methods</strong></h4>&#13;
		<p class="noindent">Some languages (such as C++) allow you to declare <em>abstract methods</em> within a class. An abstract method declaration tells the compiler that you will not be supplying the actual code for that method. Instead, you’re promising that some derived class will provide the method’s implementation. Here’s a version of <span class="literal">myclass</span> that has an abstract method:</p>&#13;
		<pre class="programs">&#13;
			class myclass<br/>{<br/>public:<br/>    int a;<br/>    int b;<br/>    virtual int f(void);<br/>    virtual int g(void);<br/>    virtual int h(void) = 0;<br/>};</pre>&#13;
		<p class="indent">Why the strange syntax? It doesn’t really make sense to assign <span class="literal">0</span> to a virtual function. Why not just use an <span class="literal">abstract</span> keyword (rather than <span class="literal">virtual</span>) like most other languages do? These are good questions. The answer probably has a lot to do with the fact that a <span class="literal">0</span> (<span class="literal">NULL</span> pointer) was being placed in the VMT entry for the abstract function. In modern versions of C++, compiler implementers typically place the address of some function that generates an appropriate runtime message (like <span class="literal">cannot call an abstract method</span>) here, rather than a <span class="literal">NULL</span> pointer. The following code snippet shows the Visual C++ VMT for this version of <span class="literal">myclass</span>:</p>&#13;
		<pre class="programs">&#13;
			CONST   SEGMENT<br/>??_7myclass@@6B@ DQ FLAT:??_R4myclass@@6B@              ; myclass::`vftable'<br/>        DQ      FLAT:?f@myclass@@UEAAHXZ<br/>        DQ      FLAT:?g@myclass@@UEAAHXZ<br/>        DQ      FLAT:_purecall<br/>CONST   ENDS</pre>&#13;
		<p class="indent">The <span class="literal">_purecall</span> entry corresponds to the abstract function <span class="literal">h()</span>. This is the name of the subroutine that handles illegal calls to abstract functions. When you override an abstract function, the C++ compiler replaces the pointer in the VMT to the <span class="literal">_purecall</span> function with the address of the overriding function (just as it would replace the address of any overridden function).</p>&#13;
		<h4 class="h4" id="ch00lev2sec144"><strong>11.5.8 Sharing VMTs</strong></h4>&#13;
		<p class="noindent">For a given class there is only one copy of the VMT in memory. This is a static object, so all objects of a given class type share the same VMT. This is reasonable, because all objects of the same class type have exactly the same member functions (see <a href="ch11.xhtml#ch11fig6">Figure 11-6</a>).</p>&#13;
		<div class="image" id="ch11fig6">&#13;
			<span epub:type="pagebreak" id="page_372"/>&#13;
			<img alt="Image" src="../images/11fig06.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-6: Objects sharing the same VMT (note that objects are all the same class type)</em></p>&#13;
		<p class="indent">Because the addresses in a VMT never change during program execution, most languages place the VMT in a constant (write-protected) section in memory. In the previous example, the compiler places the <span class="literal">myclass</span> VMT in the <span class="literal">CONST</span> segment.</p>&#13;
		<h4 class="h4" id="ch00lev2sec145"><strong>11.5.9 Inheritance in Classes</strong></h4>&#13;
		<p class="noindent">Inheritance is one of the fundamental concepts behind object-oriented programming. The basic idea is that a class inherits, or copies, all the fields from some existing class and then possibly expands the number of fields in the new class data type. For example, suppose you created a data type point that describes a point in the planar (two-dimensional) space. The class for this point might look like the following:</p>&#13;
		<pre class="programs">&#13;
			class point<br/>{<br/>    public:<br/>        float x;<br/>        float y;<br/><br/>        virtual float distance( void );<br/>};</pre>&#13;
		<p class="indent">The <span class="literal">distance()</span> member function would probably compute the distance from the origin (0,0) to the coordinate specified by the (<span class="literal">x</span>,<span class="literal">y</span>) fields of the object.</p>&#13;
		<p class="indent">Here’s a typical implementation of this member function:</p>&#13;
		<pre class="programs">&#13;
			float point::distance( void )<br/>{<br/>    return sqrt( x*x + y*y );<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_373"/>Inheritance allows you to extend an existing class by adding new fields or replacing existing fields. For example, suppose you want to extend the two-dimensional point definition to a third spatial dimension. You can easily do this with the following C++ class definition:</p>&#13;
		<pre class="programs">&#13;
			class point3D :public point<br/>{<br/>    public:<br/>        float z;<br/><br/>        virtual void rotate( float angle1, float angle2 );<br/>};</pre>&#13;
		<p class="indent">The <span class="literal">point3D</span> class inherits the <span class="literal">x</span> and <span class="literal">y</span> fields, as well as the <span class="literal">distance()</span> member function. (Of course, <span class="literal">distance()</span> does not compute the proper result for a point in three-dimensional space, but I’ll address that in a moment.) By “inherits,” I mean that <span class="literal">point3D</span> objects locate their <span class="literal">x</span> and <span class="literal">y</span> fields at exactly the same offsets as <span class="literal">point</span> objects do (see <a href="ch11.xhtml#ch11fig7">Figure 11-7</a>).</p>&#13;
		<div class="image" id="ch11fig7">&#13;
			<img alt="Image" src="../images/11fig07.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-7: Inheritance in classes</em></p>&#13;
		<p class="indent">As you might have noticed, there were actually two items added to the <span class="literal">point3D</span> class—a new data field, <span class="literal">z</span>, and a new member function, <span class="literal">rotate()</span>. In <a href="ch11.xhtml#ch11fig7">Figure 11-7</a>, you can see that adding the <span class="literal">rotate()</span> virtual member function has had no impact at all on the layout of a <span class="literal">point3D</span> object. This is because virtual member functions’ addresses appear in the VMT, not in the object itself. Although both <span class="literal">point</span> and <span class="literal">point3D</span> contain a field named <span class="literal">VMT</span>, these fields do not point at the same table in memory. Every class has its own unique VMT, which, as previously defined, consists of an array of pointers to all of the member functions (inherited or explicitly declared) for the class (see <a href="ch11.xhtml#ch11fig8">Figure 11-8</a>).</p>&#13;
		<div class="image" id="ch11fig8">&#13;
			<img alt="Image" src="../images/11fig08.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-8: VMTs for inherited classes (assuming 32-bit pointers)</em></p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_374"/>All the objects for a given class share the same VMT, but this is not true for objects of different classes. Because <span class="literal">point</span> and <span class="literal">point3D</span> are different classes, their objects’ VMT fields will point at different VMTs in memory. (See <a href="ch11.xhtml#ch11fig9">Figure 11-9</a>.)</p>&#13;
		<div class="image" id="ch11fig9">&#13;
			<img alt="Image" src="../images/11fig09.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-9: VMT access</em></p>&#13;
		<p class="indent">One problem with the <span class="literal">point3D</span> definition given thus far is that it inherits the <span class="literal">distance()</span> function from the <span class="literal">point</span> class. By default, if a class inherits member functions from some other class, the entries in the VMT corresponding to those inherited functions will point at the functions associated with the base class. If you have an object pointer variable of type <span class="literal">point3D</span>, let’s say <span class="literal">p3D</span>, and you invoke the member function <span class="literal">p3D-&gt;distance()</span>, you will not get a correct result. Because <span class="literal">point3D</span> inherits the <span class="literal">distance()</span> function from class <span class="literal">point</span>, <span class="literal">p3-&gt;distance()</span> will compute the distance to the projection of (<span class="literal">x,y,z</span>) onto the two-dimensional plane rather than the correct value on the three-dimensional plane. In C++ you can overcome this problem by <em>overloading</em> the inherited function and writing a new, <span class="literal">point3D</span>-specific member function like so:</p>&#13;
		<pre class="programs">&#13;
			class point3D :public point<br/>{<br/>    public:<br/>        float z;<br/><br/>        virtual float distance( void );<br/>        virtual void rotate( float angle1, float angle2 );<br/>};<br/><span epub:type="pagebreak" id="page_375"/>float point3D::distance( void )<br/>{<br/>    return sqrt( x*x + y*y + z*z );<br/>}</pre>&#13;
		<p class="indent">Creating an overloaded member function does not change the layout of the class’s data or the layout of the <span class="literal">point3D</span> VMT. The only change this function evokes is that the C++ compiler initializes the <span class="literal">distance()</span> entry in the <span class="literal">point3D</span> VMT with the address of the <span class="literal">point3D::distance()</span> function rather than the address of the <span class="literal">point::distance()</span> function.</p>&#13;
		<h4 class="h4" id="ch00lev2sec146"><strong>11.5.10 Polymorphism in Classes</strong></h4>&#13;
		<p class="noindent">In addition to inheritance and overloading, <em>polymorphism</em> is the other anchor upon which object-oriented programming is based. Polymorphism, which literally means “many-faced” (or, translated a little better, “many forms” or “many shapes”), describes how a single instance of a function call in your program, such as <span class="literal">x-&gt;distance()</span>, could wind up calling different functions (in the examples from the previous section, this could be the <span class="literal">point::distance()</span> or <span class="literal">point3D::distance()</span> function). What makes this possible is the fact that C++ relaxes its type-checking facilities a bit when dealing with derived (inherited) classes.</p>&#13;
		<p class="indent">Let’s look at an example. Normally, a C++ compiler will generate an error if you try to do the following:</p>&#13;
		<pre class="programs">&#13;
			float f;<br/>int *i;<br/>    .<br/>    .<br/>    .<br/>i = &amp;f; // C++ isn't going to allow this.</pre>&#13;
		<p class="indent">C++ does not allow you to assign the address of some object to a pointer whose base type doesn’t exactly match the object’s type—with one major exception. C++ relaxes this restriction so you can assign the address of some object to a pointer as long as the pointer’s base type either matches <em>or is an ancestor of</em> the object’s type (an ancestor class is one from which some other class type is derived, directly or indirectly, via inheritance). That means the following code is legal:</p>&#13;
		<pre class="programs">&#13;
			point *p;<br/>point3D *t;<br/>point *generic;<br/><br/>    p = new point;<br/>    t = new point3D;<br/>        .<br/>        .<br/>        .<br/>    generic = t;</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_376"/>If you’re wondering how this could be legitimate, take another look at <a href="ch11.xhtml#ch11fig7">Figure 11-7</a>. If <span class="literal">generic</span>’s base type is <span class="literal">point</span>, then the C++ compiler will allow access to a VMT at offset 0 in the object, an <span class="literal">x</span> field at offset 4 (8 on 64-bit machines) in the object, and a <span class="literal">y</span> field at offset 8 (16) in the object. Similarly, any attempt to invoke the <span class="literal">distance()</span> member function will access the function pointer at offset 0 into the VMT pointed at by the object’s VMT field. If <span class="literal">generic</span> points at an object of type <span class="literal">point</span>, all of these requirements are satisfied. This is also true if <span class="literal">generic</span> points at any derived class of <span class="literal">point</span> (that is, any class that inherits the fields from <span class="literal">point</span>). None of the extra fields in the derived class (<span class="literal">point3D</span>) will be accessible via the generic pointer, but that’s to be expected because <span class="literal">generic</span>’s base class is <span class="literal">point</span>.</p>&#13;
		<p class="indent">A crucial thing to note, however, is that when you invoke the <span class="literal">distance()</span> member function, you’re calling the one pointed at by the <span class="literal">point3D</span> VMT, not the one pointed at by the <span class="literal">point</span> VMT. This fact is the basis for polymorphism in an OOP language such as C++. The code a compiler emits is exactly the same code it would emit if <span class="literal">generic</span> contained the address of an object of type <span class="literal">point</span>. All of the “magic” occurs because the compiler allows the programmer to load the address of a <span class="literal">point3D</span> object into <span class="literal">generic</span>.</p>&#13;
		<h4 class="h4" id="ch00lev2sec147"><strong>11.5.11 Multiple Inheritance (in C++)</strong></h4>&#13;
		<p class="noindent">C++ is one of the few modern programming languages that support <em>multiple inheritance</em>, whereby a class can inherit the data and member functions from multiple classes. Consider the following C++ code fragment:</p>&#13;
		<pre class="programs">&#13;
			class a<br/>{<br/>    public:<br/>        int i;<br/>        virtual void setI(int i) { this-&gt;i = i; }<br/>};<br/><br/>class b<br/>{<br/>    public:<br/>        int j;<br/>        virtual void setJ(int j) { this-&gt;j = j; }<br/>};<br/><br/>class c : public a, public b<br/>{<br/>    public:<br/>        int k;<br/>        virtual void setK(int k) { this-&gt;k = k; }<br/>};</pre>&#13;
		<p class="indent">In this example, class <span class="literal">c</span> inherits all the information from classes <span class="literal">a</span> and <span class="literal">b</span>. In memory, a typical C++ compiler will create an object like that shown in <a href="ch11.xhtml#ch11fig10">Figure 11-10</a>.</p>&#13;
		<div class="image" id="ch11fig10">&#13;
			<span epub:type="pagebreak" id="page_377"/>&#13;
			<img alt="Image" src="../images/11fig10.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-10: Multiple inheritance memory layout</em></p>&#13;
		<p class="indent">The VMT pointer entry points at a typical VMT containing the addresses of the <span class="literal">setI()</span>, <span class="literal">setJ()</span>, and <span class="literal">setK()</span> methods, as shown in <a href="ch11.xhtml#ch11fig11">Figure 11-11</a>. If you call the <span class="literal">setI()</span> method, the compiler will generate code that loads the <span class="literal">this</span> pointer with the address of the VMT pointer entry in the object (the base address of the <span class="literal">c</span> object in <a href="ch11.xhtml#ch11fig10">Figure 11-10</a>). Upon entry into <span class="literal">setI()</span>, the system believes that <span class="literal">this</span> is pointing at an object of type <span class="literal">a</span>. In particular, the <span class="literal">this</span>.<span class="literal">VMT</span> field points at a VMT whose first (and, as far as type <span class="literal">a</span> is concerned, only) entry is the address of the <span class="literal">setI()</span> method. Likewise, at offset (<span class="literal">this+8</span>) in memory (as the VMT pointer is 8 bytes, assuming 64-bit pointers), the <span class="literal">setI()</span> method will find the <span class="literal">i</span> data value. As far as <span class="literal">setI()</span> is concerned, <span class="literal">this</span> is pointing at a class type <span class="literal">a</span> object (even though it’s actually pointing at a type <span class="literal">c</span> object).</p>&#13;
		<div class="image" id="ch11fig11">&#13;
			<img alt="Image" src="../images/11fig11.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-11: Multiple inheritance <span class="codeitalic">this</span> values</em></p>&#13;
		<p class="indent">When you call the <span class="literal">setK()</span> method, the system also passes the base address of the <span class="literal">c</span> object. Of course, <span class="literal">setK()</span> is expecting a type <span class="literal">c</span> object and <span class="literal">this</span> is pointing at a type <span class="literal">c</span> object, so all the offsets into the object are exactly as <span class="literal">setK()</span> expects. Note that objects of type <span class="literal">c</span> (and methods in the <span class="literal">c</span> class) will normally ignore the <span class="literal">VMT2</span> pointer field in the <span class="literal">c</span> object.</p>&#13;
		<p class="indent">The problem occurs when the program attempts to call the <span class="literal">setJ()</span> method. Because <span class="literal">setJ()</span> belongs to class <span class="literal">b</span>, it expects <span class="literal">this</span> to hold the address of a VMT pointer pointing at a VMT for class <span class="literal">b</span>. It also expects to find data field <span class="literal">j</span> at offset (<span class="literal">this+8</span>). Were we to pass the <span class="literal">c</span> object’s <span class="literal">this</span> pointer to <span class="literal">setJ()</span>, accessing (<span class="literal">this+8</span>) would reference the <span class="literal">i</span> data field, not <span class="literal">j</span>. Furthermore, were a class <span class="literal">b</span> method to make a call to another method in class <span class="literal">b</span> (such as <span class="literal">setJ()</span> making a recursive call to itself), the VMT pointer would be wrong—it points at a VMT with a pointer to <span class="literal">setI()</span> at offset 0, whereas class <span class="literal">b</span> expects it to point at a VMT with a pointer to <span class="literal">setJ()</span> at <span epub:type="pagebreak" id="page_378"/>offset 0. To resolve this issue, a typical C++ compiler will insert an extra VMT pointer into the <span class="literal">c</span> object immediately prior to the <span class="literal">j</span> data field. It will initialize this second VMT field to point into the <span class="literal">c</span> VMT at the location where the class <span class="literal">b</span> method pointers begin (see <a href="ch11.xhtml#ch11fig11">Figure 11-11</a>). When calling a method in class <span class="literal">b</span>, the compiler will emit code that initializes the <span class="literal">this</span> pointer with the address of this second VMT pointer (rather than pointing at the beginning of <span class="literal">c</span>-type object in memory). Now, upon entry to a class <span class="literal">b</span> method—such as <span class="literal">setJ()</span>—<span class="literal">this</span> will point at a legitimate VMT pointer for class <span class="literal">b</span>, and the <span class="literal">j</span> data field will appear at the offset (<span class="literal">this+8</span>) that class <span class="literal">b</span> methods expect.</p>&#13;
		<h3 class="h3" id="ch00lev1sec97"><strong>11.6 Protocols and Interfaces</strong></h3>&#13;
		<p class="noindent">Java and Swift don’t support multiple inheritance, because it has some logical problems. The classic example is the “diamond lattice” data structure. This occurs when two classes (say, <span class="literal">b</span> and <span class="literal">c</span>) both inherit information from the same class (say, <span class="literal">a</span>), and then a fourth class (say, <span class="literal">d</span>) inherits from both <span class="literal">b</span> and <span class="literal">c</span>. As a result, <span class="literal">d</span> inherits the data from <span class="literal">a</span> twice—once through <span class="literal">b</span> and once through <span class="literal">c</span>. This can create some consistency problems.</p>&#13;
		<p class="indent">Although multiple inheritance can lead to some weird problems like this, there’s no question that being able to inherit from multiple locations is often useful. Thus, the solution in languages like Java and Swift is to allow a class to inherit methods/functions from multiple parents but allow inheritance from only a single ancestor class. This avoids most of the problems with multiple inheritance (specifically, an ambiguous choice of inherited data fields) while allowing programmers to include methods from various sources. Java calls such extensions <em>interfaces</em>, and Swift calls them <em>protocols</em>.</p>&#13;
		<p class="indent">Here’s an example of a couple Swift protocol declarations and a class supporting that protocol:</p>&#13;
		<pre class="programs">&#13;
			protocol someProtocol<br/>{<br/>    func doSomething()-&gt;Void;<br/>    func doSomethingElse() -&gt;Void;<br/>}<br/>protocol anotherProtocol<br/>{<br/>    func doThis()-&gt;Void;<br/>    func doThat() -&gt;Void;<br/>}<br/><br/>class supportsProtocols: someProtocol, anotherProtocol<br/>{<br/>    var i:Int = 0;<br/>    func doSomething()-&gt;Void<br/>    {        // appropriate function body<br/>    }<br/>    func doSomethingElse()-&gt;Void<br/><span epub:type="pagebreak" id="page_379"/>    {        // appropriate function body<br/>    }<br/>    func doThis()-&gt;Void<br/>    {        // appropriate function body<br/>    }<br/>    func doThat()-&gt;Void<br/>    {        // appropriate function body<br/>    }<br/><br/>}</pre>&#13;
		<p class="indent">Swift protocols don’t supply any functions. Instead, a class that supports a protocol promises to provide an implementation of the functions the protocol(s) specify. In the preceding example, the <span class="literal">supportsProtocols</span> class is responsible for supplying all functions required by the protocols it supports. Effectively, protocols are like abstract classes containing only abstract methods—the inheriting class must provide actual implementations for all the abstract methods.</p>&#13;
		<p class="indent">Here’s the previous example coded in Java and demonstrating its comparable mechanism, the interface:</p>&#13;
		<pre class="programs">&#13;
			interface someInterface<br/>{<br/>    void doSomething();<br/>    void doSomethingElse();<br/>}<br/>interface anotherInterface<br/>{<br/>    void doThis();<br/>    void doThat();<br/>}<br/><br/>class supportsInterfaces  implements someInterface, anotherInterface<br/>{<br/>    int i;<br/>    public void doSomething()<br/>    {<br/>        // appropriate function body<br/>    }<br/>    public void doSomethingElse()<br/>    {<br/>        // appropriate function body<br/>    }<br/>    public void doThis()<br/>    {<br/>        // appropriate function body<br/>    }<br/>    public void doThat()<br/>    {<br/><span epub:type="pagebreak" id="page_380"/>        // appropriate function body<br/>    }<br/>}</pre>&#13;
		<p class="indent">Interfaces/protocols behave somewhat like base class types in Java and Swift. If you instantiate a class object and assign that instance to a variable that is an interface/protocol type, you can execute the supported member functions for that interface/protocol. Consider the following Java example:</p>&#13;
		<pre class="programs">&#13;
			someInterface some = new supportsInterfaces();<br/><br/>// We can call the member functions defined for someInterface:<br/><br/>some.doSomething();<br/>some.doSomethingElse();<br/><br/>// Note that it is illegal to try and call doThis or doThat<br/>// (or access the i data field)<br/>// using the "some" variable.</pre>&#13;
		<p class="indent">Here’s a comparable example in Swift:</p>&#13;
		<pre class="programs">&#13;
			import Foundation<br/><br/>protocol a<br/>{<br/>    func b()-&gt;Void;<br/>    func c()-&gt;Void;<br/>}<br/><br/>protocol d<br/>{<br/>    func e()-&gt;Void;<br/>    func f()-&gt;Void;<br/>}<br/>class g : a, d<br/>{<br/>    var i:Int = 0;<br/><br/>    func b()-&gt;Void {print("b")}<br/>    func c()-&gt;Void {print("c")}<br/>    func e()-&gt;Void {print("e")}<br/>    func f()-&gt;Void {print("f")}<br/><br/>    func local()-&gt;Void {print( "local to g" )}<br/>}<br/><br/><br/>var x:a = g()<br/>x.b()<br/>x.c()</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_381"/>The implementation of a protocol or interface is quite simple—it’s just a pointer to a VMT that contains the addresses of the functions declared in that protocol/interface. So, the data structure for the Swift <span class="literal">g</span> class in the previous example would have three VMT pointers in it: one for protocol <span class="literal">a</span>, one for protocol <span class="literal">d</span>, and one for the class <span class="literal">g</span> (holding a pointer to the <span class="literal">local()</span> function). <a href="ch11.xhtml#ch11fig12">Figure 11-12</a> shows the class and VMT layout.</p>&#13;
		<div class="image" id="ch11fig12">&#13;
			<img alt="Image" src="../images/11fig12.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 11-12: Multiple inheritance memory layout</em></p>&#13;
		<p class="indent">In <a href="ch11.xhtml#ch11fig12">Figure 11-12</a> the VMT pointer for class <span class="literal">g</span> contains the address of the entire VMT. There are two entries in the class that contain pointers to the VMTs for protocol <span class="literal">a</span> and protocol <span class="literal">d</span>. As the VMT for class <span class="literal">g</span> also contains pointers to the functions belonging to these protocols, there’s no need to create a separate VMT for these two protocols; instead, the <span class="literal">aPtr</span> and <span class="literal">dPtr</span> fields can point to the corresponding entries within class <span class="literal">g</span>’s VMT.</p>&#13;
		<p class="indent">When the assignment <span class="literal">var x:a = g()</span> occurs in the previous example, the Swift code will load variable <span class="literal">x</span> with the <span class="literal">aPtr</span> pointer held in the <span class="literal">g</span> object. Therefore, the calls to <span class="literal">x.b()</span> and <span class="literal">x.c()</span> work just like a normal method call—the system uses the pointer held in <span class="literal">x</span> to reference the VMT and then it calls <span class="literal">b</span> or <span class="literal">c</span> by indexing the appropriate amount into the VMT. Had <span class="literal">x</span> been of type <span class="literal">d</span> rather than <span class="literal">a</span>, then the assignment <span class="literal">var x:d = g()</span> would have loaded <span class="literal">x</span> with the address of the <span class="literal">d</span> protocol VMT (pointed at by <span class="literal">dPtr</span>). Calls to <span class="literal">d</span> and <span class="literal">e</span> would happen at offsets 0 and 8 (64-bit pointers) into the <span class="literal">d</span> VMT.</p>&#13;
		<h3 class="h3" id="ch00lev1sec98"><strong>11.7 Classes, Objects, and Performance</strong></h3>&#13;
		<p class="noindent">As you’ve seen in this chapter, the direct cost associated with object-oriented programming isn’t terribly significant. Calls to member functions (methods) are a bit more expensive because of double indirection; however, that’s a small price to pay for the flexibility OOP gives you. The extra instructions and memory accesses will probably cost only about 10 percent of your application’s total performance. Some languages, such as C++ and HLA, support the notion of a <em>static member function</em> that allows direct calls to member functions when polymorphism is unnecessary.</p>&#13;
		<p class="indent">The big problem that object-oriented programmers sometimes face is taking things to an extreme. Rather than directly accessing the fields of an object, they write accessor functions to read and write those field values. Unless the compiler does a very good job of inlining such accessor functions, the cost of accessing the object’s fields increases by about an order of magnitude. In other words, application performance can actually suffer <span epub:type="pagebreak" id="page_382"/>when OOP paradigms are overused. There may be good reasons for doing things the “object-oriented way” (such as using accessor functions to access all fields of an object), but keep in mind that these costs add up rather quickly. Unless you absolutely need the facilities provided by OOP techniques, your programs may wind up running considerably slower (and taking up a whole lot more space) than necessary.</p>&#13;
		<p class="indent">Swift is a good example of object-oriented programming taken to an extreme. Anyone who has compared the performance of compiled Swift code against an equivalent C++ program knows that Swift is much slower. Largely, this is because Swift makes objects out of everything (and constantly checks their types and bounds at runtime). The result is that it can take hundreds of machine instructions in Swift to do the same task as a half-dozen machine instructions produced by an optimizing C++ compiler.</p>&#13;
		<p class="indent">Another common problem with many object-oriented programs is overgeneralization. This can occur when a programmer uses a lot of class libraries, extending classes through inheritance in order to solve some problem with as little programming effort as possible. While saving programming effort is generally a good idea, extending class libraries can lead to situations where you need some minor task done and you call a library routine that does everything you want. The problem is that in object-oriented systems, library routines tend to be highly layered. That is, you need some work done, so you invoke some member function from a class you’ve inherited. That function probably does a little bit of work on the data you pass it and then it calls a member function in a class that it inherits. And then that function massages the data a bit and calls a member function it inherits, and so on down the line. Before too long, the CPU spends more time calling and returning from functions than it does doing any useful work. While this same situation could occur in standard (non-OOP) libraries, it’s far more common in object-oriented applications.</p>&#13;
		<p class="indent">Carefully designed object-oriented programs needn’t run significantly slower than comparable procedural programs. Just be careful not to make a lot of expensive function calls to do trivial tasks.</p>&#13;
		<h3 class="h3" id="ch00lev1sec99"><strong>11.8 For More Information</strong></h3>&#13;
		<p class="bib">Dershem, Herbert, and Michael Jipping. <em>Programming Languages, Structures and Models</em>. Belmont, CA: Wadsworth, 1990.</p>&#13;
		<p class="bib">Duntemann, Jeff. <em>Assembly Language Step-by-Step</em>. 3rd ed. Indianapolis: Wiley, 2009.</p>&#13;
		<p class="bib">Ghezzi, Carlo, and Jehdi Jazayeri. <em>Programming Language Concepts</em>. 3rd ed. New York: Wiley, 2008.</p>&#13;
		<p class="bib">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
		<p class="bib">Knuth, Donald. <em>The Art of Computer Programming, Volume I: Fundamental Algorithms.</em> 3rd ed. Boston: Addison-Wesley Professional, 1997.</p>&#13;
		<p class="bib"><span epub:type="pagebreak" id="page_383"/>Ledgard, Henry, and Michael Marcotty. <em>The Programming Language Landscape</em>. Chicago: SRA, 1986.</p>&#13;
		<p class="bib">Louden, Kenneth C., and Kenneth A. Lambert. <em>Programming Languages, Principles and Practice</em>. 3rd ed. Boston: Course Technology, 2012.</p>&#13;
		<p class="bib">Pratt, Terrence W., and Marvin V. Zelkowitz. <em>Programming Languages, Design and Implementation</em>. 4th ed. Upper Saddle River, NJ: Prentice Hall, 2001.</p>&#13;
		<p class="bib">Sebesta, Robert. <em>Concepts of Programming Languages</em>. 11th ed. Boston: Pearson, 2016.<span epub:type="pagebreak" id="page_384"/></p>&#13;
	</body></html>