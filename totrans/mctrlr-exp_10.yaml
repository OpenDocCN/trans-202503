- en: '**10  STM32F0 SWD Word Leak**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many microcontrollers allow for some sort of partial locking mode, in which
    a debugger may be attached but code is still protected. On the STM32 family, this
    corresponds to RDP Level 1, where flash memory is disconnected after the debugger
    connects. This chapter describes a vulnerability in the STM32F0 series, in which
    flash memory is disconnected two clock cycles too late. A carefully orchestrated
    debugger can dump one word per connection.
  prefs: []
  type: TYPE_NORMAL
- en: This vulnerability was first described at Usenix WOOT, near the end of Obermaier
    and Tatschner (2017).
  prefs: []
  type: TYPE_NORMAL
- en: '**The Bug**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 2](ch02.xhtml#ch02), STM32’s readout device protection
    (RDP) feature has three levels. Level 0 is unprotected, while Level 2 is a total
    JTAG lockout, rejecting all connection attempts. Level 1 is the in-between setting
    that most commercial devices are locked with; it works by disconnecting flash
    memory from the bus when JTAG is connected. The intent was to allow for failure
    analysis or reprogramming, while still preventing extraction of flash memory for
    cloning or reverse engineering.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify this with OpenOCD or another JTAG debugger. The description
    holds: connecting to a locked chip works, but nothing useful can be read from
    flash memory. You can read out RAM, or write something into RAM, but code there
    cannot read or execute code from flash memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0106-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: STM32F042'
  prefs: []
  type: TYPE_NORMAL
- en: Obermaier’s unique observation is that most JTAG debuggers perform multiple
    transactions when connecting, and that the *very first* memory access is responsible
    for locking out flash memory, but that the read often completes before the lock
    is applied!
  prefs: []
  type: TYPE_NORMAL
- en: Why *often* and not always? The details don’t matter much for exploitation,
    but the original paper makes a convincing argument that it’s some sort of a bus
    contention issue. As a workaround, it seems sufficient to retry after failed accesses,
    and it might help in stubborn situations to add a random delay.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Exploit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obermaier’s exploit runs as standalone firmware in one STM32, which implements
    the SWD protocol to dump the contents of the target chip. Full source code is
    available, and the following is his function in C to dump one 32-bit word from
    protected memory. SWD is simpler to implement than JTAG, and in this exploit you’ll
    see that the SWD implementation is less than six hundred lines.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code must reconnect in a new debugging session for every attempt,
    as flash memory becomes disconnected after the read. Because individual attempts
    often fail, it must retry until the transaction succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0107-01.jpg)![Image](../images/f0108-01.jpg)'
  prefs: []
  type: TYPE_IMG
