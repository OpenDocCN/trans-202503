- en: '**17'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**17**'
- en: DATA STRUCTURES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构**
- en: '![Image](../images/pg297_Image_276.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg297_Image_276.jpg)'
- en: 'An essential part of programming is determining how best to organize data.
    In this chapter, we’ll cover two of the most fundamental ways of organizing data:
    arrays, which can be used for grouping data items of the same data type; and records,
    which can be used for grouping data items of different data types.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一个重要部分是确定如何最好地组织数据。在本章中，我们将介绍两种最基本的数据组织方式：数组，用于将相同数据类型的数据项分组；记录，用于将不同数据类型的数据项分组。
- en: These ways of organizing data determine how we access the individual data items.
    Both require two addressing items to locate a data item. Since the data items
    in an array are all of the same type, we can access an individual data item if
    we know the name of the array and the index number of the item. Accessing an individual
    data item in a record requires the name of the record and the name of the data
    item in the record.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据组织方式决定了我们如何访问单个数据项。两者都需要两个地址项来定位数据项。由于数组中的数据项都是相同类型，我们可以通过数组名和元素的索引值来访问单个数据项。访问记录中的单个数据项则需要记录名和数据项在记录中的名称。
- en: '**Arrays**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数组**'
- en: An *array* is a collection of data elements of the same data type, arranged
    in a sequence. We can access a single element in an array using the name of the
    array together with an *index value*, which specifies the number of the element
    relative to the beginning of the array. We have used `char` arrays in previous
    chapters to store ASCII characters as text strings. Each element in the array
    was the same type, a `char`, which is 1 byte. In our earlier applications, we
    were accessing each character in order, so we started with a pointer to the first
    `char` and simply incremented it by 1 to access each subsequent `char`. We didn’t
    need an index to locate each `char` within the text string array.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组* 是一组相同数据类型的数据元素，按顺序排列。我们可以使用数组的名称和*索引值*来访问数组中的单个元素，索引值指定元素相对于数组开始位置的编号。我们在前几章中使用了`char`数组来存储ASCII字符作为文本字符串。数组中的每个元素都是相同类型的`char`，即1字节。在之前的应用中，我们按顺序访问每个字符，因此我们从指向第一个`char`的指针开始，并通过将其递增1来访问每个后续的`char`。我们不需要索引来定位文本字符串数组中的每个`char`。'
- en: In this chapter, we’ll look at `int` arrays, which use 4 bytes for each data
    element in the array. If we started with a pointer to the first element, we’d
    need to increment it by 4 to access each subsequent element; it’s much easier
    to use the array index number to access each individual element. You’ll see how
    the index number is converted to an address offset to access an array element
    relative to the beginning of the array. You’ll also see that C passes arrays to
    other functions differently from other data items.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论`int`数组，每个数组元素占用4字节。如果我们从指向第一个元素的指针开始，我们需要将其递增4以访问每个后续元素；使用数组索引来访问每个单独元素会更加简便。你将看到如何将索引值转换为地址偏移量，以便相对于数组的起始位置访问数组元素。你还将看到C语言传递数组给其他函数的方式与传递其他数据项的方式不同。
- en: '***In C***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在C语言中***'
- en: We define an array in C by stating the element data type, giving the array a
    name, and specifying the number of elements in the array. Let’s start with the
    example in [Listing 17-1](ch17.xhtml#ch17list1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，我们通过指定元素数据类型、给数组命名并指定数组元素的数量来定义一个数组。让我们从[清单17-1](ch17.xhtml#ch17list1)中的示例开始。
- en: '*fill_array.c*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*fill_array.c*'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 17-1: A program to store* int *s in an array and display them*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单17-1：一个存储* int *并显示它们的程序*'
- en: This `main` function calls the `twice_index` function, which sets each element
    in the array to twice its index. For example, `twice_index` stores the `int` 8
    in array element number 4\. The `main` function then calls `display_array`, which
    prints the contents of the entire array in the terminal window.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`main`函数调用了`twice_index`函数，该函数将数组中的每个元素设置为其索引值的两倍。例如，`twice_index`将`int`类型的8存储在数组元素的第4个位置。然后，`main`函数调用`display_array`函数，打印整个数组的内容到终端窗口。
- en: You first encountered arrays in [Chapter 2](ch02.xhtml), when learning about
    C-style strings. Those strings used a sentinel value, `NUL`, to mark the end of
    the array. The array we’re using here doesn’t have a sentinel value, so we need
    to pass the number of elements in the array to each function that processes it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你第一次接触数组是在[第2章](ch02.xhtml)中，当时学习了C风格的字符串。那些字符串使用了一个哨兵值`NUL`来标记数组的结束。我们这里使用的数组没有哨兵值，因此我们需要将数组中的元素数量传递给每个处理它的函数。
- en: One thing you might notice about the arguments we’re passing to the functions
    is that it appears the array is being passed by value, since we give only its
    name in the argument list. But `twice_index` stores values in the array, so it
    needs to know where the array is located in memory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，我们传递给函数的参数看起来像是按值传递了数组，因为我们仅在参数列表中给出了数组的名称。但`twice_index`将值存储到数组中，因此它需要知道数组在内存中的位置。
- en: Usually, a programmer passes an input value to a function by value. But if the
    input consists of a large number of data items, copying them all into registers
    and onto the stack would be very inefficient; it makes more sense to pass by pointer.
    Arrays almost always have many data items, so the designers of the C language
    decided to always pass them by pointer. When you give the name of the array as
    an argument to a function call, C will pass the address of the first element of
    the array; thus, `twice_index` can output data to the array.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序员通过值传递一个输入值给函数。但如果输入包含大量数据项，将它们都复制到寄存器和栈中会非常低效；通过指针传递会更有意义。数组几乎总是包含许多数据项，因此C语言的设计者决定始终通过指针传递它们。当你将数组的名称作为参数传递给函数调用时，C会传递数组第一个元素的地址；因此，`twice_index`可以输出数据到数组中。
- en: To see this explicitly, let’s look at the compiler-generated assembly language
    for this `main` function, as shown in [Listing 17-2](ch17.xhtml#ch17list2).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地看到这一点，让我们来看一下该`main`函数的编译器生成的汇编语言，如[列表 17-2](ch17.xhtml#ch17list2)所示。
- en: '*fill_array.s*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*fill_array.s*'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 17-2: The compiler-generated assembly language for the function in
    [Listing 17-1](ch17.xhtml#ch17list1)*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-2：编译器生成的[列表 17-1](ch17.xhtml#ch17list1)中函数的汇编语言*'
- en: The entire `int` array is allocated in `main`’s stack frame ❶. In assembly language,
    the address of the array is passed both to the `twice_index` function ❷ and to
    the `display_array` function ❸. The elements of the array are inputs to the `display_array`
    function, so it does not need to know the address of the array, but it’s much
    more efficient to pass the address of the entire array than a copy of each of
    the array elements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`int`数组在`main`的栈帧中分配 ❶。在汇编语言中，数组的地址同时传递给`twice_index`函数 ❷和`display_array`函数
    ❸。数组的元素是`display_array`函数的输入，因此它不需要知道数组的地址，但传递整个数组的地址要比传递数组中每个元素的副本更高效。
- en: Next, we’ll look at the function to store the `int`s in the array, `twice_index`.
    [Listing 17-3](ch17.xhtml#ch17list3) shows its header file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看将`int`存储到数组中的函数`twice_index`。[列表 17-3](ch17.xhtml#ch17list3)显示了它的头文件。
- en: '*twice_index.h*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*twice_index.h*'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 17-3: The header file for the* twice_index *function*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-3：*twice_index*函数的头文件*'
- en: This prototype statement shows how we use the `[]` syntax to indicate that the
    argument to a function is an array. As described previously, we need to provide
    the number of elements in the array as a separate argument.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原型声明展示了我们如何使用`[]`语法来表示函数的参数是一个数组。如前所述，我们需要将数组的元素数量作为单独的参数提供。
- en: The definition of the `twice_index` function is given in [Listing 17-4](ch17.xhtml#ch17list4).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`twice_index`函数的定义见[列表 17-4](ch17.xhtml#ch17list4)。'
- en: '*twice_index.c*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*twice_index.c*'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 17-4: A function to store twice the index number in each element of
    an array*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-4：将数组中每个元素存储为索引值两倍的函数*'
- en: The number of iterations is known when this loop starts, so we use a `for` loop
    to process the array. The compiler generated the assembly language shown in [Listing
    17-5](ch17.xhtml#ch17list5) for the `twice_index` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环开始时，循环的迭代次数是已知的，因此我们使用`for`循环来处理数组。编译器为`twice_index`函数生成的汇编语言如[列表 17-5](ch17.xhtml#ch17list5)所示。
- en: '*twice_index.s*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*twice_index.s*'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 17-5: The compiler-generated assembly language for the function in
    [Listing 17-4](ch17.xhtml#ch17list4)*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-5：编译器生成的[列表 17-4](ch17.xhtml#ch17list4)中函数的汇编语言*'
- en: To access an array element, the compiler computes the offset of the element
    from the beginning of the array and then adds that offset to the address of the
    beginning. This is an array of `int`s, so each element is 4 bytes. The compiler
    shifts the array index, `i`, 2 bits to the left to multiply it by 4 ❶. Adding
    `4 * i` to the address of the beginning of the array gives the address of the
    array element ❷.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组元素，编译器计算元素相对于数组起始位置的偏移量，然后将这个偏移量加到数组起始地址上。这是一个`int`类型的数组，因此每个元素占用4个字节。编译器将数组索引`i`左移2位，以将其乘以4
    ❶。将`4 * i`加到数组起始地址上，就得到了数组元素的地址 ❷。
- en: Next, we’ll look at the `display_array` function used to display the contents
    of the array. [Listing 17-6](ch17.xhtml#ch17list6) shows the header file for this
    function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看用于显示数组内容的 `display_array` 函数。[列表 17-6](ch17.xhtml#ch17list6) 显示了此函数的头文件。
- en: '*display_array.h*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*display_array.h*'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 17-6: The header file for the* display_array *function*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-6：* display_array *函数的头文件*'
- en: As with the `twice_index` function, we use the `[]` syntax to indicate that
    the argument to the `display_array` function is an array. We also need to provide
    the number of elements in the array as a separate argument. The function definition
    is given in [Listing 17-7](ch17.xhtml#ch17list7).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `twice_index` 函数类似，我们使用 `[]` 语法来表示传递给 `display_array` 函数的参数是一个数组。我们还需要提供数组中元素的数量作为单独的参数。函数定义见
    [列表 17-7](ch17.xhtml#ch17list7)。
- en: '*display_array.c*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*display_array.c*'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 17-7: A function to display* int *s in an array*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-7：用于显示数组中* int *类型元素的函数*'
- en: To display the integers, we’re using the `put_int` function that you wrote in
    “Your Turn” [exercise 16.8](ch16.xhtml#ch16exe8) on [page 358](ch16.xhtml#ch16you2).
    [Listing 17-8](ch17.xhtml#ch17list8) shows the compiler-generated assembly language
    for this function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示整数，我们使用了你在“你的练习”[16.8 练习](ch16.xhtml#ch16exe8)中编写的 `put_int` 函数，位于[第 358
    页](ch16.xhtml#ch16you2)。[列表 17-8](ch17.xhtml#ch17list8) 显示了该函数的编译器生成的汇编语言。
- en: '*display_array.s*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*display_array.s*'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 17-8: The compiler-generated assembly language for the function in
    [Listing 17-7](ch17.xhtml#ch17list7)*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-8：为 [列表 17-7](ch17.xhtml#ch17list7) 中的函数生成的汇编语言*'
- en: Although the array is an input to the `display_array` function, C passes the
    address of the array to the called function ❶ ❸. As in the `twice_index` function,
    the compiler multiplies the index by 4 to get the offset of each `int` in the
    array ❷. Next, I’ll demonstrate a different way to index the array elements when
    writing this program directly in assembly language.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数组是 `display_array` 函数的输入，但 C 语言将数组的地址传递给被调用的函数 ❶ ❸。和 `twice_index` 函数一样，编译器将索引乘以
    4 来获取数组中每个 `int` 的偏移量 ❷。接下来，我将演示在直接用汇编语言编写此程序时如何以不同的方式对数组元素进行索引。
- en: '***In Assembly Language***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***汇编语言中***'
- en: Our approach to the `fill_array` program will be similar to the compiler’s,
    but we’ll use instructions that are a little more intuitive. [Listing 17-9](ch17.xhtml#ch17list9)
    shows our `main` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `fill_array` 程序的处理方法与编译器的类似，但我们将使用稍微直观的指令。[列表 17-9](ch17.xhtml#ch17list9)
    显示了我们的 `main` 函数。
- en: '*fill_array.s*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*fill_array.s*'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 17-9: The assembly language program to store* int *s in an array and
    display them*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-9：用于存储* int *类型元素并显示它们的汇编语言程序*'
- en: This is similar to what the compiler generated in [Listing 17-2](ch17.xhtml#ch17list2),
    except that we use more meaningful names. However, we’ll use a different way to
    compute the address of each array element in our `twice_index` function, as shown
    in [Listing 17-10](ch17.xhtml#ch17list10).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这与编译器在 [列表 17-2](ch17.xhtml#ch17list2) 中生成的内容类似，只是我们使用了更具意义的名称。然而，我们将在 `twice_index`
    函数中使用不同的方法来计算每个数组元素的地址，具体内容见 [列表 17-10](ch17.xhtml#ch17list10)。
- en: '*twice_index.s*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*twice_index.s*'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 17-10: The assembly language function to store twice the index number
    in each element of an array*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-10：将每个数组元素中的索引值乘以 2 的汇编语言函数*'
- en: We’re using a variant of the `str` instruction that uses a register to hold
    the offset from the base register instead of a constant ❶. In our case, the index
    is in a 32-bit register, `w2`, so the value needs to be extended to 64 bits before
    adding it to the address in the base register, `x0`. Since each element in the
    array is 4 bytes, the index value needs to be multiplied by 4 to give an address
    offset.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一种 `str` 指令变种，使用寄存器保存基址寄存器的偏移量，而不是常量 ❶。在我们的例子中，索引存储在 32 位寄存器 `w2` 中，因此值需要在加到基址寄存器
    `x0` 中的地址之前扩展到 64 位。由于数组中的每个元素为 4 字节，因此索引值需要乘以 4 以得到地址偏移量。
- en: 'Let’s look at the load and store instructions that use a register to hold the
    offset from a base register:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用寄存器保存基址寄存器偏移量的加载和存储指令：
- en: ldr**—Load register, base register–relative, register offset**
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ldr**—加载寄存器，基址寄存器相对，寄存器偏移量**
- en: '`ldr w`d `, [x`b `, w`o `,` xtnd `{` amnt `}]` loads `w`d with the 32-bit value
    at the memory location obtained by adding the address in `x`b and the value in
    `w`o, optionally shifted left 2 bits, extended to 64 bits.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr w`d `, [x`b `, w`o `,` xtnd `{` amnt `}]` 将 `w`d 加载为内存位置的 32 位值，该内存位置是通过将
    `x`b 中的地址与 `w`o 中的值相加，并可选择性地左移 2 位并扩展为 64 位。'
- en: '`ldr w`d `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` loads `w`d with the 32-bit
    value at the memory location obtained by adding the address in `x`b and the value
    in `x`o, optionally shifted left 2 bits.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr w`d `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` 从内存位置加载32位值到 `w`d，内存位置由 `x`b
    中的地址与 `x`o 中的值相加得到，值可以选择性地左移2位。'
- en: '`ldr x`d `, [x`b `, w`o `,` xtnd `{` amnt `}]` loads `x`d with the 64-bit value
    at the memory location obtained by adding the address in `x`b and the value in
    `w`o, optionally shifted left 3 bits, extended to 64 bits.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr x`d `, [x`b `, w`o `,` xtnd `{` amnt `}]` 从内存位置加载64位值到 `x`d，内存位置由 `x`b
    中的地址与 `w`o 中的值相加得到，值可以选择性地左移3位，并扩展到64位。'
- en: '`ldr x`d `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` loads `x`d with the 64-bit
    value at the memory location obtained by adding the address in `x`b and the value
    in `x`o, optionally shifted left 3 bits.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr x`d `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` 从内存位置加载64位值到 `x`d，内存位置由 `x`b
    中的地址与 `x`o 中的值相加得到，值可以选择性地左移3位。'
- en: str**—Store register, base register–relative, register offset**
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: str**—存储寄存器，基址寄存器相对，寄存器偏移**
- en: '`str w`s `, [x`b `, w`o `,` xtnd `{` amnt `}]` stores the 32-bit value in `w`s
    in the memory location obtained by adding the address in `x`b and the value in
    `w`o, optionally shifted left 2 bits, extended to 64 bits.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`str w`s `, [x`b `, w`o `,` xtnd `{` amnt `}]` 将32位值存储在 `w`s 中，存储位置由 `x`b 中的地址与
    `w`o 中的值相加得到，值可以选择性地左移2位，并扩展到64位。'
- en: '`str w`s `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` stores the 32-bit value in
    `w`s in the memory location obtained by adding the address in `x`b and the value
    in `x`o, optionally shifted left 2 bits.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`str w`s `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` 将32位值存储在 `w`s 中，存储位置由 `x`b
    中的地址与 `x`o 中的值相加得到，值可以选择性地左移2位。'
- en: '`str x`s `, [x`b `, w`o `,` xtnd `{` amnt `}]` stores the 64-bit value in `x`s
    in the memory location obtained by adding the address in `x`b and the value in
    `w`o, optionally shifted left 3 bits, extended to 64 bits.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`str x`s `, [x`b `, w`o `,` xtnd `{` amnt `}]` 将64位值存储在 `x`s 中，存储位置由 `x`b 中的地址与
    `w`o 中的值相加得到，值可以选择性地左移3位，并扩展到64位。'
- en: '`str x`s `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` stores the 64-bit value in
    `x`s in the memory location obtained by adding the address in `x`b and the value
    in `x`o, optionally shifted left 3 bits.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`str x`s `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` 将64位值存储在 `x`s 中，存储位置由 `x`b
    中的地址与 `x`o 中的值相加得到，值可以选择性地左移3位。'
- en: '[Table 17-1](ch17.xhtml#ch17tab1) lists the allowable values for the xtnd option
    for the `ldr` and `str` instructions.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 17-1](ch17.xhtml#ch17tab1) 列出了 `ldr` 和 `str` 指令中 `xtnd` 选项的允许值。'
- en: '**Table 17-1:** Allowable Values for xtnd in `ldr` and `str` Instructions'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Table 17-1:** `ldr` 和 `str` 指令中 `xtnd` 的允许值'
- en: '| xtnd | **Effect** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| xtnd | **效果** |'
- en: '| --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `uxtw` | Unsigned extension of word, optional left shift |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `uxtw` | 字长的无符号扩展， 可选左移 |'
- en: '| `lsl` | Left shift |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `lsl` | 左移 |'
- en: '| `sxtw` | Signed extension of word, optional left shift |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `sxtw` | 字长的有符号扩展， 可选左移 |'
- en: '| `sxtx` | Left shift |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `sxtx` | 左移 |'
- en: A 32-bit offset, `w`o, must be extended to 64 bits to be added to the address
    in the base register, `x`b. The `sxtx` option exists for syntactic symmetry; it
    has the same effect as `lsl`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 32位偏移量 `w`o 必须扩展到64位，以便与基址寄存器 `x`b 中的地址相加。`sxtx` 选项用于语法对称，它的效果与 `lsl` 相同。
- en: Allowable values for amnt are `0` or `2` for `w`d and `w`s registers, and `0`
    or `3` for `x`d and `x`s registers. This allows us to multiply the value in the
    offset register, `w`o or `x`o, by the number of bytes in the data element we are
    loading or storing. This makes it easy for us to convert an array index number
    into an array element address offset, as we saw in [Listing 17-10](ch17.xhtml#ch17list10)❶.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`amnt` 的允许值为 `0` 或 `2`，适用于 `w`d 和 `w`s 寄存器，`0` 或 `3` 适用于 `x`d 和 `x`s 寄存器。这使我们能够将偏移寄存器中的值，`w`o
    或 `x`o，乘以我们正在加载或存储的数据元素的字节数。这使得将数组索引转换为数组元素地址偏移变得简单，如我们在 [Listing 17-10](ch17.xhtml#ch17list10)❶
    中所见。'
- en: '[Listing 17-11](ch17.xhtml#ch17list11) shows the function for displaying the
    contents of the array.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 17-11](ch17.xhtml#ch17list11) 显示了用于显示数组内容的函数。'
- en: '*display_array.s*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*display_array.s*'
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 17-11: The assembly language function to display* int *s in an array*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-11: 显示数组中整数的汇编语言函数*'
- en: This function uses the same basic algorithm as the `twice_index` function, but
    it calls other functions, so we need to create a stack record ❶. We also need
    to save the `x19`, `x20`, and `x21` registers for the calling function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用与 `twice_index` 函数相同的基本算法，但它调用了其他函数，因此我们需要创建一个堆栈记录 ❶。我们还需要保存调用函数的 `x19`、`x20`
    和 `x21` 寄存器。
- en: Arrays are used to group data items of the same type. In the next section, we’ll
    look at how to group items of different data types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数组用于将相同类型的数据项组合在一起。在下一节中，我们将看看如何将不同数据类型的项组合在一起。
- en: '**YOUR TURN**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 17.1     Change the `twice_index` and `display_array` functions to use pass
    by pointer (`int *the_array`) instead of pass by array (`int the_array[]`). Compare
    the compiler-generated assembly language with that shown in [Listings 17-2](ch17.xhtml#ch17list2),
    [17-5](ch17.xhtml#ch17list5), and [17-8](ch17.xhtml#ch17list8).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 17.1      将`twice_index`和`display_array`函数修改为使用指针传递（`int *the_array`），而不是数组传递（`int
    the_array[]`）。将编译器生成的汇编语言与[Listings 17-2](ch17.xhtml#ch17list2)、[17-5](ch17.xhtml#ch17list5)和[17-8](ch17.xhtml#ch17list8)中的内容进行比较。
- en: 17.2     Modify the program in [Listings 17-9](ch17.xhtml#ch17list9) to [17-11](ch17.xhtml#ch17list11)
    to store 16 times the index number in each element of the array.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 修改[Listings 17-9](ch17.xhtml#ch17list9)中的程序，改为[17-11](ch17.xhtml#ch17list11)，使得每个数组元素存储16倍的索引值。
- en: '**Records**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**记录**'
- en: A *record* (or *structure*) allows a programmer to group several data items
    of possibly different data types together into a new programmer-defined data type.
    The location of each individual data item in a record is called a *field* or *element*.
    You may also see a field called a *member*, especially in object-oriented programming.
    I’ll cover C++ objects in the next chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录*（或*结构*）允许程序员将几个可能具有不同数据类型的数据项组合在一起，形成一个新的程序员定义的数据类型。记录中每个数据项的位置称为*字段*或*元素*。你也可能会看到一个字段被称为*成员*，特别是在面向对象编程中。我将在下一章介绍C++对象。'
- en: Since the fields in a record can have different sizes, accessing them is a bit
    more complex than accessing the data items in an array. I’ll first describe how
    this is done in C, and then we’ll look at how records are passed to other functions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于记录中的字段可能具有不同的大小，因此访问它们比访问数组中的数据项要复杂一些。我将首先介绍在C语言中如何实现，然后我们将看看如何将记录传递给其他函数。
- en: '***In C***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在C语言中***'
- en: Let’s start by looking at a program that defines a record, stores data in each
    of its fields, and then displays the values, as shown in [Listing 17-12](ch17.xhtml#ch17list12).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看一个定义记录、将数据存储到各个字段并显示这些值的程序，如[Listing 17-12](ch17.xhtml#ch17list12)所示。
- en: '*fill_record.c*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*fill_record.c*'
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 17-12: A program to store data in a record*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-12: 一个存储数据到记录中的程序*'
- en: 'We use the `struct` keyword to declare a record in C. The fields of the record
    are declared using the usual C syntax: a data type followed by the field name
    ❶. The entire sequence, starting with the `struct` keyword through the ending
    `}` bracket, defines a new data type ❷. We define a record variable by following
    this data type with a name for the variable. The individual fields of a record
    are accessed with the dot operator followed by the field name ❸.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`struct`关键字在C中声明一个记录。记录的字段使用通常的C语法声明：数据类型后跟字段名称 ❶。从`struct`关键字开始，到结束的`}`大括号为止，定义了一个新的数据类型
    ❷。我们通过在此数据类型后面加上变量名来定义一个记录变量。记录的各个字段通过点操作符加字段名称来访问 ❸。
- en: We can learn how the record is stored in memory by looking at the assembly language
    the compiler generates for this function, which is shown in [Listing 17-13](ch17.xhtml#ch17list13).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看编译器为此函数生成的汇编语言来了解记录在内存中的存储方式，如[Listing 17-13](ch17.xhtml#ch17list13)所示。
- en: '*fill_record.s*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*fill_record.s*'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 17-13: The compiler-generated assembly language for the* main *function
    in [Listing 17-12](ch17.xhtml#ch17list12)*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-13: 编译器生成的[Listing 17-12](ch17.xhtml#ch17list12)中main函数的汇编语言*'
- en: Like other local variables, the record is allocated in the function’s stack
    frame. The individual fields in the record are accessed by offsets from the stack
    pointer ❶. [Figure 17-1](ch17.xhtml#ch17fig1) shows the stack frame used by the
    compiler for this `main` function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他局部变量一样，记录也分配在函数的堆栈框架中。记录中各个字段通过从堆栈指针的偏移量来访问 ❶。[Figure 17-1](ch17.xhtml#ch17fig1)
    显示了编译器为这个 `main` 函数使用的堆栈框架。
- en: '![Image](../images/pg402_Image_287.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg402_Image_287.jpg)'
- en: '*Figure 17-1: The stack frame for fields in a record*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 17-1: 记录中字段的堆栈框架*'
- en: You learned in [Chapter 12](ch12.xhtml) that the `ldr` and `str` instructions
    encode the word offset (see the discussion following [Figures 12-1](ch12.xhtml#ch12fig1)
    and [12-2](ch12.xhtml#ch12fig2)), so the `i` and `j` fields must each be aligned
    to a 4-byte word boundary ❷. Each of the `a`, `b`, and `c` fields is placed in
    the low-order bytes of the words at the offsets 24, 32, and 40, respectively.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 12 章](ch12.xhtml)中你学到了，`ldr` 和 `str` 指令编码了字的偏移量（参见[图 12-1](ch12.xhtml#ch12fig1)和[图
    12-2](ch12.xhtml#ch12fig2)后的讨论），因此 `i` 和 `j` 字段必须各自对齐到 4 字节的字边界 ❷。`a`、`b` 和 `c`
    字段分别被放置在偏移量为 24、32 和 40 的字的低位字节中。
- en: The `struct` occupies 20 bytes in the stack frame. The blank areas you see in
    [Figure 17-1](ch17.xhtml#ch17fig1) are unused bytes in the `struct`. The gray
    areas are unused bytes in the stack frame.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 在栈帧中占用 20 个字节。你在[图 17-1](ch17.xhtml#ch17fig1)中看到的空白区域是 `struct` 中未使用的字节。灰色区域是栈帧中未使用的字节。'
- en: Passing a record to another function raises additional issues. As you have seen,
    we need to specify the type of data we’re passing, but a record can have many
    fields, each of which can have a different data type. Next, you’ll see how C solves
    this problem.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将记录传递给另一个函数会引发额外的问题。如你所见，我们需要指定传递的数据类型，但一个记录可以有许多字段，每个字段可以有不同的数据类型。接下来，你将看到
    C 语言如何解决这个问题。
- en: Defining the fields every time we define another instance of a record is cumbersome.
    C allows us to define our own `struct` types using a *structure tag* (or simply
    *tag*), which serves as a synonym for the field definitions. This is not only
    useful for defining multiple records of the same field composition but also necessary
    for passing records to other functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每次定义另一个记录实例时都定义字段是很繁琐的。C 语言允许我们使用 *结构标签*（或简单称为 *标签*）来定义我们自己的 `struct` 类型，它作为字段定义的同义词。这不仅对定义多个相同字段组合的记录很有用，而且对于将记录传递给其他函数也是必要的。
- en: 'For example, we defined the `struct` variable `x` in [Listing 17-12](ch17.xhtml#ch17list12)
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在[清单 17-12](ch17.xhtml#ch17list12)中定义了 `struct` 变量 `x`，如下所示：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instead, we can create a tag for the fields in the `struct`, like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以为 `struct` 中的字段创建一个标签，像这样：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have created a name for our programmer-defined data type, `struct
    chars_and_ints`, we can define its variables in the usual way:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为程序员自定义的数据类型 `struct chars_and_ints` 创建了一个名称，我们可以像通常定义变量一样定义它的变量：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’ll start by declaring our new `struct` data type in a separate header file,
    as shown in [Listing 17-14](ch17.xhtml#ch17list14).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在一个单独的头文件中声明我们的新 `struct` 数据类型，如[清单 17-14](ch17.xhtml#ch17list14)所示。
- en: '*my_record.h*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*my_record.h*'
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 17-14: A record tag*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-14：一个记录标签*'
- en: We include this header file in any file where we want to define a `struct chars_and_ints`
    variable or function parameter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在任何需要定义 `struct chars_and_ints` 变量或函数参数的文件中包含这个头文件。
- en: '[Listing 17-15](ch17.xhtml#ch17list15) shows how we can use `chars_and_ints`
    to define two records in a function.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-15](ch17.xhtml#ch17list15) 展示了如何使用 `chars_and_ints` 在一个函数中定义两个记录。'
- en: '*fill_records.c*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*fill_records.c*'
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 17-15: A program to load data into two records and display their contents*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-15：一个将数据加载到两个记录并显示其内容的程序*'
- en: The `struct` C keyword and our tag specify the data type of the record variables
    we’re defining ❶. Since the `load_record` function outputs data values to the
    record, we need to pass the address of the record ❷. The record is an input to
    the `display_record` function, so we use pass by value to pass a copy of the record
    ❸.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` C 关键字和我们的标签指定了我们正在定义的记录变量的数据类型 ❶。由于 `load_record` 函数将数据值输出到记录中，我们需要传递记录的地址
    ❷。记录是 `display_record` 函数的输入，因此我们使用按值传递来传递记录的副本 ❸。'
- en: The compiler-generated assembly language for the `main` function in [Listing
    17-16](ch17.xhtml#ch17list16) shows the differences between passing a record by
    pointer to `load_record` and passing by value to `display_record`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-16](ch17.xhtml#ch17list16)中显示了 `main` 函数的编译器生成的汇编语言，展示了通过指针传递记录给 `load_record`
    和通过值传递记录给 `display_record` 的区别。'
- en: '*fill_records.s*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*fill_records.s*'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 17-16: The compiler-generated assembly language for the* main *function
    in [Listing 17-15](ch17.xhtml#ch17list15)*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-16：[清单 17-15](ch17.xhtml#ch17list15)中 `main` 函数的编译器生成的汇编语言*'
- en: The `load_record` function will output data to the `struct`, so it’s passed
    by pointer ❷. As we saw in [Listing 17-2](ch17.xhtml#ch17list2), C uses pass by
    pointer when we pass the name of an array to a function even when it’s an input,
    because arrays are typically large. Records can also be large, but this is less
    common than with arrays, so C uses pass by value when we pass the name of a `struct`
    to a function. However, the procedure call standard states that if a `struct`
    is over 16 bytes, it must be copied to memory and the copy passed by pointer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_record`函数将数据输出到`struct`中，因此它是通过指针传递的❷。正如我们在[清单 17-2](ch17.xhtml#ch17list2)中看到的，当我们将数组的名称传递给函数时，即使它是输入，C语言也使用指针传递，因为数组通常很大。记录也可以很大，但这种情况不如数组常见，因此当我们将`struct`的名称传递给函数时，C语言使用值传递。然而，过程调用标准规定，如果`struct`超过16字节，它必须复制到内存中，并通过指针传递复制。'
- en: '[Figure 17-1](ch17.xhtml#ch17fig1) shows that the size of our `struct` is 20
    bytes. The compiler has allocated extra memory in the stack frame for this copy
    ❶. Our `main` function makes a copy of the `struct` ❸ and passes a pointer to
    the copy as an input to the `load_record` function ❹.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-1](ch17.xhtml#ch17fig1)显示了我们的`struct`大小为20字节。编译器在堆栈帧中为此副本分配了额外的内存❶。我们的`main`函数创建了`struct`的副本❸，并将指向该副本的指针作为输入传递给`load_record`函数❹。'
- en: Let’s look at the `load_record` function, whose header file is shown in [Listing
    17-17](ch17.xhtml#ch17list17).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`load_record`函数，其头文件在[清单 17-17](ch17.xhtml#ch17list17)中显示。
- en: '*load_record.h*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*load_record.h*'
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 17-17: The header file for the function to load data into a record*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-17：将数据加载到记录中的函数的头文件*'
- en: '[Listing 17-18](ch17.xhtml#ch17list18) shows the definition of the `load_record`
    function.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-18](ch17.xhtml#ch17list18)显示了`load_record`函数的定义。'
- en: '*load_record.c*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*load_record.c*'
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 17-18: A function to load data into a record*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-18：将数据加载到记录中的函数*'
- en: The parentheses are required to dereference the `a_record` pointer variable
    before the field selection because the field selection operator (`.`) has a higher
    precedence than the dereference operator (`*`) in C ❶. Without them, `*a_record.a`
    means `*(a_record.a)`. Pointers to records are so common that C provides the equivalent
    `->` syntax to dereference the record pointer first and then select a field ❷.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在字段选择之前，必须使用圆括号来解引用`a_record`指针变量，因为在C语言中，字段选择操作符（`.`）的优先级高于解引用操作符（`*`）❶。没有这些圆括号，`*a_record.a`就表示`*(a_record.a)`。指向记录的指针非常常见，因此C语言提供了等效的`->`语法，先解引用记录指针，再选择字段❷。
- en: '[Listing 17-19](ch17.xhtml#ch17list19) shows the assembly language the compiler
    generated for our `load_record` function.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-19](ch17.xhtml#ch17list19)显示了编译器为我们的`load_record`函数生成的汇编语言。'
- en: '*load_record.s*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*load_record.s*'
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 17-19: The compiler-generated assembly language for the function in
    [Listing 17-18](ch17.xhtml#ch17list18)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-19：编译器生成的汇编语言，针对[清单 17-18](ch17.xhtml#ch17list18)中的函数*'
- en: This is a leaf function, so we don’t need a frame record, but the compiler created
    a stack frame for saving the arguments to the function ❶. The address of the `struct`
    is retrieved before accessing each field ❷.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个叶函数，因此我们不需要帧记录，但编译器为保存函数的参数创建了一个堆栈帧❶。在访问每个字段之前，先检索`struct`的地址❷。
- en: Now, let’s look at the `display_record` function, whose header file is shown
    in [Listing 17-20](ch17.xhtml#ch17list20).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`display_record`函数，其头文件在[清单 17-20](ch17.xhtml#ch17list20)中显示。
- en: '*display_record.h*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*display_record.h*'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 17-20: The header file for the function to display data in a record*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-20：显示记录中数据的函数的头文件*'
- en: '[Listing 17-21](ch17.xhtml#ch17list21) shows the definition of the `display_record`
    function.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-21](ch17.xhtml#ch17list21)显示了`display_record`函数的定义。'
- en: '*display_record.c*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*display_record.c*'
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 17-21: A function to display data in a record*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-21：显示记录中数据的函数*'
- en: '[Listing 17-22](ch17.xhtml#ch17list22) shows the compiler-generated assembly
    language for the `display_record` function.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-22](ch17.xhtml#ch17list22)显示了编译器为`display_record`函数生成的汇编语言。'
- en: '*display_record.s*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*display_record.s*'
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 17-22: The compiler-generated assembly language for the function in
    [Listing 17-21](ch17.xhtml#ch17list21)*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-22：编译器生成的汇编语言，针对[清单 17-21](ch17.xhtml#ch17list21)中的函数*'
- en: The compiler uses `x19` as a pointer to the caller’s copy of the `struct` ❶.
    After retrieving the values in each field of the record, it loads them in the
    proper registers for passing to the `printf` function ❷.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用`x19`作为指向调用者复制的`struct`的指针❶。在检索记录中每个字段的值后，它将这些值加载到适当的寄存器中，以便传递给`printf`函数❷。
- en: You’ve seen how to pass by value `struct`s that are larger than 16 bytes. Next,
    let’s look at passing records of less than 16 bytes. We’ll do this by rearranging
    the fields of the record and using assembly language.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了如何通过值传递大于16字节的 `struct`。接下来，让我们来看一下如何传递小于16字节的记录。我们将通过重新排列记录的字段并使用汇编语言来实现这一点。
- en: '***In Assembly Language***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在汇编语言中***'
- en: Although it’s seldom an issue, we can rearrange the fields in our record to
    make it a bit smaller. [Figure 17-2](ch17.xhtml#ch17fig2) shows how we’ll place
    both records in the `main` function’s stack frame and where their fields are.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这通常不是一个问题，但我们可以重新排列记录中的字段，使它稍微变小。[图 17-2](ch17.xhtml#ch17fig2)显示了我们将如何在 `main`
    函数的堆栈框架中放置两个记录及其字段的位置。
- en: '![Image](../images/pg408_Image_288.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg408_Image_288.jpg)'
- en: '*Figure 17-2: Two records in the stack frame*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-2：堆栈框架中的两个记录*'
- en: Using this diagram of the stack frame, we can design the `main` function as
    shown in [Listing 17-23](ch17.xhtml#ch17list23).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此堆栈框架图，我们可以按照[列表 17-23](ch17.xhtml#ch17list23)中所示设计 `main` 函数。
- en: '*fill_records.s*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*fill_records.s*'
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 17-23: The assembly language program to load and display two records*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-23：加载并显示两个记录的汇编语言程序*'
- en: In [Figure 17-2](ch17.xhtml#ch17fig2), the record is 12 bytes long. The procedure
    call standard states that records less than 16 bytes long should be passed in
    registers. We load the entire 12 bytes of a record, including the unused memory
    gaps between the fields, into registers `x0` and `w1` to pass to `display_record`
    ❷.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 17-2](ch17.xhtml#ch17fig2)中，记录长度为12个字节。过程调用标准规定，长度小于16字节的记录应通过寄存器传递。我们将记录的整个12字节，包括字段之间未使用的内存空隙，加载到寄存器
    `x0` 和 `w1` 中，以传递给 `display_record` ❷。
- en: The `ldr` instruction requires that the offset be a multiple of the number of
    bytes in the destination register. When we designed the stack frame in [Figure
    17-2](ch17.xhtml#ch17fig2), we placed the start of the `y` record on a doubleword
    boundary ❶ so we can pass the first 8 bytes of the record in the `x0` register
    ❸.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr` 指令要求偏移量是目标寄存器字节数的倍数。当我们在[图 17-2](ch17.xhtml#ch17fig2)中设计堆栈框架时，我们将 `y`
    记录的起始位置放在双字边界上 ❶，这样我们就可以通过 `x0` 寄存器 ❸ 传递记录的前8个字节。'
- en: Using the diagram of our stack frame in [Figure 17-2](ch17.xhtml#ch17fig2),
    we’ll place the `.equ` directives for the record field offsets in a file called
    *my_record.s*, as shown in [Listing 17-24](ch17.xhtml#ch17list24).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在[图 17-2](ch17.xhtml#ch17fig2)中的堆栈框架图，我们将在一个名为 *my_record.s* 的文件中放置记录字段偏移量的
    `.equ` 指令，如[列表 17-24](ch17.xhtml#ch17list24)所示。
- en: '*my_record.s*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*my_record.s*'
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 17-24: The field offsets for a record*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-24：记录的字段偏移量*'
- en: We can include the *my_record.s* file in any assembly language file that uses
    the field names to ensure consistency. Let’s look at how this works in the `load_record`
    function in [Listing 17-25](ch17.xhtml#ch17list25).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 *my_record.s* 文件包含在任何使用字段名称的汇编语言文件中，以确保一致性。我们来看一下它是如何在 `load_record` 函数中工作的，如[列表
    17-25](ch17.xhtml#ch17list25)所示。
- en: '*load_record.s*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*load_record.s*'
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 17-25: The assembly language function to load data into a record*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-25：将数据加载到记录中的汇编语言函数*'
- en: The algorithm of this function is very simple. You can see a new assembly directive
    here, `.include` ❶. The argument to this directive is a filename in quotes. The
    text in that file is inserted at this location. The `.equ` values in *my_record.s*
    give the offsets to the fields in the record.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的算法非常简单。你可以看到这里有一个新的汇编指令，`.include` ❶。这个指令的参数是一个用引号括起来的文件名。该文件中的文本会插入到此位置。*my_record.s*
    中的 `.equ` 值给出了记录中字段的偏移量。
- en: The procedure call standard says that when records of less than 16 bytes are
    passed in registers, we need to make a copy of the record in the called function.
    This differs from passing larger records by value, where the copy of the record
    is made in the calling function, with a pointer to the copy passed to the called
    function. We’ll place `display_record`’s copy in its stack frame, as shown in
    [Figure 17-3](ch17.xhtml#ch17fig3).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 过程调用标准规定，当记录的长度小于16字节并通过寄存器传递时，我们需要在被调用函数中复制该记录。这与通过值传递较大的记录不同，后者是将记录的副本在调用函数中创建，并将指向该副本的指针传递给被调用函数。我们将在被调用函数的堆栈框架中放置
    `display_record` 的副本，如[图 17-3](ch17.xhtml#ch17fig3)所示。
- en: '![Image](../images/pg411_Image_289.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg411_Image_289.jpg)'
- en: '*Figure 17-3: The saved* x19 *register and* record *in a stack frame*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-3：保存的* x19 *寄存器和* 记录 *在堆栈框架中*'
- en: '[Listing 17-26](ch17.xhtml#ch17list26) shows the resulting `display_record`
    function design.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-26](ch17.xhtml#ch17list26)展示了最终的 `display_record` 函数设计。'
- en: '*display_record.s*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*display_record.s*'
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 17-26: The assembly language function to display data in a record*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-26：用于显示记录数据的汇编语言函数*'
- en: The procedure call standard states that a called function needs to preserve
    the value in `x19`. We save its contents in our stack frame so we can use the
    register to point to our local copy of the record ❶. We then store the 12 bytes
    in the record, 8 in `x0` and 4 in `w1`, in the memory in our stack frame to create
    our local copy of the record ❷.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 程序调用标准规定，被调用的函数需要保留`x19`中的值。我们将其内容保存在堆栈帧中，以便可以使用该寄存器指向我们本地的记录副本❶。然后，我们将记录中的12个字节，其中8个字节存储在`x0`中，4个字节存储在`w1`中，保存在堆栈帧的内存中，以创建我们本地的记录副本❷。
- en: '**YOUR TURN**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 17.3     Change the order of the fields in [Listing 17-12](ch17.xhtml#ch17list12)
    to group the `char` fields together, followed by the `int` fields. Recompile the
    program in [Listings 17-15](ch17.xhtml#ch17list15), [17-17](ch17.xhtml#ch17list17),
    [17-18](ch17.xhtml#ch17list18), [17-20](ch17.xhtml#ch17list20), and [17-21](ch17.xhtml#ch17list21).
    Compare the assembly language generated by the compiler with what you see in [Listings
    17-16](ch17.xhtml#ch17list16), [17-19](ch17.xhtml#ch17list19), and [17-22](ch17.xhtml#ch17list22).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 17.3     更改[清单 17-12](ch17.xhtml#ch17list12)中字段的顺序，将`char`字段组合在一起，然后是`int`字段。重新编译[清单
    17-15](ch17.xhtml#ch17list15)、[17-17](ch17.xhtml#ch17list17)、[17-18](ch17.xhtml#ch17list18)、[17-20](ch17.xhtml#ch17list20)和[17-21](ch17.xhtml#ch17list21)中的程序。将编译器生成的汇编语言与[清单
    17-16](ch17.xhtml#ch17list16)、[17-19](ch17.xhtml#ch17list19)和[17-22](ch17.xhtml#ch17list22)中的内容进行比较。
- en: '**What You’ve Learned**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你所学到的**'
- en: '**Arrays** Collections of data items of the same data type, stored contiguously
    in memory.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组** 是存储在内存中连续的相同数据类型的数据项集合。'
- en: '**Processing arrays** The CPU has an addressing mode for accessing an array
    element using an index value.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理数组** CPU有一种地址模式，可以通过索引值访问数组元素。'
- en: '**Passing arrays** In C, arrays are passed by pointer rather than by value.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**传递数组** 在C语言中，数组是通过指针传递，而不是通过值传递。'
- en: '**Records** Collections of data items, possibly of different data types, stored
    together in memory, possibly with padding for address alignment purposes.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**记录** 是将不同数据类型的数据项可能会在内存中一起存储的集合，可能会有用于地址对齐目的的填充。'
- en: '**Accessing record fields** The address with offset addressing mode can be
    used to access a record field.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问记录字段** 可以使用带有偏移地址模式的地址来访问记录字段。'
- en: '**Passing records** It’s often more efficient to pass a record by pointer,
    even when it’s an input.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**传递记录** 即使是输入记录，通过指针传递通常更高效。'
- en: In the next chapter, I’ll show you how C++ uses records to implement the object-oriented
    programming paradigm.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将向你展示C++如何使用记录来实现面向对象编程范式。
