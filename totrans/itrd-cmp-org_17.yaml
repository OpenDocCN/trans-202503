- en: '**17'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DATA STRUCTURES**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg297_Image_276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An essential part of programming is determining how best to organize data.
    In this chapter, we’ll cover two of the most fundamental ways of organizing data:
    arrays, which can be used for grouping data items of the same data type; and records,
    which can be used for grouping data items of different data types.'
  prefs: []
  type: TYPE_NORMAL
- en: These ways of organizing data determine how we access the individual data items.
    Both require two addressing items to locate a data item. Since the data items
    in an array are all of the same type, we can access an individual data item if
    we know the name of the array and the index number of the item. Accessing an individual
    data item in a record requires the name of the record and the name of the data
    item in the record.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrays**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *array* is a collection of data elements of the same data type, arranged
    in a sequence. We can access a single element in an array using the name of the
    array together with an *index value*, which specifies the number of the element
    relative to the beginning of the array. We have used `char` arrays in previous
    chapters to store ASCII characters as text strings. Each element in the array
    was the same type, a `char`, which is 1 byte. In our earlier applications, we
    were accessing each character in order, so we started with a pointer to the first
    `char` and simply incremented it by 1 to access each subsequent `char`. We didn’t
    need an index to locate each `char` within the text string array.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at `int` arrays, which use 4 bytes for each data
    element in the array. If we started with a pointer to the first element, we’d
    need to increment it by 4 to access each subsequent element; it’s much easier
    to use the array index number to access each individual element. You’ll see how
    the index number is converted to an address offset to access an array element
    relative to the beginning of the array. You’ll also see that C passes arrays to
    other functions differently from other data items.
  prefs: []
  type: TYPE_NORMAL
- en: '***In C***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We define an array in C by stating the element data type, giving the array a
    name, and specifying the number of elements in the array. Let’s start with the
    example in [Listing 17-1](ch17.xhtml#ch17list1).
  prefs: []
  type: TYPE_NORMAL
- en: '*fill_array.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-1: A program to store* int *s in an array and display them*'
  prefs: []
  type: TYPE_NORMAL
- en: This `main` function calls the `twice_index` function, which sets each element
    in the array to twice its index. For example, `twice_index` stores the `int` 8
    in array element number 4\. The `main` function then calls `display_array`, which
    prints the contents of the entire array in the terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: You first encountered arrays in [Chapter 2](ch02.xhtml), when learning about
    C-style strings. Those strings used a sentinel value, `NUL`, to mark the end of
    the array. The array we’re using here doesn’t have a sentinel value, so we need
    to pass the number of elements in the array to each function that processes it.
  prefs: []
  type: TYPE_NORMAL
- en: One thing you might notice about the arguments we’re passing to the functions
    is that it appears the array is being passed by value, since we give only its
    name in the argument list. But `twice_index` stores values in the array, so it
    needs to know where the array is located in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a programmer passes an input value to a function by value. But if the
    input consists of a large number of data items, copying them all into registers
    and onto the stack would be very inefficient; it makes more sense to pass by pointer.
    Arrays almost always have many data items, so the designers of the C language
    decided to always pass them by pointer. When you give the name of the array as
    an argument to a function call, C will pass the address of the first element of
    the array; thus, `twice_index` can output data to the array.
  prefs: []
  type: TYPE_NORMAL
- en: To see this explicitly, let’s look at the compiler-generated assembly language
    for this `main` function, as shown in [Listing 17-2](ch17.xhtml#ch17list2).
  prefs: []
  type: TYPE_NORMAL
- en: '*fill_array.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-2: The compiler-generated assembly language for the function in
    [Listing 17-1](ch17.xhtml#ch17list1)*'
  prefs: []
  type: TYPE_NORMAL
- en: The entire `int` array is allocated in `main`’s stack frame ❶. In assembly language,
    the address of the array is passed both to the `twice_index` function ❷ and to
    the `display_array` function ❸. The elements of the array are inputs to the `display_array`
    function, so it does not need to know the address of the array, but it’s much
    more efficient to pass the address of the entire array than a copy of each of
    the array elements.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the function to store the `int`s in the array, `twice_index`.
    [Listing 17-3](ch17.xhtml#ch17list3) shows its header file.
  prefs: []
  type: TYPE_NORMAL
- en: '*twice_index.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-3: The header file for the* twice_index *function*'
  prefs: []
  type: TYPE_NORMAL
- en: This prototype statement shows how we use the `[]` syntax to indicate that the
    argument to a function is an array. As described previously, we need to provide
    the number of elements in the array as a separate argument.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the `twice_index` function is given in [Listing 17-4](ch17.xhtml#ch17list4).
  prefs: []
  type: TYPE_NORMAL
- en: '*twice_index.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-4: A function to store twice the index number in each element of
    an array*'
  prefs: []
  type: TYPE_NORMAL
- en: The number of iterations is known when this loop starts, so we use a `for` loop
    to process the array. The compiler generated the assembly language shown in [Listing
    17-5](ch17.xhtml#ch17list5) for the `twice_index` function.
  prefs: []
  type: TYPE_NORMAL
- en: '*twice_index.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-5: The compiler-generated assembly language for the function in
    [Listing 17-4](ch17.xhtml#ch17list4)*'
  prefs: []
  type: TYPE_NORMAL
- en: To access an array element, the compiler computes the offset of the element
    from the beginning of the array and then adds that offset to the address of the
    beginning. This is an array of `int`s, so each element is 4 bytes. The compiler
    shifts the array index, `i`, 2 bits to the left to multiply it by 4 ❶. Adding
    `4 * i` to the address of the beginning of the array gives the address of the
    array element ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the `display_array` function used to display the contents
    of the array. [Listing 17-6](ch17.xhtml#ch17list6) shows the header file for this
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '*display_array.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-6: The header file for the* display_array *function*'
  prefs: []
  type: TYPE_NORMAL
- en: As with the `twice_index` function, we use the `[]` syntax to indicate that
    the argument to the `display_array` function is an array. We also need to provide
    the number of elements in the array as a separate argument. The function definition
    is given in [Listing 17-7](ch17.xhtml#ch17list7).
  prefs: []
  type: TYPE_NORMAL
- en: '*display_array.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-7: A function to display* int *s in an array*'
  prefs: []
  type: TYPE_NORMAL
- en: To display the integers, we’re using the `put_int` function that you wrote in
    “Your Turn” [exercise 16.8](ch16.xhtml#ch16exe8) on [page 358](ch16.xhtml#ch16you2).
    [Listing 17-8](ch17.xhtml#ch17list8) shows the compiler-generated assembly language
    for this function.
  prefs: []
  type: TYPE_NORMAL
- en: '*display_array.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-8: The compiler-generated assembly language for the function in
    [Listing 17-7](ch17.xhtml#ch17list7)*'
  prefs: []
  type: TYPE_NORMAL
- en: Although the array is an input to the `display_array` function, C passes the
    address of the array to the called function ❶ ❸. As in the `twice_index` function,
    the compiler multiplies the index by 4 to get the offset of each `int` in the
    array ❷. Next, I’ll demonstrate a different way to index the array elements when
    writing this program directly in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '***In Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our approach to the `fill_array` program will be similar to the compiler’s,
    but we’ll use instructions that are a little more intuitive. [Listing 17-9](ch17.xhtml#ch17list9)
    shows our `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: '*fill_array.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-9: The assembly language program to store* int *s in an array and
    display them*'
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to what the compiler generated in [Listing 17-2](ch17.xhtml#ch17list2),
    except that we use more meaningful names. However, we’ll use a different way to
    compute the address of each array element in our `twice_index` function, as shown
    in [Listing 17-10](ch17.xhtml#ch17list10).
  prefs: []
  type: TYPE_NORMAL
- en: '*twice_index.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-10: The assembly language function to store twice the index number
    in each element of an array*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re using a variant of the `str` instruction that uses a register to hold
    the offset from the base register instead of a constant ❶. In our case, the index
    is in a 32-bit register, `w2`, so the value needs to be extended to 64 bits before
    adding it to the address in the base register, `x0`. Since each element in the
    array is 4 bytes, the index value needs to be multiplied by 4 to give an address
    offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the load and store instructions that use a register to hold the
    offset from a base register:'
  prefs: []
  type: TYPE_NORMAL
- en: ldr**—Load register, base register–relative, register offset**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`ldr w`d `, [x`b `, w`o `,` xtnd `{` amnt `}]` loads `w`d with the 32-bit value
    at the memory location obtained by adding the address in `x`b and the value in
    `w`o, optionally shifted left 2 bits, extended to 64 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ldr w`d `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` loads `w`d with the 32-bit
    value at the memory location obtained by adding the address in `x`b and the value
    in `x`o, optionally shifted left 2 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ldr x`d `, [x`b `, w`o `,` xtnd `{` amnt `}]` loads `x`d with the 64-bit value
    at the memory location obtained by adding the address in `x`b and the value in
    `w`o, optionally shifted left 3 bits, extended to 64 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ldr x`d `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` loads `x`d with the 64-bit
    value at the memory location obtained by adding the address in `x`b and the value
    in `x`o, optionally shifted left 3 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: str**—Store register, base register–relative, register offset**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`str w`s `, [x`b `, w`o `,` xtnd `{` amnt `}]` stores the 32-bit value in `w`s
    in the memory location obtained by adding the address in `x`b and the value in
    `w`o, optionally shifted left 2 bits, extended to 64 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '`str w`s `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` stores the 32-bit value in
    `w`s in the memory location obtained by adding the address in `x`b and the value
    in `x`o, optionally shifted left 2 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '`str x`s `, [x`b `, w`o `,` xtnd `{` amnt `}]` stores the 64-bit value in `x`s
    in the memory location obtained by adding the address in `x`b and the value in
    `w`o, optionally shifted left 3 bits, extended to 64 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '`str x`s `, [x`b `, x`o `{,` xtnd `{` amnt `}}]` stores the 64-bit value in
    `x`s in the memory location obtained by adding the address in `x`b and the value
    in `x`o, optionally shifted left 3 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-1](ch17.xhtml#ch17tab1) lists the allowable values for the xtnd option
    for the `ldr` and `str` instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** Allowable Values for xtnd in `ldr` and `str` Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| xtnd | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `uxtw` | Unsigned extension of word, optional left shift |'
  prefs: []
  type: TYPE_TB
- en: '| `lsl` | Left shift |'
  prefs: []
  type: TYPE_TB
- en: '| `sxtw` | Signed extension of word, optional left shift |'
  prefs: []
  type: TYPE_TB
- en: '| `sxtx` | Left shift |'
  prefs: []
  type: TYPE_TB
- en: A 32-bit offset, `w`o, must be extended to 64 bits to be added to the address
    in the base register, `x`b. The `sxtx` option exists for syntactic symmetry; it
    has the same effect as `lsl`.
  prefs: []
  type: TYPE_NORMAL
- en: Allowable values for amnt are `0` or `2` for `w`d and `w`s registers, and `0`
    or `3` for `x`d and `x`s registers. This allows us to multiply the value in the
    offset register, `w`o or `x`o, by the number of bytes in the data element we are
    loading or storing. This makes it easy for us to convert an array index number
    into an array element address offset, as we saw in [Listing 17-10](ch17.xhtml#ch17list10)❶.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-11](ch17.xhtml#ch17list11) shows the function for displaying the
    contents of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: '*display_array.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-11: The assembly language function to display* int *s in an array*'
  prefs: []
  type: TYPE_NORMAL
- en: This function uses the same basic algorithm as the `twice_index` function, but
    it calls other functions, so we need to create a stack record ❶. We also need
    to save the `x19`, `x20`, and `x21` registers for the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are used to group data items of the same type. In the next section, we’ll
    look at how to group items of different data types.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 17.1     Change the `twice_index` and `display_array` functions to use pass
    by pointer (`int *the_array`) instead of pass by array (`int the_array[]`). Compare
    the compiler-generated assembly language with that shown in [Listings 17-2](ch17.xhtml#ch17list2),
    [17-5](ch17.xhtml#ch17list5), and [17-8](ch17.xhtml#ch17list8).
  prefs: []
  type: TYPE_NORMAL
- en: 17.2     Modify the program in [Listings 17-9](ch17.xhtml#ch17list9) to [17-11](ch17.xhtml#ch17list11)
    to store 16 times the index number in each element of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Records**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *record* (or *structure*) allows a programmer to group several data items
    of possibly different data types together into a new programmer-defined data type.
    The location of each individual data item in a record is called a *field* or *element*.
    You may also see a field called a *member*, especially in object-oriented programming.
    I’ll cover C++ objects in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Since the fields in a record can have different sizes, accessing them is a bit
    more complex than accessing the data items in an array. I’ll first describe how
    this is done in C, and then we’ll look at how records are passed to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: '***In C***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by looking at a program that defines a record, stores data in each
    of its fields, and then displays the values, as shown in [Listing 17-12](ch17.xhtml#ch17list12).
  prefs: []
  type: TYPE_NORMAL
- en: '*fill_record.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-12: A program to store data in a record*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `struct` keyword to declare a record in C. The fields of the record
    are declared using the usual C syntax: a data type followed by the field name
    ❶. The entire sequence, starting with the `struct` keyword through the ending
    `}` bracket, defines a new data type ❷. We define a record variable by following
    this data type with a name for the variable. The individual fields of a record
    are accessed with the dot operator followed by the field name ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: We can learn how the record is stored in memory by looking at the assembly language
    the compiler generates for this function, which is shown in [Listing 17-13](ch17.xhtml#ch17list13).
  prefs: []
  type: TYPE_NORMAL
- en: '*fill_record.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-13: The compiler-generated assembly language for the* main *function
    in [Listing 17-12](ch17.xhtml#ch17list12)*'
  prefs: []
  type: TYPE_NORMAL
- en: Like other local variables, the record is allocated in the function’s stack
    frame. The individual fields in the record are accessed by offsets from the stack
    pointer ❶. [Figure 17-1](ch17.xhtml#ch17fig1) shows the stack frame used by the
    compiler for this `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg402_Image_287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: The stack frame for fields in a record*'
  prefs: []
  type: TYPE_NORMAL
- en: You learned in [Chapter 12](ch12.xhtml) that the `ldr` and `str` instructions
    encode the word offset (see the discussion following [Figures 12-1](ch12.xhtml#ch12fig1)
    and [12-2](ch12.xhtml#ch12fig2)), so the `i` and `j` fields must each be aligned
    to a 4-byte word boundary ❷. Each of the `a`, `b`, and `c` fields is placed in
    the low-order bytes of the words at the offsets 24, 32, and 40, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `struct` occupies 20 bytes in the stack frame. The blank areas you see in
    [Figure 17-1](ch17.xhtml#ch17fig1) are unused bytes in the `struct`. The gray
    areas are unused bytes in the stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a record to another function raises additional issues. As you have seen,
    we need to specify the type of data we’re passing, but a record can have many
    fields, each of which can have a different data type. Next, you’ll see how C solves
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the fields every time we define another instance of a record is cumbersome.
    C allows us to define our own `struct` types using a *structure tag* (or simply
    *tag*), which serves as a synonym for the field definitions. This is not only
    useful for defining multiple records of the same field composition but also necessary
    for passing records to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we defined the `struct` variable `x` in [Listing 17-12](ch17.xhtml#ch17list12)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can create a tag for the fields in the `struct`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created a name for our programmer-defined data type, `struct
    chars_and_ints`, we can define its variables in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We’ll start by declaring our new `struct` data type in a separate header file,
    as shown in [Listing 17-14](ch17.xhtml#ch17list14).
  prefs: []
  type: TYPE_NORMAL
- en: '*my_record.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-14: A record tag*'
  prefs: []
  type: TYPE_NORMAL
- en: We include this header file in any file where we want to define a `struct chars_and_ints`
    variable or function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-15](ch17.xhtml#ch17list15) shows how we can use `chars_and_ints`
    to define two records in a function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*fill_records.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-15: A program to load data into two records and display their contents*'
  prefs: []
  type: TYPE_NORMAL
- en: The `struct` C keyword and our tag specify the data type of the record variables
    we’re defining ❶. Since the `load_record` function outputs data values to the
    record, we need to pass the address of the record ❷. The record is an input to
    the `display_record` function, so we use pass by value to pass a copy of the record
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler-generated assembly language for the `main` function in [Listing
    17-16](ch17.xhtml#ch17list16) shows the differences between passing a record by
    pointer to `load_record` and passing by value to `display_record`.
  prefs: []
  type: TYPE_NORMAL
- en: '*fill_records.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-16: The compiler-generated assembly language for the* main *function
    in [Listing 17-15](ch17.xhtml#ch17list15)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `load_record` function will output data to the `struct`, so it’s passed
    by pointer ❷. As we saw in [Listing 17-2](ch17.xhtml#ch17list2), C uses pass by
    pointer when we pass the name of an array to a function even when it’s an input,
    because arrays are typically large. Records can also be large, but this is less
    common than with arrays, so C uses pass by value when we pass the name of a `struct`
    to a function. However, the procedure call standard states that if a `struct`
    is over 16 bytes, it must be copied to memory and the copy passed by pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-1](ch17.xhtml#ch17fig1) shows that the size of our `struct` is 20
    bytes. The compiler has allocated extra memory in the stack frame for this copy
    ❶. Our `main` function makes a copy of the `struct` ❸ and passes a pointer to
    the copy as an input to the `load_record` function ❹.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the `load_record` function, whose header file is shown in [Listing
    17-17](ch17.xhtml#ch17list17).
  prefs: []
  type: TYPE_NORMAL
- en: '*load_record.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-17: The header file for the function to load data into a record*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-18](ch17.xhtml#ch17list18) shows the definition of the `load_record`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*load_record.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-18: A function to load data into a record*'
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses are required to dereference the `a_record` pointer variable
    before the field selection because the field selection operator (`.`) has a higher
    precedence than the dereference operator (`*`) in C ❶. Without them, `*a_record.a`
    means `*(a_record.a)`. Pointers to records are so common that C provides the equivalent
    `->` syntax to dereference the record pointer first and then select a field ❷.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-19](ch17.xhtml#ch17list19) shows the assembly language the compiler
    generated for our `load_record` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*load_record.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-19: The compiler-generated assembly language for the function in
    [Listing 17-18](ch17.xhtml#ch17list18)*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a leaf function, so we don’t need a frame record, but the compiler created
    a stack frame for saving the arguments to the function ❶. The address of the `struct`
    is retrieved before accessing each field ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the `display_record` function, whose header file is shown
    in [Listing 17-20](ch17.xhtml#ch17list20).
  prefs: []
  type: TYPE_NORMAL
- en: '*display_record.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-20: The header file for the function to display data in a record*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-21](ch17.xhtml#ch17list21) shows the definition of the `display_record`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*display_record.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-21: A function to display data in a record*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-22](ch17.xhtml#ch17list22) shows the compiler-generated assembly
    language for the `display_record` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*display_record.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-22: The compiler-generated assembly language for the function in
    [Listing 17-21](ch17.xhtml#ch17list21)*'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler uses `x19` as a pointer to the caller’s copy of the `struct` ❶.
    After retrieving the values in each field of the record, it loads them in the
    proper registers for passing to the `printf` function ❷.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen how to pass by value `struct`s that are larger than 16 bytes. Next,
    let’s look at passing records of less than 16 bytes. We’ll do this by rearranging
    the fields of the record and using assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '***In Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although it’s seldom an issue, we can rearrange the fields in our record to
    make it a bit smaller. [Figure 17-2](ch17.xhtml#ch17fig2) shows how we’ll place
    both records in the `main` function’s stack frame and where their fields are.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg408_Image_288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: Two records in the stack frame*'
  prefs: []
  type: TYPE_NORMAL
- en: Using this diagram of the stack frame, we can design the `main` function as
    shown in [Listing 17-23](ch17.xhtml#ch17list23).
  prefs: []
  type: TYPE_NORMAL
- en: '*fill_records.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-23: The assembly language program to load and display two records*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 17-2](ch17.xhtml#ch17fig2), the record is 12 bytes long. The procedure
    call standard states that records less than 16 bytes long should be passed in
    registers. We load the entire 12 bytes of a record, including the unused memory
    gaps between the fields, into registers `x0` and `w1` to pass to `display_record`
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The `ldr` instruction requires that the offset be a multiple of the number of
    bytes in the destination register. When we designed the stack frame in [Figure
    17-2](ch17.xhtml#ch17fig2), we placed the start of the `y` record on a doubleword
    boundary ❶ so we can pass the first 8 bytes of the record in the `x0` register
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Using the diagram of our stack frame in [Figure 17-2](ch17.xhtml#ch17fig2),
    we’ll place the `.equ` directives for the record field offsets in a file called
    *my_record.s*, as shown in [Listing 17-24](ch17.xhtml#ch17list24).
  prefs: []
  type: TYPE_NORMAL
- en: '*my_record.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-24: The field offsets for a record*'
  prefs: []
  type: TYPE_NORMAL
- en: We can include the *my_record.s* file in any assembly language file that uses
    the field names to ensure consistency. Let’s look at how this works in the `load_record`
    function in [Listing 17-25](ch17.xhtml#ch17list25).
  prefs: []
  type: TYPE_NORMAL
- en: '*load_record.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-25: The assembly language function to load data into a record*'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm of this function is very simple. You can see a new assembly directive
    here, `.include` ❶. The argument to this directive is a filename in quotes. The
    text in that file is inserted at this location. The `.equ` values in *my_record.s*
    give the offsets to the fields in the record.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure call standard says that when records of less than 16 bytes are
    passed in registers, we need to make a copy of the record in the called function.
    This differs from passing larger records by value, where the copy of the record
    is made in the calling function, with a pointer to the copy passed to the called
    function. We’ll place `display_record`’s copy in its stack frame, as shown in
    [Figure 17-3](ch17.xhtml#ch17fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg411_Image_289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: The saved* x19 *register and* record *in a stack frame*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-26](ch17.xhtml#ch17list26) shows the resulting `display_record`
    function design.'
  prefs: []
  type: TYPE_NORMAL
- en: '*display_record.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-26: The assembly language function to display data in a record*'
  prefs: []
  type: TYPE_NORMAL
- en: The procedure call standard states that a called function needs to preserve
    the value in `x19`. We save its contents in our stack frame so we can use the
    register to point to our local copy of the record ❶. We then store the 12 bytes
    in the record, 8 in `x0` and 4 in `w1`, in the memory in our stack frame to create
    our local copy of the record ❷.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 17.3     Change the order of the fields in [Listing 17-12](ch17.xhtml#ch17list12)
    to group the `char` fields together, followed by the `int` fields. Recompile the
    program in [Listings 17-15](ch17.xhtml#ch17list15), [17-17](ch17.xhtml#ch17list17),
    [17-18](ch17.xhtml#ch17list18), [17-20](ch17.xhtml#ch17list20), and [17-21](ch17.xhtml#ch17list21).
    Compare the assembly language generated by the compiler with what you see in [Listings
    17-16](ch17.xhtml#ch17list16), [17-19](ch17.xhtml#ch17list19), and [17-22](ch17.xhtml#ch17list22).
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Arrays** Collections of data items of the same data type, stored contiguously
    in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing arrays** The CPU has an addressing mode for accessing an array
    element using an index value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing arrays** In C, arrays are passed by pointer rather than by value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Records** Collections of data items, possibly of different data types, stored
    together in memory, possibly with padding for address alignment purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing record fields** The address with offset addressing mode can be
    used to access a record field.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing records** It’s often more efficient to pass a record by pointer,
    even when it’s an input.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll show you how C++ uses records to implement the object-oriented
    programming paradigm.
  prefs: []
  type: TYPE_NORMAL
