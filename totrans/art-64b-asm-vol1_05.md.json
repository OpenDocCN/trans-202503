["```\n; The following computes `destreg` = `destreg` * `constant`:\n\nimul `destreg`[16], `constant`\nimul `destreg`[32], `constant`\nimul `destreg`[64], `constant`[32]\n\n; The following computes `dest` = `src` * `constant`:\n\nimul `destreg`[16], `srcreg`[16], `constant`\nimul `destreg`[16], `srcmem`[16], `constant`\n\nimul destreg[32], srcreg[32], `constant`\nimul destreg[32], srcmem[32], `constant`\n\nimul `destreg`[64], `srcreg`[64], `constant`[32]\nimul `destreg`[64], `srcmem`[64], `constant`[32]\n\n; The following computes `dest` = `destreg` * `src`:\n\nimul `destreg`[16], `srcreg`[16]\nimul `destreg`[16], `srcmem`[16]\nimul `destreg`[32], `srcreg`[32]\nimul `destreg`[32], `srcmem`[32]\nimul `destreg`[64], `srcreg`[64]\nimul `destreg`[64], `srcmem`[64]\n```", "```\ninc `mem`/`reg`\ndec `mem`/`reg`\n```", "```\n`symbol` = `constant_expression`\n```", "```\nMaxIndex = 15\n```", "```\n`symbol` equ `constant_expression`\n```", "```\nmaxSize  = 100\n\n`Code that uses maxSize, expecting it to be 100`\n\nmaxSize  = 256\n\n`Code that uses maxSize, expecting it to be 256`\n```", "```\nSomeStr  equ   \"abcdefgh\"\n          .\n          .\n          .\nmemStr   byte  SomeStr\n```", "```\nSomeStr  equ   \"abcdefghi\"\n          .\n          .\n          .\nmemStr   byte  SomeStr\n```", "```\nSomeStr  equ   <\"abcdefgh\">\n          .\n          .\n          .\nmemStr   byte  SomeStr\n```", "```\nSomeStr  textequ   <\"abcdefgh\">\n          .\n          .\n          .\nmemStr   byte      SomeStr\n```", "```\nmaxCnt  =       10\nmax     textequ <maxCnt>\nmax     =       max+1\n```", "```\nmaxCnt  =       maxCnt+1\n```", "```\nmv    textequ  <mov>\n        .\n        .\n        .\n       mv      rax,0\n```", "```\n`identifier` =   `constant_expression`\n`identifier` equ `constant_expression`\n```", "```\nsomeLabel equ $\n```", "```\njmp $     ; \"$\" is equivalent to the address of the jmp instr\n```", "```\njmp $+5   ; Skip to a position 5 bytes beyond the jmp\n```", "```\nsomeData     byte 1, 2, 3, 4, 5\nsizeSomeData =    $-someData\n```", "```\nsomeData     byte 1, 2, 3, 4, 5\n             byte 6, 7, 8, 9, 0\nsizeSomeData =    $-someData\n```", "```\n; Constant expression, computed while MASM\n; is assembling your program:\n\nx     = 5\ny     = 6\nSum   = x + y\n\n; Runtime calculation, computed while your program\n; is running, long after MASM has assembled it:\n\n     mov al, x\n     add al, y\n```", "```\nthis `type`\n```", "```\nsomeLabel label byte\nsomeLabel equ   this byte\n```", "```\nTapeDAT        =  0\nTape8mm        =  TapeDAT + 1\nTapeQIC80      =  Tape8mm + 1\nTapeTravan     =  TapeQIC80 + 1\nTapeDLT        =  TapeTravan + 1\n```", "```\n`new_type_name`  typedef  `existing_type_name`\n```", "```\ninteger   typedef  sdword\nfloat     typedef  real4\ndouble    typedef  real8\ncolors    typedef  byte\n```", "```\n .data\ni          integer ?\nx          float   1.0\nHouseColor colors  ?\n```", "```\n; Listing 4-1\n\n; Type checking errors.\n\n        option  casemap:none\n\nnl      =       10  ; ASCII code for newline\n\n        .data\ni8      sbyte   ?\ni16     sword   ?\ni32     sdword  ?\ni64     sqword  ?\n\n        .code\n\n; Here is the \"asmMain\" function.\n\n        public  asmMain\nasmMain proc\n\n mov     eax, i8\n        mov     al, i16\n        mov     rax, i32\n        mov     ax, i64\n\n        ret     ; Returns to caller\nasmMain endp\n        end\n```", "```\nC:\\>**ml64 /c listing4-1.asm**\nMicrosoft (R) Macro Assembler (x64) Version 14.15.26730.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n Assembling: listing4-1.asm\nlisting4-1.asm(24) : error A2022:instruction operands must be the same size\nlisting4-1.asm(25) : error A2022:instruction operands must be the same size\nlisting4-1.asm(26) : error A2022:instruction operands must be the same size\nlisting4-1.asm(27) : error A2022:instruction operands must be the same size\n```", "```\n .data\nbyte_values  label byte\n             byte  0, 1\n\n             .\n             .\n             .\n\n             mov ax, byte_values\n```", "```\n`new_type_name` ptr `address_expression`\n```", "```\nmov ax, word ptr byte_values\n```", "```\nnot [rbx]\n```", "```\nnot byte ptr [rbx]\nnot dword ptr [rbx]\n```", "```\nmov dword ptr byteVar, eax\n```", "```\nM: array [0..1023] of integer;\n```", "```\ni := 0;      (Assume \"i\" is an integer variable)\nM [i] := 100;\n```", "```\ni := 5;      (Assume all variables are integers)\nj := 10;\nk := 50;\nm [i*j-k] := 100;\n```", "```\nM [1] := 0;\nM [M [1]] := 100;\n```", "```\nmov  rbx, p       ; Load RBX with the value of pointer p\nmov  rax, [rbx]   ; Fetch the data that p points at\n```", "```\n mov rax, offset i\n    mov p, rax\n      .\n      .\n      .      ; Code that sets or clears the carry flag.\n\n    jc skipSetp\n\n       mov rax, offset j\n       mov p, rax\n        .\n        .\n        .\n\nskipSetp:\n    mov rbx, p           ; Assume both code paths wind up\n    mov rax, [rbx]       ; down here\n```", "```\n .data\npointer   typedef qword\nb         byte    ?\nd         dword   ?\npByteVar  pointer b\npDWordVar pointer d\n```", "```\noffset StaticVarName [PureConstantExpression]\noffset StaticVarName + PureConstantExpression\noffset StaticVarName - PureConstantExpression\n```", "```\n; Listing 4-2\n\n; Pointer constant demonstration.\n\n        option  casemap:none\n\nnl      =       10\n\n        .const\nttlStr  byte    \"Listing 4-2\", 0\nfmtStr  byte    \"pb's value is %ph\", nl\n        byte    \"*pb's value is %d\", nl, 0\n\n        .data\nb       byte    0\n        byte    1, 2, 3, 4, 5, 6, 7\n\npb      textequ <offset b[2]>\n\n        .code\n        externdef printf:proc\n\n; Return program title to C++ program:\n\n         public getTitle\ngetTitle proc\n         lea rax, ttlStr\n         ret\ngetTitle endp\n\n; Here is the \"asmMain\" function.\n\n        public  asmMain\nasmMain proc\n\n; \"Magic\" instruction offered without\n; explanation at this point:\n\n        sub     rsp, 48\n\n        lea     rcx, fmtStr\n        mov     rdx, pb\n        movzx   r8, byte ptr [rdx]\n        call    printf\n\n        add     rsp, 48\n        ret     ; Returns to caller\n\nasmMain endp\n        end\n```", "```\nC:\\>**build listing4-2**\n\nC:\\>**echo off**\n Assembling: listing4-2.asm\nc.cpp\n\nC:\\>**listing4-2**\nCalling Listing 4-2:\npb's value is 00007FF6AC381002h\n*pb's value is 2\nListing 4-2 terminated\n```", "```\n; Listing 4-3\n\n; Demonstration of calls\n; to C standard library malloc\n; and free functions.\n\n        option  casemap:none\n\nnl      =       10\n\n        .const\nttlStr  byte    \"Listing 4-3\", 0\nfmtStr  byte    \"Addresses returned by malloc: %ph, %ph\", nl, 0\n\n        .data\nptrVar  qword   ?\nptrVar2 qword   ?\n\n        .code\n        externdef printf:proc\n        externdef malloc:proc\n        externdef free:proc\n\n; Return program title to C++ program:\n\n         public getTitle\ngetTitle proc\n         lea rax, ttlStr\n         ret\ngetTitle endp\n\n; Here is the \"asmMain\" function.\n\n        public  asmMain\nasmMain proc\n\n; \"Magic\" instruction offered without\n; explanation at this point:\n\n        sub     rsp, 48\n\n; C standard library malloc function.\n\n; ptr = malloc(byteCnt);\n\n mov     rcx, 256        ; Allocate 256 bytes\n        call    malloc\n        mov     ptrVar, rax     ; Save pointer to buffer\n\n        mov     rcx, 1024       ; Allocate 1024 bytes\n        call    malloc\n        mov     ptrVar2, rax    ; Save pointer to buffer\n\n        lea     rcx, fmtStr\n        mov     rdx, ptrVar\n        mov     r8, rax         ; Print addresses\n        call    printf\n\n; Free the storage by calling\n; C standard library free function.\n\n; free(ptrToFree);\n\n        mov     rcx, ptrVar\n        call    free\n\n        mov     rcx, ptrVar2\n        call    free\n\n        add     rsp, 48\n        ret     ; Returns to caller\n\nasmMain endp\n        end\n```", "```\nC:\\>**build listing4-3**\n\nC:\\>**echo off**\n Assembling: listing4-3.asm\nc.cpp\n\nC:\\>**listing4-3**\nCalling Listing 4-3:\nAddresses returned by malloc: 0000013B2BC43AD0h, 0000013B2BC43BE0h\nListing 4-3 terminated\n```", "```\n; Listing 4-4\n\n; Uninitialized pointer demonstration.\n; Note that this program will not\n; run properly.\n\n        option  casemap:none\n\nnl      =       10\n\n        .const\nttlStr  byte    \"Listing 4-4\", 0\nfmtStr  byte    \"Pointer value= %p\", nl, 0\n\n        .data\nptrVar  qword   ?\n\n        .code\n        externdef printf:proc\n\n; Return program title to C++ program:\n\n         public getTitle\ngetTitle proc\n         lea rax, ttlStr\n         ret\ngetTitle endp\n\n; Here is the \"asmMain\" function.\n\n        public  asmMain\nasmMain proc\n\n; \"Magic\" instruction offered without\n; explanation at this point:\n\n        sub     rsp, 48\n\n lea     rcx, fmtStr\n        mov     rdx, ptrVar\n        mov     rdx, [rdx]      ; Will crash system\n        call    printf\n\n        add     rsp, 48\n        ret     ; Returns to caller\n\nasmMain endp\n        end\n```", "```\nmov  rcx, 256\ncall malloc       ; Allocate some storage\nmov  ptrVar, rax  ; Save address away in ptrVar\n .\n .    ; Code that uses the pointer variable ptrVar.\n .\nmov   rcx, ptrVar\ncall  free        ; Free storage associated with ptrVar\n  .\n  .   ; Code that does not change the value in ptrVar.\n  .\nmov rbx, ptrVar\nmov [rbx], al\n```", "```\nmov  rcx, 256\ncall malloc\nmov  ptrVar, rax\n .              ; Code that uses ptrVar.\n .              ; This code does not free up the storage\n .              ; associated with ptrVar.\nmov  rcx, 512\ncall malloc\nmov  ptrVar, rax\n\n; At this point, there is no way to reference the original\n; block of 256 bytes pointed at by ptrVar.\n```", "```\n; Listing 4-5\n\n; Demonstration of lack of type\n; checking in assembly language\n; pointer access.\n\n          option  casemap:none\n\nnl        =     10\nmaxLen    =     256\n\n          .const\nttlStr    byte    \"Listing 4-5\", 0\nprompt    byte    \"Input a string: \", 0\nfmtStr    byte    \"%d: Hex value of char read: %x\", nl, 0\n\n          .data\nbufPtr    qword   ?\nbytesRead qword   ?\n\n        .code\n        externdef readLine:proc\n        externdef printf:proc\n externdef malloc:proc\n        externdef free:proc\n\n; Return program title to C++ program:\n\n         public getTitle\ngetTitle proc\n         lea rax, ttlStr\n         ret\ngetTitle endp\n\n; Here is the \"asmMain\" function.\n\n        public  asmMain\nasmMain proc\n        push    rbx             ; Preserve RBX\n\n; \"Magic\" instruction offered without\n; explanation at this point:\n\n        sub     rsp, 40\n\n; C standard library malloc function.\n; Allocate sufficient characters\n; to hold a line of text input\n; by the user:\n\n        mov     rcx, maxLen     ; Allocate 256 bytes\n        call    malloc\n        mov     bufPtr, rax     ; Save pointer to buffer\n\n; Read a line of text from the user and place in\n; the newly allocated buffer:\n\n        lea     rcx, prompt     ; Prompt user to input\n        call    printf          ; a line of text\n\n        mov     rcx, bufPtr     ; Pointer to input buffer\n        mov     rdx, maxLen     ; Maximum input buffer length\n        call    readLine        ; Read text from user\n        cmp     rax, -1         ; Skip output if error\n        je      allDone\n        mov     bytesRead, rax  ; Save number of chars read\n\n; Display the data input by the user:\n\n        xor     rbx, rbx        ; Set index to zero\ndispLp: mov     r9, bufPtr      ; Pointer to buffer\n        mov     rdx, rbx        ; Display index into buffer\n        mov     r8d, [r9+rbx*1] ; Read dword rather than byte!\n        lea     rcx, fmtStr\n        call    printf\n\n inc     rbx             ; Repeat for each char in buffer\n        cmp     rbx, bytesRead\n        jb      dispLp\n\n; Free the storage by calling\n; C standard library free function.\n\n; free(bufPtr);\n\nallDone:\n        mov     rcx, bufPtr\n        call    free\n\n        add     rsp, 40\n        pop     rbx     ; Restore RBX\n        ret             ; Returns to caller\nasmMain endp\n        end\n```", "```\nC:\\>**build listing4-5**\n\nC:\\>**echo off**\n Assembling: listing4-5.asm\nc.cpp\n\nC:\\>**listing4-5**\nCalling Listing 4-5:\nInput a string: Hello, World!\n0: Hex value of char read: 6c6c6548\n1: Hex value of char read: 6f6c6c65\n2: Hex value of char read: 2c6f6c6c\n3: Hex value of char read: 202c6f6c\n4: Hex value of char read: 57202c6f\n5: Hex value of char read: 6f57202c\n6: Hex value of char read: 726f5720\n7: Hex value of char read: 6c726f57\n8: Hex value of char read: 646c726f\n9: Hex value of char read: 21646c72\n10: Hex value of char read: 21646c\n11: Hex value of char read: 2164\n12: Hex value of char read: 21\n13: Hex value of char read: 5c000000\nListing 4-5 terminated\n```", "```\n .data\nzeroString byte   \"This is the zero-terminated string\", 0\n```", "```\n lea rbx, zeroString\n          xor rax, rax    ; Set RAX to zero\nwhileLp:  cmp byte ptr [rbx+rax*1], 0\n          je  endwhile\n\n          inc rax\n          jmp whileLp\n\nendwhile:\n\n; String length is now in RAX.\n```", "```\n .data\nlengthPrefixedString label byte;\n        byte 3, \"abc\"\n```", "```\n .data\nlengthPrefixedString label byte;\n     byte lpsLen, \"abc\"\nlpsLen = $-lengthPrefixedString-1\n```", "```\n; Listing 4-6\n\n; Calling C Standard Library string functions.\n\n          option  casemap:none\n\nnl        =       10\nmaxLen    =     256\n\n          .const\nttlStr    byte  \"Listing 4-6\", 0\nprompt    byte  \"Input a string: \", 0\nfmtStr1   byte  \"After strncpy, resultStr='%s'\", nl, 0\nfmtStr2   byte  \"After strncat, resultStr='%s'\", nl, 0\nfmtStr3   byte  \"After strcmp (3), eax=%d\", nl, 0\nfmtStr4   byte  \"After strcmp (4), eax=%d\", nl, 0\nfmtStr5   byte  \"After strcmp (5), eax=%d\", nl, 0\nfmtStr6   byte  \"After strchr, rax='%s'\", nl, 0\nfmtStr7   byte  \"After strstr, rax='%s'\", nl, 0\nfmtStr8   byte  \"resultStr length is %d\", nl, 0\n\nstr1      byte  \"Hello, \", 0\nstr2      byte  \"World!\", 0\nstr3      byte  \"Hello, World!\", 0\nstr4      byte  \"hello, world!\", 0\nstr5      byte  \"HELLO, WORLD!\", 0\n\n          .data\nstrLength dword ?\nresultStr byte  maxLen dup (?)\n\n        .code\n        externdef readLine:proc\n        externdef printf:proc\n        externdef malloc:proc\n        externdef free:proc\n\n; Some C standard library string functions:\n\n; size_t strlen(char *str)\n\n        externdef strlen:proc\n\n; char *strncat(char *dest, const char *src, size_t n)\n\n        externdef strncat:proc\n\n; char *strchr(const char *str, int c)\n\n        externdef strchr:proc\n\n; int strcmp(const char *str1, const char *str2)\n\n        externdef strcmp:proc\n\n; char *strncpy(char *dest, const char *src, size_t n)\n\n        externdef strncpy:proc\n\n; char *strstr(const char *inStr, const char *search4)\n\n        externdef strstr:proc\n\n; Return program title to C++ program:\n\n         public getTitle\ngetTitle proc\n         lea rax, ttlStr\n ret\ngetTitle endp\n\n; Here is the \"asmMain\" function.\n\n        public  asmMain\nasmMain proc\n\n; \"Magic\" instruction offered without\n; explanation at this point:\n\n        sub     rsp, 48\n\n; Demonstrate the strncpy function to copy a\n; string from one location to another:\n\n        lea     rcx, resultStr  ; Destination string\n        lea     rdx, str1       ; Source string\n        mov     r8, maxLen      ; Max number of chars to copy\n        call    strncpy\n\n        lea     rcx, fmtStr1\n        lea     rdx, resultStr\n        call    printf\n\n; Demonstrate the strncat function to concatenate str2 to\n; the end of resultStr:\n\n        lea     rcx, resultStr\n        lea     rdx, str2\n        mov     r8, maxLen\n        call    strncat\n\n        lea     rcx, fmtStr2\n        lea     rdx, resultStr\n        call    printf\n\n; Demonstrate the strcmp function to compare resultStr\n; with str3, str4, and str5:\n\n        lea     rcx, resultStr\n        lea     rdx, str3\n        call    strcmp\n\n        lea     rcx, fmtStr3\n        mov     rdx, rax\n        call    printf\n\n        lea     rcx, resultStr\n        lea     rdx, str4\n        call    strcmp\n\n        lea     rcx, fmtStr4\n        mov     rdx, rax\n        call    printf\n\n lea     rcx, resultStr\n        lea     rdx, str5\n        call    strcmp\n\n        lea     rcx, fmtStr5\n        mov     rdx, rax\n        call    printf\n\n; Demonstrate the strchr function to search for\n; \",\" in resultStr:\n\n        lea     rcx, resultStr\n        mov     rdx, ','\n        call    strchr\n\n        lea     rcx, fmtStr6\n        mov     rdx, rax\n        call    printf\n\n; Demonstrate the strstr function to search for\n; str2 in resultStr:\n\n        lea     rcx, resultStr\n        lea     rdx, str2\n        call    strstr\n\n        lea     rcx, fmtStr7\n        mov     rdx, rax\n        call    printf\n\n; Demonstrate a call to the strlen function:\n\n        lea     rcx, resultStr\n        call    strlen\n\n        lea     rcx, fmtStr8\n        mov     rdx, rax\n        call    printf\n\n        add     rsp, 48\n        ret     ; Returns to caller\nasmMain endp\n        end\n```", "```\nC:\\>**build listing4-6**\n\nC:\\>**echo off**\n Assembling: listing4-6.asm\nc.cpp\n\nC:\\>**listing4-6**\nCalling Listing 4-6:\nAfter strncpy, resultStr='Hello, '\nAfter strncat, resultStr='Hello, World!'\nAfter strcmp (3), eax=0\nAfter strcmp (4), eax=-1\nAfter strcmp (5), eax=1\nAfter strchr, rax=', World!'\nAfter strstr, rax='World!'\nresultStr length is 13\nListing 4-6 terminated\n```", "```\n`element_address` = `base_address` + `((index` - `initial_index)` * `element_size)`\n```", "```\n`array_name`  `base_type` n dup (?)\n```", "```\n .data\n\n; Character array with elements 0 to 127.\n\nCharArray  byte 128 dup (?)\n\n; Array of bytes with elements 0 to 9.\n\nByteArray  byte  10 dup (?)\n\n; Array of double words with elements 0 to 3.\n\nDWArray    dword  4 dup (?)\n```", "```\nRealArray   real4  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0\nIntegerAry  sdword 1, 1, 1, 1, 1, 1, 1, 1\n```", "```\nRealArray   real4  8 dup (1.0)\nIntegerAry  sdword 8 dup (1)\n```", "```\nRealArray   real4  4 dup (1.0, 2.0)\nIntegerAry  sdword 4 dup (1, 2)\n```", "```\n`element_address` = `base_address` + `index` * `element_size`\n```", "```\nlea rbx, `base_address`\n```", "```\n`element_address` = IntegerAry + (index * 4)\n```", "```\nmov rbx, index\nmov eax, IntegerAry[rbx*4]\n```", "```\nlea rdx, IntegerAry\nmov rbx, index\nmov eax, [rdx + rbx*4]\n```", "```\nlea rax, IntegerAry\nmov rbx, index\nshl rbx, 2     ; Sneaky way to compute 4 * RBX\nadd rbx, rax   ; Compute base address plus index * 4\nmov eax, [rbx]\n```", "```\nmov ebx, index  ; Zero-extends into RBX\n```", "```\n; Listing 4-7\n\n; A simple bubble sort example.\n\n; Note: This example must be assembled\n; and linked with LARGEADDRESSAWARE:NO.\n\n        option  casemap:none\n\nnl      =       10\nmaxLen  =       256\ntrue    =       1\nfalse   =       0\n\nbool    typedef ptr byte\n\n        .const\nttlStr  byte    \"Listing 4-7\", 0\nfmtStr  byte    \"Sortme[%d] = %d\", nl, 0\n\n        .data\n\n; sortMe - A 16-element array to sort:\n\nsortMe  label   dword\n        dword   1, 2, 16, 14\n        dword   3, 9, 4,  10\n        dword   5, 7, 15, 12\n        dword   8, 6, 11, 13\nsortSize = ($ - sortMe) / sizeof dword    ; Number of elements\n\n; didSwap - A Boolean value that indicates\n;          whether a swap occurred on the\n;          last loop iteration.\n\ndidSwap bool    ?\n\n        .code\n        externdef printf:proc\n\n; Return program title to C++ program:\n\n         public getTitle\ngetTitle proc\n         lea rax, ttlStr\n         ret\ngetTitle endp\n\n; Here's the bubblesort function.\n\n;       sort(dword *array, qword count);\n\n; Note: this is not an external (C)\n; function, nor does it call any\n; external functions. So it will\n; dispense with some of the Windows\n; calling sequence stuff.\n\n; array - Address passed in RCX.\n; count - Element count passed in RDX.\n\nsort    proc\n        push    rax             ; In pure assembly language\n        push    rbx             ; it's always a good idea\n        push    rcx             ; to preserve all registers\n        push    rdx             ; you modify\n        push    r8\n\n        dec     rdx             ; numElements - 1\n\n; Outer loop:\n\nouter:  mov     didSwap, false\n\n        xor     rbx, rbx        ; RBX = 0\ninner:  cmp     rbx, rdx        ; while RBX < count - 1\n        jnb     xInner\n\n mov     eax, [rcx + rbx*4]      ; EAX = sortMe[RBX]\n        cmp     eax, [rcx + rbx*4 + 4]  ; If EAX > sortMe[RBX + 1]\n        jna     dontSwap                ; then swap\n\n        ; sortMe[RBX] > sortMe[RBX + 1], so swap elements:\n\n        mov     r8d, [rcx + rbx*4 + 4]\n        mov     [rcx + rbx*4 + 4], eax\n        mov     [rcx + rbx*4], r8d\n        mov     didSwap, true\n\ndontSwap:\n        inc     rbx                     ; Next loop iteration\n        jmp     inner\n\n; Exited from inner loop, test for repeat\n; of outer loop:\n\nxInner: cmp     didSwap, true\n        je      outer\n\n        pop     r8\n        pop     rdx\n        pop     rcx\n        pop     rbx\n        pop     rax\n        ret\nsort    endp\n\n; Here is the \"asmMain\" function.\n\n        public  asmMain\nasmMain proc\n        push    rbx\n\n; \"Magic\" instruction offered without\n; explanation at this point:\n\n        sub     rsp, 40\n\n; Sort the \"sortMe\" array:\n\n        lea     rcx, sortMe\n        mov     rdx, sortSize           ; 16 elements in array\n        call    sort\n\n; Display the sorted array:\n\n        xor     rbx, rbx\ndispLp: mov     r8d, sortMe[rbx*4]\n        mov     rdx, rbx\n        lea     rcx, fmtStr\n        call    printf\n\n inc     rbx\n        cmp     rbx, sortSize\n        jb      dispLp\n\n        add     rsp, 40\n        pop     rbx\n        ret     ; Returns to caller\nasmMain endp\n        end\n```", "```\nC:\\>**sbuild listing4-7**\n\nC:\\>**echo off**\n Assembling: listing4-7.asm\nc.cpp\n\nC:\\>**listing4-7**\nCalling Listing 4-7:\nSortme[0] = 1\nSortme[1] = 2\nSortme[2] = 3\nSortme[3] = 4\nSortme[4] = 5\nSortme[5] = 6\nSortme[6] = 7\nSortme[7] = 8\nSortme[8] = 9\nSortme[9] = 10\nSortme[10] = 11\nSortme[11] = 12\nSortme[12] = 13\nSortme[13] = 14\nSortme[14] = 15\nSortme[15] = 16\nListing 4-7 terminated\n```", "```\n`element_address =`\n     `base_address` + `(``col_index` * `row_size` + `row_index``)` * `element_size`\n```", "```\nColumn          Row             Offset\nIndex           Index           into Array\n0               0               0\n0               1               1\n0               2               2\n0               3               3\n1               0               4\n1               1               5\n1               2               6\n1               3               7\n2               0               8\n2               1               9\n2               2               10\n2               3               11\n3               0               12\n3               1               13\n3               2               14\n3               3               15\n```", "```\n`Address` = `Base +` `` `((depth_index` * `col_size` + `col_index)` * `row_size` + `row_index)` * `element_size` ``\n```", "```\n`Address` = `Base` + \n     `(((left_index` * `depth_size` + `depth_index`*)* * `col_size` + `col_index)` *\n     `row_size` + `row_index`*)* * `element_size`\n```", "```\nA: array [0..3] of sometype;\n```", "```\n`element_address` = `Base` +`index` * `element_size`\n```", "```\ntype\n OneD   = array[0..3] of char;\n TwoD   = array[0..3] of OneD;\n ThreeD = array[0..3] of TwoD;\n FourD  = array[0..3] of ThreeD;\nvar\n A: array[0..3] of FourD;\n```", "```\n`element_address` = `base_address` + `(row_index` * `col_size` + `col_index) *`\n     `element_size`\n```", "```\n`Address` = `Base` +\n     `((row_index` * `col_size` + `col_index)` *\n     `depth_size` + `depth_index)` * `element_size`\n```", "```\n`Address` =\n     `Base` + `(((row_index` * `col_size` + `col_index)` * `depth_size` + `depth_index)`\n `` `left_size` + `left_index)` * `element_size` ``\n```", "```\n`array_name` `element_type` `size`[1]*`size`[2]*`size`[3]*...*`size`[*n*] dup (?)\n```", "```\nGameGrid byte 4*4 dup (?)\n```", "```\nNameItems qword 2 * 3 * 3 dup (?)\n```", "```\nGameGrid byte 'a', 'b', 'c', 'd'\n         byte 'e', 'f', 'g', 'h'\n         byte 'i', 'j', 'k', 'l'\n         byte 'm', 'n', 'o', 'p'\n```", "```\nGameGrid byte  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n'k', 'l', 'm', 'n', 'o', 'p'\n```", "```\nStateValue byte 256*64 dup (0FFh)\n```", "```\nStateValue byte 256 dup (64 dup (0FFh))\n```", "```\n .data\ni        sdword  ?\nj        sdword  ?\nTwoD     sdword  4 dup (8 dup (?))\n\n           .\n           .\n           .\n\n; To perform the operation TwoD[i,j] := 5;\n; you'd use code like the following.\n; Note that the array index computation is (i*8 + j)*4.\n\n          mov ebx, i   ; Remember, zero-extends into RBX\n          shl rbx, 3   ; Multiply by 8\n          add ebx, j   ; Also zero-extends result into RBX^([11](#c04-footnote-13))\n          mov TwoD[rbx*4], 5\n```", "```\n .data\ni       dword  ?\nj       dword  ?\nk       dword  ?\nThreeD  sdword 3 dup (4 dup (5 dup (?)))\n          .\n          .\n          .\n\n; To perform the operation ThreeD[i,j,k] := ESI;\n; you'd use the following code that computes\n; ((i*4 + j)*5 + k)*4 as the address of ThreeD[i,j,k].\n\n          mov  ebx, i   ; Zero-extends into RBX\n          shl  ebx, 2   ; Four elements per column\n          add  ebx, j\n          imul ebx, 5   ; Five elements per row\n          add  ebx, k\n          mov  ThreeD[rbx*4], esi\n```", "```\nstudent = \n     record\n          Name:     string[64];\n          Major:    integer;\n          SSN:      string[11];\n          Midterm1: integer;\n Midterm2: integer;\n          Final:    integer;\n          Homework: integer;\n          Projects: integer;\n     end;\n```", "```\nstudent  struct\nsName    byte    65 dup (?)  ; \"Name\" is a MASM reserved word\nMajor    word    ?\nSSN      byte    12 dup (?)\nMidterm1 word    ?\nMidterm2 word    ?\nFinal    word    ?\nHomework word    ?\nProjects word    ?\nstudent  ends\n```", "```\n .data\nJohn    student  {}\n```", "```\nmov word ptr John[65], ax\n```", "```\nmov  rcx, sizeof student  ; Size of student struct\ncall malloc               ; Returns pointer in RAX\nmov [rax].Final, 100\n```", "```\nmov  rcx, sizeof student  ; Size of student struct\ncall malloc\nmov [rax].student.Final, 100\n```", "```\ngrades    struct\nMidterm1  word  ?\nMidterm2  word  ?\nFinal     word  ?\nHomework  word  ?\nProjects  word  ?\ngrades    ends\n\nstudent   struct\nsName     byte  65 dup (?)  ; \"Name\" is a MASM reserved word\nMajor     word  ?\nSSN       byte  12 dup (?)\nsGrades   grades {}\nstudent   ends\n```", "```\nmov ax, John.sGrades.Homework\n```", "```\n .data\nstructVar  structType  {}\n```", "```\n; Listing 4-8\n\n; Sample struct initialization example.\n\n         option  casemap:none\n\nnl       =       10\n\n         .const\nttlStr   byte    \"Listing 4-8\", 0\nfmtStr   byte    \"aString: maxLen:%d, len:%d, string data:'%s'\"\n         byte    nl, 0\n\n; Define a struct for a string descriptor:\n\nstrDesc  struct\nmaxLen   dword   ?\nlen      dword   ?\nstrPtr   qword   ?\nstrDesc  ends\n\n         .data\n\n; Here's the string data we will initialize the\n; string descriptor with:\n\ncharData byte   \"Initial String Data\", 0\nlen      =      lengthof charData ; Includes zero byte\n\n; Create a string descriptor initialized with\n; the charData string value:\n\naString  strDesc {len, len, offset charData}\n\n        .code\n        externdef printf:proc\n\n; Return program title to C++ program:\n\n         public getTitle\ngetTitle proc\n         lea rax, ttlStr\n         ret\ngetTitle endp\n\n; Here is the \"asmMain\" function.\n\n        public  asmMain\nasmMain proc\n\n; \"Magic\" instruction offered without\n; explanation at this point:\n\n        sub     rsp, 48\n\n; Display the fields of the string descriptor.\n\n        lea     rcx, fmtStr\n        mov     edx, aString.maxLen ; Zero-extends!\n        mov     r8d, aString.len    ; Zero-extends!\n        mov     r9,  aString.strPtr\n        call    printf\n\n        add     rsp, 48 ; Restore RSP\n        ret             ; Returns to caller\nasmMain endp\n        end\n```", "```\nC:\\>**build listing4-8**\n\nC:\\>**echo off**\n Assembling: listing4-8.asm\nc.cpp\n\nC:\\>**listing4-8**\nCalling Listing 4-8:\naString: maxLen:20, len:20, string data:'Initial String Data'\nListing 4-8 terminated\n```", "```\naryStruct struct\naryField1 byte    8 dup (?)\naryField2 word    4 dup (?)\naryStruct ends\n```", "```\na aryStruct {1,2,3,4,5,6,7,8,  1,2,3,4}\n```", "```\na aryStruct {{1,2,3,4,5,6,7,8}, {1,2,3,4}}\n```", "```\na aryStruct {{1,2,3,4}, {1,2,3,4}}\n```", "```\nb aryStruct {\"abcdefgh\", {1,2,3,4}}\n```", "```\nrecElement struct\n   `Fields for this record` \nrecElement ends\n            .\n            .\n            .\n           .data\nrecArray   recElement 4 dup ({})\n```", "```\n; Access element i of recArray:\n; RBX := i*lengthof(recElement)\n\n   imul ebx, i, sizeOf recElement     ; Zero-extends EBX to RBX!\n   mov  eax, recArray.someField[rbx]  ; LARGEADDRESSAWARE:NO!\n```", "```\n .data\nrec2D   recElement 4 dup (6 dup ({}))\n          .\n          .\n          .\n; Access element [i,j] of rec2D and load someField into EAX:\n\n     imul ebx, i, 6\n     add  ebx, j\n     imul ebx, sizeof recElement\n     lea  rcx, rec2D  ; To avoid requiring LARGEADDRESS...\n     mov  eax, [rcx].recElement.someField[rbx*1]\n```", "```\nPadded  struct\nb       byte    ?\nd       dword   ?\nb2      byte    ?\nb3      byte    ?\nw       word    ?\nPadded  ends\n```", "```\n Name                     Size Offset     Type\n\nPadded . . . . . . . . . . . . . 00000009\n  b  . . . . . . . . . . . . . .         00000000        byte\n  d  . . . . . . . . . . . . . .         00000001        dword\n  b2 . . . . . . . . . . . . . .         00000005        byte\n  b3 . . . . . . . . . . . . . .         00000006        byte\n  w  . . . . . . . . . . . . . .         00000007        word\n```", "```\nPadded  struct\nb       byte    ?\n        align   4\nd       dword   ?\nb2      byte    ?\nb3      byte    ?\n        align   2\nw       word    ?\nPadded  ends\n```", "```\nPadded . . . . . . . . . . . . .         0000000C\n  b  . . . . . . . . . . . . . .         00000000        byte\n  d  . . . . . . . . . . . . . .         00000004        dword\n  b2 . . . . . . . . . . . . . .         00000008        byte\n  b3 . . . . . . . . . . . . . .         00000009        byte\n  w  . . . . . . . . . . . . . .         0000000A        word\n```", "```\nPadded  struct  4\nb       byte    ?\nd       dword   ?\nb2      byte    ?\nb3      byte    ?\nw       word    ?\nPadded  ends\n```", "```\nPadded . . . . . . . . . . . . .         0000000C\n  b  . . . . . . . . . . . . . .         00000000        byte\n  d  . . . . . . . . . . . . . .         00000004        dword\n  b2 . . . . . . . . . . . . . .         00000008        byte\n  b3 . . . . . . . . . . . . . .         00000009        byte\n  w  . . . . . . . . . . . . . .         0000000A        word\n```", "```\nunionType union\n `Fields (syntactically identical to struct declarations)`\nunionType ends\n```", "```\nendu  textequ <ends>\n```", "```\nnumeric  union\ni        sdword  ?\nu        dword   ?\nq        qword   ?\nnumeric  ends\n           .\n           .\n           .\n         .data\nnumber  numeric  {}\n           .\n           .\n           .\n     mov number.u, 55\n           .\n           .\n           .\n     mov number.i, -62\n           .\n           .\n           .\n     mov rbx, number.q\n```", "```\nnumericRec  struct\ni           sdword  ?\nu           dword   ?\nq           qword   ?\nnumericRec  ends\n```", "```\nCharOrUns union\nchr       byte      ?\nu         dword     ?\nCharOrUns ends\n\n          .data\nv         CharOrUns {}\n```", "```\nmov v.u, eax\nmov ch, v.chr\n```", "```\nHasAnonUnion struct\nr            real8    ?\n\n             union\nu            dword    ?\ni            sdword   ?\n             ends\n\ns            qword    ?\nHasAnonUnion ends\n\n             .data\nv            HasAnonUnion {}\n```", "```\nv.r           0\nv.u           8\nv.i           8\nv.s          12\n```", "```\nVariantType struct\ntag         dword    ?  ; 0-uns32, 1-int32, 2-real64\n\n            union\nu           dword    ?\ni           sdword   ?\nr           real8    ?\n ends\nVariantType ends\n\n            .data\nv           VariantType {}\n```"]