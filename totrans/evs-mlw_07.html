<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_95" aria-label="95"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch5">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">USER ENVIRONMENT AND INTERACTION DETECTION</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">As automated malware sandboxes get better at hiding themselves from evasive malware, malware authors must adapt. One tactic they use is to enumerate the user’s environment and the user’s interaction with it. As <span class="chapterintro_Xref"><a href="chapter4.xhtml">Chapter 4</a></span> noted, the everyday user’s setup has open browser tabs, many windows open and apps in use, and frequent mouse and keyboard interaction, making it quite different from the sandbox environment. An automated malware analysis sandbox is designed to boot up, detonate a malware sample, and then promptly shut down. It may not exhibit any normal user behaviors or other indicators that suggest it’s a valid end-user system.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_96" aria-label="96"/>Modern malware can look for evidence of a real user by searching for typical user behaviors, such as downloaded browser cookies and desktop wallpaper settings or mouse and keyboard interactions. In this chapter, I’ll outline some interesting techniques that malware uses to accomplish this.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-66"/><samp class="SANS_Futura_Std_Bold_B_11">Browser Cookies, Cache, and Browsing History</samp></h3>&#13;
<p class="TNI1">Some malware may be able to enumerate the host’s internet cookies, cache, and browsing history. <i>Cookies</i> are small files that web pages save to the disk, usually for storing the user’s website configuration and preferences. Depending on the browser and version, cookies can be stored in individual files or in a small database, such as SQLite. The <i>cache</i> is a file or group of files that stores website resources such as images so that the page loads more quickly the next time the user visits it. Much like cookies, the cache can be stored in multiple files or in a database. Finally, the <i>browsing history</i> is simply a list of previously visited websites, typically stored as one or more database files.</p>&#13;
<p class="TX">The typical end user will likely have hundreds or thousands of stored cookie and cache files and a large internet browsing history, whereas a typical sandbox or malware analysis system may not have any at all. Malware can take advantage of this discrepancy by counting the number of cookies, cache entries, or previously visited websites and checking it against a threshold value. For example, if the victim machine has only five entries in its browsing history, the malware might assume it’s running in a clean sandbox environment.</p>&#13;
<p class="TX">Every browser has standard locations for cookies, cache files, and browsing history that malware might attempt to enumerate. Here are some of the most common:</p>&#13;
<p class="ListHead"><b>Chrome</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Local\Google\Chrome\User Data\Default</i></li>&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Local\Google\Chrome\User Data\Default\Cache</i></li>&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Local\Google\Chrome\User Data\Default\History</i></li>&#13;
</ul>&#13;
<p class="ListHead"><b>Firefox</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Local\Mozilla\Firefox\Profiles</i></li>&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Roaming\Mozilla\Firefox\Profiles</i></li>&#13;
</ul>&#13;
<p class="ListHead"><b>Internet Explorer</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Roaming\Microsoft\Windows\Cookies</i></li>&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Local\Microsoft\Windows\Temporary Internet Files</i></li>&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Local\Microsoft\Windows\WebCache</i></li>&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Local\Microsoft\Internet Explorer\Recovery</i></li>&#13;
</ul>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_97" aria-label="97"/><b>Edge</b></p>&#13;
<ul class="ul">&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Local\Packages\&lt;package name&gt;\AC\MicrosoftEdge\User\</i></li>&#13;
<li class="BL"><i>C:\Users\&lt;user&gt;\AppData\Local\Packages\&lt;package name&gt;\AC\MicrosoftEdge\Cache\</i></li>&#13;
</ul>&#13;
<p class="TX">This list is non-exhaustive, and locations may change, of course, depending on the Windows OS and browser versions in use.</p>&#13;
<p class="TX">If you spot malware enumerating through these files (possibly by calling Windows functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstFile</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextFile</samp>), it may be attempting to detect the analysis environment. Malware may also use <samp class="SANS_TheSansMonoCd_W5Regular_11">FindFirstUrlCacheEntry</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FindNextUrlCacheEntry</samp>, which sequentially enumerate browser cache entries. These APIs are specific to Microsoft browser caches, however. Once again, the enumeration method will largely depend on the browser and version being used.</p>&#13;
<p class="TX">Older browsers and versions typically use multiple small files for cookies, cache, and history storage, while modern browsers use databases. If the browser cookies, cache, and history are stored in database files, the malware may attempt to interact with them directly. For example, in either the malware executable file or its process memory address space, you may spot static strings that reference certain browser directories (such as <i>C:\Users\&lt;user&gt;\AppData\Local\Google\Chrome\User Data\Default\History</i>), followed by a database query such as this:</p>&#13;
<pre class="pre-24"><code>SELECT title FROM urls</code></pre>&#13;
<p class="TX">This command could be used to enumerate all of the web history in the history database. Database interaction is beyond the scope of this book, so we won’t go into further detail here, but it’s important to be aware of this technique.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-67"/><samp class="SANS_Futura_Std_Bold_B_11">Recent Office Files</samp></h3>&#13;
<p class="TNI1">Using recent Office files is another good way for malware to determine whether it’s running in an analysis lab. A real end user will likely have opened many files with Microsoft Office applications, and Windows keeps track of those files. When you open a document in Word, for example, the file will be added to your <i>Office Recent Files</i> list.</p>&#13;
<p class="TX">Information about your recent Office files is contained in the registry key <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office\&lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Office_Version_Number</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp>, under a specific subkey called <samp class="SANS_TheSansMonoCd_W5Regular_11">Excel</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Word</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Powerpoint</samp>, and so on. Further information may be stored in the filesystem directory <i>C:\Users\&lt;user&gt;\AppData\Roaming\Microsoft\Office\Recent.</i> If you spot malware enumerating this registry key or folder path (using any of the previously mentioned Windows functions for file and registry enumeration), it may very well be attempting to identify recent Office documents to determine whether the victim host is being used by a “real” end user.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_98" aria-label="98"/>&#13;
<h3 class="H1" id="sec3"><span id="h-68"/><samp class="SANS_Futura_Std_Bold_B_11">User Files and Directories</samp></h3>&#13;
<p class="TNI1">A typical user will probably have many files on the system in various user directories, such as <i>Documents</i>, <i>Pictures</i>, <i>Desktop</i>, and so on. Using the file enumeration methods described in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, malware can enumerate these directories in order to sense whether the host is a real user or not. If the malware discovers a lack of user activity in these directories, it might conclude that it’s running in a sandbox or analysis environment and take evasive actions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h-69"/><samp class="SANS_Futura_Std_Bold_B_11">Desktop Wallpaper</samp></h3>&#13;
<p class="TNI1">One particularly creative method malware uses to detect analysis machines is checking the currently configured wallpaper, since authentic users tend to change their desktop wallpaper from the Windows default. To do so, the malware can simply check the Wallpaper registry value <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Desktop\General\WallpaperSource</samp>. If the user is still using the default Windows wallpaper, the <samp class="SANS_TheSansMonoCd_W5Regular_11">WallpaperSource</samp> value will contain that wallpaper’s path, which is somewhere in the <i>C:\Windows\</i> directory. On the other hand, if the user has custom desktop wallpaper configured, the <samp class="SANS_TheSansMonoCd_W5Regular_11">WallpaperSource</samp> value will likely contain a custom directory and image name, such as <i>C:\Users\&lt;user&gt;\Pictures\my_wallpaper.jpg</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h-70"/><samp class="SANS_Futura_Std_Bold_B_11">Desktop Windows</samp></h3>&#13;
<p class="TNI1">Some malware variants count the number of active desktop windows or search for specific ones. They can use the function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetForegroundWindow</samp> to test whether the foreground window (meaning the currently active window) changes. Since I’m typing this text in LibreOffice, this program is my active foreground window. As a legitimate user, my active window will likely change quite a bit; for example, I might minimize LibreOffice to take a break from writing and watch YouTube cat videos in Chrome. In an automated malware analysis sandbox environment, the active window probably won’t change much. Some malware variants know this and can use it against the analysis system for detection. In this example, the malware is checking whether the foreground window has changed after five seconds:</p>&#13;
<pre class="pre-25"><code>loc_34E642:&#13;
call GetForegroundWindow&#13;
mov dword ptr ds:[ebx+WindowHandle], eax&#13;
push 1388h ; "5s"&#13;
call Sleep&#13;
call GetForegroundWindow&#13;
cmp dword ptr ds:[ebx+WindowHandle], eax&#13;
je loc_34E642</code></pre>&#13;
<p class="TX">First, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetForegroundWindow</samp>, which returns a handle to the current foreground window and stores it in the buffer at address <span role="doc-pagebreak" epub:type="pagebreak" id="pg_99" aria-label="99"/><samp class="SANS_TheSansMonoCd_W5Regular_11">[ebx+WindowHandle]</samp>. Next, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function, which will pause the sample for five seconds. The malware makes a second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">GetForegroundWindow</samp> and then compares the handle values of the two <samp class="SANS_TheSansMonoCd_W5Regular_11">GetForegroundWindow</samp> calls with <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp dword ptr ds:[ebx+WindowHandle], eax</samp>. If the handles match (meaning that the foreground window hasn’t changed), this routine loops over again. This malware sample could continue to loop indefinitely, possibly avoiding analysis in an automated sandbox completely, or it could loop several times and then terminate itself. Either scenario presents an interesting challenge for a malware analysis sandbox. Fortunately, many modern sandboxes simulate user activity to thwart this technique. Some can even run in interactive mode, which allows you to directly interact with the malware inside the sandbox, also helping to circumvent this type of tactic.</p>&#13;
<p class="TX">Alternatively, a malware sample can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp> function, which returns the number of open windows on the user’s desktop. Windows creates many window objects for various reasons, so in a normal user environment, this number will be fairly high. For example, I ran <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp> on my personal system and it returned a value of 97 windows! In a sandbox analysis environment, this number will likely be substantially lower. This code snippet demonstrates the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp> function:</p>&#13;
<pre class="pre-26"><code>push ebx&#13;
call EnumWindows&#13;
pop eax&#13;
cmp eax, 20&#13;
jle terminate_process</code></pre>&#13;
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp> takes a parameter that essentially serves as a pointer to a buffer that will store the result of the function call (<samp class="SANS_TheSansMonoCd_W5Regular_11">push ebx</samp>). After <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp> is called, the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop eax</samp> instruction will pop the pointer from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> buffer off the stack and into <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>. The malware compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp> value (now stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>) to <samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp>, and if the number of open windows is less than or equal to this value, the sample will terminate itself. This sample is assuming that a malware analysis sandbox will have 20 or fewer windows activated at one time.</p>&#13;
<p class="TX">Besides enumerating the number of active windows on the victim system or sensing whether the foreground window is changing, malware can also actively search for a specific application window. This is useful for two reasons. First, the malware sample can search for open windows running applications that are commonly run by typical end users: Microsoft Office products, email programs, browsers, and so on. If enough of these applications are open, the malware could reasonably assume it’s <i>not</i> running in a malware analyst’s lab. Second, the malware sample can look for certain malware analysis tools, similar to what I described in <span class="Xref">“Processes”</span> in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>. For example, the malware might search for open windows that contain the term <i>Procmon</i>, <i>Fiddler</i>, or <i>Wireshark</i>, typically by calling the function <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">FindWindow</samp>. As with looking for a certain process, it iterates <span role="doc-pagebreak" epub:type="pagebreak" id="pg_100" aria-label="100"/>through open windows and compares the title of each to a string, and the result can clue it in to the fact that it’s being analyzed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h-71"/><samp class="SANS_Futura_Std_Bold_B_11">Mouse and Keyboard Interaction</samp></h3>&#13;
<p class="TNI1">Everyday end users are almost always using their mouse to move their cursor around the screen, whether they’re browsing the internet, editing a document, or playing a video game. Some malware can detect this activity using <samp class="SANS_TheSansMonoCd_W5Regular_11">GetCursorPos</samp>, which returns the coordinates of the user’s mouse cursor. The following pseudocode shows what this might look like in action:</p>&#13;
<pre class="pre-27"><code>GetCursorPos(&amp;CursorPos1)&#13;
Sleep(30)&#13;
GetCursorPos(&amp;CursorPos2)&#13;
&#13;
if (CursorPos1 == CursorPos2)&#13;
  TerminateProcess()</code></pre>&#13;
<p class="TX">First, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetCursorPos</samp> function and stores the resulting mouse cursor coordinates in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CursorPos1</samp> buffer. Next, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function, which pauses the malware’s execution for 30 seconds, and then it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetCursorPos</samp> again. Finally, it compares the two resulting cursor coordinate values, and if they’re the same (meaning the cursor hasn’t moved), the sample will terminate itself. You can probably see how this is an effective method for evading automated sandboxes, as the cursor is unlikely to move itself (unless, of course, the sandbox is designed to mimic a real user).</p>&#13;
<p class="TX">Another similar technique involves the malware waiting for certain mouse buttons to be pressed or a certain number of mouse clicks to occur before it executes its malicious code. FireEye wrote a 2012 research article, “Hot Knives Through Butter: Evading File-based Sandboxes,” about this particular technique being used by a malware family called Upclicker. To monitor these mouse actions, Upclicker established a <i>hook</i> on the mouse, allowing the malware to intercept and monitor all mouse activity and wait for certain events to occur. Here’s what this might look like in malware code:</p>&#13;
<pre class="pre-28"><code>push offset jump_location&#13;
push 0Eh&#13;
call SetWindowsHookExA&#13;
<var>--snip--</var>&#13;
loc jump_location:&#13;
call do_evil_things</code></pre>&#13;
<p class="TX">The malware sample first pushes the <samp class="SANS_TheSansMonoCd_W5Regular_11">jump_location</samp> parameter to the stack; this is where the malware will jump to when a certain mouse event occurs. Another parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">0E</samp> in hexadecimal (or 14 in decimal), tells <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookExA</samp> to hook mouse actions. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookExA</samp> tells the program to jump to the code specified in <samp class="SANS_TheSansMonoCd_W5Regular_11">jump_location</samp> once the victim user clicks a mouse button.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_101" aria-label="101"/>This code is simplified for the sake of brevity. In reality, the malware would likely implement extra logic to take action only upon certain mouse events, such as a left-button click (as in the case of Upclicker). To read more about Upclicker and also get a good introduction to sandbox evasion, check out the FireEye report at <a href="https://media.blackhat.com/us-13/US-13-Singh-Hot-Knives-Through-Butter-Evading-File-based-Sandboxes-WP.pdf"><i>https://<wbr/>media<wbr/>.blackhat<wbr/>.com<wbr/>/us<wbr/>-13<wbr/>/US<wbr/>-13<wbr/>-Singh<wbr/>-Hot<wbr/>-Knives<wbr/>-Through<wbr/>-Butter<wbr/>-Evading<wbr/>-File<wbr/>-based<wbr/>-Sandboxes<wbr/>-WP<wbr/>.pdf<wbr/></i></a>.</p>&#13;
<p class="TX">This hooking magic doesn’t just work for the mouse. Malware can also hook the keyboard by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">0Dh</samp> (13 in decimal) to the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetWindowsHookEx</samp> function instead, then waiting for a certain key to be pressed before fully executing. (Hooking will be discussed in more detail in <span class="Xref"><a href="chapter8.xhtml">Chapters 8</a></span> and <span class="Xref"><a href="chapter12.xhtml">12</a></span>.) Alternatively, malware could also call the function <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAsyncKeyState</samp> to monitor for keypresses.</p>&#13;
<p class="TX">Monitoring mouse and keyboard interactions can be a very effective method of detecting and bypassing an automated malware analysis sandbox. Unless the sandbox or malware analyst presses the specific keys or mouse buttons, the malware sample may look completely benign in the context of the sandbox environment.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>To simulate a real end-user environment, make your analysis VMs and sandboxes look as much like a real user as possible. Changing your wallpaper and visiting some websites (to populate your cookies and cache directories) can go a long way. Even opening additional windows and moving the mouse around the screen may help avoid some of these detection techniques, even if you feel a bit silly doing it.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h-72"/><samp class="SANS_Futura_Std_Bold_B_11">System Uptime</samp></h3>&#13;
<p class="TNI1"><i>System uptime</i> is the length of time the system has been powered on, and it can be a great indicator to malware that it’s in an analysis environment. A typical end-user device will likely be powered on for hours, if not days, at a time. Servers may be powered on for months or years without a reboot. Since malware analysts typically boot up their VMs and sandboxes to analyze a malware sample on demand, a short system uptime can be a big hint that the system is an analysis machine.</p>&#13;
<p class="TX">There are multiple ways to check for system uptime, via both the Windows API and other helper commands. Perhaps the most common method is the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> Windows API function, which returns the system uptime in milliseconds. A <i>tick</i> is created by the processor clock, which is responsible for keeping time and coordinating instructions. When a system is shut down or rebooted, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> essentially resets to 0. The following code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> to see if the system has been powered on for 20 minutes:</p>&#13;
<pre class="pre-29"><code>mov ebx, 124F80h&#13;
call GetTickCount&#13;
cmp eax, ebx&#13;
jb  terminate_process</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_102" aria-label="102"/>The sample first moves <samp class="SANS_TheSansMonoCd_W5Regular_11">124F80</samp> in hex (1200000 in decimal) into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> register, representing 1,200,000 milliseconds, or 20 minutes. Then, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> and compares the returned tick count value to the value in <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>. If the value from <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> is below the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> value, meaning the system has been powered on for less than 20 minutes, the malware sample terminates itself.</p>&#13;
<p class="TX">Malware may also use the Windows command line to get the system uptime. Options include the <samp class="SANS_TheSansMonoCd_W5Regular_11">sysinfo</samp> command, which returns a list of information about the system, including the uptime; <samp class="SANS_TheSansMonoCd_W5Regular_11">uptime.exe</samp>, a binary included with most versions of Windows; and the <samp class="SANS_TheSansMonoCd_W5Regular_11">net statistics workstation</samp> command. Finally, malware can invoke WMIC to return the system uptime using the command <samp class="SANS_TheSansMonoCd_W5Regular_11">wmic os get lastbootuptime</samp>.</p>&#13;
<p class="TX">One final important note here is that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> and the other methods mentioned are often used in both benign and malicious applications, and not just for exposing analysis environments and sandboxes. Just because a malware sample is inspecting the system uptime doesn’t mean it’s acting evasively, but you should treat the behavior as a red flag.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h-73"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">In this chapter, we covered some creative and sneaky ways in which malware can enumerate the environment and look for evidence of actual user activity. You can thwart many of these user detection techniques simply by designing your analysis environment to make it look legitimate to malware. Some of these changes, such as changing the default Windows wallpaper and ensuring you have some items in your browsing history, are simple to implement. We’ll discuss other ways to thwart detection techniques in <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a></span>. Note also that some advanced sandboxes have built-in protections against many of these techniques.</p>&#13;
<p class="TX">In the next chapter, we’ll look at how evasive malware can enumerate system hardware and network device information to detect a VM analysis environment.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>