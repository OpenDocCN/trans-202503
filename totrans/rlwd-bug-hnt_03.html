<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_19"/><strong><span class="big">3</span><br/>HTTP PARAMETER POLLUTION</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent"><em>HTTP parameter pollution (HPP)</em> is the process of manipulating how a website treats the parameters it receives during HTTP requests. The vulnerability occurs when an attacker injects extra parameters into a request and the target website trusts them, leading to unexpected behavior. HPP bugs can happen on the server side or on the client side. On the client side, which is usually your browser, you can see the effect of your tests. In many cases, HPP vulnerabilities depend on how server-side code uses values passed as parameters, which are controlled by an attacker. For this reason, finding these vulnerabilities might require more experimentation than other types of bugs.</p>&#13;
<p class="indent">In this chapter, we’ll begin by exploring the differences between server-side HPP and client-side HPP in general. Then I’ll use three examples involving popular social media channels to illustrate how to use HPP to inject <span epub:type="pagebreak" id="page_20"/>parameters on target websites. Specifically, you’ll learn the differences between server- and client-side HPP, how to test for this vulnerability type, and where developers often make mistakes. As you’ll see, finding HPP vulnerabilities requires experimentation and persistence but can be worth the effort.</p>&#13;
<h3 class="h3" id="ch03lev1sec1"><strong>Server-Side HPP</strong></h3>&#13;
<p class="noindent">In server-side HPP, you send the servers unexpected information in an attempt to make the server-side code return unexpected results. When you make a request to a website, the site’s servers process the request and return a response, as discussed in <a href="ch01.xhtml#ch01">Chapter 1</a>. In some cases, the servers don’t just return a web page but also run some code based on information they receive from the URL that is sent. This code runs only on the servers, so it’s essentially invisible to you: you can see the information you send and the results you get back, but the code in between isn’t available. Therefore, you can only infer what’s happening. Because you can’t see how the server’s code functions, server-side HPP depends on you identifying potentially vulnerable parameters and experimenting with them.</p>&#13;
<p class="indent">Let’s look at an example: a server-side HPP could happen if your bank initiated transfers through its website by accepting URL parameters that were processed on its servers. Imagine that you could transfer money by entering values in the three URL parameters <span class="literal">from</span>, <span class="literal">to</span>, and <span class="literal">amount</span>. Each parameter specifies the account number to transfer money from, the account number to transfer to, and the amount to transfer, in that order. A URL with these parameters that transfers $5,000 from account number 12345 to account number 67890 might look like this:</p>&#13;
<p class="programs">https://www.<span class="codeitalic1">bank</span>.com/transfer?from=12345&amp;to=67890&amp;amount=5000</p>&#13;
<p class="indent">It’s possible the bank could assume that it will receive only one <span class="literal">from</span> parameter. But what happens if you submit two, as in the following URL:</p>&#13;
<p class="programs">https://www.<span class="codeitalic1">bank</span>.com/transfer?from=12345&amp;to=67890&amp;amount=5000&amp;from=ABCDEF</p>&#13;
<p class="indent">This URL is initially structured in the same way as the first example but appends an extra <span class="literal">from</span> parameter that specifies another sending account, <span class="literal">ABCDEF</span>. In this situation, an attacker would send the extra parameter in the hopes that the application would validate the transfer using the first <span class="literal">from</span> parameter but withdraw the money using the second one. So, an attacker might be able to execute a transfer from an account they don’t own if the bank trusted the last <span class="literal">from</span> parameter it received. Instead of transferring $5,000 from account 12345 to 67890, the server-side code would use the second parameter and send money from account ABCDEF to 67890.</p>&#13;
<p class="indent">When a server receives multiple parameters with the same name, it can respond in a variety of ways. For example, PHP and Apache use the last <span epub:type="pagebreak" id="page_21"/>occurrence, Apache Tomcat uses the first occurrence, ASP and IIS use all occurrences, and so on. Two researchers, Luca Carettoni and Stefano di Paolo, provided a detailed presentation on the many differences between server technologies at the AppSec EU 09 conference: this information is now available on the OWASP website at <em><a href="https://www.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf">https://www.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf</a></em> (see slide 9). As a result, there is no single guaranteed process for handling multiple parameter submissions with the same name, and finding HPP vulnerabilities takes some experimentation to confirm how the site you’re testing works.</p>&#13;
<p class="indent">The bank example uses parameters that are obvious. But sometimes HPP vulnerabilities occur as a result of hidden server-side behavior from code that isn’t directly visible. For example, let’s say your bank decides to revise the way it processes transfers and changes its backend code to not include a <span class="literal">from</span> parameter in the URL. This time, the bank will take two parameters, one for the account to transfer to and the other for the amount to transfer. The account to transfer from will be set by the server, which is invisible to you. An example link might look like this:</p>&#13;
<p class="programs">https://www.<span class="codeitalic1">bank</span>.com/transfer?to=67890&amp;amount=5000</p>&#13;
<p class="indent">Normally, the server-side code would be a mystery to us, but for the sake of this example, we know that the bank’s (overtly terrible and redundant) server-side Ruby code looks like this:</p>&#13;
<p class="programs">user.account = 12345<br/>&#13;
def prepare_transfer(<span class="ent">➊</span>params)<br/>&#13;
  <span class="ent">➋</span> params &lt;&lt; user.account<br/>&#13;
  <span class="ent">➌</span> transfer_money(params) #user.account (12345) becomes params[2]<br/>&#13;
end<br/>&#13;
def transfer_money(params)<br/>&#13;
  <span class="ent">➍</span> to = params[0]<br/>&#13;
  <span class="ent">➎</span> amount = params[1]<br/>&#13;
  <span class="ent">➏</span> from = params[2]<br/>&#13;
    transfer(to,amount,from)<br/>&#13;
end</p>&#13;
<p class="indent">This code creates two functions, <span class="literal">prepare_transfer</span> and <span class="literal">transfer_money</span>. The <span class="literal">prepare_transfer</span> function takes an array called <span class="literal">params</span> <span class="ent">➊</span>, which contains the <span class="literal">to</span> and <span class="literal">amount</span> parameters from the URL. The array would be <span class="literal">[67890,5000]</span>, where the array values are sandwiched between brackets and each value is separated by a comma. The first line of the function <span class="ent">➋</span> adds the user account information that was defined earlier in the code to the end of the array. We end up with the array <span class="literal">[67890,5000,12345]</span> in <span class="literal">params</span>, and then <span class="literal">params</span> is passed to <span class="literal">transfer_money</span> <span class="ent">➌</span>. Notice that unlike parameters, arrays don’t have names associated with their values, so the code depends on the array always containing each value in order: the account to transfer to is first, the amount to transfer is next, and the account to transfer <span epub:type="pagebreak" id="page_22"/>from follows the other two values. In <span class="literal">transfer_money</span>, the order of the values becomes evident as the function assigns each array value to a variable. Because array locations are numbered starting from 0, <span class="literal">params[0]</span> accesses the value at the first location in the array, which is <span class="literal">67890</span> in this case, and assigns it to the variable <span class="literal">to</span> <span class="ent">➍</span>. The other values are also assigned to variables at lines <span class="ent">➎</span> and <span class="ent">➏</span>. Then the variable names are passed to the <span class="literal">transfer</span> function, not shown in this code snippet, which takes the values and transfers the money.</p>&#13;
<p class="indent">Ideally, the URL parameters would always be formatted in the way the code expects. However, an attacker could change the outcome of this logic by passing in a <span class="literal">from</span> value to <span class="literal">params</span>, as with the following URL:</p>&#13;
<p class="programs">https://www.<span class="codeitalic1">bank</span>.com/transfer?to=67890&amp;amount=5000&amp;from=ABCDEF</p>&#13;
<p class="indent">In this case, the <span class="literal">from</span> parameter is also included in the <span class="literal">params</span> array passed to the <span class="literal">prepare_transfer</span> function; therefore, the array’s values would be <span class="literal">[67890,5000,ABCDEF]</span>, and adding the user account at <span class="ent">➋</span> would result in <span class="literal">[67890,5000,ABCDEF,12345]</span>. As a result, in the <span class="literal">transfer_money</span> function called in <span class="literal">prepare_transfer</span>, the <span class="literal">from</span> variable would take the third parameter, expecting the <span class="literal">user.account</span> value <span class="literal">12345</span>, but would actually reference the attacker-passed value <span class="literal">ABCDEF</span> <span class="ent">➍</span>.</p>&#13;
<h3 class="h3" id="ch03lev1sec2"><strong>Client-Side HPP</strong></h3>&#13;
<p class="noindent">Client-side HPP vulnerabilities allow attackers to inject extra parameters into a URL to create effects on a user’s end (<em>client side</em> is a common way of referring to actions that happen on your computer, often via the browser, and not on the site’s servers).</p>&#13;
<p class="indent">Luca Carettoni and Stefano di Paola included an example of this behavior in their presentation using the theoretical URL <em>http://host/page.php?par=123%26action=edit</em> and the following server-side code:</p>&#13;
<p class="programs"><span class="ent">➊</span> &lt;? $val=htmlspecialchars($_GET['par'],ENT_QUOTES); ?&gt;<br/>&#13;
<span class="ent">➋</span> &lt;a href="/page.php?action=view&amp;par='.&lt;?=$val?&gt;.'"&gt;View Me!&lt;/a&gt;</p>&#13;
<p class="indent">This code generates a new URL based on the value of <span class="literal">par</span>, a user-entered parameter. In this example, the attacker passes the value <span class="literal">123%26action=edit</span> as the value for <span class="literal">par</span> to generate an additional, unintended parameter. The URL-encoded value for <span class="literal">&amp;</span> is <span class="literal">%26</span>, which means that when the URL is parsed, the <span class="literal">%26</span> is interpreted as <span class="literal">&amp;</span>. This value adds an additional parameter to the generated <span class="literal">href</span> without making the action parameter explicit in the URL. Had the parameter used <span class="literal">123&amp;action=edit</span> instead of <span class="literal">%26</span>, the <span class="literal">&amp;</span> would have been interpreted as separating two different parameters, but because the site is only using the parameter <span class="literal">par</span> in its code, the <span class="literal">action</span> parameter would <span epub:type="pagebreak" id="page_23"/>be dropped. The value <span class="literal">%26</span> works around this by making sure action isn’t initially recognized as a separate parameter, and so <span class="literal">123%26action=edit</span> becomes the value of <span class="literal">par</span>.</p>&#13;
<p class="indent">Next, <span class="literal">par</span> (with the encoded <span class="literal">&amp;</span> as <span class="literal">%26</span>) is passed to the function <span class="literal">htmlspecialchars</span> <span class="ent">➊</span>. The <span class="literal">htmlspecialchars</span> function converts special characters, such as <span class="literal">%26</span>, to their HTML-encoded values, turning <span class="literal">%26</span> into <span class="literal">&amp;amp;</span> (the HTML entity that represents <span class="literal">&amp;</span> in HTML), where that character might have special meaning. The converted value is then stored in <span class="literal">$val</span>. Then a new link is generated by appending <span class="literal">$val</span> to the <span class="literal">href</span> value at <span class="ent">➋</span>. So the generated link becomes <span class="literal">&lt;a href="/page.php?action=view&amp;par=123</span><span class="codestrong">&amp;amp;action=edit</span><span class="literal">"&gt;</span>. Consequently, the attacker has managed to add the additional <span class="literal">action=edit</span> to the <span class="literal">href</span> URL, which could lead to a vulnerability depending on how the application handles the smuggled <span class="literal">action</span> parameter.</p>&#13;
<p class="indent">The following three examples detail both client and server-side HPP vulnerabilities found on HackerOne and Twitter. All of these examples involved URL parameter tampering. However, you should note that no two examples were found using the same method or share the same root cause, reinforcing the importance of thorough testing when looking for HPP vulnerabilities.</p>&#13;
<h3 class="h3" id="ch03lev1sec3"><strong>HackerOne Social Sharing Buttons</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://hackerone.com/blog/introducing-signal-and-impact/">https://hackerone.com/blog/introducing-signal-and-impact/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/105953/">https://hackerone.com/reports/105953/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> December 18, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $500</p>&#13;
<p class="noindent">One way to find HPP vulnerabilities is to look for links that appear to contact other services. HackerOne blog posts do just that by including links to share content on popular social media sites, such as Twitter, Facebook, and so on. When clicked, these HackerOne links generate content for the user to publish on social media. The published content includes a URL reference to the original blog post.</p>&#13;
<p class="indent">One hacker discovered a vulnerability that allowed you to tack on a parameter to the URL of a HackerOne blog post. The added URL parameter would be reflected in the shared social media link so that the generated social media content would link to somewhere other than the intended HackerOne blog URL.</p>&#13;
<p class="indent">The example used in the vulnerability report involved visiting the URL <em>https://hackerone.com/blog/introducing-signal</em> and then adding <em>&amp;u=https://vk.com/durov</em> to the end of it. On the blog page, when HackerOne rendered a link to share on Facebook, the link would become the following:</p>&#13;
<p class="programs">https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing<br/>&#13;
-signal?<span class="codestrong1">&amp;u=https://vk.com/durov</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_24"/>If HackerOne visitors clicked this maliciously updated link while trying to share content, the last <span class="literal">u</span> parameter would be given precedence over the first <span class="literal">u</span> parameter. Subsequently, the Facebook post would use the last <span class="literal">u</span> parameter. Then Facebook users who clicked the link would be directed to <em><a href="https://vk.com/durov">https://vk.com/durov</a></em> instead of HackerOne.</p>&#13;
<p class="indent">In addition, when posting to Twitter, HackerOne includes default tweet text that promotes the post. Attackers could also manipulate this text by including <span class="literal">&amp;text=</span> in the URL, like this:</p>&#13;
<p class="programs">https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/<br/>&#13;
durov<span class="codestrong1">&amp;text=another_site:https://vk.com/durov</span></p>&#13;
<p class="indent">When a user clicked this link, they would get a tweet pop-up containing the text “another_site: <a href="https://vk.com/durov">https://vk.com/durov</a>” instead of text promoting the HackerOne blog.</p>&#13;
<h4 class="h4" id="ch03lev2sec1"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Be on the lookout for vulnerability opportunities when websites accept content, appear to be contacting another web service (such as social media sites), and rely on the current URL to generate the content to be published.</p>&#13;
<p class="indent">In these situations, it’s possible that submitted content is being passed on without undergoing proper security checks, which could lead to parameter pollution vulnerabilities.</p>&#13;
<h3 class="h3" id="ch03lev1sec4"><strong>Twitter Unsubscribe Notifications</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://www.twitter.com/">https://www.twitter.com/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em>https://blog.mert.ninja/twitter-hpp-vulnerability/</em></p>&#13;
<p class="hang"><strong>Date reported:</strong> August 23, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $700</p>&#13;
<p class="noindent">In some cases, successfully finding an HPP vulnerability takes persistence. In August 2015, hacker Mert Tasci noticed an interesting URL (which I’ve shortened here) when unsubscribing from receiving Twitter notifications:</p>&#13;
<p class="programs">https://twitter.com/i/u?iid=F6542&amp;uid=1134885524&amp;nid=22+26&amp;sig=647192e86e28fb6<br/>&#13;
691db2502c5ef6cf3xxx</p>&#13;
<p class="indent">Notice the parameter <span class="literal">UID</span>. This <span class="literal">UID</span> happens to be the user ID of the currently signed-in Twitter account. After noticing the <span class="literal">UID</span>, Tasci did what most hackers would do—he tried changing the <span class="literal">UID</span> to that of another user, but nothing happened. Twitter just returned an error.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_25"/>Determined to continue when others might have given up, Tasci tried adding a second <span class="literal">UID</span> parameter so the URL looked like this (again, a shortened version):</p>&#13;
<p class="programs">https://twitter.com/i/u?iid=F6542&amp;uid=2321301342<span class="codestrong1">&amp;uid=1134885524</span>&amp;nid=22+26&amp;sig=<br/>&#13;
647192e86e28fb6691db2502c5ef6cf3xxx</p>&#13;
<p class="indent">Success! He managed to unsubscribe another user from their email notifications. Twitter was vulnerable to HPP unsubscribing of users. The reason this vulnerability is noteworthy, as explained to me by FileDescriptor, relates to the <span class="literal">SIG</span> parameter. As it turns out, Twitter generates the <span class="literal">SIG</span> value using the <span class="literal">UID</span> value. When a user clicks the unsubscribe URL, Twitter validates that the <span class="literal">URL</span> has not been tampered with by checking the <span class="literal">SIG</span> and <span class="literal">UID</span> values. So, in Tasci’s initial test, changing the <span class="literal">UID</span> to unsubscribe another user failed because the signature no longer matched what Twitter was expecting. However, by adding a second <span class="literal">UID</span>, Tasci succeeded in making Twitter validate the signature with the first <span class="literal">UID</span> parameter but perform the unsubscribe action using the second <span class="literal">UID</span> parameter.</p>&#13;
<h4 class="h4" id="ch03lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Tasci’s efforts demonstrate the importance of persistence and knowledge. If he had walked away from the vulnerability after changing the <span class="literal">UID</span> to another user’s and failing or had he not known about HPP-type vulnerabilities, he wouldn’t have received his $700 bounty.</p>&#13;
<p class="indent">Also, keep an eye out for parameters with auto-incremented integers, like <span class="literal">UID</span>, that are included in HTTP requests: many vulnerabilities involve manipulating parameter values like these to make web applications behave in unexpected ways. I’ll discuss this in more detail in <a href="ch16.xhtml#ch16">Chapter 16</a>.</p>&#13;
<h3 class="h3" id="ch03lev1sec5"><strong>Twitter Web Intents</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://twitter.com/">https://twitter.com/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://ericrafaloff.com/parameter-tampering-attack-on-twitter-web-intents/">https://ericrafaloff.com/parameter-tampering-attack-on-twitter-web-intents/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> November 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> Undisclosed</p>&#13;
<p class="noindent">In some cases, an HPP vulnerability can be indicative of other issues and can lead to finding additional bugs. This is what happened in the Twitter Web Intents feature. The feature provides pop-up flows for working with Twitter users’ tweets, replies, retweets, likes, and follows in the context of non-Twitter sites. Twitter Web Intents make it possible for users to interact with Twitter content without leaving the page or having to authorize a new app just for the interaction. <a href="ch03.xhtml#ch03fig01">Figure 3-1</a> shows an example of what one of these pop-ups looks like.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_26"/><a id="ch03fig01"/><img alt="image" src="../images/03fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 3-1: An early version of the Twitter Web Intents feature, which allows users to interact with Twitter content without leaving the page. In this example, users can like Jack’s tweet.</em></p>&#13;
<p class="indent">Testing this feature, hacker Eric Rafaloff found that all four intent types—following a user, liking a tweet, retweeting, and tweeting—were vulnerable to HPP. Twitter would create each intent via a <span class="literal">GET</span> request with URL parameters like the following:</p>&#13;
<p class="programs">https://twitter.com/intent/<span class="codeitalic1">intentType</span>?<span class="codeitalic1">parameter_name=parameterValue</span></p>&#13;
<p class="indent">This URL would include <span class="codeitalic">intentType</span> and one or more parameter name/value pairs—for example, a Twitter username and Tweet ID. Twitter would use these parameters to create the pop-up intent to display the user to follow or tweet to like. Rafaloff discovered a problem when he created a URL with two <span class="literal">screen_name</span> parameters instead of the expected singular <span class="literal">screen_name</span> for a follow intent:</p>&#13;
<p class="programs">https://twitter.com/intent/follow<span class="codeitalic1">?screen_name=twitter&amp;screen_name=ericrtest3</span></p>&#13;
<p class="indent">Twitter would handle the request by giving precedence to the second <span class="literal">screen_name</span> value, <span class="literal">ericrtest3</span>, instead of the first <span class="literal">twitter</span> value when generating a Follow button. Consequently, a user attempting to follow Twitter’s official account could be tricked into following Rafaloff’s test account. Visiting the URL Rafaloff created would cause Twitter’s backend code to generate the following HTML form using the two <span class="literal">screen_name</span> parameters:</p>&#13;
<p class="programs"><span class="ent">➊</span> &lt;form class="follow" id="follow_btn_form" action="/intent/follow?screen<br/>&#13;
   _name=ericrtest3" method="post"&gt;<br/>&#13;
     &lt;input type="hidden" name="authenticity_token" value="..."&gt;<br/>&#13;
  <span class="ent">➋</span> &lt;input type="hidden" name="screen_name" value="twitter"&gt;<br/>&#13;
  <span class="ent">➌</span> &lt;input type="hidden" name="profile_id" value="783214"&gt;<br/>&#13;
     &lt;button class="button" type="submit"&gt;<br/>&#13;
       &lt;b&gt;&lt;/b&gt;&lt;strong&gt;Follow&lt;/strong&gt;<br/>&#13;
     &lt;/button&gt;<br/>&#13;
   &lt;/form&gt;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_27"/>Twitter would use the information from the first <span class="literal">screen_name</span> parameter, which is associated with the official Twitter account. As a result, a target would see the correct profile of the user they intended to follow because the URL’s first <span class="literal">screen_name</span> parameter is used to populate the code at <span class="ent">➋</span> and <span class="ent">➌</span>. But, after clicking the button, the target would follow <span class="literal">ericrtest3</span>, because the action in the form tag would instead use the second <span class="literal">screen_name</span> parameter’s value <span class="ent">➊</span> passed to the original URL.</p>&#13;
<p class="indent">Similarly, when presenting intents for liking, Rafaloff found he could include a <span class="literal">screen_name</span> parameter despite its having no relevance to liking the tweet. For example, he could create this URL:</p>&#13;
<p class="programs">https://twitter.com/intent/like?tweet_i.d=6616252302978211845<span class="codestrong1">&amp;screen</span><br/>&#13;
<span class="codestrong1">_name=ericrtest3</span></p>&#13;
<p class="indent">A normal like intent would only need the <span class="literal">tweet_id</span> parameter; however, Rafaloff injected the <span class="literal">screen_name</span> parameter to the end of the URL. Liking this tweet would result in a target’s being presented with the correct owner profile to like the tweet. But the Follow button next to the correct tweet and the correct profile of the tweeter would be for the unrelated user <span class="literal">ericrtest3</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">The Twitter Web Intents vulnerability is similar to the previous <span class="literal">UID</span> Twitter vulnerability. Unsurprisingly, when a site is vulnerable to a flaw like HPP, it might be indicative of a broader systemic issue. Sometimes, when you find such a vulnerability, it’s worth taking the time to explore the platform in its entirety to see if there are other areas where you might be able to exploit similar behavior.</p>&#13;
<h3 class="h3" id="ch03lev1sec6"><strong>Summary</strong></h3>&#13;
<p class="noindent">The risk posed by HPP is contingent on the actions a site’s backend performs and where the polluted parameters are being used.</p>&#13;
<p class="indent">Discovering HPP vulnerabilities requires thorough testing, more so than for some other vulnerabilities, because we usually can’t access the code servers run after receiving our HTTP request. This means we can only infer how sites handle the parameters we pass to them.</p>&#13;
<p class="indent">Through trial and error, you might discover situations in which HPP vulnerabilities occur. Usually, social media links are a good first place to test for this vulnerability type, but remember to keep digging and think of HPP when you’re testing for parameter substitutions, such as ID-like values.<span epub:type="pagebreak" id="page_28"/></p>&#13;
</body></html>