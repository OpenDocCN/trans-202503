- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**COMMON UPPER-LAYER PROTOCOLS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见上层协议**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: 'In this chapter, we’ll continue to examine the functions of individual protocols,
    as well as what they look like when viewed with Wireshark. We’ll discuss five
    of the most common upper-layer (layer 7) protocols: DHCP, DNS, HTTP, and SMTP.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨各个协议的功能，以及使用Wireshark查看时它们的表现。我们将讨论五种最常见的上层（第7层）协议：DHCP、DNS、HTTP和SMTP。
- en: '**Dynamic Host Configuration Protocol (DHCP)**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**动态主机配置协议（DHCP）**'
- en: In the early days of networking, when a device wanted to communicate over a
    network, it needed to be assigned an address by hand. As networks grew, this manual
    process quickly became cumbersome. To solve this problem, Bootstrap Protocol (BOOTP)
    was created to automatically assign addresses to network-connected devices. BOOTP
    was later replaced with the more sophisticated Dynamic Host Configuration Protocol
    (DHCP).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络发展的早期，当设备希望通过网络进行通信时，需要手动分配一个地址。随着网络的扩展，这一手动过程迅速变得繁琐。为了解决这个问题，创建了引导协议（BOOTP）来自动为网络连接的设备分配地址。后来，BOOTP被更先进的动态主机配置协议（DHCP）所取代。
- en: DHCP is an application-layer protocol responsible for allowing a device to automatically
    obtain an IP address (and addresses of other important network assets, such as
    DNS servers and routers). Most DHCP servers today also provide other parameters
    to clients, such as the addresses of the default gateway and DNS servers in use
    on the network.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP是一个应用层协议，负责允许设备自动获取IP地址（以及其他重要的网络资源地址，如DNS服务器和路由器）。如今，大多数DHCP服务器还会向客户端提供其他参数，例如默认网关和网络中使用的DNS服务器的地址。
- en: '***DHCP Packet Structure***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DHCP数据包结构***'
- en: 'DHCP packets can carry quite a lot of information to a client. As shown in
    [Figure 9-1](ch09.xhtml#ch09fig1), the following fields are present within a DHCP
    packet:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP数据包可以携带相当多的信息给客户端。如[图9-1](ch09.xhtml#ch09fig1)所示，DHCP数据包中包含以下字段：
- en: '**OpCode**   Indicates whether the packet is a DHCP request or a DHCP reply'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作码**   表示数据包是DHCP请求还是DHCP回复'
- en: '**Hardware Type**   The type of hardware address (10MB Ethernet, IEEE 802,
    ATM, and so on)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件类型**   硬件地址的类型（10MB以太网、IEEE 802、ATM等）'
- en: '**Hardware Length**   The length of the hardware address'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件长度**   硬件地址的长度'
- en: '**Hops**   Used by relay agents to assist in finding a DHCP server'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳数**   由中继代理使用，帮助查找DHCP服务器'
- en: '**Transaction ID**   A random number used to pair requests with responses'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**事务ID**   用于将请求与响应配对的随机数字'
- en: '**Seconds Elapsed**   Seconds since the client first requested an address from
    the DHCP server'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**已用秒数**   客户端从第一次向DHCP服务器请求地址以来的秒数'
- en: '**Flags**   The types of traffic the DHCP client can accept (unicast, broadcast,
    and so on)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**标志**   DHCP客户端可以接受的流量类型（单播、广播等）'
- en: '![image](../images/f164-01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f164-01.jpg)'
- en: '*Figure 9-1: The DHCP packet structure*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：DHCP数据包结构*'
- en: '**Client IP Address**   The client’s IP address (derived from the Your IP Address
    field)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端IP地址**   客户端的IP地址（源自“您的IP地址”字段）'
- en: '**Your IP Address**   The IP address offered by the DHCP server (ultimately
    becomes the Client IP Address field value)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**您的IP地址**   DHCP服务器提供的IP地址（最终成为客户端IP地址字段的值）'
- en: '**Server IP Address**   The DHCP server’s IP address'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器IP地址**   DHCP服务器的IP地址'
- en: '**Gateway IP Address**   The IP address of the network’s default gateway'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**网关IP地址**   网络默认网关的IP地址'
- en: '**Client Hardware Address**   The client’s MAC address'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端硬件地址**   客户端的MAC地址'
- en: '**Server Host Name**   The server’s host name (optional)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器主机名**   服务器的主机名（可选）'
- en: '**Boot File**   A boot file for use by DHCP (optional)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**引导文件**   用于DHCP的引导文件（可选）'
- en: '**Options**   Used to expand the structure of the DHCP packet to give it more
    features'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项**   用于扩展DHCP数据包结构，赋予其更多功能'
- en: '***The DHCP Initialization Process***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DHCP初始化过程***'
- en: '*dhcp_nolease _initialization.pcapng*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*dhcp_nolease _initialization.pcapng*'
- en: 'The primary goal of DHCP is to assign addresses to clients during the initialization
    process. The renewal process takes place between a single client and a DHCP server,
    as shown in the file *dhcp_nolease_initialization.pcapng*. The DHCP initialization
    process is often referred to as the DORA process because it uses four types of
    DHCP packets: discover, offer, request, and acknowledgment, as shown in [Figure
    9-2](ch09.xhtml#ch09fig2). Here, we’ll take a look at each type of DORA packet.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP的主要目标是在初始化过程中为客户端分配地址。续租过程发生在单个客户端和DHCP服务器之间，如文件*dhcp_nolease_initialization.pcapng*所示。DHCP初始化过程通常称为DORA过程，因为它使用四种类型的DHCP数据包：发现、提供、请求和确认，如[图9-2](ch09.xhtml#ch09fig2)所示。在这里，我们将逐一查看每种类型的DORA数据包。
- en: '![image](../images/f165-01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f165-01.jpg)'
- en: '*Figure 9-2: The DHCP DORA process*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：DHCP DORA过程*'
- en: '**The Discover Packet**'
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**发现数据包**'
- en: As you can see in the referenced capture file, the first packet is sent from
    0.0.0.0 on port 68 to 255.255.255.255 on port 67\. The client uses 0.0.0.0 because
    it does not yet have an IP address. The packet is sent to 255.255.255.255 because
    this is the network-independent broadcast address, thus ensuring that this packet
    will be sent out to every device on the network. Because the device doesn’t know
    the address of a DHCP server, this first packet is sent in an attempt to find
    a DHCP server that will listen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在引用的捕获文件中所见，第一个数据包是从0.0.0.0的68端口发送到255.255.255.255的67端口。客户端使用0.0.0.0，因为它还没有IP地址。该数据包发送到255.255.255.255，因为这是一个与网络无关的广播地址，从而确保该数据包将被发送到网络上的每个设备。由于设备不知道DHCP服务器的地址，因此此第一个数据包是为了尝试寻找一个会监听的DHCP服务器。
- en: Examining the Packet Details pane, the first thing we notice is that DHCP relies
    on UDP as its transport layer protocol. DHCP is very concerned with the speed
    at which a client receives the information it’s requesting. DHCP has its own built-in
    reliability measures, which means UDP is a perfect fit. You can see the details
    of the discovery process by examining the first packet’s DHCP portion in the Packet
    Details pane, as shown in [Figure 9-3](ch09.xhtml#ch09fig3).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 查看数据包详细信息窗格时，首先注意到的是DHCP依赖UDP作为其传输层协议。DHCP非常关注客户端接收请求信息的速度。DHCP具有内置的可靠性措施，这意味着UDP非常适合。你可以通过查看数据包详细信息窗格中的第一个数据包的DHCP部分，来查看发现过程的细节，如[图9-3](ch09.xhtml#ch09fig3)所示。
- en: '![image](../images/f166-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f166-01.jpg)'
- en: '*Figure 9-3: The DHCP discover packet*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：DHCP发现数据包*'
- en: '**NOTE**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because Wireshark still references BOOTP when dealing with DHCP, you’ll see
    a Bootstrap Protocol section in the Packet Details pane, rather than a DHCP section.
    Nevertheless, I’ll refer to this as the packet’s* DHCP portion *throughout this
    book.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于Wireshark在处理DHCP时仍参考BOOTP，因此你将在数据包详细信息窗格中看到一个Bootstrap协议部分，而不是DHCP部分。然而，在本书中我会将其称为数据包的*DHCP部分*。*'
- en: This packet is a request, identified by the (1) in the Message type field ➊.
    Most of the fields in this discovery packet are either all zeros (as you can see
    in the IP address fields ➋) or pretty self-explanatory, based on the listing of
    DHCP fields in the previous section. The meat of this packet is in its four Option
    fields ➌.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据包是一个请求，由消息类型字段中的(1)标识 ➊。此发现数据包中的大多数字段要么全为零（如你在IP地址字段 ➋中看到的那样），要么根据上一节中列出的DHCP字段的说明非常容易理解。这个数据包的核心内容在于其四个选项字段
    ➌。
- en: '**DHCP Message Type**   This is option type `53`, with length `1` and a value
    of `Discover (1)`. These values indicate that this is a DHCP discover packet.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**DHCP消息类型**   这是选项类型`53`，长度为`1`，值为`Discover (1)`。这些值表明这是一个DHCP发现数据包。'
- en: '**Client Identifier**   This provides additional information about the client
    requesting an IP address.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端标识符**   提供有关请求IP地址的客户端的额外信息。'
- en: '**Requested IP Address**   This supplies the IP address the client would like
    to receive. This can be a previously used IP address or 0.0.0.0 to indicate no
    preference.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求的IP地址**   提供客户端希望接收的IP地址。这可以是之前使用过的IP地址，或者是0.0.0.0以表示没有偏好。'
- en: '**Parameter Request List**   This lists the different configuration items (IP
    addresses of other important network devices and other non IP items) the client
    would like to receive from the DHCP server.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数请求列表**   列出了客户端希望从DHCP服务器接收的不同配置项（其他重要网络设备的IP地址以及其他非IP项目）。'
- en: '**The Offer Packet**'
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提供数据包**'
- en: The second packet in this file lists valid IP addresses in its IP header, showing
    a packet traveling from 192.168.1.5 to 192.168.1.10, as shown in [Figure 9-4](ch09.xhtml#ch09fig4).
    The client doesn’t actually have the 192.168.1.10 address yet, so the server will
    first attempt to communicate with the client using its hardware address, as provided
    by ARP. If communication isn’t possible, the server will simply broadcast the
    offer to communicate.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本文件中的第二个数据包列出了其 IP 头中的有效 IP 地址，显示一个从 192.168.1.5 到 192.168.1.10 的数据包，如 [图 9-4](ch09.xhtml#ch09fig4)
    所示。客户端实际上还没有 192.168.1.10 地址，因此服务器将首先尝试使用 ARP 提供的硬件地址与客户端进行通信。如果通信不可行，服务器将简单地广播该响应以进行通信。
- en: The DHCP portion of this second packet, called the *offer packet*, indicates
    that the Message type is a reply ➊. This packet contains the same Transaction
    ID as the previous packet ➋, which tells us that this reply is indeed a response
    to our original request.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二个数据包的 DHCP 部分，被称为 *响应数据包*，表明消息类型是回复 ➊。该数据包包含与前一个数据包相同的事务 ID ➋，这告诉我们这个回复确实是对我们原始请求的回应。
- en: The offer packet is sent by the DHCP server in order to offer its services to
    the client. It does so by supplying information about itself and the addressing
    it wants to provide the client. In [Figure 9-4](ch09.xhtml#ch09fig4), the IP address
    192.168.1.10 in the Your (client) IP address field is being offered to the client
    ➌ from 192.168.1.5 identified by the Next server IP address field ➍.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 响应数据包是由 DHCP 服务器发送的，目的是向客户端提供服务。它通过提供关于自身以及它希望提供给客户端的地址信息来完成此操作。在 [图 9-4](ch09.xhtml#ch09fig4)
    中，IP 地址 192.168.1.10 在“您的（客户端）IP 地址”字段中被提供给客户端 ➌，该地址由“下一服务器 IP 地址”字段中的 192.168.1.5
    标识 ➍。
- en: 'The first option listed identifies the packet as a `DHCP Offer` ➎. The options
    that follow are supplied by the server and indicate the additional information
    it can offer, along with the client’s IP address. You can see that it offers the
    following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个列出的选项将数据包标识为 `DHCP 响应` ➎。后续的选项由服务器提供，并指示它可以提供的附加信息，以及客户端的 IP 地址。你可以看到它提供了以下内容：
- en: •     An IP address lease time of 10 minutes
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: •     IP 地址租用时间为 10 分钟
- en: •     A subnet mask of 255.255.255.0
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: •     子网掩码为 255.255.255.0
- en: •     A broadcast address of 192.168.1.255
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: •     广播地址为 192.168.1.255
- en: •     A router address of 192.168.1.254
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: •     路由器地址为 192.168.1.254
- en: •     A domain name of *mydomain.example*
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: •     一个域名 *mydomain.example*
- en: •     Domain name server addresses of 192.168.1.1 and 192.168.1.2
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: •     域名服务器地址为 192.168.1.1 和 192.168.1.2
- en: '![image](../images/f168-01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f168-01.jpg)'
- en: '*Figure 9-4: The DHCP offer packet*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：DHCP 响应数据包*'
- en: '**The Request Packet**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**请求数据包**'
- en: Once the client receives an offer from the DHCP server, it should accept it
    with a DHCP request packet, as shown in [Figure 9-5](ch09.xhtml#ch09fig5).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端收到来自 DHCP 服务器的响应，它应该通过一个 DHCP 请求数据包接受该响应，如 [图 9-5](ch09.xhtml#ch09fig5)
    所示。
- en: The third packet in this capture still comes from IP address 0.0.0.0, because
    we have not yet completed the process of obtaining an IP address ➊. The packet
    now knows the DHCP server it is communicating with.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个捕获中的第三个数据包仍然来自 IP 地址 0.0.0.0，因为我们还没有完成获取 IP 地址的过程 ➊。此数据包现在已经知道它正在与哪个 DHCP
    服务器通信。
- en: '![image](../images/f169-01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f169-01.jpg)'
- en: '*Figure 9-5: The DHCP request packet*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：DHCP 请求数据包*'
- en: The Message type field shows that this packet is a request ➋, and the Transaction
    ID field is the same as in the first two packets ➌, indicating they are part of
    the same process. This packet is similar to the discover packet, in that all of
    its IP-addressing information is zeroed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 消息类型字段显示该数据包是一个请求 ➋，而事务 ID 字段与前两个数据包相同 ➌，这表明它们属于同一过程。此数据包类似于发现数据包，因为其所有 IP 地址信息都被置为零。
- en: Finally, in the Option fields, we see that this is a `DHCP Request` ➍. Notice
    that the requested IP address is no longer blank and that the DHCP Server Identifier
    field also contains an address ➎.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在选项字段中，我们看到这是一条 `DHCP 请求` ➍。请注意，请求的 IP 地址不再为空，且 DHCP 服务器标识符字段也包含了一个地址 ➎。
- en: '**The Acknowledgment Packet**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**确认数据包**'
- en: In the final step in this process, the DHCP server sends the requested IP addresses
    to the client in an acknowledgment packet and records that information in its
    database, as shown in [Figure 9-6](ch09.xhtml#ch09fig6). The client now has an
    IP address and can use it to begin communicating on the network.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程的最后一步，DHCP 服务器通过确认数据包将请求的 IP 地址发送给客户端，并将该信息记录在其数据库中，如 [图 9-6](ch09.xhtml#ch09fig6)
    所示。客户端现在已经有了一个 IP 地址，并可以开始在网络上进行通信。
- en: '![image](../images/f170-01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f170-01.jpg)'
- en: '*Figure 9-6: The DCHP acknowledgment packet*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-6：DCHP确认包*'
- en: '***DHCP In-Lease Renewal***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DHCP租用续期***'
- en: '*dhcp_inlease _renewal.pcapng*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*dhcp_inlease_renewal.pcapng*'
- en: When a DHCP server assigns an IP address to a device, it *leases* it to the
    client. This means that the client is allowed to use the IP address for only a
    limited amount of time before it must renew the lease. The DORA process just discussed
    occurs the first time a client gets an IP address or when its lease time has expired.
    In either case, the device is considered to be *out of lease*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当DHCP服务器为设备分配IP地址时，它会将该地址*租用*给客户端。这意味着客户端只能在有限的时间内使用该IP地址，之后必须续租。前面讨论的DORA过程发生在客户端第一次获取IP地址或其租期已到期时。在这两种情况下，设备都被视为*租期结束*。
- en: When a client with an IP address in-lease reboots, it must perform a truncated
    version of the DORA process in order to reclaim its IP address. This process is
    called an *in-lease renewal*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个带有租用IP地址的客户端重启时，它必须执行简化版的DORA过程以重新获得其IP地址。这个过程叫做*租用续期*。
- en: In the case of a lease renewal, the discovery and offer packets are unnecessary.
    Think of an in-lease renewal as being the same DORA process used in an out-of-lease
    renewal, but the in-lease renewal doesn’t need to do as much, leaving only the
    request and acknowledgment steps. You’ll find a sample capture of an in-lease
    renewal in the file *dhcp_inlease_renewal.pcapng*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在租期续期的情况下，发现和提供数据包是不必要的。可以把租期续期看作是与租期结束续期相同的DORA过程，但租期续期不需要做太多的工作，仅剩下请求和确认步骤。你可以在文件*dhcp_inlease_renewal.pcapng*中找到租期续期的示例抓包。
- en: '***DHCP Options and Message Types***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DHCP选项和消息类型***'
- en: DHCP’s real flexibility lies in its available options. As you’ve seen, the packet’s
    DHCP options can vary in size and content. The packet’s overall size depends on
    the combination of options used. You can view a full list of the many DHCP options
    at *[http://www.iana.org/assignments/bootp-dhcp-parameters/](http://www.iana.org/assignments/bootp-dhcp-parameters/)*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP的真正灵活性体现在其可用选项上。正如你所看到的，数据包的DHCP选项可以在大小和内容上有所不同。数据包的总体大小取决于所使用的选项组合。你可以在*
    [http://www.iana.org/assignments/bootp-dhcp-parameters/](http://www.iana.org/assignments/bootp-dhcp-parameters/)*查看所有DHCP选项的完整列表。
- en: The only option required in all DHCP packets is the Message type option (option
    53). This option identifies how the DHCP client or server will process the information
    contained within the packet. There are 8 message types, as defined in [Table 9-1](ch09.xhtml#ch09tab1).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有DHCP数据包中唯一必需的选项是消息类型选项（选项53）。此选项用于标识DHCP客户端或服务器如何处理数据包中的信息。消息类型共有8种，如[表9-1](ch09.xhtml#ch09tab1)所定义。
- en: '**Table 9-1:** DHCP Message Types'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-1：DHCP消息类型**'
- en: '| **Type number** | **Message type** | **Description** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **类型编号** | **消息类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Discover | Used by the client to locate available DHCP servers |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Discover | 客户端用来定位可用的DHCP服务器 |'
- en: '| 2 | Offer | Sent by the server to the client in response to a discover packet
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Offer | 服务器响应发现数据包时发送给客户端 |'
- en: '| 3 | Request | Sent by the client to request the offered parameters from the
    server |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Request | 客户端发送给服务器，请求提供的参数 |'
- en: '| 4 | Decline | Sent by the client to the server to indicate invalid parameters
    within a packet |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Decline | 客户端发送给服务器，指示数据包内的参数无效 |'
- en: '| 5 | ACK | Sent by the server to the client with the configuration parameters
    requested |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 5 | ACK | 由服务器发送给客户端，包含客户端请求的配置信息 |'
- en: '| 6 | NAK | Sent by the client to the server to refuse a request for configuration
    parameters |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 6 | NAK | 客户端发送给服务器，用于拒绝配置参数请求 |'
- en: '| 7 | Release | Sent by the client to the server to cancel a lease by releasing
    its configuration parameters |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 7 | Release | 客户端发送给服务器，取消租约并释放其配置参数 |'
- en: '| 8 | Inform | Sent by the client to the server to ask for configuration parameters
    when the client already has an IP address |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 8 | Inform | 客户端发送给服务器，请求配置参数，当客户端已拥有IP地址时 |'
- en: '***DHCP Version 6 (DHCPv6)***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DHCP版本6（DHCPv6）***'
- en: '*dhcp6_outlease_acquisition.pcapng*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*dhcp6_outlease_acquisition.pcapng*'
- en: If you examine the packet structure for a DHCP packet in [Figure 9-1](ch09.xhtml#ch09fig1),
    you’ll see that it doesn’t provide enough room to support the length required
    for IPv6 address allocation. Instead of retrofitting DHCP for this purpose, DHCPv6
    was devised in RFC3315\. Since DHCPv6 isn’t built on the concept of BOOTP, its
    packet format is much simpler ([Figure 9-7](ch09.xhtml#ch09fig7)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看[图 9-1](ch09.xhtml#ch09fig1)中 DHCP 数据包的结构，你会发现它没有足够的空间来支持 IPv6 地址分配所需的长度。为了不将
    DHCP 修改用于此目的，RFC3315 中设计了 DHCPv6。由于 DHCPv6 并不是基于 BOOTP 的概念，它的数据包格式要简单得多（见[图 9-7](ch09.xhtml#ch09fig7)）。
- en: '![image](../images/f171-01.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f171-01.jpg)'
- en: '*Figure 9-7: The DHCPv6 packet structure*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：DHCPv6 数据包结构*'
- en: 'The packet structure shown here contains only two static values, which function
    in the same manner as their DHCP counterparts. The rest of the packet structure
    varies depending on the message type identified in the first byte. Within the
    Options section, each option is identified with a 2-byte option code and a 2-byte
    length field. A full list of message types and option codes that can appear in
    these fields can be found here: *[http://www.iana.org/assignments/dhcpv6-parameters/dhcpv6-parameters.xhtml](http://www.iana.org/assignments/dhcpv6-parameters/dhcpv6-parameters.xhtml)*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的数据包结构仅包含两个静态值，它们的作用与 DHCP 中的对应值相同。数据包结构的其余部分根据第一个字节中标识的消息类型而变化。在选项部分，每个选项都通过
    2 字节的选项代码和 2 字节的长度字段进行标识。有关这些字段中可能出现的消息类型和选项代码的完整列表，请访问： *[http://www.iana.org/assignments/dhcpv6-parameters/dhcpv6-parameters.xhtml](http://www.iana.org/assignments/dhcpv6-parameters/dhcpv6-parameters.xhtml)*。
- en: DHCPv6 accomplishes the same goal as DHCP, but to understand the flow of DHCPv6
    communication, we must replace our DORA acronym with a new one, SARR. This process
    is illustrated in [Figure 9-8](ch09.xhtml#ch09fig8), which represents a client
    that is currently out of lease.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: DHCPv6 达成的目标与 DHCP 相同，但要理解 DHCPv6 通信的流程，我们必须用一个新的缩写词 SARR 来替换原有的 DORA。这个过程在[图
    9-8](ch09.xhtml#ch09fig8)中有所示，图中代表了一个当前超出租期的客户端。
- en: '![image](../images/f172-01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f172-01.jpg)'
- en: '*Figure 9-8: The DHCPv6 SARR out-of-lease renewal process*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：DHCPv6 SARR 超出租期续租过程*'
- en: 'The SARR process has four steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: SARR 过程有四个步骤：
- en: '**Solicit**: An initial packet is sent from a client to a special multicast
    address (ff02::1:2) to attempt to locate available DHCPv6 servers on the network.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请求**：客户端从客户端向特殊的多播地址（ff02::1:2）发送初始数据包，尝试在网络上定位可用的 DHCPv6 服务器。'
- en: '**Advertise**: An available server responds directly to the client to indicate
    that it is available to provide addressing and configuration information.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**广告**：可用的服务器直接响应客户端，表明它可以提供地址分配和配置信息。'
- en: '**Request**: The client sends a formal request for configuration information
    to the server via multicast.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请求**：客户端通过多播向服务器发送正式的配置信息请求。'
- en: '**Reply**: The server sends all available requested configuration information
    directly to the client, and the process is complete.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回复**：服务器将所有可用的请求配置信息直接发送给客户端，过程完成。'
- en: A summary of this process is shown in [Figure 9-9](ch09.xhtml#ch09fig9), which
    is taken from the file *dhcp6_outlease_acquisition.pcapng*. In this example, we
    see the SARR process in action as a new host on the network (fe80::20c:29ff:fe5e:7744)
    receives configuration information from a DHCPv6 server (fe80::20c:29ff :fe1f:a755).
    Each packet represents one step of the SARR process, with the initial solicit
    and advertise packets tied together using the transaction ID 0x9de03f and the
    request and reply packets associated with the transaction ID 0x2d1603\. While
    it isn’t shown in the figure, this communication takes place over ports 546 and
    547, which are the standard ports used by DHCPv6.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的总结显示在[图 9-9](ch09.xhtml#ch09fig9)中，取自文件 *dhcp6_outlease_acquisition.pcapng*。在这个示例中，我们可以看到
    SARR 过程的实际操作，新的主机（fe80::20c:29ff:fe5e:7744）从 DHCPv6 服务器（fe80::20c:29ff:fe1f:a755）接收到配置信息。每个数据包代表
    SARR 过程的一个步骤，初始的请求和广告数据包通过事务 ID 0x9de03f 连接在一起，请求和回复数据包通过事务 ID 0x2d1603 关联。尽管图中没有显示，但这种通信是通过端口
    546 和 547 进行的，这是 DHCPv6 使用的标准端口。
- en: '![image](../images/f172-02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f172-02.jpg)'
- en: '*Figure 9-9: A client obtaining an IPv6 address via DHCPv6*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：客户端通过 DHCPv6 获取 IPv6 地址*'
- en: Overall, the packet structure of DHCPv6 traffic looks a lot different, but most
    of the same concepts apply. The process still requires some form of DHCP server
    discovery and a formal retrieval of configuration information. Those transactions
    are all tied together via transaction identifiers in each pair of packets exchanged
    between the client and server. IPv6 addressing can’t be supported by traditional
    DHCP mechanisms, so if you have devices getting IPv6 addresses automatically from
    a server on your network, it’s likely that you’re already running DHCPv6 services
    on your network. If you’d like to compare DHCP and DHCPv6 further, I recommend
    opening the packet captures discussed in this chapter side by side and stepping
    through them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，DHCPv6流量的包结构看起来与我们之前讨论的包类型有很大不同，但大多数相同的概念依然适用。该过程仍然需要某种形式的DHCP服务器发现，并正式检索配置信息。这些事务通过客户端和服务器之间交换的每对数据包中的事务标识符关联在一起。传统的DHCP机制无法支持IPv6地址分配，因此，如果你的设备从网络中的服务器自动获取IPv6地址，可能已经在网络上运行DHCPv6服务。如果你想进一步比较DHCP和DHCPv6，我建议你并排查看本章讨论的数据包捕获，并逐步分析它们。
- en: '**Domain Name System (DNS)**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**域名系统（DNS）**'
- en: The Domain Name System (DNS) is one of the most crucial internet protocols because
    it is the proverbial molasses that holds the bread together. DNS ties domain names,
    such as *[www.google.com](http://www.google.com)*, to IP addresses, such as 74.125.159.99\.
    When we want to communicate with a networked device and we don’t know its IP address,
    we access that device via its DNS name.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统（DNS）是互联网上最重要的协议之一，因为它就像粘合剂一样，将网络中的各个部分联系在一起。DNS将域名（例如 *[www.google.com](http://www.google.com)*）与IP地址（例如74.125.159.99）关联。当我们想与网络设备通信，而又不知道其IP地址时，我们通过其DNS名称访问该设备。
- en: DNS servers store a database of *resource records* of IP address–to–DNS name
    mappings, which they share with clients and other DNS servers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: DNS服务器存储IP地址与DNS名称映射的*资源记录*数据库，并与客户端和其他DNS服务器共享这些记录。
- en: '**NOTE**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because the architecture of DNS servers is complicated, we’ll just look at
    some common types of DNS traffic. You can review the various DNS-related RFCs
    at* [https://www.isc.org/community/rfcs/dns/](https://www.isc.org/community/rfcs/dns/).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于DNS服务器的架构较为复杂，我们只关注一些常见的DNS流量类型。你可以在* [https://www.isc.org/community/rfcs/dns/](https://www.isc.org/community/rfcs/dns/)
    *查看各种与DNS相关的RFC文档。*'
- en: '***DNS Packet Structure***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DNS数据包结构***'
- en: 'As you can see in [Figure 9-10](ch09.xhtml#ch09fig10), the DNS packet structure
    is somewhat different from that of the packet types we’ve discussed previously.
    The following fields can be present within a DNS packet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图9-10](ch09.xhtml#ch09fig10)中看到的，DNS数据包的结构与我们之前讨论的数据包类型略有不同。DNS数据包中可以包含以下字段：
- en: '**DNS ID Number**   Used to associate DNS queries with DNS responses'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**DNS ID号** 用于将DNS查询与DNS响应关联'
- en: '**Query/Response (QR)**   Denotes whether the packet is a DNS query or response'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询/响应（QR）** 表示数据包是DNS查询还是响应'
- en: '**OpCode**   Defines the type of query contained in the message'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作码（OpCode）** 定义消息中查询的类型'
- en: '**Authoritative Answers (AA)**   If this value is set in a response packet,
    indicates that the response is from a name server with authority over the domain'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**权威回答（AA）** 如果此值在响应数据包中设置，表示该响应来自具有该域名权威的名称服务器'
- en: '**Truncation (TC)**   Indicates that the response was truncated because it
    was too large to fit within the packet'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**截断（TC）** 表示响应被截断，因为它太大，无法放入数据包中'
- en: '**Recursion Desired (RD)**   When this value is set in a query, indicates that
    the DNS client requests a recursive query if the target name server doesn’t contain
    the information requested'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归请求（RD）** 当此值在查询中设置时，表示如果目标名称服务器没有包含所请求的信息，DNS客户端请求递归查询'
- en: '**Recursion Available (RA)**   If this value is set in a response, indicates
    that the name server supports recursive queries'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归可用（RA）** 如果此值在响应中设置，表示名称服务器支持递归查询'
- en: '![image](../images/f174-01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f174-01.jpg)'
- en: '*Figure 9-10: The DNS packet structure*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-10：DNS数据包结构*'
- en: '**Reserved (Z)**   Defined by RFC 1035 to be set as all zeros; however, sometimes
    it’s used as an extension of the RCode field'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**保留（Z）** 根据RFC 1035定义，应该设置为全零；然而，有时它被用作RCode字段的扩展'
- en: '**Response Code (RCode)**   Used in DNS responses to indicate the presence
    of any errors'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应码（RCode）** 用于DNS响应中，表示是否存在错误'
- en: '**Question Count**   The number of entries in the Questions Section'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题计数** 问题部分中的条目数'
- en: '**Answer Count**   The number of entries in the Answers Section'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**回答数量**   回答部分中的条目数量'
- en: '**Name Server (Authority) Record Count**   The number of name server resource
    records in the Authority Section'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称服务器（授权）记录数量**   授权部分中名称服务器资源记录的数量'
- en: '**Additional Records Count**   The number of other resource records in the
    Additional Information Section'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加记录数量**   附加信息部分中其他资源记录的数量'
- en: '**Questions Section**   Variable-sized section that contains one or more queries
    for information to be sent to the DNS server'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题部分**   可变大小的部分，包含一个或多个查询，用于向 DNS 服务器发送信息'
- en: '**Answers Section**   Variable-sized section that carries one or more resource
    records that answer queries'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**回答部分**   可变大小的部分，包含一个或多个资源记录，用于回答查询'
- en: '**Authority Section**   Variable-sized section that contains resource records
    that point to authoritative name servers that can be used to continue the resolution
    process'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**授权部分**   可变大小的部分，包含指向授权名称服务器的资源记录，这些服务器可以用于继续解析过程'
- en: '**Additional Information Section**   Variable-sized section that contains resource
    records that hold additional information related to the query that is not absolutely
    necessary to answer the query'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加信息部分**   可变大小的部分，包含与查询相关的附加资源记录，这些记录对于回答查询并非绝对必要'
- en: '***A Simple DNS Query***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个简单的 DNS 查询***'
- en: '*dns_query_response.pcapng*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*dns_query_response.pcapng*'
- en: DNS functions in a query-response format. A client wishing to resolve a DNS
    name to an IP address sends a *query* to a DNS server, and the server sends the
    requested information in its *response*. In its simplest form, this process takes
    two packets, as can be seen in the capture file *dns_query_response.pcapng*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 以查询-响应格式工作。希望将 DNS 名称解析为 IP 地址的客户端向 DNS 服务器发送一个 *查询*，然后服务器在其 *响应* 中返回请求的信息。在最简单的形式下，这个过程需要两个数据包，正如在捕获文件
    *dns_query_response.pcapng* 中看到的那样。
- en: The first packet, shown in [Figure 9-11](ch09.xhtml#ch09fig11), is a DNS query
    sent from the client 192.168.0.114 to the server 205.152.37.23 on port 53, which
    is the standard port used by DNS.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据包，如 [图 9-11](ch09.xhtml#ch09fig11) 所示，是客户端 192.168.0.114 向服务器 205.152.37.23
    发送的 DNS 查询，目标端口为 53，这是 DNS 使用的标准端口。
- en: '![image](../images/f175-01.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f175-01.jpg)'
- en: '*Figure 9-11: The DNS query packet*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-11：DNS 查询数据包*'
- en: When you begin examining the headers in this packet, you’ll see that DNS also
    relies on UDP ➊.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始检查这个数据包中的头部时，你会发现 DNS 也依赖于 UDP ➊。
- en: In the DNS portion of the packet, you can see that smaller fields near the beginning
    of the packet are condensed by Wireshark into a single Flags section. Expand this
    section, and you’ll see that the message is indeed a standard query ➋, that it
    is not truncated, and that recursion is desired (we’ll cover recursion shortly).
    Only a single question is identified, which can be found by expanding the Queries
    section. There, you can see the query is for the name *[wireshark.org](http://wireshark.org)*
    for a host (type `A`) internet (`IN`) address ➌. This packet is basically asking,
    “Which IP address is associated with the *[wireshark.org](http://wireshark.org)*
    domain?”
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包的 DNS 部分，你可以看到数据包开头的较小字段被 Wireshark 压缩成了一个单独的标志部分。展开此部分，你会看到该消息确实是一个标准查询
    ➋，它没有被截断，并且需要递归（稍后我们会讲解递归）。这里只识别了一个问题，可以通过展开查询部分来查看。你会看到该查询是针对 *[wireshark.org](http://wireshark.org)*
    域名的一个主机（类型 `A`）互联网（`IN`）地址 ➌。这个数据包基本上是在问：“哪个 IP 地址与 *[wireshark.org](http://wireshark.org)*
    域名关联？”
- en: The response to this request is in packet 2, as shown in [Figure 9-12](ch09.xhtml#ch09fig12).
    Because this packet has an identical identification number ➊, we know that it
    contains the correct response to the original query.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对该请求的响应在数据包 2 中，如 [图 9-12](ch09.xhtml#ch09fig12) 所示。因为这个数据包有相同的标识号 ➊，我们知道它包含对原始查询的正确响应。
- en: 'The Flags section confirms that this is a response and that recursion is available
    if necessary ➋. This packet contains only one question and one resource record
    ➌, because it includes the original question in conjunction with its answer. Expanding
    the Answers section gives us the response to the query: the IP address of *[wireshark.org](http://wireshark.org)*
    is 128.121.50.122 ➍. With this information, the client can now construct IP packets
    and begin communicating with *[wireshark.org](http://wireshark.org)*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Flags 部分确认这是一个响应，如果需要，可以使用递归 ➋。此数据包仅包含一个问题和一个资源记录 ➌，因为它包括原始问题及其答案。展开 Answers
    部分，我们可以看到查询的响应：*wireshark.org* 的 IP 地址是 128.121.50.122 ➍。通过此信息，客户端现在可以构建 IP 数据包并开始与
    *wireshark.org* 通信。
- en: '![image](../images/f176-01.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f176-01.jpg)'
- en: '*Figure 9-12: The DNS response packet*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-12：DNS 响应数据包*'
- en: '***DNS Question Types***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DNS 查询类型***'
- en: The Type fields used in DNS queries and responses indicate the resource record
    type that the query or response is for. Some of the more common message/resource
    record types are listed in [Table 9-2](ch09.xhtml#ch09tab2). You’ll be seeing
    these types throughout normal traffic and in this book. (The list in [Table 9-2](ch09.xhtml#ch09tab2)
    is brief and by no means exhaustive. To review all DNS resource record types,
    visit *[http://www.iana.org/assignments/dns-parameters/](http://www.iana.org/assignments/dns-parameters/)*.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DNS 查询和响应中使用的 Type 字段表示查询或响应的资源记录类型。一些常见的消息/资源记录类型列在 [表 9-2](ch09.xhtml#ch09tab2)
    中。在正常流量和本书中，您将看到这些类型。（[表 9-2](ch09.xhtml#ch09tab2) 中的列表很简短，并且并非详尽无遗。如需查看所有 DNS
    资源记录类型，请访问 *[http://www.iana.org/assignments/dns-parameters/](http://www.iana.org/assignments/dns-parameters/)*。）
- en: '**Table 9-2:** Common DNS Resource Record Types'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-2：** 常见的 DNS 资源记录类型'
- en: '| **Value** | **Type** | **Description** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | A | IPv4 host address |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 1 | A | IPv4 主机地址 |'
- en: '| 2 | NS | Authoritative name server |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 2 | NS | 权威名称服务器 |'
- en: '| 5 | CNAME | Canonical name for an alias |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 5 | CNAME | 别名的规范名称 |'
- en: '| 15 | MX | Mail exchange |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 15 | MX | 邮件交换 |'
- en: '| 16 | TXT | Text string |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 16 | TXT | 文本字符串 |'
- en: '| 28 | AAAA | IPv6 host address |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 28 | AAAA | IPv6 主机地址 |'
- en: '| 251 | IXFR | Incremental zone transfer |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 251 | IXFR | 增量区域传输 |'
- en: '| 252 | AXFR | Full zone transfer |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 252 | AXFR | 完整区域传输 |'
- en: '***DNS Recursion***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DNS 递归***'
- en: '*dns_recursivequery_client.pcapng, dns_recursivequery_server.pcapng*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*dns_recursivequery_client.pcapng, dns_recursivequery_server.pcapng*'
- en: Due to the hierarchical nature of the internet’s DNS structure, DNS servers
    must be able to communicate with each other in order to answer the queries submitted
    by clients. While we expect our internal DNS server to know the name-to-IP address
    mapping of our local intranet server, we can’t expect it to know the IP address
    associated with Google or Dell.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于互联网 DNS 结构的层次性，DNS 服务器必须能够相互通信，以回答客户端提交的查询。虽然我们期望内部 DNS 服务器知道我们本地内部网络服务器的名称到
    IP 地址的映射，但我们不能指望它知道 Google 或 Dell 的关联 IP 地址。
- en: When a DNS server needs to find an IP address, it queries another DNS server
    on behalf of the client making the request, in effect acting like a client. This
    process is called *recursion*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当 DNS 服务器需要查找 IP 地址时，它会代表客户端向另一台 DNS 服务器发起查询，实际上充当客户端的角色。这个过程称为 *递归*。
- en: To view the recursion process from both the DNS client and server perspectives,
    open the file *dns_recursivequery_client.pcapng*. This file contains a capture
    of a client’s DNS traffic file in two packets. The first packet is the initial
    query sent from the DNS client 172.16.0.8 to its DNS server 172.16.0.102, as shown
    in [Figure 9-13](ch09.xhtml#ch09fig13).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 DNS 客户端和服务器的角度查看递归过程，请打开文件 *dns_recursivequery_client.pcapng*。此文件包含一个客户端的
    DNS 流量捕获文件，包含两个数据包。第一个数据包是从 DNS 客户端 172.16.0.8 发往其 DNS 服务器 172.16.0.102 的初始查询，如
    [图 9-13](ch09.xhtml#ch09fig13) 所示。
- en: '![image](../images/f177-01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f177-01.jpg)'
- en: '*Figure 9-13: The DNS query with the Recursion desired bit set*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-13：设置了递归请求标志的 DNS 查询*'
- en: When you expand the DNS portion of this packet, you’ll see that this is a standard
    query for an `A` type record for the DNS name *[www.nostarch.com](http://www.nostarch.com)*
    ➋. To learn more about this packet, expand the Flags section, and you’ll see that
    recursion is desired ➊.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您展开此数据包的 DNS 部分时，您将看到这是一个标准查询，请求 DNS 名称 *[www.nostarch.com](http://www.nostarch.com)*
    的 `A` 类型记录 ➋。要了解更多关于此数据包的信息，请展开 Flags 部分，您将看到需要递归 ➊。
- en: The second packet is what we would expect to see in response to the initial
    query, as shown in [Figure 9-14](ch09.xhtml#ch09fig14).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数据包是我们期望看到的对初始查询的响应，如[图 9-14](ch09.xhtml#ch09fig14)所示。
- en: '![image](../images/f178-01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f178-01.jpg)'
- en: '*Figure 9-14: The DNS query response*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-14：DNS 查询响应*'
- en: This packet’s transaction ID matches that of our query ➊, no errors are listed,
    and we receive the `A` type resource record associated with *[www.nostarch.com](http://www.nostarch.com)*
    ➋.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包的事务 ID 与我们的查询 ➊ 匹配，没有列出任何错误，我们收到了与 *[www.nostarch.com](http://www.nostarch.com)*
    相关联的 `A` 类型资源记录 ➋。
- en: We can see that this query was answered by recursion by listening to the DNS
    server’s traffic when the recursion is taking place, as demonstrated in the file
    *dns_recursivequery_server.pcapng*. This file shows a capture of the traffic on
    the local DNS server when the query was initiated ([Figure 9-15](ch09.xhtml#ch09fig15)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过监听 DNS 服务器的流量来看到此查询是通过递归方式得到回答的，正如文件 *dns_recursivequery_server.pcapng*
    所示。该文件展示了当查询发起时本地 DNS 服务器的流量捕获（[图 9-15](ch09.xhtml#ch09fig15)）。
- en: '![image](../images/f179-01.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f179-01.jpg)'
- en: '*Figure 9-15: DNS recursion from the server’s perspective*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-15：从服务器的角度看 DNS 递归*'
- en: The first packet is the same initial query we saw in the previous capture file.
    At this point, the DNS server has received the query, checked its local database,
    and realized it doesn’t know the answer to the question of which IP address goes
    with the DNS name (*[www.nostarch.com](http://www.nostarch.com)*). Because the
    packet was sent with the Recursion desired bit set, the DNS server can ask another
    DNS server this question in an attempt to locate the answer, as you can see in
    the second packet.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据包是我们在前一个捕获文件中看到的相同初始查询。此时，DNS 服务器已经收到查询，检查了其本地数据库，并意识到它不知道哪个 IP 地址与 DNS
    名称 (*[www.nostarch.com](http://www.nostarch.com)*) 对应。由于数据包是带着“需要递归”标志发送的，DNS
    服务器可以向另一个 DNS 服务器提出这个问题，试图找到答案，正如你在第二个数据包中看到的那样。
- en: In the second packet, the DNS server at 172.16.0.102 transmits a new query to
    4.2.2.1 ➊, which is the server to which it is configured to forward upstream requests,
    as shown in [Figure 9-16](ch09.xhtml#ch09fig16). This query mirrors the original
    one, effectively turning the DNS server into a client. We can tell that this is
    a new query because the transaction ID number differs from the transaction ID
    number in the previous capture file ➋.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个数据包中，位于 172.16.0.102 的 DNS 服务器向 4.2.2.1 发送了一个新的查询 ➊，这是它配置转发上游请求的服务器，如[图
    9-16](ch09.xhtml#ch09fig16)所示。这个查询与原始查询相同，实际上将 DNS 服务器变成了一个客户端。我们可以通过事务 ID 号与前一个捕获文件中的事务
    ID 号不同来判断这是一个新的查询 ➋。
- en: '![image](../images/f179-02.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f179-02.jpg)'
- en: '*Figure 9-16: The recursive DNS query*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-16：递归 DNS 查询*'
- en: Once this packet is received by server 4.2.2.1, the local DNS server receives
    the response shown in [Figure 9-17](ch09.xhtml#ch09fig17).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器 4.2.2.1 收到这个数据包，局部 DNS 服务器就会收到如[图 9-17](ch09.xhtml#ch09fig17)所示的响应。
- en: '![image](../images/f180-01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f180-01.jpg)'
- en: '*Figure 9-17: Response to the recursive DNS query*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-17：递归 DNS 查询的响应*'
- en: Having received this response, the local DNS server can transmit the fourth
    and final packet to the DNS client with the information requested.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 收到这个响应后，局部 DNS 服务器可以将第四个也是最后一个数据包传送给 DNS 客户端，包含所请求的信息。
- en: Although this example shows only one layer of recursion, recursion can occur
    many times for a single DNS request. Here, we received an answer from the DNS
    server at 4.2.2.1, but that server could have retransmitted the query recursively
    to another server in order to find the answer. A simple query can travel all over
    the world before it finally gets a correct response. [Figure 9-18](ch09.xhtml#ch09fig18)
    illustrates the recursive DNS query process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子只展示了单层递归，但对于单个 DNS 请求，递归可能会发生多次。在这里，我们从 DNS 服务器 4.2.2.1 收到了回答，但该服务器可能已经将查询递归地转发到另一个服务器以找到答案。一个简单的查询可能会在全球范围内传输，直到最终收到正确的响应。[图
    9-18](ch09.xhtml#ch09fig18)展示了递归 DNS 查询的过程。
- en: '![image](../images/f180-02.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f180-02.jpg)'
- en: '*Figure 9-18: A recursive DNS query*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-18：递归 DNS 查询*'
- en: '***DNS Zone Transfers***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DNS 区域传输***'
- en: '*dns_axfr.pcapng*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*dns_axfr.pcapng*'
- en: A *DNS zone* is the namespace (or group of DNS names) that a DNS server has
    been delegated to manage. For instance, Emma’s Diner might have one DNS server
    responsible for *[emmasdiner.com](http://emmasdiner.com)*. In that case, devices
    both inside and outside Emma’s Diner wishing to resolve *[emmasdiner.com](http://emmasdiner.com)*
    to an IP address would need to contact that DNS server as the authority for that
    zone. If Emma’s Diner were to grow, it could add a second DNS server to handle
    the email portion of its DNS namespace only, say *[mail.emmasdiner.com](http://mail.emmasdiner.com)*,
    and that server would be the authority for that mail subdomain. Additional DNS
    servers might be added for subdomains as necessary, as shown in [Figure 9-19](ch09.xhtml#ch09fig19).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*DNS区域*是DNS服务器被委托管理的命名空间（或DNS名称组）。例如，Emma’s Diner可能有一个DNS服务器负责* [emmasdiner.com](http://emmasdiner.com)
    *。在这种情况下，想要将* [emmasdiner.com](http://emmasdiner.com) *解析为IP地址的设备，无论是在Emma’s Diner内部还是外部，都需要联系该DNS服务器作为该区域的权威。如果Emma’s
    Diner扩展业务，它可以增加第二个DNS服务器，仅处理其DNS命名空间中的电子邮件部分，例如* [mail.emmasdiner.com](http://mail.emmasdiner.com)
    *，该服务器将成为该邮件子域的权威。如[图9-19](ch09.xhtml#ch09fig19)所示，可能会根据需要为子域添加额外的DNS服务器。
- en: '![image](../images/f181-01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f181-01.jpg)'
- en: '*Figure 9-19: DNS zones divide responsibility for namespaces.*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-19：DNS区域划分了命名空间的责任。*'
- en: 'A *zone transfer* occurs when zone data is transferred between two devices,
    typically out of desire for redundancy. For example, in organizations with multiple
    DNS servers, administrators commonly configure a secondary DNS server to maintain
    a copy of the primary server’s DNS zone information in case the primary server
    becomes unavailable. There are two types of zone transfers:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*区域传输*发生在区域数据在两个设备之间传输时，通常是出于冗余的需求。例如，在有多个DNS服务器的组织中，管理员通常会配置一个辅助DNS服务器，以保持主服务器DNS区域信息的副本，以防主服务器不可用。区域传输有两种类型：
- en: '**Full zone transfer (AXFR)**   These types of transfers send an entire zone
    between devices.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整区域传输（AXFR）** 这些类型的传输在设备之间发送整个区域。'
- en: '**Incremental zone transfer (IXFR)**   These types of transfers send only a
    portion of the zone information.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**增量区域传输（IXFR）** 这些类型的传输只发送部分区域信息。'
- en: The file *dns_axfr.pcapng* contains an example of a full zone transfer between
    the hosts 172.16.16.164 and 172.16.16.139\. When you first look at this file,
    you may wonder whether you’ve opened the right one, because rather than UDP packets,
    you see TCP packets. Although DNS relies on UDP, it uses TCP for certain tasks,
    such as zone transfers, because TCP is more reliable for the amount of data being
    transferred. The first three packets in this capture file are the TCP three-way
    handshake.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*dns_axfr.pcapng*包含了主机172.16.16.164和172.16.16.139之间的完整区域传输示例。刚开始查看这个文件时，你可能会怀疑自己是否打开了正确的文件，因为你看到的是TCP数据包，而不是UDP数据包。虽然DNS依赖于UDP，但在某些任务中，它使用TCP，比如区域传输，因为TCP在传输大量数据时更为可靠。此捕获文件中的前三个数据包是TCP三次握手过程。
- en: The fourth packet begins the zone transfer request between 172.16.16.164 and
    172.16.16.139\. This packet doesn’t contain any DNS information. It’s marked as
    a “TCP segment of a reassembled PDU” because the data sent in the zone transfer
    request packet was sent in multiple packets. Packets 4 and 6 contain the packet’s
    data. Packet 5 is the acknowledgment that packet 4 was received. These packets
    are displayed in this manner because of the way Wireshark parses and displays
    TCP packets for easier readability. For our purposes, we can reference packet
    6 as the complete DNS zone transfer request, as shown in [Figure 9-20](ch09.xhtml#ch09fig20).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个数据包开始了172.16.16.164与172.16.16.139之间的区域传输请求。这个数据包不包含任何DNS信息。它被标记为“重新组装的PDU的TCP段”，因为区域传输请求数据包中的数据是通过多个数据包发送的。数据包4和6包含该数据包的数据，数据包5是确认数据包4已接收。这些数据包以这种方式显示，是因为Wireshark解析并显示TCP数据包的方式，使其更易于阅读。为了我们的目的，我们可以将数据包6作为完整的DNS区域传输请求，见[图9-20](ch09.xhtml#ch09fig20)。
- en: '![image](../images/f182-01.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f182-01.jpg)'
- en: '*Figure 9-20: DNS full zone transfer request*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-20：DNS完整区域传输请求*'
- en: The zone transfer request is a standard query ➊, but instead of requesting a
    single record type, it requests the AXFR type ➋, meaning that it wishes to receive
    the entire DNS zone from the server. The server responds with the zone records
    in packet 7, as shown in [Figure 9-21](ch09.xhtml#ch09fig21). As you can see,
    the zone transfer contains quite a bit of data, and this is one of the simpler
    examples! With the zone transfer complete, the capture file ends with the TCP
    connection teardown process.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 区域传输请求是一个标准查询➊，但它请求的是AXFR类型➋，这意味着它希望从服务器接收整个DNS区域。服务器在数据包7中响应区域记录，如[图9-21](ch09.xhtml#ch09fig21)所示。如你所见，区域传输包含了相当多的数据，这只是其中一个简单的示例！随着区域传输完成，捕获文件以TCP连接拆除过程结束。
- en: '**WARNING**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The data contained in a zone transfer can be very dangerous in the wrong hands.
    For example, by enumerating a single DNS server, you can map a network’s entire
    infrastructure.*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*区域传输中包含的数据在不当的人手中可能非常危险。例如，通过枚举单一的DNS服务器，你可以绘制出一个网络的完整基础设施。*'
- en: '![image](../images/f183-01.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f183-01.jpg)'
- en: '*Figure 9-21: The DNS full zone transfer occurring*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-21：发生DNS完整区域传输的过程*'
- en: '**Hypertext Transfer Protocol (HTTP)**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**超文本传输协议 (HTTP)**'
- en: The Hypertext Transfer Protocol is the delivery mechanism of the World Wide
    Web, allowing web browsers to connect to web servers to view web pages. In most
    organizations, HTTP represents, by far, the highest percentage of traffic seen
    going across the wire. Every time you do a Google search, send a tweet, or check
    University of Kentucky basketball scores on *[http://www.espn.com/](http://www.espn.com/)*,
    you’re using HTTP.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本传输协议是万维网的传输机制，允许网页浏览器连接到网页服务器以查看网页。在大多数组织中，HTTP代表了通过网络传输的流量中占比最高的部分。每次你进行Google搜索、发送推文或查看肯塔基大学篮球比分时，你都在使用HTTP，*例如访问[http://www.espn.com/](http://www.espn.com/)*。
- en: We won’t look at the packet structures for an HTTP transfer because there are
    so many different implementations of the HTTP protocol that the structure may
    vary wildly. Because of this variance, that exercise is left to you. Here, we’ll
    look at some practical applications of HTTP such as retrieving and posting content.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入研究HTTP传输的数据包结构，因为HTTP协议有许多不同的实现方式，结构可能会有很大差异。因此，这部分练习留给你自己完成。在这里，我们将重点讨论一些HTTP的实际应用，例如检索和发布内容。
- en: '***Browsing with HTTP***'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用HTTP浏览***'
- en: '*http_google.pcapng*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*http_google.pcapng*'
- en: HTTP is most commonly used to browse web pages on a web server using a browser.
    The capture file *http_google.pcapng* shows such an HTTP transfer, using TCP as
    the transport layer protocol. Communication begins with a three-way handshake
    between the client 172.16.16.128 and the Google web server 74.125.95.104.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP最常用于使用浏览器浏览网页。在捕获文件*http_google.pcapng*中，展示了一个使用TCP作为传输层协议的HTTP传输。通信从客户端172.16.16.128与Google网页服务器74.125.95.104之间的三次握手开始。
- en: Once communication is established, the first packet is marked as an HTTP packet
    from the client to the server, as shown in [Figure 9-22](ch09.xhtml#ch09fig22).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立通信，第一个数据包被标记为从客户端到服务器的HTTP数据包，如[图9-22](ch09.xhtml#ch09fig22)所示。
- en: '![image](../images/f184-01.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f184-01.jpg)'
- en: '*Figure 9-22: The initial HTTP `GET` request packet*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-22：初始HTTP `GET`请求数据包*'
- en: The HTTP packet is delivered over TCP to the server’s port 80 ➊, the standard
    port for HTTP communication (several other ports are often used as well, such
    as 8080 and 8888).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP数据包通过TCP传输到服务器的端口80➊，这是HTTP通信的标准端口（此外还经常使用其他端口，如8080和8888）。
- en: HTTP packets are identified by one of eight request methods as defined in HTTP
    specification version 1.1 (see *[http://www.iana.org/assignments/http-methods/http-methods.xhtml](http://www.iana.org/assignments/http-methods/http-methods.xhtml)*),
    which indicate the action the packet’s transmitter will perform on the receiver.
    As shown in [Figure 9-22](ch09.xhtml#ch09fig22), this packet identifies its method
    as `GET`, its request Uniform Resource Indicator (URI) as `/`, and the request
    version as `HTTP/1.1` ➋. This information tells us that the client is sending
    a request to download (`GET`) the root web directory (`/`) of the web server using
    version 1.1 of HTTP.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP数据包通过HTTP规范版本1.1中定义的八种请求方法之一来标识（见 *[http://www.iana.org/assignments/http-methods/http-methods.xhtml](http://www.iana.org/assignments/http-methods/http-methods.xhtml)*），这些方法指示数据包的发送者将对接收者执行的操作。如[图9-22](ch09.xhtml#ch09fig22)所示，该数据包将其方法标识为`GET`，其请求统一资源标识符（URI）为`/`，请求版本为`HTTP/1.1`
    ➋。这些信息告诉我们，客户端正在发送请求以下载（`GET`）Web服务器的根目录（`/`），并使用HTTP的1.1版本。
- en: Next, the host sends information about itself to the web server. This information
    includes things such as the browser (User-Agent) being used, languages accepted
    by the browser (Accept-Languages), and cookie information (at the bottom of the
    capture). The server can use this information to determine which data to return
    to the client in order to ensure compatibility.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，主机将有关其自身的信息发送到Web服务器。这些信息包括正在使用的浏览器（User-Agent）、浏览器接受的语言（Accept-Languages）以及cookie信息（捕获的底部）。服务器可以利用这些信息确定返回给客户端的数据，以确保兼容性。
- en: When the server receives the HTTP `GET` request in packet 4, it responds with
    a TCP ACK, acknowledging the packet, and begins transmitting the requested data
    from packets 6 to 11\. HTTP is used only to issue application-layer commands between
    the client and server. Why do all these HTTP packets show up as TCP under the
    protocol heading in the packet list? When data transfer begins, the Wireshark
    packet list window will identify those packets as TCP instead of HTTP since no
    HTTP request/response headers are present in those individual packets. Thus, where
    data transfer is occurring, you see TCP instead of HTTP in the Protocol column.
    Nonetheless, this is still part of the HTTP communication process.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器收到第4个数据包中的HTTP `GET`请求时，它会回应一个TCP ACK，确认该数据包，并开始从第6到第11个数据包传输请求的数据。HTTP仅用于在客户端和服务器之间发出应用层命令。为什么这些HTTP数据包在数据包列表中的协议标题下显示为TCP？当数据传输开始时，Wireshark数据包列表窗口将这些数据包标识为TCP，而不是HTTP，因为这些单独的数据包中没有HTTP请求/响应头。因此，在数据传输发生的地方，你会看到协议列显示为TCP，而不是HTTP。不过，这仍然是HTTP通信过程的一部分。
- en: Data is sent from the server in packets 6 and 7, an acknowledgment from the
    client in packet 8, two more data packets in packets 9 and 10, and another acknowledgment
    in packet 11, as shown in [Figure 9-23](ch09.xhtml#ch09fig23). All of these packets
    are shown in Wireshark as TCP segments, rather than as HTTP packets, although
    HTTP is still responsible for their transmission.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 数据从服务器通过第6和第7个数据包发送，从客户端通过第8个数据包进行确认，再通过第9和第10个数据包发送两个数据包，最后通过第11个数据包进行另一次确认，如[图9-23](ch09.xhtml#ch09fig23)所示。所有这些数据包在Wireshark中显示为TCP段，而不是HTTP数据包，尽管HTTP仍然负责它们的传输。
- en: '![image](../images/f185-01.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f185-01.jpg)'
- en: '*Figure 9-23: TCP transmitting data between the client browser and web server*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-23：TCP在客户端浏览器和Web服务器之间传输数据*'
- en: Once the data is transferred, Wireshark reassembles the data stream for viewing,
    as shown in [Figure 9-24](ch09.xhtml#ch09fig24).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据传输完成，Wireshark会重新组装数据流以供查看，如[图9-24](ch09.xhtml#ch09fig24)所示。
- en: '![image](../images/f185-02.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f185-02.jpg)'
- en: '*Figure 9-24: Final HTTP packet with response code 200*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-24：最终HTTP数据包，响应代码为200*'
- en: '**NOTE**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In many instances, you won’t be able to see readable HTML data when browsing
    through the packet list because that data is gzip compressed to increase bandwidth
    efficiency. This is signified by the Content-Encoding field in the HTTP response
    from the web server. It’s only when you view the full stream that the data is
    decoded and easily readable.*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*在许多情况下，你在浏览数据包列表时无法看到可读的HTML数据，因为这些数据经过gzip压缩以提高带宽效率。这可以通过Web服务器返回的HTTP响应中的Content-Encoding字段来表示。只有当你查看完整流时，数据才会被解码并变得易于阅读。*'
- en: HTTP uses a number of predefined response codes to indicate the results of a
    request method. In this example, we see a packet with status code 200 ➊, which
    indicates a successful request method. The packet also includes a timestamp and
    some additional information about the encoding of the content and configuration
    parameters of the web server. When the client receives this packet, the transaction
    is complete.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP使用许多预定义的响应代码来指示请求方法的结果。在这个例子中，我们看到一个状态码为200 ➊的数据包，表示请求方法成功。该数据包还包含了一个时间戳以及一些关于内容编码和Web服务器配置参数的附加信息。当客户端收到这个数据包时，交易就完成了。
- en: '***Posting Data with HTTP***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用HTTP发送数据***'
- en: '*http_post.pcapng*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*http_post.pcapng*'
- en: 'Now that we have looked at the process of downloading data from a web server,
    let’s turn our attention to uploading data. The file *http_post.pcapng* contains
    a very simple example of an upload: a user posting a comment to a web-site. After
    the initial three-way handshake, the client (172.16.16.128) sends an HTTP packet
    to the web server (69.163.176.56), as shown in [Figure 9-25](ch09.xhtml#ch09fig25).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了从Web服务器下载数据的过程，接下来让我们关注上传数据。文件*http_post.pcapng*包含了一个非常简单的上传示例：一个用户向网站发布评论。在初始的三次握手之后，客户端（172.16.16.128）发送一个HTTP数据包到Web服务器（69.163.176.56），如[图9-25](ch09.xhtml#ch09fig25)所示。
- en: '![image](../images/f186-01.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f186-01.jpg)'
- en: '*Figure 9-25: The HTTP `POST` packet*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-25：HTTP `POST`数据包*'
- en: This packet uses the `POST` method ➊ to upload data to a web server for processing.
    The `POST` method used here specifies the URI `/wp-comments-post.php` ➋ and the
    HTTP version of `HTTP/1.1`. To see the contents of the data posted, expand the
    HTML Form URL Encoded portion of the packet ➌.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包使用`POST`方法 ➊将数据上传到Web服务器进行处理。这里使用的`POST`方法指定了URI`/wp-comments-post.php`
    ➋以及HTTP版本`HTTP/1.1`。要查看发布的数据内容，请展开数据包中的HTML表单URL编码部分 ➌。
- en: Once the data is transmitted in this `POST`, an ACK packet is sent. As shown
    in [Figure 9-26](ch09.xhtml#ch09fig26), the server responds with packet 6, transmitting
    the response code 302 ➊, which means “found.”
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据通过这个`POST`传输，便会发送一个ACK数据包。如[图9-26](ch09.xhtml#ch09fig26)所示，服务器通过数据包6响应，传送响应代码302
    ➊，表示“找到”。
- en: '![image](../images/f187-01.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f187-01.jpg)'
- en: '*Figure 9-26: HTTP response 302 is used to redirect.*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-26：HTTP响应302用于重定向。*'
- en: The 302 response code is a common means of redirection in the HTTP world. The
    Location field in this packet specifies where the client is to be directed ➋.
    In this case, that location is on the originating web page where the comment was
    posted. The client performs a new `GET` request to retrieve content at the new
    location, which it sends over the next several packets. Finally, the server transmits
    status code 200, and the communication ends.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 302响应代码是HTTP世界中常用的重定向方式。这个数据包中的Location字段指定了客户端应该被重定向到的位置 ➋。在这种情况下，位置是在发布评论的源网页上。客户端会执行一个新的`GET`请求，以获取新位置的内容，并通过接下来的几个数据包发送。最后，服务器传输状态码200，通信结束。
- en: '**Simple Mail Transfer Protocol (SMTP)**'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**简单邮件传输协议（SMTP）**'
- en: If web browsing is the most common activity a user will participate in, sending
    and receiving email is probably in second place. The *Simple Mail Transfer Protocol
    (SMTP)*, used by platforms such as Microsoft Exchange and Postfix, is the standard
    for sending email.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果说网页浏览是用户最常参与的活动，那么发送和接收电子邮件大概排在第二位。*简单邮件传输协议（SMTP）*，用于Microsoft Exchange和Postfix等平台，是发送电子邮件的标准协议。
- en: As with HTTP, the structure of an SMTP packet can vary based on the implementation
    and the set of features supported by the client and server. In this section, we’ll
    review some of the basic functionality of SMTP by examining what sending email
    looks like at the packet level.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTTP类似，SMTP数据包的结构可能会根据实现和客户端、服务器支持的功能集有所不同。在这一节中，我们将通过查看电子邮件发送过程的数据包级别内容来回顾SMTP的一些基本功能。
- en: '***Sending and Receiving Email***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***发送和接收电子邮件***'
- en: The architecture supporting email is similar to the US Postal Service. When
    you write a letter, you put it in your mailbox, a postal worker picks it up, and
    it’s transported to a post office where it’s sorted. From there, the letter is
    either delivered to another mailbox serviced by that same post office or transported
    to another post office that is responsible for delivering it. A letter may traverse
    multiple post offices or even “hub” offices designed exclusively to distribute
    to post offices in specific geographic regions. This flow of information is illustrated
    in [Figure 9-27](ch09.xhtml#ch09fig27).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 支持电子邮件的架构类似于美国邮政服务。当你写信时，你把信放进邮箱，邮递员把信件取走并送到邮局进行分类。然后，信件要么被送到由同一个邮局服务的另一个邮箱，要么被送到另一个邮局，后者负责将其递送到目的地。信件可能会经过多个邮局，甚至是专门用于分发到特定地理区域的“中转”邮局。这个信息流在[图
    9-27](ch09.xhtml#ch09fig27)中有所展示。
- en: '![image](../images/f188-01.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f188-01.jpg)'
- en: '*Figure 9-27: Sending a letter via the postal service*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-27：通过邮政服务发送信件*'
- en: Delivering email works in a very similar manner, but the terminology is a bit
    different. At the individual user level, the physical mailbox is replaced by a
    digital mailbox that is responsible for storing and facilitating the sending and
    receiving of your email. You access this mailbox with a *mail user agent (MUA)*,
    which is an email client like Microsoft Outlook or Mozilla Thunderbird.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件的方式非常类似，但术语有所不同。在个人用户层面，物理邮箱被一个数字邮箱所取代，数字邮箱负责存储和促进电子邮件的发送和接收。你通过*邮件用户代理（MUA）*来访问这个邮箱，MUA
    是像微软 Outlook 或 Mozilla Thunderbird 这样的电子邮件客户端。
- en: When you send a message, it’s sent from your MUA to a *mail transfer agent (MTA)*.
    The MTA is often referred to as the mail server, with popular mail server applications
    being Microsoft Exchange or Postfix. If the email being sent is destined for the
    same domain it came from, the MTA can associate it with the recipient mailbox
    without any further communication. If the email is being sent to another domain,
    the MTA must use DNS to find the location address of the recipient mail server,
    then transmit the message to it. It’s worth noting that the mail server is often
    made up of other components like a Mail Delivery Agent (MDA) or a Mail Submission
    Agent (MSA), but from the network standpoint, we’ll usually only be interested
    in the concept of a client and a server. This basic overview is illustrated in
    [Figure 9-28](ch09.xhtml#ch09fig28).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发送一条消息时，它会从你的MUA发送到*邮件传输代理（MTA）*。MTA通常被称为邮件服务器，常见的邮件服务器应用程序有微软 Exchange 或
    Postfix。如果发送的电子邮件目的地是来自同一域，那么MTA可以在无需进一步通信的情况下将其与收件人的邮箱关联。如果电子邮件要发送到另一个域，MTA必须使用DNS来找到收件人邮件服务器的位置地址，然后将消息传输到该服务器。值得注意的是，邮件服务器通常由其他组件组成，如邮件投递代理（MDA）或邮件提交代理（MSA），但从网络角度来看，我们通常只关心客户端和服务器的概念。这个基本概述在[图
    9-28](ch09.xhtml#ch09fig28)中有所说明。
- en: '![image](../images/f189-01.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f189-01.jpg)'
- en: '*Figure 9-28: Sending an email via SMTP*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-28：通过SMTP发送电子邮件*'
- en: For simplicity’s sake, we’ll refer to the MUA as the email client and the MTA
    as the email server.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将MUA称为电子邮件客户端，将MTA称为电子邮件服务器。
- en: '***Tracking an Email Message***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跟踪电子邮件消息***'
- en: With a basic understanding of how email messages are transmitted, we can begin
    to look at packets that represent this process. Let’s start with the scenario
    outlined in [Figure 9-29](ch09.xhtml#ch09fig29).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基本了解电子邮件消息的传输方式，我们可以开始查看表示这个过程的数据包。让我们从[图 9-29](ch09.xhtml#ch09fig29)中的场景开始。
- en: '![image](../images/f189-02.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f189-02.jpg)'
- en: '*Figure 9-29: Tracking an email from sender to recipient*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-29：从发件人到收件人跟踪电子邮件*'
- en: 'There are three steps in this scenario:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景包含三个步骤：
- en: A user sends a message from their workstation (172.16.16.225). The email client
    transmits the message via SMTP to the local email server (172.16.16.221 / *skynet.local*
    domain).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从工作站（172.16.16.225）发送消息。电子邮件客户端通过SMTP将消息传输到本地邮件服务器（172.16.16.221 / *skynet.local*
    域）。
- en: The local email server receives the message and transmits it to a remote email
    server (172.16.16.231 / *cyberdyne.local* domain) via SMTP.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地邮件服务器接收消息，并通过SMTP将其传输到远程邮件服务器（172.16.16.231 / *cyberdyne.local* 域）。
- en: The remote email server receives the message and associates it with the appropriate
    mailbox. The email client on a user’s workstation (172.16.16.235) retrieves this
    message using the IMAP protocol.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远程邮件服务器接收消息，并将其与适当的邮箱关联。用户工作站上的电子邮件客户端（172.16.16.235）使用IMAP协议检索此消息。
- en: '**Step 1: Client to Local Server**'
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤1：客户端到本地服务器**'
- en: '*mail_sender_client_1.pcapng*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*mail_sender_client_1.pcapng*'
- en: We’ll begin stepping through this process by reviewing step 1, which is represented
    by *mail_sender_client_1.pcapng*. The file begins when the user clicks the Send
    button in their email client, initiating the TCP handshake between their workstation
    and the local email server in packets 1 through 3.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看步骤1来开始这个过程，这一步由*mail_sender_client_1.pcapng*表示。文件在用户点击其邮件客户端中的发送按钮时开始，启动了工作站与本地邮件服务器之间的数据包1到数据包3的TCP握手。
- en: '**NOTE**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can ignore any `ETHERNET FRAME CHECK SEQUENCE INCORRECT` errors observed
    while analyzing the packet captures in this section. They are an artifact of the
    lab environment in which these were created.*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*在分析本节中的数据包捕获时，您可以忽略任何观察到的`ETHERNET FRAME CHECK SEQUENCE INCORRECT`错误。这些错误是实验环境中的副作用。*'
- en: Once a connection is established, SMTP takes over and begins the work of transmitting
    the user’s message to the server. You could examine each SMTP request and response
    individually by scrolling through each packet and viewing the SMTP section of
    the Packet Details window, but there is an easier way. Since SMTP is a simple
    transactional protocol and our example is in clear text, you can follow the TCP
    stream to view the entire transaction in one window. Do this by right-clicking
    any packet in the capture and selecting **Follow** ▶ **TCP Stream**. The resulting
    stream is shown in [Figure 9-30](ch09.xhtml#ch09fig30).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，SMTP协议接管并开始将用户的消息传输到服务器。您可以通过逐个滚动数据包并查看数据包详情窗口中的SMTP部分来检查每个SMTP请求和响应，但有更简单的方法。由于SMTP是一个简单的事务协议，并且我们的示例是明文传输，您可以通过跟踪TCP流来在一个窗口中查看整个事务。右键点击数据包中的任何一个，选择**跟踪**
    ▶ **TCP流**。生成的流在[图9-30](ch09.xhtml#ch09fig30)中显示。
- en: With a connection established, the email server sends a service banner to the
    client in packet 4 to indicate that it is ready to receive a command. In this
    case, it identifies itself as a Postfix server running on the Ubuntu Linux operating
    system ➊. It also identifies that it is capable of receiving *Extended SMTP (ESMTP)*
    commands. ESMTP is an extension to the SMTP specification that allows for additional
    commands to be used during mail transmission.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 连接建立后，邮件服务器在数据包4中向客户端发送服务横幅，表示它准备好接收命令。在此情况下，它自我标识为运行在Ubuntu Linux操作系统上的Postfix服务器
    ➊。它还标识了它能够接收*扩展SMTP（ESMTP）*命令。ESMTP是SMTP规范的扩展，允许在邮件传输过程中使用额外的命令。
- en: The email client responds by issuing the `EHLO` command in packet 5 ➋. `EHLO`
    is the “Hello” command used to identify the sending host when ESMTP is supported.
    If ESMTP is not available, the client will revert to the `HELO` command to identify
    itself. In this example, the sender is identified by its IP address, although
    a DNS name can be used as well.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件客户端通过在数据包5中发出`EHLO`命令来做出响应 ➋。`EHLO`是“Hello”命令，用于在支持ESMTP时识别发送主机。如果ESMTP不可用，客户端将回退到`HELO`命令来标识自己。在本例中，发送方通过其IP地址进行标识，尽管也可以使用DNS名称。
- en: In packet 7, the server responds with a list of items that include things like
    `VRFY`, `STARTTLS`, and `SIZE 10240000` ➌. This list, which reflects commands
    supported by the SMTP server, is provided so that the client knows what commands
    it is allowed to use when transmitting the message. This feature negotiation occurs
    at the beginning of every SMTP transaction before a message is sent. The transmission
    of the message begins at packet 8 and makes up most of the remainder of this capture.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包7中，服务器响应包含包括`VRFY`、`STARTTLS`和`SIZE 10240000` ➌等项的列表。这个列表反映了SMTP服务器支持的命令，提供给客户端，以便客户端知道在传输消息时可以使用哪些命令。每次SMTP事务开始时，在发送消息之前，都会进行此功能协商。消息的传输从数据包8开始，占据了本次捕获的大部分内容。
- en: '![image](../images/f191-01.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f191-01.jpg)'
- en: '*Figure 9-30: Viewing the TCP stream from the email client to the local server*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-30：查看从邮件客户端到本地服务器的TCP流*'
- en: SMTP is governed by simple commands and parameter values sent from the client,
    followed by a response code from the server. This is very similar to protocols
    like HTTP and TELNET and is designed for simplicity. An example request and reply
    can be seen in packets 8 and 9, where the client issues the `MAIL` command with
    the parameter `FROM:<sanders@skynet.local> SIZE=556` ➍, and the server responds
    with response code 250 (Requested mail action okay, completed) and the `2.1.0
    Ok` parameter. Here, the client identifies the sender’s email address and the
    size of the message, and the server responds saying that this data was received
    and is acceptable. A similar transaction happens again in packets 10 and 11, where
    the client issues the `RCPT` command with the parameter `TO:<sanders@cyberdyne.local>`
    ➎, and the server responds with another `250 2.1.5 Ok` code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP由客户端发送的简单命令和参数值控制，之后是服务器返回的响应代码。这与HTTP和TELNET等协议非常相似，且设计简洁。一个示例请求和响应可以在数据包8和9中看到，客户端发出`MAIL`命令，并带有参数`FROM:<sanders@skynet.local>
    SIZE=556` ➍，服务器以响应代码250（请求的邮件操作正常，已完成）和`2.1.0 Ok`参数做出响应。在这里，客户端识别了发件人的电子邮件地址和消息的大小，服务器则响应说已接收到这些数据并且是可接受的。在数据包10和11中会发生类似的交易，客户端发出`RCPT`命令，并带有参数`TO:<sanders@cyberdyne.local>`
    ➎，服务器则回应另一个`250 2.1.5 Ok`代码。
- en: '**NOTE**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’d like to review all the available SMTP commands and parameters, you
    can do so here:* [http://www.iana.org/assignments/mail-parameters/mail-parameters.xhtml](http://www.iana.org/assignments/mail-parameters/mail-parameters.xhtml)*.
    If you’d like to review the available response codes, that can be done here:*
    [https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.xml](https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.xml).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想查看所有可用的SMTP命令和参数，可以在这里查看：* [http://www.iana.org/assignments/mail-parameters/mail-parameters.xhtml](http://www.iana.org/assignments/mail-parameters/mail-parameters.xhtml)*。如果你想查看可用的响应代码，也可以在这里查看：*
    [https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.xml](https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.xml)。'
- en: All that is left is to transmit the message itself. The client initiates this
    process in packet 12 by issuing the `DATA` command. The server responds with code
    354 along with a message ➏, which indicates that the server has created a buffer
    for the message and tells the client to begin transmitting. The line containing
    the code 354 tells the client to send a dot (`<CR><LF>.<CR><LF>`) to mark the
    end of the transmission. The message is transmitted in plaintext, and a response
    code indicating successful transmission is sent. You’ll notice the inclusion of
    some additional information with the message text, including the date, the content
    type and encoding, and the user agent associated with the transmission. This tells
    you that the end user who sent this message was using Mozilla Thunderbird ➐.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是传输邮件内容本身了。客户端在数据包12中发出`DATA`命令，启动这个过程。服务器以代码354和一条信息 ➏回应，表示服务器已为消息创建了一个缓冲区，并告诉客户端开始传输。包含代码354的那一行告诉客户端，发送一个点（`<CR><LF>.<CR><LF>`）来标记传输的结束。消息以明文形式传输，且成功传输后，服务器发送响应代码。你会注意到，消息文本中还包含了一些附加信息，包括日期、内容类型和编码，以及与该传输相关的用户代理。这表明发送此消息的最终用户使用的是Mozilla
    Thunderbird ➐。
- en: With transmission complete, the SMTP connection is terminated by the email client
    by issuing the `QUIT` command with no parameters in packet 18\. The server responds
    in packet 19 with the response code 221 (*<domain>* ser-vice closing transmission
    channel) and the `2.0.0 Bye` parameter ➑. The TCP connection is torn down gracefully
    in packets 20–23.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 传输完成后，SMTP连接由邮件客户端通过在数据包18中发出没有参数的`QUIT`命令终止。服务器在数据包19中以响应代码221（*<domain>* 服务关闭传输通道）和`2.0.0
    Bye`参数 ➑作出回应。TCP连接在数据包20–23中优雅地断开。
- en: '**Step 2: Local Server to Remote Server**'
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤2：本地服务器到远程服务器**'
- en: '*mail_sender_server_2.pcapng*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*mail_sender_server_2.pcapng*'
- en: Next we’ll examine the same scenario from the perspective of the local email
    server responsible for the *skynet.local* domain; its address is 172.16.16.221\.
    This capture can be found in the file *mail_sender_server_2.pcapng*, which was
    taken directly from the email server. As you might expect, the first 20 or so
    packets mirror the capture in step 1, because they are the same packets captured
    from another source.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从负责*skynet.local*域的本地邮件服务器的角度来审视同样的场景；其地址是 172.16.16.221\。这个捕获文件可以在 *mail_sender_server_2.pcapng*
    中找到，该文件直接从邮件服务器捕获。正如你所预期的，前 20 个左右的数据包与步骤 1 中的捕获镜像相同，因为它们是从另一个来源捕获的相同数据包。
- en: If the sent message was destined for another mailbox in the *skynet.local* domain,
    we wouldn’t see any more SMTP traffic; instead, we would see the retrieval of
    the message from an email client with the POP3 or IMAP protocol. However, since
    this message is destined for the *cyberdyne.local* domain, the local SMTP server
    must transmit the message to the remote SMTP server responsible for that domain.
    This process begins in packet 22 with a TCP handshake between the local server
    172.16.16.221 and the remote mail server 172.16.16.231.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发送的消息是发送到*skynet.local*域的另一个邮箱，我们就不会看到更多的 SMTP 流量；相反，我们会看到使用 POP3 或 IMAP 协议从邮件客户端检索消息。然而，由于此消息是发送到*cyberdyne.local*域，本地
    SMTP 服务器必须将消息传输到负责该域的远程 SMTP 服务器。这个过程从数据包 22 开始，涉及本地服务器 172.16.16.221 和远程邮件服务器
    172.16.16.231 之间的 TCP 握手。
- en: '**NOTE**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In a real-world scenario, an email server locates another server by using
    a special DNS record type known as a* mail exchange (MX) record*. Since this scenario
    was created in a lab and the IP address of the remote email server was preconfigured
    on the local server, we won’t see that traffic here. If you’re troubleshooting
    email delivery, you should consider the potential for DNS issues along with email-specific
    protocol issues.*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实际场景中，邮件服务器通过使用一种称为邮件交换（MX）记录的特殊 DNS 记录类型来定位另一个服务器。由于这个场景是在实验室中创建的，且远程邮件服务器的
    IP 地址已预配置在本地服务器上，因此我们不会在此看到该流量。如果你在排查邮件传输问题时，应考虑 DNS 问题与邮件协议问题的可能性。*'
- en: With a connection established, we can see in the Packet List window that SMTP
    is used to deliver the message to the remote server. You can better view this
    conversation by following the TCP stream for the transaction. It is shown in [Figure
    9-31](ch09.xhtml#ch09fig31). If you need help isolating this connection, apply
    the filter tcp.stream == 1 in the filter bar.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 建立连接后，我们可以在数据包列表窗口中看到，SMTP 被用来将消息发送到远程服务器。你可以通过查看此次事务的 TCP 流来更好地查看这个过程。它在[图
    9-31](ch09.xhtml#ch09fig31)中显示。如果你需要帮助来隔离这个连接，可以在过滤栏中应用过滤器 tcp.stream == 1。
- en: '![image](../images/f193-01.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f193-01.jpg)'
- en: '*Figure 9-31: Viewing the TCP stream from the local email server to the remote
    email server*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-31：查看从本地邮件服务器到远程邮件服务器的 TCP 流*'
- en: This transaction is nearly identical to the one in [Figure 9-30](ch09.xhtml#ch09fig30).
    Essentially, the message is just being transmitted between servers. The remote
    server identifies itself as `mail02` ➊, the local server identifies itself as
    `mail01` ➋, a list of support commands is shared ➌, and the message is transferred
    in its entirety with a bit of additional data from the previous transaction prepended
    to the message above the To line ➍. This all occurs between packets 27 and 35,
    with a TCP teardown closing the communication channel.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事务与[图 9-30](ch09.xhtml#ch09fig30)中的几乎相同。本质上，消息只是通过服务器之间传输。远程服务器将自己标识为`mail02`
    ➊，本地服务器将自己标识为`mail01` ➋，共享一组支持命令 ➌，并且消息在传输时完整无缺，其中之前事务的部分数据被附加到消息的收件人行（To line）上
    ➍。这一切发生在数据包 27 到 35 之间，最后通过 TCP 拆除关闭了通信通道。
- en: The server ultimately doesn’t care whether the message is coming from an email
    client or another SMTP server, so all the same rules and procedures apply (barring
    any type of access control restrictions). In the real world, a local email server
    and a remote email server might not support the same feature set or might be based
    on entirely different platforms. This is why the initial SMTP communication is
    so important; it allows the recipient server to transmit its supported feature
    set to the sender. When an SMTP client or server is aware of the supported features
    of the recipient server, the SMTP commands can be adjusted so that the message
    can be transmitted effectively. This capability allows SMTP to be widely usable
    between any number of client and server technologies, and this is why you don’t
    have to know much about the network infrastructure of the recipient when sending
    an email.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器最终并不关心消息是来自电子邮件客户端还是另一台 SMTP 服务器，因此所有相同的规则和程序都适用（除非有任何访问控制限制）。在现实世界中，本地邮件服务器和远程邮件服务器可能不支持相同的功能集，或者可能基于完全不同的平台。这就是为什么最初的
    SMTP 通信如此重要的原因；它允许接收服务器将其支持的功能集传输给发送方。当一个 SMTP 客户端或服务器知道接收服务器支持的功能时，SMTP 命令可以进行调整，以便有效地传输消息。这种能力使得
    SMTP 可以在任何数量的客户端和服务器技术之间广泛使用，这也是你在发送电子邮件时不必了解接收方的网络基础设施的原因。
- en: '**Step 3: Remote Server to Remote Client**'
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3：远程服务器到远程客户端**'
- en: '*mail_receiver_server_3.pcapng*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*mail_receiver_server_3.pcapng*'
- en: At this point, our message has reached the remote server responsible for delivering
    emails to mailboxes in the *cyberdyne.local* domain. We’ll now look at a packet
    capture taken from the perspective of the remote server, *mail_ receiver_server_3.pcapng*,
    shown in [Figure 9-32](ch09.xhtml#ch09fig32).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的消息已经到达了负责将电子邮件投递到 *cyberdyne.local* 域邮箱的远程服务器。接下来，我们将查看从远程服务器角度捕获的一个数据包，它的名称是
    *mail_receiver_server_3.pcapng*，如 [图 9-32](ch09.xhtml#ch09fig32) 所示。
- en: '![image](../images/f194-01.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f194-01.jpg)'
- en: '*Figure 9-32: Viewing the TCP stream from the local email server to the remote
    email server*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-32：查看从本地邮件服务器到远程邮件服务器的 TCP 流*'
- en: Once again, the first 15 packets in this capture look very familiar, as they
    are a representation of the same message being exchanged, with the source address
    representing the local email server ➊ and the destination address representing
    the remote email server ➋. Once this sequence is completed, the SMTP server can
    associate the message with the appropriate mailbox so that the intended recipient
    can retrieve it via their email client.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，这次捕获中的前 15 个数据包看起来非常熟悉，因为它们代表的是相同的消息交换，其中源地址代表本地邮件服务器 ➊，目标地址代表远程邮件服务器 ➋。完成此序列后，SMTP
    服务器可以将消息与适当的邮箱关联起来，以便目标接收者可以通过他们的电子邮件客户端检索消息。
- en: As mentioned earlier, SMTP is primarily used for sending email and is by far
    the most common protocol for that purpose. Retrieving email from a mailbox on
    a server is a bit more open-ended, and because of different needs arising in that
    space, there are several protocols that are designed to support this task. The
    most prevalent are Post Office Protocol version 3 (POP3) and Internet Message
    Access Protocol (IMAP). In our example, the remote client retrieves messages from
    the email server using IMAP in packets 16–34.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，SMTP 主要用于发送电子邮件，并且迄今为止是最常见的用于该目的的协议。从服务器上的邮箱中检索电子邮件则相对更加开放，因为在这个过程中有不同的需求，因此有几种协议被设计来支持这个任务。最常见的协议是邮局协议版本
    3（POP3）和互联网邮件访问协议（IMAP）。在我们的例子中，远程客户端通过 IMAP 协议在数据包 16 到 34 中从邮件服务器检索消息。
- en: We don’t cover IMAP in this book, but in this example, it wouldn’t do you a
    ton of good even if we did because the communication is encrypted. If you look
    at packet 21, you’ll see the client (172.16.16.235) send the `STARTTLS` command
    to the email server (172.16.16.231) in packet 21 ➊, shown in [Figure 9-33](ch09.xhtml#ch09fig33).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们不讨论 IMAP，但在这个例子中，即使我们讨论了它，它也不会给你太多帮助，因为通信是加密的。如果你查看数据包 21，你会看到客户端（172.16.16.235）在数据包
    21 中向邮件服务器（172.16.16.231）发送了 `STARTTLS` 命令 ➊，如 [图 9-33](ch09.xhtml#ch09fig33)
    所示。
- en: '![image](../images/f195-01.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f195-01.jpg)'
- en: '*Figure 9-33: The STARTTLS command indicates that the IMAP traffic will be
    encrypted.*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-33：STARTTLS 命令表示 IMAP 流量将被加密。*'
- en: This command informs the server that the client would like to retrieve messages
    securely using TLS encryption. A secure channel is negotiated between each endpoint
    in packets 24–27 ➋, and the message is retrieved securely via the *TLS (Transport
    Layer Security)* protocol in the remaining packets ➌. If you click any of these
    packets to view the data or attempt to follow the TCP stream ([Figure 9-34](ch09.xhtml#ch09fig34)),
    you’ll find that the contents are unreadable, protecting the email from being
    intercepted by someone who might be attempting to hijack or sniff traffic maliciously.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令告知服务器客户端希望使用 TLS 加密安全地检索邮件。在数据包 24–27 ➋ 中，客户端和服务器之间会协商出一个安全通道，随后邮件通过 *TLS（传输层安全）*
    协议在剩余数据包 ➌ 中安全地被检索。如果你点击这些数据包查看数据或尝试跟踪 TCP 流（[图 9-34](ch09.xhtml#ch09fig34)），你会发现内容是不可读的，这样就能保护电子邮件不被可能试图恶意劫持或嗅探流量的人员截取。
- en: With those final packets received, the process of sending a message from a user
    in one domain to a user in another domain is completed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 随着最后的数据包接收完成，从一个域的用户向另一个域的用户发送邮件的过程就完成了。
- en: '![image](../images/f196-01.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f196-01.jpg)'
- en: '*Figure 9-34: The IMAP traffic is encrypted as the client downloads the message.*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-34：IMAP 流量在客户端下载邮件时被加密。*'
- en: '***Sending Attachments via SMTP***'
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过 SMTP 发送附件***'
- en: '*mail_sender _attachment.pcapng*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*mail_sender_attachment.pcapng*'
- en: SMTP was never intended to be a mechanism for transmitting files, but the ease
    of emailing a file means that it has become the primary sharing mechanism for
    many. Let’s walk through a quick example of what sending a file looks like at
    the packet level using SMTP.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP 从来不是用来传输文件的机制，但由于通过电子邮件发送文件的便利性，它已经成为许多人主要的共享机制。让我们通过一个简单的例子，看看使用 SMTP
    发送文件在数据包层面上是如何进行的。
- en: In the packet capture *mail_sender_attachment.pcapng*, a user is sending an
    email message from their client (172.16.16.225) to another user on the same network
    via a local SMTP mail server (172.16.16.221). The message contains a bit of text
    and includes an image file attachment.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包捕获文件 *mail_sender_attachment.pcapng* 中，用户正在从其客户端（172.16.16.225）通过本地 SMTP
    邮件服务器（172.16.16.221）向同一网络中的另一用户发送电子邮件。邮件包含一些文本，并附带一个图片文件。
- en: Sending an attachment via SMTP is not too different from sending text. It’s
    all just data to the server, and although some special encoding usually takes
    place, we still rely on the `DATA` command to get things where they’re going.
    To see this in action, open the capture file and follow the TCP stream for the
    given SMTP transaction. This stream is pictured in [Figure 9-35](ch09.xhtml#ch09fig35).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SMTP 发送附件与发送文本并没有太大区别。对于服务器来说，这些都只是数据，虽然通常会进行一些特殊编码，但我们仍然依赖 `DATA` 命令将数据传送到目的地。要看到这一过程的实际操作，打开捕获文件并跟踪给定
    SMTP 事务的 TCP 流。这一过程在 [图 9-35](ch09.xhtml#ch09fig35) 中有所展示。
- en: '![image](../images/f197-01.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f197-01.jpg)'
- en: '*Figure 9-35: A user sending an attachment via SMTP*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-35：用户通过 SMTP 发送附件*'
- en: This example begins like the previous scenarios with service identification
    and an exchange of supported protocols. When the client is ready to transmit the
    message, it does so by providing the From and To addresses, and sending the `DATA`
    command instructs the server to open up a buffer to receive the information. This
    is where things get a little different.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子和之前的场景一样，首先是服务识别和支持协议的交换。当客户端准备好发送邮件时，它会提供发件人和收件人的地址，并发送 `DATA` 命令，指示服务器打开一个缓冲区来接收信息。此时，事情就有些不同了。
- en: In the previous example, the client transmitted the text directly to the server,
    and that was it. In this example, the client must send the plaintext message,
    as well as the binary data associated with the image attachment. To make this
    happen, it identifies its Content-Type as `multipart/mixed`, with a boundary of
    `------------050407080301000500070000` ➊. This tells the server that multiple
    types of data are being transmitted, each with their own unique MIME type and
    encoding, and that each type of data will be separated with the boundary value
    specified. Therefore, when another mail client receives this data, it will know
    how to interpret the data based on the boundaries and the unique MIME type and
    encoding specified in each chunk.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，客户端直接将文本传输到服务器，仅此而已。在这个示例中，客户端必须同时发送明文消息和与图像附件相关的二进制数据。为了实现这一点，它将其Content-Type标识为`multipart/mixed`，并使用边界值`------------050407080301000500070000`
    ➊。这告诉服务器，正在传输多种类型的数据，每种数据都有自己独特的MIME类型和编码，并且每种数据将通过指定的边界值进行分隔。因此，当另一个邮件客户端接收到这些数据时，它将根据边界值以及每个数据块中指定的唯一MIME类型和编码来解释数据。
- en: In our example, we have two unique parts of this message. The first is the mail
    text itself, which is identified by the content type `text/plain` ➋. After that,
    we see a boundary marker and the start of a new part of the message ➌. This part
    contains the image file and is identified by the content type `image/jpeg` ➍.
    It’s also worth noting that the `Content-Transfer-Encoding` value is set to `base64`
    ➎, meaning that the data must be converted from base 64 to be parsed. The remainder
    of the transmission includes the encoded image file ➏.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，这条消息有两个独特的部分。第一个是邮件正文本身，它通过内容类型`text/plain` ➋进行标识。接下来，我们看到一个边界标记和新消息部分的开始
    ➌。这一部分包含图像文件，并通过内容类型`image/jpeg` ➍进行标识。还值得注意的是，`Content-Transfer-Encoding`的值被设置为`base64`
    ➎，这意味着数据必须从Base64编码转换才能进行解析。剩余的传输内容包括编码后的图像文件 ➏。
- en: Whatever you do, don’t get this encoding confused with a security feature. Base
    64 encoding is almost instantly reversible, and any attacker who intercepts this
    communication would be able to retrieve the image file without much effort. If
    you are interested in carving this image file out of the packet capture yourself,
    there is a similar scenario in which we carve an image from an HTTP-based file
    transfer in the Remote-Access Trojan section of [Chapter 12](ch12.xhtml#ch12).
    Once you’ve read that, flip back to this capture file and see if you can find
    out who the user’s mysterious new coworker is.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你做什么，都不要把这种编码与安全功能混淆。Base64编码几乎是瞬时可逆的，任何拦截此通信的攻击者都能轻松恢复图像文件。如果你有兴趣自己从数据包捕获中提取出这个图像文件，在[第12章](ch12.xhtml#ch12)的远程访问木马部分有一个类似的场景，我们在那里从基于HTTP的文件传输中提取图像。阅读完后，翻回这个捕获文件，看看你是否能找出用户神秘的新同事是谁。
- en: '**Final Thoughts**'
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最终思考**'
- en: This chapter has introduced the most common protocols you will encounter when
    examining traffic at the application layer. In the following chapters, we’ll examine
    new protocols and additional features of the protocols we’ve covered here as we
    explore a wide range of real-world scenarios.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在分析应用层流量时最常遇到的协议。在接下来的章节中，我们将探讨新的协议以及我们在此处讨论的协议的附加功能，同时探索各种真实世界的场景。
- en: To learn more about individual protocols, read their associated RFCs or have
    a look at *The TCP/IP Guide* by Charles M. Kozierok (No Starch Press, 2005). Also,
    see the list of resources in [Appendix A](ch14_appa.xhtml#ch14_appa).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于各个协议的信息，请阅读它们相关的RFC，或参考Charles M. Kozierok所著的*《TCP/IP指南》*（No Starch Press，2005）。此外，请参阅[附录A](ch14_appa.xhtml#ch14_appa)中的资源列表。
