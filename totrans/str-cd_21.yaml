- en: '**GENETIC PROGRAMMING WITH FIREFLY**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 15](ch15.xhtml#ch15), we explored the Firefly language with fun
    animations and music. In this appendix, we’ll use Firefly along with *genetic
    programming* to evolve displays we can then animate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to Genetic Programming**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Genetic programming became widely known in the early 1990s. Genetic programming
    uses algorithms to create programs by mimicking biological evolution. Instead
    of manually writing the code to perform a task, genetic programming generates
    and runs a population of random programs to see how well they perform. Each program
    in the population is given a *fitness value*, often called an objective function
    value, which is used to decide which programs breed to create the next generation
    of programs. Breeding is accomplished via *crossover* between pairs of programs,
    which mixes the code of “parent” programs to produce a new “offspring” program.
    As in biological evolution, there is a small probability a program will undergo
    a random mutation. Random mutation drives evolution by inserting new “genes” into
    the population. Biological evolution is driven by other processes, like genetic
    drift, but we’ll keep things simple and rely on crossover between well-performing
    individuals and random mutation.
  prefs: []
  type: TYPE_NORMAL
- en: '**How Genetic Programming Works**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The general approach to genetic programming is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a population of randomly generated programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run each program in the population and assign it a fitness value depending on
    how well it does at solving the desired task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the next generation of programs by breeding (crossover) and mutation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from Step 2 until we either have a program that solves our task to our
    satisfaction or we give up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For us, the programs are Firefly code for generating LED displays. We’ll specify
    the display we’d like and let genetic programming evolve a program that creates
    that display (we hope!).
  prefs: []
  type: TYPE_NORMAL
- en: Typically, using genetic programming is somewhat tricky because generating random
    computer code that actually runs is difficult. Likewise, mixing two programs to
    produce a new one is challenging due to syntax issues. However, we are fortunate,
    as Firefly is extremely simple. *Any* string of characters extracted from the
    allowed set of Firefly commands is a valid Firefly program, and will thus run
    without error.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as we are seeking code to generate a particular display, we only need
    to consider Firefly instructions that manipulate the LEDs. Thus, we can dispense
    with double buffering, music, and random trails, as they are not reproducible.
    We only need instructions to move the firefly and set the mode.
  prefs: []
  type: TYPE_NORMAL
- en: We are doing genetic programming, but we’ll implement the evolution portion
    via a *genetic algorithm*, or *GA*. A genetic algorithm is more general than genetic
    programming, but for our Firefly code, the GA works perfectly to implement genetic
    programming. We won’t dive into how the genetic algorithm code works. Rather,
    we’ll just use the algorithm and see its effects. However, GA isn’t all that complicated,
    so if you read through the code, you’ll see what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to experiment with genetic programming and Firefly, we need the
    following pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: Some way to define the display we want to create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A stripped-down version of the Firefly interpreter that only processes move
    and mode commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GA code to evolve a population of Firefly programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Something to package the pieces together, run the search, and output the resulting
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s build what we need, piece by piece. If you want to jump into the Python
    code now, read through *fly_swarm.py* in the *firefly/GP* directory. Note that
    the population evolved by genetic programming is sometimes referred to as a *swarm*,
    even though swarm is most often used in relation to *swarm intelligence* algorithms.
    We’ll use “population” and “swarm” interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Displays**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most straightforward part of this exercise is defining the display we want
    to generate. Firefly’s display is a 5×5 grid of LED intensities. Therefore, we’ll
    define target displays using a 5×5 array of numbers stored in a text file. For
    example, to specify a “ball” located in the upper-left corner of the display,
    create a text file containing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This puts a medium intensity (square) “ball” in the upper-left corner with all
    other LEDs off. The text file stores the intensities of the 5×5 array for the
    genetic programming code to use as a target. The more similar the display generated
    by a candidate program is to the target, the better.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Tiny Firefly Interpreter**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need a tiny interpreter supporting only the Firefly move and mode commands
    to run our programs. We’ll make this interpreter a Python class so we can instantiate
    it easily. The result is [Listing A-1](app01.xhtml#ch0Alist1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-1: A tiny Firefly interpreter*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each program in the population, we create a `Firefly` instance with the
    program passed in. Then the `Run` method executes the program and `GetDisplay`
    returns the resulting display. For example, this code loads the `Firefly` class
    and runs a program to move north three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’ll compare the display returned by `GetDisplay` with our desired target to
    calculate the program’s fitness.
  prefs: []
  type: TYPE_NORMAL
- en: The tiny Firefly interpreter accepts digits, the letters `M`, `I`, and `D`,
    and the cardinal directions as instructions. The interpreter runs the given program
    once, without looping, and ends, preserving the resulting display. As we’ll see,
    our GA runs thousands to millions of sample Firefly programs, searching for one
    that meets our needs. Each run uses an instance of the `Firefly` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Genetic Algorithm**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `GA` class implements the GA. But we need to define a few things before
    we can use it. First, we need a mapping between the Firefly code we want and the
    vector of numbers the GA uses to represent an individual. Second, we need a class
    to bound the search. Third, we need a class to calculate the fitness value for
    an individual. A fitness value here is like a golf score: lower is better. If
    the score is 0, we can stop because we found a program that does exactly what
    we want.'
  prefs: []
  type: TYPE_NORMAL
- en: There are 17 instructions supported by our tiny Firefly interpreter. Thus, we’ll
    restrict the vectors used by the GA to [0,16] to ensure they contain integers.
    This lets us map a vector to a Firefly program.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing A-2](app01.xhtml#ch0Alist2) defines `FlyBounds` as a subclass of `Bounds`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-2: A class for bounding the search*'
  prefs: []
  type: TYPE_NORMAL
- en: '`Bounds` is a framework component used by the GA. What’s important for us is
    that the subclass defines the allowed range of values from 0 to 16 (`len(ALLOWED)-1`),
    with `ndim` being the number of instructions in the program (the dimensionality
    of the search space). The `Validate` method takes a member of the population,
    `p`, and makes it integer-valued by rounding to the nearest integer.'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need is a class to measure a program’s fitness (see [Listing
    A-3](app01.xhtml#ch0Alist3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-3: A class to measure fitness*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `target` is a 5×5 NumPy array representing the display we’re trying to
    evolve code to generate. The `Evaluate` method accepts a member of the population,
    converts it to actual Firefly code with `PositionToFirefly`, creates a Firefly
    interpreter, and then runs the code.
  prefs: []
  type: TYPE_NORMAL
- en: The last line calculates the fitness of the program. The output is a 5×5 array,
    that is, the display. For fitness, we’ll use the *mean squared error*, or *MSE*.
    This is the average value of the squared per-element difference between the program’s
    display and the display we want to generate. The lower this value, the better
    the program is at creating the desired display. When the MSE is 0, the program
    has created the target display precisely, so we’ll stop searching when (if) that
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: Using the square of the difference instead of the absolute value of the difference
    penalizes larger per-element differences more, which is what we want. We want
    to drive the population toward programs with smaller differences.
  prefs: []
  type: TYPE_NORMAL
- en: '`PositionToFirefly` uses a one-to-one mapping between the integers in `p` and
    the characters in `ALLOWED` to return the program string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GA relies on crossover and random mutation. Firefly programs are represented
    as vectors of numbers. To implement the crossover of two programs, *A* and *B*
    of length *N*, the GA selects a random index, *i*, in [0, *N –* 1]. The new offspring
    vector is *C* = *A*[: *i*] + *B*[*i* :], meaning the first *i* values of *A* followed
    by the last *N – i* values of *B*. Mutation is even simpler. A random index, *j*,
    is selected, and the value at that index is set to a random number, [0,16].'
  prefs: []
  type: TYPE_NORMAL
- en: We now have what we need to use the `GA` class and search for Firefly programs.
    Let’s see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Putting It All Together**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing A-4](app01.xhtml#ch0Alist4) shows the `main` function of *fly_swarm.py*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-4: The main function*'
  prefs: []
  type: TYPE_NORMAL
- en: The command line is parsed to load the target display, the size of the population
    (`npart`), the length of each program (`ndim`), and the number of generations
    to evolve (`niter`) ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create instances of `FlyBounds` and `RandomInitializer`, an object
    used by the GA to randomly generate the initial population of programs.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of `FlyObjective` comes next ➌, followed by the GA itself ➍. Executing
    the search takes one line of code ➎. When `Optimize` ends, it either has found
    a program that generates the target display or has run out of generations and
    abandons the search.
  prefs: []
  type: TYPE_NORMAL
- en: The results of the search are returned as a Python dictionary ➏. The list of
    successively more fit programs is in `res["gpos"]`, meaning the last element of
    the list is the best program found. We convert the best position to Firefly code,
    run the program, and grab the display generated to print it at the console along
    with the program itself. We also print where the firefly is when the program ends.
    We’ll use this last bit of information in the next section when we piece displays
    together to make animations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Evolving Firefly Programs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s evolve some code. We’ll begin by animating two displays to create a flashing
    warning sign. Next, we’ll animate a radar sweep, complete with a “beep.” Lastly,
    we’ll animate a bouncing ball of sorts. For each example, we’ll evolve the necessary
    displays and then piece them together using double buffering to produce the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Warning Sign***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The flashing warning sign consists of two displays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These displays are stored in *flash0.txt* and *flash1.txt*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first display, we search with *fly_swarm.py* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This means the target display is in *flash0.txt*. We want a population of 30
    programs, each with 60 instructions, and we’ll stop after 1,000,000 generations,
    or earlier if a program is found.
  prefs: []
  type: TYPE_NORMAL
- en: My run took about an hour and fifteen minutes to produce
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s interpret the output. First, we’re told the MSE was 0\. Excellent! We
    found a program that produces the exact display we need. Next comes the Firefly
    code. If you run this program with the console interpreter, perhaps adding `H`
    at the end to halt instead of loop, you’ll get the target display in *flash0.txt*.
    We’re told the firefly is at location (4,2) when the program ends. We’ll use this
    information to move the firefly back to position (2,2).
  prefs: []
  type: TYPE_NORMAL
- en: The final line of the output tells us about the search itself. Of the 1 million
    generations we set as the upper limit, 939,087 of them were used to find the program.
    During that time, 28,172,640 programs were tested, resulting in 49 updates to
    the best program found. No one ever said evolution was fast!
  prefs: []
  type: TYPE_NORMAL
- en: We now have the code for the first display. Searching for the second display
    produces
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, a program delivering the exact display was found, meaning MSE was 0\.
    However, this run found the program after only 22,431 generations and ran for
    less than two minutes. Sometimes evolution can be fast after all.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pause briefly to consider what the results above represent. We told `GA`
    to search for a program with 60 instructions that results in the display we want.
    How many possible 60-instruction tiny Firefly programs are there? The interpreter
    understands 17 instructions. Therefore, there are
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0442.jpg)'
  prefs: []
  type: TYPE_IMG
- en: possible 60-instruction tiny Firefly programs, which is a number so large it
    loses meaning. Did `GA` really find the *one* 60-instruction program that generates
    the target display? No. There are a vast number of 60-instruction Firefly programs
    resulting in the same display, and any one of them fits the bill. How many are
    there? That’s a good question—I have no intuition as to the answer or how to calculate
    it. I expect the number is many orders of magnitude greater than 1, especially
    if a suitable example was found quickly on the second run.
  prefs: []
  type: TYPE_NORMAL
- en: When developing this example, I noticed that the more complex the display, the
    longer the searches took—and the more often they failed—even though many were
    close and only off by one or two intensity values in a few places. This result
    is reasonable. If you try evolving your own displays, which I highly encourage,
    make them simpler instead of complicated to increase your chances of finding a
    suitable program in a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on now and use the code that cost so very many CPU cycles to find.
    The “Dance Dance” animation of [Chapter 15](ch15.xhtml#ch15) presented the code
    pattern we need to animate displays. We have two here, so we’ll show grid B, draw
    the first display on grid A, flip to show grid A, and draw the second on grid
    B before looping. To use the display code via cut-and-paste, we’ll make use of
    the firefly location information reported above to move the firefly to (2,2) before
    starting to draw the next display.
  prefs: []
  type: TYPE_NORMAL
- en: For example, *flash0.txt* ends with the firefly at position (4,2). Therefore,
    we move it back to (2,2) with `MNN`. Now we can run the code for *flash1.txt*.
    Likewise, that code ends with the firefly at (3,3), so we move back to (2,2) with
    `MNW`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing A-5](app01.xhtml#ch0Alist5) contains the full Firefly code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-5: Animating the flash displays*'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the above code with the console interpreter, it will oscillate at
    a very high rate; however, you can slow it down by putting `PPP` after `MNW` and
    `MNN`. For the micro:bit, no pause instructions are needed; see the video on the
    GitHub site.
  prefs: []
  type: TYPE_NORMAL
- en: '***Radar Sweep***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our next example is quite a bit simpler in terms of displays. We want to make
    a radar display, one with a rotating “sweep” and a beep when a “target” is present.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need eight displays for the sweep:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0443-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you look across the displays from left to right and top to bottom, you’ll
    see the sweep make a full revolution. The fourth display has a target at (0,1).
    We’ll add a “beep” for the target when the displays are animated.
  prefs: []
  type: TYPE_NORMAL
- en: The displays themselves are in the *GP/radar* directory as *radar0.txt* through
    *radar7.txt*. To evolve the displays, execute the *search_radar* shell script
    using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The script is a collection of individual runs of *fly_swarm* to evolve 40-instruction
    Firefly programs that produce the eight displays above. Each run uses a population
    of 30 programs and searches for up to 500,000 generations.
  prefs: []
  type: TYPE_NORMAL
- en: If a display fails, meaning the MSE reported in the results file is not 0, just
    try that one again manually. I needed to run the *radar3.txt* display twice. The
    first run did not find a program that included the target at (0,1). The second
    run did and only needed 18 seconds to find it.
  prefs: []
  type: TYPE_NORMAL
- en: With the display programs located, piecing together the full code is an exercise
    in following the animation pattern from *flash.fly*, where grid B is shown while
    the first display, *radar0.txt*, is drawn on grid A and then grid A is shown while
    *radar1.txt* is drawn on grid B, and so on through *radar7.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code is in [Listing A-6](app01.xhtml#ch0Alist6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-6: The radar sweep animation*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that your code will undoubtedly look different. Each time you evolve code
    for the displays, you’ll end up with a different program, as there are quite probably
    thousands to millions of 40-instruction Firefly programs that generate each configuration
    of the sweep. Don’t forget to add code to move the firefly back to (2,2) from
    its end position before starting the next display.
  prefs: []
  type: TYPE_NORMAL
- en: The beep occurs after *radar3.txt* is drawn and shown but before drawing *radar4.txt*.
    The beep plays with the firefly at (2,2) by setting the duration to 1 and playing
    note 7, a B above middle C (`1TJ7TF`).
  prefs: []
  type: TYPE_NORMAL
- en: '***Bouncing Ball***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our final example animates a ball moving in a figure-eight pattern. The screens
    are simple: a 2×2 square of intensity 5 LEDs in different positions to move a
    “ball” from the upper left to the lower right, then across the bottom of the display,
    up the lower-left-to-upper-right diagonal, and back across the top to the upper
    left before repeating—12 displays in all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0445-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The script *search_balls* in the *GP* directory performs the search for each
    display. The target displays are in the *ball* directory as *ball0.txt* through
    *ball11* *.txt*. In this case, we are searching for 30-instruction programs using
    a population of 30 individuals and up to 500,000 generations. The displays are
    simple enough that the searches are all successful, requiring an average of 966
    generations (minimum 239, maximum 2,010) per display.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing A-7](app01.xhtml#ch0Alist7) shows the full code including the 30-instruction
    sequence for each ball position.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-7: Animating a moving ball*'
  prefs: []
  type: TYPE_NORMAL
- en: The comment indicates where the sequence leaves the firefly. The move instructions
    on that line put the firefly back to (2,2) for the next display. No pause instructions
    are included to run as quickly as possible on the micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: For the console interpreter, add `PPPP` after each move of the firefly back
    to (2,2) to see the ball move.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples above demonstrate we can successfully evolve Firefly programs.
    In this section, we’ll take a closer look at just what is happening while the
    search is active by considering the initial and final populations. What do they
    look like? Next, we’ll take a look at a collection of successful searches. Are
    the programs found all similar? Lastly, while in general it isn’t usually possible
    to know what the shortest program for a task is for Firefly, we can in simple
    cases. Can genetic programming find the shortest program as well?
  prefs: []
  type: TYPE_NORMAL
- en: The files discussed in this section are found in the *GP/swarm_convergence*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '***Population Effects***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Genetic programming begins with a population of randomly generated programs.
    As the search progresses, new programs evolve while the size of the population
    remains fixed. What happens to the diversity of programs during the search? What
    does “diversity” even mean in this case?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine two searches, one for a program of 10 instructions and the other
    for 60 instructions. In both cases, we are trying to generate the display found
    in *ball/ball0.txt*, the medium intensity square in the upper left of the display.
    We’ll use a population of 30 programs and only consider a successful search, that
    is, one with an MSE of 0.
  prefs: []
  type: TYPE_NORMAL
- en: The file *swarm_10.txt* contains the best 10-instruction programs found, followed
    by the initial population of programs and then the final population. There are
    30 programs in the population, so there are 61 lines in *swarm_10.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: From this listing, it’s clear the initial population is quite different from
    the final population and that the latter is much like the best program found.
    How can we quantify this difference? One way is to measure the distance between
    the best program found and each of the initial and final population programs.
    The average distance should tell us something about the diversity of the programs
    in each population. What distance metric should we use? We could work with the
    programs as numeric vectors and calculate the distance for vectors in a 10D space.
    This is the *Euclidean distance*. However, using the Euclidean distance would
    require converting the program text to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to use the edit distance between the programs. The *edit
    distance* between two strings is how many letters must be changed to turn one
    string into the other. For example, the edit distance between “darwin” and “charles”
    is 5: we need five letters to turn “darwin” into “charles.” Similarly, the edit
    distance between “darwin” and “daniel” is 4, whereas the edit distance between
    “darwin” and “dorwin” is only 1—change the *a* to an *o*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the `editdistance` library to calculate edit distances in Python. It’s
    easily installed with `pip3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The closer the two strings are to each other, the shorter their edit distance.
    Let’s use this to calculate the average edit distance between the best program
    and the initial and final populations for *swarm_10.txt* and *swarm _60.txt*.
    The code we need is in *swarm_edit_distance.py*. See [Listing A-8](app01.xhtml#ch0Alist8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-8: The average edit distance between initial and final populations*'
  prefs: []
  type: TYPE_NORMAL
- en: The code loads *swarm_10.txt*, calculates the edit distance between the best
    program and each initial program, and then does the same with the final population
    of programs before reporting the average for both. It then repeats using *swarm_60.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the code in [Listing A-8](app01.xhtml#ch0Alist8) we get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that we divide the edit distance by the program length, either 10 or 60,
    to meaningfully compare between the different length programs. The number shown
    above is then a fraction of the program length regardless of the actual program
    length.
  prefs: []
  type: TYPE_NORMAL
- en: The initial populations are significantly more diverse than the final populations.
    For the 10-instruction program, the initial population is on average 92 percent
    different, meaning the difference between the initial set of programs and the
    best found is almost every instruction. However, the final population is on average
    only 10 percent, or one instruction, different from the best program. The population
    has collapsed, diversity has disappeared, and most programs are virtually identical
    to the best found. The collapse effect is even more pronounced for the 60-instruction
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: The results above examine what happens to the population during a single successful
    search. What if we run the search many times? Will we find the same best program
    each time? Let’s try it and see.
  prefs: []
  type: TYPE_NORMAL
- en: '***Final Program Diversity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Is the best program found by the search the same each time? To answer this question,
    let’s again search for programs generating the *ball0.txt* display. We’ll use
    10-instruction and 60-instruction programs, as above.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we run *fly_swarm.py* 10 times, keeping the best program found
    in *runs_10.txt* or *runs_60.txt*. Each run looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The best program found is put in *runs_10.txt*, one per line. Only successful
    searches, that is, those returning an MSE of 0, are kept. As the display is simple,
    most runs are successful.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the 10 best programs for 10 searches, we’ll calculate the average
    edit distance between the programs. If the search produces the same program each
    time, the average edit distance will be 0\. The higher the average edit distance,
    the more diverse the programs are, even though each program generates the desired
    display.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing A-9](app01.xhtml#ch0Alist9) shows what’s in *final_program_distance.py*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-9: The average distance between pairs of best programs found*'
  prefs: []
  type: TYPE_NORMAL
- en: This listing calculates the edit distance between each pair of best programs
    for both 10-instruction and 60-instruction programs. Naturally, the edit distance
    between a program and itself is 0, so we skip those cases. As above, the edit
    distance is divided by the program length to make it a fraction to allow meaningful
    comparison between the two.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing A-9](app01.xhtml#ch0Alist9) produces'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You’ll get slightly different results if you re-create *runs_10.txt* and *runs_60.txt*
    yourself. The output shows the average edit distance and the *standard error of
    the mean*, or *SE*. The SE is a measure of uncertainty in a mean or average value.
    For us, a small SE relative to the average indicates that the average is well
    known.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s interpret the values. For a 10-instruction program, we get an average
    difference of about 65 percent between the best programs found. Recall that each
    program is a successful program: each one generates the desired display. So even
    for short programs, there are multiple solutions, and different search runs find
    different possible solutions. Which solution is located depends on the population’s
    size, the random initial population, and random factors used in crossover and
    mutation.'
  prefs: []
  type: TYPE_NORMAL
- en: As we might suspect, longer programs have many more possible solutions. I suspect
    this is mainly because of “junk” code; that is, code that doesn’t help or hurt
    because the rest of the code still generates the desired display. We see this,
    as the average distance between successful 60-instruction programs is about 83
    percent. The programs all solve the problem, but they are very different from
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s search for 1,000 10-instruction programs to generate *ball0.txt* and see
    how many of them are unique. The code we’ll run is in *ball_search.py*. The code
    dumps the programs to the file *ball_search_results.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit of processing on the output file tells us how many unique 10-instruction
    programs were generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that we turn the list of 10-instruction programs into a set, thereby removing
    duplicates, before asking for the number of items.
  prefs: []
  type: TYPE_NORMAL
- en: Of the 1,000 successful runs looking for a 10-instruction program to generate
    *ball0.txt*, 985, or 98.5 percent, of them are unique. In other words, there are
    virtually no duplicates. This is strong support for our belief that there are
    many possible solutions to any display we care to generate.
  prefs: []
  type: TYPE_NORMAL
- en: '***Can Genetic Programming Find the Shortest Program?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We usually don’t know what the shortest program is to accomplish a given goal.
    However, for Firefly displays, at least the simple ones, we can know. Let’s continue
    working with the *ball0.txt* display.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the display, knowing the firefly starts in move mode at position
    (2,2), we can easily convince ourselves that the shortest possible program to
    generate the display has seven instructions. There are multiple seven-instruction
    programs, but no program with six or fewer instructions can create the display.
    Can genetic programming find these shortest programs? Let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: A command line like the following searches for a seven-instruction Firefly program
    generating the *ball0.txt* display.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The search terminates after 16,000 generations if no program leading to the
    display is found. We’ll consider those cases to be failures.
  prefs: []
  type: TYPE_NORMAL
- en: Running 10 searches by hand leads to seven successes and three failures. The
    seven successful programs, sorted alphabetically, are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the same program, `NW5WNEE`, shows up three of the seven times.
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer our first question: yes, genetic programming can find the shortest
    program to generate the display. We also have a hint that one of the programs
    might be more likely to show up than the others. However, 10 runs are too few
    to make any definitive statements about how often a solution appears.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s repeat the search we did in the previous section and gather 1,000 successful
    seven-instruction programs to see how often each solution appears (see *ball_search_7.py*).
    The space of possible seven-instruction programs is smaller than the space of
    10-instruction programs, so we do expect a distribution over a finite set of solutions
    that we might fully enumerate with even 1,000 trials.
  prefs: []
  type: TYPE_NORMAL
- en: The output of *ball_search_7.py* is in *ball_search_7_results.txt*, which contains
    the best program found for each of the 1,000 successful searches. If we load the
    results into Python and pass them to NumPy’s `np.unique` function, we’ll get back
    the list of unique best programs and how many times each one appeared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We see that there are 16 possible seven-instruction programs leading to the
    *ball0.txt* display. Each program begins with either `NW5` or `WN5`. This makes
    sense, as the program needs to set four positions to intensity 5, and the shortest
    way to get to the nearest ball position is to go north and then west or west and
    then north. The final four instructions enumerate the ways to move over the four
    upper-left display positions.
  prefs: []
  type: TYPE_NORMAL
- en: What about the counts? The results show the counts for each outcome over 1,000
    searches. We have no strong reason to expect that any of the possible outcomes
    is to be favored over any of the others; therefore, we expect the counts to be
    the same in the long run. The counts are not the same, but they might still be
    consistent with a distribution where each output program is equally likely. How
    can we test if this is true?
  prefs: []
  type: TYPE_NORMAL
- en: In statistics, a way to test if a set of frequencies is consistent with each
    being equally likely is to use a *χ*² (chi-square) test. We want to test the observed
    frequencies, that is, the counts, against another set of expected frequencies,
    which is the set where each outcome is equally likely. We could write a bit of
    code to do this, but fortunately for us, SciPy already has what we need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The return value from `chisquare` that concerns us is the p-value of 0.76\.
    This number can be interpreted as how consistent the counts are with each outcome
    being equally likely. If the p-value is low, usually if it’s much less than 0.05,
    we might think that the outcomes are not all equally likely. In this case, the
    p-value of 0.76 implies there is no reason to believe that any outcome, any best
    seven-instruction program, is any more likely to be found by genetic programming
    than the others.
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway from this section is that genetic programming can find the smallest
    program and will find all possible such programs with enough runs of the search.
  prefs: []
  type: TYPE_NORMAL
- en: '**Final Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples of this appendix demonstrate the utility of genetic programming
    for evolving Firefly programs. Genetic programming is not widely discussed these
    days, but it has shown a slow and steady increase in scholarly publications over
    time, as [Figure A-1](app01.xhtml#ch0Afig1) illustrates. The plot shows the number
    of Google Scholar hits by year, matching the string “genetic programming.”
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/Afig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-1: Number of Google Scholar hits for “genetic programming” by year*'
  prefs: []
  type: TYPE_NORMAL
- en: We used a GA as the basis for our genetic programming searches; however, there
    are many other algorithms one might try instead. GA is an evolutionary algorithm,
    as it simulates evolution to some degree. Another powerful evolutionary algorithm
    is differential evolution. Beyond evolutionary algorithms are the myriad of swarm
    intelligence algorithms like particle swarm optimization.
  prefs: []
  type: TYPE_NORMAL
- en: When properly configured, the genetic programming searches above can use these
    algorithms in place of `GA` by importing them into *fly_swarm.py* and replacing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: with the desired algorithm. For example, to try differential evolution, import
    *DE.py* and use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Differential evolution and particle swarm optimization are in the *GP* directory.
    Give them a try, and let me know how it goes. Do the other algorithms work at
    all? If so, how do they compare to GA?
  prefs: []
  type: TYPE_NORMAL
