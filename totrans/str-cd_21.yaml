- en: '**GENETIC PROGRAMMING WITH FIREFLY**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**使用FIREFLY进行遗传编程**'
- en: '![Image](Images/common01.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: In [Chapter 15](ch15.xhtml#ch15), we explored the Firefly language with fun
    animations and music. In this appendix, we’ll use Firefly along with *genetic
    programming* to evolve displays we can then animate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch15.xhtml#ch15)中，我们通过有趣的动画和音乐探索了Firefly语言。在本附录中，我们将结合使用Firefly和*遗传编程*，以进化出可以动画化的显示效果。
- en: '**Introduction to Genetic Programming**'
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**遗传编程简介**'
- en: Genetic programming became widely known in the early 1990s. Genetic programming
    uses algorithms to create programs by mimicking biological evolution. Instead
    of manually writing the code to perform a task, genetic programming generates
    and runs a population of random programs to see how well they perform. Each program
    in the population is given a *fitness value*, often called an objective function
    value, which is used to decide which programs breed to create the next generation
    of programs. Breeding is accomplished via *crossover* between pairs of programs,
    which mixes the code of “parent” programs to produce a new “offspring” program.
    As in biological evolution, there is a small probability a program will undergo
    a random mutation. Random mutation drives evolution by inserting new “genes” into
    the population. Biological evolution is driven by other processes, like genetic
    drift, but we’ll keep things simple and rely on crossover between well-performing
    individuals and random mutation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传编程在1990年代初期广为人知。遗传编程通过模仿生物进化使用算法来创建程序。与其手动编写执行任务的代码，遗传编程通过生成并运行一组随机程序，来观察它们的表现如何。每个程序都会获得一个*适应度值*，通常称为目标函数值，用于决定哪些程序会交配以产生下一代程序。交配是通过程序对之间的*crossover*（交叉）完成的，交叉会混合“父母”程序的代码，从而生成新的“后代”程序。正如生物进化中一样，程序也有很小的概率发生随机突变。随机突变通过将新的“基因”插入到种群中来推动进化。生物进化还受到其他过程的驱动，如基因漂移，但为了简单起见，我们将依赖于表现良好的个体之间的交叉和随机突变。
- en: '**How Genetic Programming Works**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**遗传编程如何工作**'
- en: 'The general approach to genetic programming is as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传编程的通用方法如下：
- en: Create a population of randomly generated programs.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一组随机生成的程序。
- en: Run each program in the population and assign it a fitness value depending on
    how well it does at solving the desired task.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行种群中的每个程序，并根据其在解决目标任务中的表现赋予其适应度值。
- en: Create the next generation of programs by breeding (crossover) and mutation.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过交配（交叉）和突变创建下一代程序。
- en: Repeat from Step 2 until we either have a program that solves our task to our
    satisfaction or we give up.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第2步开始重复，直到我们得到一个能够令人满意地解决任务的程序，或者我们放弃。
- en: For us, the programs are Firefly code for generating LED displays. We’ll specify
    the display we’d like and let genetic programming evolve a program that creates
    that display (we hope!).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这些程序是用于生成LED显示的Firefly代码。我们将指定我们想要的显示效果，并让遗传编程进化出一个能生成该显示效果的程序（希望如此！）。
- en: Typically, using genetic programming is somewhat tricky because generating random
    computer code that actually runs is difficult. Likewise, mixing two programs to
    produce a new one is challenging due to syntax issues. However, we are fortunate,
    as Firefly is extremely simple. *Any* string of characters extracted from the
    allowed set of Firefly commands is a valid Firefly program, and will thus run
    without error.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用遗传编程有些棘手，因为生成实际运行的随机计算机代码是困难的。同样，由于语法问题，将两个程序混合生成一个新的程序也是具有挑战性的。然而，我们很幸运，因为Firefly非常简单。*任何*从允许的Firefly命令集中提取的字符字符串都是有效的Firefly程序，因此可以毫无错误地运行。
- en: Also, as we are seeking code to generate a particular display, we only need
    to consider Firefly instructions that manipulate the LEDs. Thus, we can dispense
    with double buffering, music, and random trails, as they are not reproducible.
    We only need instructions to move the firefly and set the mode.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们寻求的是生成特定显示效果的代码，我们只需要考虑能操作LED的Firefly指令。因此，我们可以省略双缓冲、音乐和随机轨迹，因为它们是不可重复的。我们只需要指令来移动萤火虫并设置模式。
- en: We are doing genetic programming, but we’ll implement the evolution portion
    via a *genetic algorithm*, or *GA*. A genetic algorithm is more general than genetic
    programming, but for our Firefly code, the GA works perfectly to implement genetic
    programming. We won’t dive into how the genetic algorithm code works. Rather,
    we’ll just use the algorithm and see its effects. However, GA isn’t all that complicated,
    so if you read through the code, you’ll see what it’s doing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在进行遗传编程，但我们将通过*遗传算法*（*GA*）实现进化部分。遗传算法比遗传编程更为通用，但对于我们的萤火虫代码，GA非常适合实现遗传编程。我们不会深入讲解遗传算法代码的工作原理，而是直接使用该算法并观察它的效果。然而，GA并不复杂，因此如果你阅读代码，会明白它在做什么。
- en: 'Therefore, to experiment with genetic programming and Firefly, we need the
    following pieces:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要尝试遗传编程和萤火虫，我们需要以下几个部分：
- en: Some way to define the display we want to create.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种定义我们想要创建的显示的方式。
- en: A stripped-down version of the Firefly interpreter that only processes move
    and mode commands.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简化版的萤火虫解释器，仅处理移动和模式命令。
- en: GA code to evolve a population of Firefly programs.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GA代码，用于演化一群萤火虫程序。
- en: Something to package the pieces together, run the search, and output the resulting
    code.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些将各部分组合在一起、运行搜索并输出结果代码的工具。
- en: Let’s build what we need, piece by piece. If you want to jump into the Python
    code now, read through *fly_swarm.py* in the *firefly/GP* directory. Note that
    the population evolved by genetic programming is sometimes referred to as a *swarm*,
    even though swarm is most often used in relation to *swarm intelligence* algorithms.
    We’ll use “population” and “swarm” interchangeably.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一点一点地构建所需的部分。如果你现在想跳入Python代码，可以查看*fly_swarm.py*文件，位于*firefly/GP*目录下。注意，通过遗传编程演化的种群有时被称为*群体*，尽管群体一词通常与*群体智能*算法相关。我们会将“种群”和“群体”交替使用。
- en: '**Defining Displays**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义显示**'
- en: The most straightforward part of this exercise is defining the display we want
    to generate. Firefly’s display is a 5×5 grid of LED intensities. Therefore, we’ll
    define target displays using a 5×5 array of numbers stored in a text file. For
    example, to specify a “ball” located in the upper-left corner of the display,
    create a text file containing
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习中最直接的部分是定义我们想要生成的显示。萤火虫的显示是一个5×5的LED亮度网格。因此，我们将使用一个存储在文本文件中的5×5数字数组来定义目标显示。例如，要指定一个位于显示屏左上角的“球”，可以创建一个包含以下内容的文本文件：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This puts a medium intensity (square) “ball” in the upper-left corner with all
    other LEDs off. The text file stores the intensities of the 5×5 array for the
    genetic programming code to use as a target. The more similar the display generated
    by a candidate program is to the target, the better.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将一个中等强度（方形）的“球”放置在左上角，其他所有LED都关闭。文本文件存储了5×5数组的亮度，用于遗传编程代码作为目标。候选程序生成的显示与目标显示越相似，程序就越好。
- en: '**A Tiny Firefly Interpreter**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一个小型萤火虫解释器**'
- en: We need a tiny interpreter supporting only the Firefly move and mode commands
    to run our programs. We’ll make this interpreter a Python class so we can instantiate
    it easily. The result is [Listing A-1](app01.xhtml#ch0Alist1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个只支持萤火虫移动和模式命令的小型解释器来运行我们的程序。我们将把这个解释器做成一个Python类，这样我们就可以轻松地实例化它。结果见[清单
    A-1](app01.xhtml#ch0Alist1)。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing A-1: A tiny Firefly interpreter*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 A-1：一个小型萤火虫解释器*'
- en: 'For each program in the population, we create a `Firefly` instance with the
    program passed in. Then the `Run` method executes the program and `GetDisplay`
    returns the resulting display. For example, this code loads the `Firefly` class
    and runs a program to move north three times:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于种群中的每个程序，我们都会创建一个`Firefly`实例，并传入程序。然后，`Run`方法执行程序，`GetDisplay`返回生成的显示。例如，下面的代码加载`Firefly`类并运行一个程序，使其向北移动三次：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ll compare the display returned by `GetDisplay` with our desired target to
    calculate the program’s fitness.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把`GetDisplay`返回的显示与我们期望的目标进行比较，以计算程序的适应度。
- en: The tiny Firefly interpreter accepts digits, the letters `M`, `I`, and `D`,
    and the cardinal directions as instructions. The interpreter runs the given program
    once, without looping, and ends, preserving the resulting display. As we’ll see,
    our GA runs thousands to millions of sample Firefly programs, searching for one
    that meets our needs. Each run uses an instance of the `Firefly` class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 小型萤火虫解释器接受数字、字母`M`、`I`、`D`和基本方向作为指令。解释器运行给定的程序一次，不进行循环，并结束，保留结果显示。正如我们将看到的，我们的GA会运行成千上万到百万个萤火虫程序，寻找满足需求的程序。每次运行都会使用一个`Firefly`类的实例。
- en: '**The Genetic Algorithm**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**遗传算法**'
- en: 'The `GA` class implements the GA. But we need to define a few things before
    we can use it. First, we need a mapping between the Firefly code we want and the
    vector of numbers the GA uses to represent an individual. Second, we need a class
    to bound the search. Third, we need a class to calculate the fitness value for
    an individual. A fitness value here is like a golf score: lower is better. If
    the score is 0, we can stop because we found a program that does exactly what
    we want.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`GA` 类实现了遗传算法。但在使用它之前，我们需要定义一些内容。首先，我们需要一个映射，将我们想要的 Firefly 代码与 GA 用来表示个体的数字向量之间建立关系。第二，我们需要一个类来限制搜索。第三，我们需要一个类来计算个体的适应度值。这里的适应度值就像高尔夫的得分：得分越低越好。如果得分为
    0，我们就可以停止，因为我们已经找到了一个完全符合要求的程序。'
- en: There are 17 instructions supported by our tiny Firefly interpreter. Thus, we’ll
    restrict the vectors used by the GA to [0,16] to ensure they contain integers.
    This lets us map a vector to a Firefly program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Firefly 解释器支持 17 条指令。因此，我们将限制 GA 使用的向量范围为 [0,16]，以确保它们包含整数。这使我们可以将一个向量映射到一个
    Firefly 程序。
- en: '[Listing A-2](app01.xhtml#ch0Alist2) defines `FlyBounds` as a subclass of `Bounds`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 A-2](app01.xhtml#ch0Alist2) 将 `FlyBounds` 定义为 `Bounds` 的子类。'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing A-2: A class for bounding the search*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 A-2：用于限制搜索的类*'
- en: '`Bounds` is a framework component used by the GA. What’s important for us is
    that the subclass defines the allowed range of values from 0 to 16 (`len(ALLOWED)-1`),
    with `ndim` being the number of instructions in the program (the dimensionality
    of the search space). The `Validate` method takes a member of the population,
    `p`, and makes it integer-valued by rounding to the nearest integer.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bounds` 是 GA 使用的一个框架组件。对我们来说重要的是，子类定义了从 0 到 16（`len(ALLOWED)-1`）的允许值范围，`ndim`
    是程序中的指令数量（即搜索空间的维度）。`Validate` 方法接受种群中的一个成员 `p`，并通过四舍五入将其转化为整数值。'
- en: The last thing we need is a class to measure a program’s fitness (see [Listing
    A-3](app01.xhtml#ch0Alist3)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一件事是一个用来衡量程序适应度的类（见 [列表 A-3](app01.xhtml#ch0Alist3)）。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing A-3: A class to measure fitness*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 A-3：用于衡量适应度的类*'
- en: Here, `target` is a 5×5 NumPy array representing the display we’re trying to
    evolve code to generate. The `Evaluate` method accepts a member of the population,
    converts it to actual Firefly code with `PositionToFirefly`, creates a Firefly
    interpreter, and then runs the code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`target` 是一个 5×5 的 NumPy 数组，表示我们试图通过进化代码生成的显示内容。`Evaluate` 方法接受种群中的一个成员，将其转换为实际的
    Firefly 代码（通过 `PositionToFirefly`），创建一个 Firefly 解释器，然后执行代码。
- en: The last line calculates the fitness of the program. The output is a 5×5 array,
    that is, the display. For fitness, we’ll use the *mean squared error*, or *MSE*.
    This is the average value of the squared per-element difference between the program’s
    display and the display we want to generate. The lower this value, the better
    the program is at creating the desired display. When the MSE is 0, the program
    has created the target display precisely, so we’ll stop searching when (if) that
    happens.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行计算程序的适应度。输出是一个 5×5 的数组，也就是显示内容。对于适应度，我们将使用 *均方误差*（*MSE*）。这是程序的显示与我们想要生成的显示之间的每个元素差异的平方的平均值。这个值越低，程序就越擅长生成我们想要的显示内容。当
    MSE 为 0 时，程序已经精确生成了目标显示，因此当（如果）这种情况发生时，我们将停止搜索。
- en: Using the square of the difference instead of the absolute value of the difference
    penalizes larger per-element differences more, which is what we want. We want
    to drive the population toward programs with smaller differences.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用差异的平方代替差异的绝对值，可以更大程度地惩罚每个元素之间的较大差异，这正是我们想要的。我们希望将种群引导到差异较小的程序上。
- en: '`PositionToFirefly` uses a one-to-one mapping between the integers in `p` and
    the characters in `ALLOWED` to return the program string.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`PositionToFirefly` 使用 `p` 中整数与 `ALLOWED` 中字符之间的一对一映射，返回程序字符串。'
- en: 'The GA relies on crossover and random mutation. Firefly programs are represented
    as vectors of numbers. To implement the crossover of two programs, *A* and *B*
    of length *N*, the GA selects a random index, *i*, in [0, *N –* 1]. The new offspring
    vector is *C* = *A*[: *i*] + *B*[*i* :], meaning the first *i* values of *A* followed
    by the last *N – i* values of *B*. Mutation is even simpler. A random index, *j*,
    is selected, and the value at that index is set to a random number, [0,16].'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'GA依赖于交叉和随机变异。萤火虫程序表示为数字向量。为了实现两个程序*A*和*B*长度为*N*的交叉，GA选择一个随机索引*i*，范围是[0, *N
    – 1]。新的后代向量是*C* = *A*[: *i*] + *B*[*i* :]，意味着*A*的前*i*个值，后接*B*的后*N – i*个值。变异则更简单。选择一个随机索引*j*，并将该索引处的值设为一个随机数，范围是[0,16]。'
- en: We now have what we need to use the `GA` class and search for Firefly programs.
    Let’s see how to do it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了使用`GA`类并搜索萤火虫程序的所有条件。让我们看看如何操作。
- en: '**Putting It All Together**'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将一切整合在一起**'
- en: '[Listing A-4](app01.xhtml#ch0Alist4) shows the `main` function of *fly_swarm.py*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表A-4](app01.xhtml#ch0Alist4)显示了*fly_swarm.py*的`main`函数。'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing A-4: The main function*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表A-4：主函数*'
- en: The command line is parsed to load the target display, the size of the population
    (`npart`), the length of each program (`ndim`), and the number of generations
    to evolve (`niter`) ➊.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行被解析以加载目标显示、种群大小（`npart`）、每个程序的长度（`ndim`）和演化的代数（`niter`） ➊。
- en: Next, we create instances of `FlyBounds` and `RandomInitializer`, an object
    used by the GA to randomly generate the initial population of programs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`FlyBounds`和`RandomInitializer`的实例，这些对象被GA用来随机生成程序的初始种群。
- en: An instance of `FlyObjective` comes next ➌, followed by the GA itself ➍. Executing
    the search takes one line of code ➎. When `Optimize` ends, it either has found
    a program that generates the target display or has run out of generations and
    abandons the search.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`FlyObjective`的一个实例 ➌，然后是GA本身 ➍。执行搜索只需要一行代码 ➎。当`Optimize`结束时，它要么找到了生成目标显示的程序，要么在运行完所有代数后放弃搜索。
- en: The results of the search are returned as a Python dictionary ➏. The list of
    successively more fit programs is in `res["gpos"]`, meaning the last element of
    the list is the best program found. We convert the best position to Firefly code,
    run the program, and grab the display generated to print it at the console along
    with the program itself. We also print where the firefly is when the program ends.
    We’ll use this last bit of information in the next section when we piece displays
    together to make animations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索的结果以Python字典的形式返回 ➏。成功度逐渐提升的程序列表存储在`res["gpos"]`中，这意味着列表的最后一个元素是找到的最佳程序。我们将最佳位置转换为萤火虫代码，运行程序，并获取生成的显示，打印它到控制台，同时显示程序本身。我们还会打印程序结束时萤火虫的位置。我们将在下一节中使用这些信息，将显示屏组合在一起制作动画。
- en: '**Evolving Firefly Programs**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**演化萤火虫程序**'
- en: Let’s evolve some code. We’ll begin by animating two displays to create a flashing
    warning sign. Next, we’ll animate a radar sweep, complete with a “beep.” Lastly,
    we’ll animate a bouncing ball of sorts. For each example, we’ll evolve the necessary
    displays and then piece them together using double buffering to produce the animation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来演化一些代码。首先，我们将动画化两个显示屏，创建一个闪烁的警告标志。接着，我们将动画化一个雷达扫描，并加入“滴滴”的声音效果。最后，我们将动画化一个弹跳的球。对于每个示例，我们将演化所需的显示屏，并使用双重缓冲将它们组合在一起以生成动画。
- en: '***Warning Sign***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***警告标志***'
- en: 'The flashing warning sign consists of two displays:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 闪烁的警告标志由两个显示屏组成：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These displays are stored in *flash0.txt* and *flash1.txt*, respectively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些显示屏分别存储在*flash0.txt*和*flash1.txt*中。
- en: 'For the first display, we search with *fly_swarm.py* as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个显示屏，我们使用*fly_swarm.py*进行如下搜索：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This means the target display is in *flash0.txt*. We want a population of 30
    programs, each with 60 instructions, and we’ll stop after 1,000,000 generations,
    or earlier if a program is found.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着目标显示位于*flash0.txt*中。我们希望有一个由30个程序组成的种群，每个程序包含60条指令，并且在1,000,000代后停止，或者如果找到程序则提前停止。
- en: My run took about an hour and fifteen minutes to produce
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我的运行大约花费了一个小时十五分钟才完成
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s interpret the output. First, we’re told the MSE was 0\. Excellent! We
    found a program that produces the exact display we need. Next comes the Firefly
    code. If you run this program with the console interpreter, perhaps adding `H`
    at the end to halt instead of loop, you’ll get the target display in *flash0.txt*.
    We’re told the firefly is at location (4,2) when the program ends. We’ll use this
    information to move the firefly back to position (2,2).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释一下输出结果。首先，我们看到MSE为0，太好了！我们找到了生成精确显示的程序。接下来是萤火虫代码。如果你使用控制台解释器运行这个程序，可以在末尾加上`H`来停止而不是循环，那么你就能得到*flash0.txt*中的目标显示。程序结束时，萤火虫位于(4,2)的位置。我们将利用这个信息把萤火虫移动回(2,2)的位置。
- en: The final line of the output tells us about the search itself. Of the 1 million
    generations we set as the upper limit, 939,087 of them were used to find the program.
    During that time, 28,172,640 programs were tested, resulting in 49 updates to
    the best program found. No one ever said evolution was fast!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后一行告诉我们关于搜索本身的信息。在我们设定的100万代的上限中，939,087代用于找到该程序。在此期间，测试了28,172,640个程序，最终对最好的程序进行了49次更新。没有人说过进化是迅速的！
- en: We now have the code for the first display. Searching for the second display
    produces
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了第一个显示的代码。搜索第二个显示时得到的结果是
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, a program delivering the exact display was found, meaning MSE was 0\.
    However, this run found the program after only 22,431 generations and ran for
    less than two minutes. Sometimes evolution can be fast after all.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个生成精确显示的程序找到了，意味着均方误差(MSE)为0。然而，这次运行只经过了22,431代，且运行时间不到两分钟。有时候，进化也能非常迅速。
- en: Let’s pause briefly to consider what the results above represent. We told `GA`
    to search for a program with 60 instructions that results in the display we want.
    How many possible 60-instruction tiny Firefly programs are there? The interpreter
    understands 17 instructions. Therefore, there are
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微停一下，思考一下上面的结果代表了什么。我们告诉`GA`搜索一个包含60条指令的程序，结果显示我们想要的目标显示。可能有多少个60指令的小型萤火虫程序呢？解释器理解17条指令。因此，总共有
- en: '![Image](Images/f0442.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0442.jpg)'
- en: possible 60-instruction tiny Firefly programs, which is a number so large it
    loses meaning. Did `GA` really find the *one* 60-instruction program that generates
    the target display? No. There are a vast number of 60-instruction Firefly programs
    resulting in the same display, and any one of them fits the bill. How many are
    there? That’s a good question—I have no intuition as to the answer or how to calculate
    it. I expect the number is many orders of magnitude greater than 1, especially
    if a suitable example was found quickly on the second run.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的60指令小型萤火虫程序，其数量之大几乎无法衡量。`GA`真的找到了生成目标显示的*唯一*60指令程序吗？不是的。有大量的60指令萤火虫程序会生成相同的显示，任何一个都符合要求。到底有多少个呢？这是个好问题——我完全没有直觉来回答这个问题，也不知道该怎么计算。我猜这个数字比1大很多个数量级，尤其是在第二次运行时，快速找到了合适的例子。
- en: When developing this example, I noticed that the more complex the display, the
    longer the searches took—and the more often they failed—even though many were
    close and only off by one or two intensity values in a few places. This result
    is reasonable. If you try evolving your own displays, which I highly encourage,
    make them simpler instead of complicated to increase your chances of finding a
    suitable program in a reasonable amount of time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发这个示例时，我注意到，显示越复杂，搜索所需的时间就越长——并且失败的概率也越高——尽管很多时候它们已经很接近，仅在几个地方的强度值相差一两点。这一结果是合理的。如果你尝试进化自己的显示（我强烈鼓励你这么做），最好将它们做得简单一些，而不是复杂，这样才能增加在合理时间内找到合适程序的机会。
- en: Let’s move on now and use the code that cost so very many CPU cycles to find.
    The “Dance Dance” animation of [Chapter 15](ch15.xhtml#ch15) presented the code
    pattern we need to animate displays. We have two here, so we’ll show grid B, draw
    the first display on grid A, flip to show grid A, and draw the second on grid
    B before looping. To use the display code via cut-and-paste, we’ll make use of
    the firefly location information reported above to move the firefly to (2,2) before
    starting to draw the next display.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续使用花费大量CPU周期找到的代码。[第15章](ch15.xhtml#ch15)的“Dance Dance”动画展示了我们需要的代码模式来实现动画显示。我们这里有两个网格，因此我们会先在网格A上绘制第一个显示，然后切换到网格A展示，再在网格B上绘制第二个显示，最后进行循环。为了通过剪切和粘贴来使用显示代码，我们将利用上面报告的萤火虫位置信息，在开始绘制下一个显示之前将萤火虫移动到(2,2)。
- en: For example, *flash0.txt* ends with the firefly at position (4,2). Therefore,
    we move it back to (2,2) with `MNN`. Now we can run the code for *flash1.txt*.
    Likewise, that code ends with the firefly at (3,3), so we move back to (2,2) with
    `MNW`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*flash0.txt*的结束位置是(4,2)。因此，我们通过`MNN`将其移回(2,2)。现在我们可以运行*flash1.txt*的代码。同样，那个代码的结束位置是(3,3)，所以我们通过`MNW`移回(2,2)。
- en: '[Listing A-5](app01.xhtml#ch0Alist5) contains the full Firefly code.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单A-5](app01.xhtml#ch0Alist5)包含完整的萤火虫代码。'
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing A-5: Animating the flash displays*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单A-5：动画闪光显示*'
- en: If you run the above code with the console interpreter, it will oscillate at
    a very high rate; however, you can slow it down by putting `PPP` after `MNW` and
    `MNN`. For the micro:bit, no pause instructions are needed; see the video on the
    GitHub site.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用控制台解释器运行上述代码，它会以非常高的速率振荡；然而，你可以通过在`MNW`和`MNN`后加上`PPP`来减慢速度。对于micro:bit，不需要暂停指令；请参阅GitHub网站上的视频。
- en: '***Radar Sweep***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***雷达扫描***'
- en: Our next example is quite a bit simpler in terms of displays. We want to make
    a radar display, one with a rotating “sweep” and a beep when a “target” is present.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的例子在显示方面要简单得多。我们想做一个雷达显示，带有旋转的“扫描”和当“目标”存在时的蜂鸣。
- en: 'We need eight displays for the sweep:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要八个显示来完成扫描：
- en: '![Image](Images/f0443-01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0443-01.jpg)'
- en: If you look across the displays from left to right and top to bottom, you’ll
    see the sweep make a full revolution. The fourth display has a target at (0,1).
    We’ll add a “beep” for the target when the displays are animated.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从左到右、从上到下查看这些显示，你会看到扫描完成一整圈。第四个显示中有一个目标位于(0,1)。我们将在显示动画时为目标添加一个“蜂鸣”。
- en: The displays themselves are in the *GP/radar* directory as *radar0.txt* through
    *radar7.txt*. To evolve the displays, execute the *search_radar* shell script
    using
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 显示本身位于*GP/radar*目录下，从*radar0.txt*到*radar7.txt*。要演化这些显示，请使用*search_radar* shell脚本执行
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The script is a collection of individual runs of *fly_swarm* to evolve 40-instruction
    Firefly programs that produce the eight displays above. Each run uses a population
    of 30 programs and searches for up to 500,000 generations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是多个*fly_swarm*运行的集合，用于演化40指令的萤火虫程序，生成上述八个显示。每次运行使用30个程序的种群，并搜索最多500,000代。
- en: If a display fails, meaning the MSE reported in the results file is not 0, just
    try that one again manually. I needed to run the *radar3.txt* display twice. The
    first run did not find a program that included the target at (0,1). The second
    run did and only needed 18 seconds to find it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个显示失败，意味着结果文件中报告的MSE不为0，只需手动重新尝试那次。我需要运行*radar3.txt*显示两次。第一次运行没有找到包含(0,1)处目标的程序。第二次运行找到了，并且只用了18秒钟。
- en: With the display programs located, piecing together the full code is an exercise
    in following the animation pattern from *flash.fly*, where grid B is shown while
    the first display, *radar0.txt*, is drawn on grid A and then grid A is shown while
    *radar1.txt* is drawn on grid B, and so on through *radar7.txt*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 找到显示程序后，将完整代码拼接起来的过程，就是按照*flash.fly*中的动画模式操作，其中网格B在第一个显示*radar0.txt*绘制在网格A上时显示，然后网格A在*radar1.txt*绘制在网格B上时显示，以此类推，直到*radar7.txt*。
- en: The complete code is in [Listing A-6](app01.xhtml#ch0Alist6).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码见[清单A-6](app01.xhtml#ch0Alist6)。
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing A-6: The radar sweep animation*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单A-6：雷达扫描动画*'
- en: Note that your code will undoubtedly look different. Each time you evolve code
    for the displays, you’ll end up with a different program, as there are quite probably
    thousands to millions of 40-instruction Firefly programs that generate each configuration
    of the sweep. Don’t forget to add code to move the firefly back to (2,2) from
    its end position before starting the next display.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你的代码无疑会有所不同。每次你为显示演化代码时，你会得到不同的程序，因为很可能有成千上万甚至数百万个40指令的萤火虫程序可以生成每一种扫描配置。不要忘记在开始下一个显示前添加代码，将萤火虫从结束位置移动回(2,2)。
- en: The beep occurs after *radar3.txt* is drawn and shown but before drawing *radar4.txt*.
    The beep plays with the firefly at (2,2) by setting the duration to 1 and playing
    note 7, a B above middle C (`1TJ7TF`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制并展示*radar3.txt*之后，*radar4.txt*之前会发生蜂鸣。蜂鸣与位于(2,2)的萤火虫一起播放，通过将持续时间设置为1并播放音符7，即中音C上方的B音（`1TJ7TF`）。
- en: '***Bouncing Ball***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***弹跳球***'
- en: 'Our final example animates a ball moving in a figure-eight pattern. The screens
    are simple: a 2×2 square of intensity 5 LEDs in different positions to move a
    “ball” from the upper left to the lower right, then across the bottom of the display,
    up the lower-left-to-upper-right diagonal, and back across the top to the upper
    left before repeating—12 displays in all:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终示例展示了一个按8字形轨迹移动的球。屏幕非常简单：一个2×2的强度为5的LED方块，通过不同位置来移动一个“球”，从左上角到右下角，再到显示屏底部，沿着左下到右上的对角线向上，然后横跨顶部返回左上角，循环重复—共12个显示：
- en: '![Image](Images/f0445-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0445-01.jpg)'
- en: The script *search_balls* in the *GP* directory performs the search for each
    display. The target displays are in the *ball* directory as *ball0.txt* through
    *ball11* *.txt*. In this case, we are searching for 30-instruction programs using
    a population of 30 individuals and up to 500,000 generations. The displays are
    simple enough that the searches are all successful, requiring an average of 966
    generations (minimum 239, maximum 2,010) per display.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*GP*目录中的脚本*search_balls*执行每个显示的搜索。目标显示位于*ball*目录下，从*ball0.txt*到*ball11*.txt。在这个例子中，我们正在寻找30指令的程序，使用30个个体的种群，并最多进行500,000代搜索。由于显示足够简单，所有的搜索都成功，平均需要966代（最少239代，最多2,010代）每个显示。'
- en: '[Listing A-7](app01.xhtml#ch0Alist7) shows the full code including the 30-instruction
    sequence for each ball position.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表A-7](app01.xhtml#ch0Alist7)展示了包括每个球位置的30指令序列的完整代码。'
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing A-7: Animating a moving ball*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表A-7：动画移动的球*'
- en: The comment indicates where the sequence leaves the firefly. The move instructions
    on that line put the firefly back to (2,2) for the next display. No pause instructions
    are included to run as quickly as possible on the micro:bit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注释指出了序列离开萤火虫的位置。该行的移动指令将萤火虫移回到(2,2)，以便进行下一个显示。没有包括暂停指令，以便在micro:bit上尽可能快速地运行。
- en: For the console interpreter, add `PPPP` after each move of the firefly back
    to (2,2) to see the ball move.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于控制台解释器，在每次将萤火虫移动回(2,2)后，添加`PPPP`以查看球的移动。
- en: '**Discussion**'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: The examples above demonstrate we can successfully evolve Firefly programs.
    In this section, we’ll take a closer look at just what is happening while the
    search is active by considering the initial and final populations. What do they
    look like? Next, we’ll take a look at a collection of successful searches. Are
    the programs found all similar? Lastly, while in general it isn’t usually possible
    to know what the shortest program for a task is for Firefly, we can in simple
    cases. Can genetic programming find the shortest program as well?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了我们可以成功进化出萤火虫程序。在本节中，我们将更仔细地观察搜索活动中发生了什么，通过考虑初始种群和最终种群。它们看起来如何？接下来，我们将看看一组成功的搜索。找到的程序是否都相似？最后，虽然通常情况下我们不能知道萤火虫任务的最短程序是什么，但在简单的情况下我们可以。那么，遗传编程是否也能找到最短程序呢？
- en: The files discussed in this section are found in the *GP/swarm_convergence*
    directory.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的文件位于*GP/swarm_convergence*目录中。
- en: '***Population Effects***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***种群效应***'
- en: Genetic programming begins with a population of randomly generated programs.
    As the search progresses, new programs evolve while the size of the population
    remains fixed. What happens to the diversity of programs during the search? What
    does “diversity” even mean in this case?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传编程从一组随机生成的程序开始。随着搜索的进行，新程序会不断进化，而种群的大小保持不变。在搜索过程中，程序的多样性会发生什么变化？在这种情况下，“多样性”究竟意味着什么？
- en: Let’s examine two searches, one for a program of 10 instructions and the other
    for 60 instructions. In both cases, we are trying to generate the display found
    in *ball/ball0.txt*, the medium intensity square in the upper left of the display.
    We’ll use a population of 30 programs and only consider a successful search, that
    is, one with an MSE of 0.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个搜索，一个是10指令的程序，另一个是60指令的程序。在这两种情况下，我们都试图生成*ball/ball0.txt*中找到的显示，即显示左上角的中等强度的方块。我们将使用一个30个程序的种群，并只考虑成功的搜索，也就是说，均方误差（MSE）为0的搜索。
- en: The file *swarm_10.txt* contains the best 10-instruction programs found, followed
    by the initial population of programs and then the final population. There are
    30 programs in the population, so there are 61 lines in *swarm_10.txt*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*swarm_10.txt*包含找到的最佳10指令程序，接下来是初始种群的程序，再后面是最终种群。种群中有30个程序，因此*swarm_10.txt*中共有61行。
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From this listing, it’s clear the initial population is quite different from
    the final population and that the latter is much like the best program found.
    How can we quantify this difference? One way is to measure the distance between
    the best program found and each of the initial and final population programs.
    The average distance should tell us something about the diversity of the programs
    in each population. What distance metric should we use? We could work with the
    programs as numeric vectors and calculate the distance for vectors in a 10D space.
    This is the *Euclidean distance*. However, using the Euclidean distance would
    require converting the program text to numbers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个清单可以看出，初始种群与最终种群之间的差异相当大，且后者与找到的最佳程序非常相似。我们如何量化这种差异呢？一种方法是测量找到的最佳程序与每个初始和最终种群程序之间的距离。平均距离应该能告诉我们每个种群中程序的多样性。我们应该使用什么样的距离度量呢？我们可以将程序作为数值向量处理，并计算在10维空间中的向量之间的距离。这就是*欧几里得距离*。然而，使用欧几里得距离需要将程序文本转换为数字。
- en: 'Another option is to use the edit distance between the programs. The *edit
    distance* between two strings is how many letters must be changed to turn one
    string into the other. For example, the edit distance between “darwin” and “charles”
    is 5: we need five letters to turn “darwin” into “charles.” Similarly, the edit
    distance between “darwin” and “daniel” is 4, whereas the edit distance between
    “darwin” and “dorwin” is only 1—change the *a* to an *o*.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用程序之间的编辑距离。两个字符串之间的*编辑距离*是将一个字符串转化为另一个字符串时需要更改的字母数。例如，“darwin”和“charles”之间的编辑距离是5：我们需要五个字母将“darwin”转变为“charles”。类似地，“darwin”和“daniel”之间的编辑距离是4，而“darwin”和“dorwin”之间的编辑距离只有1——只需将*a*改为*o*。
- en: 'We need the `editdistance` library to calculate edit distances in Python. It’s
    easily installed with `pip3`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`editdistance`库来计算Python中的编辑距离。可以通过`pip3`轻松安装：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can use it like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The closer the two strings are to each other, the shorter their edit distance.
    Let’s use this to calculate the average edit distance between the best program
    and the initial and final populations for *swarm_10.txt* and *swarm _60.txt*.
    The code we need is in *swarm_edit_distance.py*. See [Listing A-8](app01.xhtml#ch0Alist8).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字符串之间的距离越近，它们的编辑距离就越短。我们可以用它来计算*swarm_10.txt*和*swarm_60.txt*中最佳程序与初始和最终种群之间的平均编辑距离。我们需要的代码在*swarm_edit_distance.py*中。请参见[清单A-8](app01.xhtml#ch0Alist8)。
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing A-8: The average edit distance between initial and final populations*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单A-8：初始种群与最终种群之间的平均编辑距离*'
- en: The code loads *swarm_10.txt*, calculates the edit distance between the best
    program and each initial program, and then does the same with the final population
    of programs before reporting the average for both. It then repeats using *swarm_60.txt*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码加载*swarm_10.txt*，计算最佳程序与每个初始程序之间的编辑距离，然后对最终种群的程序执行相同的操作，并报告两个种群的平均编辑距离。接着，它会使用*swarm_60.txt*重复这一过程。
- en: If we run the code in [Listing A-8](app01.xhtml#ch0Alist8) we get
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行[清单A-8](app01.xhtml#ch0Alist8)中的代码，我们会得到
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we divide the edit distance by the program length, either 10 or 60,
    to meaningfully compare between the different length programs. The number shown
    above is then a fraction of the program length regardless of the actual program
    length.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将编辑距离除以程序长度（无论是10还是60），以便在不同长度的程序之间进行有意义的比较。上述显示的数字就是程序长度的一个比例，无论程序的实际长度是多少。
- en: The initial populations are significantly more diverse than the final populations.
    For the 10-instruction program, the initial population is on average 92 percent
    different, meaning the difference between the initial set of programs and the
    best found is almost every instruction. However, the final population is on average
    only 10 percent, or one instruction, different from the best program. The population
    has collapsed, diversity has disappeared, and most programs are virtually identical
    to the best found. The collapse effect is even more pronounced for the 60-instruction
    programs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 初始种群的多样性明显高于最终种群。对于10条指令的程序，初始种群的平均差异为92％，这意味着初始程序集与最佳程序之间的差异几乎是每条指令都有不同。然而，最终种群与最佳程序的平均差异只有10％，也就是只有一条指令不同。种群已经崩溃，多样性消失，大多数程序与最佳程序几乎相同。对于60条指令的程序，崩溃效应更加显著。
- en: The results above examine what happens to the population during a single successful
    search. What if we run the search many times? Will we find the same best program
    each time? Let’s try it and see.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结果考察了在单次成功搜索过程中种群发生了什么。如果我们多次运行搜索会怎样？我们每次都能找到相同的最佳程序吗？我们来试试看。
- en: '***Final Program Diversity***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最终程序多样性***'
- en: Is the best program found by the search the same each time? To answer this question,
    let’s again search for programs generating the *ball0.txt* display. We’ll use
    10-instruction and 60-instruction programs, as above.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索找到的最佳程序每次都相同吗？为了回答这个问题，我们再次搜索生成 *ball0.txt* 显示的程序。我们将使用 10 指令和 60 指令的程序，如上所示。
- en: 'To do this, we run *fly_swarm.py* 10 times, keeping the best program found
    in *runs_10.txt* or *runs_60.txt*. Each run looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们运行 *fly_swarm.py* 10 次，将每次找到的最优程序保存在 *runs_10.txt* 或 *runs_60.txt* 中。每次运行的过程如下：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The best program found is put in *runs_10.txt*, one per line. Only successful
    searches, that is, those returning an MSE of 0, are kept. As the display is simple,
    most runs are successful.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的程序保存在*run_10.txt*中，每行一个。只有成功的搜索，即返回 MSE 为 0 的搜索，才会被保留。由于显示简单，大多数运行都成功。
- en: Now that we have the 10 best programs for 10 searches, we’ll calculate the average
    edit distance between the programs. If the search produces the same program each
    time, the average edit distance will be 0\. The higher the average edit distance,
    the more diverse the programs are, even though each program generates the desired
    display.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 10 次搜索中最好的 10 个程序，我们将计算这些程序之间的平均编辑距离。如果每次搜索都生成相同的程序，那么平均编辑距离将是 0。平均编辑距离越高，程序的多样性越大，即使每个程序都能生成期望的显示效果。
- en: '[Listing A-9](app01.xhtml#ch0Alist9) shows what’s in *final_program_distance.py*.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 A-9](app01.xhtml#ch0Alist9) 展示了 *final_program_distance.py* 的内容。'
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing A-9: The average distance between pairs of best programs found*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 A-9：所找到的最佳程序对之间的平均距离*'
- en: This listing calculates the edit distance between each pair of best programs
    for both 10-instruction and 60-instruction programs. Naturally, the edit distance
    between a program and itself is 0, so we skip those cases. As above, the edit
    distance is divided by the program length to make it a fraction to allow meaningful
    comparison between the two.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此清单计算了 10 指令和 60 指令程序中每对最佳程序之间的编辑距离。自然地，程序与自身之间的编辑距离为 0，因此我们跳过这些情况。如上所述，编辑距离会被程序长度除以，得到一个分数，从而进行有意义的比较。
- en: '[Listing A-9](app01.xhtml#ch0Alist9) produces'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 A-9](app01.xhtml#ch0Alist9) 生成了'
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You’ll get slightly different results if you re-create *runs_10.txt* and *runs_60.txt*
    yourself. The output shows the average edit distance and the *standard error of
    the mean*, or *SE*. The SE is a measure of uncertainty in a mean or average value.
    For us, a small SE relative to the average indicates that the average is well
    known.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己重新创建 *runs_10.txt* 和 *runs_60.txt*，你将得到稍微不同的结果。输出显示了平均编辑距离和 *均值标准误差*，或
    *SE*。SE 是均值或平均值的不确定性度量。对于我们来说，相对于平均值的小 SE 表示这个平均值是比较准确的。
- en: 'Let’s interpret the values. For a 10-instruction program, we get an average
    difference of about 65 percent between the best programs found. Recall that each
    program is a successful program: each one generates the desired display. So even
    for short programs, there are multiple solutions, and different search runs find
    different possible solutions. Which solution is located depends on the population’s
    size, the random initial population, and random factors used in crossover and
    mutation.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解读这些值。对于一个 10 指令的程序，我们得到的最优程序之间的平均差异大约是 65%。回想一下，每个程序都是成功的程序：每个程序都能生成期望的显示效果。所以，即使是短程序，也存在多种解决方案，不同的搜索运行会找到不同的可能解。最终找到哪个解取决于种群的大小、随机的初始种群以及交叉和变异中使用的随机因素。
- en: As we might suspect, longer programs have many more possible solutions. I suspect
    this is mainly because of “junk” code; that is, code that doesn’t help or hurt
    because the rest of the code still generates the desired display. We see this,
    as the average distance between successful 60-instruction programs is about 83
    percent. The programs all solve the problem, but they are very different from
    each other.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可能猜测的那样，较长的程序有更多的可能解决方案。我猜这主要是由于“垃圾”代码；即那些既不有益也不有害的代码，因为其余的代码仍然能够生成期望的显示效果。我们可以看到，成功的
    60 指令程序之间的平均距离约为 83%。这些程序都能解决问题，但它们之间差异很大。
- en: Let’s search for 1,000 10-instruction programs to generate *ball0.txt* and see
    how many of them are unique. The code we’ll run is in *ball_search.py*. The code
    dumps the programs to the file *ball_search_results.txt*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们搜索1,000个10指令程序来生成*ball0.txt*，看看其中有多少是唯一的。我们将运行的代码在*ball_search.py*中。代码将程序转储到*ball_search_results.txt*文件中。
- en: 'A bit of processing on the output file tells us how many unique 10-instruction
    programs were generated:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对输出文件进行一些处理，可以告诉我们生成了多少个唯一的10指令程序：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we turn the list of 10-instruction programs into a set, thereby removing
    duplicates, before asking for the number of items.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将10指令程序的列表转换为集合，从而去除了重复项，然后再请求项目的数量。
- en: Of the 1,000 successful runs looking for a 10-instruction program to generate
    *ball0.txt*, 985, or 98.5 percent, of them are unique. In other words, there are
    virtually no duplicates. This is strong support for our belief that there are
    many possible solutions to any display we care to generate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在1,000次成功的运行中，寻找生成*ball0.txt*的10指令程序，其中985次（即98.5%）是唯一的。换句话说，几乎没有重复。这强烈支持我们关于任何我们想生成的显示都有许多可能解决方案的信念。
- en: '***Can Genetic Programming Find the Shortest Program?***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***遗传编程能找到最短的程序吗？***'
- en: We usually don’t know what the shortest program is to accomplish a given goal.
    However, for Firefly displays, at least the simple ones, we can know. Let’s continue
    working with the *ball0.txt* display.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不知道完成给定目标的最短程序是什么。然而，对于萤火虫显示器，至少在简单的情况下，我们是可以知道的。让我们继续处理*ball0.txt*显示器。
- en: If we look at the display, knowing the firefly starts in move mode at position
    (2,2), we can easily convince ourselves that the shortest possible program to
    generate the display has seven instructions. There are multiple seven-instruction
    programs, but no program with six or fewer instructions can create the display.
    Can genetic programming find these shortest programs? Let’s find out.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看显示，知道萤火虫从位置(2,2)的移动模式开始，我们可以轻松地确信，生成此显示的最短程序包含七条指令。有多个七指令程序，但没有一个包含六条或更少指令的程序可以生成该显示。遗传编程能找到这些最短程序吗？让我们来找找看。
- en: A command line like the following searches for a seven-instruction Firefly program
    generating the *ball0.txt* display.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如下的命令行可以搜索生成*ball0.txt*显示的七指令萤火虫程序。
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The search terminates after 16,000 generations if no program leading to the
    display is found. We’ll consider those cases to be failures.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在16,000代内没有找到能生成显示的程序，搜索将终止。我们将这些情况视为失败。
- en: Running 10 searches by hand leads to seven successes and three failures. The
    seven successful programs, sorted alphabetically, are
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 手动运行10次搜索得到了7次成功和3次失败。7个成功的程序按字母顺序排列如下：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that the same program, `NW5WNEE`, shows up three of the seven times.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，同一个程序`NW5WNEE`出现了三次中的三次。
- en: 'To answer our first question: yes, genetic programming can find the shortest
    program to generate the display. We also have a hint that one of the programs
    might be more likely to show up than the others. However, 10 runs are too few
    to make any definitive statements about how often a solution appears.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答我们的第一个问题：是的，遗传编程可以找到生成该显示的最短程序。我们还有一个线索，可能某些程序比其他程序更可能出现。然而，10次运行太少，无法就解决方案出现的频率做出任何确定的声明。
- en: Let’s repeat the search we did in the previous section and gather 1,000 successful
    seven-instruction programs to see how often each solution appears (see *ball_search_7.py*).
    The space of possible seven-instruction programs is smaller than the space of
    10-instruction programs, so we do expect a distribution over a finite set of solutions
    that we might fully enumerate with even 1,000 trials.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复上一节中的搜索，并收集1,000个成功的七指令程序，看看每个解决方案出现的频率（见*ball_search_7.py*）。七指令程序的可能空间小于十指令程序的空间，因此我们确实预期会有一个有限解集的分布，甚至通过1,000次试验我们也能完全列举出来。
- en: The output of *ball_search_7.py* is in *ball_search_7_results.txt*, which contains
    the best program found for each of the 1,000 successful searches. If we load the
    results into Python and pass them to NumPy’s `np.unique` function, we’ll get back
    the list of unique best programs and how many times each one appeared.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*ball_search_7.py*的输出保存在*ball_search_7_results.txt*中，其中包含每次1,000次成功搜索中找到的最佳程序。如果我们将结果加载到Python中，并传递给NumPy的`np.unique`函数，我们将得到唯一最佳程序的列表，以及每个程序出现的次数。'
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We see that there are 16 possible seven-instruction programs leading to the
    *ball0.txt* display. Each program begins with either `NW5` or `WN5`. This makes
    sense, as the program needs to set four positions to intensity 5, and the shortest
    way to get to the nearest ball position is to go north and then west or west and
    then north. The final four instructions enumerate the ways to move over the four
    upper-left display positions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到有16个可能的七条指令程序能导致*ball0.txt*显示。每个程序都以`NW5`或`WN5`开始。这是有道理的，因为程序需要将四个位置设置为强度5，而到达最近的球位置的最短方式是先向北然后向西，或者先向西然后向北。最后四条指令列举了如何移动到四个左上角的显示位置。
- en: What about the counts? The results show the counts for each outcome over 1,000
    searches. We have no strong reason to expect that any of the possible outcomes
    is to be favored over any of the others; therefore, we expect the counts to be
    the same in the long run. The counts are not the same, but they might still be
    consistent with a distribution where each output program is equally likely. How
    can we test if this is true?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 那么计数如何呢？结果显示了在1,000次搜索中每个结果的计数。我们没有强烈的理由认为任何一个可能的结果会比其他结果更有优势；因此，我们预期从长远来看，计数应该是相同的。计数虽然不同，但它们可能仍然与每个输出程序都有相等可能性的分布一致。我们如何测试这一点是否成立？
- en: In statistics, a way to test if a set of frequencies is consistent with each
    being equally likely is to use a *χ*² (chi-square) test. We want to test the observed
    frequencies, that is, the counts, against another set of expected frequencies,
    which is the set where each outcome is equally likely. We could write a bit of
    code to do this, but fortunately for us, SciPy already has what we need.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，测试一组频率是否与每个频率相等的可能性一致的方法是使用*χ*²（卡方）检验。我们想要将观察到的频率，即计数，与另一组期望频率进行比较，期望频率是每个结果的可能性相等的集合。我们可以编写一些代码来完成这项工作，但幸运的是，SciPy已经提供了我们所需要的工具。
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The return value from `chisquare` that concerns us is the p-value of 0.76\.
    This number can be interpreted as how consistent the counts are with each outcome
    being equally likely. If the p-value is low, usually if it’s much less than 0.05,
    we might think that the outcomes are not all equally likely. In this case, the
    p-value of 0.76 implies there is no reason to believe that any outcome, any best
    seven-instruction program, is any more likely to be found by genetic programming
    than the others.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心的`chisquare`返回值是p值0.76。这个数字可以解释为计数与每个结果都有相等可能性的程度。如果p值较低，通常是远小于0.05，我们可能认为结果并非都是同样可能的。在这种情况下，p值0.76意味着没有理由相信任何一个结果，任何最佳的七条指令程序，比其他程序更可能通过遗传编程找到。
- en: The takeaway from this section is that genetic programming can find the smallest
    program and will find all possible such programs with enough runs of the search.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的要点是，遗传编程能够找到最小的程序，并且只要进行足够的搜索，它将找到所有可能的这样的程序。
- en: '**Final Thoughts**'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最终思考**'
- en: The examples of this appendix demonstrate the utility of genetic programming
    for evolving Firefly programs. Genetic programming is not widely discussed these
    days, but it has shown a slow and steady increase in scholarly publications over
    time, as [Figure A-1](app01.xhtml#ch0Afig1) illustrates. The plot shows the number
    of Google Scholar hits by year, matching the string “genetic programming.”
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录的示例展示了遗传编程在进化萤火虫程序中的实用性。虽然遗传编程如今不再广泛讨论，但随着时间的推移，它在学术出版物中的数量呈现出缓慢而稳定的增长，正如[图A-1](app01.xhtml#ch0Afig1)所示。该图展示了按年份统计的“遗传编程”在谷歌学术中的检索次数。
- en: '![Image](Images/Afig01.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/Afig01.jpg)'
- en: '*Figure A-1: Number of Google Scholar hits for “genetic programming” by year*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A-1：每年“遗传编程”在谷歌学术的检索次数*'
- en: We used a GA as the basis for our genetic programming searches; however, there
    are many other algorithms one might try instead. GA is an evolutionary algorithm,
    as it simulates evolution to some degree. Another powerful evolutionary algorithm
    is differential evolution. Beyond evolutionary algorithms are the myriad of swarm
    intelligence algorithms like particle swarm optimization.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了GA作为遗传编程搜索的基础；然而，也有许多其他算法可以尝试替代它。GA是一种进化算法，因为它在某种程度上模拟了进化。另一个强大的进化算法是差分进化。除了进化算法之外，还有各种各样的群体智能算法，如粒子群优化。
- en: When properly configured, the genetic programming searches above can use these
    algorithms in place of `GA` by importing them into *fly_swarm.py* and replacing
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置正确时，上述遗传编程搜索可以通过将这些算法导入*fly_swarm.py*并进行替换，来取代`GA`。
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: with the desired algorithm. For example, to try differential evolution, import
    *DE.py* and use
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所需的算法。例如，若要尝试差分进化，导入*DE.py*并使用
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Differential evolution and particle swarm optimization are in the *GP* directory.
    Give them a try, and let me know how it goes. Do the other algorithms work at
    all? If so, how do they compare to GA?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 差分进化和粒子群优化位于*GP*目录中。试试看，并告诉我结果如何。其他算法完全有效吗？如果是，它们与遗传算法相比如何？
