- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">GETTING
    DATA IN AND OUT WITH I/O AND SERDES</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">通过I/O和SERDES进出数据</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Throughout this book, we’ve focused on the internals of FPGAs, and that’s typical
    of the FPGA design process. FPGA design largely centers around writing Verilog
    or VHDL code targeting internal components like flip-flops, LUTs, block RAMs,
    and DSP blocks. But what’s going on at the edge of the device, where data enters
    and exits the FPGA?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书一直专注于FPGA的内部结构，这也是FPGA设计过程中的典型情况。FPGA设计主要围绕编写面向内部组件（如触发器、查找表（LUTs）、块RAM和DSP块）的Verilog或VHDL代码。但设备边缘发生了什么呢？数据是如何进出FPGA的？
- en: There’s a surprising amount of complexity involved in getting data into and
    out of an FPGA. In my experience, this is where most of the trickier FPGA design
    problems occur. Understanding how the *input/output (I/O)* works will help you
    tackle those problems. You’ll be able to spend less time worrying about external
    interfaces, and more time solving the internal task at hand.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据输入和输出到FPGA涉及的复杂性超乎想象。根据我的经验，这也是大多数棘手的FPGA设计问题出现的地方。理解*输入/输出 (I/O)*的工作原理将帮助你解决这些问题。你将能够花更少的时间担心外部接口，更多的时间解决内部任务。
- en: Working with I/O is where the boundary between being a “software person” and
    a “hardware person” lies. You need to understand the details of the electrical
    signals that you’re interfacing to in order to configure the FPGA pins correctly.
    What voltage do they operate at? Are the signals single-ended or differential?
    (And what does that even mean?) How can you use double data rate or a serializer/deserializer
    to send data at very high speeds? This chapter answers these questions and more.
    Even if you don’t have an electrical engineering background, you’ll learn the
    fundamentals of interfacing FPGAs to the outside world.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用I/O是“软件人员”和“硬件人员”之间的分界线。你需要了解你正在接口的电信号的细节，以便正确配置FPGA引脚。它们在什么电压下工作？信号是单端还是差分的？（那到底意味着什么？）你如何使用双倍数据速率或串行/解串行器以非常高的速度发送数据？本章将回答这些问题以及更多内容。即使你没有电气工程背景，也会学到将FPGA与外部世界连接的基础知识。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with GPIO Pins</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用GPIO引脚</samp>
- en: Most pins on the FPGA are *general purpose input/output (GPIO)* pins, meaning
    they can function as a digital input or output. We’ve used these pins in the book’s
    projects to take in signals from push buttons and output signals to light up LEDs,
    but we haven’t worried about the details of how this actually works. In this section,
    we’ll look at how GPIO pins interface with an FPGA and how they can be made to
    input data, output data, or both.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA上的大多数引脚是*通用输入输出（GPIO）*引脚，意味着它们可以作为数字输入或输出。我们在本书的项目中使用了这些引脚来接收来自按钮的信号，并输出信号点亮LED，但我们并未关注它们实际如何工作的细节。在这一节中，我们将探讨GPIO引脚如何与FPGA接口，以及如何将它们配置为输入数据、输出数据或两者兼有。
- en: When I was first getting into FPGA design, I had no idea of the nuances involved
    in pin configuration. There are many knobs to turn and settings to play with.
    Having a thorough understanding of your GPIO pins is important, especially for
    high-speed designs, because maintaining signal integrity and performance throughout
    your design starts at the pins.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我刚开始接触FPGA设计时，我完全不了解引脚配置中的细微差别。这里有许多需要调整的参数和设置。彻底理解你的GPIO引脚非常重要，尤其是在高速设计中，因为在整个设计中保持信号完整性和性能始于引脚。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">I/O Buffers</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">I/O缓冲器</samp>
- en: GPIO pins interface with an FPGA through *buffers*, electronic circuit elements
    that isolate their input from their output. These buffers are what allow you to
    configure some pins as inputs and others as outputs. As you’ll see soon, they
    even allow you to toggle a pin between input and output while the FPGA is running.
    [Figure 11-1](#fig11-1) shows a simplified block diagram of a GPIO pin interface
    on an Intel FPGA, to illustrate how a buffer serves as an intermediary between
    the pin and the internal FPGA logic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO引脚通过*缓冲器*与FPGA接口，缓冲器是电子电路元件，用于将输入与输出隔离。这些缓冲器使得你可以将一些引脚配置为输入，而另一些配置为输出。正如你很快会看到的，它们甚至允许你在FPGA运行时将引脚在输入和输出之间切换。[图11-1](#fig11-1)显示了一个简化的Intel
    FPGA上GPIO引脚接口的框图，说明了缓冲器如何充当引脚和FPGA内部逻辑之间的中介。
- en: '![](../images/Figure11-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: A simplified GPIO
    block diagram</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-1：简化的GPIO模块图</samp>
- en: The box on the right-hand side of the image (with the X inside it) represents
    the physical pin. Immediately to the left of the pin is a block labeled Buffer,
    which represents the I/O buffer. It contains two main components, represented
    by triangles. The triangle pointing to the right is the *output* *buffer*; it
    pushes data out to the pin. The triangle pointing to the left is the *input buffer*;
    it sends data from the pin into the FPGA.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图像右侧的框（内含X）代表物理引脚。引脚的左边紧邻一个标记为Buffer的模块，代表I/O缓冲区。它包含两个主要组件，由三角形表示。指向右侧的三角形是*输出缓冲区*；它将数据推送到引脚上。指向左侧的三角形是*输入缓冲区*；它将数据从引脚传送到FPGA。
- en: On the far left of the diagram is a block labeled GPIO, representing the internal
    FPGA logic that interacts directly with the pin via the buffers. The main path
    to notice here is OE, which stands for *output enable*. This turns the output
    buffer on or off to control whether the pin will function as an output or an input.
    When OE is high, the output buffer will drive the pin with whatever data is present
    on the output path. If data on the output path is low, the pin will be low, and
    if data on the output path is high, the pin will be high. When OE is low, the
    pin is configured as an input, so the output buffer stops passing its input to
    its output. At this point the buffer’s output becomes *high impedance* (also called
    *hi-Z* or *tri-state*), meaning it will accept very little current. A high-impedance
    output buffer no longer affects anything happening on the pin. Instead, the pin’s
    state is governed by whatever external signal is coming in. The input buffer is
    free to read that signal and pass it along to the input path for use inside the
    FPGA.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图表最左边是一个标记为GPIO的模块，代表与引脚通过缓冲区直接交互的内部FPGA逻辑。这里需要注意的主要路径是OE，代表*输出使能*。它控制输出缓冲区的开关，决定引脚是作为输出还是输入。当OE为高时，输出缓冲区会将输出路径上的数据驱动到引脚上。如果输出路径上的数据为低，引脚也会是低电平；如果输出路径上的数据为高，引脚则是高电平。当OE为低时，引脚被配置为输入模式，因此输出缓冲区停止将其输入传递到输出。此时，缓冲区的输出变为*高阻抗*（也称为*高Z*或*三态*），意味着它几乎不接受任何电流。高阻抗的输出缓冲区不再影响引脚上的任何操作。相反，引脚的状态由外部输入信号决定。输入缓冲区可以自由读取该信号，并将其传递到输入路径，以供FPGA内部使用。
- en: '[Table 11-1](#tab11-1) shows a truth table for an output buffer, summarizing
    this behavior.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-1](#tab11-1)展示了一个输出缓冲区的真值表，总结了该行为。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-1:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for an Output Buffer</samp>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 11-1：</samp> <samp class="SANS_Futura_Std_Book_11">输出缓冲区的真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">OE</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">输入</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">OE</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: Looking at this table, we can see that when OE is high, the value on the buffer’s
    input is simply passed to its output. However, when OE is low, the buffer’s output
    is high impedance (conventionally represented by a *Z*), regardless of the value
    on the input.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个表格可以看出，当OE为高时，缓冲区输入的值会被直接传递到输出。但当OE为低时，缓冲区的输出变为高阻抗（通常用*Z*表示），无论输入值是什么。
- en: In the projects in this book, we’ve defined the input and output signals at
    the top level of the design code. Inputs are represented with the keyword <samp
    class="SANS_TheSansMonoCd_W5Regular_11">input</samp> (Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    (VHDL), while outputs are indicated by the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">output</samp>
    (Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> (VHDL).
    When building the FPGA, the synthesis tools see which signals are defined for
    each direction and set up the buffers accordingly. If the signal is an input,
    OE will be set low. If the signal in an output, OE will be set high. Then, during
    the place and route process, the physical constraints file maps the signals to
    the specific pins on the FPGA. This is how GPIO pins get configured as dedicated
    input or output pins for your design.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中的项目中，我们已在设计代码的顶层定义了输入和输出信号。输入通过关键字<samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>（Verilog）或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp>（VHDL）表示，而输出则通过关键字<samp class="SANS_TheSansMonoCd_W5Regular_11">output</samp>（Verilog）或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp>（VHDL）表示。在构建FPGA时，综合工具会看到每个方向定义了哪些信号，并相应地设置缓冲区。如果信号是输入，OE将被设置为低电平。如果信号是输出，OE将被设置为高电平。然后，在布置和布线过程中，物理约束文件将信号映射到FPGA的特定引脚。这就是GPIO引脚如何配置为专用输入或输出引脚的方式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Bidirectional Data for Half-Duplex
    Communication</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">半双工通信的双向数据</samp>
- en: While most pins in a design are typically fixed as either input or output, a
    GPIO pin can be configured to be *bidirectional*, meaning it can switch between
    functioning as input and output within the same design. When the FPGA needs to
    output data through the bidirectional pin, it drives the OE signal high, then
    puts the data to transmit onto the output path. When the FPGA needs to receive
    data as input through the bidirectional pin, it drives OE low. This puts the output
    buffer into tri-state (high impedance), enabling the FPGA to listen to the data
    on the pin and pass it to the input path. When a pin is configured to be bidirectional
    like this, it’s acting as a *transceiver*, as opposed to just a transmitter or
    just a receiver.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设计中的大多数引脚通常被固定为输入或输出，但GPIO引脚可以配置为*双向*，这意味着它可以在同一设计中在输入和输出之间切换。当FPGA需要通过双向引脚输出数据时，它会将OE信号驱动为高电平，然后将要传输的数据放到输出路径上。当FPGA需要通过双向引脚接收数据作为输入时，它会将OE信号驱动为低电平。这将把输出缓冲区设置为三态（高阻抗），使FPGA能够监听引脚上的数据并将其传递到输入路径。当引脚配置为这种双向时，它充当的是*收发器*，而不仅仅是一个发射器或接收器。
- en: Bidirectional pins are useful for *half-duplex* communication, where two devices
    exchange data using a single, shared transmission line (one pin). Either device
    can serve as a transmitter, but only one device can transmit at a time, while
    the other receives. This is in contrast to *full-duplex* communication, where
    both devices can transmit and receive data at the same time. Full-duplex communication
    requires two transmission lines (two pins), one for sending data from device 1
    to device 2 and the other for sending data from device 2 to device 1, as opposed
    to the single transmission line of half-duplex communication.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 双向引脚对于*半双工*通信非常有用，其中两个设备通过一个共享的传输线（一个引脚）交换数据。任何一个设备都可以充当发射器，但每次只能有一个设备进行传输，而另一个设备进行接收。这与*全双工*通信相对，后者允许两个设备同时传输和接收数据。全双工通信需要两条传输线（两个引脚），一条用于从设备1到设备2发送数据，另一条用于从设备2到设备1发送数据，这与半双工通信中的单一传输线不同。
- en: A common example of half-duplex communication is a two-way radio. The speaker
    is only able to transmit when they hold down the button on the radio. When the
    speaker is transmitting, the listener is unable to transmit, so the speaker and
    listener must agree whose turn it is to talk. This is why people always say “Over”
    in the movies when they’re talking on walkie-talkies; it’s a signal that the speaker
    is done talking and the listener is now free to respond.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 半双工通信的一个常见例子是双向无线电。讲解者只有在按住无线电上的按钮时才能传输信息。当讲解者在传输时，听者无法进行传输，因此讲解者和听者必须商定谁先发言。这也是为什么电影中人们在使用对讲机时总是会说“Over”——这是一个信号，表示讲解者已经讲完，听者现在可以自由回应。
- en: With a physical wire, if the two sides don’t take turns sharing the communication
    channel, then there can be a data collision. This collision can corrupt the data,
    so nobody receives anything. To avoid this the devices must agree on a *protocol*,
    a set of rules governing communication. The protocol determines how a device can
    initiate a transaction, establishes well-defined locations in time for other devices
    on the line to talk back (the equivalent of saying “Over”), and so on. Some protocols
    are even able to handle data collisions by detecting when data is corrupted and
    resending the corrupted data, though this requires additional complexity.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于物理线路，如果两端没有轮流共享通信通道，就会发生数据碰撞。这种碰撞可能会损坏数据，导致任何一方都无法接收到信息。为了避免这种情况，设备必须达成一种*协议*，即一组管理通信的规则。协议确定了设备如何发起事务，建立了其他设备在时间上有明确的时机进行回应（类似于说“完毕”），等等。有些协议甚至能够通过检测数据损坏并重新发送损坏的数据来处理数据碰撞，尽管这需要额外的复杂性。
- en: Half-duplex communication is usually more complicated than using dedicated transmit
    and receive channels, but it’s still quite common. *I2C* (or I²C, pronounced “eye-squared-see”
    or “eye-two-see” and short for *inter- integrated circuit*), for example, is a
    widely used half-duplex protocol. Countless unique integrated circuits—including
    ADCs, DACs, accelerometers, gyroscopes, temperature sensors, microcontrollers,
    and many others—use I2C to communicate, since it’s relatively simple to implement
    and, thanks to its half-duplex nature, requires a very low pin count. Only two
    pins, clock and data, are used in I2C, which is why you may also see it referred
    to as *TWI (two-wire interface)*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 半双工通信通常比使用专用的发送和接收通道更复杂，但仍然非常常见。例如，*I2C*（或 I²C，发音为“eye-squared-see”或“eye-two-see”，是*集成电路间通信*的缩写）是一种广泛使用的半双工协议。无数独特的集成电路——包括
    ADC、DAC、加速度计、陀螺仪、温度传感器、微控制器等——都使用 I2C 来通信，因为它相对简单易实现，并且由于其半双工的特性，只需要极少的引脚。I2C
    只使用两个引脚：时钟和数据，这也是为什么它有时被称为*TWI（双线接口）*的原因。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A Bidirectional Pin Implementation</samp>
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">双向引脚实现</samp>
- en: 'Let’s look at how to code a bidirectional pin using Verilog or VHDL. As you
    examine this code, refer to [Figure 11-2](#fig11-2) to see how the signals in
    the code match the block diagram from [Figure 11-1](#fig11-1):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Verilog 或 VHDL 编写双向引脚代码。在查看此代码时，请参考[图 11-2](#fig11-2)，以查看代码中的信号如何与[图
    11-1](#fig11-1)中的框图匹配：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We declare the bidirectional pin (<samp class="SANS_TheSansMonoCd_W5Regular_11">io_Data</samp>)
    with the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">inout</samp> in
    both Verilog and VHDL ❶. At this point we can imagine that we’re at the pin, as
    indicated by the label <samp class="SANS_TheSansMonoCd_W5Regular_11">io_Data</samp>
    in [Figure 11-2](#fig11-2). We’ll need to map this signal to one of the FPGA’s
    pins in our physical constraints file. For the input functionality, we simply
    use an assignment to drive <samp class="SANS_TheSansMonoCd_W5Regular_11">w_RX_Data</samp>
    with the data from the pin ❷. On the output side, we selectively enable the output
    buffer using the signal <samp class="SANS_TheSansMonoCd_W5Regular_11">w_TX_En</samp>
    ❸. We use the ternary operator in Verilog or a conditional assignment in VHDL.
    The data driven onto <samp class="SANS_TheSansMonoCd_W5Regular_11">io_Data</samp>
    will either be <samp class="SANS_TheSansMonoCd_W5Regular_11">w_TX_Data</samp>
    or high impedance (indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">1'bZ</samp>
    in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">'Z'</samp> in VHDL),
    depending on the state of the output enable signal (<samp class="SANS_TheSansMonoCd_W5Regular_11">w_TX_En</samp>).
    This code pattern is very common for bidirectional data. Synthesis tools are smart
    enough to recognize it and infer an I/O buffer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Verilog 和 VHDL 中使用关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">inout</samp>
    声明双向引脚 (<samp class="SANS_TheSansMonoCd_W5Regular_11">io_Data</samp>) ❶。此时我们可以想象自己已经位于引脚处，正如
    [图 11-2](#fig11-2) 中标签 <samp class="SANS_TheSansMonoCd_W5Regular_11">io_Data</samp>
    所示。我们需要在物理约束文件中将这个信号映射到 FPGA 的一个引脚。在输入功能方面，我们仅需通过赋值操作将引脚的数据驱动到 <samp class="SANS_TheSansMonoCd_W5Regular_11">w_RX_Data</samp>
    ❷。在输出端，我们通过使用信号 <samp class="SANS_TheSansMonoCd_W5Regular_11">w_TX_En</samp> 来选择性地启用输出缓冲区
    ❸。我们在 Verilog 中使用三元操作符，或在 VHDL 中使用条件赋值。驱动到 <samp class="SANS_TheSansMonoCd_W5Regular_11">io_Data</samp>
    上的数据将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">w_TX_Data</samp> 或高阻抗（在 Verilog
    中表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1'bZ</samp>，在 VHDL 中为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">'Z'</samp>），具体取决于输出使能信号 (<samp class="SANS_TheSansMonoCd_W5Regular_11">w_TX_En</samp>)
    的状态。这种代码模式对于双向数据来说非常常见，综合工具足够智能，能够识别并推断出一个 I/O 缓冲区。
- en: '![](../images/Figure11-2.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: A labeled bidirectional
    interface</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-2：带标签的双向接口</samp>
- en: One thing you might notice is that any data driven out on <samp class="SANS_TheSansMonoCd_W5Regular_11">w_TX_Data</samp>
    will be received on <samp class="SANS_TheSansMonoCd_W5Regular_11">w_RX_Data</samp>,
    since they’re connected together through <samp class="SANS_TheSansMonoCd_W5Regular_11">io_Data</samp>.
    You’ll need to address this elsewhere in the code by telling your receiver to
    ignore any data on <samp class="SANS_TheSansMonoCd_W5Regular_11">io_Data</samp>
    when <samp class="SANS_TheSansMonoCd_W5Regular_11">w_TX_En</samp> is high. Otherwise,
    your FPGA will be hearing itself talk.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，任何驱动到 <samp class="SANS_TheSansMonoCd_W5Regular_11">w_TX_Data</samp>
    的数据都会被接收到 <samp class="SANS_TheSansMonoCd_W5Regular_11">w_RX_Data</samp>，因为它们通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">io_Data</samp> 连接在一起。你需要在代码的其他地方处理这个问题，通过告知接收器在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">w_TX_En</samp> 为高电平时忽略 <samp class="SANS_TheSansMonoCd_W5Regular_11">io_Data</samp>
    上的任何数据。否则，你的 FPGA 会“听到”自己发出的数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Electrical Characteristics</samp>
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">电气特性</samp>
- en: 'There are many different electrical characteristics that you can specify for
    each individual GPIO pin. We’re going to talk about three: operating voltage,
    drive strength, and slew rate. We’ll also look at the electrical differences between
    single-ended and differential data transmission.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 GPIO 引脚，你可以指定许多不同的电气特性。我们将讨论三种：工作电压、驱动强度和上升/下降速率。我们还将看看单端和差分数据传输之间的电气差异。
- en: As you read, keep in mind that these aren’t the only pin settings you can control.
    For example, you also may be able to set pins to be open drain, include a pull-up
    or pull-down resistor or a termination resistor, and much more. The I/O of your
    FPGA can be configured in many, many ways, depending on which GPIO properties
    are built into the device itself. If you need to implement anything other than
    simple signal interfaces, it’s worth exploring the relevant datasheets to ensure
    you’re working correctly with your I/O buffers. All of the specific information
    about your FPGA’s I/O can usually be found in the I/O user guide, which is a great
    reference for details on what types of electronics your FPGA is capable of interfacing
    to.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读时，请记住，这些并不是你可以控制的唯一引脚设置。例如，你还可以将引脚设置为开漏，加入上拉或下拉电阻，或者终端电阻等。你的FPGA的I/O可以以多种方式配置，这取决于设备本身内置的GPIO属性。如果你需要实现简单信号接口之外的功能，建议查阅相关数据手册，确保你正确地使用I/O缓冲器。关于FPGA
    I/O的所有具体信息通常可以在I/O用户手册中找到，这是一个很好的参考，可以帮助你了解FPGA能够与哪些类型的电子设备进行接口。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Operating Voltage</samp>
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">操作电压</samp>
- en: The *operating voltage* specifies what voltage the pin will be driven to for
    a logic 1 output and sets the expected voltage for a logic 1 input. Most commonly,
    FPGA pins use 0 V to represent a 0 and 3.3 V to represent a 1\. This standard
    is called *LVCMOS33* (LVCMOS is short for *low-voltage complementary metal oxide
    semiconductor*). Another standard you might come across is 0 V to represent a
    0 and 5 V to represent a 1\. This is called *TTL*, short for *transistor–transistor
    logic*. TTL is less common in FPGAs these days, since many don’t allow voltages
    as high as 5 V internally. There’s also the LVCMOS25 standard, which uses 0 V
    to represent a 0 and 2.5 V to represent a 1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作电压*指定引脚在逻辑1输出时将被驱动到的电压，并设置逻辑1输入的预期电压。最常见的是，FPGA引脚使用0V表示0，3.3V表示1。这种标准称为*LVCMOS33*（LVCMOS是*低电压互补金属氧化物半导体*的缩写）。你还可能遇到另一种标准：0V表示0，5V表示1，这称为*TTL*（*晶体管–晶体管逻辑*的缩写）。如今，TTL在FPGA中不太常见，因为许多FPGA内部不允许使用高达5V的电压。还有LVCMOS25标准，它使用0V表示0，2.5V表示1。'
- en: LVCMOS33, LVCMOS25, and TTL are all examples of *single-ended* I/O standards,
    meaning the signals involved are referenced to ground. As you’ll see soon, there
    are also *differential* standards, where the signals aren’t referenced to ground.
    There are many more single-ended standards than the three I’ve mentioned. A typical
    FPGA supports about a dozen single-ended I/O standards.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: LVCMOS33、LVCMOS25 和 TTL 都是*单端*I/O标准的例子，意味着相关信号是以地为参考的。如你很快会看到的，还有*差分*标准，其中信号不以地为参考。单端标准的种类比我提到的三种更多。一个典型的FPGA支持大约十几种单端I/O标准。
- en: One important note about setting your operating voltage is that all signals
    on a single bank need to be at the same operating voltage. A *bank* is a group
    of pins that all operate with a common reference voltage, usually called *VCCIO*.
    You might have eight banks on your FPGA, and each bank can use a unique operating
    voltage. For example, you might configure bank 1 to use 1.8 V, bank 2 to use 3.3
    V, and bank 3 to use 2.5 V. What’s critical is that all the pins within a single
    bank are operating at the same voltage. You can’t put an LVCMOS33 pin on the same
    bank as an LVCMOS25 pin, because the former requires a VCCIO of 3.3 V while the
    latter requires a VCCIO of 2.5 V. When doing your schematic review, always check
    to make sure that the signals on each bank share the same reference voltage. If
    you try to mix voltages in the same bank, the place and route tool will likely
    generate an error, or at least a very strong warning.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置操作电压，有一个重要的注意事项：同一组引脚上的所有信号必须使用相同的操作电压。*银行*是指一组引脚，它们都使用一个共同的参考电压，通常称为*VCCIO*。你的FPGA上可能有八个银行，每个银行可以使用独特的操作电压。例如，你可能将银行1配置为使用1.8V，将银行2配置为使用3.3V，将银行3配置为使用2.5V。关键在于同一银行内的所有引脚必须在相同电压下工作。你不能将一个LVCMOS33引脚与LVCMOS25引脚放在同一个银行，因为前者需要3.3V的VCCIO，而后者需要2.5V的VCCIO。在进行原理图审查时，始终检查确保每个银行的信号共享相同的参考电压。如果你尝试在同一银行中混合不同的电压，放置与布线工具很可能会生成错误，或者至少会发出一个非常强烈的警告。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Drive Strength</samp>
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">驱动强度</samp>
- en: The *drive strength* of a pin determines how much current (in milliamps, or
    mA) can be driven into or out of the pin. For example, a pin set to an 8 mA drive
    strength will be capable of sinking or sourcing up to 8 mA of current. The drive
    strength can be changed on an individual pin basis and should be high enough to
    match the needs of the circuit you’re interfacing to. Most often, the drive strength
    settings can be left at the default for all of the pins on your FPGA. Unless you
    have some high current needs, it’s unlikely you’ll need to modify the default
    settings.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*驱动强度*决定了一个引脚可以驱动的电流大小（以毫安 mA 为单位）。例如，一个设置为 8 mA 驱动强度的引脚将能够吸入或输出最多 8 mA 的电流。驱动强度可以根据每个引脚单独调整，并应足够高以匹配你所连接的电路需求。通常情况下，所有引脚的驱动强度设置可以保留为默认值。除非你有高电流需求，否则不太可能需要修改默认设置。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Slew Rate</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">斜率</samp>
- en: The *slew rate* sets the rate of change allowed for an output signal. It’s usually
    specified in qualitative terms, such as *fast*, *medium*, or *slow*. The slew
    rate setting affects how quickly a pin can change from a 0 to a 1 or from a 1
    to a 0\. Like drive strength, the slew rate can often be left at the default setting
    for each of your pins. The exception is if you’re interfacing to some component
    that requires very fast data rates, in which case you might want to select the
    fastest option. However, selecting a faster slew rate can increase system noise,
    so it’s not recommended to slew faster unless you really need it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*斜率*设定了输出信号允许变化的速率。通常以定性术语表示，如*快*、*中*或*慢*。斜率设置会影响引脚从 0 变为 1 或从 1 变为 0 的速度。和驱动强度一样，斜率通常可以保留为每个引脚的默认设置。唯一的例外是，当你需要与某个要求非常快速数据传输速率的组件进行接口时，这时你可能需要选择最快的选项。然而，选择更快的斜率可能会增加系统噪声，因此除非确实需要，否则不建议使用更快的斜率。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Differential Signaling</samp>
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">差分信号传输</samp>
- en: '*Differential signaling* is a method of sending data where you have two signals
    that aren’t referenced to ground, but rather to each other. As I hinted earlier,
    this is in contrast to *single-ended signaling*, where you have one data signal
    referenced to ground. [Figure 11-3](#fig11-3) illustrates the difference.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*差分信号传输*是一种数据传输方法，其中有两个信号，它们不是参考地面，而是相互参考。如我之前所提，这与*单端信号传输*形成对比，后者只有一个数据信号参考地面。[图
    11-3](#fig11-3)展示了它们之间的区别。'
- en: '![](../images/Figure11-3.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: Single-ended vs.
    differential interfaces</samp>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-3：单端与差分接口</samp>
- en: 'The top half of the figure shows a single-ended configuration: we have device
    1 transmitting data to device 2 on a single wire, and another wire for the ground
    path. There’s no data on this ground wire, but it’s needed to maintain a consistent
    ground reference between the devices. Data is sent as a voltage on the data wire:
    0 V for a 0 or some other value (such as 3.3 V) for a 1, depending on the operating
    voltage. If we wanted to add another data path, we could just add another single
    wire between the two devices; the ground reference can work for multiple data
    paths.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图的上半部分展示了单端配置：我们有设备 1 通过单根线将数据传输给设备 2，另有一根线用于地面路径。地面线没有数据，但它是保持设备间一致地面参考所必需的。数据通过数据线以电压的形式传送：0
    V 表示 0，或根据工作电压为 1 的其他值（如 3.3 V）。如果我们想增加另一条数据路径，只需在两个设备之间再加一根单独的线；地面参考可适用于多个数据路径。
- en: The bottom half of the image shows a differential configuration. Here, we don’t
    have a ground reference passed between the devices. Instead, we have a pair of
    data lines. Notice the bubble at the start of the upper line, on the output of
    device 1’s transmit buffer. This looks like the bubble we saw when looking at
    NOT gates and NAND gates back in [Chapter 3](chapter3.xhtml), and it’s a common
    indication that we have a differential pair. If the difference between the + and
    – terminals on the receiver is a positive voltage above some threshold, then the
    signal is decoded as a 1; if the difference is a negative voltage below some threshold,
    then the signal is decoded as a 0\. The details depend on the differential standard.
    For example, TIA/EIA-644, more commonly called *LVDS (low-voltage differential
    signaling)*, specifies that there should be a difference of about +/– 350 millivolts
    (mV) between the two wires. This voltage is quite a bit lower than most single-ended
    signals use, meaning the system can operate at less power, which is one advantage
    of differential communication over single-ended communication. A typical FPGA
    supports about the same number of differential standards as single-ended standards
    (a dozen or so).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图片的下半部分展示了一个差分配置。在这里，我们没有地参考线通过设备之间传递。相反，我们有一对数据线。注意到上行线起始处的气泡，这是设备1的传输缓冲区输出端。这看起来像我们在[第3章](chapter3.xhtml)中看到的NOT门和NAND门的气泡，且这是我们拥有差分对的常见标志。如果接收端的+端和–端之间的电压差超过某个阈值并为正电压，那么信号被解码为1；如果电压差为负并低于某个阈值，则信号被解码为0。具体细节取决于差分标准。例如，TIA/EIA-644，通常称为*LVDS（低电压差分信号传输）*，规定两条电线之间的电压差应约为+/-350毫伏（mV）。这个电压比大多数单端信号使用的电压要低得多，这意味着系统可以在更低的功耗下工作，这是差分通信相对于单端通信的一个优势。典型的FPGA支持的差分标准数量大致与单端标准相同（大约十几种）。
- en: One disadvantage you might have picked up on is that differential communication
    requires twice as many wires for every data path. In the case of single-ended
    data transfer, there’s just one wire for each data path we want to create. If
    we want 10 data paths, we need 10 wires (and usually at least 1 ground wire).
    To create the same 10 data paths with differential signaling, we’d need 20 wires
    (but no ground wires). This extra wiring costs money and will require a larger
    connector. Still, differential signals have some unique properties that may make
    this trade-off worthwhile in certain applications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到一个缺点，那就是差分通信每条数据路径需要使用两倍数量的电线。对于单端数据传输，每条数据路径只需要一根电线。如果我们想要10条数据路径，我们需要10根电线（通常还至少需要1根地线）。而要使用差分信号创建相同的10条数据路径，我们需要20根电线（但不需要地线）。这些额外的电线会增加成本，并需要更大的连接器。然而，差分信号具有一些独特的特性，在某些应用中，这种折衷是值得的。
- en: One important advantage is that differential signals are much more immune to
    *noise*, or *electromagnetic interference (EMI)*, than single-ended signals. EMI
    is a phenomenon caused by changing electrical and magnetic fields—for example,
    from a nearby microwave oven, cell phone, or power line—that can cause disturbances
    in other systems. You can think of a wire that carries data as a small antenna
    that receives all sorts of unwanted electrical signals, creating noise that shows
    up as a voltage blip on the wire. A large enough voltage blip on a single-ended
    signal could corrupt the data, causing a 0 to turn into a 1, or a 1 into a 0\.
    With a differential signal, however, the voltage blip will affect both wires equally,
    meaning the voltage difference between the wires will remain constant. Since it’s
    the voltage difference, and not the exact value of the voltage itself, that matters,
    the noise is effectively canceled out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的优势是，差分信号比单端信号对*噪声*或*电磁干扰（EMI）*的免疫能力要强得多。电磁干扰是一种由电磁场变化引起的现象——例如，来自附近微波炉、手机或电力线的变化——它会在其他系统中造成干扰。你可以把一根传输数据的电线想象成一个小天线，它会接收各种不需要的电信号，产生噪声，这些噪声会在电线上以电压波动的形式表现出来。单端信号上的电压波动足够大时，可能会破坏数据，使0变成1，或者1变成0。然而，对于差分信号来说，电压波动会对两条电线产生相同的影响，这意味着两根电线之间的电压差保持不变。由于重要的是电压差，而不是电压的精确值，因此噪声会被有效地抵消。
- en: An additional benefit of differential communication is that the transmitter
    and the receiver can be referenced to different ground voltages and still send
    and receive data reliably. It might seem strange, but ground isn’t always exactly
    0 V. The ground in a system can be affected by noise, just as data lines can be,
    so problems can arise when you rely on ground as a source of truth throughout
    your system. In particular, it’s difficult to maintain a common ground reference
    for two devices that are far apart, which is why differential signals are often
    used to send data over long distances. For example, RS-485, a differential electrical
    standard, can send data at 10 megabits per second (Mb/s) over a distance of nearly
    1 mile, which would be impossible with a single-ended signal. Even at closer distances,
    there are situations where one system might not be referenced to ground at all.
    Instead, it might be *floating* or *isolated* from a ground reference. To communicate
    with an isolated system, you need a method of communication that doesn’t rely
    on a shared ground reference; differential communication is one such method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 差分通信的另一个好处是发射器和接收器可以参考不同的地电压，同时仍然能够可靠地发送和接收数据。这可能听起来有些奇怪，但地电压并不总是完全为0V。系统中的地电压可能会受到噪声的影响，就像数据线一样，因此如果你依赖地电压作为系统中唯一的参考电压，就可能出现问题。特别是，对于相距较远的两个设备，很难维持一个共同的地电压参考，这也是为什么差分信号常常被用于长距离传输数据的原因。例如，RS-485作为一种差分电气标准，可以在近1英里的距离内以每秒10兆比特（Mb/s）的速度传输数据，而单端信号无法实现这一点。即使在较短的距离下，也有一些情况，其中一个系统可能根本不以地电压为参考，而是*浮空*或*与地电压隔离*。为了与隔离系统通信，你需要一种不依赖于共享地电压参考的通信方式，差分通信就是这样一种方式。
- en: Differential signals are also able to send data at faster rates than single-ended
    signals. When a transmitter needs to change from a 0 to a 1, it must drive the
    line all the way from the voltage corresponding to a 0 to the voltage corresponding
    to a 1, and that process takes some amount of time (the slew rate). The bigger
    the difference between the voltages, the more current must be driven onto the
    line, and the longer the process will take. Since single-ended protocols typically
    require wider voltage swings between a 0 and a 1, they’re inherently slower than
    differential protocols. For example, the LVCMOS33 voltage swing of 3.3 V is much
    greater than the LVDS voltage swing of +/– 350 mV. For this reason, almost all
    high-speed applications use differential signals. We’ll get into more detail about
    this later in the chapter when we discuss SerDes, but interfaces like USB, SATA,
    and Ethernet all use differential signals for the highest possible data rates.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 差分信号能够以比单端信号更快的速度传输数据。当发射器需要从0切换到1时，它必须将线路的电压从对应0的电压驱动到对应1的电压，这个过程需要一定的时间（称为变化速率）。电压之间的差异越大，需要驱动到线路上的电流就越大，过程所需的时间也越长。由于单端协议通常要求在0和1之间有更宽的电压波动，它们天生比差分协议更慢。例如，LVCMOS33的电压摆幅为3.3V，远大于LVDS的电压摆幅+/-
    350 mV。因此，几乎所有高速应用都使用差分信号。我们将在本章后续讨论SerDes时详细了解这一点，但像USB、SATA和以太网这样的接口都使用差分信号，以实现尽可能高的数据传输速率。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">How to Modify Pin Settings</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">如何修改引脚设置</samp>
- en: 'If you want to specify the operating voltage, drive strength, or slew rate
    values for your pins, or control which pins are for single-ended signals and which
    are for differential signals, the place to do it is your physical constraints
    file. Recall that this file lists how the pins on your FPGA connect to the signals
    in your design. In addition to specifying the pin mapping, you can also add these
    other parameters to further define the I/O behavior. Here’s an excerpt from a
    Lattice constraint file that includes some additional parameters:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为引脚指定工作电压、驱动强度或变化速率值，或者控制哪些引脚用于单端信号，哪些引脚用于差分信号，应该在物理约束文件中进行配置。回想一下，这个文件列出了FPGA的引脚如何与设计中的信号连接。除了指定引脚映射之外，你还可以添加这些其他参数，进一步定义I/O行为。以下是一个来自Lattice约束文件的片段，其中包含一些附加参数：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line maps the signal <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp>
    to the pin A13\. The second line sets the operating voltage to <samp class="SANS_TheSansMonoCd_W5Regular_11">LVCMOS33</samp>,
    the drive strength to <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>,
    and the slew rate to <samp class="SANS_TheSansMonoCd_W5Regular_11">FAST</samp>.
    You should refer to the constraints user guide for your particular FPGA to see
    how to set these parameters; the syntax isn’t universal across devices. You can
    also use the GUI in your IDE to set these parameters without having to learn the
    exact syntax required.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将信号<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp>映射到A13引脚。第二行将操作电压设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LVCMOS33</samp>，驱动强度设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>，上升率设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FAST</samp>。你应参考你特定FPGA的约束用户指南，以了解如何设置这些参数；因为语法在不同设备之间并不通用。你也可以在你的IDE中使用GUI来设置这些参数，而无需学习所需的精确语法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Faster Data Transmission
    with Double Data Rate</samp>
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">通过双倍数据速率实现更快的数据传输</samp>
- en: Sending data quickly is where FPGAs can really shine, and one way to speed up
    transmission is to use *double data rate (DDR)*. Up until this point, I’ve stated
    that the signals in your FPGA should be synchronized to the rising edges of the
    clock. With double data rate, however, signals change on the rising *and* falling
    edges of the clock. This enables you to send twice the amount of data with the
    same clock frequency, as shown in [Figure 11-4](#fig11-4).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 快速发送数据是FPGA的优势所在，而加速传输的一种方式是使用*双倍数据速率（DDR）*。到目前为止，我已经指出，FPGA中的信号应该与时钟的上升沿同步。然而，在双倍数据速率下，信号会在时钟的上升*和*下降沿发生变化。这使得你可以在相同的时钟频率下发送两倍的数据量，如[图11-4](#fig11-4)所示。
- en: '![](../images/Figure11-4.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: Single vs. double
    data rate</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图11-4：单倍数据速率与双倍数据速率</samp>
- en: As you can see, with single data rate, where data is sent on each rising clock
    edge, you’re able to move three bits of data (D0 through D2) during three clock
    cycles. In comparison, with double data rate, where data is sent on both rising
    and falling edges, you can send six bits of data (D0 through D5) during the same
    three clock cycles. This technique is known for its use in LPDDR memory, short
    for *low-power double data rate*, a type of RAM commonly found in computers, smartphones,
    and other electronics. Changing the data on both edges of the clock increases
    the bandwidth of the memory.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在单倍数据速率模式下，数据在每个上升时钟沿发送，你可以在三个时钟周期内移动三个位的数据（D0到D2）。相比之下，在双倍数据速率模式下，数据在上升沿和下降沿都发送，你可以在相同的三个时钟周期内发送六个位的数据（D0到D5）。这种技术广泛用于LPDDR内存，即*低功耗双倍数据速率*，这是一种常见于计算机、智能手机和其他电子设备中的RAM。改变时钟的上下沿的数据可提高内存的带宽。
- en: 'You need to create double data rate output (ODDR) buffers anywhere you want
    to use DDR for data transfer. The details vary between FPGA manufacturers, but
    I generally recommend creating these ODDR buffers directly within your Verilog
    or VHDL, using instantiation, since they aren’t terribly complicated to configure.
    As an example, let’s take a look at an instantiation template for an ODDR buffer
    from AMD’s Virtex-7 Library User Guide:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在任何需要使用DDR进行数据传输的地方创建双倍数据速率输出（ODDR）缓冲区。不同FPGA厂商之间的具体实现有所不同，但我一般建议在Verilog或VHDL中直接创建这些ODDR缓冲区，通过实例化的方式，因为它们的配置并不复杂。作为例子，我们可以看看来自AMD
    Virtex-7库用户指南中的ODDR缓冲区实例化模板：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s not critical to understand every line here. The most important connection
    is the output pin itself ❶ ; this is where the <samp class="SANS_TheSansMonoCd_W5Regular_11">ODDR</samp>
    block is connected to the pin. The two data inputs, <samp class="SANS_TheSansMonoCd_W5Regular_11">D1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">D2</samp>, will be used in an
    alternating pattern to drive the data to the output pin. <samp class="SANS_TheSansMonoCd_W5Regular_11">D1</samp>
    is driven on rising (or positive) edges and <samp class="SANS_TheSansMonoCd_W5Regular_11">D2</samp>
    on falling (or negative) edges.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这里的每一行并不关键。最重要的连接是输出引脚本身 ❶；这是<sup class="SANS_TheSansMonoCd_W5Regular_11">ODDR</sup>模块连接到引脚的地方。两个数据输入端口，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">D1</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">D2</samp>，将以交替模式将数据传送到输出引脚。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">D1</samp>在上升（或正）沿驱动，<samp class="SANS_TheSansMonoCd_W5Regular_11">D2</samp>在下降（或负）沿驱动。
- en: Double data rate allows you to speed up data transmission, but if you really
    want to get your data flying, some FPGAs have a specialized type of interface
    called SerDes that allows for even speedier input and output. We’ll examine this
    exciting FPGA feature next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 双倍数据速率可以加速数据传输，但如果你真的想让数据飞速传输，一些FPGA配备了一种名为SerDes的专用接口，能够实现更高速的输入和输出。接下来，我们将探讨这个令人兴奋的FPGA特性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">SerDes</samp>
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">SerDes</samp>
- en: A *SerDes*, short for *serializer/deserializer*, is a primitive of some (but
    not all) FPGAs responsible for inputting or outputting data at very high speeds,
    into the gigabits per second (Gb/s). At a high level, it works by taking a parallel
    data stream and converting it into a serial data stream for high-speed transmission.
    On the receiving end, the serial data is converted back to parallel. This is how
    the FPGA can exchange data with other devices at very fast data rates. It may
    sound counterintuitive that sending data serially, one bit at a time, is faster
    than sending data in parallel, several bits at a time, but that’s the magic of
    SerDes. We’ll discuss why this works soon.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*SerDes*（即*串行器/解串器*）是某些（但并非所有）FPGA的原始功能，负责以极高的速度输入或输出数据，达到每秒吉比特（Gb/s）的传输速率。简单来说，它通过将并行数据流转换为串行数据流进行高速传输。而在接收端，串行数据会被转换回并行数据。正因如此，FPGA能够以非常快的数据速率与其他设备交换数据。虽然看起来串行传输——一次传输一位数据——比并行传输——一次传输多个比特——速度更快似乎不太直观，但这正是SerDes的魔力所在。我们稍后将讨论为什么这会有效。'
- en: SerDes primitives are sometimes called *SerDes transceivers*, which reflects
    that they can send and receive data. That said, SerDes transceivers are almost
    always full-duplex, meaning they don’t have to switch back and forth between being
    a transmitter and a receiver like we saw previously with bidirectional communication.
    You usually set up one data path as a transmitter out of your FPGA, and another
    as a receiver into your FPGA.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: SerDes原语有时被称为*SerDes收发器*，这反映了它们既可以发送也可以接收数据。话虽如此，SerDes收发器几乎总是全双工的，意味着它们不必像我们之前在双向通信中看到的那样在发送器和接收器之间来回切换。你通常会将一个数据路径设置为从FPGA发出的发送器，另一个设置为输入到FPGA的接收器。
- en: SerDes transceivers help FPGAs excel at sending or receiving very large amounts
    of data at a rate that wouldn’t be possible with other devices. This is a killer
    feature that makes FPGAs attractive for use cases such as receiving data from
    a video camera. A high-resolution camera might have a pixel space of 1,920×1,080,
    with 32 bits of data per pixel, and new images captured at a rate of 60 Hz. If
    we multiply those numbers, that translates to 3.9Gb of uncompressed raw data per
    second—quite a lot!—and some cameras can go even higher, up to 4K and 120 Hz.
    SerDes transceivers allow an FPGA to receive an absolute firehose of data and
    unpack it in such a way that the FPGA can process it correctly. Another common
    use case is networking, where you have Ethernet packets flying around at hundreds
    of gigabits per second. You might have multiple SerDes transceivers working together
    on a single device to route packets correctly, again at very fast data rates that
    wouldn’t be possible to achieve on a standard I/O pin.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: SerDes收发器帮助FPGA以其他设备无法实现的速率发送或接收大量数据。这是一个关键特性，使得FPGA在接收来自视频摄像头的数据等应用场景中具有吸引力。高分辨率摄像头的像素空间可能为1,920×1,080，每个像素32位数据，并且以60
    Hz的频率捕获新图像。如果将这些数字相乘，就意味着每秒有3.9Gb的未压缩原始数据——非常大！——而有些摄像头甚至可以更高，达到4K和120 Hz。SerDes收发器使得FPGA能够接收大量数据，并以一种可以正确处理的方式解包数据。另一个常见的应用场景是网络通信，在这种情况下，以每秒数百吉比特的速率传输以太网数据包。你可能会有多个SerDes收发器共同工作，在一个设备上正确路由数据包，同样，这些数据传输速率在标准I/O引脚上是无法实现的。
- en: At its heart, SerDes revolves around converting between parallel and serial
    data. To understand why this conversion is necessary, we need to take a closer
    look at the differences between serial and parallel data transfer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SerDes的核心功能是实现并行数据和串行数据之间的转换。为了理解这种转换的必要性，我们需要更详细地了解串行和并行数据传输之间的差异。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parallel vs. Serial
    Communication</samp>
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">并行与串行通信</samp>
- en: '*Parallel communication* means we’re using multiple communication channels
    (usually wires) to send data, with the data split up across the different channels.
    *Serial communication* means we’re sending the data on a single channel, one bit
    at a time. [Figure 11-5](#fig11-5) illustrates the difference.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行通信*意味着我们使用多个通信通道（通常是线路）来发送数据，数据被分割到不同的通道上。*串行通信*则意味着我们在单一通道上传输数据，每次传输一个比特。[图11-5](#fig11-5)展示了两者之间的差异。'
- en: '![](../images/Figure11-5.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: Parallel vs. serial
    interfaces</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图11-5：并行与串行接口</samp>
- en: The top half of the figure shows an 8-bit-wide synchronous parallel interface.
    *Synchronous* means that we have a clock signal sent between the devices, and
    the data is aligned with the clock. With this interface, we can send a whole byte
    of data on a single clock cycle, with one bit on each of the eight wires. In this
    case, we’re sending the value <samp class="SANS_TheSansMonoCd_W5Regular_11">01100011</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">0x63</samp>. While we have eight
    parallel data paths in this example, you could theoretically create a parallel
    interface with any width—you could have a 2-bit-wide interface, a 32-bit-wide
    interface, a 64-bit-wide interface, or any other arbitrary size.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图的上半部分展示了一个8位宽的同步并行接口。*同步*意味着我们在设备之间传送时钟信号，数据与时钟信号对齐。在这个接口下，我们可以在一个时钟周期内发送整个字节的数据，每根线传输一个比特。在这个例子中，我们传输的是值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">01100011</samp>，或者<samp class="SANS_TheSansMonoCd_W5Regular_11">0x63</samp>。虽然在这个例子中我们有八条并行数据路径，但理论上你可以创建任何宽度的并行接口——你可以有一个2位宽的接口、一个32位宽的接口、一个64位宽的接口，或者任何其他任意大小的接口。
- en: The bottom half of the figure shows the same data transfer of the value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01100011</samp>, but it’s sent in a synchronous
    serial stream. Once again, there’s a clock signal shared between the devices,
    but now the data is sent across a single wire, one bit per clock cycle. This way,
    it takes eight clock cycles to send <samp class="SANS_TheSansMonoCd_W5Regular_11">0x63</samp>,
    rather than just one clock cycle in the parallel case.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图的下半部分展示了相同的数据传输值<samp class="SANS_TheSansMonoCd_W5Regular_11">01100011</samp>，但它是通过同步串行流发送的。再次强调，设备之间共享时钟信号，但现在数据通过一根单一的线传输，每个时钟周期传输一个比特。这样，传输<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x63</samp>需要八个时钟周期，而在并行的情况下，只需一个时钟周期。
- en: Since parallel communication allows you to send multiple bits in a single clock
    cycle, it might seem logical that transmitting data in parallel will always allow
    you to send more data per unit time than sending the data serially. In fact, parallel
    data transfer runs up against some serious limitations as the bandwidth increases.
    The physics can’t easily scale to support today’s high-speed data needs, which
    is why parallel interfaces are far less common today than they used to be.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并行通信允许你在一个时钟周期内传输多个比特，似乎传输数据的并行方式总是能比串行传输在单位时间内发送更多的数据。事实上，随着带宽的增加，并行数据传输会遇到一些严重的限制。物理原理无法轻易地扩展以支持今天高速数据的需求，这也是为什么并行接口今天比过去更少见的原因。
- en: If you’re old enough to remember the days of ribbon printers, those would connect
    to your computer using an LPT port, which is a type of parallel interface. Another
    example was the old PCI bus that was a common way to plug devices like modems
    and sound cards into your desktop motherboard. Neither of these interfaces is
    used very much anymore; they couldn’t keep up with our need for faster data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够老，记得带状打印机的时代，那时它们通过 LPT 端口连接到计算机，LPT 是一种并行接口。另一个例子是老式的 PCI 总线，它是将调制解调器和声卡等设备插入桌面主板的常见方式。这些接口现在已经不常用了，因为它们无法跟上我们对更快数据的需求。
- en: To illustrate why, let’s consider how your data transfer speed (or bandwidth)
    is calculated on a parallel interface like PCI. The first version of PCI operated
    at a clock rate of 33 MHz and was 32 bits wide, meaning there were 32 individual
    data wires that needed to be connected between two devices. Multiplying the numbers
    out, we get 1,056Mb/s, or 132 megabytes per second (MB/s), of bandwidth. This
    was sufficient for the computing needs of the 1990s, but the demand for more data
    soon began to increase. We wanted better graphics cards, for example, and the
    bus to support that data transfer needed to grow accordingly. PCI designers answered
    the demand by doubling the clock rate to 66 MHz, which doubled the total bandwidth
    from 132MB/s to 264MB/s. That bought a few years, but it wasn’t enough, so PCI
    next doubled the width of the connector from 32 bits to 64 bits, meaning now we
    have 64 data wires. This provided around 528MB/s of bandwidth, which again bought
    a few years, but still it wasn’t enough.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们考虑一下如何计算像 PCI 这样的并行接口上的数据传输速度（或带宽）。PCI 的第一个版本的时钟频率为 33 MHz，宽度为 32
    位，这意味着有 32 根独立的数据线需要在两个设备之间连接。将这些数字相乘，我们得到 1,056Mb/s，或者每秒 132 兆字节（MB/s）的带宽。这对于
    1990 年代的计算需求来说是足够的，但对更多数据的需求很快开始增加。举个例子，我们需要更好的显卡，而支持这种数据传输的总线也需要相应增长。PCI 设计师通过将时钟频率加倍到
    66 MHz 来回应这一需求，从而将总带宽从 132MB/s 加倍至 264MB/s。这满足了需求几年，但还不够，于是 PCI 接下来将连接器的宽度从 32
    位加倍到 64 位，这意味着现在有 64 根数据线。这提供了大约 528MB/s 的带宽，虽然又满足了几年需求，但仍然不够。
- en: 'By this time, PCI was reaching a point of diminishing returns. There are only
    two ways to increase data throughput with a parallel interface like PCI: make
    the bus wider or increase the clock speed. At 64 bits wide, PCI connectors were
    already a few inches long. To go any wider—say, to 128 bits—the connectors would
    need to be enormous. Routing all those connections in the circuit board gets very
    challenging, too. It simply doesn’t make sense to continue to widen the bus.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，PCI 已经到了收益递减的阶段。对于像 PCI 这样的并行接口，增加数据吞吐量只有两种方式：让总线变宽或提高时钟频率。在 64 位宽时，PCI
    连接器已经有几英寸长。要想再宽一些，比如 128 位，连接器将变得非常庞大。将这些连接器布线到电路板上也变得极为复杂。继续加宽总线显然没有意义。
- en: 'There are also big challenges with increasing the clock speed. When you have
    a wide data bus and you’re sending a clock signal alongside the data, as in the
    synchronous parallel interface in [Figure 11-5](#fig11-5), you need to maintain
    a tight relationship between the clock and the data. The clock will be fed into
    the clock input of each flip-flop on the receiving side: for a 128-bit-wide bus,
    for example, there are 128 individual flip-flops that all need that same clock.
    With so many parallel flip-flops, however, you start to run into problems with
    *clock skew*, a phenomenon where the same clock arrives at different times to
    each flip-flop due to propagation delay.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 增加时钟速度也面临着巨大的挑战。当你有一个宽的数据总线，并且你要在数据旁边发送时钟信号，如[图11-5](#fig11-5)中的同步并行接口那样，你需要保持时钟和数据之间的紧密关系。时钟将被输入到接收端每个触发器的时钟输入中：例如，对于一个128位宽的总线，有128个独立的触发器，它们都需要相同的时钟。然而，随着并行触发器数量的增加，你开始遇到*时钟偏移*的问题，时钟由于传播延迟的原因在不同的时间到达每个触发器。
- en: As we discussed in [Chapter 7](chapter7.xhtml), signals don’t travel instantly;
    rather, there’s some delay, and the longer the signals have to travel (that is,
    the longer the wire) the longer the propagation delay becomes. With a 128-bit-wide
    bus, the distance the clock signal travels to get to the bit-0 flip-flop can be
    quite different from the distance the clock signal travels to get to the bit-127
    flip-flop. As the clock frequency increases, this difference can create enough
    clock skew to trigger metastable conditions and corrupt the data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第7章](chapter7.xhtml)中讨论的那样，信号不会瞬间传播；相反，它存在一些延迟，信号传播的距离越长（也就是线路越长），传播延迟就越大。在一个128位宽的总线中，时钟信号传递到比特0触发器的距离与传递到比特127触发器的距离可能大不相同。随着时钟频率的增加，这种差异可能会产生足够的时钟偏移，触发亚稳态条件并导致数据损坏。
- en: Clearly, parallel communication has issues. There are fundamental limits to
    how fast you can go and how many bits you can send at once. Ultimately, the problem
    comes down to the need to send a separate clock signal alongside the data. The
    solution is to send the clock and the data together, serially, as part of a single
    combined signal.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并行通信存在问题。你可以达到的速度和一次性发送的位数有着基本的限制。最终，问题归结于需要在数据旁边发送单独的时钟信号。解决方案是将时钟和数据一起串行发送，作为一个单一的组合信号。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Self-Clocking Signals</samp>
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">自同步信号</samp>
- en: Combining the clock and the data into one signal gives you something called
    a *self-clocking signal*. The process of creating this signal is sometimes referred
    to as *embedding the clock in the data*, and it’s the key technique that makes
    high-speed serial data transfer via SerDes possible. If you send the clock and
    the data together as one signal, then the issue of clock skew is no longer a problem,
    since your clock is received exactly when your data is received; they’re the same
    signal! With clock skew out of the picture, you’re able to increase the clock
    frequency (and therefore the data frequency) tremendously.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将时钟和数据结合成一个信号给你带来了一个叫做*自同步信号*的东西。创建这个信号的过程有时被称为*将时钟嵌入数据中*，这是通过SerDes实现高速串行数据传输的关键技术。如果你将时钟和数据作为一个信号一起发送，那么时钟偏移问题就不再是问题，因为时钟和数据是同时到达的；它们是同一个信号！随着时钟偏移问题的消失，你可以大幅度提高时钟频率（从而提高数据频率）。
- en: There are many different systems, called *encoding schemes*, for embedding the
    clock in the data. Common ones include Manchester code, High-Level Data Link Control
    (HDLC), and 8B/10B. We’ll focus on Manchester code, since it’s a relatively simple
    encoding scheme, to illustrate one way to create a self-clocking signal. [Figure
    11-6](#fig11-6) shows how Manchester code works.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的系统，称为*编码方案*，用于将时钟嵌入数据中。常见的包括曼彻斯特编码、高级数据链路控制（HDLC）和8B/10B。我们将重点讨论曼彻斯特编码，因为它是一个相对简单的编码方案，可以用来展示如何创建自同步信号。[图11-6](#fig11-6)展示了曼彻斯特编码的工作原理。
- en: '![](../images/Figure11-6.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: Embedding the
    clock in the data with Manchester code</samp>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图11-6：使用曼彻斯特编码将时钟嵌入数据</samp>
- en: To implement Manchester code, you take the XOR (exclusive OR) of the clock and
    data signals, producing a new signal that combines the two. In any given clock
    period, the data signal will be a 1 or a 0, while the clock signal is a 1 for
    the first half of the period and a 0 for the second half of the period. The resulting
    Manchester code signal thus changes halfway through the clock period as well,
    in response to the transition in the clock signal. Depending on the data value
    in that period, the Manchester signal will either be low then high (when the data
    is a 1) or high then low (when the data is a 0). [Table 11-2](#tab11-2) is a truth
    table for the Manchester signal based on the different data/clock combinations.
    You can use this table to understand the Manchester signal pattern in [Figure
    11-6](#fig11-6).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现曼彻斯特编码，你需要对时钟信号和数据信号进行异或（XOR，异或运算），生成一个结合了这两者的新信号。在任意给定的时钟周期内，数据信号要么是 1，要么是
    0，而时钟信号在周期的前一半是 1，后一半是 0。因此，生成的曼彻斯特编码信号也会在时钟周期的中点发生变化，以响应时钟信号的转换。根据该周期内的数据值，曼彻斯特信号要么是先低后高（当数据为
    1 时），要么是先高后低（当数据为 0 时）。[表 11-2](#tab11-2) 是基于不同数据/时钟组合的曼彻斯特信号真值表。你可以使用此表来理解[图
    11-6](#fig11-6)中曼彻斯特信号的模式。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-2:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for Manchester Code</samp>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 11-2：</samp> <samp class="SANS_Futura_Std_Book_11">曼彻斯特编码真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Data</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Clock</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Manchester encoding</samp> |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">数据</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">时钟</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">曼彻斯特编码</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: This is simply a truth table for a two-input XOR logic gate, where the inputs
    are the data and clock signals. As we discussed in [Chapter 3](chapter3.xhtml),
    XOR performs the operation either/or, but not both, so the output is high when
    exactly one input is high, but not when both or neither are high. Looking at the
    waveforms in [Figure 11-6](#fig11-6), notice that whenever the clock and data
    are both high, the encoded value is low. The encoded value is also low when the
    clock and data are both low, and it’s high when only one of the two is high.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个两输入异或逻辑门的真值表，其中输入为数据信号和时钟信号。正如我们在[第 3 章](chapter3.xhtml)中讨论的，异或执行的是“非此即彼”操作，而不是“既是又是”，因此当恰好一个输入为高电平时输出为高电平，而当两个输入都是高电平或两个输入都是低电平时，输出则为低电平。查看[图
    11-6](#fig11-6)中的波形，可以注意到每当时钟和数据都为高电平时，编码值是低电平；当时钟和数据都为低电平时，编码值也是低电平；而当只有一个输入为高电平时，编码值为高电平。
- en: The Manchester encoded signal allows you to send the clock and data signals
    together on a single wire. As mentioned previously, this is the key enabler of
    high-speed serial data transfer. You no longer need to worry about the alignment
    of the clock to the data, because *the clock is the data* and *the data is the
    clock*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 曼彻斯特编码信号使你可以将时钟信号和数据信号通过一根电缆一起传输。如前所述，这就是实现高速串行数据传输的关键技术。你不再需要担心时钟与数据的对齐问题，因为*时钟就是数据*，*数据就是时钟*。
- en: On the receiving side, you need to separate the clock back out from the data,
    a process called *clock data recovery (CDR)*. This is achieved using an XOR gate
    and some small, additional logic at the receiver. Then you can use the recovered
    clock as your clock input to a flip-flop, and feed the recovered data into the
    data input of that same flip-flop. This way you have perfect synchronization between
    the clock and the data. The issue of clock skew that we saw with parallel data
    goes away, enabling you to crank up the data rates far beyond what parallel data
    transfer could ever achieve.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收端，你需要将时钟从数据中分离出来，这一过程称为*时钟数据恢复（CDR）*。这通过使用XOR门和接收端的一些小型附加逻辑来实现。然后，你可以将恢复的时钟作为时钟输入提供给触发器，并将恢复的数据送入同一触发器的数据输入。通过这种方式，你可以确保时钟和数据之间的完美同步。我们在并行数据传输中看到的时钟偏移问题消失了，从而使得数据传输速率能够远远超出并行数据传输的极限。
- en: Manchester code is just one way to generate a self-clocking signal, and it’s
    a simple encoding scheme. It isn’t used for modern, more complicated SerDes applications,
    but it does have some features that are critical. For one, the Manchester encoded
    signal is guaranteed to transition on each clock cycle. If you’re sending a continuous
    stream of 0s in the data, for example, there will still be transitions in the
    encoded signal. These transitions are essential for performing CDR on the receiving
    side. Without guaranteed transitions, the receiver wouldn’t be able to lock onto
    the input stream. It wouldn’t know if the data was being sent at 3 gigabits per
    second (Gb/s), or 1.5Gb/s, or if it was running at all.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 曼彻斯特编码只是生成自时钟信号的一种方式，它是一种简单的编码方案。它并不用于现代更复杂的SerDes应用，但它确实具有一些至关重要的特性。例如，曼彻斯特编码的信号保证在每个时钟周期都有转换。如果你正在发送一连串的0数据，编码后的信号中仍会有转换。这些转换对于接收端执行时钟数据恢复（CDR）至关重要。如果没有这些保证的转换，接收端将无法锁定输入数据流。它无法知道数据是否以3吉比特每秒（Gb/s）的速率传输，或者以1.5Gb/s的速率传输，或者是否根本没有传输。
- en: 'Another important feature of Manchester code is that it’s *DC balanced*, meaning
    there are an equal number of highs and lows in the resulting data stream. This
    helps maintain signal integrity and overcome non-ideal conditions on the wire
    during high-speed data transfer. We normally consider wires to be perfect conductors,
    but in reality they aren’t; every wire has some capacitance, inductance, and resistance.
    At slow data rates these don’t matter much, but when we get into the Gb/s range,
    we need to consider these effects. For example, since there’s some capacitance
    in the wire, it makes sense that the wire can be charged up like a capacitor.
    When a wire becomes slightly charged, for example to a high state, then it requires
    more energy to discharge it to a low state. Ideally, you don’t want to charge
    up your wires at all: in other words, you want to maintain a DC balance. Sending
    an equal number of high and low transitions in SerDes is critical to maintaining
    good signal integrity, and all clock and data encoding schemes have this feature.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 曼彻斯特编码的另一个重要特性是它是*直流平衡*的，这意味着生成的数据流中高电平和低电平的数量是相等的。这有助于保持信号完整性，并在高速数据传输过程中克服导线上的非理想条件。我们通常认为导线是完美的导体，但实际上并非如此；每根导线都有一定的电容、电感和电阻。在低速数据传输时这些因素不太重要，但当数据速率达到Gb/s级别时，就需要考虑这些影响。例如，由于导线中存在电容，导线可以像电容器一样充电。当导线稍微被充电时，例如处于高电平状态，那么将其放电至低电平状态需要更多的能量。理想情况下，你不希望导线被充电：换句话说，你希望保持直流平衡。在SerDes中发送相等数量的高电平和低电平转换对于保持良好的信号完整性至关重要，所有时钟和数据编码方案都具备这一特性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How SerDes Works</samp>
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SerDes的工作原理</samp>
- en: Now that we’ve covered the speed advantages of serial communication over parallel
    communication and examined how to combine the clock and data into one signal,
    we’re ready to look at how SerDes actually works. [Figure 11-7](#fig11-7) shows
    a simplified block diagram of a SerDes interface.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经讨论了串行通信相较于并行通信的速度优势，并且了解了如何将时钟和数据合并为一个信号，接下来我们将深入探讨SerDes的实际工作原理。[图11-7](#fig11-7)展示了一个简化的SerDes接口框图。
- en: '![](../images/Figure11-7.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-7: A simplified SerDes
    block diagram</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图11-7：简化的SerDes框图</samp>
- en: 'Looking at the image as a whole, we have a serializer on the left that acts
    as a transmitter, and a deserializer on the right that acts as a receiver. We
    have clock and data signals going into the serializer on the left, and clock and
    data signals coming out of the deserializer on the right. That’s really all we’re
    trying to do with SerDes: send some data and a clock signal from a transmitter
    to a receiver. However, doing this at fast data rates requires a lot more functionality
    than we’ve seen in simpler input and output buffers.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从整体上看，左侧是一个序列化器，充当发送器，右侧是一个反序列化器，充当接收器。我们有时钟和数据信号输入到左侧的序列化器，而时钟和数据信号则从右侧的反序列化器输出。这就是我们在做SerDes时真正想要实现的：从发送器发送一些数据和时钟信号到接收器。然而，要以高速数据传输进行这一操作，需要比我们在简单输入输出缓冲区中看到的更多的功能。
- en: First, notice that there’s a phase-locked loop on the transmit side, in the
    lower-left corner of [Figure 11-7](#fig11-7). Usually this is a dedicated PLL
    specific to the SerDes transceiver that uses a reference clock (Clk In) to generate
    the clock that will run the serializer. This clock dictates the overall rate at
    which your SerDes will run. The data that you actually want to send (Data In)
    comes into the SerDes block in parallel. I’ve drawn four lines here, but there
    could be any number of wires. The serializer takes the output of the PLL and the
    parallel data, encodes it using an encoding protocol, and generates a serial data
    stream at the desired SerDes rate. For example, if you have a parallel interface
    that takes 4 bits at a time at a 250 MHz clock rate, then the serializer will
    generate a serialized version of this data that can be transferred at 1Gb/s, four
    times that speed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意在发送端的左下角有一个锁相环（PLL），位于[图11-7](#fig11-7)中。通常这是一个专门为SerDes收发器设计的PLL，它使用参考时钟（Clk
    In）生成将驱动序列化器的时钟。这个时钟决定了SerDes的整体运行速率。你实际想要发送的数据（Data In）以并行形式进入SerDes模块。我这里画了四条线，但也可以有任意数量的线。序列化器接收PLL的输出和并行数据，使用编码协议进行编码，并以所需的SerDes速率生成串行数据流。例如，如果你有一个并行接口，每次接受4位数据，时钟频率为250
    MHz，那么序列化器将生成一个该数据的串行版本，可以以1Gb/s的速度传输，即该速度的四倍。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Depending on the encoding scheme, the actual serial stream will likely be
    running at above 1Gb/s. For example, the 8B/10B scheme takes 8-bit data and encodes
    it into 10-bit data. It does this for two purposes: to ensure transitions in the
    clock so we can do clock data recovery at the receiver, and to maintain a DC balance.
    Going from 8-bit data to 10-bit data adds a 20 percent overhead, however, so to
    send data at a rate of 1Gb/s we need to send the actual serial stream at 1.2Gb/s.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*根据编码方案，实际的串行数据流可能会以超过1Gb/s的速度运行。例如，8B/10B编码方案将8位数据编码为10位数据。这样做有两个目的：确保时钟中的跃迁，从而在接收器端进行时钟数据恢复，以及保持直流平衡。然而，将8位数据转化为10位数据会增加20%的开销，因此，为了以1Gb/s的速度发送数据，我们需要以1.2Gb/s的速度发送实际的串行数据流。*'
- en: The output stage is next. Notice that the output stage contains a differential
    output buffer. For the reasons discussed previously, such as the ability to send
    data at high rates, at lower power, and with noise immunity, SerDes transceivers
    use differential data. The output stage also performs some extra signal conditioning
    to improve the signal integrity. Once the signal is as conditioned as it can be,
    it passes through the data channel.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是输出阶段。注意，输出阶段包含一个差分输出缓冲区。出于之前讨论的原因，例如能够以较高的速率发送数据、低功耗以及抗噪声能力，SerDes收发器使用差分数据。输出阶段还会执行一些额外的信号调理，以提高信号的完整性。一旦信号的调理完成，它就会通过数据通道传输。
- en: Sending data at high speeds requires optimizations in all parts of the data
    path, including the data channel itself. For copper wires, the impedance of the
    material must be controlled to ensure good signal integrity. The channel can also
    be made from a different material than copper. For example, fiber optics can be
    used, where light rather than electricity is sent down thin glass or plastic wires.
    Fiber optics provides excellent signal integrity and is immune to EMI, but it’s
    a more expensive solution than traditional copper wires.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以高速发送数据要求数据路径各个部分进行优化，包括数据通道本身。对于铜线，必须控制材料的阻抗，以确保良好的信号完整性。通道也可以使用不同于铜的材料。例如，可以使用光纤，其中光而非电流通过细小的玻璃或塑料线传输。光纤提供了出色的信号完整性，并且免受电磁干扰（EMI），但它比传统铜线更昂贵。
- en: On the receive side, the input stage performs its own signal conditioning to
    extract the best-quality signal possible. The data is then sent to both a CDR
    block and the serial-to-parallel conversion and decoder block. The CDR recovers
    the clock signal from the data stream, and then the deserializer uses that extracted
    clock to sample the data. It might seem a bit odd that you can recover the clock
    and then use that clock to sample data from the same signal, but that’s the magic
    of how SerDes works! Finally, at the output side, the data is again converted
    to parallel. Continuing with the previous example, you would recover your 250
    MHz data stream across the four parallel output wires.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收端，输入阶段会执行自己的信号调节，以提取尽可能高质量的信号。然后，数据会被发送到 CDR 块和串行到并行转换与解码块。CDR 从数据流中恢复时钟信号，然后解串器利用提取的时钟信号对数据进行采样。可能看起来有些奇怪，你能从同一个信号中恢复时钟并利用该时钟采样数据，但这就是
    SerDes 工作的魔力！最后，在输出端，数据再次被转换为并行格式。继续之前的例子，你将会恢复通过四根并行输出线传输的 250 MHz 数据流。
- en: This example referred to a 1Gb/s data rate, but that isn’t really that fast
    anymore. As data rates keep increasing, we need to keep optimizing each part of
    this whole process. Maintaining high signal integrity is critical for SerDes applications.
    At fast data rates, small resistances, capacitances, and inductances can affect
    the signal integrity of the line. Passing data through a connector (for example,
    a USB plug) causes small imperfections in the data path that affect the signal
    integrity too, so optimizing every aspect of the process becomes critical.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子提到的是 1Gb/s 的数据速率，但现在这已经不算特别快了。随着数据速率的不断提升，我们需要持续优化这个过程的每一部分。维持高信号完整性对 SerDes
    应用至关重要。在高速数据传输时，小的电阻、电容和电感都会影响线路的信号完整性。通过连接器（例如 USB 插头）传输数据时，也会在数据路径中造成一些小的缺陷，从而影响信号完整性，因此优化每个环节变得至关重要。
- en: SerDes is one of the killer features of modern FPGAs, but there’s a lot of complexity
    involved. As you’ve just seen, something as simple-sounding as high-speed data
    transfer involves a number of steps, including serializing data, transmitting
    it, receiving it, and then deserializing it again. Even with that process, we’re
    fighting physics to get data to travel at faster and faster rates.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: SerDes 是现代 FPGA 的杀手级特性之一，但它涉及了很多复杂的内容。正如你刚才所看到的，像高速数据传输这样看似简单的操作，实际上涉及多个步骤，包括数据的串行化、传输、接收以及再反序列化。即使有了这个过程，我们依然要与物理学作斗争，以便让数据能够以越来越快的速度传输。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: To be a successful FPGA designer, it helps to have a strong understanding of
    I/O. This is where the FPGA engineer works at the intersection of electrical engineering
    and software engineering. This chapter explained how FPGAs use buffers to bring
    data in and send data out and explored some of the more common settings that FPGA
    designers need to be aware of when configuring I/O, including the operating voltage,
    drive strength, and slew rate. You learned about the difference between single-ended
    and differential communication, and you saw how DDR uses both rising and falling
    clock edges to send data more quickly. We also explored SerDes, a powerful input/output
    feature that allows FPGAs to excel at high-speed data applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 成为一名成功的 FPGA 设计师，有助于深入了解 I/O。这是 FPGA 工程师在电气工程和软件工程交汇处的工作领域。本章解释了 FPGA 如何使用缓冲区来接收数据并发送数据，并探讨了
    FPGA 设计师在配置 I/O 时需要注意的一些常见设置，包括操作电压、驱动强度和上升/下降速率。你了解了单端和差分通信的区别，并且看到 DDR 如何利用时钟的上升和下降沿来更快地发送数据。我们还探讨了
    SerDes，这一强大的输入/输出特性使得 FPGA 在高速数据应用中表现出色。
