- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">KERBEROS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Windows 2000, the Kerberos authentication protocol replaced Netlogon as the
    primary mechanism for authenticating users on a domain controller. This chapter
    builds upon the description of interactive domain authentication in [Chapter 12](chapter12.xhtml)
    to explain how a user can authenticate to a Windows domain using Kerberos.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking at how Kerberos works, including how to generate the
    encryption keys used in the protocol, and decrypt Kerberos authentication tokens.
    Once you understand the inner workings of the protocol, we’ll cover the delegation
    of authentication and the role of Kerberos in user-to-user authentication protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos was first developed at Massachusetts Institute of Technology (MIT)
    in the 1980s. Microsoft uses version 5 of the protocol, which was formalized in
    RFC1510 in 1993, then updated in RFC4120 in 2005\. Microsoft has also made a few
    modifications to the protocol to support its own needs; I’ll mention some of these
    changes over the course of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Interactive Authentication with Kerberos</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As its primary function, Kerberos distributes *tickets*, each of which represents
    a user’s verified identity. The system can use this identity to determine whether
    the user can access a service, such as a file server. For example, if the user
    sends their ticket in a request to open a file, the file server can check its
    validity, then decide whether to grant the user access through something like
    an access check.
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos provides a means of distributing these tickets securely over an untrusted
    network and allowing the tickets to be verified. It does this by using shared
    encryption keys, commonly derived from a user’s password, to encrypt and verify
    the tickets. The Active Directory server never stores the password in plaintext;
    it stores only the encryption key.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initial User Authentication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 14-1](chapter14.xhtml#fig14-1) shows the initial Kerberos user authentication
    process between a client computer and the domain controller running the *key distribution
    center (KDC)* service. The KDC issues Kerberos tickets to users and manages session
    encryption keys.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: An overview of
    Kerberos authentication</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When the LSA processes a logon request, it first derives the shared encryption
    key based on the user’s password and a salt ❶. It generates the salt based on
    values, such as the username and realm, that depend on the type of encryption
    algorithm in use. We use the term *realm* to describe the scope of the Kerberos
    authentication. In Windows, the realm is the DNS name for the domain that contains
    the user, such as *mineral.local*. We can combine the username and the realm to
    form a user principal name, commonly written with an at symbol (@), as in *user@mineral.local*.
  prefs: []
  type: TYPE_NORMAL
- en: The LSA then generates an *authentication service request (AS-REQ)* message
    and sends it over the network to the authentication server ❷. The authentication
    server is the part of the KDC that is responsible for issuing an initial ticket
    to the authentication process. The AS-REQ message contains the username and realm
    as well as *pre-authentication data*, which consists of the current time encrypted
    with the user’s shared encryption key. The authentication server can look up the
    shared key from its key database using the specified username and realm, then
    use the key to decrypt the pre-authentication data ❸. If it succeeds, it has verified
    that the data has come from the user, as only the server and the client should
    know the shared encryption key.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication server then generates a *ticket granting ticket (TGT)*, which
    it encrypts with the shared encryption key for a special user, *krbtgt*. The authenticating
    user doesn’t know the *krbtgt* user’s shared key, so they can’t decrypt the ticket.
    While the TGT has a special name, it’s essentially just a ticket that verifies
    the user’s identity to the *ticket granting server (TGS)*, which is responsible
    for issuing tickets for the user to authenticate to a network service. The ticket
    contains details about the user’s identity encoded in a *privilege attribute certificate
    (PAC)*, as well as a randomly generated session key for the TGS to use. We’ll
    see an example of a PAC in “Decrypting the AP-REQ Message” on page 469.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication server also generates a second data value and encrypts it
    with the user’s shared encryption key. This value, when decrypted, contains details
    about the ticket, such as how long it’s valid for. Eventually, a ticket expires,
    and the user will need to request a new TGT. This second value also contains the
    session encryption key, encrypted in the ticket. The authentication server packages
    the encrypted ticket and ticket information into the *authentication service reply
    (AS-REP)* message and sends it back to the client LSA ❹. [Figure 14-2](chapter14.xhtml#fig14-2)
    summarizes the format of this message.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: The AS-REP message
    format</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once the LSA receives the AS-REP, it can decrypt it and extract the session
    key from the encrypted ticket information by using the user’s shared encryption
    key. The successful decryption also demonstrates that the LSA is communicating
    with the correct authentication server, as another server wouldn’t know the user’s
    shared key.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the LSA still doesn’t know all of the user’s information, as this information
    is stored in the PAC, which is encrypted in the ticket. To get the PAC, the LSA
    must request a ticket for itself from the TGS ❺. To do so, the LSA packages up
    the TGT, which it can’t alter, with the *service principal name (SPN)* of the
    service it wants to access. The SPN is a string of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">service class/instance
    name/service name</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'The *service class* is the type of service to use. The *instance name* is the
    hostname or network address that the service is running on. Finally, the *service
    name* is an optional value for disambiguating similar services on the same host.
    For the LSA to request a ticket for itself, it must set the service class to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp> and the instance name to the
    current host, such as *graphite.mineral.local*. When converted to a string, this
    creates the following SPN: <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST/graphite.mineral.local</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: You might remember that we used this string format to specify a target name
    for NTLM authentication in [Chapter 13](chapter13.xhtml). In fact, Windows took
    this format from Kerberos and applied it to NTLM to try to counter NTLM relay
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that the server can verify its request, the LSA will also generate
    a cryptographic hash of the TGT. This hash encompasses the SPN, a timestamp, and
    a unique sequence number, all encrypted with the session key from the AS-REP’s
    encrypted data value. This additional encrypted value is called the *authenticator*.
    The TGT, SPN, and authenticator are packaged up in a *ticket granting service
    request (TGS-REQ)* message and sent to the TGS. [Figure 14-3](chapter14.xhtml#fig14-3)
    summarizes the format of this message.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The TGS-REQ message
    format</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The TGS receives the TGS-REQ message, and because it knows the shared encryption
    key for the *krbtgt* user, it can decrypt the TGT. This allows it to extract details
    about the user, as well as the session key. It can then verify that the ticket
    hasn’t expired or isn’t otherwise invalid (which would be the case if the user
    weren’t allowed to authenticate to the domain or service).
  prefs: []
  type: TYPE_NORMAL
- en: The TGS can use the session key from the ticket to decrypt the authenticator
    and verify that the hash matches the associated information. This process ensures
    that only a user with access to the shared encryption key could have extracted
    the session key from the AS-REP and encrypted the contents of the authenticator
    for this TGT. The TGS then verifies that the timestamp is recent. Typically, it
    will reject the request if the timestamp is older than five minutes. For this
    reason, it’s crucial to Kerberos authentication that the client and server systems
    have synchronized clocks. The TGS also checks that it hasn’t already seen the
    ticket’s sequence number. This check counters replay attacks, in which the same
    TGS-REQ is sent multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: If all the checks pass, the TGS can look up the SPN in the key database to retrieve
    an encryption key. Technically, each SPN could have its own encryption key, but
    Active Directory usually just maps these SPNs to a user or computer account. For
    example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST/graphite.mineral.local</samp>
    SPN is mapped to the computer account for the *GRAPHITE* machine. You can query
    the SPNs an account is mapped to using the <samp class="SANS_TheSansMonoCd_W5Regular_11">setspn</samp>
    utility or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>
    PowerShell command, as shown in [Listing 14-1](chapter14.xhtml#Lis14-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-1: Enumerating SPNs mapped to the current computer account'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the host exists, the TGS can extract the shared encryption key for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp> service ticket it
    will generate. If you return to [Figure 14-1](chapter14.xhtml#fig14-1), you’ll
    see that the TGS will copy the PAC from the decrypted TGT into this new ticket
    and encrypt it with the session key for the SPN ❻. The TGS generates the same
    encrypted data as it did with the AS-REP, including the session key for the service
    to use. Then it packages the new ticket and the encrypted value into the *ticket
    granting service reply (TGS-REP)* and returns it to the client ❼. [Figure 14-4](chapter14.xhtml#fig14-4)
    summarizes the format of the TGS-REP message.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: The TGS-REP message
    format</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The LSA can now verify that it can decrypt the contents of the ticket and ensure
    the ticket targets the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>
    SPN it requested. In particular, as the last step in [Figure 14-1](chapter14.xhtml#fig14-1),
    it uses the PAC to create the new user’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object ❽. This completes the authentication process. The user has now been authenticated,
    and the system can start its logon session, console session, and processes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Network Service Authentication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once the user has been authenticated to the local machine, the LSA must cache
    the following information before the user can communicate with other services
    on the network: the user’s shared encryption key, which is based on their password;
    the TGT, to request additional service tickets; and the TGT session key.'
  prefs: []
  type: TYPE_NORMAL
- en: The SSPI APIs discussed in the previous chapter include a Kerberos security
    package that handles the network service authentication process to retrieve a
    valid ticket for a network service based on its SPN. [Figure 14-5](chapter14.xhtml#fig14-5)
    provides an overview of the process of getting a ticket for a network service.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: Kerberos authentication
    to a network service</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This authentication process involves three systems: the client, the server,
    and the KDC. The first thing the client does is call the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    SSPI API with the user credentials and the network service’s SPN ❶.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-5](chapter14.xhtml#fig14-5), we’re assuming that we’re making
    the authentication request as an existing authenticated user with a cached TGT.
    If we’re not, and we’ve specified a username and password, the LSA needs to get
    the TGT for that user by following the authentication process outlined in the
    previous section. If the LSA already has a valid TGT, it can make a request to
    the TGS for a new ticket targeting the specified SPN ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The TGS then verifies that the TGT is valid and that the caller knows the session
    key, which it can extract with knowledge of the user’s shared key. Once it has
    verified this value, the TGS looks up the shared encryption key for the target
    SPN. If the SPN doesn’t exist or the user isn’t allowed to use the service, it
    returns an error, which the LSA will report to the caller. If everything occurs
    correctly, the TGS will generate the TGS-REP message with the new ticket and return
    it to the client’s LSA ❸.
  prefs: []
  type: TYPE_NORMAL
- en: As with the original TGT, the TGS encrypts the ticket using a key the client
    shouldn’t have access to. However, it encrypts the extra encrypted value using
    the TGT’s session key, which the LSA can decrypt. This encrypted value contains
    the session key for communicating with the service. The LSA takes the ticket and
    generates an authenticator encrypted with the service session key, then packages
    the ticket and authenticator into an *authentication protocol request (AP-REQ)*
    message. The structure of this message is basically the same as that of the TGS-REQ
    message, but the request is sent to the service rather than the TGS.
  prefs: []
  type: TYPE_NORMAL
- en: The LSA returns this AP-REQ to the user ❹. At this point, the client application
    regains control of the authentication process, and it can package up the AP-REQ
    into the network protocol and transmit it to the server ❺. The server extracts
    the AP-REQ and passes it to its own LSA via the <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>
    API ❻.
  prefs: []
  type: TYPE_NORMAL
- en: The LSA on the server should already have the shared encryption key for the
    cached ticket. It’s common to tie the SPN to the computer account used by the
    *Local System* user. Therefore, any privileged service, such as the SMB server,
    should have access to the computer’s password needed to decrypt the ticket. If
    the service is running as a user, the system must have configured an SPN mapping
    for that user before the ticket can be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming it can decrypt and verify the ticket, the server’s LSA will then extract
    the PAC from the ticket and build a local token for the user. The PAC has a signature
    that the server can use to verify that it hasn’t been tampered with. Also, an
    optional verification process can ensure that the PAC was issued by the KDC. The
    network service can now use the generated token to impersonate the authenticating
    user ❼.
  prefs: []
  type: TYPE_NORMAL
- en: The final step in [Figure 14-5](chapter14.xhtml#fig14-5) is optional. By default,
    the server doesn’t need to return anything to the client to complete the authentication;
    it has everything it needs to decrypt the ticket and let the service access the
    user’s identity. However, you might want to ensure that the server you’re talking
    to knows the ticket’s key and isn’t lying. One way that the server can prove it
    knows the encryption key is to encrypt or sign something using the ticket’s session
    key and return this to the client. We refer to this practice as *mutual authentication*.
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos uses the *authentication protocol reply (AP-REP)* message to send this
    encrypted value back to the client ❽. The AP-REP message contains an authenticator
    value like the one sent in the AP-REQ, but it has a slightly different format,
    as it is encrypted using the session key. Because only a valid recipient of the
    ticket could have decrypted the session key to encrypt the authenticator, this
    verifies the server’s identity.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Performing Kerberos Authentication in
    PowerShell</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How much of the network service authentication process can we observe from PowerShell?
    Let’s find out. We’ll start by getting the credentials handle, as shown in [Listing
    14-2](chapter14.xhtml#Lis14-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-2: Setting up a client authentication context for Kerberos'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Kerberos</samp>
    package ❶ instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp>
    package we used in the previous chapter. Once we receive the handle, we can create
    a client authentication context. To do this, we must specify an SPN to authenticate
    to; here I’ve picked the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>
    SPN on the local computer ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the LSA should get a ticket for the service by using the previously
    negotiated TGT and sending a TGS-REQ. If the SPN is incorrect or unknown, the
    TGS will return an error, which the LSA will pass back to us when it creates the
    client authentication context. The error will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In [Listing 14-2](chapter14.xhtml#Lis14-2), the only thing we receive is the
    AP-REQ ❸; we don’t receive the TGS-REQ or the TGS-REP. Because we formatted the
    fields of the Kerberos authentication token, we can see only the values available
    in plaintext. This includes a set of option flags currently set to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>;
    other values would indicate various properties of the request, which we’ll come
    back to when we discuss configuring the optional mutual authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The ticket also contains the target SPN and realm ❹, which the server needs
    to select the correct shared encryption key. You can recognize an SPN based on
    the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SRV_INST</samp>
    name type, which indicates a service instance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the ticket specifies the encryption parameters. First it lists the algorithm
    used to encrypt and verify the ciphertext. In this case, it uses AES ciphertext-stealing
    mode (CTS) with a 256-bit key for encryption and a SHA1 HMAC truncated to 96 bits
    ❺. [Table 14-1](chapter14.xhtml#tab14-1) shows other common encryption algorithms
    used by Windows.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Kerberos Encryption Types on Windows</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Encryption</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Verification</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AES256_CTS_HMAC_SHA1_96</samp>
    | <samp class="SANS_Futura_Std_Book_11">AES CTS 256-bit</samp> | <samp class="SANS_Futura_Std_Book_11">SHA1
    HMAC truncated to 96 bits</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AES128_CTS_HMAC_SHA1_96</samp>
    | <samp class="SANS_Futura_Std_Book_11">AES CTS 128-bit</samp> | <samp class="SANS_Futura_Std_Book_11">SHA1
    HMAC truncated to 96 bits</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DES_CBC_MD5</samp> | <samp
    class="SANS_Futura_Std_Book_11">DES 56-bit</samp> | <samp class="SANS_Futura_Std_Book_11">MD5
    HMAC</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ARCFOUR_HMAC_MD5</samp> | <samp
    class="SANS_Futura_Std_Book_11">RC4</samp> | <samp class="SANS_Futura_Std_Book_11">MD5
    HMAC</samp> |'
  prefs: []
  type: TYPE_TB
- en: Notice that the ticket contains the *key version number* ❻. When a user or computer
    changes its password, the shared encryption key must also change. To ensure that
    the system selects the correct key, it stores this version number with the password-derived
    key and increments it upon every key change. In this case, the version is 1, which
    means the computer has never changed its password.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of the key version number indicates that the ticket is encrypted
    with a long-lived shared encryption key. A missing version number would indicate
    that the ticket was encrypted with a previously negotiated session key. Because
    we’re looking at the first message being sent to the service as part of this authentication
    process, the client and service do not currently share any session key, so the
    client must use the computer’s shared encryption key.
  prefs: []
  type: TYPE_NORMAL
- en: The encrypted ciphertext follows the key information. Since we don’t know the
    encryption key, we can’t decrypt it. Following the ticket is the authenticator
    ❼, which also starts by listing key information. Notice the lack of a key version
    number; it’s missing here because the authenticator is encrypted with the session
    key inside the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In this case, because we’ve generated a ticket targeting the computer we’re
    currently running on, we could extract the computer account encryption key, either
    by directly accessing it in memory or from the MACHINE.ACC$ LSA secret in the
    registry. This process is outside the scope of this chapter.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can complete the authentication process by passing the client authentication
    token to a server authentication context, in the same way we did when using NTLM
    authentication in [Chapter 13](chapter13.xhtml). [Listing 14-3](chapter14.xhtml#Lis14-3)
    demonstrates this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-3: Completing the Kerberos authentication'
  prefs: []
  type: TYPE_NORMAL
- en: We set up the server authentication context, then update the context with the
    client’s authentication token. However, when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    PowerShell command, the authentication fails with an error. Perhaps this shouldn’t
    come as a massive surprise. Only the *Local System* user has direct access to
    the shared encryption key for the computer account used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>
    SPN. Therefore, when the LSA verifies the AP-REQ, it can’t decrypt it and returns
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Can we find an SPN that we can negotiate locally? Windows specifies a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RestrictedKrbHost</samp> service class.
    The SPN for the local computer with this service class is mapped to the computer
    account, so the ticket is once again encrypted using the computer account’s key.
    However, the LSA treats the service class specially and will allow any user on
    the system to decrypt it, unlike with <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>.
    When we change the command to use the restricted service class instead, we get
    the output shown in [Listing 14-4](chapter14.xhtml#Lis14-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-4: Authenticating using the RestrictedKrbHost SPN'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we change the SPN to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">RestrictedKrbHost</samp>
    service class for the current computer name ❶. We then complete the authentication,
    as in Listings 14-2 and 14-3\. Note the change in the SPN provided in the AP-REQ
    message ❷. This time, when we update the server authentication context the operation
    succeeds, so we can extract the generated <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object and display the logon session ❸.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 14-5](chapter14.xhtml#Lis14-5), we test mutual authentication and
    view the returned AP-REP message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-5: Enabling mutual authentication'
  prefs: []
  type: TYPE_NORMAL
- en: We enable mutual authentication by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp>
    request attribute flag when creating the client authentication context ❶. In the
    AP-REQ message, we see that a <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuthRequired</samp>
    flag is set ❷, which requires the service to return an AP-REP message. When we
    format the server’s authentication token, we see the AP-REP message, which contains
    only an encrypted value ❸. The encryption key information ❹ doesn’t have a key
    version number, as this is encrypted by the session key, not a shared encryption
    key.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Decrypting the AP-REQ Message</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we receive an AP-REQ message, we’ll want to decrypt it. But so far, we’ve
    encrypted all the tickets in our examples using a key derived from the computer’s
    password. While we might be able to extract this password for use in the decryption
    operation, doing so would require a lot of additional work. How can we decrypt
    the ticket for the AP-REQ message with the least amount of effort?
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach is to specify an SPN that causes the TGS to use our own password.
    We can then derive the encryption key based on the account password we control
    to decrypt the ticket. You can add an SPN to your user account using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">setspn</samp> utility or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp>
    PowerShell command. You’ll need to do this as a domain administrator; otherwise,
    you won’t have the Active Directory access necessary to configure it. The following
    command adds the SPN <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp>
    to the *alice* user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can also use this command to remove SPNs by changing <samp class="SANS_TheSansMonoCd_W5Regular_11">Add</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove</samp>. The SPN can be
    almost arbitrary, but it’s a best practice to stick to known service classes and
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: We can now run the script to perform the authentication with the new SPN. [Listing
    14-6](chapter14.xhtml#Lis14-6) shows the resulting AP-REQ.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-6: The AP-REQ for the HTTP/graphite SPN'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you examine this output, you’ll see that not much has changed, but we can
    at least confirm that the ticket relates to the SPN we specified. This means we
    can request a ticket for the service that should map to the user. One other change
    is that the encryption type is now RC4 rather than AES. This is due to an odd
    behavior of Kerberos in Windows: when the SPN is assigned to a user, the encryption
    type defaults to RC4\. This is good news for us, as RC4 is much simpler to decrypt,
    as you’ll soon see. Note also that the key version number is set, indicating that
    the ticket is encrypted with the shared encryption key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can decrypt this ticket, we need to generate a key for the encryption
    algorithm. Generating an RC4 key is easy: we simply calculate the MD4 hash of
    the Unicode password on which it is based. We’ve seen this operation before: this
    key is identical to the NT hash used in NTLM, and not by coincidence. When Microsoft
    introduced the RC4 algorithm into Kerberos, it used the NT hash to support existing
    users without requiring them to update their passwords to generate new encryption
    keys. The use of the RC4 algorithm also circumvents difficulties involving cryptography
    export restrictions.'
  prefs: []
  type: TYPE_NORMAL
- en: If we supply the user’s password, we can generate the RC4 Kerberos key using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosKey</samp> PowerShell
    command, as shown in [Listing 14-7](chapter14.xhtml#Lis14-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-7: Generating an RC4 Kerberos key for the SPN'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you must use the valid password of the user account with which you’re
    running the example.
  prefs: []
  type: TYPE_NORMAL
- en: We can now pass the AP-REQ authentication token and the key to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaAuthToken</samp>
    PowerShell command to decrypt the ticket and authenticator. By passing the decrypted
    authentication token to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    command, we can display the unprotected information. As the decrypted ticket is
    quite large, we’ll inspect it in parts, starting in [Listing 14-8](chapter14.xhtml#Lis14-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-8: The basic decrypted ticket information'
  prefs: []
  type: TYPE_NORMAL
- en: The unencrypted ticket begins at the <samp class="SANS_TheSansMonoCd_W5Regular_11">Realm</samp>
    value. Most of what follows is bookkeeping information, including flags that do
    things like indicate the fact that pre-authentication occurred (<samp class="SANS_TheSansMonoCd_W5Regular_11">PreAuthent</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag is related
    to delegation, a topic we’ll come back to in “Kerberos Delegation” on page 479.
    The ticket also contains the SPN of the user being authenticated ❶. Because the
    *alice* user requested the ticket for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp>
    service, this user’s information is what is being authenticated. Next, we see
    that the ticket has a limited lifetime, in this case based on the authentication
    time ❷ and an end time, making it valid for around 10 hours. When the ticket expires,
    the client can renew it for another five days. (The <samp class="SANS_TheSansMonoCd_W5Regular_11">Renewable</samp>
    flag encodes information about the ability to renew the ticket.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-9](chapter14.xhtml#Lis14-9) shows the next component of the ticket:
    the randomly generated session key.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-9: The ticket session key'
  prefs: []
  type: TYPE_NORMAL
- en: This session key is used to encrypt the authenticator. The client and server
    might also use it to encrypt and verify any subsequent keys or data they transmit.
  prefs: []
  type: TYPE_NORMAL
- en: After this is a list of authorization data values that the server can use to
    determine the security properties of the client user. The most important of these
    is the PAC, which contains everything the receiving Windows system needs to build
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object for the user.
    The PAC is itself split into multiple parts. [Listing 14-10](chapter14.xhtml#Lis14-10)
    contains its logon information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-10: The logon PAC entry'
  prefs: []
  type: TYPE_NORMAL
- en: 'The logon PAC entry follows the format used in the Netlogon protocol prior
    to Windows 2000\. It starts with basic user information ❶, such as the user’s
    name, SID, and primary group. Next comes the list of group memberships, split
    into three parts: domain groups ❷, resource groups ❸, and extra groups ❺. For
    each group, the SID (formatted as a name if known) and the attributes that should
    apply to it are shown. For size reasons, the domain and resource group SIDs are
    only stored using the last RID value. The full SIDs are derived by adding this
    RID to the logon domain SID ❼ or the resource group SID ❹, respectively. The extra
    groups list stores the full SIDs and so can contain SIDs with different prefixes.'
  prefs: []
  type: TYPE_NORMAL
- en: After the group information is additional bookkeeping about the user, such as
    when they last logged on and changed their password ❻. This section also includes
    information about the server and domain that authenticated the user, including
    the domain name and SID. The user flags show that the extra and resource groups
    are present in the ticket. The user account control flags indicate properties
    of the account (in this case, that the user’s password doesn’t expire).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is an empty session key consisting of all zeros ❽. You’ll find
    a non-empty session key only if the KDC didn’t directly authenticate the user
    and instead used another authentication protocol, such as NTLM. In this case the
    session key for that sub-authentication protocol will be shown here; however,
    in most cases it will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-11](chapter14.xhtml#Lis14-11) shows the next PAC entry, which contains
    the user’s claim attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-11: The user claims PAC entry'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 4](chapter4.xhtml), the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object exposes these user claims as security attributes, and they can play a role
    in the access control process, typically through a central access policy. If the
    target SPN is a computer account rather than a user account, the Kerberos ticket
    will also include information about the client device in the form of device groups
    and device claims, as shown in [Listing 14-12](chapter14.xhtml#Lis14-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-12: The device groups and device claims PAC entries'
  prefs: []
  type: TYPE_NORMAL
- en: As with the user claims, you’ll typically only find these used in a central
    access policy. [Listing 14-13](chapter14.xhtml#Lis14-13) shows additional bookkeeping
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-13: The client info and UPN PAC entries'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Client ID</samp> field should
    match the user’s authentication time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-14](chapter14.xhtml#Lis14-14) shows a couple of signatures applied
    to the PAC data to ensure it hasn’t been tampered with. Without these signatures,
    the user could forge their own PAC, adding any groups they would like the LSA
    to place in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-14: PAC signatures'
  prefs: []
  type: TYPE_NORMAL
- en: The first signature covers the entire PAC. However, as the signature fields
    are embedded inside the PAC, they’re replaced with zeros during the signature
    calculation. This signature is generated using the shared key used to encrypt
    the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: The second signature is used to verify that the server signature was issued
    by the KDC. This signature covers only the server and uses the encryption key
    for the *krbtgt* user. To verify the signature, the server needs to send it to
    the KDC, as it doesn’t know the encryption key. For performance reasons, it’s
    common to not perform this validation when the server is running as a privileged
    user such as *SYSTEM*.
  prefs: []
  type: TYPE_NORMAL
- en: The final signature is calculated from the entire ticket with the PAC removed.
    The encryption key used for the signature is the one for the *krbtgt* user. This
    signature allows the KDC to detect any tampering of the ticket, which the server
    signature wouldn’t cover, as it verifies only the PAC.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Windows has faced multiple security issues related to PAC signature verification.
    Most notable is CVE-2014-6324, which occurred because the TGS accepted CRC32 as
    a valid signature mechanism. As CRC32 is not cryptographically secure and can
    be trivially brute-forced, an attacker could create a valid PAC containing any
    groups they liked, including the full domain administrator.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Listing 14-15](chapter14.xhtml#Lis14-15) shows the final component of the
    decrypted AS-REQ message, the authenticator.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-15: The decrypted AS-REQ authenticator'
  prefs: []
  type: TYPE_NORMAL
- en: The authenticator contains some basic user information, as well as a timestamp
    indicating when it was created on the client that can be used to confirm the request
    is recent and has not been replayed to the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'One odd thing you might notice is that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp>
    field is present, but it doesn’t appear to contain a valid cryptographic hash
    ❶. This is because the authenticator has repurposed this field to store additional
    information, as indicated by the type value <samp class="SANS_TheSansMonoCd_W5Regular_11">GSSAPI</samp>.
    By default, this field contains the channel binding for the connection, if specified,
    and some additional flags. In this case, no channel binding is set, so the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Channel Binding</samp> field contains
    all zeros. If you were to specify a <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>
    parameter in the same way we did when using NTLM, the field would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The authenticator contains a sub-session key ❷, which the connection can use
    going forward. It also contains a randomly generated sequence number ❸ that, along
    with the timestamp, can thwart replay attacks that attempt to use the same ticket
    and authenticator. Finally, the authenticator can contain additional authorization
    data ❹. In this case, the data specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">AD_ETYPE_NEGOTIATION</samp>
    type, which allows the connection to try to upgrade the encryption algorithm used
    from RC4 to one of the AES encryption formats.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">GSSAPI</samp> type value used
    in [Listing 14-15](chapter14.xhtml#Lis14-15) represents the *Generic Security
    Services Application Program Interface (GSSAPI)*, a general API for implementing
    network authentication protocols. You would use GSSAPI instead of SSPI on Linux
    or macOS to perform Kerberos authentication. RFC2743 and RFC2744 define the current
    version of GSSAPI, while RFC4121 defines the protocol’s Kerberos-specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: SSPI is mostly compatible with GSSAPI, and it’s common to find network protocol
    documentation that refers to the GSSAPI names of the functions to use, especially
    for encryption and signatures. For example, to encrypt and decrypt data in GSSAPI,
    you would use the <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_Wrap</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_Unwrap</samp> functions,
    respectively, instead of the SSPI <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs.
    Similarly, for signature generation and verification, you would use <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_GetMIC</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_VerifyMIC</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp>. As this is a book
    on Windows security, we won’t dwell on the intricacies of GSSAPI any further.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Decrypting the AP-REP Message</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we’ve decrypted the AP-REQ message’s ticket and authenticator, we have
    the key we need to decrypt the AP-REP used for mutual authentication. We do so
    in [Listing 14-16](chapter14.xhtml#Lis14-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-16: Decrypting the AP-REP message'
  prefs: []
  type: TYPE_NORMAL
- en: We first need to get the session key from the decrypted AP-REQ ticket. With
    that key, we can decrypt the AP-REP using <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaAuthToken</samp>
    once again. In the output, you can see the newly negotiated session key; in this
    case, it’s been upgraded from RC4 to an AES key. It also includes a sequence number
    to prevent replay attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll look at one more topic related to Kerberos service authentication:
    how it works across domain trust boundaries.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Cross-Domain Authentication</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When discussing domain forests in [Chapter 10](chapter10.xhtml) I mentioned
    the concept of trust relationships, in which a trusted domain accepts credentials
    belonging to a user configuration stored on a different domain. This section discusses
    how the Kerberos protocol works across domains in the same forest. Although Kerberos
    authentication can also occur between forests, and with non-Windows Kerberos implementations,
    we won’t cover those complex cases here.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-6](chapter14.xhtml#fig14-6) shows the basic operations of inter-domain
    Kerberos authentication between the example *MINERAL* and *SALES* domains.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: An overview of
    inter-domain Kerberos authentication</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The client in the *MINERAL* domain first requests a service ticket for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.SALES</samp> SPN ❶. The TGS can’t
    satisfy this request, as the SPN isn’t present in its own domain. It checks the
    global catalog to see if any other domain in the forest has the SPN configured,
    and finds it in the *SALES* domain.
  prefs: []
  type: TYPE_NORMAL
- en: The TGS then checks whether it has a trust relationship with the *SALES* domain,
    which it does. When a new trust relationship is established between two domains,
    a shared Kerberos key is configured between the domain controllers in each domain.
    This key encrypts a *referral ticket*, which contains the user’s information and
    the requested service, and returns it to the client ❷. The client then forwards
    the referral ticket to the TGS in the *SALES* domain ❸. As the ticket is encrypted
    using a shared inter-domain key, the *SALES* TGS can decrypt it to verify its
    contents.
  prefs: []
  type: TYPE_NORMAL
- en: The *SALES* TGS needs to modify the PAC provided in the referral ticket to add
    domain-local group memberships for the *SALES* domain based on the user’s existing
    groups. The TGS will then re-sign the modified PAC and insert it into the service
    ticket for use by the local service. It can now issue the service ticket for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.SALES</samp> and, using the service’s
    key, return it to the client ❹.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In complex inter-domain trust relationships, domains shouldn’t trust any additional
    SIDs included in the PAC, as an attacker who has compromised the source domain
    could generate a PAC containing arbitrary SIDs and then compromise the target*
    *domain. Windows implements a SID-filtering mechanism to remove SIDs from the
    PAC that are deemed dangerous, such as any SIDs for the local domain. The full
    details of SID filtering are, however, outside the scope of this book.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Finally, the client can use the service ticket to authenticate to the services
    in the *SALES* domain ❺. The server receiving the service ticket can use it to
    build a token based on the modified PAC generated by its domain’s TGS.
  prefs: []
  type: TYPE_NORMAL
- en: The domains might need to repeat this process of issuing a referral ticket multiple
    times if they don’t have a direct trust relationship. For example, returning to
    the example domains from [Chapter 10](chapter10.xhtml), if a user in the *ENGINEERING*
    domain wanted to authenticate to a service in the *SALES* domain, then the root
    *MINERAL* domain would first have to issue a referral ticket. This ticket could
    then be used to establish a referral ticket for the *SALES* domain.
  prefs: []
  type: TYPE_NORMAL
- en: In more complex forests consisting of many domains and trees, this multi-hop
    referral process might lead to poor performance. To remediate this, Windows provides
    a mechanism to establish a *shortcut trust* relationship between any two domains
    in a forest. The domains can use this trust to establish the referral ticket without
    needing to follow the normal transitive trust path.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered the basics of Kerberos authentication. Now let’s move on to deeper
    topics, starting with how an authenticated user can securely forward their credentials
    to a service.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Kerberos Delegation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Delegation* enables a service to forward a user’s credentials to another service.
    This is useful because, when a user connects to a service using Kerberos, they
    do not provide it with their credentials. Instead, they provide a ticket that
    has been encrypted using the server’s shared encryption key. The service could
    try forwarding the ticket on to another service, but as it won’t know the new
    service’s shared encryption key it won’t be able to encrypt the ticket, so the
    new service won’t accept it.'
  prefs: []
  type: TYPE_NORMAL
- en: The only way to get an encrypted ticket for a new service might seem to be to
    send a TGS-REQ message to the TGS using a TGT. However, the original service only
    has a TGT for its own account, not for the user, and without the user’s TGT a
    service can’t forward a user’s credentials further than specified. This behavior
    provides an important security measure; if any authentication a user made to a
    service could be delegated to another service, it would likely be easy to get
    full administrator access to the domain.
  prefs: []
  type: TYPE_NORMAL
- en: That said, forwarding credentials is a useful feature. For example, let’s say
    you have a corporate network that users can access only from an external network,
    via a web server. It would be useful if the web server could provide the users’
    credentials to access the backend systems, such as a database server. One way
    of solving this issue would be for the web server to request the user’s plaintext
    credentials and then use those to authenticate to the domain, which would then
    provide the user’s TGT. In practice, though, this is a terrible idea for security.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to make it possible to securely forward credentials, Kerberos implements
    a defined delegation process. A client can opt in to delegation, allowing a target
    service to use their identity to request tickets for other network services on
    their behalf. Windows domains configure delegation on a per-account basis for
    both users and computers. In the GUI, you’ll see the delegation dialog shown in
    [Figure 14-7](chapter14.xhtml#fig14-7) when inspecting the properties of an account.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: The delegation
    tab for the</samp> <samp class="SANS_Futura_Std_Book_11">GRAPHITE</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">computer account</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-7](chapter14.xhtml#fig14-7) shows three main options for delegation.
    The first option, the default, disables delegation for the account. The second
    option, called *unconstrained delegation*, allows the account to delegate to any
    other service on the network using the authenticating user’s credentials. The
    third option, known as *constrained delegation*, allows the user’s credentials
    to be delegated to a fixed set of services defined by a list of permitted SPNs.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig into the similarities and differences between the two types of delegation
    and see how they’re implemented. In the following sections, we’ll modify some
    of the delegation settings in the Active Directory server. This means that you
    must perform these operations from a user account that has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeEnableDelegationPrivilege</samp>
    on the domain controller. Typically, only administrators have this privilege,
    so you should run these examples as a domain administrator.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unconstrained Delegation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Microsoft introduced unconstrained delegation in Windows 2000 along with the
    original Windows Kerberos implementation. This Kerberos delegation mechanism requires
    the client to opt in to providing a copy of their TGT, enabling the service to
    delegate their credentials. It works only with Kerberos authentication, as the
    user must have first authenticated to the service using the Kerberos protocol.
    [Figure 14-8](chapter14.xhtml#fig14-8) gives an overview of the unconstrained
    delegation process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: The unconstrained
    delegation process</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This figure shows a client delegating its credentials through the HTTP service
    on the server *WEB* to the database service on the server *DB*. The client first
    makes a ticket request to the TGS with its TGT for a normal ticket, using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.MINERAL</samp> SPN ❶. If
    the destination service can use delegation, the returned ticket should have the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OkAsDelegate</samp> flag set, which
    indicates to the client that it can delegate if it wants to.
  prefs: []
  type: TYPE_NORMAL
- en: The client then makes a second request for a new TGT to send to the HTTP service.
    The client indicates its intention by specifying the target principal name as
    the *krbtgt* user and setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwarded</samp> flags on the
    TGS-REQ ❷. If delegation is allowed, the TGS will return this new TGT to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The client can then package up the original service ticket and the TGT into
    the AP-REQ message for the server and send it over HTTP ❸. The AP-REQ must also
    contain the session key information for the encrypted TGT so that the target service
    can decrypt it. The Windows APIs enable mutual authentication when delegating
    credentials, so the server returns an AP-REP to the client ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Once the HTTP service has received the AP-REQ, it can get the LSA to give it
    a token for that user. The LSA will also save the TGT and session key information
    in the new logon session. When the HTTP service wants to authenticate to the database
    service, it can impersonate the user’s token and start the Kerberos authentication
    process. This means the user’s TGT will be used to request a ticket for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SQL/DB.MINERAL</samp> from the TGS ❺.
    Assuming the service meets all the policy requirements, the TGS will return the
    service ticket ❻, which the LSA will return as a new AP-REQ to pass to the database
    service ❼, completing the delegation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the delegated TGT is sent via the AP-REQ message, we should be able to inspect
    the delegation process occurring during a local authentication in PowerShell.
    The authenticating user needs a registered SPN. We’ll use the *alice* user, for
    whom we added an SPN in “Decrypting the AP-REQ Message” on page 469. First we
    must enable unconstrained delegation for this user. You can either use the GUI
    to enable the delegation, or run the following <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADAccountControl</samp>
    PowerShell command as a domain administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can verify that delegation has been enabled using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp> command
    (depending on the account type), as shown in [Listing 14-17](chapter14.xhtml#Lis14-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-17: Querying the user’s TrustedForDelegation property'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s create a client authentication context and request an AP-REQ message
    with a delegate ticket ([Listing 14-18](chapter14.xhtml#Lis14-18)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-18: Requesting an AP-REQ and displaying the delegate ticket'
  prefs: []
  type: TYPE_NORMAL
- en: We must specify both the <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Delegate</samp> flags ❶ for
    the LSA to request the delegated TGT. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">OkAsDelegate</samp>
    flag is set in the resulting ticket ❷. This flag exists regardless of whether
    the client requested delegation, as the LSA combines it with the delegate request
    attribute to determine whether to request the TGT.
  prefs: []
  type: TYPE_NORMAL
- en: The authenticator stores the new TGT as part of the GSSAPI checksum, as shown
    in [Listing 14-19](chapter14.xhtml#Lis14-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-19: The AP-REQ authenticator with the delegated TGT'
  prefs: []
  type: TYPE_NORMAL
- en: If you compare this authenticator with the one shown in [Listing 14-15](chapter14.xhtml#Lis14-15),
    the first difference you should notice is that both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Delegate</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutual</samp> context flags
    are set ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Delegate</samp> flag indicates
    that a *Kerberos Credential (KRB-CRED)* structure is packed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp>
    field. Within the KRB-CRED, we find the TGT ticket ❷. We can tell it’s a TGT because
    it’s for the *krbtgt* principal ❸. The KRB-CRED structure also contains an extra
    encrypted part to hold the session keys that go with the TGT ❹.
  prefs: []
  type: TYPE_NORMAL
- en: If we can complete the authentication, we can receive an impersonation token.
    The LSA now has enough information for the service to request any service ticket
    on behalf of the user that provided the delegated TGT, as demonstrated in [Listing
    14-20](chapter14.xhtml#Lis14-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-20: Completing the delegation authentication process'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
    in [Listing 14-20](chapter14.xhtml#Lis14-20) has the Delegation impersonation
    level. Certain kernel APIs enforce this impersonation level, including <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateClientSecurity</samp>,
    which captures the calling client’s token for later use by the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonateClient</samp>
    kernel API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateClientSecurity</samp>
    API takes a Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerIsRemote</samp>
    parameter. If the parameter is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the API fails to capture the token if the impersonation level is not Delegation.
    However, well-known callers such as the SMB do not set the parameter to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Therefore, the Delegation
    impersonation level is the de facto equivalent to the Impersonation level for
    both local and remote access, assuming there are credentials available in the
    logon session.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In Windows 10 and later, you can enable a feature called Credential Guard
    that uses virtualization technology to protect the user’s credentials, including
    the Kerberos TGT session key stored by the LSA, from being disclosed to a privileged
    user reading the memory of the LSASS process. As unconstrained delegation would
    introduce a mechanism to disclose the TGT session key for a user, it is no longer
    possible to use it if Credential Guard is enabled.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constrained Delegation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Microsoft introduced constrained delegation, also called *Service for User
    (S4U)*, in Windows 2003\. Its purpose was to fix a security weakness in unconstrained
    delegation: namely, once a user had delegated credentials to a service, it could
    impersonate them to any other service in the same domain, even if the services
    were completely unrelated to the purpose of the original service.'
  prefs: []
  type: TYPE_NORMAL
- en: This made any service with unconstrained delegation a good target for attack.
    If you compromised the service and could convince a privileged user to delegate
    their credentials to it, you had a good chance of compromising the entire network.
    Technically a user had to opt in to delegating their credentials, but common client
    applications such as Internet Explorer did so by default, and always passed the
    delegate request attribute when setting up the client authentication context.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft resolved the security weakness by allowing an administrator to specify
    an explicit list of SPNs that the service could use for delegation. For example,
    the administrator could limit the HTTP service discussed earlier to delegating
    only to the database service and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constrained delegation can work in three modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos-only delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol transition delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource-based delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll cover each mode in turn in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Kerberos-Only Delegation</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Also called *Service for User to Proxy (S4U2proxy)* in the official documentation,
    the Kerberos-only delegation mode works in much the same way as unconstrained
    delegation. It requires the user to authenticate to the intermediate service using
    Kerberos, as described in [Figure 14-9](chapter14.xhtml#fig14-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: An overview of
    constrained Kerberos-only delegation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: While this looks very similar to [Figure 14-8](chapter14.xhtml#fig14-8), there
    are subtle differences. First, the original user requests a normal service ticket
    for the HTTP service ❶, not an additional TGT. The user can package this service
    ticket into an AP-REQ message and send it to the HTTP service ❷. The HTTP service
    then wants to delegate the user’s authentication to the database service, so it
    requests a service ticket from the TGS, including its own TGT. It also attaches
    the user’s service ticket for its own service to the TGS-REQ message ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The TGS inspects the request. If the user’s service ticket has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp>
    flag set and the database service is in the list of allowed services for the account
    making the ticket request, the TGS will use the user’s service ticket to the HTTP
    service to generate a service ticket for the database service ❹. The service can
    package this ticket and associated information into an AP-REQ message as normal
    and send it to the database service ❺.
  prefs: []
  type: TYPE_NORMAL
- en: While it might seem as though the user can’t control the delegation of their
    credentials, they could block the delegation by simply choosing not to request
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> service ticket.
    We’ll come back to how to unset the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp>
    flag later.
  prefs: []
  type: TYPE_NORMAL
- en: The list of SPNs for services to which an account can delegate is stored in
    the user’s or computer’s account entry in Active Directory, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToDelegateTo</samp>
    attribute. You can set this attribute using <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADComputer</samp> in PowerShell,
    as shown in [Listing 14-21](chapter14.xhtml#Lis14-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-21: Adding a new msDS-AllowedToDelegateTo entry for the <samp class="SANS_Futura_Std_Book_11">alice</samp>
    account'
  prefs: []
  type: TYPE_NORMAL
- en: To query the list of SPNs, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>, as shown
    in [Listing 14-22](chapter14.xhtml#Lis14-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-22: Querying the msDS-AllowedToDelegateTo attribute'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we confirm we can delegate to the <samp class="SANS_TheSansMonoCd_W5Regular_11">CIFS/graphite</samp>
    service.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Protocol Transition Delegation</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Requiring end-to-end Kerberos authentication to the domain isn’t always feasible.
    For example, what if the user accessing the HTTP service is on a public network
    and cannot directly connect to the KDC to get a service ticket? This is where
    the second type of constrained delegation—protocol transition delegation, referred
    to as *Service for User to Self (S4U2self)* in the documentation—might be useful.
    It performs an *authentication protocol transition*, meaning that the frontend
    HTTP service can authenticate using its own authentication mechanism, then use
    that information to construct a service ticket for the database service with the
    user’s domain credentials, without requiring the user to know about Kerberos.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-10](chapter14.xhtml#fig14-10) shows the steps involved in constrained
    delegation using an authentication protocol transition.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: An overview of
    constrained delegation with an authentication protocol transition</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The user first makes a request to the HTTP service and provides authentication
    credentials ❶. The credentials don’t have to be related to the Kerberos credentials
    we want to use, and the authentication protocol used can be anything, such as
    basic HTTP authentication. The HTTP service maps the authenticated user to a domain
    account, then makes a request to the TGS for a service ticket for itself with
    that domain account’s information ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The TGS gathers all of the target user’s details (like their group memberships),
    puts them into the PAC, and sends the service ticket back to the service. Because
    the ticket is for the service itself, the LSA can decrypt the ticket, extract
    the PAC, and generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: This process might seem dangerous. After all, it lets you request a service
    ticket out of thin air without requiring any authentication of the user. Believe
    it or not, this is really how S4U2self works; however, bear in mind that the token
    generated is only useful for the local system. The LSA can already synthesize
    a token containing any groups it likes and use it locally, so this doesn’t change
    the security properties of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with a synthesized local token, though, the LSA has a copy of the S4U2self
    service ticket. If the service’s account is configured for delegation, it can
    use S4U2proxy with the S4U2self service ticket to request a service ticket for
    a permitted service ❸. It can then package this new service ticket in an AP-REQ
    and use it to authenticate to the database service ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can configure S4U2self to be permitted to transition to S4U2proxy by setting
    the list of permitted SPNs in <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToDelegateTo</samp>
    and setting the user account control flag <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. You saw how to modify
    the permitted SPNs in [Listing 14-21](chapter14.xhtml#Lis14-21). You can set the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp>
    flag using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To query the status of the flag, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>, as shown
    in [Listing 14-23](chapter14.xhtml#Lis14-23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-23: Querying the TrustedToAuthForDelegation flag'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll note we do not check whether we can request the initial S4U2self ticket.
    As mentioned earlier, this is only an issue for the local system’s security. Without
    S4U2proxy configured, the computer can’t use the credentials in a network request.
    In fact, any user on Windows can request an S4U token using <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    or via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command,
    even if not connected to an enterprise network.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-24](chapter14.xhtml#Lis14-24) shows that we’re currently running
    as the *alice* user. Let’s try requesting a token for another user.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-24: Requesting an S4U2self token as a normal user'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">S4U</samp> parameter to
    request a token for the *bob* user ❶. Notice we don’t need to specify a password.
    We can confirm that the token is really for *bob* by formatting it ❷.
  prefs: []
  type: TYPE_NORMAL
- en: This design would have a massive local security hole if the LSA didn’t restrict
    the token to Identification level, which prevents a normal user from being able
    to use the token to access secured resources ❸. The only way to get an Impersonation-level
    token is to have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled, which only the local *SYSTEM* account has by default. Thus, it’s typical
    to configure <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp>
    on the computer account used by the *SYSTEM* account, so it can impersonate the
    S4U2self token at the Impersonation level, then get the LSA to query for the S4U2proxy
    ticket.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resource-Based Delegation</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final constrained delegation type, resource-based delegation, was introduced
    in Windows Server 2012\. It doesn’t change the underlying delegation process outlined
    previously; instead, it changes the condition under which a forwardable ticket
    gets issued for a service. Rather than basing this decision only on the account
    requesting the delegated ticket, it also considers the target SPN being requested.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToActOnBehalfOfOtherIdentity</samp>
    attribute on a user or computer object controls resource-based delegation. This
    attribute is a security descriptor that contains an ACE for every account the
    user can delegate to. You can set it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADComputer</samp> PowerShell
    command by specifying distinguished names of the users or computers to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PrincipalsAllowedToDelegateToAccount</samp>
    parameter. In [Listing 14-25](chapter14.xhtml#Lis14-25), we add the *GRAPHITE*
    computer account to the list of accounts to which the *alice* user can delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-25: Setting resource-based delegation on a user account'
  prefs: []
  type: TYPE_NORMAL
- en: This allows the *GRAPHITE* computer account to request a service ticket for
    one of the *alice* user’s SPNs. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>
    command exposes the full distinguished name of the target account ❶, but if we
    extract the security descriptor from the attribute and format it, we see the *MINERAL\GRAPHITE$*
    SID in an ACE in the formatted DACL ❷.
  prefs: []
  type: TYPE_NORMAL
- en: When transitioning from S4U2self to S4U2proxy, the client principal doesn’t
    need to have the <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp>
    flag set. As a mechanism of control, the domain controller provides two group
    SIDs that indicate the source of the token. [Table 14-2](chapter14.xhtml#tab14-2)
    shows these two SIDs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-2:</samp> <samp class="SANS_Futura_Std_Book_11">SIDs
    for Asserted Identities</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SID</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Authentication authority
    asserted identity</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-18-1</samp>
    | <samp class="SANS_Futura_Std_Book_11">Token generated through authentication</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Service asserted identity</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-18-2</samp> | <samp class="SANS_Futura_Std_Book_11">Token
    generated through an S4U mechanism</samp> |'
  prefs: []
  type: TYPE_TB
- en: The first SID indicates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object was generated by providing authentication credentials to the KDC. The second
    SID is assigned for S4U2self or S4U2proxy tokens. A security descriptor can use
    these SIDs to limit access to a service configured for resource delegation to
    either Kerberos-only delegation, which gets the first SID, or authentication protocol
    transition delegation, which gets the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delegation is a dangerous feature if misconfigured, and it’s easy to misconfigure.
    This seems especially true for transitioning from S4U2self to S4U2proxy through
    constrained delegation, through which a service could impersonate any user in
    the domain, including privileged users. To reduce the danger of this occurring,
    the system can set the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountNotDelegated</samp>
    UAC flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> on an account
    to block it from being used in a delegation scenario. In the GUI, this flag is
    called “Account is sensitive and cannot be delegated.” You can set it on the domain
    controller using a domain administrator account by running the following PowerShell
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In [Listing 14-26](chapter14.xhtml#Lis14-26), we look at what this flag changes
    to prevent delegation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-26: Inspecting ticket flags for an account with AccountNotDelegated
    set'
  prefs: []
  type: TYPE_NORMAL
- en: First, we confirm that the *alice* user has the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountNotDelegated</samp>
    flag set to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> ❶. We then
    request a service ticket for this user. By decrypting it, we can see that the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag is no longer
    present ❷. As explained earlier, the TGS will refuse to issue a new service ticket
    based on an existing service ticket if the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp>
    flag is not set. This effectively blocks delegation automatically. Note that if
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag is set
    and you’ve just changed the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountNotDelegated</samp>
    flag, I’d recommend logging out, then logging back in as the user to ensure the
    user has no tickets cached.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we’ve needed an SPN configured for a user or computer in order for
    the KDC to select the correct shared encryption key. An alternative authentication
    mode is also available that allows users to authenticate to each other without
    an SPN. Let’s finish the chapter by discussing how we can use Kerberos without
    configuring an SPN for a user.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">User-to-User Kerberos Authentication</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The NTLM protocol can perform network authentication between unprivileged users,
    but because a Kerberos account needs a mapped SPN in order to grant a ticket,
    it shouldn’t normally be able to do this. To enable authentication between unprivileged
    users, Windows Kerberos includes a feature called *User-to-User (U2U) authentication*.
    [Figure 14-11](chapter14.xhtml#fig14-11) shows the basic operations of U2U authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: User-to-user
    authentication with Kerberos</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, *alice* wants to authenticate to a service running under *bob*’s
    account. However, *bob* doesn’t have an SPN registered, so when *alice* makes
    a service ticket request ❶, it will fail, as the KDC doesn’t know the target SPN.
    But because the requested service name is in UPN format (that is, <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp>),
    the LSA assumes that the user wants U2U authentication and instead generates a
    TGT-REQ message. It sends the TGT-REQ message to the service running under *bob*’s
    account ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The service accepts the TGT-REQ token, and the LSA packages *bob*’s cached TGT
    into a TGT-REP message to send back to the client ❸. (Note that the LSA simply
    takes the caller’s cached TGT; it doesn’t seem to pay any attention to the UPN
    in the TGT-REQ. Therefore, the TGT returned might not be for the user requested,
    which will be important in the next step.)
  prefs: []
  type: TYPE_NORMAL
- en: Upon receipt of the TGT-REP, the LSA can package the TGT for *alice* and the
    TGT for *bob* into a TGS-REQ, then request a service ticket for <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp>
    ❹. The TGS can then decrypt the TGTs, verify that the extra TGT is for the requested
    user account, and generate a service ticket encrypted with the TGT session key
    for *bob*. If the extra TGT is not for *bob*, perhaps because the service was
    not running under *bob*’s account, the request will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the request succeeds, the client’s LSASS can package up the service
    ticket into an AP-REQ message to send to the service and complete the authentication
    ❺. Let’s run a test to see U2U authentication in operation ([Listing 14-27](chapter14.xhtml#Lis14-27)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-27: Initializing the U2U authentication client'
  prefs: []
  type: TYPE_NORMAL
- en: First, we initialize the U2U client authentication context; note this should
    be running as the *alice* user. You should be familiar with most of this code
    by now; the only important difference is specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp>
    as the target SPN ❶. When we format the authentication token, we see a TGT-REQ
    message containing the desired principal ❷. We now need the server authentication
    context to continue the authentication process ([Listing 14-28](chapter14.xhtml#Lis14-28)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-28: Creating the server authentication context and getting the TGT-REP'
  prefs: []
  type: TYPE_NORMAL
- en: We first create the credentials handle and read the credentials for *bob* from
    the shell. It’s necessary to specify credentials for *bob* because otherwise the
    server authentication would use *alice*’s TGT, which would fail when creating
    the service ticket for the <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp>
    SPN. With the credentials handle, we can create the server authentication context.
  prefs: []
  type: TYPE_NORMAL
- en: By formatting the returned authentication token, we can see it’s a TGT-REP with
    the TGT ticket ❶. We don’t know the *krbtgt* user’s password, so we can’t decrypt
    it, meaning there’s no way of knowing whether the ticket is for *bob* or not.
    In [Listing 14-29](chapter14.xhtml#Lis14-29), we update the client authentication
    context with the TGT-REP message and print the new authentication token.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-29: Continuing the U2U authentication'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we now have our AP-REQ message to send to the server ❶. It contains
    a ticket encrypted with *bob*’s session key ❷, and the target principal is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp> ❸. In [Listing
    14-30](chapter14.xhtml#Lis14-30), we’re back on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-30: Completing U2U authentication'
  prefs: []
  type: TYPE_NORMAL
- en: We complete the authentication ❶ and query the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object, which indicates a successful logon for *alice* ❷.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s walk through some worked examples to demonstrate how you can use the various
    commands in this chapter to help with security research or systems analysis.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Querying the Kerberos
    Ticket Cache</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The LSA maintains a cache of tickets requested using Kerberos for each logon
    session. You can query the current user’s ticket cache using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosTicket</samp>
    command, as shown in [Listing 14-31](chapter14.xhtml#Lis14-31).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-31: Querying the Kerberos ticket cache'
  prefs: []
  type: TYPE_NORMAL
- en: First, we query for the tickets ❶, selecting the fields <samp class="SANS_TheSansMonoCd_W5Regular_11">ServiceName</samp>
    (the ticket’s SPN) and <samp class="SANS_TheSansMonoCd_W5Regular_11">EndTime</samp>
    (the expiration time for the ticket, at which point it must be renewed). The first
    ticket in the cache is the user’s TGT, used for requesting service tickets ❷.
    In this example, we also have a service ticket for the LDAP directory server.
  prefs: []
  type: TYPE_NORMAL
- en: We can view a cached Kerberos ticket using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-KerberosTicket</samp>
    command ❸, but the ticket is still encrypted, and as we probably don’t know the
    target service’s shared key we won’t be able to decrypt it. In theory, we could
    send the ticket to the destination service to authenticate to it directly. However,
    we don’t have the extracted session key needed to encrypt the authentication data
    in a valid AP-REQ either, so we’ll need to call the SSPI to generate the AP-REQ
    based on the cached ticket.
  prefs: []
  type: TYPE_NORMAL
- en: If you have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled, however, each ticket cache entry should contain the session key. [Listing
    14-32](chapter14.xhtml#Lis14-32) shows how to query for all tickets for all local
    logon sessions and extract the cached session key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-32: Extracting all tickets and session keys'
  prefs: []
  type: TYPE_NORMAL
- en: We start by getting the list of logon sessions that can be passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosTicket</samp>.
    We need to have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled to query for the tickets of any logon session except the caller’s, so
    we impersonate the *SYSTEM* user while querying the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Impersonating *SYSTEM* also allows us to get the session key. We can format
    the key as hex along with the SPN of the cached ticket. With both the ticket and
    the session key, we can implement our own authentication request to the service.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simple Kerberoasting</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One potential reason to interact with the ticket cache is to get a ticket for
    Kerberoasting, an attack described in the “Silver Tickets and Kerberoasting” box
    on page 465. However, you don’t need to query the cache for this attack, as you
    can find all the information you need using the SSPI APIs. Let’s walk through
    a simple example so that you can understand how the Kerberoasting process works.
    First, in [Listing 14-33](chapter14.xhtml#Lis14-33), we query for all user accounts
    with configured SPNs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-33: Checking for users with configured SPNs'
  prefs: []
  type: TYPE_NORMAL
- en: We see the *krbtgt* user, and that *alice* still has the <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp>
    SPN we configured earlier in the chapter. We also see an account for a SQL server
    that has the SPN <samp class="SANS_TheSansMonoCd_W5Regular_11">MSSQL/topaz.mineral.local</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want to pick *krbtgt* as a target, as this account will have a complex
    password that will be difficult to brute-force (any computer account with an SPN
    configured also has an automatically configured complex password). We’ll try to
    brute-force the password for the *sqlserver* user. First we need to make a request
    for its SPN and receive the ticket ([Listing 14-34](chapter14.xhtml#Lis14-34)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-34: Getting a service ticket for the <samp class="SANS_Futura_Std_Book_11">sqlserver</samp>
    user'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the ticket, we can generate a key based on a list of passwords.
    We can then try to decrypt the ticket with each key until we find a key that works,
    as illustrated in [Listing 14-35](chapter14.xhtml#Lis14-35).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-35: Decrypting the ticket with a set of passwords'
  prefs: []
  type: TYPE_NORMAL
- en: We can check if the ticket was decrypted by querying its <samp class="SANS_TheSansMonoCd_W5Regular_11">Decrypted</samp>
    property ❶. If it was decrypted, we then print the password to the console. In
    this case, we find that the password for the *sqlserver* user is <samp class="SANS_TheSansMonoCd_W5Regular_11">DBPassw0rd</samp>—
    probably not the most secure option! Note that this example script isn’t very
    efficient or fast. It’s made easier by the ticket being encrypted with the RC4
    encryption algorithm; you could apply the same technique to AES, but the brute-forcing
    attempt will take longer, as AES key derivation is more complex.
  prefs: []
  type: TYPE_NORMAL
- en: For better performance, you’re better off using another tool, such as Rubeus
    (*[https://<wbr>github<wbr>.com<wbr>/GhostPack<wbr>/Rubeus](https://github.com/GhostPack/Rubeus)*),
    originally developed by Will Schroeder at SpecterOps. This tool can get the ticket
    and use it to generate a hash that you can feed to a fast password-cracking tool
    such as John the Ripper (*[https://<wbr>www<wbr>.openwall<wbr>.com<wbr>/john<wbr>/](https://www.openwall.com/john/)*).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter contained an in-depth discussion of Kerberos, the protocol used
    for Windows domain authentication since Windows 2000\. We examined the key distribution
    center implemented on the Windows domain controller, which holds the list of keys
    associated with all users and computers on a network, and saw how Kerberos uses
    these keys (typically derived from the account password) to authenticate tickets,
    which can then authenticate to services on the network.
  prefs: []
  type: TYPE_NORMAL
- en: To support complex authentication scenarios, Kerberos allows for the delegation
    of credentials. We discussed this topic at length, including both constrained
    and unconstrained delegation as well as the associated Service for User mechanisms.
    We finished the chapter with a description of user-to-user authentication, which
    allows for two users to authenticate to each other without needing to register
    an SPN with the domain.
  prefs: []
  type: TYPE_NORMAL
- en: The next (and final) chapter will describe some additional network authentication
    protocols as well as going into more depth on how the SSPI APIs are used.
  prefs: []
  type: TYPE_NORMAL
