- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">KERBEROS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">KERBEROS</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: In Windows 2000, the Kerberos authentication protocol replaced Netlogon as the
    primary mechanism for authenticating users on a domain controller. This chapter
    builds upon the description of interactive domain authentication in [Chapter 12](chapter12.xhtml)
    to explain how a user can authenticate to a Windows domain using Kerberos.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 2000 中，Kerberos 身份验证协议取代了 Netlogon，成为域控制器上验证用户的主要机制。本章将在 [第 12 章](chapter12.xhtml)
    关于交互式域身份验证的描述基础上，解释用户如何使用 Kerberos 对 Windows 域进行身份验证。
- en: We’ll start by looking at how Kerberos works, including how to generate the
    encryption keys used in the protocol, and decrypt Kerberos authentication tokens.
    Once you understand the inner workings of the protocol, we’ll cover the delegation
    of authentication and the role of Kerberos in user-to-user authentication protocols.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从了解 Kerberos 的工作原理开始，包括如何生成协议中使用的加密密钥，以及如何解密 Kerberos 身份验证令牌。一旦你理解了协议的内部工作原理，我们将介绍身份验证的委托以及
    Kerberos 在用户间身份验证协议中的作用。
- en: Kerberos was first developed at Massachusetts Institute of Technology (MIT)
    in the 1980s. Microsoft uses version 5 of the protocol, which was formalized in
    RFC1510 in 1993, then updated in RFC4120 in 2005\. Microsoft has also made a few
    modifications to the protocol to support its own needs; I’ll mention some of these
    changes over the course of this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos 最初是在 1980 年代由麻省理工学院（MIT）开发的。微软使用该协议的第 5 版，该版本在 1993 年通过 RFC1510 正式化，之后在
    2005 年通过 RFC4120 更新。微软还对协议进行了一些修改，以支持自身的需求；我将在本章中提到其中一些更改。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Interactive Authentication with Kerberos</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">与 Kerberos 的交互式身份验证</samp>
- en: As its primary function, Kerberos distributes *tickets*, each of which represents
    a user’s verified identity. The system can use this identity to determine whether
    the user can access a service, such as a file server. For example, if the user
    sends their ticket in a request to open a file, the file server can check its
    validity, then decide whether to grant the user access through something like
    an access check.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其主要功能，Kerberos 分发*票证*，每个票证代表一个经过验证的用户身份。系统可以利用这个身份来决定用户是否可以访问某个服务，比如文件服务器。例如，如果用户在请求打开文件时发送了他们的票证，文件服务器可以检查其有效性，然后通过类似访问检查的方式决定是否授予用户访问权限。
- en: Kerberos provides a means of distributing these tickets securely over an untrusted
    network and allowing the tickets to be verified. It does this by using shared
    encryption keys, commonly derived from a user’s password, to encrypt and verify
    the tickets. The Active Directory server never stores the password in plaintext;
    it stores only the encryption key.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos 提供了一种方法，通过不受信任的网络安全地分发这些票证，并允许验证这些票证。它通过使用共享的加密密钥来做到这一点，这些密钥通常是从用户的密码中派生出来的，用来加密和验证票证。Active
    Directory 服务器从不以明文形式存储密码；它只存储加密密钥。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initial User Authentication</samp>
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">初始用户身份验证</samp>
- en: '[Figure 14-1](chapter14.xhtml#fig14-1) shows the initial Kerberos user authentication
    process between a client computer and the domain controller running the *key distribution
    center (KDC)* service. The KDC issues Kerberos tickets to users and manages session
    encryption keys.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-1](chapter14.xhtml#fig14-1) 显示了客户端计算机与运行*密钥分发中心（KDC）*服务的域控制器之间的初始 Kerberos
    用户身份验证过程。KDC 向用户发放 Kerberos 票证，并管理会话加密密钥。'
- en: '![](../images/Figure14-1.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: An overview of
    Kerberos authentication</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-1：Kerberos 身份验证概述</samp>
- en: When the LSA processes a logon request, it first derives the shared encryption
    key based on the user’s password and a salt ❶. It generates the salt based on
    values, such as the username and realm, that depend on the type of encryption
    algorithm in use. We use the term *realm* to describe the scope of the Kerberos
    authentication. In Windows, the realm is the DNS name for the domain that contains
    the user, such as *mineral.local*. We can combine the username and the realm to
    form a user principal name, commonly written with an at symbol (@), as in *user@mineral.local*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当LSA处理登录请求时，它首先基于用户的密码和盐值❶推导出共享的加密密钥。它根据诸如用户名和领域等值生成盐值，这些值取决于所使用的加密算法类型。我们使用*领域*这个术语来描述Kerberos认证的范围。在Windows中，领域是包含用户的域的DNS名称，例如*mineral.local*。我们可以将用户名和领域组合起来形成用户主体名称，通常用@符号表示，如*user@mineral.local*。
- en: The LSA then generates an *authentication service request (AS-REQ)* message
    and sends it over the network to the authentication server ❷. The authentication
    server is the part of the KDC that is responsible for issuing an initial ticket
    to the authentication process. The AS-REQ message contains the username and realm
    as well as *pre-authentication data*, which consists of the current time encrypted
    with the user’s shared encryption key. The authentication server can look up the
    shared key from its key database using the specified username and realm, then
    use the key to decrypt the pre-authentication data ❸. If it succeeds, it has verified
    that the data has come from the user, as only the server and the client should
    know the shared encryption key.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后LSA生成一个*认证服务请求（AS-REQ）*消息，并通过网络将其发送到认证服务器 ❷。认证服务器是KDC的一个部分，负责向认证过程发放初始票证。AS-REQ消息包含用户名和领域以及*预认证数据*，该数据由当前时间和用户共享的加密密钥加密组成。认证服务器可以通过指定的用户名和领域在其密钥数据库中查找共享密钥，然后使用该密钥解密预认证数据❸。如果解密成功，证明数据确实来自用户，因为只有服务器和客户端知道共享的加密密钥。
- en: The authentication server then generates a *ticket granting ticket (TGT)*, which
    it encrypts with the shared encryption key for a special user, *krbtgt*. The authenticating
    user doesn’t know the *krbtgt* user’s shared key, so they can’t decrypt the ticket.
    While the TGT has a special name, it’s essentially just a ticket that verifies
    the user’s identity to the *ticket granting server (TGS)*, which is responsible
    for issuing tickets for the user to authenticate to a network service. The ticket
    contains details about the user’s identity encoded in a *privilege attribute certificate
    (PAC)*, as well as a randomly generated session key for the TGS to use. We’ll
    see an example of a PAC in “Decrypting the AP-REQ Message” on page 469.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 认证服务器接着生成一个*票证授予票证（TGT）*，并用为特殊用户*krbtgt*的共享加密密钥对其进行加密。认证用户并不知道*krbtgt*用户的共享密钥，因此无法解密该票证。尽管TGT有一个特殊的名称，但它本质上只是一个验证用户身份的票证，用于验证用户向*票证授予服务器（TGS）*的身份，TGS负责为用户颁发票证，以便用户向网络服务进行认证。该票证包含了用户身份的详细信息，这些信息编码在*特权属性证书（PAC）*中，以及一个为TGS使用的随机生成的会话密钥。我们将在“解密AP-REQ消息”中看到PAC的示例，详见第469页。
- en: The authentication server also generates a second data value and encrypts it
    with the user’s shared encryption key. This value, when decrypted, contains details
    about the ticket, such as how long it’s valid for. Eventually, a ticket expires,
    and the user will need to request a new TGT. This second value also contains the
    session encryption key, encrypted in the ticket. The authentication server packages
    the encrypted ticket and ticket information into the *authentication service reply
    (AS-REP)* message and sends it back to the client LSA ❹. [Figure 14-2](chapter14.xhtml#fig14-2)
    summarizes the format of this message.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 认证服务器还生成第二个数据值，并使用用户共享的加密密钥对其进行加密。这个值在解密后包含关于票证的详细信息，例如票证的有效期。最终，票证会过期，用户需要请求一个新的TGT。这个第二个值还包含了会话加密密钥，已加密在票证中。认证服务器将加密的票证和票证信息打包成*认证服务回复（AS-REP）*消息，并将其发送回客户端LSA
    ❹。[图14-2](chapter14.xhtml#fig14-2)总结了该消息的格式。
- en: '![](../images/Figure14-2.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: The AS-REP message
    format</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-2：AS-REP消息格式</samp>
- en: Once the LSA receives the AS-REP, it can decrypt it and extract the session
    key from the encrypted ticket information by using the user’s shared encryption
    key. The successful decryption also demonstrates that the LSA is communicating
    with the correct authentication server, as another server wouldn’t know the user’s
    shared key.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦LSA接收到AS-REP，它可以解密并从加密的票证信息中提取会话密钥，使用用户的共享加密密钥。成功解密还表明LSA正在与正确的认证服务器通信，因为其他服务器不会知道用户的共享密钥。
- en: 'But the LSA still doesn’t know all of the user’s information, as this information
    is stored in the PAC, which is encrypted in the ticket. To get the PAC, the LSA
    must request a ticket for itself from the TGS ❺. To do so, the LSA packages up
    the TGT, which it can’t alter, with the *service principal name (SPN)* of the
    service it wants to access. The SPN is a string of the following form:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是LSA仍然不知道用户的所有信息，因为这些信息存储在PAC中，并且PAC在票证中被加密。为了获取PAC，LSA必须向TGS请求自己的票证❺。为此，LSA将不能更改的TGT与要访问的服务的*服务主体名称
    (SPN)* 打包在一起。SPN的格式如下：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">service class/instance
    name/service name</samp>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">服务类/实例名/服务名</samp>
- en: 'The *service class* is the type of service to use. The *instance name* is the
    hostname or network address that the service is running on. Finally, the *service
    name* is an optional value for disambiguating similar services on the same host.
    For the LSA to request a ticket for itself, it must set the service class to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp> and the instance name to the
    current host, such as *graphite.mineral.local*. When converted to a string, this
    creates the following SPN: <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST/graphite.mineral.local</samp>.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务类*是要使用的服务类型。*实例名称*是服务正在运行的主机名或网络地址。最后，*服务名称*是用于消除同一主机上类似服务的歧义的可选值。为了请求自己的票证，LSA必须将服务类设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>，将实例名称设置为当前主机，例如*graphite.mineral.local*。当转换为字符串时，这将创建以下SPN：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HOST/graphite.mineral.local</samp>。'
- en: You might remember that we used this string format to specify a target name
    for NTLM authentication in [Chapter 13](chapter13.xhtml). In fact, Windows took
    this format from Kerberos and applied it to NTLM to try to counter NTLM relay
    attacks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你还记得，在[第13章](chapter13.xhtml)中我们使用了这种字符串格式来指定NTLM认证的目标名称。事实上，Windows从Kerberos中采用了这种格式，并将其应用于NTLM以试图抵御NTLM中继攻击。
- en: To ensure that the server can verify its request, the LSA will also generate
    a cryptographic hash of the TGT. This hash encompasses the SPN, a timestamp, and
    a unique sequence number, all encrypted with the session key from the AS-REP’s
    encrypted data value. This additional encrypted value is called the *authenticator*.
    The TGT, SPN, and authenticator are packaged up in a *ticket granting service
    request (TGS-REQ)* message and sent to the TGS. [Figure 14-3](chapter14.xhtml#fig14-3)
    summarizes the format of this message.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保服务器可以验证其请求，LSA还将生成TGT的加密哈希值。此哈希值包括SPN、时间戳和唯一序列号，所有这些都使用AS-REP的加密数据值中的会话密钥加密。这额外的加密值称为*认证者*。TGT、SPN和认证者被打包在一个*票证授予服务请求
    (TGS-REQ)* 消息中，并发送到TGS。[图14-3](chapter14.xhtml#fig14-3)总结了此消息的格式。
- en: '![](../images/Figure14-3.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The TGS-REQ message
    format</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-3：TGS-REQ消息格式</samp>
- en: The TGS receives the TGS-REQ message, and because it knows the shared encryption
    key for the *krbtgt* user, it can decrypt the TGT. This allows it to extract details
    about the user, as well as the session key. It can then verify that the ticket
    hasn’t expired or isn’t otherwise invalid (which would be the case if the user
    weren’t allowed to authenticate to the domain or service).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: TGS接收到TGS-REQ消息，并因为知道*krbtgt*用户的共享加密密钥，可以解密TGT。这使得它能够提取用户的详细信息以及会话密钥。然后，它可以验证票证是否已过期或无效（如果用户未被允许对域或服务进行身份验证，则会出现这种情况）。
- en: The TGS can use the session key from the ticket to decrypt the authenticator
    and verify that the hash matches the associated information. This process ensures
    that only a user with access to the shared encryption key could have extracted
    the session key from the AS-REP and encrypted the contents of the authenticator
    for this TGT. The TGS then verifies that the timestamp is recent. Typically, it
    will reject the request if the timestamp is older than five minutes. For this
    reason, it’s crucial to Kerberos authentication that the client and server systems
    have synchronized clocks. The TGS also checks that it hasn’t already seen the
    ticket’s sequence number. This check counters replay attacks, in which the same
    TGS-REQ is sent multiple times.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TGS 可以使用票证中的会话密钥解密认证器，并验证哈希值与相关信息是否匹配。这个过程确保只有具有共享加密密钥的用户才能从 AS-REP 中提取会话密钥，并加密该
    TGT 的认证器内容。然后，TGS 验证时间戳是否是最近的。通常，如果时间戳超过五分钟，它会拒绝该请求。因此，客户端和服务器系统的时钟同步对于 Kerberos
    认证至关重要。TGS 还会检查它是否已经见过该票证的序列号。此检查可以防止重放攻击，在重放攻击中，TGS-REQ 被多次发送。
- en: If all the checks pass, the TGS can look up the SPN in the key database to retrieve
    an encryption key. Technically, each SPN could have its own encryption key, but
    Active Directory usually just maps these SPNs to a user or computer account. For
    example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST/graphite.mineral.local</samp>
    SPN is mapped to the computer account for the *GRAPHITE* machine. You can query
    the SPNs an account is mapped to using the <samp class="SANS_TheSansMonoCd_W5Regular_11">setspn</samp>
    utility or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>
    PowerShell command, as shown in [Listing 14-1](chapter14.xhtml#Lis14-1).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有检查通过，TGS 可以在密钥数据库中查找 SPN 以检索加密密钥。从技术上讲，每个 SPN 都可以有自己的加密密钥，但 Active Directory
    通常只是将这些 SPN 映射到用户或计算机帐户。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">HOST/graphite.mineral.local</samp>
    SPN 映射到 *GRAPHITE* 机器的计算机帐户。你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">setspn</samp>
    工具或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp> PowerShell
    命令查询帐户映射到的 SPN，如 [清单 14-1](chapter14.xhtml#Lis14-1) 所示。
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 14-1: Enumerating SPNs mapped to the current computer account'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-1：枚举映射到当前计算机帐户的 SPN
- en: Assuming the host exists, the TGS can extract the shared encryption key for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp> service ticket it
    will generate. If you return to [Figure 14-1](chapter14.xhtml#fig14-1), you’ll
    see that the TGS will copy the PAC from the decrypted TGT into this new ticket
    and encrypt it with the session key for the SPN ❻. The TGS generates the same
    encrypted data as it did with the AS-REP, including the session key for the service
    to use. Then it packages the new ticket and the encrypted value into the *ticket
    granting service reply (TGS-REP)* and returns it to the client ❼. [Figure 14-4](chapter14.xhtml#fig14-4)
    summarizes the format of the TGS-REP message.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设主机存在，TGS 可以提取它将生成的 <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>
    服务票证的共享加密密钥。如果你返回到 [图 14-1](chapter14.xhtml#fig14-1)，你会看到 TGS 将从解密的 TGT 中复制 PAC
    到这个新票证中，并使用服务主体名称 (SPN) ❻ 的会话密钥对其进行加密。TGS 生成与 AS-REP 相同的加密数据，包括供服务使用的会话密钥。然后，它将新票证和加密值打包到
    *票证授予服务回复 (TGS-REP)* 中并返回给客户端 ❼。[图 14-4](chapter14.xhtml#fig14-4) 总结了 TGS-REP
    消息的格式。
- en: '![](../images/Figure14-4.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: The TGS-REP message
    format</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-4：TGS-REP 消息格式</samp>
- en: The LSA can now verify that it can decrypt the contents of the ticket and ensure
    the ticket targets the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>
    SPN it requested. In particular, as the last step in [Figure 14-1](chapter14.xhtml#fig14-1),
    it uses the PAC to create the new user’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object ❽. This completes the authentication process. The user has now been authenticated,
    and the system can start its logon session, console session, and processes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: LSA 现在可以验证它是否能够解密票证的内容，并确保票证针对它请求的 <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>
    SPN。特别地，作为 [图 14-1](chapter14.xhtml#fig14-1) 中的最后一步，它使用 PAC 创建新用户的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象 ❽。这完成了认证过程。用户现在已通过认证，系统可以开始其登录会话、控制台会话和进程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Network Service Authentication</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">网络服务认证</samp>
- en: 'Once the user has been authenticated to the local machine, the LSA must cache
    the following information before the user can communicate with other services
    on the network: the user’s shared encryption key, which is based on their password;
    the TGT, to request additional service tickets; and the TGT session key.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户通过本地机器认证，LSA 必须缓存以下信息，才能让用户与网络上的其他服务进行通信：用户的共享加密密钥（基于其密码）、TGT（用于请求其他服务票据）以及
    TGT 会话密钥。
- en: The SSPI APIs discussed in the previous chapter include a Kerberos security
    package that handles the network service authentication process to retrieve a
    valid ticket for a network service based on its SPN. [Figure 14-5](chapter14.xhtml#fig14-5)
    provides an overview of the process of getting a ticket for a network service.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章讨论的 SSPI API 包含一个 Kerberos 安全包，处理网络服务认证过程，以根据其 SPN 获取有效的网络服务票据。[图 14-5](chapter14.xhtml#fig14-5)
    提供了获取网络服务票据的过程概述。
- en: '![](../images/Figure14-5.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: Kerberos authentication
    to a network service</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-5：Kerberos 网络服务认证</samp>
- en: 'This authentication process involves three systems: the client, the server,
    and the KDC. The first thing the client does is call the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    SSPI API with the user credentials and the network service’s SPN ❶.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该认证过程涉及三个系统：客户端、服务器和 KDC。客户端首先调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    SSPI API，使用用户凭据和网络服务的 SPN ❶。
- en: In [Figure 14-5](chapter14.xhtml#fig14-5), we’re assuming that we’re making
    the authentication request as an existing authenticated user with a cached TGT.
    If we’re not, and we’ve specified a username and password, the LSA needs to get
    the TGT for that user by following the authentication process outlined in the
    previous section. If the LSA already has a valid TGT, it can make a request to
    the TGS for a new ticket targeting the specified SPN ❷.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 14-5](chapter14.xhtml#fig14-5) 中，我们假设作为已认证用户，凭借缓存的 TGT 发起认证请求。如果不是，并且我们已经指定了用户名和密码，则
    LSA 需要通过遵循上一节概述的认证过程来获取该用户的 TGT。如果 LSA 已有有效的 TGT，它可以向 TGS 请求一个新的票据，目标为指定的 SPN
    ❷。
- en: The TGS then verifies that the TGT is valid and that the caller knows the session
    key, which it can extract with knowledge of the user’s shared key. Once it has
    verified this value, the TGS looks up the shared encryption key for the target
    SPN. If the SPN doesn’t exist or the user isn’t allowed to use the service, it
    returns an error, which the LSA will report to the caller. If everything occurs
    correctly, the TGS will generate the TGS-REP message with the new ticket and return
    it to the client’s LSA ❸.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，TGS 验证 TGT 是否有效，并检查调用者是否知道会话密钥，TGS 可以通过用户共享密钥来提取该密钥。一旦验证通过，TGS 查找目标 SPN 的共享加密密钥。如果
    SPN 不存在或用户不允许使用该服务，则返回错误，LSA 会将此错误报告给调用者。如果一切正常，TGS 会生成带有新票据的 TGS-REP 消息，并将其返回给客户端的
    LSA ❸。
- en: As with the original TGT, the TGS encrypts the ticket using a key the client
    shouldn’t have access to. However, it encrypts the extra encrypted value using
    the TGT’s session key, which the LSA can decrypt. This encrypted value contains
    the session key for communicating with the service. The LSA takes the ticket and
    generates an authenticator encrypted with the service session key, then packages
    the ticket and authenticator into an *authentication protocol request (AP-REQ)*
    message. The structure of this message is basically the same as that of the TGS-REQ
    message, but the request is sent to the service rather than the TGS.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始 TGT 相似，TGS 使用客户端不应能访问的密钥加密票据。然而，它使用 TGT 会话密钥加密额外的加密值，LSA 可以解密该密文。此加密值包含与服务通信的会话密钥。LSA
    获取票据并生成一个使用服务会话密钥加密的认证器，然后将票据和认证器打包成 *认证协议请求 (AP-REQ)* 消息。该消息的结构与 TGS-REQ 消息基本相同，但请求是发送给服务而不是
    TGS。
- en: The LSA returns this AP-REQ to the user ❹. At this point, the client application
    regains control of the authentication process, and it can package up the AP-REQ
    into the network protocol and transmit it to the server ❺. The server extracts
    the AP-REQ and passes it to its own LSA via the <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>
    API ❻.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: LSA 将这个 AP-REQ 返回给用户 ❹。此时，客户端应用程序重新控制认证过程，并可以将 AP-REQ 封装进网络协议并传输给服务器 ❺。服务器提取
    AP-REQ，并通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>
    API 将其传递给自己的 LSA ❻。
- en: The LSA on the server should already have the shared encryption key for the
    cached ticket. It’s common to tie the SPN to the computer account used by the
    *Local System* user. Therefore, any privileged service, such as the SMB server,
    should have access to the computer’s password needed to decrypt the ticket. If
    the service is running as a user, the system must have configured an SPN mapping
    for that user before the ticket can be accepted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上的 LSA 应该已经拥有缓存票证的共享加密密钥。通常会将 SPN 绑定到 *本地系统* 用户使用的计算机帐户。因此，任何特权服务（如 SMB 服务器）都应该能够访问解密票证所需的计算机密码。如果该服务以某个用户身份运行，则系统必须在接受票证之前为该用户配置
    SPN 映射。
- en: Assuming it can decrypt and verify the ticket, the server’s LSA will then extract
    the PAC from the ticket and build a local token for the user. The PAC has a signature
    that the server can use to verify that it hasn’t been tampered with. Also, an
    optional verification process can ensure that the PAC was issued by the KDC. The
    network service can now use the generated token to impersonate the authenticating
    user ❼.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设它能解密并验证票证，服务器的 LSA 将从票证中提取 PAC 并为用户构建本地令牌。PAC 包含签名，服务器可以用来验证其未被篡改。此外，选项验证过程可以确保
    PAC 是由 KDC 发出的。网络服务现在可以使用生成的令牌来模拟认证用户 ❼。
- en: The final step in [Figure 14-5](chapter14.xhtml#fig14-5) is optional. By default,
    the server doesn’t need to return anything to the client to complete the authentication;
    it has everything it needs to decrypt the ticket and let the service access the
    user’s identity. However, you might want to ensure that the server you’re talking
    to knows the ticket’s key and isn’t lying. One way that the server can prove it
    knows the encryption key is to encrypt or sign something using the ticket’s session
    key and return this to the client. We refer to this practice as *mutual authentication*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-5](chapter14.xhtml#fig14-5) 中的最后一步是可选的。默认情况下，服务器不需要向客户端返回任何内容来完成认证；它已经拥有解密票证所需的所有内容，并可以让服务访问用户的身份。然而，你可能希望确保你所联系的服务器知道票证的密钥并且没有撒谎。服务器证明它知道加密密钥的一种方式是使用票证的会话密钥加密或签名某些内容并将其返回给客户端。我们将这种做法称为
    *互相认证*。'
- en: Kerberos uses the *authentication protocol reply (AP-REP)* message to send this
    encrypted value back to the client ❽. The AP-REP message contains an authenticator
    value like the one sent in the AP-REQ, but it has a slightly different format,
    as it is encrypted using the session key. Because only a valid recipient of the
    ticket could have decrypted the session key to encrypt the authenticator, this
    verifies the server’s identity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos 使用 *认证协议回复（AP-REP）* 消息将加密值发送回客户端 ❽。AP-REP 消息包含与 AP-REQ 中发送的认证器值类似的值，但其格式稍有不同，因为它使用会话密钥进行了加密。由于只有有效的票证接收者才能解密会话密钥以加密认证器，因此这验证了服务器的身份。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Performing Kerberos Authentication in
    PowerShell</samp>
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">在 PowerShell 中执行 Kerberos 认证</samp>
- en: How much of the network service authentication process can we observe from PowerShell?
    Let’s find out. We’ll start by getting the credentials handle, as shown in [Listing
    14-2](chapter14.xhtml#Lis14-2).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 PowerShell 中观察到网络服务认证过程的哪些部分呢？让我们一探究竟。我们将从获取凭据句柄开始，如 [清单 14-2](chapter14.xhtml#Lis14-2)
    所示。
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 14-2: Setting up a client authentication context for Kerberos'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-2：为 Kerberos 设置客户端认证上下文
- en: In this case, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Kerberos</samp>
    package ❶ instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp>
    package we used in the previous chapter. Once we receive the handle, we can create
    a client authentication context. To do this, we must specify an SPN to authenticate
    to; here I’ve picked the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>
    SPN on the local computer ❷.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们指定了<samp class="SANS_TheSansMonoCd_W5Regular_11">Kerberos</samp>包❶，而不是上一章中使用的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp>包。一旦我们收到句柄，就可以创建客户端身份验证上下文。为此，我们必须指定一个SPN进行身份验证；在这里，我选择了本地计算机上的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp> SPN❷。
- en: 'At this point, the LSA should get a ticket for the service by using the previously
    negotiated TGT and sending a TGS-REQ. If the SPN is incorrect or unknown, the
    TGS will return an error, which the LSA will pass back to us when it creates the
    client authentication context. The error will look like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，LSA应该使用先前协商的TGT获取服务的票证，并发送TGS-REQ。如果SPN不正确或未知，TGS将返回错误，LSA将在创建客户端身份验证上下文时将该错误传回给我们。错误将如下所示：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In [Listing 14-2](chapter14.xhtml#Lis14-2), the only thing we receive is the
    AP-REQ ❸; we don’t receive the TGS-REQ or the TGS-REP. Because we formatted the
    fields of the Kerberos authentication token, we can see only the values available
    in plaintext. This includes a set of option flags currently set to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>;
    other values would indicate various properties of the request, which we’ll come
    back to when we discuss configuring the optional mutual authentication.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单14-2](chapter14.xhtml#Lis14-2)中，我们收到的唯一内容是AP-REQ❸；我们没有收到TGS-REQ或TGS-REP。由于我们已经格式化了Kerberos认证令牌的字段，因此只能看到以明文呈现的值。这包括一组选项标志，目前设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp>；其他值则表示请求的各种属性，我们将在讨论配置可选的双向认证时回到这些内容。
- en: The ticket also contains the target SPN and realm ❹, which the server needs
    to select the correct shared encryption key. You can recognize an SPN based on
    the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SRV_INST</samp>
    name type, which indicates a service instance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 票证还包含目标SPN和领域❹，服务器需要使用这些信息来选择正确的共享加密密钥。你可以通过存在<samp class="SANS_TheSansMonoCd_W5Regular_11">SRV_INST</samp>名称类型来识别SPN，这表明这是一个服务实例。
- en: Next, the ticket specifies the encryption parameters. First it lists the algorithm
    used to encrypt and verify the ciphertext. In this case, it uses AES ciphertext-stealing
    mode (CTS) with a 256-bit key for encryption and a SHA1 HMAC truncated to 96 bits
    ❺. [Table 14-1](chapter14.xhtml#tab14-1) shows other common encryption algorithms
    used by Windows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，票证指定了加密参数。首先，它列出了用于加密和验证密文的算法。在这种情况下，它使用了AES加密文本偷取模式（CTS），并使用256位密钥进行加密，同时使用SHA1
    HMAC并截断为96位❺。[表14-1](chapter14.xhtml#tab14-1)显示了Windows上常用的其他加密算法。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Kerberos Encryption Types on Windows</samp>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表14-1：</samp> <samp class="SANS_Futura_Std_Book_11">Windows上的常见Kerberos加密类型</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Encryption</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Verification</samp> |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">加密</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">验证</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AES256_CTS_HMAC_SHA1_96</samp>
    | <samp class="SANS_Futura_Std_Book_11">AES CTS 256-bit</samp> | <samp class="SANS_Futura_Std_Book_11">SHA1
    HMAC truncated to 96 bits</samp> |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AES256_CTS_HMAC_SHA1_96</samp>
    | <samp class="SANS_Futura_Std_Book_11">AES CTS 256位</samp> | <samp class="SANS_Futura_Std_Book_11">SHA1
    HMAC 截断为96位</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AES128_CTS_HMAC_SHA1_96</samp>
    | <samp class="SANS_Futura_Std_Book_11">AES CTS 128-bit</samp> | <samp class="SANS_Futura_Std_Book_11">SHA1
    HMAC truncated to 96 bits</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AES128_CTS_HMAC_SHA1_96</samp>
    | <samp class="SANS_Futura_Std_Book_11">AES CTS 128位</samp> | <samp class="SANS_Futura_Std_Book_11">SHA1
    HMAC 截断为96位</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DES_CBC_MD5</samp> | <samp
    class="SANS_Futura_Std_Book_11">DES 56-bit</samp> | <samp class="SANS_Futura_Std_Book_11">MD5
    HMAC</samp> |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DES_CBC_MD5</samp> | <samp
    class="SANS_Futura_Std_Book_11">DES 56位</samp> | <samp class="SANS_Futura_Std_Book_11">MD5
    HMAC</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ARCFOUR_HMAC_MD5</samp> | <samp
    class="SANS_Futura_Std_Book_11">RC4</samp> | <samp class="SANS_Futura_Std_Book_11">MD5
    HMAC</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ARCFOUR_HMAC_MD5</samp> | <samp
    class="SANS_Futura_Std_Book_11">RC4</samp> | <samp class="SANS_Futura_Std_Book_11">MD5
    HMAC</samp> |'
- en: Notice that the ticket contains the *key version number* ❻. When a user or computer
    changes its password, the shared encryption key must also change. To ensure that
    the system selects the correct key, it stores this version number with the password-derived
    key and increments it upon every key change. In this case, the version is 1, which
    means the computer has never changed its password.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，票证中包含了*密钥版本号* ❻。当用户或计算机更改其密码时，共享的加密密钥也必须更改。为了确保系统选择正确的密钥，它将该版本号与基于密码派生的密钥一起存储，并在每次密钥更改时递增。在此情况下，版本号为1，这意味着计算机从未更改过密码。
- en: The presence of the key version number indicates that the ticket is encrypted
    with a long-lived shared encryption key. A missing version number would indicate
    that the ticket was encrypted with a previously negotiated session key. Because
    we’re looking at the first message being sent to the service as part of this authentication
    process, the client and service do not currently share any session key, so the
    client must use the computer’s shared encryption key.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥版本号的存在表明该票证是用长生命周期的共享加密密钥加密的。缺少版本号则表示票证是用先前协商的会话密钥加密的。由于我们正在查看作为身份验证过程一部分发送给服务的第一条消息，客户端和服务目前不共享任何会话密钥，因此客户端必须使用计算机的共享加密密钥。
- en: The encrypted ciphertext follows the key information. Since we don’t know the
    encryption key, we can’t decrypt it. Following the ticket is the authenticator
    ❼, which also starts by listing key information. Notice the lack of a key version
    number; it’s missing here because the authenticator is encrypted with the session
    key inside the ticket.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 加密的密文紧随密钥信息之后。由于我们不知道加密密钥，无法解密它。紧接在票证之后的是认证器❼，它也首先列出了密钥信息。请注意，缺少密钥版本号；这里没有版本号是因为认证器是用票证内的会话密钥加密的。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In this case, because we’ve generated a ticket targeting the computer we’re
    currently running on, we could extract the computer account encryption key, either
    by directly accessing it in memory or from the MACHINE.ACC$ LSA secret in the
    registry. This process is outside the scope of this chapter.*'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在这种情况下，由于我们生成了一个针对当前运行计算机的票证，我们可以通过直接访问内存或从注册表中的MACHINE.ACC$ LSA机密提取计算机账户的加密密钥。这个过程超出了本章的范围。*'
- en: We can complete the authentication process by passing the client authentication
    token to a server authentication context, in the same way we did when using NTLM
    authentication in [Chapter 13](chapter13.xhtml). [Listing 14-3](chapter14.xhtml#Lis14-3)
    demonstrates this.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将客户端身份验证令牌传递给服务器身份验证上下文来完成身份验证过程，方式与在[第13章](chapter13.xhtml)中使用NTLM身份验证时相同。[清单14-3](chapter14.xhtml#Lis14-3)展示了这一点。
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 14-3: Completing the Kerberos authentication'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-3：完成Kerberos身份验证
- en: We set up the server authentication context, then update the context with the
    client’s authentication token. However, when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    PowerShell command, the authentication fails with an error. Perhaps this shouldn’t
    come as a massive surprise. Only the *Local System* user has direct access to
    the shared encryption key for the computer account used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>
    SPN. Therefore, when the LSA verifies the AP-REQ, it can’t decrypt it and returns
    an error.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: "我们设置了服务器身份验证上下文，然后使用客户端的身份验证令牌更新该上下文。然而，当我们调用<samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >Update-LsaServerContext</samp> PowerShell命令时，身份验证失败并返回错误。也许这不应令人感到特别惊讶。只有*本地系统*用户才能直接访问用于<\t\
    samp class=\"SANS_TheSansMonoCd_W5Regular_11\">HOST</samp> SPN的计算机账户的共享加密密钥。因此，当LSA验证AP-REQ时，它无法解密该信息，并返回错误。"
- en: Can we find an SPN that we can negotiate locally? Windows specifies a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RestrictedKrbHost</samp> service class.
    The SPN for the local computer with this service class is mapped to the computer
    account, so the ticket is once again encrypted using the computer account’s key.
    However, the LSA treats the service class specially and will allow any user on
    the system to decrypt it, unlike with <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>.
    When we change the command to use the restricted service class instead, we get
    the output shown in [Listing 14-4](chapter14.xhtml#Lis14-4).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能找到一个可以本地协商的 SPN 吗？Windows 指定了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">RestrictedKrbHost</samp>
    服务类。具有此服务类的本地计算机的 SPN 映射到计算机帐户，因此票证再次使用计算机帐户的密钥进行加密。然而，LSA 特殊处理此服务类，并允许系统上的任何用户解密它，不像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HOST</samp>。当我们将命令更改为使用受限服务类时，我们得到了在
    [清单 14-4](chapter14.xhtml#Lis14-4) 中显示的输出。
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 14-4: Authenticating using the RestrictedKrbHost SPN'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-4：使用 RestrictedKrbHost SPN 进行身份验证
- en: Here, we change the SPN to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">RestrictedKrbHost</samp>
    service class for the current computer name ❶. We then complete the authentication,
    as in Listings 14-2 and 14-3\. Note the change in the SPN provided in the AP-REQ
    message ❷. This time, when we update the server authentication context the operation
    succeeds, so we can extract the generated <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object and display the logon session ❸.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 SPN 更改为使用当前计算机名称的 <samp class="SANS_TheSansMonoCd_W5Regular_11">RestrictedKrbHost</samp>
    服务类 ❶。然后，按照清单 14-2 和 14-3 完成身份验证。请注意 AP-REQ 消息中提供的 SPN 变更 ❷。这次，当我们更新服务器身份验证上下文时，操作成功，因此我们可以提取生成的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象并显示登录会话 ❸。
- en: In [Listing 14-5](chapter14.xhtml#Lis14-5), we test mutual authentication and
    view the returned AP-REP message.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 14-5](chapter14.xhtml#Lis14-5) 中，我们测试了双向身份验证并查看了返回的 AP-REP 消息。
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 14-5: Enabling mutual authentication'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-5：启用双向身份验证
- en: We enable mutual authentication by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp>
    request attribute flag when creating the client authentication context ❶. In the
    AP-REQ message, we see that a <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuthRequired</samp>
    flag is set ❷, which requires the service to return an AP-REP message. When we
    format the server’s authentication token, we see the AP-REP message, which contains
    only an encrypted value ❸. The encryption key information ❹ doesn’t have a key
    version number, as this is encrypted by the session key, not a shared encryption
    key.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在创建客户端身份验证上下文时指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp>
    请求属性标志来启用双向身份验证 ❶。在 AP-REQ 消息中，我们看到设置了 <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuthRequired</samp>
    标志 ❷，这要求服务返回一个 AP-REP 消息。当我们格式化服务器的身份验证令牌时，我们看到 AP-REP 消息，其中仅包含加密值 ❸。加密密钥信息 ❹
    没有密钥版本号，因为这是通过会话密钥加密的，而不是共享加密密钥。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Decrypting the AP-REQ Message</samp>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解密 AP-REQ 消息</samp>
- en: Once we receive an AP-REQ message, we’ll want to decrypt it. But so far, we’ve
    encrypted all the tickets in our examples using a key derived from the computer’s
    password. While we might be able to extract this password for use in the decryption
    operation, doing so would require a lot of additional work. How can we decrypt
    the ticket for the AP-REQ message with the least amount of effort?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到 AP-REQ 消息，我们就想解密它。但到目前为止，我们在示例中加密了所有票证，使用的是从计算机密码派生的密钥。虽然我们可能能够提取此密码以用于解密操作，但这样做需要额外的工作。我们如何以最少的努力解密
    AP-REQ 消息的票证呢？
- en: 'One approach is to specify an SPN that causes the TGS to use our own password.
    We can then derive the encryption key based on the account password we control
    to decrypt the ticket. You can add an SPN to your user account using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">setspn</samp> utility or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp>
    PowerShell command. You’ll need to do this as a domain administrator; otherwise,
    you won’t have the Active Directory access necessary to configure it. The following
    command adds the SPN <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp>
    to the *alice* user:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是指定一个 SPN，使得 TGS 使用我们自己的密码。然后，我们可以基于我们控制的帐户密码推导出加密密钥来解密票据。您可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">setspn</samp>
    工具或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp> PowerShell
    命令将 SPN 添加到用户帐户中。您需要作为域管理员执行此操作，否则您将无法访问必要的 Active Directory 来进行配置。以下命令将 SPN <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp> 添加到 *alice* 用户：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also use this command to remove SPNs by changing <samp class="SANS_TheSansMonoCd_W5Regular_11">Add</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove</samp>. The SPN can be
    almost arbitrary, but it’s a best practice to stick to known service classes and
    hosts.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Add</samp> 更改为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove</samp>
    来使用此命令删除 SPN。SPN 几乎可以是任意的，但最好遵循已知的服务类和主机的最佳实践。
- en: We can now run the script to perform the authentication with the new SPN. [Listing
    14-6](chapter14.xhtml#Lis14-6) shows the resulting AP-REQ.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行脚本，通过新的 SPN 执行身份验证。[列表 14-6](chapter14.xhtml#Lis14-6) 显示了生成的 AP-REQ。
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 14-6: The AP-REQ for the HTTP/graphite SPN'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-6：HTTP/graphite SPN 的 AP-REQ
- en: 'If you examine this output, you’ll see that not much has changed, but we can
    at least confirm that the ticket relates to the SPN we specified. This means we
    can request a ticket for the service that should map to the user. One other change
    is that the encryption type is now RC4 rather than AES. This is due to an odd
    behavior of Kerberos in Windows: when the SPN is assigned to a user, the encryption
    type defaults to RC4\. This is good news for us, as RC4 is much simpler to decrypt,
    as you’ll soon see. Note also that the key version number is set, indicating that
    the ticket is encrypted with the shared encryption key.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查这个输出，你会发现变化不大，但至少可以确认该票据与我们指定的 SPN 相关。这意味着我们可以请求与该用户相匹配的服务的票据。另一个变化是加密类型现在是
    RC4，而不是 AES。这是由于 Windows 中 Kerberos 的一个奇怪行为：当 SPN 被分配给用户时，加密类型默认为 RC4。这对我们来说是个好消息，因为
    RC4 要比 AES 更容易解密，正如你很快会看到的那样。另请注意，密钥版本号已设置，表示该票据是使用共享加密密钥加密的。
- en: 'Before we can decrypt this ticket, we need to generate a key for the encryption
    algorithm. Generating an RC4 key is easy: we simply calculate the MD4 hash of
    the Unicode password on which it is based. We’ve seen this operation before: this
    key is identical to the NT hash used in NTLM, and not by coincidence. When Microsoft
    introduced the RC4 algorithm into Kerberos, it used the NT hash to support existing
    users without requiring them to update their passwords to generate new encryption
    keys. The use of the RC4 algorithm also circumvents difficulties involving cryptography
    export restrictions.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以解密这个票据之前，需要为加密算法生成一个密钥。生成 RC4 密钥很简单：我们只需计算基于的 Unicode 密码的 MD4 哈希值。我们之前见过这个操作：这个密钥与
    NTLM 中使用的 NT 哈希值相同，这并非巧合。当微软将 RC4 算法引入 Kerberos 时，它使用 NT 哈希来支持现有用户，而不要求他们更新密码以生成新的加密密钥。使用
    RC4 算法还可以规避涉及加密技术出口限制的困难。
- en: If we supply the user’s password, we can generate the RC4 Kerberos key using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosKey</samp> PowerShell
    command, as shown in [Listing 14-7](chapter14.xhtml#Lis14-7).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供用户的密码，我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosKey</samp>
    PowerShell 命令生成 RC4 Kerberos 密钥，如[列表 14-7](chapter14.xhtml#Lis14-7)所示。
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 14-7: Generating an RC4 Kerberos key for the SPN'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-7：为 SPN 生成 RC4 Kerberos 密钥
- en: Note that you must use the valid password of the user account with which you’re
    running the example.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您必须使用运行示例时的有效用户帐户密码。
- en: We can now pass the AP-REQ authentication token and the key to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaAuthToken</samp>
    PowerShell command to decrypt the ticket and authenticator. By passing the decrypted
    authentication token to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    command, we can display the unprotected information. As the decrypted ticket is
    quite large, we’ll inspect it in parts, starting in [Listing 14-8](chapter14.xhtml#Lis14-8).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将 AP-REQ 身份验证令牌和密钥传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaAuthToken</samp>
    PowerShell 命令来解密票证和身份验证器。通过将解密后的身份验证令牌传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp>
    命令，我们可以显示未保护的信息。由于解密后的票证相当大，我们将分部分检查它，从[示例 14-8](chapter14.xhtml#Lis14-8)开始。
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 14-8: The basic decrypted ticket information'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 14-8：基本的解密票证信息
- en: The unencrypted ticket begins at the <samp class="SANS_TheSansMonoCd_W5Regular_11">Realm</samp>
    value. Most of what follows is bookkeeping information, including flags that do
    things like indicate the fact that pre-authentication occurred (<samp class="SANS_TheSansMonoCd_W5Regular_11">PreAuthent</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag is related
    to delegation, a topic we’ll come back to in “Kerberos Delegation” on page 479.
    The ticket also contains the SPN of the user being authenticated ❶. Because the
    *alice* user requested the ticket for the <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp>
    service, this user’s information is what is being authenticated. Next, we see
    that the ticket has a limited lifetime, in this case based on the authentication
    time ❷ and an end time, making it valid for around 10 hours. When the ticket expires,
    the client can renew it for another five days. (The <samp class="SANS_TheSansMonoCd_W5Regular_11">Renewable</samp>
    flag encodes information about the ability to renew the ticket.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 未加密的票证从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Realm</samp> 值开始。接下来大部分是记录信息，包括表示发生了预身份验证的标志（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PreAuthent</samp>）。<samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp>
    标志与委托有关，这是我们将在第 479 页的“Kerberos 委托”中讨论的话题。票证还包含正在进行身份验证的用户的 SPN ❶。由于 *alice* 用户请求了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp> 服务的票证，因此正在进行身份验证的是该用户的信息。接下来，我们看到票证有一个有限的有效期，在这种情况下基于身份验证时间
    ❷ 和结束时间，使其有效期大约为 10 小时。当票证过期时，客户端可以续订它，续订时间为五天。（<samp class="SANS_TheSansMonoCd_W5Regular_11">Renewable</samp>
    标志编码了关于续订票证能力的信息。）
- en: '[Listing 14-9](chapter14.xhtml#Lis14-9) shows the next component of the ticket:
    the randomly generated session key.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14-9](chapter14.xhtml#Lis14-9) 显示了票证的下一个组件：随机生成的会话密钥。'
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 14-9: The ticket session key'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 14-9：票证会话密钥
- en: This session key is used to encrypt the authenticator. The client and server
    might also use it to encrypt and verify any subsequent keys or data they transmit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此会话密钥用于加密身份验证器。客户端和服务器还可能使用它来加密和验证它们传输的任何后续密钥或数据。
- en: After this is a list of authorization data values that the server can use to
    determine the security properties of the client user. The most important of these
    is the PAC, which contains everything the receiving Windows system needs to build
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object for the user.
    The PAC is itself split into multiple parts. [Listing 14-10](chapter14.xhtml#Lis14-10)
    contains its logon information.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之后是一个授权数据值列表，服务器可以使用这些值来确定客户端用户的安全属性。最重要的是 PAC，它包含接收的 Windows 系统需要构建用户的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象的所有信息。PAC 本身被分为多个部分。[示例
    14-10](chapter14.xhtml#Lis14-10) 包含其登录信息。
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 14-10: The logon PAC entry'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 14-10：登录 PAC 条目
- en: 'The logon PAC entry follows the format used in the Netlogon protocol prior
    to Windows 2000\. It starts with basic user information ❶, such as the user’s
    name, SID, and primary group. Next comes the list of group memberships, split
    into three parts: domain groups ❷, resource groups ❸, and extra groups ❺. For
    each group, the SID (formatted as a name if known) and the attributes that should
    apply to it are shown. For size reasons, the domain and resource group SIDs are
    only stored using the last RID value. The full SIDs are derived by adding this
    RID to the logon domain SID ❼ or the resource group SID ❹, respectively. The extra
    groups list stores the full SIDs and so can contain SIDs with different prefixes.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 登录 PAC 条目遵循 Windows 2000 之前 Netlogon 协议使用的格式。它以基本的用户信息 ❶ 开始，例如用户的名称、SID 和主组。接下来是组成员资格列表，分为三部分：域组
    ❷、资源组 ❸ 和额外组 ❺。对于每个组，显示其 SID（如果已知，则格式化为名称）和应应用于它的属性。由于大小原因，域和资源组的 SID 仅使用最后的 RID
    值存储。完整的 SID 通过将此 RID 添加到登录域 SID ❼ 或资源组 SID ❹ 来推导出。额外组列表存储完整的 SID，因此可以包含具有不同前缀的
    SID。
- en: After the group information is additional bookkeeping about the user, such as
    when they last logged on and changed their password ❻. This section also includes
    information about the server and domain that authenticated the user, including
    the domain name and SID. The user flags show that the extra and resource groups
    are present in the ticket. The user account control flags indicate properties
    of the account (in this case, that the user’s password doesn’t expire).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在组信息之后，是关于用户的额外记账信息，例如他们上次登录的时间和密码更改时间 ❻。此部分还包括认证用户的服务器和域的信息，包括域名和 SID。用户标志显示额外组和资源组存在于票证中。用户帐户控制标志表示帐户的属性（在这种情况下，用户的密码不会过期）。
- en: Finally, there is an empty session key consisting of all zeros ❽. You’ll find
    a non-empty session key only if the KDC didn’t directly authenticate the user
    and instead used another authentication protocol, such as NTLM. In this case the
    session key for that sub-authentication protocol will be shown here; however,
    in most cases it will be empty.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，存在一个全零的空会话密钥 ❽。只有在 KDC 没有直接认证用户而是使用其他认证协议（如 NTLM）时，你才会找到一个非空的会话密钥。在这种情况下，那个子认证协议的会话密钥会显示在这里；然而，在大多数情况下，它将为空。
- en: '[Listing 14-11](chapter14.xhtml#Lis14-11) shows the next PAC entry, which contains
    the user’s claim attributes.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-11](chapter14.xhtml#Lis14-11) 显示了下一个 PAC 条目，其中包含用户的声明属性。'
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 14-11: The user claims PAC entry'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-11：用户声明 PAC 条目
- en: As mentioned in [Chapter 4](chapter4.xhtml), the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object exposes these user claims as security attributes, and they can play a role
    in the access control process, typically through a central access policy. If the
    target SPN is a computer account rather than a user account, the Kerberos ticket
    will also include information about the client device in the form of device groups
    and device claims, as shown in [Listing 14-12](chapter14.xhtml#Lis14-12).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 4 章](chapter4.xhtml)所述，<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象将这些用户声明作为安全属性暴露出来，并且它们通常通过中央访问策略在访问控制过程中发挥作用。如果目标 SPN 是计算机帐户而不是用户帐户，则 Kerberos
    票证还将以设备组和设备声明的形式包含有关客户端设备的信息，如[列表 14-12](chapter14.xhtml#Lis14-12)所示。
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 14-12: The device groups and device claims PAC entries'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-12：设备组和设备声明的 PAC 条目
- en: As with the user claims, you’ll typically only find these used in a central
    access policy. [Listing 14-13](chapter14.xhtml#Lis14-13) shows additional bookkeeping
    entries.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户声明一样，这些通常只会在中央访问策略中使用。[列表 14-13](chapter14.xhtml#Lis14-13) 显示了额外的记账条目。
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 14-13: The client info and UPN PAC entries'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-13：客户端信息和 UPN PAC 条目
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Client ID</samp> field should
    match the user’s authentication time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Client ID</samp> 字段应与用户的认证时间匹配。
- en: '[Listing 14-14](chapter14.xhtml#Lis14-14) shows a couple of signatures applied
    to the PAC data to ensure it hasn’t been tampered with. Without these signatures,
    the user could forge their own PAC, adding any groups they would like the LSA
    to place in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-14](chapter14.xhtml#Lis14-14) 显示了应用于 PAC 数据的几个签名，以确保数据没有被篡改。没有这些签名，用户可能会伪造自己的
    PAC，添加他们希望 LSA 在其 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象中放置的任何组。'
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 14-14: PAC signatures'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-14：PAC 签名
- en: The first signature covers the entire PAC. However, as the signature fields
    are embedded inside the PAC, they’re replaced with zeros during the signature
    calculation. This signature is generated using the shared key used to encrypt
    the ticket.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个签名覆盖整个PAC。然而，由于签名字段嵌入在PAC中，它们在签名计算过程中被替换为零。此签名是使用用于加密票证的共享密钥生成的。
- en: The second signature is used to verify that the server signature was issued
    by the KDC. This signature covers only the server and uses the encryption key
    for the *krbtgt* user. To verify the signature, the server needs to send it to
    the KDC, as it doesn’t know the encryption key. For performance reasons, it’s
    common to not perform this validation when the server is running as a privileged
    user such as *SYSTEM*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个签名用于验证服务器签名是否由KDC发出。此签名仅覆盖服务器，并使用*krbtgt*用户的加密密钥。为了验证签名，服务器需要将其发送到KDC，因为它不知道加密密钥。出于性能考虑，当服务器以特权用户身份（如*SYSTEM*）运行时，通常不会执行此验证。
- en: The final signature is calculated from the entire ticket with the PAC removed.
    The encryption key used for the signature is the one for the *krbtgt* user. This
    signature allows the KDC to detect any tampering of the ticket, which the server
    signature wouldn’t cover, as it verifies only the PAC.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最终签名是从整个票证中计算得出的，其中去除了PAC。用于签名的加密密钥是*krbtgt*用户的密钥。这个签名允许KDC检测票证是否被篡改，而服务器签名无法覆盖这一点，因为它仅验证PAC。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Windows has faced multiple security issues related to PAC signature verification.
    Most notable is CVE-2014-6324, which occurred because the TGS accepted CRC32 as
    a valid signature mechanism. As CRC32 is not cryptographically secure and can
    be trivially brute-forced, an attacker could create a valid PAC containing any
    groups they liked, including the full domain administrator.*'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Windows曾面临多个与PAC签名验证相关的安全问题。最著名的是CVE-2014-6324，它发生的原因是TGS接受CRC32作为有效的签名机制。由于CRC32在加密上不安全且可以轻松暴力破解，攻击者可以创建一个有效的PAC，包含他们想要的任何组，包括完整的域管理员组。*'
- en: '[Listing 14-15](chapter14.xhtml#Lis14-15) shows the final component of the
    decrypted AS-REQ message, the authenticator.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-15](chapter14.xhtml#Lis14-15)展示了解密后的AS-REQ消息的最后一个组件——认证器。'
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 14-15: The decrypted AS-REQ authenticator'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-15：解密后的AS-REQ认证器
- en: The authenticator contains some basic user information, as well as a timestamp
    indicating when it was created on the client that can be used to confirm the request
    is recent and has not been replayed to the service.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 认证器包含一些基本的用户信息，以及一个时间戳，表示它是在客户端创建的时间，可以用来确认请求是近期的且未被重放到服务中。
- en: 'One odd thing you might notice is that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp>
    field is present, but it doesn’t appear to contain a valid cryptographic hash
    ❶. This is because the authenticator has repurposed this field to store additional
    information, as indicated by the type value <samp class="SANS_TheSansMonoCd_W5Regular_11">GSSAPI</samp>.
    By default, this field contains the channel binding for the connection, if specified,
    and some additional flags. In this case, no channel binding is set, so the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Channel Binding</samp> field contains
    all zeros. If you were to specify a <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>
    parameter in the same way we did when using NTLM, the field would look something
    like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到一个奇怪的地方，就是出现了一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp>字段，但它似乎不包含有效的加密哈希❶。这是因为认证器将这个字段重新用于存储额外的信息，正如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GSSAPI</samp>类型值所示。默认情况下，如果指定了，它包含连接的通道绑定以及一些附加的标志。在这种情况下，没有设置通道绑定，所以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Channel Binding</samp>字段包含全零。如果你像使用NTLM时那样指定<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp>参数，该字段会类似如下：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The authenticator contains a sub-session key ❷, which the connection can use
    going forward. It also contains a randomly generated sequence number ❸ that, along
    with the timestamp, can thwart replay attacks that attempt to use the same ticket
    and authenticator. Finally, the authenticator can contain additional authorization
    data ❹. In this case, the data specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">AD_ETYPE_NEGOTIATION</samp>
    type, which allows the connection to try to upgrade the encryption algorithm used
    from RC4 to one of the AES encryption formats.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器包含一个子会话密钥❷，该密钥可以在连接中继续使用。它还包含一个随机生成的序列号❸，该序列号与时间戳一起，可以防止重放攻击，防止使用相同的票据和验证器进行攻击。最后，验证器还可以包含额外的授权数据❹。在此情况下，数据指定了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AD_ETYPE_NEGOTIATION</samp>类型，允许连接尝试将加密算法从RC4升级为AES加密格式之一。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">GSSAPI</samp> type value used
    in [Listing 14-15](chapter14.xhtml#Lis14-15) represents the *Generic Security
    Services Application Program Interface (GSSAPI)*, a general API for implementing
    network authentication protocols. You would use GSSAPI instead of SSPI on Linux
    or macOS to perform Kerberos authentication. RFC2743 and RFC2744 define the current
    version of GSSAPI, while RFC4121 defines the protocol’s Kerberos-specific implementation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表14-15](chapter14.xhtml#Lis14-15)中使用的<samp class="SANS_TheSansMonoCd_W5Regular_11">GSSAPI</samp>类型值代表了*通用安全服务应用程序编程接口（GSSAPI）*，这是一个实现网络身份验证协议的通用API。您可以在Linux或macOS上使用GSSAPI代替SSPI来执行Kerberos身份验证。RFC2743和RFC2744定义了GSSAPI的当前版本，而RFC4121定义了该协议的Kerberos特定实现。
- en: SSPI is mostly compatible with GSSAPI, and it’s common to find network protocol
    documentation that refers to the GSSAPI names of the functions to use, especially
    for encryption and signatures. For example, to encrypt and decrypt data in GSSAPI,
    you would use the <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_Wrap</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_Unwrap</samp> functions,
    respectively, instead of the SSPI <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs.
    Similarly, for signature generation and verification, you would use <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_GetMIC</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_VerifyMIC</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp>. As this is a book
    on Windows security, we won’t dwell on the intricacies of GSSAPI any further.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SSPI与GSSAPI基本兼容，通常可以在网络协议文档中看到提到使用GSSAPI函数名称，尤其是在加密和签名方面。例如，在GSSAPI中加密和解密数据时，分别使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GSS_Wrap</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_Unwrap</samp>函数，而不是SSPI中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp>
    API。类似地，在生成和验证签名时，应该使用<samp class="SANS_TheSansMonoCd_W5Regular_11">GSS_GetMIC</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GSS_VerifyMIC</samp>，而不是<samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp>。由于本书主要讨论Windows安全性，我们将不再深入探讨GSSAPI的细节。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Decrypting the AP-REP Message</samp>
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解密AP-REP消息</samp>
- en: Once we’ve decrypted the AP-REQ message’s ticket and authenticator, we have
    the key we need to decrypt the AP-REP used for mutual authentication. We do so
    in [Listing 14-16](chapter14.xhtml#Lis14-16).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们解密了AP-REQ消息的票据和验证器，我们就得到了用于解密AP-REP以进行相互身份验证的密钥。在[列表14-16](chapter14.xhtml#Lis14-16)中我们完成了这个过程。
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 14-16: Decrypting the AP-REP message'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-16：解密AP-REP消息
- en: We first need to get the session key from the decrypted AP-REQ ticket. With
    that key, we can decrypt the AP-REP using <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaAuthToken</samp>
    once again. In the output, you can see the newly negotiated session key; in this
    case, it’s been upgraded from RC4 to an AES key. It also includes a sequence number
    to prevent replay attacks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要从解密后的AP-REQ票据中获取会话密钥。有了该密钥，我们可以再次使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaAuthToken</samp>解密AP-REP。在输出中，您可以看到新协商的会话密钥；在此案例中，它已从RC4升级为AES密钥。它还包括一个序列号，以防止重放攻击。
- en: 'Next, we’ll look at one more topic related to Kerberos service authentication:
    how it works across domain trust boundaries.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨与Kerberos服务身份验证相关的另一个话题：它如何跨域信任边界工作。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Cross-Domain Authentication</samp>
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">跨域身份验证</samp>
- en: When discussing domain forests in [Chapter 10](chapter10.xhtml) I mentioned
    the concept of trust relationships, in which a trusted domain accepts credentials
    belonging to a user configuration stored on a different domain. This section discusses
    how the Kerberos protocol works across domains in the same forest. Although Kerberos
    authentication can also occur between forests, and with non-Windows Kerberos implementations,
    we won’t cover those complex cases here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论[第10章](chapter10.xhtml)中的域森林时，我提到了信任关系的概念，其中一个受信域接受存储在另一个域中的用户配置信息作为凭据。本节讨论Kerberos协议如何在同一森林中的域之间工作。尽管Kerberos身份验证也可以在不同森林之间发生，并且支持非Windows的Kerberos实现，但我们这里不讨论这些复杂的情况。
- en: '[Figure 14-6](chapter14.xhtml#fig14-6) shows the basic operations of inter-domain
    Kerberos authentication between the example *MINERAL* and *SALES* domains.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-6](chapter14.xhtml#fig14-6)展示了示例*MINERAL*域与*SALES*域之间跨域Kerberos身份验证的基本操作。'
- en: '![](../images/Figure14-6.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: An overview of
    inter-domain Kerberos authentication</samp>'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-6：跨域Kerberos身份验证概览</samp>
- en: The client in the *MINERAL* domain first requests a service ticket for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.SALES</samp> SPN ❶. The TGS can’t
    satisfy this request, as the SPN isn’t present in its own domain. It checks the
    global catalog to see if any other domain in the forest has the SPN configured,
    and finds it in the *SALES* domain.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*MINERAL*域中的客户端首先请求<samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.SALES</samp>
    SPN的服务票据❶。由于SPN不在其自己的域中，TGS无法满足此请求。它检查全局目录，查看森林中是否有其他域配置了该SPN，并在*SALES*域中找到了它。'
- en: The TGS then checks whether it has a trust relationship with the *SALES* domain,
    which it does. When a new trust relationship is established between two domains,
    a shared Kerberos key is configured between the domain controllers in each domain.
    This key encrypts a *referral ticket*, which contains the user’s information and
    the requested service, and returns it to the client ❷. The client then forwards
    the referral ticket to the TGS in the *SALES* domain ❸. As the ticket is encrypted
    using a shared inter-domain key, the *SALES* TGS can decrypt it to verify its
    contents.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，TGS检查它是否与*SALES*域有信任关系，结果是有的。当两个域之间建立新的信任关系时，会在每个域的域控制器之间配置共享的Kerberos密钥。该密钥加密一个*推荐票据*，其中包含用户的信息和请求的服务，并将其返回给客户端❷。客户端随后将推荐票据转发到*SALES*域中的TGS❸。由于票据是使用共享的跨域密钥加密的，*SALES*
    TGS可以解密该票据以验证其内容。
- en: The *SALES* TGS needs to modify the PAC provided in the referral ticket to add
    domain-local group memberships for the *SALES* domain based on the user’s existing
    groups. The TGS will then re-sign the modified PAC and insert it into the service
    ticket for use by the local service. It can now issue the service ticket for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.SALES</samp> and, using the service’s
    key, return it to the client ❹.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*SALES* TGS需要修改推荐票据中提供的PAC，基于用户现有的组，添加属于*SALES*域的本地域组成员资格。然后，TGS会重新签名修改后的PAC，并将其插入到服务票据中供本地服务使用。它现在可以为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.SALES</samp>颁发服务票据，并使用服务的密钥将其返回给客户端❹。'
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In complex inter-domain trust relationships, domains shouldn’t trust any additional
    SIDs included in the PAC, as an attacker who has compromised the source domain
    could generate a PAC containing arbitrary SIDs and then compromise the target*
    *domain. Windows implements a SID-filtering mechanism to remove SIDs from the
    PAC that are deemed dangerous, such as any SIDs for the local domain. The full
    details of SID filtering are, however, outside the scope of this book.*'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在复杂的跨域信任关系中，域不应信任PAC中包含的任何附加SID，因为攻击者如果入侵了源域，可能会生成包含任意SID的PAC，然后危及目标* *域。Windows实现了SID过滤机制，以删除PAC中被认为危险的SID，例如任何本地域的SID。SID过滤的详细信息超出了本书的范围。*'
- en: Finally, the client can use the service ticket to authenticate to the services
    in the *SALES* domain ❺. The server receiving the service ticket can use it to
    build a token based on the modified PAC generated by its domain’s TGS.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，客户端可以使用服务票据向*SALES*域的服务进行身份验证❺。接收服务票据的服务器可以利用它根据其域的TGS生成的修改后的PAC构建令牌。
- en: The domains might need to repeat this process of issuing a referral ticket multiple
    times if they don’t have a direct trust relationship. For example, returning to
    the example domains from [Chapter 10](chapter10.xhtml), if a user in the *ENGINEERING*
    domain wanted to authenticate to a service in the *SALES* domain, then the root
    *MINERAL* domain would first have to issue a referral ticket. This ticket could
    then be used to establish a referral ticket for the *SALES* domain.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果域之间没有直接的信任关系，它们可能需要多次重复发放推荐票据的过程。例如，回到[第10章](chapter10.xhtml)中的域示例，如果*ENGINEERING*域中的用户希望认证到*SALES*域中的服务，则根域*MINERAL*首先需要发放一个推荐票据。然后，该票据可以用于为*SALES*域建立推荐票据。
- en: In more complex forests consisting of many domains and trees, this multi-hop
    referral process might lead to poor performance. To remediate this, Windows provides
    a mechanism to establish a *shortcut trust* relationship between any two domains
    in a forest. The domains can use this trust to establish the referral ticket without
    needing to follow the normal transitive trust path.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在由多个域和树组成的更复杂的森林中，这种多跳转推荐过程可能会导致性能下降。为了解决这个问题，Windows提供了一种机制，可以在森林中的任何两个域之间建立*快捷信任*关系。这些域可以利用此信任关系建立推荐票据，而无需遵循正常的传递信任路径。
- en: We’ve covered the basics of Kerberos authentication. Now let’s move on to deeper
    topics, starting with how an authenticated user can securely forward their credentials
    to a service.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了Kerberos认证的基础知识。接下来让我们深入探讨更复杂的话题，首先讨论经过认证的用户如何安全地将他们的凭据转发给服务。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Kerberos Delegation</samp>
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Kerberos委派</samp>
- en: '*Delegation* enables a service to forward a user’s credentials to another service.
    This is useful because, when a user connects to a service using Kerberos, they
    do not provide it with their credentials. Instead, they provide a ticket that
    has been encrypted using the server’s shared encryption key. The service could
    try forwarding the ticket on to another service, but as it won’t know the new
    service’s shared encryption key it won’t be able to encrypt the ticket, so the
    new service won’t accept it.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*委派*使得一个服务能够将用户的凭据转发到另一个服务。这是有用的，因为，当用户通过Kerberos连接到一个服务时，他们不会向其提供自己的凭据。相反，他们提供一个使用服务器共享加密密钥加密的票据。服务可以尝试将票据转发到另一个服务，但由于它不知道新服务的共享加密密钥，它将无法加密票据，因此新服务将无法接受该票据。'
- en: The only way to get an encrypted ticket for a new service might seem to be to
    send a TGS-REQ message to the TGS using a TGT. However, the original service only
    has a TGT for its own account, not for the user, and without the user’s TGT a
    service can’t forward a user’s credentials further than specified. This behavior
    provides an important security measure; if any authentication a user made to a
    service could be delegated to another service, it would likely be easy to get
    full administrator access to the domain.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 获取新服务的加密票据的唯一方法似乎是使用TGT向TGS发送TGS-REQ消息。然而，原始服务只有自己的TGT，而没有用户的TGT，没有用户的TGT，服务无法将用户的凭据转发到指定的服务。这种行为提供了一个重要的安全措施；如果用户对某个服务的认证能够被委托给另一个服务，可能会很容易获取对域的完全管理员访问权限。
- en: That said, forwarding credentials is a useful feature. For example, let’s say
    you have a corporate network that users can access only from an external network,
    via a web server. It would be useful if the web server could provide the users’
    credentials to access the backend systems, such as a database server. One way
    of solving this issue would be for the web server to request the user’s plaintext
    credentials and then use those to authenticate to the domain, which would then
    provide the user’s TGT. In practice, though, this is a terrible idea for security.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，转发凭据是一个有用的功能。例如，假设你有一个公司网络，用户只能通过外部网络访问该网络，通常是通过一个Web服务器。如果Web服务器能够提供用户的凭据以访问后端系统，比如数据库服务器，那将非常有用。解决这个问题的一种方法是让Web服务器请求用户的明文凭据，然后用这些凭据进行域认证，之后域会提供用户的TGT。然而，在实际操作中，这对于安全性来说是一个糟糕的主意。
- en: Therefore, to make it possible to securely forward credentials, Kerberos implements
    a defined delegation process. A client can opt in to delegation, allowing a target
    service to use their identity to request tickets for other network services on
    their behalf. Windows domains configure delegation on a per-account basis for
    both users and computers. In the GUI, you’ll see the delegation dialog shown in
    [Figure 14-7](chapter14.xhtml#fig14-7) when inspecting the properties of an account.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使安全地转发凭证成为可能，Kerberos 实现了一个定义的委派过程。客户端可以选择加入委派，允许目标服务使用他们的身份代表他们请求其他网络服务的票证。Windows
    域为用户和计算机按帐户配置委派。在 GUI 中，您将在检查帐户属性时看到[图 14-7](chapter14.xhtml#fig14-7)中显示的委派对话框。
- en: '![](../images/Figure14-7.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: The delegation
    tab for the</samp> <samp class="SANS_Futura_Std_Book_11">GRAPHITE</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">computer account</samp>'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-7：用于</samp> <samp class="SANS_Futura_Std_Book_11">GRAPHITE</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">计算机帐户的委派标签</samp>
- en: '[Figure 14-7](chapter14.xhtml#fig14-7) shows three main options for delegation.
    The first option, the default, disables delegation for the account. The second
    option, called *unconstrained delegation*, allows the account to delegate to any
    other service on the network using the authenticating user’s credentials. The
    third option, known as *constrained delegation*, allows the user’s credentials
    to be delegated to a fixed set of services defined by a list of permitted SPNs.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-7](chapter14.xhtml#fig14-7) 显示了三种主要的委派选项。第一种选项，即默认选项，禁用帐户的委派。第二种选项，被称为
    *不受限委派*，允许帐户使用认证用户的凭证将委派到网络上的任何其他服务。第三种选项，称为 *受限委派*，允许将用户的凭证委派到由允许的 SPN 列表定义的固定服务集合。'
- en: Let’s dig into the similarities and differences between the two types of delegation
    and see how they’re implemented. In the following sections, we’ll modify some
    of the delegation settings in the Active Directory server. This means that you
    must perform these operations from a user account that has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeEnableDelegationPrivilege</samp>
    on the domain controller. Typically, only administrators have this privilege,
    so you should run these examples as a domain administrator.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨两种委派类型之间的相似性和差异，并查看它们是如何实现的。在接下来的部分中，我们将修改 Active Directory 服务器中的一些委派设置。这意味着您必须从具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeEnableDelegationPrivilege</samp>
    权限的用户帐户执行这些操作。通常，只有管理员才具有此权限，因此您应该以域管理员身份运行这些示例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unconstrained Delegation</samp>
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">不受限委派</samp>
- en: Microsoft introduced unconstrained delegation in Windows 2000 along with the
    original Windows Kerberos implementation. This Kerberos delegation mechanism requires
    the client to opt in to providing a copy of their TGT, enabling the service to
    delegate their credentials. It works only with Kerberos authentication, as the
    user must have first authenticated to the service using the Kerberos protocol.
    [Figure 14-8](chapter14.xhtml#fig14-8) gives an overview of the unconstrained
    delegation process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在 Windows 2000 中引入了不受限的委派功能，并与原始的 Windows Kerberos 实现一起推出。这个 Kerberos 委派机制要求客户端选择加入提供其
    TGT 的副本，从而使服务能够委派他们的凭证。它仅与 Kerberos 认证一起工作，因为用户必须先使用 Kerberos 协议通过认证服务进行身份验证。[图
    14-8](chapter14.xhtml#fig14-8)概述了不受限的委派过程。
- en: '![](../images/Figure14-8.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: The unconstrained
    delegation process</samp>'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-8：不受限的委派过程</samp>
- en: This figure shows a client delegating its credentials through the HTTP service
    on the server *WEB* to the database service on the server *DB*. The client first
    makes a ticket request to the TGS with its TGT for a normal ticket, using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.MINERAL</samp> SPN ❶. If
    the destination service can use delegation, the returned ticket should have the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OkAsDelegate</samp> flag set, which
    indicates to the client that it can delegate if it wants to.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了一个客户端通过服务器 *WEB* 上的 HTTP 服务将其凭证委派到服务器 *DB* 上的数据库服务。客户端首先使用其 TGT 向 TGS 发起请求，获取普通票证，并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/WEB.MINERAL</samp> SPN ❶。如果目标服务可以使用委派，返回的票证应设置
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OkAsDelegate</samp> 标志，这表示客户端可以选择是否委派凭证。
- en: The client then makes a second request for a new TGT to send to the HTTP service.
    The client indicates its intention by specifying the target principal name as
    the *krbtgt* user and setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwarded</samp> flags on the
    TGS-REQ ❷. If delegation is allowed, the TGS will return this new TGT to the client.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端然后会发起第二次请求，获取一个新的 TGT 发送给 HTTP 服务。客户端通过将目标主体名称指定为 *krbtgt* 用户，并在 TGS-REQ
    ❷ 上设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Forwarded</samp> 标志，来表明它的意图。如果允许委派，TGS
    将把这个新的 TGT 返回给客户端。
- en: The client can then package up the original service ticket and the TGT into
    the AP-REQ message for the server and send it over HTTP ❸. The AP-REQ must also
    contain the session key information for the encrypted TGT so that the target service
    can decrypt it. The Windows APIs enable mutual authentication when delegating
    credentials, so the server returns an AP-REP to the client ❹.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端随后可以将原始服务票证和 TGT 打包到 AP-REQ 消息中，发送给服务器，并通过 HTTP ❸ 传输。AP-REQ 消息还必须包含加密 TGT
    的会话密钥信息，以便目标服务能够解密它。Windows API 在委派凭证时启用相互认证，因此服务器会向客户端返回 AP-REP ❹。
- en: Once the HTTP service has received the AP-REQ, it can get the LSA to give it
    a token for that user. The LSA will also save the TGT and session key information
    in the new logon session. When the HTTP service wants to authenticate to the database
    service, it can impersonate the user’s token and start the Kerberos authentication
    process. This means the user’s TGT will be used to request a ticket for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SQL/DB.MINERAL</samp> from the TGS ❺.
    Assuming the service meets all the policy requirements, the TGS will return the
    service ticket ❻, which the LSA will return as a new AP-REQ to pass to the database
    service ❼, completing the delegation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 HTTP 服务接收到 AP-REQ，它可以获取 LSA 给该用户的令牌。LSA 还会将 TGT 和会话密钥信息保存在新的登录会话中。当 HTTP
    服务想要对数据库服务进行认证时，它可以模拟该用户的令牌，并启动 Kerberos 认证过程。这意味着用户的 TGT 将用于从 TGS 请求 <samp class="SANS_TheSansMonoCd_W5Regular_11">SQL/DB.MINERAL</samp>
    的票证 ❺。假设服务满足所有策略要求，TGS 将返回服务票证 ❻，LSA 将返回一个新的 AP-REQ，并将其传递给数据库服务 ❼，完成委派。
- en: 'As the delegated TGT is sent via the AP-REQ message, we should be able to inspect
    the delegation process occurring during a local authentication in PowerShell.
    The authenticating user needs a registered SPN. We’ll use the *alice* user, for
    whom we added an SPN in “Decrypting the AP-REQ Message” on page 469. First we
    must enable unconstrained delegation for this user. You can either use the GUI
    to enable the delegation, or run the following <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADAccountControl</samp>
    PowerShell command as a domain administrator:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于委派的 TGT 是通过 AP-REQ 消息发送的，我们应该能够检查在 PowerShell 中本地认证期间发生的委派过程。进行认证的用户需要一个注册的
    SPN。我们将使用 *alice* 用户，之前在“解密 AP-REQ 消息”第 469 页为其添加了 SPN。首先，我们必须为此用户启用不受约束的委派。你可以使用
    GUI 启用委派，或者作为域管理员运行以下 <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADAccountControl</samp>
    PowerShell 命令：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can verify that delegation has been enabled using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp> command
    (depending on the account type), as shown in [Listing 14-17](chapter14.xhtml#Lis14-17).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp> 命令（根据账户类型）来验证是否已启用委派，如
    [列表 14-17](chapter14.xhtml#Lis14-17) 所示。
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 14-17: Querying the user’s TrustedForDelegation property'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-17：查询用户的 TrustedForDelegation 属性
- en: Now let’s create a client authentication context and request an AP-REQ message
    with a delegate ticket ([Listing 14-18](chapter14.xhtml#Lis14-18)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个客户端身份验证上下文，并请求带有委派票证的 AP-REQ 消息（[列表 14-18](chapter14.xhtml#Lis14-18)）。
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 14-18: Requesting an AP-REQ and displaying the delegate ticket'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-18：请求 AP-REQ 并显示委派票证
- en: We must specify both the <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Delegate</samp> flags ❶ for
    the LSA to request the delegated TGT. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">OkAsDelegate</samp>
    flag is set in the resulting ticket ❷. This flag exists regardless of whether
    the client requested delegation, as the LSA combines it with the delegate request
    attribute to determine whether to request the TGT.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The authenticator stores the new TGT as part of the GSSAPI checksum, as shown
    in [Listing 14-19](chapter14.xhtml#Lis14-19).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 14-19: The AP-REQ authenticator with the delegated TGT'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: If you compare this authenticator with the one shown in [Listing 14-15](chapter14.xhtml#Lis14-15),
    the first difference you should notice is that both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Delegate</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutual</samp> context flags
    are set ❶.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Delegate</samp> flag indicates
    that a *Kerberos Credential (KRB-CRED)* structure is packed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp>
    field. Within the KRB-CRED, we find the TGT ticket ❷. We can tell it’s a TGT because
    it’s for the *krbtgt* principal ❸. The KRB-CRED structure also contains an extra
    encrypted part to hold the session keys that go with the TGT ❹.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: If we can complete the authentication, we can receive an impersonation token.
    The LSA now has enough information for the service to request any service ticket
    on behalf of the user that provided the delegated TGT, as demonstrated in [Listing
    14-20](chapter14.xhtml#Lis14-20).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 14-20: Completing the delegation authentication process'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
    in [Listing 14-20](chapter14.xhtml#Lis14-20) has the Delegation impersonation
    level. Certain kernel APIs enforce this impersonation level, including <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateClientSecurity</samp>,
    which captures the calling client’s token for later use by the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonateClient</samp>
    kernel API. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateClientSecurity</samp>
    API takes a Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerIsRemote</samp>
    parameter. If the parameter is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the API fails to capture the token if the impersonation level is not Delegation.
    However, well-known callers such as the SMB do not set the parameter to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Therefore, the Delegation
    impersonation level is the de facto equivalent to the Impersonation level for
    both local and remote access, assuming there are credentials available in the
    logon session.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In Windows 10 and later, you can enable a feature called Credential Guard
    that uses virtualization technology to protect the user’s credentials, including
    the Kerberos TGT session key stored by the LSA, from being disclosed to a privileged
    user reading the memory of the LSASS process. As unconstrained delegation would
    introduce a mechanism to disclose the TGT session key for a user, it is no longer
    possible to use it if Credential Guard is enabled.*'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constrained Delegation</samp>
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Microsoft introduced constrained delegation, also called *Service for User
    (S4U)*, in Windows 2003\. Its purpose was to fix a security weakness in unconstrained
    delegation: namely, once a user had delegated credentials to a service, it could
    impersonate them to any other service in the same domain, even if the services
    were completely unrelated to the purpose of the original service.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: This made any service with unconstrained delegation a good target for attack.
    If you compromised the service and could convince a privileged user to delegate
    their credentials to it, you had a good chance of compromising the entire network.
    Technically a user had to opt in to delegating their credentials, but common client
    applications such as Internet Explorer did so by default, and always passed the
    delegate request attribute when setting up the client authentication context.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft resolved the security weakness by allowing an administrator to specify
    an explicit list of SPNs that the service could use for delegation. For example,
    the administrator could limit the HTTP service discussed earlier to delegating
    only to the database service and nothing else.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Constrained delegation can work in three modes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos-only delegation
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol transition delegation
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource-based delegation
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll cover each mode in turn in the following sections.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Kerberos-Only Delegation</samp>
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Also called *Service for User to Proxy (S4U2proxy)* in the official documentation,
    the Kerberos-only delegation mode works in much the same way as unconstrained
    delegation. It requires the user to authenticate to the intermediate service using
    Kerberos, as described in [Figure 14-9](chapter14.xhtml#fig14-9).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-9.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: An overview of
    constrained Kerberos-only delegation</samp>'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: While this looks very similar to [Figure 14-8](chapter14.xhtml#fig14-8), there
    are subtle differences. First, the original user requests a normal service ticket
    for the HTTP service ❶, not an additional TGT. The user can package this service
    ticket into an AP-REQ message and send it to the HTTP service ❷. The HTTP service
    then wants to delegate the user’s authentication to the database service, so it
    requests a service ticket from the TGS, including its own TGT. It also attaches
    the user’s service ticket for its own service to the TGS-REQ message ❸.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The TGS inspects the request. If the user’s service ticket has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp>
    flag set and the database service is in the list of allowed services for the account
    making the ticket request, the TGS will use the user’s service ticket to the HTTP
    service to generate a service ticket for the database service ❹. The service can
    package this ticket and associated information into an AP-REQ message as normal
    and send it to the database service ❺.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: While it might seem as though the user can’t control the delegation of their
    credentials, they could block the delegation by simply choosing not to request
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> service ticket.
    We’ll come back to how to unset the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp>
    flag later.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The list of SPNs for services to which an account can delegate is stored in
    the user’s or computer’s account entry in Active Directory, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToDelegateTo</samp>
    attribute. You can set this attribute using <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADComputer</samp> in PowerShell,
    as shown in [Listing 14-21](chapter14.xhtml#Lis14-21).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 14-21: Adding a new msDS-AllowedToDelegateTo entry for the <samp class="SANS_Futura_Std_Book_11">alice</samp>
    account'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: To query the list of SPNs, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>, as shown
    in [Listing 14-22](chapter14.xhtml#Lis14-22).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 14-22: Querying the msDS-AllowedToDelegateTo attribute'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we confirm we can delegate to the <samp class="SANS_TheSansMonoCd_W5Regular_11">CIFS/graphite</samp>
    service.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Protocol Transition Delegation</samp>
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Requiring end-to-end Kerberos authentication to the domain isn’t always feasible.
    For example, what if the user accessing the HTTP service is on a public network
    and cannot directly connect to the KDC to get a service ticket? This is where
    the second type of constrained delegation—protocol transition delegation, referred
    to as *Service for User to Self (S4U2self)* in the documentation—might be useful.
    It performs an *authentication protocol transition*, meaning that the frontend
    HTTP service can authenticate using its own authentication mechanism, then use
    that information to construct a service ticket for the database service with the
    user’s domain credentials, without requiring the user to know about Kerberos.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-10](chapter14.xhtml#fig14-10) shows the steps involved in constrained
    delegation using an authentication protocol transition.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-10.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: An overview of
    constrained delegation with an authentication protocol transition</samp>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The user first makes a request to the HTTP service and provides authentication
    credentials ❶. The credentials don’t have to be related to the Kerberos credentials
    we want to use, and the authentication protocol used can be anything, such as
    basic HTTP authentication. The HTTP service maps the authenticated user to a domain
    account, then makes a request to the TGS for a service ticket for itself with
    that domain account’s information ❷.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The TGS gathers all of the target user’s details (like their group memberships),
    puts them into the PAC, and sends the service ticket back to the service. Because
    the ticket is for the service itself, the LSA can decrypt the ticket, extract
    the PAC, and generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: This process might seem dangerous. After all, it lets you request a service
    ticket out of thin air without requiring any authentication of the user. Believe
    it or not, this is really how S4U2self works; however, bear in mind that the token
    generated is only useful for the local system. The LSA can already synthesize
    a token containing any groups it likes and use it locally, so this doesn’t change
    the security properties of the system.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with a synthesized local token, though, the LSA has a copy of the S4U2self
    service ticket. If the service’s account is configured for delegation, it can
    use S4U2proxy with the S4U2self service ticket to request a service ticket for
    a permitted service ❸. It can then package this new service ticket in an AP-REQ
    and use it to authenticate to the database service ❹.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'You can configure S4U2self to be permitted to transition to S4U2proxy by setting
    the list of permitted SPNs in <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToDelegateTo</samp>
    and setting the user account control flag <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. You saw how to modify
    the permitted SPNs in [Listing 14-21](chapter14.xhtml#Lis14-21). You can set the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp>
    flag using the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To query the status of the flag, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>, as shown
    in [Listing 14-23](chapter14.xhtml#Lis14-23).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 14-23: Querying the TrustedToAuthForDelegation flag'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: You’ll note we do not check whether we can request the initial S4U2self ticket.
    As mentioned earlier, this is only an issue for the local system’s security. Without
    S4U2proxy configured, the computer can’t use the credentials in a network request.
    In fact, any user on Windows can request an S4U token using <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    or via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command,
    even if not connected to an enterprise network.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-24](chapter14.xhtml#Lis14-24) shows that we’re currently running
    as the *alice* user. Let’s try requesting a token for another user.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-24](chapter14.xhtml#Lis14-24)显示我们当前是以*alice*用户身份运行。让我们尝试请求另一个用户的令牌。'
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 14-24: Requesting an S4U2self token as a normal user'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-24：以普通用户身份请求S4U2self令牌
- en: Here, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">S4U</samp> parameter to
    request a token for the *bob* user ❶. Notice we don’t need to specify a password.
    We can confirm that the token is really for *bob* by formatting it ❷.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用带有<samp class="SANS_TheSansMonoCd_W5Regular_11">S4U</samp>参数的<code>Get-NtToken</code>来请求*bob*用户的令牌❶。请注意，我们不需要指定密码。我们可以通过格式化令牌来确认它确实是为*bob*用户请求的❷。
- en: This design would have a massive local security hole if the LSA didn’t restrict
    the token to Identification level, which prevents a normal user from being able
    to use the token to access secured resources ❸. The only way to get an Impersonation-level
    token is to have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled, which only the local *SYSTEM* account has by default. Thus, it’s typical
    to configure <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp>
    on the computer account used by the *SYSTEM* account, so it can impersonate the
    S4U2self token at the Impersonation level, then get the LSA to query for the S4U2proxy
    ticket.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果LSA没有将令牌限制为身份验证级别，这个设计将会带来一个巨大的本地安全漏洞，因为这会允许普通用户使用该令牌访问受保护的资源❸。获得模拟级别令牌的唯一方法是启用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>，而该权限默认只有本地*SYSTEM*账户具有。因此，通常会在*SYSTEM*账户使用的计算机账户上配置<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp>，这样它就可以在模拟级别上模拟S4U2self令牌，然后让LSA查询S4U2proxy票据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resource-Based Delegation</samp>
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于资源的委派</samp>
- en: The final constrained delegation type, resource-based delegation, was introduced
    in Windows Server 2012\. It doesn’t change the underlying delegation process outlined
    previously; instead, it changes the condition under which a forwardable ticket
    gets issued for a service. Rather than basing this decision only on the account
    requesting the delegated ticket, it also considers the target SPN being requested.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种受限委派类型是基于资源的委派，它在Windows Server 2012中引入。它并没有改变之前概述的底层委派过程；而是改变了发放可转发票据的条件。它不仅根据请求委派票据的账户来做出决定，还考虑了请求的目标SPN。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToActOnBehalfOfOtherIdentity</samp>
    attribute on a user or computer object controls resource-based delegation. This
    attribute is a security descriptor that contains an ACE for every account the
    user can delegate to. You can set it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADComputer</samp> PowerShell
    command by specifying distinguished names of the users or computers to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PrincipalsAllowedToDelegateToAccount</samp>
    parameter. In [Listing 14-25](chapter14.xhtml#Lis14-25), we add the *GRAPHITE*
    computer account to the list of accounts to which the *alice* user can delegate.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 用户或计算机对象上的<samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToActOnBehalfOfOtherIdentity</samp>属性控制基于资源的委派。此属性是一个安全描述符，包含一个ACE，表示每个用户可以委派的账户。您可以通过指定用户或计算机的区分名称，将其设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PrincipalsAllowedToDelegateToAccount</samp>参数，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Set-ADUser</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">Set-ADComputer</samp>
    PowerShell命令。在[列表14-25](chapter14.xhtml#Lis14-25)中，我们将*GRAPHITE*计算机账户添加到*alice*用户可以委派的账户列表中。
- en: '[PRE29]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 14-25: Setting resource-based delegation on a user account'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-25：在用户账户上设置基于资源的委派
- en: This allows the *GRAPHITE* computer account to request a service ticket for
    one of the *alice* user’s SPNs. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>
    command exposes the full distinguished name of the target account ❶, but if we
    extract the security descriptor from the attribute and format it, we see the *MINERAL\GRAPHITE$*
    SID in an ACE in the formatted DACL ❷.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许*GRAPHITE*计算机账户请求服务票据，以便访问其中一个*alice*用户的SPN。<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>命令暴露了目标账户的完整区分名称❶，但如果我们从属性中提取安全描述符并格式化它，我们可以在格式化的DACL中看到*MINERAL\GRAPHITE$*
    SID出现在一个ACE中❷。
- en: When transitioning from S4U2self to S4U2proxy, the client principal doesn’t
    need to have the <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthForDelegation</samp>
    flag set. As a mechanism of control, the domain controller provides two group
    SIDs that indicate the source of the token. [Table 14-2](chapter14.xhtml#tab14-2)
    shows these two SIDs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 14-2:</samp> <samp class="SANS_Futura_Std_Book_11">SIDs
    for Asserted Identities</samp>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SID</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Authentication authority
    asserted identity</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-18-1</samp>
    | <samp class="SANS_Futura_Std_Book_11">Token generated through authentication</samp>
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Service asserted identity</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-18-2</samp> | <samp class="SANS_Futura_Std_Book_11">Token
    generated through an S4U mechanism</samp> |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: The first SID indicates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object was generated by providing authentication credentials to the KDC. The second
    SID is assigned for S4U2self or S4U2proxy tokens. A security descriptor can use
    these SIDs to limit access to a service configured for resource delegation to
    either Kerberos-only delegation, which gets the first SID, or authentication protocol
    transition delegation, which gets the second.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Delegation is a dangerous feature if misconfigured, and it’s easy to misconfigure.
    This seems especially true for transitioning from S4U2self to S4U2proxy through
    constrained delegation, through which a service could impersonate any user in
    the domain, including privileged users. To reduce the danger of this occurring,
    the system can set the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountNotDelegated</samp>
    UAC flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> on an account
    to block it from being used in a delegation scenario. In the GUI, this flag is
    called “Account is sensitive and cannot be delegated.” You can set it on the domain
    controller using a domain administrator account by running the following PowerShell
    command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In [Listing 14-26](chapter14.xhtml#Lis14-26), we look at what this flag changes
    to prevent delegation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 14-26: Inspecting ticket flags for an account with AccountNotDelegated
    set'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: First, we confirm that the *alice* user has the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountNotDelegated</samp>
    flag set to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> ❶. We then
    request a service ticket for this user. By decrypting it, we can see that the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag is no longer
    present ❷. As explained earlier, the TGS will refuse to issue a new service ticket
    based on an existing service ticket if the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp>
    flag is not set. This effectively blocks delegation automatically. Note that if
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Forwardable</samp> flag is set
    and you’ve just changed the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountNotDelegated</samp>
    flag, I’d recommend logging out, then logging back in as the user to ensure the
    user has no tickets cached.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we’ve needed an SPN configured for a user or computer in order for
    the KDC to select the correct shared encryption key. An alternative authentication
    mode is also available that allows users to authenticate to each other without
    an SPN. Let’s finish the chapter by discussing how we can use Kerberos without
    configuring an SPN for a user.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">User-to-User Kerberos Authentication</samp>
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The NTLM protocol can perform network authentication between unprivileged users,
    but because a Kerberos account needs a mapped SPN in order to grant a ticket,
    it shouldn’t normally be able to do this. To enable authentication between unprivileged
    users, Windows Kerberos includes a feature called *User-to-User (U2U) authentication*.
    [Figure 14-11](chapter14.xhtml#fig14-11) shows the basic operations of U2U authentication.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-11.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: User-to-user
    authentication with Kerberos</samp>'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, *alice* wants to authenticate to a service running under *bob*’s
    account. However, *bob* doesn’t have an SPN registered, so when *alice* makes
    a service ticket request ❶, it will fail, as the KDC doesn’t know the target SPN.
    But because the requested service name is in UPN format (that is, <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp>),
    the LSA assumes that the user wants U2U authentication and instead generates a
    TGT-REQ message. It sends the TGT-REQ message to the service running under *bob*’s
    account ❷.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The service accepts the TGT-REQ token, and the LSA packages *bob*’s cached TGT
    into a TGT-REP message to send back to the client ❸. (Note that the LSA simply
    takes the caller’s cached TGT; it doesn’t seem to pay any attention to the UPN
    in the TGT-REQ. Therefore, the TGT returned might not be for the user requested,
    which will be important in the next step.)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Upon receipt of the TGT-REP, the LSA can package the TGT for *alice* and the
    TGT for *bob* into a TGS-REQ, then request a service ticket for <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp>
    ❹. The TGS can then decrypt the TGTs, verify that the extra TGT is for the requested
    user account, and generate a service ticket encrypted with the TGT session key
    for *bob*. If the extra TGT is not for *bob*, perhaps because the service was
    not running under *bob*’s account, the request will fail.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the request succeeds, the client’s LSASS can package up the service
    ticket into an AP-REQ message to send to the service and complete the authentication
    ❺. Let’s run a test to see U2U authentication in operation ([Listing 14-27](chapter14.xhtml#Lis14-27)).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 14-27: Initializing the U2U authentication client'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: First, we initialize the U2U client authentication context; note this should
    be running as the *alice* user. You should be familiar with most of this code
    by now; the only important difference is specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp>
    as the target SPN ❶. When we format the authentication token, we see a TGT-REQ
    message containing the desired principal ❷. We now need the server authentication
    context to continue the authentication process ([Listing 14-28](chapter14.xhtml#Lis14-28)).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 14-28: Creating the server authentication context and getting the TGT-REP'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: We first create the credentials handle and read the credentials for *bob* from
    the shell. It’s necessary to specify credentials for *bob* because otherwise the
    server authentication would use *alice*’s TGT, which would fail when creating
    the service ticket for the <samp class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp>
    SPN. With the credentials handle, we can create the server authentication context.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: By formatting the returned authentication token, we can see it’s a TGT-REP with
    the TGT ticket ❶. We don’t know the *krbtgt* user’s password, so we can’t decrypt
    it, meaning there’s no way of knowing whether the ticket is for *bob* or not.
    In [Listing 14-29](chapter14.xhtml#Lis14-29), we update the client authentication
    context with the TGT-REP message and print the new authentication token.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 14-29: Continuing the U2U authentication'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we now have our AP-REQ message to send to the server ❶. It contains
    a ticket encrypted with *bob*’s session key ❷, and the target principal is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bob@mineral.local</samp> ❸. In [Listing
    14-30](chapter14.xhtml#Lis14-30), we’re back on the server side.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 14-30: Completing U2U authentication'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: We complete the authentication ❶ and query the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object, which indicates a successful logon for *alice* ❷.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s walk through some worked examples to demonstrate how you can use the various
    commands in this chapter to help with security research or systems analysis.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Querying the Kerberos
    Ticket Cache</samp>
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The LSA maintains a cache of tickets requested using Kerberos for each logon
    session. You can query the current user’s ticket cache using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosTicket</samp>
    command, as shown in [Listing 14-31](chapter14.xhtml#Lis14-31).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 14-31: Querying the Kerberos ticket cache'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: First, we query for the tickets ❶, selecting the fields <samp class="SANS_TheSansMonoCd_W5Regular_11">ServiceName</samp>
    (the ticket’s SPN) and <samp class="SANS_TheSansMonoCd_W5Regular_11">EndTime</samp>
    (the expiration time for the ticket, at which point it must be renewed). The first
    ticket in the cache is the user’s TGT, used for requesting service tickets ❷.
    In this example, we also have a service ticket for the LDAP directory server.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: We can view a cached Kerberos ticket using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-KerberosTicket</samp>
    command ❸, but the ticket is still encrypted, and as we probably don’t know the
    target service’s shared key we won’t be able to decrypt it. In theory, we could
    send the ticket to the destination service to authenticate to it directly. However,
    we don’t have the extracted session key needed to encrypt the authentication data
    in a valid AP-REQ either, so we’ll need to call the SSPI to generate the AP-REQ
    based on the cached ticket.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: If you have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled, however, each ticket cache entry should contain the session key. [Listing
    14-32](chapter14.xhtml#Lis14-32) shows how to query for all tickets for all local
    logon sessions and extract the cached session key.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 14-32: Extracting all tickets and session keys'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: We start by getting the list of logon sessions that can be passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-KerberosTicket</samp>.
    We need to have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled to query for the tickets of any logon session except the caller’s, so
    we impersonate the *SYSTEM* user while querying the cache.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Impersonating *SYSTEM* also allows us to get the session key. We can format
    the key as hex along with the SPN of the cached ticket. With both the ticket and
    the session key, we can implement our own authentication request to the service.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simple Kerberoasting</samp>
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One potential reason to interact with the ticket cache is to get a ticket for
    Kerberoasting, an attack described in the “Silver Tickets and Kerberoasting” box
    on page 465. However, you don’t need to query the cache for this attack, as you
    can find all the information you need using the SSPI APIs. Let’s walk through
    a simple example so that you can understand how the Kerberoasting process works.
    First, in [Listing 14-33](chapter14.xhtml#Lis14-33), we query for all user accounts
    with configured SPNs.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 14-33: Checking for users with configured SPNs'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: We see the *krbtgt* user, and that *alice* still has the <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/graphite</samp>
    SPN we configured earlier in the chapter. We also see an account for a SQL server
    that has the SPN <samp class="SANS_TheSansMonoCd_W5Regular_11">MSSQL/topaz.mineral.local</samp>.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want to pick *krbtgt* as a target, as this account will have a complex
    password that will be difficult to brute-force (any computer account with an SPN
    configured also has an automatically configured complex password). We’ll try to
    brute-force the password for the *sqlserver* user. First we need to make a request
    for its SPN and receive the ticket ([Listing 14-34](chapter14.xhtml#Lis14-34)).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 14-34: Getting a service ticket for the <samp class="SANS_Futura_Std_Book_11">sqlserver</samp>
    user'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the ticket, we can generate a key based on a list of passwords.
    We can then try to decrypt the ticket with each key until we find a key that works,
    as illustrated in [Listing 14-35](chapter14.xhtml#Lis14-35).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 14-35: Decrypting the ticket with a set of passwords'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: We can check if the ticket was decrypted by querying its <samp class="SANS_TheSansMonoCd_W5Regular_11">Decrypted</samp>
    property ❶. If it was decrypted, we then print the password to the console. In
    this case, we find that the password for the *sqlserver* user is <samp class="SANS_TheSansMonoCd_W5Regular_11">DBPassw0rd</samp>—
    probably not the most secure option! Note that this example script isn’t very
    efficient or fast. It’s made easier by the ticket being encrypted with the RC4
    encryption algorithm; you could apply the same technique to AES, but the brute-forcing
    attempt will take longer, as AES key derivation is more complex.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: For better performance, you’re better off using another tool, such as Rubeus
    (*[https://<wbr>github<wbr>.com<wbr>/GhostPack<wbr>/Rubeus](https://github.com/GhostPack/Rubeus)*),
    originally developed by Will Schroeder at SpecterOps. This tool can get the ticket
    and use it to generate a hash that you can feed to a fast password-cracking tool
    such as John the Ripper (*[https://<wbr>www<wbr>.openwall<wbr>.com<wbr>/john<wbr>/](https://www.openwall.com/john/)*).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter contained an in-depth discussion of Kerberos, the protocol used
    for Windows domain authentication since Windows 2000\. We examined the key distribution
    center implemented on the Windows domain controller, which holds the list of keys
    associated with all users and computers on a network, and saw how Kerberos uses
    these keys (typically derived from the account password) to authenticate tickets,
    which can then authenticate to services on the network.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: To support complex authentication scenarios, Kerberos allows for the delegation
    of credentials. We discussed this topic at length, including both constrained
    and unconstrained delegation as well as the associated Service for User mechanisms.
    We finished the chapter with a description of user-to-user authentication, which
    allows for two users to authenticate to each other without needing to register
    an SPN with the domain.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The next (and final) chapter will describe some additional network authentication
    protocols as well as going into more depth on how the SSPI APIs are used.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
