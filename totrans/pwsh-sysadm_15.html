<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_173"/><span class="big">13</span><br/>WORKING WITH AWS</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">In the preceding chapter, you learned about using Microsoft Azure with PowerShell. Now let’s see what we can do with Amazon Web Services (AWS). In this chapter, you’ll go deep into using PowerShell with AWS. Once you’ve learned how to authenticate to AWS with PowerShell, you’ll</span> learn how to create an EC2 instance from scratch, deploy an Elastic Beanstalk (EBS) application, and create an Amazon Relational Database Service (Amazon RDS) Microsoft SQL Server database.</p>&#13;
<p class="indent">Like Azure, AWS is a juggernaut in the cloud world. Chances are high that if you’re in IT, you’ll be working with AWS in some way in your career. And as with Azure, there’s a handy PowerShell module for working with AWS: <span class="literal">AWSPowerShell</span>.</p>&#13;
<p class="indent">You can install <span class="literal">AWSPowerShell</span> from the PowerShell Gallery the same way you installed the <span class="literal">Az</span> module, by calling <span class="codestrong">Install-Module AWSPowerShell</span>. Once this module is downloaded and installed, you’re ready to go.</p>&#13;
<h3 class="h3" id="ch13lev1"><span epub:type="pagebreak" id="page_174"/>Prerequisites</h3>&#13;
<p class="noindent">I’m assuming you already have an AWS account and that you have access to the root user. You can sign up for an AWS free tier account at <em><a href="https://aws.amazon.com/free/">https://aws.amazon.com/free/</a></em>. You won’t need to do everything as root, but you will need it to create your first <em>identity and access management</em> <em>(IAM)</em> user. You’ll also need to have the <span class="literal">AWSPowerShell</span> module downloaded and installed, as noted earlier.</p>&#13;
<h3 class="h3" id="ch13lev2">AWS Authentication</h3>&#13;
<p class="noindent">In AWS, authentication is done using the IAM service, which handles authentication, authorization, accounting, and auditing in AWS. To authenticate to AWS, you must have an IAM user created under your subscription, and that user has to have access to the appropriate resources. The first step to working with AWS is creating an IAM user.</p>&#13;
<p class="indent">When an AWS account is created, a root user is automatically created, so you’ll use the root user to create your IAM user. <em>Technically</em>, you could use the root user to do anything in AWS, but that is highly discouraged.</p>&#13;
<h4 class="h4" id="ch13lev2sec1">Authenticating with the Root User</h4>&#13;
<p class="noindent">Let’s create the IAM user you’ll use throughout the rest of the chapter. First, however, you need to somehow authenticate it. Without another IAM user, the only way to do that is with the root user. Sadly, this means you have to abandon PowerShell for a moment. You’ll have to use the AWS Management Console’s GUI to get the root user’s access and secret keys.</p>&#13;
<p class="indent">Your first move is to log into your AWS account. Navigate to the right-hand corner of the screen and click the account drop-down menu, shown in <a href="ch13.xhtml#ch13fig1">Figure 13-1</a>.</p>&#13;
<div class="image"><img src="../images/13fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch13fig1"><em>Figure 13-1: My Security Credentials option</em></p>&#13;
<p class="indent">Click the <strong>My Security Credentials</strong> option. A screen will pop up, warning that messing with your security credentials isn’t a good idea; see <a href="ch13.xhtml#ch13fig2">Figure 13-2</a>. But you need to do it here to create an IAM user.</p>&#13;
<div class="image"><img src="../images/13fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch13fig2"><span epub:type="pagebreak" id="page_175"/><em>Figure 13-2: Authentication warning</em></p>&#13;
<p class="indent">Click <strong>Continue to Security Credentials</strong>, then click <strong>Access Keys</strong>. Clicking <strong>Create New Access Key</strong> should present a way to view your account’s access key ID and secret key. It should also give you an option to download a key file containing both. If you haven’t already, download the file and put it in a safe spot. For now, though, you need to copy the access key and secret key from this page and add them to your default profile in your PowerShell session.</p>&#13;
<p class="indent">Pass both of these keys to the <span class="literal">Set-AWSCredential</span> command, which saves them so they can be reused by the commands that’ll create an IAM user. Check out <a href="ch13.xhtml#ch13list1">Listing 13-1</a> for the full command.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Set-AWSCredential -AccessKey '</span><span class="codeitalicst1">access key</span><span class="codestrong1">' -SecretKey '</span><span class="codeitalicst1">secret key</span><span class="codestrong1">'</span></pre>&#13;
<p class="caption" id="ch13list1"><em>Listing 13-1: Setting AWS access keys</em></p>&#13;
<p class="indent">With that done, you’re ready to create an IAM user.</p>&#13;
<h4 class="h4" id="ch13lev2sec2">Creating an IAM User and Role</h4>&#13;
<p class="noindent">Now that you’re authenticated as the root user, you can create an IAM user. Use the <span class="literal">New-IAMUser</span> command, specifying the name of the IAM user you’d like to use (in this example, <span class="literal">Automator</span>). When you create the user, you should see output like that in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-IAMUser -UserName Automator</span>&#13;
&#13;
Arn                 : arn:aws:iam::013223035658:user/Automator&#13;
CreateDate          : 9/16/2019 5:01:24 PM&#13;
PasswordLastUsed    : 1/1/0001 12:00:00 AM&#13;
Path                : /&#13;
PermissionsBoundary :&#13;
UserId              : AIDAJU2WN5KIFOUMPDSR4&#13;
UserName            : Automator</pre>&#13;
<p class="caption" id="ch13list2"><em>Listing 13-2: Creating an IAM user</em></p>&#13;
<p class="indent">Notice the <span class="literal">Arn</span> property in Listing 13-2. You'll need this value coming up when you create the IAM role. </p>&#13;
<p class="indent">The next step is to give the user the appropriate permission. You do that by assigning this user a role that’s assigned a policy. AWS groups certain permissions in units called <em>roles</em>, which allow the administrator to more easily delegate permissions (a strategy known as <em>role-based access control</em>, or <em>RBAC</em>). The <em>policy</em> then determines what permissions a role has access to.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_176"/>You can create a role by using the <span class="literal">New-IAMRole</span> command, but first you need to create what AWS calls a <em>trust relationship policy document</em>: a string of text in JSON that defines the services that this user can access and the level at which they can access them.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list3">Listing 13-3</a> is an example of a trust relationship policy document. Important: Notice the <span class="codeitalic1">XXXXXX</span> on the Principal line. Be sure to replace the ARN of the IAM user you just created there.</p>&#13;
<pre>{&#13;
    "Version": "2012-10-17",&#13;
    "Statement": [&#13;
        {&#13;
            "Effect": "Allow",&#13;
            "Principal" : { "AWS": "arn:aws:iam::<span class="codeitalic1">XXXXXX</span>:user/Automator" },&#13;
            "Action": "sts:AssumeRole"&#13;
        }&#13;
    ]&#13;
}</pre>&#13;
<p class="caption" id="ch13list3"><em>Listing 13-3: Example trust policy document</em></p>&#13;
<p class="indent">This JSON changes the role itself (modifying its trust policy) to allow your <span class="literal">Automator</span> user to use it. It is giving the <span class="literal">AssumeRole</span> permission to your user. This is required to create the role. For more information about how to create a trust relationship policy document, refer to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_manage_modify.html"><em>https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_manage_modify.html</em></a>.</p>&#13;
<p class="indent">Assign this JSON string to a <span class="literal">$json</span> variable and then pass it as the value of the <span class="literal">AssumeRolePolicyDocument</span> parameter in <span class="literal">New-IamRole</span>, as shown in <a href="ch13.xhtml#ch13list4">Listing 13-4</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$json = '{</span>&#13;
&gt;&gt;<span class="codestrong1">     "Version": "2012-10-17",</span>&#13;
&gt;&gt;<span class="codestrong1">     "Statement": [</span>&#13;
&gt;&gt;<span class="codestrong1">         {</span>&#13;
&gt;&gt;<span class="codestrong1">             "Effect": "Allow",</span>&#13;
&gt;&gt;<span class="codestrong1">             "Principal" : { "AWS": "arn:aws:iam::<span class="codeitalic1">XXXXXX</span>:user/Automator" },</span>&#13;
&gt;&gt;<span class="codestrong1">             "Action": "sts:AssumeRole"</span>&#13;
&gt;&gt;<span class="codestrong1">         }</span>&#13;
&gt;&gt;<span class="codestrong1">     ]</span>&#13;
&gt;&gt;<span class="codestrong1"> }</span>'&#13;
PS&gt; <span class="codestrong1">New-IAMRole -AssumeRolePolicyDocument $json -RoleName 'AllAccess'</span>&#13;
&#13;
Path             RoleName                         RoleId                   CreateDate          &#13;
----             --------                         ------                   ----------          &#13;
/                AllAccess                        <span class="codeitalic1">&lt;Your Specific Role ID&gt;</span>  <span class="codeitalic1">&lt;Date created&gt;</span></pre>&#13;
<p class="caption" id="ch13list4"><em>Listing 13-4: Creating a new IAM role</em></p>&#13;
<p class="indent">Now that the IAM role is created, you need to give it permission to access the various resources you’ll be working with. Rather than spend the next 12 dozen pages detailing AWS IAM roles and security, let’s do something simple and give the <span class="literal">Automator</span> full access to everything (effectively making it a root user).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_177"/>Note that in practice, you should <em>not</em> do this. It’s always best to limit access to only those necessary. Check out the AWS IAM Best Practices guide (<em><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html">https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html</a></em>) for more information. But for now, let’s assign this user the <span class="literal">AdministratorAccess</span> managed policy by using the <span class="literal">Register-IAMUserPolicy</span> command. You’ll need the Amazon Resource Name (ARN) of the policy. To do that, you can use the <span class="literal">Get-IAMPolicies</span> command and filter by policy name, storing that name in a variable, and passing the variable into <span class="literal">Register-IAMUserPolicy</span> (all of which you can see in <a href="ch13.xhtml#ch13list5">Listing 13-5</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$policyArn = (Get-IAMPolicies | where {$_.PolicyName -eq 'AdministratorAccess'}).Arn</span>&#13;
PS&gt; <span class="codestrong1">Register-IAMUserPolicy -PolicyArn $policyArn -UserName Automator</span></pre>&#13;
<p class="caption" id="ch13list5"><em>Listing 13-5: Attaching a policy to the user</em></p>&#13;
<p class="indent">The last thing you need to do is generate an access key that will let you authenticate your user. Do this with the <span class="literal">New-IAMAcessKey</span> command, as shown in <a href="ch13.xhtml#ch13list6">Listing 13-6</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$key = New-IAMAccessKey -UserName Automator</span>&#13;
PS&gt; <span class="codestrong1">$key</span>&#13;
&#13;
AccessKeyId     : XXXXXXXX&#13;
CreateDate      : 9/16/2019 6:17:40 PM&#13;
SecretAccessKey : XXXXXXXXX&#13;
Status          : Active&#13;
UserName        : Automator</pre>&#13;
<p class="caption" id="ch13list6"><em>Listing 13-6: Creating an IAM access key</em></p>&#13;
<p class="indent">Your new IAM user is all set up. Now let’s authenticate it.</p>&#13;
<h4 class="h4" id="ch13lev2sec3">Authenticating Your IAM User</h4>&#13;
<p class="noindent">In an earlier section, you authenticated with the root user—this was a temporary measure. You need to authenticate your IAM user so you can actually get some work done! You need to authenticate your IAM user before you can do just about anything in AWS. You’ll again use the <span class="literal">Set-AWSCredential</span> command to update your profile with your new access and secret keys. Change the command a bit, though, by using the <span class="literal">StoreAs</span> parameter, as shown in <a href="ch13.xhtml#ch13list7">Listing 13-7</a>. Because you’ll be using this IAM user throughout the rest of the session, you’ll store the access and secret key in the AWS default profile so you don’t have to run this command again for every session.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Set-AWSCredential -AccessKey $key.AccessKeyId -SecretKey</span> &#13;
<span class="codestrong1">$key.SecretAccessKey -StoreAs 'Default'</span></pre>&#13;
<p class="caption" id="ch13list7"><em>Listing 13-7: Setting default AWS access keys</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_178"/>The final command to run is <span class="codestrong">Initialize-AWSDefaultConfiguration -Region '</span><span class="codeitalicst">your region here</span><span class="codestrong">'</span>, which prevents having to specify the region every time you call a command. This is a one-time step. You can find all regions by running <span class="literal">Get-AWSRegion</span> to find the closest region to you.</p>&#13;
<p class="indent">That’s it! You now have an authenticated session in AWS and can move on to working with AWS services. To confirm, run <span class="literal">Get-AWSCredentials</span> with the <span class="literal">ListProfileDetail</span> parameter to look for all saved credentials. If all is well, you will see the default profile show up:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-AWSCredentials -ListProfileDetail</span>&#13;
ProfileName StoreTypeName         ProfileLocation&#13;
----------- -------------         ---------------&#13;
Default     NetSDKCredentialsFile</pre>&#13;
<h3 class="h3" id="ch13lev3">Creating an AWS EC2 Instance</h3>&#13;
<p class="noindent">In <a href="ch12.xhtml#ch12">Chapter 12</a>, you created an Azure virtual machine. Here, you’ll do something similar by creating an <em>AWS EC2 instance</em>. An AWS EC2 instance offers the same learning opportunity that an Azure virtual machine does; creating VMs is an extremely common occurrence, whether you’re using Azure or AWS. However, to create a VM in AWS, you need to approach provisioning in a different way than with Azure. Here, the underlying APIs are different, meaning the commands you run will be different, but in a nutshell, you’ll be performing essentially the same task: creating a virtual machine. It doesn’t help that AWS has its own lingo! I’ve tried to mirror the steps we took to create the VM in the preceding chapter, but of course, because of the architectural and syntactic differences between Azure and AWS, you will see some noticeable differences.</p>&#13;
<p class="indent">Luckily, just as with Azure, you have a module called <span class="literal">AWSPowerShell</span> that makes it easier to write everything from scratch. Just as you did in the preceding chapter, you’ll build from the ground up: setting up all the dependencies you need and then creating the EC2 instance.</p>&#13;
<h4 class="h4" id="ch13lev3sec4">The Virtual Private Cloud</h4>&#13;
<p class="noindent">The first dependency you need is a network. You can use an existing network or build your own. Because this book is hands-on, you’ll build your own network from scratch. In Azure, you did this with a vNet, but in AWS, you’ll work with <em>virtual private clouds (VPCs)</em>, which are a network fabric that allows the virtual machine to connect with the rest of the cloud. To replicate the same settings an Azure vNet might have, you’ll simply create a VPC with a single subnet set to its most basic level. Because there is such a wide range of configuration options to choose from, I decided it’s best to mirror our Azure network configuration as closely as possible.</p>&#13;
<p class="indent">Before you get started, you need to know the subnet you’d like to create. Let’s use 10.10.0.0/24 as our example network. You’ll store that information and a variable, and use the <span class="literal">New-EC2Vpc</span> command, as shown in <a href="ch13.xhtml#ch13list8">Listing 13-8</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_179"/>PS&gt; <span class="codestrong1">$network = '10.0.0.0/16'</span>&#13;
PS&gt; <span class="codestrong1">$vpc = New-EC2Vpc -CidrBlock $network</span>&#13;
PS&gt; <span class="codestrong1">$vpc</span>&#13;
&#13;
CidrBlock                   : 10.0.0.0/24&#13;
CidrBlockAssociationSet     : {vpc-cidr-assoc-03f1edbc052e8c207}&#13;
DhcpOptionsId               : dopt-3c9c3047&#13;
InstanceTenancy             : default&#13;
Ipv6CidrBlockAssociationSet : {}&#13;
IsDefault                   : False&#13;
State                       : pending&#13;
Tags                        : {}&#13;
VpcId                       : vpc-03e8c773094d52eb3</pre>&#13;
<p class="caption" id="ch13list8"><em>Listing 13-8: Creating an AWS VPC</em></p>&#13;
<p class="indent">Once you create the VPC, you have to manually enable DNS support (Azure did this for you automatically). Manually enabling DNS support should point the servers attached to this VPC to an internal Amazon DNS server. Likewise, you need to manually give a public hostname (another thing Azure took care of for you). To do this, you need to enable DNS hostnames. Do both of these by using the code in <a href="ch13.xhtml#ch13list9">Listing 13-9</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Edit-EC2VpcAttribute -VpcId $vpc.VpcId -EnableDnsSupport $true</span>&#13;
PS&gt; <span class="codestrong1">Edit-EC2VpcAttribute -VpcId $vpc.VpcId -EnableDnsHostnames $true</span></pre>&#13;
<p class="caption" id="ch13list9"><em>Listing 13-9: Enabling VPC DNS support and hostnames</em></p>&#13;
<p class="indent">Notice that you use the <span class="literal">Edit-EC2VpcAttribute</span> command for both. As its name suggests, this command lets you edit several of your EC2 VPC’s attributes.</p>&#13;
<h4 class="h4" id="ch13lev3sec5">The Internet Gateway</h4>&#13;
<p class="noindent">The next step is creating an internet gateway. This allows your EC2 instance to route traffic to and from the internet. Again, you need to do this manually, here using the <span class="literal">New-EC2InternetGateway</span> command (<a href="ch13.xhtml#ch13list10">Listing 13-10</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$gw = New-EC2InternetGateway</span>&#13;
PS&gt; <span class="codestrong1">$gw</span>&#13;
&#13;
Attachments InternetGatewayId     Tags&#13;
----------- -----------------     ----&#13;
{}          igw-05ca5aaa3459119b1 {}</pre>&#13;
<p class="caption" id="ch13list10"><em>Listing 13-10: Creating an internet gateway</em></p>&#13;
<p class="indent">Once the gateway is created, you have to attach it to your VPC by using the <span class="literal">Add-EC2InternetGateway</span> command, as shown in <a href="ch13.xhtml#ch13list11">Listing 13-11</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Add-EC2InternetGateway -InternetGatewayId $gw.InternetGatewayId -VpcId $vpc.VpcId</span></pre>&#13;
<p class="caption" id="ch13list11"><em>Listing 13-11: Attaching a VPC to an internet gateway</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_180"/>With the VPC out of the way, let’s take the next step and add a route to your network.</p>&#13;
<h4 class="h4" id="ch13lev3sec6">Routes</h4>&#13;
<p class="noindent">With the gateway created, you now need to create a route table and a route so that the EC2 instances on your VPC can access the internet. A <em>route</em> is a path that network traffic takes to find the destination. A <em>route table</em> is a, well, table of routes. Your route needs to go in a table, so you’ll create the route table first. Use the <span class="literal">New-EC2RouteTable</span> command, passing in your VPC ID (<a href="ch13.xhtml#ch13list12">Listing 13-12</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$rt = New-EC2RouteTable -VpcId $vpc.VpcId</span>&#13;
PS&gt; <span class="codestrong1">$rt</span>&#13;
&#13;
Associations    : {}&#13;
PropagatingVgws : {}&#13;
Routes          : {}&#13;
RouteTableId    : rtb-09786c17af32005d8&#13;
Tags            : {}&#13;
VpcId           : vpc-03e8c773094d52eb3</pre>&#13;
<p class="caption" id="ch13list12"><em>Listing 13-12: Creating a route table</em></p>&#13;
<p class="indent">Inside the route table, you create a route that points to the gateway you just created. You’re creating a <em>default route</em>, or <em>default gateway</em>, meaning a route that outgoing network traffic will take if a more specific route isn’t defined. You’ll route all traffic (0.0.0.0/0) through your internet gateway. Use the <span class="literal">New-EC2Route</span> command, which will return <span class="literal">True</span> if successful, as shown in <a href="ch13.xhtml#ch13list13">Listing 13-13</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-EC2Route -RouteTableId $rt.RouteTableId -GatewayId</span> &#13;
<span class="codestrong1">$gw.InternetGatewayId -DestinationCidrBlock '0.0.0.0/0'</span>&#13;
&#13;
True</pre>&#13;
<p class="caption" id="ch13list13"><em>Listing 13-13: Creating a route</em></p>&#13;
<p class="indent">As you can see, your route should be successfully created!</p>&#13;
<h4 class="h4" id="ch13lev3sec7">Subnet</h4>&#13;
<p class="noindent">Next, you have to create a subnet inside your larger VPC and associate it with your route table. Remember that a subnet defines the logical network that your EC2 instance’s network adapter will be a part of. To create one, you use the <span class="literal">New-EC2Subnet</span> command, and then use the <span class="literal">Register-EC2RouteTable</span> command to register the subnet to the route table you built earlier. First, though, you need to define an <em>availability zone</em> (where AWS datacenters will be hosting your subnet) for the subnet. If you’re not sure which availability zone you want to use, you can use the <span class="literal">Get-EC2AvailabilityZone</span> command to enumerate all of them. <a href="ch13.xhtml#ch13list14">Listing 13-14</a> shows what should happen if you do.</p>&#13;
<pre><span epub:type="pagebreak" id="page_181"/>PS&gt; <span class="codestrong1">Get-EC2AvailabilityZone</span>&#13;
&#13;
Messages RegionName State     ZoneName&#13;
-------- ---------- -----     --------&#13;
{}       us-east-1  available us-east-1a&#13;
{}       us-east-1  available us-east-1b&#13;
{}       us-east-1  available us-east-1c&#13;
{}       us-east-1  available us-east-1d&#13;
{}       us-east-1  available us-east-1e&#13;
{}       us-east-1  available us-east-1f</pre>&#13;
<p class="caption" id="ch13list14"><em>Listing 13-14: Enumerating EC2 availability zones</em></p>&#13;
<p class="indent">If it’s all the same to you, let’s use the <span class="literal">us-east-1d</span> availability zone. <a href="ch13.xhtml#ch13list15">Listing 13-15</a> shows the code to create the subnet, using the <span class="literal">New-EC2Subnet</span> command, which takes the VPC ID you created earlier, a CIDR block (subnet), and finally that availability zone you found as well as the code to register the table (using the <span class="literal">Register-EC2RouteTable</span> command).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$sn = New-EC2Subnet -VpcId $vpc.VpcId -CidrBlock '10.0.1.0/24' -AvailabilityZone 'us-east-1d'</span>&#13;
PS&gt; <span class="codestrong1">Register-EC2RouteTable -RouteTableId $rt.RouteTableId -SubnetId $sn.SubnetId</span>&#13;
rtbassoc-06a8b5154bc8f2d98</pre>&#13;
<p class="caption" id="ch13list15"><em>Listing 13-15: Creating and registering a subnet</em></p>&#13;
<p class="indent">Now that you have the subnet created and registered, you’re all done with the network stack!</p>&#13;
<h4 class="h4" id="ch13lev3sec8">Assigning an AMI to Your EC2 Instance</h4>&#13;
<p class="noindent">After building the network stack, you have to assign an Amazon Machine Image (AMI) to your VM. An <em>AMI</em>, which is a “snapshot” of a disk, is used as a template to prevent having to install the operating system on EC2 instances from scratch. You need to find an existing AMI that suits your needs: you need an AMI that can support a Windows Server 2016 instance, so first you need to find the name of that instance. Enumerate all of the available instances with the <span class="codestrong">Get-EC2ImageByName</span> command, and you should see an image called <span class="literal">WINDOWS_2016_BASE</span>. Perfect.</p>&#13;
<p class="indent">Now that you know the image name, use <span class="literal">Get-EC2ImageByName</span> again, and this time, specify the image you’d like to use. Doing so will tell the command to return the image object you need, as you can see in <a href="ch13.xhtml#ch13list16">Listing 13-16</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$ami = Get-EC2ImageByName -Name 'WINDOWS_2016_BASE'</span>&#13;
PS&gt; <span class="codestrong1">$ami</span>&#13;
&#13;
Architecture        : x86_64&#13;
BlockDeviceMappings : {/dev/sda1, xvdca, xvdcb, xvdcc...}&#13;
CreationDate        : 2019-08-15T02:27:20.000Z&#13;
Description         : Microsoft Windows Server 2016...&#13;
EnaSupport          : True&#13;
Hypervisor          : xen&#13;
ImageId             : ami-0b7b74ba8473ec232&#13;
<span epub:type="pagebreak" id="page_182"/>ImageLocation       : amazon/Windows_Server-2016-English-Full-Base-2019.08.15&#13;
ImageOwnerAlias     : amazon&#13;
ImageType           : machine&#13;
KernelId            :&#13;
Name                : Windows_Server-2016-English-Full-Base-2019.08.15&#13;
OwnerId             : 801119661308&#13;
Platform            : Windows&#13;
ProductCodes        : {}&#13;
Public              : True&#13;
RamdiskId           :&#13;
RootDeviceName      : /dev/sda1&#13;
RootDeviceType      : ebs&#13;
SriovNetSupport     : simple&#13;
State               : available&#13;
StateReason         :&#13;
Tags                : {}&#13;
VirtualizationType  : hvm</pre>&#13;
<p class="caption" id="ch13list16"><em>Listing 13-16: Finding the AMI</em></p>&#13;
<p class="indent">Your image is stored and ready to go. Finally, you can create your EC2 instance. All you need is the instance type; unfortunately, you can’t get a list of them with a PowerShell cmdlet, but you can find them at <a href="https://aws.amazon.com/ec2/instance-types/"><em>https://aws.amazon.com/ec2/instance-types/</em></a>. Let’s use the free one: <span class="literal">t2.micro</span>. Load up your parameters—the image ID, whether you want to associate with a public IP, the instance type, and subnet ID—and run the <span class="literal">New-EC2Instance</span> command (<a href="ch13.xhtml#ch13list17">Listing 13-17</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$params = @{</span>&#13;
&gt;&gt;<span class="codestrong1">      ImageId = $ami.ImageId</span>&#13;
&gt;&gt;<span class="codestrong1">      AssociatePublicIp = $false</span>&#13;
&gt;&gt;<span class="codestrong1">      InstanceType = 't2.micro'</span>&#13;
&gt;&gt;<span class="codestrong1">      SubnetId = $sn.SubnetId</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">New-EC2Instance @params</span>&#13;
&#13;
GroupNames    : {}&#13;
Groups        : {}&#13;
Instances     : {}&#13;
OwnerId       : 013223035658&#13;
RequesterId   :&#13;
ReservationId : r-05aa0d9b0fdf2df4f</pre>&#13;
<p class="caption" id="ch13list17"><em>Listing 13-17: Creating an EC2 instance</em></p>&#13;
<p class="indent">It’s done! You should see a brand-new EC2 instance in your AWS Management Console, or you can use the <span class="literal">Get-EC2Instance</span> command to return your newly created instance.</p>&#13;
<h4 class="h4" id="ch13lev3sec9">Wrapping Up</h4>&#13;
<p class="noindent">You nailed down the code to create the EC2 instance, but, as is, the code is cumbersome to use. Let’s make this code easier to use over and over again. <span epub:type="pagebreak" id="page_183"/>Chances are, creating an EC2 instance will be a frequent occurrence, so you’ll create a custom function to avoid doing everything one step at a time. At a high level, this function works the same way as the one you created in <a href="ch12.xhtml#ch12">Chapter 12</a> in Azure; I won’t go through the specifics of the function here, but the script can be found in the book’s resources, and I highly recommend you try to build the function on your own.</p>&#13;
<p class="indent">When the script is called and all dependencies already exist <em>except</em> for the EC2 instance itself, you’ll see output similar to <a href="ch13.xhtml#ch13list18">Listing 13-18</a> when you run it with the <span class="literal">Verbose</span> parameter.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$parameters = @{</span>&#13;
&gt;&gt;<span class="codestrong1">      VpcCidrBlock = '10.0.0.0/16'</span>&#13;
&gt;&gt;<span class="codestrong1">      EnableDnsSupport = $true</span>&#13;
&gt;&gt;<span class="codestrong1">      SubnetCidrBlock = '10.0.1.0/24'</span>&#13;
&gt;&gt;<span class="codestrong1">      OperatingSystem = 'Windows Server 2016'</span>&#13;
&gt;&gt;<span class="codestrong1">      SubnetAvailabilityZone = 'us-east-1d'</span>&#13;
&gt;&gt;<span class="codestrong1">      InstanceType = 't2.micro'</span>&#13;
&gt;&gt;<span class="codestrong1">      Verbose = $true</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">New-CustomEC2Instance @parameters</span>&#13;
&#13;
VERBOSE: Invoking Amazon Elastic Compute Cloud operation 'DescribeVpcs' in region 'us-east-1'&#13;
VERBOSE: A VPC with the CIDR block [10.0.0.0/16] has already been created.&#13;
VERBOSE: Enabling DNS support on VPC ID [vpc-03ba701f5633fcfac]...&#13;
VERBOSE: Invoking Amazon EC2 operation 'ModifyVpcAttribute' in region 'us-east-1'&#13;
VERBOSE: Invoking Amazon EC2 operation 'ModifyVpcAttribute' in region 'us-east-1'&#13;
VERBOSE: Invoking Amazon Elastic Compute Cloud operation 'DescribeInternetGateways' in region &#13;
         'us-east-1'&#13;
VERBOSE: An internet gateway is already attached to VPC ID [vpc-03ba701f5633fcfac].&#13;
VERBOSE: Invoking Amazon Elastic Compute Cloud operation 'DescribeRouteTables' in region &#13;
         'us-east-1'&#13;
VERBOSE: Route table already exists for VPC ID [vpc-03ba701f5633fcfac].&#13;
VERBOSE: A default route has already been created for route table ID [rtb-0b4aa3a0e1801311f &#13;
         rtb-0aed41cac6175a94d].&#13;
VERBOSE: Invoking Amazon Elastic Compute Cloud operation 'DescribeSubnets' in region 'us-east-1'&#13;
VERBOSE: A subnet has already been created and registered with VPC ID [vpc-03ba701f5633fcfac].&#13;
VERBOSE: Invoking Amazon EC2 operation 'DescribeImages' in region 'us-east-1'&#13;
VERBOSE: Creating EC2 instance...&#13;
VERBOSE: Invoking Amazon EC2 operation 'RunInstances' in region 'us-east-1'&#13;
&#13;
GroupNames    : {}&#13;
Groups        : {}&#13;
Instances     : {}&#13;
OwnerId       : 013223035658&#13;
RequesterId   :&#13;
ReservationId : r-0bc2437cfbde8e92a</pre>&#13;
<p class="caption" id="ch13list18"><em>Listing 13-18: Running the custom EC2 instance creation function</em></p>&#13;
<p class="indent">You now have the tools you need to automate the boring task of creating EC2 instances in AWS!</p>&#13;
<h3 class="h3" id="ch13lev4"><span epub:type="pagebreak" id="page_184"/>Deploying an Elastic Beanstalk Application</h3>&#13;
<p class="noindent">Much like Microsoft Azure’s Web App service, AWS has a web app service of its own. <em>Elastic Beanstalk (EB)</em> is a service that allows you to upload web packages to be hosted on the AWS infrastructure. In this section, you’ll see what it takes to create an EB application and then deploy a package to one. This process requires five steps:</p>&#13;
<ol>&#13;
<li><p class="noindent">Create the application.</p></li>&#13;
<li><p class="noindent">Create the environment.</p></li>&#13;
<li><p class="noindent">Upload the package to make it available to the application.</p></li>&#13;
<li><p class="noindent">Create a new version of the application.</p></li>&#13;
<li><p class="noindent">Deploy the new version to the environment.</p></li>&#13;
</ol>&#13;
<p class="indent">Let’s start by creating a new application.</p>&#13;
<h4 class="h4" id="ch13lev4sec10">Creating the Application</h4>&#13;
<p class="noindent">To create a new application, use the <span class="literal">New-EBApplication</span> command, which provides the application’s name. Let’s call it <span class="literal">AutomateWorkflow</span>. Run the command, and you should see something like <a href="ch13.xhtml#ch13list19">Listing 13-19</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$ebApp = New-EBApplication -ApplicationName 'AutomateWorkflow'</span>&#13;
PS&gt; <span class="codestrong1">$ebApp</span>&#13;
&#13;
ApplicationName         : AutomateWorkflow&#13;
ConfigurationTemplates  : {}&#13;
DateCreated             : 9/19/2019 11:43:56 AM&#13;
DateUpdated             : 9/19/2019 11:43:56 AM&#13;
Description             :&#13;
ResourceLifecycleConfig : Amazon.ElasticBeanstalk.Model&#13;
                          .ApplicationResourceLifecycleConfig&#13;
Versions                : {}</pre>&#13;
<p class="caption" id="ch13list19"><em>Listing 13-19: Creating a new Elastic Beanstalk application</em></p>&#13;
<p class="indent">The next step is creating the <em>environment</em>, which is the infrastructure the application will be hosted on. The command to create a new environment is <span class="literal">New-EBEnvironment</span>. Unfortunately, creating the environment isn’t quite as straightforward as creating the application. A couple of the parameters, such as the application name and name of the environment, are up to you, but you need to know the <span class="literal">SolutionStackName</span>, <span class="literal">Tier_Type</span>, and <span class="literal">Tier_Name</span>. Let’s look at these a little more closely.</p>&#13;
<p class="indent">You use the <span class="literal">SolutionStackName</span> to specify the operating system and IIS version you’d like your app to run under. For a list of available solution stacks, run the <span class="literal">Get-EBAvailableSolutionStackList</span> command and inspect the <span class="literal">SolutionStackDetails</span> property, as shown in <a href="ch13.xhtml#ch13list20">Listing 13-20</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_185"/>PS&gt; <span class="codestrong1">(Get-EBAvailableSolutionStackList).SolutionStackDetails</span>&#13;
&#13;
PermittedFileTypes SolutionStackName&#13;
------------------ -----------------&#13;
{zip}              64bit Windows Server Core 2016 v1.2.0 running IIS 10.0&#13;
{zip}              64bit Windows Server 2016 v1.2.0 running IIS 10.0&#13;
{zip}              64bit Windows Server Core 2012 R2 v1.2.0 running IIS 8.5&#13;
{zip}              64bit Windows Server 2012 R2 v1.2.0 running IIS 8.5&#13;
{zip}              64bit Windows Server 2012 v1.2.0 running IIS 8&#13;
{zip}              64bit Windows Server 2008 R2 v1.2.0 running IIS 7.5&#13;
{zip}              64bit Amazon Linux 2018.03 v2.12.2 runni...&#13;
{jar, zip}         64bit Amazon Linux 2018.03 v2.7.4 running Java 8&#13;
{jar, zip}         64bit Amazon Linux 2018.03 v2.7.4 running Java 7&#13;
{zip}              64bit Amazon Linux 2018.03 v4.5.3 running Node.js&#13;
{zip}              64bit Amazon Linux 2015.09 v2.0.8 running Node.js&#13;
{zip}              64bit Amazon Linux 2015.03 v1.4.6 running Node.js&#13;
{zip}              64bit Amazon Linux 2014.03 v1.1.0 running Node.js&#13;
{zip}              32bit Amazon Linux 2014.03 v1.1.0 running Node.js&#13;
{zip}              64bit Amazon Linux 2018.03 v2.8.1 running PHP 5.4&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch13list20"><em>Listing 13-20: Finding available solution stacks</em></p>&#13;
<p class="indent">As you can see, you have a lot of options. For this example, choose 64-bit Windows Server Core 2012 R2 running IIS 8.5.</p>&#13;
<p class="indent">Now let’s look at the <span class="literal">Tier_Type</span>. The <span class="literal">Tier_Type</span> specifies the kind of environment your web service will be running under. The <span class="literal">Standard</span> type is required if you’ll be using this environment to host a website.</p>&#13;
<p class="indent">And finally, for the <span class="literal">Tier_Name</span> parameter, you have the options of <span class="literal">WebServer</span> and <span class="literal">Worker</span>. Choose <span class="literal">WebServer</span> here because you’d like to host a website (<span class="literal">Worker</span> would be required if you were creating an API).</p>&#13;
<p class="indent">Now that your parameters are all figured out, let’s run <span class="literal">New-EBEnvironment</span>. <a href="ch13.xhtml#ch13list21">Listing 13-21</a> shows the command and the output.</p>&#13;
<pre>PS&gt; $instanceProfileOptionSetting = New-Object Amazon.ElasticBeanstalk.Model.&#13;
ConfigurationOptionSetting -ArgumentList aws:autoscaling:launchconfiguration,&#13;
IamInstanceProfile,'aws-elasticbeanstalk-ec2-role'&#13;
&#13;
&gt;&gt; $parameters = @{&#13;
&gt;&gt;      <span class="codestrong1">ApplicationName = 'AutomateWorkflow'</span>&#13;
&gt;&gt;      <span class="codestrong1">EnvironmentName = 'Testing'</span>&#13;
&gt;&gt;<span class="codestrong1">      SolutionStackName = '64bit Windows Server Core 2019 v2.5.9 running IIS 10.0'</span>&#13;
&gt;&gt;      <span class="codestrong1">Tier_Type = 'Standard'</span>&#13;
&gt;&gt;      <span class="codestrong1">Tier_Name = 'WebServer'</span>&#13;
&gt;&gt;      OptionSetting = $instanceProfileOptionSetting&#13;
&gt;&gt; }&#13;
PS&gt; <span class="codestrong1">New-EBEnvironment @parameters</span>&#13;
&#13;
AbortableOperationInProgress : False&#13;
ApplicationName              : AutomateWorkflow&#13;
CNAME                        :&#13;
DateCreated                  : 10/3/2020 9:31:49 AM&#13;
DateUpdated                  : 10/3/2020 9:31:49 AM&#13;
Description                  :&#13;
EndpointURL                  :&#13;
EnvironmentArn               : arn:aws:elasticbeanstalk:us-east-1:054715970076:environment/AutomateWorkflow/Testing &#13;
EnvironmentId                :  e-f3pfgxhrzf&#13;
<span epub:type="pagebreak" id="page_186"/>EnvironmentLinks             : {}&#13;
EnvironmentName              : Testing&#13;
Health                       : Grey&#13;
HealthStatus                 :&#13;
OperationsRole               :&#13;
PlatformArn                  : arn:aws:elasticbeanstalk:us-east-1::platform/IIS 10.0 running on 64bit Windows Server Core &#13;
                               2019/2.5.9 &#13;
Resources                    :&#13;
SolutionStackName            : 64bit Windows Server Core 2019 v2.5.9 running IIS 10.0&#13;
Status                       : Launching&#13;
TemplateName                 :&#13;
Tier                         : Amazon.ElasticBeanstalk.Model.EnvironmentTier&#13;
VersionLabel                 :</pre>&#13;
<p class="caption" id="ch13list21"><em>Listing 13-21: Creating an Elastic Beanstalk application</em></p>&#13;
<p class="indent">You’ll notice that the status shows <span class="literal">Launching</span>. This means the app isn’t available yet, so you may have to wait a bit for the environment to come up. You can periodically check on the status of the app by running <span class="codestrong">Get-EBEnvironment -ApplicationName 'AutomateWorkflow' -EnvironmentName 'Testing'</span>. The environment may stay in a <span class="literal">Launching</span> state for a few minutes.</p>&#13;
<p class="indent">When you see the <span class="literal">Status</span> property turn to <span class="literal">Ready</span>, the environment is up, and it’s time to deploy a package to the site.</p>&#13;
<h4 class="h4" id="ch13lev4sec11">Deploying a Package</h4>&#13;
<p class="noindent">Let’s deploy. The package you’ll deploy should contain any files you want your website to host. You can put whatever you’d like in there—for our purposes, it doesn’t matter. All you have to make sure of is that it’s in a ZIP file. Use the <span class="literal">Compress-Archive</span> command to zip up whatever files you want to deploy:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Compress-Archive -Path 'C:\MyPackageFolder\*' -DestinationPath 'C:\package.zip'</span></pre>&#13;
<p class="indent">With your package nice and zipped up, you need to put it somewhere the application can find. You could put it in a couple of places, but for this example, you’ll put it in an Amazon S3 bucket, a common way to store data in AWS. But to put it in an Amazon S3 bucket, you first need an Amazon S3 bucket! Let’s make one in PowerShell. Go ahead and run <span class="codestrong">New-S3Bucket -BucketName 'automateworkflow'</span>.</p>&#13;
<p class="indent">With your S3 bucket up and waiting for contents, upload the ZIP file by using the <span class="literal">Write-S3Object</span> command, as shown in <a href="ch13.xhtml#ch13list22">Listing 13-22</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Write-S3Object -BucketName 'automateworkflow' -File 'C:\package.zip'</span></pre>&#13;
<p class="caption" id="ch13list22"><em>Listing 13-22: Uploading the package to S3</em></p>&#13;
<p class="indent">Now you have to point the application to the S3 key you just created and specify a version label for it. The version label can be anything, but typically, you use a unique number based on the time. So let’s use the number of ticks representing the current date and time. Once you have the version label, run <span class="literal">New-EBApplicationVersion</span> with a few more parameters, as shown in <a href="ch13.xhtml#ch13list23">Listing 13-23</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_187"/>PS&gt; <span class="codestrong1">$verLabel = [System.DateTime]::Now.Ticks.ToString()</span>&#13;
PS&gt; <span class="codestrong1">$newVerParams = @{</span>&#13;
&gt;&gt;      <span class="codestrong1">ApplicationName       = 'AutomateWorkflow'</span>&#13;
&gt;&gt;      <span class="codestrong1">VersionLabel          = $verLabel</span>&#13;
&gt;&gt;      <span class="codestrong1">SourceBundle_S3Bucket = 'automateworkflow'</span>&#13;
&gt;&gt;      <span class="codestrong1">SourceBundle_S3Key    = 'package.zip'</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">New-EBApplicationVersion @newVerParams</span>&#13;
&#13;
ApplicationName        : AutomateWorkflow&#13;
BuildArn               :&#13;
DateCreated            : 9/19/2019 12:35:21 PM&#13;
DateUpdated            : 9/19/2019 12:35:21 PM&#13;
Description            :&#13;
SourceBuildInformation :&#13;
SourceBundle           : Amazon.ElasticBeanstalk.Model.S3Location&#13;
Status                 : Unprocessed&#13;
VersionLabel           : 636729573206374337</pre>&#13;
<p class="caption" id="ch13list23"><em>Listing 13-23: Creating a new application version</em></p>&#13;
<p class="indent">Your application version has now been created! It’s time to deploy this version to your environment. Do that by using the <span class="literal">Update-EBEnvironment</span> command, as shown in <a href="ch13.xhtml#ch13list24">Listing 13-24</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Update-EBEnvironment -ApplicationName 'AutomateWorkflow'  -EnvironmentName</span> &#13;
<span class="codestrong1">'Testing' -VersionLabel $verLabel -Force</span>&#13;
&#13;
AbortableOperationInProgress : True&#13;
ApplicationName              : AutomateWorkflow&#13;
CNAME                        : Testing.3u2ukxj2ux.us-ea...&#13;
DateCreated                  : 9/19/2019 12:19:36 PM&#13;
DateUpdated                  : 9/19/2019 12:37:04 PM&#13;
Description                  :&#13;
EndpointURL                  : awseb-e-w-AWSEBL...&#13;
EnvironmentArn               : arn:aws:elasticbeanstalk... &#13;
EnvironmentId                : e-wkba2k4kcf&#13;
EnvironmentLinks             : {}&#13;
EnvironmentName              : Testing&#13;
Health                       : Grey&#13;
HealthStatus                 :&#13;
PlatformArn                  : arn:aws:elasticbeanstalk:... &#13;
Resources                    :&#13;
SolutionStackName            : 64bit Windows Server Core 2012 R2 running IIS 8.5&#13;
Status                       : <span class="ent">❶</span>Updating&#13;
TemplateName                 :&#13;
Tier                         : Amazon.ElasticBeanstalk.Model.EnvironmentTier&#13;
VersionLabel                 : 636729573206374337</pre>&#13;
<p class="caption" id="ch13list24"><em>Listing 13-24: Deploying the application to the EB environment</em></p>&#13;
<p class="indent">You can see that the status has gone from <span class="literal">Ready</span> to <span class="literal">Updating</span> <span class="ent">❶</span>. Again, you need to wait a bit until the status turns back to <span class="literal">Ready</span> as you can see in <a href="ch13.xhtml#ch13list25">Listing 13-25</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_188"/>PS&gt; <span class="codestrong1">Get-EBEnvironment -ApplicationName 'AutomateWorkflow'</span> &#13;
<span class="codestrong1">-EnvironmentName 'Testing'</span>&#13;
&#13;
AbortableOperationInProgress : False&#13;
ApplicationName              : AutomateWorkflow&#13;
CNAME                        : Testing.3u2ukxj2ux.us-e...&#13;
DateCreated                  : 9/19/2019 12:19:36 PM&#13;
DateUpdated                  : 9/19/2019 12:38:53 PM&#13;
Description                  :&#13;
EndpointURL                  : awseb-e-w-AWSEBL...&#13;
EnvironmentArn               : arn:aws:elasticbeanstalk... &#13;
EnvironmentId                : e-wkba2k4kcf&#13;
EnvironmentLinks             : {}&#13;
EnvironmentName              : Testing&#13;
Health                       : Green&#13;
HealthStatus                 :&#13;
PlatformArn                  : arn:aws:elasticbeanstalk:...&#13;
Resources                    :&#13;
SolutionStackName            : 64bit Windows Server Core 2012 R2 running IIS 8.5&#13;
Status                       : <span class="ent">❶</span>Ready&#13;
TemplateName                 :&#13;
Tier                         : Amazon.ElasticBeanstalk.Model.EnvironmentTier&#13;
VersionLabel                 :</pre>&#13;
<p class="caption" id="ch13list25"><em>Listing 13-25: Confirming the application is ready</em></p>&#13;
<p class="indent">As you check in, the status is <span class="literal">Ready</span> again <span class="ent">❶</span>. Everything looks good!</p>&#13;
<h3 class="h3" id="ch13lev5">Creating a SQL Server Database in AWS</h3>&#13;
<p class="noindent">As an AWS administrator, you may need to set up different types of relational databases. AWS provides the Amazon Relational Database Service (Amazon RDS), which allows for administrators to easily provision a few types of databases. There a few options, but for now, you’ll stick with SQL.</p>&#13;
<p class="indent">In this section, you’ll create a blank Microsoft SQL Server database in RDS. The main command you’ll use is <span class="literal">New-RDSDBInstance</span>. Like <span class="literal">New-AzureRmSqlDatabase</span>, <span class="literal">New-RDSDBInstance</span> has <em>a lot</em> of parameters, more than I can possibly cover in this section. If you’re curious about other ways to provision RDS instances, I encourage you to review the help contents for <span class="literal">New-RDSDBInstance</span>.</p>&#13;
<p class="indent">For our purposes, though, you need the following information:</p>&#13;
<ul>&#13;
<li><p class="noindent">The name of the instance</p></li>&#13;
<li><p class="noindent">The database engine (SQL Server, MariaDB, MySQL, and so on)</p></li>&#13;
<li><p class="noindent">The instance class that specifies the type of resources the SQL Server runs on</p></li>&#13;
<li><p class="noindent">The master username and password</p></li>&#13;
<li><p class="noindent">The size of the database (in GB)</p></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_189"/>A few of these things you can figure out easily: the name, username/password, and size. The others require further investigation.</p>&#13;
<p class="indent">Let’s start with the engine version. You can get a list of all available engines and their versions by using the <span class="literal">Get-RDSDBEngineVersion</span> command. When run with no parameters, this command returns a lot of information—too much for what you’re doing. You can use the <span class="literal">Group-Object</span> command to group all the objects by engine, which will provide a list of all engine versions grouped by the engine name. As you can see in <a href="ch13.xhtml#ch13list26">Listing 13-26</a>, you now have a more manageable output that shows all the available engines you can use.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-RDSDBEngineVersion | Group-Object -Property Engine</span>&#13;
&#13;
Count Name                      Group&#13;
----- ----                      -----&#13;
    1 aurora-mysql              {Amazon.RDS.Model.DBEngineVersion}&#13;
    1 aurora-mysql-pq           {Amazon.RDS.Model.DBEngineVersion}&#13;
    1 neptune                   {Amazon.RDS.Model.DBEngineVersion}&#13;
<span class="codeitalic1">--snip--</span>&#13;
   16 sqlserver-ee              {Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Mo...&#13;
&#13;
   17 sqlserver-ex              {Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Mo...&#13;
&#13;
   17 sqlserver-se              {Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Mo...&#13;
&#13;
   17 sqlserver-web             {Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Model.DBEngineVersion, &#13;
                                Amazon.RDS.Mo...&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch13list26"><em>Listing 13-26: Investigating RDS DB engine versions</em></p>&#13;
<p class="indent">You have four <span class="literal">sqlserver</span> entries, representing SQL Server Express, Web, Standard Edition, and Enterprise Edition. Since this is just an example, you’ll go with SQL Server Express; it’s a no-frills database engine and, most important, it’s free, which allows you to tune and tweak it if necessary. Select the SQL Server Express engine by using <span class="codestrong">sqlserver-ex</span>.</p>&#13;
<p class="indent">After picking an engine, you have to specify a version. By default, <span class="literal">New-RDSDBInstance</span> provisions the latest version (which you’ll be using), but you can specify a different version by using the <span class="literal">EngineVersion</span> parameter. To see all the available versions, you’ll run <span class="literal">Get-RDSDBEngineVersion</span> again, limit the search to <span class="literal">sqlserver-ex</span>, and return only the engine versions (<a href="ch13.xhtml#ch13list27">Listing 13-27</a>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_190"/>PS&gt; <span class="codestrong1">Get-RDSDBEngineVersion -Engine 'sqlserver-ex' |</span> &#13;
<span class="codestrong1">Format-Table -Property EngineVersion</span>&#13;
&#13;
EngineVersion&#13;
-------------&#13;
10.50.6000.34.v1&#13;
10.50.6529.0.v1&#13;
10.50.6560.0.v1&#13;
11.00.5058.0.v1&#13;
11.00.6020.0.v1&#13;
11.00.6594.0.v1&#13;
11.00.7462.6.v1&#13;
12.00.4422.0.v1&#13;
12.00.5000.0.v1&#13;
12.00.5546.0.v1&#13;
12.00.5571.0.v1&#13;
13.00.2164.0.v1&#13;
13.00.4422.0.v1&#13;
13.00.4451.0.v1&#13;
13.00.4466.4.v1&#13;
14.00.1000.169.v1&#13;
14.00.3015.40.v1</pre>&#13;
<p class="caption" id="ch13list27"><em>Listing 13-27: Finding SQL Server Express engine versions</em></p>&#13;
<p class="indent">The next parameter value you need to provide to <span class="literal">New-RDSDBInstance</span> is the instance class. The instance class represents the performance of the underlying infrastructure—memory, CPU, and so forth—that the database will be hosted on. Unfortunately, there’s no PowerShell command to easily find all available instance class options, but you can check out this link to get a full rundown: <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html"><em>https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide</em><em>/Concepts.DBInstanceClass.html</em></a>.</p>&#13;
<p class="indent">When selecting an instance class, it’s important to verify that it’s supported by the engine you chose. Here, you’ll use the <span class="literal">db2.t2.micro</span> instance class to create your RDS DB, but many of the other options will not work. For a full breakdown on which instance classes are supported under which RDS DB, refer to the AWS RDS FAQs (<em><a href="https://aws.amazon.com/rds/faqs/">https://aws.amazon.com/rds/faqs/</a></em>). If you choose an instance class that’s not supported by the engine you’re using, you’ll receive an error as in <a href="ch13.xhtml#ch13list28">Listing 13-28</a>.</p>&#13;
<pre>New-RDSDBInstance : RDS does not support creating a DB instance with the &#13;
following combination: DBInstanceClass=db.t1.micro, Engine=sqlserver-ex, &#13;
EngineVersion=14.00.3015.40.v1, LicenseModel=license-included. For supported &#13;
combinations of instance class and database engine version, see the &#13;
documentation.</pre>&#13;
<p class="caption" id="ch13list28"><em>Listing 13-28: Error when specifying an invalid instance configuration</em></p>&#13;
<p class="indent">Once you’ve selected a (supported) instance class, you have to decide on a username and password. Note that AWS will not accept any old password: you cannot have a slash, <span class="literal">@</span> sign, comma, or space in your password, or you will receive an error message like the one in <a href="ch13.xhtml#ch13list29">Listing 13-29</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_191"/>New-RDSDBInstance : The parameter MasterUserPassword is not a valid password. &#13;
Only printable ASCII characters besides '/', '@', '"', ' ' may be used.</pre>&#13;
<p class="caption" id="ch13list29"><em>Listing 13-29: Specifying an invalid password with <span class="literal">New-RDSDBInstance</span></em></p>&#13;
<p class="indent">With that, you have all the parameters needed to fire off <span class="literal">New-RDSDBInstance</span>! You can see the expected output in <a href="ch13.xhtml#ch13list30">Listing 13-30</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$parameters = @{</span>&#13;
&gt;&gt;      <span class="codestrong1">DBInstanceIdentifier = 'Automating'</span>&#13;
&gt;&gt;      <span class="codestrong1">Engine = 'sqlserver-ex'</span>&#13;
&gt;&gt;      <span class="codestrong1">DBInstanceClass = 'db.t2.micro'</span>&#13;
&gt;&gt;      <span class="codestrong1">MasterUsername = 'sa'</span>&#13;
&gt;&gt;      <span class="codestrong1">MasterUserPassword = 'password'</span>&#13;
&gt;&gt;      <span class="codestrong1">AllocatedStorage = 20</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">New-RDSDBInstance @parameters</span>&#13;
&#13;
AllocatedStorage                      : 20&#13;
AutoMinorVersionUpgrade               : True&#13;
AvailabilityZone                      :&#13;
BackupRetentionPeriod                 : 1&#13;
CACertificateIdentifier               : rds-ca-2015&#13;
CharacterSetName                      :&#13;
CopyTagsToSnapshot                    : False&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch13list30"><em>Listing 13-30: Provisioning a new RDS database instance</em></p>&#13;
<p class="indent">Congratulations! Your AWS should have a shiny, new RDS database.</p>&#13;
<h3 class="h3" id="ch13lev6">Summary</h3>&#13;
<p class="noindent">This chapter covered the basics of using AWS with PowerShell. You looked at AWS authentication and then went through several common AWS tasks: creating EC2 instances, deploying Elastic Beanstalk web applications, and provisioning an Amazon RDS SQL database.</p>&#13;
<p class="indent">After this chapter and the preceding one, you should have a good sense of how to use PowerShell to work with the cloud. Of course, there’s much more to learn—more than I could ever cover in this book—but for now, you’ll be moving on to the next part of this book: creating your own fully functional PowerShell module.<span epub:type="pagebreak" id="page_192"/></p>&#13;
</body></html>