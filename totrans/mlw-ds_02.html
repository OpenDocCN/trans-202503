<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_11"/><strong><span class="big">2</span></strong><br/><strong>BEYOND BASIC STATIC ANALYSIS: X86 DISASSEMBLY</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">To thoroughly understand a malicious program, we often need to go beyond basic static analysis of its sections, strings, imports, and images. This involves reverse engineering a program’s assembly code. Indeed, disassembly and reverse engineering lie at the heart of deep static analysis of malware samples.</p>
<p class="indent">Because reverse engineering is an art, technical craft, and science, a thorough exploration is beyond the scope of this chapter. My goal here is to introduce you to reverse engineering so that you can apply it to malware data science. Understanding this methodology is essential for successfully applying machine learning and data analysis to malware.</p>
<p class="indent">In this chapter I start with the concepts you’ll need to understand x86 disassembly. Later in the chapter I show how malware authors attempt to bypass disassembly and discuss ways to mitigate these anti-analysis and anti-detection maneuvers. But first, let’s review some common disassembly methods as well as the basics of x86 assembly language.</p>
<h3 class="h3" id="lev21"><span epub:type="pagebreak" id="page_12"/><strong>Disassembly Methods</strong></h3>
<p class="noindent"><em>Disassembly</em> is the process by which we translate malware’s binary code into valid x86 assembly language. Malware authors generally write malware programs in a high-level language like C or C++ and then use a compiler to compile the source code into x86 binary code. Assembly language is the human-readable representation of this binary code. Therefore, disassembling a malware program into assembly language is necessary to understand how it behaves at its core.</p>
<p class="indent">Unfortunately, disassembly is no easy feat because malware authors regularly employ tricks to thwart would-be reverse engineers. In fact, perfect disassembly in the face of deliberate obfuscation is an unsolved problem in computer science. Currently, only approximate, error-prone methods exist for disassembling such programs.</p>
<p class="indent">For example, consider the case of <em>self-modifying code</em>, or binary code that modifies itself as it executes. The only way to disassemble this code properly is to understand the program logic by which the code modifies itself, but that can be exceedingly complex.</p>
<p class="indent">Because perfect disassembly is currently impossible, we must use imperfect methods to accomplish this task. The method we’ll use is <em>linear disassembly</em>, which involves identifying the contiguous sequence of bytes in the Portable Executable (PE) file that corresponds to its x86 program code and then decoding these bytes. The key limitation of this approach is that it ignores subtleties about how instructions are decoded by the CPU in the course of program execution. Also, it doesn’t account for the various obfuscations malware authors sometimes use to make their programs harder to analyze.</p>
<p class="indent">The other methods of reverse engineering, which we won’t cover here, are the more complex disassembly methods used by industrial-grade disassemblers such as IDA Pro. These more advanced methods actually simulate or reason about program execution to discover which assembly instructions a program might reach as a result of a series of conditional branches.</p>
<p class="indent">Although this type of disassembly can be more accurate than linear disassembly, it’s far more CPU intensive than linear disassembly methods, making it less suitable for data science purposes where the focus is on disassembling thousands or even millions of programs.</p>
<p class="indent">Before you can begin analysis using linear disassembly, however, you’ll need to review the basic components of assembly language.</p>
<h3 class="h3" id="lev22"><strong>Basics of x86 Assembly Language</strong></h3>
<p class="noindent">Assembly language is the lowest-level human-readable programming language for a given architecture, and it maps closely to the binary instruction format of a particular CPU architecture. A line of assembly language is almost always equivalent to a single CPU instruction. Because assembly is so low level, you can often retrieve it easily from a malware binary by using the right tools.</p>
<p class="indent"><span epub:type="pagebreak" id="page_13"/>Gaining basic proficiency in reading disassembled malware x86 code is easier than you might think. This is because most malware assembly code spends most of its time calling into the operating system by way of the Windows operating system’s <em>dynamic-link libraries (DLLs)</em>, which are loaded into program memory at runtime. Malware programs use DLLs to do most of the real work, such as modifying the system registry, moving and copying files, making network connections and communicating via network protocols, and so on. Therefore, following malware assembly code often involves understanding the ways in which function calls are made from assembly and understanding what various DLL calls do. Of course, things can get much more complicated, but knowing this much can reveal a lot about the malware.</p>
<p class="indent">In the following sections I introduce some important assembly language concepts. I also explain some abstract concepts like control flow and control flow graphs. Finally, we disassemble the <em>ircbot.exe</em> program and explore how its assembly and control flow can give us insight into its purpose.</p>
<p class="indent">There are two major dialects of x86 assembly: Intel and AT&amp;T. In this book I use Intel syntax, which can be obtained from all major disassemblers and is the syntax used in the official Intel documentation of the x86 CPU.</p>
<p class="indent">Let’s start by taking a look at CPU registers.</p>
<h4 class="h4" id="lev23"><strong><em>CPU Registers</em></strong></h4>
<p class="noindent"><em>Registers</em> are small data storage units on which x86 CPUs perform computations. Because registers are located on the CPU itself, register access is orders of magnitude faster than memory access. This is why core computational operations, such as arithmetic and condition testing instructions, all target registers. It’s also why the CPU uses registers to store information about the status of running programs. Although many registers are available to experienced x86 assembly programmers, we’ll just focus on a few important ones here.</p>
<h5 class="h5" id="lev24"><strong>General-Purpose Registers</strong></h5>
<p class="noindent">General-purpose registers are like scratch space for assembly programmers. On a 32-bit system, each of these registers contains 32, 16, or 8 bits of space against which we can perform arithmetic operations, bitwise operations, byte order–swapping operations, and more.</p>
<p class="indent">In common computational workflows, programs move data into registers from memory or from external hardware devices, perform some operations on this data, and then move the data back out to memory for storage. For example, to sort a long list, a program typically pulls list items in from an array in memory, compares them in the registers, and then writes the comparison results back out to memory.</p>
<p class="indent">To understand some of the nuances of the general-purpose register model in the Intel 32-bit architecture, take a look at <a href="ch02.xhtml#ch02fig1">Figure 2-1</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_14"/><a id="ch02fig1"/><img alt="image" src="../images/f0014-01.jpg"/></div>
<p class="figcap"><em>Figure 2-1: Registers in the x86 architecture</em></p>
<p class="indent">The vertical axis shows the layout of the general-purpose registers, and the horizontal axis shows how EAX, EBX, ECX, and EDX are subdivided. EAX, EBX, ECX, and EDX are 32-bit registers that have smaller, 16-bit registers inside them: AX, BX, CX, and DX. As you can see in the figure, these 16-bit registers can be subdivided into upper and lower 8-bit registers: AH, AL, BH, BL, CH, CL, DH, and DL. Although it’s sometimes useful to address the subdivisions in EAX, EBX, ECX, and EDX, you’ll mostly see direct references to EAX, EBX, ECX, and EDX.</p>
<h5 class="h5" id="lev25"><strong>Stack and Control Flow Registers</strong></h5>
<p class="noindent">The stack management registers store critical information about the <em>program stack</em>, which is responsible for storing local variables for functions, arguments passed into functions, and control information relating to the program control flow. Let’s go over some of these registers.</p>
<p class="indent">In simple terms, the ESP register points to the top of the stack for the currently executing function, whereas the EBP register points to the bottom of the stack for the currently executing function. This is crucial information for modern programs, because it means that by referencing data relative to the stack rather than using its absolute address, procedural and object-oriented code can access local variables more gracefully and efficiently.</p>
<p class="indent">Although you won’t see direct references to the EIP register in x86 assembly code, it’s important in security analysis, particularly in the context of vulnerability research and buffer-overflow exploit development. This is because EIP contains the memory address of the currently executing instruction. Attackers can use buffer-overflow exploits to corrupt the value of the EIP register indirectly and take control of program execution.</p>
<p class="indent"><span epub:type="pagebreak" id="page_15"/>In addition to its role in exploitation, EIP is also important in the analysis of malicious code deployed by malware. Using a debugger we can inspect EIP’s value at any moment, which helps us understand what code malware is executing at any particular time.</p>
<p class="indent">EFLAGS is a status register that contains CPU <em>flags</em>, which are bits that store status information about the state of the currently executing program. The EFLAGS register is central to the process of making <em>conditional branches</em>, or changes in execution flow resulting from the outcome of if/then-style program logic, within x86 programs. Specifically, whenever an x86 assembly program checks whether some value is greater or less than zero and then jumps to a function based on the outcome of this test, the EFLAGS register plays an enabling role, as described in more detail in “<a href="ch02.xhtml#lev30">Basic Blocks and Control Flow Graphs</a>” on <a href="ch02.xhtml#page_19">page 19</a>.</p>
<h4 class="h4" id="lev26"><strong><em>Arithmetic Instructions</em></strong></h4>
<p class="noindent"><em>Instructions</em> operate on general-purpose registers. You can perform simple computations with the general-purpose registers using arithmetic instructions. For example, <span class="literal">add</span>, <span class="literal">sub</span>, <span class="literal">inc</span>, <span class="literal">dec</span>, and <span class="literal">mul</span> are examples of arithmetic instructions you’ll encounter frequently in malware reverse engineering. <a href="ch02.xhtml#ch02tab1">Table 2-1</a> lists some examples of basic instructions and their syntax.</p>
<p class="tabcap" id="ch02tab1"><strong>Table 2-1:</strong> Arithmetic Instructions</p>
<table class="topbot-d">
<thead>
<tr>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Instructions</strong></p></td>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">add ebx, 100</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">Adds 100 to the value in EBX and then stores the result in EBX</p></td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">sub ebx, 100</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">Subtracts 100 from the value in EBX and then stores the result in EBX</p></td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">inc ah</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">Increments the value in AH by 1</p></td>
</tr>
<tr>
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">dec al</span></p></td>
<td class="table-ba" style="vertical-align: top;"><p class="taba">Decrements the value in AL by 1</p></td>
</tr>
</tbody>
</table>
<p class="indent">The <span class="literal">add</span> instruction adds two integers and stores the result in the first operand specified, whether this is a memory location or a register according to the following syntax. Keep in mind only one argument can be a memory location. The <span class="literal">sub</span> instruction is similar to <span class="literal">add</span>, except it subtracts integers. The <span class="literal">inc</span> instruction increments a register or memory location’s integer value, whereas <span class="literal">dec</span> decrements a register or memory location’s integer value.</p>
<h4 class="h4" id="lev27"><strong><em>Data Movement Instructions</em></strong></h4>
<p class="noindent">The x86 processor provides a robust set of instructions for moving data between registers and memory. These instructions provide the underlying mechanisms that allow us to manipulate data. The staple memory movement instruction is the <span class="literal">mov</span> instruction. <a href="ch02.xhtml#ch02tab2">Table 2-2</a> shows how you can use the <span class="literal">mov</span> instruction to move data around.</p>
<p class="tabcap" id="ch02tab2"><span epub:type="pagebreak" id="page_16"/><strong>Table 2-2:</strong> Data Movement Instructions</p>
<table class="topbot-d">
<thead>
<tr>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Instructions</strong></p></td>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">mov ebx,eax</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">Moves the value in register EAX into register EBX</p></td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">mov eax, [0x12345678]</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">Moves the data at memory address 0x12345678 into the EAX register</p></td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">mov edx, 1</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">Moves the value 1 into the register EDX</p></td>
</tr>
<tr>
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">mov [0x12345678], eax</span></p></td>
<td class="table-ba" style="vertical-align: top;"><p class="taba">Moves the value in EAX into the memory location 0x12345678</p></td>
</tr>
</tbody>
</table>
<p class="indent">Related to the <span class="literal">mov</span> instruction, the <span class="literal">lea</span> instruction loads the absolute memory address specified into the register used for getting a pointer to a memory location. For example, <span class="literal">lea edx, [esp-4]</span> subtracts 4 from the value in ESP and loads the resulting value into EDX.</p>
<h5 class="h5" id="lev28"><strong>Stack Instructions</strong></h5>
<p class="noindent">The <em>stack</em> in x86 assembly is a data structure that allows you to push and pop values onto and off of it. This is similar to how you would add and remove plates on and off the top of a stack of plates.</p>
<p class="indent">Because control flow is often expressed through C-style function calls in x86 assembly and because these function calls use the stack to pass arguments, allocate local variables, and remember what part of the program to return to after a function finishes executing, the stack and control flow need to be understood together.</p>
<p class="indent">The <span class="literal">push</span> instruction pushes values onto the program stack when the programmer wants to save a register value onto the stack, and the <span class="literal">pop</span> instruction deletes values from the stack and places them into a designated register.</p>
<p class="indent">The <span class="literal">push</span> instruction uses the following syntax to perform its operations:</p>
<p class="programs">push 1</p>
<p class="indent">In this example, the program points the stack pointer (the register ESP) to a new memory address, thereby making room for the value (1), which is now stored at the top location on the stack. Then it copies the value from the argument to the memory location the CPU has just made room for on the top of the stack.</p>
<p class="indent">Let’s contrast this with <span class="literal">pop</span>:</p>
<p class="programs">pop eax</p>
<p class="indent">The program uses <span class="literal">pop</span> to pop the top value off the stack and move it into a specified register. In this example, <span class="literal">pop eax</span> pops the top value off the stack and moves it into <span class="literal">eax</span>.</p>
<p class="indent">An unintuitive but important detail to understand about the x86 program stack is that it grows downward in memory, so that the highest value on the stack is actually stored at the lowest address in stack memory. This <span epub:type="pagebreak" id="page_17"/>becomes very important to remember when you analyze assembly code that references data stored on the stack, as it can quickly get confusing unless you know the stack’s memory layout.</p>
<p class="indent">Because the x86 stack grows downward in memory, when the <span class="literal">push</span> instruction allocates space on the program stack for a new value, it decrements the value of ESP so that it points to a lower location in memory and then copies a value from the target register into that memory location, starting at the top address of the stack and growing up. Conversely, the <span class="literal">pop</span> instruction actually copies the top value off of the stack and then increments the value of ESP so it points to a higher memory location.</p>
<h5 class="h5" id="lev29"><strong>Control Flow Instructions</strong></h5>
<p class="noindent">An x86 program’s <em>control flow</em> defines the network of possible instruction execution sequences a program may execute, depending on the data, device interactions, and other inputs the program might receive. Control flow instructions define a program’s control flow. They are more complicated than stack instructions but still quite intuitive. Because control flow is often expressed through C-style function calls in x86 assembly, the stack and control flow are closely related. They’re also related because these function calls use the stack to pass arguments, allocate local variables, and remember what part of the program to return to after a function finishes executing.</p>
<p class="indent">The <span class="literal">call</span> and <span class="literal">ret</span> control flow instructions are the most important in terms of how programs call functions in x86 assembly and how programs return from functions after these functions are done executing.</p>
<p class="indent">The <span class="literal">call</span> instruction calls a function. Think of this as a function you might write in a higher-level language like C to allow the program to return to the instruction after the <span class="literal">call</span> instruction is invoked and the function has finished executing. You can invoke the <span class="literal">call</span> instruction using the following syntax, where <span class="codeitalic">address</span> denotes the memory location where the function’s code begins:</p>
<p class="programs">call <span class="codeitalic1">address</span></p>
<p class="indent">The <span class="literal">call</span> instruction does two things. First, it pushes the address of the instruction that will execute after the function call returns onto the top of the stack so that the program knows what address to return to after the called function finishes executing. Second, <span class="literal">call</span> replaces the current value of EIP with the value specified by the <span class="codeitalic">address</span> operand. Then, the CPU begins execution at the new memory location pointed to by EIP.</p>
<p class="indent">Just as <span class="literal">call</span> initiates a function call, the <span class="literal">ret</span> instruction completes it. You can use the <span class="literal">ret</span> instruction on its own and without any parameter, as shown here:</p>
<p class="programs">ret</p>
<p class="indent"><span epub:type="pagebreak" id="page_18"/>When invoked, <span class="literal">ret</span> pops the top value off the stack, which we expect to be the saved program counter value (EIP) that the <span class="literal">call</span> instruction pushed onto the stack when the <span class="literal">call</span> instruction was invoked. Then it places the popped program counter value back into EIP and resumes execution.</p>
<p class="indent">The <span class="literal">jmp</span> instruction is another important control flow construction, which operates more simply than <span class="literal">call</span>. Instead of worrying about saving EIP, <span class="literal">jmp</span> simply tells the CPU to move to the memory address specified as its parameter and begin execution there. For example, <span class="literal">jmp 0x12345678</span> tells the CPU to start executing the program code stored at memory location 0x12345678 on the next instruction.</p>
<p class="indent">You may be wondering how you can make <span class="literal">jmp</span> and <span class="literal">call</span> instructions execute in a conditional way, such as “if the program has received a network packet, execute the following function.” The answer is that x86 assembly doesn’t have high-level constructs like if, then, else, else if, and so on. Instead, branching to an address within a program’s code typically requires two instructions: a <span class="literal">cmp</span> instruction, which checks the value in some register against some test value and stores the result of that test in the EFLAGS register, and a conditional branch instruction.</p>
<p class="indent">Most conditional branch instructions start with a <em>j</em>, which allows the program to jump to a memory address, and are post-fixed with letters that stand for the condition being tested. For example, <span class="literal">jge</span> tells the program to jump if greater than or equal to. This means that the value in the register being tested must be greater than or equal to the test value.</p>
<p class="indent">The <span class="literal">cmp</span> instruction uses the following syntax:</p>
<p class="programs">cmp <span class="codeitalic1">register, memory location, or literal, register, memory location, or<br/>literal</span></p>
<p class="indent">As stated earlier, <span class="literal">cmp</span> compares the value in the specified general-purpose register with <span class="codeitalic">value</span> and then stores the result of that comparison in the EFLAGS register.</p>
<p class="indent">The various conditional <span class="literal">jmp</span> instructions are then invoked as follows:</p>
<p class="programs">j* <span class="codeitalic1">address</span></p>
<p class="indent">As you can see, we can prefix <em>j</em> to any number of conditional test instructions. For example, to jump only if the value tested is greater than or equal to the value in the register, use the following instruction:</p>
<p class="programs">jge <span class="codeitalic1">address</span></p>
<p class="indent">Note that unlike the case of the <span class="literal">call</span> and <span class="literal">ret</span> instructions, the <span class="literal">jmp</span> family of instructions never touches the program stack. In fact, in the case of the <span class="literal">jmp</span> family of instructions, the x86 program is responsible for tracking its own execution flow and potentially saving or deleting information about what addresses it has visited and where it should return to after a particular sequence of instructions has executed.</p>
<h5 class="h5" id="lev30"><span epub:type="pagebreak" id="page_19"/><strong>Basic Blocks and Control Flow Graphs</strong></h5>
<p class="noindent">Although x86 programs look sequential when we scroll through their code in a text editor, they actually have loops, conditional branches, and unconditional branches (control flow). All of these give each x86 program a <em>network</em> structure. Let’s use the simple toy assembly program in <a href="ch02.xhtml#ch02list1">Listing 2-1</a> to see how this works.</p>
<p class="programs">   <span class="codestrong1">setup:</span> # symbol standing in for address of instruction on the next line<br/><span class="ent">➊</span> <span class="codestrong1">mov eax, 10</span><br/>   <span class="codestrong1">loopstart:</span> # symbol standing in for address of the instruction on the next<br/>   line<br/><span class="ent">➋</span> <span class="codestrong1">sub eax, 1</span><br/><span class="ent">➌</span> <span class="codestrong1">cmp 0, eax</span><br/>   <span class="codestrong1">jne $loopstart</span><br/>   <span class="codestrong1">loopend:</span> # symbol standing in for address of the instruction on the next<br/>   line<br/>   <span class="codestrong1">mov eax, 1</span><br/>   # more code would go here</p>
<p class="listing" id="ch02list1"><em>Listing 2-1: Assembly program for understanding control flow graph</em></p>
<p class="indent">As you can see, this program initializes a counter to the value 10, stored in register EAX <span class="ent">➊</span>. Next, it does a loop in which the value in EAX is decremented by 1 <span class="ent">➋</span> on each iteration. Finally, once EAX has reached a value of 0 <span class="ent">➌</span>, the program breaks out of the loop.</p>
<p class="indent">In the language of control flow graph analysis, we can think of these instructions as comprising three basic blocks. A <em>basic block</em> is a sequence of instructions that we know will always execute contiguously. In other words, a basic block always ends with either a branching instruction or an instruction that is the target of a branch, and it always begins with either the first instruction of the program, called the program’s <em>entry point</em>, or a branch target.</p>
<p class="indent">In <a href="ch02.xhtml#ch02list1">Listing 2-1</a>, you can see where the basic blocks of our simple program begin and end. The first basic block is composed of the instruction <span class="literal">mov eax, 10</span> under <span class="literal">setup:</span>. The second basic block is composed of lines beginning with <span class="literal">sub eax, 1</span> through <span class="literal">jne $loopstart</span> under <span class="literal">loopstart:</span>, and the third starts at <span class="literal">mov eax, 1</span> under <span class="literal">loopend:</span>. We can visualize the relationships between the basic blocks using the graph in <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>. (We use the term <em>graph</em> synonymously with the term <em>network</em>; in computer science, these terms are interchangeable.)</p>
<div class="image"><a id="ch02fig2"/><img alt="image" src="../images/f0019-01.jpg"/></div>
<p class="figcap"><em>Figure 2-2: A visualization of the control flow graph of our simple assembly program</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_20"/>If one basic block can ever flow into another basic block, we connect it, as shown in <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>. The figure shows that the <span class="literal">setup</span> basic block leads to the <span class="literal">loopstart</span> basic block, which repeats 10 times before it transitions to the <span class="literal">loopend</span> basic block. Real-world programs have control flow graphs such as these, but they’re much more complicated, with thousands of basic blocks and thousands of interconnections.</p>
<h3 class="h3" id="lev31"><strong>Disassembling ircbot.exe Using pefile and capstone</strong></h3>
<p class="noindent">Now that you have a good understanding of the basics of assembly language, let’s disassemble the first 100 bytes of <em>ircbot.exe</em>’s assembly code using linear disassembly. To do this, we’ll use the open source Python libraries <span class="literal">pefile</span> (introduced in <a href="ch01.xhtml#ch01">Chapter 1</a>) and <span class="literal">capstone</span>, which is an open source disassembly library that can disassemble 32-bit x86 binary code. You can install both of these libraries with <span class="literal">pip</span> using the following commands:</p>
<p class="programs"><span class="codestrong1">pip install pefile</span><br/><span class="codestrong1">pip install capstone</span></p>
<p class="indent">Once these two libraries are installed, we can leverage them to disassemble <em>ircbot.exe</em> using the code in <a href="ch02.xhtml#ch02list2">Listing 2-2</a>.</p>
<p class="programs">#!/usr/bin/python<br/><span class="codestrong1">import pefile</span><br/><span class="codestrong1">from capstone import *</span><br/><br/># load the target PE file<br/><span class="codestrong1">pe = pefile.PE("ircbot.exe")</span><br/><br/># get the address of the program entry point from the program header<br/><span class="codestrong1">entrypoint = pe.OPTIONAL_HEADER.AddressOfEntryPoint</span><br/><br/># compute memory address where the entry code will be loaded into memory<br/><span class="codestrong1">entrypoint_address = entrypoint+pe.OPTIONAL_HEADER.ImageBase</span><br/><br/># get the binary code from the PE file object<br/><span class="codestrong1">binary_code = pe.get_memory_mapped_image()[entrypoint:entrypoint+100]</span><br/><br/># initialize disassembler to disassemble 32 bit x86 binary code<br/><span class="codestrong1">disassembler = Cs(CS_ARCH_X86, CS_MODE_32)</span><br/><br/># disassemble the code<br/><span class="codestrong1">for instruction in disassembler.disasm(binary_code, entrypoint_address):</span><br/>    <span class="codestrong1">print "%s\t%s" %(instruction.mnemonic, instruction.op_str)</span></p>
<p class="listing" id="ch02list2"><em>Listing 2-2: Disassembling</em> ircbot.exe</p>
<p class="indent">This should produce the following output:</p>
<p class="programs"><span class="ent">➊</span> push    ebp<br/>   mov     ebp, esp<br/><span epub:type="pagebreak" id="page_21"/>   push    -1<br/>   push    0x437588<br/>   push    0x41982c<br/><span class="ent">➋</span> mov     eax, dword ptr fs:[0]<br/>   push    eax<br/>   mov     dword ptr fs:[0], esp<br/><span class="ent">➌</span> add     esp, -0x5c<br/>   push    ebx<br/>   push    esi<br/>   push    edi<br/>   mov     dword ptr [ebp - 0x18], esp<br/><span class="ent">➍</span> call    dword ptr [0x496308]<br/>   <span class="codeitalic1">--snip--</span></p>
<p class="indent">Don’t worry about understanding all of the instructions in the disassembly output: that would involve an understanding of assembly that goes beyond the scope of this book. However, you should feel comfortable with many of the instructions in the output and have some sense of what they do. For example, the malware pushes the value in register EBP onto the stack <span class="ent">➊</span>, saving its value. Then it proceeds to move the value in ESP into EBP and pushes some numerical values onto the stack. The program moves some data in memory into the EAX register <span class="ent">➋</span>, and it adds the value -0x5c to the value in the ESP register <span class="ent">➌</span>. Finally, the program uses the <span class="literal">call</span> instruction to call a function stored at the memory address 0x496308 <span class="ent">➍</span>.</p>
<p class="indent">Because this is not a book on reverse engineering, I won’t go into any more depth here about what the code means. What I’ve presented is a start to understanding how assembly language works. For more information on assembly language, I recommend the Intel programmer’s manual at <em><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a></em>.</p>
<h3 class="h3" id="lev32"><strong>Factors That Limit Static Analysis</strong></h3>
<p class="noindent">In this chapter and <a href="ch01.xhtml#ch01">Chapter 1</a>, you learned about a variety of ways in which static analysis techniques can be used to elucidate the purpose and methods of a newly discovered malicious binary. Unfortunately, static analysis has limitations that render it less useful in some circumstances. For example, malware authors can employ certain offensive tactics that are far easier to implement than to defend against. Let’s take a look at some of these offensive tactics and see how to defend against them.</p>
<h4 class="h4" id="lev33"><strong><em>Packing</em></strong></h4>
<p class="noindent">Malware <em>packing</em> is the process by which malware authors compress, encrypt, or otherwise mangle the bulk of their malicious program so that it appears inscrutable to malware analysts. When the malware is run, it unpacks itself and then begins execution. The obvious way around malware packing is to actually run the malware in a safe environment, a dynamic analysis technique I’ll cover in <a href="ch03.xhtml#ch03">Chapter 3</a>.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_22"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Software packing is also used by benign software installers for legitimate reasons. Benign software authors use packing to deliver their code because it allows them to compress program resources to reduce software installer download sizes. It also helps them thwart reverse engineering attempts by business competitors, and it provides a convenient way to bundle many program resources within a single installer file.</em></p>
</div>
<h4 class="h4" id="lev34"><strong><em>Resource Obfuscation</em></strong></h4>
<p class="noindent">Another anti-detection, anti-analysis technique malware authors use is <em>resource obfuscation</em>. They obfuscate the way program resources, such as strings and graphical images, are stored on disk, and then deobfuscate them at runtime so they can be used by the malicious program. For example, a simple obfuscation would be to add a value of 1 to all bytes in images and strings stored in the PE resources section and then subtract 1 from all of this data at runtime. Of course, any number of obfuscations are possible here, all of which make life difficult for malware analysts attempting to make sense of a malware binary using static analysis.</p>
<p class="indent">As with packing, one way around resource obfuscation is to just run the malware in a safe environment. When this is not an option, the only mitigation for resource obfuscation is to actually figure out the ways in which malware has obfuscated its resources and to manually deobfuscate them, which is what professional malware analysts often do.</p>
<h4 class="h4" id="lev35"><strong><em>Anti-disassembly Techniques</em></strong></h4>
<p class="noindent">A third group of anti-detection, anti-analysis techniques used by malware authors are <em>anti-disassembly</em> techniques. These techniques are designed to exploit the inherent limitations of state-of-the-art disassembly techniques to hide code from malware analysts or make malware analysts think that a block of code stored on disk contains different instructions than it actually does.</p>
<p class="indent">An example of an anti-disassembly technique involves branching to a memory location that the malware author’s disassemblers will interpret as a different instruction, essentially hiding the malware’s true instructions from reverse engineers. Anti-disassembly techniques have huge potential and there’s no perfect way to defend against them. In practice, the two main defenses against these techniques are to run malware samples in a dynamic environment and to manually figure out where anti-disassembly strategies manifest within a malware sample and how to bypass them.</p>
<h4 class="h4" id="lev36"><strong><em>Dynamically Downloaded Data</em></strong></h4>
<p class="noindent">A final class of anti-analysis techniques malware authors use involves externally sourcing data and code. For example, a malware sample may load code dynamically from an external server at malware startup time. If this is the case, static analysis will be useless against such code. Similarly, malware may source decryption keys from external servers at startup time and then use these keys to decrypt data or code that will be used in the malware’s execution.</p>
<p class="indent"><span epub:type="pagebreak" id="page_23"/>Obviously, if the malware is using an industrial-strength encryption algorithm, static analysis will not be sufficient to recover the encrypted data and code. Such anti-analysis and anti-detection techniques are quite powerful, and the only way around them is to acquire the code, data, or private keys on the external servers by some means and then use them in one’s analysis of the malware in question.</p>
<h3 class="h3" id="lev37"><strong>Summary</strong></h3>
<p class="noindent">This chapter introduced x86 assembly code analysis and demonstrated how we can perform disassembly-based static analysis on <em>ircbot.exe</em> using open source Python tools. Although this is not meant to be a complete primer on x86 assembly, you should now feel comfortable enough that you have a starting place for figuring out what’s going on in a given malware assembly dump. Finally, you learned ways in which malware authors can defend against disassembly and other static analysis techniques, and how you can mitigate these anti-analysis and anti-detection strategies. In <a href="ch03.xhtml#ch03">Chapter 3</a>, you’ll learn to conduct dynamic malware analysis that makes up for many of the weaknesses of static malware analysis.<span epub:type="pagebreak" id="page_24"/></p>
</body></html>