- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**READING FROM AND WRITING TO GAME MEMORY**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**读取和写入游戏内存**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Earlier chapters discussed how memory is structured as well as how to scan and
    modify memory using Cheat Engine and OllyDbg. Working with memory will be essential
    when you begin to write bots, and your code will need to know how to do so.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节讨论了内存是如何构建的，以及如何使用 Cheat Engine 和 OllyDbg 扫描和修改内存。在你开始编写机器人时，操作内存将是至关重要的，你的代码需要知道如何操作内存。
- en: This chapter digs into the code-level details of memory manipulation. First,
    you’ll learn how to use code to locate and obtain handles to game processes. Next,
    you’ll learn how to use those handles to read from and write to memory both from
    remote processes and from injected code. To wrap up, you’ll learn bypasses for
    a certain memory protection technique, complete with a small example of code injection.
    You’ll find the example code for this chapter in the *GameHackingExamples/Chapter6_AccessingMemory*
    directory in this book’s source files.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了内存操作的代码层面细节。首先，你将学习如何使用代码定位并获取游戏进程的句柄。接下来，你将学习如何使用这些句柄从远程进程或注入的代码中读取和写入内存。最后，你将学习绕过某种内存保护技术，并附带一个小示例，演示代码注入。你将在本书的源代码文件中的*GameHackingExamples/Chapter6_AccessingMemory*目录下找到本章的示例代码。
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When I talk about API functions in this chapter (and in later ones), I’m referring
    to the Windows API unless otherwise specified. If I don’t mention a header file
    for the library, you can assume it is* Windows.h.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我在本章（以及后续章节）中谈论 API 函数时，我指的是 Windows API，除非另有说明。如果我没有提到库的头文件，你可以假设它是* Windows.h。'
- en: '**Obtaining the Game’s Process Identifier**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取游戏的进程标识符**'
- en: To read from or write to a game’s memory, you need its *process identifier (PID)*,
    a number that uniquely identifies an active process. If the game has a visible
    window, you can obtain the PID of the process that created that window by calling
    `GetWindowThreadProcessId()`. This function takes the window’s handle as the first
    parameter and outputs the PID to the second parameter. You can find the window’s
    handle by passing its title (the text on the taskbar) as the second parameter
    to `FindWindow()`, as shown in [Listing 6-1](ch06.xhtml#ch6exe1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取或写入游戏的内存，你需要其*进程标识符（PID）*，这是一个唯一标识活动进程的数字。如果游戏有一个可见窗口，你可以通过调用 `GetWindowThreadProcessId()`
    来获取创建该窗口的进程的 PID。此函数将窗口的句柄作为第一个参数，并将 PID 输出到第二个参数。你可以通过将窗口标题（任务栏上的文本）作为第二个参数传递给
    `FindWindow()` 来找到窗口的句柄，如 [示例 6-1](ch06.xhtml#ch6exe1) 所示。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: Fetching a window’s handle to obtain a PID*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-1：获取窗口句柄以获取 PID*'
- en: With the window handle secured, all you have to do is create a place to store
    the PID and call `GetWindowThreadProcessId()`, as shown in this example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 获取到窗口句柄后，你只需创建一个存储 PID 的地方并调用 `GetWindowThreadProcessId()`，如以下示例所示。
- en: If a game isn’t windowed or the window name isn’t predictable, you can find
    the game’s PID by enumerating all processes and looking for the name of the game
    binary. [Listing 6-2](ch06.xhtml#ch6exe2) does this using the API functions `CreateToolhelp32Snapshot()`,
    `Process32First()`, and `Process32Next()` from *tlhelp32.h.*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏没有窗口，或者窗口名称不可预测，你可以通过枚举所有进程并查找游戏二进制文件的名称来找到游戏的 PID。[示例 6-2](ch06.xhtml#ch6exe2)
    就是使用 API 函数 `CreateToolhelp32Snapshot()`、`Process32First()` 和 `Process32Next()`
    来实现的，这些函数来自 *tlhelp32.h*。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-2: Fetching a game’s PID without the window name*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-2：在没有窗口名称的情况下获取游戏的 PID*'
- en: '[Listing 6-2](ch06.xhtml#ch6exe2) might look a bit more complex than [Listing
    6-1](ch06.xhtml#ch6exe1), but underneath all that code, the function is actually
    like a canonical `for (iterator`; comparator; increment) loop. The `CreateToolhelp32Snapshot()`
    function obtains a list of processes named `snapshot`, and `entry` is an *iterator*
    over that list. The value returned by `Process32First()` initializes the iterator,
    while `Process32Next()` *increments* it. Finally, the Boolean return value of
    `Process32Next()` is the *comparator*. This code just iterates over a snapshot
    of every running process, looks for one whose binary path contains the text *game.exe*,
    and prints its PID.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-2](ch06.xhtml#ch6exe2) 可能看起来比 [示例 6-1](ch06.xhtml#ch6exe1) 更复杂，但在所有代码的背后，这个函数实际上就像一个典型的
    `for (iterator`; 比较器; 增量) 循环。`CreateToolhelp32Snapshot()` 函数获取一个名为 `snapshot`
    的进程列表，`entry` 是该列表的*迭代器*。`Process32First()` 返回的值初始化了迭代器，而 `Process32Next()` *递增*
    了它。最后，`Process32Next()` 的布尔返回值是*比较器*。这段代码只是遍历了每个运行中的进程的快照，寻找其二进制路径包含文本 *game.exe*
    的进程，并打印其 PID。'
- en: '***Obtaining Process Handles***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取进程句柄***'
- en: Once you know a game’s PID, you can obtain a handle to the process itself using
    an API function called `OpenProcess()`. This function allows you to fetch handles
    with the access levels you need to read from and write to memory. This is crucial
    to game hacking, as any function that operates on a process will require a handle
    with proper access.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了游戏的 PID，你可以通过一个名为 `OpenProcess()` 的 API 函数获取到该进程的句柄。此函数允许你以所需的访问权限获取句柄，以便读取和写入内存。这对于游戏破解至关重要，因为任何操作进程的函数都需要具有适当访问权限的句柄。
- en: 'Let’s take a look at the prototype of `OpenProcess()`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `OpenProcess()` 的原型：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first parameter, `DesiredAccess`, expects one or a mixture of process access
    flags to set on the handle that `OpenProcess()` returns. There are many flags
    you can use, but these are the most common in game hacking:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数 `DesiredAccess` 期望一个或多个进程访问标志，用于设置 `OpenProcess()` 返回的句柄。你可以使用多种标志，但在游戏破解中最常见的是以下几个：
- en: '`PROCESS_VM_OPERATION` The returned handle can be used with `VirtualAllocEx()`,
    `VirtualFreeEx()`, and `VirtualProtectEx()` to allocate, free, and protect chunks
    of memory, respectively.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`PROCESS_VM_OPERATION` 返回的句柄可以与 `VirtualAllocEx()`、`VirtualFreeEx()` 和 `VirtualProtectEx()`
    一起使用，分别用于分配、释放和保护内存块。'
- en: '`PROCESS_VM_READ` The returned handle can be used with `ReadProcessMemory()`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`PROCESS_VM_READ` 返回的句柄可以与 `ReadProcessMemory()` 一起使用。'
- en: '`PROCESS_VM_WRITE` The returned handle can be used with `WriteProcessMemory()`,
    but it must also have `PROCESS_VM_OPERATION` rights. You can set both flags by
    passing `PROCESS_VM_OPERATION | PROCESS_VM_WRITE` as the `DesiredAccess` parameter.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`PROCESS_VM_WRITE` 返回的句柄可以与 `WriteProcessMemory()` 一起使用，但它也必须具有 `PROCESS_VM_OPERATION`
    权限。你可以通过将 `PROCESS_VM_OPERATION | PROCESS_VM_WRITE` 作为 `DesiredAccess` 参数来设置这两个标志。'
- en: '`PROCESS_CREATE_THREAD` The returned handle can be used with `CreateRemoteThread()`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`PROCESS_CREATE_THREAD` 返回的句柄可以与 `CreateRemoteThread()` 一起使用。'
- en: '`PROCESS_ALL_ACCESS` The returned handle can be used to do anything. Avoid
    using this flag, as it can only be used by processes with debug privileges enabled
    and has compatibility issues with older versions of Windows.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`PROCESS_ALL_ACCESS` 返回的句柄可以用来执行任何操作。避免使用此标志，因为它只能由启用了调试权限的进程使用，并且在旧版本的 Windows
    中存在兼容性问题。'
- en: When fetching a handle to a game, you can typically just set the `OpenProcess()`
    function’s second parameter, `InheritHandle`, to `false`. The third parameter,
    `ProcessId`, expects the PID of the process to be opened.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取游戏的句柄时，通常可以将 `OpenProcess()` 函数的第二个参数 `InheritHandle` 设置为 `false`。第三个参数 `ProcessId`
    期望打开的进程的 PID。
- en: '***Working with OpenProcess()***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 OpenProcess()***'
- en: 'Now let’s walk through an example call to `OpenProcess()` that uses a handle
    with access permissions allowing it to read from and write to memory:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个使用访问权限允许从内存读取和写入的句柄调用 `OpenProcess()` 的示例：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, the call to `getGamePID()` fetches the PID you’re looking for. (The
    function is something you’ll have to write yourself, though it could just be one
    of the snippets I showed in [Listings 6-1](ch06.xhtml#ch6exe1) and [6-2](ch06.xhtml#ch6exe2),
    fleshed out into a fullblown function.) Then, the code calls `OpenProcess()` with
    three flags: the `PROCESS_VM_OPERATION` flag gives this handle memory access permissions,
    and the other two combined give it read and write permissions. This example also
    contains an error-handling case ➊, but as long as you have the correct PID, you
    have valid access flags, and your code is running under the same or higher permissions
    as the game (for example, if you start your bot using Run As Admin), the call
    should never fail.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，调用 `getGamePID()` 获取你需要的 PID。（这个函数是你需要自己编写的，不过它可以只是我在[列表 6-1](ch06.xhtml#ch6exe1)和[6-2](ch06.xhtml#ch6exe2)中展示的代码片段，扩展成一个完整的函数。）接着，代码使用三个标志调用
    `OpenProcess()`：`PROCESS_VM_OPERATION` 标志为该句柄提供内存访问权限，另外两个标志组合提供了读写权限。这个示例还包含了一个错误处理案例
    ➊，但只要你有正确的 PID，拥有有效的访问标志，且代码运行的权限与游戏相同或更高（例如，如果你以管理员身份启动你的机器人），则该调用不应失败。
- en: 'Once you’re done using a handle, clean it up using `CloseHandle()` as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用完句柄，就应使用 `CloseHandle()` 清理它，代码如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can reuse handles as much as you want, so you can leave one open until you’re
    completely done using it or until your bot is exited.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意重用句柄，所以你可以一直保持一个句柄直到完全不再使用它，或者直到你的机器人退出。
- en: Now that you’ve seen how to open a process handle in preparation for manipulating
    game memory, let’s dig into how to actually access the memory of that process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到如何打开进程句柄，为操作游戏内存做好准备，接下来让我们深入探讨如何实际访问该进程的内存。
- en: '**Accessing Memory**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**访问内存**'
- en: 'The Windows API exposes two functions that are crucial to memory access: `ReadProcessMemory()`
    and `WriteProcessMemory()`. You can use these functions to externally manipulate
    a game’s memory.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Windows API 提供了两个对内存访问至关重要的函数：`ReadProcessMemory()` 和 `WriteProcessMemory()`。你可以使用这些函数来外部操控游戏的内存。
- en: '***Working with ReadProcessMemory() and WriteProcessMemory()***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 ReadProcessMemory() 和 WriteProcessMemory()***'
- en: The prototypes for these two functions (shown in [Listing 6-3](ch06.xhtml#ch6exe3))
    resemble each other closely, and you’ll follow almost exactly the same steps to
    use them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的原型（如在[清单 6-3](ch06.xhtml#ch6exe3)中所示）非常相似，使用它们时你几乎会遵循完全相同的步骤。
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-3:* `ReadProcessMemory()` *and* `WriteProcessMemory()` *prototypes*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-3：`ReadProcessMemory()` *和* `WriteProcessMemory()` *原型*'
- en: Both functions expect `Process` to be a process handle and `Address` to be the
    target memory address. When the function is reading from memory, `Buffer` is expected
    to point to an object that will hold the read data. When the function is writing
    to memory, `Buffer` is expected to point to the data to write. In both cases,
    `Size` defines the size of `Buffer`, in bytes. The final parameter to both functions
    is used to optionally return the number of bytes that were accessed; you can safely
    set it to `NULL`. Unless the function fails, the value returned in the final parameter
    should be equal to `Size`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数都期望 `Process` 是一个进程句柄，`Address` 是目标内存地址。当函数从内存中读取时，`Buffer` 应该指向一个对象，该对象将保存读取的数据。当函数向内存写入时，`Buffer`
    应该指向要写入的数据。在这两种情况下，`Size` 定义了 `Buffer` 的大小（以字节为单位）。两个函数的最后一个参数用于可选地返回已访问的字节数；你可以安全地将其设置为
    `NULL`。除非函数失败，否则返回的最终参数值应该等于 `Size`。
- en: '***Accessing a Value in Memory with ReadProcessMemory() and WriteProcessMemory()***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 ReadProcessMemory() 和 WriteProcessMemory() 访问内存中的值***'
- en: The code in [Listing 6-4](ch06.xhtml#ch6exe4) shows how you might use these
    functions to access a value in memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-4](ch06.xhtml#ch6exe4) 中的代码展示了如何使用这些函数来访问内存中的某个值。'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-4: Reading from and writing to process memory using the Windows
    API*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-4：使用 Windows API 读取和写入进程内存*'
- en: Before code like this appears in a program, you need to find the PID (`proc`)
    as described in “[Obtaining the Game’s Process Identifier](ch06.xhtml#ch00lev1sec120)”
    on [page 120](ch06.xhtml#page_120), as well as the memory address (`adr`) you
    want to read from or write to. With those values in place, the `ReadProcessMemory()`
    function stores a fetched value from memory in `val`. Then, the code increments
    `val` and replaces the original value by calling `WriteProcessMemory()`. After
    the write takes place, `ReadProcessMemory()` is called on the same address to
    confirm the new memory value. Notice that `val` isn’t actually a buffer. Passing
    `&val` as the `Buffer` parameter works because it can be a pointer to any static
    memory structure, as long as `Size` matches.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种代码出现在程序中之前，你需要找到 PID（`proc`），如在 “[获取游戏进程标识符](ch06.xhtml#ch00lev1sec120)”一节中所述（位于[第120页](ch06.xhtml#page_120)），以及你希望读取或写入的内存地址（`adr`）。有了这些值，`ReadProcessMemory()`
    函数将从内存中读取的值存储在 `val` 中。然后，代码会递增 `val` 并通过调用 `WriteProcessMemory()` 替换原始值。写入操作完成后，`ReadProcessMemory()`
    将再次调用相同的地址以确认新的内存值。注意，`val` 实际上并不是一个缓冲区。将 `&val` 作为 `Buffer` 参数传递是可行的，因为它可以是指向任何静态内存结构的指针，只要
    `Size` 匹配即可。
- en: '***Writing Templated Memory Access Functions***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写模板化内存访问函数***'
- en: Of course, the example in [Listing 6-4](ch06.xhtml#ch6exe4) assumes you already
    know what type of memory you’re dealing with, and it hardcodes the type as `DWORD`.
    To be a versatile game hacker, it’s better to have some generic code in your toolbox
    to avoid duplicating code for different types. Generic memory reading and writing
    functions that support different types might look like [Listing 6-5](ch06.xhtml#ch6exe5).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，[清单 6-4](ch06.xhtml#ch6exe4) 中的示例假设你已经知道所处理的内存类型，并且它将类型硬编码为 `DWORD`。为了成为一名多才多艺的游戏黑客，最好在工具箱中准备一些通用代码，以避免为不同类型重复编写代码。支持不同类型的通用内存读取和写入函数可能像[清单
    6-5](ch06.xhtml#ch6exe5)中展示的那样。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 6-5: Generic memory functions*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-5：通用内存函数*'
- en: These functions use C++ templates to accept arbitrary types as arguments. They
    allow you to access memory with whatever types you like in a very clean way. For
    example, given these `readMemory()` and `writeMemory()` templates I just showed,
    you could make the calls in [Listing 6-6](ch06.xhtml#ch6exe6).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数使用 C++ 模板来接受任意类型作为参数。它们允许你以非常简洁的方式访问内存中的各种类型。例如，基于我刚才展示的 `readMemory()`
    和 `writeMemory()` 模板，你可以在[清单 6-6](ch06.xhtml#ch6exe6)中调用这些函数。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 6-6: Calling templated memory access functions*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-6：调用模板化的内存访问函数*'
- en: Compare this to the calls to `WriteProcessMemory()` and `ReadProcessMemory()`
    in [Listing 6-4](ch06.xhtml#ch6exe4). This code still reads a value, increments
    it, and writes the new value to memory. But since the templated functions let
    you specify the type when you call them, you don’t need a new `readMemory()` and
    `writeMemory()` function for every data type you might need to work with. That’s
    much cleaner, since you’ll often want to work with all kinds of data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与 [示例 6-4](ch06.xhtml#ch6exe4) 中对 `WriteProcessMemory()` 和 `ReadProcessMemory()`
    的调用进行比较。这段代码仍然读取一个值，递增它，然后将新值写入内存。但是由于模板化函数允许你在调用时指定类型，因此你不需要为每种可能需要操作的数据类型创建一个新的
    `readMemory()` 和 `writeMemory()` 函数。这更加简洁，因为你通常希望处理各种数据。
- en: '**Memory Protection**'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内存保护**'
- en: When memory is allocated by a game (or any program), it is placed in a *page*.
    In x86 Windows, pages are chunks of 4,096 bytes that store data. Because all memory
    must be within a page, the minimal allocation unit is 4,096 bytes. The operating
    system can place memory chunks smaller than 4,096 bytes as a subset of an existing
    page that has enough uncommitted space, in a newly allocated page, or across two
    contiguous pages that have the same attributes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当内存被游戏（或任何程序）分配时，它会被放置在一个 *页面* 中。在 x86 Windows 中，页面是 4,096 字节的块，用于存储数据。由于所有内存必须在一个页面内，因此最小的分配单元为
    4,096 字节。操作系统可以将小于 4,096 字节的内存块作为已有页面中足够未提交空间的子集，放置在新分配的页面中，或跨越具有相同属性的两个连续页面。
- en: Memory chunks 4,096 bytes or larger span *n* pages, where *n* is
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 内存块为 4,096 字节或更大的范围，跨越 *n* 页，其中 *n* 是
- en: '![image](../images/f0124-01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0124-01.jpg)'
- en: The operating system typically looks for room in existing pages when allocating
    memory, but it allocates new pages on demand if necessary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通常在分配内存时会查找已有页面中的空闲空间，但如果必要，它会按需分配新页面。
- en: '**NOTE**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s also possible for large chunks to span* n *+ 1 pages, as there’s no guarantee
    that a chunk begins at the start of a page.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于大块数据，也可能跨越* n *+ 1 页，因为没有保证数据块从页面的开始处开始。*'
- en: 'The important thing to understand about memory pages is that each page has
    a set of specific attributes. Most of these attributes are transparent in user
    mode, but there’s one you should be extra conscious of when working with memory:
    protection.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内存页面，重要的是要理解每个页面都有一组特定的属性。这些属性在用户模式下大多数是透明的，但有一个在操作内存时你应该特别注意的属性：保护。
- en: '***Differentiating x86 Windows Memory Protection Attributes***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***区分 x86 Windows 内存保护属性***'
- en: The memory-reading techniques you’ve learned so far are very basic. They assume
    that the memory you’re accessing is protected with the `PAGE_READWRITE` attribute.
    While this assumption is correct for variable data, other types of data exist
    on pages with different types of protection. [Table 6-1](ch06.xhtml#ch6tab1) describes
    the different types of memory protection in x86 Windows.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你学到的内存读取技术非常基础。它们假设你访问的内存是用 `PAGE_READWRITE` 属性保护的。虽然这种假设对于变量数据是正确的，但还有其他类型的数据存在于具有不同保护类型的页面上。[表
    6-1](ch06.xhtml#ch6tab1) 描述了 x86 Windows 中不同类型的内存保护。
- en: '**Table 6-1:** Memory Protection Types'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：** 内存保护类型'
- en: '| **Protection type** | **Value** | **Read permission?** | **Write permission?**
    | **Execute permission?** | **Special permissions?** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **保护类型** | **值** | **读取权限？** | **写入权限？** | **执行权限？** | **特殊权限？** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `PAGE_NOACCESS` | 0x01 | No | No | No |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `PAGE_NOACCESS` | 0x01 | 否 | 否 | 否 |  |'
- en: '| `PAGE_READONLY` | 0x02 | Yes | No | No |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `PAGE_READONLY` | 0x02 | 是 | 否 | 否 |  |'
- en: '| `PAGE_READWRITE` | 0x04 | Yes | No | No |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `PAGE_READWRITE` | 0x04 | 是 | 否 | 否 |  |'
- en: '| `PAGE_WRITECOPY` | 0x08 | Yes | Yes | No | Yes, copy on write |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `PAGE_WRITECOPY` | 0x08 | 是 | 是 | 否 | 是，写时复制 |'
- en: '| `PAGE_EXECUTE` | 0x10 | No | No | Yes |  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `PAGE_EXECUTE` | 0x10 | 否 | 否 | 是 |  |'
- en: '| `PAGE_EXECUTE_READ` | 0x20 | Yes | No | Yes |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `PAGE_EXECUTE_READ` | 0x20 | 是 | 否 | 是 |  |'
- en: '| `PAGE_EXECUTE_READWRITE` | 0x40 | Yes | Yes | Yes |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `PAGE_EXECUTE_READWRITE` | 0x40 | 是 | 是 | 是 |  |'
- en: '| `PAGE_EXECUTE_WRITECOPY` | 0x80 | Yes | Yes | Yes | Yes, copy on write |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `PAGE_EXECUTE_WRITECOPY` | 0x80 | 是 | 是 | 是 | 是，写时复制 |'
- en: '| `PAGE_GUARD` | 0x100 | No | No | No | Yes, guard page |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `PAGE_GUARD` | 0x100 | 否 | 否 | 否 | 是，保护页 |'
- en: If a protection type in [Table 6-1](ch06.xhtml#ch6tab1) has a *Yes* in any permission
    column, it means the action in question can be performed on that page of memory.
    For example, if a page is `PAGE_READONLY`, then a program can read the memory
    on that page, but the program cannot write to that memory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [表 6-1](ch06.xhtml#ch6tab1) 中的某个保护类型在任何权限列中标有*是*，则意味着可以在该内存页上执行相关操作。例如，如果一个页面是
    `PAGE_READONLY`，则程序可以读取该页面的内存，但不能写入该内存。
- en: Constant strings, for example, are usually stored with `PAGE_READONLY` protection.
    Other constant data, such as virtual function tables and a module’s entire *Portable
    Executable (PE)* header (which contains information about a program, such as the
    kind of application it is, library functions it uses, its size, and so on), are
    also stored on read-only pages. Assembly code, on the other hand, is stored on
    pages protected with `PAGE_EXECUTE_READ`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，常量字符串通常使用 `PAGE_READONLY` 保护存储。其他常量数据，如虚拟函数表和一个模块的整个*可移植执行文件（PE）*头部（其中包含关于程序的信息，如它是哪种类型的应用程序、使用了哪些库函数、它的大小等）也存储在只读页面上。而汇编代码则存储在使用
    `PAGE_EXECUTE_READ` 保护的页面上。
- en: Most protection types involve only some combination of read, write, and execute
    protection. For now, you can safely ignore special protection types; I cover them
    in “Special Protection Types” on [page 126](ch06.xhtml#page_126) if you’re curious,
    but only very advanced hacks will ever require knowledge of them. The basic protection
    types, though, will be prevalent in your game-hacking adventures.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数保护类型仅涉及读、写和执行保护的某种组合。目前，你可以安全地忽略特殊的保护类型；如果你感兴趣，可以在 [第 126 页](ch06.xhtml#page_126)的“特殊保护类型”中了解，我在其中有详细讲解，但只有非常高级的黑客才需要了解它们。然而，基本的保护类型在你的游戏黑客之旅中将会是常见的。
- en: '**SPECIAL PROTECTION TYPES**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**特殊保护类型**'
- en: Two protection types in [Table 6-1](ch06.xhtml#ch6tab1) include *copy-on-write*
    protection. When multiple processes have pages of memory that are identical (such
    as pages with mapped system DLLs), copy-on-write protection is used to conserve
    memory. The actual data is stored in only one physical place, and the operating
    system virtually maps all memory pages containing that data to the physical location.
    If a process sharing the memory makes a change to it, a copy of the data will
    be made in physical memory, the change will be applied, and the memory page(s)
    for that process will be remapped to the new physical memory. When a copy on write
    happens, the protection for all affected pages changes accordingly; `PAGE_WRITECOPY`
    will become `PAGE_READWRITE`, and `PAGE_EXECUTE_WRITECOPY` will become `PAGE_EXECUTE_READWRITE`.
    I’ve found no game hacking–specific uses for copy-on-write pages, but it’s useful
    to understand them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-1](ch06.xhtml#ch6tab1) 中的两种保护类型包括*写时复制*保护。当多个进程拥有相同的内存页（例如，映射的系统 DLL 页）时，使用写时复制保护来节省内存。实际数据只存储在一个物理位置，操作系统会虚拟映射所有包含该数据的内存页到物理位置。如果一个共享内存的进程对数据进行了修改，数据会在物理内存中创建一份副本，修改会应用到这份副本，且该进程的内存页会被重新映射到新的物理内存。当写时复制发生时，所有受影响的页面的保护会相应地发生变化；`PAGE_WRITECOPY`
    会变成 `PAGE_READWRITE`，而 `PAGE_EXECUTE_WRITECOPY` 会变成 `PAGE_EXECUTE_READWRITE`。我没有发现写时复制页在游戏黑客中的特定用途，但了解它们是很有帮助的。'
- en: Pages can also be created with *guard* protection. Guarded pages must have a
    secondary protection, defined like `PAGE_GUARD | PAGE_READONLY`. When the program
    tries to access a guarded page, the operating system will throw a `STATUS_GUARD_PAGE_VIOLATION`
    exception. Once the exception is handled, the guard protection is removed from
    the page, leaving only the secondary protection. One way in which the operating
    system uses this type of protection is to dynamically expand the call stack by
    placing a guarded page at the top and allocating more memory when that guarded
    page is hit. Some memory analysis tools place guarded pages after heap memory
    to detect heap corruption bugs. In the context of game hacking, a guarded page
    can be used as a trip wire that tells you when a game might be attempting to detect
    your code within its memory.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 页还可以使用*保护*保护。保护页面必须具有二级保护，例如 `PAGE_GUARD | PAGE_READONLY`。当程序尝试访问受保护的页面时，操作系统会抛出
    `STATUS_GUARD_PAGE_VIOLATION` 异常。一旦异常被处理，保护将从页面中移除，只剩下二级保护。操作系统使用此类保护的一种方式是通过在栈顶放置受保护页面，并在该受保护页面被访问时动态扩展调用栈，分配更多内存。一些内存分析工具会将保护页放置在堆内存之后，以检测堆损坏漏洞。在游戏黑客的背景下，受保护的页面可以作为一个触发器，当游戏可能尝试检测你的代码时，告诉你其内存中的变化。
- en: '***Changing Memory Protection***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更改内存保护***'
- en: 'When you want to hack a game, you’ll sometimes need to access memory in a way
    that is forbidden by the memory page’s protection, making it important to be able
    to change memory protection at will. Luckily, the Windows API provides the `VirtualProtectEx()`
    function for this purpose. This is the function’s prototype:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要破解游戏时，有时需要以内存页保护所禁止的方式访问内存，这使得能够随意更改内存保护变得非常重要。幸运的是，Windows API提供了`VirtualProtectEx()`函数来实现这一目的。该函数的原型如下：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The parameters `Process`, `Address`, and `Size` take the same input as they
    do in the `ReadProcessMemory()` and `WriteProcessMemory()` functions. `NewProtect`
    should specify the new protection flags for the memory, and `OldProtect` can optionally
    point to a `DWORD` where the old protection flags will be stored.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`Process`、`Address`和`Size`与`ReadProcessMemory()`和`WriteProcessMemory()`函数中的输入相同。`NewProtect`应指定内存的新保护标志，而`OldProtect`则可以选择指向一个`DWORD`，其中存储旧的保护标志。
- en: The most granular scale for memory protection is per page, which means `VirtualProtectEx()`
    will set the new protection to every page that is on or between `Address` and
    `Address + Size - 1`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 内存保护的最细粒度是按页进行的，这意味着`VirtualProtectEx()`会将新的保护设置为`Address`与`Address + Size -
    1`之间的每一页。
- en: '**NOTE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* `VirtualProtectEx()` *function has a sister called* `VirtualProtect()`*.
    They work the same way, but* `VirtualProtect()` *operates only on the process
    calling it and, thus, does not have a process handle parameter.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*`VirtualProtectEx()`* *函数有一个姐妹函数叫做* `VirtualProtect()`*。它们的工作方式相同，但* `VirtualProtect()`
    *只对调用它的进程起作用，因此没有进程句柄参数。*'
- en: When you’re writing your own code to change memory protections, I suggest making
    it flexible by creating a template. A generic wrapped function for `VirtualProtectEx()`
    should look something like [Listing 6-7](ch06.xhtml#ch6exe7).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写自己的代码来更改内存保护时，我建议通过创建一个模板来使其灵活。`VirtualProtectEx()`的通用包装函数应类似于[清单6-7](ch06.xhtml#ch6exe7)。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 6-7: A generic function to change memory protection*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-7：更改内存保护的通用函数*'
- en: 'With this template in place, if you wanted to, say, write a `DWORD` to a memory
    page without write permission, you might do something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板的基础上，如果你想，比如说，将一个`DWORD`写入一个没有写权限的内存页，你可能会做如下操作：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, this sets the protection on the memory to change to `PAGE_READWRITE`.
    With write permission granted, the door is open to call `writeMemory()` and change
    the data at `address`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这段代码将内存的保护设置为`PAGE_READWRITE`。在授予写权限后，就可以调用`writeMemory()`并更改`address`处的数据。
- en: When you’re changing memory protection, it’s best practice to let the change
    persist only as long as needed and restore the original protection as soon as
    possible. This is less efficient, but it ensures that a game doesn’t detect your
    bot (for example, by noticing that some of its assembly code pages have become
    writable).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改内存保护时，最佳实践是让变更仅在需要时生效，并尽快恢复原始保护。这虽然效率较低，但可以确保游戏不会检测到你的机器人（例如，通过注意到其某些汇编代码页已变为可写）。
- en: 'A typical write operation on read-only memory should look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对只读内存进行典型写操作应如下所示：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code calls the `protectMemory()` function from [Listing 6-7](ch06.xhtml#ch6exe7)
    to change the protection to `PAGE_READWRITE`. It then writes `newValue` to the
    memory before changing the protection back to `oldProt`, which was set to the
    page’s original protection by the initial call to `protectMemory()`. The `writeMemory()`
    function used here is the same one defined in [Listing 6-5](ch06.xhtml#ch6exe5).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码调用[清单6-7](ch06.xhtml#ch6exe7)中的`protectMemory()`函数，将保护更改为`PAGE_READWRITE`。然后，它将`newValue`写入内存，之后再将保护恢复为`oldProt`，该值在最初调用`protectMemory()`时被设置为页面的原始保护。这里使用的`writeMemory()`函数与[清单6-5](ch06.xhtml#ch6exe5)中定义的相同。
- en: A final important point is that when you’re manipulating a game’s memory, it’s
    entirely possible that the game will access the memory at the same time as you.
    If the new protection that you set is not compatible with the original protection,
    the game process will get an `ACCESS_VIOLATION` exception and crash. For instance,
    if you change memory protection from `PAGE_EXECUTE` to `PAGE_READWRITE`, the game
    might try to execute the code on the page(s) when the memory is not marked as
    executable. In this case, you’d want to instead set the memory protection to `PAGE_EXECUTE_READWRITE`
    to ensure that you can operate on the memory while still allowing the game to
    execute it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最终重要的点是，当你操作游戏的内存时，完全有可能游戏会在你操作内存的同时访问它。如果你设置的新保护与原始保护不兼容，游戏进程将出现 `ACCESS_VIOLATION`
    异常并崩溃。例如，如果你将内存保护从 `PAGE_EXECUTE` 更改为 `PAGE_READWRITE`，当内存没有标记为可执行时，游戏可能会尝试在该页执行代码。在这种情况下，你应该将内存保护设置为
    `PAGE_EXECUTE_READWRITE`，以确保在允许游戏执行代码的同时，你也能操作内存。
- en: '**Address Space Layout Randomization**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**地址空间布局随机化**'
- en: So far, I’ve described memory addresses as static integers that change only
    as the binary changes. This model is correct on Windows XP and earlier. On later
    Windows systems, however, memory addresses are only static relative to the base
    address of the game binary, because these systems enable a feature called *address
    space layout randomization (ASLR)* for supported binaries. When a binary is compiled
    with ASLR support (enabled by default on MSVC++ 2010 and many other compilers),
    its base address can be different every time it is run. Conversely, non-ASLR binaries
    will always have a base address of 0x400000.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我描述的内存地址是静态整数，只有在二进制文件发生变化时才会改变。这个模型在 Windows XP 及之前的版本中是正确的。然而，在后来的 Windows
    系统中，内存地址相对游戏二进制文件的基地址是静态的，因为这些系统为支持的二进制文件启用了名为*地址空间布局随机化（ASLR）*的特性。当一个二进制文件编译时支持
    ASLR（在 MSVC++ 2010 和许多其他编译器中默认启用），它的基地址每次运行时可能都不同。相反，非 ASLR 的二进制文件将始终具有基地址 0x400000。
- en: '**NOTE**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Since ASLR doesn’t work on XP, I’ll call 0x400000 the* XP-base.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于 ASLR 在 XP 上不起作用，我将 0x400000 称为* XP 基地址。'
- en: '***Disabling ASLR to Simplify Bot Development***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***禁用 ASLR 简化机器人开发***'
- en: 'To keep development simple, you can disable ASLR and use addresses with the
    transparent XP-base. To do so, enter a single command in the Visual Studio Command
    Prompt:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持开发简单，你可以禁用 ASLR 并使用透明的 XP 基地址。为此，你只需在 Visual Studio 命令提示符下输入一个命令：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To re-enable it, enter:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新启用它，请输入：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***Bypassing ASLR in Production***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绕过生产环境中的 ASLR***'
- en: 'Disabling ASLR is suitable for bot development, but it is a no-no for production;
    end users cannot be expected to turn off ALSR. Instead, you can write a function
    to dynamically rebase addresses at runtime. If you use addresses with the XP-base,
    the code to do a rebase would look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用 ASLR 适合机器人开发，但不适用于生产环境；不能指望最终用户关闭 ALSR。相反，你可以编写一个函数，在运行时动态重新基址。如果使用带有 XP
    基地址的地址，执行重新基址的代码如下：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you know the base address of the game (`newBase`), this function allows
    you to essentially ignore ASLR by rebasing `address`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道游戏的基地址（`newBase`）时，使用此函数可以通过重新基址 `address` 来基本忽略 ASLR。
- en: To find `newBase`, however, you need to use the `GetModuleHandle()` function.
    When the parameter to `GetModuleHandle()` is `NULL`, it always returns a handle
    to the main binary in a process. The function’s returned type is `HMODULE`, but
    the value is actually just the address where the binary is mapped. This is the
    base address, so you can directly cast it to a `DWORD` to get `newBase`. Since
    you’re looking for the base address in another process, though, you need a way
    to execute the function in the context of that process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要找到 `newBase`，你需要使用 `GetModuleHandle()` 函数。当 `GetModuleHandle()` 的参数为 `NULL`
    时，它总是返回一个指向进程主二进制文件的句柄。该函数返回的类型是 `HMODULE`，但实际返回的值就是二进制文件映射的地址。这就是基地址，因此你可以直接将其转换为
    `DWORD` 来获取 `newBase`。不过，由于你是在另一个进程中寻找基地址，你需要一种方法来在该进程的上下文中执行此函数。
- en: To do this, call `GetModuleHandle()` using the `CreateRemoteThread()` API function,
    which can be used to spawn threads and execute code in a remote process. It has
    the prototype shown in [Listing 6-8](ch06.xhtml#ch6exe8).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，调用 `GetModuleHandle()`，使用 `CreateRemoteThread()` API 函数，这个函数可以用来生成线程并在远程进程中执行代码。它的原型见
    [清单 6-8](ch06.xhtml#ch6exe8)。
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-8: A function that spawns a thread*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-8：一个生成线程的函数*'
- en: The spawned thread will start execution on `StartAddress`, treating it as a
    single-parameter function with `Param` as input and setting the value returned
    as the thread exit code. This is ideal, as the thread can be started with `StartAddress`
    pointing to the address of `GetModuleHandle()` and `Param` set to `NULL`. You
    can then use the API function `WaitForSingleObject()` to wait until the thread
    is done executing and get the returned base address using the API function `GetExitCodeThread()`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 被创建的线程将从 `StartAddress` 开始执行，将其视为一个单参数函数，`Param` 作为输入，并将返回的值设置为线程的退出代码。这是理想的，因为线程可以通过
    `StartAddress` 指向 `GetModuleHandle()` 的地址，并将 `Param` 设置为 `NULL` 来启动。然后，你可以使用 API
    函数 `WaitForSingleObject()` 等待线程执行完成，并使用 API 函数 `GetExitCodeThread()` 获取返回的基地址。
- en: Once all of these things are tied together, the code to get `newBase` from an
    external bot should look like [Listing 6-9](ch06.xhtml#ch6exe9).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些操作结合起来，从外部机器人获取 `newBase` 的代码应该像 [Listing 6-9](ch06.xhtml#ch6exe9) 一样。
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 6-9: Finding the base address of a game with API functions*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-9：使用 API 函数查找游戏的基地址*'
- en: The `GetModuleHandle()` function is part of *kernel32.dll*, which has the same
    base address in every process, so first this code gets the address for *kernel32.dll*.
    Since the base address of *kernel32.dll* is the same in every process, the address
    of `GetModuleHandle()` will be the same in the game as it is in the external bot.
    Given the base address of *kernel32.dll*, this code finds the address of `GetModuleHandle()`
    easily with the API function `GetProcAddress()`. From there, it calls the `CreateRemoteThread()`
    function from [Listing 6-8](ch06.xhtml#ch6exe8), lets the thread do its job, and
    fetches the exit code to obtain `newBase`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetModuleHandle()` 函数是 *kernel32.dll* 的一部分，该 DLL 在每个进程中都有相同的基地址，因此首先这段代码获取
    *kernel32.dll* 的地址。由于 *kernel32.dll* 的基地址在每个进程中相同，`GetModuleHandle()` 的地址在游戏中和外部机器人中也是一样的。给定
    *kernel32.dll* 的基地址，这段代码通过 API 函数 `GetProcAddress()` 很容易找到 `GetModuleHandle()`
    的地址。接着，它调用 [Listing 6-8](ch06.xhtml#ch6exe8) 中的 `CreateRemoteThread()` 函数，让线程执行任务，并获取退出码以获得
    `newBase`。'
- en: '**Closing Thoughts**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: Now that you’ve seen how to manipulate memory from your own code, I’ll show
    you how to apply the skills from Parts I and II to games. These skills are paramount
    to the concepts you’ll explore in the coming chapters, so make sure you have a
    firm grasp on what’s happening. If you’re having trouble, play with the example
    code as you review concepts, as it provides a safe sandbox for testing and tweaking
    how the methods in this and earlier chapters behave.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何从自己的代码中操作内存，我将向你展示如何将第一和第二部分中的技能应用于游戏。这些技能对于你将在接下来的章节中探索的概念至关重要，因此请确保你牢牢掌握正在发生的事情。如果你遇到困难，在复习概念时可以尝试修改示例代码，它为测试和调整本章及早期章节中的方法提供了一个安全的沙盒环境。
- en: The way [Listing 6-9](ch06.xhtml#ch6exe9) tricks the game into executing `GetModuleHandle()`
    is a form of code injection. But that’s just a glimpse into what injection can
    do. If you’re excited to learn more about it, dive into [Chapter 7](ch07.xhtml#ch07),
    which explores this topic in detail.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 6-9](ch06.xhtml#ch6exe9) 通过使游戏执行 `GetModuleHandle()` 来进行的操作是一种代码注入方式。但这仅仅是注入技术能做的一部分。如果你对学习更多注入内容感兴趣，可以深入研究
    [第7章](ch07.xhtml#ch07)，该章节将详细探讨这一主题。'
