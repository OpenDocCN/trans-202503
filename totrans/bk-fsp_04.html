<html><head></head><body><section class="chapter" title="Chapter&#xA0;4.&#xA0;Staying Objective" epub:type="chapter" id="staying_objective"><div class="titlepage"><div><div><h2 class="title">Chapter 4. Staying Objective</h2></div></div></div><p>For years, <span class="emphasis"><em>object-oriented (OO)</em></span> development has been the de facto standard for developing business software, particularly within the enterprise, so you’re probably familiar with many of its core principles. It should come as no surprise that as a .NET language, F# supports the full cast of constructs—including classes, structs, and interfaces—available in the other .NET languages. Despite its reputation as a niche language useful only for academic exercises or highly specialized software, F#’s general-purpose, multiparadigm nature makes it suitable for most development situations. With C# and Visual Basic already well established, though, why choose F# as an OO language?</p><p>A large part of the decision rests on F#’s terse syntax, but features like type inference, object expressions, and the ability to combine object-oriented and functional styles make a strong argument, too. Let’s face it, though: Even if you’re developing in a primarily functional manner, when you’re developing software on the .NET Framework you’re going to have to work with objects at some point; that’s just the nature of the platform.</p><p><a id="iddle1231" class="indexterm"/><a id="iddle1264" class="indexterm"/><a id="iddle1266" class="indexterm"/><a id="iddle1302" class="indexterm"/><a id="iddle2053" class="indexterm"/>In this chapter, you’ll learn how to create OO constructs in F# with less code, yet still build robust frameworks that can hold their own against similar frameworks built with more dedicated OO languages.</p><div class="sect1" title="Classes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="classes">Classes</h2></div></div></div><p>Conceptually, classes in F# are identical to classes in other OO languages in that they encapsulate related data and behavior as fields, properties, methods, and events (collectively called <span class="emphasis"><em>members</em></span>) to model real-world objects or concepts. Like classes in C# and Visual Basic, F# classes are reference types that support single inheritance and multiple interface implementation, and can control access to their members. As with all user-defined data types in F#, you declare classes with the <code class="literal">type</code> keyword. (Rather than requiring different keywords for every data type you can create, the compiler infers the construct based on its structure.)</p><p>To illustrate, let’s take another look at the class definition introduced in the type inference discussion in <a class="xref" href="ch03.html" title="Chapter 3. Fundamentals">Chapter 3</a>.</p><a id="pro_id00129"/><pre class="programlisting">type Person (id : Guid, name : string, age : int) =
  member x.Id = id
  member x.Name = name
  member x.Age = age</pre><p>There’s a lot of definition packed into this example. In just four lines, there’s a class with a <span class="emphasis"><em>primary constructor</em></span> with three arguments and three implicit, read-only properties! While quite a departure from the other .NET languages, this terseness is just one of the ways that F# distinguishes itself.</p><div class="sect2" title="Constructors"><div class="titlepage"><div><div><h3 class="title" id="constructors">Constructors</h3></div></div></div><p>Constructors are the means by which new class instances are created and initialized. They’re really specialized functions that return fully initialized class instances. Classes in F# do not require a constructor, as shown here:</p><a id="pro_id00130"/><pre class="programlisting">type ConstructorlessClass = class end</pre><p>The empty class in this example is valid F# but, unlike in C#, if you don’t define a constructor, the compiler won’t automatically generate a <span class="emphasis"><em>default constructor</em></span> (a constructor with no parameters). Since a memberless class that you can’t instantiate is pretty useless, your classes will typically have at least one constructor and one member.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note01"/>Note</h3><p><span class="emphasis"><em>One reason you might choose to omit the constructor is that each of the type’s members is static; that is, it applies to the type rather than an individual instance. We’ll examine static members in detail a bit later in this chapter.</em></span></p></div><p><a id="iddle1267" class="indexterm"/><a id="iddle1674" class="indexterm"/><a id="iddle1777" class="indexterm"/>As with other OO languages, you create new class instances by invoking a constructor. In the case of our <code class="literal">Person</code> class there’s only one constructor, so the choice is clear.</p><a id="pro_id00131"/><pre class="programlisting">let me = <span class="strong"><strong>Person(Guid.NewGuid(), "Dave", 33)</strong></span></pre><p>Using the <code class="literal">new</code> keyword to create a new class instance is optional. By convention, you use the <code class="literal">new</code> keyword only when creating an instance of a class that implements the <code class="literal">IDisposable</code> interface.</p><p>F# constructors come in two flavors: primary constructors and additional constructors.</p><div class="sect3" title="Primary Constructors"><div class="titlepage"><div><div><h4 class="title" id="primary_constructors">Primary Constructors</h4></div></div></div><p>F# classes can have a <span class="emphasis"><em>primary constructor</em></span> whose arguments are embedded within the type definition itself. The primary constructor’s body contains a series of <code class="literal">let</code> and <code class="literal">do</code> bindings that represent the class’s field definitions and initialization code.</p><a id="pro_id00132"/><pre class="programlisting">type Person  ①(name : string, dob : System.DateTime) =
② let age = (System.DateTime.Now - dob).TotalDays / 365.25
③ do printfn "Creating person: %s (Age: %f)" name age
  member x.Name = name
  member x.DateOfBirth = dob
  member x.Age = age</pre><p>In this example, the primary constructor includes the parameter list with type annotations ①, a single field definition for the calculated age ②, and a <code class="literal">do</code> binding ③ that prints the person’s name and age when the object is constructed. All of the primary constructor’s parameters are automatically available as fields throughout your class, so there’s no need to explicitly map them.</p><p>The compiler can frequently infer the types for each constructor parameter, so there’s often no need to include explicit type annotations. In the preceding example, a type annotation (or one on an intermediate binding with a type annotation) would still be needed for the <code class="literal">dob</code> parameter so the compiler can resolve the correct subtract operator overload. However, that’s more the exception than the rule, as shown in the next example, where the compiler can infer the types for both the <code class="literal">name</code> and <code class="literal">age</code> parameters as <code class="literal">string</code> and <code class="literal">int</code>, respectively.</p><a id="pro_id00133"/><pre class="programlisting">type Person (name, age) =
  do printfn "Creating person: %s (Age: %i)" name age
  member x.Name = name
  member x.Age = age

let me = Person ("Dave", 33)</pre><p><a id="iddle1084" class="indexterm"/><a id="iddle1085" class="indexterm"/><a id="iddle1087" class="indexterm"/><a id="iddle1090" class="indexterm"/><a id="iddle1091" class="indexterm"/><a id="iddle1100" class="indexterm"/><a id="iddle1265" class="indexterm"/><a id="iddle1542" class="indexterm"/><a id="iddle1673" class="indexterm"/><a id="iddle1757" class="indexterm"/><a id="iddle1780" class="indexterm"/><a id="iddle1793" class="indexterm"/><a id="iddle1794" class="indexterm"/><a id="iddle1924" class="indexterm"/>By default, the primary constructor is public, but you can change that by including an access modifier before the parameter list. You might consider changing the primary constructor’s accessibility if you were implementing the <span class="emphasis"><em>Singleton pattern</em></span>, which specifies that only a single instance of the type can exist, as shown here:</p><a id="pro_id00134"/><pre class="programlisting">type Greeter <span class="strong"><strong>private</strong></span> () =
  static let _instance = lazy (Greeter())
  static member Instance with get() = _instance.Force()
  member x.SayHello() = printfn "hello"

Greeter.Instance.SayHello()</pre><div class="sidebar"><a id="more_about_accessibility_in_fhash"/><div class="sidebar-title">More About Accessibility in F#</div><p><span class="emphasis"><em>Access modifiers</em></span> limit the scope of bindings, types, and members throughout your program. F# differs from C# and Visual Basic in that it directly supports only the <code class="literal">public</code>, <code class="literal">private</code>, and <code class="literal">internal</code> modifiers. You can’t define <code class="literal">protected</code> class members in F# due in part to how they complicate the functional nature of the language. F# does still honor <code class="literal">protected</code> members defined in other languages, so they won’t be publicly accessible and you can still override them in derived classes without breaking the abstraction.</p></div></div><div class="sect3" title="Additional Constructors"><div class="titlepage"><div><div><h4 class="title" id="additional_constructors">Additional Constructors</h4></div></div></div><p>Constructors that you define beyond the primary constructor are called <span class="emphasis"><em>additional constructors</em></span>. Additional constructors are defined with the <code class="literal">new</code> keyword followed by a parameter list and constructor body, as shown next. While additional constructors must always invoke the primary constructor, they may do so indirectly through another constructor, thereby allowing you to chain constructor calls.</p><a id="pro_id00135"/><pre class="programlisting">type Person (name, age) =
  do printfn "Creating person: %s (Age: %i)" name age
  <span class="strong"><strong>new (name) = Person(name, 0)</strong></span>
  <span class="strong"><strong>new () = Person("")</strong></span>
  member x.Name = name
  member x.Age = age</pre><p>Additional constructors can contain their own <code class="literal">let</code> bindings and other expressions, but unlike those in the primary constructor, any such elements will be local to the constructor where they’re defined rather than exposed as fields.</p><p><a id="iddle1157" class="indexterm"/><a id="iddle1268" class="indexterm"/><a id="iddle1305" class="indexterm"/><a id="iddle1869" class="indexterm"/><a id="iddle2017" class="indexterm"/><a id="iddle2095" class="indexterm"/>Additional constructors can invoke additional code like a primary constructor, but instead of using a <code class="literal">do</code> binding they use the <code class="literal">then</code> keyword. In this example, each additional constructor includes the <code class="literal">then</code> keyword in order to print a message indicating which constructor is being invoked.</p><a id="pro_id00136"/><pre class="programlisting">type Person (name, age) =
  do printfn "Creating person: %s (Age: %i)" name age
  new (name) = Person(name, 0)
               <span class="strong"><strong>then printfn "Creating person with default age"</strong></span>
  new () = Person("")
           <span class="strong"><strong>then printfn "Creating person with default name and age"</strong></span>
  member x.Name = name
  member x.Age = age</pre><p>Classes without a primary constructor behave a bit differently at initialization. When you use them, you must explicitly define fields with the <code class="literal">val</code> keyword, and any additional constructors must initialize any fields not decorated with the <code class="literal">DefaultValue</code> attribute, as shown here:</p><a id="pro_id00137"/><pre class="programlisting">type Person =
  val _name : string
  val _age : int
  new (name, age) = { _name = name; _age = age }
  new (name) = Person(name, 0)
  new () = Person("")
  member x.Name = x._name
  member x.Age = x._age</pre></div><div class="sect3" title="Self-Identifiers"><div class="titlepage"><div><div><h4 class="title" id="self-id00005">Self-Identifiers</h4></div></div></div><p>Sometimes you’ll want to reference a class member within a constructor. By default, class members aren’t accessible because they require a recursive reference to the type, but you can enable <span class="emphasis"><em>self-referencing</em></span> with the <code class="literal">as</code> keyword and a <span class="emphasis"><em>self-identifier</em></span> like this:</p><a id="pro_id00138"/><pre class="programlisting">type Person (name, age) <span class="strong"><strong>as this</strong></span> =
  do printfn "Creating person: %s (Age: %i)" this.Name this.Age
  member x.Name = name
  member x.Age = age</pre><p>You can choose any name for your self-identifiers as long as you follow the normal rules for identifiers. You could even use a quoted identifier like the following ones if you really want to irritate your future self or anyone else who’s maintaining your code.</p><a id="pro_id00139"/><pre class="programlisting">type Person (name, age) as <span class="strong"><strong>``This is a bad identifier``</strong></span> =
  do
    printfn "Creating person: %s (Age: %i)"
      <span class="strong"><strong>``This is a bad identifier``.Name</strong></span>
      <span class="strong"><strong>``This is a bad identifier``.Age</strong></span>
      member x.Name = name
      member x.Age = age</pre><p><a id="iddle1423" class="indexterm"/><a id="iddle1424" class="indexterm"/><a id="iddle1425" class="indexterm"/><a id="iddle2096" class="indexterm"/>It’s generally best to stick with short names. Common conventions are to use either <code class="literal">x</code> or <code class="literal">this</code>. But whatever you choose, be consistent!</p><div class="warning" title="Warning" epub:type="warning"><h3 class="title"><a id="ch04note02"/>Warning</h3><p><span class="emphasis"><em>The compiler will generate a warning if you define a self-identifier but don’t use it in your constructor. The reason is that using the as keyword makes the class definition recursive, which results in additional run time validation that can negatively impact initializing types in your class hierarchy. Use self-identifiers in primary constructors only when you actually need them.</em></span></p></div></div></div><div class="sect2" title="Fields"><div class="titlepage"><div><div><h3 class="title" id="fields">Fields</h3></div></div></div><p>Fields define the data elements associated with an object. In the previous section, we took a brief look at both ways to create fields. In this section, we’ll examine field creation in more detail.</p><div class="sect3" title="let Bindings"><div class="titlepage"><div><div><h4 class="title" id="let_bindings-id00006">let Bindings</h4></div></div></div><p>The first way to create fields is with <code class="literal">let</code> bindings in the primary constructor. These fields, which must be initialized in the primary constructor, are <span class="emphasis"><em>always</em></span> private to the class. Although they must be initialized when they’re created, you can make the value mutable as in any <code class="literal">let</code> binding, as shown here:</p><a id="pro_id00140"/><pre class="programlisting">type Person () =
  <span class="strong"><strong>let mutable name : string = ""</strong></span>
  member x.Name
    with get() = name
    and set(v) = name &lt;- v</pre><p>Here, a mutable <code class="literal">let</code> binding is used to define the backing store for the <code class="literal">Name</code> property.</p></div><div class="sect3" title="Explicit Fields"><div class="titlepage"><div><div><h4 class="title" id="explicit_fields">Explicit Fields</h4></div></div></div><p>When you want a little more control over a field or your class doesn’t have a primary constructor, create an explicit field with the <code class="literal">val</code> keyword. Explicit fields don’t need to be initialized immediately, but in classes with a primary constructor you’ll need to decorate them with the <code class="literal">DefaultValue</code> attribute to ensure that the value is initialized to its appropriate “zero” value, like this:</p><a id="pro_id00141"/><pre class="programlisting">type Person () =
  <span class="strong"><strong>[&lt;DefaultValue&gt;] val mutable n : string</strong></span>
  member x.Name
    with get() = x.n
    and set(v) = x.n &lt;- v</pre><p><a id="iddle1088" class="indexterm"/><a id="iddle1093" class="indexterm"/><a id="iddle1373" class="indexterm"/><a id="iddle1638" class="indexterm"/><a id="iddle1781" class="indexterm"/><a id="iddle1785" class="indexterm"/><a id="iddle1787" class="indexterm"/>In this example, <code class="literal">n</code> is an explicit field. Because <code class="literal">n</code> is of type <code class="literal">string</code>, it’s initialized to <code class="literal">null</code>, as you can see here:</p><a id="pro_id00142"/><pre class="programlisting">&gt; <span class="strong"><strong>let p = Person()</strong></span>
p.Name;;

val p : Person
val it : string = null</pre><p>Explicit fields are public by default, but you can make them private by including the <code class="literal">private</code> access modifier in the definition like this:</p><a id="pro_id00143"/><pre class="programlisting">type Person () =
  [&lt;DefaultValue&gt;] val mutable <span class="strong"><strong>private</strong></span> n : string
  -- <span class="emphasis"><em>snip</em></span> --</pre></div></div><div class="sect2" title="Properties"><div class="titlepage"><div><div><h3 class="title" id="properties">Properties</h3></div></div></div><p>Like fields, <span class="emphasis"><em>properties</em></span> represent data associated with an object. Unlike fields, though, properties offer more control over how that data is accessed or modified by exposing the actions through some combination of <code class="literal">get</code> and/or <code class="literal">set</code> functions (collectively called <span class="emphasis"><em>accessors</em></span>).</p><p>You can define properties either implicitly or explicitly. One guideline is to favor implicit properties when you’re exposing a simple value; when you need custom logic when getting or setting a property value, use explicit properties instead.</p><div class="sect3" title="Explicit Properties"><div class="titlepage"><div><div><h4 class="title" id="explicit_properties">Explicit Properties</h4></div></div></div><p>Explicit properties are those where you define and control the backing store (typically with a <code class="literal">let</code> binding) and implement the <code class="literal">get</code> and <code class="literal">set</code> function bodies yourself. You define an explicit property with the <code class="literal">member</code> keyword followed by a self-identifier, the property name, a type annotation (if the compiler can’t infer it), and the function bodies, as shown here:</p><a id="pro_id00144"/><pre class="programlisting">type Person() =
  <span class="strong"><strong>let mutable name = ""</strong></span>
  <span class="strong"><strong>member x.Name</strong></span>
    <span class="strong"><strong>with get() = name</strong></span>
    <span class="strong"><strong>and set(value) = name &lt;- value</strong></span></pre><p>In this example, the <code class="literal">name</code> field is the private backing store for the read/write <code class="literal">Name</code> property. Once you’ve created an instance of this <code class="literal">Person</code> class, you can assign a value to the <code class="literal">Name</code> property with the assignment operator, like so:</p><a id="pro_id00145"/><pre class="programlisting">let me = Person()
me.Name &lt;- "Dave"</pre><p><a id="iddle1086" class="indexterm"/><a id="iddle1089" class="indexterm"/><a id="iddle1092" class="indexterm"/><a id="iddle1122" class="indexterm"/><a id="iddle1192" class="indexterm"/><a id="iddle1521" class="indexterm"/><a id="iddle1543" class="indexterm"/><a id="iddle1640" class="indexterm"/><a id="iddle1782" class="indexterm"/><a id="iddle1786" class="indexterm"/><a id="iddle1788" class="indexterm"/><a id="iddle1795" class="indexterm"/><a id="iddle2121" class="indexterm"/>Instead of using the <code class="literal">and</code> keyword, you can use an alternative syntax where the <code class="literal">get</code> and <code class="literal">set</code> accessors are defined as separate properties.</p><a id="pro_id00146"/><pre class="programlisting">type Person() =
  let mutable name = ""
  <span class="strong"><strong>member x.Name with get() = name</strong></span>
  <span class="strong"><strong>member x.Name with set(value) = name &lt;- value</strong></span></pre><p>Whichever syntax you choose, properties are public by default, but you can control their accessibility by inserting the access modifier (<code class="literal">public</code>, <code class="literal">private</code>, or <code class="literal">internal</code>) after the <code class="literal">with</code> (or <code class="literal">and</code>) keyword, like this:</p><a id="pro_id00147"/><pre class="programlisting">type Person() =
  let mutable name = ""
  member x.Name
    with <span class="strong"><strong>public</strong></span> get() = name
    and <span class="strong"><strong>internal</strong></span> set(value) = name &lt;- value</pre><p>If you wanted the <code class="literal">Name</code> property to be read-only, you could revise the class to include the value as an argument to the primary constructor and remove the <code class="literal">and set...</code> line in this way:</p><a id="pro_id00148"/><pre class="programlisting">type Person(name) =
  member x.Name with get() = name</pre><p>Of course, this is F#, so although defining a read-only property is already easy, there’s an even easier way with the explicit syntax.</p><a id="pro_id00149"/><pre class="programlisting">type Person(name) =
  member x.Name = name</pre><p>When you’re creating a read-only property, the compiler automatically generates the <code class="literal">get</code> accessor function for you.</p></div><div class="sect3" title="Implicit Properties"><div class="titlepage"><div><div><h4 class="title" id="implicit_properties">Implicit Properties</h4></div></div></div><p>Implicit, or automatic, properties were added to F# in version 3.0 (if you’re using 2.0, you’ll need to use explicit properties). They’re very much like auto-implemented properties in C# in that they allow the compiler to generate the proper backing store and corresponding <code class="literal">get</code>/<code class="literal">set</code> accessor bodies. Implicit properties are a lot like their explicit counterparts, but there are a few differences.</p><p>First, implicit properties are considered part of the type’s initialization, so they must appear before other member definitions, typically along with the primary constructor. Next, they are defined via the <code class="literal">member val</code> keyword pair and must be initialized to a default value, as shown next. (They must not include a self-identifier.) And finally, their accessibility can be changed only at the property level, not the accessor level.</p><a id="pro_id00150"/><pre class="programlisting">type Person() =
  <span class="strong"><strong>member val Name = "" with get, set</strong></span></pre><p><a id="iddle1004" class="indexterm"/><a id="iddle1062" class="indexterm"/><a id="iddle1160" class="indexterm"/><a id="iddle1303" class="indexterm"/><a id="iddle1522" class="indexterm"/><a id="iddle1548" class="indexterm"/><a id="iddle1789" class="indexterm"/><a id="iddle1955" class="indexterm"/>If your implicit property is read-only, you can omit the <code class="literal">with</code> expression like this:</p><a id="pro_id00151"/><pre class="programlisting">type Person(name) =
  <span class="strong"><strong>member val Name = name</strong></span></pre></div><div class="sect3" title="Indexed Properties"><div class="titlepage"><div><div><h4 class="title" id="indexed_properties">Indexed Properties</h4></div></div></div><p>F# classes can also have <span class="emphasis"><em>indexed properties</em></span>, which are useful for defining an array-like interface for working with sequential data. Indexed properties are defined like ordinary properties except that the <code class="literal">get</code> accessor includes an argument.</p><p>When you are creating indexed properties, naming one <code class="literal">Item</code> makes it a <span class="emphasis"><em>default indexed property</em></span> and enables convenient syntactic support through the dot operator and a pair of brackets enclosing the index value (<code class="literal">.[...]</code>). For example, consider a class that accepts a string and exposes each word through a default indexer like this:</p><a id="pro_id00152"/><pre class="programlisting">type Sentence(initial : string) =
  let mutable words = initial.Split ' '
  let mutable text = initial
  <span class="strong"><strong>member x.Item</strong></span>
    <span class="strong"><strong>with get i = words.[i]</strong></span>
    <span class="strong"><strong>and set i v =</strong></span>
      <span class="strong"><strong>words.[i] &lt;- v</strong></span>
      <span class="strong"><strong>text &lt;- System.String.Join(" ", words)</strong></span></pre><p>Notice that the <code class="literal">Item</code> property is defined like a normal property with the <code class="literal">get</code>, and even a <code class="literal">set</code>, accessor. Because this indexer is just a wrapper around the <code class="literal">words</code> array (<code class="literal">String.Split</code> returns an array), it accepts an integer value and returns the corresponding word.</p><p>F# arrays are zero-based, so you can get the second word from a sentence like this:</p><a id="pro_id00153"/><pre class="programlisting">&gt; let s = Sentence "Don't forget to drink your Ovaltine"
<span class="strong"><strong>s.[1];;</strong></span>

val s1 : Sentence
val it : string = "forget"</pre><p>To change the second word, you’d reference the index in the same way and use the assignment operator (<code class="literal">&lt;-</code>) like so:</p><a id="pro_id00154"/><pre class="programlisting">&gt; <span class="strong"><strong>s.[1] &lt;- "remember";;</strong></span>
val it : unit = ()
&gt; <span class="strong"><strong>s.[1];;</strong></span>
val it : string = "remember"</pre><p><a id="iddle1523" class="indexterm"/><a id="iddle1528" class="indexterm"/><a id="iddle1790" class="indexterm"/><a id="iddle1791" class="indexterm"/>Furthermore, default indexed properties can be multidimensional. For instance, you can define one to return a specific character from a word by including two parameters.</p><a id="pro_id00155"/><pre class="programlisting">type Sentence(initial : string) =
  -- <span class="emphasis"><em>snip</em></span> --
  member x.Item with get(w, i) = words.[w].[i]</pre><p>Now you can easily get the first character of the second word like this:</p><a id="pro_id00156"/><pre class="programlisting">&gt; <span class="strong"><strong>s.[1, 0];;</strong></span>
val it : char = 'f'</pre><p>But what if you want to define another indexed property to get a character out of the original string? You’ve already defined a default indexed property that accepts an integer, so you can’t do it that way. In C#, you’d have to create this as a method, but in F# any property can be an indexed property. For example:</p><a id="pro_id00157"/><pre class="programlisting">type Sentence(initial : string) =
  -- <span class="emphasis"><em>snip</em></span> --
  member x.Chars with get(i) = text.[i]</pre><p>The only caveat is that you can’t use the dot/bracket syntax that you’d use with a default indexed property; you have to access the property as if it’s a method (as described in <a class="xref" href="ch04.html#instance_methods" title="Instance Methods">Instance Methods</a>) by including the index value in parentheses after the property name in this way:</p><a id="pro_id00158"/><pre class="programlisting">&gt; <span class="strong"><strong>s.Chars(0);;</strong></span>
val it : char = 'D'</pre><p>Though it looks like a method call, if the <code class="literal">Chars</code> indexed property included a <code class="literal">set</code> accessor, you’d use the assignment operator just like you would with any other property to change the underlying value.</p></div><div class="sect3" title="Setting at Initialization"><div class="titlepage"><div><div><h4 class="title" id="setting_at_initialization">Setting at Initialization</h4></div></div></div><p>An alternative object initialization syntax lets you set individual property values as part of the constructor call. To use the object initialization syntax, you need only include each property name and value (separated by an equal sign) immediately following the normal constructor arguments. Let’s reconsider one of the previous <code class="literal">Person</code> class examples to illustrate.</p><a id="pro_id00159"/><pre class="programlisting">type Person() =
  member val Name = "" with get, set</pre><p><a id="iddle1529" class="indexterm"/><a id="iddle1639" class="indexterm"/><a id="iddle1642" class="indexterm"/><a id="iddle1643" class="indexterm"/><a id="iddle1644" class="indexterm"/>Because the <code class="literal">Person</code> class has only the single, parameterless constructor, you could create an instance and then assign a value to the <code class="literal">Name</code> property in a second operation. But it would be much more concise to do it all at once, like this:</p><a id="pro_id00160"/><pre class="programlisting">let p = Person(Name = "Dave")</pre><p>There is one catch to using this syntax: Any properties you initialize this way must be writable.</p></div></div><div class="sect2" title="Methods"><div class="titlepage"><div><div><h3 class="title" id="methods">Methods</h3></div></div></div><p>Methods are functions that are associated with a class and that represent the type’s behavior.</p><div class="sect3" title="Instance Methods"><div class="titlepage"><div><div><h4 class="title" id="instance_methods">Instance Methods</h4></div></div></div><p>There are two ways to define instance methods. The first form uses the <code class="literal">member</code> keyword to define a public method in much the same way as a property, as demonstrated by the <code class="literal">GetArea</code> method that follows.</p><a id="pro_id00161"/><pre class="programlisting">open System

type Circle(diameter : float) =
  member x.Diameter = diameter
  <span class="strong"><strong>member x.GetArea() =</strong></span>
    <span class="strong"><strong>let r = diameter / 2.0</strong></span>
    <span class="strong"><strong>System.Math.PI * (r ** 2.0)</strong></span></pre><p>Here, the <code class="literal">Circle</code> class is initialized with a <code class="literal">diameter</code> value and contains a parameterless, public method named <code class="literal">GetArea</code> that calculates the area of the circle. Because <code class="literal">GetArea</code> is an instance method, you’ll need to create an instance of the <code class="literal">Circle</code> class to invoke it as follows:</p><a id="pro_id00162"/><pre class="programlisting">&gt; <span class="strong"><strong>let c = Circle 5.0</strong></span>
<span class="strong"><strong>c.GetArea();;</strong></span>

val c : Circle
val it : float = 19.63495408</pre></div><div class="sect3" title="Method Accessibility"><div class="titlepage"><div><div><h4 class="title" id="method_accessibility">Method Accessibility</h4></div></div></div><p>As with properties, you can control access to methods with accessibility modifiers. For example, to make a method private you would simply include the <code class="literal">private</code> keyword in the method’s signature, as in the <code class="literal">GetRadius</code> method here:</p><a id="pro_id00163"/><pre class="programlisting">type Circle(diameter : float) =
  member <span class="strong"><strong>private</strong></span> x.GetRadius() = diameter / 2.0
  member x.Diameter = diameter
  member x.GetArea() = System.Math.PI * (x.GetRadius() ** 2.0)</pre><p><a id="iddle1127" class="indexterm"/><a id="iddle1665" class="indexterm"/>Alternatively, you can use a <code class="literal">let</code> binding to define a private function, as shown here:</p><a id="pro_id00164"/><pre class="programlisting">type Circle(diameter : float) =
  <span class="strong"><strong>let getRadius() = diameter / 2.0</strong></span>
  member x.Diameter = diameter
  member x.GetArea() = System.Math.PI * (getRadius() ** 2.0)</pre></div><div class="sect3" title="Named Arguments"><div class="titlepage"><div><div><h4 class="title" id="named_arguments">Named Arguments</h4></div></div></div><p>When you call a method, you’ll usually provide the arguments as a comma-delimited list with each argument corresponding to the parameter at the same position. For a bit of extra flexibility, though, F# allows <span class="emphasis"><em>named arguments</em></span> for both methods and constructors. With named arguments, each argument is explicitly associated with a particular parameter by name. In some cases, named arguments can help clarify your code, but they also allow you to specify the arguments in any order.</p><p>The following example contains a method that calculates the Euclidean distance between two points in a three-dimensional space (RGB colors, to be exact).</p><a id="pro_id00165"/><pre class="programlisting">open System
open System.Drawing

type ColorDistance() =
  member x.GetEuclideanDistance(c1 : Color, c2 : Color) =
    let getPointDistance p1 p2 = (float p1 - float p2) ** 2.0
    [ getPointDistance c1.R c2.R
      getPointDistance c1.G c2.G
      getPointDistance c1.B c2.B ] |&gt; List.sum |&gt; Math.Sqrt</pre><p>You can call the <code class="literal">GetEuclideanDistance</code> method normally by specifying two colors, or by specifying the parameter names in the argument list like this:</p><a id="pro_id00166"/><pre class="programlisting">&gt; <span class="strong"><strong>let d = ColorDistance()</strong></span>
<span class="strong"><strong>d.GetEuclideanDistance(Color.White, Color.Black);;</strong></span>

val d : ColorDistance
val it : float = 441.6729559

&gt; <span class="strong"><strong>d.GetEuclideanDistance(c2 = Color.White, c1 = Color.Snow);;</strong></span>
val it : float = 7.071067812</pre><p>You can specify named arguments in any order. You can also use named arguments with unnamed arguments, but if you do, the unnamed arguments must appear first in the argument list. Finally, because named arguments are permissible only for methods defined with the member syntax, they can’t be used with functions created through <code class="literal">let</code> bindings.</p></div><div class="sect3" title="Overloaded Methods"><div class="titlepage"><div><div><h4 class="title" id="overloaded_methods">Overloaded Methods</h4></div></div></div><p><a id="iddle1048" class="indexterm"/><a id="iddle1301" class="indexterm"/><a id="iddle1645" class="indexterm"/><a id="iddle1697" class="indexterm"/><a id="iddle1701" class="indexterm"/><a id="iddle1710" class="indexterm"/><a id="iddle1712" class="indexterm"/><a id="iddle1715" class="indexterm"/><a id="iddle1733" class="indexterm"/>An <span class="emphasis"><em>overloaded method</em></span> shares its name with one or more other methods in the same class but has a different set of parameters. Overloaded methods often define subsets of parameters, with each overload calling a more specific form with its supplied arguments and providing default values for others.</p><p>For example, if you were building a utility to tie in to your favorite version control system, you might define a <code class="literal">Commit</code> method that accepts a list of files, the description, and the target branch. To make the target branch optional, you could overload the <code class="literal">Commit</code> function as shown here:</p><a id="pro_id00167"/><pre class="programlisting">open System.IO

type Repository() =
  member ① x.Commit(files, desc, branch) =
    printfn "Committed %i files (%s) to \"%s\"" (List.length files) desc branch
  member ② x.Commit(files, desc) =
    x.Commit(files, desc,  ③"default")</pre><p>In this example, the overload at ① is responsible for committing changes to the repository, while the overload at ② makes the branch parameter optional when you supply the default value shown at ③.</p></div><div class="sect3" title="Optional Parameters"><div class="titlepage"><div><div><h4 class="title" id="optional_parameters">Optional Parameters</h4></div></div></div><p>Even though F# supports method overloading, you probably won’t use it very often because F# also supports <span class="emphasis"><em>optional parameters</em></span>, which are generally more convenient. If you prefix a parameter name with a question mark (<code class="literal">?</code>), the compiler treats it as an optional parameter.</p><p>Optional parameters are a bit different in F# than they are in C# and Visual Basic. In other languages, optional parameters are defined with a default value that’s used when the corresponding argument is omitted. In F#, though, the parameters are actually compiled to <code class="literal">option&lt;_&gt;</code> and default to <code class="literal">None</code>. (Optional parameter values behave like any other option type value, so you’ll still use <code class="literal">defaultArg</code> or pattern matching in your method to get a meaningful value, as appropriate.)</p><p>Let’s rewrite the <code class="literal">Repository</code> example from the previous section to use an optional parameter instead of an overloaded method.</p><a id="pro_id00168"/><pre class="programlisting">open System.IO

type Repository() =
  static member Commit(files, desc, ?branch) =
    let targetBranch = defaultArg branch "default"
    printfn "Committed %i files (%s) to \"%s\"" (List.length files) desc targetBranch</pre><p>Although you need to manage the optional parameter within the method, you now need to maintain only the one method instead of multiple, overloaded versions. As you can see, optional parameters can reduce the likelihood of defects that come from using inconsistent defaults across overloads, and they simplify refactoring because only one method needs to change.</p></div><div class="sect3" title="Slice Expressions"><div class="titlepage"><div><div><h4 class="title" id="slice_expressions">Slice Expressions</h4></div></div></div><p><a id="iddle1492" class="indexterm"/><a id="iddle1567" class="indexterm"/><a id="iddle1926" class="indexterm"/><a id="iddle1929" class="indexterm"/><a id="iddle1978" class="indexterm"/>Indexed properties, introduced in <a class="xref" href="ch04.html#indexed_properties" title="Indexed Properties">Indexed Properties</a>, are great for working with a single value in an encapsulated sequence, but you’ll sometimes want to work with a range of values in that sequence. Traditionally you’d have to get each item manually through the indexer, or implement <code class="literal">IEnumerable&lt;'T&gt;</code> and get the values through some combination of LINQ’s <code class="literal">Skip</code> and <code class="literal">Take</code> extension methods. <span class="emphasis"><em>Slice expressions</em></span> resemble indexed properties, except that they use range expressions to identify which items should be included in the resulting sequence.</p><p>To use slice expressions with your class, you need to implement a <code class="literal">GetSlice</code> method. There’s really nothing special about the <code class="literal">GetSlice</code> method; it’s just the method that the compiler looks for when it encounters the slice expression syntax. To illustrate a slice expression, let’s revisit the <code class="literal">Sentence</code> class from the indexed properties section.</p><a id="pro_id00169"/><pre class="programlisting">type Sentence(initial : string) =
  let words = initial.Split ' '
  let text = initial
  member x.GetSlice(lower, upper) =
    match defaultArg lower 0 with
    | l when l &gt;= words.Length -&gt; Array.empty&lt;string&gt;
    | l -&gt; match defaultArg upper (words.Length - 1) with
           | u when u &gt;= words.Length -&gt; words.[l..]
           | u -&gt; words.[l..u]</pre><p>The basic class definition is the same as before, except this time we have a <code class="literal">GetSlice()</code> method that accepts the lower and upper bounds. (Don’t dwell on the match expressions here; a full discussion is waiting for you in <a class="xref" href="ch07.html" title="Chapter 7. Patterns, Patterns, Everywhere">Chapter 7</a>. For now it’s enough to know that they’re just doing some boundary checks.)</p><p>You could call this method directly in your code, but the expression form is much more convenient. For example, to retrieve the second, third, and fourth words in a sentence, you could write:</p><a id="pro_id00170"/><pre class="programlisting">&gt; <span class="strong"><strong>let s = Sentence "Don't forget to drink your Ovaltine"</strong></span>
<span class="strong"><strong>s.[1..3];;</strong></span>

val s : Sentence
val it : string [] = [|"forget"; "to"; "drink"|]</pre><p>One of the nice things about slice expressions is that the bounds parameters are optional, so you can use open-ended ranges. To specify a range without a lower bound, just omit the first value (the 1) in the slice expression, which in this case is equivalent to <code class="literal">[0..3]</code>.</p><a id="pro_id00171"/><pre class="programlisting">&gt; <span class="strong"><strong>s.[..3];;</strong></span>
val it : string [] = [|"Don't"; "forget"; "to"; "drink"|]</pre><p>Similarly, you can leave out the second parameter and get the items up to the end of the collection.</p><a id="pro_id00172"/><pre class="programlisting">&gt; <span class="strong"><strong>s.[3..];;</strong></span>
val it : string [] = [|"drink"; "your"; "Ovaltine"|]</pre><p><a id="iddle1232" class="indexterm"/><a id="iddle1353" class="indexterm"/><a id="iddle1356" class="indexterm"/>Like indexed properties, slice expressions can work on two dimensions, but you need to overload the <code class="literal">GetSlice</code> method to accept four parameters that define both pairs of lower and upper bounds. Continuing with the <code class="literal">Sentence</code> example, we can add a multidimensional slice overload to get a range of characters from a range of words like this:</p><a id="pro_id00173"/><pre class="programlisting">type Sentence(initial : string) =
  -- <span class="emphasis"><em>snip</em></span> --
  member x.GetSlice(lower1, upper1, lower2, upper2) =
    x.GetSlice(lower1, upper1)
    |&gt; Array.map
        (fun w -&gt; match defaultArg lower2 0 with
                  | l when l &gt;= w.Length -&gt; ""
                  | l -&gt; match defaultArg upper2 (w.Length - 1) with
                         | u when u &gt;= w.Length -&gt; w.[l..]
                         | u -&gt; w.[l..u])</pre><p>To use this overload, just separate the range pairs in the slice expression with a comma.</p><a id="pro_id00174"/><pre class="programlisting">&gt; <span class="strong"><strong>s.[1..4, ..1];;</strong></span>
val it : string [] = [|"fo"; "to"; "dr"; "yo"|]</pre></div></div><div class="sect2" title="Events"><div class="titlepage"><div><div><h3 class="title" id="events">Events</h3></div></div></div><p>The final member type is <span class="emphasis"><em>events</em></span>. Events are used throughout the .NET Framework with some notable examples found in the user interface components and ADO.NET. As in other .NET languages, at their core F# events are collections of functions invoked in response to some action like a button click or an asynchronous process completion.</p><p>In many ways F# events serve the same purpose as traditional .NET events, but they’re a completely different mechanism. However, for cross-language compatibility, they can tie in to the .NET event system. (We’ll see how your custom events can harness this capability with the <code class="literal">CLIEvent</code> attribute a bit later in this section.)</p><div class="sect3" title="Basic Event Handling"><div class="titlepage"><div><div><h4 class="title" id="basic_event_handling">Basic Event Handling</h4></div></div></div><p>Events in F# are instances of the <code class="literal">Event&lt;'T&gt;</code> class (found in <code class="literal">FSharp.Core.Control</code>). One of the primary features that the <code class="literal">Event&lt;'T&gt;</code> class enables is a more explicit publish/subscribe model than you might be used to. In this model you can subscribe to published events by adding event handlers to the event via a call to the <code class="literal">Add</code> function.</p><p>For example, the <code class="literal">System.Timers.Timer</code> class publishes an <code class="literal">Elapsed</code> event that you can subscribe to.</p><a id="pro_id00175"/><pre class="programlisting">  let ticks = ref 0
  let t = ① new System.Timers.Timer(500.0)
  t.Elapsed.Add ② (fun ea -&gt; printfn "tick"; ticks := ticks.Value + 1)
③ t.Start()
  while ticks.Value &lt; 5 do ()
  t.Dispose()</pre><p><a id="iddle1099" class="indexterm"/><a id="iddle1346" class="indexterm"/><a id="iddle1348" class="indexterm"/><a id="iddle1349" class="indexterm"/><a id="iddle1351" class="indexterm"/><a id="iddle1352" class="indexterm"/><a id="iddle1355" class="indexterm"/><a id="iddle1429" class="indexterm"/><a id="iddle1464" class="indexterm"/><a id="iddle1551" class="indexterm"/><a id="iddle1720" class="indexterm"/><a id="iddle1736" class="indexterm"/>Here we create a new instance of the <code class="literal">Timer</code> class at ①. At ②, we subscribe to the <code class="literal">Elapsed</code> function using a <span class="emphasis"><em>lambda expression</em></span> (an anonymous function) as the event handler. Once the timer is started at ③, the event handler prints <code class="literal">tick</code> and increments a reference cell’s value (remember, closures like the one created by the lambda expression can’t use mutable <code class="literal">let</code> bindings) every half-second, per the timer definition. When the tick counter reaches five, the loop will terminate and the timer will be stopped and disposed of.</p></div><div class="sect3" title="Observing Events"><div class="titlepage"><div><div><h4 class="title" id="observing_events">Observing Events</h4></div></div></div><p>The other primary benefit of F# events is that they enable you to treat events as sequences that you can intelligently partition, filter, aggregate, or otherwise act upon as they’re triggered. The <code class="literal">Event</code> module defines a number of functions—such as <code class="literal">add</code>, <code class="literal">filter</code>, <code class="literal">partition</code>, and <code class="literal">pairwise</code>—that accept published events.</p><p>To see this principle in action, let’s turn to an example in ADO.NET. The <code class="literal">DataTable</code> class triggers a variety of events in response to certain actions like changed or deleted rows. If you wanted to handle the <code class="literal">RowChanged</code> event, you could add a single event handler (just as in the previous section) and include logic to filter out the events you don’t care about, or you could use the <code class="literal">filter</code> function from the <code class="literal">Event</code> module and invoke your handler only when it’s needed, as follows:</p><a id="pro_id00176"/><pre class="programlisting">  open System
  open System.Data

  let dt = new DataTable("person")
  dt.Columns.AddRange
    [| new DataColumn("person_id", typedefof&lt;int&gt;)
       new DataColumn("first_name", typedefof&lt;string&gt;)
       new DataColumn("last_name", typedefof&lt;string&gt;) |]
  dt.Constraints.Add("pk_person", dt.Columns.[0], true)

  let 1 h1, h2 =
2 dt.RowChanged
    |&gt; 3 Event.partition
           4(fun ea -&gt;
              let ln = ea.Row.["last_name"] :?&gt; string
              ln.Equals("Pond", StringComparison.InvariantCultureIgnoreCase))

5 h1.Add (fun _ -&gt; printfn "Come along, Pond")
6 h2.Add (fun _ -&gt; printfn "Row changed")</pre><p><a id="iddle1035" class="indexterm"/><a id="iddle1354" class="indexterm"/><a id="iddle1357" class="indexterm"/><a id="iddle1358" class="indexterm"/><a id="iddle1450" class="indexterm"/><a id="iddle1737" class="indexterm"/><a id="iddle1796" class="indexterm"/><a id="iddle2024" class="indexterm"/>We’ll forego a discussion of the first half of this example; for our purposes, all that’s important there is that it sets up a <code class="literal">DataTable</code> with three columns and a primary key. What’s really important here is the <code class="literal">partition</code> function.</p><p>In this example, we invoke the <code class="literal">partition</code> function at ③ by supplying both a delegate (in the form of a lambda expression) at ④ and the <code class="literal">Event</code> object published by the <code class="literal">DataTable</code>’s <code class="literal">RowChanged</code> event at ②. The <code class="literal">partition</code> function then returns two new events that we bind to <code class="literal">h1</code> and <code class="literal">h2</code> at ①. Finally, we subscribe to both of the new events by calling their <code class="literal">Add</code> method at ⑤ and ⑥.</p><p>Now that the table structure and event handlers are in place, we can add some rows and see how the events are triggered.</p><a id="pro_id00177"/><pre class="programlisting"><span class="strong"><strong>&gt; dt.Rows.Add(1, "Rory", "Williams") |&gt; ignore;;</strong></span>
Row changed
val it : unit = ()
<span class="strong"><strong>&gt; dt.Rows.Add(2, "Amelia", "Pond") |&gt; ignore;;</strong></span>
Come along, Pond
val it : unit = ()</pre><p>As you can see, when the first row is added, the last name doesn’t match the criteria specified in the filter, so <code class="literal">h2</code> is triggered. However, the second row does match the criteria, so <code class="literal">h1</code> is triggered instead.</p><p>If the syntax for calling the partition function looks backward, that’s because it is; the <span class="emphasis"><em>forward pipelining operator</em></span> (<code class="literal">|&gt;</code>) applies its left operand as the final argument to the function specified by its right operand. (The forward pipelining operator is used frequently in F#, and we’ll explore it in much more detail in <a class="xref" href="ch05.html" title="Chapter 5. Let’s Get Functional">Chapter 5</a>.)</p></div><div class="sect3" title="Custom Events"><div class="titlepage"><div><div><h4 class="title" id="custom_events">Custom Events</h4></div></div></div><p>You can define your own custom events in your types. However, doing so is a bit different than in other .NET languages because events exist only as objects in F# and they lack keyword support.</p><p>The first thing you need to do, aside from defining the type, is create a field (with a <code class="literal">let</code> binding) for your event object. This is the object used to coordinate publishing and triggering the event. Once the field is defined, you can expose the event’s <code class="literal">Publish</code> property to the outside world with a property of your own. Finally, you’ll need to trigger the event somewhere by calling the <code class="literal">Trigger</code> function.</p><a id="pro_id00178"/><pre class="programlisting">type Toggle() =
  <span class="strong"><strong>let toggleChangedEvent = Event&lt;_&gt;()</strong></span>
  let mutable isOn = false

  member x.ToggleChanged = <span class="strong"><strong>toggleChangedEvent.Publish</strong></span>

  member x.Toggle() =
    isOn &lt;- not isOn
    <span class="strong"><strong>toggleChangedEvent.Trigger (x, isOn)</strong></span></pre><p><a id="iddle1233" class="indexterm"/><a id="iddle1347" class="indexterm"/><a id="iddle1350" class="indexterm"/><a id="iddle1614" class="indexterm"/><a id="iddle1963" class="indexterm"/><a id="iddle1964" class="indexterm"/><a id="iddle1965" class="indexterm"/>With the type defined, you can create a new instance and subscribe to the <code class="literal">ToggleChanged</code> event as with any built-in type. For example, next we use a partition to create two new event handlers, one to handle when the toggle is turned on and another to handle when it is turned off. The call to <code class="literal">Event.map</code> simply rephrases the event by throwing away the first parameter (the source, or sender, per .NET conventions) before calling the <code class="literal">partition</code> function.</p><a id="pro_id00179"/><pre class="programlisting">let myToggle = Toggle()
let onHandler, offHandler =
  <span class="strong"><strong>myToggle.ToggleChanged</strong></span>
  |&gt; <span class="strong"><strong>Event.map</strong></span> (fun (_, isOn) -&gt; isOn)
  |&gt; <span class="strong"><strong>Event.partition</strong></span> (fun isOn -&gt; isOn)

onHandler |&gt; <span class="strong"><strong>Event.add</strong></span> (fun _ -&gt; printfn "Turned on!")
offHandler |&gt; <span class="strong"><strong>Event.add</strong></span> (fun _ -&gt; printfn "Turned off!")</pre><p>Now every call to the <code class="literal">Toggle</code> method will trigger the <code class="literal">ToggleChanged</code> event and cause one of the two handlers to execute.</p><a id="pro_id00180"/><pre class="programlisting"><span class="strong"><strong>&gt; myToggle.Toggle();;</strong></span>
Turned on!
val it : unit = ()
<span class="strong"><strong>&gt; myToggle.Toggle();;</strong></span>
Turned off!
val it : unit = ()</pre><p>As you’ve just seen, the <code class="literal">ToggleChanged</code> event is fully enabled within F#. If your class won’t be consumed outside F# assemblies, you could stop here. However, if you need to use it in assemblies written in different languages, you’ll have to do one more thing: decorate the <code class="literal">ToggleChanged</code> property with the <code class="literal">CLIEvent</code> attribute.</p><a id="pro_id00181"/><pre class="programlisting"><span class="strong"><strong>[&lt;CLIEvent&gt;]</strong></span>
member x.ToggleChanged = toggleChangedEvent.Publish</pre><p>The <code class="literal">CLIEvent</code> attribute instructs the compiler to include the appropriate metadata that makes the event consumable from other .NET languages.</p></div></div></div><div class="sect1" title="Structures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="structures">Structures</h2></div></div></div><p><span class="emphasis"><em>Structures</em></span>, or <span class="emphasis"><em>structs</em></span>, are similar to classes in that they can have fields, properties, methods, and events. Structs are defined just like classes except that the type must be decorated with the <code class="literal">Struct</code> attribute.</p><a id="pro_id00182"/><pre class="programlisting"><span class="strong"><strong>[&lt;Struct&gt;]</strong></span>
type Circle(diameter : float) =
  member x.getRadius() = diameter / 2.0
  member x.Diameter = diameter
  member x.GetArea() = System.Math.PI * (x.getRadius() ** 2.0)</pre><p><a id="iddle1525" class="indexterm"/><a id="iddle2097" class="indexterm"/><a id="iddle2100" class="indexterm"/>However, despite their similarities, behind the scenes, classes and structs are very different animals. The primary difference between them is that structs are <span class="emphasis"><em>value types</em></span>.</p><p>This difference is significant because it affects not only how you interact with the data but also how value types are represented in the computer’s memory. With both types, the runtime allocates space in memory to store the value. Value types always result in a new allocation with the data copied into that space. With reference types, the memory is allocated once and accessed via a reference that identifies its location.</p><p>When you pass a reference type to a function, the runtime creates a new reference to that location in memory rather than a copy of the data. Therefore, reference types can more easily wreak havoc through side effects, because when you pass a reference type to a function any changes that you make to that object are immediately reflected wherever that object is referenced. In contrast, passing a value type to a function creates a copy of the value so any changes to it are isolated to that one instance.</p><p>Structs are also initialized differently than classes. Unlike classes, the compiler generates a default (parameterless) constructor for structs that initializes all fields to their appropriate zero value (<code class="literal">zero</code>, <code class="literal">null</code>, and so on). This means that you can’t use <code class="literal">let</code> bindings to create private instance fields or methods within a struct unless they’re static; instead, you must use <code class="literal">val</code> to define struct instance fields. Also, you can’t define your own default constructor, so any additional constructors you define must accept at least one parameter. (Your fields can still be mutable as long as you don’t include a primary constructor.)</p><p>Because of differences in how memory is allocated for reference and value types, structs cannot contain fields of their own type. Without this restriction, the memory requirement for a struct instance would be infinitely large because each instance would recursively require enough space for another instance of the same type.</p><p>Finally, structs can implement interfaces but cannot otherwise participate in inheritance. Regardless, structs still derive from <code class="literal">System.Object</code>, so you can override methods (like <code class="literal">ToString</code>).</p></div><div class="sect1" title="Inheritance"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="inheritance">Inheritance</h2></div></div></div><p>In OO programming, <span class="emphasis"><em>inheritance</em></span> describes an <span class="emphasis"><em>identity</em></span> relationship between two types in the way that an apple <span class="emphasis"><em>is</em></span> a fruit. F# classes support <span class="emphasis"><em>single inheritance</em></span>, meaning that any given class can directly inherit from only one other in order to establish a class hierarchy. Through inheritance, public (and sometimes internal) members exposed by the base type are automatically available in the derived type. You can see this principle in action in the following snippet.</p><a id="pro_id00183"/><pre class="programlisting">type BaseType() =
  member x.SayHello name = printfn "Hello, %s" name

type DerivedType() =
  inherit BaseType()</pre><p><a id="iddle1066" class="indexterm"/><a id="iddle1228" class="indexterm"/><a id="iddle1526" class="indexterm"/><a id="iddle1941" class="indexterm"/><a id="iddle2082" class="indexterm"/>The <code class="literal">DerivedType</code> defined here doesn’t define any functionality of its own, but because it derives from <code class="literal">BaseType</code>, the <code class="literal">SayHello</code> method is accessible through <code class="literal">DerivedType</code>.</p><p>F# inheritance requires a primary constructor. To specify a base class, include the <code class="literal">inherit</code> keyword followed by the base type name and its constructor arguments in the primary constructor before any bindings or member definitions. For instance, a task management system might have a <code class="literal">WorkItem</code> class that represents all work items in the system, as well as specialized classes such as <code class="literal">Defect</code> and <code class="literal">Enhancement</code> that derive from the <code class="literal">WorkItem</code> class, as shown next in bold.</p><a id="pro_id00184"/><pre class="programlisting">type WorkItem(summary : string, desc : string) =
  member val Summary = summary
  member val Description = desc

type Defect(summary, desc, severity : int) =
  <span class="strong"><strong>inherit WorkItem(summary, desc)</strong></span>
  member val Severity = severity
type Enhancement(summary, desc, requestedBy : string) =
  <span class="strong"><strong>inherit WorkItem(summary, desc)</strong></span>
  member val RequestedBy = requestedBy</pre><p>Every .NET class, including the primitive types, ultimately participates in inheritance. Also, when you define a class without explicitly specifying a base class, the defined class implicitly inherits from <code class="literal">System.Object</code>.</p><div class="sect2" title="Casting"><div class="titlepage"><div><div><h3 class="title" id="casting">Casting</h3></div></div></div><p>In <a class="xref" href="ch03.html" title="Chapter 3. Fundamentals">Chapter 3</a> you learned how to convert between numeric types. Types can also be converted within their type hierarchy through the upcast and downcast operators.</p><div class="sect3" title="Upcasting"><div class="titlepage"><div><div><h4 class="title" id="upcasting">Upcasting</h4></div></div></div><p>Until now I’ve maintained that there are no implicit conversions in F#, but that’s not entirely true. The only time that types are implicitly <span class="emphasis"><em>upcast</em></span> (converted to a type higher in their inheritance structure) is when they’re passed to a method or a <code class="literal">let</code>-bound function where the corresponding parameter is a flexible type. In all other cases, you must explicitly cast the type with the <span class="emphasis"><em>static cast</em></span> operator (<code class="literal">:&gt;</code>).</p><p>To see the static cast operator in action, let’s continue with the <code class="literal">WorkItem</code> example by creating a <code class="literal">Defect</code> and immediately casting it to a <code class="literal">WorkItem</code>.</p><a id="pro_id00185"/><pre class="programlisting"><span class="strong"><strong>&gt; let w = Defect("Incompatibility detected", "Delete", 1) :&gt; WorkItem;;</strong></span>
val w : WorkItem</pre><p><a id="iddle1027" class="indexterm"/><a id="iddle1326" class="indexterm"/><a id="iddle1328" class="indexterm"/><a id="iddle1546" class="indexterm"/><a id="iddle1718" class="indexterm"/><a id="iddle1719" class="indexterm"/>The static cast operator resolves valid casts at compile time. If the code compiles, the conversion will always succeed.</p></div><div class="sect3" title="Downcasting"><div class="titlepage"><div><div><h4 class="title" id="downcasting">Downcasting</h4></div></div></div><p>The opposite of an upcast is a <span class="emphasis"><em>downcast</em></span>. Downcasts are used to convert a type to something lower in its hierarchy, that is, to convert a base type to a derived type. To perform a downcast, you use the <span class="emphasis"><em>dynamic cast</em></span> operator (<code class="literal">:?&gt;</code>)</p><p>Because the <code class="literal">WorkItem</code> instance we created in the previous example is still a <code class="literal">Defect</code>, we can use the dynamic cast operator to convert it back to a <code class="literal">WorkItem</code>.</p><a id="pro_id00186"/><pre class="programlisting"><span class="strong"><strong>&gt; let d = w :?&gt; Defect;;</strong></span>
val d : Defect</pre><p>Unlike the static cast operator, the dynamic cast operator isn’t resolved until run time, so you may see an <code class="literal">InvalidCastException</code> if the target type isn’t valid for the source object. For instance, if you try to downcast <code class="literal">w</code> to <code class="literal">Enhancement</code>, the cast will fail.</p><a id="pro_id00187"/><pre class="programlisting"><span class="strong"><strong>&gt; let e = w :?&gt; Enhancement;;</strong></span>
System.InvalidCastException: Unable to cast object of type 'Defect' to type 'Enhancement'.
   at Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxGeneric[T](Object source)
   at &lt;StartupCode$FSI_0007&gt;.$FSI_0007.main@()
Stopped due to error</pre></div></div><div class="sect2" title="Overriding Members"><div class="titlepage"><div><div><h3 class="title" id="overriding_members">Overriding Members</h3></div></div></div><p>Aside from reusing code, you might use inheritance to change the functionality offered by a base class by overriding its members.</p><p>For example, the <code class="literal">ToString</code> method defined on <code class="literal">System.Object</code> is a great (and often overlooked) debugging tool whose default implementation isn’t particularly informative because it just returns the type name. To make it more useful, your classes can override the default functionality and return a string that actually describes the object.</p><p>To illustrate, consider the <code class="literal">WorkItem</code> class from earlier. If you were to call its <code class="literal">ToString</code> method, you would see something like this:</p><a id="pro_id00188"/><pre class="programlisting"><span class="strong"><strong>&gt; let w = WorkItem("Take out the trash", "It's overflowing!")</strong></span>
<span class="strong"><strong>w.ToString();;</strong></span>

val w : WorkItem
val it : string = "FSI_0002+WorkItem"</pre><div class="note" title="Note"><h3 class="title"><a id="ch04note03"/>Note</h3><p><span class="emphasis"><em>In the preceding example, FSI_0002+ is an artifact of invoking the code in FSI. Your type name will probably differ.</em></span></p></div><p>To override the default behavior and make <code class="literal">ToString</code> return something more useful, define a new method with the <code class="literal">override</code> keyword.</p><a id="pro_id00189"/><pre class="programlisting">type WorkItem(summary : string, desc : string) =
  -- <span class="emphasis"><em>snip</em></span> --
  <span class="strong"><strong>override</strong></span> x.ToString() = sprintf "%s" x.Summary</pre><p><a id="iddle1079" class="indexterm"/><a id="iddle1202" class="indexterm"/><a id="iddle1203" class="indexterm"/><a id="iddle2108" class="indexterm"/>If you call <code class="literal">ToString</code> now, the result will be the summary text instead of the type name.</p><a id="pro_id00190"/><pre class="programlisting"><span class="strong"><strong>&gt; let w = WorkItem("Take out the trash", "It's overflowing!")</strong></span>
<span class="strong"><strong>w.ToString();;</strong></span>

val w : WorkItem = Take out the trash
val it : string = "Take out the trash"</pre><p>You can override a given function only once per type, but you can override it at multiple levels in the hierarchy. For instance, here’s how you could override <code class="literal">ToString</code> again in the <code class="literal">Defect</code> class to display the severity of the defect:</p><a id="pro_id00191"/><pre class="programlisting">type Defect(summary, desc, severity : int) =
  inherit WorkItem(summary, desc)
  member val Severity = severity
  <span class="strong"><strong>override x.ToString() = sprintf "%s (%i)" x.Summary x.Severity</strong></span></pre><p>When overriding a <span class="emphasis"><em>virtual member</em></span> (an abstract member with a default implementation), you can call into the base functionality through the <code class="literal">base</code> keyword. The <code class="literal">base</code> keyword behaves like a self-identifier except that it represents the base class.</p><p>Continuing with our <code class="literal">ToString</code> override theme, to augment the default behavior your override could call <code class="literal">base.ToString()</code> like this:</p><a id="pro_id00192"/><pre class="programlisting">type Defect(summary, desc, severity : int) =
  -- <span class="emphasis"><em>snip</em></span> --
  override x.ToString() =
    sprintf "%s (%i)" (<span class="strong"><strong>base.ToString()</strong></span>) x.Severity</pre><p>Note that the <code class="literal">base</code> keyword is available only in classes that explicitly inherit from another type. To use the <code class="literal">base</code> keyword in a class that inherits from <code class="literal">System.Object</code>, you would need to explicitly inherit from it as follows:</p><a id="pro_id00193"/><pre class="programlisting">type WorkItem(summary : string, desc : string) =
  inherit System.Object()
  -- <span class="emphasis"><em>snip</em></span> --
  override x.ToString() =
    sprintf "[%s] %s" (base.ToString()) x.Summary</pre></div><div class="sect2" title="Abstract Classes"><div class="titlepage"><div><div><h3 class="title" id="abstract_classes">Abstract Classes</h3></div></div></div><p>An <span class="emphasis"><em>abstract class</em></span> is one that can’t be directly instantiated; it’s accessible only through derived classes. Abstract classes typically define a common interface and optional implementation for a group of related classes that <a id="iddle1080" class="indexterm"/><a id="iddle1082" class="indexterm"/><a id="iddle1083" class="indexterm"/>fulfill similar needs in different ways. Abstract classes are used throughout the .NET Framework; one great example is the <code class="literal">TextWriter</code> class in the <code class="literal">System.IO</code> namespace.</p><p>The <code class="literal">TextWriter</code> class defines a common mechanism for writing characters to <span class="emphasis"><em>something</em></span>. It doesn’t care where or how the characters are written, but it orchestrates some of the process, with the implementation details left to individual derived classes such as <code class="literal">StreamWriter</code>, <code class="literal">StringWriter</code>, and <code class="literal">HttpWriter</code>.</p><p>You can define your own abstract classes by decorating the type definition with the <code class="literal">AbstractClass</code> attribute. For example, to create a simple tree structure you could use an abstract class as follows:</p><a id="pro_id00194"/><pre class="programlisting"><span class="strong"><strong>[&lt;AbstractClass&gt;]</strong></span>
type Node(name : string, ?content : Node list) =
  member x.Name = name
  member x.Content = content</pre></div><div class="sect2" title="Abstract Members"><div class="titlepage"><div><div><h3 class="title" id="abstract_members">Abstract Members</h3></div></div></div><p>One reason to define an abstract class is to define <span class="emphasis"><em>abstract members</em></span>, that is, members without an implementation. Abstract members are allowed only in abstract classes (or interfaces, described in <a class="xref" href="ch04.html#interfaces" title="Interfaces">Interfaces</a>) and must be implemented in a derived class. They’re handy when you want to define what a class does but not how it does it.</p><div class="sect3" title="Abstract Properties"><div class="titlepage"><div><div><h4 class="title" id="abstract_properties">Abstract Properties</h4></div></div></div><p>When you want to define the data associated with a particular type but not how that data is stored or what happens when it is accessed, you can define an <span class="emphasis"><em>abstract property</em></span> with the <code class="literal">abstract</code> keyword.</p><p>For example, this abstract class contains one abstract property:</p><a id="pro_id00195"/><pre class="programlisting">[&lt;AbstractClass&gt;]
type AbstractBaseClass() =
  <span class="strong"><strong>abstract member SomeData : string with get, set</strong></span></pre><p><code class="literal">AbstractBaseClass</code> requires only that its subtypes implement the <code class="literal">SomeData</code> property, but they’re free to implement their own storage mechanism. For instance, one derived class may use a traditional backing store, whereas another may opt to use a .NET generic dictionary as follows:</p><a id="pro_id00196"/><pre class="programlisting">type BindingBackedClass() =
  <span class="strong"><strong>inherit AbstractBaseClass()</strong></span>
  let mutable someData = ""
  <span class="strong"><strong>override x.SomeData</strong></span>
    with get() = someData
    and set(v) = someData &lt;- v

type DictionaryBackedClass() =
  <span class="strong"><strong>inherit AbstractBaseClass()</strong></span>
  let dict = System.Collections.Generic.Dictionary&lt;string, string&gt;()
[&lt;Literal&gt;]
let SomeDataKey = "SomeData"
<span class="strong"><strong>override x.SomeData</strong></span>
  with get() =
    match dict.TryGetValue(SomeDataKey) with
    | true, v -&gt; v
    | _, _ -&gt; ""
  and set(v) =
    match System.String.IsNullOrEmpty(v) with
    | true when dict.ContainsKey(SomeDataKey) -&gt;
        dict.Remove(SomeDataKey) |&gt; ignore
    | _ -&gt; dict.[SomeDataKey] &lt;- v</pre><p><a id="iddle1081" class="indexterm"/>As you can see, both <code class="literal">BindingBackedClass</code> and <code class="literal">DictionaryBackedClass</code> derive from <code class="literal">AbstractBaseClass</code>, but they implement the <code class="literal">SomeData</code> property in very different ways.</p></div><div class="sect3" title="Abstract Methods"><div class="titlepage"><div><div><h4 class="title" id="abstract_methods">Abstract Methods</h4></div></div></div><p>Even though you can define abstract properties, you’re much more likely to use <span class="emphasis"><em>abstract methods</em></span>. Like abstract properties, abstract methods allow you to define a capability that derived classes must implement without specifying any of the implementation details. For example, when calculating the area of a shape, you might define an abstract <code class="literal">Shape</code> class that includes an abstract <code class="literal">GetArea</code> method.</p><a id="pro_id00197"/><pre class="programlisting">[&lt;AbstractClass&gt;]
type Shape() =
  <span class="strong"><strong>abstract member GetArea : unit -&gt; float</strong></span></pre><p>Because the method doesn’t have an implementation, you must explicitly define the entire signature. In this case, the <code class="literal">GetArea</code> method accepts <code class="literal">unit</code> and returns a float.</p><p>Overriding a method is also similar to overriding a property, as you can see in the following <code class="literal">Circle</code> and <code class="literal">Rectangle</code> classes:</p><a id="pro_id00198"/><pre class="programlisting">open System

type Circle(r : float) =
  inherit Shape()
  member val Radius = r
  <span class="strong"><strong>override x.GetArea()</strong></span> =
    Math.Pow(Math.PI * r, 2.0)

type Rectangle(w : float, h : float) =
  inherit Shape()
  member val Width = w
  member val Height = h
  <span class="strong"><strong>override x.GetArea()</strong></span> = w * h</pre></div></div><div class="sect2" title="Virtual Members"><div class="titlepage"><div><div><h3 class="title" id="virtual_members">Virtual Members</h3></div></div></div><p><a id="iddle1304" class="indexterm"/><a id="iddle1717" class="indexterm"/><a id="iddle1863" class="indexterm"/><a id="iddle1865" class="indexterm"/><a id="iddle2109" class="indexterm"/><a id="iddle2110" class="indexterm"/>Like C# and Visual Basic, F# allows <span class="emphasis"><em>virtual members</em></span>—that is, properties or methods that can be overridden in a derived class. But unlike other .NET languages, F# takes a more literal approach to virtual members. For instance, in C# you include the <code class="literal">virtual</code> modifier in a nonprivate instance member definition, and in Visual Basic you use the <code class="literal">Overridable</code> modifier to achieve the same effect.</p><p>Virtual members in F# are closely related to abstract members. In fact, in order to create a virtual member you first define an abstract member and then provide a default implementation with the <code class="literal">default</code> keyword. For example, in the following listing the <code class="literal">Node</code> class is the basis for a simple tree structure. It provides two virtual methods, <code class="literal">AddChild</code> and <code class="literal">RemoveChild</code>, which help control the tree structure.</p><a id="pro_id00199"/><pre class="programlisting">open System
open System.Collections.Generic

type Node(name : string) =
  let children = List&lt;Node&gt;()
  member x.Children with get() = children.AsReadOnly()
  <span class="strong"><strong>abstract member AddChild : Node -&gt; unit</strong></span>
  <span class="strong"><strong>abstract member RemoveChild : Node -&gt; unit</strong></span>
  <span class="strong"><strong>default x.AddChild(n) = children.Add n</strong></span>
  <span class="strong"><strong>default x.RemoveChild(n) = children.Remove n |&gt; ignore</strong></span></pre><p>With this definition, all <code class="literal">Node</code> class instances (including any derived types) will allow children. To create a specialized <code class="literal">Node</code> that doesn’t allow children, you could define a <code class="literal">TerminalNode</code> class and override both virtual methods to prevent children from being added or removed.</p><a id="pro_id00200"/><pre class="programlisting">type TerminalNode(name : string) =
  inherit Node(name)
  [&lt;Literal&gt;]
  let notSupportedMsg = "Cannot add or remove children"
  <span class="strong"><strong>override x.AddChild(n)</strong></span> =
    raise (NotSupportedException(notSupportedMsg))
  <span class="strong"><strong>override x.RemoveChild(n)</strong></span> =
    raise (NotSupportedException(notSupportedMsg))</pre></div><div class="sect2" title="Sealed Classes"><div class="titlepage"><div><div><h3 class="title" id="sealed_classes">Sealed Classes</h3></div></div></div><p>A <span class="emphasis"><em>sealed class</em></span> is a class that cannot serve as the base class for another class. One of the most notable sealed classes in the .NET Framework is <code class="literal">System.String</code>.</p><p>You can create your own sealed classes by decorating them with the <code class="literal">Sealed</code> attribute, as shown in the following snippet:</p><a id="pro_id00201"/><pre class="programlisting"><span class="strong"><strong>[&lt;Sealed&gt;]</strong></span>
type NotInheritable() = class end</pre><p><a id="iddle1864" class="indexterm"/><a id="iddle1942" class="indexterm"/><a id="iddle1943" class="indexterm"/><a id="iddle1945" class="indexterm"/><a id="iddle1947" class="indexterm"/>If you tried to create another class that inherits from the <code class="literal">NotInheritable</code> class, the compiler would raise an error like this:</p><a id="pro_id00202"/><pre class="programlisting">&gt; <span class="strong"><strong>type InvalidClass() =</strong></span>
     <span class="strong"><strong>inherit NotInheritable();;</strong></span>

       inherit NotInheritable();;
       --^^^^^^^^^^^^^^^^^^^^^^^^

stdin(4,3): error FS0945: Cannot inherit a sealed type</pre></div></div><div class="sect1" title="Static Members"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="static_members">Static Members</h2></div></div></div><p>Fields, properties, and methods are instance members by default. You can make each static so that it applies to the type rather than a specific instance by including the <code class="literal">static</code> keyword before the member definition.</p><div class="sidebar"><a id="word_about_static_classes"/><div class="sidebar-title">A Word about Static Classes</div><p>In C# a <span class="emphasis"><em>static class</em></span> is an implicitly sealed class that cannot be instantiated and in which all members are static. Most of the time in F#, when you want static class–like functionality, you’ll place it in a module. However, modules have certain limitations. For example, they don’t allow you to overload functions.</p><p>Although F# doesn’t directly support static classes the way that C# does, you can do a little syntactic dance to achieve a similar effect. To do so, omit the primary constructor (or make it private if you need a static initializer) to ensure that no instances can be created, and then verify that every member is static (the F# compiler won’t enforce this for you). For completeness, decorate the class with <code class="literal">SealedAttribute</code> so that nothing inherits from it.</p></div><div class="sect2" title="Static Initializers"><div class="titlepage"><div><div><h3 class="title" id="static_initializers">Static Initializers</h3></div></div></div><p><span class="emphasis"><em>Static initializers</em></span>, or <span class="emphasis"><em>static constructors</em></span>, execute only once per class and ensure that certain code is executed before a class is used for the first time. You create static initializers in F# through a series of static <code class="literal">let</code> and <code class="literal">do</code> bindings, just as you would when defining a primary constructor. In fact, if your class needs a static initializer, you must include a primary constructor to contain the static bindings as shown here:</p><a id="pro_id00203"/><pre class="programlisting">type ClassWithStaticCtor() =
  <span class="strong"><strong>static let mutable staticField = 0</strong></span>
  <span class="strong"><strong>static do printfn "Invoking static initializer"</strong></span>
            <span class="strong"><strong>staticField &lt;- 10</strong></span>
  do printfn "Static Field Value: %i" staticField</pre><p><a id="iddle1944" class="indexterm"/><a id="iddle1946" class="indexterm"/><a id="iddle1949" class="indexterm"/>Static initializers can access only the static members of their containing class. If you try to access an instance member from within a static initializer, you’ll get a compiler error.</p></div><div class="sect2" title="Static Fields"><div class="titlepage"><div><div><h3 class="title" id="static_fields">Static Fields</h3></div></div></div><p><span class="emphasis"><em>Static fields</em></span> are often useful as a single reference for something you need to use repeatedly. For example, to associate certain data with the class itself, define a static field by including the <code class="literal">static</code> keyword before a <code class="literal">let</code> binding, as shown here:</p><a id="pro_id00204"/><pre class="programlisting">module Logger =
  let private log l c m = printfn "%-5s [%s] %s" l c m
  let LogInfo = log "INFO"
  let LogError = log "ERROR"

type MyService() =
  <span class="strong"><strong>static let logCategory = "MyService"</strong></span>
  member x.DoSomething() =
    Logger.LogInfo logCategory "Doing something"
  member x.DoSomethingElse() =
    Logger.LogError logCategory "Doing something else"</pre><p>When the <code class="literal">DoSomething</code> and <code class="literal">DoSomethingElse</code> methods are called, each calls a function in the <code class="literal">Logger</code> module to write a log message in the same category but without the duplication of data.</p><a id="pro_id00205"/><pre class="programlisting">&gt; <span class="strong"><strong>let svc = MyService()</strong></span>
<span class="strong"><strong>svc.DoSomething()</strong></span>
<span class="strong"><strong>svc.DoSomethingElse();;</strong></span>
INFO [MyService] Doing something
ERROR [MyService] Doing something else</pre></div><div class="sect2" title="Static Properties"><div class="titlepage"><div><div><h3 class="title" id="static_properties">Static Properties</h3></div></div></div><p>Properties can also be static. Here, a read-only <span class="emphasis"><em>static property</em></span> is used to expose the number of times a particular method has been called across all instances of your class.</p><a id="pro_id00206"/><pre class="programlisting">type Processor() =
  static let mutable itemsProcessed = 0
  <span class="strong"><strong>static member ItemsProcessed = itemsProcessed</strong></span>
  member x.Process() =
    <span class="strong"><strong>itemsProcessed &lt;- itemsProcessed + 1</strong></span>
    printfn "Processing..."</pre><p>Every time the <code class="literal">Process</code> method is called, it increments the <code class="literal">itemsProcessed</code> field and prints a message. To see how many times the <code class="literal">Process</code> method has been called across all instances, inspect the <code class="literal">ItemsProcessed</code> property on the <code class="literal">Processor</code> class itself.</p><a id="pro_id00207"/><pre class="programlisting">&gt; <span class="strong"><strong>while Processor.ItemsProcessed &lt; 5 do (Processor()).Process();;</strong></span>
Processing...
Processing...
Processing...
Processing...
Processing...
val it : unit = ()</pre><p><a id="iddle1419" class="indexterm"/><a id="iddle1948" class="indexterm"/>This example iterates as long as the <code class="literal">Process</code> method has been invoked fewer than five times. Each iteration creates a new instance of the <code class="literal">Processor</code> class and invokes its <code class="literal">Process</code> method (which illustrates how the static property is instance agnostic).</p></div><div class="sect2" title="Static Methods"><div class="titlepage"><div><div><h3 class="title" id="static_methods">Static Methods</h3></div></div></div><p>Like other static members, <span class="emphasis"><em>static methods</em></span> apply to a type rather than an instance. For example, static methods are commonly used in the <span class="emphasis"><em>Factory pattern</em></span> (a common approach to creating instances of similar classes without relying on a specific implementation). In some variations of the Factory pattern, a static method returns new instances of objects that conform to a specific interface. To illustrate this concept, consider an application where you need to handle different image formats. You may have an abstract <code class="literal">ImageReader</code> class that other types derive from in order to handle specific formats like JPEG, GIF, and PNG.</p><a id="pro_id00208"/><pre class="programlisting">[&lt;AbstractClass&gt;]
type ImageReader() =
  abstract member Dimensions : int * int with get
  abstract member Resolution : int * int with get
  abstract member Content : byte array with get

type JpgImageReader(fileName : string) =
  inherit ImageReader()
  -- <span class="emphasis"><em>snip</em></span> --

type GifImageReader(fileName : string) =
  inherit ImageReader()
  -- <span class="emphasis"><em>snip</em></span> --

type PngImageReader(fileName : string) =
  inherit ImageReader()
  -- <span class="emphasis"><em>snip</em></span> --</pre><p>A Factory method for creating instances of these classes might look something like this:</p><a id="pro_id00209"/><pre class="programlisting">open System.IO

[&lt;Sealed&gt;]
type ImageReaderFactory private() =
  static member CreateReader(fileName) =
    let fi = FileInfo(fileName)

    match fi.Extension.ToUpper() with
    | ".JPG" -&gt; JpgImageReader(fileName) :&gt; ImageReader
    | ".GIF" -&gt; GifImageReader(fileName) :&gt; ImageReader
    | ".PNG" -&gt; PngImageReader(fileName) :&gt; ImageReader
    | ext -&gt; failwith (sprintf "Unsupported extension: %s" ext)</pre><p><a id="iddle1121" class="indexterm"/><a id="iddle1537" class="indexterm"/><a id="iddle1664" class="indexterm"/>The static <code class="literal">CreateReader</code> method in the preceeding snippet uses F# pattern matching to create the appropriate <code class="literal">ImageReader</code> implementation based on the provided filename. When the file extension isn’t recognized, it raises an exception indicating that the format isn’t supported. Because the method is static, you can call it without creating an instance of the <code class="literal">ImageReaderFactory</code> class, as shown here:</p><a id="pro_id00210"/><pre class="programlisting">ImageReaderFactory.CreateReader "MyPicture.jpg"
ImageReaderFactory.CreateReader "MyPicture.gif"
ImageReaderFactory.CreateReader "MyPicture.png"
ImageReaderFactory.CreateReader "MyPicture.targa"</pre></div></div><div class="sect1" title="Mutually Recursive Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="mutually_recursive_types">Mutually Recursive Types</h2></div></div></div><p>When two or more types depend on each other such that one cannot be used without the other, the types are said to be <span class="emphasis"><em>mutually recursive</em></span>.</p><p>To illustrate, think of a book and its pages. The book can contain a collection of pages, but each page might also refer back to the book. Remember, F# is evaluated top-down, so which type would you define first? The book or the page? Because the book depends on its pages and the page refers back to the book, there is mutual recursion here. This means that you must define the types together using the <code class="literal">and</code> keyword, as shown here:</p><a id="pro_id00211"/><pre class="programlisting"><span class="strong"><strong>type Book() =</strong></span>
  let pages = List&lt;Page&gt;()
  member x.Pages with get() = pages.AsReadOnly()
  member x.AddPage(pageNumber : int, page : Page) =
    if page.Owner = Some(x) then failwith "Page is already part of a book"
    pages.Insert(pageNumber - 1, page)
<span class="strong"><strong>and Page(content : string) =</strong></span>
  let mutable owner : Book option = None
  member x.Content = content
  member x.Owner with get() = owner
  member internal x.Owner with set(v) = owner &lt;- v
  override x.ToString() = content</pre></div><div class="sect1" title="Interfaces"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="interfaces">Interfaces</h2></div></div></div><p>In OO programming, <span class="emphasis"><em>interfaces</em></span> specify the properties, methods, and sometimes even events that a type must support. In some ways interfaces are like abstract classes, with certain important differences. For one, unlike abstract classes, interfaces cannot contain any implementations of their members; their members must be abstract. Also, because interfaces define <a id="iddle1512" class="indexterm"/><a id="iddle1539" class="indexterm"/>functionality that implementers must support, all interface members are implicitly public. Finally, interfaces aren’t subject to the same inheritance restrictions as classes: A class can implement any number of interfaces (and structs can, too).</p><div class="sect2" title="Implementing Interfaces"><div class="titlepage"><div><div><h3 class="title" id="implementing_interfaces">Implementing Interfaces</h3></div></div></div><p>F# approaches interface implementation a bit differently than its .NET language counterparts. C# and Visual Basic allow both implicit and explicit implementations. With <span class="emphasis"><em>implicit implementations</em></span>, interface members are accessible directly through the implementing class, whereas with <span class="emphasis"><em>explicit implementations</em></span>, interface members are accessible only when the implementing type is treated as the interface.</p><p>Consider this C# example with two classes that both implement the <code class="literal">IDisposable</code> interface:</p><a id="pro_id00212"/><pre class="programlisting">// C#

class ImplicitExample : IDisposable
{
① <span class="strong"><strong>public void Dispose()</strong></span>
  {
    Console.WriteLine("Disposing");
  }
}

class ExplicitExample : IDisposable
{
② <span class="strong"><strong>void IDisposable.Dispose()</strong></span>
  {
    Console.WriteLine("Disposing");
  }
}</pre><p>Both classes implement <code class="literal">IDisposable</code>, but <code class="literal">ImplicitExample</code>① does so implicitly and <code class="literal">ExplicitExample</code> ② does it explicitly. This difference has a dramatic effect on how you call the <code class="literal">Dispose</code> method in each class, as shown here:</p><a id="pro_id00213"/><pre class="programlisting">  // C#

  var ex1 = ①new ImplicitExample();
② ex1.Dispose();

  var ex2 = ③ new ExplicitExample();
④ ((IDisposable)ex2).Dispose();</pre><p>Here we instantiate <code class="literal">ImplicitExample</code> at ① and <code class="literal">ExplicitExample</code> at ③. For both classes we call the <code class="literal">Dispose</code> method, but because <code class="literal">Dispose</code> is implicitly implemented in the <code class="literal">ImplicitExample</code> class we can call it directly through <code class="literal">ex1</code>, as we do at ②. The compiler would produce an error if we tried the same <a id="iddle1513" class="indexterm"/><a id="iddle1536" class="indexterm"/><a id="iddle1538" class="indexterm"/><a id="iddle1541" class="indexterm"/><a id="iddle1626" class="indexterm"/><a id="iddle2054" class="indexterm"/>approach with <code class="literal">ex2</code> because <code class="literal">Dispose</code> is explicitly implemented in <code class="literal">ExplicitExample</code>. Instead, we need to cast <code class="literal">ex2</code> to <code class="literal">IDisposable</code>, as shown at ④, in order to call its <code class="literal">Dispose</code> method.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note04"/>Note</h3><p><span class="emphasis"><em>All interface implementations in F# are explicit. Though F# honors implicit interface implementations on types defined in other languages, any implementations that you define in F# will be explicit.</em></span></p></div><p>Implementing an interface in F# is similar to inheriting from another class except that it uses the <code class="literal">interface</code> keyword. For example, to implement <code class="literal">IDisposable</code> in one of your types, you could do this:</p><a id="pro_id00214"/><pre class="programlisting">open System

type MyDisposable() =
  <span class="strong"><strong>interface IDisposable with</strong></span>
    member x.Dispose() = printfn "Disposing"</pre><p>To manually invoke the <code class="literal">Dispose</code> method on the <code class="literal">MyDisposable</code> class, you’ll need to cast an instance to <code class="literal">IDisposable</code>, as shown here with the static cast operator:</p><a id="pro_id00215"/><pre class="programlisting">let d = new MyDisposable()
(d :&gt; IDisposable).Dispose()</pre></div><div class="sect2" title="Defining Interfaces"><div class="titlepage"><div><div><h3 class="title" id="defining_interfaces">Defining Interfaces</h3></div></div></div><p>When you define a type without any constructors and only abstract members, the F# compiler infers that the type is an interface. For example, an interface for working with image data might look something like this:</p><a id="pro_id00216"/><pre class="programlisting">open System.Drawing
open System.IO

<span class="strong"><strong>type IImageAdapter =</strong></span>
  <span class="strong"><strong>abstract member PixelDimensions : SizeF with get</strong></span>
  <span class="strong"><strong>abstract member VerticalResolution : int with get</strong></span>
  <span class="strong"><strong>abstract member HorizontalResolution : int with get</strong></span>
  <span class="strong"><strong>abstract member GetRawData : unit -&gt; Stream</strong></span></pre><p>As you can see, the <code class="literal">IImageAdapter</code> type contains no constructors and all of its four members are abstract. To define an empty, or <span class="emphasis"><em>marker</em></span>, interface you can end the definition with the <code class="literal">interface end</code> keyword pair:</p><a id="pro_id00217"/><pre class="programlisting">type IMarker = <span class="strong"><strong>interface end</strong></span></pre><div class="note" title="Note"><h3 class="title"><a id="ch04note05"/>Note</h3><p><span class="emphasis"><em>It’s standard practice in .NET development to begin interface names with a capital letter</em></span> I <span class="emphasis"><em>. You should do so for the sake of consistency.</em></span></p></div><p><a id="iddle1053" class="indexterm"/><a id="iddle1527" class="indexterm"/><a id="iddle1540" class="indexterm"/><a id="iddle1691" class="indexterm"/><a id="iddle1695" class="indexterm"/><a id="iddle1696" class="indexterm"/><a id="iddle1716" class="indexterm"/><a id="iddle1776" class="indexterm"/>Like classes, interfaces can inherit from each other to define more specialized contracts. Also like classes, interface inheritance is accomplished with the <code class="literal">inherit</code> keyword.</p><p>Let’s continue our imaging example. The <code class="literal">IImageAdapter</code> interface is helpful for working with any image format, but some formats include capabilities not available in others. To handle these, you could define additional interfaces that represent these capabilities. For example, when working with a format that supports transparency you might create an <code class="literal">ITransparentImageAdapter</code> that derives from <code class="literal">IImageAdapter</code>, as shown here:</p><a id="pro_id00218"/><pre class="programlisting">type ITransparentImageAdapter =
  inherit IImageAdapter
  abstract member TransparentColor : Color with get, set</pre><p>Now, any types that implement the <code class="literal">ITransparentImageAdapter</code> must implement all members defined by both <code class="literal">IImageAdapter</code> and <code class="literal">ITransparentImageAdapter</code>.</p></div></div><div class="sect1" title="Custom Operators"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="custom_operators">Custom Operators</h2></div></div></div><p>In <a class="xref" href="ch03.html" title="Chapter 3. Fundamentals">Chapter 3</a> you saw numerous predefined operators for working with the built-in data types. You can use <span class="emphasis"><em>operator overloading</em></span> to extend many of these to your types as well. By overloading operators, you can make your custom types interact a bit more naturally.</p><p>Operators in F# come in two forms: prefix and infix. <span class="emphasis"><em>Prefix operators</em></span> are placed before their operand, whereas <span class="emphasis"><em>infix operators</em></span> are placed between their operands. F# operators can also be <span class="emphasis"><em>unary</em></span> or <span class="emphasis"><em>binary</em></span>, meaning that they operate against one or two arguments, respectively. Custom operators are defined as static methods except that the name is the operator wrapped in parentheses.</p><div class="sect2" title="Prefix Operators"><div class="titlepage"><div><div><h3 class="title" id="prefix_operators">Prefix Operators</h3></div></div></div><p>When defining a prefix operator, you must begin its name with a tilde (<code class="literal">~</code>) to distinguish it from infix operators with the same name. The tilde is not otherwise part of the operator. To demonstrate operator overloading, we’ll define a type that represents basic RGB colors. Consider this class definition:</p><a id="pro_id00219"/><pre class="programlisting">type RgbColor(r, g, b) =
  member x.Red = r
  member x.Green = g
  member x.Blue = b
  override x.ToString() = sprintf "(%i, %i, %i)" r g b</pre><p>To calculate the negative color you could define a <code class="literal">GetNegative</code> function, but wouldn’t it be more intuitive to prefix an instance with the negative sign (<code class="literal">-</code>) instead?</p><a id="pro_id00220"/><pre class="programlisting">type RgbColor(r, g, b) =
  -- <span class="emphasis"><em>snip</em></span> --
  /// Negate a color
  <span class="strong"><strong>static member (~-) (r : RgbColor) =</strong></span>
    RgbColor(
      r.Red ^^^ 0xFF,
      r.Green ^^^ 0xFF,
      r.Blue ^^^ 0xFF
    )</pre><p><a id="iddle1693" class="indexterm"/>With the custom operator defined, you can now create a color instance and find its negative with a convenient syntax like this:</p><a id="pro_id00221"/><pre class="programlisting"><span class="strong"><strong>&gt; let yellow = RgbColor(255, 255, 0)</strong></span>
<span class="strong"><strong>let blue = -yellow;;</strong></span>

val yellow : RgbColor = (255, 255, 0)
val blue : RgbColor = (0, 0, 255)</pre></div><div class="sect2" title="Infix Operators"><div class="titlepage"><div><div><h3 class="title" id="infix_operators">Infix Operators</h3></div></div></div><p>Creating infix operators is almost like creating prefix operators except that you omit the tilde character from the name.</p><p>Continuing with the <code class="literal">RgbColor</code> example, it would be nice to add and subtract two colors using the familiar and natural <code class="literal">+</code> and <code class="literal">-</code> operators.</p><a id="pro_id00222"/><pre class="programlisting">open System

type RgbColor(r, g, b) =
  -- <span class="emphasis"><em>snip</em></span> --
  /// Add two colors
  <span class="strong"><strong>static member (+) (l : RgbColor, r : RgbColor) =</strong></span>
    RgbColor(
      Math.Min(255, l.Red + r.Red),
      Math.Min(255, l.Green + r.Green),
      Math.Min(255, l.Blue + r.Blue)
    )
  /// Subtract two colors
  <span class="strong"><strong>static member (-) (l : RgbColor, r : RgbColor) =</strong></span>
    RgbColor(
      Math.Max(0, l.Red - r.Red),
      Math.Max(0, l.Green - r.Green),
      Math.Max(0, l.Blue - r.Blue)
    )</pre><p>Now we can add and subtract colors just as we would add and subtract numbers.</p><a id="pro_id00223"/><pre class="programlisting"><span class="strong"><strong>&gt; let red = RgbColor(255, 0, 0)</strong></span>
<span class="strong"><strong>let green = RgbColor(0, 255, 0)</strong></span>
<span class="strong"><strong>let yellow = red + green;;</strong></span>

val red : RgbColor = (255, 0, 0)
val green : RgbColor = (0, 255, 0)
val yellow : RgbColor = (255, 255, 0)

<span class="strong"><strong>&gt; let magenta = RgbColor(255, 0, 255)</strong></span>
<span class="strong"><strong>let blue = magenta - red;;</strong></span>

val magenta : RgbColor = (255, 0, 255)
val blue : RgbColor = (0, 0, 255)</pre></div><div class="sect2" title="New Operators"><div class="titlepage"><div><div><h3 class="title" id="new_operators">New Operators</h3></div></div></div><p><a id="iddle1692" class="indexterm"/><a id="iddle1694" class="indexterm"/>You’re not limited to overloading only existing operators. You can define custom operators using various combinations of the characters <code class="literal">!</code>, <code class="literal">%</code>, <code class="literal">&amp;</code>, <code class="literal">*</code>, <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">.</code>, <code class="literal">/</code>, <code class="literal">&lt;</code>, <code class="literal">=</code>, <code class="literal">&gt;</code>, <code class="literal">?</code>, <code class="literal">@</code>, <code class="literal">^</code>, <code class="literal">|</code>, and <code class="literal">~</code>. Creating custom operators can be complicated because the combination you select determines the precedence (priority) and associativity (right to left or left to right) of the operation. Furthermore, creating custom operators can hinder the comprehensibility of your code if you choose something that’s not intuitive. That said, if you still want to define a new operator, the definition looks the same as an overload.</p><p>For example, in the previous section we overloaded the <code class="literal">+</code> operator to add two colors, but how about blending colors? The <code class="literal">+</code> operator would have been a nice choice for a blending operation, but because it’s already being used for adding colors we can define the <code class="literal">+=</code> operator instead.</p><a id="pro_id00224"/><pre class="programlisting">type RgbColor(r, g, b) =
  -- <span class="emphasis"><em>snip</em></span> --
  /// Blend two colors
  <span class="strong"><strong>static member (+=) (l : RgbColor, r : RgbColor) =</strong></span>
    RgbColor(
      (l.Red + r.Red) / 2,
      (l.Green + r.Green) / 2,
      (l.Blue + r.Blue) / 2
    )</pre><p>Now blending two colors is as easy as adding them:</p><a id="pro_id00225"/><pre class="programlisting"><span class="strong"><strong>&gt; let grey = yellow += blue;;</strong></span>

val grey : RgbColor = (127, 127, 127)</pre></div><div class="sect2" title="Global Operators"><div class="titlepage"><div><div><h3 class="title" id="global_operators">Global Operators</h3></div></div></div><p>Not only does F# allow you to overload operators on types, but you can also define operators globally. This lets you create new operators even for types <a id="iddle1684" class="indexterm"/>you don’t control! For example, to define any of the custom operators on the standard <code class="literal">System.Drawing.Color</code> struct, you could define a new operator at the global level using a <code class="literal">let</code> binding as follows:</p><a id="pro_id00226"/><pre class="programlisting">open System
open System.Drawing

<span class="strong"><strong>let (+) (l : Color) (r : Color) =</strong></span>
    Color.FromArgb(
      255, // Alpha channel
      Math.Min(255, int &lt;| l.R + r.R),
      Math.Min(255, int &lt;| l.G + r.G),
      Math.Min(255, int &lt;| l.B + r.B)
    )</pre><div class="warning" title="Warning" epub:type="warning"><h3 class="title"><a id="ch04note06"/>Warning</h3><p><span class="emphasis"><em>Be careful when defining global operators. Any operator you define that conflicts with the built-in one will take priority, meaning you can inadvertently replace core functionality.</em></span></p></div></div></div><div class="sect1" title="Object Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="object_expressions">Object Expressions</h2></div></div></div><p>As an alternative to formal inheritance, F# provides <span class="emphasis"><em>object expressions</em></span>, a handy construct for creating ad hoc (anonymous) types based on an existing class or interface. Object expressions are useful when you need a one-off type but don’t want to create a formal type. (Although the analogy isn’t perfect, you might find it helpful to think of object expressions as lambda expressions for types, because the result of an object expression is an instance of a new type that implements the interface or inherits from a base class.)</p><p>For example, consider a simplified game scenario where a character can equip a weapon. You might see a weapon interface and character class like this:</p><a id="pro_id00227"/><pre class="programlisting">type IWeapon =
  abstract Description : string with get
  abstract Power : int with get

type Character(name : string, maxHP : int) =
  member x.Name = name
  member val HP = maxHP with get, set
  member val Weapon : IWeapon option = None with get, set
  member x.Attack(o : Character) =
    let power = match x.Weapon with
                | Some(w) -&gt; w.Power
                | None -&gt; 1 // fists
    o.HP &lt;- System.Math.Max(0, o.HP - power)
  override x.ToString() =
    sprintf "%s: %i/%i" name x.HP maxHP</pre><p><a id="iddle1675" class="indexterm"/><a id="iddle2120" class="indexterm"/>You can use these definitions to create a few characters:</p><a id="pro_id00228"/><pre class="programlisting">let witchKing = Character("Witch-king", 100)
let frodo = Character("Frodo", 50)</pre><p>As currently written, if either character attacked the other he wouldn’t do much damage since he has only his fists. It would be nice to give each character a weapon, but all we have right now is the <code class="literal">IWeapon</code> interface. We could define types for every weapon we can think of, but it’s much more convenient to write a function that creates weapons for us via an object expression.</p><p>Object expressions, like the one in the following <code class="literal">forgeWeapon</code> function, are defined with the <code class="literal">new</code> keyword followed by the type name, the <code class="literal">with</code> keyword, and the member definitions all wrapped in braces.</p><a id="pro_id00229"/><pre class="programlisting">let forgeWeapon desc power =
  <span class="strong"><strong>{ new IWeapon with</strong></span>
      <span class="strong"><strong>member x.Description with get() = desc</strong></span>
      <span class="strong"><strong>member x.Power with get() = power }</strong></span></pre><p>With the <code class="literal">forgeWeapon</code> function in place, we can create some weapons for our characters.</p><a id="pro_id00230"/><pre class="programlisting">&gt; <span class="strong"><strong>let morgulBlade = forgeWeapon "Morgul-blade" 25</strong></span>
<span class="strong"><strong>let sting = forgeWeapon "Sting" 10;;</strong></span>

val morgulBlade : IWeapon
val sting : IWeapon</pre><p>As you can see, both calls to <code class="literal">forgeWeapon</code> result in new instances of <code class="literal">IWeapon</code>. They can be used as if they had been formally defined through type definitions, as you can see by assigning each to a character and invoking the <code class="literal">Attack</code> function:</p><a id="pro_id00231"/><pre class="programlisting">witchKing.Weapon &lt;- Some(morgulBlade)
frodo.Weapon &lt;- Some(sting)

witchKing.Attack frodo</pre><p>Despite their convenience, object expressions aren’t suitable for every situation. One of their primary drawbacks is that they must implement every abstract member from the underlying type. If the underlying interface or base class has many abstract members, an object expression can become cumbersome very quickly, so you would probably want to consider using a different construct.</p><p>Object expressions aren’t limited to a single base type. To implement multiple base types with an object expression, you use an inheritance-like <a id="iddle1386" class="indexterm"/><a id="iddle1568" class="indexterm"/><a id="iddle1676" class="indexterm"/><a id="iddle2043" class="indexterm"/><a id="iddle2044" class="indexterm"/><a id="iddle2045" class="indexterm"/><a id="iddle2046" class="indexterm"/>syntax. For instance, if you wanted weapons created through the <code class="literal">forgeWeapon</code> function to also implement <code class="literal">IDisposable</code>, you could use the following:</p><a id="pro_id00232"/><pre class="programlisting">let forgeWeapon desc power =
  { new IWeapon with
      member x.Description with get() = desc
      member x.Power with get() = power
    <span class="strong"><strong>interface System.IDisposable with</strong></span>
      <span class="strong"><strong>member x.Dispose() = printfn "Disposing"</strong></span> }</pre><p>Creating a new weapon is the same as earlier:</p><a id="pro_id00233"/><pre class="programlisting">let narsil = forgeWeapon "Narsil" 25</pre><p>Objects created through object expressions that include multiple base types are always treated as the type listed immediately after the <code class="literal">new</code> keyword, unless they’re explicitly cast to one of the other types. For example, in the case of the <code class="literal">forgeWeapon</code> function, the returned object will be <code class="literal">IWeapon</code> unless you cast it to <code class="literal">IDisposable</code>.</p><a id="pro_id00234"/><pre class="programlisting">(narsil :?&gt; System.IDisposable).Dispose()</pre></div><div class="sect1" title="Type Extensions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="type_extensions">Type Extensions</h2></div></div></div><p>When LINQ was added to the .NET Framework, one exciting feature that it introduced to C# and Visual Basic was extension methods. <span class="emphasis"><em>Extension methods</em></span> allow you to add new methods to an existing type without relying on inheritance or other design patterns such as the Decorator pattern. F# provides similar capabilities except that it doesn’t stop with methods. In F#, you can create extension methods, properties, events, and even static members!</p><p>You extend existing types in F# through <span class="emphasis"><em>type extensions</em></span>, or <span class="emphasis"><em>type augmentations</em></span>. Type extensions come in two flavors: intrinsic and optional.</p><p><span class="emphasis"><em>Intrinsic extensions</em></span> must be defined in the same namespace or module, and in the same source file as the type being extended. The new extensions become part of the extended type when the code is compiled and are visible through reflection. Intrinsic extensions are useful when you want to build up a type incrementally by grouping related pieces or as an alternative to building mutually recursive type definitions.</p><p><span class="emphasis"><em>Optional extensions</em></span> must be defined in a module. Like their C# and Visual Basic counterparts, they are accessible only when their containing namespace or module is open but are not visible through reflection. Optional extensions are most useful for adding custom functionality to types you don’t control or that are defined in other assemblies.</p><p><a id="iddle1384" class="indexterm"/><a id="iddle2122" class="indexterm"/>Regardless of whether you’re defining intrinsic or optional extensions, the syntax is the same. You begin with a new type definition. The difference is that instead of using a primary constructor and an equal sign, you use the <code class="literal">with</code> keyword followed by your extension definitions. For example, here we extend the <code class="literal">Color</code> struct (in <code class="literal">System.Drawing</code>) with both a static and an instance method.</p><a id="pro_id00235"/><pre class="programlisting">module ColorExtensions =
  open System
  open System.Drawing
  open System.Text.RegularExpressions

  // Regular expression to parse the ARGB components from a hex string
① let private hexPattern =
    Regex("^#(?&lt;color&gt;[\dA-F]{8})$", RegexOptions.IgnoreCase ||| RegexOptions.Compiled)

  // Type extension
② type Color with
  ③ static member FromHex(hex) =
      match hexPattern.Match hex with
      | matches when matches.Success -&gt;
        Color.FromArgb &lt;| Convert.ToInt32(matches.Groups.["color"].Value, 16)
      | _ -&gt; Color.Empty
  ④ member x.ToHex() = sprintf "#%02X%02X%02X%02X" x.A x.R x.G x.B</pre><p>This optional type extension enhances the <code class="literal">Color</code> struct’s usability by allowing you to create new instances from known hexadecimal color strings or translate the color into a hexadecimal color string. The type extension itself is at ②. The static extension method ③ relies on the regular expression (a domain-specific language for parsing strings) at ① to match and extract the hexadecimal value to convert it into the ARGB value passed to <code class="literal">Color</code>’s constructor. The instance extension method ④ simply returns the ARGB value formatted as a hexadecimal string.</p><div class="sidebar"><a id="cross-language_considerations"/><div class="sidebar-title">Cross-Language Considerations</div><p>Despite serving a similar purpose, extension methods in F# are implemented differently than in the rest of the .NET Framework. Therefore, optional extension methods defined in F# aren’t accessible as extension methods in C# or Visual Basic unless you include the <code class="literal">Extension</code> attribute in both the type definition and extension methods.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00007">Summary</h2></div></div></div><p>Despite F#’s perception as a niche functional language on the .NET Framework, you’ve seen in this chapter that F# is also a full-featured OO language. Numerous examples demonstrated how F#’s concise syntax aids you in developing robust OO frameworks complete with classes, structures, and interfaces. You’ve even seen how to implement some common design patterns like Singleton and Factory.</p><p>Although F# supports the same common OO concepts as its more established counterpart languages, you’ve learned how it takes familiar concepts like operator overloading, events, and extension methods and expands them into something much more powerful through observation and type augmentation. Finally, you’ve seen how entirely new constructs like object expressions can improve code quality by allowing you to create ad hoc types when and where you need them.</p></div></section></body></html>