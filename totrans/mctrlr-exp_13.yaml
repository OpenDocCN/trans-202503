- en: '**13  Basics of Glitching**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dear reader, please indulge me in a little mythology. After that, we’ll move
    on to modern clock and voltage glitching attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Way back in the good old days, so the story says, a satellite TV smart card
    was vulnerable to memory corruption. The people did rejoice, as a memory corruption
    exploit was sufficient to unlock all of the channels and extract all of the card’s
    memory. Then from the heavens came a message—an EEPROM update, rather than a prophecy—and
    the cards were patched to spin in an infinite loop rather than decode Captain
    Picard’s latest fight with the Borg. The exact patch and the exact card are lost
    to time, but in C we might say the code looked something like the following.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0131-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because the card spins in an infinite loop rather than doing its job, pirates
    called it “looped.” From this they invented “unlooping,” the technique of messing
    with the card’s voltage or clock to jump out of the infinite loop. Today we call
    these techniques “fault injection” or “glitching,” and they are still brutally
    effective at removing protections from chips.
  prefs: []
  type: TYPE_NORMAL
- en: The trick is to very briefly drop the voltage supply to the chip, or to introduce
    a very brief additional cycle to the clock supply line. Like running the chip
    too fast or on too little power, this causes instructions to be mis-executed.
    But because the violation is so brief, as little as one instruction will be corrupted
    while everything else remains fine.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the smart card will spin forever executing the `while` loop
    on line 3\. Optimizations and assembly languages will express it differently,
    but imagine it becomes the following pseudo-assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0132-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the device is looped, the microcontroller will execute lines 2 and 3 in
    sequence forever. If we shorten the clock so that the jump-if-equal instruction
    on line 3 does not write over the program counter, execution will continue on
    line 5, calling the main method as if this chip weren’t locked. Because the loop
    runs continuously, the chip is helpfully giving us many tries before each reboot.
  prefs: []
  type: TYPE_NORMAL
- en: Another good target is a copy loop. At startup, a smart card often presents
    its Answer To Reset (ATR) string. If the `for` loop that sends the string is like
    this, we might leak extra bytes of memory out of the card by glitching as `i`
    is compared to `16` after the last byte. When the comparison is exact (*i* ≠ 16)
    instead of a range (*i <* 16), this might dump a lot of extra memory!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0132-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the early 2000s, unlooper hardware was commercially sold to hobbyists and
    schematics for home designs were passed around on forums. Most consisted of an
    Atmel AT90 microcontroller with 7400 series chips to insert glitches on the clock
    and data lines against the DirecTV HU Card.^([1](footnotes.xhtml#ch13fn1)) See
    [Figure 13.1](ch13.xhtml#ch13fig1) for an example, and search eBay for “Mikobu”
    if you’d prefer to purchase one already made.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0133-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Smart Card Unlooper from PLC77 (2001)'
  prefs: []
  type: TYPE_NORMAL
- en: As far as software goes, most of these unlooper designs require firmware to
    be loaded into the AT90 through the MAX232 chip over a serial port. While many
    glitching programs were shared as source code or black box binaries, there was
    also a tradition of sharing them as commented VBScript for a program called WinExplorer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock Glitching**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a microcontroller is designed, there’s a matter of timing closure. For
    any given chip, there is some maximum clock rate, beneath which the design behaves
    as specified. Beneath this speed, all of the combinational logic gets the right
    result in time to be latched by the sequential logic.
  prefs: []
  type: TYPE_NORMAL
- en: Above this rate, things fail, but not all at once. Maybe multiplication is the
    bottleneck of the clock rate, and exceeding that rate by a little bit causes some
    multiplications to fail while everything else works fine. If you never need multiplication,
    you might exceed this clock rate to get more performance in other functions.
  prefs: []
  type: TYPE_NORMAL
- en: When a chip takes its raw clock input from an external pin, and it doesn’t smooth
    that clock out with a phase-locked loop, we have the opportunity to perform some
    clock glitching. We do this by inserting a short clock pulse, one single edge
    or cycle that is far above the maximum rate of the chip.
  prefs: []
  type: TYPE_NORMAL
- en: In a multi-cycle design, this can be thought of as one piece of one instruction
    being given time to finish. Maybe the wrong opcode is latched in the first cycle
    of the instruction, or maybe a jump never writes back to the program counter at
    the end of the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: I usually begin with a range of time in which the firmware makes an important
    decision, then attempt to fault random points in that range until I get the chip
    to misbehave. Because we control the clock itself, this timing can be extremely
    accurate and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Voltage Glitching**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the raw clock input isn’t available, voltage glitching might still be an
    option. The idea is to abruptly shift the voltage, raising or lowering it for
    such a brief moment that the chip does not crash but it also doesn’t execute its
    instruction properly.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping the voltage has many effects. One is that the transistors flip more
    slowly, so that a device might be well within its timing closure is suddenly unable
    to calculate its results in time, somewhat like clock glitching. An Atmega328P,
    for example, safely runs at 20MHz at 4.5V only 10MHz at 2.7V. Other effects include
    failures in memories and mistaken instruction decoding.
  prefs: []
  type: TYPE_NORMAL
- en: Calibration of a voltage glitch can be tricky. The first axis will be the time
    offset from an observable trigger, like a pin rising high. The duration of change
    and the target voltage will be two more axes, and clock drift will make things
    less reliable the longer we wait after the trigger for the glitch to occur.
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, many modern glitching attacks simply short circuit the
    core voltage to ground and rely on very short timing to prevent a crash.^([2](footnotes.xhtml#ch13fn2))
  prefs: []
  type: TYPE_NORMAL
- en: However you arrange things, it’s important to calibrate your glitching on one
    axis at a time. I do this on a development board with the same chip as my target,
    first running a tight `while` loop that adds up a bunch of numbers and prints
    a warning when they disagree. I can then search for a duration and voltage that
    make the warnings appear, without yet worrying about when to apply the glitch.
    I remove most of the decoupling capacitors, then add them back individually if
    things become too unstable.
  prefs: []
  type: TYPE_NORMAL
- en: Only after successfully injecting faults in this easy target do I bother switching
    over to my real target. It’s there that my trigger and offset matter, and it’s
    best that the other parameters already be dialed in.
  prefs: []
  type: TYPE_NORMAL
