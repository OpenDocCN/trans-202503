<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_119" aria-label="119"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch5">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">5</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">PERSISTENCE</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">Arguably one of the best ways to detect malicious threats on macOS is to focus on persistence. Here, <i>persistence</i> refers to the means by which software, including malware, installs itself on a system to ensure it will automatically re-execute upon startup, user login, or some other deterministic event. Otherwise, it might never run again if the user logs out or the system reboots. In this chapter, I focus solely on enumerating persistent items. In <a href="part2.xhtml">Part II</a>, where I cover approaches that allow events to be observed as they occur, I’ll discuss how to leverage Apple’s Endpoint Security to monitor for persistence events.</p>&#13;
<p class="TX">As a shared characteristic of most malware, persistence serves as a robust detection mechanism capable of uncovering most infections. On <span role="doc-pagebreak" epub:type="pagebreak" id="pg_120" aria-label="120"/>macOS, malware generally persists in one of two ways: as launch items (daemons or agents) or as login items. In this chapter, I’ll show you exactly how to enumerate such items to reveal almost any Mac malware specimen.</p>&#13;
<p class="TX">Of course, not all macOS malware persists. For example, ransomware that encrypts user files or stealers that grab and exfiltrate sensitive user data often have no need to run multiple times, and thus rarely install themselves persistently.</p>&#13;
<p class="TX">On the other hand, legitimate programs designed to run continuously, such as auto-updaters, security tools, or even simple helper utilities, also tend to persist. Thus, the fact that something is persistently installed doesn’t mean our code should flag it as malicious.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-39"/><span class="SANS_Futura_Std_Bold_B_11">Examples of Persistent Malware</span></h3>&#13;
<p class="TNI">Because this chapter focuses on uncovering malware that persists as either a login item or a launch item, let’s start with a brief example of each. Initially disclosed by the researcher Taha Karim, the WindTail malware targeted employees working in government and critical infrastructure in the Middle East.<sup><a role="doc-noteref" id="chapter5_1" href="#chapter5-1">1</a></sup> In a detailed research paper,<sup><a role="doc-noteref" id="chapter5_2" href="#chapter5-2">2</a></sup> I noted that the malware, which often masquerades as a PowerPoint presentation named <i>Final_Presentation</i>, persists itself as a login item to ensure that it automatically re-executes each time the user logs in. In the malware’s application bundle, we find its main binary, a file named <i>usrnode</i>. Decompiling this file uncovers the persistence logic at the start of its <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> function:</p>&#13;
&#13;
<pre><code>int main(int argc, const char* argv[])&#13;
    r12 = [NSURL fileURLWithPath:NSBundle.mainBundle.bundlePath];&#13;
&#13;
    rbx = LSSharedFileListCreate(0x0, _kLSSharedFileListSessionLoginItems, 0x0);&#13;
    LSSharedFileListInsertItemURL(rbx, _kLSSharedFileListItemLast, 0x0, 0x0, r12, 0x0, 0x0);&#13;
    ...&#13;
&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Once the malware determines where on the host it’s running from, it invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">LSSharedFileListCreate</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">LSSharedFileListInsertItemURL</span> functions to install itself as a persistent login item. This login item makes the malware visible in the Login Items pane of the System Preferences application (<a href="chapter5.xhtml#fig5-1">Figure 5-1</a>). Apparently, the malware authors considered this an acceptable trade-off for persistence.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_121" aria-label="121"/>&#13;
<figure class="IMG"><img class="img1" id="fig5-1" src="../images/Figure5-1.jpg" alt="" width="1203" height="349"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: WindTail persists itself as a login item named</span> <span class="SANS_Futura_Std_Book_11">Final_Presentation</span><span class="SANS_Futura_Std_Book_Oblique_I_11">.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Let’s take a look at another persistent macOS malware specimen. Named DazzleSpy, this sophisticated nation-state malware leveraged zero-day vulnerabilities to remotely infect macOS users.<sup><a role="doc-noteref" id="chapter5_3" href="#chapter5-3">3</a></sup> While DazzleSpy’s infection vector posed detection challenges, the malware’s approach to persistence was rather obvious, giving defenders a straightforward way to detect it.</p>&#13;
<p class="TX">After gaining initial code execution and escaping the browser sandbox, DazzleSpy would persist itself as a launch agent that masqueraded as an Apple software updater. To persist as a launch agent, an item usually creates a property list in one of the <i>LaunchAgents</i> directories. DazzleSpy creates a property list within the current user’s <i>Library/LaunchAgents</i> directory and names its property list <i>com.apple.softwareupdate.plist</i>. The malware’s binary hardcodes references to the launch agent directory, as well as to the name of the plist, making them readily visible in the output of the <span class="SANS_TheSansMonoCd_W5Regular_11">strings</span> command:</p>&#13;
&#13;
<pre><code>% <b>strings - DazzleSpy/softwareupdate</b>&#13;
...&#13;
%@/Library/LaunchAgents&#13;
/com.apple.softwareupdate.plist&#13;
</code></pre>&#13;
<p class="TX">If we load the malware in a decompiler, we find a class method named <span class="SANS_TheSansMonoCd_W5Regular_11">installDaemon</span> that makes use of these strings. As its name implies, the method will persistently install the malware (albeit not as a launch daemon, but rather as an agent):</p>&#13;
&#13;
<pre><code>+(void)installDaemon {&#13;
    rax = NSHomeDirectory();&#13;
    ...&#13;
    var_78 = [NSString stringWithFormat:@"%@/<b>Library/LaunchAgents</b>", rax];&#13;
    var_80 = [var_78 stringByAppendingFormat:@"/<b>com.apple.softwareupdate.plist</b>"];&#13;
    ...&#13;
    var_90 = [[NSMutableDictionary alloc] init];&#13;
    var_98 = [[NSMutableArray alloc] init];&#13;
    ...&#13;
    rax = @(YES);&#13;
    [var_90 setObject:rax forKey:@"RunAtLoad"];&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_122" aria-label="122"/>    [var_90 setObject:@"com.apple.softwareupdate" forKey:@"Label"];&#13;
    [var_90 setObject:var_98 forKey:@"ProgramArguments"];&#13;
    ...&#13;
    [var_90 writeToFile:var_80 atomically:0x0];&#13;
...&#13;
}&#13;
</code></pre>&#13;
<p class="TX">From this decompilation, we can see that the malware first dynamically builds a path to the current user’s <i>Library/LaunchAgents</i> directory and then appends the string <i>com.apple.softwareupdate.plist</i> to it. It then builds a dictionary with keys such as <span class="SANS_TheSansMonoCd_W5Regular_11">RunAtLoad</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">Label</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">ProgramArguments</span>, whose values describe how to restart the persisted item, how to identify it, and its path. To complete the persistence, the malware writes this dictionary to the property list file in the launch agent directory.</p>&#13;
<p class="TX">By executing the malware on an isolated analysis machine under the watchful eye of a file monitor, we can confirm DazzleSpy’s persistence. As expected, the file monitor shows the binary (<i>softwareupdate</i>) creating its property list file in the current user’s <i>LaunchAgents</i> directory:</p>&#13;
&#13;
<pre><code># <b>FileMonitor.app/Contents/MacOS/FileMonitor -pretty</b>&#13;
...&#13;
{&#13;
  "event" : "ES_EVENT_TYPE_NOTIFY_CREATE",&#13;
  "file" : {&#13;
    "destination" : "/Users/User/Library/LaunchAgents/com.apple.softwareupdate.plist",&#13;
    "process" : {&#13;
      "pid" : 1469,&#13;
      "name" : "softwareupdate",&#13;
      "path" : "/Users/User/Desktop/softwareupdate"&#13;
    }&#13;
  }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Then, by examining the contents of this newly created file, we can find the path to which the malware has persistently installed itself, <i>/Users/User/ .local/softwareupdate</i>:</p>&#13;
&#13;
<pre><code>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&#13;
...&#13;
&lt;plist version="1.0"&gt;&#13;
&lt;dict&gt;&#13;
    &lt;key&gt;KeepAlive&lt;/key&gt;&#13;
    &lt;true/&gt;&#13;
    &lt;key&gt;Label&lt;/key&gt;&#13;
    &lt;string&gt;com.apple.softwareupdate&lt;/string&gt;&#13;
    &lt;key&gt;ProgramArguments&lt;/key&gt;&#13;
    &lt;array&gt;&#13;
        &lt;string&gt;<b>/Users/User/.local/softwareupdate</b>&lt;/string&gt;&#13;
        &lt;string&gt;1&lt;/string&gt;&#13;
    &lt;/array&gt;&#13;
    &lt;key&gt;<b>RunAtLoad</b>&lt;/key&gt;&#13;
<b>    </b>&lt;true/&gt;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_123" aria-label="123"/>    &lt;key&gt;SuccessfulExit&lt;/key&gt;&#13;
    <b>&lt;true/&gt;</b>&#13;
&lt;/dict&gt;&#13;
&lt;/plist&gt;&#13;
</code></pre>&#13;
<p class="TX">The malware set the <span class="SANS_TheSansMonoCd_W5Regular_11">RunAtLoad</span> key to true, so macOS will automatically restart the specified binary each time the user logs in. In other words, DazzleSpy has attained persistence.</p>&#13;
<p class="TX">At the start of this chapter, I mentioned that legitimate software also persists. How can you determine whether a persisted item is malicious? Arguably the best way involves examining the item’s code signing information using the approaches described in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>. Legitimate items should be signed by readily recognizable companies and notarized by Apple.</p>&#13;
<p class="TX">Malicious persisted items often have common characteristics too. Consider DazzleSpy, which runs from the hidden <i>.local</i> directory and isn’t signed or notarized. The name of the malware’s property list, <i>com.apple .softwareupdate</i>, suggests that this persistent item belongs to Apple. However, Apple never installs persistent components to users’ <i>LaunchAgents</i> directories, and all of its launch items reference binaries signed solely by Apple proper. In these respects, DazzleSpy isn’t an outlier; most malicious persistent items are equally easy to classify as suspicious due to such anomalies.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-40"/><span class="SANS_Futura_Std_Bold_B_11">Background Task Management</span></h3>&#13;
<p class="TNI">How can we determine whether an item has persisted? A naive approach is to simply enumerate all <i>.plist</i> files found in the launch item directories, which include the system and user <i>LaunchDaemon</i> and <i>LaunchAgent</i> directories. However, as of macOS 13, Apple encourages developers to move their launch items directly into their application bundles.<sup><a role="doc-noteref" id="chapter5_4" href="#chapter5-4">4</a></sup> These changes essentially deprecate persistence via a user’s launch item directories, meaning that manually enumerating persistent items requires scanning every application bundle, which is inefficient. Moreover, software can persist as login items, which don’t leverage property lists or dedicated directories.</p>&#13;
<p class="TX">Luckily, starting with macOS 13, Apple has consolidated the management of the most common persistence mechanisms (including launch agents, launch daemons, and login items) into a proprietary subsystem named <i>Background Task Management</i>. This subsystem provides the list of login and launch items that populate the Login Items pane in the System Preferences application (<a href="chapter5.xhtml#fig5-2">Figure 5-2</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_124" aria-label="124"/>&#13;
<figure class="IMG"><img class="img1" id="fig5-2" src="../images/Figure5-2.jpg" alt="" width="1390" height="915"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: Login and launch items shown in the System Preferences app</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">On my computer, several of my Objective-See tools install themselves as login items, while Adobe’s cloud-syncing app and Google Chrome’s updater install persistent launch items.</p>&#13;
<p class="TX">Of course, we want the ability to obtain this list of persistent items programmatically, as any persistent malware will likely show up here as well. Although the components of the Background Task Management subsystem are proprietary and closed source, dynamic analysis reveals that the subsystem stores detailed metadata about the persistent items it tracks in a single database file. For our purposes, the presence of this centralized database is a godsend. Unfortunately, as its format is proprietary and undocumented, we have a bit of work in front of us if we’d like to use it.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-42"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Examining the Subsystem</span></h4>&#13;
<p class="TNI">Let’s walk through the Background Task Management subsystem’s interactions with this database. Understanding these operations will help us create a tool capable of programmatically extracting its contents. Using a file monitor, we can see that when an item is persisted, the Background Task Management daemon, <i>backgroundtaskmanagementd</i>, updates a file in the <i>/private/var/db/com.apple.backgroundtaskmanagement/</i> directory. To perform this operation atomically, it first creates a temporary file, then moves it into the <i>com.apple.backgroundtaskmanagement</i> directory via a <span class="SANS_TheSansMonoCd_W5Regular_11">rename</span> operation:</p>&#13;
&#13;
<pre><code># <b>FileMonitor.app/Contents/MacOS/FileMonitor -pretty</b>&#13;
{&#13;
  "event" : "ES_EVENT_TYPE_NOTIFY_CREATE",&#13;
  "file" : {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_125" aria-label="125"/>    "destination" :&#13;
    "/private/var/folders/zz/.../TemporaryItems/.../BackgroundItems-v<span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</span>.btm",&#13;
    "process" : {&#13;
       "pid" : 612,&#13;
       "name" : "backgroundtaskmanagementd",&#13;
       ...&#13;
     }&#13;
  }&#13;
  ...&#13;
}&#13;
&#13;
{&#13;
  "event" : "ES_EVENT_TYPE_NOTIFY_WRITE",&#13;
  "file" : {&#13;
    "destination" :&#13;
    "/private/var/folders/zz/.../TemporaryItems/.../BackgroundItems-v<span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</span>.btm",&#13;
    "process" : {&#13;
      "pid" : 612,&#13;
      "name" : "backgroundtaskmanagementd",&#13;
      ...&#13;
    }&#13;
  }&#13;
  ...&#13;
}&#13;
&#13;
{&#13;
  "event" : "ES_EVENT_TYPE_NOTIFY_RENAME",&#13;
  "file" : {&#13;
    "source" :&#13;
    "/private/var/folders/zz/.../TemporaryItems/.../BackgroundItems-v<span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</span>.btm",&#13;
    "destination" :&#13;
    "/private/var/db/com.apple.backgroundtaskmanagement/BackgroundItems-v<span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</span>.btm",&#13;
    "process" : {&#13;
      "pid" : 612,&#13;
      "name" : "backgroundtaskmanagementd",&#13;
      ...&#13;
    }&#13;
  }&#13;
  ...&#13;
}&#13;
</code></pre>&#13;
<p class="TX">If we disassemble the daemon’s binary, located in the <i>/System/Library/PrivateFrameworks/BackgroundTaskManagement.framework/Versions/A/Resources/</i> directory, we find references to a format string, <span class="SANS_TheSansMonoCd_W5Regular_11">BackgroundItems-v%ld.btm</span>, in <span class="SANS_TheSansMonoCd_W5Regular_11">storeNameForDatabaseVersion</span>:, a method of the BTMStore class:</p>&#13;
&#13;
<pre><code>+[BTMStore storeNameForDatabaseVersion:]&#13;
    pacibsp&#13;
    sub    sp, sp, #0x20&#13;
    stp    fp, lr, [sp, #0x10]&#13;
    add    fp, sp, #0x10&#13;
    nop&#13;
    ldr    x0, =_OBJC_CLASS_$_NSString&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_126" aria-label="126"/>    str    x2, [sp, #0x10 + var_10]&#13;
    adr    x2, #0x100031f10            ; <b>@"BackgroundItems-v%ld.btm"</b>&#13;
    ...&#13;
</code></pre>&#13;
<p class="TX">Further reverse engineering reveals that the name of the database contains a version number, which increases as newer versions of macOS are released. In the examples shown here, we’ve abstracted this version number with an <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</span>, but on your system, it’s likely to be 8 or higher. Using the <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> command, we can see that the contents of the <i>BackgroundItems-vx.btm</i> file are stored as a binary property list. To view these details yourself, be sure to supply the correct version number for your system when running the command:</p>&#13;
&#13;
<pre><code>% <b>file /private/var/db/com.apple.backgroundtaskmanagement/BackgroundItems-v</b><b><var>x</var></b><b>.btm</b>&#13;
/private/var/db/com.apple.backgroundtaskmanagement/BackgroundItems-v<var>x</var>.btm:&#13;
Apple binary property list&#13;
</code></pre>&#13;
<p class="TX">We can convert the contents of a binary property into XML using <span class="SANS_TheSansMonoCd_W5Regular_11">plutil</span>. Unfortunately, the resulting XML contains not only spelling mistakes but also serialized objects that aren’t readily human readable:</p>&#13;
&#13;
<pre><code>% <b>plutil -p /private/var/db/com.apple.backgroundtaskmanagement/BackgroundItems-v</b><b><var>x</var></b><b>.btm</b>&#13;
{&#13;
  "$archiver" =&gt; "NSKeyedArchiver"&#13;
  "$objects" =&gt; [&#13;
    0 =&gt; "$null"&#13;
    1 =&gt; {&#13;
      "$class" =&gt;&#13;
      &lt;CFKeyedArchiverUID 0x600002854240 [0x1e3bcf9a0]&gt;{value = 265}&#13;
&#13;
      "itemsByUserIdentifier" =&gt;&#13;
      &lt;CFKeyedArchiverUID 0x600002854260 [0x1e3bcf9a0]&gt;{value = 2}&#13;
&#13;
      "mdmPaloadsByIdentifier" =&gt;&#13;
      &lt;CFKeyedArchiverUID 0x600002854280 [0x1e3bcf9a0]&gt;{value = 263}&#13;
&#13;
      "userSettingsByUserIdentifier" =&gt;&#13;
      &lt;CFKeyedArchiverUID 0x6000028542a0 [0x1e3bcf9a0]&gt;{value = 257}&#13;
    }&#13;
    ...&#13;
&#13;
    265 =&gt; {&#13;
      "$classes" =&gt; [&#13;
         0 =&gt; "Storage"&#13;
         1 =&gt; "NSObject"&#13;
      ]&#13;
      "$classname" =&gt; "Storage"&#13;
    }&#13;
    ...&#13;
</code></pre>&#13;
<p class="TX"><i>Serialization</i> is the process of taking an initialized, in-memory object and converting it to a format in which it can be saved (for example, to a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_127" aria-label="127"/>file). While serialization is an efficient way for programs to interact with objects, serialized objects aren’t generally human readable. Moreover, if the objects are of an undocumented class, we must first understand the internal details of the class before we can write code that makes sense of them.</p>&#13;
<p class="TX">As part of the Background Task Management subsystem, Apple ships a command line utility named <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span> that can interact with <i>BackgroundItems-vx .btm</i> files. If executed with the <span class="SANS_TheSansMonoCd_W5Regular_11">dumpbtm</span> flag, the tool will deserialize and print out the file’s contents:</p>&#13;
&#13;
<pre><code># <b>sfltool dumpbtm</b>&#13;
&#13;
#1:&#13;
                 UUID: 8C271A5F-928F-456C-B177-8D9162293BA7&#13;
                 Name: softwareupdate&#13;
       Developer Name: (null)&#13;
                 Type: legacy daemon (0x10010)&#13;
          Disposition: [enabled, allowed, visible, notified] (11)&#13;
           Identifier: com.apple.softwareupdate&#13;
                  URL: file:///Library/LaunchDaemons/com.apple.softwareupdate.plist&#13;
      Executable Path: /Users/User/.local/softwareupdate&#13;
           Generation: 1&#13;
    Parent Identifier: Unknown Developer&#13;
&#13;
#2:&#13;
        UUID: 9B6C3670-2946-4F0F-B58C-5D163BE627C0&#13;
                 Name: ChmodBPF&#13;
       Developer Name: Wireshark&#13;
      Team Identifier: 7Z6EMTD2C6&#13;
                 Type: curated legacy daemon (0x90010)&#13;
          Disposition: [enabled, allowed, visible, notified] (11)&#13;
           Identifier: org.wireshark.ChmodBPF&#13;
                  URL: file:///Library/LaunchDaemons/org.wireshark.ChmodBPF.plist&#13;
      Executable Path: /Library/Application Support/Wireshark/ChmodBPF/ChmodBPF&#13;
           Generation: 1&#13;
    Assoc. Bundle IDs: [org.wireshark.Wireshark]&#13;
    Parent Identifier: Wireshark&#13;
</code></pre>&#13;
<p class="TX">In this example, the deserialized objects include DazzleSpy (<i>softwareupdate</i>) and Wireshark’s <i>ChmodBPF</i> daemon. As <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span> can produce deserialized output from the proprietary database, reverse engineering it should help us understand its deserialization and parsing logic. This, in turn, should enable us to write our own parser capable of enumerating all persistent items managed by the Background Task Management subsystem, including any malware.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-43"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dissecting sfltool</span></h4>&#13;
<p class="TNI">While the focus of this book is not on reverse engineering, I’ll briefly discuss how to dissect <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span> so you can understand its interactions with other Background Task Management components and the ever-so-important <i>.btm</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_128" aria-label="128"/>file. In a terminal, let’s begin by streaming messages from the system log while running <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">dumpbtm</span> flag:</p>&#13;
&#13;
<pre><code>% <b>log stream</b>&#13;
...&#13;
backgroundtaskmanagementd: -[BTMService listener:shouldAcceptNewConnection:]:&#13;
connection=&lt;NSXPCConnection: 0x152307aa0&gt; connection from pid 52886 on mach service named&#13;
com.apple.backgroundtaskmanagement&#13;
&#13;
backgroundtaskmanagementd dumpDatabaseWithAuthorization: error=Error&#13;
Domain=NSOSStatusErrorDomain Code=0 "noErr: Call succeeded with no error"&#13;
</code></pre>&#13;
<p class="TX">As you can see in the log output (which I’ve slightly modified for brevity), the Background Task Management daemon has received a message from a process with an ID of 52886 corresponding to the running instance of <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span>. You can see that the tool has made an XPC connection to the daemon. If the connection succeeds, <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span> can then invoke remote methods found within the daemon. For example, from the log messages, you see that it invoked the daemon’s <span class="SANS_TheSansMonoCd_W5Regular_11">dumpDatabaseWithAuthorization:</span> method to get the contents of the Background Task Management database.</p>&#13;
<p class="TX">In <a href="chapter5.xhtml#Lis5-1">Listing 5-1</a>, we try to implement this same approach. We leverage the private <span class="SANS_TheSansMonoCd_W5Regular_11">BackgroundTaskManagement</span> framework, which implements necessary classes, such as <span class="SANS_TheSansMonoCd_W5Regular_11">BTMManager</span>, and methods including the client-side <span class="SANS_TheSansMonoCd_W5Regular_11">dumpDatabaseWithAuthorization:error:</span>.</p>&#13;
<span id="Lis5-1"/>&#13;
<pre><code>#import &lt;dlfcn.h&gt;&#13;
#import &lt;Foundation/Foundation.h&gt;&#13;
#import &lt;SecurityFoundation/SFAuthorization.h&gt;&#13;
&#13;
#define BTM_DAEMON "/System/Library/PrivateFrameworks/\&#13;
BackgroundTaskManagement.framework/Resources/backgroundtaskmanagementd"&#13;
&#13;
@interface BTMManager : NSObject&#13;
    +(id)shared;&#13;
    -(id)dumpDatabaseWithAuthorization:(SFAuthorization*)arg1 error:(id*)arg2;&#13;
@end&#13;
&#13;
int main(int argc, const char* argv[]) {&#13;
    void* btmd = dlopen(BTM_DAEMON, RTLD_LAZY);&#13;
&#13;
    Class BTMManager = NSClassFromString(@"BTMManager");&#13;
    id sharedInstance = [BTMManager shared];&#13;
&#13;
    SFAuthorization* authorization = [SFAuthorization authorization];&#13;
    [authorization obtainWithRight:"system.privilege.admin"&#13;
    flags:kAuthorizationFlagExtendRights error:NULL];&#13;
&#13;
    id dbContents = [sharedInstance dumpDatabaseWithAuthorization:authorization error:NULL];&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: Attempting to dump the Background Task Management database</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_129" aria-label="129"/>Unfortunately, this approach fails. As shown in the following log messages, the failure appears to be due to the fact that our binary (which, in this instance, has a process ID of 20987) doesn’t possess a private Apple entitlement needed to connect to the Background Task Management daemon:</p>&#13;
&#13;
<pre><code>% <b>log stream</b>&#13;
...&#13;
backgroundtaskmanagementd: -[BTMService listener:shouldAcceptNewConnection:]:&#13;
process with pid=20987 lacks entitlement 'com.apple.private.backgroundtaskmanagement.manage'&#13;
or deprecated entitlement 'com.apple.private.coreservices.canmanagebackgroundtasks'&#13;
</code></pre>&#13;
<p class="TX">We can confirm that this is why we can’t connect to the daemon by reverse engineering the code in the daemon responsible for handling new XPC connections from clients:</p>&#13;
&#13;
<pre><code>/* @class BTMService */&#13;
-(BOOL)listener:(NSXPCListener*)listener&#13;
shouldAcceptNewConnection:(NSXPCConnection*)newConnection {&#13;
    ...&#13;
    x24 = [x0 valueForEntitlement:@"com.apple.private.coreservices.canmanagebackgroundtasks"];&#13;
    ...&#13;
    if(objc_opt_isKindOfClass(x24, objc_opt_class(@class(NSNumber))) == 0x0 ||&#13;
    [x24 boolValue] == 0x0) {&#13;
        // Reject the client that is attempting to connect.&#13;
    }&#13;
</code></pre>&#13;
<p class="TX">In this disassembly, you can see the check for the private entitlement <i>com.apple.private.coreservices.canmanagebackgroundtasks</i>, which matches the one we saw in the logs. If the client doesn’t hold it (or the newer <i>com.apple .private.backgroundtaskmanagement.manage</i> entitlement), the system will deny the connection.</p>&#13;
<p class="TX">Using the <span class="SANS_TheSansMonoCd_W5Regular_11">codesign</span> utility, you can see that <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span> indeed contains the necessary entitlement:</p>&#13;
&#13;
<pre><code>% <b>codesign -d --entitlements - /usr/bin/sfltool</b>&#13;
Executable=/usr/bin/sfltool&#13;
[Dict]&#13;
    [Key] <b>com.apple.private.coreservices.canmanagebackgroundtasks</b>&#13;
    [Value]&#13;
        [Bool] true&#13;
    [Key] com.apple.private.sharedfilelist.export&#13;
    [Value]&#13;
        [Bool] true&#13;
</code></pre>&#13;
<p class="TX">Since we can’t obtain the private Apple entitlement needed to connect to the Background Task Management daemon for our own program, we’re left having to access and parse the database directly from disk.</p>&#13;
<p class="TX">When given full disk access, it’s easy to access the database’s contents. However, parsing its contents requires a bit more work, as it contains undocumented serialized objects. Luckily, continued reverse engineering reveals <span role="doc-pagebreak" epub:type="pagebreak" id="pg_130" aria-label="130"/>that once the daemon has read the contents of the database, its deserialization logic starts in a method named <span class="SANS_TheSansMonoCd_W5Regular_11">_decodeRootData:error</span>:</p>&#13;
&#13;
<pre><code>-(void*)_decodeRootData:(NSData*)data error:(void**)arg3 {&#13;
    ...&#13;
    x0 = [NSKeyedUnarchiver alloc];&#13;
    x21 = [x0 initForReadingFromData:data error:&amp;error];&#13;
    ...&#13;
    x0 = [x21 decodeObjectOfClass:objc_opt_class(@class(Storage)) forKey:@"store"];&#13;
</code></pre>&#13;
<p class="TX">When the Background Task Management daemon reads the contents of the database, it performs deserialization by following these standard steps:</p>&#13;
<p class="NLF">  1.  Reading the contents of the database into memory as an <span class="SANS_TheSansMonoCd_W5Regular_11">NSData</span> object</p>&#13;
<p class="NL">  2.  Initializing an <span class="SANS_TheSansMonoCd_W5Regular_11">NSKeyedUnarchiver</span> object with this data</p>&#13;
<p class="NLL">  3.  Deserializing the objects in the unarchiver via a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">NSKeyedUnarchiver decodeObjectOfClass:forKey:</span> method</p>&#13;
<p class="TX">Take note of the serialized class name, <span class="SANS_TheSansMonoCd_W5Regular_11">Storage</span>, and its key in the archiver, <span class="SANS_TheSansMonoCd_W5Regular_11">store</span>, as these will come into play shortly. Also note that when the <span class="SANS_TheSansMonoCd_W5Regular_11">decodeObjectOfClass:forKey:</span> method is invoked, the <span class="SANS_TheSansMonoCd_W5Regular_11">initWithCoder:</span> method of any embedded object is also automatically invoked behind the scenes. This allows objects to perform their own deserialization.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-41"/><span class="SANS_Futura_Std_Bold_B_11">Writing a Background Task Management Database Parser</span></h3>&#13;
<p class="TNI">We’re now ready to write our own parser. Let’s take what we’ve learned through reverse engineering and write a tool capable of deserializing the metadata of all persistent items found in the Background Task Management database. I’ll walk through the relevant code snippets here, but you can find the entire code for this parser, dubbed <i>DumpBTM</i>, in Objective-See’s GitHub repository at <a href="https://github.com/objective-see/DumpBTM"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/DumpBTM</i></a>. At the end of this discussion, I’ll show how you can make use of this library in your own code to programmatically obtain a list of items persisting on any macOS system.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-44"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding the Database Path</span></h4>&#13;
<p class="TNI">Let’s begin by writing some code that dynamically finds the path of the database. Although it’s located in the <i>/private/var/db/com.apple.backgroundtaskmanagement/</i> directory, Apple occasionally bumps up the version number in the name across releases of macOS. Even with these name changes, though, finding the database is easy enough through its unique extension, <i>.btm</i>. The code in <a href="chapter5.xhtml#Lis5-2">Listing 5-2</a> uses a simple predicate to find all <i>.btm</i> files in the <i>com.apple.backgroundtaskmanagement</i> directory. There should only be one, but to be safe, the code grabs the one with the highest version.</p>&#13;
<span id="Lis5-2"/>&#13;
<pre><code>#define BTM_DIRECTORY @"/private/var/db/com.apple.backgroundtaskmanagement/"&#13;
&#13;
NSURL* getPath(void) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_131" aria-label="131"/>  <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span> NSArray* files = [NSFileManager.defaultManager contentsOfDirectoryAtURL:&#13;
    [NSURL fileURLWithPath:BTM_DIRECTORY] includingPropertiesForKeys:nil options:0 error:nil];&#13;
&#13;
  <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span> NSArray* btmFiles = [files filteredArrayUsingPredicate:[NSPredicate&#13;
    predicateWithFormat:@"self.absoluteString ENDSWITH '.btm'"]];&#13;
&#13;
  <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span> return btmFiles.lastObject;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: Finding the most recent Background Task Management database</span></p>&#13;
<p class="TX">First, the code creates a list of all files in the directory <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, via the predicate <span class="SANS_TheSansMonoCd_W5Regular_11">self.absoluteString ENDSWITH '.btm'</span> and the method <span class="SANS_TheSansMonoCd_W5Regular_11">filteredArrayUsingPredicate:</span>, it creates a second list containing solely <i>.btm</i> files <span class="CodeAnnotation" aria-label="annotation2">❷</span>. It then returns the last file in this list, which should be the one with the highest version <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-45"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Deserializing Background Task Management Files</span></h4>&#13;
<p class="TNI">I noted that the serialized objects in the Background Task Management file are instances of undocumented classes specific to the subsystem. To deserialize them, we must, at a minimum, provide a class declaration. We found these classes embedded in the daemon, including the top-level object in the serialized database that belongs to an undocumented class named <span class="SANS_TheSansMonoCd_W5Regular_11">Storage</span>. Recall that we also saw this class name in the <span class="SANS_TheSansMonoCd_W5Regular_11">plutil</span> output.</p>&#13;
<p class="TX">This class contains various instance variables that describe its properties, including a dictionary called <span class="SANS_TheSansMonoCd_W5Regular_11">itemsByUserIdentifier</span>. To deserialize the <span class="SANS_TheSansMonoCd_W5Regular_11">Storage</span> object, we create the declaration shown in <a href="chapter5.xhtml#Lis5-3">Listing 5-3</a>.</p>&#13;
<span id="Lis5-3"/>&#13;
<pre><code>@interface Storage : NSObject &lt;NSSecureCoding&gt;&#13;
    @property(nonatomic, retain)NSDictionary* itemsByUserIdentifier;&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: The Storage class interface</span></p>&#13;
<p class="TX">Further reverse engineering reveals more details about the <span class="SANS_TheSansMonoCd_W5Regular_11">Storage</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">itemsByUserIdentifier</span> dictionary. For example, it contains key-value pairs whose values are of another undocumented Background Task Management class named <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span> class contains metadata about each persistent item managed by the subsystem, such as its path, its code signing information, and its state (for example, enabled or disabled).</p>&#13;
<p class="TX">Again, as <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span> is an undocumented class, making use of it in our code requires providing a declaration extracted from the daemon. <a href="chapter5.xhtml#Lis5-4">Listing 5-4</a> shows such a declaration.</p>&#13;
<span id="Lis5-4"/>&#13;
<pre><code>@interface ItemRecord : NSObject &lt;NSSecureCoding&gt;&#13;
    @property NSInteger type;&#13;
    @property NSInteger generation;&#13;
    @property NSInteger disposition;&#13;
    @property(nonatomic, retain)NSURL* url;&#13;
    ...&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_132" aria-label="132"/>    @property(nonatomic, retain)NSString* identifier;&#13;
    @property(nonatomic, retain)NSString* developerName;&#13;
    @property(nonatomic, retain)NSString* executablePath;&#13;
    @property(nonatomic, retain)NSString* teamIdentifier;&#13;
    @property(nonatomic, retain)NSString* bundleIdentifier;&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: The <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ItemRecord</span> class interface</span></p>&#13;
<p class="TX">With the relevant classes declared, we’re almost ready to trigger the serialization of all objects in the Background Task Management file. However, as the deserialization process invokes each object’s <span class="SANS_TheSansMonoCd_W5Regular_11">initWithCoder:</span> method, and each object conforms to the <span class="SANS_TheSansMonoCd_W5Regular_11">NSSecureCoding</span> protocol, we should provide an implementation of this method to keep the linker happy and ensure that deserialization succeeds. To reimplement the <span class="SANS_TheSansMonoCd_W5Regular_11">initWithCoder:</span> methods for the undocumented objects, we can use a disassembler to find their implementations. For example, here is the decompilation of the <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">initWithCoder:</span> method:</p>&#13;
&#13;
<pre><code>-(void*)initWithCoder:(NSCoder*)decoder {&#13;
  x0 = objc_opt_class(@class(NSUUID));&#13;
  x0 = [decoder decodeObjectOfClass:x0 forKey:@"uuid"];&#13;
  self.uuid = x0;&#13;
&#13;
  x0 = objc_opt_class(@class(NSString));&#13;
  x0 = [decoder decodeObjectOfClass:x0 forKey:@"executablePath"];&#13;
  self.executablePath = x0;&#13;
&#13;
  x0 = objc_opt_class(@class(NSString));&#13;
  x0 = [decoder decodeObjectOfClass: x0 forKey:@"teamIdentifier"];&#13;
  self.teamIdentifier = x0;&#13;
  ...&#13;
}&#13;
</code></pre>&#13;
<p class="TX">We can easily mimic the method in our own code (<a href="chapter5.xhtml#Lis5-5">Listing 5-5</a>).</p>&#13;
<span id="Lis5-5"/>&#13;
<pre><code>-(id)initWithCoder:(NSCoder *)decoder {&#13;
    self = [super init];&#13;
    if(nil != self) {&#13;
        self.uuid = [decoder decodeObjectOfClass:[NSUUID class] forKey:@"uuid"];&#13;
&#13;
        self.executablePath =&#13;
        [decoder decodeObjectOfClass:[NSString class] forKey:@"executablePath"];&#13;
&#13;
        self.teamIdentifier =&#13;
        [decoder decodeObjectOfClass:[NSString class] forKey:@"teamIdentifier"];&#13;
        ...&#13;
    return self;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: A reimplementation of the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ItemRecord initWithCoder</span>: method</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_133" aria-label="133"/>In our reimplementation of the <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">initWithCoder:</span> method, we deserialize the properties of the object, including its UUID, executable path, team identifier, and more. This is as easy as invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">decodeObjectOfClass:forKey:</span> method for each property on the serialized object that is passed in as an <span class="SANS_TheSansMonoCd_W5Regular_11">NSCoder</span>.</p>&#13;
<p class="TX">However, there is a simpler way to access these methods. As you saw in the disassembly, the Background Task Management daemon contains class implementations of serialized <span class="SANS_TheSansMonoCd_W5Regular_11">Storage</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span> objects, including their <span class="SANS_TheSansMonoCd_W5Regular_11">initWithCoder:</span> methods. Thus, if we load and link the daemon binary into our process’s address space, we’ll have access to those methods without needing to reimplement them ourselves. As all executables are now compiled in a position-independent manner, we can link to anything we’d like in our own program, including the daemon. <a href="chapter5.xhtml#Lis5-6">Listing 5-6</a> contains the code to load and link the daemon, then makes use of its objects when triggering the full deserialization of the objects stored in the database.</p>&#13;
<span id="Lis5-6"/>&#13;
<pre><code>#define BTM_DAEMON "/System/Library/PrivateFrameworks/\&#13;
BackgroundTaskManagement.framework/Resources/backgroundtaskmanagementd"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> void* btmd = dlopen(BTM_DAEMON, RTLD_LAZY);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> NSURL* path = getPath();&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> NSData* data = [NSData dataWithContentsOfURL:path options:0 error:NULL];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> NSKeyedUnarchiver* keyedUnarchiver =&#13;
[[NSKeyedUnarchiver alloc] initForReadingFromData:data error:NULL];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> Storage* storage = [keyedUnarchiver decodeObjectOfClass:&#13;
[NSClassFromString(@"Storage") class] forKey:@"store"];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: Deserializing Background Task Management objects</span></p>&#13;
<p class="TX">After invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">dlopen</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which loads and links the Background Task Management daemon into a process’s memory space, the code invokes a helper function we’ve written to get the path of the system’s Background Task Management database file <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Once it has found and loaded the contents of the database into memory <span class="CodeAnnotation" aria-label="annotation3">❸</span>, the code initializes a keyed unarchiver object with the database data <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Now the code is ready to trigger the deserialization of the objects in the database via the keyed archiver’s <span class="SANS_TheSansMonoCd_W5Regular_11">decodeObjectOfClass:forKey:</span> method. Previously, I noted that the class of the database’s top-level object is named <span class="SANS_TheSansMonoCd_W5Regular_11">Storage</span>. As it’s undocumented, we dynamically resolve it via <span class="SANS_TheSansMonoCd_W5Regular_11">NSClassFromString(@"Storage")</span>. This resolution succeeds because we’ve loaded the daemon that implements this class into our process space. For the key required to begin the deserialization, we mimic the daemon by specifying the string <span class="SANS_TheSansMonoCd_W5Regular_11">"store"</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Behind the scenes, this code will trigger an invocation of the <span class="SANS_TheSansMonoCd_W5Regular_11">Storage</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">initWithCoder:</span> method, giving it a chance to deserialize the top-level <span class="SANS_TheSansMonoCd_W5Regular_11">Storage</span> object in the database. Recall that this object includes a dictionary <span role="doc-pagebreak" epub:type="pagebreak" id="pg_134" aria-label="134"/>containing an <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span> object describing each persisted item. An invocation to the <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">initWithCoder:</span> method will automatically deserialize these embedded objects.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-46"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing Metadata</span></h4>&#13;
<p class="TNI">Once we’ve completed the deserialization, we can access the metadata about each item persisted on the system and managed by Background Task Management (<a href="chapter5.xhtml#Lis5-7">Listing 5-7</a>).</p>&#13;
<span id="Lis5-7"/>&#13;
<pre><code>int itemNumber = 0;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> for(NSString* key in storage.itemsByUserIdentifier) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> NSArray* items = storage.itemsByUserIdentifier[key];&#13;
    for(ItemRecord* item in items) {&#13;
        printf(" #%d\n", ++itemNumber);&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> printf(" %s\n", [[item performSelector:NSSelectorFromString&#13;
        (@"dumpVerboseDescription")] UTF8String]);&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: Printing deserialized items</span></p>&#13;
<p class="TX">Accessing the metadata is as simple as iterating over the deserialized <span class="SANS_TheSansMonoCd_W5Regular_11">Storage</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">itemsByUserIdentifier</span> dictionary <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which organizes the persistent items by user UUID <span class="CodeAnnotation" aria-label="annotation2">❷</span>. For all <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span> objects, we can invoke the class’s <span class="SANS_TheSansMonoCd_W5Regular_11">dumpVerboseDescription</span> method <span class="CodeAnnotation" aria-label="annotation3">❸</span> to print out each object in a nicely formatted manner. Because we didn’t declare this method in the class interface, we instead use the Objective-C <span class="SANS_TheSansMonoCd_W5Regular_11">performSelector:</span> method to invoke it by name.</p>&#13;
<p class="TX">Compiling and running the code produces output that provides the same information as Apple’s closed source <span class="SANS_TheSansMonoCd_W5Regular_11">sfltool</span>:</p>&#13;
&#13;
<pre><code>% <b>./dumpBTM</b>&#13;
Opened /private/var/db/com.apple.backgroundtaskmanagement/BackgroundItems-v<span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</span>.btm&#13;
...&#13;
#1&#13;
                 UUID: 8C271A5F-928F-456C-B177-8D9162293BA7&#13;
                 Name: softwareupdate&#13;
       Developer Name: (null)&#13;
                 Type: legacy daemon (0x10010)&#13;
          Disposition: [enabled, allowed, visible, notified] (11)&#13;
           Identifier: com.apple.softwareupdate&#13;
                  URL: file:///Library/LaunchDaemons/com.apple.softwareupdate.plist&#13;
      Executable Path: /Users/User/.local/softwareupdate&#13;
           Generation: 1&#13;
    Parent Identifier: Unknown Developer&#13;
&#13;
#2&#13;
                 UUID: 9B6C3670-2946-4F0F-B58C-5D163BE627C0&#13;
                 Name: ChmodBPF&#13;
       Developer Name: Wireshark&#13;
      Team Identifier: 7Z6EMTD2C6&#13;
                 Type: curated legacy daemon (0x90010)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_135" aria-label="135"/>          Disposition: [enabled, allowed, visible, notified] (11)&#13;
           Identifier: org.wireshark.ChmodBPF&#13;
                  URL: file:///Library/LaunchDaemons/org.wireshark.ChmodBPF.plist&#13;
      Executable Path: /Library/Application Support/Wireshark/ChmodBPF/ChmodBPF&#13;
           Generation: 1&#13;
    Assoc. Bundle IDs: [org.wireshark.Wireshark]&#13;
    Parent Identifier: Wireshark&#13;
</code></pre>&#13;
<p class="TNI1">Because most macOS malware persists, this ability to programmatically enumerate persistently installed items is incredibly important. However, these enumerations will also include legitimate items, such as Wireshark’s <i>ChmodBPF</i> demon, as shown here.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-47"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identifying Malicious Items</span></h4>&#13;
<p class="TNI">Of course, when attempting to programmatically detect malware, just printing out the persistent items isn’t all that helpful. As you just saw, the Background Task Management database includes metadata about persistently installed items that are benign, so the code must closely examine each. For example, the first item shown in the tool’s output is likely suspicious; its name suggests that it’s a core Apple component, but it’s running from a hidden directory and is unsigned. (Spoiler alert: it’s DazzleSpy.) On the other hand, the second item’s code signing information, including its developer name and team ID, identifies it as a legitimate component of the network monitoring and analysis tool Wireshark.</p>&#13;
<p class="TX">To programmatically extract information from each item, you can directly access relevant properties of the <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span> object. For example, <a href="chapter5.xhtml#Lis5-8">Listing 5-8</a> updates the code we wrote in <a href="chapter5.xhtml#Lis5-7">Listing 5-7</a> to access the path to each item’s property list, its name, and its executable path.</p>&#13;
<span id="Lis5-8"/>&#13;
<pre><code>for(NSString* key in storage.itemsByUserIdentifier) {&#13;
    NSArray* items = storage.itemsByUserIdentifier[key];&#13;
&#13;
    for(ItemRecord* item in items) {&#13;
        NSURL* url = item.url;&#13;
        NSString* name = item.name;&#13;
        NSString* path = item.executablePath;&#13;
        ...&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: Accessing <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ItemRecord</span> properties</span></p>&#13;
<p class="TX">I’ve excerpted the code presented here from the <i>DumpBTM</i> project, a complete Background Task Management parser. Compiled into a library for easy linking into other projects, <i>DumpBTM</i> also allows us to extract the metadata of each persistent item into a dictionary to cleanly abstract away the internals of the undocumented Background Task Management objects (<a href="chapter5.xhtml#Lis5-9">Listing 5-9</a>). Other code can then ingest this dictionary, for example, to examine each item for anomalies or apply heuristics to classify them as benign or potentially malicious.</p>&#13;
<span id="Lis5-9"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_136" aria-label="136"/>#define KEY_BTM_ITEM_URL @"url"&#13;
#define KEY_BTM_ITEM_UUID @"uuid"&#13;
#define KEY_BTM_ITEM_NAME @"name"&#13;
#define KEY_BTM_ITEM_EXE_PATH @"executablePath"&#13;
&#13;
NSDictionary* toDictionary(ItemRecord* item) {&#13;
    NSMutableDictionary* dictionary = [NSMutableDictionary dictionary];&#13;
&#13;
    dictionary[KEY_BTM_ITEM_UUID] = item.uuid;&#13;
    dictionary[KEY_BTM_ITEM_URL] = item.url;&#13;
    dictionary[KEY_BTM_ITEM_NAME] = item.name;&#13;
    dictionary[KEY_BTM_ITEM_EXE_PATH] = item.executablePath;&#13;
    ...&#13;
    return dictionary;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Extracting properties into a dictionary</span></p>&#13;
<p class="TX">To extract an <span class="SANS_TheSansMonoCd_W5Regular_11">ItemRecord</span> object’s properties, we simply create a dictionary and add each property to it with a key of our choosing.</p>&#13;
<p class="TX">In the <i>DumpBTM</i> library, an exported function named <span class="SANS_TheSansMonoCd_W5Regular_11">parseBTM</span> invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">toDictionary</span> function shown here. I’ll end this chapter by showing how your code could make use of the library by invoking <span class="SANS_TheSansMonoCd_W5Regular_11">parseBTM</span> to obtain a dictionary containing metadata of all the persistent items stored in the Background Task Management database.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-42"/><span class="SANS_Futura_Std_Bold_B_11">Using DumpBTM in Your Own Code</span></h3>&#13;
<p class="TNI">When you compile <i>DumpBTM</i>, you’ll find two files in its <i>library/lib</i> directory: the library’s header file (<i>dumpBTM.h</i>) and the compiled library <i>libDumpBTM.a</i>. Add both files to your project. Include the header file in your source code using either an <span class="SANS_TheSansMonoCd_W5Regular_11">#include</span> or an <span class="SANS_TheSansMonoCd_W5Regular_11">#import</span> directive, as this file contains the library’s exported function definitions and constants. If you link in the compiled library at compile time, your code should be able to invoke the library’s exported functions (<a href="chapter5.xhtml#Lis5-10">Listing 5-10</a>).</p>&#13;
<span id="Lis5-10"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> #import "dumpBTM.h"&#13;
...&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> NSDictionary* contents = parseBTM(nil);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> for(NSString* uuid in contents[KEY_BTM_ITEMS_BY_USER_ID]) {&#13;
    for(NSDictionary* item in contents[KEY_BTM_ITEMS_BY_USER_ID][uuid]) {&#13;
        // Add code to process each persistent item.&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Enumerating persistent items</span></p>&#13;
<p class="TX">After importing the library’s header file <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we invoke its exported <span class="SANS_TheSansMonoCd_W5Regular_11">parseBTM</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This function returns a dictionary containing all <span role="doc-pagebreak" epub:type="pagebreak" id="pg_137" aria-label="137"/>persistent items managed by the Background Task Management subsystem and stored in its database, keyed by unique user identifiers. You can see that the code iterates over each user identifier, then over each persistent item <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h1-43"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">The ability to identify persistently installed items is crucial to detecting malware. In this chapter, you learned how to programmatically interact with macOS’s Background Task Management database, which contains the metadata of all persistent launch and login items. Though this process required a brief foray into the internals of the Background Task Management subsystem, we were able to build a complete parser capable of fully deserializing all objects in the database, providing us with a list of persistently installed items.<sup><a role="doc-noteref" id="chapter5_5" href="#chapter5-5">5</a></sup></p>&#13;
<p class="TX">Note, however, that some malware leverages more creative persistence mechanisms that the Background Task Management subsystem doesn’t track, and we won’t find this malware in the subsystem’s database. Not to worry; in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, we’ll dive into KnockKnock, a tool that uses approaches beyond Background Task Management to comprehensively uncover persistent malware found anywhere on the operating system.</p>&#13;
<p class="TX">This chapter wraps up <a href="part1.xhtml">Part I</a> and the discussion of data collection. You’re now ready to explore the world of real-time monitoring, which can build the foundations of a proactive detection approach.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter5-1" href="#chapter5_1">  1</a></span>.  Thomas Brewster, “Hackers Are Exposing an Apple Mac Weakness in Middle East Espionage,” Forbes, August 30, 2018, <a href="https://www.forbes.com/sites/thomasbrewster/2018/08/30/apple-mac-loophole-breached-in-middle-east-hacks/#4b6706016fd6"><i>https://<wbr/>www<wbr/>.forbes<wbr/>.com<wbr/>/sites<wbr/>/thomasbrewster<wbr/>/2018<wbr/>/08<wbr/>/30<wbr/>/apple<wbr/>-mac<wbr/>-loophole<wbr/>-breached<wbr/>-in<wbr/>-middle<wbr/>-east<wbr/>-hacks<wbr/>/#4b6706016fd6</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter5-2" href="#chapter5_2">  2</a></span>.  Patrick Wardle, “Cyber Espionage in the Middle East: Unravelling OSX.WindTail,” VirusBulletin, October 3, 2019, <a href="https://www.virusbulletin.com/uploads/pdf/magazine/2019/VB2019-Wardle.pdf"><i>https://<wbr/>www<wbr/>.virusbulletin<wbr/>.com<wbr/>/uploads<wbr/>/pdf<wbr/>/magazine<wbr/>/2019<wbr/>/VB2019<wbr/>-Wardle<wbr/>.pdf</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter5-3" href="#chapter5_3">  3</a></span>.  Marc-Etienne M. L<span class="endnoteentry_accent">é</span>veill<span class="endnoteentry_accent">é</span> and Anton Cherepanov, “Watering Hole Deploys New macOS Malware, DazzleSpy, in Asia,” We Live Security, January 25, 2022, <a href="https://www.welivesecurity.com/2022/01/25/watering-hole-deploys-new-macos-malware-dazzlespy-asia/"><i>https://<wbr/>www<wbr/>.welivesecurity<wbr/>.com<wbr/>/2022<wbr/>/01<wbr/>/25<wbr/>/watering<wbr/>-hole<wbr/>-deploys<wbr/>-new<wbr/>-macos<wbr/>-malware<wbr/>-dazzlespy<wbr/>-asia<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter5-4" href="#chapter5_4">  4</a></span>.  “Updating Helper Executables from Earlier Versions of macOS,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/servicemanagement/updating_helper_executables_from_earlier_versions_of_macos"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/servicemanagement<wbr/>/updating<wbr/>_helper<wbr/>_executables<wbr/>_from<wbr/>_earlier<wbr/>_versions<wbr/>_of<wbr/>_macos</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter5-5" href="#chapter5_5">  5</a></span>.  If you’re interested in learning more about the internals of the Background Task Management subsystem, including how to reverse engineer it to understand its components, see my 2023 DEF CON talk, “Demystifying (&amp; Bypassing) macOS’s Background Task Management,” <a href="https://speakerdeck.com/patrickwardle/demystifying-and-bypassing-macoss-background-task-management"><i>https://<wbr/>speakerdeck<wbr/>.com<wbr/>/patrickwardle<wbr/>/demystifying<wbr/>-and<wbr/>-bypassing<wbr/>-macoss<wbr/>-background<wbr/>-task<wbr/>-management</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>