- en: 4 Reaction Timer
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 反应计时器
- en: An average human reacts to a visual stimulus, like a light turning on, in about
    215 milliseconds. This is the time it takes for a signal you see with your eyes
    to travel to your brain and out to your limbs to respond. The reaction timer is
    a great project to demonstrate this time delay, and it also makes for a fun game!
    How fast are you and your friends?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，人的视觉反应时间大约为215毫秒。也就是说，从你看到信号（如灯光打开）到信号传递到大脑，再到肢体反应的时间。反应计时器是一个很好的项目来展示这种时间延迟，同时它也是一个有趣的游戏！你和你的朋友反应有多快？
- en: 'In this chapter, you’ll learn how to build your own reaction timer using Arduino.
    The full project is shown in [Figure 4-1](ch04.xhtml#ch04fig01). The concept behind
    it is simple: the Arduino will turn on an LED, start a timer, and wait until you
    press a button. When you see the LED turn on, you press the button as quickly
    as you can, and the Arduino will report back to your computer the time between
    the light coming on and you pressing the button. The Arduino has a 16 MHz clock,
    which means that it can process 16 million instructions per second! That’s *fast*,
    and it makes the Arduino perfect for this project.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你将学习如何使用Arduino制作自己的反应计时器。完整的项目展示在[图4-1](ch04.xhtml#ch04fig01)中。其背后的概念很简单：Arduino会点亮一个LED，启动计时器，并等待你按下按钮。当你看到LED亮起时，你尽快按下按钮，Arduino会将从灯光亮起到你按下按钮之间的时间反馈给你的计算机。Arduino的时钟速度为16
    MHz，意味着它每秒可以处理1600万个指令！这可是*非常快*的，因此Arduino非常适合这个项目。
- en: '**FIGURE 4-1:** The completed Reaction Timer project'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-1：** 完整的反应计时器项目'
- en: '![Image](../images/fig4_1.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig4_1.jpg)'
- en: '**MATERIALS TO GATHER**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**所需材料**'
- en: Like the previous projects in this book, the Reaction Timer uses LEDs, resistors,
    wires, and an Arduino. Unlike other projects, this one also includes a button
    to make the game interactive, and to make it look spiffy we suggest a custom cardboard
    enclosure. [Figures 4-2](ch04.xhtml#ch04fig02) and [4-3](ch04.xhtml#ch04fig03)
    show the parts and materials you’ll need for this project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 像本书中的前几个项目一样，反应计时器使用了LED、 电阻、电线和Arduino。与其他项目不同的是，这个项目还包括了一个按钮来使游戏更加互动，并且为了让外观更加炫酷，我们建议使用定制的纸板外壳。[图4-2](ch04.xhtml#ch04fig02)和[4-3](ch04.xhtml#ch04fig03)展示了你需要的零件和材料。
- en: '**Electronic Parts**'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**电子元件**'
- en: • One SparkFun RedBoard (DEV-13975), Arduino Uno (DEV-11021), or any other Arduino-compatible
    board
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • 一块SparkFun RedBoard（DEV-13975）、Arduino Uno（DEV-11021）或任何兼容Arduino的开发板
- en: • One USB Mini-B cable (CAB-11301 or your board’s USB cable)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • 一根USB Mini-B数据线（CAB-11301，或你使用的开发板的USB线）
- en: • One solderless breadboard (PRT-12002)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: • 一块无焊面包板（PRT-12002）
- en: • One red LED, one blue LED, and one green LED (COM-12062)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个红色LED，一个蓝色LED和一个绿色LED（COM-12062）
- en: • Three 330 Ω resistors (COM-08377, or COM-11507 for a pack of 20)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: • 三个330 Ω电阻（COM-08377，或者COM-11507，一包20个）
- en: • One 10 kΩ resistor (COM-08374, or COM-11508 for a pack of 20)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个10 kΩ电阻（COM-08374，或者COM-11508，一包20个）
- en: • One push button (COM-10302)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个按钮（COM-10302）
- en: • Male-to-male jumper wires (PRT-11026)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: • 公对公跳线（PRT-11026）
- en: • Male-to-female jumper wires (PRT-09140*)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: • 公对母跳线（PRT-09140*）
- en: '**NOTE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The parts marked with an asterisk (*) do not come with the standard SparkFun
    Inventor’s Kit but are available in the separate add-on kit.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*标有星号（*）的零件不包含在标准SparkFun发明者工具包中，但可以在单独的附加工具包中找到。*'
- en: '**FIGURE 4-2:** Components and materials for the Reaction Timer'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-2：** 反应计时器的组件和材料'
- en: '![Image](../images/fig4_2.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig4_2.jpg)'
- en: '**Other Materials and Tools**'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**其他材料与工具**'
- en: • Pencil
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: • 铅笔
- en: • Craft knife
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: • 工艺刀
- en: • Metal ruler
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: • 金属尺
- en: • Glue (hot glue gun or craft glue)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: • 胶水（热熔胶枪或工艺胶水）
- en: • (Optional) Drill and 3/16-inch and 5/16-inch drill bits
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: • （可选）电钻以及3/16英寸和5/16英寸钻头
- en: • (Optional) Wire cutters (not shown)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: • （可选）电线剪（未显示）
- en: • Cardboard (about 12 inches square) or a cardboard box
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: • 纸板（大约12英寸见方）或一个纸箱
- en: • Enclosure template (see [Figure 4-16](ch04.xhtml#ch04fig16) on page [115](ch04.xhtml#page_115))
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: • 外壳模板（见[图4-16](ch04.xhtml#ch04fig16)，第[115](ch04.xhtml#page_115)页）
- en: • (Optional) Ping-pong ball
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: • （可选）乒乓球
- en: '**FIGURE 4-3:** Recommended tools'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-3：** 推荐的工具'
- en: '![Image](../images/fig4_3.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig4_3.jpg)'
- en: '**NEW COMPONENT: THE PUSH BUTTON**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**新组件：按钮**'
- en: 'This project revolves around two components: an LED and a button. The button
    switch is an *input* to an Arduino pin, which means that the sketch can react
    to a change in the voltage on that pin. Inputs like buttons let you create circuits
    that people can interact with.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目围绕两个组件：LED 和按钮。按钮开关是 Arduino 引脚的*输入*，这意味着该草图可以对该引脚上的电压变化作出反应。像按钮这样的输入设备让你可以创建人们可以互动的电路。
- en: '**How Push Buttons Work**'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**按钮如何工作**'
- en: There are many different kinds of push buttons, but they all work in a similar
    manner. A *push button* is really an electrical switch. Push buttons like the
    ones in [Figure 4-4](ch04.xhtml#ch04fig04) are small, spring-loaded devices that
    connect two sides together electrically for as long as you apply pressure, like
    the keys on your keyboard. And they’re everywhere—in remote controls, garage door
    openers, coffee makers, radios, game controllers, and so much more!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种按钮，但它们的工作原理都类似。*按钮*实际上是一个电气开关。像[图 4-4](ch04.xhtml#ch04fig04)中显示的按钮是小型的弹簧加载设备，当你施加压力时，它将两个端口电连接起来，类似于你键盘上的按键。而且它们无处不在——遥控器、车库门开门器、咖啡机、收音机、游戏手柄等！
- en: '**FIGURE 4-4:** A variety of push buttons'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-4：** 各种按钮'
- en: '![Image](../images/fig4_4.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig4_4.jpg)'
- en: These nifty input devices are really simple on the inside. [Figure 4-5](ch04.xhtml#ch04fig05)
    shows the schematics for both a push button and a switch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些巧妙的输入设备内部其实非常简单。[图 4-5](ch04.xhtml#ch04fig05)展示了按钮和开关的示意图。
- en: '**FIGURE 4-5:** Schematic drawings for a push button and a switch'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-5：** 按钮和开关的示意图'
- en: '![Image](../images/fig4_5.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig4_5.jpg)'
- en: When you flip a switch on, a piece of metal inside closes the gap between two
    contacts, like a gate. When you press a push button, metal pushes straight down
    to bridge that gap. Find a push button in your supplies for this project and examine
    it. Even though the schematic symbol in [Figure 4-5](ch04.xhtml#ch04fig05) shows
    only two contacts, most standard push buttons for breadboards have four legs.
    [Figure 4-6](ch04.xhtml#ch04fig06) shows a more accurate illustration of the contacts
    inside, along with how a button like that might look on the breadboard. When you
    plug one in, the legs should straddle the ditch in the middle of the breadboard.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你翻动开关时，内部的一块金属闭合了两个接触点之间的间隙，就像一个门一样。当你按下按钮时，金属直线向下推动，桥接了这个间隙。找到这个项目所需的按钮，并仔细检查它。即使[图
    4-5](ch04.xhtml#ch04fig05)中的示意图仅显示了两个接触点，绝大多数面包板用的标准按钮都有四根引脚。[图 4-6](ch04.xhtml#ch04fig06)则展示了更准确的内部接触点示意图，并且展示了类似按钮在面包板上的样子。当你将按钮插入时，引脚应该跨越面包板中间的槽口。
- en: '**FIGURE 4-6:** Push button schematic and button correctly placed on a breadboard
    with legs straddling the ditch'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-6：** 按钮示意图和按钮正确放置在面包板上，脚插入槽口两侧'
- en: '![Image](../images/fig4_6.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig4_6.jpg)'
- en: Push buttons are fantastic inputs in projects, because everyone knows how they
    work. Push buttons are also pretty simple to connect in a circuit with an Arduino.
    Let’s look at how that works.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮在项目中是非常好的输入设备，因为每个人都知道它们是如何工作的。按钮连接到 Arduino 电路也相对简单。让我们看看它是如何工作的。
- en: '**Using Resistors with Push Buttons**'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**与按钮一起使用电阻**'
- en: To use any button as an input to an Arduino, you’ll need to use a *pull-up resistor
    circuit* like the one in [Figure 4-7](ch04.xhtml#ch04fig07). A pull-up resistor
    connects to a power source on one side and to an input component (like a button)
    on the other. The part of a circuit that needs to detect input is connected at
    the intersection of the resistor and the button.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任何按钮用作 Arduino 的输入，你需要使用像[图 4-7](ch04.xhtml#ch04fig07)中的*上拉电阻电路*。上拉电阻的一端连接到电源，另一端连接到输入组件（如按钮）。需要检测输入的电路部分连接在电阻和按钮的交点处。
- en: 'In the configuration shown in [Figure 4-7](ch04.xhtml#ch04fig07), the resistor
    to 5 V *pulls* the Arduino pin’s default voltage *up* to 5 V, which is considered
    `HIGH`. When the button is pushed, a path is created between the Arduino pin and
    ground, and the Arduino pin reads a `LOW` voltage. This works because current
    always flows along the path of least resistance: when the button isn’t pressed,
    the Arduino pin 10 kΩ resistor is the only path the current can access, but when
    the button *is* pressed, it offers a path with effectively zero resistance.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4-7](ch04.xhtml#ch04fig07)所示的配置中，电阻将 5 V *拉*到 Arduino 引脚的默认电压 *升高* 到 5 V，这被认为是
    `HIGH`。当按钮被按下时，会在 Arduino 引脚和地之间创建一个通路，Arduino 引脚读取 `LOW` 电压。之所以有效，是因为电流总是沿着电阻最小的路径流动：当按钮没有按下时，Arduino
    引脚上的 10 kΩ 电阻是电流唯一能通过的路径，而当按钮 *按下* 时，它提供了一个几乎没有电阻的路径。
- en: '**FIGURE 4-7:** Pull-up resistor and push button circuit'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-7：** 上拉电阻和按钮电路'
- en: '![Image](../images/fig4_7.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_7.jpg)'
- en: '**BUILD THE REACTION TIMER PROTOTYPE**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建反应计时器原型**'
- en: The Reaction Timer combines an LED circuit similar to the ones in previous projects
    with the button circuit from [Figure 4-7](ch04.xhtml#ch04fig07) to make the supercircuit
    in [Figure 4-8](ch04.xhtml#ch04fig08), which lights an LED and detects button
    presses.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 反应计时器结合了类似于前面项目中的 LED 电路和[图 4-7](ch04.xhtml#ch04fig07)中的按钮电路，组成了[图 4-8](ch04.xhtml#ch04fig08)中的超级电路，点亮
    LED 并检测按钮按压。
- en: '**FIGURE 4-8:** Schematic diagram for the Reaction Timer prototype'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-8：** 反应计时器原型的电路图'
- en: '![Image](../images/fig4_8.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_8.jpg)'
- en: Take out your breadboard and wire up a single LED and a button, as shown in
    [Figures 4-9](ch04.xhtml#ch04fig09) and [4-10](ch04.xhtml#ch04fig10). You’ll use
    this prototype to test your code before building the final Reaction Timer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 拿出你的面包板，按照[图 4-9](ch04.xhtml#ch04fig09)和[4-10](ch04.xhtml#ch04fig10)所示，接一个 LED
    和一个按钮。你将使用这个原型来测试你的代码，然后再构建最终的反应计时器。
- en: '**FIGURE 4-9:** Wiring diagram for the Reaction Timer circuit'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-9：** 反应计时器电路接线图'
- en: '![Image](../images/fig4_9.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_9.jpg)'
- en: '**FIGURE 4-10:** Final prototype circuit of the Reaction Timer with a single
    button and a single LED'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-10：** 带有单个按钮和单个 LED 的反应计时器最终原型电路'
- en: '![Image](../images/fig4_10.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_10.jpg)'
- en: 'As you connect this circuit, note the two different resistance values: 330
    Ω for the LED and 10 kΩ for the push button. (See “[Resistors and Bands](app01.xhtml#app01lev1sec4)”
    on page [308](app01.xhtml#page_308) for details on how to determine the value
    of a resistor from its color bands.) The resistor on the LED is a current-limiting
    resistor and should be tied to ground, while the resistor on the push button is
    a pull-up resistor connecting pin 3 to 5 V. But your circuit can’t do anything
    without the code, so let’s look at that now.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接这个电路时，请注意两种不同的电阻值：LED 为 330 Ω，按钮为 10 kΩ。（有关如何根据颜色带确定电阻值的详细信息，请参见“[电阻器和色带](app01.xhtml#app01lev1sec4)”第
    [308](app01.xhtml#page_308) 页。）LED 上的电阻是限流电阻，应连接到地，而按钮上的电阻是上拉电阻，将引脚 3 连接到 5 V。但没有代码，你的电路什么也做不了，现在我们来看一下代码。
- en: '**PROGRAM THE REACTION TIMER**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程反应计时器**'
- en: 'As your sketches and circuits become more complex, you’ll find it helpful to
    organize your thoughts by listing each action you want the Arduino to take, in
    the order you want it to happen. Some programmers refer to a list like this as
    *pseudocode*. Here’s our pseudocode for the Reaction Timer:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着草图和电路的复杂化，你会发现按顺序列出 Arduino 要执行的每个动作会有助于整理思路。一些程序员把这样的列表称为*伪代码*。以下是我们为反应计时器编写的伪代码：
- en: 1\. Wait a random amount of time before turning on the LED (to prevent predicting/gaming
    the Reaction Timer).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在打开 LED 之前，等待一个随机时间（以防预测/作弊反应计时器）。
- en: 2\. Turn on the LED.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 打开 LED。
- en: 3\. Record the starting time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 记录起始时间。
- en: 4\. Start a timer and wait for a button press.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 启动计时器，等待按钮按下。
- en: 5\. When the button is pressed, calculate the reaction time as the timer value
    minus the starting time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 按下按钮时，计算反应时间，即计时器值减去起始时间。
- en: 6\. Report the time back.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 返回时间。
- en: Pretty simple, right? Let’s open up Arduino and look at the sketch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？我们打开 Arduino，看看草图。
- en: '**Write the setup() Function**'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**编写 setup() 函数**'
- en: Open a new sketch and type the initialization and the `setup()` code shown in
    [Listing 4-1](ch04.xhtml#ch04ex01).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的草图，输入初始化和`setup()`代码，如[清单 4-1](ch04.xhtml#ch04ex01)所示。
- en: '**LISTING 4-1:** `setup()` and initialization code for the Reaction Timer'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 4-1：** 反应计时器的`setup()`和初始化代码'
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* *`unsigned int`* *data type can hold values from 0 to 65,535 (2^(16)
    – 1).*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*`unsigned int`* *数据类型可以存储从0到65,535（2^(16) – 1)的值。*'
- en: First, the namespace defines three `unsigned int` variables ➊ to store the `waitTime`,
    `startTime`, and `reactTime` values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，命名空间定义了三个`unsigned int`变量 ➊，用来存储`waitTime`、`startTime`和`reactTime`值。
- en: 'Next comes the `setup()` function, which has a new instruction: `Serial.begin(9600)`
    ➋. Make sure to capitalize `Serial` and leave no spaces between `Serial`, the
    period, and `begin`. This instruction is a little different from previous commands
    because it has a period that divides the *object* and the *method*. An *object*
    is a concept used in computer programming that is similar to a special type of
    variable that can have different functions or actions. Here `Serial` is the name
    of the object we’re using. The functions that an object can perform are called
    *methods*. The `begin()` method initializes or begins *serial communication* between
    your Arduino and your computer, which allows the Arduino to send and receive data
    through the USB cable. For this command, the number in the parentheses, `9600`,
    sets the communication rate to 9,600 bits per second (or *baud*). The Arduino
    will use serial communication to report your reaction time back to your computer.
    The `Serial` object has many other methods, which we’ll introduce throughout this
    book, to handle data between the computer and the Arduino.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`setup()`函数，它有一个新指令：`Serial.begin(9600)` ➋。确保将`Serial`大写，并且`Serial`、句点和`begin`之间没有空格。这个指令与之前的命令略有不同，因为它有一个句点来分隔*对象*和*方法*。*对象*是计算机编程中的一个概念，类似于一种特殊类型的变量，可以执行不同的功能或操作。这里的`Serial`是我们正在使用的对象名称。一个对象可以执行的功能叫做*方法*。`begin()`方法初始化或启动*串口通信*，使得Arduino和计算机之间能够通过USB线进行数据传输。对于这个命令，括号中的数字`9600`设置了通信速率为9,600位每秒（或*波特率*）。Arduino将使用串口通信将你的反应时间报告回计算机。`Serial`对象还有许多其他方法，我们将在本书中介绍，用于处理计算机和Arduino之间的数据。
- en: Finally, you’ll set up your pins. This project uses a single LED on pin 13 to
    indicate when to press the button, so you once again use pin 13 as an `OUTPUT`
    using the `pinMode()` function. Then set pin 3 with the `pinMode()` function ➌
    using the `INPUT` keyword. You use `INPUT` here because Arduino needs to be able
    to detect button presses, not output to the button.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将设置引脚。本项目使用第13号引脚上的一个LED指示何时按下按钮，因此你再次使用`pinMode()`函数将第13号引脚设置为`OUTPUT`。然后使用`pinMode()`函数
    ➌ 将第3号引脚设置为`INPUT`。这里使用`INPUT`是因为Arduino需要能够检测按钮按下的动作，而不是向按钮输出信号。
- en: '**Write the loop() Function**'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**编写loop()函数**'
- en: Now let’s write the `loop()` part of the sketch. Enter the code in [Listing
    4-2](ch04.xhtml#ch04ex02) after your `setup()` function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写草图中的`loop()`部分。在`setup()`函数后，输入[Listing 4-2](ch04.xhtml#ch04ex02)中的代码。
- en: '**LISTING 4-2:** The `loop()` function for the Reaction Timer'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**Listing 4-2：** 反应计时器的`loop()`函数'
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, this code uses the `Serial.println()` method ➊ to show a message prompt
    explaining how to play the game. The `println()` method sends text to the computer
    and adds a newline character to move the cursor down one line. When this method
    is called, any text between quotation marks (`" "`) is displayed on the Arduino
    IDE’s Serial Monitor. The Serial Monitor is like a simple chat window, or *terminal*,
    that allows you to send and receive data between the Arduino and your computer.
    You can open the Serial Monitor by clicking the magnifying glass button in the
    top-right corner of the Arduino IDE (shown in [Figure 4-11](ch04.xhtml#ch04fig11)),
    by clicking Tools ▸ Serial Monitor, or by using the hotkey CTRL-SHIFT-M.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这段代码使用`Serial.println()`方法 ➊ 显示一条消息提示，解释如何玩游戏。`println()`方法将文本发送到计算机，并添加一个换行符，使光标向下一行移动。当调用此方法时，任何在引号（`"
    "`）中的文本都会显示在Arduino IDE的串口监视器上。串口监视器就像一个简单的聊天窗口或*终端*，允许你在Arduino和计算机之间发送和接收数据。你可以通过点击Arduino
    IDE右上角的放大镜按钮（如[图4-11](ch04.xhtml#ch04fig11)所示），点击工具 ▸ 串口监视器，或使用快捷键CTRL-SHIFT-M来打开串口监视器。
- en: '**FIGURE 4-11:** Opening the Serial Monitor through the Arduino IDE'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-11：** 通过Arduino IDE打开串口监视器'
- en: '![Image](../images/fig4_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_11.jpg)'
- en: We’ll look at the Serial Monitor in just a moment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会查看串口监视器。
- en: '**Generate the Delay Time**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成延迟时间**'
- en: 'To make the Reaction Timer less predictable, the sketch calls the `random()`
    function ➋ to generate a random `waitTime`. The `random()` function takes a minimum
    value and a maximum value as arguments and returns a *pseudorandom number* (a
    number that appears to be random but isn’t; this is explained in more detail in
    “[Try It Out: Make `waitTime` More Random](ch04.xhtml#ch04sb01)” on page [109](ch04.xhtml#page_109)).
    In this example, the `waitTime` variable is set to a “random” number between 2,000
    and 4,000 and is passed to `delay()` ➌ before the LED turns on. This prevents
    you and your friends from predicting when to press the button.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使反应计时器更加不可预测，草图调用 `random()` 函数 ➋ 来生成一个随机的 `waitTime`。`random()` 函数接受最小值和最大值作为参数，并返回一个
    *伪随机数*（看似随机但实际上不是；在 “[尝试：让 `waitTime` 更加随机](ch04.xhtml#ch04sb01)” 第 [109](ch04.xhtml#page_109)
    页中有更详细的解释）。在这个示例中，`waitTime` 变量被设置为介于 2,000 和 4,000 之间的“随机”数，并在 LED 灯亮起之前传递给 `delay()`
    ➌。这样可以防止你和你的朋友预测按钮的按下时机。
- en: When the LED turns on, a call to the `millis()` function ➍ captures the starting
    time. The `millis()` function checks the Arduino’s internal timer and returns
    the number of milliseconds since the Arduino was turned on or reset. The `millis()`
    function is handy for any Arduino project that involves timing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 LED 灯亮起时，调用 `millis()` 函数 ➍ 来捕获起始时间。`millis()` 函数检查 Arduino 的内部计时器，并返回自 Arduino
    开机或重置以来的毫秒数。`millis()` 函数对于任何涉及计时的 Arduino 项目都非常有用。
- en: '**Check the Button with a while() Loop**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查带有 while() 循环的按钮**'
- en: After fetching the start time, the sketch uses a `while()` loop ➎ to wait for
    a button press. In Arduino, as in many other programming languages, a `while()`
    loop runs the code inside its curly brackets as long as the expression between
    its parentheses is `true`. In this case, the expression is
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取起始时间后，草图使用 `while()` 循环 ➎ 等待按钮按下。在 Arduino 中，像许多其他编程语言一样，`while()` 循环只要括号中的表达式为
    `true`，就会运行其大括号内的代码。在这种情况下，表达式是
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `digitalRead()` command reads the voltage on the pin specified between the
    parentheses and returns a value of `HIGH` or `LOW` depending on if it sees 5 V
    or GND. This call checks the voltage on pin 3\. Remember that pull-up resistor
    on the push button? The button’s normal state is open, and the pin defaults to
    `HIGH` until you press the button to close the circuit. When you press the button,
    pin 3 connects to ground, and the state becomes `LOW`. The double equal sign (`==`)
    checks equality. (See “[Logical Comparison Operators](ch04.xhtml#ch04sb02)” on
    page [106](ch04.xhtml#page_106).)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`digitalRead()` 命令读取括号中指定引脚的电压，并根据是否检测到 5V 或 GND 返回 `HIGH` 或 `LOW` 的值。此调用检查引脚
    3 的电压。还记得那个按钮上的上拉电阻吗？按钮的正常状态是开路，默认情况下引脚为 `HIGH`，直到按下按钮闭合电路。当按下按钮时，引脚 3 连接到地面，状态变为
    `LOW`。双等号 (`==`) 用于检查相等性。（参见 “[逻辑比较运算符](ch04.xhtml#ch04sb02)” 第 [106](ch04.xhtml#page_106)
    页。）'
- en: As long as the button isn’t pressed, the expression is `true`, and the `while()`
    loop should repeat, preventing the sketch from executing any code after. Notice,
    however, that there’s no actual code inside the loop. This is referred to as a
    *holding* or *blocking loop*, and rather than executing any code itself, it just
    prevents other code from executing. When the button is pressed, the expression
    becomes `false`, and the sketch proceeds.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 只要按钮没有被按下，表达式为 `true`，`while()` 循环就会重复，从而阻止草图执行后续代码。不过请注意，循环内实际上没有任何代码。这被称为
    *保持* 或 *阻塞循环*，它并不执行任何代码，而是仅仅阻止其他代码的执行。当按钮被按下时，表达式变为 `false`，草图继续执行。
- en: '**Calculate and Display the Reaction Time**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算并显示反应时间**'
- en: Next, the sketch computes the reaction time ➏ by subtracting the `startTime`
    from the current timer value, which is fetched with the `millis()` command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，草图通过从当前计时器值中减去 `startTime` 来计算反应时间 ➏，当前计时器值通过 `millis()` 命令获取。
- en: As a final step, the LEDs are turned off, and the `reactTime` value is printed
    to the serial communication line. To make the information more readable, the sketch
    prints the string `"Nice job! Your reaction time was "` to the Serial Monitor
    using the `print()` method ➐ of the `Serial` object. This method sends the text
    between the quotation marks and doesn’t move the cursor to a new line. In fact,
    it keeps the cursor on the same line so that you can append more information,
    like the actual reaction time, which is added at ➑ with `Serial.print(reactTime);`.
    The sentence is finished with a call to the `println()` method ➒, which prints
    the string `" milliseconds"` and then moves the cursor to a new line.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，关闭 LED，并将 `reactTime` 值打印到串口通信线上。为了使信息更易读，草图使用 `Serial` 对象的 `print()` 方法➐
    将字符串 `"Nice job! Your reaction time was "` 打印到串口监视器。这种方法发送括号中的文本，并且不会将光标移动到新的一行。实际上，它会保持光标在同一行，以便你可以追加更多信息，比如实际的反应时间，后者通过
    `Serial.print(reactTime);` 在 ➑ 处添加。然后，通过调用 `println()` 方法 ➒ 完成句子，这将打印字符串 `" milliseconds"`，并将光标移到新的一行。
- en: '**LOGICAL COMPARISON OPERATORS**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑比较运算符**'
- en: '*Logical comparison operators* perform operations that test one value against
    another value. For example, the double equal sign (`==`) compares two values to
    see whether they are equal. A logical operation can return only one of two values:
    `true`, meaning the comparison evaluates correctly, or `false`, meaning it doesn’t
    evaluate correctly. In Arduino, there are many ways to compare two values, and
    all of the operators are listed in the following table:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑比较运算符* 执行将一个值与另一个值进行比较的操作。例如，双等号（`==`）比较两个值是否相等。逻辑运算只能返回两种值中的一种：`true`，表示比较正确，或者
    `false`，表示比较不正确。在 Arduino 中，有很多方法可以比较两个值，所有的运算符如下表所示：'
- en: '| **OPERATOR** | **COMPARISON** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **比较** |'
- en: '| `==` | Equal to |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 等于 |'
- en: '| `!=` | Not equal to |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 |'
- en: '| `>` | Greater than |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 |'
- en: '| `>=` | Greater than or equal to |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于或等于 |'
- en: '| `<` | Less than |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 |'
- en: '| `<=` | Less than or equal to |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于或等于 |'
- en: For example, if you enter `2 == 4` in the Arduino IDE, it will return `false`,
    because two is not equal to four. However, if you enter `2 <= 4` in the Arduino
    IDE, it will return `true`, because two is less than or equal to four. In sketches,
    comparison operators are often used with `if()` or `while()` statements to run
    a certain block of code based on a certain condition. For example, the `while()`
    loop in [Listing 4-2](ch04.xhtml#ch04ex02) says, “while `digitalRead(3) == HIGH`
    is `true`, repeat the holding loop; otherwise, skip to the next bit of code.”
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在 Arduino IDE 中输入 `2 == 4`，它会返回 `false`，因为二者不相等。但是，如果你在 Arduino IDE 中输入
    `2 <= 4`，它会返回 `true`，因为二者小于或相等。在草图中，比较运算符通常与 `if()` 或 `while()` 语句一起使用，根据某个条件执行特定的代码块。例如，[清单
    4-2](ch04.xhtml#ch04ex02) 中的 `while()` 循环写道：“当 `digitalRead(3) == HIGH` 为 `true`
    时，重复执行保持循环；否则，跳到下一段代码。”
- en: 'A common bug is to mistakenly use a single equal sign when working with comparisons.
    Remember: a single equal sign sets a variable, whereas the double equal sign compares
    the two values.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是错误地使用单等号进行比较。记住：单等号用于赋值，而双等号用于比较两个值。
- en: You’ll use comparison operators more and more as you start to evaluate data
    your Arduino gathers from various sensors and inputs, and we’ll use some of them
    later in this chapter, too.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你开始评估 Arduino 从各种传感器和输入中收集的数据，你将越来越多地使用比较运算符，接下来我们也会在本章中使用其中的一些。
- en: Notice that every character must be explicitly printed, including any spaces
    you want between numbers or characters. You can use the `print()` and `println()`
    methods, as in this example, to combine, format, or organize text that you display
    in the Serial Monitor.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个字符都必须显式打印，包括数字或字符之间的空格。你可以使用 `print()` 和 `println()` 方法，如本示例所示，来组合、格式化或组织你在串口监视器中显示的文本。
- en: The final line of code in the `loop()` function is a short `delay()` function
    to pause the sketch before it loops back and starts the Reaction Timer again.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()` 函数中的最后一行代码是一个简短的 `delay()` 函数，用于在草图回到起始位置并重新开始反应计时器之前暂停。'
- en: '**SPECIAL COMMAND CHARACTERS**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**特殊命令字符**'
- en: When printing data or text, you must represent every individual character, including
    spaces, and every formatting command in your code. There’s a set of reserved characters,
    called *escape sequences*, to indicate special formatting. For example, `\n` moves
    the cursor to a new line; so, `Serial.print("Hello Arduino!\n");` is equivalent
    to `Serial.println("Hello Arduino!");`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数据或文本时，必须表示每个单独的字符，包括空格，以及代码中的每个格式化命令。有一组保留字符，称为 *转义序列*，用于表示特殊格式。例如，`\n` 将光标移动到新的一行；因此，`Serial.print("Hello
    Arduino!\n");` 等同于 `Serial.println("Hello Arduino!");`。
- en: You can use escape sequences in your `print` statements to add formatting or
    other special characters to your text. The following table lists a handful of
    useful escape sequences.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `print` 语句中使用转义序列，向文本中添加格式或其他特殊字符。下表列出了一些有用的转义序列。
- en: '| **ESCAPE SEQUENCE** | **RESULT** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **转义序列** | **结果** |'
- en: '| `\t` | Tab |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 |'
- en: '| `\n` | New line |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行 |'
- en: '| `\''` | Single quotation mark |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `\''` | 单引号 |'
- en: '| `\"` | Double quotation mark |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 |'
- en: '| `\x*hh*` | ASCII character, where `*hh*` is a hexadecimal number |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `\x*hh*` | ASCII 字符，其中 `*hh*` 是十六进制数 |'
- en: '**Test the Reaction Timer Sketch**'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**测试反应计时器草图**'
- en: That’s all the code you need to test your Reaction Timer game circuit! Save
    your sketch, compile it, and upload it to your Arduino now. To see the data that
    your sketch sends on the serial communication line, open the Serial Monitor window
    by clicking **Tools ▸ Serial Monitor** or the magnifying glass button in the upper-right
    corner of the IDE.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要测试反应计时器游戏电路的所有代码！现在保存你的草图，编译并上传到你的 Arduino。要查看草图通过串行通信线路发送的数据，请通过点击 **工具
    ▸ 串口监视器** 或 IDE 右上角的放大镜按钮打开串口监视器窗口。
- en: Notice that the bottom-right corner of the Serial Monitor has a pull-down menu
    to control the serial data rate in *baud* (bits per second), which defaults to
    9,600 baud (see [Figure 4-12](ch04.xhtml#ch04fig12)). This is the same value this
    sketch uses to initialize the `Serial` object, using the `Serial.begin(9600)`
    instruction. Always check that the Serial Monitor speed is the same as the rate
    set in the sketch with `Serial.begin()`—otherwise, you may just get gibberish!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，串口监视器右下角有一个下拉菜单，可以控制串行数据速率，以 *波特率*（每秒位数）表示，默认值为 9,600 波特（见 [图 4-12](ch04.xhtml#ch04fig12)）。这是此草图用于初始化
    `Serial` 对象的相同值，使用 `Serial.begin(9600)` 指令。请始终检查串口监视器的速度是否与草图中 `Serial.begin()`
    设置的速率相同，否则你可能会看到乱码！
- en: '**FIGURE 4-12:** The Arduino IDE’s Serial Monitor window testing the Reaction
    Timer'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-12：** Arduino IDE 的串口监视器窗口测试反应计时器'
- en: '![Image](../images/fig4_12.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_12.jpg)'
- en: '**NOTE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some components, such as GPS or a serial-enabled LCD screen, will communicate
    with the Arduino at different baud rates, so when using a new part, it’s a good
    idea to check what rate it uses and set that in the sketch.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*某些组件，例如 GPS 或串行启用的 LCD 屏幕，可能会以不同的波特率与 Arduino 通信，因此在使用新部件时，最好检查它使用的速率并在草图中进行设置。*'
- en: You can set the serial data rate to any standard rate from 300 to 250,000 baud,
    but 9,600 baud is the most common speed. Generally speaking, slower speeds are
    more reliable and use less power and fewer resources on the Arduino, but they
    also introduce a delay that slows down the `loop()`. If you need a really fast
    response and don’t care much about power usage, you can use a faster baud rate.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将串行数据速率设置为从 300 到 250,000 波特的任何标准速率，但 9,600 波特是最常用的速度。一般来说，较慢的速度更可靠，消耗的功率和资源较少，但也会引入延迟，减缓
    `loop()` 的执行速度。如果你需要非常快速的响应并且不太在乎功耗，你可以使用更高的波特率。
- en: Now, let’s play! Run the sketch and watch your LED closely. When it lights up,
    push the button. Your code will print your reaction time, in milliseconds, to
    the Serial Monitor, like in [Figure 4-12](ch04.xhtml#ch04fig12). How fast are
    you? Go challenge one of your friends! The average is about 215 ms. How do *you*
    measure up?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！运行草图并仔细观察你的 LED。当它亮起时，按下按钮。你的代码将把你的反应时间（毫秒为单位）打印到串口监视器上，就像 [图 4-12](ch04.xhtml#ch04fig12)
    中所示的那样。你有多快？快去挑战你的朋友吧！平均反应时间约为 215 毫秒。*你*的表现如何？
- en: '**TRY IT OUT: MAKE WAITTIME MORE RANDOM**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**试一试：使等待时间更随机**'
- en: In most digital devices like an Arduino, it’s hard to get a *truly* random number
    because the random number is generated through a mathematical calculation. On
    an Arduino, each time the `random()` function is called, the function bases its
    calculation on the previous result from `random()`. Because the next “random”
    number is calculated from the previous result, the sequence of numbers will always
    be the same.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数数字设备，如 Arduino 中，很难获得一个*真正*的随机数，因为随机数是通过数学计算生成的。在 Arduino 上，每次调用`random()`函数时，函数会基于上次`random()`的结果进行计算。由于下一个“随机”数是由上一个结果计算得出的，因此数字序列将始终相同。
- en: For example, on our Arduino (and probably yours), the first call to `random(2000,
    4000)` will always set `waitTime` to `2807`. The second number generated will
    always be `3249`, the third will be `2073`, and so on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的 Arduino 上（也可能是你的），第一次调用`random(2000, 4000)`总是将`waitTime`设置为`2807`。第二个生成的数字总是`3249`，第三个是`2073`，依此类推。
- en: You can make the `waitTime` value appear more random by calling the function
    `randomSeed()` in your `setup()` function. This generates a *seed* value that
    tells `random()` where the pseudorandom sequence should start. When your Arduino
    starts running a sketch, the seed defaults to `1`, which is why `2807` is always
    the first number generated by the `random(2000, 4000)` call.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`setup()`函数中调用`randomSeed()`来让`waitTime`值看起来更随机。这会生成一个*种子*值，告诉`random()`伪随机序列应该从哪里开始。当你的
    Arduino 开始运行草图时，种子默认为`1`，这就是为什么`random(2000, 4000)`调用时`2807`总是第一个生成的数字。
- en: 'To make your Reaction Timer behave more randomly, add this line of code to
    your `setup()` routine, just before the closing curly bracket:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的反应计时器表现得更随机，在`setup()`例程中，在闭合大括号前添加这一行代码：
- en: '[PRE3]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This seeds the random-number generator with the current voltage value on the
    Arduino’s analog pin A5\. We’ll cover `analogRead()` in more detail in Chapter
    5, but for now, just know that it reads the voltage level on the analog pin passed
    to it. Because pin A5 isn’t connected to anything in the Reaction Timer, the voltage
    *floats*, or bounces around somewhat unpredictably.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这会用 Arduino 模拟引脚 A5 上的当前电压值来为随机数生成器提供种子。我们将在第5章详细讨论`analogRead()`，但现在只需知道它读取传入的模拟引脚上的电压水平。因为引脚
    A5 在反应计时器中没有连接到任何东西，所以电压会*浮动*，或者说有些不可预测地波动。
- en: 'If you choose to add this line of code, then each time you run your sketch,
    the first call to `random(2000, 4000)` should return a different number. To confirm,
    add these two lines of code after the `delay(waitTime)` call in your sketch:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择添加这行代码，那么每次运行草图时，第一次调用`random(2000, 4000)`应该会返回不同的数字。为确认这一点，在你的草图中的`delay(waitTime)`调用后添加以下两行代码：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, comment out the `randomSeed()` call by adding `//` at the beginning of
    the line, run your sketch a few times, and note the initial `waitTime` values
    printed. Uncomment the `randomSeed()` call and repeat the process. Over time and
    a lot of data points, there will still be a pattern, but that’s a topic for another
    book—or perhaps for a degree in computer science!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在行首添加`//`来注释掉`randomSeed()`调用，运行你的草图几次，并记录初始的`waitTime`值。取消注释`randomSeed()`调用并重复这个过程。随着时间的推移以及大量数据点的累积，仍然会出现模式，但那是另一本书的内容——或者可能是计算机科学学位的内容！
- en: '**Play Again?**'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**再玩一次？**'
- en: To play again, simply press the Arduino’s reset button—the brass-colored button
    near the corner of the board, shown in [Figure 4-13](ch04.xhtml#ch04fig13). This
    will restart your code and let you play again. Watch the LED closely. Are you
    any faster?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要再玩一次，只需按下 Arduino 的重置按钮——即板子角落附近的黄铜色按钮，如[图 4-13](ch04.xhtml#ch04fig13)所示。这将重新启动你的代码并让你再玩一次。仔细观察LED。你变得更快了吗？
- en: '**FIGURE 4-13:** Press the reset button to play again.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-13：** 按下重置按钮再玩一次。'
- en: '![Image](../images/fig4_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_13.jpg)'
- en: '**Add a Game Element**'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加一个游戏元素**'
- en: 'To add a little carnival-game style to this project, you can add a visual speed
    indicator to show if you’re faster than a given reaction time. We suggest starting
    with the average, 215 ms, as the time to beat. To do this, you’ll need to add
    two more LEDs: a green one to indicate that you were faster than the time set
    in the code and a red one to say you were slower. Since you already used pin 13
    for the stimulus LED, you’ll connect these two LEDs to pins 11 and 12\. Add these
    to your breadboard as shown in [Figures 4-14](ch04.xhtml#ch04fig14) and [4-15](ch04.xhtml#ch04fig15).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要为这个项目增加一点嘉年华游戏的风格，你可以添加一个视觉速度指示器，用来显示你是否比给定的反应时间更快。我们建议以平均反应时间215毫秒作为挑战目标。为了实现这一点，你需要再添加两个LED灯：一个绿色LED表示你比代码设置的时间快，另一个红色LED表示你较慢。由于你已经使用了13号引脚连接刺激LED，所以你将把这两个LED连接到11号和12号引脚。将它们按照[图4-14](ch04.xhtml#ch04fig14)和[图4-15](ch04.xhtml#ch04fig15)所示连接到面包板上。
- en: '**FIGURE 4-14:** Circuit diagram with two extra LEDs'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-14：** 带有两个额外LED的电路图'
- en: '![Image](../images/fig4_14.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_14.jpg)'
- en: '**FIGURE 4-15:** Completed wiring of the new circuit with two extra LEDs'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-15：** 新电路的完整接线图，包含两个额外的LED'
- en: '![Image](../images/fig4_15.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_15.jpg)'
- en: '**Update the Code for Extra LEDs**'
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更新代码以支持额外的LED**'
- en: Now that you have these two indicator LEDs, you’ll add a few extra lines of
    code to your project to turn on the green LED if you’re faster than the time to
    beat and the red LED if you’re not.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经有了这两个指示LED，你需要再添加一些代码行，用于在你的反应时间比目标时间快时点亮绿色LED，在反应时间不如目标时间时点亮红色LED。
- en: You’ll need to add a `pinMode()` command for pins 12 and 11 and set these up
    as `OUTPUT`s to control your new LEDs. The changes to the `setup()` function are
    shown in [Listing 4-3](ch04.xhtml#ch04ex03) (the existing code is shown in light
    gray).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为12号和11号引脚添加`pinMode()`命令，并将其设置为`OUTPUT`，以控制你的新LED。对`setup()`函数的修改见[列表4-3](ch04.xhtml#ch04ex03)（现有代码用浅灰色显示）。
- en: '**LISTING 4-3:** The modified `setup()` function for the Reaction Timer with
    the extra speed-indicator LEDs'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表4-3：** 添加了额外速度指示LED的反应计时器`setup()`函数修改版'
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You simply inserted two extra `pinMode()` instructions for the two extra LEDs
    that you’re going to add.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你只是插入了两个额外的`pinMode()`指令，用于配置你将要添加的两个LED。
- en: '**Control the Flow with if() and else()**'
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用if()和else()控制流程**'
- en: Now you’ll need to add a little bit of decision logic into your sketch. In Arduino
    programming, an `if()` statement allows you to control the direction and flow
    of a sketch. It tells the code “if this is true, run the code in the following
    curly brackets.” The general syntax for the `if()` statement is shown in [Listing
    4-4](ch04.xhtml#ch04ex04).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要在你的代码中加入一些决策逻辑。在Arduino编程中，`if()`语句允许你控制代码的执行方向和流程。它告诉代码：“如果这个条件成立，就执行以下大括号内的代码。”`if()`语句的一般语法见[列表4-4](ch04.xhtml#ch04ex04)。
- en: '**LISTING 4-4:** Generic `if()` statement in Arduino'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表4-4：** Arduino中的通用`if()`语句'
- en: '[PRE6]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *`expression`* ➊ is a Boolean expression that is either `true` or `false`,
    like the ones we discussed earlier in “[Logical Comparison Operators](ch04.xhtml#ch04sb02)”
    on page [106](ch04.xhtml#page_106). If the expression is `true`, the sketch will
    start executing any code between the curly brackets ➋. If it’s not `true`, the
    sketch skips over the curly brackets and goes to the next statement. Oftentimes,
    the `if()` statement is paired with an `else` ➌. If the expression is not `true`,
    the sketch skips over the first set of curly brackets ➋ and continues on to the
    code that is part of the `else` statement ➍.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*`expression`* ➊ 是一个布尔表达式，可以是`true`或`false`，类似于我们在“[逻辑比较运算符](ch04.xhtml#ch04sb02)”一节中讨论过的内容，见第[106页](ch04.xhtml#page_106)。如果表达式为`true`，程序将开始执行大括号之间的代码
    ➋。如果表达式不为`true`，程序将跳过大括号，直接执行下一个语句。通常，`if()`语句会和`else` ➌一起使用。如果表达式不为`true`，程序将跳过第一组大括号
    ➋，继续执行`else`语句中的代码 ➍。'
- en: For the Reaction Timer game, you’ll use an `if()` statement to turn on the green
    LED if the reaction time is less than or equal to 215 ms and the red LED if the
    reaction time is greater than 215 ms. You’ll be able to change this value to make
    it harder or easier, but this is a good middling value for now. [Listing 4-5](ch04.xhtml#ch04ex05)
    shows the code to do this.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在反应计时器游戏中，你将使用`if()`语句来控制绿色LED在反应时间小于或等于215毫秒时点亮，红色LED在反应时间大于215毫秒时点亮。你可以更改这个值，来调整游戏难度，但现在这个值是一个不错的中等难度。[列表4-5](ch04.xhtml#ch04ex05)展示了实现此功能的代码。
- en: '**LISTING 4-5:** Code snippet of the `if()` statement for the Reaction Timer
    game'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表4-5：** 反应计时器游戏的`if()`语句代码片段'
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see at ➊ that the sketch uses the `if()` statement to perform this logic.
    The Boolean expression, `reactTime <= 215` ➋, checks whether the value from `reactTime`
    is less than or equal to `215`, and if it is, the green LED turns on ➌. When the
    green LED turns on, the red LED needs to be off, so you add one extra instruction
    ➍ to do that. Finally, you add the `else` statement ➎ to turn the red LED on if
    the `if()` statement evaluates to `false`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到➊，草图使用了`if()`语句来执行这个逻辑。布尔表达式`reactTime <= 215` ➋，检查`reactTime`的值是否小于或等于`215`，如果是，绿灯就会亮起➌。当绿灯亮起时，红灯需要关闭，所以你会加上一条额外的指令➍来关闭它。最后，你加上`else`语句➎来在`if()`语句为`false`时点亮红灯。
- en: '**Upload the Complete Code for the Reaction Timer**'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**上传完整的反应计时器代码**'
- en: The new `if()` statement should be placed within the `loop()`, after the code
    to turn off the red LED, as shown in [Listing 4-6](ch04.xhtml#ch04ex06). (The
    *`snip`* indicates where existing code has been omitted on the page for length.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`if()`语句应放置在`loop()`中，紧接着关闭红色LED的代码，如[清单 4-6](ch04.xhtml#ch04ex06)所示。（*`snip`*表示页面中由于篇幅问题省略的现有代码位置。）
- en: '**LISTING 4-6:** Adding the `if()` statement for the green and red LED game
    indicators'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 4-6：** 为绿灯和红灯游戏指示器添加`if()`语句'
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After you’ve added the new code, upload the whole sketch to your Arduino. Open
    the Serial Monitor and play a game to make sure it all works as expected. Can
    you get the green light to turn on? You have to be fast!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加完新代码后，将整个草图上传到你的Arduino。打开串口监视器并进行游戏，确保一切按预期运行。你能让绿灯亮起来吗？你得够快！
- en: '**GAMING THE GAME: CONTROL THE DIFFICULTY**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩转游戏：控制难度**'
- en: As with all games, with the Reaction Timer, sometimes you’ll need to adjust
    the difficulty level. Since you’re the programmer, you get to control the game.
    If 215 ms is too fast or too slow, you can adjust your game *threshold* by changing
    the number in the line `if (reactTime <= 215)`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 和所有游戏一样，反应计时器有时也需要调整难度级别。既然你是程序员，你就能控制游戏。如果215毫秒太快或太慢，你可以通过更改`if (reactTime
    <= 215)`中的数字来调整游戏的*阈值*。
- en: Want to make it impossible to beat? Change this value to a low number like 100
    ms. Want to be nice and make it easier? Change it to a number like 500 ms. You’re
    writing the code, so you get to decide the rules of the game!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 想要让它几乎不可能被击败吗？把这个值改成像100毫秒这样的小数值。想要让它变得简单点？改成像500毫秒这样的数字。你在写代码，所以你可以决定游戏的规则！
- en: '**BUILD THE REACTION TIMER ENCLOSURE**'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建反应计时器外壳**'
- en: When your prototype works, it’s time to build a more permanent enclosure. To
    keep this project as simple as possible, our version of the Reaction Timer is
    designed to fit into a small SparkFun box. The top of the box measures 3 7/8 inches
    × 5 inches, but you can put your game in anything you have lying around the house—an
    old cereal box, oatmeal container, or anything else made of a sturdy cardboard.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的原型工作正常时，是时候构建一个更永久的外壳了。为了尽可能简化这个项目，我们版本的反应计时器设计为适合放入一个小的SparkFun盒子。盒子的顶部尺寸为3
    7/8英寸×5英寸，但你可以将游戏放进家里任何现有的东西里——一个旧的谷物盒、燕麦容器或任何其他结实的纸板物品。
- en: We made our Reaction Timer look like an old-school carnival game with a few
    fun clip-art drawings we found, but you can make yours look however you want.
    [Figure 4-16](ch04.xhtml#ch04fig16) shows a template for the outside of our box.
    For this design, we have a hole for the button, a hole for the stimulus LED, and
    two holes for indicator LEDs—one to show that you’re faster than a ninja and the
    other to show that you’re as slow as a turtle. You can download the template with
    this book’s resources via *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*
    or just cut holes for the LEDs and buttons anywhere you like on your box.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让我们的反应计时器看起来像一个老式的嘉年华游戏，配上我们找到的一些有趣的剪贴画，但你可以根据自己的喜好来设计外观。[图 4-16](ch04.xhtml#ch04fig16)展示了我们盒子外部的模板。这个设计中有一个按钮孔、一个刺激LED孔和两个指示LED孔——一个显示你比忍者还快，另一个显示你像乌龟一样慢。你可以通过本书的资源下载模板，链接在*
    [https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*，或者直接在盒子上随便切割LED和按钮的孔。
- en: '**FIGURE 4-16:** Template for the Reaction Timer carnival game cover art (not
    full size)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-16：** 反应计时器嘉年华游戏封面艺术模板（非完整尺寸）'
- en: '![Image](../images/fig4_16.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_16.jpg)'
- en: '**Cut Out the Cardboard**'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**剪裁纸板**'
- en: If you use our template, print it and then glue or tape it to the front of your
    box. Whether you use the template or not, you’ll need to make a total of four
    holes in the cardboard for the three LEDs and the button. You can use a craft
    knife or a drill to *carefully* cut out the holes, as shown in [Figure 4-17](ch04.xhtml#ch04fig17).
    The LEDs are 5 mm in diameter, so a 3/16-inch drill bit is a pretty close fit.
    For the button hole, we recommend using a 5/16-inch drill bit, if you’re drilling,
    or a sharp pencil.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用我们的模板，先打印出来，然后将它粘贴或用胶带固定在盒子的前面。不论是否使用模板，你都需要在纸板上打四个孔，用于三个 LED 和一个按钮。你可以使用工艺刀或电钻*小心*地切出孔洞，如[图
    4-17](ch04.xhtml#ch04fig17)所示。LED 的直径是 5 毫米，所以使用 3/16 英寸的钻头比较合适。对于按钮孔，我们建议使用 5/16
    英寸的钻头，如果你在钻孔，也可以用一支尖锐的铅笔。
- en: '**FIGURE 4-17:** Cutting out the holes from a cardboard box'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-17：** 从纸板盒中切出孔洞'
- en: '![Image](../images/fig4_17.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_17.jpg)'
- en: '**Assemble the Electronics**'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**组装电子元件**'
- en: Now that you have the holes cut out of your Reaction Timer box, you need to
    add the electronic components. You’re going to move the three LEDs and the button
    from the breadboard to the exterior of your new cardboard box so that players
    can see them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经从反应计时器盒中切出了孔洞，接下来需要添加电子元件。你将把三个 LED 和按钮从面包板上移动到新纸板盒的外部，这样玩家才能看到它们。
- en: '**Attach the LEDs and Button to the Cardboard**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将 LED 和按钮固定到纸板上**'
- en: First, press the LEDs through their three holes from the back side of the cardboard,
    making sure that each sits snugly. If the holes you cut are too big and the LEDs
    are a little loose, simply add a small dab of glue to keep them in, as in [Figure
    4-18](ch04.xhtml#ch04fig18).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从纸板的背面把 LED 插入它们的三个孔中，确保每个 LED 均紧密地固定。如果你切出的孔太大，导致 LED 有些松动，可以在孔周围加一点胶水将它们固定，如[图
    4-18](ch04.xhtml#ch04fig18)所示。
- en: '**FIGURE 4-18:** Moving the LEDs to your project box/ cardboard'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-18：** 将 LED 移动到项目盒/纸板上'
- en: '![Image](../images/fig4_18.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_18.jpg)'
- en: Next, add the button. The push buttons that come in the SparkFun Inventor’s
    Kit have a cap that pops off. Remove the button cap, insert the button from the
    inside of the box, and glue the button onto the cardboard, as in [Figure 4-19](ch04.xhtml#ch04fig19).
    Reattach the button cap on the top side of the cardboard. Players are going to
    mash this button as they try to get the best score possible, so use a lot of glue
    to make sure it’s secure! When the glue is dry, try the button out. You need to
    be able to press the button in all the way, so make sure the cap doesn’t get caught
    on any cardboard when you press it down.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加按钮。SparkFun 发明者工具包中的按键有一个可以拆下的按钮帽。移除按钮帽，从盒子的内侧插入按钮，并将按钮粘贴到纸板上，如[图 4-19](ch04.xhtml#ch04fig19)所示。然后将按钮帽重新安装到纸板的顶部。玩家会在尽力获得最佳分数时疯狂按压这个按钮，所以一定要使用大量胶水来确保它稳固！当胶水干了之后，试试按钮。你需要能够将按钮完全按下，所以确保按下时按钮帽不会卡在纸板上。
- en: '**FIGURE 4-19:** Secure the button in place with a lot of glue.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-19：** 使用大量胶水固定按钮'
- en: '![Image](../images/fig4_19.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_19.jpg)'
- en: '**NOTE**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If using hot glue, be cautious when gluing the button to the cardboard. Hot
    glue is hot!*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果使用热熔胶，在将按钮粘贴到纸板上时要小心。热熔胶很烫！*'
- en: '**Reconnect the Components to the Arduino**'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**重新连接电子元件到 Arduino**'
- en: Now, use male-to-female jumper wires to connect the LEDs to the breadboard.
    Remember that the shorter leg of the LED needs to connect to ground (GND) in the
    circuit, and each of the longer legs should connect to its respective pin on the
    Arduino, through a 330 Ω resistor. Because the LED legs are a bit long, you may
    need to clip them back with wire cutters. A strategy we often use is to cut the
    shorter leg just a little shorter so that you can always tell which leg is the
    negative leg, as shown in [Figure 4-20](ch04.xhtml#ch04fig20).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用公对母跳线将 LED 连接到面包板。记住，LED 的短腿需要连接到电路的地（GND），而每根长腿应该通过一个 330 Ω 电阻连接到 Arduino
    上相应的引脚。由于 LED 的腿有点长，你可能需要用剪线钳把它们剪短。我们常用的一个方法是把短腿剪得稍微短一点，这样你就可以随时辨别哪一腿是负极腿，如[图
    4-20](ch04.xhtml#ch04fig20)所示。
- en: '**FIGURE 4-20:** Cutting back the LED legs. Keep the short leg short!'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-20：** 剪短 LED 的腿。保持短腿短！'
- en: '![Image](../images/fig4_20.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_20.jpg)'
- en: If you can’t tell which leg is longer, you can also look at the shape of the
    plastic lens on the LED. There is typically a flat edge on the side nearest to
    the negative leg of the LED. The flat edge is subtle, but if you look closely,
    you should be able to see it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分不清哪个引脚更长，还可以查看LED的塑料镜头形状。通常，LED负极一侧的塑料镜头会有一个平边。这个平边虽然不明显，但如果仔细观察，你应该能看到。
- en: Press the female ends of the male-to-female jumper wires onto the ends of the
    LEDs so that they fit snugly, like in [Figure 4-21](ch04.xhtml#ch04fig21). To
    keep things organized and easy to follow, we recommend using a black wire for
    the negative (short leg) of the LED.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将公对母跳线的母端按压到LED的端口上，使其紧密贴合，像[图4-21](ch04.xhtml#ch04fig21)所示。为了保持组织整洁并便于跟随，我们建议使用黑色线材连接LED的负极（短脚）。
- en: '**FIGURE 4-21:** Connecting the LED to the jumper wires'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-21：** 将LED连接到跳线'
- en: '![Image](../images/fig4_21.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_21.jpg)'
- en: Once the jumper wires are connected to all three LEDs, connect the male ends
    to the breadboard circuit. The wires for the stimulus LED should go to E2 and
    E3, for the green LED to E8 and E9, and for the red LED to E12 and E13.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦跳线接入所有三个LED灯，将公端连接到面包板电路中。刺激LED的线应连接到E2和E3，绿色LED连接到E8和E9，红色LED连接到E12和E13。
- en: Next, reconnect the button to the circuit. The button has four legs, but you
    only need to connect to two legs on one side of the button. Connect one male-to-female
    wire to one leg and another to the other leg, as in [Figure 4-22](ch04.xhtml#ch04fig22).
    Then, plug one wire into the same breadboard row that connects the 10 kΩ resistor
    and Arduino pin 3, and plug the other into GND on the breadboard. (If you wired
    up your breadboard prototype just like the diagram in [Figure 4-14](ch04.xhtml#ch04fig14),
    then connect these wires to E20 and E22 on the breadboard.) Because the button
    is just a switch, it doesn’t matter which wire you plug into GND.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，重新将按钮连接到电路中。按钮有四个引脚，但你只需要连接按钮一侧的两个引脚。将一根公对母跳线连接到一个引脚，另一根连接到另一个引脚，如[图4-22](ch04.xhtml#ch04fig22)所示。然后，将一根线插入与10
    kΩ电阻和Arduino引脚3连接的同一面包板行，另一根插入面包板的GND。如果你的面包板原型与[图4-14](ch04.xhtml#ch04fig14)中的示意图相同，那么请将这些线连接到面包板的E20和E22上。因为按钮只是一个开关，所以接入GND的线不需要特别注意。
- en: '**FIGURE 4-22:** Connecting the male-to-female jumper wires to two legs on
    one side of the button'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-22：** 将公对母跳线连接到按钮一侧的两个引脚'
- en: '![Image](../images/fig4_22.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_22.jpg)'
- en: With your components in place, plug your Arduino into the computer and open
    the Serial Monitor to make sure your circuit still works. You should see your
    instruction messages on the Serial Monitor. When the blue LED lights, press the
    button as fast as you can. The Serial Monitor should show your reaction time,
    and either the red or green LED should turn on, based on how fast you were.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有组件就位后，将Arduino连接到计算机并打开串口监视器，确保电路仍然工作。你应该能在串口监视器上看到指令信息。当蓝色LED亮起时，尽可能快地按下按钮。串口监视器应显示你的反应时间，并且红色或绿色LED应亮起，具体取决于你的反应速度。
- en: If your circuit doesn’t seem to be working, check that all of your connections
    are secure, and compare your circuit to [Figures 4-14](ch04.xhtml#ch04fig14) and
    [4-15](ch04.xhtml#ch04fig15) to make sure the connections are correct.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电路似乎不工作，请检查所有连接是否牢固，并将电路与[图4-14](ch04.xhtml#ch04fig14)和[图4-15](ch04.xhtml#ch04fig15)进行对比，确保连接正确。
- en: '**Spice Up Your Game Enclosure**'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**装饰你的游戏外壳**'
- en: To finish up, add some bling to your new game. Use your imagination! You might
    want to cover your Reaction Timer with your favorite stickers or paint the box.
    We love using ping-pong balls in our projects, and since we had a half left over
    from [Project 2](ch02.xhtml#ch02), we decided to glue it on top of the blue LED,
    as in [Figure 4-23](ch04.xhtml#ch04fig23).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为你的新游戏添加一些装饰。发挥你的想象力！你可能想用你喜欢的贴纸装饰反应计时器，或者给盒子涂上颜色。我们在项目中喜欢使用乒乓球，因为我们在[项目2](ch02.xhtml#ch02)中剩下了一个半个，所以我们决定把它粘在蓝色LED上面，像[图4-23](ch04.xhtml#ch04fig23)所示。
- en: '**FIGURE 4-23:** Carnival-themed Reaction Timer game'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-23：** 以狂欢节为主题的反应计时器游戏'
- en: '![Image](../images/fig4_23.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_23.jpg)'
- en: '**GOING FURTHER**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**深入探索**'
- en: Next, try combining what you learned in the first three projects with what you
    know from this project to make it more interesting—add even more LEDs, or maybe
    make the game suitable for two players.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试将前面三个项目中的所学与这个项目的知识结合起来，使游戏更有趣——加入更多的LED，或者将游戏改造成适合两名玩家。
- en: '**Hack**'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**技巧**'
- en: Add two more LEDs to make a four-LED scale that will show your speed more accurately.
    Faster reaction times will light up more LEDs. To do this, you’ll need the help
    of a nested `if()`–`else if()` control statement. You can stack your condition
    statements to tell the code what to do in different conditions, so if the first
    logical expression is `false`, the next one is tested; if that’s also `false`,
    the next is tested; and so on until the final `else()` statement, which runs if
    none of the previous conditions were `true`. [Listing 4-7](ch04.xhtml#ch04ex07)
    shows an example of this conditional logic. It assumes you’ve added two extra
    LEDs connected to pins 10 and 9\. Don’t forget the `pinMode()` commands you’ll
    have to add to the `setup()`!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个额外的 LED，制作一个四 LED 的速度显示条，以更准确地显示你的反应速度。更快的反应时间将点亮更多的 LED。为了实现这一点，你将需要使用嵌套的
    `if()`–`else if()` 控制语句。你可以堆叠条件语句，让代码根据不同的条件做出相应的处理，因此如果第一个逻辑表达式为 `false`，则会测试下一个；如果那个也为
    `false`，则继续测试下一个，以此类推，直到最后的 `else()` 语句执行，如果之前的条件都没有为 `true`。[列表 4-7](ch04.xhtml#ch04ex07)
    展示了这种条件逻辑的示例。假设你已经添加了两个额外的 LED，分别连接到 10 和 9 引脚。不要忘了你需要在 `setup()` 中添加的 `pinMode()`
    命令！
- en: '**LISTING 4-7:** Snippet of nested `if()–else if()` statement'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 4-7：** 嵌套的 `if()–else if()` 语句片段'
- en: '[PRE9]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `if()` statement at ➊ checks whether the reaction time is less than or equal
    to 215 ms and lights up all four LEDs. Then two `else if()` statements catch times
    between 215 ms and 250 ms ➋, lighting up three LEDs, and between 250 ms and 300
    ms ➌, lighting up two LEDs. Finally, an `else` statement ➍ catches all times slower
    than 300 ms and lights up a single LED.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的 `if()` 语句检查反应时间是否小于或等于 215 毫秒，并点亮所有四个 LED。然后，两个 `else if()` 语句分别处理 215
    毫秒至 250 毫秒 ➋ 之间的时间，点亮三个 LED，以及 250 毫秒至 300 毫秒 ➌ 之间的时间，点亮两个 LED。最后，一个 `else` 语句
    ➍ 处理所有超过 300 毫秒的时间，并点亮一个 LED。
- en: If you need a little more help with the code, check out our example sketch in
    the resources at *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多的代码帮助，请查看我们在资源中提供的示例草图，地址为 *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*。
- en: '**Modify**'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**修改**'
- en: One fun way to modify this project would be to make it a two-player game. You
    could add a second button and repurpose your LEDs to indicate which player is
    faster. In this modification, the green LED will light up if Player 1 is faster,
    and the red LED will light up if Player 2 is faster.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 修改这个项目的一种有趣方式是将其变成两人游戏。你可以添加第二个按钮，并重新利用你的 LED 来显示哪个玩家更快。在这个修改中，如果玩家 1 更快，绿色
    LED 会亮起；如果玩家 2 更快，红色 LED 会亮起。
- en: First, add a second button. [Figure 4-24](ch04.xhtml#ch04fig24) shows the additional
    button at the bottom of the breadboard. Notice that it’s just a duplication of
    the pull-up resistor/button combination circuit that you built for the first button.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加第二个按钮。[图 4-24](ch04.xhtml#ch04fig24) 显示了面包板底部的附加按钮。请注意，它只是你为第一个按钮构建的上拉电阻/按钮组合电路的重复。
- en: '**FIGURE 4-24:** Adding a second button for two-player mode'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-24：** 为两人模式添加第二个按钮'
- en: '![Image](../images/fig4_24.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig4_24.jpg)'
- en: '**NOTE**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If both players hit the buttons at exactly the same time, the game will favor
    Player 1 (the green LED). Although this would be a really rare occurrence, how
    would you modify the code to light up both LEDs if both buttons are pressed at
    the same time?*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果两个玩家恰好同时按下按钮，游戏会偏向玩家 1（绿色 LED）。虽然这种情况非常罕见，但如果两个按钮同时按下，你会如何修改代码，让两个 LED 都亮起呢？*'
- en: The complete code for the two-player modification is available, along with the
    wiring diagram for the modification, at *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 两人游戏模式的完整代码可用，并附有修改的接线图，详见 *[https://www.nostarch.com/arduinoinventor/](https://www.nostarch.com/arduinoinventor/)*。
- en: Now, go and take your new game out on the town. Are you faster than your family?
    Are you faster than your friends? Who is the fastest person you know?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，去把你新的游戏带到城里吧。你比家里的人快吗？你比朋友们快吗？你认识的最快的人是谁？
