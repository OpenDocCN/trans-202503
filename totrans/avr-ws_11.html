<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch11">
  <div id="header1101" class="chapter">
   <h1 class="cn">
    <span class="page" id="p218">
    </span>
    <span class="page" id="p219">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch11">
     11
    </a>
   </h1>
   <h1 class="ctfm">
    AVR and the SPI Bus
   </h1>
  </div>
  <div class="figure" id="ct11">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   We can loosely define a
   <i class="calibre5">
    bus
   </i>
   as a connection between two devices that allows us to send data from one device to the other. For example, there are several types of data buses that can connect your AVR microcontroller to a sensor or display device. This chapter introduces the
   <i class="calibre5">
    serial peripheral interface (SPI) bus
   </i>
   , which we use to send bytes of data directly between a primary device and one or more secondary devices.
  </p>
  <p class="calibre8">
   In this chapter, you will learn how to:
  </p>
  <ul class="calibre10">
   <li class="blf">
    • Implement the SPI bus with AVR microcontrollers.
   </li>
   <li class="bl">
    • Read SPI device data sheets in order to write matching code.
   </li>
   <li class="bl">
    • Add a reset button to your projects.
   </li>
   <li class="bll">
    • Use two different SPI-based devices in the same project.
   </li>
  </ul>
  <p class="calibre8">
   <span id="p220">
   </span>
   Along the way, you’ll also learn how to use 74HC595 shift register ICs to increase the number of available digital output pins, display eight-digit numbers with a MAX7219 LED display driver IC, and measure voltages with the MCP3008 ADC IC.
  </p>
  <div class="chapter">
   <h2 class="ah" id="ah1301">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1301">
     How Buses Work
    </a>
   </h2>
   <p class="paft">
    The SPI bus enables communication between AVR microcontrollers and many popular parts and sensors. It works similarly to the USART that we used in
    <a class="url" href="nsp-boxall502581-0014.xhtml#ch04">
     Chapters 4
    </a>
    and
    <a class="url" href="nsp-boxall502581-0019.xhtml#ch09">
     9
    </a>
    , in that it transmits data in serial fashion from the microcontroller using one wire and to the microcontroller using another. However, the SPI bus also uses a third connection: a
    <i class="calibre5">
     clock line
    </i>
    , which carries an electrical signal that turns on and off at a constant frequency. Every time the clock changes state from high to low or low to high, a bit of data (an
    <i class="calibre5">
     on
    </i>
    or
    <i class="calibre5">
     off
    </i>
    ) is sent along the data line either from or to the microcontroller. The clock signal synchronizes with the data signal, allowing for fast and accurate data transmission.
   </p>
   <p class="calibre8">
    We can demonstrate the changing states of the data and clock lines using a DSO. For example, consider
    <a class="url" href="nsp-boxall502581-0021.xhtml#f11001">
     Figure 11-1
    </a>
    , which shows a byte of data traveling along the SPI bus.
   </p>
   <div class="figure" id="f11001">
    <p class="fig">
     <img alt="Screen capture from a digital storage oscilloscope showing the two channels of the SPI bus, and the electrical representation of a byte of data on the SPI bus" height="807" src="images/nsp-boxall502581-f11001.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 11-1:
      </span>
      A DSO showing a byte of data traveling on the SPI bus
     </p>
    </div>
   </div>
   <p class="calibre8">
    In
    <a class="url" href="nsp-boxall502581-0021.xhtml#f11001">
     Figure 11-1
    </a>
    , the upper waveform (marked 1 in the left margin) is the clock signal, which is activated when we use the SPI bus. The signal starts at 0 V, moves up to 5 V, then returns to 0 V, repeating this pattern if data is being transferred. The lower waveform (marked 2) represents the data, with a 1 being a 5 V signal and a 1 being a 0 V signal. From right to left, the data being sent is 10110110.
   </p>
   <p class="calibre8">
    The SPI bus can send and receive data simultaneously and at different speeds, depending on the microcontroller or SPI-based device used. Communication with the SPI bus uses a
    <i class="calibre5">
     main–secondary
    </i>
    configuration: the AVR acts as the
    <i class="calibre5">
     main
    </i>
    and determines which device (the
    <i class="calibre5">
     secondary
    </i>
    ) it will communicate with at a given time.
   </p>
   <p class="calibre8">
    <span id="p221">
    </span>
    In this book we’ll use the ATmega328P-PU microcontroller for projects that use the SPI bus, since the ATtiny85 doesn’t have enough memory or output pins to run those projects.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1301">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1301">
      Pin Connections and Voltages
     </a>
    </h3>
    <p class="paft">
     Each SPI device uses four pins to communicate with a main:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • MOSI (main out, secondary in)
     </li>
     <li class="bl">
      • MISO (main in, secondary out)
     </li>
     <li class="bl">
      • SCK (clock)
     </li>
     <li class="bll">
      • SS (secondary select, also known as “latch”)
     </li>
    </ul>
    <p class="calibre8">
     These SPI pins connect to your microcontroller as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11002">
      Figure 11-2
     </a>
     .
    </p>
    <div class="figure" id="f11002">
     <p class="fig">
      <img alt="Diagram showing how a main and secondary device are connected using the SPI bus" height="295" src="images/nsp-boxall502581-f11002.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-2:
       </span>
       Typical AVR-to-SPI device connection
      </p>
     </div>
    </div>
    <p class="calibre8">
     The SS pin on the SPI main device is labeled PBx in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11002">
      Figure 11-2
     </a>
     ; you can use any free GPIO pin, but to keep things simple it’s good to use a free pin on PORTB as the connection will be close to the SPI pins. Different manufacturers often use their own terminology for the SPI bus connections, but this should be easy to interpret after a quick examination.
    </p>
    <p class="calibre8">
     Since our AVR runs on 5 V in the following projects, your SPI device must also operate at or tolerate operating at 5 V, so be sure to check this with the seller or manufacturer before use. If you simply must use an SPI device that operates at a reduced voltage, such as 3.3 V, you can use a
     <i class="calibre5">
      level converter
     </i>
     like PMD Way part number 441079, shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11003">
      Figure 11-3
     </a>
     . A level converter can convert a 5 V digital signal to a 3.3 V signal, and vice versa.
    </p>
    <div class="figure" id="f11003">
     <p class="fig">
      <img alt="Photo of a level converter" height="1043" src="images/nsp-boxall502581-f11003.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-3:
       </span>
       PMD Way part number 441079
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p222">
     </span>
     This is a four-channel level converter board, meaning it can convert four independent electrical signals on the one board. To use a level converter, wire it between the four wires on the SPI bus: place the 5 V wires on the HV pads and the matching lower voltage wires on the LV pads and connect GND of both sides to the board. Remember to disconnect your USBasp programmer from your projects once you’ve uploaded the code, as the programmer’s pins share the SPI pins and can sometimes cause interruptions to the data flow between the microcontroller and the SPI-based device.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1302">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1302">
      Implementing the SPI Bus
     </a>
    </h3>
    <p class="paft">
     Next, let’s examine how to implement the SPI bus in our code and how to make the hardware connections. I’ll show you some parameters of an example SPI part being used, then how to adjust the SPI Control Register (SPCR) shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11004">
      Figure 11-4
     </a>
     to activate the SPI bus to our required parameters. In the following projects, I’ll also show you how this is done for various other SPI parts.
    </p>
    <div class="figure" id="f11004">
     <p class="fig">
      <img alt="Image of the SPI control register from the microcontroller’s data sheet" height="194" src="images/nsp-boxall502581-f11004.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-4:
       </span>
       SPCR diagram from the ATmega328P-PU data sheet
      </p>
     </div>
    </div>
    <p class="calibre8">
     Leave SPIE as 0, as we’re not working with interrupts, and set SPE to 1 to enable the SPI bus. Next, consider the DORD bit, which determines whether the byte of data is sent with the MSB (most significant bit, bit 7 of the byte) or the LSB (least significant bit, bit 0 of the byte) first. You’ll need to determine the direction from the secondary’s data sheet, which will include a timing diagram like the one in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11005">
      Figure 11-5
     </a>
     , or the supplier.
    </p>
    <div class="figure" id="f11005">
     <p class="fig">
      <img alt="SPI bus timing diagram for the MAX7219 LED display controller IC" height="525" src="images/nsp-boxall502581-f11005.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-5:
       </span>
       Example timing diagram for an SPI device (the MAX7219)
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p223">
     </span>
     Review the timing diagram’s DIN line. The data travels down the bus with the MSB first. If D0 were at the start of the line, the LSB would be first. Set DORD to 1 for LSB first, to 0 for MSB first.
    </p>
    <p class="calibre8">
     Returning to the SPCR, set MSTR to 1 to enable the microcontroller as the main device, and 0 if you need to enable the microcontroller as the secondary device. For all our projects we’ll use 1. Next, set CPOL to match the polarity of the clock (SCK) signal in the SPI bus when idle (that is, before and after data is carried on the bus): 0 for a low signal or 1 for a high signal. Again, you can get this information from the timing diagram: in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11005">
      Figure 11-5
     </a>
     the CLK (or clock/SCK) line is low when not in use, then rises when the first bit of data arrives, then alternates repeatedly until the data transmission has finished and it falls low again, so for this device you’d set it to 0.
    </p>
    <p class="calibre8">
     CPHA, the clock-phase bit, determines whether the data is sampled at the start or the end of the clock bit. For example, review the CLK and DIN lines of
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11005">
      Figure 11-5
     </a>
     . The data is sampled at the start of the clock bit, as the clock rises at the start time of the data bits. In this case you would set CPHA to 0. If the data bit started as the clock bit ended, CPHA would be 1.
    </p>
    <p class="calibre8">
     Finally, you’ll use the last two bits, SPR1 and SPR0, in conjunction to set the speed of the clock and matching data signals on the SPI bus. Set both to 0 for maximum speed in relation to the microcontroller. Also set the AVR output pin connected to your SPI device’s SS pin as an output using a
     <code class="calibre23">
      DDR
     </code>
     <code class="i1">
      x
     </code>
     function, then set that pin to high using the typical
     <code class="calibre23">
      PORT
     </code>
     <code class="i1">
      x
     </code>
     function.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1303">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1303">
      Sending Data
     </a>
    </h3>
    <p class="paft">
     Now that you’ve initialized your SPI bus, it should be ready to receive and send data. We’ll practice sending data first, then examine receiving data later in this chapter. To send a byte of data to the SPI device, you need to do four things (all of which we’ll do in the
     <a class="url" href="nsp-boxall502581-0021.xhtml#pro44">
      next project
     </a>
     ):
    </p>
    <ul class="calibre10">
     <li class="blf">
      • Set the SS pin low using a
      <code class="calibre23">
       PORT
      </code>
      <code class="i1">
       x
      </code>
      command.
     </li>
     <li class="bl">
      • Place the byte of data you wish to send into the SPDR register.
     </li>
     <li class="bl">
      • Wait for the transmission to finish using
      <code class="calibre23">
       while(!(SPSR &amp; (1&lt;&lt;SPIF)));
      </code>
      .
     </li>
     <li class="bll">
      • Set the SS pin high using a
      <code class="calibre23">
       PORT
      </code>
      <code class="i1">
       x
      </code>
      command.
     </li>
    </ul>
    <p class="calibre8">
     This may seem a little complicated, but with practice and the right information from part suppliers, it’s easy. I’ll explain everything you need to know to build our SPI bus projects, the first of which harnesses a particularly useful shift register IC.
    </p>
    <p class="hd" id="pro44">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro44">
      <span class="ccust1">
       Project 44: Using the 74HC595 Shift Register
      </span>
     </a>
    </p>
    <p class="paft">
     When your AVR-based project doesn’t have enough digital output pins, you can connect one or more
     <i class="calibre5">
      shift registers
     </i>
     and still have plenty of output pins for use on the AVR itself. A shift register is an integrated circuit with eight
     <span id="p224">
     </span>
     digital output pins that we can control by sending a byte of data to the IC via the SPI bus. The projects in this chapter will use the 74HC595 shift register, as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11006">
      Figure 11-6
     </a>
     .
    </p>
    <div class="figure" id="f11006">
     <p class="fig">
      <img alt="Photo of a 74HC595 shift register integrated circuit" height="686" src="images/nsp-boxall502581-f11006.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-6:
       </span>
       The 74HC595 shift register IC
      </p>
     </div>
    </div>
    <p class="calibre8">
     The 74HC595 shift register has eight digital outputs that operate in the same way as your AVR’s digital outputs, as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11007">
      Figure 11-7
     </a>
     .
    </p>
    <div class="figure" id="f11007">
     <p class="fig">
      <img alt="Schematic symbol for the 74HC595 shift register IC" height="1200" src="images/nsp-boxall502581-f11007.jpg" width="888" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-7:
       </span>
       The 74HC595 schematic symbol
      </p>
     </div>
    </div>
    <p class="calibre8">
     <a class="url" href="nsp-boxall502581-0021.xhtml#tab1101">
      Table 11-1
     </a>
     gives details on how to connect the shift register to the microcontroller.
    </p>
    <table id="tab1101" class="calibre13">
     <thead class="calibre14">
      <tr class="calibre15">
       <th colspan="2" class="calibre16">
        <p class="th1">
         <span id="p225">
         </span>
         <span class="calibre4">
          Table 11-1
         </span>
         : 74HC595 Connections
        </p>
       </th>
      </tr>
      <tr class="calibre15">
       <th scope="col" class="calibre16">
        <p class="tch">
         Pin
        </p>
       </th>
       <th scope="col" class="calibre16">
        <p class="tch">
         Connection
        </p>
       </th>
      </tr>
     </thead>
     <tbody class="calibre17">
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         16
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         5 V positive power supply
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         8
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         GND
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         QA to QH (15, 1–7)
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         Digital outputs 0 to 7
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         10
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         5 V positive power supply
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         11
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         SPI bus clock
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         12
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         SPI SS
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         13
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         GND
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         14
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         SPI data in
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         9
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         SPI data out
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p class="calibre8">
     The principle behind the shift register is simple: we send 1 byte of data (8 bits) to the shift register, which turns the matching eight outputs on or off based on that byte of data. The bits representing the byte match the output pins in order from highest to lowest. Therefore, the MSB of the data represents output pin 7 of the shift register, while the LSB represents output pin 0. For example, if we send the byte
     <code class="calibre23">
      0b10000110
     </code>
     to the shift register via the SPI bus, it will turn on outputs 7, 2, and 1 and will turn off outputs 0 and 3–6 until the shift register receives the next byte of data, or we turn the power off.
    </p>
    <p class="calibre8">
     Once you send a new byte of data to the shift register, it sends the previous byte of data out via SPI pin 9, the data out pin. Thus, you can harness two or more, sending multiple bytes of data in one operation to control multiple shift registers.
    </p>
    <p class="pcust">
     <span class="ccust">
      Note
     </span>
     You can usually draw up to 20 mA of current from an output pin, and the total current drawn from an entire 74HC595 shouldn’t exceed 75 mA.
    </p>
    <p class="calibre8">
     You get an extra eight digital output pins for every shift register attached to the SPI bus. This makes shift registers very convenient when you want to control lots of LEDs or other devices. In this project, we’ll use it to control a seven-segment numeric LED display.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1304">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1304">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your display circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      <span id="p226">
      </span>
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • One 74HC595 shift register IC
     </li>
     <li class="bl">
      • One common-cathode seven-segment LED display
     </li>
     <li class="bl">
      • Eight 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors (R1–R8)
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11008">
      Figure 11-8
     </a>
     .
    </p>
    <div class="figure" id="f11008">
     <p class="fig">
      <img alt="Schematic diagram for Project 44" height="831" src="images/nsp-boxall502581-f11008.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-8:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0021.xhtml#pro44">
        Project 44
       </a>
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1305">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1305">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 44
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 11
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     to compile and upload the data as usual. Don’t forget to disconnect the programmer once you’ve uploaded it to the microcontroller. After a moment, the digits 0 to 9 should show in ascending order on the LED display, and then repeat.
    </p>
    <p class="calibre8">
     Let’s examine the code to see how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 44 - Using the 74HC595 Shift Register
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void setupSPI()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p227">
      </span>
      PORTB |= (1 &lt;&lt; 0); // SS pin HIGH
     </p>
     <p class="cl">
      // Set up SPI bus
     </p>
     <p class="cl">
      SPCR = 0b01110000;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ void dispNumSR(uint8_t value)
     </p>
     <p class="cl">
      // Displays a number from 0–9 on the seven-segment LED display
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // SS pin LOW
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ PORTB &amp;= ~(1 &lt;&lt; PORTB0);
     </p>
     <p class="cl">
      switch(value)
     </p>
     <p class="cl">
      // Determine which byte of data to send to the 74HC595
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      case 0 : SPDR = 0b11111100; break; // 0
     </p>
     <p class="cl">
      case 1 : SPDR = 0b01100000; break; // 1
     </p>
     <p class="cl">
      case 2 : SPDR = 0b11011010; break; // 2
     </p>
     <p class="cl">
      case 3 : SPDR = 0b11110010; break; // 3
     </p>
     <p class="cl">
      case 4 : SPDR = 0b01100110; break; // 4
     </p>
     <p class="cl">
      case 5 : SPDR = 0b10110110; break; // 5
     </p>
     <p class="cl">
      case 6 : SPDR = 0b10111110; break; // 6
     </p>
     <p class="cl">
      case 7 : SPDR = 0b11100000; break; // 7
     </p>
     <p class="cl">
      case 8 : SPDR = 0b11111110; break; // 8
     </p>
     <p class="cl">
      case 9 : SPDR = 0b11100110; break; // 9
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ while(!(SPSR &amp; (1&lt;&lt;SPIF)));          // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      // SS pin HIGH
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; PORTB0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl2">
      <!--<ccust1>5</ccust1>-->
      ❺ {
     </p>
     <p class="cl">
      uint8_t i=0;
     </p>
     <p class="cl">
      DDRB = 0b11111111;                   // Set PORTB as outputs
     </p>
     <p class="cl">
      setupSPI();
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      for (i=0; i&lt;10; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      dispNumSR(i);
     </p>
     <p class="cl">
      _delay_ms(250);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     The code contains a couple of custom functions, the first being
     <code class="calibre23">
      setupSPI()
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶. We use this function to initialize the SPI bus and set the SS pin to high, then set the SPCR register as explained earlier in this chapter. We set the DORD bit in the SPCR register to 1, as we need to send data to the 74HC595 with the LSB first. We can see the requirement to use the 56LSB first from the timing diagram in the 74HC595’s data sheet, shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11009">
      Figure 11-9
     </a>
     : Q
     <sub class="calibre28">
      A
     </sub>
     (the first output pin) is the first to be set high.
    </p>
    <div class="figure" id="f11009">
     <p class="fig">
      <span id="p228">
      </span>
      <img alt="Timing diagram for the 74HC595" height="1010" src="images/nsp-boxall502581-f11009.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-9:
       </span>
       The 74HC595’s timing diagram
      </p>
     </div>
    </div>
    <p class="calibre8">
     We also need to determine what value to use for the CPOL bit. We set this to 0, since the polarity of the clock signal is low, or off, when idle.
    </p>
    <p class="calibre8">
     The final bit to consider is CPHA, the clock-phase bit mentioned earlier. If you refer to the diagram again and compare the RCLK timing and signals to any of the Q outputs, you’ll see that they both change from low to high at the same time. Therefore, the data is sampled at the start, so we set CPHA to 0. The final bits (1 and 0) we leave as 0 to set the SPI bus for maximum possible speed.
    </p>
    <p class="calibre8">
     Our second custom function,
     <code class="calibre23">
      dispNumSR()
     </code>
     <!--<ccust1>2</ccust1>-->
     ❷, accepts an integer between 0 and 9 and shows this on the LED display. It first sets the SS pin low
     <!--<ccust1>3</ccust1>-->
     ❸, then determines which matching byte of data for the digit to display using a
     <code class="calibre23">
      switch...case
     </code>
     statement.
    </p>
    <p class="calibre8">
     The microcontroller sends each byte of data with the LSB first. The bits match the eight outputs on the 74HC595, which we wire to the LED display segments A−G and the decimal point, respectively, as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11008">
      Figure 11-8
     </a>
     . This byte of data is then placed in the SPDR register in each matching
     <code class="calibre23">
      case
     </code>
     statement. The code waits for the transfer to finish
     <!--<ccust1>4</ccust1>-->
     ❹, then sets the SS pin high to complete the data transmission.
    </p>
    <p class="calibre8">
     The main loop of code
     <!--<ccust1>5</ccust1>-->
     ❺ simply sets up PORTB as outputs, as it contains the pins we need for all four SPI bus connections, then calls the
     <code class="calibre23">
      setupSPI()
     </code>
     function to set up the SPI bus as described earlier. It then sends the numbers 0 to 9 to the LED display.
    </p>
    <p class="calibre8">
     The decimal point in our project is connected, but not in use. You can turn it on and off with the last bit of the byte sent to the shift register. For a challenge, try modifying the
     <code class="calibre23">
      dispNumSR()
     </code>
     function to accept a second variable to turn the decimal point on or off.
    </p>
    <p class="calibre8">
     Now that you know how to control a single device with the SPI bus, let’s try using it to control two devices at the same time.
    </p>
    <p class="hd" id="pro45">
     <span class="page" id="p229">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro45">
      <span class="ccust1">
       Project 45: Using Two 74HC595 Shift Registers
      </span>
     </a>
    </p>
    <p class="paft">
     Using two or more shift registers is an inexpensive and simple way to control many more digital outputs with your AVR. As an example, this project uses two 74HC595 shift registers to show double-digit numbers via two LED displays.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1306">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1306">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your display circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Two 74HC595 shift registers
     </li>
     <li class="bl">
      • Two common-cathode seven-segment LED displays
     </li>
     <li class="bl">
      • 16 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors (R1–R16)
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11010">
      Figure 11-10
     </a>
     .
    </p>
    <div class="figure" id="f11010">
     <p class="fig">
      <img alt="Schematic diagram for Project 45" height="928" src="images/nsp-boxall502581-f11010.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-10:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0021.xhtml#pro45">
        Project 45
       </a>
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1307">
     <span class="page" id="p230">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1307">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 45
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 11
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     to compile and upload the data as usual. After a moment or two the numbers 0 through 99 should appear in ascending order on the LED displays, then repeat.
    </p>
    <p class="calibre8">
     Let’s see how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 45 - Using Two 74HC595 Shift Registers
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      void setupSPI()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; 0);          // SS pin HIGH
     </p>
     <p class="cl">
      // Set up SPI bus
     </p>
     <p class="cl">
      SPCR = 0b01110000;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void dispNumSR(uint8_t value)
     </p>
     <p class="cl">
      // Displays a number from 00–99 on the seven-segment LED displays
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t leftDigit;
     </p>
     <p class="cl">
      uint8_t rightDigit;
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ uint8_t digitData[] = {0b11111100, 0b01100000, 0b11011010, 0b11110010, 0b01100110,
     </p>
     <p class="cl">
      0b10110110, 0b10111110, 0b11100000, 0b11111110, 0b11100110};
     </p>
     <p class="clf">
      <!--<ccust1>3</ccust1>-->
      ❸ leftDigit = value/10;
     </p>
     <p class="cl">
      rightDigit = value%10;
     </p>
     <p class="clf">
      <!--<ccust1>4</ccust1>-->
      ❹ PORTB &amp;= ~(1 &lt;&lt; PORTB0);    // SS pin LOW
     </p>
     <p class="clf">
      <!--<ccust1>5</ccust1>-->
      ❺ SPDR = digitData[rightDigit];
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ while(!(SPSR &amp; (1&lt;&lt;SPIF))); // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      SPDR = digitData[leftDigit];
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF))); // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ PORTB |= (1 &lt;&lt; PORTB0);     // SS pin HIGH
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i=0;
     </p>
     <p class="cl">
      DDRB = 0b11111111;          // Set PORTB as outputs
     </p>
     <p class="cl">
      setupSPI();
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      for (i=0; i&lt;100; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      dispNumSR(i);
     </p>
     <p class="cl">
      _delay_ms(250);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     <span id="p231">
     </span>
     The code for this dual-digit version is similar to that of
     <a class="url" href="nsp-boxall502581-0021.xhtml#pro44">
      Project 44
     </a>
     , except that since we have two shift registers to control, it sends two bytes of data at once. This time, the
     <code class="calibre23">
      dispNumSR()
     </code>
     function
     <!--<ccust1>1</ccust1>-->
     ❶ accepts a number between 0 and 99, then divides the number using division and modulo
     <!--<ccust1>3</ccust1>-->
     ❸ in order to treat each digit separately and store them in the
     <code class="calibre23">
      leftDigit
     </code>
     and
     <code class="calibre23">
      rightDigit
     </code>
     variables.
    </p>
    <p class="calibre8">
     Next, the required operation for sending SPI data begins. We set the SS pin low
     <!--<ccust1>4</ccust1>-->
     ❹, then send out the byte of data that represents the digit 0 to 9 as specified in the
     <code class="calibre23">
      digitData
     </code>
     array
     <!--<ccust1>2</ccust1>-->
     ❷ for the right-hand digit to the shift register
     <!--<ccust1>5</ccust1>-->
     ❺. After waiting
     <!--<ccust1>6</ccust1>-->
     ❻ for the byte to be transferred, we send the byte of data for the left-hand digit in the same manner. After we’ve finished waiting for the transmission to complete, the code sets the SS pin high
     <!--<ccust1>7</ccust1>-->
     ❼ to complete the data transmission. The SS pins of both shift registers are connected, so we only need one digital output to control them.
    </p>
    <p class="calibre8">
     The byte for the second (ones) digit is sent first, as it is the second shift register—the byte sits in the first shift register, then the byte for the tens digit is sent, which pushes the first byte into the second shift register. That means the first shift register contains the data for the tens digit, and the second shift register contains the data for the ones digit. Once the SS pin is set high, the shift registers’ outputs activate, and the LED displays begin showing the numbers.
    </p>
    <p class="calibre8">
     Although this project controlled LED displays, you now have the necessary skills to use multiple shift registers to expand your AVR’s outputs in other cases. If you need to control larger numerical displays—up to eight digits—the next project is for you.
    </p>
    <p class="hd" id="pro46">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro46">
      <span class="ccust1">
       Project 46: Using the MAX7219 LED Driver IC
      </span>
     </a>
    </p>
    <p class="paft">
     When you need to use more than two seven-segment numerical displays for a project, the wiring and related controls can become quite complex. Thankfully, there’s a solution for this: the Maxim MAX7219 LED driver IC, a popular IC that can control up to 64 LEDs at once. In turn, we can use these LEDs to simultaneously display eight numerical digits with only four control wires via the SPI bus. This project shows how to use this display module.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1308">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1308">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     The MAX7219 is available in both through-hole (
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11011">
      Figure 11-11
     </a>
     ) and surface-mount (
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11012">
      Figure 11-12
     </a>
     ) package types.
    </p>
    <div class="figure" id="f11011">
     <p class="fig">
      <img alt="Photo of a through-hole MAX7219" height="999" src="images/nsp-boxall502581-f11011.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 11-12:
       </span>
       The MAX7219 in a surface-mount package type
      </p>
     </div>
    </div>
    <div class="figure" id="f11012">
     <p class="fig">
      <img alt="Photo of a surface-mount MAX7219" height="974" src="images/nsp-boxall502581-f11012.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-11:
       </span>
       The MAX7219 in a through-hole package type
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p232">
     </span>
     The through-hole version is most useful when working with a solderless breadboard or making your own hand-assembled printed circuit board (PCB). If you have trouble finding a MAX7219, the Allegro AS1107 is a drop-in replacement.
    </p>
    <p class="calibre8">
     If you’re looking to control large numerical displays, you can easily find them preassembled, usually with four to eight digits fitted to a module with the MAX7219. For this project we’ll use an eight-digit module, as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11013">
      Figure 11-13
     </a>
     .
    </p>
    <div class="figure" id="f11013">
     <p class="fig">
      <img alt="Photo of an eight-digit LED module with a MAX7219" height="398" src="images/nsp-boxall502581-f11013.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-13:
       </span>
       An eight-digit LED module
      </p>
     </div>
    </div>
    <p class="calibre8">
     These modules use the surface-mount version of the MAX7219, which is soldered onto the rear of the module’s PCB. The modules usually include some inline header pins to allow for attaching control wires. If you haven’t already done so, solder these pins to your module as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11014">
      Figure 11-14
     </a>
     .
    </p>
    <div class="figure" id="f11014">
     <p class="fig">
      <img alt="Photo of the header pins soldered to the eight-digit LED module" height="990" src="images/nsp-boxall502581-f11014.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-14:
       </span>
       Connecting inline header pins
      </p>
     </div>
    </div>
    <p class="calibre8">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • MAX7219 eight-digit module
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     <span id="p233">
     </span>
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11015">
      Figure 11-15
     </a>
     .
    </p>
    <div class="figure" id="f11015">
     <p class="fig">
      <img alt="Schematic diagram for Project 46" height="1200" src="images/nsp-boxall502581-f11015.jpg" width="822" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-15:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0021.xhtml#pro46">
        Project 46
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     As you construct your circuit to follow the schematic, connect your display module as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#tab1102">
      Table 11-2
     </a>
     .
    </p>
    <table id="tab1102" class="calibre13">
     <thead class="calibre14">
      <tr class="calibre15">
       <th colspan="2" class="calibre16">
        <p class="th1">
         <span class="calibre4">
          Table 11-2
         </span>
         : ATmega328P-PU to MAX7219 Connections
        </p>
       </th>
      </tr>
      <tr class="calibre15">
       <th scope="col" class="calibre16">
        <p class="tch">
         ATmega328P-PU
        </p>
       </th>
       <th scope="col" class="calibre16">
        <p class="tch">
         MAX7219 module
        </p>
       </th>
      </tr>
     </thead>
     <tbody class="calibre17">
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         7
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         V
         <sub class="calibre28">
          cc
         </sub>
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         8
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         GND
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         17
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         DIN
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         14
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         SS
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         19
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         CLK
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p class="calibre8">
     Note that the display may quickly draw and stop drawing current, which sometimes will affect the power supply voltage. Therefore, we use a 470
     <span lang="el" xml:lang="el">
      μF
     </span>
     electrolytic capacitor to keep the 5 V power smooth. You can review capacitor types in
     <a class="url" href="nsp-boxall502581-0012.xhtml#ch02">
      Chapter 2
     </a>
     .
    </p>
    <p class="calibre8">
     <span id="p234">
     </span>
     Before we dive into the code, let’s consider the parameters required for the SPI setup via the SPCR register. From the timing diagram for the MAX7219 in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11005">
      Figure 11-5
     </a>
     , we can see that we should set the DORD bit to 0, as the MAX7219 requires data sent LSB first. We’ll set the CPOL bit to 0, as the clock signal is low at the start of data transmission, and we’ll set the CPHA bit to 0 too, as the clock signal’s polarity is low at idle.
    </p>
    <p class="calibre8">
     Now we need to explore how to control the MAX7219. Every time we want the IC to do something, we must send two bytes of data. The first byte is the address of a control register (other ICs have registers just as the microcontroller does), and the second byte is the value to be stored in that register. This could be setup configuration such as display brightness, or the value that represents a number to display on a certain digit.
    </p>
    <p class="calibre8">
     The possible values for each register are described in the MAX7219 using hexadecimal numbers (base-16), so we’ll use them to save effort. You can store hexadecimal numbers in
     <code class="calibre23">
      char
     </code>
     variable types. For your own reference and research, you may wish to download and review the MAX7219’s data sheet from
     <a class="url-i" href="https://www.maximintegrated.com/en/products/power/display-power-control/MAX7219.html">
      https://www.maximintegrated.com/en/products/power/display-power-control/MAX7219.html
     </a>
     .
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1309">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1309">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <a class="url-i" href="nsp-boxall502581-0021.xhtml#pro46">
      Project 46
     </a>
     subfolder of this book’s
     <a class="url-i" href="nsp-boxall502581-0021.xhtml#ch11">
      Chapter 11
     </a>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     to compile and upload the data as usual. After a moment or two the display should show eight zeros, then count upward until it gets to 9,999,999, then repeat.
    </p>
    <p class="calibre8">
     Let’s see how this is done:
    </p>
    <pre>
     <p class="clf">
      // Project 46 - Using the MAX7219 LED Driver IC
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void writeMAX7219(char hexdata1, char hexdata2)
     </p>
     <p class="cl">
      // Sends two bytes in hexadecimal to the MAX7219
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB &amp;= ~(1 &lt;&lt; PORTB0);    // SS pin LOW
     </p>
     <p class="cl">
      SPDR = hexdata1;            // Send value of hexdata1
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF))); // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      SPDR = hexdata2;            // Send value of hexdata2
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF))); // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; PORTB0);     // SS pin HIGH
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ void blankMAX7219()
     </p>
     <p class="cl">
      // Blanks all digits
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="cl">
      for (i=1; i&lt;9; i++)         // Blank all digits
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      writeMAX7219(i,15);      // Send blank (15) to digit register (i)
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <span id="p235">
      </span>
      <!--<ccust1>3</ccust1>-->
      ❸ void initMAX7219()
     </p>
     <p class="cl">
      // Set up MAX7219 for use
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; 0);          // SS pin HIGH
     </p>
     <p class="cl">
      SPCR = 0b01010000;          // Set up SPI bus for MAX7219
     </p>
     <p class="cl">
      writeMAX7219(0x09,0xFF);    // Mode decode for digits
     </p>
     <p class="cl">
      writeMAX7219(0x0B,0x07);    // Set scan limit to 8 digits: 0x09 + 0xFF)
     </p>
     <p class="cl">
      writeMAX7219(0x0A,0x01);    // Set intensity to 8 - 0x0A + 0x08)
     </p>
     <p class="cl">
      writeMAX7219(0x0C,0x01);    // Mode display on
     </p>
     <p class="cl">
      blankMAX7219();
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>4</ccust1>-->
      ❹ void dispMAX7219(uint8_t digit, uint8_t number, uint8_t dp)
     </p>
     <p class="cl">
      // Displays "number" in location "digit" with decimal point on/off
     </p>
     <p class="cl">
      // Digit: 1~8 for location 1~8
     </p>
     <p class="cl">
      // Number: 0~15 for 0~9, - E, H, L, P, blank
     </p>
     <p class="cl">
      // dp: 1 on, 0 off
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ if (dp==1)                  // Add decimal point
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      number = number + 128;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      writeMAX7219(digit, number);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>6</ccust1>-->
      ❻ void numberMAX7219(uint32_t value)
     </p>
     <p class="cl">
      // Displays a number between 0–99999999
     </p>
     <p class="clf">
      uint8_t digits[9];
     </p>
     <p class="cl">
      uint8_t i = 1;
     </p>
     <p class="clf">
      for (i=1; i&lt;9; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ digits[i]=15;            // Sending 15 blanks the digit
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      i = 1;
     </p>
     <p class="cl">
      while (value &gt; 0)           // Continue until value &gt; 0
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      digits[i] = value % 10;  // Determine and store last digit
     </p>
     <p class="cl">
      value = value / 10;      // Divide value by 10
     </p>
     <p class="cl">
      i++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      for (i=1; i&lt;9; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      dispMAX7219(i, digits[i],0);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl2">
      <!--<ccust1>8</ccust1>-->
      ❽ {
     </p>
     <p class="cl">
      uint32_t i;
     </p>
     <p class="cl">
      DDRB = 0b11111111;          // Set PORTB as outputs
     </p>
     <p class="cl">
      initMAX7219();
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p236">
      </span>
      for (i = 0; i&lt;100000000; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      numberMAX7219(i);
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     To save time, we use a custom function,
     <code class="calibre23">
      writeMAX7219(
     </code>
     <code class="i1">
      char hexdata1
     </code>
     <code class="calibre23">
      ,
     </code>
     <code class="i1">
      char hexdata2
     </code>
     <code class="calibre23">
      )
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶, to send two hexadecimal bytes of data to the IC via the SPI bus. This function sets the SS pin low, assigns the first byte of data to the SPDR register, waits for transmission to finish, then repeats the process for the second byte and the sets the SS pin high again. After setting up the SPI bus, we initialize the MAX7219 by placing values in four configuration registers using another custom function,
     <code class="calibre23">
      initMAX7219()
     </code>
     <!--<ccust1>3</ccust1>-->
     ❸.
    </p>
    <p class="calibre8">
     Before writing any digits to the display, we introduce the
     <code class="calibre23">
      blankMAX7219()
     </code>
     function
     <!--<ccust1>2</ccust1>-->
     ❷ to be sure we clear the display between writes. Without this function, if we were to, say, write 32,785 to the display and then write 45, the display would show 32,745.
    </p>
    <p class="calibre8">
     To show a digit on the display, we use
     <code class="calibre23">
      writeMAX7219()
     </code>
     to send two bytes of data. The first byte of data is the digit location, from right to left (locations 0 to 7). The address for each digit location is conveniently the same as the location plus 1; for example, the address for digit 5 is
     <code class="calibre23">
      0x06
     </code>
     in hexadecimal. The second byte of data is the actual number to display. To display the number nine on the leftmost digit of our module, for instance, we’d send
     <code class="calibre23">
      0x08
     </code>
     then
     <code class="calibre23">
      0x09
     </code>
     , as follows:
    </p>
    <pre>
     <p class="cls">
      writeMAX7219(0x08, 0x09);
     </p>
    </pre>
    <p class="calibre8">
     You can also use decimal numbers or integer variables if convenient:
    </p>
    <pre>
     <p class="cls">
      writeMAX7219(8, 9);
     </p>
    </pre>
    <p class="calibre8">
     You can view the address map for the digit locations in Table 2 of the MAX7219 data sheet and the characters you can display in Table 5.
    </p>
    <p class="calibre8">
     Now that we’ve set up out
     <code class="calibre23">
      writeMAX7219()
     </code>
     function to easily write data to the MAX7219, we harness this function within another function:
     <code class="calibre23">
      dispMAX7219(uint8_t digit, uint8_t number, uint8_t dp)
     </code>
     <!--<ccust1>4</ccust1>-->
     ❹. We use this to display digits in locations with or without the decimal point. Set
     <code class="i1">
      dp
     </code>
     to 1 to show the decimal point, or 0 to not show it. For example, to display the number 3 without the decimal point on the rightmost digit of the module, we would use:
    </p>
    <pre>
     <p class="cls">
      <code class="calibre23">
       dispMAX7219(1, 3, 0)
      </code>
     </p>
    </pre>
    <p class="calibre8">
     The decimal point is activated by adding 128 (which is
     <code class="calibre23">
      0xF0
     </code>
     in hexadecimal) to the byte representing the number to display
     <!--<ccust1>5</ccust1>-->
     ❺.
    </p>
    <p class="calibre8">
     All the custom functions mentioned so far build up to our final function,
     <code class="calibre23">
      numberMAX7219(
     </code>
     <code class="i1">
      uint32_t value
     </code>
     <code class="calibre23">
      )
     </code>
     <!--<ccust1>6</ccust1>-->
     ❻, which accepts an integer between 0 and 99,999,999 and shows it on our display module. This function uses
     <span id="p237">
     </span>
     modulo and division to break down the whole number into separate digits and places them in an array. It then runs through the array and sends each digit to the display.
    </p>
    <p class="calibre8">
     At the start of the function, we fill the array with the number 15
     <!--<ccust1>7</ccust1>-->
     ❼. This is because sending a 15 as the number value to the MAX7219 causes the IC to blank the digit being addressed, allowing us to avoid displaying leading zeros for unused digits. Finally, the main loop of code
     <!--<ccust1>8</ccust1>-->
     ❽ sets up the interface pins used for SPI as outputs, and successively displays the numbers 0 through 99,999,999 on the LED display.
    </p>
    <p class="calibre8">
     This may seem like a lot of work, but now that you have the tools to easily drive these larger numerical displays, you can reuse the functions in your own projects. If you enjoy a challenge, why not write your own MAX7219 library? In the meantime, to set the stage for later projects, I’d like to introduce a new addition to your AVR circuitry.
    </p>
    <p class="hd" id="pro47">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro47">
      <span class="ccust1">
       Project 47: Adding a Reset Button
      </span>
     </a>
    </p>
    <p class="paft">
     In future projects in this book and in your own creations, there will come a time when you need to literally reset a project so it starts operating again in the same manner as when first turned on. To enable this, your projects will need a reset button, which we’ll construct now. Reset buttons save time and are much more convenient than disconnecting then reconnecting the power supply.
    </p>
    <p class="calibre8">
     To add reset buttons to your AVR projects, you will need the following:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • Pushbutton
     </li>
     <li class="bl">
      • 10
      <span lang="en" xml:lang="en">
       kΩ
      </span>
      resistor
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     The reset button circuit for the ATtiny85 is shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11016">
      Figure 11-16
     </a>
     .
    </p>
    <div class="figure" id="f11016">
     <p class="fig">
      <img alt="Schematic diagram for adding a reset button to an ATtiny85 microcontroller" height="782" src="images/nsp-boxall502581-f11016.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-16:
       </span>
       Reset button circuit for the ATtiny85
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p238">
     </span>
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11017">
      Figure 11-17
     </a>
     shows the reset button circuit for the ATmega328P-PU.
    </p>
    <div class="figure" id="f11017">
     <p class="fig">
      <img alt="Schematic diagram for adding a reset button to an ATmega328P-PU microcontroller" height="1200" src="images/nsp-boxall502581-f11017.jpg" width="946" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-17:
       </span>
       Reset button circuit for the ATmega328P-PU
      </p>
     </div>
    </div>
    <p class="calibre8">
     If you are comparing this to the buttons discussed in
     <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
      Chapter 3
     </a>
     , notice the difference in the wiring. This button configuration, in which the connection of the resistor between the 5 V and RESET pins keeps the pin in a high state for normal operation, is called a
     <i class="calibre5">
      pullup
     </i>
     configuration. When the user presses the button, the RESET pin is set to a low state as the button directly connects the pin to GND.
    </p>
    <p class="calibre8">
     We know to use this pullup configuration thanks to the part’s schematic symbol in the data sheet: there’s a solid bar over the RESET pin’s label, unlike the labels for the other pins. This bar means that the default input for this pin for normal operation is high, and whatever function the pin is used for will be activated when it is set to low.
    </p>
    <p class="calibre8">
     You don’t need to add any code to your project to allow for the reset button—it’s a simple hardware addition. With the button set up, let’s move
     <span id="p239">
     </span>
     on to controlling two different SPI devices and learning how to receive data from the SPI bus. These sections will prepare us for the final project in this chapter, where we’ll create a simple digital voltmeter.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah1302">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1302">
     Multiple SPI Devices on the Same Bus
    </a>
   </h2>
   <p class="paft">
    You can use two or more different SPI-based devices on the same SPI bus, and doing so only requires one extra digital output pin per device. Simply connect all the SCK, MOSI, and MISO pins together, and then connect the SS pins to their own digital output pin on the AVR. For example,
    <a class="url" href="nsp-boxall502581-0021.xhtml#f11018">
     Figure 11-18
    </a>
    shows two SPI devices on the one bus, each with its own SS line connected to a unique PORTB pin.
   </p>
   <div class="figure" id="f11018">
    <p class="fig">
     <img alt="Diagram showing how a main and two secondary devices are connected using the SPI bus" height="655" src="images/nsp-boxall502581-f11018.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 11-18:
      </span>
      Two SPI devices connected to one microcontroller
     </p>
    </div>
   </div>
   <p class="calibre8">
    When it comes time to communicate with a particular SPI device, just use the appropriate SS connection and proceed as normal. We’ll do that in the
    <a class="url" href="nsp-boxall502581-0021.xhtml#pro48">
     next project
    </a>
    , which uses the MAX7219 LED display from
    <a class="url" href="nsp-boxall502581-0021.xhtml#pro46">
     Project 46
    </a>
    along with a new device.
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah1303">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1303">
     Receiving Data from the SPI Bus
    </a>
   </h2>
   <p class="paft">
    As explained previously, we send a byte of data from the microcontroller to the SPI device by placing it in the SPDR register. Receiving a byte of data from an SPI device requires two operations: first the SPI device we’re communicating with sends a byte of data, then the AVR places this byte in the SPDR register for our use.
   </p>
   <p class="calibre8">
    Thus, you can think of the SPI bus as a continuous circle of data, as shown in
    <a class="url" href="nsp-boxall502581-0021.xhtml#f11019">
     Figure 11-19
    </a>
    .
   </p>
   <div class="figure" id="f11019">
    <p class="fig">
     <span id="p240">
     </span>
     <img alt="Image illustrating data flow between an SPI bus device and the microcontroller’s SPDR register" height="337" src="images/nsp-boxall502581-f11019.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 11-19:
      </span>
      SPI bus data transfer
     </p>
    </div>
   </div>
   <p class="calibre8">
    As a bit of data leaves the microcontroller on its way to the SPI device, a bit of data leaves the SPI device and heads back into the SPDR register. When you place a full byte of data in the SPDR register, it travels to the SPI device and pushes the data out of the SPI device and into the SPDR register.
   </p>
   <p class="calibre8">
    This means that when you need a byte of data from the SPI device, you need to send a byte of data to that device to “push” the data from the SPI device back to the SPDR register. You’ll see how this works in the
    <a class="url" href="nsp-boxall502581-0021.xhtml#pro48">
     following project
    </a>
    .
   </p>
   <p class="hd" id="pro48">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro48">
     <span class="ccust1">
      Project 48: Using the MCP3008 ADC IC
     </span>
    </a>
   </p>
   <p class="paft">
    Back in
    <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
     Chapter 3
    </a>
    , you started to learn how to use the AVRs’ built-in ADC pins to measure connected voltages from external devices such as potentiometers and temperature sensors. However, if you want to use more ADCs, you may have a conflict with the usage of the ADC pins and other uses—that is, you may have already planned to use the pins on the microcontroller that can be used for ADCs for another purpose. An alternative is to use an external ADC IC like the Microchip MCP3008 8-channel ADC IC shown in
    <a class="url" href="nsp-boxall502581-0021.xhtml#f11020">
     Figure 11-20
    </a>
    , which has eight ADC pins.
   </p>
   <div class="figure" id="f11020">
    <p class="fig">
     <img alt="Photo of an MCP3008 8-channel ADC IC" height="917" src="images/nsp-boxall502581-f11020.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 11-20:
      </span>
      Microchip MCP3008 8-channel ADC IC
     </p>
    </div>
   </div>
   <p class="calibre8">
    Each of these eight pins can measure between 0 V and 5 V DC, and each returns a 10-bit value for measurement. The MCP3008 is easy to use, since it’s connected to the SPI bus, and you don’t need to worry about any other non-SPI bus AVR registers for setup or control. See the schematic in
    <a class="url" href="nsp-boxall502581-0021.xhtml#f11021">
     Figure 11-21
    </a>
    .
   </p>
   <div class="figure" id="f11021">
    <p class="fig">
     <span id="p241">
     </span>
     <img alt="Schematic symbol for the MCP3008" height="1200" src="images/nsp-boxall502581-f11021.jpg" width="1051" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 11-21:
      </span>
      MCP3008 schematic symbol
     </p>
    </div>
   </div>
   <p class="calibre8">
    To connect the ATmega328P-PU to the MCP3008, follow the guidelines in
    <a class="url" href="nsp-boxall502581-0021.xhtml#tab1103">
     Table 11-3
    </a>
    .
   </p>
   <table id="tab1103" class="calibre13">
    <thead class="calibre14">
     <tr class="calibre15">
      <th colspan="2" class="calibre16">
       <p class="th1">
        <span class="calibre4">
         Table 11-3
        </span>
        : ATmega328P-PU to MCP3008 Connections
       </p>
      </th>
     </tr>
     <tr class="calibre15">
      <th scope="col" class="calibre16">
       <p class="tch">
        ATmega328P-PU
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        MCP3008
       </p>
      </th>
     </tr>
    </thead>
    <tbody class="calibre17">
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        V
        <sub class="calibre28">
         DD
        </sub>
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        5 V
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        V
        <sub class="calibre28">
         REF
        </sub>
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        GND
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        DGND, AGND
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        15
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        SS
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        17
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        D
        <sub class="calibre28">
         IN
        </sub>
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        18
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        D
        <sub class="calibre28">
         OUT
        </sub>
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        19
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        CLK
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="calibre8">
    There are also some extra pins on the MCP3008 to consider. The first is the V
    <sub class="calibre28">
     REF
    </sub>
    , for voltage reference. Our ADC measures analog signals with a 10-bit resolution that represents the signal with a number between 0 and 1,023. In our projects we’ll connect the V
    <sub class="calibre28">
     REF
    </sub>
    pin to the 5 V power supply, which gives our ADC a
    <i class="calibre5">
     reference voltage
    </i>
    —the upper limit (where the lower is zero) to the signals being measured.
   </p>
   <p class="calibre8">
    Later, you may wish to measure signals between (for example) 0 and 3 V DC. You can then connect the V
    <sub class="calibre28">
     REF
    </sub>
    pin to a 3 V signal. In that case, the reading would be more accurate, since the 1,023 possible values would cover between 0 V and 3 V, rather than spreading farther out over 0 V and 5 V.
   </p>
   <p class="calibre8">
    The other eight pins are for ADC channels 0 to 7 and can be connected to signals up to 5 V DC. Do not exceed 5 V, as doing so will damage the IC. The negative or GND connections for the signals being measured connect to the AGND pin on the IC.
   </p>
   <p class="calibre8">
    <span id="p242">
    </span>
    In this project, you’ll use the MCP3008 to measure signals with one ADC, then display the value on our MAX7219 module from
    <a class="url" href="nsp-boxall502581-0021.xhtml#pro48">
     Project 48
    </a>
    . In addition to familiarizing you with the MCP3008, this project serves as a great example of using two SPI bus devices with the same microcontroller.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1310">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1310">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • Microchip MCP3008 IC
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • MAX7219 eight-digit module
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11022">
      Figure 11-22
     </a>
     . Along with following the schematic, connect your display module as shown in
     <a class="url" href="nsp-boxall502581-0021.xhtml#tab1102">
      Table 11-2
     </a>
     .
    </p>
    <div class="figure" id="f11022">
     <p class="fig">
      <img alt="Schematic diagram for Project 48" height="1019" src="images/nsp-boxall502581-f11022.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-22:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0021.xhtml#pro48">
        Project 48
       </a>
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1311">
     <span class="page" id="p243">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1311">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 48
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 11
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     to compile and upload the data as usual. Since nothing is currently connected to input, we say the ADC has a
     <i class="calibre5">
      floating input
     </i>
     . This means the value returned is somewhat random, and the display should show random numbers.
    </p>
    <p class="calibre8">
     Now connect something with an output between 0 V and 5 V DC, such as a AA battery or your TMP36 temperature sensor from previous projects, to the Signal+/–connections. Be sure to connect the positive of the signal or battery to the Signal+ pin on the ADC (pin 1) and the negative to GND (also marked as Signal– in the schematic). The display should now show the number of millivolts measured by the ADC (1 volt equals 1,000 millivolts). If you don’t have a battery or sensor or anything else to measure, simply connect the ADC input to the 5 V or GND line and see how close it is to 5 V or 0 V, respectively.
    </p>
    <p class="calibre8">
     As with all SPI devices, we determine the parameters for SPI bus setup from the SPCR register.
     <a class="url" href="nsp-boxall502581-0021.xhtml#f11023">
      Figure 11-23
     </a>
     shows the timing diagram from the MCP3008’s data sheet (available at
     <a class="url-i" href="https://www.microchip.com/wwwproducts/en/MCP3008/">
      https://www.microchip.com/wwwproducts/en/MCP3008/
     </a>
     ).
    </p>
    <div class="figure" id="f11023">
     <p class="fig">
      <img alt="SPI bus timing diagram for the MCP3008" height="1030" src="images/nsp-boxall502581-f11023.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 11-23:
       </span>
       Timing diagram for MCP3008
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p244">
     </span>
     We can see that we should set the DORD bit to 0, as the MCP3008 requires data to be sent LSB first. We’ll set the CPOL and CPHA bits to 0 as well, since the clock signal is low at the start of data transmission and the polarity of the clock signal is low at idle.
    </p>
    <p class="calibre8">
     Now we need to learn how the MCP3008 is controlled. We’ll be using it in its simplest form, that of a single-ended ADC (so simply measuring between 0 V and V
     <sub class="calibre28">
      REF
     </sub>
     , in our case 5 V). Every time we want to use the MCP3008, we set the SPCR register to
     <code class="calibre23">
      0b01010010
     </code>
     . (If you’re using multiple SPI devices, you will need to set SPCR before communicating with each device.)
    </p>
    <p class="calibre8">
     Next, we send three bytes of data to the MCP3008 so it will return the required ADC value to the microcontroller over two bytes. We first place
     <code class="calibre23">
      0b00000001
     </code>
     into SPDR as the “start bit” to activate the MCP3008. Next, we place a configuration data byte into SPDR. The first bit is 1 for a single-ended ADC, then the next three bits represent, in binary, which ADC to use (0 to 7). As we’re using ADC 0, we set these three bits to 0. The last four bits are unused, so we leave them as 0.
    </p>
    <p class="calibre8">
     Once we’ve sent the configuration byte to the MCP3008, it returns a byte of data representing the most significant two bits of the ADC result (bits 0 and 1 of the byte). As mentioned previously, data moves circularly through the SPI bus, so the byte from the MCP3008 is found in the SPDR register. To capture this byte of data, we “push” it out by placing an integer variable in SPDR. The remaining six bits of the byte will contain random data, so to set them to 0 we use the bitwise operation
     <code class="calibre23">
      &amp;
     </code>
     on the captured byte.
    </p>
    <p class="calibre8">
     Finally, we need the last eight bits of the ADC result, so we push a random byte of data (all 0s is fine) down the SPI bus to receive the byte from the ADC by placing 0 in SPDR. After waiting for the transmission to complete, we then equate another integer variable to SPDR, which now contains the rest of the ADC data.
    </p>
    <p class="calibre8">
     Now that we have 2 bytes of data, one containing the top 2 bits (the MSB) and the other containing the other 8 bits of data (the LSB), we need to convert them into a single value: a 16-bit integer, which we’ll call the
     <i class="calibre5">
      result
     </i>
     . For this, we bit-shift the MSB variable 8 bits to the left into the result integer, then use bitwise operation
     <code class="calibre23">
      |
     </code>
     to drop the LSB variable into the result. At last, we have the 10-bit value of the ADC in one integer variable, which will be between 0 and 1,023.
    </p>
    <p class="calibre8">
     Let’s examine the code to see how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 48 - Using the MCP3008 ADC IC
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      void writeMAX7219(char hexdata1, char hexdata2)
     </p>
     <p class="cl">
      // Sends two bytes in hexadecimal to MAX7219
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      SPCR = 0b01010000;             // Set up SPI bus for MAX7219
     </p>
     <p class="cl">
      PORTB &amp;= ~(1 &lt;&lt; PORTB0);       // SS pin LOW
     </p>
     <p class="cl">
      SPDR = hexdata1;               // Send value of hexdata1
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF)));    // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      <span id="p245">
      </span>
      SPDR = hexdata2;               // Send value of hexdata2
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF)));    // Wait for SPI transmission to finish
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; PORTB0);        // SS pin HIGH
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void blankMAX7219()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="cl">
      for (i=1; i&lt;9; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      writeMAX7219(i,15);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initMAX7219()
     </p>
     <p class="cl">
      // Set up MAX7219 for use
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB |= (1 &lt;&lt; 0);
     </p>
     <p class="cl">
      SPCR = 0b01010000;
     </p>
     <p class="cl">
      writeMAX7219(0x09,0xFF);
     </p>
     <p class="cl">
      writeMAX7219(0x0B,0x07);
     </p>
     <p class="cl">
      writeMAX7219(0x0A,0x01);
     </p>
     <p class="cl">
      writeMAX7219(0x0C,0x01);
     </p>
     <p class="cl">
      blankMAX7219();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void dispMAX7219(uint8_t digit, uint8_t number, uint8_t dp)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      if (dp==1)                     // Add decimal point
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      number = number + 128;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      writeMAX7219(digit, number);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void numberMAX7219(uint32_t value)
     </p>
     <p class="cl">
      // Displays a number between 0–99999999
     </p>
     <p class="clf">
      uint8_t digits[9];
     </p>
     <p class="cl">
      uint8_t i = 1;
     </p>
     <p class="clf">
      for (i=1; i&lt;9; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      digits[i]=15;              // Sending 15 blanks the digit
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      i = 1;
     </p>
     <p class="cl">
      while (value &gt; 0)             // Continue until value &gt; 0
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      digits[i] = value % 10;    // Determine and store last digit
     </p>
     <p class="cl">
      value = value / 10;        // Divide value by 10
     </p>
     <p class="cl">
      i++;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      for (i=1; i&lt;9; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      dispMAX7219(i, digits[i],0);
     </p>
     <p class="cl">
      <span id="p246">
      </span>
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ uint16_t readMCP3008()
     </p>
     <p class="cl">
      // Read channel 0 and return value
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ uint8_t LSB;
     </p>
     <p class="cl">
      uint8_t MSB;
     </p>
     <p class="cl">
      uint16_t ADCvalue;            // Holds data to return to main code
     </p>
     <p class="cl">
      SPCR = 0b01010010;            // Set up SPI bus for MCP3008
     </p>
     <p class="clf">
      // SS on PB1 (15)
     </p>
     <p class="cl">
      PORTB &amp;= ~(1 &lt;&lt; PORTB1);      // SS pin LOW
     </p>
     <p class="clf">
      <!--<ccust1>3</ccust1>-->
      ❸ SPDR = 0b00000001;            // Send start bit
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF)));   // Wait for SPI transmission to finish
     </p>
     <p class="clf">
      SPDR = 0b10000000;            // Select ADC0
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF)));
     </p>
     <p class="clf">
      // Place top 2 bits of ADC value in MSB, ignore unwanted bits
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ MSB = SPDR &amp; 0b00000011;
     </p>
     <p class="clf">
      <!--<ccust1>5</ccust1>-->
      ❺ SPDR = 0b00000000;            // Request next 8 bits of data
     </p>
     <p class="cl">
      while(!(SPSR &amp; (1&lt;&lt;SPIF)));
     </p>
     <p class="cl">
      // Place lower 8 bits of data in LSB
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ LSB = SPDR;
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ PORTB |= (1 &lt;&lt; PORTB1);       // SS pin HIGH
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ ADCvalue = MSB &lt;&lt; 8 | LSB;    // Construct final 10-bit ADC value
     </p>
     <p class="cl">
      return ADCvalue;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint16_t ADCoutput;
     </p>
     <p class="cl">
      DDRB = 0b11111111;            // Set PORTB as outputs
     </p>
     <p class="cl">
      initMAX7219();
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>9</ccust1>-->
      ❾ ADCoutput = readMCP3008();
     </p>
     <p class="cl">
      // Convert ADC value to millivolts
     </p>
     <p class="cl">
      <!--<ccust1>0</ccust1>-->
      ⓿ ADCoutput = ADCoutput * 4.8828;
     </p>
     <p class="cl">
      numberMAX7219(ADCoutput);
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     In this code, we have reused all the MAX7219 functions from
     <a class="url" href="nsp-boxall502581-0021.xhtml#pro48">
      Project 48
     </a>
     to display the ADC value in millivolts. Our main code receives an ADC value, converts it to millivolts, then shows it on the MAX7219 display. You should be familiar with the basic structure by now.
    </p>
    <p class="calibre8">
     We also declare a new function,
     <code class="calibre23">
      readMCP3008()
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶, that returns a 16-bit integer containing the value measured by the MCP3008’s first ADC (0). Inside the function we define three variables—two 8-bit integers to hold
     <span id="p247">
     </span>
     the MSB and LSB of the data that the ADC returns and a 16-bit integer to return the full value of the ADC measurement—and set the
     <code class="calibre23">
      SPCR
     </code>
     register for the MCP3008
     <!--<ccust1>2</ccust1>-->
     ❷. We then set the SS pin low to start the SPI bus as usual.
    </p>
    <p class="calibre8">
     After sending the start bit to activate the MCP3008
     <!--<ccust1>3</ccust1>-->
     ❸, we wait for the SPI bus transmission to be completed, as always. Following this, we send the configuration byte, telling the MCP3008 we want a single-ended ADC result from channel 0. Once we’ve done so, the MCP3008 returns the MSB of the result.
    </p>
    <p class="calibre8">
     We store the MSB in the variable
     <code class="calibre23">
      MSB
     </code>
     <!--<ccust1>4</ccust1>-->
     ❹ and perform the bitwise
     <code class="calibre23">
      &amp;
     </code>
     to remove the random unnecessary bits. Then we request the LSB of the data by sending a random byte (here, all 0s)
     <!--<ccust1>5</ccust1>-->
     ❺, wait for the transmission to end, and store the data in
     <code class="calibre23">
      LSB
     </code>
     <!--<ccust1>6</ccust1>-->
     ❻. After this, we’re finished with the MCP3008, so we remove it from the SPI bus by setting the SS pin high
     <!--<ccust1>7</ccust1>-->
     ❼.
    </p>
    <p class="calibre8">
     We now have the two bytes of data that need to be converted to a single integer for return as the value of this function. We do this by shifting the MSB into the top eight bits of the return variable
     <code class="calibre23">
      ADCvalue
     </code>
     and dropping in the LSB with the
     <code class="calibre23">
      |
     </code>
     function
     <!--<ccust1>8</ccust1>-->
     ❽.
    </p>
    <p class="calibre8">
     Now that we have a value from the ADC, we move on to the main loop of code, assigning the reading from the ADC to a 16-bit integer
     <!--<ccust1>9</ccust1>-->
     ❾. However, this value falls between 0 and 1,023, so we need to convert it to millivolts (mV). Our V
     <sub class="calibre28">
      REF
     </sub>
     is 5 V, or 5,000 mV. Therefore, we divide 5,000 by 1,024 to determine the multiplier to convert this ADC value to mV: 4.8828. The program then converts the ADC value to millivolts
     <!--<ccust1>0</ccust1>-->
     ⓿ and sends it to the display.
    </p>
    <p class="calibre8">
     At this point you should understand how to implement the SPI bus, including how to examine SPI device data sheets to locate the information required to use them with your AVR. You’ve also learned how to take advantage of the useful shift register IC, the MAX7219 display driver, and the MCP3008 ADC. This knowledge should prepare you to use other SPI-based parts for your own projects.
    </p>
    <p class="calibre8">
     In the
     <a class="url" href="nsp-boxall502581-0022.xhtml#ch12">
      next chapter
     </a>
     , you’ll learn how to use many more interesting and useful parts with another type of data bus: the I
     <sup class="calibre6">
      2
     </sup>
     C.
    </p>
   </div>
  </div>
 </div>
</div></body></html>