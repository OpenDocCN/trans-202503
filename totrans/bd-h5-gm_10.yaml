- en: Chapter 8. Next Steps in HTML5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章：HTML5 的下一步
- en: In addition to graphical advances, HTML5 has a host of other features that make
    it a powerful game development environment. In this chapter, I’ll discuss a few
    of them so you’re aware of what features are available, and I’ll point you to
    some useful resources for further reading. Some of these features, such as WebGL,
    are subjects worthy of their own books, whereas others will be useful only for
    certain types of games. For these reasons, I’ll only introduce the concepts here
    and leave more thorough exploration up to you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图形方面的进步外，HTML5 还有许多其他特性，使其成为一个强大的游戏开发环境。在本章中，我将讨论其中的一些特性，帮助你了解可用的功能，并为进一步阅读提供一些有用的资源。其中一些特性，例如
    WebGL，是值得单独成书的主题，而另一些则只对某些类型的游戏有用。因此，我这里只介绍这些概念，具体的深入探索留给你自己去做。
- en: Saving and Retrieving Data
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和检索数据
- en: People play games like *Bubble Shooter* in short sessions with little or no
    persistent data; in fact, our game saves only the high score from one session
    to the next. At present, the high score is stored in Web Storage, so it’s unique
    to the browser the game is played on. To save a global high score and display
    a high score table, we’d need to write a server-side component that sends the
    score to a server and retrieves a list of high scores.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 人们像玩 *Bubble Shooter* 这样的游戏时，通常是在短时间内进行的，并且几乎没有或没有持久数据；实际上，我们的游戏只保存从一次会话到下一次会话的最高分。目前，最高分是存储在
    Web Storage 中，因此它对游戏所在的浏览器是唯一的。为了保存一个全局的最高分并显示最高分表，我们需要编写一个服务器端组件，将分数发送到服务器并检索一个最高分列表。
- en: 'Games with more complex states should have server-side access, too. When you
    store state on the server, players can return to the same game from multiple devices.
    For our purposes, we’ll use two main ways to save and retrieve data on a server:
    AJAX and WebSockets.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂状态的游戏也应该有服务器端访问。当你将状态存储在服务器上时，玩家可以从多个设备返回到相同的游戏。为了我们的目的，我们将使用两种主要方式在服务器上保存和检索数据：AJAX
    和 WebSockets。
- en: AJAX
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AJAX
- en: '*AJAX (Asynchronous JavaScript and XML)* provides a technique for sending a
    request to a server and receiving a response. AJAX is not a single technology
    but rather a method by which a number of tried-and-tested browser features are
    combined to make server-side calls and manage the responses. All of the major
    browsers have supported AJAX for a number of years.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*AJAX（异步 JavaScript 和 XML）* 提供了一种向服务器发送请求并接收响应的技术。AJAX 不是单一的技术，而是一种将多种经过验证的浏览器功能结合起来，以进行服务器端调用和管理响应的方法。所有主流浏览器已经支持
    AJAX 多年。'
- en: 'Although the *X* stands for XML, you can use AJAX to retrieve HTML data, string
    data, and JSON strings that can be parsed and interpreted. The code for making
    AJAX calls is well documented, and multiple libraries are available so you don’t
    have to handcraft the calls. For example, here’s how you’d send an AJAX request
    to a server with the `$.ajax` call in jQuery:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *X* 代表 XML，但你可以使用 AJAX 检索 HTML 数据、字符串数据和可以解析和解释的 JSON 字符串。AJAX 调用的代码有详细的文档，并且有多个库可以使用，因此你不必手动编写调用代码。例如，以下是如何使用
    jQuery 中的 `$.ajax` 调用向服务器发送 AJAX 请求的方式：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `$.ajax` call makes a `POST` request to the relative URL *save_data.php*,
    sends the value contained in `highScore` to the server under the name `high_score`,
    and logs the server’s response to the console. I set the URL target for the request
    ➊, the data to send ➋, the type of request ➌, and a function to run after the
    request completes ➍, but you can set many other properties, including functions
    to run in case of an error, timeout settings, and so on. These are listed in the
    jQuery documentation at *[http://api.jquery.com/](http://api.jquery.com/)*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `$.ajax` 调用向相对 URL *save_data.php* 发起一个 `POST` 请求，将 `highScore` 中的值以 `high_score`
    为名称发送到服务器，并将服务器的响应记录到控制台。我设置了请求的目标 URL ➊，发送的数据 ➋，请求类型 ➌，以及请求完成后运行的函数 ➍，但你可以设置许多其他属性，包括在出现错误时运行的函数、超时设置等。这些属性在
    jQuery 文档中的 *[http://api.jquery.com/](http://api.jquery.com/)* 有列出。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* A *in AJAX stands for* asynchronous*, because other JavaScript operations
    will continue while the server deals with the data and sends the response. That
    means you can’t be sure when the `complete` function will run: it’ll happen whenever
    the response comes back, but the user interface will remain responsive while it
    happens. It’s possible to make synchronous calls, but because this effectively
    freezes the entire page until the request is complete, the user experience is
    generally so poor that doing so is considered bad practice.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most modern browsers also have WebSockets available to make client to server
    calls. WebSockets are a relatively new technology incorporated into the HTML5
    specification. If you want to learn how they work at a lower level than I describe
    here, a good place to start is with the Mozilla Developer Network documentation
    at *[https://developer.mozilla.org/en/docs/WebSockets/](https://developer.mozilla.org/en/docs/WebSockets/)*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets are similar to AJAX, but whereas AJAX sets up a call-and-response
    relationship between the client and server, a WebSocket maintains a persistent
    connection between them. The client deals with responses as they come in, and
    the JavaScript code can listen continuously for further responses. The server
    also constantly listens while the socket is open; therefore, WebSockets are much
    better than AJAX when conversations between the client and server involve lots
    of small data transactions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A persistent connection is especially useful in multiplayer gaming environments.
    Before WebSockets, the main way to update game state elements shared by multiple
    clients, such as player avatars within an environment, was to continuously poll
    the server with AJAX and check for updates. This would be coded to happen every
    few seconds, which obviously isn’t sufficient for a real-time game. People tried
    various hacks—such as a technique called *long-polling*, which effectively tricks
    the client into maintaining a connection to the server—to improve the process,
    but these were often inefficient in terms of server resources. Now, you can just
    leave a WebSocket open, and whenever one client updates the game state, the server
    can immediately update all of the other clients’ information without waiting for
    the next update cycle.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Mainstream browsers have ever-improving support for WebSockets, and as with
    AJAX, I recommend using a library to eliminate some of the nitty-gritty of opening
    connections, sending and listening for data, and handling errors. Libraries will
    also often have a fallback to AJAX or other server communication methods for cases
    in which WebSockets aren’t supported; however, the fallbacks may not replicate
    the performance features that you’re using WebSockets for in the first place,
    so be aware that they’re not a magic solution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Socket.IO (*[http://socket.io/](http://socket.io/)*) is one of the most popular
    WebSocket libraries. Here’s how you can use it to make a call:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code uses a call to the library with `io.connect` to open a new WebSocket
    and then `socket.emit` sends the `highScore` value as an event named `new_high_score`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 `io.connect` 调用库打开一个新的 WebSocket，然后 `socket.emit` 将 `highScore` 值作为名为
    `new_high_score` 的事件发送。
- en: WebSockets and libraries such as Socket.IO have much greater capabilities than
    AJAX, but the libraries that make them easy to use often assume a specific server-side
    environment. If you plan to use WebSockets, check that the library you plan to
    use has a backend component that matches your server environment. Libraries for
    most platforms are readily available, whether you’re using Node.js, .NET, or Java.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 和像 Socket.IO 这样的库比 AJAX 更具功能性，但使它们易于使用的库通常假设一个特定的服务器端环境。如果你打算使用 WebSocket，检查你计划使用的库是否有与你的服务器环境匹配的后端组件。大多数平台的库都可以轻松找到，无论你使用的是
    Node.js、.NET 还是 Java。
- en: Along with sending and receiving data to and from the server, you might also
    want to process certain data outside your main game program. That’s where Web
    Workers will come in handy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与服务器发送和接收数据外，你可能还想在主游戏程序之外处理某些数据。这时，Web Worker 将会派上用场。
- en: Web Workers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web Worker
- en: JavaScript in a browser is generally considered a *single-threaded* environment,
    meaning that only one script can run at a time. This won’t cause problems most
    of the time but can be an issue if a particularly large computational process
    blocks the processor from animating, responding to user input, and performing
    other important tasks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的 JavaScript 通常被认为是 *单线程* 环境，这意味着一次只能运行一个脚本。大多数时候这不会引起问题，但如果一个特别大的计算过程阻塞了处理器，导致动画无法播放、用户输入无法响应以及其他重要任务无法执行时，就可能成为问题。
- en: For example, let’s say processing game-level data takes the browser 1 or 2 seconds,
    and this happens every 30 seconds or so. The overall load may not be high, but
    you can’t pause the game every 30 seconds! In this situation, consider using a
    Web Worker.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设处理游戏级别数据需要浏览器花费 1 到 2 秒，每隔大约 30 秒就会发生一次。整体负载可能不高，但你不能每隔 30 秒就暂停游戏！在这种情况下，可以考虑使用
    Web Worker。
- en: Web Workers (*[https://developer.mozilla.org/en/docs/Web/API/Worker/](https://developer.mozilla.org/en/docs/Web/API/Worker/)*)
    allow you to run code in a separate thread without blocking your main JavaScript
    operations. They’re called “workers” because you can essentially hand them a task
    and tell them to report back when they’re finished. The browser will determine
    how much CPU time to give them so as not to interfere unduly with other processes.
    Workers can be dedicated or shared, but you’ll generally find dedicated workers
    most useful, especially while support for Web Workers is being developed across
    browsers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Web Worker (*[https://developer.mozilla.org/en/docs/Web/API/Worker/](https://developer.mozilla.org/en/docs/Web/API/Worker/)*）允许你在独立的线程中运行代码，而不会阻塞你的主
    JavaScript 操作。它们之所以被称为“Worker”，是因为你基本上可以把一个任务交给它们，让它们在完成后报告结果。浏览器将决定给它们多少 CPU
    时间，以避免对其他进程造成不必要的干扰。Worker 可以是专用的或共享的，但通常你会发现专用的 Worker 更加有用，尤其是在 Web Worker 跨浏览器支持逐步完善的过程中。
- en: Web Workers follow a couple of rules that differentiate them from regular JavaScript.
    Most important, they have no access to the DOM, the browser document, or the browser
    window. Workers also operate within their own scope, so you’ll need to pass data
    explicitly and then retrieve the result when complete. I’ll illustrate how they
    work with the following example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Web Worker 有几个规则，使它们与常规 JavaScript 区别开来。最重要的是，它们无法访问 DOM、浏览器文档或浏览器窗口。Worker
    也在自己的作用域内运行，因此你需要显式传递数据，然后在完成时获取结果。我将通过以下示例来说明它们是如何工作的。
- en: 'Workers are initialized by passing the name of a script to load to the `new
    Worker` command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Worker 通过将要加载的脚本名称传递给 `new Worker` 命令来初始化：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will start a new worker, and that worker will run the script inside *work.js*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个新的 Worker，Worker 将在 *work.js* 中运行脚本。
- en: 'A worker runs when you send it a message via `postMessage`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过 `postMessage` 发送消息时，Worker 会开始运行：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `postMessage` command can contain a JavaScript object or be empty.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`postMessage` 命令可以包含一个 JavaScript 对象，也可以为空。'
- en: 'You can handle responses—values a worker returns when it completes a task—by
    adding event listeners to the worker within the calling script:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向调用脚本中的 Worker 添加事件监听器来处理响应——当 Worker 完成任务时返回的值：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `e` contains the data that `worker` sent back. The event to listen to,
    labeled `"message"`, is any valid string. Therefore, a `worker` could send back
    different responses in different circumstances, or it could just keep working
    and sending messages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`e` 包含了 `worker` 返回的数据。需要监听的事件是标记为 `"message"` 的任何有效字符串。因此，`worker` 可以根据不同的情况发送不同的响应，或者它可以继续工作并发送消息。
- en: 'Inside the worker, the model of event listeners is similar, with the `worker`
    referring to itself as `this` or `self`. As an example, *work.js* could contain
    the following to return the message:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 worker 内部，事件监听器的模型类似，`worker` 自我指代为 `this` 或 `self`。举个例子，*work.js* 可能包含如下内容来返回消息：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code listens for an event marked `"message"`, and on receipt, it immediately
    posts a response in the form of an object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码监听标记为 `"message"` 的事件，并在收到事件后立即以对象的形式发布响应。
- en: At present, not all the major browsers support Web Workers well enough to make
    it reliable. Polyfills do exist for Web Workers, but these will often negatively
    affect your user’s experience if a long-running process that you assumed would
    be nonblocking suddenly freezes the game for a few seconds. However, the situation
    is constantly improving, and hopefully, Web Workers will soon be considered a
    core part of the HTML5 game developer’s arsenal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，并非所有主流浏览器都足够好地支持 Web Workers 以使其可靠。确实存在 Web Workers 的 Polyfills，但如果一个原本认为是非阻塞的长期运行过程突然使游戏冻结几秒钟，这些
    Polyfills 往往会对用户体验产生负面影响。然而，情况正在不断改善，希望 Web Workers 很快会成为 HTML5 游戏开发者工具箱的核心部分。
- en: But managing your data more effectively is just a start to making your game
    more fun. Appearance matters, too, and for a graphics upgrade, you can go 3D with
    WebGL or even use it to beef up your rendering power for 2D games.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 更有效地管理你的数据只是让游戏更有趣的开始。外观也很重要，若要进行图形升级，你可以使用 WebGL 实现 3D，或者甚至利用它提升 2D 游戏的渲染能力。
- en: WebGL
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL
- en: For the canvas version of *Bubble Shooter*, we used the 2D rendering context,
    accessed with calls along the lines of
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *Bubble Shooter* 的 canvas 版本，我们使用了 2D 渲染上下文，通过类似以下的调用方式来访问：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As I touched upon in [Chapter 6](ch06.html "Chapter 6. Rendering Canvas Sprites"),
    the specification of `"2d"` implies that other options are available, and sometimes,
    depending on browser support, that’s true. The third dimension is accessed through
    WebGL, an API that provides a set of 3D manipulation functions for creating scenes,
    adding lighting and textures, positioning cameras, and so on, taking advantage
    of the acceleration that modern graphics cards provide. (Visit *[https://www.khronos.org/registry/webgl/specs/1.0/](https://www.khronos.org/registry/webgl/specs/1.0/)*
    to learn about WebGL in more detail.) To start using WebGL, we first instantiate
    a 3D context with the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第6章](ch06.html "第6章 渲染 Canvas 精灵")中提到的，`"2d"`的规范意味着还可以使用其他选项，有时根据浏览器支持情况，确实如此。第三维度通过
    WebGL 访问，WebGL 是一个 API，提供了一组 3D 操作函数，用于创建场景、添加光照和纹理、定位相机等，利用现代显卡提供的加速功能。（访问 *[https://www.khronos.org/registry/webgl/specs/1.0/](https://www.khronos.org/registry/webgl/specs/1.0/)*
    了解更多关于 WebGL 的详细信息。）要开始使用 WebGL，我们首先通过以下方式实例化一个 3D 上下文：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is sometimes retrieved as `"experimental-webgl"`, so the most compatible
    call is this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时会以 `"experimental-webgl"` 的形式返回，因此最兼容的调用是：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Accelerated WebGL is powerful enough to display fully rendered 3D scenes rivaling
    those of native games. The downside is that working in three dimensions and manipulating
    and creating scenes requires a lot of math and a lot of low-level code that involves
    writing programs directly to the graphics processor. The concepts are the same
    as when creating 3D games in native code, such as C++, and require low-level knowledge
    of 3D modeling to describe the shape of an object; textures to define surface
    patterns; and shaders, which describe how to render a surface when light hits
    it. As such, I highly recommend working with existing libraries to handle model
    rendering, any physics requirements, and basically any features you can get off
    the shelf. Babylon.js (*[http://www.babylonjs.com/](http://www.babylonjs.com/)*)
    and PlayCanvas (*[https://playcanvas.com/](https://playcanvas.com/)*) are two
    libraries that make working with WebGL in the browser much simpler.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Using WebGL also brings up the question of how to import objects and textures
    into 3D scenes. Typically, you create models in modeling software, such as 3D
    Studio or Maya, and then export to a commonly supported format. WebGL libraries
    generally won’t work with those formats, so you’ll usually need to convert from
    the original 3D modeling file format to JSON using another set of tools, such
    as the 3DS Max-to-Babylon.js exporter (*[https://github.com/BabylonJS/Babylon.js/tree/master/Exporters/3ds%20Max](https://github.com/BabylonJS/Babylon.js/tree/master/Exporters/3ds%20Max)*),
    which exports from Autodesk’s 3D Studio product into Babylon.js.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Creating and converting 3D models is a large enough task that WebGL game development
    quickly becomes a project for teams of developers and designers rather than for
    a sole developer; however, many very impressive demos have been made entirely
    solo, and the Babylon.js website has a great set of showcases.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: A secondary advantage of the WebGL context is that you can use it to render
    2D scenes, which can then take advantage of the huge speed available through GPU
    acceleration. Particle effects and rendering large numbers of onscreen elements
    in accelerated WebGL far outperform the same tasks in the canvas.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you look for off-the-shelf libraries that enable 2D rendering
    in WebGL. One such library is Pixi.js (*[http://www.pixijs.com/](http://www.pixijs.com/)*),
    which also provides a fallback to the canvas.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Browser support for WebGL is growing and includes the latest versions of Chrome,
    Firefox, and Internet Explorer, although older versions of Internet Explorer are
    incompatible at the time of this writing. For this reason, WebGL isn’t considered
    ready for mass-market development, but this situation continues to improve.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Building a slick game is all well and good, but a game is nothing without players.
    To reach players, you need to deploy your game somewhere publicly accessible.
    Depending on where you deploy, you should consider some changes to improve the
    player’s experience.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一款精美的游戏固然很好，但没有玩家，游戏就没有意义。要让玩家访问，你需要将游戏部署到一个公开可访问的地方。根据部署的位置，你应该考虑做出一些改变，以提升玩家的体验。
- en: Deploying HTML5 Games
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 HTML5 游戏
- en: In this section, I’ll give a brief overview of the process behind deploying
    a game running inside desktop and mobile browsers, and I’ll explain how you’d
    wrap up an HTML5 application as a native mobile application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将简要概述在桌面和移动浏览器中运行游戏的部署过程，并解释如何将 HTML5 应用程序封装为本地移动应用程序。
- en: Running Fullscreen in a Desktop Browser
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在桌面浏览器中运行全屏
- en: 'One way to deploy an HTML5 game is to just create a website and upload it.
    In fact, just upload *Bubble Shooter* to the Web to make it accessible to anyone
    who accesses the *index.html* file. Deploying an HTML5 game to the Web is no different
    from deploying any other website; however, players often complain about a lack
    of immersion when they are running games in a browser, because it’s easy to become
    distracted by tabs showing notifications from Facebook, email, instant messages,
    and so on. The HTML5 arsenal has a trick to fix these interruptions: the Fullscreen
    API.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 HTML5 游戏的一种方式是创建一个网站并上传它。事实上，只需将*泡泡射手*上传到 Web，就能让任何访问 *index.html* 文件的人都能玩这个游戏。将
    HTML5 游戏部署到 Web 与部署任何其他网站没有什么不同；然而，玩家常常抱怨在浏览器中玩游戏时缺乏沉浸感，因为很容易被显示 Facebook、电子邮件、即时消息等通知的标签页所打扰。HTML5
    提供了一个解决这些中断的技巧：全屏 API。
- en: Where supported, the Fullscreen API lets a web page fill the entire width and
    height of the screen, removing the address bar and other browser frame elements.
    You can implement fullscreen capabilities by running the following JavaScript
    code. For security reasons, you need to run this code inside a user-generated
    event handler; that is, you will usually make a button for the player to click
    or specify a key for them to press to activate fullscreen mode.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持的环境下，全屏 API 允许网页填满整个屏幕的宽度和高度，去除地址栏和其他浏览器框架元素。你可以通过运行以下 JavaScript 代码来实现全屏功能。出于安全原因，你需要在用户生成的事件处理程序内运行此代码；也就是说，通常你会为玩家创建一个按钮，或指定一个按键来激活全屏模式。
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the use of vendor prefixes while the `requestFullScreen` API is being implemented
    (`mozRequestFullScreen` for Firefox, `webkitRequestFullScreen` for Chrome, and
    so on). When you call `requestFullScreen`, the user should see a dialog from the
    browser asking whether to allow or deny your game’s request to go fullscreen.
    If the player allows fullscreen, pressing the ESC key should return them to the
    regular view.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在实现 `requestFullScreen` API 时使用了供应商前缀（Firefox 使用 `mozRequestFullScreen`，Chrome
    使用 `webkitRequestFullScreen`，等等）。当你调用 `requestFullScreen` 时，用户应该会看到浏览器弹出对话框，询问是否允许或拒绝游戏请求进入全屏。如果玩家允许全屏，按下
    ESC 键应该会将他们返回到常规视图。
- en: 'You can also apply fullscreen mode to a single element inside the DOM. You
    might want to do this if you have a game running within a website with navigation
    to other pages, for example. Then, players can go into fullscreen mode to remove
    the distractions of navigation bars and other page clutter. You could even apply
    fullscreen mode to *Bubble Shooter*. Just add a new toolbar button that runs the
    following code when a player clicks the button:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将全屏模式应用于 DOM 中的单个元素。如果你的网站中有运行中的游戏，并且包含导航到其他页面的功能，你可能想这样做。这样，玩家可以进入全屏模式，去除导航栏和其他页面杂物的干扰。你甚至可以将全屏模式应用于*泡泡射手*。只需添加一个新的工具栏按钮，当玩家点击该按钮时运行以下代码：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I’ll leave this as an exercise for you to implement, and I suggest you add it
    to *ui.js* to keep it with the other user interface code. But if you’d rather
    not deploy to your own website, try a hosting service. You could set up an application
    on Facebook or upload a game to a dedicated game website, such as Kongregate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这部分留给你自己实现，并建议你将其添加到*ui.js*中，以便与其他用户界面代码一起管理。但如果你不想将其部署到你自己的网站，可以尝试使用托管服务。你可以在
    Facebook 上设置一个应用程序，或者将游戏上传到专门的游戏网站，例如 Kongregate。
- en: Of course, the promise of cross-platform development and deployment is one of
    the biggest attractions of HTML5, and because most desktop browser features have
    been ported to mobile browsers, *Bubble Shooter* should work just as well on both.
    However, the behaviors aren’t quite identical between platforms, and I’ll discuss
    those differences next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，跨平台开发和部署的承诺是HTML5最吸引人的特点之一，而且因为大多数桌面浏览器的功能已经移植到移动浏览器，*泡泡射手*应该能够在两者上都顺利运行。然而，不同平台之间的行为并不完全相同，接下来我将讨论这些差异。
- en: Running in a Mobile Browser
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在移动浏览器中运行
- en: Even if you’re still running *Bubble Shooter* on a local or development web
    server, you should be able to load the game in a mobile browser and play it. It
    should function just as well as it does on a desktop browser. Congratulations,
    you’ve just made your first mobile game!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你仍然在本地或开发Web服务器上运行*泡泡射手*，你也应该能够在移动浏览器中加载并玩这个游戏。它的表现应该与在桌面浏览器上一样好。恭喜你，你刚刚制作了第一个移动游戏！
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In case you haven’t deployed the game yet, you can also play it at* [http://buildanhtml5game.com/bubbleshooter/](http://buildanhtml5game.com/bubbleshooter/)*.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你还没有发布游戏，你也可以在* [http://buildanhtml5game.com/bubbleshooter/](http://buildanhtml5game.com/bubbleshooter/)
    *上玩它。*'
- en: When developing games for mobile devices, it’s more likely you’ll need to make
    usability and interface changes than technical ones, but that’s not to say you
    can ignore implementation changes completely. You’ll benefit from knowing the
    subtle differences in behavior and how to optimize the experience for mobile users,
    so let’s get started.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在为移动设备开发游戏时，你更有可能需要做的是可用性和界面方面的调整，而不是技术上的修改，但这并不意味着你可以完全忽视实现上的变化。你将从了解这些细微的行为差异和如何优化移动用户体验中受益，所以让我们开始吧。
- en: Touch Events
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触摸事件
- en: First, touchscreen-specific events are implemented by browsers on touchscreen
    devices. Two of those events are `touchstart` and `touchend`, which are roughly
    equivalent to `mousedown` and `mouseup`, respectively. However, the `click` event
    differs slightly in a touchscreen environment. Mobile browsers wait a few hundred
    milliseconds to determine whether the user double-taps, which is a zoom operation,
    to make absolutely sure that the user intends a single `click`. This won’t make
    much difference in *Bubble Shooter*, but for rapid-reaction games, those few hundred
    milliseconds will be noticeable to the player.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，触摸屏设备上的浏览器实现了特定的触摸事件。这些事件中有两个是`touchstart`和`touchend`，它们大致等同于`mousedown`和`mouseup`。然而，`click`事件在触摸屏环境中略有不同。移动浏览器会等待几百毫秒，以确定用户是否进行双击（即放大操作），以确保用户确实打算进行单次`click`。在*泡泡射手*中，这不会有太大区别，但在快速反应类游戏中，这几百毫秒的延迟对于玩家来说是可以察觉的。
- en: 'You can use mobile-specific events, and they’ll be ignored on desktop devices
    without a touchscreen, although for the most part, using `mousedown` will have
    the same effect as `touchstart` and `mouseup` will be equivalent to `touchend`.
    For example, in *Bubble Shooter*, we could use `mousedown` instead of `click`
    to detect when the player wants to fire a bubble, which would turn this line from
    *game.js*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用移动设备特有的事件，这些事件在没有触摸屏的桌面设备上会被忽略，尽管大多数情况下，使用`mousedown`将与`touchstart`效果相同，`mouseup`则等同于`touchend`。例如，在*泡泡射手*中，我们可以使用`mousedown`代替`click`来检测玩家何时想要发射泡泡，这样会将*game.js*中的这一行变成：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'into this line of code instead:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 改为以下这行代码：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only effect would be that the bubble will fire when the user clicks the
    mouse button down or touches the screen rather than waiting for the mouse button
    to be released or the finger removed from the screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的效果是，玩家点击鼠标按钮或触摸屏幕时，泡泡会立即发射，而不是等待鼠标按钮释放或手指离开屏幕。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Using only the mouse and touch events will remove keyboard accessibility if
    you have a game that could conceivably be controlled by the keyboard. In some
    games, you might want to continue using the click event so a player could still,
    for example, navigate a menu system using the keyboard or other input device.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果只使用鼠标和触摸事件，将会移除键盘的可访问性，特别是如果你的游戏本来可以用键盘控制的话。在某些游戏中，你可能仍然希望使用点击事件，以便玩家仍然可以使用键盘或其他输入设备导航菜单系统。*'
- en: 'If you know that your game will be played only on a mobile device, you could
    also use `touchstart`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你的游戏只会在移动设备上玩，你也可以使用`touchstart`：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This should work the same way as `mousedown`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该与`mousedown`的效果相同。
- en: You may be wondering, then, why `touchstart` and `touchend` exist at all if
    they’re virtually equivalent to `mousedown` and `mouseup`. The answer is that
    in most cases you can treat them as conceptually equivalent, but touch events
    can be useful if you want to detect more than one touch point simultaneously.
    The user will (usually) have only one mouse pointer, but it’s possible to make
    contact with a touchscreen in multiple places. If you’re building a game that
    requires this kind of input, touch events are the ones to use, and you’ll have
    to find a way to make them work in a mouse environment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你可能会想，既然 `touchstart` 和 `touchend` 与 `mousedown` 和 `mouseup` 几乎等价，那它们存在的意义是什么？答案是，在大多数情况下，你可以将它们视为概念上的等价物，但触摸事件在你需要同时检测多个触摸点时非常有用。用户通常只有一个鼠标指针，但在触摸屏上，可以在多个位置进行触碰。如果你正在构建一个需要这种输入的游戏，触摸事件是你要使用的，而你也需要找到方法在鼠标环境中使它们生效。
- en: Scaling
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放
- en: 'Another interaction difference comes into play with zooming. You probably don’t
    want players zooming into the game area at all, whether they double-tap or not.
    Fortunately, you can restrict this by adding `<meta>` tags to the HTML head:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个交互差异出现在缩放操作上。你可能不希望玩家在游戏区域进行缩放，无论他们是否双击。幸运的是，你可以通过向 HTML 头部添加 `<meta>` 标签来限制这一点：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example tells the browser to render the page at a scale of 1:1 and set
    the viewport width to the default for the device. The content of the `<meta>`
    tag specifies the size of the display and restricts (or allows) zooming. Apple
    originally introduced this `<meta>` tag, and other browsers use it as a basis
    for their own behavior. Hence, Apple’s own documentation (*[https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html](https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html)*)
    is the best place to look for a description of the various options. However, using
    this tag is very much a case of looking up what’s expected to happen in any particular
    mobile browser and then testing it to see how it works in practice. Work is underway
    to standardize viewport sizing using CSS (*[http://www.w3.org/TR/css-device-adapt/](http://www.w3.org/TR/css-device-adapt/)*),
    although it has minimal browser support at present.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例告诉浏览器将页面按 1:1 的比例渲染，并将视口宽度设置为设备的默认值。`<meta>` 标签的内容指定了显示的大小，并限制（或允许）缩放。这个
    `<meta>` 标签最初是由 Apple 引入的，其他浏览器也以它为基础实现自己的行为。因此，Apple 自己的文档 (*[https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html](https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html)*)
    是查看各种选项描述的最佳地方。然而，使用这个标签实际上就是查找任何特定移动浏览器的预期行为，然后测试它在实际中的效果。目前，CSS 正在进行视口大小的标准化工作
    (*[http://www.w3.org/TR/css-device-adapt/](http://www.w3.org/TR/css-device-adapt/)*)，但目前浏览器支持有限。
- en: 'The most common option you’ll use in the `<meta>` tag is `user-scalable=no`,
    which simply prevents the user from zooming. But changing the other values in
    the `<meta>` tag can greatly affect how the browser displays your game, too. The
    settings in the `<meta>` tag are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<meta>` 标签中，你最常用的选项是 `user-scalable=no`，它简单地防止用户进行缩放。但改变 `<meta>` 标签中的其他值也会极大地影响浏览器如何显示你的游戏。`<meta>`
    标签中的设置如下：
- en: '****`user-scalable`****. Can be yes or no. Allows or disables zooming.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`user-scalable`****。可以是 yes 或 no。允许或禁用缩放。'
- en: '****`initial-scale`****. A decimal number specifying the zoom factor at which
    to draw the viewport.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`initial-scale`****。一个小数，指定绘制视口时的缩放因子。'
- en: '****`maximum-scale`****. A decimal representing the maximum zoomable scale
    to allow the user to zoom to.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`maximum-scale`****。一个表示允许用户缩放到的最大缩放比例的小数。'
- en: '****`minimum-scale`****. A decimal representing the minimum zoomable scale
    to allow the user to zoom to.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`minimum-scale`****。一个表示允许用户缩放到的最小缩放比例的小数。'
- en: '****`width`****. Specify this in pixels, or use `device-width`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`width`****。指定为像素值，或者使用 `device-width`。'
- en: '****`height`****. Specify this in pixels, or use `device-height`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`height`****。指定为像素值，或者使用 `device-height`。'
- en: If the game is designed with a width of, say, 760 pixels, you could set `width`
    to 760, and the browser would keep the page at that width and eliminate any extra
    pixels of spacing on either side. Unfortunately, by scaling the viewport, you’ll
    almost certainly have to solve problems with image scaling and aspect ratio; trying
    to draw 760 pixels on a screen that’s made up of 1024 pixels means some aliasing
    will need to occur.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Aspect ratios also vary much more between mobile devices than desktop screens.
    For example, the iPad 1 and 2 have a resolution of 1024×768, the iPad 3 is 2048×1536,
    the iPhone 6 is 750×1334, the iPhone 6 Plus is 1080×1920, and there are almost
    as many Android resolutions as there are devices. Unfortunately, no simple solution
    exists. Be sure to test continually on a wide range of devices, and experiment
    with a combination of `<meta>` properties and CSS layouts to ensure your game
    looks good on a variety of screen sizes and aspect ratios.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Of course, even after you solve the aspect ratio problem, if users are still
    playing your game through a mobile browser, they may not be able to play while
    offline. To really get an HTML5 game onto the device, you need to wrap up the
    code in a native package. When your game is a native application, the user should
    be able to play it whether online or offline, unless your game requires an Internet
    connection anyway. Let’s look at using a wrapper service next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Deploying as a Native Application
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have two main ways to deploy your HTML5 game as a native web application.
    You can write a wrapper using Objective-C, Java, or whichever language the target
    platform requires, or you can use an existing wrapper service. Unless you’re very
    proficient with native mobile coding, I highly recommend that you look at a wrapper
    service.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper services, such as PhoneGap/Cordova (*[http://cordova.apache.org/](http://cordova.apache.org/)*)
    and Ludei (*[https://www.ludei.com/](https://www.ludei.com/)*), give you less
    control, but they often provide access to native features, such as accelerometers
    and in-app purchases. Sometimes they even offer accelerated graphics capabilities
    and bespoke APIs. They require less time and effort, too, making them an excellent
    way to build test deployments so you can quickly see your game running on a device.
    I’d advise using a service unless you have a very good reason not to.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Using a third-party wrapper often involves uploading your HTML5 code through
    an online service and downloading a compiled version for each device. These services
    effectively do the same work as custom wrappers, but they’ve been optimized over
    iterations, usually for multiple platforms. They also continue to add support
    for newer handsets and operating systems, which is very time consuming to keep
    on top of yourself. In addition, a community is usually writing plug-ins to provide
    extra functionality, such as offering in-app purchases or accessing the device’s
    camera.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that no matter how you decide to wrap your HTML5 application,
    the files will all be running in a local environment; that is, your game won’t
    need to download assets over the Web or from a server. As a result, your game
    will be playable even when no web connection is available. If you’re developing
    a multiplayer game, it will need an Internet connection to be active, but even
    then your game will benefit from faster startup times and (if your game is a hit)
    it will save on bandwidth costs. As always, perform constant iterative testing
    to intercept problems before they become major issues.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: That’s the end of my mobile tour, but on a desktop browser, *Bubble Shooter*
    is simple enough that unless you’re playing on a very low-powered machine, you
    shouldn’t run into performance problems. But at some point, as you develop more
    complex games, you’ll find that some piece of code runs slower than intended,
    and then you’ll want to optimize that code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Optimization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two main areas to look at when you’re optimizing a game are memory management
    and speed. In particular, you should ensure your game doesn’t consume increasing
    amounts of system resources the longer it runs, and you’ll want to make the most
    of available hardware and coding tricks for speed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not you encounter visible problems, such as slowing animation, continually
    checking your game’s performance is good practice. You’ll likely only need to
    optimize for speed as a result of a specific problem, but keeping an eye on memory
    utilization is good practice in all cases. For example, a game may run fine when
    you play for five minutes, but if you leave it open in a browser tab for hours
    on end, you may return to find your nice animation loop eating up tens or hundreds
    of megabytes of memory because of a leak. For less powerful mobile devices, this
    can be a real problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, browser tools can help identify and diagnose problems, and you
    can implement coding techniques to fix those problems or minimize the risk of
    them happening. Good memory management is particularly important, so we’ll look
    at that before we move on to speed optimization.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Memory Management
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might not expect a small JavaScript game to run into memory issues on systems
    that happily run massive 3D games, but memory management is actually a pressing
    concern for HTML5 game developers. The problem is less about running out of memory
    (although it is possible, with some effort, to use up a vast amount of memory)
    and more about the way JavaScript allocates memory and frees it up later. Rather
    than constantly allocating and freeing memory, browsers run through periodic sweeps
    to clear memory, which can cause jittery animations, unresponsive interfaces,
    and general interruption of game flow.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Writing JavaScript in ways that minimize memory usage is a large subject, and
    browser vendors often publish papers on how to get the best out of their systems.
    For example, check out Mozilla’s documentation on memory management at *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management/](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management/)*.
    You can also read an excellent introduction to memory-efficient JavaScript, written
    by one of the Chrome engineers, Addy Osmani, at *[http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/](http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/)*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The key to dealing with memory issues is identifying them in the first place.
    You may suspect you have a problem, but you need to know where it is. The main
    desktop browsers have tools to help. Those tools are constantly evolving, so I
    won’t discuss them in depth. But a search through the documentation for each browser
    should bring up relevant documents and tutorials, such as the one for Chrome at
    *[https://developer.chrome.com/devtools/docs/javascript-memory-profiling/](https://developer.chrome.com/devtools/docs/javascript-memory-profiling/)*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s where to start in the three major browsers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In Chrome, open Developer Tools and click **Profiles**. Select **Take Heap Snapshot**
    and click **Take Snapshot** to examine objects in memory, including DOM elements.
    [Figure 8-1](ch08.html#snapshot_of_bubble_shooter_in_memorycomm "Figure 8-1. A
    snapshot of Bubble Shooter in memory, as displayed by the Chrome browser tools")
    shows how this looks for *Bubble Shooter*.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Firefox, you can use Firebug and other plug-ins to examine objects in memory.
    You can also type **`about:memory`** into the address bar for a snapshot of what’s
    currently in the browser’s memory.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Internet Explorer 11, open the Developer Tools and select the **Memory**
    tool.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![A snapshot of Bubble Shooter in memory, as displayed by the Chrome browser
    tools](httpatomoreillycomsourcenostarchimages2184543.png.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1. A snapshot of *Bubble Shooter* in memory, as displayed by the Chrome
    browser tools
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Another useful tool is to visualize when garbage collection is occurring. This
    takes the form of a graph across time, and you can see what range of memory your
    game is occupying. [Figure 8-2](ch08.html#memory_usage_by_bubble_shooter "Figure 8-2. Memory
    usage by Bubble Shooter") shows *Bubble Shooter*’s memory usage over time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The sawtooth line represents memory used when objects are created. The line
    rises, and then it sharply drops when garbage collection occurs. Although we’re
    not creating and destroying many objects, there’s a definite sign that if we saw
    problems with animations not running smoothly, we could look at using more object
    pools.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The key to maintaining fast animations is to test and iterate. This is especially
    true when developing for mobile devices, where debugging tools are usually slightly
    harder to access and where memory and processing power are also usually less abundant.
    If you notice intermittent slowdowns and animation freezes that are difficult
    to reproduce, it’s likely that you have a memory issue to identify and address.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory usage by Bubble Shooter](httpatomoreillycomsourcenostarchimages2184545.png.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2. Memory usage by *Bubble Shooter*
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for Speed
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory may or may not be an issue, depending on your game’s needs, and memory
    fixes occasionally require coding techniques somewhat at odds with writing readable,
    reusable code. However, optimizing for speed is more achievable as a side effect
    of following general best practices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript engines are improving in speed all the time and so are browsers’
    rendering engines (especially with the addition of WebGL). But, as with garbage
    collection, you should still be aware of the pain points. The browser vendors
    won’t solve all your performance problems for you. In reality, JavaScript interpreters
    are becoming so fast that speed problems are more likely to occur while rendering
    than anywhere else; however, coding techniques can make the translation between
    JavaScript and machine code more efficient and speed up operations, such as passing
    image data to the rendering engine.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Each time you add or change an element in the DOM, the browser has to work out
    what to draw and where to draw it. HTML documents were originally designed as
    flowing, text-based documents, and the browser will assume the content you send
    it is meant to be laid out like any other web page.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: But actions that cause the browser to repaint the display, such as adding new
    elements to the screen or changing an element’s coordinates, are very common in
    games. In *Bubble Shooter*, we can get away with adding and removing elements
    as we want because relatively few elements are onscreen. Multiply the number of
    items onscreen by 10 or 100, and you’ll start to see problems. Remember that the
    garbage collector needs to sweep away any element deleted from the scene, and
    DOM elements tend to be complex.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the canvas copes with graphical additions without an expensive
    paint operation because no reflowing occurs inside a `canvas` element. The browser
    considers `canvas` elements to be images, which are just streams of pixels that
    go from memory to screen.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Changing properties of the `canvas` element, such as its position or transparency,
    rather than pixels within it, is just as expensive as changing any other DOM element.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: You can see how much time the browser spends painting a scene by loading *Bubble
    Shooter* in the Chrome desktop browser, pressing F12 to open Developer Tools,
    and navigating to the Timeline tab. Click **Record** in the bottom control bar,
    reload the game, and then click the **Events** bar at the top to see a view like
    [Figure 8-3](ch08.html#browser_events_involved_in_playing_bubbl "Figure 8-3. The
    browser events involved in playing Bubble Shooter in Chrome").
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![The browser events involved in playing Bubble Shooter in Chrome](httpatomoreillycomsourcenostarchimages2184547.png.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3. The browser events involved in playing *Bubble Shooter* in Chrome
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: All of the paint events ➊, like those in [Figure 8-3](ch08.html#browser_events_involved_in_playing_bubbl
    "Figure 8-3. The browser events involved in playing Bubble Shooter in Chrome"),
    should be highlighted in green on your screen. In the canvas version of the game,
    a few paint calls occur once a level has been loaded, whereas in the CSS version,
    such calls occur constantly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: You can use the Timeline tool to identify when paint events happen and minimize
    them to speed up your game’s rendering. Just remember that different browsers
    may repaint the scene at different times. As always, use the tools available,
    but also test on your target platforms and devices as the main guide to performance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In general, minimizing DOM manipulation is the key to minimizing paint operations.
    Search for articles on minimizing browser reflow and browser paint operations
    for more detailed and up-to-date information on the inner workings of rendering
    engines.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your game has any kind of scoring or progression system, someone will try
    to cheat it. But the key is to assess the ramifications of having cheats slip
    through the system and decide whether or not those ramifications are critical.
    For *Bubble Shooter*, this isn’t an issue: if someone wants to set a high score
    on their local machine, that’s up to them. However, for games with an online competitive
    element or where buying power-ups is a revenue stream, you need to ensure that
    cheating is difficult to impossible.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: We can try to address security in HTML5 games in a few ways.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Trust No One
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplistic approach to security in any games that run on the client, whether
    they’re built with HTML5, Flash, or even native code, is to not trust anything
    that the client sends to the server. A POST back to the server with, say, a high
    score value (as we used in the examples on AJAX and Web-Sockets) is easily forged.
    The score may be valid, the POST may be forged, or someone may even use a debugging
    tool to change the high score while the game runs. The server only sees the data
    as it’s received and can’t differentiate between a genuine and a cheat POST.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, not trusting the client is often the correct approach: there’s
    no way to completely guarantee the security of code running on the client. The
    only way to make a game secure is to have all game logic processed by the server.
    To completely secure *Bubble Shooter*, we’d pass mouse clicks to the server, have
    the collision and popping logic run on the server, and then pass the results back
    to the client to animate. This is more difficult to develop and test, and the
    user would need a constant (and fast) Internet connection to even play the game.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscation
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server-side approach is essential when a game includes financial transactions,
    but for many games, obfuscation is good enough. The idea behind obfuscation is
    to make cheating as difficult as possible, essentially making the effort involved
    greater than the reward. For example, if a high score is posted to the server
    as an encoded value, passed with a checksum, and takes hours of reading through
    code to decipher how it was created, cheaters are unlikely to go through all of
    that effort just to get to the top of a high score table.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Of course, obfuscation usually comes at the price of readability for you as
    well as hackers. But there are a number of ways to make code difficult to read,
    and you can even apply some as a post-build process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest option is running your code through a *minifier* before you package
    it for a live environment. Minifiers shorten all long variable names in your code
    and eliminate whitespace. For example, code such as this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'becomes something like this after minifying:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Effectively, minifying removes the whitespace and puts everything onto one
    line. Such minified code quickly becomes difficult to read. You can easily un-minify
    the line breaks. Many minifiers will also rename variables inside functions. For
    example, this function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'could become much smaller:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The property that you’ve been calling `highScore` in your code becomes much
    harder to find if it’s now called `a` instead!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Minifying code also has the added advantage of creating smaller code that
    should therefore load faster, which is an important consideration when deploying
    in a web environment. In fact, you should consider minifying your JavaScript code
    in all web applications.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Google released a tool called the Closure Compiler, which acts as a minifier
    along with providing a number of other benefits. It attempts to optimize code,
    even rewriting it in places, and outputs smaller and sometimes even faster code
    than the original version. The compiler generates JavaScript, analyzes your code,
    and raises errors. Declaring variables, keeping track of scope, and maintaining
    other good practices pay off when you use a minifier such as the Closure Compiler,
    because the compiler provides greater benefits the clearer and simpler your coding
    structure is.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: You can use the Closure Compiler online or download and run the Java application
    from *[https://developers.google.com/closure/compiler/](https://developers.google.com/closure/compiler/)*.
    Once you have access to it, paste the Closure Compiler in the JavaScript code
    that you want to compile and then copy the output. It’s recommended that you keep
    a copy of your original code, because the compiler output is far too difficult
    to work with if you need to make further changes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Using Private Variables
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Along with post-build processes, you can also code in ways that make it harder
    for cheaters to follow through code and change it on the fly. For example, private
    variables make manipulating internal values on the console more difficult. The
    following has a private variable for `highScore`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The variable is considered private because it only exists inside the scope
    of a `Game` object. We could have made the variable public as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This would allow the value of `highScore` to be changed on a `Game` object just
    by changing the value of its `highScore` property. However, in the private version,
    there’s no way to access the value of `highScore` from outside the object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: If `highScore` is private, cheaters will have difficulty changing its value
    without using a program like Firebug to add a breakpoint within the object. They’ll
    have even more trouble if the code is minified and obfuscated. `highScore` is
    actually labeled `"a"`, and it’s difficult to even find where the high score is
    updated in the first place.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: With a couple of relatively simple steps (making some variables private and
    minifying our code), we’ve already narrowed down the potential cheaters from those
    who know a small amount of JavaScript to those who know it quite well and are
    willing to take the time to reverse engineer our code. Now, let’s look at one
    more way to prevent cheating.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Validating with Checksums
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also secure information passed to the server by using checksums to
    validate the variable passed. The simplest techniques just encode a value so there
    is at least some check that the number is correct. This won’t eliminate cheating,
    and checksums don’t need to be very complicated, but it will ensure that anyone
    who wants to cheat needs to read and understand your JavaScript code first. For
    example, if we passed `highScore` to the server, we could POST something like
    this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The value 21 is 9,825 modulus 129 (or `highScore%129` in code), where 129 is
    a number I chose as being big enough to create a range of check values but also
    being a factor smaller than likely high scores. This almost trivial check actually
    increases the level of security because now the barrier to posting a fake high
    score is not only knowing how to POST but also being able to follow through the
    code to the point where the `check` value is created. A seasoned JavaScript programmer
    might find those steps simple, but the average meddling game player probably won’t.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example may be too trivial for your liking, and you can use any
    process you like for generating a checksum. Common approaches include using hash
    functions such as MD5, SHA, or CRC32, although the disadvantage of these is that
    programmers will often recognize the structure well enough to know they are looking
    at a standard hashing function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: In principle, any process you create that can generate a range of check values
    will significantly slow down, and possibly discourage, a large number of potential
    cheaters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you may still get a few cheaters whatever you do, because some hackers
    enjoy the challenge of beating the programmer more than the challenge of beating
    the game. You can obfuscate as much as you like, and you may end up with code
    that’s almost impossible to read. But remember that you can never guarantee security
    in client-side code and never fully trust the information passed from the client
    to the server.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have gathered from this chapter, browser support for HTML5 is an
    ever-changing landscape. The good news is that browsers are generally converging
    on the same standard rather than adding their own features. Also, support for
    HTML5 is improving all the time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: With the rate of change, it’s important to keep up-to-date on which browser
    features are ready for mainstream usage as well as what’s on the horizon. Whether
    in terms of improved performance, memory management, sound, or 3D features, the
    capabilities of HTML5 games are constantly advancing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Further Practice
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add fullscreen capability to *Bubble Shooter* in a desktop browser. To make
    the switch as easy as possible, add a button to the top bar that is visible only
    if fullscreen mode is supported. Also, change the CSS so that when the page is
    displayed fullscreen, the game is centered.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a routine to post the player’s score to a fictional server address using
    jQuery’s `ajax` method. Post the score at the end of each level and write a checksum
    function to add basic security using your method of choice.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find and test some online minifier and obfuscation services. Compare the file
    size of the output code to the size of the original source.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
