- en: '**B**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BITCOIN PROGRAMMING WITH BITCOINJ**'
  prefs: []
  type: TYPE_NORMAL
- en: In [Appendix A](../Text/app01.html#app01), we dabbled with JavaScript code that
    could perform some basic actions with a Bitcoin wallet by automating a preexisting
    wallet. In this appendix, we’ll write far more powerful programs that directly
    insert themselves into the Bitcoin network. As discussed previously, Bitcoin programs
    written this way—meaning those that do not rely on APIs from external companies
    and avoid dependencies on separate wallet programs—are usually the smartest solution
    for serious Bitcoin development projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Best Programming Language for Connecting to the Bitcoin Network**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re an experienced programmer, most likely you have a favorite programming
    language you would prefer to use to write your Bitcoin programs. However, only
    a few mature libraries currently exist that can connect directly to the Bitcoin
    network. One is the C++ reference implementation with which all the first full
    clients of the Bitcoin system were written.^([1](../Text/footnote.html#footnote37))
    Large enterprise companies interested in supporting bitcoins should use this library.
    However, working with C++ is difficult for novices.
  prefs: []
  type: TYPE_NORMAL
- en: Another mature library is written in Java and is called bitcoinJ.^([2](../Text/footnote.html#footnote38))
    Because Java is easier to work with than C++, it is the library we’ll use. (The
    bitcoinJ library can also be used easily from languages built on top of the Java
    Virtual Machine, such as Scala or Clojure.)
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the options for other languages are rather limited. By searching
    the Internet, you *will* find Bitcoin libraries for other languages, such as Ruby,
    C#, and Python. However, most of these libraries are either in extremely early
    development or simply use the more limited JSON-RPC interface, which was discussed
    in [Appendix A](../Text/app01.html#app01).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some serious attempts are being made to offer full Bitcoin client support
    within the Go programming language. However, at the time of this writing, these
    libraries are either still in early development (such as gocoin^([3](../Text/footnote.html#footnote39)))
    or are missing major features (such as btcd ^([4](../Text/footnote.html#footnote40))).*'
  prefs: []
  type: TYPE_NORMAL
- en: No matter which library you choose, keep in mind that you must be vigilant about
    security. Essentially, when you use any of these libraries, you’ll be giving the
    library authors the keys to your Bitcoin kingdom. As we warned previously, technically
    it would be relatively easy to introduce rogue code into one of these libraries
    to steal all your money!
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing Java, Maven, and the BitcoinJ Library**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s ready your computer to do Java and bitcoinJ programming. The following
    steps should work on any major OS: Windows, Mac, or Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 1: Installing Java***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Java programming language is maintained by Oracle Corporation. Your computer
    may already have Java installed, but if you’ve never done Java development, your
    computer may only contain the Java JRE (Java Runtime Engine), which can run Java
    programs but is not adequate for developing them. Instead, you need the Java JDK
    (Java Development Kit). To download the JDK, do a Google search for *Java JDK*.
    The first link (which should be a link on the official Oracle website) should
    direct you to the right place to access the download.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux developers:** Some versions of Linux may install the OpenJDK version
    of Java by default. At the time of this writing, this unofficial Java variant
    is missing some components that this tutorial depends on. Instead, look online
    for information about installing the Oracle JDK on your version of Linux and make
    it the default Java version on your system.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 2: Installing Maven***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Maven is a packaging tool for Java. Essentially, you specify which libraries
    your program needs, and Maven automatically downloads them from the Internet and
    makes them available to your program. This is analogous to the Node Package Manager
    used in [Appendix A](../Text/app01.html#app01).
  prefs: []
  type: TYPE_NORMAL
- en: You can download Maven and find instructions for installing Maven on each OS
    at *[https://maven.apache.org/](https://maven.apache.org/)*. Just follow the instructions
    at the main Maven website to install it or search Google for tutorials. Because
    more than a million other people have had to install Maven, if you run into installation
    problems, just type your problem into Google. It is very likely you’ll get helpful
    information on how to solve your problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Windows users:** At the time of this writing, detailed instructions for
    installing Maven on Windows are cleverly hidden at the very bottom of* [http://maven.apache.org/download.cgi](http://maven.apache.org/download.cgi).
    ***Mac/Linux users:** You can use your package managers here: brew install maven
    for Mac and sudo apt-get install maven for Debian Linux*.'
  prefs: []
  type: TYPE_NORMAL
- en: To ensure Maven is properly installed, a version message should display when
    you type `mvn --version` from a console.
  prefs: []
  type: TYPE_NORMAL
- en: For typical Java programming, we could stop here because any needed additional
    libraries could be downloaded through the Maven package system. However, because
    we’re writing programs that work with money, the bitcoinJ maintainers require
    all developers to take a few extra precautions and install a couple of additional
    tools that directly relate to security issues.
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 3: Installing Git***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For security reasons, we’ll install Git, which is a popular source code management
    tool. But it also offers features for securely downloading source code from online
    repositories that we’ll rely on. Download Git from *[http://git-scm.com/](http://git-scm.com/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Once again, Mac and Linux users can use their package managers: brew install
    git and apt-get install git, respectively. Do you see a pattern?*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 4: Installing BitcoinJ***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: BitcoinJ is a Bitcoin library that can “talk bitcoin” and can connect directly
    to the Bitcoin network. By calling functions in this library, we can send and
    receive bitcoins in real time.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build bitcoinJ directly from its authoritative source. Navigate to a directory
    from the console where you want to install the bitcoinJ library (your *Home* directory
    would be a good place).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A new subdirectory will be created, so other existing files in this directory
    will not be affected by this installation.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following into your console (on Windows you may need to use the special
    Git Bash console that was installed when you installed Git):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line downloads the bitcoinJ code from the authoritative website ➊.
    Then, we use git to switch to an older version of this library using the `git
    checkout` command ➋. During this tutorial, this command will shield us from any
    problems that might be caused by newer versions of the library. However, when
    you’ve completed the tutorials, you can switch to the newest version of bitcoinJ
    (`git checkout master`) to experiment with its shiny new features. The last line
    installs the package into the local Maven package repository ➌. When we reference
    bitcoinJ from our programs, Maven will fetch it from this repository (instead
    of grabbing it from the Internet), and we can be confident we’re using an uncorrupted
    version of this library.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can finally start programming!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Starter Project for hello-money**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Appendix A](../Text/app01.html#app01), we created a JavaScript program called
    `Hello Money!` that detects when money is sent to a Bitcoin address. Now, we’ll
    write a more sophisticated program with Java and bitcoinJ that accomplishes the
    same task. From the console, navigate to a directory where you want your new program
    to live, such as your computer’s *Home* or *Documents* folder. A subdirectory
    will be created in this place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now type the following to have Maven create an empty starter project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These commands create a directory called *hello-money* at the current location
    with the `hello-money` starter project.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If Maven prompts you for answers during this process, just keep pressing ENTER
    to use the default setting.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to inform Maven that this program will use a couple of external
    libraries. We do this by editing the file *pom.xml*, which should now exist in
    the new directory. Also in this file should be a section named `<dependencies>`
    where we’ll add bitcoinJ as a new dependency. After the previous dependency (i.e.,
    *after* the line that reads `</dependency>` singular), add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ll add a plug-in called `exec-maven-plugin` to our program. A *plug-in*
    is a special type of library. The `exec-maven-plugin` will make it easier to run
    our finished program from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the very bottom of the projects in *pom.xml* (i.e., *after* the line that
    reads `</dependencies>` plural), add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re ready to run this *empty* program for the first time as a test. To
    do this, execute the following lines from the console in the program’s directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first line ➊ loads all the necessary libraries into the project and builds
    the program into a Java bytecode file. The second line ➋ actually runs the program.
  prefs: []
  type: TYPE_NORMAL
- en: If the program runs successfully, you should see `Hello World!` printed on the
    screen. This means Maven has successfully created a functioning Java program and
    that we’re now ready to start writing the core Bitcoin code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing the Code for hello-money**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The entirety of the code for our `hello-money` program follows. To add this
    to the project, open the file *src/main/java/hellomoney/App.java* and replace
    its contents with this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, run the command `mvn install`, which checks the syntax of this new program
    code and builds it into a program file. If the build works, the message `BUILD
    SUCCESS` should appear (along with tons of other esoteric messages).
  prefs: []
  type: TYPE_NORMAL
- en: Before we run the program, let’s walk through it step-by-step to see what it
    does.
  prefs: []
  type: TYPE_NORMAL
- en: '***Declarations at the Top of the Program***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first line in the program declares the name of the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare all the libraries the program will reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Three of these references are for Bitcoin classes: First, we’ll use the core
    libraries to access basic Bitcoin classes (such as classes for wallets and keys).
    Second, we need classes for storing the blockchain (called a *block store* in
    BitcoinJ lingo). Third, we need to use the `DnsDiscovery` class, which helps us
    find other nodes participating in the Bitcoin network. We import the `java.io.File`
    class because we’ll be writing our block store to a file, and we import the `java.math.BigInteger`
    class to work with, well, big integers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s define the Java class that holds the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The program code is stored in a new class called `App`, which contains a single
    member function `main`. We mentioned this `hellomoney.App` class in the *pom.xml*
    file, declaring it as the *main class* of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at individual lines in the main function.
  prefs: []
  type: TYPE_NORMAL
- en: '***Initializing Our Java Objects***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here is the code that initializes the Java object we need from the bitcoinJ
    library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We start by fetching the network parameters for the main, production Bitcoin
    network ➊. Although only one true Bitcoin network is actually used for transactions,
    it’s difficult to test the Bitcoin system thoroughly with real money; therefore,
    Bitcoin developers also maintain a second Bitcoin network called *TestNet* for
    testing only. The `NetworkParameters` structure contains information about the
    genesis block (the first block in the block-chain) as well as information about
    the maximum number of coins and several other assorted details, which may differ
    between the main Bitcoin network and the TestNet. By having all this information
    packed in the `NetworkParameters` data structure, it’s easy to connect our program
    to another network besides the main Bitcoin network, such as the TestNet, as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new, empty wallet that we’ll set up to receive our coins ➋.
    As discussed earlier, Bitcoin wallets contain one or more Bitcoin addresses, and
    each Bitcoin address consists of a public and a private key. Here ➌, the bitcoinJ
    library creates a new key pair for us. Then, we print out the public address and
    private keys that were generated ➍➎. Finally, we add our new key pair to the wallet
    ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Usually, when using bitcoinJ, you should reuse the same wallet every time
    the program runs and load/save it every time the program starts/stops or your
    program can lose track of money. This is not an issue for the simple hello-money
    program. However, before you build more sophisticated bitcoinJ programs, read
    “[Gotchas When Using Wallets in BitcoinJ](../Text/app02.html#ch00leve1sec173)”
    on [page 239](../Text/app02.html#page_239).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only does a Bitcoin app need a wallet, it also needs a blockchain. The
    following lines initialize a new blockchain for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Because blockchains consume lots of space, we’ll write it to a file named *my-blockchain*
    ➊. Next, we create a block store, which is an object that manages the data for
    our copious blockchain data ➋. BitcoinJ offers several block store types, all
    with different feature and performance trade-offs. In this example, we’ll use
    an `SPVBlockStore` object, which is usually the best choice for most apps.
  prefs: []
  type: TYPE_NORMAL
- en: So what are the trade-offs you need to know about? Well, the biggest performance
    challenge any app that works with bitcoins has to deal with is that the official
    Bitcoin blockchain is larger than 10GB in size. Do most Bitcoin apps *really*
    need all 10GB of the blockchain?
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer this question, let’s consider why the blockchain exists. At a simplified
    level, a Bitcoin blockchain is responsible for two main jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Figuring out how much money everyone on the network has
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Figuring out whether new transactions broadcast across the network are valid
  prefs: []
  type: TYPE_NORMAL
- en: For the first task, the blockchain allows us to examine all the historical blocks
    in the blockchain and compile comprehensive data about every Bitcoin address ever
    used and how much money each contains. For the second task, it allows us to examine
    new blocks of transactions created by the network and then to verify that these
    blocks have the appropriate hashing information that proves they are correctly
    mined blocks according to the latest difficulty requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'But consider the first job of the blockchain: Do most apps need to discern
    how much money is in every wallet in existence? No, most apps only need to identify
    the amount of money in *one* or a small number of wallets. Therefore, not all
    10GB of data are needed. The prescient Satoshi, in his original Bitcoin whitepaper,
    was able to see that in this case, an optimization called *Simplified Payment
    Verification (SPV)* was possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We also covered SPV a bit in [Chapter 9](../Text/ch09.html#ch09), when comparing
    different types of Bitcoin wallets.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick refresher of how SPV works: If you know you’re interested in
    a single wallet ahead of time, you can just tally up how much money is in that
    one wallet as you pull the entire historical blockchain off the Bitcoin network.
    At that point, you only need to store header information of blocks and can ignore
    information in older blocks entirely in most situations, which is what `SPVBlockStore`
    does. In doing so, the `SPVBlockStore` (as of 2014) is less than 1GB in size,
    less than a one-tenth the size of the official blockchain, and this is why we
    use `SPVBlockChain` to store our data.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve created the block store, we can use it to create a `BlockChain` object
    ➌. Notice that when we create this `BlockChain` object, we must pass in our wallet
    as created. Because we’re not downloading all 10GB, the block-chain object needs
    to know ahead of time which wallets (and their addresses) are important to us
    so it can select the right blockchain data to download.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Even though SPVBlockStore is much smaller than the full blockchain, it can
    still take a long time for your app to download all the needed data from the network—usually,
    about 20 minutes. However, it will write this data to a file, and an SPVBlockStore
    object is smart enough to check the supplied file to see whether any data has
    already been downloaded since the last time the program was run. If so, it downloads
    only new data that has arrived after the program was last run.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Connecting to the Bitcoin Network***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With a wallet and a place to store the blockchain data, we can now connect
    to the actual Bitcoin network. A Bitcoin node connects to the Bitcoin network
    by connecting to several semirandom peer nodes. Here is the code that fires up
    a connection to several peers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First we create a `PeerGroup` object ➊ that manages these connections. Next,
    we choose some random peers to connect to. We do this by adding a peer discovery
    algorithm to the `PeerGroup` ➋. The `DnsDiscovery` class basically uses the URLs
    of some well-established and trusted nodes as a starting point to discover peers
    that are willing to accept new connections. Then we add our wallet to the `PeerGroup`
    object ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re finally ready to inject the app into the Bitcoin network! We do this
    by calling `PeerGroup.start` ➍, which will find and connect to some nodes and
    perform the appropriate handshake operations via network sockets. And, like any
    Bitcoin node, we request that the peers send us the blockchain so we can become
    a fully functional node ➎. As mentioned previously, this step will take a while
    to run, but only the first time we run the program.
  prefs: []
  type: TYPE_NORMAL
- en: '***Listening for New Money***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One last feature we need to add to the `hello-money` program is a hook to detect
    when money has arrived:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The bitcoinJ wallet object has an `addEventListener` member function, and we
    can create an anonymous class of type `EventListener`, which intercepts and listens
    to different events that might happen to a wallet ➊. In our app, we’re interested
    in the `onCoinsReceived` function ➋, which will be called every time money is
    received by this wallet. Let’s explore in more detail exactly what this means.
  prefs: []
  type: TYPE_NORMAL
- en: Because the program lives directly in the Bitcoin network, it can listen to
    the *bitcoin firehose*, a stream of data that contains every Bitcoin transaction
    happening anywhere in the world in close to real time. Each transaction is examined
    to see whether it involves receiving money into any Bitcoin address contained
    in our wallet. In our app, the wallet contains only one address. As soon as this
    transaction arrives (even before it has been incorporated into a mined block),
    our function `onCoinsReceved` will be called.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the hello-money program, we won’t worry about capturing confirmation events
    on the money received; we’ll only listen for the transmission of new, unconfirmed
    transactions. However, if we were interested in confirmations, we could capture
    them via the onTransactionConfidenceChanged function. Because we’re running a
    full Bitcoin client, we can do what we want, whereas in [Appendix A](../Text/app01.html#app01)
    we were* forced *to look only at confirmed transactions due to the limitations
    of the JSON-RPC interface.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onCoinsReceived` function has four parameters passed into it ➋: the wallet
    object, a transaction object, the previous balance in the wallet, and the new
    balance. The bitcoinJ library uses the Java `BigInteger` class to encode Bitcoin
    balances, because this numerical type can handle very large integers precisely.
    If you’ve written financial software before, you’ll know why the `BigInteger`
    class is used (or you may recall how the bank heist was done in the movie *Office
    Space*). The fact is that it’s very easy to botch a financial transaction due
    to rounding errors, and using big, precise integers prevents this problem. Hence,
    bitcoinJ performs all Bitcoin math using satoshis, the smallest unit of bitcoins,
    which are worth one one-hundred-millionth of a bitcoin.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Because we added the event listener* after *we downloaded the initial blockchain,
    the onCoinsReceived function will be called* only *when new transactions appear
    as the program is running. If we had declared it before downloading the initial
    blockchain, the design of bitcoinJ is such that onCoinsReceived would also have
    been called on relevant historical transactions.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we put the program into an infinite loop, so the program continues
    running as we wait for money to arrive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Running and Testing the hello-money Java Program**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re ready to run and test the program! As before, we first compile and then
    run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Some messages should then appear as your program connects to the Bitcoin network
    and downloads the blockchain. The first time the program is run, this may take
    a while:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After the blockchain has finished downloading, you can test the `hello-money`
    program and send it some tiny sum from your favorite wallet app. Simply send 0.0002
    BTC to the public address and record the private key (we’ll be using this money
    in the follow-up example program later in this appendix). The program should detect
    when the money arrives and display a message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The new balance in the wallet should display in satoshis (divide by 100,000,000
    to see that this number is indeed 0.0002 BTC).
  prefs: []
  type: TYPE_NORMAL
- en: You’ve successfully written a bitcoinJ program that creates a Bitcoin wallet
    and reports on any money received. Now let’s write a second program that uses
    the newly stored money!
  prefs: []
  type: TYPE_NORMAL
- en: '**Bye-Bye Money**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s write a brand-new program that can *send* money from an arbitrary
    Bitcoin address. To create a new `bye-bye-money` program, run the following from
    your top-level program directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then, make the exact additions to the *pom.xml* file as we did in the `hello-money`
    example, except for the line that reads `<mainClass>hellomoney.App</mainClass>`.
    Change that line to `<mainClass>byebyemoney.App</mainClass>`. (These steps are
    analogous to those we followed for our `hello-money` program in “[Creating a Starter
    Project for hello-money](../Text/app02.html#ch00leve1sec161)” on [page 228](../Text/app02.html#page_228).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as before, open the file *src/main/java/byebyemoney/App.java* and replace
    its contents with the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Many of the lines in this new program are shared with our previous `hello-money`
    program, but let’s look carefully at the new parts.
  prefs: []
  type: TYPE_NORMAL
- en: '***Importing a Private Key***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To send money from our program, we need to import the private key of the Bitcoin
    address from the previous example. Here is the code that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the first lines, we’re explicitly adding a new, preexisting private key to
    our wallet ➊➋. This is the key associated with the Bitcoin address that received
    the money in the `hello-money` program. You need to replace the private key shown
    on this line with the private key you wrote down when running the previous example.
    Also, in this new program we’re not using the `SPVBlockStore` function; instead,
    we’re using bitcoinJ’s `MemoryBlockStore` ➌ function for variety. This block store
    won’t create a file, but by using it, our program will need to redownload the
    blockchain every time the program runs. (This also guarantees that bitcoinJ will
    assign the correct balance to the wallet. We’ll discuss why in “Gotchas When Using
    Wallets in BitcoinJ” on [page 239](../Text/app02.html#page_239).)
  prefs: []
  type: TYPE_NORMAL
- en: '***Sending the Money***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at the code that actually sends the money:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the balance contained in the wallet ➊ and display it ➋. Next,
    we declare the destination address the money should be sent to ➌. In this example,
    we input the main donation address for the Bitcoin Foundation; feel free to substitute
    a public address of one of your own wallets.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, it’s best to include a transaction fee when sending bitcoins, which
    we declare to be 10,000 satoshis ➍. Next, we create a `SendRequest` object ➎,
    which is a structure to hold the basic information about what we’re sending and
    includes the destination address and the amount to be sent (which is the balance
    minus the fee). Then, we set the fee on this object ➏ and send our money ➐!
  prefs: []
  type: TYPE_NORMAL
- en: '***Ensuring the Money Transmission***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we try to send more money than we have, if the fee is inadequate, or if
    the Internet connection drops out at the wrong moment, the money might never be
    accepted by the network. Therefore, we need to write code that waits and ensures
    that the money we sent is transmitted to the network. Here’s what we’ll add to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code ➊ retrieves a Java *future* object, which indicates that
    the send transaction has been properly broadcast to the network. (A standard in
    Java, futures retrieve information about a separate execution thread—in this case
    the thread that monitors communication with the Bitcoin network.) If this line
    completes without throwing an exception, we display a message indicating that
    the money was sent ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running bye-bye-money***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can run `bye-bye-money` in the usual way (remember to input your own private
    key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**EXCEPTION TYPES IN BITCOINJ**'
  prefs: []
  type: TYPE_NORMAL
- en: 'One feature we skimped on in this example is error handling: The main function
    simply rethrows a variety of different exceptions for operations that can go wrong
    as we attempt to send our money. These include the following exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '• `BlockStoreException`: This is thrown when the block store cannot be created
    (most commonly, this happens with block store types that write to a file when
    something corrupts the file).'
  prefs: []
  type: TYPE_NORMAL
- en: '• `AddressFormatException`: This is thrown when the format of the address is
    incorrect.'
  prefs: []
  type: TYPE_NORMAL
- en: '• `InterruptedException`: This is thrown when network connection problems occur.'
  prefs: []
  type: TYPE_NORMAL
- en: '• `ExecutionException`: This is thrown when we’re using a future object and
    an exception occurs in the other thread (as happens when we check for completion
    of the transaction broadcast).'
  prefs: []
  type: TYPE_NORMAL
- en: In a more sophisticated Bitcoin app, you should catch all of these exception
    types separately and add more descriptive error messages for your app’s users.
  prefs: []
  type: TYPE_NORMAL
- en: Because this program churns through the blockchain in memory, you’ll need to
    wait a few minutes or more for it to complete (even when you rerun it). If the
    program is successful, you’ll see the message *The money was sent!*, and the money
    should arrive at the destination wallet. You can also access a blockchain information
    site (such as *[http://blockchain.info/](http://blockchain.info/)*), enter the
    source or destination address, and see that the details of the transaction are
    part of the public record.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now understand the basics of writing a Bitcoin application!
  prefs: []
  type: TYPE_NORMAL
- en: '**Gotchas When Using Wallets in BitcoinJ**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To the novice, the way wallets and the `BlockChain` object work in bitcoinJ
    can be very confusing. If you don’t fully understand bitcoinJ’s behavior, bitcoinJ
    can also report incorrect wallet balances.
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens because bitcoinJ is optimized around the concept of an SPV blockchain.
    The performance benefits of SPV blockchains were discussed earlier, but because
    they contain only limited blockchain data, you need to follow a few basic rules
    to ensure they work properly for you in bitcoinJ:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. If your app’s wallet already has money in it, bitcoinJ needs to know the
    amount *before* the blockchain is downloaded from the network.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. After the blockchain is loaded, bitcoinJ will perform the necessary tasks
    to ensure the wallet’s accuracy as new transactions appear on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. If you use a block store type that supports saving to a disk file, your
    app is responsible for saving the wallet to a file, as well (it is also responsible
    for loading the block store and wallet data).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw when we constructed a `BlockChain` object, bitcoinJ expects the
    app to pass in a wallet object. This allows the wallet to be updated when relevant
    *historical* transactions are found in downloaded blocks and allows rule #1 to
    be enforced: *Be sure not to add additional keys to your wallet after the fact
    and expect your wallet to work without redownloading the blockchain.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, when we initialized the `PeerGroup` object, we called `addWallet()`
    to add our wallet to the peer group. By doing so, bitcoinJ keeps the wallet balance
    in sync with any *new* transactions that appear in the Bitcoin network as the
    program is running, enforcing rule #2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure rule #3 is adhered to, you can use the `Wallet.loadFromFile()`
    and `Wallet.saveToFile()`functions. A `Wallet.autoSaveToFile()` function is also
    available that can help with loading and saving the block store and wallet data.
    To learn how to use these functions properly, look at the example programs in
    the bitcoinJ repository.'
  prefs: []
  type: TYPE_NORMAL
- en: If you keep the previously listed three basic tenets in mind, you’ll avoid most
    of the pitfalls that accompany mastering bitcoinJ.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We hope you’ve enjoyed this tour of bitcoinJ programming, and we look forward
    to seeing any awesome new apps that you build. After all, the app you build just
    might completely reinvent how people interact with their money in the Internet
    age!
  prefs: []
  type: TYPE_NORMAL
