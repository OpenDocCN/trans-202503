["```\n`A quoted string'\n```", "```\nTwo names # followed by a comment\n```", "```\n88North20th_street\n_88North20th_street\n```", "```\ndefine(macro[, expansion])\n```", "```\n   $ m4\n   define(`macro')\n\n   Hello macro world!\n➊ Hello   world!\n  <ctrl-d>$\n```", "```\n   $ m4\n➊ define(`macro', `expansion')\n➋\n   macro ``quoted' macro text'\n➌ expansion `quoted' macro text\n   <ctrl-d>$\n```", "``` ``quoted' macro ```", "```\n$ m4\ndefine(`macro', `expansion')macro\nexpansion\n<ctrl-d>$\n```", "```\n$ m4\ndefine(`macro', `expansion')dnl\nmacro\nexpansion\n<ctrl-d>$\n```", "```\nchangequote(`[',`]')dnl\n```", "```\n   $ m4\n   define(`with2args', `The $# arguments are $1 and $2.')dnl\n➊ with2args\n   The 0 arguments are  and .\n   with2args()\n   The 1 arguments are  and .\n➋ with2args(`arg1')\n   The 1 arguments are arg1 and .\n   with2args(`arg1', `arg2')\n   The 2 arguments are arg1 and arg2.\n   with2args(`arg1', `arg2', `arg3')\n   The 3 arguments are arg1 and arg2.\n➌ with2args (`arg1', `arg2')\n   The 0 arguments are  and . (arg1, arg2)\n   <ctrl-d>$\n```", "```\n   $ m4\n   define(`with3args', `The three arguments are $1, $2, and $3.')dnl\n➊ with3args(arg1,\n             arg2,\n             arg3)\n   The three arguments are arg1, arg2, and arg3.\n➋ with3args(arg1\n             ,arg2\n             ,arg3\n             )\n   The three arguments are arg1\n             , arg2\n             , and arg3\n             .\n   <ctrl-d>$\n```", "```\n$ m4\ndefine(`macro', `expansion')dnl\nmacro ``quoted' text'\nexpansion `quoted' text\n<ctrl-d>$\n```", "```'` `text`) from a stream of input text (```", "```).\n\nThe diagram above this line shows how M4 actually generates the output text from the input text. When the first token (`macro`) is read in the top line, M4 finds a matching symbol in the symbol table, pushes it onto the input stream on the second line, and then restarts the input stream. Thus, the very next token read is another name token (`expansion`). Since this name is not found in the symbol table, the text is sent directly to the output stream. The third line sends the next token from the input stream (a space character) directly to the output stream. Finally, in the fourth line, one level of quotes is removed from the quoted text (```", "```), and the result (`` `quoted' text ``) is sent to the output stream.\n\n#### *Infinite Recursion*\n\nAs you might guess, there are some potentially nasty side effects of this process. For example, you can accidentally define a macro that is infinitely recursive. The expansion of such a macro would lead to a massive amount of unwanted output, followed by a stack overflow. This is easy to do:\n\n```", "```\n\nThis happens because the macro name expands into text containing the macro’s own name, which is then pushed back onto the input stream for reprocessing. Consider the following scenario: *What would have been the result if I’d left the quotes off of the expansion text in the macro definition? What would have happened if I’d added another set of quotes around the expansion text?* To help you discover the answers to these questions, let’s turn next to M4 quoting rules.\n\n#### *Quoting Rules*\n\nProper quoting is critical. You have probably encountered situations where your invocations of Autoconf macros didn’t work as you expected. The problem is often a case of under-quoting, which means you omitted a required level of quotes around some text.\n\nYou see, each time text passes through M4, a layer of quotes is stripped off. Quoted strings are not names and are therefore not subject to macro expansion, but if a quoted string passes through M4 twice, the second time through, it’s no longer quoted. As a result, individual words within that string are no longer part of a string but instead are parsed as name tokens, which are subject to macro expansion. To illustrate this, enter the following text at a shell prompt:\n\n```", "```def''')dnl\n   abc\n   `def'\n   <ctrl-d>$\n```", "```\n/usr/bin/m4 --nesting-limit=1024 --gnu --include=/usr/share/autoconf \\\n--debug=aflq --fatal-warning --debugfile=autom4te.cache/traces.0t \\\n--trace=AC_CANONICAL_BUILD ... --trace=sinclude \\\n--reload-state=/usr/share/autoconf/autoconf.m4f aclocal.m4 configure.ac\n```", "```\n# Test for option A\n# -----------------\nAC_DEFUN([TEST_A],\n[AC_REQUIRE([TEST_B])dnl\ntest \"$A\" = \"yes\" && options=\"$options A\"])\n```", "```\n--snip--\n# Configure FTKLIB, FTKINC, FTK_LTLIB and FTK_INCLUDE\nAC_ARG_VAR([FTKLIB], [The PATH wherein libflaimtk.la can be found.])\nAC_ARG_VAR([FTKINC], [The PATH wherein flaimtk.h can be found.])\n\n# Ensure that both or neither FTK paths were specified.\nif { test -n \"$FTKLIB\" && test -z \"$FTKINC\"; } || \\\n   { test -z \"$FTKLIB\" && test -n \"$FTKINC\"; }; then\n  AC_MSG_ERROR([Specify both FTKINC and FTKLIB, or neither.])\nfi\n\n# Not specified? Check for FTK in standard places.\nif test -z \"$FTKLIB\"; then\n  # Check for FLAIM toolkit as a sub-project.\n  if test -d \"$srcdir/ftk\"; then\n    AC_CONFIG_SUBDIRS([ftk])\n    FTKINC='$(top_srcdir)/ftk/src'\n    FTKLIB='$(top_builddir)/ftk/src'\n  else\n    # Check for FLAIM toolkit as a superproject.\n if test -d \"$srcdir/../ftk\"; then\n      FTKINC='$(top_srcdir)/../ftk/src'\n      FTKLIB='$(top_builddir)/../ftk/src'\n    fi\n  fi\nfi\n\n# Still empty? Check for *installed* FLAIM toolkit.\nif test -z \"$FTKLIB\"; then\n  AC_CHECK_LIB([flaimtk], [ftkFastChecksum],\n    [AC_CHECK_HEADERS([flaimtk.h])\n     LIBS=\"-lflaimtk $LIBS\"],\n    [AC_MSG_ERROR([No FLAIM toolkit found. Terminating.])])\nfi\n\n# AC_SUBST command line variables from FTKLIB and FTKINC.\nif test -n \"$FTKLIB\"; then\n  AC_SUBST([FTK_LTLIB], [\"$FTKLIB/libflaimtk.la\"])\n  AC_SUBST([FTK_INCLUDE], [\"-I$FTKINC\"])\nfi\n--snip--\n```", "```\nAC_DEFUN([FLM_FTK_SEARCH],\n[AC_ARG_VAR([FTKLIB], [The PATH wherein libflaimtk.la can be found.])\nAC_ARG_VAR([FTKINC], [The PATH wherein flaimtk.h can be found.])\n--snip--\n# AC_SUBST command line variables from FTKLIB and FTKINC.\nif test -n \"$FTKLIB\"; then\n  AC_SUBST([FTK_LTLIB], [\"$FTKLIB/libflaimtk.la\"])\n AC_SUBST([FTK_INCLUDE], [\"-I$FTKINC\"])\nfi])\n```", "```\n   --snip--\n   # Add jni.h include directories to include search path\n   AX_JNI_INCLUDE_DIR\n   for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS; do\n     CPPFLAGS=\"$CPPFLAGS -I$JNI_INCLUDE_DIR\"\n   done\n\n➊ # Configure FTKLIB, FTKINC, FTK_LTLIB, and FTK_INCLUDE\n   FLM_FTK_SEARCH\n # Check for Java compiler.\n   --snip--\n```", "```\n# FLM_FTK_SEARCH\n# --------------\n# Define AC_ARG_VAR (user variables), FTKLIB, and FTKINC,\n# allowing the user to specify the location of the flaim toolkit\n# library and header file. If not specified, check for these files:\n#\n#   1\\. As a sub-project.\n#   2\\. As a super-project (sibling to the current project).\n#   3\\. As installed components on the system.\n#\n# If found, AC_SUBST FTK_LTLIB and FTK_INCLUDE variables with\n# values derived from FTKLIB and FTKINC user variables.\n# FTKLIB and FTKINC are file locations, whereas FTK_LTLIB and\n# FTK_INCLUDE are linker and preprocessor command line options.\n#\n# Author:   John Calcote <john.calcote@gmail.com>\n# Modified: 2009-08-30\n# License:  AllPermissive\n#\nAC_DEFUN([FLM_FTK_SEARCH],\n--snip--\n```", "```\n   --snip--\n   AC_SUBST([FTK_INCLUDE], [\"-I$FTKINC\"])\n➊ fi[]dnl\n   ])# FLM_FTK_SEARCH\n```", "```\n   # FLM_PROG_TRY_DOXYGEN([quiet])\n   # ------------------------------\n   # FLM_PROG_TRY_DOXYGEN tests for an existing doxygen source\n   # documentation program. It sets or uses the environment\n   # variable DOXYGEN.\n   #\n   # If no arguments are given to this macro, and no doxygen\n   # program can be found, it prints a warning message to STDOUT\n   # and to the config.log file. If the quiet argument is passed,\n   # then only the normal \"check\" line is displayed. Any other-token\n   # argument is considered by autoconf to be an error at expansion\n # time.\n   #\n   # Makes the DOXYGEN variable precious to Autoconf. You can\n   # use the DOXYGEN variable in your Makefile.in files with\n   # @DOXYGEN@.\n   #\n   # Author: John Calcote <john.calcote@gmail.com>\n   # Modified: 2009-08-30\n   # License: AllPermissive\n   #\n   AC_DEFUN([FLM_PROG_TRY_DOXYGEN],\n➊ [AC_ARG_VAR([DOXYGEN], [Doxygen source doc generation program])dnl\n➋ AC_CHECK_PROGS([DOXYGEN], [doxygen])\n➌ m4_ifval([$1],,\n➍ [if test -z \"$DOXYGEN\"; then\n     AC_MSG_WARN([doxygen not found - continuing without Doxygen support])\n   fi])\n   ])# FLM_PROG_TRY_DOXYGEN\n```", "```\n--snip--\nifelse ([$1],,\n[if test -z \"$DOXYGEN\"; then\nAC_MSG_WARN([Doxygen program not found - continuing without Doxygen])\nfi])\n--snip--\n```", "```\nm4_ifval([$1],[a],[b]])\nifelse([$1],[],[b],[a])\n```", "```\nm4_if(comment)\nm4_if(string-1, string-2, equal[, not-equal])\nm4_if(string-1, string-2, equal-1, string-3, string-4, equal-2,\n    ...[, not-equal])\n```", "```\n--snip--\nm4_if([$1],,\n[if test -z \"$DOXYGEN\"; then\n    AC_MSG_WARN([doxygen not found - continuing without Doxygen support])\nfi], [$1], [quiet],, [m4_fatal([Invalid option in FLM_PROG_TRY_DOXYGEN])])\n--snip--\n```", "```\nif $1 == '' then\n    Generate WARNING if no doxygen program is found\nelse if $1 == 'quiet' then\n    Don't generate any messages\nelse\n    Generate a fatal \"bad parameter\" error at autoconf (autoreconf) time\nend\n```", "```\nm4_traceon([name, ...])\nm4_traceoff([name, ...])\n```", "```\n   $ m4\n   define(`abc', `def')dnl\n   define(`def', `ghi')dnl\n   traceon(`abc', `def')dnl\n   abc\n➊ m4trace: -1- abc\n   m4trace: -1- def\n ghi\n   traceoff(`abc', `def')dnl\n➋ m4trace: -1- traceoff\n   <ctrl-d>$\n```", "```\n$ m4 --trace=abc\n```", "```\n$ autoconf --trace=FLM_PROG_TRY_DOXYGEN\n```"]