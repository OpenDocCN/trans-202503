<html><head></head><body>
<h2 class="h2"><a id="ch08"/><span epub:type="pagebreak" id="page_151"/><strong><span class="big">8</span></strong><br/><strong>TRANSPORT LAYER PROTOCOLS</strong></h2>&#13;
<div class="image"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindent"><span class="big1">In this chapter, we’ll continue to examine individual protocols and how they appear at the packet level. Moving up the OSI model, we’ll look at the transport layer and the two most common transport protocols, TCP and UDP.</span></p>&#13;
<h3 class="h3"><a id="ch08lev1sec1"/><strong>Transmission Control Protocol (TCP)</strong></h3>&#13;
<p class="noindent">The ultimate goal of the <em>Transmission Control Protocol (TCP)</em> is to provide endto-end reliability for the delivery of data. TCP, which is defined in RFC 793, handles data sequencing and error recovery, and ultimately ensures that data gets where it’s supposed to go. TCP is considered a <em>connection-oriented protocol</em> because it establishes a formal connection before transmitting data, tracks packet delivery, and usually attempts to formally close communication channels when transmission is complete. Many commonly used application-layer protocols rely on TCP and IP to deliver packets to their final destination.</p>&#13;
<h4 class="h4"><a id="ch08lev2sec1"/><span epub:type="pagebreak" id="page_152"/><strong><em>TCP Packet Structure</em></strong></h4>&#13;
<p class="noindenta">TCP provides a great deal of functionality, as reflected in the complexity of its header. As shown in <a href="ch08.xhtml#ch08fig1">Figure 8-1</a>, the following are the TCP header fields:</p>&#13;
<p class="noindentla"><strong>Source Port</strong>   The port used to transmit the packet.</p>&#13;
<p class="noindentla"><strong>Destination Port</strong>   The port to which the packet will be transmitted.</p>&#13;
<p class="noindentla"><strong>Sequence Number</strong>   The number used to identify a TCP segment. This field is used to ensure that parts of a data stream are not missing.</p>&#13;
<p class="noindentla"><strong>Acknowledgment Number</strong>   The sequence number that is to be expected in the next packet from the other device taking part in the communication.</p>&#13;
<p class="noindentla"><strong>Flags</strong>   The URG, ACK, PSH, RST, SYN, and FIN flags for identifying the type of TCP packet being transmitted.</p>&#13;
<p class="noindentla"><strong>Window Size</strong>   The size of the TCP receiver buffer in bytes.</p>&#13;
<p class="noindentla"><strong>Checksum</strong>   Used to ensure the contents of the TCP header and data are intact upon arrival.</p>&#13;
<p class="noindentla"><strong>Urgent Pointer</strong>   If the URG flag is set, this field is examined for additional instructions for where the CPU should begin reading the data within the packet.</p>&#13;
<p class="noindentla"><strong>Options</strong>   Various optional fields that can be specified in a TCP packet.</p>&#13;
<div class="image"><img alt="image" src="../images/f152-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig1"/><em>Figure 8-1: The TCP header</em></p>&#13;
<h4 class="h4"><a id="ch08lev2sec2"/><strong><em>TCP Ports</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>tcp_ports.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">All TCP communication takes place using source and destination <em>ports</em>, which can be found in every TCP header. A port is like the jack on an old telephone switchboard. A switchboard operator would monitor a board of lights and plugs. When a light lit up, he would connect with the caller, ask who she wanted to talk to, and then connect her to the other party by plugging in a cable. Every call needed to have a source port (the caller) and a destination port (the recipient). TCP ports work in much the same fashion.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_153"/>To transmit data to a particular application on a remote server or device, a TCP packet must know the port the remote service is listening on. If you try to access an application on a port other than the one configured for use, the communication will fail.</p>&#13;
<p class="indent">The source port in this sequence isn’t incredibly important and can be selected randomly. The remote server will simply determine the port to communicate with from the original packet it’s sent (see <a href="ch08.xhtml#ch08fig2">Figure 8-2</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f153-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig2"/><em>Figure 8-2: TCP uses ports to transmit data.</em></p>&#13;
<p class="indenta">There are 65,535 ports available for use when communicating with TCP. We typically divide these into two groups:</p>&#13;
<p class="bullet">•     The <em>system port group</em> (also known as the standard port or well-known port group) is from 1 through 1023 (ignoring 0 because it’s reserved). Well-known, established services generally use ports that lie within the system port grouping.</p>&#13;
<p class="bulleta">•     The <em>ephemeral port group</em> is from 1024 through 65535 (although some operating systems have different definitions for this). Only one service can communicate on a port at any given time, so modern operating systems select source ports randomly in an effort to make communications unique. These source ports are typically located in the ephemeral range.</p>&#13;
<p class="indent">Let’s examine a couple of TCP packets and identify the port numbers they are using by opening the file <em>tcp_ports.pcapng</em>. In this file, we have the HTTP communication of a client browsing to two websites. As mentioned previously, HTTP uses TCP for communication, making it a great example of standard TCP traffic.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>In the first packet in this file (see <a href="ch08.xhtml#ch08fig3">Figure 8-3</a>), the first two values represent the packet’s source port and destination port. This packet is being sent from 172.16.16.128 to 212.58.226.142. The source port is 2826 <span class="ent">➊</span>, an ephemeral port. (Remember that source ports are chosen at random by the operating system, although they can increment from that random selection.) The destination port is a system port, port 80 <span class="ent">➋</span>, the standard port used for web servers using HTTP.</p>&#13;
<div class="image"><img alt="image" src="../images/f154-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig3"/><em>Figure 8-3: The source and destination ports can be found in the TCP header.</em></p>&#13;
<p class="indent">Notice that Wireshark labels these ports as slc-systemlog (2826) and http (80). Wireshark maintains a list of ports and their most common uses. Although system ports are primarily the ones with labeled common uses, many ephemeral ports have commonly used services associated with them. The labeling of these ports can be confusing, so it’s typically best to disable it by turning off transport name resolution. To do this, go to <strong>Edit</strong> ▶ <strong>Preferences</strong> ▶ <strong>Name Resolution</strong> and uncheck Enable Transport Name Resolution. If you wish to leave this option enabled but want to change how Wireshark identifies a certain port, you can do so by modifying the <em>services</em> file located in the Wireshark system directory. The contents of this file are based on the IANA common ports listing (see “Using a Custom hosts File” on <a href="ch05.xhtml#page_86">page 86</a> for an example of how to edit a name resolution file).</p>&#13;
<p class="indent">The second packet is sent back from 212.58.226.142 to 172.16.16.128 (see <a href="ch08.xhtml#ch08fig4">Figure 8-4</a>). As with the IP addresses, the source and destination ports are now also switched <span class="ent">➊</span>.</p>&#13;
<p class="indent">In most cases, TCP-based communication works the same way: a random source port is chosen to communicate to a known destination port. Once this initial packet is sent, the remote device communicates with the source device using the established ports.</p>&#13;
<p class="indent">This sample capture file includes one more communication stream. See if you can locate the port numbers it uses for communication.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_155"/><img alt="image" src="../images/f155-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig4"/><em>Figure 8-4: Switching the source and destination port numbers for reverse communication</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>As we progress through this book, you’ll learn more about the ports associated with common protocols and services. Eventually, you’ll be able to profile services and devices by the ports they use. For a comprehensive list of common ports, look at the</em> services <em>file located in the Wireshark system directory.</em></p>&#13;
</div>&#13;
<h4 class="h4"><a id="ch08lev2sec3"/><strong><em>The TCP Three-Way Handshake</em></strong></h4>&#13;
<p class="noindenta">All TCP-based communication must begin with a <em>handshake</em> between two hosts. This handshake process serves several purposes:</p>&#13;
<p class="bullet">•     It allows the transmitting host to ensure that the recipient host is up and able to communicate.</p>&#13;
<p class="bullet">•     It lets the transmitting host check that the recipient is listening on the port the transmitting host is attempting to communicate on.</p>&#13;
<div class="note1">&#13;
<p class="noindent"><em>tcp_handshake.pcapng</em></p>&#13;
</div>&#13;
<p class="bullet">•     It allows the transmitting host to send its starting sequence number to the recipient so that both hosts can keep the stream of packets in proper sequence.</p>&#13;
<p class="indent">The TCP handshake occurs in three steps, as shown in <a href="ch08.xhtml#ch08fig5">Figure 8-5</a>. In the first step, the device that wants to communicate (host A) sends a TCP packet to its target (host B). This initial packet contains no data other than the lower-layer protocol headers. The TCP header in this packet has the SYN flag set and includes the initial sequence number and maximum segment size (MSS) that will be used for the communication process. Host B responds to this packet by sending a similar packet with the SYN and ACK flags set, along with its initial sequence number. Finally, host A sends one last packet to host B with only the ACK flag set. Once this process is completed, both devices should have all of the information they need to begin communicating properly.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_156"/><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>TCP packets are often referred to by the flags they have set. For example, rather than refer to a packet as a TCP packet with the SYN flag set, we call that packet a SYN packet. As such, the packets used in the TCP handshake process are referred to as SYN, SYN/ACK, and ACK.</em></p>&#13;
</div>&#13;
<p class="indent">To see this process in action, open <em>tcp_handshake.pcapng</em>. Wireshark includes a feature that replaces the sequence numbers of TCP packets with relative numbers for easier analysis. For our purposes, we’ll disable this feature in order to see the actual sequence numbers. To disable this, choose <strong>Edit</strong> ▶ <strong>Preferences</strong>, expand the <strong>Protocols</strong> heading, and choose <strong>TCP</strong>. In the window, uncheck the box next to <strong>Relative Sequence Numbers</strong> and click <strong>OK</strong>.</p>&#13;
<div class="image"><img alt="image" src="../images/f156-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig5"/><em>Figure 8-5: The TCP three-way handshake</em></p>&#13;
<p class="indent">The first packet in this capture represents our initial SYN packet <span class="ent">➋</span> (see <a href="ch08.xhtml#ch08fig6">Figure 8-6</a>). The packet is transmitted from 172.16.16.128 on port 2826 to 212.58.226.142 on port 80. We can see here that the sequence number transmitted is 3691127924 <span class="ent">➊</span>.</p>&#13;
<p class="indent">The second packet in the handshake is the SYN/ACK response <span class="ent">➌</span> from 212.58.226.142 (see <a href="ch08.xhtml#ch08fig7">Figure 8-7</a>). This packet also contains this host’s initial sequence number (233779340) <span class="ent">➊</span> and an acknowledgment number (3691127925) <span class="ent">➋</span>. The acknowledgment number shown here is 1 more than the sequence number included in the previous packet, because this field is used to specify the next sequence number the host expects to receive.</p>&#13;
<p class="indent">The final packet is the ACK <span class="ent">➋</span> packet sent from 172.16.16.128 (see <a href="ch08.xhtml#ch08fig8">Figure 8-8</a>). This packet, as expected, contains the sequence number 3691127925 <span class="ent">➊</span> as defined in the previous packet’s Acknowledgment number field.</p>&#13;
<p class="indent">A handshake occurs before every TCP communication sequence. When you are sorting through a busy capture file in search of the beginning of a communication sequence, the sequence SYN-SYN/ACK-ACK is a great marker.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_157"/><img alt="image" src="../images/f157-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig6"/><em>Figure 8-6: The initial SYN packet</em></p>&#13;
<div class="image"><img alt="image" src="../images/f157-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig7"/><em>Figure 8-7: The SYN/ACK response</em></p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_158"/><img alt="image" src="../images/f158-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig8"/><em>Figure 8-8: The final ACK</em></p>&#13;
<h4 class="h4"><a id="ch08lev2sec4"/><strong><em>TCP Teardown</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>tcp_teardown.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">Most greetings eventually have a good-bye and, in the case of TCP, every handshake has a teardown. The <em>TCP teardown</em> is used to gracefully end a connection between two devices after they have finished communicating. This process involves four packets, and it utilizes the FIN flag to signify the end of a connection.</p>&#13;
<p class="indent">In a teardown sequence, host A tells host B that it is finished communicating by sending a TCP packet with the FIN and ACK flags set. Host B responds with an ACK packet and transmits its own FIN/ACK packet. Host A responds with an ACK packet, ending the communication. This process is illustrated in <a href="ch08.xhtml#ch08fig9">Figure 8-9</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f158-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig9"/><em>Figure 8-9: The TCP teardown process</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_159"/>To view this process in Wireshark, open the file <em>tcp_teardown.pcapng</em>. Beginning with the first packet in the sequence (see <a href="ch08.xhtml#ch08fig10">Figure 8-10</a>), you can see that the device at 67.228.110.120 initiates teardown by sending a packet with the FIN and ACK flags set <span class="ent">➊</span>.</p>&#13;
<div class="image"><img alt="image" src="../images/f159-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig10"/><em>Figure 8-10: The FIN/ACK packet initiates the teardown process.</em></p>&#13;
<p class="indent">Once this packet is sent, 172.16.16.128 responds with an ACK packet to acknowledge receipt of the first packet, and it sends a FIN/ACK packet. The process is complete when 67.228.110.120 sends a final ACK. At this point, the communication between the two devices ends. If they need to begin communicating again, they will have to complete a new TCP handshake.</p>&#13;
<h4 class="h4"><a id="ch08lev2sec5"/><strong><em>TCP Resets</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>tcp_refuseconnection.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">In an ideal world, every connection would end gracefully with a TCP tear-down. In reality, connections often end abruptly. For example, a host may be misconfigured, or a potential attacker may perform a port scan. In these cases, when a packet is sent to a device that is not willing to accept it, a TCP packet with the RST flag set may be sent. The RST flag is used to indicate that a connection was closed abruptly or to refuse a connection attempt.</p>&#13;
<p class="indent">The file <em>tcp_refuseconnection.pcapng</em> displays an example of network traffic that includes an RST packet. The first packet in this file is from the host at 192.168.100.138, which is attempting to communicate with 192.168.100.1 on port 80. What this host doesn’t know is that 192.168.100.1 isn’t listening on port 80 because it’s a Cisco router with no web interface configured. There is no service configured to accept connections on that port. In response to this attempted communication, 192.168.100.1 sends a packet to 192.168.100.138 telling it that communication won’t be possible over <span epub:type="pagebreak" id="page_160"/>port 80. <a href="ch08.xhtml#ch08fig11">Figure 8-11</a> shows the abrupt end to this attempted communication in the TCP header of the second packet. The RST packet contains nothing other than RST and ACK flags <span class="ent">➊</span>, and no further communication follows.</p>&#13;
<div class="image"><img alt="image" src="../images/f160-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig11"/><em>Figure 8-11: The RST and ACK flags signify the end of communication.</em></p>&#13;
<p class="indent">An RST packet ends communication whether it arrives at the beginning of an attempted communication sequence, as in this example, or is sent in the middle of the communication between hosts.</p>&#13;
<h3 class="h3"><a id="ch08lev1sec2"/><strong>User Datagram Protocol (UDP)</strong></h3>&#13;
<div class="note1">&#13;
<p class="noindent"><em>udp_dnsrequest.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The <em>User Datagram Protocol (UDP)</em> is the other layer 4 protocol commonly used on modern networks. While TCP is designed for reliable data delivery with built-in error checking, UDP aims to provide speedy transmission. For this reason, UDP is a best-effort service, commonly referred to as a <em>connectionless protocol</em>. A connectionless protocol doesn’t formally establish and terminate a connection between hosts, unlike TCP with its handshake and teardown processes.</p>&#13;
<p class="indent">With a connectionless protocol, which doesn’t provide reliable services, it would seem that UDP traffic would be flaky at best. That would be true, except that the protocols that rely on UDP typically have their own built-in reliability services or use certain features of ICMP to make the connection somewhat more reliable. For example, the application-layer protocols DNS and DHCP, which are highly dependent on the speed of packet transmission across a network, use UDP as their transport layer protocol, but they handle error checking and retransmission timers themselves.</p>&#13;
<h4 class="h4"><a id="ch08lev2sec6"/><span epub:type="pagebreak" id="page_161"/><strong><em>UDP Packet Structure</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>udp_dnsrequest.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The UDP header is much smaller and simpler than the TCP header. As shown in <a href="ch08.xhtml#ch08fig12">Figure 8-12</a>, the following are the UDP header fields:</p>&#13;
<p class="noindentla"><strong>Source Port</strong>   The port used to transmit the packet</p>&#13;
<p class="noindentla"><strong>Destination Port</strong>   The port to which the packet will be transmitted</p>&#13;
<p class="noindentla"><strong>Packet Length</strong>   The length of the packet in bytes</p>&#13;
<p class="noindentla"><strong>Checksum</strong>   Used to ensure that the contents of the UDP header and data are intact upon arrival</p>&#13;
<div class="image"><img alt="image" src="../images/f161-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig12"/><em>Figure 8-12: The UDP header</em></p>&#13;
<p class="indent">The file <em>udp_dnsrequest.pcapng</em> contains one packet. This packet represents a DNS request, which uses UDP. When you expand the packet’s UDP header, you’ll see four fields (see <a href="ch08.xhtml#ch08fig13">Figure 8-13</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f161-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch08fig13"/><em>Figure 8-13: The contents of a UDP packet are very simple.</em></p>&#13;
<p class="indent">The key point to remember is that UDP does not care about reliable delivery. Therefore, any application that uses UDP must take special steps to ensure reliable delivery, if it is necessary. This is in contrast to TCP, which utilizes a formal connection setup and teardown, and has features in place to validate that packets were transmitted successfully.</p>&#13;
<p class="indent">This chapter has introduced you to the transport layer protocols TCP and UDP. Not unlike network protocols, TCP and UDP are at the core of most of your daily communication, and the ability to analyze them effectively is critical to becoming an effective packet analyst. In <a href="ch09.xhtml#ch09">Chapter 9</a>, we will look at common application-layer protocols.<span epub:type="pagebreak" id="page_162"/></p>&#13;
</body></html>