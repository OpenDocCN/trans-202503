<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch7">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch7">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_115" aria-label=" Page 115. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">MONGODB AND MONGOOSE</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">Most applications rely on a database management system, or <i>database</i> for short, to organize and grant access to a collection of datasets. In this chapter, you’ll work with the MongoDB non-relational database and Mongoose, its accompanying object mapper.</p>&#13;
<p class="TX">Because MongoDB returns data as JSON and uses JavaScript for database queries, it provides a natural choice for full-stack JavaScript developers. In the following sections, you’ll learn how to create a Mongoose model through which you can query your database, simplify your interactions with MongoDB, and craft middleware that connects your frontend to your backend database. You’ll also write service functions to implement the four CRUD operations on the database.</p>&#13;
<p class="TX">In <span class="Xref"><a href="#Exe7">Exercise 7</a> on page 125</span>, you’ll add a database to the GraphQL API you created in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, replacing its current static datastore.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-43"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_116" aria-label=" Page 116. "/><samp class="SANS_Futura_Std_Bold_B_11">How Apps Use Databases and Object-Relational Mappers</samp></h3>&#13;
<p class="TNI">An app needs a database to store and manipulate data. So far in this book, our app’s APIs returned only predefined datasets, saved in files, that couldn’t change. We used parameters in our requests to add to the dataset but couldn’t store the data between different API calls (called <i>persisting</i> the data). If we wanted to update the app’s weather information, for example, we’d need a database to persist the data so that the next API call could read it. In full-stack development, we commonly use databases to store user-related data. Another example of a database is the one that your email client uses to store your messages.</p>&#13;
<p class="TX">To work with a database, we first need to connect to it and authenticate with it. Once we have access to the data, we can execute queries to ask for certain datasets. The query returns the results containing data that our app can display or use in some other way. How each of these steps works in practice depends on the specific database in use.</p>&#13;
<p class="TX">Querying the data by using the database’s API tends to be clumsy because it usually requires a good amount of boilerplate code, even to simply establish and maintain the connection. Hence, we often use an <i>object-relational mapper</i> or <i>object data modeling tool</i>, which simplifies working with the databases by abstracting some of the details. For example, the Mongoose object data modeling tool for MongoDB handles database connections for us, saving us from having to check for an open database connection during each interaction.</p>&#13;
<p class="TX">Mongoose also makes it easier to handle the fact that MongoDB runs on a separate database server. Working with distributed systems requires making asynchronous calls, which you learned about in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>. With Mongoose, we can access the data with an object-oriented <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> interface instead of using clumsy callback functions.</p>&#13;
<p class="TX">In addition, MongoDB is schema-less; it doesn’t require us to predefine and strictly adhere to a schema. While convenient, this flexibility is also a common source of errors, especially in large-scale applications or projects with a rotating cast of developers. In <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, we discussed the benefits of adding types to JavaScript by using TypeScript. Mongoose types and verifies the integrity of MongoDB’s data models similarly, as you’ll discover in <span class="Xref">“Defining a Mongoose Model” on page 118</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-44"/><samp class="SANS_Futura_Std_Bold_B_11">Relational and Non-Relational Databases</samp></h3>&#13;
<p class="TNI">Databases can organize data in several ways, which fall into two main categories: relational and non-relational. <i>Relational databases</i>, such as MySQL and PostgreSQL, store data in one or more tables. You can think of these databases as resembling Excel spreadsheets. As in Excel, each table has a unique name and contains columns and rows. The columns define properties, such as the data type, for all data stored in the column, and the rows contain the actual datasets, each of which is identified by a unique ID. Relational databases use some variation of Structured Query Language (SQL) for their database operations.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_117" aria-label=" Page 117. "/>MongoDB is a <i>non-relational database</i>. Unlike traditional relational databases, it stores data as JSON documents instead of tables and doesn’t use SQL. Sometimes termed <i>NoSQL</i>, non-relational databases can store data in many different formats. For example, the popular NoSQL databases Redis and Memcached use key-value storage, which makes them highly performant and easily scalable. Thus, they’re often used as in-memory caches. Another NoSQL database, Neo4j, is a <i>graph database</i> that uses graph theory to store data as nodes, a concept we mentioned in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. These are just a few examples of non-relational databases.</p>&#13;
<p class="TX">MongoDB is the most widely used <i>document database</i>; instead of tables, rows, and columns, it organizes data in collections, documents, and fields. The <i>field</i> is the smallest unit in the database. It defines the data type and additional properties and contains the actual data. You can consider it the rough equivalent of a column in a SQL table. <i>Documents</i>, which are made of fields, are like rows in a SQL table. We sometimes call them records, and MongoDB uses <i>BSON</i>, a binary representation of a JSON object, to store them. A <i>collection</i> is roughly equivalent to a SQL table, but instead of rows and columns, it aggregates documents.</p>&#13;
<p class="TX">Because non-relational databases can store data in different formats, each database uses a specific, optimized query language for CRUD operations. These low-level APIs focus on accessing and manipulating the data, and not necessarily on the developer experience. By contrast, object-relational mappers provide a high-level abstraction with a clean and simplified interface to the query language. So, while MongoDB has the MongoDB Query Language (MQL), we’ll use Mongoose to access it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H1" id="sec3"><span id="h1-45"/><samp class="SANS_Futura_Std_Bold_B_11">Setting Up MongoDB and Mongoose</samp></h3>&#13;
<p class="TNI">Before you start using MongoDB and Mongoose, you must add them to your sample project. For the sake of simplicity, we’ll use an in-memory implementation of MongoDB rather than install and maintain a real database server on our machines. This is appropriate for testing the chapter’s examples, but not for deploying an actual application, as it does not persist the data between restarts. You’ll gain experience setting up a real MongoDB server when you build the Food Finder application in <span class="Xref"><a href="part2.xhtml">Part II</a></span>. <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> will show you how to use a pre-built Docker container that contains the MongoDB server.</p>&#13;
<p class="TX">Run this command in the root directory of the refactored Next.js app from <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>:</p>&#13;
&#13;
<pre class="pre-123"><code>$ <b>npm install mongodb-memory-server mongoose</b></code></pre>&#13;
<p class="TX">Then create two new folders in the root directory, next to the <i>package .json</i> file: one for the Mongoose code, called <i>mongoose</i>, with subfolder <i>weather</i>, and one called <i>middleware</i>, which will hold the necessary middleware.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H1" id="sec4"><span id="h1-46"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_118" aria-label=" Page 118. "/><samp class="SANS_Futura_Std_Bold_B_11">Defining a Mongoose Model</samp></h3>&#13;
<p class="TNI">In order to verify the integrity of our data, we must create a schema-based Mongoose <i>model</i>, which acts as a direct interface to a MongoDB collection in a database. All interactions with the database will happen through the model. Before we create the model, though, we need to create the schema itself, which defines the structure of the database’s data and maps the Mongoose instance to the documents in the collection.</p>&#13;
<p class="TX">Our Mongoose schema will match the schema created for the GraphQL API in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. That’s because we’ll connect the GraphQL API to the database in <span class="Xref"><a href="#Exe7">Exercise 7</a> on page 125</span>, allowing us to replace the static JSON object with datasets we queried from the database.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-99"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Interface</samp></h4>&#13;
<p class="TNI">Before writing the Mongoose model and schema in TypeScript, let’s declare a TypeScript interface. Without a matching interface, we won’t be able to type the model or schema for TSC, and the code won’t compile. Paste the code shown in <a href="chapter7.xhtml#Lis7-1">Listing 7-1</a> into the <i>mongoose/weather/interface.ts</i> file.</p>&#13;
<span id="Lis7-1"/>&#13;
<pre class="pre-124"><code>export declare interface WeatherInterface {&#13;
    zip: string;&#13;
    weather: string;&#13;
    tempC: string;&#13;
    tempF: string;&#13;
    friends: string[];&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-1: The interface for the Mongoose weather model</span></p>&#13;
<p class="TX">The code is a regular TypeScript interface with properties matching the GraphQL and Mongoose schemas.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-100"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Schema</samp></h4>&#13;
<p class="TNI"><a href="chapter7.xhtml#Lis7-2">Listing 7-2</a> shows the Mongoose schema. Its top-level properties represent the fields in the document. Each field has a type and a flag indicating whether it is required. Fields can also have additional optional properties, such as custom or built-in validators. Here we use the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">required</samp> validator; other common built-in validators are <samp class="SANS_TheSansMonoCd_W5Regular_11">minlength</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">maxlength</samp> for strings, and <samp class="SANS_TheSansMonoCd_W5Regular_11">min</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp> for numbers. Add the code to the <i>mongoose/weather/schema.ts</i> file.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_119" aria-label=" Page 119. "/>&#13;
<span id="Lis7-2"/>&#13;
<pre class="pre-125"><code>import {Schema} from "mongoose";&#13;
import {WeatherInterface} from "./interface";&#13;
&#13;
export const WeatherSchema = new Schema&lt;WeatherInterface&gt;({&#13;
    zip: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    weather: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    tempC: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    tempF: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    friends: {&#13;
        type: ["String"],&#13;
        required: true,&#13;
    },&#13;
});&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-2: The schema for the Mongoose weather model</span></p>&#13;
<p class="TX">We use an object passed to the schema constructor to create the schema and set <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp> as its SchemaType. Therefore, we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schema</samp> function from the <i>mongoose</i> package and the interface we created previously.</p>&#13;
<p class="TX">Like TypeScript, which adds custom types to JavaScript, Mongoose casts each property to its associated <i>SchemaType</i>, which provides the configuration of the model. The available types are a mixture of built-in JavaScript types, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Date</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Number</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>, and custom types, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectId</samp>, the latter of which refers to the default unique <samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp> property that Mongoose adds to each document upon creation. This is similar to the primary key you might know from relational databases.</p>&#13;
<p class="TX">The weather API we created in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> returned an object with four properties: <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tempF</samp>, each of which is a string. In addition, we have one array of strings in the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp> property. In this schema, we define the same properties, then export the schema.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-101"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Model</samp></h4>&#13;
<p class="TNI">Now that we have a schema, we can create the Mongoose model. This wrapper on the schema will provide access to the MongoDB documents in the collection for all CRUD operations. We write the model in the <i>mongoose/weather/model.ts</i> file, whose code is in <a href="chapter7.xhtml#Lis7-3">Listing 7-3</a>. Keep in mind that we haven’t yet connected it to the MongoDB database on the server.</p>&#13;
<span id="Lis7-3"/>&#13;
<pre class="pre-126"><code>import mongoose, {model} from "mongoose";&#13;
import {WeatherInterface} from "./interface";&#13;
import {WeatherSchema} from "./schema";&#13;
&#13;
export default mongoose.models.Weather ||&#13;
    model&lt;WeatherInterface&gt;("Weather", WeatherSchema);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-3: The Mongoose weather model</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_120" aria-label=" Page 120. "/>First we import the Mongoose module and the model constructor from the <i>mongoose</i> package, as well as the interface and the schema we created earlier. Then we set up the <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp> model, using <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp> to type it. We pass it two parameters: the model’s name, <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>, and the schema, which defines the model’s internal data structure. Mongoose binds the newly created model to our MongoDB instance’s collection. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Weathers</samp> collection resides in the <i>Weather</i> database, both of which Mongoose creates. Note that we need to check for an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp> model on <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.models</samp> before creating a new one; otherwise, Mongoose will throw an error. We export the model so that we can use it in our following modules.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-102"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Database-Connection Middleware</samp></h4>&#13;
<p class="TNI">Several times in this book so far, we’ve mentioned that full-stack development covers an application’s frontend, backend, and middleware, which is often also referred to as “application glue.” Now it’s time to create our first dedicated middleware.</p>&#13;
<p class="TX">This middleware will open a connection to the database, then use Mongoose’s asynchronous helper function to maintain that connection. Next, it will map Mongoose’s models to the MongoDB collections so that we can access them through Mongoose. Conveniently, the connection helper will buffer the operations and reconnect to the database if necessary, so we don’t need to handle connectivity issues by ourselves. Paste the code from <a href="chapter7.xhtml#Lis7-4">Listing 7-4</a> into the <i>middleware/db-connect.ts</i> file.</p>&#13;
<span id="Lis7-4"/>&#13;
<pre class="pre-127"><code>import mongoose from "mongoose";&#13;
import {MongoMemoryServer} from "mongodb-memory-server";&#13;
&#13;
async function dbConnect(): Promise&lt;any | String&gt; {&#13;
    const mongoServer = await MongoMemoryServer.create();&#13;
    const MONGOIO_URI = mongoServer.getUri();&#13;
    await mongoose.disconnect();&#13;
    await mongoose.connect(MONGOIO_URI, {&#13;
        dbName: "Weather"&#13;
    });&#13;
}&#13;
&#13;
export default dbConnect;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-4: The Mongoose middleware</span></p>&#13;
<p class="TX">We import the <i>mongoose</i> package and the <i>mongodb-memory-server</i> database. The async function <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>, which we define and then export, manages the connection to the database server through the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.connect</samp> function. We create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">MongoMemoryServer</samp> to persist our data in memory rather than use a real database server, as discussed. Then we store the connection string in the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGOIO_URI</samp>. Because we are using the in-memory server, this string is dynamic, but for a remote database, it would be a static string representing the database’s server address. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_121" aria-label=" Page 121. "/>Then we close all existing connections and use Mongoose to open a new connection. The Mongoose models are already mapped and available, so we’re ready to perform our first queries.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-47"/><samp class="SANS_Futura_Std_Bold_B_11">Querying the Database</samp></h3>&#13;
<p class="TNI">Now it’s time to write database queries. Instead of sprinkling these queries around your application code or writing them directly in the GraphQL resolvers, you should extract them as services.</p>&#13;
<p class="TX">A <i>service</i> is a function that performs the actual CRUD operations on the Mongoose model and returns the result. Each GraphQL resolver can then call a service function, and all internal database access should happen through these functions. Moreover, each service should be responsible for only one specific CRUD operation. Mongoose automatically queues the commands and executes them, maintains the connection, and then processes the queue as soon as there is a connection to the database.</p>&#13;
<p class="TX">This section introduces service functions and basic Mongoose commands. However, it isn’t a complete reference. When you start working with Mongoose on your own projects, look up all the functions you’ll need in the Mongoose documentation.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-103"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Document</samp></h4>&#13;
<p class="TNI">The first and most basic operation is the “create” operation. It is conveniently called <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.create</samp> and, fortunately, we can use it to both create and update a dataset. That’s because Mongoose automatically creates a new database entry, or document, if the entry doesn’t already exist. Hence, we don’t need to check whether a dataset exists and then conditionally create it before updating it.</p>&#13;
<p class="TX"><a href="chapter7.xhtml#Lis7-5">Listing 7-5</a> shows a basic implementation of a service function that stores a dataset in the database. Place the code in the <i>mongoose/weather/ services.ts</i> file.</p>&#13;
<span id="Lis7-5"/>&#13;
<pre class="pre-128"><code>import WeatherModel from "./model";&#13;
import {WeatherInterface} from "./interface";&#13;
&#13;
export async function storeDocument(doc: WeatherInterface): Promise&lt;boolean&gt; {&#13;
    try {&#13;
        await WeatherModel.create(doc);&#13;
    } catch (error) {&#13;
        return false;&#13;
    }&#13;
    return true;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-5: Creating a document through Mongoose</span></p>&#13;
<p class="TX">To store a document, we create and export the async function <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocument</samp>, which takes the dataset as the argument. Here we type it <span role="doc-pagebreak" epub:type="pagebreak" id="pg_122" aria-label=" Page 122. "/>as <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>. Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> function on the model and pass the dataset to it. The function will create and insert the document in <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>, which is the weather collection in the MongoDB instance. Finally, it returns a Boolean to indicate the status of the operation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-104"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading a Document</samp></h4>&#13;
<p class="TNI">To implement the “read” operation, we query MongoDB through Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp> function. It takes one argument, an object with the properties to look for, and returns the first match. Extend the <i>mongoose/weather/services.ts</i> file with the code in <a href="chapter7.xhtml#Lis7-6">Listing 7-6</a>. It defines a <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> function to find and return the first document from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Weathers</samp> collection whose <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> property matches the ZIP code passed to the function as a parameter.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_123" aria-label=" Page 123. "/>&#13;
<span id="Lis7-6"/>&#13;
<pre class="pre-129"><code>export async function findByZip(&#13;
    paramZip: string&#13;
): Promise&lt;Array&lt;WeatherInterface&gt; | null&gt; {&#13;
    try {&#13;
        return await WeatherModel.findOne({zip: paramZip});&#13;
    } catch (err) {&#13;
        console.log(err);&#13;
    }&#13;
    return [];&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-6: Reading data through Mongoose</span></p>&#13;
<p class="TX">We add and export the async function <samp class="SANS_TheSansMonoCd_W5Regular_11">readByZip</samp> to the services in the <i>services.ts</i> file. The function takes one string parameter, the ZIP code, and returns either an array with documents or an empty array. Inside the new service function, we call Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp> function on the model and pass a filter object, looking for the document whose <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> field matches the parameter’s value. Finally, the function returns the result or <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2" id="sec12"><span id="h2-105"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating a Document</samp></h4>&#13;
<p class="TNI">We mentioned that we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> function to update documents. However, there is also a specific API for this task: <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp>. It takes two arguments. The first is the filter object, similar to the filter we used with <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp>, and the second is an object with the new values. You can think of <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp> as a combination of the “find” and “create” functions. Extend the <i>mongoose/weather/services.ts</i> file with the code from <a href="chapter7.xhtml#Lis7-7">Listing 7-7</a>.</p>&#13;
<span id="Lis7-7"/>&#13;
<pre class="pre-130"><code>export async function updateByZip(&#13;
    paramZip: string,&#13;
    newData: WeatherInterface&#13;
): Promise&lt;boolean&gt; {&#13;
    try {&#13;
        await WeatherModel.updateOne({zip: paramZip}, newData);&#13;
        return true;&#13;
    } catch (err) {&#13;
        console.log(err);&#13;
    }&#13;
    return false;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-7: Updating data through Mongoose</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">updateByZip</samp> function that we add to the services takes two parameters. The first one is a string, <samp class="SANS_TheSansMonoCd_W5Regular_11">paramZip</samp>, which is the ZIP code we use to query for the document we want to update. The second parameter is the new dataset, which we type as <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>. We call Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp> function on the model, passing it a filter object and the latest data. The function should return a Boolean to indicate the status.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-106"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Deleting a Document</samp></h4>&#13;
<p class="TNI">The last CRUD operation we need to implement is a service to delete a document. For this, we use Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteOne</samp> function and add the code from <a href="chapter7.xhtml#Lis7-8">Listing 7-8</a> to the <i>mongoose/weather/services.ts</i> file. It is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp> function, except that it directly deletes the query’s result. Mongoose queues the operations and deletes the document from the database automatically once there is a connection.</p>&#13;
<span id="Lis7-8"/>&#13;
<pre class="pre-131"><code>export async function deleteByZip(&#13;
        paramZip: string&#13;
    ): Promise&lt;boolean&gt; {&#13;
    try {&#13;
        await WeatherModel.deleteOne({zip: paramZip});&#13;
        return true;&#13;
    } catch (err) {&#13;
        console.log(err);&#13;
    }&#13;
    return false;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-8: Deleting data through Mongoose</span></p>&#13;
<p class="TX">The async function <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteByZip</samp> takes one string parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>. We use it to query the model and find the document to delete, passing the filter to Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteOne</samp> function. The function should return a Boolean.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H1" id="sec14"><span id="h1-48"/><samp class="SANS_Futura_Std_Bold_B_11">Creating an End-to-End Query</samp></h3>&#13;
<p class="TNI">In full-stack development, <i>end-to-end</i> typically refers to the ability of data to travel all the way from the app’s frontend (or from one of its APIs) through the middleware to the backend, and then all the way back to its original source. For practice, let’s create a simple end-to-end example using the <i>/zipcode</i> endpoint of our REST API.</p>&#13;
<p class="TX">We’ll modify the API to take the query parameter from the URL, find the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> object for the requested ZIP code in the database, and then <span role="doc-pagebreak" epub:type="pagebreak" id="pg_124" aria-label=" Page 124. "/>return it, effectively replacing the static JSON response with a dynamic query result. Modify the file <i>pages/api/v1/weather/[zipcode].ts</i> to match <a href="chapter7.xhtml#Lis7-9">Listing 7-9</a>.</p>&#13;
<span id="Lis7-9"/>&#13;
<pre class="pre-132"><code>import type {NextApiRequest, NextApiResponse} from "next";&#13;
<b>import {findByZip} from "./../../../../mongoose/weather/services";</b>&#13;
import dbConnect from "./../../../..//middleware/db-connect";&#13;
<b>dbConnect();</b>&#13;
&#13;
export default async function handler(&#13;
    req: NextApiRequest,&#13;
    res: NextApiResponse&#13;
): Promise&lt;NextApiResponse&lt;WeatherDetailType&gt; | void&gt; {&#13;
<b>    let data </b><b>= await findByZip(req.query.zipcode as string);</b>&#13;
    return res.status(200).json(<b>data</b>);&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-9: The end-to-end REST API</span></p>&#13;
<p class="TX">Notice the modified API handler. We made two major changes to it. First we called <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> to connect to the database. Then we used the imported <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> service and passed it the query parameter cast to a string type. Instead of the static JSON object as before, we now return the dynamic <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> that we receive from the service function.</p>&#13;
<p class="TX">We need to perform one more step before we can receive data in response to the API call: <i>seeding</i> the database, or adding initial datasets to it. For simplicity, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocuments</samp> service and seed directly in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function. Modify the <i>middleware/db-connect.ts</i> file to match the code in <a href="chapter7.xhtml#Lis7-10">Listing 7-10</a>, which imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocument</samp> service and adds the datasets after establishing the database connection.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_125" aria-label=" Page 125. "/>&#13;
<span id="Lis7-10"/>&#13;
<pre class="pre-133"><code>import mongoose from "mongoose";&#13;
import {MongoMemoryServer} from "mongodb-memory-server";&#13;
<b>import {storeDocument} from </b><b>"</b><b>../mongoose/weather/services</b><b>"</b><b>;</b>&#13;
&#13;
async function dbConnect(): Promise&lt;any | String&gt; {&#13;
    const mongoServer = await MongoMemoryServer.create();&#13;
    const MONGOIO_URI = mongoServer.getUri();&#13;
    await mongoose.disconnect();&#13;
&#13;
    let db = await mongoose.connect(MONGOIO_URI, {&#13;
        dbName: "Weather"&#13;
    });&#13;
&#13;
    <b>await storeDocument({</b>&#13;
<b>    </b>    <b>zip: </b><b>"</b><b>96815</b><b>"</b><b>,</b>&#13;
<b>    </b>    <b>weather: </b><b>"</b><b>sunny</b><b>"</b><b>,</b>&#13;
<b>    </b>    <b>tempC: </b><b>"</b><b>25C</b><b>"</b><b>,</b>&#13;
<b>  </b>      <b>tempF: </b><b>"</b><b>70F</b><b>"</b><b>,</b>&#13;
    <b>    friends: [</b><b>"</b><b>96814</b><b>"</b><b>, </b><b>"</b><b>96826</b><b>"</b><b>]</b>&#13;
    <b>});</b>&#13;
    <b>await storeDocument({</b>&#13;
    <b>    zip: </b><b>"</b><b>96814</b><b>"</b><b>,</b>&#13;
    <b>    weather: </b><b>"</b><b>rainy</b><b>"</b><b>,</b>&#13;
    <b>    tempC: </b><b>"</b><b>20C</b><b>"</b><b>,</b>&#13;
    <b>    tempF: </b><b>"</b><b>68F</b><b>"</b><b>,</b>&#13;
    <b>    friends: [</b><b>"</b><b>96815</b><b>"</b><b>, </b><b>"</b><b>96826</b><b>"</b><b>]</b>&#13;
    <b>});</b>&#13;
    <b>await storeDocument({</b>&#13;
        <b>zip: </b><b>"</b><b>96826</b><b>"</b><b>,</b>&#13;
    <b>    weather: </b><b>"</b><b>rainy</b><b>"</b><b>,</b>&#13;
<b>  </b>      <b>tempC: </b><b>"</b><b>30C</b><b>"</b><b>,</b>&#13;
<b>  </b>      <b>tempF: </b><b>"</b><b>86F</b><b>"</b><b>,</b>&#13;
<b>  </b>      <b>friends: [</b><b>"</b><b>96815</b><b>"</b><b>, </b><b>"</b><b>96814</b><b>"</b><b>]</b>&#13;
    <b>});</b>&#13;
&#13;
}&#13;
export default dbConnect;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-10: The naive data seeding in the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dbConnect</samp> <span class="Futura_Std_Book_Oblique_BI_11">function</span></p>&#13;
<p class="TX">Now we can perform the end-to-end request. Visit the REST API endpoint in the browser at <i>http://localhost:3000/api/v1/weather/96815</i>. You should see the dataset from the MongoDB database as the API response. Try adjusting the query parameter in the URL to another valid ZIP code. You should get another dataset in the response.</p>&#13;
<p class="HeadProject"><span id="Exe7"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 7: Connect the GraphQL API to the Database</samp></p>&#13;
<p class="TNI">Let’s rework our weather application’s GraphQL API so that it reads the response data from the database instead of from a static JSON file. The code will look familiar, as we’ll use the same patterns as for the REST API example in the preceding section.</p>&#13;
<p class="TX">First, verify that you’ve added the MongoDB memory implementation and Mongoose to your project. If not, add them now by following the instructions in <span class="Xref">“Setting Up MongoDB and Mongoose” on page 117</span>. Next, check that you’ve created the files in the <i>middleware</i> and <i>mongoose</i> folders described throughout this chapter and that they contain the code from <a href="chapter7.xhtml#Lis7-1">Listings 7-1</a> through <a href="chapter7.xhtml#Lis7-10">7-10</a>.</p>&#13;
<p class="TX">Now, to connect the GraphQL API to the database, we need to do two things: implement the database connection and refactor the GraphQL resolvers to use its datasets.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-107"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Connecting to the Database</samp></h4>&#13;
<p class="TNI">To query the database through the GraphQL API, we need to have a connection to the database. As you learned in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, all API calls have the same endpoint, <i>/graphql</i>. This fact will now prove incredibly convenient for us; because all requests have the same entry point, we need to handle the database connection only once. Hence, we open the file <i>api/graphql.ts</i> and modify it to match the code in <a href="chapter7.xhtml#Lis7-11">Listing 7-11</a>.</p>&#13;
<span id="Lis7-11"/>&#13;
<pre class="pre-134"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_126" aria-label=" Page 126. "/>import {ApolloServer} from "@apollo/server";&#13;
import {startServerAndCreateNextHandler} from "@as-integrations/next";&#13;
import {resolvers} from "../../graphql/resolvers";&#13;
import {typeDefs} from "../../graphql/schema";&#13;
import {NextApiHandler, NextApiRequest, NextApiResponse} from "next";&#13;
<b>import dbConnect from "../../middleware/db-connect";</b>&#13;
//@ts-ignore&#13;
const server = new ApolloServer({&#13;
    resolvers,&#13;
    typeDefs&#13;
});&#13;
&#13;
const handler = startServerAndCreateNextHandler(server);&#13;
&#13;
const allowCors = (fn: NextApiHandler) =&gt;&#13;
    async (req: NextApiRequest, res: NextApiResponse) =&gt; {&#13;
        res.setHeader("Allow", "POST");&#13;
        res.setHeader("Access-Control-Allow-Origin", "*");&#13;
        res.setHeader("Access-Control-Allow-Methods", "POST");&#13;
        res.setHeader("Access-Control-Allow-Headers", "*");&#13;
        res.setHeader("Access-Control-Allow-Credentials", "true");&#13;
&#13;
        if (req.method === "OPTIONS") {&#13;
            res.status(200).end();&#13;
        }&#13;
        return await fn(req, res);&#13;
    };&#13;
&#13;
<b>const connectDB =</b> (fn: NextApiHandler) =&gt;&#13;
    async (req: NextApiRequest, res: NextApiResponse) =&gt; {&#13;
<b>    </b>    <b>await dbConnect();</b>&#13;
        return await fn(req, res);&#13;
    };&#13;
&#13;
export default <b>connectDB(</b>allowCors(handler)<b>)</b>;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-11: The</span> <span class="Futura_Std_Book_11">api/graphql.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file including a connection to the database</span></p>&#13;
<p class="TX">We made three changes to the file. First we imported the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function from the middleware; then we created a new wrapper similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">allowCors</samp> function and used it to ensure that each API call connects to the API. We could safely do so because we implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> to enforce only one database connection at the same time. Finally, we wrapped the handler with the new wrapper and exported it as the default.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2" id="sec16"><span id="h2-108"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Services to GraphQL Resolvers</samp></h4>&#13;
<p class="TNI">Now it’s time to add the services to the resolvers. In <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, you learned that query resolvers implement the reading of data, whereas mutation resolvers implement the creation, updating, and deletion of data.</p>&#13;
<p class="TX">There, we also defined two resolvers: one to return a weather object for a given ZIP code and one to update a location’s weather data. Now we’ll add the services <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">updateByZip</samp>, which we created in this chapter, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_127" aria-label=" Page 127. "/>to the resolvers. Instead of the na<span class="accent">ï</span>ve implementations with the static data object, we modify the resolvers to query and update the MongoDB documents through the services.</p>&#13;
<p class="TX"><a href="chapter7.xhtml#Lis7-12">Listing 7-12</a> shows the modified code for the <i>graphql/resolvers.ts</i> file in which we refactor these two resolvers.</p>&#13;
<span id="Lis7-12"/>&#13;
<pre class="pre-135"><code>import {WeatherInterface} from "../mongoose/weather/interface";&#13;
<b>import {findByZip, updateByZip} from </b><b>"</b><b>../mongoose/weather/services</b><b>"</b><b>;</b>&#13;
&#13;
export const resolvers = {&#13;
    Query: {&#13;
        weather: async (_: any, param: WeatherInterface) =&gt; {&#13;
            let data = <b>await findByZip(param.zip)</b>;&#13;
            return [data];&#13;
        },&#13;
    },&#13;
    Mutation: {&#13;
        weather: async (_: any, param: {data: WeatherInterface}) =&gt; {&#13;
            <b>await updateByZip(param.data.zip, param.data</b>);&#13;
            let data = await findByZip(param.data.zip);&#13;
            return [data];&#13;
        },&#13;
    },&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 7-12: The</span> <span class="Futura_Std_Book_11">graphql/resolvers.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file using services</span></p>&#13;
<p class="TX">We replace the na<span class="accent">i</span>ve <samp class="SANS_TheSansMonoCd_W5Regular_11">array.filter</samp> functionality with the appropriate services. To query the data, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> service and pass it the <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> variable from the request payload and then return the result data wrapped in an array. For the mutation, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateByZip</samp> service. Per type definition, the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> mutation returns the updated dataset. To do so, we query for the modified document with the <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> service once again and return the result as an array item.</p>&#13;
<p class="TX">Visit the GraphQL sandbox at <i>http://localhost:3000/api/graphql</i> and play with the API endpoints to read and update documents from the MongoDB database.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H1" id="sec17"><span id="h1-49"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you explored using the non-relational database MongoDB and its Mongoose object data modeling tool, which lets you add and enforce schemas as well as perform CRUD operations on MongoDB instances. We covered the differences between relational and non-relational databases and how they store data. Then you created a Mongoose schema and a model, connected Mongoose to the MongoDB instance, and wrote the services to perform operations on the MongoDB collection.</p>&#13;
<p class="TX">Finally, you connected the REST and GraphQL APIs to the MongoDB database. Now, instead of static datasets, all of your APIs return dynamic documents, and you can both read and update documents through them.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_128" aria-label=" Page 128. "/>MongoDB and Mongoose are extensive technologies with a huge array of functionalities. To learn more about them, consult the official documentation at <a href="https://mongoosejs.com"><i>https://<wbr/>mongoosejs<wbr/>.com</i></a> and read the articles at <a href="https://www.geeksforgeeks.org/mongoose-module-introduction"><i>https://<wbr/>www<wbr/>.geeksforgeeks<wbr/>.org<wbr/>/mongoose<wbr/>-module<wbr/>-introduction</i></a>/.</p>&#13;
<p class="TX">The next chapter covers Jest, a modern testing framework for conducting unit, snapshot, and integration tests.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>