<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_63"/><span class="big">2</span><br/>A DEEPER DIVE INTO C PROGRAMMING</h2>&#13;
<div class="imagec"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindents">With many of the basics of C programming covered in the previous chapter, we now dive deeper into the details of C. In this chapter we revisit many of the topics from the previous chapter, such as arrays, strings, and structs, discussing them in more detail. We also introduce C’s pointer variables and dynamic memory allocation. <em>Pointers</em> provide a level of indirection to accessing program state, and <em>dynamic memory allocation</em> allows a program to adjust to changes in size and space needs as it runs, allocating more space as it needs it and freeing space it no longer needs. By understanding how and when to use pointer variables and dynamic memory allocation, a C programmer can design programs that are both powerful and efficient.</p>&#13;
<p class="indent">We begin with a discussion of the parts of program memory, as this will help in understanding many of the topics presented later. As the chapter <span epub:type="pagebreak" id="page_64"/>progresses, we cover C file I/O and some advanced C topics including library linking and compiling to assembly code.</p>&#13;
<h3 class="h3" id="lev1_9">2.1 Parts of Program Memory and Scope</h3>&#13;
<p class="noindent">The following C program shows examples of functions, parameters, and local and global variables (function comments are omitted to shorten this code listing):</p>&#13;
<p class="programs">/* An example C program with local and global variables */<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int max(int n1, int n2); /* function prototypes */<br/>&#13;
int change(int amt);<br/>&#13;
<br/>&#13;
int g_x;  /* global variable: declared outside function bodies */<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int x, result;   /* local variables: declared inside function bodies */<br/>&#13;
<br/>&#13;
    printf("Enter a value: ");<br/>&#13;
    scanf("%d", &amp;x);<br/>&#13;
    g_x = 10;       /* global variables can be accessed in any function */<br/>&#13;
<br/>&#13;
    result = max(g_x, x);<br/>&#13;
    printf("%d is the largest of %d and %d\n", result, g_x, x);<br/>&#13;
<br/>&#13;
    result = change(10);<br/>&#13;
    printf("g_x's value was %d and now is %d\n", result, g_x);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int max(int n1, int n2) {  /* function with two parameters */<br/>&#13;
    int val;    /* local variable */<br/>&#13;
<br/>&#13;
    val = n1;<br/>&#13;
    if ( n2 &gt; n1 ) {<br/>&#13;
        val = n2;<br/>&#13;
    }<br/>&#13;
    return val;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int change(int amt) {<br/>&#13;
    int val;<br/>&#13;
<br/>&#13;
    val = g_x;  /* global variables can be accessed in any function */<br/>&#13;
    g_x += amt;<br/>&#13;
<span epub:type="pagebreak" id="page_65"/>&#13;
    return val;<br/>&#13;
}</p>&#13;
<p class="indent">This example shows program variables with different scope. A variable’s <em>scope</em> defines when its name has meaning. In other words, scope defines the set of program code blocks in which a variable is bound to (associated with) a program memory location and can be used by program code.</p>&#13;
<p class="indent">Declaring a variable outside of any function body creates a <em>global variable</em>. Global variables remain permanently in scope and can be used by any code in the program because they’re always bound to one specific memory location. Every global variable must have a unique name—its name uniquely identifies a specific storage location in program memory for the entire duration of the program.</p>&#13;
<p class="indent"><em>Local variables and parameters</em> are only in scope inside the function in which they are defined. For example, the <span class="literal">amt</span> parameter is in scope only inside the <span class="literal">change</span> function. This means that only statements within the <span class="literal">change</span> function body can access the <span class="literal">amt</span> parameter, and an instance of the <span class="literal">amt</span> parameter is bound to a specific memory storage location only within a specific active execution of the function. Space to store a parameter’s value is allocated on the stack when the function gets called, and it is deallocated from the stack when the function returns. Each activation of a function gets its own bindings for its parameters and local variables. Thus, for recursive function calls, each call (or activation) gets a separate stack frame containing space for its parameters and local variables.</p>&#13;
<p class="indent">Because parameters and local variables are only in scope inside the function that defines them, different functions can use the same names for local variables and parameters. For example, both the <span class="literal">change</span> and the <span class="literal">max</span> functions have a local variable named <span class="literal">val</span>. When code in the <span class="literal">max</span> function refers to <span class="literal">val</span> it refers to its local variable <span class="literal">val</span> and not to the <span class="literal">change</span> function’s local variable <span class="literal">val</span> (which is not in scope inside the <span class="literal">max</span> function).</p>&#13;
<p class="indent">While there may occasionally be times when using global variables in C programs is necessary, we strongly recommend that you <em>avoid programming with global variables whenever possible</em>. Using only local variables and parameters yields code that’s more modular, more general-purpose, and easier to debug. Also, because a function’s parameters and local variables are only allocated in program memory when the function is active, they may result in more space-efficient programs.</p>&#13;
<p class="indent">Upon launching a new program, the operating system allocates the new program’s address space. A program’s <em>address space</em> (or memory space) represents storage locations for everything it needs in its execution, namely storage for its instructions and data. A program’s address space can be thought of as an array of addressable bytes; each used address in the program’s address space stores all or part of a program instruction or data value (or some additional state necessary for the program’s execution).</p>&#13;
<p class="indent">A program’s memory space is divided into several parts, each of which is used to store a different kind of entity in the process’s address space. <a href="ch02.xhtml#ch2fig1">Figure 2-1</a> illustrates the parts of a program’s memory space.</p>&#13;
<span epub:type="pagebreak" id="page_66"/>&#13;
<div class="imagec" id="ch2fig1"><img alt="image" src="../images/02fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-1: The parts of a program’s address space</em></p>&#13;
<p class="indent">The top of a program’s memory is reserved for use by the operating system, but the remaining parts are usable by the running program. The program’s instructions are stored in the <em>code</em> section of the memory. For example, the program listed earlier stores instructions for the <span class="literal">main</span>, <span class="literal">max</span>, and <span class="literal">change</span> functions in this region of memory.</p>&#13;
<p class="indent">Local variables and parameters reside in the portion of memory for the <em>stack</em>. Because the amount of stack space grows and shrinks over the program’s execution as functions are called and returned from, the stack part of memory is typically allocated near the bottom of memory (at the highest memory addresses) to leave space for it to change. Stack storage space for local variables and parameters exists only when the function is active (within the stack frame for the function’s activation on the stack).</p>&#13;
<p class="indent">Global variables are stored in the <em>data</em> section. Unlike the stack, the data region does not grow or shrink—storage space for globals persists for the entire run of the program.</p>&#13;
<p class="indent">Finally, the <em>heap</em> portion of memory is the part of a program’s address space associated with dynamic memory allocation. The heap is typically located far from stack memory and grows into higher addresses as more space is dynamically allocated by the running program.</p>&#13;
<h3 class="h3" id="lev1_10">2.2 C’s Pointer Variables</h3>&#13;
<p class="noindent">C’s pointer variables provide a level of indirection to accessing program memory. By understanding how to use pointer variables, a programmer can write C programs that are both powerful and efficient. For example, through pointer variables, a C programmer can:</p>&#13;
<ul>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_67"/>implement functions whose parameters can modify values in the caller’s stack frame</li>&#13;
<li class="noindent">dynamically allocate (and deallocate) program memory at runtime when the program needs it</li>&#13;
<li class="noindent">efficiently pass large data structures to functions</li>&#13;
<li class="noindent">create linked dynamic data structures</li>&#13;
<li class="noindent">interpret bytes of program memory in different ways.</li>&#13;
</ul>&#13;
<p class="indent">In this section, we introduce the syntax and semantics of C’s pointer variables and introduce common examples of how to use them in C programs.</p>&#13;
<h4 class="h4" id="lev2_17">2.2.1 Pointer Variables</h4>&#13;
<p class="noindent">A <em>pointer variable</em> stores the address of a memory location in which a value of a specific type can be stored. For example, a pointer variable can store the value of an <span class="literal">int</span> address at which the integer value 12 is stored. The pointer variable <em>points to</em> (refers to) the value. A pointer provides <em>a level of indirection</em> for accessing values stored in memory. <a href="ch02.xhtml#ch2fig2">Figure 2-2</a> illustrates an example of what a pointer variable might look like in memory:</p>&#13;
<div class="imagec" id="ch2fig2"><img alt="image" src="../images/02fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-2: A pointer variable stores the address of a location in memory. Here, the pointer stores the address of an integer variable that holds the number 12.</em></p>&#13;
<p class="indent">Through the pointer variable, <span class="literal">ptr</span>, the value (<span class="literal">12</span>) stored in the memory location it points to can be indirectly accessed. C programs most frequently use pointer variables for:</p>&#13;
<div class="number">&#13;
<p class="number">1. <em>“pass by pointer” parameters</em>, for writing functions that can modify their argument’s value through a pointer parameter</p>&#13;
<p class="number">2. <em>dynamic memory allocation</em>, for writing programs that allocate (and free) space as the program runs. Dynamic memory is commonly used for dynamically allocating arrays. It is useful when a programmer doesn’t know the size of a data structure at compile time (e.g., the array size depends on user input at runtime). It also enables data structures to be resized as the program runs.</p>&#13;
</div>&#13;
<h5 class="h5" id="lev3_6">Rules for Using Pointer Variables</h5>&#13;
<p class="noindent">The rules for using pointer variables are similar to regular variables, except that you need to think about two types: the type of the pointer variable, and the type stored in the memory address to which the pointer variable points.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_68"/>First, <em>declare a pointer variable</em> using <span class="literal"/> <span class="codeitalic">&lt;type_name&gt;</span> <span class="literal">*</span><span class="codeitalic">&lt;var_name&gt;</span>:</p>&#13;
<p class="programs">int *ptr;   // stores the memory address of an int (ptr "points to" an int)<br/>&#13;
char *cptr; // stores the memory address of a char (cptr "points to" a char)</p>&#13;
<p class="note"><strong><span class="black">Note</span> POINTER TYPES</strong></p>&#13;
<p class="note1">Although <span class="literal">ptr</span> and <span class="literal">cptr</span> are both pointers, they refer to different types:</p>&#13;
<ul>&#13;
<li class="note1">The type of <span class="literal">ptr</span> is <em>pointer to int</em> (<span class="literal">int *</span>). It can point to a memory location that stores an <span class="literal">int</span> value.</li>&#13;
<li class="note1">The type of <span class="literal">cptr</span> is <em>pointer to char</em> (<span class="literal">char *</span>). It can point to a memory location that stores a <span class="literal">char</span> value.</li>&#13;
</ul>&#13;
<p class="indent">Next, <em>initialize the pointer variable</em> (make it point to something). Pointer variables <em>store address values</em>. A pointer should be initialized to store the address of a memory location whose type matches the type to which the pointer variable points. One way to initialize a pointer is to use the <em>address operator</em> (<span class="literal">&amp;</span>) with a variable to get the variable’s address value:</p>&#13;
<p class="programs">int x;<br/>&#13;
char ch;<br/>&#13;
<br/>&#13;
ptr = &amp;x;    // ptr gets the address of x, pointer "points to" x<br/>&#13;
cptr = &amp;ch;  // cptr gets the address of ch, pointer "points to" ch</p>&#13;
<div class="imagec" id="ch2fig3"><img alt="image" src="../images/02fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-3: A program can initialize a pointer by assigning it the address of an existing variable of the appropriate type.</em></p>&#13;
<p class="indent">Here’s an example of an invalid pointer initialization due to mismatched types:</p>&#13;
<p class="programs">cptr = &amp;x;   // ERROR: cptr can hold a char memory location<br/>&#13;
             // (&amp;x is the address of an int)</p>&#13;
<p class="noindent">Even though the C compiler may allow this type of assignment (with a warning about incompatible types), the behavior of accessing and modifying <span class="literal">x</span> through <span class="literal">cptr</span> will likely not behave as the programmer expects. Instead, the programmer should use an <span class="literal">int *</span> variable to point to an <span class="literal">int</span> storage location.</p>&#13;
<p class="indent">All pointer variables can also be assigned a special value, <span class="literal">NULL</span>, which represents an invalid address. While a <em>null pointer</em> (one whose value is <span class="literal">NULL</span>) should never be used to access memory, the value <span class="literal">NULL</span> is useful for testing a pointer variable to see if it points to a valid memory address. That is, C <span epub:type="pagebreak" id="page_69"/>programmers will commonly check a pointer to ensure that its value isn’t <span class="literal">NULL</span> before attempting to access the memory location to which it points. To set a pointer to <span class="literal">NULL</span>:</p>&#13;
<p class="programs">ptr = NULL;<br/>&#13;
cptr = NULL;</p>&#13;
<div class="imagec" id="ch2fig4"><img alt="image" src="../images/02fig04.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-4: Any pointer can be given the special value <span class="literal">NULL</span>, which indicates that it doesn’t refer to any particular address. Null pointers should never be dereferenced.</em></p>&#13;
<p class="indent">Finally, <em>use the pointer variable</em>. The <em>dereference operator</em> (<span class="literal">*</span>) follows a pointer variable to the location in memory that it points to and accesses the value at that location:</p>&#13;
<p class="programs">/* Assuming an integer named x has already been declared, this code sets the<br/>&#13;
   value of x to 8. */<br/>&#13;
<br/>&#13;
ptr = &amp;x;   /* initialize ptr to the address of x (ptr points to variable x) */<br/>&#13;
*ptr = 8;   /* the memory location ptr points to is assigned 8 */</p>&#13;
<div class="imagec" id="ch2fig5"><img alt="image" src="../images/02fig05.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-5: Dereferencing a pointer accesses the value to which the pointer refers.</em></p>&#13;
<h5 class="h5" id="lev3_7">Pointer Examples</h5>&#13;
<p class="noindent">Here’s an example sequence of C statements using two pointer variables:</p>&#13;
<p class="programs">int *ptr1, *ptr2, x, y;<br/>&#13;
<br/>&#13;
x = 8;<br/>&#13;
ptr2 = &amp;x;     // ptr2 is assigned the address of x<br/>&#13;
ptr1 = NULL;</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0069-01.jpg"/></div>&#13;
<span epub:type="pagebreak" id="page_70"/>&#13;
<p class="programs">*ptr2 = 10;     // the memory location ptr2 points to is assigned 10<br/>&#13;
y = *ptr2 + 3;  // y is assigned what ptr2 points to plus 3</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0070-01.jpg"/></div>&#13;
<p class="programs">ptr1 = ptr2;   // ptr1 gets the address value stored in ptr2 (both point to x)</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0070-02.jpg"/></div>&#13;
<p class="programs">*ptr1 = 100;</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0070-03.jpg"/></div>&#13;
<p class="programs">ptr1 = &amp;y;     <span class="codeitalic1">// change ptr1's value (change what it points to)</span><br/>&#13;
*ptr1 = 80;</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0070-04.jpg"/></div>&#13;
<p class="indent">When using pointer variables, carefully consider the types of the relevant variables. Drawing pictures of memory (like those shown above) can help with understanding what pointer code is doing. Some common errors involve misusing the dereference operator (<span class="literal">*</span>) or the address operator (<span class="literal">&amp;</span>). For example:</p>&#13;
<p class="programs">ptr = 20;       // ERROR?:  this assigns ptr to point to address 20<br/>&#13;
ptr = &amp;x;<br/>&#13;
*ptr = 20;      // CORRECT: this assigns 20 to the memory pointed to by ptr</p>&#13;
<p class="indent">If your program dereferences a pointer variable that does not contain a valid address, the program crashes:</p>&#13;
<span epub:type="pagebreak" id="page_71"/>&#13;
<p class="programs">ptr = NULL;<br/>&#13;
*ptr = 6;    // CRASH! program crashes with a segfault (a memory fault)<br/>&#13;
<br/>&#13;
ptr = 20;<br/>&#13;
*ptr = 6;    // CRASH! segfault (20 is not a valid address)<br/>&#13;
<br/>&#13;
ptr = x;<br/>&#13;
*ptr = 6;    // likely CRASH or may set some memory location with 6<br/>&#13;
             // (depends on the value of x which is used as an address value)<br/>&#13;
<br/>&#13;
ptr = &amp;x;    // This is probably what the programmer intended<br/>&#13;
*ptr = 6;</p>&#13;
<p class="indent">These types of errors exemplify one reason to initialize pointer variables to <span class="literal">NULL</span>; a program can then test a pointer’s value for <span class="literal">NULL</span> before dereferencing it:</p>&#13;
<p class="programs">if (ptr != NULL) {<br/>&#13;
    *ptr = 6;<br/>&#13;
}</p>&#13;
<h3 class="h3" id="lev1_11">2.3 Pointers and Functions</h3>&#13;
<p class="noindent">Pointer parameters provide a mechanism through which functions can modify argument values. The commonly used <em>pass by pointer</em> pattern uses a pointer function parameter that <em>gets the value of the address of some storage location</em> passed to it by the caller. For example, the caller could pass the address of one of its local variables. By dereferencing the pointer parameter inside the function, the function can modify the value at the storage location to which it points.</p>&#13;
<p class="indent">We have already seen similar functionality with array parameters, where an array function parameter gets the value of the base address of the passed array (the parameter refers to the same set of array elements as its argument), and the function can modify the values stored in the array. In general, this same idea can be applied by passing pointer parameters to functions that point to the memory locations in the caller’s scope.</p>&#13;
<p class="note"><strong><span class="black">Note</span> PASS BY VALUE</strong></p>&#13;
<p class="note1">All arguments in C are passed by value and follow pass-by-value semantics: the parameter gets a copy of its argument value, and modifying the parameter’s value does not change its argument’s value. When passing base type values, like the value of an <span class="literal">int</span> variable, the function parameter gets a copy of its argument value (the specific <span class="literal">int</span> value), and changing the value stored in the parameter cannot change the value stored in its argument.</p>&#13;
<p class="note1"><span epub:type="pagebreak" id="page_72"/>In the pass-by-pointer pattern, the parameter still gets the value of its argument, but it is passed <em>the value of an address</em>. Just like in passing base types, changing a pointer parameter’s value will not change its argument’s value (i.e., assigning the parameter to point to a different address will not change the argument’s address value). However, by dereferencing a pointer parameter, the function can change the contents of memory that both the parameter and its argument refer to; through a pointer parameter, a function can modify a variable that is visible to the caller after the function returns.</p>&#13;
<p class="indent">Here are the steps for implementing and calling a function with a pass-by-pointer parameter, with example code snippets showing each step:</p>&#13;
<div class="number">&#13;
<p class="number">1. Declare the function parameter to be a pointer to the variable type:</p>&#13;
<p class="programs1">/* input: an int pointer that stores the address of a memory<br/>&#13;
 *        location that can store an int value (it points to an int)<br/>&#13;
 */<br/>&#13;
int change_value(int *input) {</p>&#13;
<p class="number">2. When making the function call, pass in the address of a variable as the argument:</p>&#13;
<p class="programs1">int x;<br/>&#13;
change_value(&amp;x);</p>&#13;
<p class="number-p">In the preceding example, since the parameter’s type is <span class="literal">int *</span>, the address passed must be the address of an <span class="literal">int</span> variable.</p>&#13;
<p class="number">3. In the body of the function, dereference the pointer parameter to change the argument’s value:</p>&#13;
<p class="programs1">*input = 100;  // the location input points to (x's memory) <br/>&#13;
               // is assigned 100</p>&#13;
</div>&#13;
<p class="indent">Next, let’s examine a larger example program:</p>&#13;
<p class="margnote">passbypointer.c</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int change_value(int *input);<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int x;<br/>&#13;
    int y;<br/>&#13;
<br/>&#13;
    x = 30;<br/>&#13;
    y = change_value(&amp;x);<br/>&#13;
    printf("x: %d y: %d\n", x, y);  // prints x: 100 y: 30<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
/*<br/>&#13;
<span epub:type="pagebreak" id="page_73"/>&#13;
 * changes the value of the argument<br/>&#13;
 *     input: a pointer to the value to change<br/>&#13;
 *     returns: the original value of the argument<br/>&#13;
 */<br/>&#13;
int change_value(int *input) {<br/>&#13;
    int val;<br/>&#13;
<br/>&#13;
    val = *input; /* val gets the value input points to */<br/>&#13;
<br/>&#13;
    if (val &lt; 100) {<br/>&#13;
        *input = 100;  /* the value input points to gets 100 */<br/>&#13;
    } else {<br/>&#13;
        *input =  val * 2;<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    return val;<br/>&#13;
}</p>&#13;
<p class="indent">When run, the output is:</p>&#13;
<p class="programs">x: 100 y: 30</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig6">Figure 2-6</a> shows what the call stack looks like before executing the return in <span class="literal">change_value</span>.</p>&#13;
<div class="imagec" id="ch2fig6"><img alt="image" src="../images/02fig06.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-6: A snapshot of the call stack prior to returning from <span class="literal">change_value</span></em></p>&#13;
<p class="indent">The input parameter gets a copy of the value of its argument (the address of <span class="literal">x</span>). The value of <span class="literal">x</span> is 30 when the function call is made. Inside the <span class="literal">change_value</span> function, the parameter is dereferenced to assign the value 100 to the memory location pointed to by the parameter (<span class="literal">*input = 100;</span>, meaning “the location <span class="literal">input</span> points to gets the value 100”). Since the parameter stores the address of a local variable in the <span class="literal">main</span> function’s stack frame, through dereferencing the parameter, the value stored in the caller’s local variable can be changed. When the function returns, the argument’s value reflects the change made to it through the pointer parameter (the value of <span class="literal">x</span> in <span class="literal">main</span> was changed to 100 by the <span class="literal">change_value</span> function through its <span class="literal">input</span> parameter).</p>&#13;
<h3 class="h3" id="lev1_12"><span epub:type="pagebreak" id="page_74"/>2.4 Dynamic Memory Allocation</h3>&#13;
<p class="noindent">In addition to pass-by-pointer parameters, programs commonly use pointer variables to dynamically allocate memory. Such <em>dynamic memory allocation</em> allows a C program to request more memory as it’s running, and a pointer variable stores the address of the dynamically allocated space. Programs often allocate memory dynamically to tailor the size of an array for a particular run.</p>&#13;
<p class="indent">Dynamic memory allocation grants flexibility to programs that:</p>&#13;
<ul>&#13;
<li class="noindent">do not know the size of arrays or other data structures until runtime (e.g., the size depends on user input)</li>&#13;
<li class="noindent">need to allow for a variety of input sizes (not just up to some fixed capacity)</li>&#13;
<li class="noindent">want to allocate exactly the size of data structures needed for a particular execution (don’t waste capacity)</li>&#13;
<li class="noindent">grow or shrink the sizes of memory allocated as the program runs, reallocating more space when needed and freeing up space when it’s no longer required.</li>&#13;
</ul>&#13;
<h4 class="h4" id="lev2_18">2.4.1 Heap Memory</h4>&#13;
<p class="noindent">Every byte of memory in a program’s memory space has an associated address. Everything the program needs to run is in its memory space, and different types of entities reside in different parts of a program’s memory space. For example, the <em>code</em> region contains the program’s instructions, global variables reside in the <em>data</em> region, local variables and parameters occupy the <em>stack</em>, and dynamically allocated memory comes from the <em>heap</em>. Because the stack and the heap grow at runtime (as functions are called and return and as dynamic memory is allocated and freed), they are typically far apart in a program’s address space to leave a large amount of space for each to grow into as the program runs.</p>&#13;
<p class="indent">Dynamically allocated memory occupies the heap memory region of a program’s address space (see <a href="ch02.xhtml#lev1_10">page 66</a>). When a program dynamically requests memory at runtime, the heap provides a chunk of memory whose address must be assigned to a pointer variable.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig7">Figure 2-7</a> illustrates the parts of a running program’s memory with an example of a pointer variable (<span class="literal">ptr</span>) on the stack that stores the address of dynamically allocated heap memory (it points to heap memory).</p>&#13;
<span epub:type="pagebreak" id="page_75"/>&#13;
<div class="imagec" id="ch2fig7"><img alt="image" src="../images/02fig07.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-7: A pointer on the stack points to a block of memory that was allocated from the heap.</em></p>&#13;
<p class="indent">It’s important to remember that heap memory is anonymous memory, where “anonymous” means that addresses in the heap are not bound to variable names. Declaring a named program variable allocates it on the stack or in the data part of program memory. A local or global pointer variable can store the address of an anonymous heap memory location (e.g., a local pointer variable on the stack can point to heap memory), and dereferencing such a pointer enables a program to store data in the heap.</p>&#13;
<h4 class="h4" id="lev2_19">2.4.2 malloc and free</h4>&#13;
<p class="noindent"><em>malloc</em> and <em>free</em> are functions in the standard C library (<span class="literal">stdlib</span>) that a program can call to allocate and deallocate memory in the <em>heap</em>. Heap memory must be explicitly allocated (malloc’ed) and deallocated (freed) by a C program.</p>&#13;
<p class="indent">To allocate heap memory, call <span class="literal">malloc</span>, passing in the total number of bytes of contiguous heap memory to allocate. Use the <span class="literal">sizeof</span> <em>operator</em> to compute the number of bytes to request. For example, to allocate space on the heap to store a single integer, a program could call:</p>&#13;
<p class="programs">// Determine the size of an integer and allocate that much heap space.<br/>&#13;
malloc(sizeof(int));</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>The <span class="literal">malloc</span> function returns the base address of the allocated heap memory to the caller (or <span class="literal">NULL</span> if an error occurs). Here’s a full example program with a call to <span class="literal">malloc</span> to allocate heap space to store a single <span class="literal">int</span> value:</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int *p;<br/>&#13;
<br/>&#13;
    p = malloc(sizeof(int));  // allocate heap memory for storing an int<br/>&#13;
<br/>&#13;
    if (p != NULL) {<br/>&#13;
        *p = 6;   // the heap memory p points to gets the value 6<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">malloc</span> function returns a <span class="literal">void *</span> type, which represents a generic pointer to a non-specified type (or to any type). When a program calls <span class="literal">malloc</span> and assigns the result to a pointer variable, the program associates the allocated memory with the type of the pointer variable.</p>&#13;
<p class="indent">Sometimes you may see calls to <span class="literal">malloc</span> that explicitly recast its return type from <span class="literal">void *</span> to match the type of the pointer variable. For example:</p>&#13;
<p class="programs">p = (int *) malloc(sizeof(int));</p>&#13;
<p class="indent">The <span class="literal">(int *)</span> before <span class="literal">malloc</span> tells the compiler that the <span class="literal">void *</span> type returned by <span class="literal">malloc</span> will be used as an <span class="literal">int *</span> in this call (it recasts the return type of <span class="literal">malloc</span> to an <span class="literal">int *</span>). We discuss type recasting and the <span class="literal">void *</span> type in more detail later in this chapter, on <a href="ch02.xhtml#lev2_38">page 126</a>.</p>&#13;
<p class="indent">A call to <span class="literal">malloc</span> fails if there is not enough free heap memory to satisfy the requested number of bytes to allocate. Usually, <span class="literal">malloc</span> failing indicates an error in the program such as passing <span class="literal">malloc</span> a very large request, passing a negative number of bytes, or calling <span class="literal">malloc</span> in an infinite loop and running out of heap memory. Because any call to <span class="literal">malloc</span> can fail, you should <em>always test its return value for</em> <span class="codeitalic">NULL</span> (indicating <span class="literal">malloc</span> failed) before dereferencing the pointer value. Dereferencing a null pointer will cause your program to crash! For example:</p>&#13;
<p class="programs">int *p;<br/>&#13;
<br/>&#13;
p = malloc(sizeof(int));<br/>&#13;
if (p == NULL) {<br/>&#13;
    printf("Bad malloc error\n");<br/>&#13;
    exit(1);   // exit the program and indicate error<br/>&#13;
}<br/>&#13;
*p = 6;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_77"/>When a program no longer needs the heap memory it dynamically allocated with <span class="literal">malloc</span>, it should explicitly deallocate the memory by calling the <span class="literal">free</span> function. It’s also a good idea to set the pointer’s value to <span class="literal">NULL</span> after calling <span class="literal">free</span>, so that if an error in the program causes it to be accidentally dereferenced after the call to <span class="literal">free</span>, the program will crash rather than modify parts of heap memory that have been reallocated by subsequent calls to <span class="literal">malloc</span>. Such unintended memory references can result in undefined program behavior that is often very difficult to debug, whereas a null pointer dereference will fail immediately, making it a relatively easy bug to find and to fix.</p>&#13;
<p class="programs">free(p);<br/>&#13;
p = NULL;</p>&#13;
<h4 class="h4" id="lev2_20">2.4.3 Dynamically Allocated Arrays and Strings</h4>&#13;
<p class="noindent">C programmers often dynamically allocate memory to store arrays. A successful call to <span class="literal">malloc</span> allocates one contiguous chunk of heap memory of the requested size. It returns the address of the start of this chunk of memory to the caller, making the returned address value suitable for the base address of a dynamically allocated array in heap memory.</p>&#13;
<p class="indent">To dynamically allocate space for an array of elements, pass <span class="literal">malloc</span> the total number of bytes in the desired array. That is, the program should request from <span class="literal">malloc</span> the total number of bytes in each array element times the number of elements in the array. Pass <span class="literal">malloc</span> an expression for the total number of bytes in the form of <span class="literal">sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">) *</span> <span class="codeitalic">&lt;number of elements&gt;</span>. For example:</p>&#13;
<p class="programs">int *arr;<br/>&#13;
char *c_arr;<br/>&#13;
<br/>&#13;
// allocate an array of 20 ints on the heap:<br/>&#13;
arr = malloc(sizeof(int) * 20);<br/>&#13;
<br/>&#13;
// allocate an array of 10 chars on the heap:<br/>&#13;
c_arr = malloc(sizeof(char) * 10);</p>&#13;
<p class="indent">After the calls to <span class="literal">malloc</span> in this example, the <span class="literal">int</span> pointer variable <span class="literal">arr</span> stores the base address of an array of 20 contiguous integer storage locations in heap memory, and the <span class="literal">c_arr</span> char pointer variable stores the base address of an array of 10 contiguous char storage locations in heap memory. <a href="ch02.xhtml#ch2fig8">Figure 2-8</a> depicts what this might look like.</p>&#13;
<span epub:type="pagebreak" id="page_78"/>&#13;
<div class="imagec" id="ch2fig8"><img alt="image" src="../images/02fig08.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-8: A 20-element integer array and 10-element character array allocated on the heap</em></p>&#13;
<p class="indent">Note that while <span class="literal">malloc</span> returns a pointer to dynamically allocated space in heap memory, C programs store the pointer to heap locations on the stack. The pointer variables contain <em>only the base address</em> (the starting address) of the array storage space in the heap. Just like statically declared arrays, the memory locations for dynamically allocated arrays are in contiguous memory locations. While a single call to <span class="literal">malloc</span> results in a chunk of memory of the requested number of bytes being allocated, multiple calls to <span class="literal">malloc</span> <em>will not</em> result in heap addresses that are contiguous (on most systems). In the previous example, the <span class="literal">char</span> array elements and the <span class="literal">int</span> array elements may be at addresses that are far apart in the heap.</p>&#13;
<p class="indent">After dynamically allocating heap space for an array, a program can access the array through the pointer variable. Because the pointer variable’s value represents the base address of the array in the heap, we can use the same syntax to access elements in dynamically allocated arrays as we use to access elements in statically declared arrays (see <a href="ch01.xhtml#lev1_5">page 44</a>). Here’s an example:</p>&#13;
<p class="programs">int i;<br/>&#13;
int s_array[20];<br/>&#13;
int *d_array;<br/>&#13;
<br/>&#13;
d_array = malloc(sizeof(int) * 20);<br/>&#13;
if (d_array == NULL) {<br/>&#13;
    printf("Error: malloc failed\n");<br/>&#13;
    exit(1);<br/>&#13;
}<br/>&#13;
<br/>&#13;
for (i=0; i &lt; 20; i++) {<br/>&#13;
    s_array[i] = i;<br/>&#13;
    d_array[i] = i;<br/>&#13;
}<br/>&#13;
<br/>&#13;
printf("%d %d \n", s_array[3], d_array[3]);  // prints 3 3</p>&#13;
<p class="indent">It may not be obvious why the same syntax can be used for accessing elements in dynamically allocated arrays as is used in accessing elements in statically declared arrays. However, even though their types are different, the values of <span class="literal">s_array</span> and <span class="literal">d_array</span> both evaluate to the base address of the array in memory (see <a href="ch02.xhtml#ch2tab1">Table 2-1</a>).</p>&#13;
<p class="tabcap" id="ch2tab1"><span epub:type="pagebreak" id="page_79"/><strong>Table 2-1:</strong> Comparison of Statically Allocated <span class="literal">s_array</span> and Dynamically Allocated <span class="literal">d_array</span></p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Expression</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Type</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">s_array</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">base address of array in memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(static) array of integers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">d_array</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">base address of array in memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">integer pointer (<span class="literal">int *</span>)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Because the names of both variables evaluate to the base address of the array in memory (the address of the first element memory), the semantics of the <span class="literal">[i]</span> syntax following the name of the variable remain the same for both: <span class="literal">[i]</span> <em>dereferences the</em> <span class="codeitalic">int</span> <em>storage location at offset</em> <span class="codeitalic">i</span> <em>from the base address of the array in memory</em>—it’s accessing the <span class="literal">i</span>th element.</p>&#13;
<p class="indent">For most purposes, we recommend using the <span class="literal">[i]</span> syntax to access the elements of a dynamically allocated array. However, programs can also use the pointer dereferencing syntax (the <span class="literal">*</span> operator) to access array elements. For example, placing a <span class="literal">*</span> in front of a pointer that refers to a dynamically allocated array will dereference the pointer to access element 0 of the array:</p>&#13;
<p class="programs">/* these two statements are identical: both put 8 in index 0 */<br/>&#13;
d_array[0] = 8; // put 8 in index 0 of the d_array<br/>&#13;
*d_array = 8;   // in the location pointed to by d_array store 8</p>&#13;
<p class="indent">The “Arrays in C” section on <a href="ch02.xhtml#lev1_13">page 81</a> describes arrays in more detail, and the “Pointer Arithmetic” section on <a href="ch02.xhtml#lev2_39">page 224</a> discusses accessing array elements through pointer variables.</p>&#13;
<p class="indent">When a program is finished using a dynamically allocated array, it should call <span class="literal">free</span> to deallocate the heap space. As mentioned earlier, we recommend setting the pointer to <span class="literal">NULL</span> after freeing it:</p>&#13;
<p class="programs">free(arr);<br/>&#13;
arr = NULL;<br/>&#13;
<br/>&#13;
free(c_arr);<br/>&#13;
c_arr = NULL;<br/>&#13;
<br/>&#13;
free(d_array);<br/>&#13;
d_array = NULL;</p>&#13;
<div class="g-box">&#13;
<p class="box-title">HEAP MEMORY MANAGEMENT, MALLOC AND FREE</p>&#13;
<p class="noindentt">The C standard library implements <span class="literal">malloc</span> and <span class="literal">free</span>, which are the programming interface to its heap memory manager. When called, <span class="literal">malloc</span> needs to find a contiguous chunk of unallocated heap memory space that can satisfy the size of the request. The heap memory manager maintains a <em>free list</em> of unallocated <em>extents</em> of heap memory, where each extent specifies the start address and size of a contiguous unallocated chunk of heap space.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_80"/>Initially, all of heap memory is empty, meaning that the free list has a single extent consisting of the entire heap region. After a program has made some calls to <span class="literal">malloc</span> and <span class="literal">free</span>, heap memory can become <em>fragmented</em>, meaning that there are chunks of free heap space interspersed with chunks of allocated heap space. The heap memory manager typically keeps lists of different ranges of sizes of heap space to enable fast searching for a free extent of a particular size. In addition, it implements one or more policies for choosing among multiple free extents that could be used to satisfy a request.</p>&#13;
<p class="noindentt">The <span class="literal">free</span> function may seem odd in that it only expects to receive the address of the heap space to free without needing the size of the heap space to free at that address. That’s because <span class="literal">malloc</span> not only allocates the requested memory bytes, but it also allocates a few additional bytes right before the allocated chunk to store a header structure. The header stores metadata about the allocated chunk of heap space, such as the size. As a result, a call to <span class="literal">free</span> only needs to pass the address of heap memory to free. The implementation of <span class="literal">free</span> can get the size of the memory to free from the header information that is in memory right before the address passed to <span class="literal">free</span>.</p>&#13;
<p class="noindentt">For more information about heap memory management, see an OS textbook (for example, Chapter 17, “Free Space Management,” in <em>OS in Three Easy Pieces</em> covers these details).<sup><a href="ch02.xhtml#fn2_1" id="rfn2_1">1</a></sup></p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_21">2.4.4 Pointers to Heap Memory and Functions</h4>&#13;
<p class="noindent">When passing a dynamically allocated array to a function, the pointer variable argument’s <em>value</em> is passed to the function (i.e., the base address of the array in the heap is passed to the function). Thus, when passing either statically declared or dynamically allocated arrays to functions, the parameter gets exactly the same value—the base address of the array in memory. As a result, the same function can be used for statically and dynamically allocated arrays of the same type, and identical syntax can be used inside the function for accessing array elements. The parameter declarations <span class="literal">int *arr</span> and <span class="literal">int</span> <span class="literal">arr[]</span> are equivalent. However, by convention, the pointer syntax tends to be used for functions that may be called with dynamically allocated arrays:</p>&#13;
<p class="programs">int main() {<br/>&#13;
    int *arr1;<br/>&#13;
<br/>&#13;
    arr1 = malloc(sizeof(int) * 10);<br/>&#13;
    if (arr1 == NULL) {<br/>&#13;
        printf("malloc error\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    /* pass the value of arr1 (base address of array in heap) */<br/>&#13;
    init_array(arr1, 10);<br/>&#13;
    ...<br/>&#13;
}<br/>&#13;
<span epub:type="pagebreak" id="page_81"/>void init_array(int *arr, int size) {<br/>&#13;
    int i;<br/>&#13;
    for (i = 0; i &lt; size; i++) {<br/>&#13;
        arr[i] = i;<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="indent">At the point just before returning from the <span class="literal">init_array</span> function, the contents of memory will look like <a href="ch02.xhtml#ch2fig9">Figure 2-9</a>. Note that <span class="literal">main</span> only passes the base address of the array to <span class="literal">init_array</span>. The array’s large block of contiguous memory remains on the heap, but the function can access it by dereferencing the <span class="literal">arr</span> pointer parameter.</p>&#13;
<div class="imagec" id="ch2fig9"><img alt="image" src="../images/02fig09.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-9: The contents of memory prior to returning from <span class="literal">init_array</span>. Both <span class="literal">main</span>’s <span class="literal">arr1</span> and <span class="literal">init_array</span>’s <span class="literal">arr</span> variable point to the same block of heap memory.</em></p>&#13;
<h3 class="h3" id="lev1_13">2.5 Arrays in C</h3>&#13;
<p class="noindent">In “Introduction to Arrays” on <a href="ch01.xhtml#lev2_9">page 44</a>, we introduced statically declared one-dimensional C arrays and discussed the semantics of passing arrays to functions. In “Dynamic Memory Allocation” on <a href="ch02.xhtml#lev1_12">page 136</a>, we introduced dynamically allocated one-dimensional arrays and discussed the semantics of passing them to functions.</p>&#13;
<p class="indent">In this section, we take a more in-depth look at arrays in C. We describe both statically and dynamically allocated arrays in more detail and discuss two-dimensional arrays.</p>&#13;
<h4 class="h4" id="lev2_22">2.5.1 Single-Dimensional Arrays</h4>&#13;
<h5 class="h5" id="lev3_8">Statically Allocated</h5>&#13;
<p class="noindent">Before jumping into new content, we briefly summarize static arrays with an example. See “Introduction to Arrays” on <a href="ch01.xhtml#lev2_9">page 44</a> for more detail on statically declared one-dimensional arrays.</p>&#13;
<p class="indent">Statically declared arrays are allocated either on the stack (for local variables) or in the data region of memory (for global variables). A programmer <span epub:type="pagebreak" id="page_82"/>can declare an array variable by specifying its type (the type stored at each index) and its total capacity (number of elements).</p>&#13;
<p class="indent">When passing an array to a function, C copies the value of the base address to the parameter. That is, both the parameter and the argument refer to the same memory locations—the parameter pointer points to the argument’s array elements in memory. As a result, modifying the values stored in the array through an array parameter modifies the values stored in the argument array.</p>&#13;
<p class="indent">Here are some examples of static array declaration and use:</p>&#13;
<p class="programs">// declare arrays specifying their type and total capacity<br/>&#13;
float averages[30];   // array of float, 30 elements<br/>&#13;
char  name[20];       // array of char, 20 elements<br/>&#13;
int i;<br/>&#13;
<br/>&#13;
// access array elements<br/>&#13;
for (i = 0; i &lt; 10; i++) {<br/>&#13;
    averages[i] = 0.0 + i;<br/>&#13;
    name[i] = 'a' + i;<br/>&#13;
}<br/>&#13;
name[10] = '\0';    // name is being used for storing a C-style string<br/>&#13;
<br/>&#13;
// prints: 3 d abcdefghij<br/>&#13;
printf("%g %c %s\n", averages[3], name[3], name);<br/>&#13;
<br/>&#13;
strcpy(name, "Hello");<br/>&#13;
printf("%s\n", name);  // prints: Hello</p>&#13;
<h5 class="h5" id="lev3_9">Dynamically Allocated</h5>&#13;
<p class="noindent">In “Dynamic Memory Allocation” on <a href="ch02.xhtml#lev1_12">page 74</a>, we introduced dynamically allocated one-dimensional arrays, including their access syntax and the syntax and semantics of passing dynamically allocated arrays to functions. Here, we present a short recap of that information with an example.</p>&#13;
<p class="indent">Calling the <span class="literal">malloc</span> function dynamically allocates an array on the heap at runtime. The address of the allocated heap space can be assigned to a global or local pointer variable, which then points to the first element of the array. To dynamically allocate space, pass <span class="literal">malloc</span> the total number of bytes to allocate for the array (using the <span class="literal">sizeof</span> operator to get the size of a specific type). A single call to <span class="literal">malloc</span> allocates a contiguous chunk of heap space of the requested size. For example:</p>&#13;
<p class="programs">// declare a pointer variable to point to allocated heap space<br/>&#13;
int    *p_array;<br/>&#13;
double *d_array;<br/>&#13;
<br/>&#13;
// call malloc to allocate the appropriate number of bytes for the array<br/>&#13;
<span epub:type="pagebreak" id="page_83"/>p_array = malloc(sizeof(int) * 50);      // allocate 50 ints<br/>&#13;
d_array = malloc(sizeof(double) * 100);  // allocate 100 doubles<br/>&#13;
<br/>&#13;
// always CHECK RETURN VALUE of functions and HANDLE ERROR return values<br/>&#13;
if ( (p_array == NULL) || (d_array == NULL) ) {<br/>&#13;
    printf("ERROR: malloc failed!\n");<br/>&#13;
    exit(1);<br/>&#13;
}<br/>&#13;
<br/>&#13;
// use [] notation to access array elements<br/>&#13;
for (i = 0; i &lt; 50; i++) {<br/>&#13;
    p_array[i] = 0;<br/>&#13;
    d_array[i] = 0.0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
// free heap space when done using it<br/>&#13;
free(p_array);<br/>&#13;
p_array = NULL;<br/>&#13;
<br/>&#13;
free(d_array);<br/>&#13;
d_array = NULL;</p>&#13;
<h5 class="h5" id="lev3_10">Array Memory Layout</h5>&#13;
<p class="noindent">Whether an array is statically declared or dynamically allocated via a single call to <span class="literal">malloc</span>, array elements represent contiguous memory locations (addresses):</p>&#13;
<p class="programs"> array [0]:  base address<br/>&#13;
 array [1]:  next address<br/>&#13;
 array [2]:  next address<br/>&#13;
   ...            ...<br/>&#13;
 array [99]: last address</p>&#13;
<p class="indent">The location of element <span class="literal">i</span> is at an offset <span class="literal">i</span> from the base address of the array. The exact address of the <span class="literal">i</span>th element depends on the number of bytes of the type stored in the array. For example, consider the following array declarations:</p>&#13;
<p class="programs">int  iarray[6];  // an array of six ints, each of which is four bytes<br/>&#13;
char carray[4];  // an array of four chars, each of which is one byte</p>&#13;
<p class="indent">The addresses of their individual array elements might look something like this:</p>&#13;
<p class="programs"> addr   element<br/>&#13;
 ----   -------<br/>&#13;
 1230:  iarray[0]<br/>&#13;
 1234:  iarray[1]<br/>&#13;
<span epub:type="pagebreak" id="page_84"/>&#13;
 1238:  iarray[2]<br/>&#13;
 1242:  iarray[3]<br/>&#13;
 1246:  iarray[4]<br/>&#13;
 1250:  iarray[5]<br/>&#13;
     ...<br/>&#13;
 1280:  carray[0]<br/>&#13;
 1281:  carray[1]<br/>&#13;
 1282:  carray[2]<br/>&#13;
 1283:  carray[3]</p>&#13;
<p class="indent">In this example, <span class="literal">1230</span> is the base address of <span class="literal">iarray</span> and <span class="literal">1280</span> the base address of <span class="literal">carray</span>. Note that individual elements of each array are allocated to contiguous memory addresses: each element of <span class="literal">iarray</span> stores a four-byte <span class="literal">int</span> value, so its element addresses differ by four, and each element of <span class="literal">carray</span> stores a one-byte <span class="literal">char</span> value, so its addresses differ by one. There is no guarantee that the set of local variables are allocated to contiguous memory locations on the stack (hence, there could be a gap in the addresses between the end of <span class="literal">iarray</span> and the start of <span class="literal">carray</span>, as shown in this example).</p>&#13;
<h4 class="h4" id="lev2_23">2.5.2 Two-Dimensional Arrays</h4>&#13;
<p class="noindent">C supports multidimensional arrays, but we limit our discussion of multidimensional arrays to two-dimensional (2D) arrays, since 1D and 2D arrays are the most commonly used by C programmers.</p>&#13;
<h5 class="h5" id="lev3_11">Statically Allocated 2D Arrays</h5>&#13;
<p class="noindent">To statically declare a multidimensional array variable, specify the size of each dimension. For example:</p>&#13;
<p class="programs">int   matrix[50][100];<br/>&#13;
short little[10][10];</p>&#13;
<p class="noindent">Here, <span class="literal">matrix</span> is a 2D array of <span class="literal">int</span> values with 50 rows and 100 columns, and <span class="literal">little</span> is a 2D array of <span class="literal">short</span> values with 10 rows and 10 columns.</p>&#13;
<p class="indent">To access an individual element, indicate both the row and the column index:</p>&#13;
<p class="programs">int   val;<br/>&#13;
short num;<br/>&#13;
<br/>&#13;
val = matrix[3][7];  // get int value in row 3, column 7 of matrix<br/>&#13;
num = little[8][4];  // get short value in row 8, column 4 of little</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig10">Figure 2-10</a> illustrates the 2D array as a matrix of integer values, where a specific element in the 2D array is indexed by row and column index values.</p>&#13;
<span epub:type="pagebreak" id="page_85"/>&#13;
<div class="imagec" id="ch2fig10"><img alt="image" src="../images/02fig10.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-10: A two-dimensional array represented as a matrix. Accessing matrix[2][3] is like indexing into a grid at row 2 and column 3.</em></p>&#13;
<p class="indent">Programs often access the elements of a 2D array by iterating with nested loops. For example, the following nested loop initializes all elements in <span class="literal">matrix</span> to 0:</p>&#13;
<p class="programs">int i, j;<br/>&#13;
<br/>&#13;
for (i = 0; i &lt; 50; i++) {  // for each row i<br/>&#13;
    for (j = 0; j &lt; 100; j++) { // iterate over each column element in row i<br/>&#13;
        matrix[i][j] = 0;<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<h5 class="h5" id="lev3_12">Two-Dimensional Array Parameters</h5>&#13;
<p class="noindent">The same rules for passing one-dimensional array arguments to functions apply to passing two-dimensional array arguments: the parameter gets the value of the base address of the 2D array (<span class="literal">&amp;arr[0][0]</span>). In other words, the parameter points to the argument’s array elements and therefore the function can change values stored in the passed array.</p>&#13;
<p class="indent">For multidimensional array parameters, you must indicate that the parameter is a multidimensional array, but you can leave the size of the first dimension unspecified (for good generic design). The sizes of other dimensions must be fully specified so that the compiler can generate the correct offsets into the array. Here’s a 2D example:</p>&#13;
<p class="programs">// a C constant definition: COLS is defined to be the value 100<br/>&#13;
#define COLS  (100)<br/>&#13;
<br/>&#13;
/*<br/>&#13;
 * init_matrix: initializes the passed matrix elements to the<br/>&#13;
 *              product of their index values<br/>&#13;
<span epub:type="pagebreak" id="page_86"/>&#13;
 *   m: a 2D array (the column dimension must be 100)<br/>&#13;
 *   rows: the number of rows in the matrix<br/>&#13;
 *   return: does not return a value<br/>&#13;
 */<br/>&#13;
void init_matrix(int m[][COLS], int rows) {<br/>&#13;
    int i, j;<br/>&#13;
    for (i = 0; i &lt; rows; i++) {<br/>&#13;
        for (j = 0; j &lt; COLS; j++) {<br/>&#13;
            m[i][j] = i*j;<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int matrix[50][COLS];<br/>&#13;
    int bigger[90][COLS];<br/>&#13;
<br/>&#13;
    init_matrix(matrix, 50);<br/>&#13;
    init_matrix(bigger, 90);<br/>&#13;
    ...</p>&#13;
<p class="indent">Both the <span class="literal">matrix</span> and the <span class="literal">bigger</span> arrays can be passed as arguments to the <span class="literal">init_matrix</span> function because they have the same column dimension as the parameter definition.</p>&#13;
<p class="note"><strong><span class="black">Note</span></strong></p>&#13;
<p class="note1">The column dimension must be specified in the parameter definition of a 2D array so that the compiler can calculate the offset from the base address of the 2D array to the start of a particular row of elements. The offset calculation follows from the layout of 2D arrays in memory.</p>&#13;
<h5 class="h5" id="lev3_13">Two-Dimensional Array Memory Layout</h5>&#13;
<p class="noindent">Statically allocated 2D arrays are arranged in memory in <em>row-major order</em>, meaning that all of row 0’s elements come first, followed by all of row 1’s elements, and so on. For example, given the following declaration of a 2D array of integers</p>&#13;
<p class="programs">int arr[3][4];  // int array with 3 rows and 4 columns</p>&#13;
<p class="noindent">its layout in memory might look like <a href="ch02.xhtml#ch2fig11">Figure 2-11</a>.</p>&#13;
<span epub:type="pagebreak" id="page_87"/>&#13;
<div class="imagec" id="ch2fig11"><img alt="image" src="../images/02fig11.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-11: The layout of a two-dimensional array in row-major order</em></p>&#13;
<p class="indent">Note that all array elements are allocated to contiguous memory addresses. That is, the base address of the 2D array is the memory address of the <span class="literal">[0][0]</span> element (<span class="literal">&amp;arr[0][0]</span>), and subsequent elements are stored contiguously in row-major order (e.g., the entirety of row 1 is followed immediately by the entirety of row 2, and so on).</p>&#13;
<h5 class="h5" id="lev3_14">Dynamically Allocated 2D Arrays</h5>&#13;
<p class="noindent">Dynamically allocated 2D arrays can be allocated in two ways. For an <em>N</em> × <em>M</em> 2D array, either:</p>&#13;
<div class="number">&#13;
<p class="number">1. Make a single call to <span class="literal">malloc</span>, allocating one large chunk of heap space to store all <em>N</em> × <em>M</em> array elements.</p>&#13;
<p class="number">2. Make multiple calls to <span class="literal">malloc</span>, allocating an array of arrays. First, allocate a 1D array of <em>N</em> pointers to the element type, with a 1D array of pointers for each row in the 2D array. Then, allocate <em>N</em> 1D arrays of size <em>M</em> to store the set of column values for each row in the 2D array. Assign the addresses of each of these <em>N</em> arrays to the elements of the first array of <em>N</em> pointers.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_88"/>&#13;
<p class="indent">The variable declarations, allocation code, and array element access syntax differ depending on which of these two methods a programmer chooses to use.</p>&#13;
<h5 class="h5" id="lev3_15">Method 1: Memory-Efficient Allocation</h5>&#13;
<p class="noindent">In this method, a single call to <span class="literal">malloc</span> allocates the total number of bytes needed to store the <em>N</em> × <em>M</em> array of values. This method has the benefit of being more memory efficient because the entire space for all <em>N</em> × <em>M</em> elements will be allocated at once, in contiguous memory locations.</p>&#13;
<p class="indent">The call to <span class="literal">malloc</span> returns the starting address of the allocated space (the base address of the array), which (like a 1D array) should be stored in a pointer variable. In fact, there is no semantic difference between allocating a 1D or 2D array using this method: the call to <span class="literal">malloc</span> returns the starting address of a contiguously allocated chunk of heap memory of the requested number of bytes. Because allocation of a 2D array using this method looks just like allocation for a 1D array, the programmer has to explicitly map 2D row and column indexing on top of this single chunk of heap memory space (the compiler has no implicit notion of rows or columns and thus cannot interpret double indexing syntax into this malloc’ed space).</p>&#13;
<p class="indent">Here’s an example C code snippet that dynamically allocates a 2D array using method 1:</p>&#13;
<p class="programs">#define N 3<br/>&#13;
#define M 4<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int *two_d_array;    // the type is a pointer to an int (the element type)<br/>&#13;
<br/>&#13;
    // allocate in a single malloc of N x M int-sized elements:<br/>&#13;
    two_d_array = malloc(sizeof(int) * N * M);<br/>&#13;
<br/>&#13;
    if (two_d_array == NULL) {<br/>&#13;
        printf("ERROR: malloc failed!\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    ...</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig12">Figure 2-12</a> shows an example of allocating a 2D array using this method and illustrates what memory might look like after the call to <span class="literal">malloc</span>.</p>&#13;
<span epub:type="pagebreak" id="page_89"/>&#13;
<div class="imagec" id="ch2fig12"><img alt="image" src="../images/02fig12.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-12: The results of allocating a 2D array with a single call to <span class="literal">malloc</span></em></p>&#13;
<p class="indent">Like 1D dynamically allocated arrays, the pointer variable for a 2D array is allocated on the stack. That pointer is then assigned the value returned by the call to <span class="literal">malloc</span>, which represents the base address of the contiguous chunk of <em>N</em> × <em>M</em> <span class="literal">int</span> storage locations in the heap memory.</p>&#13;
<p class="indent">Because this method uses a single chunk of malloc’ed space for the 2D array, the memory allocation is as efficient as possible (it only requires one call to <span class="literal">malloc</span> for the entire 2D array). It’s the more efficient way to access memory due to all elements being located close together in contiguous memory, with each access requiring only a single level of indirection from the pointer variable.</p>&#13;
<p class="indent">However, the C compiler does not know the difference between a 2D or 1D array allocation using this method. As a result, the double indexing syntax (<span class="literal">[i][j]</span>) of statically declared 2D arrays <em>cannot</em> be used when allocating a 2D array using this method. Instead, the programmer must explicitly compute the offset into the contiguous chunk of heap memory using a function of row and column index values (<span class="literal">[i*M + j]</span>, where <span class="literal">M</span> is the column dimension).</p>&#13;
<p class="indent">Here’s an example of how a programmer would structure code to initialize all the elements of a 2D array:</p>&#13;
<p class="programs">// access using [] notation:<br/>&#13;
//   cannot use [i][j] syntax because the compiler has no idea where the<br/>&#13;
//   next row starts within this chunk of heap space, so the programmer<br/>&#13;
//   must explicitly add a function of row and column index values<br/>&#13;
//   (i*M+j) to map their 2D view of the space into the 1D chunk of memory<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_90"/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    for (j = 0; j &lt; M; j++) {<br/>&#13;
        two_d_array[i*M + j] = 0;<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<h5 class="h5" id="lev3_16">Method 1 (Single malloc) and Function Parameters</h5>&#13;
<p class="noindent">The base address of an array of <span class="literal">int</span> types allocated via a single <span class="literal">malloc</span> is a pointer to an <span class="literal">int</span>, so it can be passed to a function with an (<span class="literal">int *</span>) parameter. Additionally, the function must be passed row and column dimensions so that it can correctly compute offsets into the 2D array. For example:</p>&#13;
<p class="programs">/*<br/>&#13;
 * initialize all elements in a 2D array to 0<br/>&#13;
 *  arr: the array<br/>&#13;
 *  rows: number of rows<br/>&#13;
 *  cols: number of columns<br/>&#13;
 */<br/>&#13;
void init2D(int *arr, int rows, int cols) {<br/>&#13;
    int i, j;<br/>&#13;
    for (i = 0; i &lt; rows; i++) {<br/>&#13;
        for (j = 0; j &lt; cols; j++) {<br/>&#13;
            arr[i*cols + j] = 0;<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int *array;<br/>&#13;
    array = malloc(sizeof(int) * N * M);<br/>&#13;
    if (array != NULL) {<br/>&#13;
        init2D(array, N, M);<br/>&#13;
    }<br/>&#13;
    ...</p>&#13;
<h5 class="h5" id="lev3_17">Method 2: The Programmer-Friendly Way</h5>&#13;
<p class="noindent">The second method for dynamically allocating a 2D array stores the array as an array of <em>N</em> 1D arrays (one 1D array per row). It requires <em>N</em> + 1 calls to <span class="literal">malloc</span>: one <span class="literal">malloc</span> for the array of row arrays, and one <span class="literal">malloc</span> for each of the <em>N</em> row’s column arrays. As a result, the element locations <em>within a row</em> are contiguous, but elements are not contiguous across rows of the 2D array. Allocation and element access are not as efficient as in method 1, and the type definitions for variables can be a bit more confusing. However, using this method, a programmer can use double indexing syntax to access individual elements of the 2D array (the first index is an index into the array of rows, <span epub:type="pagebreak" id="page_91"/>the second index is an index into the array of column elements within that row).</p>&#13;
<p class="indent">Here is an example of allocating a 2D array using method 2 (with the error detection and handling code removed for readability):</p>&#13;
<p class="programs">// the 2D array variable is declared to be `int **` (a pointer to an int *)<br/>&#13;
// a dynamically allocated array of dynamically allocated int arrays<br/>&#13;
// (a pointer to pointers to ints)<br/>&#13;
int **two_d_array;<br/>&#13;
int i;<br/>&#13;
<br/>&#13;
// allocate an array of N pointers to ints<br/>&#13;
// malloc returns the address of this array (a pointer to (int *)'s)<br/>&#13;
two_d_array = malloc(sizeof(int *) * N);<br/>&#13;
<br/>&#13;
// for each row, malloc space for its column elements and add it to<br/>&#13;
// the array of arrays<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
// malloc space for row i's M column elements<br/>&#13;
    two_d_array[i] = malloc(sizeof(int) * M);<br/>&#13;
}</p>&#13;
<p class="indent">In this example, note the types of the variables and the sizes passed to the calls to <span class="literal">malloc</span>. To refer to the dynamically allocated 2D array, the programmer declares a variable (<span class="literal">two_d_array</span>) of type <span class="literal">int **</span> that will store the address of a dynamically allocated array of <span class="literal">int *</span> element values. Each element in <span class="literal">two_d_array</span> stores the address of a dynamically allocated array of <span class="literal">int</span> values (the type of <span class="literal">two_d_array[i]</span> is <span class="literal">int *</span>).</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig13">Figure 2-13</a> shows what memory might look like after the preceding example’s <em>N</em> + 1 calls to <span class="literal">malloc</span>.</p>&#13;
<div class="imagec" id="ch2fig13"><img alt="image" src="../images/02fig13.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-13: The arrangement of memory after allocating a 2D array with N + 1 <span class="literal">malloc</span> calls</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_92"/>Note that when using this method, only the elements allocated as part of a single call to <span class="literal">malloc</span> are contiguous in memory. That is, elements within each row are contiguous, but elements from different rows (even neighboring rows) are not.</p>&#13;
<p class="indent">Once allocated, individual elements of the 2D array can be accessed using double-indexing notation. The first index specifies an element in the outer array of <span class="literal">int *</span> pointers (which row), and the second index specifies an element in the inner <span class="literal">int</span> array (which column within the row).</p>&#13;
<p class="programs">int i, j;<br/>&#13;
<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    for (j = 0; j &lt; M; j++) {<br/>&#13;
        two_d_array[i][j] = 0;<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="indent">To understand how double indexing is evaluated, consider the type and value of the following parts of the expression:</p>&#13;
<p class="programs">       two_d_array: an array of int pointers, it stores the base address of an<br/>&#13;
                 array of (int *) values. Its type is int** (a pointer to <br/>&#13;
                 int *).<br/>&#13;
<br/>&#13;
    two_d_array[i]: the ith index into the array of arrays, it stores an <br/>&#13;
                 (int *) value that represents the base address of an array of <br/>&#13;
                 (int) values.  Its type is int*.<br/>&#13;
<br/>&#13;
 two_d_array[i][j]: the jth element pointed to by the ith element of the array<br/>&#13;
                of arrays, it stores an int value (the value in row i, column <br/>&#13;
                j of the 2D array).  Its type is int.</p>&#13;
<h5 class="h5" id="lev3_18">Method 2 (An Array of Arrays) and Function Parameters</h5>&#13;
<p class="noindent">The array argument’s type is <span class="literal">int **</span> (a pointer to a pointer to an <span class="literal">int</span>), and the function parameter matches its argument’s type. Additionally, row and column sizes should be passed to the function. Because this is a different type from method 1, both array types cannot use a common function (they are not the same C type).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_93"/>Here’s an example function that takes a method 2 (array of arrays) 2D array as a parameter:</p>&#13;
<p class="programs">/*<br/>&#13;
 * initialize a 2D array<br/>&#13;
 * arr: the array<br/>&#13;
 * rows: number of rows<br/>&#13;
 * cols: number of columns<br/>&#13;
 */<br/>&#13;
void init2D_Method2(int **arr, int rows, int cols) {<br/>&#13;
    int i,j;<br/>&#13;
<br/>&#13;
    for (i = 0; i &lt; rows; i++) {<br/>&#13;
        for (j = 0; j &lt; cols; j++) {<br/>&#13;
            arr[i][j] = 0;<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
}<br/>&#13;
<br/>&#13;
/*<br/>&#13;
 * main: example of calling init2D_Method2<br/>&#13;
 */<br/>&#13;
int main() {<br/>&#13;
    int **two_d_array;<br/>&#13;
<br/>&#13;
    // some code to allocate the row array and multiple col arrays<br/>&#13;
    // ...<br/>&#13;
<br/>&#13;
    init2D_Method2(two_d_array, N, M);<br/>&#13;
    ...</p>&#13;
<p class="indent">Here, the function implementation can use double-indexing syntax. Unlike statically declared 2D arrays, both the row and column dimensions need to be passed as parameters: the <span class="literal">rows</span> parameter specifies the bounds on the outermost array (the array of row arrays), and the <span class="literal">cols</span> parameter specifies the bounds on the inner arrays (the array column values for each row).</p>&#13;
<h3 class="h3" id="lev1_14">2.6 Strings and the String Library</h3>&#13;
<p class="noindent">In the previous chapter, we introduced “Arrays and Strings” (<a href="ch01.xhtml#lev1_5">page 44</a>). In this chapter, we discuss dynamically allocated C strings and their use with the C string library. We first give a brief overview of statically declared strings.</p>&#13;
<h4 class="h4" id="lev2_24"><span epub:type="pagebreak" id="page_94"/>2.6.1 C’s Support for Statically Allocated Strings (Arrays of char)</h4>&#13;
<p class="noindent">C does not support a separate string type, but a string can be implemented in C programs using an array of <span class="literal">char</span> values that is terminated by a special null character value <span class="literal">’\0’</span>. The terminating null character identifies the end of the sequence of character values that make up a string. Not every character array is a C string, but every C string is an array of <span class="literal">char</span> values.</p>&#13;
<p class="indent">Because strings frequently appear in programs, C provides libraries with functions for manipulating strings. Programs that use the C string library need to include <span class="literal">string.h</span>. Most string library functions require the programmer to allocate space for the array of characters that the functions manipulate. When printing out the value of a string, use the <span class="literal">%s</span> placeholder.</p>&#13;
<p class="indent">Here’s an example program that uses strings and some string library functions:</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;string.h&gt;   // include the C string library<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    char str1[10];<br/>&#13;
    char str2[10];<br/>&#13;
<br/>&#13;
    str1[0] = 'h';<br/>&#13;
    str1[1] = 'i';<br/>&#13;
    str1[2] = '\0';   // explicitly add null terminating character to end<br/>&#13;
<br/>&#13;
    // strcpy copies the bytes from the source parameter (str1) to the<br/>&#13;
    // destination parameter (str2) and null terminates the copy.<br/>&#13;
    strcpy(str2, str1);<br/>&#13;
    str2[1] = 'o';<br/>&#13;
    printf("%s %s\n", str1, str2);  // prints: hi ho<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<h4 class="h4" id="lev2_25">2.6.2 Dynamically Allocating Strings</h4>&#13;
<p class="noindent">Arrays of characters can be dynamically allocated (as discussed in “C’s Pointer Variables” on <a href="ch02.xhtml#lev1_10">page 66</a> and “Arrays in C” on <a href="ch02.xhtml#lev1_13">page 81</a>). When dynamically allocating space to store a string, it’s important to remember to allocate space in the array for the terminating <span class="literal">'\0'</span> character at the end of the string.</p>&#13;
<p class="indent">The following example program demonstrates static and dynamically allocated strings (note the value passed to <span class="literal">malloc</span>):</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include &lt;string.h&gt;<br/><span epub:type="pagebreak" id="page_95"/>&#13;
int main() {<br/>&#13;
    int size;<br/>&#13;
    char str[64];         // statically allocated<br/>&#13;
    char *new_str = NULL; // for dynamically allocated<br/>&#13;
<br/>&#13;
    strcpy(str, "Hello");<br/>&#13;
    size = strlen(str);   // returns 5<br/>&#13;
<br/>&#13;
    new_str = malloc(sizeof(char) * (size+1)); // need space for '\0'<br/>&#13;
    if(new_str == NULL) {<br/>&#13;
        printf("Error: malloc failed!  exiting.\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
    strcpy(new_str, str);<br/>&#13;
    printf("%s %s\n", str, new_str);    // prints "Hello Hello"<br/>&#13;
<br/>&#13;
    strcat(str, " There");  // concatenate " There" to the end of str<br/>&#13;
    printf("%s\n", str);    // prints "Hello There"<br/>&#13;
<br/>&#13;
    free(new_str);  // free malloc'ed space when done<br/>&#13;
    new_str = NULL;<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="note"><strong><span class="black">Warning</span> C STRING FUNCTIONS AND DESTINATION MEMORY</strong></p>&#13;
<p class="note-w">Many C string functions (notably <span class="literal">strcpy</span> and <span class="literal">strcat</span>) store their results by following a <em>destination</em> string pointer (<span class="literal">char *</span>) parameter and writing to the location it points to. Such functions assume that the destination contains enough memory to store the result. Thus, as a programmer, you must ensure that sufficient memory is available at the destination prior to calling these functions.</p>&#13;
<p class="note-w">Failure to allocate enough memory will yield undefined results that range from program crashes to major security vulnerabilities (see “Real World: Buffer Overflow” on <a href="ch07.xhtml#lev1_60">page 362</a>). For example, the following calls to <span class="literal">strcpy</span> and <span class="literal">strcat</span> demonstrate mistakes that novice C programmers often make:</p>&#13;
<p class="programs-l">// Attempt to write a 12-byte string into a 5-character array.<br/>&#13;
char mystr[5];<br/>&#13;
strcpy(mystr, "hello world");<br/>&#13;
<br/>&#13;
// Attempt to write to a string with a NULL destination.<br/>&#13;
char *mystr = NULL;<br/>&#13;
strcpy(mystr, "try again");<br/>&#13;
<br/>&#13;
<br/>&#13;
// Attempt to modify a read-only string literal.<br/>&#13;
char *mystr = "string literal value";<br/>&#13;
strcat(mystr, "string literals aren't writable");</p>&#13;
<h4 class="h4" id="lev2_26"><span epub:type="pagebreak" id="page_96"/>2.6.3 Libraries for Manipulating C Strings and Characters</h4>&#13;
<p class="noindent">C provides several libraries with functions for manipulating strings and characters. The string library (<span class="literal">string.h</span>) is particularly useful when writing programs that use C strings. The <span class="literal">stdlib.h</span> and <span class="literal">stdio.h</span> libraries also contain functions for string manipulation, and the <span class="literal">ctype.h</span> library contains functions for manipulating individual character values.</p>&#13;
<p class="indent">When using C string library functions, it’s important to remember that most do not allocate space for the strings they manipulate, nor do they check that you pass in valid strings; your program must allocate space for the strings that the C string library will use. Furthermore, if the library function modifies the passed string, then the caller needs to ensure that the string is correctly formatted (i.e., that it has a terminating <span class="literal">’\0’</span> character at the end). Calling string library functions with bad array argument values will often cause a program to crash. The documentation (e.g., manual pages) for different library functions specifies whether the library function allocates space or if the caller is responsible for passing in allocated space to the library function.</p>&#13;
<p class="note"><strong><span class="black">Note</span> CHAR[] AND CHAR * PARAMETERS AND CHAR * RETURN TYPE</strong></p>&#13;
<p class="note1">Both statically declared and dynamically allocated arrays of characters can be passed to a <span class="literal">char *</span> parameter because the name of either type of variable evaluates to the base address of the array in memory. Declaring the parameter as type <span class="literal">char []</span> will also work for both statically and dynamically allocated argument values, but <span class="literal">char *</span> is more commonly used for specifying the type of string (array of <span class="literal">char</span>) parameters.</p>&#13;
<p class="note1">If a function returns a string (its return type is a <span class="literal">char *</span>), its return value can only be assigned to a variable whose type is also <span class="literal">char *</span>; it cannot be assigned to a statically allocated array variable. This restriction exists because the name of a statically declared array variable is not a valid <em>lvalue</em> (its base address in memory cannot be changed; see “Accessing Field Values” on <a href="ch01.xhtml#lev2_15">page 57</a>), so it cannot be assigned a <span class="literal">char *</span> return value.</p>&#13;
<h5 class="h5" id="lev3_19">strlen, strcpy, strncpy</h5>&#13;
<p class="noindent">The string library provides functions for copying strings and finding the length of a string:</p>&#13;
<p class="programs">// returns the number of characters in the string <br/>&#13;
// (not including the null character)<br/>&#13;
int strlen(char *s);<br/>&#13;
<br/>&#13;
// copies string src to string dst up until the first '\0' character in src<br/>&#13;
// (the caller needs to make sure src is initialized correctly and<br/>&#13;
// dst has enough space to store a copy of the src string)<br/>&#13;
// returns the address of the dst string<br/>&#13;
char *strcpy(char *dst, char *src);<br/>&#13;
<span epub:type="pagebreak" id="page_97"/>// like strcpy but copies up to the first '\0' or size characters<br/>&#13;
// (this provides some safety to not copy beyond the bounds of the dst<br/>&#13;
// array if the src string is not well formed or is longer than the<br/>&#13;
// space available in the dst array); size_t is an unsigned integer type<br/>&#13;
char *strncpy(char *dst, char *src, size_t size);</p>&#13;
<p class="indent">The <span class="literal">strcpy</span> function is unsafe to use in situations when the source string might be longer than the total capacity of the destination string. In this case, one should use <span class="literal">strncpy</span>. The size parameter stops <span class="literal">strncpy</span> from copying more than <span class="literal">size</span> characters from the <span class="literal">src</span> string into the <span class="literal">dst</span> string. When the length of the <span class="literal">src</span> string is greater than or equal to <span class="literal">size</span>, <span class="literal">strncpy</span> copies the first <span class="literal">size</span> characters from <span class="literal">src</span> to <span class="literal">dst</span> and does not add a null character to the end of the <span class="literal">dst</span>. As a result, the programmer should explicitly add a null character to the end of <span class="literal">dst</span> after calling <span class="literal">strncpy</span>.</p>&#13;
<p class="indent">Here are some example uses of these functions in a program:</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include &lt;string.h&gt;   // include the string library<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    // variable declarations that will be used in examples<br/>&#13;
    int len, i, ret;<br/>&#13;
    char str[32];<br/>&#13;
    char *d_str, *ptr;<br/>&#13;
<br/>&#13;
    strcpy(str, "Hello There");<br/>&#13;
    len = strlen(str);  // len is 11<br/>&#13;
<br/>&#13;
    d_str = malloc(sizeof(char) * (len+1));<br/>&#13;
    if (d_str == NULL) {<br/>&#13;
        printf("Error: malloc failed\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    strncpy(d_str, str, 5);<br/>&#13;
    d_str[5] = '\0';   // explicitly add null terminating character to end<br/>&#13;
    <br/>&#13;
    printf("%d:%s\n", strlen(str), str);      // prints 11:Hello There<br/>&#13;
    printf("%d:%s\n", strlen(d_str), d_str);  // prints 5:Hello<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<h5 class="h5" id="lev3_20">strcmp, strncmp</h5>&#13;
<p class="noindent">The string library also provides a function to compare two strings. Comparing string variables using the <span class="literal">==</span> operator <em>does not</em> compare the characters in <span epub:type="pagebreak" id="page_98"/>the strings—it compares only the base addresses of the two strings. For example, the expression</p>&#13;
<p class="programs">if (d_str == str) { ...</p>&#13;
<p class="noindent">compares the base address of the <span class="literal">char</span> array in the heap pointed to by <span class="literal">d_str</span> to the base address of the <span class="literal">str char</span> array allocated on the stack.</p>&#13;
<p class="indent">To compare the values of the strings, a programmer needs to either write code by hand to compare corresponding element values, or use the <span class="literal">strcmp</span> or <span class="literal">strncmp</span> functions from the string library:</p>&#13;
<p class="programs">int strcmp(char *s1, char *s2);<br/>&#13;
// returns 0 if s1 and s2 are the same strings<br/>&#13;
// a value &lt; 0 if s1 is less than s2<br/>&#13;
// a value &gt; 0 if s1 is greater than s2<br/>&#13;
<br/>&#13;
int strncmp(char *s1, char *s2, size_t n);<br/>&#13;
// compare s1 and s2 up to at most n characters</p>&#13;
<p class="indent">The <span class="literal">strcmp</span> function compares strings character by character based on their <em>ASCII representation</em> (see “Notes” on <a href="ch01.xhtml#lev1_8">page 189</a>). In other words, it compares the <span class="literal">char</span> values in corresponding positions of the two parameter arrays to produce the result of the string comparison, which occasionally yields unintuitive results. For example, the ASCII encoding for the <span class="literal">char</span> value <span class="literal">’a’</span> is <em>larger</em> than the encoding for the <span class="literal">char</span> value <span class="literal">’Z’</span>. Thus, <span class="literal">strcmp("aaa", "Zoo")</span> returns a positive value indicating that <span class="literal">"aaa"</span> is greater than <span class="literal">"Zoo"</span>, and a call to <span class="literal">strcmp("aaa", "zoo")</span> returns a negative value indicating that <span class="literal">"aaa"</span> is less than <span class="literal">"zoo"</span>.</p>&#13;
<p class="indent">Here are some string comparison examples:</p>&#13;
<p class="programs">strcpy(str, "alligator");<br/>&#13;
strcpy(d_str, "Zebra");<br/>&#13;
<br/>&#13;
ret =  strcmp(str,d_str);<br/>&#13;
if (ret == 0) {<br/>&#13;
    printf("%s is equal to %s\n", str, d_str);<br/>&#13;
} else if (ret &lt; 0) {<br/>&#13;
    printf("%s is less than %s\n", str, d_str);<br/>&#13;
} else {<br/>&#13;
    printf("%s is greater than %s\n", str, d_str);  // true for these strings<br/>&#13;
}<br/>&#13;
<br/>&#13;
ret = strncmp(str, "all", 3);  // returns 0: they are equal up to first 3 chars</p>&#13;
<h5 class="h5" id="lev3_21">strcat, strstr, strchr</h5>&#13;
<p class="noindent">String library functions can concatenate strings (note that it’s up to the caller to ensure that the destination string has enough space to store the result):</p>&#13;
<span epub:type="pagebreak" id="page_99"/>&#13;
<p class="programs">// append chars from src to end of dst<br/>&#13;
// returns ptr to dst and adds '\0' to end<br/>&#13;
char *strcat(char *dst, char *src)<br/>&#13;
<br/>&#13;
// append the first chars from src to end of dst, up to a maximum of size<br/>&#13;
// returns ptr to dst and adds '\0' to end<br/>&#13;
char *strncat(char *dst, char *src, size_t size);</p>&#13;
<p class="indent">It also provides functions for finding substrings or character values in strings:</p>&#13;
<p class="programs">// locate a substring inside a string<br/>&#13;
// (const means that the function doesn't modify string)<br/>&#13;
// returns a pointer to the beginning of substr in string<br/>&#13;
// returns NULL if substr not in string<br/>&#13;
char *strstr(const char *string, char *substr);<br/>&#13;
<br/>&#13;
// locate a character (c) in the passed string (s)<br/>&#13;
// (const means that the function doesn't modify s)<br/>&#13;
// returns a pointer to the first occurrence of the char c in string<br/>&#13;
// or NULL if c is not in the string<br/>&#13;
char *strchr(const char *s, int c);</p>&#13;
<p class="indent">Here are some examples using these functions (we omit some error handling for the sake of readability):</p>&#13;
<p class="programs">char str[32];<br/>&#13;
char *ptr;<br/>&#13;
<br/>&#13;
strcpy(str, "Zebra fish");<br/>&#13;
strcat(str, " stripes");  // str gets "Zebra fish stripes"<br/>&#13;
printf("%s\n", str);     // prints: Zebra fish stripes<br/>&#13;
<br/>&#13;
strncat(str, " are black.", 8);<br/>&#13;
printf("%s\n", str);     // prints: Zebra fish stripes are bla  (spaces count)<br/>&#13;
<br/>&#13;
ptr = strstr(str, "trip");<br/>&#13;
if (ptr != NULL) {<br/>&#13;
    printf("%s\n", ptr);   // prints: tripes are bla<br/>&#13;
}<br/>&#13;
<br/>&#13;
ptr = strchr(str, 'e');<br/>&#13;
if (ptr != NULL) {<br/>&#13;
    printf("%s\n", ptr);   // prints: ebra fish stripes are bla<br/>&#13;
}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>Calls to <span class="literal">strchr</span> and <span class="literal">strstr</span> return the address of the first element in the parameter array with a matching character value or a matching substring value, respectively. This element address is the start of an array of <span class="literal">char</span> values terminated by a <span class="literal">’\0’</span> character. In other words, <span class="literal">ptr</span> points to the beginning of a substring inside another string. When printing the value of <span class="literal">ptr</span> as a string with <span class="literal">printf</span>, the character values starting at the index pointed to by <span class="literal">ptr</span> are printed, yielding the results listed in the preceding example.</p>&#13;
<h5 class="h5" id="lev3_22">strtok, strtok_r</h5>&#13;
<p class="noindent">The string library also provides functions that divide a string into tokens. A <em>token</em> refers to a subsequence of characters in a string separated by any number of delimiter characters of the programmer’s choosing.</p>&#13;
<p class="programs">char *strtok(char *str, const char *delim);<br/>&#13;
<br/>&#13;
// a reentrant version of strtok (reentrant is defined in later chapters):<br/>&#13;
char *strtok_r(char *str, const char *delim, char **saveptr);</p>&#13;
<p class="indent">The <span class="literal">strtok</span> (or <span class="literal">strtok_r</span>) functions find individual tokens within a larger string. For example, setting <span class="literal">strtok</span>’s delimiters to the set of whitespace characters yields words in a string that originally contains an English sentence. That is, each word in the sentence is a token in the string.</p>&#13;
<p class="indent">Following is an example program that uses <span class="literal">strtok</span> to find individual words as the tokens in an input string.<sup><a href="ch02.xhtml#fn2_2" id="rfn2_2">2</a></sup></p>&#13;
<p class="programs">/*<br/>&#13;
 * Extract whitespace-delimited tokens from a line of input<br/>&#13;
 * and print them one per line.<br/>&#13;
 *<br/>&#13;
 * to compile:<br/>&#13;
 *   gcc -g -Wall strtokexample.c<br/>&#13;
 *<br/>&#13;
 * example run:<br/>&#13;
 *   Enter a line of text:        aaaaa             bbbbbbbbb          cccccc<br/>&#13;
 *<br/>&#13;
 *   The input line is:<br/>&#13;
 *         aaaaa             bbbbbbbbb          cccccc<br/>&#13;
 *   Next token is aaaaa<br/>&#13;
 *   Next token is bbbbbbbbb<br/>&#13;
 *   Next token is cccccc<br/>&#13;
 */<br/>&#13;
<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;string.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
     /* whitespace stores the delim string passed to strtok.  The delim<br/>&#13;
<span epub:type="pagebreak" id="page_101"/>&#13;
      * string  is initialized to the set of characters that delimit tokens<br/>&#13;
      * We initialize the delim string to the following set of chars:<br/>&#13;
      *   ' ': space  '\t': tab  '\f': form feed  '\r': carriage return<br/>&#13;
      *   '\v': vertical tab  '\n': new line<br/>&#13;
      * (run "man ascii" to list all ASCII characters)<br/>&#13;
      *<br/>&#13;
      * This line shows one way to statically initialize a string variable<br/>&#13;
      * (using this method the string contents are constant, meaning that they<br/>&#13;
      *  cannot be modified, which is fine for the way we are using the<br/>&#13;
      *  whitespace string in this program).<br/>&#13;
      */<br/>&#13;
    char *whitespace = " \t\f\r\v\n";  /* Note the space char at beginning */<br/>&#13;
<br/>&#13;
    char *token;  /* The next token in the line. */<br/>&#13;
    char *line;   /* The line of text read in that we will tokenize. */<br/>&#13;
<br/>&#13;
    /* Allocate some space for the user's string on the heap. */<br/>&#13;
    line = malloc(200 * sizeof(char));<br/>&#13;
    if (line == NULL) {<br/>&#13;
        printf("Error: malloc failed\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    /* Read in a line entered by the user from "standard in". */<br/>&#13;
    printf("Enter a line of text:\n");<br/>&#13;
    line = fgets(line, 200 * sizeof(char), stdin);<br/>&#13;
    if (line == NULL) {<br/>&#13;
        printf("Error: reading input failed, exiting...\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
    printf("The input line is:\n%s\n", line);<br/>&#13;
<br/>&#13;
    /* Divide the string into tokens. */<br/>&#13;
    token = strtok(line, whitespace);       /* get the first token */<br/>&#13;
    while (token != NULL) {<br/>&#13;
        printf("Next token is %s\n", token);<br/>&#13;
        token = strtok(NULL, whitespace);     /* get the next token */<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    free(line);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<h5 class="h5" id="lev3_23"><span epub:type="pagebreak" id="page_102"/>sprintf</h5>&#13;
<p class="noindent">The C <span class="literal">stdio</span> library also provides functions that manipulate C strings. Perhaps the most useful is the <span class="literal">sprintf</span> function, which “prints” into a string rather than printing output to a terminal:</p>&#13;
<p class="programs">// like printf(), the format string allows for placeholders like %d, %f, etc.<br/>&#13;
// pass parameters after the format string to fill them in<br/>&#13;
int sprintf(char *s, const char *format, ...);</p>&#13;
<p class="indent"><span class="literal">sprintf</span> initializes the contents of a string from values of various types. Its parameter <span class="literal">format</span> resembles those of <span class="literal">printf</span> and <span class="literal">scanf</span>. Here are some examples:</p>&#13;
<p class="programs">char str[64];<br/>&#13;
float ave = 76.8;<br/>&#13;
int num = 2;<br/>&#13;
<br/>&#13;
// initialize str to format string, filling in each placeholder with<br/>&#13;
// a char representation of its arguments' values<br/>&#13;
sprintf(str, "%s is %d years old and in grade %d", "Henry", 12, 7);<br/>&#13;
printf("%s\n", str);  // prints: Henry is 12 years old and in grade 7<br/>&#13;
<br/>&#13;
sprintf(str, "The average grade on exam %d is %g", num, ave);<br/>&#13;
printf("%s\n", str);  // prints: The average grade on exam 2 is 76.8</p>&#13;
<h5 class="h5" id="lev3_24">Functions for Individual Character Values</h5>&#13;
<p class="noindent">The standard C library (<span class="literal">stdlib.h</span>) contains a set of functions for manipulating and testing individual <span class="literal">char</span> values, including:</p>&#13;
<p class="programs">#include &lt;stdlib.h&gt;   // include stdlib and ctype to use these<br/>&#13;
#include &lt;ctype.h&gt;<br/>&#13;
<br/>&#13;
int islower(ch);<br/>&#13;
int isupper(ch);       // these functions return a non-zero value if the<br/>&#13;
int isalpha(ch);       // test is TRUE, otherwise they return 0 (FALSE)<br/>&#13;
int isdigit(ch);<br/>&#13;
int isalnum(ch);<br/>&#13;
int ispunct(ch);<br/>&#13;
int isspace(ch);<br/>&#13;
char tolower(ch);     // returns ASCII value of lower-case of argument<br/>&#13;
char toupper(ch);</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>Here are some examples of their use:</p>&#13;
<p class="programs">char str[64];<br/>&#13;
int len, i;<br/>&#13;
<br/>&#13;
strcpy(str, "I see 20 ZEBRAS, GOATS, and COWS");<br/>&#13;
<br/>&#13;
if ( islower(str[2]) ){<br/>&#13;
    printf("%c is lower case\n", str[2]);   // prints: s is lower case<br/>&#13;
}<br/>&#13;
<br/>&#13;
len = strlen(str);<br/>&#13;
for (i = 0; i &lt; len; i++) {<br/>&#13;
    if ( isupper(str[i]) ) {<br/>&#13;
        str[i] = tolower(str[i]);<br/>&#13;
    } else if( isdigit(str[i]) ) {<br/>&#13;
        str[i] = 'X';<br/>&#13;
    }<br/>&#13;
}<br/>&#13;
printf("%s\n", str);  // prints: i see XX zebras, goats, and cows</p>&#13;
<h5 class="h5" id="lev3_25">Functions to Convert Strings to Other Types</h5>&#13;
<p class="noindent"><span class="literal">stdlib.h</span> also contains functions to convert between strings and other C types. For example:</p>&#13;
<p class="programs">#include &lt;stdlib.h&gt;<br/>&#13;
<br/>&#13;
int atoi(const char *nptr);     // convert a string to an integer<br/>&#13;
double atof(const char *nptr);  // convert a string to a float</p>&#13;
<p class="indent">Here’s an example:</p>&#13;
<p class="programs">printf("%d %g\n", atoi("1234"), atof("4.56"));</p>&#13;
<p class="indent">For more information about these and other C library functions (including what they do, their parameter format, what they return, and which headers need to be included to use them), see their <em>man pages</em>.<sup><a href="ch02.xhtml#fn2_3" id="rfn2_3">3</a></sup> For example, to view the <span class="literal">strcpy</span> man page, run:</p>&#13;
<p class="programs">$ <span class="codestrong1">man strcpy</span></p>&#13;
<h3 class="h3" id="lev1_15">2.7 C Structs</h3>&#13;
<p class="noindent">In the previous chapter, we introduced C structures in “Structs” on <a href="ch01.xhtml#lev1_6">page 52</a>. In this chapter, we dive deeper into C structs, examine statically and dynamically allocated structs, and combine structs and pointers to create more complex data types and data structures.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_104"/>We begin with a quick overview of statically declared structs. See the previous chapter for more details.</p>&#13;
<h4 class="h4" id="lev2_27">2.7.1 Review of the C struct Type</h4>&#13;
<p class="noindent">A <span class="literal">struct</span> type represents a heterogeneous collection of data; it’s a mechanism for treating a set of different types as a single, coherent unit.</p>&#13;
<p class="indent">There are three steps to defining and using <span class="literal">struct</span> types in C programs:</p>&#13;
<div class="number">&#13;
<p class="number">1. Define a <span class="literal">struct</span> type that defines the field values and their types.</p>&#13;
<p class="number">2. Declare variables of the <span class="literal">struct</span> type.</p>&#13;
<p class="number">3. Use <em>dot notation</em> to access individual field values in the variable.</p>&#13;
</div>&#13;
<p class="indent">In C, structs are lvalues (they can appear on the left-hand side of an assignment statement; see “Accessing Field Values” on <a href="ch01.xhtml#lev2_15">page 57</a>). The value of a <span class="literal">struct</span> variable is the contents of its memory (all of the bytes making up its field values). When calling functions with <span class="literal">struct</span> parameters, the value of the <span class="literal">struct</span> argument (a copy of all of the bytes of all of its fields) gets copied to the <span class="literal">struct</span> function parameter.</p>&#13;
<p class="indent">When programming with structs, and in particular when combining structs and arrays, it’s critical to carefully consider the type of every expression. Each field in a <span class="literal">struct</span> represents a specific type, and the syntax for accessing field values and the semantics of passing individual field values to functions follow those of their specific type.</p>&#13;
<p class="indent">The following full example program demonstrates defining a <span class="literal">struct</span> type, declaring variables of that type, accessing field values, and passing structs and individual field values to functions (we omit some error handling and comments for readability):</p>&#13;
<p class="margnote">struct_review.c</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;string.h&gt;<br/>&#13;
<br/>&#13;
/* define a new struct type (outside function bodies) */<br/>&#13;
struct studentT {<br/>&#13;
    char  name[64];<br/>&#13;
    int   age;<br/>&#13;
    float gpa;<br/>&#13;
    int   grad_yr;<br/>&#13;
};<br/>&#13;
<br/>&#13;
/* function prototypes */<br/>&#13;
int checkID(struct studentT s1, int min_age);<br/>&#13;
void changeName(char *old, char *new);<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int can_vote;<br/>&#13;
    // declare variables of struct type:<br/>&#13;
    struct studentT student1, student2;<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_105"/>&#13;
    // access field values using .<br/>&#13;
    strcpy(student1.name, "Ruth");<br/>&#13;
    student1.age = 17;<br/>&#13;
    student1.gpa = 3.5;<br/>&#13;
    student1.grad_yr = 2021;<br/>&#13;
<br/>&#13;
    // structs are lvalues<br/>&#13;
    student2 = student1;<br/>&#13;
    strcpy(student2.name, "Frances");<br/>&#13;
    student2.age = student1.age + 4;<br/>&#13;
<br/>&#13;
    // passing a struct<br/>&#13;
    can_vote = checkID(student1, 18);<br/>&#13;
    printf("%s %d\n", student1.name, can_vote);<br/>&#13;
<br/>&#13;
    can_vote = checkID(student2, 18);<br/>&#13;
    printf("%s %d\n", student2.name, can_vote);<br/>&#13;
<br/>&#13;
    // passing a struct field value<br/>&#13;
    changeName(student2.name, "Kwame");<br/>&#13;
    printf("student 2's name is now %s\n", student2.name);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int checkID(struct studentT s, int min_age) {<br/>&#13;
    int ret = 1;<br/>&#13;
<br/>&#13;
    if (s.age &lt; min_age) {<br/>&#13;
        ret = 0;<br/>&#13;
        // changes age field IN PARAMETER COPY ONLY<br/>&#13;
        s.age = min_age + 1;<br/>&#13;
    }<br/>&#13;
    return ret;<br/>&#13;
}<br/>&#13;
<br/>&#13;
void changeName(char *old, char *new) {<br/>&#13;
    if ((old == NULL) || (new == NULL)) {<br/>&#13;
        return;<br/>&#13;
    }<br/>&#13;
    strcpy(old,new);<br/>&#13;
}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_106"/>When run, the program produces:</p>&#13;
<p class="programs">Ruth 0<br/>&#13;
Frances 1<br/>&#13;
student 2's name is now Kwame</p>&#13;
<p class="indent">When working with structs, it’s particularly important to think about the types of the <span class="literal">struct</span> and its fields. For example, when passing a <span class="literal">struct</span> to a function, the parameter gets a copy of the <span class="literal">struct</span>’s value (a copy of all the bytes from the argument). Consequently, changes to the parameter’s field values <em>do not</em> change the argument’s value. This behavior is illustrated in the preceding program in the call to <span class="literal">checkID</span>, which modifies the parameter’s age field. The changes in <span class="literal">checkID</span> have no effect on the corresponding argument’s age field value.</p>&#13;
<p class="indent">When passing a field of a <span class="literal">struct</span> to a function, the semantics match the type of the field (the type of the function’s parameter). For example, in the call to <span class="literal">changeName</span>, the value of the <span class="literal">name</span> field (the base address of the <span class="literal">name</span> array inside the <span class="literal">student2</span> struct) gets copied to the parameter <span class="literal">old</span>, meaning that the parameter refers to the same set of array elements in memory as its argument. Thus, changing an element of the array in the function also changes the element’s value in the argument; the semantics of passing the <span class="literal">name</span> field match the type of the <span class="literal">name</span> field.</p>&#13;
<h4 class="h4" id="lev2_28">2.7.2 Pointers and Structs</h4>&#13;
<p class="noindent">Just like other C types, programmers can declare a variable as a pointer to a user-defined <span class="literal">struct</span> type. The semantics of using a <span class="literal">struct</span> pointer variable resemble those of other pointer types such as <span class="literal">int *</span>.</p>&#13;
<p class="indent">Consider the <span class="literal">struct studentT</span> type introduced in the previous program example:</p>&#13;
<p class="programs">struct studentT {<br/>&#13;
    char  name[64];<br/>&#13;
    int   age;<br/>&#13;
    float gpa;<br/>&#13;
    int   grad_yr;<br/>&#13;
};</p>&#13;
<p class="indent">A programmer can declare variables of type <span class="literal">struct studentT</span> or <span class="literal">struct</span> <span class="literal">studentT *</span> (a pointer to a <span class="literal">struct studentT</span>):</p>&#13;
<p class="programs">struct studentT s;<br/>&#13;
struct studentT *sptr;<br/>&#13;
<br/>&#13;
// think very carefully about the type of each field when<br/>&#13;
// accessing it (name is an array of char, age is an int ...)<br/>&#13;
strcpy(s.name, "Freya");<br/>&#13;
s.age = 18;<br/>&#13;
s.gpa = 4.0;<br/>&#13;
<span epub:type="pagebreak" id="page_107"/>&#13;
s.grad_yr = 2020;<br/>&#13;
<br/>&#13;
// malloc space for a struct studentT for sptr to point to:<br/>&#13;
sptr = malloc(sizeof(struct studentT));<br/>&#13;
if (sptr == NULL) {<br/>&#13;
    printf("Error: malloc failed\n");<br/>&#13;
    exit(1);<br/>&#13;
}</p>&#13;
<p class="indent">Note that the call to <span class="literal">malloc</span> initializes <span class="literal">sptr</span> to point to a dynamically allocated struct in heap memory. Using the <span class="literal">sizeof</span> operator to compute <span class="literal">malloc</span>’s size request (e.g., <span class="literal">sizeof(struct studentT)</span>) ensures that <span class="literal">malloc</span> allocates space for <em>all</em> of the field values in the struct.</p>&#13;
<p class="indent">To access individual fields in a pointer to a <span class="literal">struct</span>, the pointer variable first needs to be <em>dereferenced</em>. Based on the rules for pointer dereferencing (see “C’s Pointer Variables” on <a href="ch02.xhtml#lev1_10">page 66</a>), you may be tempted to access <span class="literal">struct</span> fields like so:</p>&#13;
<p class="programs">// the grad_yr field of what sptr points to gets 2021:<br/>&#13;
(*sptr).grad_yr = 2021;<br/>&#13;
<br/>&#13;
// the age field of what sptr points to gets s.age plus 1:<br/>&#13;
(*sptr).age = s.age + 1;</p>&#13;
<p class="indent">However, because pointers to structs are so commonly used, C provides a special operator (<span class="literal">-&gt;</span>) that both dereferences a <span class="literal">struct</span> pointer and accesses one of its field values. For example, <span class="literal">sptr-&gt;year</span> is equivalent to <span class="literal">(*sptr).year</span>. Here are some examples of accessing field values using this notation:</p>&#13;
<p class="programs">// the gpa field of what sptr points to gets 3.5:<br/>&#13;
sptr-&gt;gpa = 3.5;<br/>&#13;
<br/>&#13;
// the name field of what sptr points to is a char *<br/>&#13;
// (can use strcpy to init its value):<br/>&#13;
strcpy(sptr-&gt;name, "Lars");</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig14">Figure 2-14</a> sketches what the variables <span class="literal">s</span> and <span class="literal">sptr</span> may look like in memory after the preceding code executes. Recall that <span class="literal">malloc</span> allocates memory from the heap, and local variables are allocated on the stack.</p>&#13;
<span epub:type="pagebreak" id="page_108"/>&#13;
<div class="imagec" id="ch2fig14"><img alt="image" src="../images/02fig14.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-14: The differences in memory layout between a statically allocated struct (data on the stack) and a dynamically allocated struct (data on the heap)</em></p>&#13;
<h4 class="h4" id="lev2_29">2.7.3 Pointer Fields in Structs</h4>&#13;
<p class="noindent">Structs can also be defined to have pointer types as field values. Here’s an example:</p>&#13;
<p class="programs">struct personT {<br/>&#13;
    char *name;     // for a dynamically allocated string field<br/>&#13;
    int  age;<br/>&#13;
};<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    struct personT p1, *p2;<br/>&#13;
<br/>&#13;
    // need to malloc space for the name field:<br/>&#13;
    p1.name = malloc(sizeof(char) * 8);<br/>&#13;
    strcpy(p1.name, "Zhichen");<br/>&#13;
    p1.age = 22;<br/>&#13;
<br/>&#13;
<br/>&#13;
    // first malloc space for the struct:<br/>&#13;
    p2 = malloc(sizeof(struct personT));<br/>&#13;
<br/>&#13;
    // then malloc space for the name field:<br/>&#13;
    p2-&gt;name = malloc(sizeof(char) * 4);<br/>&#13;
    strcpy(p2-&gt;name, "Vic");<br/>&#13;
    p2-&gt;age = 19;<br/>&#13;
    ...<br/>&#13;
<br/>&#13;
    // Note: for strings, we must allocate one extra byte to hold the<br/>&#13;
    // terminating null character that marks the end of the string.<br/>&#13;
}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>In memory, these variables will look like <a href="ch02.xhtml#ch2fig15">Figure 2-15</a> (note which parts are allocated on the stack and which are on the heap).</p>&#13;
<div class="imagec" id="ch2fig15"><img alt="image" src="../images/02fig15.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-15: The layout in memory of a struct with a pointer field</em></p>&#13;
<p class="indent">As structs and the types of their fields increase in complexity, be careful with their syntax. To access field values appropriately, start from the outermost variable type and use its type syntax to access individual parts. For example, the types of the <span class="literal">struct</span> variables shown in <a href="ch02.xhtml#ch2tab2">Table 2-2</a> govern how a programmer should access their fields.</p>&#13;
<p class="tabcap" id="ch2tab2"><strong>Table 2-2:</strong> Struct Field Access Examples</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Expression</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Type</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Field access syntax</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p1</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">struct personT</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p1.age, p1.name</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">struct personT *</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p2-&gt;age, p2-&gt;name</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Further, knowing the types of field values allows a program to use the correct syntax in accessing them, as shown by the examples in <a href="ch02.xhtml#ch2tab3">Table 2-3</a>.</p>&#13;
<p class="tabcap" id="ch2tab3"><strong>Table 2-3:</strong> Accessing Different Struct Field Types</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Expression</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Type</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Example access syntax</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p1.age</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p1.age = 18;</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p2-&gt;age</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int *</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p2-&gt;age = 18;</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p1.name</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">char *</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">printf("%s", p1.name);</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p2-&gt;name</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">char *</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">printf("%s", p2-&gt;name);</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p2-&gt;name[2]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">char</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">p2-&gt;name[2] = ’a’;</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">In examining the last example, start by considering the type of the outermost variable (<span class="literal">p2</span> is a pointer to a <span class="literal">struct personT</span>). Therefore, to access a field value in the struct, the programmer needs to use <span class="literal">-&gt;</span> syntax (<span class="literal">p2-&gt;name</span>). Next, consider the type of the <span class="literal">name</span> field, which is a <span class="literal">char *</span>, used in this program to point to an array of <span class="literal">char</span> values. To access a specific <span class="literal">char</span> storage location through the <span class="literal">name</span> field, use array indexing notation: <span class="literal">p2-&gt;name[2] =</span> <span class="literal">’a’</span>.</p>&#13;
<h4 class="h4" id="lev2_30"><span epub:type="pagebreak" id="page_110"/>2.7.4 Arrays of Structs</h4>&#13;
<p class="noindent">Arrays, pointers, and structs can be combined to create more complex data structures. Here are some examples of declaring variables of different types of arrays of structs:</p>&#13;
<p class="programs">struct studentT classroom1[40];   // an array of 40 struct studentT<br/>&#13;
<br/>&#13;
struct studentT *classroom2;      // a pointer to a struct studentT<br/>&#13;
                                  // (for a dynamically allocated array)<br/>&#13;
<br/>&#13;
struct studentT *classroom3[40];  // an array of 40 struct studentT *<br/>&#13;
                                  // (each element stores a (struct studentT *)</p>&#13;
<p class="indent">Again, thinking very carefully about variable and field types is necessary for understanding the syntax and semantics of using these variables in a program. Here are some examples of the correct syntax for accessing these variables:</p>&#13;
<p class="programs">// classroom1 is an array:<br/>&#13;
//    use indexing to access a particular element<br/>&#13;
//    each element in classroom1 stores a struct studentT:<br/>&#13;
//    use dot notation to access fields<br/>&#13;
classroom1[3].age = 21;<br/>&#13;
<br/>&#13;
// classroom2 is a pointer to a struct studentT<br/>&#13;
//    call malloc to dynamically allocate an array<br/>&#13;
//    of 15 studentT structs for it to point to:<br/>&#13;
classroom2 = malloc(sizeof(struct studentT) * 15);<br/>&#13;
<br/>&#13;
// each element in array pointed to by classroom2 is a studentT struct<br/>&#13;
//    use [] notation to access an element of the array, and dot notation<br/>&#13;
//    to access a particular field value of the struct at that index:<br/>&#13;
classroom2[3].year = 2013;<br/>&#13;
<br/>&#13;
// classroom3 is an array of struct studentT *<br/>&#13;
//    use [] notation to access a particular element<br/>&#13;
//    call malloc to dynamically allocate a struct for it to point to<br/>&#13;
classroom3[5] = malloc(sizeof(struct studentT));<br/>&#13;
<br/>&#13;
// access fields of the struct using -&gt; notation<br/>&#13;
// set the age field pointed to in element 5 of the classroom3 array to 21<br/>&#13;
classroom3[5]-&gt;age = 21;   </p>&#13;
<p class="indent">A function that takes an array of type <span class="literal">struct studentT *</span> as a parameter might look like this:</p>&#13;
<p class="programs">void updateAges(struct studentT *classroom, int size) {<br/>&#13;
    int i;<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_111"/>&#13;
    for (i = 0; i &lt; size; i++) {<br/>&#13;
        classroom[i].age += 1;<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="indent">A program could pass this function either a statically or dynamically allocated array of <span class="literal">struct studentT</span>:</p>&#13;
<p class="programs">updateAges(classroom1, 40);<br/>&#13;
updateAges(classroom2, 15);</p>&#13;
<p class="indent">The semantics of passing <span class="literal">classroom1</span> (or <span class="literal">classroom2</span>) to <span class="literal">updateAges</span> match the semantics of passing a statically declared (or dynamically allocated) array to a function: the parameter refers to the same set of elements as the argument and thus changes to the array’s values within the function affect the argument’s elements.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig16">Figure 2-16</a> shows what the stack might look like for the second call to the <span class="literal">updateAges</span> function (showing the passed <span class="literal">classroom2</span> array with example field values for the struct in each of its elements).</p>&#13;
<div class="imagec" id="ch2fig16"><img alt="image" src="../images/02fig16.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-16: The memory layout of an array of <span class="literal">struct studentT</span> passed to a function</em></p>&#13;
<p class="indent">As always, the parameter gets a copy of the value of its argument (the memory address of the array in heap memory). Thus, modifying the array’s elements in the function will persist to its argument’s values (both the parameter and the argument refer to the same array in memory).</p>&#13;
<p class="indent">The <span class="literal">updateAges</span> function cannot be passed the <span class="literal">classroom3</span> array because its type is not the same as the parameter’s type: <span class="literal">classroom3</span> is an array of <span class="literal">struct</span> <span class="literal">studentT *</span>, not an array of <span class="literal">struct studentT</span>.</p>&#13;
<h4 class="h4" id="lev2_31">2.7.5 Self-Referential Structs</h4>&#13;
<p class="noindent">A struct can be defined with fields whose type is a pointer to the same <span class="literal">struct</span> type. These self-referential <span class="literal">struct</span> types can be used to build linked implementations of data structures, such as linked lists, trees, and graphs.</p>&#13;
<p class="indent">The details of these data types and their linked implementations are beyond the scope of this book. However, we briefly show one example of how to define and use a self-referential <span class="literal">struct</span> type to create a linked list in C. Refer to a textbook on data structures and algorithms for more information about linked lists.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_112"/>A <em>linked list</em> is one way to implement a <em>list abstract data type</em>. A list represents a sequence of elements that are ordered by their position in the list. In C, a list data structure could be implemented as an array or as a linked list using a self-referential <span class="literal">struct</span> type for storing individual nodes in the list.</p>&#13;
<p class="indent">To build the latter, a programmer would define a <span class="literal">node</span> struct to contain one list element and a link to the next node in the list. Here’s an example that could store a linked list of integer values:</p>&#13;
<p class="programs">struct node {<br/>&#13;
    int data;           // used to store a list element's data value<br/>&#13;
    struct node *next;  // used to point to the next node in the list<br/>&#13;
};</p>&#13;
<p class="indent">Instances of this <span class="literal">struct</span> type can be linked together through the <span class="literal">next</span> field to create a linked list.</p>&#13;
<p class="indent">This example code snippet creates a linked list containing three elements (the list itself is referred to by the <span class="literal">head</span> variable that points to the first node in the list):</p>&#13;
<p class="programs">struct node *head, *temp;<br/>&#13;
int i;<br/>&#13;
<br/>&#13;
head = NULL;  // an empty linked list<br/>&#13;
<br/>&#13;
head = malloc(sizeof(struct node));  // allocate a node<br/>&#13;
if (head == NULL) {<br/>&#13;
    printf("Error malloc\n");<br/>&#13;
    exit(1);<br/>&#13;
}<br/>&#13;
head-&gt;data = 10;    // set the data field<br/>&#13;
head-&gt;next = NULL;  // set next to NULL (there is no next element)<br/>&#13;
<br/>&#13;
// add 2 more nodes to the head of the list:<br/>&#13;
for (i = 0; i &lt; 2; i++) {<br/>&#13;
    temp = malloc(sizeof(struct node));  // allocate a node<br/>&#13;
    if (temp == NULL) {<br/>&#13;
        printf("Error malloc\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
    temp-&gt;data = i;     // set data field<br/>&#13;
    temp-&gt;next = head;  // set next to point to current first node<br/>&#13;
    head = temp;        // change head to point to newly added node<br/>&#13;
}</p>&#13;
<p class="indent">Note that the <span class="literal">temp</span> variable temporarily points to a malloc’ed <span class="literal">node</span> that gets initialized and then added to the beginning of the list by setting its <span class="literal">next</span> field to point to the node currently pointed to by <span class="literal">head</span>, and then by changing the <span class="literal">head</span> to point to this new node.</p>&#13;
<p class="indent">The result of executing this code would look like <a href="ch02.xhtml#ch2fig17">Figure 2-17</a> in memory.</p>&#13;
<span epub:type="pagebreak" id="page_113"/>&#13;
<div class="imagec" id="ch2fig17"><img alt="image" src="../images/02fig17.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-17: The layout in memory of three example linked list nodes</em></p>&#13;
<h3 class="h3" id="lev1_16">2.8 I/O in C (Standard and File)</h3>&#13;
<p class="noindent">C supports many functions for performing standard I/O as well as file I/O. In this section, we discuss some of the most commonly used interfaces for I/O in C.</p>&#13;
<h4 class="h4" id="lev2_32">2.8.1 Standard Input/Output</h4>&#13;
<p class="noindent">Every running program begins with three default I/O streams: standard out (<span class="literal">stdout</span>), standard in (<span class="literal">stdin</span>), and standard error (<span class="literal">stderr</span>). A program can write (print) output to <span class="literal">stdout</span> and <span class="literal">stderr</span>, and it can read input values from <span class="literal">stdin</span>. <span class="literal">stdin</span> is usually defined to read in input from the keyboard, whereas <span class="literal">stdout</span> and <span class="literal">stderr</span> output to the terminal.</p>&#13;
<p class="indent">The C <span class="literal">stdio.h</span> library provides the <span class="literal">printf</span> function used for printing to standard out and the <span class="literal">scanf</span> function that can be used to read in values from standard in. C also has functions to read and write one character at a time (<span class="literal">getchar</span> and <span class="literal">putchar</span>) as well as other functions and libraries for reading and writing characters to standard I/O streams. A C program must explicitly include <span class="literal">stdio.h</span> to call these functions.</p>&#13;
<p class="indent">You can change the location that a running program’s <span class="literal">stdin</span>, <span class="literal">stdout</span> and/ or <span class="literal">stderr</span> read from or write to. One way to do this is by redirecting one or all of these to read or write to a file. Here are some example shell commands for redirecting a program’s <span class="literal">stdin</span>, <span class="literal">stdout</span>, or <span class="literal">stderr</span> to a file (<span class="literal">$</span> is the shell prompt):</p>&#13;
<p class="programs">#  redirect a.out's stdin to read from file infile.txt:<br/>&#13;
$ <span class="codestrong1">./a.out &lt; infile.txt</span><br/>&#13;
<br/>&#13;
#  redirect a.out's stdout to print to file outfile.txt:<br/>&#13;
$ <span class="codestrong1">./a.out &gt; outfile.txt</span><br/>&#13;
<br/>&#13;
# redirect a.out's stdout and stderr to a file out.txt<br/>&#13;
$ <span class="codestrong1">./a.out &amp;&gt; outfile.txt</span><br/>&#13;
<br/>&#13;
# redirect all three to different files:<br/>&#13;
#   (&lt; redirects stdin, 1&gt; stdout, and 2&gt; stderr):<br/>&#13;
$ <span class="codestrong1">./a.out &lt; infile.txt 1&gt; outfile.txt 2&gt; errorfile.txt</span></p>&#13;
<h5 class="h5" id="lev3_26"><span epub:type="pagebreak" id="page_114"/>printf</h5>&#13;
<p class="noindent">C’s <span class="literal">printf</span> function resembles formatted <span class="literal">print</span> calls in Python, where the caller specifies a format string to print. The format string often contains special format specifiers, including special characters that will print tabs (<span class="literal">\t</span>) or newlines (<span class="literal">\n</span>), or that specify placeholders for values in the output (<span class="literal">%</span> followed by a type specifier). When adding placeholders in a format string passed to <span class="literal">printf</span>, pass their corresponding values as additional arguments following the format string. Here are some example calls to <span class="literal">printf</span>:</p>&#13;
<p class="margnote">printf.c</p>&#13;
<p class="programs">int x = 5, y = 10;<br/>&#13;
float pi = 3.14;<br/>&#13;
<br/>&#13;
printf("x is %d and y is %d\n", x, y);<br/>&#13;
<br/>&#13;
printf("%g \t %s \t %d\n", pi, "hello", y);</p>&#13;
<p class="indent">When run, these <span class="literal">printf</span> statements output:</p>&#13;
<p class="programs">x is 5 and y is 10<br/>&#13;
3.14   hello   10</p>&#13;
<p class="indent">Note how the tab characters (<span class="literal">\t</span>) get printed in the second call, and the different formatting placeholders for different types of values (<span class="literal">%g</span>, <span class="literal">%s</span>, and <span class="literal">%d</span>).</p>&#13;
<p class="indent">Here’s a set of formatting placeholders for common C types. Note that placeholders for <span class="literal">long</span> and <span class="literal">long long</span> values include an <span class="literal">l</span> or <span class="literal">ll</span> prefix.</p>&#13;
<p class="programs">%f, %g: placeholders for a float or double value<br/>&#13;
%d:     placeholder for a decimal value (char, short, int)<br/>&#13;
%u:     placeholder for an unsigned decimal<br/>&#13;
%c:     placeholder for a single character<br/>&#13;
%s:     placeholder for a string value<br/>&#13;
%p:     placeholder to print an address value<br/>&#13;
<br/>&#13;
%ld:    placeholder for a long value<br/>&#13;
%lu:    placeholder for an unsigned long value<br/>&#13;
%lld:   placeholder for a long long value<br/>&#13;
%llu:   placeholder for an unsigned long long value</p>&#13;
<p class="indent">Here are some examples of their use:</p>&#13;
<p class="programs">float labs;<br/>&#13;
int midterm;<br/>&#13;
<br/>&#13;
labs = 93.8;<br/>&#13;
midterm = 87;<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_115"/>&#13;
printf("Hello %s, here are your grades so far:\n", "Tanya");<br/>&#13;
printf("\t midterm: %d (out of %d)\n", midterm, 100);<br/>&#13;
printf("\t lab ave: %f\n", labs);<br/>&#13;
printf("\t final report: %c\n", 'A');</p>&#13;
<p class="indent">When run, the output will look like this:</p>&#13;
<p class="programs">Hello Tanya, here are your grades so far:<br/>&#13;
     midterm: 87 (out of 100)<br/>&#13;
     lab ave: 93.800003<br/>&#13;
     final report: A</p>&#13;
<p class="indent">C also allows you to specify the field width with format placeholders. Here are some examples:</p>&#13;
<p class="programs">%5.3f: print float value in space 5 chars wide, with 3 places beyond decimal<br/>&#13;
%20s:  print the string value in a field of 20 chars wide, right justified<br/>&#13;
%-20s: print the string value in a field of 20 chars wide, left justified<br/>&#13;
%8d:   print the int value in a field of 8 chars wide, right justified<br/>&#13;
%-8d:  print the int value in a field of 8 chars wide, left justified</p>&#13;
<p class="indent">Here’s a larger example that uses field width specifiers with placeholders in the format string:</p>&#13;
<p class="margnote">printf_format.c</p>&#13;
<p class="programs">#include &lt;stdio.h&gt; // library needed for printf<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    float x, y;<br/>&#13;
    char ch;<br/>&#13;
<br/>&#13;
    x = 4.50001;<br/>&#13;
    y = 5.199999;<br/>&#13;
    ch = 'a';      // ch stores ASCII value of 'a' (the value 97)<br/>&#13;
<br/>&#13;
    // .1: print x and y with single precision<br/>&#13;
    printf("%.1f %.1f\n", x, y);<br/>&#13;
<br/>&#13;
    printf("%6.1f \t %6.1f \t %c\n", x, y, ch);<br/>&#13;
<br/>&#13;
    // ch+1 is 98, the ASCII value of 'b'<br/>&#13;
    printf("%6.1f \t %6.1f \t %c\n", x+1, y+1, ch+1);<br/>&#13;
<br/>&#13;
    printf("%6.1f \t %6.1f \t %c\n", x*20, y*20, ch+2);<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_116"/>When run, the program output looks like this:</p>&#13;
<p class="programs">4.5 5.2<br/>&#13;
   4.5    5.2     a<br/>&#13;
   5.5    6.2     b<br/>&#13;
  90.0  104.0     c</p>&#13;
<p class="indent">Note how the use of tabs and field width in the last three <span class="literal">printf</span> statements result in a tabular output.</p>&#13;
<p class="indent">Finally, C defines placeholders for displaying values in different representations:</p>&#13;
<p class="programs">%x:     print value in hexadecimal (base 16)<br/>&#13;
%o:     print value in octal (base 8)<br/>&#13;
%d:     print value in signed decimal  (base 10)<br/>&#13;
%u:     print value in unsigned decimal (unsigned base 10)<br/>&#13;
%e:     print float or double in scientific notation<br/>&#13;
(there is no formatting option to display a value in binary)</p>&#13;
<p class="indent">Here is an example using placeholders to print values in different representations:</p>&#13;
<p class="programs">int x;<br/>&#13;
char ch;<br/>&#13;
<br/>&#13;
x = 26;<br/>&#13;
ch = 'A';<br/>&#13;
<br/>&#13;
printf("x is %d in decimal, %x in hexadecimal and %o in octal\n", x, x, x);<br/>&#13;
printf("ch value is %d which is the ASCII value of  %c\n", ch, ch);</p>&#13;
<p class="indent">When run, the program output looks like this:</p>&#13;
<p class="programs">x is 26 in decimal, 1a in hexadecimal and 32 in octal<br/>&#13;
ch value is 65 which is the ASCII value of A</p>&#13;
<h5 class="h5" id="lev3_27">scanf</h5>&#13;
<p class="noindent">The <span class="literal">scanf</span> function provides one method for reading in values from <span class="literal">stdin</span> (usually from the user entering them via the keyboard) and storing them in program variables. The <span class="literal">scanf</span> function is a bit picky about the exact format in which the user enters data, which can make it sensitive to badly formed user input.</p>&#13;
<p class="indent">The arguments to the <span class="literal">scanf</span> function are similar to those of <span class="literal">printf</span>: <span class="literal">scanf</span> takes a format string that specifies the number and type of input values to read in, followed by the <em>locations</em> of program variables into which the values should be stored. Programs typically combine the <em>address of</em> (<span class="literal">&amp;</span>) operator with a variable name to produce the location of the variable in the program’s memory—the memory address of the variable. Here’s an example call to <span class="literal">scanf</span> that reads in two values (an <span class="literal">int</span> and a <span class="literal">float</span>):</p>&#13;
<span epub:type="pagebreak" id="page_117"/>&#13;
<p class="margnote">scanf_ex.c</p>&#13;
<p class="programs">int x;<br/>&#13;
float pi;<br/>&#13;
<br/>&#13;
// read in an int value followed by a float value ("%d%g")<br/>&#13;
// store the int value at the memory location of x (&amp;x)<br/>&#13;
// store the float value at the memory location of pi (&amp;pi)<br/>&#13;
scanf("%d%g", &amp;x, &amp;pi);</p>&#13;
<p class="indent">Individual input values must be separated by at least one whitespace character (e.g., spaces, tabs, newlines). However, <span class="literal">scanf</span> skips over leading and trailing whitespace characters as it finds the start and end of each numeric literal value. As a result, a user could enter the value 8 and 3.14 with any amount of whitespace before or after the two values (and at least one or more whitespace characters between), and <span class="literal">scanf</span> will always read in 8 and assign it to <span class="literal">x</span> and read in 3.14 and assign it to <span class="literal">pi</span>. For example, this input with lots of spaces between the two values will result in reading in 8 and storing it in <span class="literal">x</span>, and 3.14 and storing in <span class="literal">pi</span>:</p>&#13;
<p class="programs"><span class="codestrong1">           8                   3.14</span></p>&#13;
<p class="indent">Programmers often write format strings for <span class="literal">scanf</span> that only consist of placeholder specifiers without any other characters between them. For reading in the two numbers in the preceding example, the format string might look like:</p>&#13;
<p class="programs">// read in an int and a float separated by at least one white space character<br/>&#13;
scanf("%d%g",&amp;x, &amp;pi);</p>&#13;
<h5 class="h5" id="lev3_28">getchar and putchar</h5>&#13;
<p class="noindent">The C functions <span class="literal">getchar</span> and <span class="literal">putchar</span> respectively read or write a single character value from <span class="literal">stdin</span> and to <span class="literal">stdout</span>. <span class="literal">getchar</span> is particularly useful in C programs that need to support careful error detection and handling of badly formed user input (<span class="literal">scanf</span> is not robust in this way).</p>&#13;
<p class="programs">ch = getchar();  // read in the next char value from stdin<br/>&#13;
putchar(ch);     // write the value of ch to stdout</p>&#13;
<h4 class="h4" id="lev2_33">2.8.2 File Input/Output</h4>&#13;
<p class="noindent">The C standard I/O library (<span class="literal">stdio.h</span>) includes a stream interface for file I/O. A <em>file</em> stores persistent data: data that lives beyond the execution of the program that created it. A text file represents a stream of characters, and each open file tracks its current position in the character stream. When opening a file, the current position starts at the very first character in the file, and it moves as a result of every character read (or written) to the file. To read the 10th character in a file, the first nine characters need to first be read (or the <span epub:type="pagebreak" id="page_118"/>current position must be explicitly moved to the 10th character using the <span class="literal">fseek</span> function).</p>&#13;
<p class="indent">C’s file interface views a file as an input or output stream, and library functions read from or write to the next position in the file stream. The <span class="literal">fprintf</span> and <span class="literal">fscanf</span> functions serve as the file I/O counterparts to <span class="literal">printf</span> and <span class="literal">scanf</span>. They use a format string to specify what to write or read, and they include arguments that provide values or storage for the data that gets written or read. Similarly, the library provides the <span class="literal">fputc</span>, <span class="literal">fgetc</span>, <span class="literal">fputs</span>, and <span class="literal">fgets</span> functions for reading and writing individual characters or strings to file streams. Although there are many libraries that support file I/O in C, we present only the <span class="literal">stdio.h</span> library’s stream interface to text files in detail.</p>&#13;
<p class="indent">Text files may contain special chars like the <span class="literal">stdin</span> and <span class="literal">stdout</span> streams: newlines (<span class="literal">’\n’</span>), tabs (<span class="literal">’\t’</span>), etc. Additionally, upon reaching the end of a file’s data, C’s I/O library generates a special end-of-file character (<span class="literal">EOF</span>) that represents the end of the file. Functions reading from a file can test for <span class="literal">EOF</span> to determine when they have reached the end of the file stream.</p>&#13;
<h4 class="h4" id="lev2_34">2.8.3 Using Text Files in C</h4>&#13;
<p class="noindent">To read or write a file in C, follow these steps.</p>&#13;
<p class="indent">First, <em>declare</em> a <span class="literal">FILE *</span> variable:</p>&#13;
<p class="programs">FILE *infile;<br/>&#13;
FILE *outfile;</p>&#13;
<p class="noindent">These declarations create pointer variables to a library-defined <span class="literal">FILE</span> type. These pointers cannot be dereferenced in an application program. Instead, they refer to a specific file stream when passed to I/O library functions.</p>&#13;
<p class="indent">Second, <em>open</em> the file: associate the variable with an actual file stream by calling <span class="literal">fopen</span>. When opening a file, the <em>mode</em> parameter determines whether the program opens it for reading (<span class="literal">"r"</span>), writing (<span class="literal">"w"</span>), or appending (<span class="literal">"a"</span>):</p>&#13;
<p class="programs">infile = fopen("input.txt", "r");  // relative path name of file, read mode<br/>&#13;
if (infile == NULL) {<br/>&#13;
    printf("Error: unable to open file %s\n", "input.txt");<br/>&#13;
    exit(1);<br/>&#13;
}<br/>&#13;
<br/>&#13;
// fopen with absolute path name of file, write mode<br/>&#13;
outfile = fopen("/home/me/output.txt", "w");<br/>&#13;
if (outfile == NULL) {<br/>&#13;
    printf("Error: unable to open outfile\n");<br/>&#13;
    exit(1);<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">fopen</span> function returns <span class="literal">NULL</span> to report errors, which may occur if it’s given an invalid filename or the user doesn’t have permission to open the specified file (e.g., not having write permission to the <span class="literal">output.txt</span> file).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_119"/>Third, <em>use</em> I/O operations to read, write, or move the current position in the file:</p>&#13;
<p class="programs">int ch;  // EOF is not a char value, but is an int.<br/>&#13;
         // since all char values can be stored in int, use int for ch<br/>&#13;
<br/>&#13;
ch = getc(infile);      // read next char from the infile stream<br/>&#13;
if (ch != EOF) {<br/>&#13;
    putc(ch, outfile);  // write char value to the outfile stream<br/>&#13;
}</p>&#13;
<p class="indent">Finally, <em>close</em> the file: use <span class="literal">fclose</span> to close the file when the program no longer needs it:</p>&#13;
<p class="programs">fclose(infile);<br/>&#13;
fclose(outfile);</p>&#13;
<p class="indent">The <span class="literal">stdio</span> library also provides functions to change the current position in a file:</p>&#13;
<p class="programs">// to reset current position to beginning of file<br/>&#13;
void rewind(FILE *f);<br/>&#13;
<br/>&#13;
rewind(infile);<br/>&#13;
<br/>&#13;
// to move to a specific location in the file:<br/>&#13;
fseek(FILE *f, long offset, int whence);<br/>&#13;
<br/>&#13;
fseek(f, 0, SEEK_SET);    // seek to the beginning of the file<br/>&#13;
fseek(f, 3, SEEK_CUR);    // seek 3 chars forward from the current position<br/>&#13;
fseek(f, -3, SEEK_END);   // seek 3 chars back from the end of the file</p>&#13;
<h4 class="h4" id="lev2_35">2.8.4 Standard and File I/O Functions in stdio.h</h4>&#13;
<p class="noindent">The C <span class="literal">stdio.h</span> library has many functions for reading and writing to files and to the standard file-like streams (<span class="literal">stdin</span>, <span class="literal">stdout</span>, and <span class="literal">stderr</span>). These functions can be classified into character-based, string-based, and formatted I/O functions. Here’s some additional details about a subset of these functions:</p>&#13;
<p class="programs">// ---------------<br/>&#13;
// Character Based<br/>&#13;
// ---------------<br/>&#13;
<br/>&#13;
// returns the next character in the file stream (EOF is an int value)<br/>&#13;
int fgetc(FILE *f);<br/>&#13;
<br/>&#13;
// writes the char value c to the file stream f<br/>&#13;
// returns the char value written<br/>&#13;
int fputc(int c, FILE *f);<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_120"/>&#13;
// pushes the character c back onto the file stream<br/>&#13;
// at most one char (and not EOF) can be pushed back<br/>&#13;
int ungetc(int c, FILE *f);<br/>&#13;
<br/>&#13;
// like fgetc and fputc but for stdin and stdout<br/>&#13;
int getchar();<br/>&#13;
int putchar(int c);<br/>&#13;
<br/>&#13;
// -------------<br/>&#13;
// String  Based<br/>&#13;
// -------------<br/>&#13;
<br/>&#13;
// reads at most n-1 characters into the array s stopping if a newline is<br/>&#13;
// encountered, newline is included in the array which is '\0' terminated<br/>&#13;
char *fgets(char *s, int n, FILE *f);<br/>&#13;
<br/>&#13;
// writes the string s (make sure '\0' terminated) to the file stream f<br/>&#13;
int fputs(char *s, FILE *f);<br/>&#13;
<br/>&#13;
// ---------<br/>&#13;
// Formatted<br/>&#13;
// ---------<br/>&#13;
<br/>&#13;
// writes the contents of the format string to file stream f<br/>&#13;
//   (with placeholders filled in with subsequent argument values)<br/>&#13;
// returns the number of characters printed<br/>&#13;
int fprintf(FILE *f, char *format, ...);<br/>&#13;
<br/>&#13;
// like fprintf but to stdout<br/>&#13;
int printf(char *format, ...);<br/>&#13;
<br/>&#13;
// use fprintf to print stderr:<br/>&#13;
fprintf(stderr, "Error return value: %d\n", ret);<br/>&#13;
<br/>&#13;
// read values specified in the format string from file stream f<br/>&#13;
//   store the read-in values to program storage locations of types<br/>&#13;
//   matching the format string<br/>&#13;
// returns number of input items converted and assigned<br/>&#13;
//   or EOF on error or if EOF was reached<br/>&#13;
int fscanf(FILE *f, char *format, ...);<br/>&#13;
<br/>&#13;
// like fscanf but reads from stdin<br/>&#13;
int scanf(char *format, ...);</p>&#13;
<p class="indent">In general, <span class="literal">scanf</span> and <span class="literal">fscanf</span> are sensitive to badly formed input. However, for file I/O, often programmers can assume that an input file is well formatted, so <span class="literal">fscanf</span> may be robust enough in such cases. With <span class="literal">scanf</span>, badly <span epub:type="pagebreak" id="page_121"/>formed user input will often cause a program to crash. Reading in one character at a time and including code to test values before converting them to different types is more robust, but it requires the programmer to implement more complex I/O functionality.</p>&#13;
<p class="indent">The format string for <span class="literal">fscanf</span> can include the following syntax specifying different types of values and ways of reading from the file stream:</p>&#13;
<p class="programs">%d integer<br/>&#13;
%f float<br/>&#13;
%lf double<br/>&#13;
%c character<br/>&#13;
%s string, up to first white space<br/>&#13;
<br/>&#13;
%[...] string, up to first character not in brackets<br/>&#13;
%[0123456789] would read in digits<br/>&#13;
%[^...] string, up to first character in brackets<br/>&#13;
%[^\n] would read everything up to a newline</p>&#13;
<p class="indent">It can be tricky to get the <span class="literal">fscanf</span> format string correct, particularly when reading a mix of numeric and string or character types from a file.</p>&#13;
<p class="indent">Here are a few example calls to <span class="literal">fscanf</span> (and one to <span class="literal">fprintf</span>) with different format strings (let’s assume that the <span class="literal">fopen</span> calls from the previous example have executed successfully):</p>&#13;
<p class="programs">int x;<br/>&#13;
double d;<br/>&#13;
char c, array[MAX];<br/>&#13;
<br/>&#13;
// write int &amp; char values to file separated by colon with newline at the end<br/>&#13;
fprintf(outfile, "%d:%c\n", x, c);<br/>&#13;
<br/>&#13;
// read an int &amp; char from file where int and char are separated by a comma<br/>&#13;
fscanf(infile, "%d,%c", &amp;x, &amp;c);<br/>&#13;
<br/>&#13;
// read a string from a file into array (stops reading at whitespace char)<br/>&#13;
fscanf(infile,"%s", array);<br/>&#13;
<br/>&#13;
// read a double and a string up to 24 chars from infile<br/>&#13;
fscanf(infile, "%lf %24s", &amp;d, array);<br/>&#13;
<br/>&#13;
// read in a string consisting of only char values in the specified set (0-5)<br/>&#13;
// stops reading when...<br/>&#13;
//   20 chars have been read OR<br/>&#13;
//   a character not in the set is reached OR<br/>&#13;
//   the file stream reaches end-of-file (EOF)<br/>&#13;
fscanf(infile, "%20[012345]", array);<br/>&#13;
<br/>&#13;
// read in a string; stop when reaching a punctuation mark from the set<br/>&#13;
<span epub:type="pagebreak" id="page_122"/>&#13;
fscanf(infile, "%[^.,:!;]", array);<br/>&#13;
<br/>&#13;
// read in two integer values: store first in long, second in int<br/>&#13;
// then read in a char value following the int value<br/>&#13;
fscanf(infile, "%ld %d%c", &amp;x, &amp;b, &amp;c);</p>&#13;
<p class="indent">In the final example in the preceding code, the format string explicitly reads in a character value after a number to ensure that the file stream’s current position gets properly advanced for any subsequent calls to <span class="literal">fscanf</span>. For example, this pattern is often used to explicitly read in (and discard) a whitespace character (like <em>\n</em>), to ensure that the next call to <span class="literal">fscanf</span> begins from the next line in the file. Reading an additional character is necessary if the <em>next</em> call to <span class="literal">fscanf</span> attempts to read in a character value. Otherwise, having not consumed the newline, the next call to <span class="literal">fscanf</span> will read the newline rather than the intended character. If the next call reads in a numeric type value, then leading whitespace chars are automatically discarded by <span class="literal">fscanf</span> and the programmer does not need to explicitly read the <span class="literal">\n</span> character from the file stream.</p>&#13;
<h3 class="h3" id="lev1_17">2.9 Some Advanced C Features</h3>&#13;
<p class="noindent">Almost all of the C programming language has been presented in previous sections. In this section, we cover a few remaining advanced C language features and some advanced C programming and compiling topics:</p>&#13;
<ul>&#13;
<li class="noindent">the C <span class="literal">switch</span> statement (<a href="ch02.xhtml#lev2_36">page 122</a>)</li>&#13;
<li class="noindent">command line arguments (<a href="ch02.xhtml#lev2_37">page 125</a>)</li>&#13;
<li class="noindent">the <span class="literal">void *</span> type and type recasting (<a href="ch02.xhtml#lev2_38">page 126</a>)</li>&#13;
<li class="noindent">pointer arithmetic (<a href="ch02.xhtml#lev2_39">page 128</a>)</li>&#13;
<li class="noindent">C libraries: using, compiling, and linking (<a href="ch02.xhtml#lev2_40">page 133</a>)</li>&#13;
<li class="noindent">writing and using your own C libraries (and dividing your program into multiple modules (<span class="literal">.c</span> and <span class="literal">.h</span> files); <a href="ch02.xhtml#lev2_41">page 139</a>)</li>&#13;
<li class="noindent">compiling C source to assembly code (<a href="ch02.xhtml#lev2_42">page 145</a>).</li>&#13;
</ul>&#13;
<h4 class="h4" id="lev2_36">2.9.1 switch Statements</h4>&#13;
<p class="noindent">The C <span class="literal">switch</span> statement can be used in place of some, but not all, chaining <span class="literal">if</span>–<span class="literal">else if</span> code sequences. While <span class="literal">switch</span> doesn’t provide any additional expressive power to the C programming language, it often yields more concise code branching sequences. It may also allow the compiler to produce branching code that executes more efficiently than equivalent chaining <span class="literal">if</span>–<span class="literal">else if</span> code.</p>&#13;
<p class="indent">The C syntax for a <span class="literal">switch</span> statement looks like:</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_123"/>switch (<span class="codeitalic1">&lt;expression&gt;</span>) {<br/>&#13;
<br/>&#13;
   case <span class="codeitalic1">&lt;literal value 1&gt;</span>:<br/>&#13;
        <span class="codeitalic1">&lt;statements&gt;</span>;<br/>&#13;
        break;         // breaks out of switch statement body<br/>&#13;
   case <span class="codeitalic1">&lt;literal value 2&gt;</span>:<br/>&#13;
        <span class="codeitalic1">&lt;statements&gt;</span>;<br/>&#13;
        break;         // breaks out of switch statement body<br/>&#13;
   ...<br/>&#13;
   default:            // default label is optional<br/>&#13;
        <span class="codeitalic1">&lt;statements&gt;</span>;<br/>&#13;
}</p>&#13;
<p class="indent">A switch statement is executed as follows:</p>&#13;
<div class="number">&#13;
<p class="number">1. The <span class="literal"/> <span class="codeitalic">&lt;expression&gt;</span> evaluates first.</p>&#13;
<p class="number">2. Next, the <span class="literal">switch</span> searches for a <span class="literal">case</span> literal value that matches the value of the expression.</p>&#13;
<p class="number">3. Upon finding a matching <span class="literal">case</span> literal, it begins executing the <span class="literal"/> <span class="codeitalic">&lt;statements&gt;</span> that immediately follow it.</p>&#13;
<p class="number">4. If no matching <span class="literal">case</span> is found, it will begin executing the <span class="literal"/> <span class="codeitalic">&lt;statements&gt;</span> in the <span class="literal">default</span> label if one is present.</p>&#13;
<p class="number">5. Otherwise, no statements in the body of the <span class="literal">switch</span> statement get executed.</p>&#13;
</div>&#13;
<p class="indent">A few rules about <span class="literal">switch</span> statements:</p>&#13;
<ul>&#13;
<li class="noindent">The value associated with each <span class="literal">case</span> must be a literal value—it <em>cannot</em> be an expression. The original expression gets matched for <em>equality</em> only with the literal values associated with each <span class="literal">case</span>.</li>&#13;
<li class="noindent">Reaching a <span class="literal">break</span> statement stops the execution of all remaining statements inside the body of the <span class="literal">switch</span> statement. That is, <span class="literal">break</span> breaks out of the body of the <span class="literal">switch</span> statement and continues execution with the next statement after the entire <span class="literal">switch</span> block.</li>&#13;
<li class="noindent">The <span class="literal">case</span> statement with a matching value marks the starting point into the sequence of C statements that will be executed—execution jumps to a location inside the <span class="literal">switch</span> body to start executing code. Thus, if there is no <span class="literal">break</span> statement at the end of a particular <span class="literal">case</span>, then the statements under the subsequent <span class="literal">case</span> statements execute in order until either a <span class="literal">break</span> statement is executed or the end of the body of the <span class="literal">switch</span> statement is reached.</li>&#13;
<li class="noindent">The <span class="literal">default</span> label is optional. If present, it must be at the end.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/>Here’s an example program with a <span class="literal">switch</span> statement:</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int num, new_num = 0;<br/>&#13;
<br/>&#13;
    printf("enter a number between 6 and 9: ");<br/>&#13;
    scanf("%d", &amp;num);<br/>&#13;
<br/>&#13;
    switch(num) {<br/>&#13;
        case 6:<br/>&#13;
            new_num = num + 1;<br/>&#13;
            break;<br/>&#13;
        case 7:<br/>&#13;
            new_num = num;<br/>&#13;
            break;<br/>&#13;
        case 8:<br/>&#13;
            new_num = num - 1;<br/>&#13;
            break;<br/>&#13;
        case 9:<br/>&#13;
            new_num = num + 2;<br/>&#13;
            break;<br/>&#13;
        default:<br/>&#13;
            printf("Hey, %d is not between 6 and 9\n", num);<br/>&#13;
    }<br/>&#13;
    printf("num %d  new_num %d\n", num, new_num);<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">Here are some example runs of this code:</p>&#13;
<p class="programs"><span class="codestrong1">./a.out</span><br/>&#13;
enter a number between 6 and 9: <span class="codestrong1">9</span><br/>&#13;
num 9  new_num 11<br/>&#13;
<br/>&#13;
<span class="codestrong1">./a.out</span><br/>&#13;
enter a number between 6 and 9: <span class="codestrong1">6</span><br/>&#13;
num 6  new_num 7<br/>&#13;
<br/>&#13;
<span class="codestrong1">./a.out</span><br/>&#13;
enter a number between 6 and 9: <span class="codestrong1">12</span><br/>&#13;
Hey, 12 is not between 6 and 9<br/>&#13;
num 12  new_num 0</p>&#13;
<h4 class="h4" id="lev2_37"><span epub:type="pagebreak" id="page_125"/>2.9.2 Command Line Arguments</h4>&#13;
<p class="noindent">A program can be made more general purpose by reading command line arguments, which are included as part of the command entered by the user to run a binary executable program. They specify input values or options that change the runtime behavior of the program. In other words, running the program with different command line argument values results in a program’s behavior changing from run to run without having to modify the program code and recompile it. For example, if a program takes the name of an input filename as a command line argument, a user can run it with any input filename as opposed to a program that refers to a specific input filename in the code.</p>&#13;
<p class="indent">Any command line arguments the user provides get passed to the <span class="literal">main</span> function as parameter values. To write a program that takes command line arguments, the <span class="literal">main</span> function’s definition must include two parameters, <span class="literal">argc</span> and <span class="literal">argv</span>:</p>&#13;
<p class="programs">int main(int argc, char *argv[]) { ...</p>&#13;
<p class="noindent">Note that the type of the second parameter could also be represented as <span class="literal">char</span> <span class="literal">**argv</span>.</p>&#13;
<p class="indent">The first parameter, <span class="literal">argc</span>, stores the argument count. Its value represents the number of command line arguments passed to the main function (including the name of the program). For example, if the user enters</p>&#13;
<p class="programs"><span class="codestrong1">./a.out 10 11 200</span></p>&#13;
<p class="noindent">then <span class="literal">argc</span> will hold the value 4 (<span class="literal">a.out</span> counts as the first command line argument, and <span class="literal">10</span>, <span class="literal">11</span>, and <span class="literal">200</span> as the other three).</p>&#13;
<p class="indent">The second parameter, <span class="literal">argv</span>, stores the argument vector. It contains the value of each command line argument. Each command line argument gets passed in as a string value, thus <span class="literal">argv</span>’s type is an array of strings (or an array of <span class="literal">char</span> arrays). The <span class="literal">argv</span> array contains <span class="literal">argc + 1</span> elements. The first <span class="literal">argc</span> elements store the command line argument strings, and the last element stores <span class="literal">NULL</span>, signifying the end of the command line argument list. For example, in the command line entered in the previous example, the <span class="literal">argv</span> array would look like <a href="ch02.xhtml#ch2fig18">Figure 2-18</a>.</p>&#13;
<span epub:type="pagebreak" id="page_126"/>&#13;
<div class="imagec" id="ch2fig18"><img alt="image" src="../images/02fig18.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-18: The <span class="literal">argv</span> parameter passed to <span class="literal">main</span> is an array of strings. Each command line argument is passed as a separate string element in the array. The value of the last element is <span class="literal">NULL</span>, signifying the end of the list of command line arguments.</em></p>&#13;
<p class="indent">The strings in an <span class="literal">argv</span> array are <em>immutable</em>, meaning that they are stored in read-only memory. As a result, if a program wants to modify the value of one of its command line arguments, it needs to make a local copy of the command line argument and modify the copy.</p>&#13;
<p class="indent">Often, a program wants to interpret a command line argument passed to <span class="literal">main</span> as a type other than a string. In the previous example, the program may want to extract the integer value <span class="literal">10</span> from the string value <span class="literal">"10"</span> of its first command line argument. C’s standard library provides functions for converting strings to other types. For example, the <span class="literal">atoi</span> (“a to i,” for “ASCII to integer”) function converts a string of digit characters to its corresponding integer value:</p>&#13;
<p class="programs">int x;<br/>&#13;
x = atoi(argv[1]);  // x gets the int value 10</p>&#13;
<p class="indent">See “Functions to Convert Strings to Other Types” on <a href="ch02.xhtml#lev3_25">page 103</a> for more information about these functions, and the <span class="literal">commandlineargs.c</span> program<sup><a href="ch02.xhtml#fn2_4" id="rfn2_4">4</a></sup> for another example of C command line arguments.</p>&#13;
<h4 class="h4" id="lev2_38">2.9.3 The void * Type and Type Recasting</h4>&#13;
<p class="noindent">The C type <span class="literal">void *</span> represents a generic pointer—a pointer to any type, or a pointer to an unspecified type. C allows for a generic pointer type because memory addresses on a system are always stored in the same number of bytes (e.g., addresses are four bytes on 32-bit systems and eight bytes on 64-bit systems). As a result, every pointer variable requires the same number of storage bytes, and because they’re all the same size, the compiler can allocate space for a <span class="literal">void *</span> variable without knowing the type it points to. Here’s an example:</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_127"/>void *gen_ptr;<br/>&#13;
int x;<br/>&#13;
char ch;<br/>&#13;
<br/>&#13;
gen_ptr = &amp;x;  // gen_ptr can be assigned the address of an int<br/>&#13;
gen_ptr = &amp;ch; // or the address of a char (or the address of any type)</p>&#13;
<p class="indent">Typically, programmers do not declare variables of type <span class="literal">void *</span> as in the preceding example. Instead, it’s commonly used to specify generic return types from functions or generic parameters to functions. The <span class="literal">void *</span> type is often used as a return type by functions that return newly allocated memory that can be used to store any type (e.g., <span class="literal">malloc</span>). It’s also used as a function parameter for functions that can take any type of value. In this case, individual calls to the function pass in a pointer to some specific type, which can be passed to the function’s <span class="literal">void *</span> parameter because it can store the address of any type.</p>&#13;
<p class="indent">Because <span class="literal">void *</span> is a generic pointer type, it cannot be directly dereferenced—the compiler does not know the size of memory that the address points to. For example, the address could refer to an <span class="literal">int</span> storage location of four bytes or it could refer to a <span class="literal">char</span> storage location in memory of one byte. Therefore, the programmer must explicitly <em>recast</em> the <span class="literal">void *</span> pointer to a pointer of a specific type before dereferencing it. Recasting tells the compiler the specific type of pointer variable, allowing the compiler to generate the correct memory access code for pointer dereferences.</p>&#13;
<p class="indent">Here are two examples of <span class="literal">void *</span> use. First, a call to <span class="literal">malloc</span> recasts its <span class="literal">void</span> <span class="literal">*</span> return type to the specific pointer type of the variable used to store its returned heap memory address:</p>&#13;
<p class="programs">int *array;<br/>&#13;
char *str;<br/>&#13;
<br/>&#13;
array = (int *)malloc(sizeof(int) * 10); // recast void * return value<br/>&#13;
str = (char *)malloc(sizeof(char) * 20);<br/>&#13;
<br/>&#13;
*array = 10;<br/>&#13;
str[0] = 'a';</p>&#13;
<p class="indent">Second, students often encounter the <span class="literal">void *</span> when creating threads (see “Hello Threading! Writing Your First Multithreaded Program” on <a href="ch14.xhtml#lev1_106">page 677</a>). Using a <span class="literal">void *</span> parameter type in a thread function allows the thread to take any type of application-specific pointer. The <span class="literal">pthread_create</span> function has a parameter for the thread main function and a <span class="literal">void *</span> parameter for the argument value that it passes to the thread main function that the newly created thread will execute. The use of the <span class="literal">void *</span> parameter makes <span class="literal">pthread_create</span> a generic thread creation function; it can be used to point to any type of memory location. For a specific program that calls <span class="literal">pthread_create</span>, the programmer knows the type of the argument passed to the <span class="literal">void *</span> parameter, so the programmer must recast it to its known type before dereferencing it. In this <span epub:type="pagebreak" id="page_128"/>example, suppose that the address passed to the <span class="literal">args</span> parameter contains the address of an integer variable:</p>&#13;
<p class="programs">/*<br/>&#13;
 * an application-specific pthread main function<br/>&#13;
 * must have this function prototype: int func_name(void *args)<br/>&#13;
 *<br/>&#13;
 * any given implementation knows what type is really passed in<br/>&#13;
 *  args: pointer to an int value<br/>&#13;
 */<br/>&#13;
int my_thr_main(void *args) {<br/>&#13;
    int num;<br/>&#13;
<br/>&#13;
    // first recast args to an int *, then dereference to get int value<br/>&#13;
    num = *((int *)args);  // num gets 6<br/>&#13;
    ...<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int ret, x;<br/>&#13;
    pthread_t tid;<br/>&#13;
<br/>&#13;
    x = 6;<br/>&#13;
    // pass the address of int variable (x) to pthread_create's void * param<br/>&#13;
    // (we recast &amp;x as a (void *) to match the type of pthread_create's param)<br/>&#13;
    ret = pthread_create(&amp;tid, NULL,<br/>&#13;
                         my_thr_main,    // a thread main function<br/>&#13;
                         (void *)(&amp;x));  // &amp;x will be passed to my_thr_main<br/>&#13;
    // ...</p>&#13;
<h4 class="h4" id="lev2_39">2.9.4 Pointer Arithmetic</h4>&#13;
<p class="noindent">If a pointer variable points to an array, a program can perform arithmetic on the pointer to access any of the array’s elements. In most cases, we recommend against using pointer arithmetic to access array elements: it’s easy to make errors and more difficult to debug when you do. However, occasionally it may be convenient to successively increment a pointer to iterate over an array of elements.</p>&#13;
<p class="indent">When incremented, a pointer points to the next storage location <em>of the type it points to</em>. For example, incrementing an integer pointer (<span class="literal">int *</span>) makes it point to the next <span class="literal">int</span> storage address (the address four bytes beyond its current value), and incrementing a character pointer makes it point to the next <span class="literal">char</span> storage address (the address one byte beyond its current value).</p>&#13;
<p class="indent">In the following example program, we demonstrate how to use pointer arithmetic to manipulate an array. First declare pointer variables whose type matches the array’s element type:</p>&#13;
<span epub:type="pagebreak" id="page_129"/>&#13;
<p class="margnote">pointerarith.c</p>&#13;
<p class="programs">#define N 10<br/>&#13;
#define M 20<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    // array declarations:<br/>&#13;
    char letters[N];<br/>&#13;
    int numbers[N], i, j;<br/>&#13;
    int matrix[N][M];<br/>&#13;
<br/>&#13;
    // declare pointer variables that will access int or char array elements<br/>&#13;
    // using pointer arithmetic (the pointer type must match array element type)<br/>&#13;
    char *cptr = NULL;<br/>&#13;
    int *iptr = NULL;<br/>&#13;
    ...</p>&#13;
<p class="indent">Next, initialize the pointer variables to the base address of the arrays over which they will iterate:</p>&#13;
<p class="margnote">pointerarith.c</p>&#13;
<p class="programs">// make the pointer point to the first element in the array<br/>&#13;
cptr = &amp;(letters[0]); //  &amp;(letters[0])  is the address of element 0<br/>&#13;
iptr = numbers;       // the address of element 0 (numbers is &amp;(numbers[0]))</p>&#13;
<p class="indent">Then, using pointer dereferencing, our program can access the array’s elements. Here, we’re dereferencing to assign a value to an array element and then incrementing the pointer variable by one to advance it to point to the next element:</p>&#13;
<p class="margnote">pointerarith.c</p>&#13;
<p class="programs">// initialized letters and numbers arrays through pointer variables<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    // dereference each pointer and update the element it currently points to<br/>&#13;
    *cptr = 'a' + i;<br/>&#13;
    *iptr = i * 3;<br/>&#13;
<br/>&#13;
    // use pointer arithmetic to set each pointer to point to the next element<br/>&#13;
    cptr++;  // cptr points to the next char address (next element of letters)<br/>&#13;
    iptr++;  // iptr points to the next int address  (next element of numbers)<br/>&#13;
}</p>&#13;
<p class="indent">Note that in this example, the pointer values are incremented inside the loop. Thus, incrementing their value makes them point to the next element in the array. This pattern effectively walks through each element of an array in the same way that accessing <span class="literal">cptr[i]</span> or <span class="literal">iptr[i]</span> at each iteration would.</p>&#13;
<span epub:type="pagebreak" id="page_130"/>&#13;
<p class="note"><strong><span class="black">Note</span> THE SEMANTICS OF POINTER ARITHMETIC AND THE UNDERLYING ARITHMETIC FUNCTION</strong></p>&#13;
<p class="note1">The semantics of pointer arithmetic are type independent: changing any type of pointer’s value by <span class="literal">N</span> (<span class="literal">ptr = ptr + N</span>) makes the pointer point <span class="literal">N</span> storage locations beyond its current value (or makes it point to <span class="literal">N</span> elements beyond the current element it points to). As a result, incrementing a pointer of any type makes it point to the very next memory location of the type it points to.</p>&#13;
<p class="note1">However, the actual arithmetic function that the compiler generates for a pointer arithmetic expression varies depending on the type of the pointer variable (depending on the number of bytes the system uses to store the type to which it points). For example, incrementing a <span class="literal">char</span> pointer will increase its value by one because the very next valid <span class="literal">char</span> address is one byte from the current location. Incrementing an <span class="literal">int</span> pointer will increase its value by four because the next valid integer address is four bytes from the current location.</p>&#13;
<p class="note1">A programmer can simply write <span class="literal">ptr++</span> to make a pointer point to the next element value. The compiler generates code to add the appropriate number of bytes for the corresponding type it points to. The addition effectively sets its value to the next valid address in memory of that type.</p>&#13;
<p class="indent">You can see how the previous code modified array elements by printing out their values (we show this first using array indexing and then using pointer arithmetic to access each array element’s value):</p>&#13;
<p class="programs">printf("\n array values using indexing to access: \n");<br/>&#13;
// see what the code above did:<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    printf("letters[%d] = %c, numbers[%d] = %d\n",<br/>&#13;
           i, letters[i], i, numbers[i]);<br/>&#13;
}<br/>&#13;
<br/>&#13;
// we could also use pointer arith to print these out:<br/>&#13;
printf("\n array values using pointer arith to access: \n");<br/>&#13;
// first: initialize pointers to base address of arrays:<br/>&#13;
cptr = letters;  // letters == &amp;letters[0]<br/>&#13;
iptr = numbers;<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    // dereference pointers to access array element values<br/>&#13;
    printf("letters[%d] = %c, numbers[%d] = %d\n",<br/>&#13;
            i, *cptr, i, *iptr);<br/>&#13;
<br/>&#13;
    // increment pointers to point to the next element<br/>&#13;
    cptr++;<br/>&#13;
    iptr++;<br/>&#13;
}</p>&#13;
<p class="indent">Here’s what the output looks like:</p>&#13;
<p class="programs"> array values using indexing to access:<br/>&#13;
letters[0] = a, numbers[0] = 0<br/>&#13;
letters[1] = b, numbers[1] = 3<br/>&#13;
<span epub:type="pagebreak" id="page_131"/>&#13;
letters[2] = c, numbers[2] = 6<br/>&#13;
letters[3] = d, numbers[3] = 9<br/>&#13;
letters[4] = e, numbers[4] = 12<br/>&#13;
letters[5] = f, numbers[5] = 15<br/>&#13;
letters[6] = g, numbers[6] = 18<br/>&#13;
letters[7] = h, numbers[7] = 21<br/>&#13;
letters[8] = i, numbers[8] = 24<br/>&#13;
letters[9] = j, numbers[9] = 27<br/>&#13;
<br/>&#13;
 array values using pointer arith to access:<br/>&#13;
letters[0] = a, numbers[0] = 0<br/>&#13;
letters[1] = b, numbers[1] = 3<br/>&#13;
letters[2] = c, numbers[2] = 6<br/>&#13;
letters[3] = d, numbers[3] = 9<br/>&#13;
letters[4] = e, numbers[4] = 12<br/>&#13;
letters[5] = f, numbers[5] = 15<br/>&#13;
letters[6] = g, numbers[6] = 18<br/>&#13;
letters[7] = h, numbers[7] = 21<br/>&#13;
letters[8] = i, numbers[8] = 24<br/>&#13;
letters[9] = j, numbers[9] = 27</p>&#13;
<p class="indent">Pointer arithmetic can be used to iterate over any contiguous chunk of memory. Here’s an example using pointer arithmetic to initialize a statically declared 2D array:</p>&#13;
<p class="programs">// sets matrix to:<br/>&#13;
// row 0:   0,   1,   2, ...,  99<br/>&#13;
// row 1: 100, 110, 120, ..., 199<br/>&#13;
//        ...<br/>&#13;
iptr = &amp;(matrix[0][0]);<br/>&#13;
for (i = 0; i &lt; N*M; i++) {<br/>&#13;
    *iptr = i;<br/>&#13;
    iptr++;<br/>&#13;
}<br/>&#13;
<br/>&#13;
// see what the code above did:<br/>&#13;
printf("\n 2D array values inited using pointer arith: \n");<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    for (j = 0; j &lt; M; j++) {<br/>&#13;
        printf("%3d ", matrix[i][j]);<br/>&#13;
    }<br/>&#13;
    printf("\n");<br/>&#13;
}<br/>&#13;
<br/>&#13;
return 0;<br/>&#13;
}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_132"/>The output will look like:</p>&#13;
<p class="programs"> 2D array values initialized using pointer arith:<br/>&#13;
  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19<br/>&#13;
 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39<br/>&#13;
 40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59<br/>&#13;
 60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79<br/>&#13;
 80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99<br/>&#13;
100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119<br/>&#13;
120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139<br/>&#13;
140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159<br/>&#13;
160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179<br/>&#13;
180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199</p>&#13;
<p class="indent">Pointer arithmetic can access contiguous memory locations in any pattern, starting and ending anywhere in a contiguous chunk of memory. For example, after initializing a pointer to the address of an array element, its value can be changed by more than one. For example:</p>&#13;
<p class="programs">iptr = &amp;numbers[2];<br/>&#13;
*iptr = -13;<br/>&#13;
iptr += 4;<br/>&#13;
*iptr = 9999;</p>&#13;
<p class="indent">After executing the preceding code, printing the <span class="literal">numbers</span> array’s values would look like this (note that the values at index 2 and index 6 have changed):</p>&#13;
<p class="programs">numbers[0] = 0<br/>&#13;
numbers[1] = 3<br/>&#13;
numbers[2] = -13<br/>&#13;
numbers[3] = 9<br/>&#13;
numbers[4] = 12<br/>&#13;
numbers[5] = 15<br/>&#13;
numbers[6] = 9999<br/>&#13;
numbers[7] = 21<br/>&#13;
numbers[8] = 24<br/>&#13;
numbers[9] = 27</p>&#13;
<p class="indent">Pointer arithmetic works on dynamically allocated arrays, too. However, programmers must be careful working with dynamically allocated multidimensional arrays. If, for example, a program uses multiple <span class="literal">malloc</span> calls to dynamically allocate individual rows of a 2D array (see “Method 2: The Programmer-Friendly Way” on <a href="ch02.xhtml#lev3_17">page 90</a>), then the pointer must be reset to point to the address of the starting element of every row. Resetting the pointer is necessary because only elements within a row are located in contiguous memory addresses. On the other hand, if the 2D array is allocated as a single <span class="literal">malloc</span> of total rows times columns space (see “Method 1: Memory-Efficient Allocation” on <a href="ch02.xhtml#lev3_15">page 88</a>), then all the rows are in contiguous memory <span epub:type="pagebreak" id="page_133"/>(like in the statically declared 2D array from the previous example). In the latter case, the pointer only needs to be initialized to point to the base address, and then pointer arithmetic will correctly access any element in the 2D array.</p>&#13;
<h4 class="h4" id="lev2_40">2.9.5 C Libraries: Using, Compiling, and Linking</h4>&#13;
<p class="noindent">A <em>library</em> implements a collection of functions and definitions that can be used by other programs. A C library consists of two parts:</p>&#13;
<ul>&#13;
<li class="noindent">The <em>application programming interface</em> (API) to the library, which gets defined in one or more header files (<span class="literal">.h</span> files) that must be included in C source code files that plan to use the library. The headers define what the library exports to its users. These definitions usually include library function prototypes, and they may also include type, constant, or global variable declarations.</li>&#13;
<li class="noindent">The <em>implementation</em> of the library’s functionality, often made available to programs in a precompiled binary format that gets <em>linked</em> (added) into the binary executable created by <span class="literal">gcc</span>. Precompiled library code might be in an archive file (<span class="literal">libsomelib.a</span>) containing several <span class="literal">.o</span> files that can be statically linked into the executable file at compile time. Alternatively, it may consist of a shared object file (<span class="literal">libsomelib.so</span>) that can be dynamically linked at runtime into a running program.</li>&#13;
</ul>&#13;
<p class="indent">For example, the C string library implements a set of functions to manipulate C strings. The <span class="literal">string.h</span> header file defines its interface, so any program that wants to use string library functions must <span class="literal">#include &lt;string.h&gt;</span>. The implementation of the C string library is part of the larger standard C library (<span class="literal">libc</span>) that the <span class="literal">gcc</span> compiler automatically links into every executable file it creates.</p>&#13;
<p class="indent">A library’s implementation consists of one or more modules (<span class="literal">.c</span> files), and may additionally include header files that are internal to the library implementation; internal header files are not part of the library’s API but are part of well-designed, modular library code. Often the C source code implementation of a library is not exported to the user of the library. Instead, the library is made available in a precompiled binary form. These binary formats are not executable programs (they cannot be run on their own), but they provide executable code that can be <em>linked</em> into (added into) an executable file by <span class="literal">gcc</span> at compilation time.</p>&#13;
<p class="indent">There are numerous libraries available for C programmers to use. For example, the POSIX thread library (discussed in <a href="ch10.xhtml#ch10">Chapter 10</a>) enables multithreaded C programs. C programmers can also implement and use their own libraries (see “Writing and Using Your Own C Libraries” on <a href="ch02.xhtml#lev2_41">page 133</a>). Large C programs tend to use many C libraries, some of which <span class="literal">gcc</span> links implicitly, whereas others require explicit linking with the <span class="literal">-l</span> command line option to <span class="literal">gcc</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_134"/>Standard C libraries normally do not need to be explicitly linked in with the <span class="literal">-l</span> option, but other libraries do. The documentation for a library function often specifies whether the library needs to be explicitly linked in when compiling. For example, the POSIX threads library (<span class="literal">pthread</span>) and the <span class="literal">readline</span> library require explicit linking on the <span class="literal">gcc</span> command line:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o myprog myprog.c -lpthread -lreadline</span></p>&#13;
<p class="indent">Note that the full name of the library file should not be included in the <span class="literal">-l</span> argument to <span class="literal">gcc</span>; the library files are named something like <span class="literal">libpthread.so</span> or <span class="literal">libreadline.a</span>, but the <span class="literal">lib</span> prefix and <span class="literal">.so</span> or <span class="literal">.a</span> suffix of the filenames are not included. The actual library filename may also contain version numbers (e.g., <span class="literal">libreadline.so.8.0</span>), which are also not included in the <span class="literal">-l</span> command line option (<span class="literal">-lreadline</span>). By not forcing the user to specify (or even know) the exact name and location of the library files to link in, <span class="literal">gcc</span> is free to find the most recent version of a library in a user’s library path. It also allows the compiler to choose to dynamically link when both a shared object (<span class="literal">.so</span>) and an archive (<span class="literal">.a</span>) version of a library are available. If users want to statically link libraries, then they can explicitly specify static linking in the <span class="literal">gcc</span> command line. The <span class="literal">--static</span> option provides one method for requesting static linking:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o myprog myprog.c --static -lpthread -lreadline</span></p>&#13;
<h5 class="h5" id="lev3_29">Compilation Steps</h5>&#13;
<p class="noindent">Characterizing C’s program compilation steps will help to illustrate how library code gets linked into an executable binary file. We first present the compilation steps and then discuss (with examples) different types of errors that can occur when compiling programs that use libraries.</p>&#13;
<p class="indent">The C compiler translates a C source file (e.g., <span class="literal">myprog.c</span>) into an executable binary file (e.g., <span class="literal">a.out</span>) in four distinct steps (plus a fifth step that occurs at runtime).</p>&#13;
<p class="indent">The <em>precompiler</em> step runs first and expands <em>preprocessor directives</em>: the <span class="literal">#</span> directives that appear in the C program, such as <span class="literal">#define</span> and <span class="literal">#include</span>. Compilation errors at this step include syntax errors in preprocessor directives or <span class="literal">gcc</span> not finding header files associated with <span class="literal">#include</span> directives. To view the intermediate results of the precompiler step, pass the <span class="literal">-E</span> flag to <span class="literal">gcc</span> (the output can be redirected to a file that can be viewed by a text editor):</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -E  myprog.c</span><br/>&#13;
$ <span class="codestrong1">gcc -E  myprog.c  &gt; out</span><br/>&#13;
$ <span class="codestrong1">vim out</span></p>&#13;
<p class="indent">The <em>compile</em> step runs next and does the bulk of the compilation task. It translates the C program source code (<span class="literal">myprog.c</span>) to machine-specific assembly code (<span class="literal">myprog.s</span>). Assembly code is a human-readable form of the binary machine code instructions that a computer can execute. Compilation errors at this step include C language syntax errors, undefined symbol warnings, and errors from missing definitions and function prototypes. To view the <span epub:type="pagebreak" id="page_135"/>intermediate results of the compile step, pass the <span class="literal">-S</span> flag to <span class="literal">gcc</span> (this option creates a text file named <span class="literal">myprog.s</span> with the assembly translation of <span class="literal">myprog.c</span>, which can be viewed in a text editor):</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -S  myprog.c</span><br/>&#13;
$ <span class="codestrong1">vim myprog.s</span></p>&#13;
<p class="indent">The <em>assembly</em> step converts the assembly code into relocatable binary object code (<span class="literal">myprog.o</span>). The resulting object file contains machine code instructions, but it is not a complete executable program that can run on its own. The <span class="literal">gcc</span> compiler on Unix and Linux systems produces binary files in a specific format called ELF (Executable and Linkable Format).<sup><a href="ch02.xhtml#fn2_5" id="rfn2_5">5</a></sup> To stop compilation after this step, pass the <span class="literal">-c</span> flag to <span class="literal">gcc</span> (this produces a file named <span class="literal">myprog.o</span>). Binary files (e.g., <span class="literal">a.out</span> and <span class="literal">.o</span> files) can be viewed using <span class="literal">objdump</span> or similar tools for displaying binary files:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -c  myprog.c</span><br/>&#13;
<br/>&#13;
# disassemble functions in myprog.o with objdump:<br/>&#13;
$ <span class="codestrong1">objdump -d myprog.o</span></p>&#13;
<p class="indent">The <em>link editing</em> step runs last and creates a single executable file (<span class="literal">a.out</span>) from relocatable binaries (<span class="literal">.o</span>) and libraries (<span class="literal">.a</span> or <span class="literal">.so</span>). In this step, the linker verifies that any references to names (symbols) in a <span class="literal">.o</span> file are present in other <span class="literal">.o</span>, <span class="literal">.a</span>, or <span class="literal">.so</span> files. For example, the linker will find the <span class="literal">printf</span> function in the standard C library (<span class="literal">libc.so</span>). If the linker cannot find the definition of a symbol, this step fails with an error stating that a symbol is undefined. Running <span class="literal">gcc</span> without flags for partial compilation performs all four steps of compiling a C source code file (<span class="literal">myprog.c</span>) to an executable binary file (<span class="literal">a.out</span>) that can be run:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc myprog.c</span><br/>&#13;
$ <span class="codestrong1">./a.out</span><br/>&#13;
<br/>&#13;
# disassemble functions in a.out with objdump:<br/>&#13;
$ <span class="codestrong1">objdump -d a.out</span></p>&#13;
<p class="indent">If the binary executable file (<span class="literal">a.out</span>) statically links in library code (from <span class="literal">.a</span> library files), then <span class="literal">gcc</span> embeds copies of library functions from the <span class="literal">.a</span> file in the resulting <span class="literal">a.out</span> file. All calls to library functions by the application are <em>bound</em> to the locations in the <span class="literal">a.out</span> file to which the library function is copied. Binding associates a name with a location in the program memory. For example, binding a call to a library function named <span class="literal">gofish</span> means replacing the use of the function name with the address in memory of the function (in later chapters we discuss memory addresses in more detail—see, for example, “Memory Addresses” on <a href="ch13.xhtml#lev2_227">page 642</a>).</p>&#13;
<p class="indent">If, however, the <span class="literal">a.out</span> was created by dynamically linking a library (from library shared object, <span class="literal">.so</span>, files), then <span class="literal">a.out</span> does not contain a copy of the library function code from these libraries. Instead, it contains information <span epub:type="pagebreak" id="page_136"/>about which dynamically linked libraries are needed by the <span class="literal">a.out</span> file to run it. Such executables require an additional linking step at runtime.</p>&#13;
<p class="indent">The <em>runtime linking</em> step is needed if <span class="literal">a.out</span> was linked with shared object files during link editing. In such cases, the dynamic library code (in <span class="literal">.so</span> files) must be loaded at runtime and linked with the running program. This runtime loading and linking of shared object libraries is called <em>dynamic linking</em>. When a user runs an <span class="literal">a.out</span> executable with shared object dependencies, the system performs dynamic linking before the program begins executing its <span class="literal">main</span> function.</p>&#13;
<p class="indent">The compiler adds information about shared object dependencies into the <span class="literal">a.out</span> file during the link editing compilation step. When the program starts executing, the dynamic linker examines the list of shared object dependencies and finds and loads the shared object files into the running program. It then updates relocation table entries in the <span class="literal">a.out</span> file, binding the program’s use of symbols in shared objects (such as calls to library functions) to their locations in the <span class="literal">.so</span> file loaded at runtime. Runtime linking reports errors if the dynamic linker cannot find a shared object (<span class="literal">.so</span>) file needed by the executable.</p>&#13;
<p class="indent">The <span class="literal">ldd</span> utility lists an executable file’s shared object dependencies:</p>&#13;
<p class="programs">$ <span class="codestrong1">ldd a.out</span></p>&#13;
<p class="indent">The <em>GNU debugger (GDB)</em> can examine a running program and show which shared object code is loaded and linked at runtime. We cover GDB in <a href="ch03.xhtml#ch03">Chapter 3</a>. However, the details of examining the Procedure Lookup Table (PLT), which is used for runtime linking of calls to dynamically linked library functions, is beyond the scope of this textbook.</p>&#13;
<p class="indent">More details about the phases of compilation and about tools for examining different phases can be found online.<sup><a href="ch02.xhtml#fn2_6" id="rfn2_6">6</a></sup></p>&#13;
<h5 class="h5" id="lev3_30">Common Compilation Errors Related to Compiling and Linking Libraries</h5>&#13;
<p class="noindent">Several compilation and linking errors can occur due to the programmer forgetting to include library header files or forgetting to explicitly link in library code. Identifying the <span class="literal">gcc</span> compiler error or warning associated with each of these errors will help in debugging errors related to using C libraries.</p>&#13;
<p class="indent">Consider this next C program that makes a call to a function <span class="literal">libraryfunc</span> from the <span class="literal">examplelib</span> library (available as a shared object file, <span class="literal">libmylib.so</span>):</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;examplelib.h&gt;<br/>&#13;
<br/>&#13;
int main(int argc, char *argv[]) {<br/>&#13;
    int result;<br/>&#13;
    result = libraryfunc(6, MAX);<br/>&#13;
    printf("result is %d\n", result);<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_137"/>Assume that the header file, <span class="literal">examplelib.h</span>, contains the definitions in the following example:</p>&#13;
<p class="programs">#define MAX 10   // a constant exported by the library<br/>&#13;
<br/>&#13;
// a function exported by the library<br/>&#13;
extern int libraryfunc(int x, int y);</p>&#13;
<p class="indent">The <span class="literal">extern</span> prefix to the function prototype means that the function’s definition comes from another file—it’s not in the <span class="literal">examplelib.h</span> file, but instead it’s provided by one of the <span class="literal">.c</span> files in the library’s implementation.</p>&#13;
<p class="noindentt"><strong>Forgetting to include a header file.</strong> If the programmer forgets to include <span class="literal">examplelib.h</span> in their program, then the compiler produces warnings and errors about the program’s use of library functions and constants that it does not know about. For example, if the user compiles their program without <span class="literal">#include &lt;examplelib.h&gt;</span>, <span class="literal">gcc</span> will produce the following output:</p>&#13;
<p class="programs"># '-g': add debug information, -c: compile to '.o'<br/>&#13;
$ <span class="codestrong1">gcc -g -c myprog.c</span><br/>&#13;
<br/>&#13;
myprog.c: In function main:<br/>&#13;
myprog.c:8:12: warning: implicit declaration of function libraryfunc<br/>&#13;
   result = libraryfunc(6, MAX);<br/>&#13;
            ^~~~~~~~~~~<br/>&#13;
<br/>&#13;
myprog.c:8:27: error: MAX undeclared (first use in this function)<br/>&#13;
   result = libraryfunc(6, MAX);<br/>&#13;
                           ^~~</p>&#13;
<p class="indent">The first compiler warning (<span class="literal">implicit declaration of function</span> <span class="literal">libraryfunc</span>) tells the programmer that the compiler cannot find a function prototype for the <span class="literal">libraryfunc</span> function. This is just a compiler warning because <span class="literal">gcc</span> will guess that the function’s return type is an integer and will continue compiling the program. However, programmers should <em>not</em> ignore such warnings! They indicate that the program isn’t including a function prototype before its use in the <span class="literal">myprog.c</span> file, which is often due to not including a header file that contains the function prototype.</p>&#13;
<p class="indent">The second compiler error (<span class="literal">MAX undeclared (first use in this</span> <span class="literal">function)</span>) follows from a missing constant definition. The compiler cannot guess at the value of the missing constant, so this missing definition fails with an error. This type of “undeclared” message often indicates that a header file defining a constant or global variable is missing or hasn’t been properly included.</p>&#13;
<p class="noindentt"><strong>Forgetting to link a library.</strong> If the programmer includes the library header file (as shown in the previous listing), but forgets to explicitly link in the library during the link editing step of compilation, then <span class="literal">gcc</span> indicates this with an “undefined reference” error:</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_138"/>$ <span class="codestrong1">gcc -g myprog.c</span><br/>&#13;
<br/>&#13;
In function main:<br/>&#13;
myprog.c:9: undefined reference to libraryfunc<br/>&#13;
collect2: error: ld returned 1 exit status</p>&#13;
<p class="indent">This error originates from <span class="literal">ld</span>, the linker component of the compiler. It indicates that the linker cannot find the implementation of the library function <span class="literal">libraryfunc</span> that gets called at line 9 in <span class="literal">myprog.c</span>. An “undefined reference” error indicates that a library needs to be explicitly linked into the executable. In this example, specifying <span class="literal">-lexamplelib</span> on the <span class="literal">gcc</span> command line will fix the error:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -g myprog.c  -lexamplelib</span></p>&#13;
<p class="noindentt"><strong>gcc can’t find header or library files.</strong> Compilation will also fail with errors if a library’s header or implementation files are not present in the directories that <span class="literal">gcc</span> searches by default. For example, if <span class="literal">gcc</span> cannot find the <span class="literal">examplelib.h</span> file, it will produce an error message like this:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -c myprog.c -lexamplelib</span><br/>&#13;
myprog.c:1:10: fatal error: examplelib.h: No such file or directory<br/>&#13;
 #include &lt;examplelib.h&gt;<br/>&#13;
          ^~~~~~~<br/>&#13;
<br/>&#13;
compilation terminated.</p>&#13;
<p class="indent">If the linker cannot find a <span class="literal">.a</span> or <span class="literal">.so</span> version of the library to link in during the link editing step of compilation, <span class="literal">gcc</span> will exit with an error like the following:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -c myprog.c -lexamplelib</span><br/>&#13;
/usr/bin/ld: cannot find -lexamplelib<br/>&#13;
collect2: error: ld returned 1 exit status</p>&#13;
<p class="indent">Similarly, if a dynamically linked executable cannot locate a shared object file (e.g., <span class="literal">libexamplelib.so</span>), it will fail to execute at runtime with an error like the following:</p>&#13;
<p class="programs">$ <span class="codestrong1">./a.out</span><br/>&#13;
./a.out: error while loading shared libraries:<br/>&#13;
   libexamplelib.so: cannot open shared object file: No such file or directory</p>&#13;
<p class="indent">To resolve these types of errors, programmers must specify additional options to <span class="literal">gcc</span> to indicate where the library’s files can be found. They may also need to modify the <span class="literal">LD_LIBRARY_PATH</span> environment variable for the runtime linker to find a library’s <span class="literal">.so</span> file.</p>&#13;
<h5 class="h5" id="lev3_31"><span epub:type="pagebreak" id="page_139"/>Library and Include Paths</h5>&#13;
<p class="noindent">The compiler automatically searches in standard directory locations for header and library files. For example, systems commonly store standard header files in <span class="literal">/usr/include</span>, and library files in <span class="literal">/usr/lib</span>, and <span class="literal">gcc</span> automatically looks for headers and libraries in these directories; <span class="literal">gcc</span> also automatically searches for header files in the current working directory.</p>&#13;
<p class="indent">If <span class="literal">gcc</span> cannot find a header or a library file, then the user must explicitly provide paths on the command line using <span class="literal">-I</span> and <span class="literal">-L</span>. For example, suppose that a library named <span class="literal">libexamplelib.so</span> exists in <span class="literal">/home/me/lib</span>, and its header file <span class="literal">examplelib.h</span> is in <span class="literal">/home/me/include</span>. Because <span class="literal">gcc</span> knows nothing of those paths by default, it must be explicitly told to include files there to successfully compile a program that uses this library:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc  -I/home/me/include -o myprog myprog.c -L/home/me/lib -lexamplelib</span></p>&#13;
<p class="indent">To specify the location of a dynamic library (e.g., <span class="literal">libexamplelib.so</span>) when launching a dynamically linked executable, set the <span class="literal">LD_LIBRARY_PATH</span> environment variable to include the path to the library. Here’s an example bash command that can be run at a shell prompt or added to a <span class="literal">.bashrc</span> file:</p>&#13;
<p class="programs">export LD_LIBRARY_PATH=/home/me/lib:$LD_LIBRARY_PATH</p>&#13;
<p class="indent">When the <span class="literal">gcc</span> command lines get long, or when an executable requires many source and header files, it helps to simplify compilation by using <span class="literal">make</span> and a <span class="literal">Makefile</span>.<sup><a href="ch02.xhtml#fn2_7" id="rfn2_7">7</a></sup></p>&#13;
<h4 class="h4" id="lev2_41">2.9.6 Writing and Using Your Own C Libraries</h4>&#13;
<p class="noindent">Programmers typically divide large C programs into separate <em>modules</em> (i.e., separate <span class="literal">.c</span> files) of related functionality. Definitions shared by more than one module are put in header files (<span class="literal">.h</span> files) that are included by the modules that need them. Similarly, C library code is also implemented in one or more modules (<span class="literal">.c</span> files) and one or more header files (<span class="literal">.h</span> files). C programmers often implement their own C libraries of commonly used functionality. By writing a library, a programmer implements the functionality once, in the library, and then can use this functionality in any subsequent C program that they write.</p>&#13;
<p class="indent">In “C Libraries: Using, Compiling, and Linking” on <a href="ch02.xhtml#lev2_40">page 133</a>, we describe how to use, compile, and link C library code into C programs. In this section, we discuss how to write and use your own libraries in C. What we present here also applies to structuring and compiling larger C programs composed of multiple C source and header files.</p>&#13;
<p class="indent">To create a library in C:</p>&#13;
<div class="number">&#13;
<p class="number">1. Define an interface to the library in a header (<span class="literal">.h</span>) file. This header file must be included by any program that wants to use the library.</p>&#13;
<p class="number">2. Create an implementation of the library in one or more <span class="literal">.c</span> files. This set of function definitions implement the library’s functionality. Some functions may be interface functions that users of the <span epub:type="pagebreak" id="page_140"/>library will call, and others may be internal functions that cannot be called by users of the library (internal functions are part of good modular design of the library’s implementation).</p>&#13;
<p class="number">3. Compile a binary form of the library that can be linked into programs that use the library.</p>&#13;
</div>&#13;
<p class="indent">The binary form of a library could be directly built from its source file(s) as part of compiling the application code that uses the library. This method compiles the library files into <span class="literal">.o</span> files and statically links them into the binary executable. Including libraries this way often applies to library code that you write for your own use (since you have access to its <span class="literal">.c</span> source files), and it’s also the method to build an executable from multiple <span class="literal">.c</span> modules.</p>&#13;
<p class="indent">Alternatively, a library could be compiled into a binary archive (<span class="literal">.a</span>) or a shared object (<span class="literal">.so</span>) file for programs that want to use the library. In these cases, users of the library often will not have access to the library’s C source code files, and thus they are not able to directly compile the library code with application code that uses it. When a program uses such a precompiled library (e.g., a <span class="literal">.a</span> or <span class="literal">.so</span>), the library’s code must be explicitly linked into the executable file using <span class="literal">gcc</span>’s <span class="literal">-l</span> command line option.</p>&#13;
<p class="indent">We focus our detailed discussion of writing, compiling, and linking library code on the case in which the programmer has access to individual library modules (either the <span class="literal">.c</span> or <span class="literal">.o</span> files). This focus also applies to designing and compiling large C programs that are divided into multiple <span class="literal">.c</span> and <span class="literal">.h</span> files. We briefly show commands for building archive and shared object forms of libraries. More information about building these types of library files is available in the <span class="literal">gcc</span> documentation, including the man pages for <span class="literal">gcc</span> and <span class="literal">ar</span>.</p>&#13;
<p class="indent">In the following, we show some examples of creating and using your own libraries.</p>&#13;
<p class="noindentt"><strong>Define the library interface</strong> Header files (<span class="literal">.h</span> file) are text files that contain C function prototypes and other definitions—they represent the interface of a library. A header file must be included in any application that intends to use the library. For example, the C standard library header files are usually stored in <span class="literal">/usr/include/</span> and can be viewed with an editor:</p>&#13;
<p class="programs">$ <span class="codestrong1">vi /usr/include/stdio.h</span></p>&#13;
<p class="indent">Here’s an example header file<sup><a href="ch02.xhtml#fn2_8" id="rfn2_8">8</a></sup> from a library that contains some definitions for users of the library:</p>&#13;
<p class="margnote">myfile.h</p>&#13;
<p class="programs">#ifndef _MYLIB_H_<br/>&#13;
#define _MYLIB_H_<br/>&#13;
<br/>&#13;
// a constant definition exported by library:<br/>&#13;
#define MAX_FOO  20<br/>&#13;
<br/>&#13;
// a type definition exported by library:<br/>&#13;
<span epub:type="pagebreak" id="page_141"/>&#13;
struct foo_struct {<br/>&#13;
    int x;<br/>&#13;
    float y;<br/>&#13;
};<br/>&#13;
<br/>&#13;
// a global variable exported by library<br/>&#13;
// "extern" means that this is not a variable declaration,<br/>&#13;
// but it defines that a variable named total_times of type<br/>&#13;
// int exists in the library implementation and is available<br/>&#13;
// for use by programs using the library.<br/>&#13;
// It is unusual for a library to export global variables<br/>&#13;
// to its users, but if it does, it is important that<br/>&#13;
// extern appears in the definition in the .h file<br/>&#13;
extern int total_times;<br/>&#13;
<br/>&#13;
// a function prototype for a function exported by library:<br/>&#13;
// extern means that this function definition exists<br/>&#13;
// somewhere else.<br/>&#13;
/*<br/>&#13;
 * This function returns the larger of two float values<br/>&#13;
 *  y, z: the two values<br/>&#13;
 *  returns the value of the larger one<br/>&#13;
 */<br/>&#13;
extern float bigger(float y, float z);<br/>&#13;
<br/>&#13;
#endif</p>&#13;
<p class="indent">Header files typically have special “boilerplate” code around their contents. For example:</p>&#13;
<p class="programs">#ifndef <span class="codeitalic1">&lt;identifier&gt;</span><br/>&#13;
<br/>&#13;
// header file contents<br/>&#13;
<br/>&#13;
#endif <span class="codeitalic1">&lt;identifier&gt;</span></p>&#13;
<p class="indent">This boilerplate code ensures that the compiler’s preprocessor only includes the contents of <span class="literal">mylib.h</span> exactly once in any C file that includes it. It is important to include <span class="literal">.h</span> file contents only once to avoid duplicate definition errors at compile time. Similarly, if you forget to include a <span class="literal">.h</span> file in a C program that uses the library, the compiler will generate an “undefined symbol” warning.</p>&#13;
<p class="indent">The comments in the <span class="literal">.h</span> file are part of the interface to the library, written for users of the library. These comments should be verbose, explaining definitions and describing what each library function does, what parameter values it takes, and what it returns. Sometimes a <span class="literal">.h</span> file will also include a top-level comment describing how to use the library.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_142"/>The keyword <span class="literal">extern</span> before the global variable definition and function prototype means that these names are defined somewhere else. It is particularly important to include <span class="literal">extern</span> before any global variables that the library exports, as it distinguishes a name and type definition (in the <span class="literal">.h</span> file) from a variable declaration in the library’s implementation. In the previous example, the global variable is declared exactly once inside the library, but it’s exported to library users through its <span class="literal">extern</span> definition in the library’s <span class="literal">.h</span> file.</p>&#13;
<p class="noindentt"><strong>Implement the library functionality.</strong> Programmers implement libraries in one or more <span class="literal">.c</span> files (and sometimes internal <span class="literal">.h</span> files). The implementation includes definitions of all the function prototypes in the <span class="literal">.h</span> file as well as other functions that are internal to its implementation. These internal functions are often defined with the keyword <span class="literal">static</span>, which scopes their availability to the module (<span class="literal">.c</span> file) in which they are defined. The library implementation should also include variable definitions for any <span class="literal">extern</span> global variable declarations in the <span class="literal">.h</span> file. Here’s an example library implementation:</p>&#13;
<p class="margnote">mylib.c</p>&#13;
<p class="programs">#include &lt;stdlib.h&gt;<br/>&#13;
<br/>&#13;
// Include the library header file if the implementation needs<br/>&#13;
// any of its definitions (types or constants, for example.)<br/>&#13;
// Use " " instead of &lt; &gt; if the mylib.h file is not in a<br/>&#13;
// default library path with other standard library header<br/>&#13;
// files (the usual case for library code you write and use.)<br/>&#13;
#include "mylib.h"<br/>&#13;
<br/>&#13;
// declare the global variable exported by the library<br/>&#13;
int total_times = 0;<br/>&#13;
<br/>&#13;
// include function definitions for each library function:<br/>&#13;
float bigger(float y, float z) {<br/>&#13;
    total_times++;<br/>&#13;
    if (y &gt; z) {<br/>&#13;
        return y;<br/>&#13;
    }<br/>&#13;
    return z;<br/>&#13;
}</p>&#13;
<p class="noindentt"><strong>Create a binary form of the library.</strong> To create a binary form of the library (a <span class="literal">.o</span> file), compile with the <span class="literal">-c</span> option:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o mylib.o -c mylib.c</span></p>&#13;
<p class="indent">One or more <span class="literal">.o</span> files can build an archive (<span class="literal">.a</span>) or shared object (<span class="literal">.so</span>) version of the library. To build a static library use the archiver (<span class="literal">ar</span>):</p>&#13;
<p class="programs">$ <span class="codestrong1">ar -rcs libmylib.a mylib.o</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_143"/>To build a dynamically linked library, the <span class="literal">mylib.o</span> object file(s) in the library must be built with <em>position independent code</em> (using <span class="literal">-fPIC</span>). A <span class="literal">libmylib.so</span> shared object file can be created from <span class="literal">mylib.o</span> by specifying the <span class="literal">-shared</span> flag to <span class="literal">gcc</span>:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -fPIC -o mylib.o -c mylib.c</span><br/>&#13;
$ <span class="codestrong1">gcc -shared -o libmylib.so mylib.o</span></p>&#13;
<p class="indent">Shared object and archive libraries are often built from multiple <span class="literal">.o</span> files, for example (remember that <span class="literal">.o</span> for dynamically linked libraries need to be built using the <span class="literal">-fPIC</span> flag):</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -shared -o libbiglib.so file1.o file2.o file3.o file4.o</span><br/>&#13;
$ <span class="codestrong1">ar -rcs libbiglib.a file1.o file2.o file3.o file4.o</span></p>&#13;
<p class="noindentt"><strong>Use and link the library.</strong> Other <span class="literal">.c</span> files that use this library should <span class="literal">#include</span> its header file, and the implementation (<span class="literal">.o</span> file) should be explicitly linked during compilation.</p>&#13;
<p class="indent">After including the library header file, your code then can call the library’s functions:</p>&#13;
<p class="margnote">myprog.c</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
#include "mylib.h"   // include library header file<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    float val1, val2, ret;<br/>&#13;
    printf("Enter two float values: ");<br/>&#13;
    scanf("%f%f", &amp;val1, &amp;val2);<br/>&#13;
    ret = bigger(val1, val2);   // use a library function<br/>&#13;
    printf("%f is the biggest\n", ret);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="note"><strong><span class="black">Note</span> #INCLUDE SYNTAX AND THE PREPROCESSOR</strong></p>&#13;
<p class="note1">The <span class="literal">#include</span> syntax to include <span class="literal">mylib.h</span> is different from the syntax to include <span class="literal">stdio.h</span>. This is because <span class="literal">mylib.h</span> is not located with the header files from standard libraries. The preprocessor has default places it looks for standard header files. When including a file with the <span class="literal">&lt;file.h&gt;</span> syntax instead of the <span class="literal">"file.h"</span> syntax, the preprocessor searches for the header file in those standard places.</p>&#13;
<p class="note1"><span epub:type="pagebreak" id="page_144"/>When <span class="literal">mylib.h</span> is included inside double quotes, the preprocessor first looks in the current directory for the <span class="literal">mylib.h</span> file, and then other places that you need to explicitly tell it to look, by specifying an include path (<span class="literal">-I</span>) to <span class="literal">gcc</span>. For example, if the header file is in the <span class="literal">/home/me/myincludes</span> directory (and not in the same directory as the <span class="literal">myprog.c</span> file), then the path to this directory must be specified in the <span class="literal">gcc</span> command line for the preprocessor to find the <span class="literal">mylib.h</span> file:</p>&#13;
<p class="programsn">$ <span class="codestrong1">gcc -I/home/me/myincludes -c myprog.c</span></p>&#13;
<p class="indent">To compile a program (<span class="literal">myprog.c</span>) that uses the library (<span class="literal">mylib.o</span>) into a binary executable:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o myprog myprog.c mylib.o</span></p>&#13;
<p class="indent">Or, if the library’s implementation files are available at compile time, then the program can be built directly from the program and library <span class="literal">.c</span> files:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o myprog myprog.c mylib.c</span></p>&#13;
<p class="indent">Or, if the library is available as an archive or shared object file, then it can be linked in using <span class="literal">-l</span> (<span class="literal">-lmylib</span>: note that the library name is <span class="literal">libmylib.[a,so]</span>, but only the <span class="literal">mylib</span> part is included in the <span class="literal">gcc</span> command line):</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o myprog myprog.c -L. -lmylib</span></p>&#13;
<p class="indent">The <span class="literal">-L.</span> option specifies the path to the <span class="literal">libmylib.[so,a]</span> files (the <span class="literal">.</span> after the <span class="literal">-L</span> indicates that it should search the current directory). By default, <span class="literal">gcc</span> will dynamically link a library if it can find a <span class="literal">.so</span> version. See “C Libraries: Using, Compiling, and Linking” on <a href="ch02.xhtml#lev2_40">page 133</a> for more information about linking and link paths.</p>&#13;
<p class="indent">The program can then be run:</p>&#13;
<p class="programs">$ <span class="codestrong1">./myprog</span></p>&#13;
<p class="indent">If you run the dynamically linked version of <span class="literal">myprog</span>, you may encounter an error that looks like this:</p>&#13;
<p class="programs">/usr/bin/ld: cannot find -lmylib<br/>&#13;
collect2: error: ld returned 1 exit status</p>&#13;
<p class="indent">This error is saying that the runtime linker cannot find <span class="literal">libmylib.so</span> at runtime. To fix this problem, set your <span class="literal">LD_LIBRARY_PATH</span> environment variable to include the path to the <span class="literal">libmylib.so</span> file. Subsequent runs of <span class="literal">myprog</span> use the path you add to <span class="literal">LD_LIBRARY_PATH</span> to find the <span class="literal">libmylib.so</span> file and load it at runtime. For example, if <span class="literal">libmylib.so</span> is in the <span class="literal">/home/me/mylibs/</span> subdirectory, run this (just once) at the bash shell prompt to set the <span class="literal">LD_LIBRARY_PATH</span> environment variable:</p>&#13;
<p class="programs">$ <span class="codestrong1">export LD_LIBRARY_PATH=/home/me/mylibs:$LD_LIBRARY_PATH</span></p>&#13;
<h4 class="h4" id="lev2_42"><span epub:type="pagebreak" id="page_145"/>2.9.7 Compiling C to Assembly, and Compiling and Linking Assembly and C Code</h4>&#13;
<p class="noindent">A compiler can compile C code to assembly code, and it can compile assembly code into a binary form that links into a binary executable program. We use IA32 assembly and <span class="literal">gcc</span> as our example assembly language and compiler, but this functionality is supported by any C compiler, and most compilers support compiling to a number of different assembly languages. See <a href="ch08.xhtml#ch08">Chapter 8</a> for details about assembly code and assembly programming.</p>&#13;
<p class="indent">Consider this very simple C program:</p>&#13;
<p class="margnote">simpleops.c</p>&#13;
<p class="programs">int main() {<br/>&#13;
    int x, y;<br/>&#13;
    x = 1;<br/>&#13;
    x = x + 2;<br/>&#13;
    x = x - 14;<br/>&#13;
    y = x*100;<br/>&#13;
    x = x + y * 6;<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">gcc</span> compiler will compile it into an IA32 assembly text file (<span class="literal">.s</span>) using the <span class="literal">-S</span> command line option to specify compiling to assembly and the <span class="literal">-m32</span> command line option to specify generating IA32 assembly:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -m32 -S simpleops.c</span>   # runs the assembler to create a .s text file</p>&#13;
<p class="indent">This command creates a file named <span class="literal">simpleops.s</span> with the compiler’s IA32 assembly translation of the C code. Because the <span class="literal">.s</span> file is a text file, a user can view it (and edit it) using any text editor. For example:</p>&#13;
<p class="programs">$ <span class="codestrong1">vim simpleops.s</span></p>&#13;
<p class="indent">Passing additional compiler flags provides directions to <span class="literal">gcc</span> that it should use certain features or optimizations in its translation of C to IA32 assembly code.</p>&#13;
<p class="indent">An assembly code file, either one generated from <span class="literal">gcc</span> or one written by hand by a programmer, can be compiled by <span class="literal">gcc</span> into binary machine code form using the <span class="literal">-c</span> option:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -m32 -c simpleops.s</span>   # compiles to a relocatable object binary file (.o)</p>&#13;
<p class="indent">The resulting <span class="literal">simpleops.o</span> file can then be linked into a binary executable file (note: this requires that the 32-bit version of the system libraries are installed on your system):</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -m32 -o simpleops simpleops.o</span>  # creates a 32-bit executable file</p>&#13;
<p class="indent">This command creates a binary executable file, <span class="literal">simpleops</span>, for IA32 (and x86-64) architectures.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_146"/>The <span class="literal">gcc</span> command line to build an executable file can include <span class="literal">.o</span> and <span class="literal">.c</span> files that will be compiled and linked together to create the single binary executable.</p>&#13;
<p class="indent">Systems provide utilities that allow users to view binary files. For example, <span class="literal">objdump</span> displays the machine code and assembly code mappings in <span class="literal">.o</span> files:</p>&#13;
<p class="programs">$ <span class="codestrong1">objdump -d simpleops.o</span></p>&#13;
<p class="indent">This output can be compared to the assembly file:</p>&#13;
<p class="programs">$ <span class="codestrong1">cat simpleops.s</span></p>&#13;
<p class="indent">You should see something like this (we’ve annotated some of the assembly code with its corresponding code from the C program):</p>&#13;
<p class="programs">        .file   "simpleops.c"<br/>&#13;
        .text<br/>&#13;
        .globl main<br/>&#13;
        .type   main, @function<br/>&#13;
main:<br/>&#13;
        pushl   %ebp<br/>&#13;
        movl    %esp, %ebp<br/>&#13;
        subl    $16, %esp<br/>&#13;
        movl    $1, -8(%ebp)      # x = 1<br/>&#13;
        addl    $2, -8(%ebp)      # x = x + 2<br/>&#13;
        subl    $14, -8(%ebp)     # x = x - 14<br/>&#13;
        movl    -8(%ebp), %eax    # load x into R[%eax]<br/>&#13;
        imull   $100, %eax, %eax  # into R[%eax] store result of x*100<br/>&#13;
        movl    %eax, -4(%ebp)    # y = x*100<br/>&#13;
        movl    -4(%ebp), %edx<br/>&#13;
        movl    %edx, %eax<br/>&#13;
        addl    %eax, %eax<br/>&#13;
        addl    %edx, %eax<br/>&#13;
        addl    %eax, %eax<br/>&#13;
        addl    %eax, -8(%ebp)<br/>&#13;
        movl    $0, %eax<br/>&#13;
        leave<br/>&#13;
        ret<br/>&#13;
        .size   main, .-main<br/>&#13;
        .ident "GCC: (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0"<br/>&#13;
        .section .note.GNU-stack,"",@progbits</p>&#13;
<h5 class="h5" id="lev3_32">Writing and Compiling Assembly Code</h5>&#13;
<p class="noindent">Programmers can write their own assembly code by hand and compile it with <span class="literal">gcc</span> into a binary executable program. For example, to implement a function in assembly, add code to a <span class="literal">.s</span> file and use <span class="literal">gcc</span> to compile it. The following example shows the basic structure of a function in IA32 assembly. <span epub:type="pagebreak" id="page_147"/>Such code would be written in a file (e.g., <span class="literal">myfunc.s</span>) for a function with the prototype <span class="literal">int myfunc(int param);</span>. Functions with more parameters or needing more space for local variables may differ slightly in their preamble code.</p>&#13;
<p class="programs">        .text                   # this file contains instruction code<br/>&#13;
.globl myfunc                   # myfunc is the name of a function<br/>&#13;
        .type   myfunc, @function<br/>&#13;
myfunc:                         # the start of the function<br/>&#13;
        pushl   %ebp            # function preamble:<br/>&#13;
        movl    %esp, %ebp      #  the 1st three instrs set up the stack<br/>&#13;
        subl    $16, %esp<br/>&#13;
<br/>&#13;
        # A programmer adds specific IA32 instructions<br/>&#13;
        # here that allocate stack space for any local variables<br/>&#13;
        # and then implements code using parameters and locals to<br/>&#13;
        # perform the functionality of the myfunc function<br/>&#13;
        #<br/>&#13;
        # the return value should be stored in %eax before returning<br/>&#13;
<br/>&#13;
        leave    # function return code<br/>&#13;
        ret</p>&#13;
<p class="indent">A C program that wanted to call this function would need to include its function prototype:</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int myfunc(int param);<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int ret;<br/>&#13;
<br/>&#13;
    ret = myfunc(32);<br/>&#13;
    printf("myfunc(32) is %d\n", ret);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">The following <span class="literal">gcc</span> commands build an executable file (<span class="literal">myprog</span>) from <span class="literal">myfunc.s</span> and <span class="literal">main.c</span> source files:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -m32 -c myfunc.s</span><br/>&#13;
$ <span class="codestrong1">gcc -m32 -o myprog myfunc.o main.c</span></p>&#13;
<div class="g-box">&#13;
<p class="box-title"><span epub:type="pagebreak" id="page_148"/>HANDWRITTEN ASSEMBLY CODE</p>&#13;
<p class="noindentt">Unlike C, which is a high-level language that can be compiled and run on a wide variety of systems, assembly code is very low level and specific to a particular hardware architecture. Programmers may handwrite assembly code for low-level functions or for code sequences that are crucial to the performance of their software. A programmer can sometimes write assembly code that runs faster than the compiler-optimized assembly translation of C, and sometimes a C programmer wants to access low-level parts of the underlying architecture (such as specific registers) in their code. Small parts of operating system code are often implemented in assembly code for these reasons. However, because C is a portable language and is much higher level than assembly languages, the vast majority of operating system code is written in C, relying on good optimizing compilers to produce machine code that performs well.</p>&#13;
<p class="noindentt">Although most systems programmers rarely write assembly code, being able to read and understand a program’s assembly code is an important skill for obtaining a deeper understanding of what a program does and how it gets executed. It can also help with understanding a program’s performance and with discovering and understanding security vulnerabilities in programs.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_18">2.10 Summary</h3>&#13;
<p class="noindent">In this chapter, we covered the C programming language in depth and discussed some advanced C programming topics, as well. In the next chapter, we present two very helpful C debugging tools: the GNU GDB debugger for general-purpose C program debugging, and the Valgrind memory debugger for finding memory access errors in C programs. Equipped with these programming tools and knowledge of the core C programming language presented in this chapter, a C programmer can design powerful, efficient, and robust software.</p>&#13;
<h3 class="h3" id="lev1_19">Notes</h3>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_1" id="fn2_1">1.</a> <em><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf">http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_2" id="fn2_2">2.</a> <em><a href="https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c">https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_3" id="fn2_3">3.</a> <em><a href="http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html">http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_4" id="fn2_4">4.</a> <em><a href="https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c">https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_5" id="fn2_5">5.</a> <em><a href="https://wikipedia.org/wiki/Executable_and_Linkable_Format">https://wikipedia.org/wiki/Executable_and_Linkable_Format</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_6" id="fn2_6">6.</a> <em><a href="http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html">http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_7" id="fn2_7">7.</a> <em><a href="https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html">https://www.cs.swarthmore.edu/~newhall/unixhelp/howto<sub>m</sub>akefiles.html</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_8" id="fn2_8">8.</a> <em><a href="https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h">https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h</a></em></p>&#13;
</body></html>