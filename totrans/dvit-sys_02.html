<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_63"/><span class="big">2</span><br/>A DEEPER DIVE INTO C PROGRAMMING</h2>&#13;
<div class="imagec"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindents">With many of the basics of C programming covered in the previous chapter, we now dive deeper into the details of C. In this chapter we revisit many of the topics from the previous chapter, such as arrays, strings, and structs, discussing them in more detail. We also introduce C’s pointer variables and dynamic memory allocation. <em>Pointers</em> provide a level of indirection to accessing program state, and <em>dynamic memory allocation</em> allows a program to adjust to changes in size and space needs as it runs, allocating more space as it needs it and freeing space it no longer needs. By understanding how and when to use pointer variables and dynamic memory allocation, a C programmer can design programs that are both powerful and efficient.</p>&#13;
<p class="indent">We begin with a discussion of the parts of program memory, as this will help in understanding many of the topics presented later. As the chapter <span epub:type="pagebreak" id="page_64"/>progresses, we cover C file I/O and some advanced C topics including library linking and compiling to assembly code.</p>&#13;
<h3 class="h3" id="lev1_9">2.1 Parts of Program Memory and Scope</h3>&#13;
<p class="noindent">The following C program shows examples of functions, parameters, and local and global variables (function comments are omitted to shorten this code listing):</p>&#13;
<pre>/* An example C program with local and global variables */<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int max(int n1, int n2); /* function prototypes */<br/>&#13;
int change(int amt);<br/>&#13;
<br/>&#13;
int g_x;  /* global variable: declared outside function bodies */<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int x, result;   /* local variables: declared inside function bodies */<br/>&#13;
<br/>&#13;
    printf("Enter a value: ");<br/>&#13;
    scanf("%d", &amp;x);<br/>&#13;
    g_x = 10;       /* global variables can be accessed in any function */<br/>&#13;
<br/>&#13;
    result = max(g_x, x);<br/>&#13;
    printf("%d is the largest of %d and %d\n", result, g_x, x);<br/>&#13;
<br/>&#13;
    result = change(10);<br/>&#13;
    printf("g_x's value was %d and now is %d\n", result, g_x);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int max(int n1, int n2) {  /* function with two parameters */<br/>&#13;
    int val;    /* local variable */<br/>&#13;
<br/>&#13;
    val = n1;<br/>&#13;
    if ( n2 &gt; n1 ) {<br/>&#13;
        val = n2;<br/>&#13;
    }<br/>&#13;
    return val;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int change(int amt) {<br/>&#13;
    int val;<br/>&#13;
<br/>&#13;
    val = g_x;  /* global variables can be accessed in any function */<br/>&#13;
    g_x += amt;<br/>&#13;
<span epub:type="pagebreak" id="page_65"/>&#13;
    return val;<br/>&#13;
}</pre>&#13;
<p class="indent">This example shows program variables with different scope. A variable’s <em>scope</em> defines when its name has meaning. In other words, scope defines the set of program code blocks in which a variable is bound to (associated with) a program memory location and can be used by program code.</p>&#13;
<p class="indent">Declaring a variable outside of any function body creates a <em>global variable</em>. Global variables remain permanently in scope and can be used by any code in the program because they’re always bound to one specific memory location. Every global variable must have a unique name—its name uniquely identifies a specific storage location in program memory for the entire duration of the program.</p>&#13;
<p class="indent"><em>Local variables and parameters</em> are only in scope inside the function in which they are defined. For example, the <code>amt</code> parameter is in scope only inside the <code>change</code> function. This means that only statements within the <code>change</code> function body can access the <code>amt</code> parameter, and an instance of the <code>amt</code> parameter is bound to a specific memory storage location only within a specific active execution of the function. Space to store a parameter’s value is allocated on the stack when the function gets called, and it is deallocated from the stack when the function returns. Each activation of a function gets its own bindings for its parameters and local variables. Thus, for recursive function calls, each call (or activation) gets a separate stack frame containing space for its parameters and local variables.</p>&#13;
<p class="indent">Because parameters and local variables are only in scope inside the function that defines them, different functions can use the same names for local variables and parameters. For example, both the <code>change</code> and the <code>max</code> functions have a local variable named <code>val</code>. When code in the <code>max</code> function refers to <code>val</code> it refers to its local variable <code>val</code> and not to the <code>change</code> function’s local variable <code>val</code> (which is not in scope inside the <code>max</code> function).</p>&#13;
<p class="indent">While there may occasionally be times when using global variables in C programs is necessary, we strongly recommend that you <em>avoid programming with global variables whenever possible</em>. Using only local variables and parameters yields code that’s more modular, more general-purpose, and easier to debug. Also, because a function’s parameters and local variables are only allocated in program memory when the function is active, they may result in more space-efficient programs.</p>&#13;
<p class="indent">Upon launching a new program, the operating system allocates the new program’s address space. A program’s <em>address space</em> (or memory space) represents storage locations for everything it needs in its execution, namely storage for its instructions and data. A program’s address space can be thought of as an array of addressable bytes; each used address in the program’s address space stores all or part of a program instruction or data value (or some additional state necessary for the program’s execution).</p>&#13;
<p class="indent">A program’s memory space is divided into several parts, each of which is used to store a different kind of entity in the process’s address space. <a href="ch02.xhtml#ch2fig1">Figure 2-1</a> illustrates the parts of a program’s memory space.</p>&#13;
<span epub:type="pagebreak" id="page_66"/>&#13;
<div class="imagec" id="ch2fig1"><img alt="image" src="../images/02fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-1: The parts of a program’s address space</em></p>&#13;
<p class="indent">The top of a program’s memory is reserved for use by the operating system, but the remaining parts are usable by the running program. The program’s instructions are stored in the <em>code</em> section of the memory. For example, the program listed earlier stores instructions for the <code>main</code>, <code>max</code>, and <code>change</code> functions in this region of memory.</p>&#13;
<p class="indent">Local variables and parameters reside in the portion of memory for the <em>stack</em>. Because the amount of stack space grows and shrinks over the program’s execution as functions are called and returned from, the stack part of memory is typically allocated near the bottom of memory (at the highest memory addresses) to leave space for it to change. Stack storage space for local variables and parameters exists only when the function is active (within the stack frame for the function’s activation on the stack).</p>&#13;
<p class="indent">Global variables are stored in the <em>data</em> section. Unlike the stack, the data region does not grow or shrink—storage space for globals persists for the entire run of the program.</p>&#13;
<p class="indent">Finally, the <em>heap</em> portion of memory is the part of a program’s address space associated with dynamic memory allocation. The heap is typically located far from stack memory and grows into higher addresses as more space is dynamically allocated by the running program.</p>&#13;
<h3 class="h3" id="lev1_10">2.2 C’s Pointer Variables</h3>&#13;
<p class="noindent">C’s pointer variables provide a level of indirection to accessing program memory. By understanding how to use pointer variables, a programmer can write C programs that are both powerful and efficient. For example, through pointer variables, a C programmer can:</p>&#13;
<ul>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_67"/>implement functions whose parameters can modify values in the caller’s stack frame</li>&#13;
<li class="noindent">dynamically allocate (and deallocate) program memory at runtime when the program needs it</li>&#13;
<li class="noindent">efficiently pass large data structures to functions</li>&#13;
<li class="noindent">create linked dynamic data structures</li>&#13;
<li class="noindent">interpret bytes of program memory in different ways.</li>&#13;
</ul>&#13;
<p class="indent">In this section, we introduce the syntax and semantics of C’s pointer variables and introduce common examples of how to use them in C programs.</p>&#13;
<h4 class="h4" id="lev2_17">2.2.1 Pointer Variables</h4>&#13;
<p class="noindent">A <em>pointer variable</em> stores the address of a memory location in which a value of a specific type can be stored. For example, a pointer variable can store the value of an <code>int</code> address at which the integer value 12 is stored. The pointer variable <em>points to</em> (refers to) the value. A pointer provides <em>a level of indirection</em> for accessing values stored in memory. <a href="ch02.xhtml#ch2fig2">Figure 2-2</a> illustrates an example of what a pointer variable might look like in memory:</p>&#13;
<div class="imagec" id="ch2fig2"><img alt="image" src="../images/02fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-2: A pointer variable stores the address of a location in memory. Here, the pointer stores the address of an integer variable that holds the number 12.</em></p>&#13;
<p class="indent">Through the pointer variable, <code>ptr</code>, the value (<code>12</code>) stored in the memory location it points to can be indirectly accessed. C programs most frequently use pointer variables for:</p>&#13;
<div class="number">&#13;
<p class="number">1. <em>“pass by pointer” parameters</em>, for writing functions that can modify their argument’s value through a pointer parameter</p>&#13;
<p class="number">2. <em>dynamic memory allocation</em>, for writing programs that allocate (and free) space as the program runs. Dynamic memory is commonly used for dynamically allocating arrays. It is useful when a programmer doesn’t know the size of a data structure at compile time (e.g., the array size depends on user input at runtime). It also enables data structures to be resized as the program runs.</p>&#13;
</div>&#13;
<h5 class="h5" id="lev3_6">Rules for Using Pointer Variables</h5>&#13;
<p class="noindent">The rules for using pointer variables are similar to regular variables, except that you need to think about two types: the type of the pointer variable, and the type stored in the memory address to which the pointer variable points.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_68"/>First, <em>declare a pointer variable</em> using <span class="literal"/> <span class="codeitalic">&lt;type_name&gt;</span> <code>*</code><span class="codeitalic">&lt;var_name&gt;</span>:</p>&#13;
<pre>int *ptr;   // stores the memory address of an int (ptr "points to" an int)<br/>&#13;
char *cptr; // stores the memory address of a char (cptr "points to" a char)</pre>&#13;
<p class="note"><strong><span class="black">Note</span> POINTER TYPES</strong></p>&#13;
<p class="note1">Although <code>ptr</code> and <code>cptr</code> are both pointers, they refer to different types:</p>&#13;
<ul>&#13;
<li class="note1">The type of <code>ptr</code> is <em>pointer to int</em> (<code>int *</code>). It can point to a memory location that stores an <code>int</code> value.</li>&#13;
<li class="note1">The type of <code>cptr</code> is <em>pointer to char</em> (<code>char *</code>). It can point to a memory location that stores a <code>char</code> value.</li>&#13;
</ul>&#13;
<p class="indent">Next, <em>initialize the pointer variable</em> (make it point to something). Pointer variables <em>store address values</em>. A pointer should be initialized to store the address of a memory location whose type matches the type to which the pointer variable points. One way to initialize a pointer is to use the <em>address operator</em> (<code>&amp;</code>) with a variable to get the variable’s address value:</p>&#13;
<pre>int x;<br/>&#13;
char ch;<br/>&#13;
<br/>&#13;
ptr = &amp;x;    // ptr gets the address of x, pointer "points to" x<br/>&#13;
cptr = &amp;ch;  // cptr gets the address of ch, pointer "points to" ch</pre>&#13;
<div class="imagec" id="ch2fig3"><img alt="image" src="../images/02fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-3: A program can initialize a pointer by assigning it the address of an existing variable of the appropriate type.</em></p>&#13;
<p class="indent">Here’s an example of an invalid pointer initialization due to mismatched types:</p>&#13;
<pre>cptr = &amp;x;   // ERROR: cptr can hold a char memory location<br/>&#13;
             // (&amp;x is the address of an int)</pre>&#13;
<p class="noindent">Even though the C compiler may allow this type of assignment (with a warning about incompatible types), the behavior of accessing and modifying <code>x</code> through <code>cptr</code> will likely not behave as the programmer expects. Instead, the programmer should use an <code>int *</code> variable to point to an <code>int</code> storage location.</p>&#13;
<p class="indent">All pointer variables can also be assigned a special value, <code>NULL</code>, which represents an invalid address. While a <em>null pointer</em> (one whose value is <code>NULL</code>) should never be used to access memory, the value <code>NULL</code> is useful for testing a pointer variable to see if it points to a valid memory address. That is, C <span epub:type="pagebreak" id="page_69"/>programmers will commonly check a pointer to ensure that its value isn’t <code>NULL</code> before attempting to access the memory location to which it points. To set a pointer to <code>NULL</code>:</p>&#13;
<pre>ptr = NULL;<br/>&#13;
cptr = NULL;</pre>&#13;
<div class="imagec" id="ch2fig4"><img alt="image" src="../images/02fig04.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-4: Any pointer can be given the special value <code>NULL</code>, which indicates that it doesn’t refer to any particular address. Null pointers should never be dereferenced.</em></p>&#13;
<p class="indent">Finally, <em>use the pointer variable</em>. The <em>dereference operator</em> (<code>*</code>) follows a pointer variable to the location in memory that it points to and accesses the value at that location:</p>&#13;
<pre>/* Assuming an integer named x has already been declared, this code sets the<br/>&#13;
   value of x to 8. */<br/>&#13;
<br/>&#13;
ptr = &amp;x;   /* initialize ptr to the address of x (ptr points to variable x) */<br/>&#13;
*ptr = 8;   /* the memory location ptr points to is assigned 8 */</pre>&#13;
<div class="imagec" id="ch2fig5"><img alt="image" src="../images/02fig05.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-5: Dereferencing a pointer accesses the value to which the pointer refers.</em></p>&#13;
<h5 class="h5" id="lev3_7">Pointer Examples</h5>&#13;
<p class="noindent">Here’s an example sequence of C statements using two pointer variables:</p>&#13;
<pre>int *ptr1, *ptr2, x, y;<br/>&#13;
<br/>&#13;
x = 8;<br/>&#13;
ptr2 = &amp;x;     // ptr2 is assigned the address of x<br/>&#13;
ptr1 = NULL;</pre>&#13;
<div class="imagec"><img alt="image" src="../images/f0069-01.jpg"/></div>&#13;
<span epub:type="pagebreak" id="page_70"/>&#13;
<pre>*ptr2 = 10;     // the memory location ptr2 points to is assigned 10<br/>&#13;
y = *ptr2 + 3;  // y is assigned what ptr2 points to plus 3</pre>&#13;
<div class="imagec"><img alt="image" src="../images/f0070-01.jpg"/></div>&#13;
<pre>ptr1 = ptr2;   // ptr1 gets the address value stored in ptr2 (both point to x)</pre>&#13;
<div class="imagec"><img alt="image" src="../images/f0070-02.jpg"/></div>&#13;
<pre>*ptr1 = 100;</pre>&#13;
<div class="imagec"><img alt="image" src="../images/f0070-03.jpg"/></div>&#13;
<pre>ptr1 = &amp;y;     <span class="codeitalic1">// change ptr1's value (change what it points to)</span><br/>&#13;
*ptr1 = 80;</pre>&#13;
<div class="imagec"><img alt="image" src="../images/f0070-04.jpg"/></div>&#13;
<p class="indent">When using pointer variables, carefully consider the types of the relevant variables. Drawing pictures of memory (like those shown above) can help with understanding what pointer code is doing. Some common errors involve misusing the dereference operator (<code>*</code>) or the address operator (<code>&amp;</code>). For example:</p>&#13;
<pre>ptr = 20;       // ERROR?:  this assigns ptr to point to address 20<br/>&#13;
ptr = &amp;x;<br/>&#13;
*ptr = 20;      // CORRECT: this assigns 20 to the memory pointed to by ptr</pre>&#13;
<p class="indent">If your program dereferences a pointer variable that does not contain a valid address, the program crashes:</p>&#13;
<span epub:type="pagebreak" id="page_71"/>&#13;
<pre>ptr = NULL;<br/>&#13;
*ptr = 6;    // CRASH! program crashes with a segfault (a memory fault)<br/>&#13;
<br/>&#13;
ptr = 20;<br/>&#13;
*ptr = 6;    // CRASH! segfault (20 is not a valid address)<br/>&#13;
<br/>&#13;
ptr = x;<br/>&#13;
*ptr = 6;    // likely CRASH or may set some memory location with 6<br/>&#13;
             // (depends on the value of x which is used as an address value)<br/>&#13;
<br/>&#13;
ptr = &amp;x;    // This is probably what the programmer intended<br/>&#13;
*ptr = 6;</pre>&#13;
<p class="indent">These types of errors exemplify one reason to initialize pointer variables to <code>NULL</code>; a program can then test a pointer’s value for <code>NULL</code> before dereferencing it:</p>&#13;
<pre>if (ptr != NULL) {<br/>&#13;
    *ptr = 6;<br/>&#13;
}</pre>&#13;
<h3 class="h3" id="lev1_11">2.3 Pointers and Functions</h3>&#13;
<p class="noindent">Pointer parameters provide a mechanism through which functions can modify argument values. The commonly used <em>pass by pointer</em> pattern uses a pointer function parameter that <em>gets the value of the address of some storage location</em> passed to it by the caller. For example, the caller could pass the address of one of its local variables. By dereferencing the pointer parameter inside the function, the function can modify the value at the storage location to which it points.</p>&#13;
<p class="indent">We have already seen similar functionality with array parameters, where an array function parameter gets the value of the base address of the passed array (the parameter refers to the same set of array elements as its argument), and the function can modify the values stored in the array. In general, this same idea can be applied by passing pointer parameters to functions that point to the memory locations in the caller’s scope.</p>&#13;
<p class="note"><strong><span class="black">Note</span> PASS BY VALUE</strong></p>&#13;
<p class="note1">All arguments in C are passed by value and follow pass-by-value semantics: the parameter gets a copy of its argument value, and modifying the parameter’s value does not change its argument’s value. When passing base type values, like the value of an <code>int</code> variable, the function parameter gets a copy of its argument value (the specific <code>int</code> value), and changing the value stored in the parameter cannot change the value stored in its argument.</p>&#13;
<p class="note1"><span epub:type="pagebreak" id="page_72"/>In the pass-by-pointer pattern, the parameter still gets the value of its argument, but it is passed <em>the value of an address</em>. Just like in passing base types, changing a pointer parameter’s value will not change its argument’s value (i.e., assigning the parameter to point to a different address will not change the argument’s address value). However, by dereferencing a pointer parameter, the function can change the contents of memory that both the parameter and its argument refer to; through a pointer parameter, a function can modify a variable that is visible to the caller after the function returns.</p>&#13;
<p class="indent">Here are the steps for implementing and calling a function with a pass-by-pointer parameter, with example code snippets showing each step:</p>&#13;
<div class="number">&#13;
<p class="number">1. Declare the function parameter to be a pointer to the variable type:</p>&#13;
<p class="programs1">/* input: an int pointer that stores the address of a memory<br/>&#13;
 *        location that can store an int value (it points to an int)<br/>&#13;
 */<br/>&#13;
int change_value(int *input) {</p>&#13;
<p class="number">2. When making the function call, pass in the address of a variable as the argument:</p>&#13;
<p class="programs1">int x;<br/>&#13;
change_value(&amp;x);</p>&#13;
<p class="number-p">In the preceding example, since the parameter’s type is <code>int *</code>, the address passed must be the address of an <code>int</code> variable.</p>&#13;
<p class="number">3. In the body of the function, dereference the pointer parameter to change the argument’s value:</p>&#13;
<p class="programs1">*input = 100;  // the location input points to (x's memory) <br/>&#13;
               // is assigned 100</p>&#13;
</div>&#13;
<p class="indent">Next, let’s examine a larger example program:</p>&#13;
<p class="margnote">passbypointer.c</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int change_value(int *input);<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int x;<br/>&#13;
    int y;<br/>&#13;
<br/>&#13;
    x = 30;<br/>&#13;
    y = change_value(&amp;x);<br/>&#13;
    printf("x: %d y: %d\n", x, y);  // prints x: 100 y: 30<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
/*<br/>&#13;
<span epub:type="pagebreak" id="page_73"/>&#13;
 * changes the value of the argument<br/>&#13;
 *     input: a pointer to the value to change<br/>&#13;
 *     returns: the original value of the argument<br/>&#13;
 */<br/>&#13;
int change_value(int *input) {<br/>&#13;
    int val;<br/>&#13;
<br/>&#13;
    val = *input; /* val gets the value input points to */<br/>&#13;
<br/>&#13;
    if (val &lt; 100) {<br/>&#13;
        *input = 100;  /* the value input points to gets 100 */<br/>&#13;
    } else {<br/>&#13;
        *input =  val * 2;<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    return val;<br/>&#13;
}</pre>&#13;
<p class="indent">When run, the output is:</p>&#13;
<pre>x: 100 y: 30</pre>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig6">Figure 2-6</a> shows what the call stack looks like before executing the return in <code>change_value</code>.</p>&#13;
<div class="imagec" id="ch2fig6"><img alt="image" src="../images/02fig06.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-6: A snapshot of the call stack prior to returning from <code>change_value</code></em></p>&#13;
<p class="indent">The input parameter gets a copy of the value of its argument (the address of <code>x</code>). The value of <code>x</code> is 30 when the function call is made. Inside the <code>change_value</code> function, the parameter is dereferenced to assign the value 100 to the memory location pointed to by the parameter (<code>*input = 100;</code>, meaning “the location <code>input</code> points to gets the value 100”). Since the parameter stores the address of a local variable in the <code>main</code> function’s stack frame, through dereferencing the parameter, the value stored in the caller’s local variable can be changed. When the function returns, the argument’s value reflects the change made to it through the pointer parameter (the value of <code>x</code> in <code>main</code> was changed to 100 by the <code>change_value</code> function through its <code>input</code> parameter).</p>&#13;
<h3 class="h3" id="lev1_12"><span epub:type="pagebreak" id="page_74"/>2.4 Dynamic Memory Allocation</h3>&#13;
<p class="noindent">In addition to pass-by-pointer parameters, programs commonly use pointer variables to dynamically allocate memory. Such <em>dynamic memory allocation</em> allows a C program to request more memory as it’s running, and a pointer variable stores the address of the dynamically allocated space. Programs often allocate memory dynamically to tailor the size of an array for a particular run.</p>&#13;
<p class="indent">Dynamic memory allocation grants flexibility to programs that:</p>&#13;
<ul>&#13;
<li class="noindent">do not know the size of arrays or other data structures until runtime (e.g., the size depends on user input)</li>&#13;
<li class="noindent">need to allow for a variety of input sizes (not just up to some fixed capacity)</li>&#13;
<li class="noindent">want to allocate exactly the size of data structures needed for a particular execution (don’t waste capacity)</li>&#13;
<li class="noindent">grow or shrink the sizes of memory allocated as the program runs, reallocating more space when needed and freeing up space when it’s no longer required.</li>&#13;
</ul>&#13;
<h4 class="h4" id="lev2_18">2.4.1 Heap Memory</h4>&#13;
<p class="noindent">Every byte of memory in a program’s memory space has an associated address. Everything the program needs to run is in its memory space, and different types of entities reside in different parts of a program’s memory space. For example, the <em>code</em> region contains the program’s instructions, global variables reside in the <em>data</em> region, local variables and parameters occupy the <em>stack</em>, and dynamically allocated memory comes from the <em>heap</em>. Because the stack and the heap grow at runtime (as functions are called and return and as dynamic memory is allocated and freed), they are typically far apart in a program’s address space to leave a large amount of space for each to grow into as the program runs.</p>&#13;
<p class="indent">Dynamically allocated memory occupies the heap memory region of a program’s address space (see <a href="ch02.xhtml#lev1_10">page 66</a>). When a program dynamically requests memory at runtime, the heap provides a chunk of memory whose address must be assigned to a pointer variable.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig7">Figure 2-7</a> illustrates the parts of a running program’s memory with an example of a pointer variable (<code>ptr</code>) on the stack that stores the address of dynamically allocated heap memory (it points to heap memory).</p>&#13;
<span epub:type="pagebreak" id="page_75"/>&#13;
<div class="imagec" id="ch2fig7"><img alt="image" src="../images/02fig07.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-7: A pointer on the stack points to a block of memory that was allocated from the heap.</em></p>&#13;
<p class="indent">It’s important to remember that heap memory is anonymous memory, where “anonymous” means that addresses in the heap are not bound to variable names. Declaring a named program variable allocates it on the stack or in the data part of program memory. A local or global pointer variable can store the address of an anonymous heap memory location (e.g., a local pointer variable on the stack can point to heap memory), and dereferencing such a pointer enables a program to store data in the heap.</p>&#13;
<h4 class="h4" id="lev2_19">2.4.2 malloc and free</h4>&#13;
<p class="noindent"><em>malloc</em> and <em>free</em> are functions in the standard C library (<code>stdlib</code>) that a program can call to allocate and deallocate memory in the <em>heap</em>. Heap memory must be explicitly allocated (malloc’ed) and deallocated (freed) by a C program.</p>&#13;
<p class="indent">To allocate heap memory, call <code>malloc</code>, passing in the total number of bytes of contiguous heap memory to allocate. Use the <code>sizeof</code> <em>operator</em> to compute the number of bytes to request. For example, to allocate space on the heap to store a single integer, a program could call:</p>&#13;
<pre>// Determine the size of an integer and allocate that much heap space.<br/>&#13;
malloc(sizeof(int));</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>The <code>malloc</code> function returns the base address of the allocated heap memory to the caller (or <code>NULL</code> if an error occurs). Here’s a full example program with a call to <code>malloc</code> to allocate heap space to store a single <code>int</code> value:</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int *p;<br/>&#13;
<br/>&#13;
    p = malloc(sizeof(int));  // allocate heap memory for storing an int<br/>&#13;
<br/>&#13;
    if (p != NULL) {<br/>&#13;
        *p = 6;   // the heap memory p points to gets the value 6<br/>&#13;
    }<br/>&#13;
}</pre>&#13;
<p class="indent">The <code>malloc</code> function returns a <code>void *</code> type, which represents a generic pointer to a non-specified type (or to any type). When a program calls <code>malloc</code> and assigns the result to a pointer variable, the program associates the allocated memory with the type of the pointer variable.</p>&#13;
<p class="indent">Sometimes you may see calls to <code>malloc</code> that explicitly recast its return type from <code>void *</code> to match the type of the pointer variable. For example:</p>&#13;
<pre>p = (int *) malloc(sizeof(int));</pre>&#13;
<p class="indent">The <code>(int *)</code> before <code>malloc</code> tells the compiler that the <code>void *</code> type returned by <code>malloc</code> will be used as an <code>int *</code> in this call (it recasts the return type of <code>malloc</code> to an <code>int *</code>). We discuss type recasting and the <code>void *</code> type in more detail later in this chapter, on <a href="ch02.xhtml#lev2_38">page 126</a>.</p>&#13;
<p class="indent">A call to <code>malloc</code> fails if there is not enough free heap memory to satisfy the requested number of bytes to allocate. Usually, <code>malloc</code> failing indicates an error in the program such as passing <code>malloc</code> a very large request, passing a negative number of bytes, or calling <code>malloc</code> in an infinite loop and running out of heap memory. Because any call to <code>malloc</code> can fail, you should <em>always test its return value for</em> <span class="codeitalic">NULL</span> (indicating <code>malloc</code> failed) before dereferencing the pointer value. Dereferencing a null pointer will cause your program to crash! For example:</p>&#13;
<pre>int *p;<br/>&#13;
<br/>&#13;
p = malloc(sizeof(int));<br/>&#13;
if (p == NULL) {<br/>&#13;
    printf("Bad malloc error\n");<br/>&#13;
    exit(1);   // exit the program and indicate error<br/>&#13;
}<br/>&#13;
*p = 6;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_77"/>When a program no longer needs the heap memory it dynamically allocated with <code>malloc</code>, it should explicitly deallocate the memory by calling the <code>free</code> function. It’s also a good idea to set the pointer’s value to <code>NULL</code> after calling <code>free</code>, so that if an error in the program causes it to be accidentally dereferenced after the call to <code>free</code>, the program will crash rather than modify parts of heap memory that have been reallocated by subsequent calls to <code>malloc</code>. Such unintended memory references can result in undefined program behavior that is often very difficult to debug, whereas a null pointer dereference will fail immediately, making it a relatively easy bug to find and to fix.</p>&#13;
<pre>free(p);<br/>&#13;
p = NULL;</pre>&#13;
<h4 class="h4" id="lev2_20">2.4.3 Dynamically Allocated Arrays and Strings</h4>&#13;
<p class="noindent">C programmers often dynamically allocate memory to store arrays. A successful call to <code>malloc</code> allocates one contiguous chunk of heap memory of the requested size. It returns the address of the start of this chunk of memory to the caller, making the returned address value suitable for the base address of a dynamically allocated array in heap memory.</p>&#13;
<p class="indent">To dynamically allocate space for an array of elements, pass <code>malloc</code> the total number of bytes in the desired array. That is, the program should request from <code>malloc</code> the total number of bytes in each array element times the number of elements in the array. Pass <code>malloc</code> an expression for the total number of bytes in the form of <code>sizeof(</code> <span class="codeitalic">&lt;type&gt;</span><code>) *</code> <span class="codeitalic">&lt;number of elements&gt;</span>. For example:</p>&#13;
<pre>int *arr;<br/>&#13;
char *c_arr;<br/>&#13;
<br/>&#13;
// allocate an array of 20 ints on the heap:<br/>&#13;
arr = malloc(sizeof(int) * 20);<br/>&#13;
<br/>&#13;
// allocate an array of 10 chars on the heap:<br/>&#13;
c_arr = malloc(sizeof(char) * 10);</pre>&#13;
<p class="indent">After the calls to <code>malloc</code> in this example, the <code>int</code> pointer variable <code>arr</code> stores the base address of an array of 20 contiguous integer storage locations in heap memory, and the <code>c_arr</code> char pointer variable stores the base address of an array of 10 contiguous char storage locations in heap memory. <a href="ch02.xhtml#ch2fig8">Figure 2-8</a> depicts what this might look like.</p>&#13;
<span epub:type="pagebreak" id="page_78"/>&#13;
<div class="imagec" id="ch2fig8"><img alt="image" src="../images/02fig08.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-8: A 20-element integer array and 10-element character array allocated on the heap</em></p>&#13;
<p class="indent">Note that while <code>malloc</code> returns a pointer to dynamically allocated space in heap memory, C programs store the pointer to heap locations on the stack. The pointer variables contain <em>only the base address</em> (the starting address) of the array storage space in the heap. Just like statically declared arrays, the memory locations for dynamically allocated arrays are in contiguous memory locations. While a single call to <code>malloc</code> results in a chunk of memory of the requested number of bytes being allocated, multiple calls to <code>malloc</code> <em>will not</em> result in heap addresses that are contiguous (on most systems). In the previous example, the <code>char</code> array elements and the <code>int</code> array elements may be at addresses that are far apart in the heap.</p>&#13;
<p class="indent">After dynamically allocating heap space for an array, a program can access the array through the pointer variable. Because the pointer variable’s value represents the base address of the array in the heap, we can use the same syntax to access elements in dynamically allocated arrays as we use to access elements in statically declared arrays (see <a href="ch01.xhtml#lev1_5">page 44</a>). Here’s an example:</p>&#13;
<pre>int i;<br/>&#13;
int s_array[20];<br/>&#13;
int *d_array;<br/>&#13;
<br/>&#13;
d_array = malloc(sizeof(int) * 20);<br/>&#13;
if (d_array == NULL) {<br/>&#13;
    printf("Error: malloc failed\n");<br/>&#13;
    exit(1);<br/>&#13;
}<br/>&#13;
<br/>&#13;
for (i=0; i &lt; 20; i++) {<br/>&#13;
    s_array[i] = i;<br/>&#13;
    d_array[i] = i;<br/>&#13;
}<br/>&#13;
<br/>&#13;
printf("%d %d \n", s_array[3], d_array[3]);  // prints 3 3</pre>&#13;
<p class="indent">It may not be obvious why the same syntax can be used for accessing elements in dynamically allocated arrays as is used in accessing elements in statically declared arrays. However, even though their types are different, the values of <code>s_array</code> and <code>d_array</code> both evaluate to the base address of the array in memory (see <a href="ch02.xhtml#ch2tab1">Table 2-1</a>).</p>&#13;
<p class="tabcap" id="ch2tab1"><span epub:type="pagebreak" id="page_79"/><strong>Table 2-1:</strong> Comparison of Statically Allocated <code>s_array</code> and Dynamically Allocated <code>d_array</code></p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Expression</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Type</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>s_array</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">base address of array in memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(static) array of integers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>d_array</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">base address of array in memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">integer pointer (<code>int *</code>)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Because the names of both variables evaluate to the base address of the array in memory (the address of the first element memory), the semantics of the <code>[i]</code> syntax following the name of the variable remain the same for both: <code>[i]</code> <em>dereferences the</em> <span class="codeitalic">int</span> <em>storage location at offset</em> <span class="codeitalic">i</span> <em>from the base address of the array in memory</em>—it’s accessing the <code>i</code>th element.</p>&#13;
<p class="indent">For most purposes, we recommend using the <code>[i]</code> syntax to access the elements of a dynamically allocated array. However, programs can also use the pointer dereferencing syntax (the <code>*</code> operator) to access array elements. For example, placing a <code>*</code> in front of a pointer that refers to a dynamically allocated array will dereference the pointer to access element 0 of the array:</p>&#13;
<pre>/* these two statements are identical: both put 8 in index 0 */<br/>&#13;
d_array[0] = 8; // put 8 in index 0 of the d_array<br/>&#13;
*d_array = 8;   // in the location pointed to by d_array store 8</pre>&#13;
<p class="indent">The “Arrays in C” section on <a href="ch02.xhtml#lev1_13">page 81</a> describes arrays in more detail, and the “Pointer Arithmetic” section on <a href="ch02.xhtml#lev2_39">page 224</a> discusses accessing array elements through pointer variables.</p>&#13;
<p class="indent">When a program is finished using a dynamically allocated array, it should call <code>free</code> to deallocate the heap space. As mentioned earlier, we recommend setting the pointer to <code>NULL</code> after freeing it:</p>&#13;
<pre>free(arr);<br/>&#13;
arr = NULL;<br/>&#13;
<br/>&#13;
free(c_arr);<br/>&#13;
c_arr = NULL;<br/>&#13;
<br/>&#13;
free(d_array);<br/>&#13;
d_array = NULL;</pre>&#13;
<div class="g-box">&#13;
<p class="box-title">HEAP MEMORY MANAGEMENT, MALLOC AND FREE</p>&#13;
<p class="noindentt">The C standard library implements <code>malloc</code> and <code>free</code>, which are the programming interface to its heap memory manager. When called, <code>malloc</code> needs to find a contiguous chunk of unallocated heap memory space that can satisfy the size of the request. The heap memory manager maintains a <em>free list</em> of unallocated <em>extents</em> of heap memory, where each extent specifies the start address and size of a contiguous unallocated chunk of heap space.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_80"/>Initially, all of heap memory is empty, meaning that the free list has a single extent consisting of the entire heap region. After a program has made some calls to <code>malloc</code> and <code>free</code>, heap memory can become <em>fragmented</em>, meaning that there are chunks of free heap space interspersed with chunks of allocated heap space. The heap memory manager typically keeps lists of different ranges of sizes of heap space to enable fast searching for a free extent of a particular size. In addition, it implements one or more policies for choosing among multiple free extents that could be used to satisfy a request.</p>&#13;
<p class="noindentt">The <code>free</code> function may seem odd in that it only expects to receive the address of the heap space to free without needing the size of the heap space to free at that address. That’s because <code>malloc</code> not only allocates the requested memory bytes, but it also allocates a few additional bytes right before the allocated chunk to store a header structure. The header stores metadata about the allocated chunk of heap space, such as the size. As a result, a call to <code>free</code> only needs to pass the address of heap memory to free. The implementation of <code>free</code> can get the size of the memory to free from the header information that is in memory right before the address passed to <code>free</code>.</p>&#13;
<p class="noindentt">For more information about heap memory management, see an OS textbook (for example, Chapter 17, “Free Space Management,” in <em>OS in Three Easy Pieces</em> covers these details).<sup><a href="ch02.xhtml#fn2_1" id="rfn2_1">1</a></sup></p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_21">2.4.4 Pointers to Heap Memory and Functions</h4>&#13;
<p class="noindent">When passing a dynamically allocated array to a function, the pointer variable argument’s <em>value</em> is passed to the function (i.e., the base address of the array in the heap is passed to the function). Thus, when passing either statically declared or dynamically allocated arrays to functions, the parameter gets exactly the same value—the base address of the array in memory. As a result, the same function can be used for statically and dynamically allocated arrays of the same type, and identical syntax can be used inside the function for accessing array elements. The parameter declarations <code>int *arr</code> and <code>int</code> <code>arr[]</code> are equivalent. However, by convention, the pointer syntax tends to be used for functions that may be called with dynamically allocated arrays:</p>&#13;
<pre>int main() {<br/>&#13;
    int *arr1;<br/>&#13;
<br/>&#13;
    arr1 = malloc(sizeof(int) * 10);<br/>&#13;
    if (arr1 == NULL) {<br/>&#13;
        printf("malloc error\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    /* pass the value of arr1 (base address of array in heap) */<br/>&#13;
    init_array(arr1, 10);<br/>&#13;
    ...<br/>&#13;
}<br/>&#13;
<span epub:type="pagebreak" id="page_81"/>void init_array(int *arr, int size) {<br/>&#13;
    int i;<br/>&#13;
    for (i = 0; i &lt; size; i++) {<br/>&#13;
        arr[i] = i;<br/>&#13;
    }<br/>&#13;
}</pre>&#13;
<p class="indent">At the point just before returning from the <code>init_array</code> function, the contents of memory will look like <a href="ch02.xhtml#ch2fig9">Figure 2-9</a>. Note that <code>main</code> only passes the base address of the array to <code>init_array</code>. The array’s large block of contiguous memory remains on the heap, but the function can access it by dereferencing the <code>arr</code> pointer parameter.</p>&#13;
<div class="imagec" id="ch2fig9"><img alt="image" src="../images/02fig09.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-9: The contents of memory prior to returning from <code>init_array</code>. Both <code>main</code>’s <code>arr1</code> and <code>init_array</code>’s <code>arr</code> variable point to the same block of heap memory.</em></p>&#13;
<h3 class="h3" id="lev1_13">2.5 Arrays in C</h3>&#13;
<p class="noindent">In “Introduction to Arrays” on <a href="ch01.xhtml#lev2_9">page 44</a>, we introduced statically declared one-dimensional C arrays and discussed the semantics of passing arrays to functions. In “Dynamic Memory Allocation” on <a href="ch02.xhtml#lev1_12">page 136</a>, we introduced dynamically allocated one-dimensional arrays and discussed the semantics of passing them to functions.</p>&#13;
<p class="indent">In this section, we take a more in-depth look at arrays in C. We describe both statically and dynamically allocated arrays in more detail and discuss two-dimensional arrays.</p>&#13;
<h4 class="h4" id="lev2_22">2.5.1 Single-Dimensional Arrays</h4>&#13;
<h5 class="h5" id="lev3_8">Statically Allocated</h5>&#13;
<p class="noindent">Before jumping into new content, we briefly summarize static arrays with an example. See “Introduction to Arrays” on <a href="ch01.xhtml#lev2_9">page 44</a> for more detail on statically declared one-dimensional arrays.</p>&#13;
<p class="indent">Statically declared arrays are allocated either on the stack (for local variables) or in the data region of memory (for global variables). A programmer <span epub:type="pagebreak" id="page_82"/>can declare an array variable by specifying its type (the type stored at each index) and its total capacity (number of elements).</p>&#13;
<p class="indent">When passing an array to a function, C copies the value of the base address to the parameter. That is, both the parameter and the argument refer to the same memory locations—the parameter pointer points to the argument’s array elements in memory. As a result, modifying the values stored in the array through an array parameter modifies the values stored in the argument array.</p>&#13;
<p class="indent">Here are some examples of static array declaration and use:</p>&#13;
<pre>// declare arrays specifying their type and total capacity<br/>&#13;
float averages[30];   // array of float, 30 elements<br/>&#13;
char  name[20];       // array of char, 20 elements<br/>&#13;
int i;<br/>&#13;
<br/>&#13;
// access array elements<br/>&#13;
for (i = 0; i &lt; 10; i++) {<br/>&#13;
    averages[i] = 0.0 + i;<br/>&#13;
    name[i] = 'a' + i;<br/>&#13;
}<br/>&#13;
name[10] = '\0';    // name is being used for storing a C-style string<br/>&#13;
<br/>&#13;
// prints: 3 d abcdefghij<br/>&#13;
printf("%g %c %s\n", averages[3], name[3], name);<br/>&#13;
<br/>&#13;
strcpy(name, "Hello");<br/>&#13;
printf("%s\n", name);  // prints: Hello</pre>&#13;
<h5 class="h5" id="lev3_9">Dynamically Allocated</h5>&#13;
<p class="noindent">In “Dynamic Memory Allocation” on <a href="ch02.xhtml#lev1_12">page 74</a>, we introduced dynamically allocated one-dimensional arrays, including their access syntax and the syntax and semantics of passing dynamically allocated arrays to functions. Here, we present a short recap of that information with an example.</p>&#13;
<p class="indent">Calling the <code>malloc</code> function dynamically allocates an array on the heap at runtime. The address of the allocated heap space can be assigned to a global or local pointer variable, which then points to the first element of the array. To dynamically allocate space, pass <code>malloc</code> the total number of bytes to allocate for the array (using the <code>sizeof</code> operator to get the size of a specific type). A single call to <code>malloc</code> allocates a contiguous chunk of heap space of the requested size. For example:</p>&#13;
<pre>// declare a pointer variable to point to allocated heap space<br/>&#13;
int    *p_array;<br/>&#13;
double *d_array;<br/>&#13;
<br/>&#13;
// call malloc to allocate the appropriate number of bytes for the array<br/>&#13;
<span epub:type="pagebreak" id="page_83"/>p_array = malloc(sizeof(int) * 50);      // allocate 50 ints<br/>&#13;
d_array = malloc(sizeof(double) * 100);  // allocate 100 doubles<br/>&#13;
<br/>&#13;
// always CHECK RETURN VALUE of functions and HANDLE ERROR return values<br/>&#13;
if ( (p_array == NULL) || (d_array == NULL) ) {<br/>&#13;
    printf("ERROR: malloc failed!\n");<br/>&#13;
    exit(1);<br/>&#13;
}<br/>&#13;
<br/>&#13;
// use [] notation to access array elements<br/>&#13;
for (i = 0; i &lt; 50; i++) {<br/>&#13;
    p_array[i] = 0;<br/>&#13;
    d_array[i] = 0.0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
// free heap space when done using it<br/>&#13;
free(p_array);<br/>&#13;
p_array = NULL;<br/>&#13;
<br/>&#13;
free(d_array);<br/>&#13;
d_array = NULL;</pre>&#13;
<h5 class="h5" id="lev3_10">Array Memory Layout</h5>&#13;
<p class="noindent">Whether an array is statically declared or dynamically allocated via a single call to <code>malloc</code>, array elements represent contiguous memory locations (addresses):</p>&#13;
<pre> array [0]:  base address<br/>&#13;
 array [1]:  next address<br/>&#13;
 array [2]:  next address<br/>&#13;
   ...            ...<br/>&#13;
 array [99]: last address</pre>&#13;
<p class="indent">The location of element <code>i</code> is at an offset <code>i</code> from the base address of the array. The exact address of the <code>i</code>th element depends on the number of bytes of the type stored in the array. For example, consider the following array declarations:</p>&#13;
<pre>int  iarray[6];  // an array of six ints, each of which is four bytes<br/>&#13;
char carray[4];  // an array of four chars, each of which is one byte</pre>&#13;
<p class="indent">The addresses of their individual array elements might look something like this:</p>&#13;
<pre> addr   element<br/>&#13;
 ----   -------<br/>&#13;
 1230:  iarray[0]<br/>&#13;
 1234:  iarray[1]<br/>&#13;
<span epub:type="pagebreak" id="page_84"/>&#13;
 1238:  iarray[2]<br/>&#13;
 1242:  iarray[3]<br/>&#13;
 1246:  iarray[4]<br/>&#13;
 1250:  iarray[5]<br/>&#13;
     ...<br/>&#13;
 1280:  carray[0]<br/>&#13;
 1281:  carray[1]<br/>&#13;
 1282:  carray[2]<br/>&#13;
 1283:  carray[3]</pre>&#13;
<p class="indent">In this example, <code>1230</code> is the base address of <code>iarray</code> and <code>1280</code> the base address of <code>carray</code>. Note that individual elements of each array are allocated to contiguous memory addresses: each element of <code>iarray</code> stores a four-byte <code>int</code> value, so its element addresses differ by four, and each element of <code>carray</code> stores a one-byte <code>char</code> value, so its addresses differ by one. There is no guarantee that the set of local variables are allocated to contiguous memory locations on the stack (hence, there could be a gap in the addresses between the end of <code>iarray</code> and the start of <code>carray</code>, as shown in this example).</p>&#13;
<h4 class="h4" id="lev2_23">2.5.2 Two-Dimensional Arrays</h4>&#13;
<p class="noindent">C supports multidimensional arrays, but we limit our discussion of multidimensional arrays to two-dimensional (2D) arrays, since 1D and 2D arrays are the most commonly used by C programmers.</p>&#13;
<h5 class="h5" id="lev3_11">Statically Allocated 2D Arrays</h5>&#13;
<p class="noindent">To statically declare a multidimensional array variable, specify the size of each dimension. For example:</p>&#13;
<pre>int   matrix[50][100];<br/>&#13;
short little[10][10];</pre>&#13;
<p class="noindent">Here, <code>matrix</code> is a 2D array of <code>int</code> values with 50 rows and 100 columns, and <code>little</code> is a 2D array of <code>short</code> values with 10 rows and 10 columns.</p>&#13;
<p class="indent">To access an individual element, indicate both the row and the column index:</p>&#13;
<pre>int   val;<br/>&#13;
short num;<br/>&#13;
<br/>&#13;
val = matrix[3][7];  // get int value in row 3, column 7 of matrix<br/>&#13;
num = little[8][4];  // get short value in row 8, column 4 of little</pre>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig10">Figure 2-10</a> illustrates the 2D array as a matrix of integer values, where a specific element in the 2D array is indexed by row and column index values.</p>&#13;
<span epub:type="pagebreak" id="page_85"/>&#13;
<div class="imagec" id="ch2fig10"><img alt="image" src="../images/02fig10.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-10: A two-dimensional array represented as a matrix. Accessing matrix[2][3] is like indexing into a grid at row 2 and column 3.</em></p>&#13;
<p class="indent">Programs often access the elements of a 2D array by iterating with nested loops. For example, the following nested loop initializes all elements in <code>matrix</code> to 0:</p>&#13;
<pre>int i, j;<br/>&#13;
<br/>&#13;
for (i = 0; i &lt; 50; i++) {  // for each row i<br/>&#13;
    for (j = 0; j &lt; 100; j++) { // iterate over each column element in row i<br/>&#13;
        matrix[i][j] = 0;<br/>&#13;
    }<br/>&#13;
}</pre>&#13;
<h5 class="h5" id="lev3_12">Two-Dimensional Array Parameters</h5>&#13;
<p class="noindent">The same rules for passing one-dimensional array arguments to functions apply to passing two-dimensional array arguments: the parameter gets the value of the base address of the 2D array (<code>&amp;arr[0][0]</code>). In other words, the parameter points to the argument’s array elements and therefore the function can change values stored in the passed array.</p>&#13;
<p class="indent">For multidimensional array parameters, you must indicate that the parameter is a multidimensional array, but you can leave the size of the first dimension unspecified (for good generic design). The sizes of other dimensions must be fully specified so that the compiler can generate the correct offsets into the array. Here’s a 2D example:</p>&#13;
<pre>// a C constant definition: COLS is defined to be the value 100<br/>&#13;
#define COLS  (100)<br/>&#13;
<br/>&#13;
/*<br/>&#13;
 * init_matrix: initializes the passed matrix elements to the<br/>&#13;
 *              product of their index values<br/>&#13;
<span epub:type="pagebreak" id="page_86"/>&#13;
 *   m: a 2D array (the column dimension must be 100)<br/>&#13;
 *   rows: the number of rows in the matrix<br/>&#13;
 *   return: does not return a value<br/>&#13;
 */<br/>&#13;
void init_matrix(int m[][COLS], int rows) {<br/>&#13;
    int i, j;<br/>&#13;
    for (i = 0; i &lt; rows; i++) {<br/>&#13;
        for (j = 0; j &lt; COLS; j++) {<br/>&#13;
            m[i][j] = i*j;<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int matrix[50][COLS];<br/>&#13;
    int bigger[90][COLS];<br/>&#13;
<br/>&#13;
    init_matrix(matrix, 50);<br/>&#13;
    init_matrix(bigger, 90);<br/>&#13;
    ...</pre>&#13;
<p class="indent">Both the <code>matrix</code> and the <code>bigger</code> arrays can be passed as arguments to the <code>init_matrix</code> function because they have the same column dimension as the parameter definition.</p>&#13;
<p class="note"><strong><span class="black">Note</span></strong></p>&#13;
<p class="note1">The column dimension must be specified in the parameter definition of a 2D array so that the compiler can calculate the offset from the base address of the 2D array to the start of a particular row of elements. The offset calculation follows from the layout of 2D arrays in memory.</p>&#13;
<h5 class="h5" id="lev3_13">Two-Dimensional Array Memory Layout</h5>&#13;
<p class="noindent">Statically allocated 2D arrays are arranged in memory in <em>row-major order</em>, meaning that all of row 0’s elements come first, followed by all of row 1’s elements, and so on. For example, given the following declaration of a 2D array of integers</p>&#13;
<pre>int arr[3][4];  // int array with 3 rows and 4 columns</pre>&#13;
<p class="noindent">its layout in memory might look like <a href="ch02.xhtml#ch2fig11">Figure 2-11</a>.</p>&#13;
<span epub:type="pagebreak" id="page_87"/>&#13;
<div class="imagec" id="ch2fig11"><img alt="image" src="../images/02fig11.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-11: The layout of a two-dimensional array in row-major order</em></p>&#13;
<p class="indent">Note that all array elements are allocated to contiguous memory addresses. That is, the base address of the 2D array is the memory address of the <code>[0][0]</code> element (<code>&amp;arr[0][0]</code>), and subsequent elements are stored contiguously in row-major order (e.g., the entirety of row 1 is followed immediately by the entirety of row 2, and so on).</p>&#13;
<h5 class="h5" id="lev3_14">Dynamically Allocated 2D Arrays</h5>&#13;
<p class="noindent">Dynamically allocated 2D arrays can be allocated in two ways. For an <em>N</em> × <em>M</em> 2D array, either:</p>&#13;
<div class="number">&#13;
<p class="number">1. Make a single call to <code>malloc</code>, allocating one large chunk of heap space to store all <em>N</em> × <em>M</em> array elements.</p>&#13;
<p class="number">2. Make multiple calls to <code>malloc</code>, allocating an array of arrays. First, allocate a 1D array of <em>N</em> pointers to the element type, with a 1D array of pointers for each row in the 2D array. Then, allocate <em>N</em> 1D arrays of size <em>M</em> to store the set of column values for each row in the 2D array. Assign the addresses of each of these <em>N</em> arrays to the elements of the first array of <em>N</em> pointers.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_88"/>&#13;
<p class="indent">The variable declarations, allocation code, and array element access syntax differ depending on which of these two methods a programmer chooses to use.</p>&#13;
<h5 class="h5" id="lev3_15">Method 1: Memory-Efficient Allocation</h5>&#13;
<p class="noindent">In this method, a single call to <code>malloc</code> allocates the total number of bytes needed to store the <em>N</em> × <em>M</em> array of values. This method has the benefit of being more memory efficient because the entire space for all <em>N</em> × <em>M</em> elements will be allocated at once, in contiguous memory locations.</p>&#13;
<p class="indent">The call to <code>malloc</code> returns the starting address of the allocated space (the base address of the array), which (like a 1D array) should be stored in a pointer variable. In fact, there is no semantic difference between allocating a 1D or 2D array using this method: the call to <code>malloc</code> returns the starting address of a contiguously allocated chunk of heap memory of the requested number of bytes. Because allocation of a 2D array using this method looks just like allocation for a 1D array, the programmer has to explicitly map 2D row and column indexing on top of this single chunk of heap memory space (the compiler has no implicit notion of rows or columns and thus cannot interpret double indexing syntax into this malloc’ed space).</p>&#13;
<p class="indent">Here’s an example C code snippet that dynamically allocates a 2D array using method 1:</p>&#13;
<pre>#define N 3<br/>&#13;
#define M 4<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int *two_d_array;    // the type is a pointer to an int (the element type)<br/>&#13;
<br/>&#13;
    // allocate in a single malloc of N x M int-sized elements:<br/>&#13;
    two_d_array = malloc(sizeof(int) * N * M);<br/>&#13;
<br/>&#13;
    if (two_d_array == NULL) {<br/>&#13;
        printf("ERROR: malloc failed!\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    ...</pre>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig12">Figure 2-12</a> shows an example of allocating a 2D array using this method and illustrates what memory might look like after the call to <code>malloc</code>.</p>&#13;
<span epub:type="pagebreak" id="page_89"/>&#13;
<div class="imagec" id="ch2fig12"><img alt="image" src="../images/02fig12.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-12: The results of allocating a 2D array with a single call to <code>malloc</code></em></p>&#13;
<p class="indent">Like 1D dynamically allocated arrays, the pointer variable for a 2D array is allocated on the stack. That pointer is then assigned the value returned by the call to <code>malloc</code>, which represents the base address of the contiguous chunk of <em>N</em> × <em>M</em> <code>int</code> storage locations in the heap memory.</p>&#13;
<p class="indent">Because this method uses a single chunk of malloc’ed space for the 2D array, the memory allocation is as efficient as possible (it only requires one call to <code>malloc</code> for the entire 2D array). It’s the more efficient way to access memory due to all elements being located close together in contiguous memory, with each access requiring only a single level of indirection from the pointer variable.</p>&#13;
<p class="indent">However, the C compiler does not know the difference between a 2D or 1D array allocation using this method. As a result, the double indexing syntax (<code>[i][j]</code>) of statically declared 2D arrays <em>cannot</em> be used when allocating a 2D array using this method. Instead, the programmer must explicitly compute the offset into the contiguous chunk of heap memory using a function of row and column index values (<code>[i*M + j]</code>, where <code>M</code> is the column dimension).</p>&#13;
<p class="indent">Here’s an example of how a programmer would structure code to initialize all the elements of a 2D array:</p>&#13;
<pre>// access using [] notation:<br/>&#13;
//   cannot use [i][j] syntax because the compiler has no idea where the<br/>&#13;
//   next row starts within this chunk of heap space, so the programmer<br/>&#13;
//   must explicitly add a function of row and column index values<br/>&#13;
//   (i*M+j) to map their 2D view of the space into the 1D chunk of memory<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_90"/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    for (j = 0; j &lt; M; j++) {<br/>&#13;
        two_d_array[i*M + j] = 0;<br/>&#13;
    }<br/>&#13;
}</pre>&#13;
<h5 class="h5" id="lev3_16">Method 1 (Single malloc) and Function Parameters</h5>&#13;
<p class="noindent">The base address of an array of <code>int</code> types allocated via a single <code>malloc</code> is a pointer to an <code>int</code>, so it can be passed to a function with an (<code>int *</code>) parameter. Additionally, the function must be passed row and column dimensions so that it can correctly compute offsets into the 2D array. For example:</p>&#13;
<pre>/*<br/>&#13;
 * initialize all elements in a 2D array to 0<br/>&#13;
 *  arr: the array<br/>&#13;
 *  rows: number of rows<br/>&#13;
 *  cols: number of columns<br/>&#13;
 */<br/>&#13;
void init2D(int *arr, int rows, int cols) {<br/>&#13;
    int i, j;<br/>&#13;
    for (i = 0; i &lt; rows; i++) {<br/>&#13;
        for (j = 0; j &lt; cols; j++) {<br/>&#13;
            arr[i*cols + j] = 0;<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int *array;<br/>&#13;
    array = malloc(sizeof(int) * N * M);<br/>&#13;
    if (array != NULL) {<br/>&#13;
        init2D(array, N, M);<br/>&#13;
    }<br/>&#13;
    ...</pre>&#13;
<h5 class="h5" id="lev3_17">Method 2: The Programmer-Friendly Way</h5>&#13;
<p class="noindent">The second method for dynamically allocating a 2D array stores the array as an array of <em>N</em> 1D arrays (one 1D array per row). It requires <em>N</em> + 1 calls to <code>malloc</code>: one <code>malloc</code> for the array of row arrays, and one <code>malloc</code> for each of the <em>N</em> row’s column arrays. As a result, the element locations <em>within a row</em> are contiguous, but elements are not contiguous across rows of the 2D array. Allocation and element access are not as efficient as in method 1, and the type definitions for variables can be a bit more confusing. However, using this method, a programmer can use double indexing syntax to access individual elements of the 2D array (the first index is an index into the array of rows, <span epub:type="pagebreak" id="page_91"/>the second index is an index into the array of column elements within that row).</p>&#13;
<p class="indent">Here is an example of allocating a 2D array using method 2 (with the error detection and handling code removed for readability):</p>&#13;
<pre>// the 2D array variable is declared to be `int **` (a pointer to an int *)<br/>&#13;
// a dynamically allocated array of dynamically allocated int arrays<br/>&#13;
// (a pointer to pointers to ints)<br/>&#13;
int **two_d_array;<br/>&#13;
int i;<br/>&#13;
<br/>&#13;
// allocate an array of N pointers to ints<br/>&#13;
// malloc returns the address of this array (a pointer to (int *)'s)<br/>&#13;
two_d_array = malloc(sizeof(int *) * N);<br/>&#13;
<br/>&#13;
// for each row, malloc space for its column elements and add it to<br/>&#13;
// the array of arrays<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
// malloc space for row i's M column elements<br/>&#13;
    two_d_array[i] = malloc(sizeof(int) * M);<br/>&#13;
}</pre>&#13;
<p class="indent">In this example, note the types of the variables and the sizes passed to the calls to <code>malloc</code>. To refer to the dynamically allocated 2D array, the programmer declares a variable (<code>two_d_array</code>) of type <code>int **</code> that will store the address of a dynamically allocated array of <code>int *</code> element values. Each element in <code>two_d_array</code> stores the address of a dynamically allocated array of <code>int</code> values (the type of <code>two_d_array[i]</code> is <code>int *</code>).</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig13">Figure 2-13</a> shows what memory might look like after the preceding example’s <em>N</em> + 1 calls to <code>malloc</code>.</p>&#13;
<div class="imagec" id="ch2fig13"><img alt="image" src="../images/02fig13.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-13: The arrangement of memory after allocating a 2D array with N + 1 <code>malloc</code> calls</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_92"/>Note that when using this method, only the elements allocated as part of a single call to <code>malloc</code> are contiguous in memory. That is, elements within each row are contiguous, but elements from different rows (even neighboring rows) are not.</p>&#13;
<p class="indent">Once allocated, individual elements of the 2D array can be accessed using double-indexing notation. The first index specifies an element in the outer array of <code>int *</code> pointers (which row), and the second index specifies an element in the inner <code>int</code> array (which column within the row).</p>&#13;
<pre>int i, j;<br/>&#13;
<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    for (j = 0; j &lt; M; j++) {<br/>&#13;
        two_d_array[i][j] = 0;<br/>&#13;
    }<br/>&#13;
}</pre>&#13;
<p class="indent">To understand how double indexing is evaluated, consider the type and value of the following parts of the expression:</p>&#13;
<pre>       two_d_array: an array of int pointers, it stores the base address of an<br/>&#13;
                 array of (int *) values. Its type is int** (a pointer to <br/>&#13;
                 int *).<br/>&#13;
<br/>&#13;
    two_d_array[i]: the ith index into the array of arrays, it stores an <br/>&#13;
                 (int *) value that represents the base address of an array of <br/>&#13;
                 (int) values.  Its type is int*.<br/>&#13;
<br/>&#13;
 two_d_array[i][j]: the jth element pointed to by the ith element of the array<br/>&#13;
                of arrays, it stores an int value (the value in row i, column <br/>&#13;
                j of the 2D array).  Its type is int.</pre>&#13;
<h5 class="h5" id="lev3_18">Method 2 (An Array of Arrays) and Function Parameters</h5>&#13;
<p class="noindent">The array argument’s type is <code>int **</code> (a pointer to a pointer to an <code>int</code>), and the function parameter matches its argument’s type. Additionally, row and column sizes should be passed to the function. Because this is a different type from method 1, both array types cannot use a common function (they are not the same C type).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_93"/>Here’s an example function that takes a method 2 (array of arrays) 2D array as a parameter:</p>&#13;
<pre>/*<br/>&#13;
 * initialize a 2D array<br/>&#13;
 * arr: the array<br/>&#13;
 * rows: number of rows<br/>&#13;
 * cols: number of columns<br/>&#13;
 */<br/>&#13;
void init2D_Method2(int **arr, int rows, int cols) {<br/>&#13;
    int i,j;<br/>&#13;
<br/>&#13;
    for (i = 0; i &lt; rows; i++) {<br/>&#13;
        for (j = 0; j &lt; cols; j++) {<br/>&#13;
            arr[i][j] = 0;<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
}<br/>&#13;
<br/>&#13;
/*<br/>&#13;
 * main: example of calling init2D_Method2<br/>&#13;
 */<br/>&#13;
int main() {<br/>&#13;
    int **two_d_array;<br/>&#13;
<br/>&#13;
    // some code to allocate the row array and multiple col arrays<br/>&#13;
    // ...<br/>&#13;
<br/>&#13;
    init2D_Method2(two_d_array, N, M);<br/>&#13;
    ...</pre>&#13;
<p class="indent">Here, the function implementation can use double-indexing syntax. Unlike statically declared 2D arrays, both the row and column dimensions need to be passed as parameters: the <code>rows</code> parameter specifies the bounds on the outermost array (the array of row arrays), and the <code>cols</code> parameter specifies the bounds on the inner arrays (the array column values for each row).</p>&#13;
<h3 class="h3" id="lev1_14">2.6 Strings and the String Library</h3>&#13;
<p class="noindent">In the previous chapter, we introduced “Arrays and Strings” (<a href="ch01.xhtml#lev1_5">page 44</a>). In this chapter, we discuss dynamically allocated C strings and their use with the C string library. We first give a brief overview of statically declared strings.</p>&#13;
<h4 class="h4" id="lev2_24"><span epub:type="pagebreak" id="page_94"/>2.6.1 C’s Support for Statically Allocated Strings (Arrays of char)</h4>&#13;
<p class="noindent">C does not support a separate string type, but a string can be implemented in C programs using an array of <code>char</code> values that is terminated by a special null character value <code>’\0’</code>. The terminating null character identifies the end of the sequence of character values that make up a string. Not every character array is a C string, but every C string is an array of <code>char</code> values.</p>&#13;
<p class="indent">Because strings frequently appear in programs, C provides libraries with functions for manipulating strings. Programs that use the C string library need to include <code>string.h</code>. Most string library functions require the programmer to allocate space for the array of characters that the functions manipulate. When printing out the value of a string, use the <code>%s</code> placeholder.</p>&#13;
<p class="indent">Here’s an example program that uses strings and some string library functions:</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;string.h&gt;   // include the C string library<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    char str1[10];<br/>&#13;
    char str2[10];<br/>&#13;
<br/>&#13;
    str1[0] = 'h';<br/>&#13;
    str1[1] = 'i';<br/>&#13;
    str1[2] = '\0';   // explicitly add null terminating character to end<br/>&#13;
<br/>&#13;
    // strcpy copies the bytes from the source parameter (str1) to the<br/>&#13;
    // destination parameter (str2) and null terminates the copy.<br/>&#13;
    strcpy(str2, str1);<br/>&#13;
    str2[1] = 'o';<br/>&#13;
    printf("%s %s\n", str1, str2);  // prints: hi ho<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<h4 class="h4" id="lev2_25">2.6.2 Dynamically Allocating Strings</h4>&#13;
<p class="noindent">Arrays of characters can be dynamically allocated (as discussed in “C’s Pointer Variables” on <a href="ch02.xhtml#lev1_10">page 66</a> and “Arrays in C” on <a href="ch02.xhtml#lev1_13">page 81</a>). When dynamically allocating space to store a string, it’s important to remember to allocate space in the array for the terminating <code>'\0'</code> character at the end of the string.</p>&#13;
<p class="indent">The following example program demonstrates static and dynamically allocated strings (note the value passed to <code>malloc</code>):</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include &lt;string.h&gt;<br/><span epub:type="pagebreak" id="page_95"/>&#13;
int main() {<br/>&#13;
    int size;<br/>&#13;
    char str[64];         // statically allocated<br/>&#13;
    char *new_str = NULL; // for dynamically allocated<br/>&#13;
<br/>&#13;
    strcpy(str, "Hello");<br/>&#13;
    size = strlen(str);   // returns 5<br/>&#13;
<br/>&#13;
    new_str = malloc(sizeof(char) * (size+1)); // need space for '\0'<br/>&#13;
    if(new_str == NULL) {<br/>&#13;
        printf("Error: malloc failed!  exiting.\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
    strcpy(new_str, str);<br/>&#13;
    printf("%s %s\n", str, new_str);    // prints "Hello Hello"<br/>&#13;
<br/>&#13;
    strcat(str, " There");  // concatenate " There" to the end of str<br/>&#13;
    printf("%s\n", str);    // prints "Hello There"<br/>&#13;
<br/>&#13;
    free(new_str);  // free malloc'ed space when done<br/>&#13;
    new_str = NULL;<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="note"><strong><span class="black">Warning</span> C STRING FUNCTIONS AND DESTINATION MEMORY</strong></p>&#13;
<p class="note-w">Many C string functions (notably <code>strcpy</code> and <code>strcat</code>) store their results by following a <em>destination</em> string pointer (<code>char *</code>) parameter and writing to the location it points to. Such functions assume that the destination contains enough memory to store the result. Thus, as a programmer, you must ensure that sufficient memory is available at the destination prior to calling these functions.</p>&#13;
<p class="note-w">Failure to allocate enough memory will yield undefined results that range from program crashes to major security vulnerabilities (see “Real World: Buffer Overflow” on <a href="ch07.xhtml#lev1_60">page 362</a>). For example, the following calls to <code>strcpy</code> and <code>strcat</code> demonstrate mistakes that novice C programmers often make:</p>&#13;
<p class="programs-l">// Attempt to write a 12-byte string into a 5-character array.<br/>&#13;
char mystr[5];<br/>&#13;
strcpy(mystr, "hello world");<br/>&#13;
<br/>&#13;
// Attempt to write to a string with a NULL destination.<br/>&#13;
char *mystr = NULL;<br/>&#13;
strcpy(mystr, "try again");<br/>&#13;
<br/>&#13;
<br/>&#13;
// Attempt to modify a read-only string literal.<br/>&#13;
char *mystr = "string literal value";<br/>&#13;
strcat(mystr, "string literals aren't writable");</p>&#13;
<h4 class="h4" id="lev2_26"><span epub:type="pagebreak" id="page_96"/>2.6.3 Libraries for Manipulating C Strings and Characters</h4>&#13;
<p class="noindent">C provides several libraries with functions for manipulating strings and characters. The string library (<code>string.h</code>) is particularly useful when writing programs that use C strings. The <code>stdlib.h</code> and <code>stdio.h</code> libraries also contain functions for string manipulation, and the <code>ctype.h</code> library contains functions for manipulating individual character values.</p>&#13;
<p class="indent">When using C string library functions, it’s important to remember that most do not allocate space for the strings they manipulate, nor do they check that you pass in valid strings; your program must allocate space for the strings that the C string library will use. Furthermore, if the library function modifies the passed string, then the caller needs to ensure that the string is correctly formatted (i.e., that it has a terminating <code>’\0’</code> character at the end). Calling string library functions with bad array argument values will often cause a program to crash. The documentation (e.g., manual pages) for different library functions specifies whether the library function allocates space or if the caller is responsible for passing in allocated space to the library function.</p>&#13;
<p class="note"><strong><span class="black">Note</span> CHAR[] AND CHAR * PARAMETERS AND CHAR * RETURN TYPE</strong></p>&#13;
<p class="note1">Both statically declared and dynamically allocated arrays of characters can be passed to a <code>char *</code> parameter because the name of either type of variable evaluates to the base address of the array in memory. Declaring the parameter as type <code>char []</code> will also work for both statically and dynamically allocated argument values, but <code>char *</code> is more commonly used for specifying the type of string (array of <code>char</code>) parameters.</p>&#13;
<p class="note1">If a function returns a string (its return type is a <code>char *</code>), its return value can only be assigned to a variable whose type is also <code>char *</code>; it cannot be assigned to a statically allocated array variable. This restriction exists because the name of a statically declared array variable is not a valid <em>lvalue</em> (its base address in memory cannot be changed; see “Accessing Field Values” on <a href="ch01.xhtml#lev2_15">page 57</a>), so it cannot be assigned a <code>char *</code> return value.</p>&#13;
<h5 class="h5" id="lev3_19">strlen, strcpy, strncpy</h5>&#13;
<p class="noindent">The string library provides functions for copying strings and finding the length of a string:</p>&#13;
<pre>// returns the number of characters in the string <br/>&#13;
// (not including the null character)<br/>&#13;
int strlen(char *s);<br/>&#13;
<br/>&#13;
// copies string src to string dst up until the first '\0' character in src<br/>&#13;
// (the caller needs to make sure src is initialized correctly and<br/>&#13;
// dst has enough space to store a copy of the src string)<br/>&#13;
// returns the address of the dst string<br/>&#13;
char *strcpy(char *dst, char *src);<br/>&#13;
<span epub:type="pagebreak" id="page_97"/>// like strcpy but copies up to the first '\0' or size characters<br/>&#13;
// (this provides some safety to not copy beyond the bounds of the dst<br/>&#13;
// array if the src string is not well formed or is longer than the<br/>&#13;
// space available in the dst array); size_t is an unsigned integer type<br/>&#13;
char *strncpy(char *dst, char *src, size_t size);</pre>&#13;
<p class="indent">The <code>strcpy</code> function is unsafe to use in situations when the source string might be longer than the total capacity of the destination string. In this case, one should use <code>strncpy</code>. The size parameter stops <code>strncpy</code> from copying more than <code>size</code> characters from the <code>src</code> string into the <code>dst</code> string. When the length of the <code>src</code> string is greater than or equal to <code>size</code>, <code>strncpy</code> copies the first <code>size</code> characters from <code>src</code> to <code>dst</code> and does not add a null character to the end of the <code>dst</code>. As a result, the programmer should explicitly add a null character to the end of <code>dst</code> after calling <code>strncpy</code>.</p>&#13;
<p class="indent">Here are some example uses of these functions in a program:</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include &lt;string.h&gt;   // include the string library<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    // variable declarations that will be used in examples<br/>&#13;
    int len, i, ret;<br/>&#13;
    char str[32];<br/>&#13;
    char *d_str, *ptr;<br/>&#13;
<br/>&#13;
    strcpy(str, "Hello There");<br/>&#13;
    len = strlen(str);  // len is 11<br/>&#13;
<br/>&#13;
    d_str = malloc(sizeof(char) * (len+1));<br/>&#13;
    if (d_str == NULL) {<br/>&#13;
        printf("Error: malloc failed\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    strncpy(d_str, str, 5);<br/>&#13;
    d_str[5] = '\0';   // explicitly add null terminating character to end<br/>&#13;
    <br/>&#13;
    printf("%d:%s\n", strlen(str), str);      // prints 11:Hello There<br/>&#13;
    printf("%d:%s\n", strlen(d_str), d_str);  // prints 5:Hello<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<h5 class="h5" id="lev3_20">strcmp, strncmp</h5>&#13;
<p class="noindent">The string library also provides a function to compare two strings. Comparing string variables using the <code>==</code> operator <em>does not</em> compare the characters in <span epub:type="pagebreak" id="page_98"/>the strings—it compares only the base addresses of the two strings. For example, the expression</p>&#13;
<pre>if (d_str == str) { ...</pre>&#13;
<p class="noindent">compares the base address of the <code>char</code> array in the heap pointed to by <code>d_str</code> to the base address of the <code>str char</code> array allocated on the stack.</p>&#13;
<p class="indent">To compare the values of the strings, a programmer needs to either write code by hand to compare corresponding element values, or use the <code>strcmp</code> or <code>strncmp</code> functions from the string library:</p>&#13;
<pre>int strcmp(char *s1, char *s2);<br/>&#13;
// returns 0 if s1 and s2 are the same strings<br/>&#13;
// a value &lt; 0 if s1 is less than s2<br/>&#13;
// a value &gt; 0 if s1 is greater than s2<br/>&#13;
<br/>&#13;
int strncmp(char *s1, char *s2, size_t n);<br/>&#13;
// compare s1 and s2 up to at most n characters</pre>&#13;
<p class="indent">The <code>strcmp</code> function compares strings character by character based on their <em>ASCII representation</em> (see “Notes” on <a href="ch01.xhtml#lev1_8">page 189</a>). In other words, it compares the <code>char</code> values in corresponding positions of the two parameter arrays to produce the result of the string comparison, which occasionally yields unintuitive results. For example, the ASCII encoding for the <code>char</code> value <code>’a’</code> is <em>larger</em> than the encoding for the <code>char</code> value <code>’Z’</code>. Thus, <code>strcmp("aaa", "Zoo")</code> returns a positive value indicating that <code>"aaa"</code> is greater than <code>"Zoo"</code>, and a call to <code>strcmp("aaa", "zoo")</code> returns a negative value indicating that <code>"aaa"</code> is less than <code>"zoo"</code>.</p>&#13;
<p class="indent">Here are some string comparison examples:</p>&#13;
<pre>strcpy(str, "alligator");<br/>&#13;
strcpy(d_str, "Zebra");<br/>&#13;
<br/>&#13;
ret =  strcmp(str,d_str);<br/>&#13;
if (ret == 0) {<br/>&#13;
    printf("%s is equal to %s\n", str, d_str);<br/>&#13;
} else if (ret &lt; 0) {<br/>&#13;
    printf("%s is less than %s\n", str, d_str);<br/>&#13;
} else {<br/>&#13;
    printf("%s is greater than %s\n", str, d_str);  // true for these strings<br/>&#13;
}<br/>&#13;
<br/>&#13;
ret = strncmp(str, "all", 3);  // returns 0: they are equal up to first 3 chars</pre>&#13;
<h5 class="h5" id="lev3_21">strcat, strstr, strchr</h5>&#13;
<p class="noindent">String library functions can concatenate strings (note that it’s up to the caller to ensure that the destination string has enough space to store the result):</p>&#13;
<span epub:type="pagebreak" id="page_99"/>&#13;
<pre>// append chars from src to end of dst<br/>&#13;
// returns ptr to dst and adds '\0' to end<br/>&#13;
char *strcat(char *dst, char *src)<br/>&#13;
<br/>&#13;
// append the first chars from src to end of dst, up to a maximum of size<br/>&#13;
// returns ptr to dst and adds '\0' to end<br/>&#13;
char *strncat(char *dst, char *src, size_t size);</pre>&#13;
<p class="indent">It also provides functions for finding substrings or character values in strings:</p>&#13;
<pre>// locate a substring inside a string<br/>&#13;
// (const means that the function doesn't modify string)<br/>&#13;
// returns a pointer to the beginning of substr in string<br/>&#13;
// returns NULL if substr not in string<br/>&#13;
char *strstr(const char *string, char *substr);<br/>&#13;
<br/>&#13;
// locate a character (c) in the passed string (s)<br/>&#13;
// (const means that the function doesn't modify s)<br/>&#13;
// returns a pointer to the first occurrence of the char c in string<br/>&#13;
// or NULL if c is not in the string<br/>&#13;
char *strchr(const char *s, int c);</pre>&#13;
<p class="indent">Here are some examples using these functions (we omit some error handling for the sake of readability):</p>&#13;
<pre>char str[32];<br/>&#13;
char *ptr;<br/>&#13;
<br/>&#13;
strcpy(str, "Zebra fish");<br/>&#13;
strcat(str, " stripes");  // str gets "Zebra fish stripes"<br/>&#13;
printf("%s\n", str);     // prints: Zebra fish stripes<br/>&#13;
<br/>&#13;
strncat(str, " are black.", 8);<br/>&#13;
printf("%s\n", str);     // prints: Zebra fish stripes are bla  (spaces count)<br/>&#13;
<br/>&#13;
ptr = strstr(str, "trip");<br/>&#13;
if (ptr != NULL) {<br/>&#13;
    printf("%s\n", ptr);   // prints: tripes are bla<br/>&#13;
}<br/>&#13;
<br/>&#13;
ptr = strchr(str, 'e');<br/>&#13;
if (ptr != NULL) {<br/>&#13;
    printf("%s\n", ptr);   // prints: ebra fish stripes are bla<br/>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>Calls to <code>strchr</code> and <code>strstr</code> return the address of the first element in the parameter array with a matching character value or a matching substring value, respectively. This element address is the start of an array of <code>char</code> values terminated by a <code>’\0’</code> character. In other words, <code>ptr</code> points to the beginning of a substring inside another string. When printing the value of <code>ptr</code> as a string with <code>printf</code>, the character values starting at the index pointed to by <code>ptr</code> are printed, yielding the results listed in the preceding example.</p>&#13;
<h5 class="h5" id="lev3_22">strtok, strtok_r</h5>&#13;
<p class="noindent">The string library also provides functions that divide a string into tokens. A <em>token</em> refers to a subsequence of characters in a string separated by any number of delimiter characters of the programmer’s choosing.</p>&#13;
<pre>char *strtok(char *str, const char *delim);<br/>&#13;
<br/>&#13;
// a reentrant version of strtok (reentrant is defined in later chapters):<br/>&#13;
char *strtok_r(char *str, const char *delim, char **saveptr);</pre>&#13;
<p class="indent">The <code>strtok</code> (or <code>strtok_r</code>) functions find individual tokens within a larger string. For example, setting <code>strtok</code>’s delimiters to the set of whitespace characters yields words in a string that originally contains an English sentence. That is, each word in the sentence is a token in the string.</p>&#13;
<p class="indent">Following is an example program that uses <code>strtok</code> to find individual words as the tokens in an input string.<sup><a href="ch02.xhtml#fn2_2" id="rfn2_2">2</a></sup></p>&#13;
<pre>/*<br/>&#13;
 * Extract whitespace-delimited tokens from a line of input<br/>&#13;
 * and print them one per line.<br/>&#13;
 *<br/>&#13;
 * to compile:<br/>&#13;
 *   gcc -g -Wall strtokexample.c<br/>&#13;
 *<br/>&#13;
 * example run:<br/>&#13;
 *   Enter a line of text:        aaaaa             bbbbbbbbb          cccccc<br/>&#13;
 *<br/>&#13;
 *   The input line is:<br/>&#13;
 *         aaaaa             bbbbbbbbb          cccccc<br/>&#13;
 *   Next token is aaaaa<br/>&#13;
 *   Next token is bbbbbbbbb<br/>&#13;
 *   Next token is cccccc<br/>&#13;
 */<br/>&#13;
<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;string.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
     /* whitespace stores the delim string passed to strtok.  The delim<br/>&#13;
<span epub:type="pagebreak" id="page_101"/>&#13;
      * string  is initialized to the set of characters that delimit tokens<br/>&#13;
      * We initialize the delim string to the following set of chars:<br/>&#13;
      *   ' ': space  '\t': tab  '\f': form feed  '\r': carriage return<br/>&#13;
      *   '\v': vertical tab  '\n': new line<br/>&#13;
      * (run "man ascii" to list all ASCII characters)<br/>&#13;
      *<br/>&#13;
      * This line shows one way to statically initialize a string variable<br/>&#13;
      * (using this method the string contents are constant, meaning that they<br/>&#13;
      *  cannot be modified, which is fine for the way we are using the<br/>&#13;
      *  whitespace string in this program).<br/>&#13;
      */<br/>&#13;
    char *whitespace = " \t\f\r\v\n";  /* Note the space char at beginning */<br/>&#13;
<br/>&#13;
    char *token;  /* The next token in the line. */<br/>&#13;
    char *line;   /* The line of text read in that we will tokenize. */<br/>&#13;
<br/>&#13;
    /* Allocate some space for the user's string on the heap. */<br/>&#13;
    line = malloc(200 * sizeof(char));<br/>&#13;
    if (line == NULL) {<br/>&#13;
        printf("Error: malloc failed\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    /* Read in a line entered by the user from "standard in". */<br/>&#13;
    printf("Enter a line of text:\n");<br/>&#13;
    line = fgets(line, 200 * sizeof(char), stdin);<br/>&#13;
    if (line == NULL) {<br/>&#13;
        printf("Error: reading input failed, exiting...\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
    printf("The input line is:\n%s\n", line);<br/>&#13;
<br/>&#13;
    /* Divide the string into tokens. */<br/>&#13;
    token = strtok(line, whitespace);       /* get the first token */<br/>&#13;
    while (token != NULL) {<br/>&#13;
        printf("Next token is %s\n", token);<br/>&#13;
        token = strtok(NULL, whitespace);     /* get the next token */<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    free(line);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<h5 class="h5" id="lev3_23"><span epub:type="pagebreak" id="page_102"/>sprintf</h5>&#13;
<p class="noindent">The C <code>stdio</code> library also provides functions that manipulate C strings. Perhaps the most useful is the <code>sprintf</code> function, which “prints” into a string rather than printing output to a terminal:</p>&#13;
<pre>// like printf(), the format string allows for placeholders like %d, %f, etc.<br/>&#13;
// pass parameters after the format string to fill them in<br/>&#13;
int sprintf(char *s, const char *format, ...);</pre>&#13;
<p class="indent"><code>sprintf</code> initializes the contents of a string from values of various types. Its parameter <code>format</code> resembles those of <code>printf</code> and <code>scanf</code>. Here are some examples:</p>&#13;
<pre>char str[64];<br/>&#13;
float ave = 76.8;<br/>&#13;
int num = 2;<br/>&#13;
<br/>&#13;
// initialize str to format string, filling in each placeholder with<br/>&#13;
// a char representation of its arguments' values<br/>&#13;
sprintf(str, "%s is %d years old and in grade %d", "Henry", 12, 7);<br/>&#13;
printf("%s\n", str);  // prints: Henry is 12 years old and in grade 7<br/>&#13;
<br/>&#13;
sprintf(str, "The average grade on exam %d is %g", num, ave);<br/>&#13;
printf("%s\n", str);  // prints: The average grade on exam 2 is 76.8</pre>&#13;
<h5 class="h5" id="lev3_24">Functions for Individual Character Values</h5>&#13;
<p class="noindent">The standard C library (<code>stdlib.h</code>) contains a set of functions for manipulating and testing individual <code>char</code> values, including:</p>&#13;
<pre>#include &lt;stdlib.h&gt;   // include stdlib and ctype to use these<br/>&#13;
#include &lt;ctype.h&gt;<br/>&#13;
<br/>&#13;
int islower(ch);<br/>&#13;
int isupper(ch);       // these functions return a non-zero value if the<br/>&#13;
int isalpha(ch);       // test is TRUE, otherwise they return 0 (FALSE)<br/>&#13;
int isdigit(ch);<br/>&#13;
int isalnum(ch);<br/>&#13;
int ispunct(ch);<br/>&#13;
int isspace(ch);<br/>&#13;
char tolower(ch);     // returns ASCII value of lower-case of argument<br/>&#13;
char toupper(ch);</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>Here are some examples of their use:</p>&#13;
<pre>char str[64];<br/>&#13;
int len, i;<br/>&#13;
<br/>&#13;
strcpy(str, "I see 20 ZEBRAS, GOATS, and COWS");<br/>&#13;
<br/>&#13;
if ( islower(str[2]) ){<br/>&#13;
    printf("%c is lower case\n", str[2]);   // prints: s is lower case<br/>&#13;
}<br/>&#13;
<br/>&#13;
len = strlen(str);<br/>&#13;
for (i = 0; i &lt; len; i++) {<br/>&#13;
    if ( isupper(str[i]) ) {<br/>&#13;
        str[i] = tolower(str[i]);<br/>&#13;
    } else if( isdigit(str[i]) ) {<br/>&#13;
        str[i] = 'X';<br/>&#13;
    }<br/>&#13;
}<br/>&#13;
printf("%s\n", str);  // prints: i see XX zebras, goats, and cows</pre>&#13;
<h5 class="h5" id="lev3_25">Functions to Convert Strings to Other Types</h5>&#13;
<p class="noindent"><code>stdlib.h</code> also contains functions to convert between strings and other C types. For example:</p>&#13;
<pre>#include &lt;stdlib.h&gt;<br/>&#13;
<br/>&#13;
int atoi(const char *nptr);     // convert a string to an integer<br/>&#13;
double atof(const char *nptr);  // convert a string to a float</pre>&#13;
<p class="indent">Here’s an example:</p>&#13;
<pre>printf("%d %g\n", atoi("1234"), atof("4.56"));</pre>&#13;
<p class="indent">For more information about these and other C library functions (including what they do, their parameter format, what they return, and which headers need to be included to use them), see their <em>man pages</em>.<sup><a href="ch02.xhtml#fn2_3" id="rfn2_3">3</a></sup> For example, to view the <code>strcpy</code> man page, run:</p>&#13;
<pre>$ <span class="codestrong1">man strcpy</span></pre>&#13;
<h3 class="h3" id="lev1_15">2.7 C Structs</h3>&#13;
<p class="noindent">In the previous chapter, we introduced C structures in “Structs” on <a href="ch01.xhtml#lev1_6">page 52</a>. In this chapter, we dive deeper into C structs, examine statically and dynamically allocated structs, and combine structs and pointers to create more complex data types and data structures.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_104"/>We begin with a quick overview of statically declared structs. See the previous chapter for more details.</p>&#13;
<h4 class="h4" id="lev2_27">2.7.1 Review of the C struct Type</h4>&#13;
<p class="noindent">A <code>struct</code> type represents a heterogeneous collection of data; it’s a mechanism for treating a set of different types as a single, coherent unit.</p>&#13;
<p class="indent">There are three steps to defining and using <code>struct</code> types in C programs:</p>&#13;
<div class="number">&#13;
<p class="number">1. Define a <code>struct</code> type that defines the field values and their types.</p>&#13;
<p class="number">2. Declare variables of the <code>struct</code> type.</p>&#13;
<p class="number">3. Use <em>dot notation</em> to access individual field values in the variable.</p>&#13;
</div>&#13;
<p class="indent">In C, structs are lvalues (they can appear on the left-hand side of an assignment statement; see “Accessing Field Values” on <a href="ch01.xhtml#lev2_15">page 57</a>). The value of a <code>struct</code> variable is the contents of its memory (all of the bytes making up its field values). When calling functions with <code>struct</code> parameters, the value of the <code>struct</code> argument (a copy of all of the bytes of all of its fields) gets copied to the <code>struct</code> function parameter.</p>&#13;
<p class="indent">When programming with structs, and in particular when combining structs and arrays, it’s critical to carefully consider the type of every expression. Each field in a <code>struct</code> represents a specific type, and the syntax for accessing field values and the semantics of passing individual field values to functions follow those of their specific type.</p>&#13;
<p class="indent">The following full example program demonstrates defining a <code>struct</code> type, declaring variables of that type, accessing field values, and passing structs and individual field values to functions (we omit some error handling and comments for readability):</p>&#13;
<p class="margnote">struct_review.c</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;string.h&gt;<br/>&#13;
<br/>&#13;
/* define a new struct type (outside function bodies) */<br/>&#13;
struct studentT {<br/>&#13;
    char  name[64];<br/>&#13;
    int   age;<br/>&#13;
    float gpa;<br/>&#13;
    int   grad_yr;<br/>&#13;
};<br/>&#13;
<br/>&#13;
/* function prototypes */<br/>&#13;
int checkID(struct studentT s1, int min_age);<br/>&#13;
void changeName(char *old, char *new);<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int can_vote;<br/>&#13;
    // declare variables of struct type:<br/>&#13;
    struct studentT student1, student2;<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_105"/>&#13;
    // access field values using .<br/>&#13;
    strcpy(student1.name, "Ruth");<br/>&#13;
    student1.age = 17;<br/>&#13;
    student1.gpa = 3.5;<br/>&#13;
    student1.grad_yr = 2021;<br/>&#13;
<br/>&#13;
    // structs are lvalues<br/>&#13;
    student2 = student1;<br/>&#13;
    strcpy(student2.name, "Frances");<br/>&#13;
    student2.age = student1.age + 4;<br/>&#13;
<br/>&#13;
    // passing a struct<br/>&#13;
    can_vote = checkID(student1, 18);<br/>&#13;
    printf("%s %d\n", student1.name, can_vote);<br/>&#13;
<br/>&#13;
    can_vote = checkID(student2, 18);<br/>&#13;
    printf("%s %d\n", student2.name, can_vote);<br/>&#13;
<br/>&#13;
    // passing a struct field value<br/>&#13;
    changeName(student2.name, "Kwame");<br/>&#13;
    printf("student 2's name is now %s\n", student2.name);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int checkID(struct studentT s, int min_age) {<br/>&#13;
    int ret = 1;<br/>&#13;
<br/>&#13;
    if (s.age &lt; min_age) {<br/>&#13;
        ret = 0;<br/>&#13;
        // changes age field IN PARAMETER COPY ONLY<br/>&#13;
        s.age = min_age + 1;<br/>&#13;
    }<br/>&#13;
    return ret;<br/>&#13;
}<br/>&#13;
<br/>&#13;
void changeName(char *old, char *new) {<br/>&#13;
    if ((old == NULL) || (new == NULL)) {<br/>&#13;
        return;<br/>&#13;
    }<br/>&#13;
    strcpy(old,new);<br/>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_106"/>When run, the program produces:</p>&#13;
<pre>Ruth 0<br/>&#13;
Frances 1<br/>&#13;
student 2's name is now Kwame</pre>&#13;
<p class="indent">When working with structs, it’s particularly important to think about the types of the <code>struct</code> and its fields. For example, when passing a <code>struct</code> to a function, the parameter gets a copy of the <code>struct</code>’s value (a copy of all the bytes from the argument). Consequently, changes to the parameter’s field values <em>do not</em> change the argument’s value. This behavior is illustrated in the preceding program in the call to <code>checkID</code>, which modifies the parameter’s age field. The changes in <code>checkID</code> have no effect on the corresponding argument’s age field value.</p>&#13;
<p class="indent">When passing a field of a <code>struct</code> to a function, the semantics match the type of the field (the type of the function’s parameter). For example, in the call to <code>changeName</code>, the value of the <code>name</code> field (the base address of the <code>name</code> array inside the <code>student2</code> struct) gets copied to the parameter <code>old</code>, meaning that the parameter refers to the same set of array elements in memory as its argument. Thus, changing an element of the array in the function also changes the element’s value in the argument; the semantics of passing the <code>name</code> field match the type of the <code>name</code> field.</p>&#13;
<h4 class="h4" id="lev2_28">2.7.2 Pointers and Structs</h4>&#13;
<p class="noindent">Just like other C types, programmers can declare a variable as a pointer to a user-defined <code>struct</code> type. The semantics of using a <code>struct</code> pointer variable resemble those of other pointer types such as <code>int *</code>.</p>&#13;
<p class="indent">Consider the <code>struct studentT</code> type introduced in the previous program example:</p>&#13;
<pre>struct studentT {<br/>&#13;
    char  name[64];<br/>&#13;
    int   age;<br/>&#13;
    float gpa;<br/>&#13;
    int   grad_yr;<br/>&#13;
};</pre>&#13;
<p class="indent">A programmer can declare variables of type <code>struct studentT</code> or <code>struct</code> <code>studentT *</code> (a pointer to a <code>struct studentT</code>):</p>&#13;
<pre>struct studentT s;<br/>&#13;
struct studentT *sptr;<br/>&#13;
<br/>&#13;
// think very carefully about the type of each field when<br/>&#13;
// accessing it (name is an array of char, age is an int ...)<br/>&#13;
strcpy(s.name, "Freya");<br/>&#13;
s.age = 18;<br/>&#13;
s.gpa = 4.0;<br/>&#13;
<span epub:type="pagebreak" id="page_107"/>&#13;
s.grad_yr = 2020;<br/>&#13;
<br/>&#13;
// malloc space for a struct studentT for sptr to point to:<br/>&#13;
sptr = malloc(sizeof(struct studentT));<br/>&#13;
if (sptr == NULL) {<br/>&#13;
    printf("Error: malloc failed\n");<br/>&#13;
    exit(1);<br/>&#13;
}</pre>&#13;
<p class="indent">Note that the call to <code>malloc</code> initializes <code>sptr</code> to point to a dynamically allocated struct in heap memory. Using the <code>sizeof</code> operator to compute <code>malloc</code>’s size request (e.g., <code>sizeof(struct studentT)</code>) ensures that <code>malloc</code> allocates space for <em>all</em> of the field values in the struct.</p>&#13;
<p class="indent">To access individual fields in a pointer to a <code>struct</code>, the pointer variable first needs to be <em>dereferenced</em>. Based on the rules for pointer dereferencing (see “C’s Pointer Variables” on <a href="ch02.xhtml#lev1_10">page 66</a>), you may be tempted to access <code>struct</code> fields like so:</p>&#13;
<pre>// the grad_yr field of what sptr points to gets 2021:<br/>&#13;
(*sptr).grad_yr = 2021;<br/>&#13;
<br/>&#13;
// the age field of what sptr points to gets s.age plus 1:<br/>&#13;
(*sptr).age = s.age + 1;</pre>&#13;
<p class="indent">However, because pointers to structs are so commonly used, C provides a special operator (<code>-&gt;</code>) that both dereferences a <code>struct</code> pointer and accesses one of its field values. For example, <code>sptr-&gt;year</code> is equivalent to <code>(*sptr).year</code>. Here are some examples of accessing field values using this notation:</p>&#13;
<pre>// the gpa field of what sptr points to gets 3.5:<br/>&#13;
sptr-&gt;gpa = 3.5;<br/>&#13;
<br/>&#13;
// the name field of what sptr points to is a char *<br/>&#13;
// (can use strcpy to init its value):<br/>&#13;
strcpy(sptr-&gt;name, "Lars");</pre>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig14">Figure 2-14</a> sketches what the variables <code>s</code> and <code>sptr</code> may look like in memory after the preceding code executes. Recall that <code>malloc</code> allocates memory from the heap, and local variables are allocated on the stack.</p>&#13;
<span epub:type="pagebreak" id="page_108"/>&#13;
<div class="imagec" id="ch2fig14"><img alt="image" src="../images/02fig14.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-14: The differences in memory layout between a statically allocated struct (data on the stack) and a dynamically allocated struct (data on the heap)</em></p>&#13;
<h4 class="h4" id="lev2_29">2.7.3 Pointer Fields in Structs</h4>&#13;
<p class="noindent">Structs can also be defined to have pointer types as field values. Here’s an example:</p>&#13;
<pre>struct personT {<br/>&#13;
    char *name;     // for a dynamically allocated string field<br/>&#13;
    int  age;<br/>&#13;
};<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    struct personT p1, *p2;<br/>&#13;
<br/>&#13;
    // need to malloc space for the name field:<br/>&#13;
    p1.name = malloc(sizeof(char) * 8);<br/>&#13;
    strcpy(p1.name, "Zhichen");<br/>&#13;
    p1.age = 22;<br/>&#13;
<br/>&#13;
<br/>&#13;
    // first malloc space for the struct:<br/>&#13;
    p2 = malloc(sizeof(struct personT));<br/>&#13;
<br/>&#13;
    // then malloc space for the name field:<br/>&#13;
    p2-&gt;name = malloc(sizeof(char) * 4);<br/>&#13;
    strcpy(p2-&gt;name, "Vic");<br/>&#13;
    p2-&gt;age = 19;<br/>&#13;
    ...<br/>&#13;
<br/>&#13;
    // Note: for strings, we must allocate one extra byte to hold the<br/>&#13;
    // terminating null character that marks the end of the string.<br/>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>In memory, these variables will look like <a href="ch02.xhtml#ch2fig15">Figure 2-15</a> (note which parts are allocated on the stack and which are on the heap).</p>&#13;
<div class="imagec" id="ch2fig15"><img alt="image" src="../images/02fig15.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-15: The layout in memory of a struct with a pointer field</em></p>&#13;
<p class="indent">As structs and the types of their fields increase in complexity, be careful with their syntax. To access field values appropriately, start from the outermost variable type and use its type syntax to access individual parts. For example, the types of the <code>struct</code> variables shown in <a href="ch02.xhtml#ch2tab2">Table 2-2</a> govern how a programmer should access their fields.</p>&#13;
<p class="tabcap" id="ch2tab2"><strong>Table 2-2:</strong> Struct Field Access Examples</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Expression</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Type</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Field access syntax</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>p1</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>struct personT</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>p1.age, p1.name</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>p2</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>struct personT *</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>p2-&gt;age, p2-&gt;name</code></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Further, knowing the types of field values allows a program to use the correct syntax in accessing them, as shown by the examples in <a href="ch02.xhtml#ch2tab3">Table 2-3</a>.</p>&#13;
<p class="tabcap" id="ch2tab3"><strong>Table 2-3:</strong> Accessing Different Struct Field Types</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Expression</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Type</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Example access syntax</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>p1.age</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>int</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>p1.age = 18;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>p2-&gt;age</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>int *</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>p2-&gt;age = 18;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>p1.name</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>char *</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>printf("%s", p1.name);</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>p2-&gt;name</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>char *</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>printf("%s", p2-&gt;name);</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>p2-&gt;name[2]</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>char</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>p2-&gt;name[2] = ’a’;</code></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">In examining the last example, start by considering the type of the outermost variable (<code>p2</code> is a pointer to a <code>struct personT</code>). Therefore, to access a field value in the struct, the programmer needs to use <code>-&gt;</code> syntax (<code>p2-&gt;name</code>). Next, consider the type of the <code>name</code> field, which is a <code>char *</code>, used in this program to point to an array of <code>char</code> values. To access a specific <code>char</code> storage location through the <code>name</code> field, use array indexing notation: <code>p2-&gt;name[2] =</code> <code>’a’</code>.</p>&#13;
<h4 class="h4" id="lev2_30"><span epub:type="pagebreak" id="page_110"/>2.7.4 Arrays of Structs</h4>&#13;
<p class="noindent">Arrays, pointers, and structs can be combined to create more complex data structures. Here are some examples of declaring variables of different types of arrays of structs:</p>&#13;
<pre>struct studentT classroom1[40];   // an array of 40 struct studentT<br/>&#13;
<br/>&#13;
struct studentT *classroom2;      // a pointer to a struct studentT<br/>&#13;
                                  // (for a dynamically allocated array)<br/>&#13;
<br/>&#13;
struct studentT *classroom3[40];  // an array of 40 struct studentT *<br/>&#13;
                                  // (each element stores a (struct studentT *)</pre>&#13;
<p class="indent">Again, thinking very carefully about variable and field types is necessary for understanding the syntax and semantics of using these variables in a program. Here are some examples of the correct syntax for accessing these variables:</p>&#13;
<pre>// classroom1 is an array:<br/>&#13;
//    use indexing to access a particular element<br/>&#13;
//    each element in classroom1 stores a struct studentT:<br/>&#13;
//    use dot notation to access fields<br/>&#13;
classroom1[3].age = 21;<br/>&#13;
<br/>&#13;
// classroom2 is a pointer to a struct studentT<br/>&#13;
//    call malloc to dynamically allocate an array<br/>&#13;
//    of 15 studentT structs for it to point to:<br/>&#13;
classroom2 = malloc(sizeof(struct studentT) * 15);<br/>&#13;
<br/>&#13;
// each element in array pointed to by classroom2 is a studentT struct<br/>&#13;
//    use [] notation to access an element of the array, and dot notation<br/>&#13;
//    to access a particular field value of the struct at that index:<br/>&#13;
classroom2[3].year = 2013;<br/>&#13;
<br/>&#13;
// classroom3 is an array of struct studentT *<br/>&#13;
//    use [] notation to access a particular element<br/>&#13;
//    call malloc to dynamically allocate a struct for it to point to<br/>&#13;
classroom3[5] = malloc(sizeof(struct studentT));<br/>&#13;
<br/>&#13;
// access fields of the struct using -&gt; notation<br/>&#13;
// set the age field pointed to in element 5 of the classroom3 array to 21<br/>&#13;
classroom3[5]-&gt;age = 21;   </pre>&#13;
<p class="indent">A function that takes an array of type <code>struct studentT *</code> as a parameter might look like this:</p>&#13;
<pre>void updateAges(struct studentT *classroom, int size) {<br/>&#13;
    int i;<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_111"/>&#13;
    for (i = 0; i &lt; size; i++) {<br/>&#13;
        classroom[i].age += 1;<br/>&#13;
    }<br/>&#13;
}</pre>&#13;
<p class="indent">A program could pass this function either a statically or dynamically allocated array of <code>struct studentT</code>:</p>&#13;
<pre>updateAges(classroom1, 40);<br/>&#13;
updateAges(classroom2, 15);</pre>&#13;
<p class="indent">The semantics of passing <code>classroom1</code> (or <code>classroom2</code>) to <code>updateAges</code> match the semantics of passing a statically declared (or dynamically allocated) array to a function: the parameter refers to the same set of elements as the argument and thus changes to the array’s values within the function affect the argument’s elements.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig16">Figure 2-16</a> shows what the stack might look like for the second call to the <code>updateAges</code> function (showing the passed <code>classroom2</code> array with example field values for the struct in each of its elements).</p>&#13;
<div class="imagec" id="ch2fig16"><img alt="image" src="../images/02fig16.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-16: The memory layout of an array of <code>struct studentT</code> passed to a function</em></p>&#13;
<p class="indent">As always, the parameter gets a copy of the value of its argument (the memory address of the array in heap memory). Thus, modifying the array’s elements in the function will persist to its argument’s values (both the parameter and the argument refer to the same array in memory).</p>&#13;
<p class="indent">The <code>updateAges</code> function cannot be passed the <code>classroom3</code> array because its type is not the same as the parameter’s type: <code>classroom3</code> is an array of <code>struct</code> <code>studentT *</code>, not an array of <code>struct studentT</code>.</p>&#13;
<h4 class="h4" id="lev2_31">2.7.5 Self-Referential Structs</h4>&#13;
<p class="noindent">A struct can be defined with fields whose type is a pointer to the same <code>struct</code> type. These self-referential <code>struct</code> types can be used to build linked implementations of data structures, such as linked lists, trees, and graphs.</p>&#13;
<p class="indent">The details of these data types and their linked implementations are beyond the scope of this book. However, we briefly show one example of how to define and use a self-referential <code>struct</code> type to create a linked list in C. Refer to a textbook on data structures and algorithms for more information about linked lists.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_112"/>A <em>linked list</em> is one way to implement a <em>list abstract data type</em>. A list represents a sequence of elements that are ordered by their position in the list. In C, a list data structure could be implemented as an array or as a linked list using a self-referential <code>struct</code> type for storing individual nodes in the list.</p>&#13;
<p class="indent">To build the latter, a programmer would define a <code>node</code> struct to contain one list element and a link to the next node in the list. Here’s an example that could store a linked list of integer values:</p>&#13;
<pre>struct node {<br/>&#13;
    int data;           // used to store a list element's data value<br/>&#13;
    struct node *next;  // used to point to the next node in the list<br/>&#13;
};</pre>&#13;
<p class="indent">Instances of this <code>struct</code> type can be linked together through the <code>next</code> field to create a linked list.</p>&#13;
<p class="indent">This example code snippet creates a linked list containing three elements (the list itself is referred to by the <code>head</code> variable that points to the first node in the list):</p>&#13;
<pre>struct node *head, *temp;<br/>&#13;
int i;<br/>&#13;
<br/>&#13;
head = NULL;  // an empty linked list<br/>&#13;
<br/>&#13;
head = malloc(sizeof(struct node));  // allocate a node<br/>&#13;
if (head == NULL) {<br/>&#13;
    printf("Error malloc\n");<br/>&#13;
    exit(1);<br/>&#13;
}<br/>&#13;
head-&gt;data = 10;    // set the data field<br/>&#13;
head-&gt;next = NULL;  // set next to NULL (there is no next element)<br/>&#13;
<br/>&#13;
// add 2 more nodes to the head of the list:<br/>&#13;
for (i = 0; i &lt; 2; i++) {<br/>&#13;
    temp = malloc(sizeof(struct node));  // allocate a node<br/>&#13;
    if (temp == NULL) {<br/>&#13;
        printf("Error malloc\n");<br/>&#13;
        exit(1);<br/>&#13;
    }<br/>&#13;
    temp-&gt;data = i;     // set data field<br/>&#13;
    temp-&gt;next = head;  // set next to point to current first node<br/>&#13;
    head = temp;        // change head to point to newly added node<br/>&#13;
}</pre>&#13;
<p class="indent">Note that the <code>temp</code> variable temporarily points to a malloc’ed <code>node</code> that gets initialized and then added to the beginning of the list by setting its <code>next</code> field to point to the node currently pointed to by <code>head</code>, and then by changing the <code>head</code> to point to this new node.</p>&#13;
<p class="indent">The result of executing this code would look like <a href="ch02.xhtml#ch2fig17">Figure 2-17</a> in memory.</p>&#13;
<span epub:type="pagebreak" id="page_113"/>&#13;
<div class="imagec" id="ch2fig17"><img alt="image" src="../images/02fig17.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-17: The layout in memory of three example linked list nodes</em></p>&#13;
<h3 class="h3" id="lev1_16">2.8 I/O in C (Standard and File)</h3>&#13;
<p class="noindent">C supports many functions for performing standard I/O as well as file I/O. In this section, we discuss some of the most commonly used interfaces for I/O in C.</p>&#13;
<h4 class="h4" id="lev2_32">2.8.1 Standard Input/Output</h4>&#13;
<p class="noindent">Every running program begins with three default I/O streams: standard out (<code>stdout</code>), standard in (<code>stdin</code>), and standard error (<code>stderr</code>). A program can write (print) output to <code>stdout</code> and <code>stderr</code>, and it can read input values from <code>stdin</code>. <code>stdin</code> is usually defined to read in input from the keyboard, whereas <code>stdout</code> and <code>stderr</code> output to the terminal.</p>&#13;
<p class="indent">The C <code>stdio.h</code> library provides the <code>printf</code> function used for printing to standard out and the <code>scanf</code> function that can be used to read in values from standard in. C also has functions to read and write one character at a time (<code>getchar</code> and <code>putchar</code>) as well as other functions and libraries for reading and writing characters to standard I/O streams. A C program must explicitly include <code>stdio.h</code> to call these functions.</p>&#13;
<p class="indent">You can change the location that a running program’s <code>stdin</code>, <code>stdout</code> and/ or <code>stderr</code> read from or write to. One way to do this is by redirecting one or all of these to read or write to a file. Here are some example shell commands for redirecting a program’s <code>stdin</code>, <code>stdout</code>, or <code>stderr</code> to a file (<code>$</code> is the shell prompt):</p>&#13;
<pre>#  redirect a.out's stdin to read from file infile.txt:<br/>&#13;
$ <span class="codestrong1">./a.out &lt; infile.txt</span><br/>&#13;
<br/>&#13;
#  redirect a.out's stdout to print to file outfile.txt:<br/>&#13;
$ <span class="codestrong1">./a.out &gt; outfile.txt</span><br/>&#13;
<br/>&#13;
# redirect a.out's stdout and stderr to a file out.txt<br/>&#13;
$ <span class="codestrong1">./a.out &amp;&gt; outfile.txt</span><br/>&#13;
<br/>&#13;
# redirect all three to different files:<br/>&#13;
#   (&lt; redirects stdin, 1&gt; stdout, and 2&gt; stderr):<br/>&#13;
$ <span class="codestrong1">./a.out &lt; infile.txt 1&gt; outfile.txt 2&gt; errorfile.txt</span></pre>&#13;
<h5 class="h5" id="lev3_26"><span epub:type="pagebreak" id="page_114"/>printf</h5>&#13;
<p class="noindent">C’s <code>printf</code> function resembles formatted <code>print</code> calls in Python, where the caller specifies a format string to print. The format string often contains special format specifiers, including special characters that will print tabs (<code>\t</code>) or newlines (<code>\n</code>), or that specify placeholders for values in the output (<code>%</code> followed by a type specifier). When adding placeholders in a format string passed to <code>printf</code>, pass their corresponding values as additional arguments following the format string. Here are some example calls to <code>printf</code>:</p>&#13;
<p class="margnote">printf.c</p>&#13;
<pre>int x = 5, y = 10;<br/>&#13;
float pi = 3.14;<br/>&#13;
<br/>&#13;
printf("x is %d and y is %d\n", x, y);<br/>&#13;
<br/>&#13;
printf("%g \t %s \t %d\n", pi, "hello", y);</pre>&#13;
<p class="indent">When run, these <code>printf</code> statements output:</p>&#13;
<pre>x is 5 and y is 10<br/>&#13;
3.14   hello   10</pre>&#13;
<p class="indent">Note how the tab characters (<code>\t</code>) get printed in the second call, and the different formatting placeholders for different types of values (<code>%g</code>, <code>%s</code>, and <code>%d</code>).</p>&#13;
<p class="indent">Here’s a set of formatting placeholders for common C types. Note that placeholders for <code>long</code> and <code>long long</code> values include an <code>l</code> or <code>ll</code> prefix.</p>&#13;
<pre>%f, %g: placeholders for a float or double value<br/>&#13;
%d:     placeholder for a decimal value (char, short, int)<br/>&#13;
%u:     placeholder for an unsigned decimal<br/>&#13;
%c:     placeholder for a single character<br/>&#13;
%s:     placeholder for a string value<br/>&#13;
%p:     placeholder to print an address value<br/>&#13;
<br/>&#13;
%ld:    placeholder for a long value<br/>&#13;
%lu:    placeholder for an unsigned long value<br/>&#13;
%lld:   placeholder for a long long value<br/>&#13;
%llu:   placeholder for an unsigned long long value</pre>&#13;
<p class="indent">Here are some examples of their use:</p>&#13;
<pre>float labs;<br/>&#13;
int midterm;<br/>&#13;
<br/>&#13;
labs = 93.8;<br/>&#13;
midterm = 87;<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_115"/>&#13;
printf("Hello %s, here are your grades so far:\n", "Tanya");<br/>&#13;
printf("\t midterm: %d (out of %d)\n", midterm, 100);<br/>&#13;
printf("\t lab ave: %f\n", labs);<br/>&#13;
printf("\t final report: %c\n", 'A');</pre>&#13;
<p class="indent">When run, the output will look like this:</p>&#13;
<pre>Hello Tanya, here are your grades so far:<br/>&#13;
     midterm: 87 (out of 100)<br/>&#13;
     lab ave: 93.800003<br/>&#13;
     final report: A</pre>&#13;
<p class="indent">C also allows you to specify the field width with format placeholders. Here are some examples:</p>&#13;
<pre>%5.3f: print float value in space 5 chars wide, with 3 places beyond decimal<br/>&#13;
%20s:  print the string value in a field of 20 chars wide, right justified<br/>&#13;
%-20s: print the string value in a field of 20 chars wide, left justified<br/>&#13;
%8d:   print the int value in a field of 8 chars wide, right justified<br/>&#13;
%-8d:  print the int value in a field of 8 chars wide, left justified</pre>&#13;
<p class="indent">Here’s a larger example that uses field width specifiers with placeholders in the format string:</p>&#13;
<p class="margnote">printf_format.c</p>&#13;
<pre>#include &lt;stdio.h&gt; // library needed for printf<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    float x, y;<br/>&#13;
    char ch;<br/>&#13;
<br/>&#13;
    x = 4.50001;<br/>&#13;
    y = 5.199999;<br/>&#13;
    ch = 'a';      // ch stores ASCII value of 'a' (the value 97)<br/>&#13;
<br/>&#13;
    // .1: print x and y with single precision<br/>&#13;
    printf("%.1f %.1f\n", x, y);<br/>&#13;
<br/>&#13;
    printf("%6.1f \t %6.1f \t %c\n", x, y, ch);<br/>&#13;
<br/>&#13;
    // ch+1 is 98, the ASCII value of 'b'<br/>&#13;
    printf("%6.1f \t %6.1f \t %c\n", x+1, y+1, ch+1);<br/>&#13;
<br/>&#13;
    printf("%6.1f \t %6.1f \t %c\n", x*20, y*20, ch+2);<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_116"/>When run, the program output looks like this:</p>&#13;
<pre>4.5 5.2<br/>&#13;
   4.5    5.2     a<br/>&#13;
   5.5    6.2     b<br/>&#13;
  90.0  104.0     c</pre>&#13;
<p class="indent">Note how the use of tabs and field width in the last three <code>printf</code> statements result in a tabular output.</p>&#13;
<p class="indent">Finally, C defines placeholders for displaying values in different representations:</p>&#13;
<pre>%x:     print value in hexadecimal (base 16)<br/>&#13;
%o:     print value in octal (base 8)<br/>&#13;
%d:     print value in signed decimal  (base 10)<br/>&#13;
%u:     print value in unsigned decimal (unsigned base 10)<br/>&#13;
%e:     print float or double in scientific notation<br/>&#13;
(there is no formatting option to display a value in binary)</pre>&#13;
<p class="indent">Here is an example using placeholders to print values in different representations:</p>&#13;
<pre>int x;<br/>&#13;
char ch;<br/>&#13;
<br/>&#13;
x = 26;<br/>&#13;
ch = 'A';<br/>&#13;
<br/>&#13;
printf("x is %d in decimal, %x in hexadecimal and %o in octal\n", x, x, x);<br/>&#13;
printf("ch value is %d which is the ASCII value of  %c\n", ch, ch);</pre>&#13;
<p class="indent">When run, the program output looks like this:</p>&#13;
<pre>x is 26 in decimal, 1a in hexadecimal and 32 in octal<br/>&#13;
ch value is 65 which is the ASCII value of A</pre>&#13;
<h5 class="h5" id="lev3_27">scanf</h5>&#13;
<p class="noindent">The <code>scanf</code> function provides one method for reading in values from <code>stdin</code> (usually from the user entering them via the keyboard) and storing them in program variables. The <code>scanf</code> function is a bit picky about the exact format in which the user enters data, which can make it sensitive to badly formed user input.</p>&#13;
<p class="indent">The arguments to the <code>scanf</code> function are similar to those of <code>printf</code>: <code>scanf</code> takes a format string that specifies the number and type of input values to read in, followed by the <em>locations</em> of program variables into which the values should be stored. Programs typically combine the <em>address of</em> (<code>&amp;</code>) operator with a variable name to produce the location of the variable in the program’s memory—the memory address of the variable. Here’s an example call to <code>scanf</code> that reads in two values (an <code>int</code> and a <code>float</code>):</p>&#13;
<span epub:type="pagebreak" id="page_117"/>&#13;
<p class="margnote">scanf_ex.c</p>&#13;
<pre>int x;<br/>&#13;
float pi;<br/>&#13;
<br/>&#13;
// read in an int value followed by a float value ("%d%g")<br/>&#13;
// store the int value at the memory location of x (&amp;x)<br/>&#13;
// store the float value at the memory location of pi (&amp;pi)<br/>&#13;
scanf("%d%g", &amp;x, &amp;pi);</pre>&#13;
<p class="indent">Individual input values must be separated by at least one whitespace character (e.g., spaces, tabs, newlines). However, <code>scanf</code> skips over leading and trailing whitespace characters as it finds the start and end of each numeric literal value. As a result, a user could enter the value 8 and 3.14 with any amount of whitespace before or after the two values (and at least one or more whitespace characters between), and <code>scanf</code> will always read in 8 and assign it to <code>x</code> and read in 3.14 and assign it to <code>pi</code>. For example, this input with lots of spaces between the two values will result in reading in 8 and storing it in <code>x</code>, and 3.14 and storing in <code>pi</code>:</p>&#13;
<pre><span class="codestrong1">           8                   3.14</span></pre>&#13;
<p class="indent">Programmers often write format strings for <code>scanf</code> that only consist of placeholder specifiers without any other characters between them. For reading in the two numbers in the preceding example, the format string might look like:</p>&#13;
<pre>// read in an int and a float separated by at least one white space character<br/>&#13;
scanf("%d%g",&amp;x, &amp;pi);</pre>&#13;
<h5 class="h5" id="lev3_28">getchar and putchar</h5>&#13;
<p class="noindent">The C functions <code>getchar</code> and <code>putchar</code> respectively read or write a single character value from <code>stdin</code> and to <code>stdout</code>. <code>getchar</code> is particularly useful in C programs that need to support careful error detection and handling of badly formed user input (<code>scanf</code> is not robust in this way).</p>&#13;
<pre>ch = getchar();  // read in the next char value from stdin<br/>&#13;
putchar(ch);     // write the value of ch to stdout</pre>&#13;
<h4 class="h4" id="lev2_33">2.8.2 File Input/Output</h4>&#13;
<p class="noindent">The C standard I/O library (<code>stdio.h</code>) includes a stream interface for file I/O. A <em>file</em> stores persistent data: data that lives beyond the execution of the program that created it. A text file represents a stream of characters, and each open file tracks its current position in the character stream. When opening a file, the current position starts at the very first character in the file, and it moves as a result of every character read (or written) to the file. To read the 10th character in a file, the first nine characters need to first be read (or the <span epub:type="pagebreak" id="page_118"/>current position must be explicitly moved to the 10th character using the <code>fseek</code> function).</p>&#13;
<p class="indent">C’s file interface views a file as an input or output stream, and library functions read from or write to the next position in the file stream. The <code>fprintf</code> and <code>fscanf</code> functions serve as the file I/O counterparts to <code>printf</code> and <code>scanf</code>. They use a format string to specify what to write or read, and they include arguments that provide values or storage for the data that gets written or read. Similarly, the library provides the <code>fputc</code>, <code>fgetc</code>, <code>fputs</code>, and <code>fgets</code> functions for reading and writing individual characters or strings to file streams. Although there are many libraries that support file I/O in C, we present only the <code>stdio.h</code> library’s stream interface to text files in detail.</p>&#13;
<p class="indent">Text files may contain special chars like the <code>stdin</code> and <code>stdout</code> streams: newlines (<code>’\n’</code>), tabs (<code>’\t’</code>), etc. Additionally, upon reaching the end of a file’s data, C’s I/O library generates a special end-of-file character (<code>EOF</code>) that represents the end of the file. Functions reading from a file can test for <code>EOF</code> to determine when they have reached the end of the file stream.</p>&#13;
<h4 class="h4" id="lev2_34">2.8.3 Using Text Files in C</h4>&#13;
<p class="noindent">To read or write a file in C, follow these steps.</p>&#13;
<p class="indent">First, <em>declare</em> a <code>FILE *</code> variable:</p>&#13;
<pre>FILE *infile;<br/>&#13;
FILE *outfile;</pre>&#13;
<p class="noindent">These declarations create pointer variables to a library-defined <code>FILE</code> type. These pointers cannot be dereferenced in an application program. Instead, they refer to a specific file stream when passed to I/O library functions.</p>&#13;
<p class="indent">Second, <em>open</em> the file: associate the variable with an actual file stream by calling <code>fopen</code>. When opening a file, the <em>mode</em> parameter determines whether the program opens it for reading (<code>"r"</code>), writing (<code>"w"</code>), or appending (<code>"a"</code>):</p>&#13;
<pre>infile = fopen("input.txt", "r");  // relative path name of file, read mode<br/>&#13;
if (infile == NULL) {<br/>&#13;
    printf("Error: unable to open file %s\n", "input.txt");<br/>&#13;
    exit(1);<br/>&#13;
}<br/>&#13;
<br/>&#13;
// fopen with absolute path name of file, write mode<br/>&#13;
outfile = fopen("/home/me/output.txt", "w");<br/>&#13;
if (outfile == NULL) {<br/>&#13;
    printf("Error: unable to open outfile\n");<br/>&#13;
    exit(1);<br/>&#13;
}</pre>&#13;
<p class="indent">The <code>fopen</code> function returns <code>NULL</code> to report errors, which may occur if it’s given an invalid filename or the user doesn’t have permission to open the specified file (e.g., not having write permission to the <code>output.txt</code> file).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_119"/>Third, <em>use</em> I/O operations to read, write, or move the current position in the file:</p>&#13;
<pre>int ch;  // EOF is not a char value, but is an int.<br/>&#13;
         // since all char values can be stored in int, use int for ch<br/>&#13;
<br/>&#13;
ch = getc(infile);      // read next char from the infile stream<br/>&#13;
if (ch != EOF) {<br/>&#13;
    putc(ch, outfile);  // write char value to the outfile stream<br/>&#13;
}</pre>&#13;
<p class="indent">Finally, <em>close</em> the file: use <code>fclose</code> to close the file when the program no longer needs it:</p>&#13;
<pre>fclose(infile);<br/>&#13;
fclose(outfile);</pre>&#13;
<p class="indent">The <code>stdio</code> library also provides functions to change the current position in a file:</p>&#13;
<pre>// to reset current position to beginning of file<br/>&#13;
void rewind(FILE *f);<br/>&#13;
<br/>&#13;
rewind(infile);<br/>&#13;
<br/>&#13;
// to move to a specific location in the file:<br/>&#13;
fseek(FILE *f, long offset, int whence);<br/>&#13;
<br/>&#13;
fseek(f, 0, SEEK_SET);    // seek to the beginning of the file<br/>&#13;
fseek(f, 3, SEEK_CUR);    // seek 3 chars forward from the current position<br/>&#13;
fseek(f, -3, SEEK_END);   // seek 3 chars back from the end of the file</pre>&#13;
<h4 class="h4" id="lev2_35">2.8.4 Standard and File I/O Functions in stdio.h</h4>&#13;
<p class="noindent">The C <code>stdio.h</code> library has many functions for reading and writing to files and to the standard file-like streams (<code>stdin</code>, <code>stdout</code>, and <code>stderr</code>). These functions can be classified into character-based, string-based, and formatted I/O functions. Here’s some additional details about a subset of these functions:</p>&#13;
<pre>// ---------------<br/>&#13;
// Character Based<br/>&#13;
// ---------------<br/>&#13;
<br/>&#13;
// returns the next character in the file stream (EOF is an int value)<br/>&#13;
int fgetc(FILE *f);<br/>&#13;
<br/>&#13;
// writes the char value c to the file stream f<br/>&#13;
// returns the char value written<br/>&#13;
int fputc(int c, FILE *f);<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_120"/>&#13;
// pushes the character c back onto the file stream<br/>&#13;
// at most one char (and not EOF) can be pushed back<br/>&#13;
int ungetc(int c, FILE *f);<br/>&#13;
<br/>&#13;
// like fgetc and fputc but for stdin and stdout<br/>&#13;
int getchar();<br/>&#13;
int putchar(int c);<br/>&#13;
<br/>&#13;
// -------------<br/>&#13;
// String  Based<br/>&#13;
// -------------<br/>&#13;
<br/>&#13;
// reads at most n-1 characters into the array s stopping if a newline is<br/>&#13;
// encountered, newline is included in the array which is '\0' terminated<br/>&#13;
char *fgets(char *s, int n, FILE *f);<br/>&#13;
<br/>&#13;
// writes the string s (make sure '\0' terminated) to the file stream f<br/>&#13;
int fputs(char *s, FILE *f);<br/>&#13;
<br/>&#13;
// ---------<br/>&#13;
// Formatted<br/>&#13;
// ---------<br/>&#13;
<br/>&#13;
// writes the contents of the format string to file stream f<br/>&#13;
//   (with placeholders filled in with subsequent argument values)<br/>&#13;
// returns the number of characters printed<br/>&#13;
int fprintf(FILE *f, char *format, ...);<br/>&#13;
<br/>&#13;
// like fprintf but to stdout<br/>&#13;
int printf(char *format, ...);<br/>&#13;
<br/>&#13;
// use fprintf to print stderr:<br/>&#13;
fprintf(stderr, "Error return value: %d\n", ret);<br/>&#13;
<br/>&#13;
// read values specified in the format string from file stream f<br/>&#13;
//   store the read-in values to program storage locations of types<br/>&#13;
//   matching the format string<br/>&#13;
// returns number of input items converted and assigned<br/>&#13;
//   or EOF on error or if EOF was reached<br/>&#13;
int fscanf(FILE *f, char *format, ...);<br/>&#13;
<br/>&#13;
// like fscanf but reads from stdin<br/>&#13;
int scanf(char *format, ...);</pre>&#13;
<p class="indent">In general, <code>scanf</code> and <code>fscanf</code> are sensitive to badly formed input. However, for file I/O, often programmers can assume that an input file is well formatted, so <code>fscanf</code> may be robust enough in such cases. With <code>scanf</code>, badly <span epub:type="pagebreak" id="page_121"/>formed user input will often cause a program to crash. Reading in one character at a time and including code to test values before converting them to different types is more robust, but it requires the programmer to implement more complex I/O functionality.</p>&#13;
<p class="indent">The format string for <code>fscanf</code> can include the following syntax specifying different types of values and ways of reading from the file stream:</p>&#13;
<pre>%d integer<br/>&#13;
%f float<br/>&#13;
%lf double<br/>&#13;
%c character<br/>&#13;
%s string, up to first white space<br/>&#13;
<br/>&#13;
%[...] string, up to first character not in brackets<br/>&#13;
%[0123456789] would read in digits<br/>&#13;
%[^...] string, up to first character in brackets<br/>&#13;
%[^\n] would read everything up to a newline</pre>&#13;
<p class="indent">It can be tricky to get the <code>fscanf</code> format string correct, particularly when reading a mix of numeric and string or character types from a file.</p>&#13;
<p class="indent">Here are a few example calls to <code>fscanf</code> (and one to <code>fprintf</code>) with different format strings (let’s assume that the <code>fopen</code> calls from the previous example have executed successfully):</p>&#13;
<pre>int x;<br/>&#13;
double d;<br/>&#13;
char c, array[MAX];<br/>&#13;
<br/>&#13;
// write int &amp; char values to file separated by colon with newline at the end<br/>&#13;
fprintf(outfile, "%d:%c\n", x, c);<br/>&#13;
<br/>&#13;
// read an int &amp; char from file where int and char are separated by a comma<br/>&#13;
fscanf(infile, "%d,%c", &amp;x, &amp;c);<br/>&#13;
<br/>&#13;
// read a string from a file into array (stops reading at whitespace char)<br/>&#13;
fscanf(infile,"%s", array);<br/>&#13;
<br/>&#13;
// read a double and a string up to 24 chars from infile<br/>&#13;
fscanf(infile, "%lf %24s", &amp;d, array);<br/>&#13;
<br/>&#13;
// read in a string consisting of only char values in the specified set (0-5)<br/>&#13;
// stops reading when...<br/>&#13;
//   20 chars have been read OR<br/>&#13;
//   a character not in the set is reached OR<br/>&#13;
//   the file stream reaches end-of-file (EOF)<br/>&#13;
fscanf(infile, "%20[012345]", array);<br/>&#13;
<br/>&#13;
// read in a string; stop when reaching a punctuation mark from the set<br/>&#13;
<span epub:type="pagebreak" id="page_122"/>&#13;
fscanf(infile, "%[^.,:!;]", array);<br/>&#13;
<br/>&#13;
// read in two integer values: store first in long, second in int<br/>&#13;
// then read in a char value following the int value<br/>&#13;
fscanf(infile, "%ld %d%c", &amp;x, &amp;b, &amp;c);</pre>&#13;
<p class="indent">In the final example in the preceding code, the format string explicitly reads in a character value after a number to ensure that the file stream’s current position gets properly advanced for any subsequent calls to <code>fscanf</code>. For example, this pattern is often used to explicitly read in (and discard) a whitespace character (like <em>\n</em>), to ensure that the next call to <code>fscanf</code> begins from the next line in the file. Reading an additional character is necessary if the <em>next</em> call to <code>fscanf</code> attempts to read in a character value. Otherwise, having not consumed the newline, the next call to <code>fscanf</code> will read the newline rather than the intended character. If the next call reads in a numeric type value, then leading whitespace chars are automatically discarded by <code>fscanf</code> and the programmer does not need to explicitly read the <code>\n</code> character from the file stream.</p>&#13;
<h3 class="h3" id="lev1_17">2.9 Some Advanced C Features</h3>&#13;
<p class="noindent">Almost all of the C programming language has been presented in previous sections. In this section, we cover a few remaining advanced C language features and some advanced C programming and compiling topics:</p>&#13;
<ul>&#13;
<li class="noindent">the C <code>switch</code> statement (<a href="ch02.xhtml#lev2_36">page 122</a>)</li>&#13;
<li class="noindent">command line arguments (<a href="ch02.xhtml#lev2_37">page 125</a>)</li>&#13;
<li class="noindent">the <code>void *</code> type and type recasting (<a href="ch02.xhtml#lev2_38">page 126</a>)</li>&#13;
<li class="noindent">pointer arithmetic (<a href="ch02.xhtml#lev2_39">page 128</a>)</li>&#13;
<li class="noindent">C libraries: using, compiling, and linking (<a href="ch02.xhtml#lev2_40">page 133</a>)</li>&#13;
<li class="noindent">writing and using your own C libraries (and dividing your program into multiple modules (<code>.c</code> and <code>.h</code> files); <a href="ch02.xhtml#lev2_41">page 139</a>)</li>&#13;
<li class="noindent">compiling C source to assembly code (<a href="ch02.xhtml#lev2_42">page 145</a>).</li>&#13;
</ul>&#13;
<h4 class="h4" id="lev2_36">2.9.1 switch Statements</h4>&#13;
<p class="noindent">The C <code>switch</code> statement can be used in place of some, but not all, chaining <code>if</code>–<code>else if</code> code sequences. While <code>switch</code> doesn’t provide any additional expressive power to the C programming language, it often yields more concise code branching sequences. It may also allow the compiler to produce branching code that executes more efficiently than equivalent chaining <code>if</code>–<code>else if</code> code.</p>&#13;
<p class="indent">The C syntax for a <code>switch</code> statement looks like:</p>&#13;
<pre><span epub:type="pagebreak" id="page_123"/>switch (<span class="codeitalic1">&lt;expression&gt;</span>) {<br/>&#13;
<br/>&#13;
   case <span class="codeitalic1">&lt;literal value 1&gt;</span>:<br/>&#13;
        <span class="codeitalic1">&lt;statements&gt;</span>;<br/>&#13;
        break;         // breaks out of switch statement body<br/>&#13;
   case <span class="codeitalic1">&lt;literal value 2&gt;</span>:<br/>&#13;
        <span class="codeitalic1">&lt;statements&gt;</span>;<br/>&#13;
        break;         // breaks out of switch statement body<br/>&#13;
   ...<br/>&#13;
   default:            // default label is optional<br/>&#13;
        <span class="codeitalic1">&lt;statements&gt;</span>;<br/>&#13;
}</pre>&#13;
<p class="indent">A switch statement is executed as follows:</p>&#13;
<div class="number">&#13;
<p class="number">1. The <span class="literal"/> <span class="codeitalic">&lt;expression&gt;</span> evaluates first.</p>&#13;
<p class="number">2. Next, the <code>switch</code> searches for a <code>case</code> literal value that matches the value of the expression.</p>&#13;
<p class="number">3. Upon finding a matching <code>case</code> literal, it begins executing the <span class="literal"/> <span class="codeitalic">&lt;statements&gt;</span> that immediately follow it.</p>&#13;
<p class="number">4. If no matching <code>case</code> is found, it will begin executing the <span class="literal"/> <span class="codeitalic">&lt;statements&gt;</span> in the <code>default</code> label if one is present.</p>&#13;
<p class="number">5. Otherwise, no statements in the body of the <code>switch</code> statement get executed.</p>&#13;
</div>&#13;
<p class="indent">A few rules about <code>switch</code> statements:</p>&#13;
<ul>&#13;
<li class="noindent">The value associated with each <code>case</code> must be a literal value—it <em>cannot</em> be an expression. The original expression gets matched for <em>equality</em> only with the literal values associated with each <code>case</code>.</li>&#13;
<li class="noindent">Reaching a <code>break</code> statement stops the execution of all remaining statements inside the body of the <code>switch</code> statement. That is, <code>break</code> breaks out of the body of the <code>switch</code> statement and continues execution with the next statement after the entire <code>switch</code> block.</li>&#13;
<li class="noindent">The <code>case</code> statement with a matching value marks the starting point into the sequence of C statements that will be executed—execution jumps to a location inside the <code>switch</code> body to start executing code. Thus, if there is no <code>break</code> statement at the end of a particular <code>case</code>, then the statements under the subsequent <code>case</code> statements execute in order until either a <code>break</code> statement is executed or the end of the body of the <code>switch</code> statement is reached.</li>&#13;
<li class="noindent">The <code>default</code> label is optional. If present, it must be at the end.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/>Here’s an example program with a <code>switch</code> statement:</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int num, new_num = 0;<br/>&#13;
<br/>&#13;
    printf("enter a number between 6 and 9: ");<br/>&#13;
    scanf("%d", &amp;num);<br/>&#13;
<br/>&#13;
    switch(num) {<br/>&#13;
        case 6:<br/>&#13;
            new_num = num + 1;<br/>&#13;
            break;<br/>&#13;
        case 7:<br/>&#13;
            new_num = num;<br/>&#13;
            break;<br/>&#13;
        case 8:<br/>&#13;
            new_num = num - 1;<br/>&#13;
            break;<br/>&#13;
        case 9:<br/>&#13;
            new_num = num + 2;<br/>&#13;
            break;<br/>&#13;
        default:<br/>&#13;
            printf("Hey, %d is not between 6 and 9\n", num);<br/>&#13;
    }<br/>&#13;
    printf("num %d  new_num %d\n", num, new_num);<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">Here are some example runs of this code:</p>&#13;
<pre><span class="codestrong1">./a.out</span><br/>&#13;
enter a number between 6 and 9: <span class="codestrong1">9</span><br/>&#13;
num 9  new_num 11<br/>&#13;
<br/>&#13;
<span class="codestrong1">./a.out</span><br/>&#13;
enter a number between 6 and 9: <span class="codestrong1">6</span><br/>&#13;
num 6  new_num 7<br/>&#13;
<br/>&#13;
<span class="codestrong1">./a.out</span><br/>&#13;
enter a number between 6 and 9: <span class="codestrong1">12</span><br/>&#13;
Hey, 12 is not between 6 and 9<br/>&#13;
num 12  new_num 0</pre>&#13;
<h4 class="h4" id="lev2_37"><span epub:type="pagebreak" id="page_125"/>2.9.2 Command Line Arguments</h4>&#13;
<p class="noindent">A program can be made more general purpose by reading command line arguments, which are included as part of the command entered by the user to run a binary executable program. They specify input values or options that change the runtime behavior of the program. In other words, running the program with different command line argument values results in a program’s behavior changing from run to run without having to modify the program code and recompile it. For example, if a program takes the name of an input filename as a command line argument, a user can run it with any input filename as opposed to a program that refers to a specific input filename in the code.</p>&#13;
<p class="indent">Any command line arguments the user provides get passed to the <code>main</code> function as parameter values. To write a program that takes command line arguments, the <code>main</code> function’s definition must include two parameters, <code>argc</code> and <code>argv</code>:</p>&#13;
<pre>int main(int argc, char *argv[]) { ...</pre>&#13;
<p class="noindent">Note that the type of the second parameter could also be represented as <code>char</code> <code>**argv</code>.</p>&#13;
<p class="indent">The first parameter, <code>argc</code>, stores the argument count. Its value represents the number of command line arguments passed to the main function (including the name of the program). For example, if the user enters</p>&#13;
<pre><span class="codestrong1">./a.out 10 11 200</span></pre>&#13;
<p class="noindent">then <code>argc</code> will hold the value 4 (<code>a.out</code> counts as the first command line argument, and <code>10</code>, <code>11</code>, and <code>200</code> as the other three).</p>&#13;
<p class="indent">The second parameter, <code>argv</code>, stores the argument vector. It contains the value of each command line argument. Each command line argument gets passed in as a string value, thus <code>argv</code>’s type is an array of strings (or an array of <code>char</code> arrays). The <code>argv</code> array contains <code>argc + 1</code> elements. The first <code>argc</code> elements store the command line argument strings, and the last element stores <code>NULL</code>, signifying the end of the command line argument list. For example, in the command line entered in the previous example, the <code>argv</code> array would look like <a href="ch02.xhtml#ch2fig18">Figure 2-18</a>.</p>&#13;
<span epub:type="pagebreak" id="page_126"/>&#13;
<div class="imagec" id="ch2fig18"><img alt="image" src="../images/02fig18.jpg"/></div>&#13;
<p class="figcap"><em>Figure 2-18: The <code>argv</code> parameter passed to <code>main</code> is an array of strings. Each command line argument is passed as a separate string element in the array. The value of the last element is <code>NULL</code>, signifying the end of the list of command line arguments.</em></p>&#13;
<p class="indent">The strings in an <code>argv</code> array are <em>immutable</em>, meaning that they are stored in read-only memory. As a result, if a program wants to modify the value of one of its command line arguments, it needs to make a local copy of the command line argument and modify the copy.</p>&#13;
<p class="indent">Often, a program wants to interpret a command line argument passed to <code>main</code> as a type other than a string. In the previous example, the program may want to extract the integer value <code>10</code> from the string value <code>"10"</code> of its first command line argument. C’s standard library provides functions for converting strings to other types. For example, the <code>atoi</code> (“a to i,” for “ASCII to integer”) function converts a string of digit characters to its corresponding integer value:</p>&#13;
<pre>int x;<br/>&#13;
x = atoi(argv[1]);  // x gets the int value 10</pre>&#13;
<p class="indent">See “Functions to Convert Strings to Other Types” on <a href="ch02.xhtml#lev3_25">page 103</a> for more information about these functions, and the <code>commandlineargs.c</code> program<sup><a href="ch02.xhtml#fn2_4" id="rfn2_4">4</a></sup> for another example of C command line arguments.</p>&#13;
<h4 class="h4" id="lev2_38">2.9.3 The void * Type and Type Recasting</h4>&#13;
<p class="noindent">The C type <code>void *</code> represents a generic pointer—a pointer to any type, or a pointer to an unspecified type. C allows for a generic pointer type because memory addresses on a system are always stored in the same number of bytes (e.g., addresses are four bytes on 32-bit systems and eight bytes on 64-bit systems). As a result, every pointer variable requires the same number of storage bytes, and because they’re all the same size, the compiler can allocate space for a <code>void *</code> variable without knowing the type it points to. Here’s an example:</p>&#13;
<pre><span epub:type="pagebreak" id="page_127"/>void *gen_ptr;<br/>&#13;
int x;<br/>&#13;
char ch;<br/>&#13;
<br/>&#13;
gen_ptr = &amp;x;  // gen_ptr can be assigned the address of an int<br/>&#13;
gen_ptr = &amp;ch; // or the address of a char (or the address of any type)</pre>&#13;
<p class="indent">Typically, programmers do not declare variables of type <code>void *</code> as in the preceding example. Instead, it’s commonly used to specify generic return types from functions or generic parameters to functions. The <code>void *</code> type is often used as a return type by functions that return newly allocated memory that can be used to store any type (e.g., <code>malloc</code>). It’s also used as a function parameter for functions that can take any type of value. In this case, individual calls to the function pass in a pointer to some specific type, which can be passed to the function’s <code>void *</code> parameter because it can store the address of any type.</p>&#13;
<p class="indent">Because <code>void *</code> is a generic pointer type, it cannot be directly dereferenced—the compiler does not know the size of memory that the address points to. For example, the address could refer to an <code>int</code> storage location of four bytes or it could refer to a <code>char</code> storage location in memory of one byte. Therefore, the programmer must explicitly <em>recast</em> the <code>void *</code> pointer to a pointer of a specific type before dereferencing it. Recasting tells the compiler the specific type of pointer variable, allowing the compiler to generate the correct memory access code for pointer dereferences.</p>&#13;
<p class="indent">Here are two examples of <code>void *</code> use. First, a call to <code>malloc</code> recasts its <code>void</code> <code>*</code> return type to the specific pointer type of the variable used to store its returned heap memory address:</p>&#13;
<pre>int *array;<br/>&#13;
char *str;<br/>&#13;
<br/>&#13;
array = (int *)malloc(sizeof(int) * 10); // recast void * return value<br/>&#13;
str = (char *)malloc(sizeof(char) * 20);<br/>&#13;
<br/>&#13;
*array = 10;<br/>&#13;
str[0] = 'a';</pre>&#13;
<p class="indent">Second, students often encounter the <code>void *</code> when creating threads (see “Hello Threading! Writing Your First Multithreaded Program” on <a href="ch14.xhtml#lev1_106">page 677</a>). Using a <code>void *</code> parameter type in a thread function allows the thread to take any type of application-specific pointer. The <code>pthread_create</code> function has a parameter for the thread main function and a <code>void *</code> parameter for the argument value that it passes to the thread main function that the newly created thread will execute. The use of the <code>void *</code> parameter makes <code>pthread_create</code> a generic thread creation function; it can be used to point to any type of memory location. For a specific program that calls <code>pthread_create</code>, the programmer knows the type of the argument passed to the <code>void *</code> parameter, so the programmer must recast it to its known type before dereferencing it. In this <span epub:type="pagebreak" id="page_128"/>example, suppose that the address passed to the <code>args</code> parameter contains the address of an integer variable:</p>&#13;
<pre>/*<br/>&#13;
 * an application-specific pthread main function<br/>&#13;
 * must have this function prototype: int func_name(void *args)<br/>&#13;
 *<br/>&#13;
 * any given implementation knows what type is really passed in<br/>&#13;
 *  args: pointer to an int value<br/>&#13;
 */<br/>&#13;
int my_thr_main(void *args) {<br/>&#13;
    int num;<br/>&#13;
<br/>&#13;
    // first recast args to an int *, then dereference to get int value<br/>&#13;
    num = *((int *)args);  // num gets 6<br/>&#13;
    ...<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int ret, x;<br/>&#13;
    pthread_t tid;<br/>&#13;
<br/>&#13;
    x = 6;<br/>&#13;
    // pass the address of int variable (x) to pthread_create's void * param<br/>&#13;
    // (we recast &amp;x as a (void *) to match the type of pthread_create's param)<br/>&#13;
    ret = pthread_create(&amp;tid, NULL,<br/>&#13;
                         my_thr_main,    // a thread main function<br/>&#13;
                         (void *)(&amp;x));  // &amp;x will be passed to my_thr_main<br/>&#13;
    // ...</pre>&#13;
<h4 class="h4" id="lev2_39">2.9.4 Pointer Arithmetic</h4>&#13;
<p class="noindent">If a pointer variable points to an array, a program can perform arithmetic on the pointer to access any of the array’s elements. In most cases, we recommend against using pointer arithmetic to access array elements: it’s easy to make errors and more difficult to debug when you do. However, occasionally it may be convenient to successively increment a pointer to iterate over an array of elements.</p>&#13;
<p class="indent">When incremented, a pointer points to the next storage location <em>of the type it points to</em>. For example, incrementing an integer pointer (<code>int *</code>) makes it point to the next <code>int</code> storage address (the address four bytes beyond its current value), and incrementing a character pointer makes it point to the next <code>char</code> storage address (the address one byte beyond its current value).</p>&#13;
<p class="indent">In the following example program, we demonstrate how to use pointer arithmetic to manipulate an array. First declare pointer variables whose type matches the array’s element type:</p>&#13;
<span epub:type="pagebreak" id="page_129"/>&#13;
<p class="margnote">pointerarith.c</p>&#13;
<pre>#define N 10<br/>&#13;
#define M 20<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    // array declarations:<br/>&#13;
    char letters[N];<br/>&#13;
    int numbers[N], i, j;<br/>&#13;
    int matrix[N][M];<br/>&#13;
<br/>&#13;
    // declare pointer variables that will access int or char array elements<br/>&#13;
    // using pointer arithmetic (the pointer type must match array element type)<br/>&#13;
    char *cptr = NULL;<br/>&#13;
    int *iptr = NULL;<br/>&#13;
    ...</pre>&#13;
<p class="indent">Next, initialize the pointer variables to the base address of the arrays over which they will iterate:</p>&#13;
<p class="margnote">pointerarith.c</p>&#13;
<pre>// make the pointer point to the first element in the array<br/>&#13;
cptr = &amp;(letters[0]); //  &amp;(letters[0])  is the address of element 0<br/>&#13;
iptr = numbers;       // the address of element 0 (numbers is &amp;(numbers[0]))</pre>&#13;
<p class="indent">Then, using pointer dereferencing, our program can access the array’s elements. Here, we’re dereferencing to assign a value to an array element and then incrementing the pointer variable by one to advance it to point to the next element:</p>&#13;
<p class="margnote">pointerarith.c</p>&#13;
<pre>// initialized letters and numbers arrays through pointer variables<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    // dereference each pointer and update the element it currently points to<br/>&#13;
    *cptr = 'a' + i;<br/>&#13;
    *iptr = i * 3;<br/>&#13;
<br/>&#13;
    // use pointer arithmetic to set each pointer to point to the next element<br/>&#13;
    cptr++;  // cptr points to the next char address (next element of letters)<br/>&#13;
    iptr++;  // iptr points to the next int address  (next element of numbers)<br/>&#13;
}</pre>&#13;
<p class="indent">Note that in this example, the pointer values are incremented inside the loop. Thus, incrementing their value makes them point to the next element in the array. This pattern effectively walks through each element of an array in the same way that accessing <code>cptr[i]</code> or <code>iptr[i]</code> at each iteration would.</p>&#13;
<span epub:type="pagebreak" id="page_130"/>&#13;
<p class="note"><strong><span class="black">Note</span> THE SEMANTICS OF POINTER ARITHMETIC AND THE UNDERLYING ARITHMETIC FUNCTION</strong></p>&#13;
<p class="note1">The semantics of pointer arithmetic are type independent: changing any type of pointer’s value by <code>N</code> (<code>ptr = ptr + N</code>) makes the pointer point <code>N</code> storage locations beyond its current value (or makes it point to <code>N</code> elements beyond the current element it points to). As a result, incrementing a pointer of any type makes it point to the very next memory location of the type it points to.</p>&#13;
<p class="note1">However, the actual arithmetic function that the compiler generates for a pointer arithmetic expression varies depending on the type of the pointer variable (depending on the number of bytes the system uses to store the type to which it points). For example, incrementing a <code>char</code> pointer will increase its value by one because the very next valid <code>char</code> address is one byte from the current location. Incrementing an <code>int</code> pointer will increase its value by four because the next valid integer address is four bytes from the current location.</p>&#13;
<p class="note1">A programmer can simply write <code>ptr++</code> to make a pointer point to the next element value. The compiler generates code to add the appropriate number of bytes for the corresponding type it points to. The addition effectively sets its value to the next valid address in memory of that type.</p>&#13;
<p class="indent">You can see how the previous code modified array elements by printing out their values (we show this first using array indexing and then using pointer arithmetic to access each array element’s value):</p>&#13;
<pre>printf("\n array values using indexing to access: \n");<br/>&#13;
// see what the code above did:<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    printf("letters[%d] = %c, numbers[%d] = %d\n",<br/>&#13;
           i, letters[i], i, numbers[i]);<br/>&#13;
}<br/>&#13;
<br/>&#13;
// we could also use pointer arith to print these out:<br/>&#13;
printf("\n array values using pointer arith to access: \n");<br/>&#13;
// first: initialize pointers to base address of arrays:<br/>&#13;
cptr = letters;  // letters == &amp;letters[0]<br/>&#13;
iptr = numbers;<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    // dereference pointers to access array element values<br/>&#13;
    printf("letters[%d] = %c, numbers[%d] = %d\n",<br/>&#13;
            i, *cptr, i, *iptr);<br/>&#13;
<br/>&#13;
    // increment pointers to point to the next element<br/>&#13;
    cptr++;<br/>&#13;
    iptr++;<br/>&#13;
}</pre>&#13;
<p class="indent">Here’s what the output looks like:</p>&#13;
<pre> array values using indexing to access:<br/>&#13;
letters[0] = a, numbers[0] = 0<br/>&#13;
letters[1] = b, numbers[1] = 3<br/>&#13;
<span epub:type="pagebreak" id="page_131"/>&#13;
letters[2] = c, numbers[2] = 6<br/>&#13;
letters[3] = d, numbers[3] = 9<br/>&#13;
letters[4] = e, numbers[4] = 12<br/>&#13;
letters[5] = f, numbers[5] = 15<br/>&#13;
letters[6] = g, numbers[6] = 18<br/>&#13;
letters[7] = h, numbers[7] = 21<br/>&#13;
letters[8] = i, numbers[8] = 24<br/>&#13;
letters[9] = j, numbers[9] = 27<br/>&#13;
<br/>&#13;
 array values using pointer arith to access:<br/>&#13;
letters[0] = a, numbers[0] = 0<br/>&#13;
letters[1] = b, numbers[1] = 3<br/>&#13;
letters[2] = c, numbers[2] = 6<br/>&#13;
letters[3] = d, numbers[3] = 9<br/>&#13;
letters[4] = e, numbers[4] = 12<br/>&#13;
letters[5] = f, numbers[5] = 15<br/>&#13;
letters[6] = g, numbers[6] = 18<br/>&#13;
letters[7] = h, numbers[7] = 21<br/>&#13;
letters[8] = i, numbers[8] = 24<br/>&#13;
letters[9] = j, numbers[9] = 27</pre>&#13;
<p class="indent">Pointer arithmetic can be used to iterate over any contiguous chunk of memory. Here’s an example using pointer arithmetic to initialize a statically declared 2D array:</p>&#13;
<pre>// sets matrix to:<br/>&#13;
// row 0:   0,   1,   2, ...,  99<br/>&#13;
// row 1: 100, 110, 120, ..., 199<br/>&#13;
//        ...<br/>&#13;
iptr = &amp;(matrix[0][0]);<br/>&#13;
for (i = 0; i &lt; N*M; i++) {<br/>&#13;
    *iptr = i;<br/>&#13;
    iptr++;<br/>&#13;
}<br/>&#13;
<br/>&#13;
// see what the code above did:<br/>&#13;
printf("\n 2D array values inited using pointer arith: \n");<br/>&#13;
for (i = 0; i &lt; N; i++) {<br/>&#13;
    for (j = 0; j &lt; M; j++) {<br/>&#13;
        printf("%3d ", matrix[i][j]);<br/>&#13;
    }<br/>&#13;
    printf("\n");<br/>&#13;
}<br/>&#13;
<br/>&#13;
return 0;<br/>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_132"/>The output will look like:</p>&#13;
<pre> 2D array values initialized using pointer arith:<br/>&#13;
  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19<br/>&#13;
 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39<br/>&#13;
 40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59<br/>&#13;
 60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79<br/>&#13;
 80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99<br/>&#13;
100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119<br/>&#13;
120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139<br/>&#13;
140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159<br/>&#13;
160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179<br/>&#13;
180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199</pre>&#13;
<p class="indent">Pointer arithmetic can access contiguous memory locations in any pattern, starting and ending anywhere in a contiguous chunk of memory. For example, after initializing a pointer to the address of an array element, its value can be changed by more than one. For example:</p>&#13;
<pre>iptr = &amp;numbers[2];<br/>&#13;
*iptr = -13;<br/>&#13;
iptr += 4;<br/>&#13;
*iptr = 9999;</pre>&#13;
<p class="indent">After executing the preceding code, printing the <code>numbers</code> array’s values would look like this (note that the values at index 2 and index 6 have changed):</p>&#13;
<pre>numbers[0] = 0<br/>&#13;
numbers[1] = 3<br/>&#13;
numbers[2] = -13<br/>&#13;
numbers[3] = 9<br/>&#13;
numbers[4] = 12<br/>&#13;
numbers[5] = 15<br/>&#13;
numbers[6] = 9999<br/>&#13;
numbers[7] = 21<br/>&#13;
numbers[8] = 24<br/>&#13;
numbers[9] = 27</pre>&#13;
<p class="indent">Pointer arithmetic works on dynamically allocated arrays, too. However, programmers must be careful working with dynamically allocated multidimensional arrays. If, for example, a program uses multiple <code>malloc</code> calls to dynamically allocate individual rows of a 2D array (see “Method 2: The Programmer-Friendly Way” on <a href="ch02.xhtml#lev3_17">page 90</a>), then the pointer must be reset to point to the address of the starting element of every row. Resetting the pointer is necessary because only elements within a row are located in contiguous memory addresses. On the other hand, if the 2D array is allocated as a single <code>malloc</code> of total rows times columns space (see “Method 1: Memory-Efficient Allocation” on <a href="ch02.xhtml#lev3_15">page 88</a>), then all the rows are in contiguous memory <span epub:type="pagebreak" id="page_133"/>(like in the statically declared 2D array from the previous example). In the latter case, the pointer only needs to be initialized to point to the base address, and then pointer arithmetic will correctly access any element in the 2D array.</p>&#13;
<h4 class="h4" id="lev2_40">2.9.5 C Libraries: Using, Compiling, and Linking</h4>&#13;
<p class="noindent">A <em>library</em> implements a collection of functions and definitions that can be used by other programs. A C library consists of two parts:</p>&#13;
<ul>&#13;
<li class="noindent">The <em>application programming interface</em> (API) to the library, which gets defined in one or more header files (<code>.h</code> files) that must be included in C source code files that plan to use the library. The headers define what the library exports to its users. These definitions usually include library function prototypes, and they may also include type, constant, or global variable declarations.</li>&#13;
<li class="noindent">The <em>implementation</em> of the library’s functionality, often made available to programs in a precompiled binary format that gets <em>linked</em> (added) into the binary executable created by <code>gcc</code>. Precompiled library code might be in an archive file (<code>libsomelib.a</code>) containing several <code>.o</code> files that can be statically linked into the executable file at compile time. Alternatively, it may consist of a shared object file (<code>libsomelib.so</code>) that can be dynamically linked at runtime into a running program.</li>&#13;
</ul>&#13;
<p class="indent">For example, the C string library implements a set of functions to manipulate C strings. The <code>string.h</code> header file defines its interface, so any program that wants to use string library functions must <code>#include &lt;string.h&gt;</code>. The implementation of the C string library is part of the larger standard C library (<code>libc</code>) that the <code>gcc</code> compiler automatically links into every executable file it creates.</p>&#13;
<p class="indent">A library’s implementation consists of one or more modules (<code>.c</code> files), and may additionally include header files that are internal to the library implementation; internal header files are not part of the library’s API but are part of well-designed, modular library code. Often the C source code implementation of a library is not exported to the user of the library. Instead, the library is made available in a precompiled binary form. These binary formats are not executable programs (they cannot be run on their own), but they provide executable code that can be <em>linked</em> into (added into) an executable file by <code>gcc</code> at compilation time.</p>&#13;
<p class="indent">There are numerous libraries available for C programmers to use. For example, the POSIX thread library (discussed in <a href="ch10.xhtml#ch10">Chapter 10</a>) enables multithreaded C programs. C programmers can also implement and use their own libraries (see “Writing and Using Your Own C Libraries” on <a href="ch02.xhtml#lev2_41">page 133</a>). Large C programs tend to use many C libraries, some of which <code>gcc</code> links implicitly, whereas others require explicit linking with the <code>-l</code> command line option to <code>gcc</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_134"/>Standard C libraries normally do not need to be explicitly linked in with the <code>-l</code> option, but other libraries do. The documentation for a library function often specifies whether the library needs to be explicitly linked in when compiling. For example, the POSIX threads library (<code>pthread</code>) and the <code>readline</code> library require explicit linking on the <code>gcc</code> command line:</p>&#13;
<pre>$ <span class="codestrong1">gcc -o myprog myprog.c -lpthread -lreadline</span></pre>&#13;
<p class="indent">Note that the full name of the library file should not be included in the <code>-l</code> argument to <code>gcc</code>; the library files are named something like <code>libpthread.so</code> or <code>libreadline.a</code>, but the <code>lib</code> prefix and <code>.so</code> or <code>.a</code> suffix of the filenames are not included. The actual library filename may also contain version numbers (e.g., <code>libreadline.so.8.0</code>), which are also not included in the <code>-l</code> command line option (<code>-lreadline</code>). By not forcing the user to specify (or even know) the exact name and location of the library files to link in, <code>gcc</code> is free to find the most recent version of a library in a user’s library path. It also allows the compiler to choose to dynamically link when both a shared object (<code>.so</code>) and an archive (<code>.a</code>) version of a library are available. If users want to statically link libraries, then they can explicitly specify static linking in the <code>gcc</code> command line. The <code>--static</code> option provides one method for requesting static linking:</p>&#13;
<pre>$ <span class="codestrong1">gcc -o myprog myprog.c --static -lpthread -lreadline</span></pre>&#13;
<h5 class="h5" id="lev3_29">Compilation Steps</h5>&#13;
<p class="noindent">Characterizing C’s program compilation steps will help to illustrate how library code gets linked into an executable binary file. We first present the compilation steps and then discuss (with examples) different types of errors that can occur when compiling programs that use libraries.</p>&#13;
<p class="indent">The C compiler translates a C source file (e.g., <code>myprog.c</code>) into an executable binary file (e.g., <code>a.out</code>) in four distinct steps (plus a fifth step that occurs at runtime).</p>&#13;
<p class="indent">The <em>precompiler</em> step runs first and expands <em>preprocessor directives</em>: the <code>#</code> directives that appear in the C program, such as <code>#define</code> and <code>#include</code>. Compilation errors at this step include syntax errors in preprocessor directives or <code>gcc</code> not finding header files associated with <code>#include</code> directives. To view the intermediate results of the precompiler step, pass the <code>-E</code> flag to <code>gcc</code> (the output can be redirected to a file that can be viewed by a text editor):</p>&#13;
<pre>$ <span class="codestrong1">gcc -E  myprog.c</span><br/>&#13;
$ <span class="codestrong1">gcc -E  myprog.c  &gt; out</span><br/>&#13;
$ <span class="codestrong1">vim out</span></pre>&#13;
<p class="indent">The <em>compile</em> step runs next and does the bulk of the compilation task. It translates the C program source code (<code>myprog.c</code>) to machine-specific assembly code (<code>myprog.s</code>). Assembly code is a human-readable form of the binary machine code instructions that a computer can execute. Compilation errors at this step include C language syntax errors, undefined symbol warnings, and errors from missing definitions and function prototypes. To view the <span epub:type="pagebreak" id="page_135"/>intermediate results of the compile step, pass the <code>-S</code> flag to <code>gcc</code> (this option creates a text file named <code>myprog.s</code> with the assembly translation of <code>myprog.c</code>, which can be viewed in a text editor):</p>&#13;
<pre>$ <span class="codestrong1">gcc -S  myprog.c</span><br/>&#13;
$ <span class="codestrong1">vim myprog.s</span></pre>&#13;
<p class="indent">The <em>assembly</em> step converts the assembly code into relocatable binary object code (<code>myprog.o</code>). The resulting object file contains machine code instructions, but it is not a complete executable program that can run on its own. The <code>gcc</code> compiler on Unix and Linux systems produces binary files in a specific format called ELF (Executable and Linkable Format).<sup><a href="ch02.xhtml#fn2_5" id="rfn2_5">5</a></sup> To stop compilation after this step, pass the <code>-c</code> flag to <code>gcc</code> (this produces a file named <code>myprog.o</code>). Binary files (e.g., <code>a.out</code> and <code>.o</code> files) can be viewed using <code>objdump</code> or similar tools for displaying binary files:</p>&#13;
<pre>$ <span class="codestrong1">gcc -c  myprog.c</span><br/>&#13;
<br/>&#13;
# disassemble functions in myprog.o with objdump:<br/>&#13;
$ <span class="codestrong1">objdump -d myprog.o</span></pre>&#13;
<p class="indent">The <em>link editing</em> step runs last and creates a single executable file (<code>a.out</code>) from relocatable binaries (<code>.o</code>) and libraries (<code>.a</code> or <code>.so</code>). In this step, the linker verifies that any references to names (symbols) in a <code>.o</code> file are present in other <code>.o</code>, <code>.a</code>, or <code>.so</code> files. For example, the linker will find the <code>printf</code> function in the standard C library (<code>libc.so</code>). If the linker cannot find the definition of a symbol, this step fails with an error stating that a symbol is undefined. Running <code>gcc</code> without flags for partial compilation performs all four steps of compiling a C source code file (<code>myprog.c</code>) to an executable binary file (<code>a.out</code>) that can be run:</p>&#13;
<pre>$ <span class="codestrong1">gcc myprog.c</span><br/>&#13;
$ <span class="codestrong1">./a.out</span><br/>&#13;
<br/>&#13;
# disassemble functions in a.out with objdump:<br/>&#13;
$ <span class="codestrong1">objdump -d a.out</span></pre>&#13;
<p class="indent">If the binary executable file (<code>a.out</code>) statically links in library code (from <code>.a</code> library files), then <code>gcc</code> embeds copies of library functions from the <code>.a</code> file in the resulting <code>a.out</code> file. All calls to library functions by the application are <em>bound</em> to the locations in the <code>a.out</code> file to which the library function is copied. Binding associates a name with a location in the program memory. For example, binding a call to a library function named <code>gofish</code> means replacing the use of the function name with the address in memory of the function (in later chapters we discuss memory addresses in more detail—see, for example, “Memory Addresses” on <a href="ch13.xhtml#lev2_227">page 642</a>).</p>&#13;
<p class="indent">If, however, the <code>a.out</code> was created by dynamically linking a library (from library shared object, <code>.so</code>, files), then <code>a.out</code> does not contain a copy of the library function code from these libraries. Instead, it contains information <span epub:type="pagebreak" id="page_136"/>about which dynamically linked libraries are needed by the <code>a.out</code> file to run it. Such executables require an additional linking step at runtime.</p>&#13;
<p class="indent">The <em>runtime linking</em> step is needed if <code>a.out</code> was linked with shared object files during link editing. In such cases, the dynamic library code (in <code>.so</code> files) must be loaded at runtime and linked with the running program. This runtime loading and linking of shared object libraries is called <em>dynamic linking</em>. When a user runs an <code>a.out</code> executable with shared object dependencies, the system performs dynamic linking before the program begins executing its <code>main</code> function.</p>&#13;
<p class="indent">The compiler adds information about shared object dependencies into the <code>a.out</code> file during the link editing compilation step. When the program starts executing, the dynamic linker examines the list of shared object dependencies and finds and loads the shared object files into the running program. It then updates relocation table entries in the <code>a.out</code> file, binding the program’s use of symbols in shared objects (such as calls to library functions) to their locations in the <code>.so</code> file loaded at runtime. Runtime linking reports errors if the dynamic linker cannot find a shared object (<code>.so</code>) file needed by the executable.</p>&#13;
<p class="indent">The <code>ldd</code> utility lists an executable file’s shared object dependencies:</p>&#13;
<pre>$ <span class="codestrong1">ldd a.out</span></pre>&#13;
<p class="indent">The <em>GNU debugger (GDB)</em> can examine a running program and show which shared object code is loaded and linked at runtime. We cover GDB in <a href="ch03.xhtml#ch03">Chapter 3</a>. However, the details of examining the Procedure Lookup Table (PLT), which is used for runtime linking of calls to dynamically linked library functions, is beyond the scope of this textbook.</p>&#13;
<p class="indent">More details about the phases of compilation and about tools for examining different phases can be found online.<sup><a href="ch02.xhtml#fn2_6" id="rfn2_6">6</a></sup></p>&#13;
<h5 class="h5" id="lev3_30">Common Compilation Errors Related to Compiling and Linking Libraries</h5>&#13;
<p class="noindent">Several compilation and linking errors can occur due to the programmer forgetting to include library header files or forgetting to explicitly link in library code. Identifying the <code>gcc</code> compiler error or warning associated with each of these errors will help in debugging errors related to using C libraries.</p>&#13;
<p class="indent">Consider this next C program that makes a call to a function <code>libraryfunc</code> from the <code>examplelib</code> library (available as a shared object file, <code>libmylib.so</code>):</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;examplelib.h&gt;<br/>&#13;
<br/>&#13;
int main(int argc, char *argv[]) {<br/>&#13;
    int result;<br/>&#13;
    result = libraryfunc(6, MAX);<br/>&#13;
    printf("result is %d\n", result);<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_137"/>Assume that the header file, <code>examplelib.h</code>, contains the definitions in the following example:</p>&#13;
<pre>#define MAX 10   // a constant exported by the library<br/>&#13;
<br/>&#13;
// a function exported by the library<br/>&#13;
extern int libraryfunc(int x, int y);</pre>&#13;
<p class="indent">The <code>extern</code> prefix to the function prototype means that the function’s definition comes from another file—it’s not in the <code>examplelib.h</code> file, but instead it’s provided by one of the <code>.c</code> files in the library’s implementation.</p>&#13;
<p class="noindentt"><strong>Forgetting to include a header file.</strong> If the programmer forgets to include <code>examplelib.h</code> in their program, then the compiler produces warnings and errors about the program’s use of library functions and constants that it does not know about. For example, if the user compiles their program without <code>#include &lt;examplelib.h&gt;</code>, <code>gcc</code> will produce the following output:</p>&#13;
<pre># '-g': add debug information, -c: compile to '.o'<br/>&#13;
$ <span class="codestrong1">gcc -g -c myprog.c</span><br/>&#13;
<br/>&#13;
myprog.c: In function main:<br/>&#13;
myprog.c:8:12: warning: implicit declaration of function libraryfunc<br/>&#13;
   result = libraryfunc(6, MAX);<br/>&#13;
            ^~~~~~~~~~~<br/>&#13;
<br/>&#13;
myprog.c:8:27: error: MAX undeclared (first use in this function)<br/>&#13;
   result = libraryfunc(6, MAX);<br/>&#13;
                           ^~~</pre>&#13;
<p class="indent">The first compiler warning (<code>implicit declaration of function</code> <code>libraryfunc</code>) tells the programmer that the compiler cannot find a function prototype for the <code>libraryfunc</code> function. This is just a compiler warning because <code>gcc</code> will guess that the function’s return type is an integer and will continue compiling the program. However, programmers should <em>not</em> ignore such warnings! They indicate that the program isn’t including a function prototype before its use in the <code>myprog.c</code> file, which is often due to not including a header file that contains the function prototype.</p>&#13;
<p class="indent">The second compiler error (<code>MAX undeclared (first use in this</code> <code>function)</code>) follows from a missing constant definition. The compiler cannot guess at the value of the missing constant, so this missing definition fails with an error. This type of “undeclared” message often indicates that a header file defining a constant or global variable is missing or hasn’t been properly included.</p>&#13;
<p class="noindentt"><strong>Forgetting to link a library.</strong> If the programmer includes the library header file (as shown in the previous listing), but forgets to explicitly link in the library during the link editing step of compilation, then <code>gcc</code> indicates this with an “undefined reference” error:</p>&#13;
<pre><span epub:type="pagebreak" id="page_138"/>$ <span class="codestrong1">gcc -g myprog.c</span><br/>&#13;
<br/>&#13;
In function main:<br/>&#13;
myprog.c:9: undefined reference to libraryfunc<br/>&#13;
collect2: error: ld returned 1 exit status</pre>&#13;
<p class="indent">This error originates from <code>ld</code>, the linker component of the compiler. It indicates that the linker cannot find the implementation of the library function <code>libraryfunc</code> that gets called at line 9 in <code>myprog.c</code>. An “undefined reference” error indicates that a library needs to be explicitly linked into the executable. In this example, specifying <code>-lexamplelib</code> on the <code>gcc</code> command line will fix the error:</p>&#13;
<pre>$ <span class="codestrong1">gcc -g myprog.c  -lexamplelib</span></pre>&#13;
<p class="noindentt"><strong>gcc can’t find header or library files.</strong> Compilation will also fail with errors if a library’s header or implementation files are not present in the directories that <code>gcc</code> searches by default. For example, if <code>gcc</code> cannot find the <code>examplelib.h</code> file, it will produce an error message like this:</p>&#13;
<pre>$ <span class="codestrong1">gcc -c myprog.c -lexamplelib</span><br/>&#13;
myprog.c:1:10: fatal error: examplelib.h: No such file or directory<br/>&#13;
 #include &lt;examplelib.h&gt;<br/>&#13;
          ^~~~~~~<br/>&#13;
<br/>&#13;
compilation terminated.</pre>&#13;
<p class="indent">If the linker cannot find a <code>.a</code> or <code>.so</code> version of the library to link in during the link editing step of compilation, <code>gcc</code> will exit with an error like the following:</p>&#13;
<pre>$ <span class="codestrong1">gcc -c myprog.c -lexamplelib</span><br/>&#13;
/usr/bin/ld: cannot find -lexamplelib<br/>&#13;
collect2: error: ld returned 1 exit status</pre>&#13;
<p class="indent">Similarly, if a dynamically linked executable cannot locate a shared object file (e.g., <code>libexamplelib.so</code>), it will fail to execute at runtime with an error like the following:</p>&#13;
<pre>$ <span class="codestrong1">./a.out</span><br/>&#13;
./a.out: error while loading shared libraries:<br/>&#13;
   libexamplelib.so: cannot open shared object file: No such file or directory</pre>&#13;
<p class="indent">To resolve these types of errors, programmers must specify additional options to <code>gcc</code> to indicate where the library’s files can be found. They may also need to modify the <code>LD_LIBRARY_PATH</code> environment variable for the runtime linker to find a library’s <code>.so</code> file.</p>&#13;
<h5 class="h5" id="lev3_31"><span epub:type="pagebreak" id="page_139"/>Library and Include Paths</h5>&#13;
<p class="noindent">The compiler automatically searches in standard directory locations for header and library files. For example, systems commonly store standard header files in <code>/usr/include</code>, and library files in <code>/usr/lib</code>, and <code>gcc</code> automatically looks for headers and libraries in these directories; <code>gcc</code> also automatically searches for header files in the current working directory.</p>&#13;
<p class="indent">If <code>gcc</code> cannot find a header or a library file, then the user must explicitly provide paths on the command line using <code>-I</code> and <code>-L</code>. For example, suppose that a library named <code>libexamplelib.so</code> exists in <code>/home/me/lib</code>, and its header file <code>examplelib.h</code> is in <code>/home/me/include</code>. Because <code>gcc</code> knows nothing of those paths by default, it must be explicitly told to include files there to successfully compile a program that uses this library:</p>&#13;
<pre>$ <span class="codestrong1">gcc  -I/home/me/include -o myprog myprog.c -L/home/me/lib -lexamplelib</span></pre>&#13;
<p class="indent">To specify the location of a dynamic library (e.g., <code>libexamplelib.so</code>) when launching a dynamically linked executable, set the <code>LD_LIBRARY_PATH</code> environment variable to include the path to the library. Here’s an example bash command that can be run at a shell prompt or added to a <code>.bashrc</code> file:</p>&#13;
<pre>export LD_LIBRARY_PATH=/home/me/lib:$LD_LIBRARY_PATH</pre>&#13;
<p class="indent">When the <code>gcc</code> command lines get long, or when an executable requires many source and header files, it helps to simplify compilation by using <code>make</code> and a <code>Makefile</code>.<sup><a href="ch02.xhtml#fn2_7" id="rfn2_7">7</a></sup></p>&#13;
<h4 class="h4" id="lev2_41">2.9.6 Writing and Using Your Own C Libraries</h4>&#13;
<p class="noindent">Programmers typically divide large C programs into separate <em>modules</em> (i.e., separate <code>.c</code> files) of related functionality. Definitions shared by more than one module are put in header files (<code>.h</code> files) that are included by the modules that need them. Similarly, C library code is also implemented in one or more modules (<code>.c</code> files) and one or more header files (<code>.h</code> files). C programmers often implement their own C libraries of commonly used functionality. By writing a library, a programmer implements the functionality once, in the library, and then can use this functionality in any subsequent C program that they write.</p>&#13;
<p class="indent">In “C Libraries: Using, Compiling, and Linking” on <a href="ch02.xhtml#lev2_40">page 133</a>, we describe how to use, compile, and link C library code into C programs. In this section, we discuss how to write and use your own libraries in C. What we present here also applies to structuring and compiling larger C programs composed of multiple C source and header files.</p>&#13;
<p class="indent">To create a library in C:</p>&#13;
<div class="number">&#13;
<p class="number">1. Define an interface to the library in a header (<code>.h</code>) file. This header file must be included by any program that wants to use the library.</p>&#13;
<p class="number">2. Create an implementation of the library in one or more <code>.c</code> files. This set of function definitions implement the library’s functionality. Some functions may be interface functions that users of the <span epub:type="pagebreak" id="page_140"/>library will call, and others may be internal functions that cannot be called by users of the library (internal functions are part of good modular design of the library’s implementation).</p>&#13;
<p class="number">3. Compile a binary form of the library that can be linked into programs that use the library.</p>&#13;
</div>&#13;
<p class="indent">The binary form of a library could be directly built from its source file(s) as part of compiling the application code that uses the library. This method compiles the library files into <code>.o</code> files and statically links them into the binary executable. Including libraries this way often applies to library code that you write for your own use (since you have access to its <code>.c</code> source files), and it’s also the method to build an executable from multiple <code>.c</code> modules.</p>&#13;
<p class="indent">Alternatively, a library could be compiled into a binary archive (<code>.a</code>) or a shared object (<code>.so</code>) file for programs that want to use the library. In these cases, users of the library often will not have access to the library’s C source code files, and thus they are not able to directly compile the library code with application code that uses it. When a program uses such a precompiled library (e.g., a <code>.a</code> or <code>.so</code>), the library’s code must be explicitly linked into the executable file using <code>gcc</code>’s <code>-l</code> command line option.</p>&#13;
<p class="indent">We focus our detailed discussion of writing, compiling, and linking library code on the case in which the programmer has access to individual library modules (either the <code>.c</code> or <code>.o</code> files). This focus also applies to designing and compiling large C programs that are divided into multiple <code>.c</code> and <code>.h</code> files. We briefly show commands for building archive and shared object forms of libraries. More information about building these types of library files is available in the <code>gcc</code> documentation, including the man pages for <code>gcc</code> and <code>ar</code>.</p>&#13;
<p class="indent">In the following, we show some examples of creating and using your own libraries.</p>&#13;
<p class="noindentt"><strong>Define the library interface</strong> Header files (<code>.h</code> file) are text files that contain C function prototypes and other definitions—they represent the interface of a library. A header file must be included in any application that intends to use the library. For example, the C standard library header files are usually stored in <code>/usr/include/</code> and can be viewed with an editor:</p>&#13;
<pre>$ <span class="codestrong1">vi /usr/include/stdio.h</span></pre>&#13;
<p class="indent">Here’s an example header file<sup><a href="ch02.xhtml#fn2_8" id="rfn2_8">8</a></sup> from a library that contains some definitions for users of the library:</p>&#13;
<p class="margnote">myfile.h</p>&#13;
<pre>#ifndef _MYLIB_H_<br/>&#13;
#define _MYLIB_H_<br/>&#13;
<br/>&#13;
// a constant definition exported by library:<br/>&#13;
#define MAX_FOO  20<br/>&#13;
<br/>&#13;
// a type definition exported by library:<br/>&#13;
<span epub:type="pagebreak" id="page_141"/>&#13;
struct foo_struct {<br/>&#13;
    int x;<br/>&#13;
    float y;<br/>&#13;
};<br/>&#13;
<br/>&#13;
// a global variable exported by library<br/>&#13;
// "extern" means that this is not a variable declaration,<br/>&#13;
// but it defines that a variable named total_times of type<br/>&#13;
// int exists in the library implementation and is available<br/>&#13;
// for use by programs using the library.<br/>&#13;
// It is unusual for a library to export global variables<br/>&#13;
// to its users, but if it does, it is important that<br/>&#13;
// extern appears in the definition in the .h file<br/>&#13;
extern int total_times;<br/>&#13;
<br/>&#13;
// a function prototype for a function exported by library:<br/>&#13;
// extern means that this function definition exists<br/>&#13;
// somewhere else.<br/>&#13;
/*<br/>&#13;
 * This function returns the larger of two float values<br/>&#13;
 *  y, z: the two values<br/>&#13;
 *  returns the value of the larger one<br/>&#13;
 */<br/>&#13;
extern float bigger(float y, float z);<br/>&#13;
<br/>&#13;
#endif</pre>&#13;
<p class="indent">Header files typically have special “boilerplate” code around their contents. For example:</p>&#13;
<pre>#ifndef <span class="codeitalic1">&lt;identifier&gt;</span><br/>&#13;
<br/>&#13;
// header file contents<br/>&#13;
<br/>&#13;
#endif <span class="codeitalic1">&lt;identifier&gt;</span></pre>&#13;
<p class="indent">This boilerplate code ensures that the compiler’s preprocessor only includes the contents of <code>mylib.h</code> exactly once in any C file that includes it. It is important to include <code>.h</code> file contents only once to avoid duplicate definition errors at compile time. Similarly, if you forget to include a <code>.h</code> file in a C program that uses the library, the compiler will generate an “undefined symbol” warning.</p>&#13;
<p class="indent">The comments in the <code>.h</code> file are part of the interface to the library, written for users of the library. These comments should be verbose, explaining definitions and describing what each library function does, what parameter values it takes, and what it returns. Sometimes a <code>.h</code> file will also include a top-level comment describing how to use the library.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_142"/>The keyword <code>extern</code> before the global variable definition and function prototype means that these names are defined somewhere else. It is particularly important to include <code>extern</code> before any global variables that the library exports, as it distinguishes a name and type definition (in the <code>.h</code> file) from a variable declaration in the library’s implementation. In the previous example, the global variable is declared exactly once inside the library, but it’s exported to library users through its <code>extern</code> definition in the library’s <code>.h</code> file.</p>&#13;
<p class="noindentt"><strong>Implement the library functionality.</strong> Programmers implement libraries in one or more <code>.c</code> files (and sometimes internal <code>.h</code> files). The implementation includes definitions of all the function prototypes in the <code>.h</code> file as well as other functions that are internal to its implementation. These internal functions are often defined with the keyword <code>static</code>, which scopes their availability to the module (<code>.c</code> file) in which they are defined. The library implementation should also include variable definitions for any <code>extern</code> global variable declarations in the <code>.h</code> file. Here’s an example library implementation:</p>&#13;
<p class="margnote">mylib.c</p>&#13;
<pre>#include &lt;stdlib.h&gt;<br/>&#13;
<br/>&#13;
// Include the library header file if the implementation needs<br/>&#13;
// any of its definitions (types or constants, for example.)<br/>&#13;
// Use " " instead of &lt; &gt; if the mylib.h file is not in a<br/>&#13;
// default library path with other standard library header<br/>&#13;
// files (the usual case for library code you write and use.)<br/>&#13;
#include "mylib.h"<br/>&#13;
<br/>&#13;
// declare the global variable exported by the library<br/>&#13;
int total_times = 0;<br/>&#13;
<br/>&#13;
// include function definitions for each library function:<br/>&#13;
float bigger(float y, float z) {<br/>&#13;
    total_times++;<br/>&#13;
    if (y &gt; z) {<br/>&#13;
        return y;<br/>&#13;
    }<br/>&#13;
    return z;<br/>&#13;
}</pre>&#13;
<p class="noindentt"><strong>Create a binary form of the library.</strong> To create a binary form of the library (a <code>.o</code> file), compile with the <code>-c</code> option:</p>&#13;
<pre>$ <span class="codestrong1">gcc -o mylib.o -c mylib.c</span></pre>&#13;
<p class="indent">One or more <code>.o</code> files can build an archive (<code>.a</code>) or shared object (<code>.so</code>) version of the library. To build a static library use the archiver (<code>ar</code>):</p>&#13;
<pre>$ <span class="codestrong1">ar -rcs libmylib.a mylib.o</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_143"/>To build a dynamically linked library, the <code>mylib.o</code> object file(s) in the library must be built with <em>position independent code</em> (using <code>-fPIC</code>). A <code>libmylib.so</code> shared object file can be created from <code>mylib.o</code> by specifying the <code>-shared</code> flag to <code>gcc</code>:</p>&#13;
<pre>$ <span class="codestrong1">gcc -fPIC -o mylib.o -c mylib.c</span><br/>&#13;
$ <span class="codestrong1">gcc -shared -o libmylib.so mylib.o</span></pre>&#13;
<p class="indent">Shared object and archive libraries are often built from multiple <code>.o</code> files, for example (remember that <code>.o</code> for dynamically linked libraries need to be built using the <code>-fPIC</code> flag):</p>&#13;
<pre>$ <span class="codestrong1">gcc -shared -o libbiglib.so file1.o file2.o file3.o file4.o</span><br/>&#13;
$ <span class="codestrong1">ar -rcs libbiglib.a file1.o file2.o file3.o file4.o</span></pre>&#13;
<p class="noindentt"><strong>Use and link the library.</strong> Other <code>.c</code> files that use this library should <code>#include</code> its header file, and the implementation (<code>.o</code> file) should be explicitly linked during compilation.</p>&#13;
<p class="indent">After including the library header file, your code then can call the library’s functions:</p>&#13;
<p class="margnote">myprog.c</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include "mylib.h"   // include library header file<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    float val1, val2, ret;<br/>&#13;
    printf("Enter two float values: ");<br/>&#13;
    scanf("%f%f", &amp;val1, &amp;val2);<br/>&#13;
    ret = bigger(val1, val2);   // use a library function<br/>&#13;
    printf("%f is the biggest\n", ret);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="note"><strong><span class="black">Note</span> #INCLUDE SYNTAX AND THE PREPROCESSOR</strong></p>&#13;
<p class="note1">The <code>#include</code> syntax to include <code>mylib.h</code> is different from the syntax to include <code>stdio.h</code>. This is because <code>mylib.h</code> is not located with the header files from standard libraries. The preprocessor has default places it looks for standard header files. When including a file with the <code>&lt;file.h&gt;</code> syntax instead of the <code>"file.h"</code> syntax, the preprocessor searches for the header file in those standard places.</p>&#13;
<p class="note1"><span epub:type="pagebreak" id="page_144"/>When <code>mylib.h</code> is included inside double quotes, the preprocessor first looks in the current directory for the <code>mylib.h</code> file, and then other places that you need to explicitly tell it to look, by specifying an include path (<code>-I</code>) to <code>gcc</code>. For example, if the header file is in the <code>/home/me/myincludes</code> directory (and not in the same directory as the <code>myprog.c</code> file), then the path to this directory must be specified in the <code>gcc</code> command line for the preprocessor to find the <code>mylib.h</code> file:</p>&#13;
<p class="programsn">$ <span class="codestrong1">gcc -I/home/me/myincludes -c myprog.c</span></p>&#13;
<p class="indent">To compile a program (<code>myprog.c</code>) that uses the library (<code>mylib.o</code>) into a binary executable:</p>&#13;
<pre>$ <span class="codestrong1">gcc -o myprog myprog.c mylib.o</span></pre>&#13;
<p class="indent">Or, if the library’s implementation files are available at compile time, then the program can be built directly from the program and library <code>.c</code> files:</p>&#13;
<pre>$ <span class="codestrong1">gcc -o myprog myprog.c mylib.c</span></pre>&#13;
<p class="indent">Or, if the library is available as an archive or shared object file, then it can be linked in using <code>-l</code> (<code>-lmylib</code>: note that the library name is <code>libmylib.[a,so]</code>, but only the <code>mylib</code> part is included in the <code>gcc</code> command line):</p>&#13;
<pre>$ <span class="codestrong1">gcc -o myprog myprog.c -L. -lmylib</span></pre>&#13;
<p class="indent">The <code>-L.</code> option specifies the path to the <code>libmylib.[so,a]</code> files (the <code>.</code> after the <code>-L</code> indicates that it should search the current directory). By default, <code>gcc</code> will dynamically link a library if it can find a <code>.so</code> version. See “C Libraries: Using, Compiling, and Linking” on <a href="ch02.xhtml#lev2_40">page 133</a> for more information about linking and link paths.</p>&#13;
<p class="indent">The program can then be run:</p>&#13;
<pre>$ <span class="codestrong1">./myprog</span></pre>&#13;
<p class="indent">If you run the dynamically linked version of <code>myprog</code>, you may encounter an error that looks like this:</p>&#13;
<pre>/usr/bin/ld: cannot find -lmylib<br/>&#13;
collect2: error: ld returned 1 exit status</pre>&#13;
<p class="indent">This error is saying that the runtime linker cannot find <code>libmylib.so</code> at runtime. To fix this problem, set your <code>LD_LIBRARY_PATH</code> environment variable to include the path to the <code>libmylib.so</code> file. Subsequent runs of <code>myprog</code> use the path you add to <code>LD_LIBRARY_PATH</code> to find the <code>libmylib.so</code> file and load it at runtime. For example, if <code>libmylib.so</code> is in the <code>/home/me/mylibs/</code> subdirectory, run this (just once) at the bash shell prompt to set the <code>LD_LIBRARY_PATH</code> environment variable:</p>&#13;
<pre>$ <span class="codestrong1">export LD_LIBRARY_PATH=/home/me/mylibs:$LD_LIBRARY_PATH</span></pre>&#13;
<h4 class="h4" id="lev2_42"><span epub:type="pagebreak" id="page_145"/>2.9.7 Compiling C to Assembly, and Compiling and Linking Assembly and C Code</h4>&#13;
<p class="noindent">A compiler can compile C code to assembly code, and it can compile assembly code into a binary form that links into a binary executable program. We use IA32 assembly and <code>gcc</code> as our example assembly language and compiler, but this functionality is supported by any C compiler, and most compilers support compiling to a number of different assembly languages. See <a href="ch08.xhtml#ch08">Chapter 8</a> for details about assembly code and assembly programming.</p>&#13;
<p class="indent">Consider this very simple C program:</p>&#13;
<p class="margnote">simpleops.c</p>&#13;
<pre>int main() {<br/>&#13;
    int x, y;<br/>&#13;
    x = 1;<br/>&#13;
    x = x + 2;<br/>&#13;
    x = x - 14;<br/>&#13;
    y = x*100;<br/>&#13;
    x = x + y * 6;<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">The <code>gcc</code> compiler will compile it into an IA32 assembly text file (<code>.s</code>) using the <code>-S</code> command line option to specify compiling to assembly and the <code>-m32</code> command line option to specify generating IA32 assembly:</p>&#13;
<pre>$ <span class="codestrong1">gcc -m32 -S simpleops.c</span>   # runs the assembler to create a .s text file</pre>&#13;
<p class="indent">This command creates a file named <code>simpleops.s</code> with the compiler’s IA32 assembly translation of the C code. Because the <code>.s</code> file is a text file, a user can view it (and edit it) using any text editor. For example:</p>&#13;
<pre>$ <span class="codestrong1">vim simpleops.s</span></pre>&#13;
<p class="indent">Passing additional compiler flags provides directions to <code>gcc</code> that it should use certain features or optimizations in its translation of C to IA32 assembly code.</p>&#13;
<p class="indent">An assembly code file, either one generated from <code>gcc</code> or one written by hand by a programmer, can be compiled by <code>gcc</code> into binary machine code form using the <code>-c</code> option:</p>&#13;
<pre>$ <span class="codestrong1">gcc -m32 -c simpleops.s</span>   # compiles to a relocatable object binary file (.o)</pre>&#13;
<p class="indent">The resulting <code>simpleops.o</code> file can then be linked into a binary executable file (note: this requires that the 32-bit version of the system libraries are installed on your system):</p>&#13;
<pre>$ <span class="codestrong1">gcc -m32 -o simpleops simpleops.o</span>  # creates a 32-bit executable file</pre>&#13;
<p class="indent">This command creates a binary executable file, <code>simpleops</code>, for IA32 (and x86-64) architectures.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_146"/>The <code>gcc</code> command line to build an executable file can include <code>.o</code> and <code>.c</code> files that will be compiled and linked together to create the single binary executable.</p>&#13;
<p class="indent">Systems provide utilities that allow users to view binary files. For example, <code>objdump</code> displays the machine code and assembly code mappings in <code>.o</code> files:</p>&#13;
<pre>$ <span class="codestrong1">objdump -d simpleops.o</span></pre>&#13;
<p class="indent">This output can be compared to the assembly file:</p>&#13;
<pre>$ <span class="codestrong1">cat simpleops.s</span></pre>&#13;
<p class="indent">You should see something like this (we’ve annotated some of the assembly code with its corresponding code from the C program):</p>&#13;
<pre>        .file   "simpleops.c"<br/>&#13;
        .text<br/>&#13;
        .globl main<br/>&#13;
        .type   main, @function<br/>&#13;
main:<br/>&#13;
        pushl   %ebp<br/>&#13;
        movl    %esp, %ebp<br/>&#13;
        subl    $16, %esp<br/>&#13;
        movl    $1, -8(%ebp)      # x = 1<br/>&#13;
        addl    $2, -8(%ebp)      # x = x + 2<br/>&#13;
        subl    $14, -8(%ebp)     # x = x - 14<br/>&#13;
        movl    -8(%ebp), %eax    # load x into R[%eax]<br/>&#13;
        imull   $100, %eax, %eax  # into R[%eax] store result of x*100<br/>&#13;
        movl    %eax, -4(%ebp)    # y = x*100<br/>&#13;
        movl    -4(%ebp), %edx<br/>&#13;
        movl    %edx, %eax<br/>&#13;
        addl    %eax, %eax<br/>&#13;
        addl    %edx, %eax<br/>&#13;
        addl    %eax, %eax<br/>&#13;
        addl    %eax, -8(%ebp)<br/>&#13;
        movl    $0, %eax<br/>&#13;
        leave<br/>&#13;
        ret<br/>&#13;
        .size   main, .-main<br/>&#13;
        .ident "GCC: (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0"<br/>&#13;
        .section .note.GNU-stack,"",@progbits</pre>&#13;
<h5 class="h5" id="lev3_32">Writing and Compiling Assembly Code</h5>&#13;
<p class="noindent">Programmers can write their own assembly code by hand and compile it with <code>gcc</code> into a binary executable program. For example, to implement a function in assembly, add code to a <code>.s</code> file and use <code>gcc</code> to compile it. The following example shows the basic structure of a function in IA32 assembly. <span epub:type="pagebreak" id="page_147"/>Such code would be written in a file (e.g., <code>myfunc.s</code>) for a function with the prototype <code>int myfunc(int param);</code>. Functions with more parameters or needing more space for local variables may differ slightly in their preamble code.</p>&#13;
<pre>        .text                   # this file contains instruction code<br/>&#13;
.globl myfunc                   # myfunc is the name of a function<br/>&#13;
        .type   myfunc, @function<br/>&#13;
myfunc:                         # the start of the function<br/>&#13;
        pushl   %ebp            # function preamble:<br/>&#13;
        movl    %esp, %ebp      #  the 1st three instrs set up the stack<br/>&#13;
        subl    $16, %esp<br/>&#13;
<br/>&#13;
        # A programmer adds specific IA32 instructions<br/>&#13;
        # here that allocate stack space for any local variables<br/>&#13;
        # and then implements code using parameters and locals to<br/>&#13;
        # perform the functionality of the myfunc function<br/>&#13;
        #<br/>&#13;
        # the return value should be stored in %eax before returning<br/>&#13;
<br/>&#13;
        leave    # function return code<br/>&#13;
        ret</pre>&#13;
<p class="indent">A C program that wanted to call this function would need to include its function prototype:</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int myfunc(int param);<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int ret;<br/>&#13;
<br/>&#13;
    ret = myfunc(32);<br/>&#13;
    printf("myfunc(32) is %d\n", ret);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">The following <code>gcc</code> commands build an executable file (<code>myprog</code>) from <code>myfunc.s</code> and <code>main.c</code> source files:</p>&#13;
<pre>$ <span class="codestrong1">gcc -m32 -c myfunc.s</span><br/>&#13;
$ <span class="codestrong1">gcc -m32 -o myprog myfunc.o main.c</span></pre>&#13;
<div class="g-box">&#13;
<p class="box-title"><span epub:type="pagebreak" id="page_148"/>HANDWRITTEN ASSEMBLY CODE</p>&#13;
<p class="noindentt">Unlike C, which is a high-level language that can be compiled and run on a wide variety of systems, assembly code is very low level and specific to a particular hardware architecture. Programmers may handwrite assembly code for low-level functions or for code sequences that are crucial to the performance of their software. A programmer can sometimes write assembly code that runs faster than the compiler-optimized assembly translation of C, and sometimes a C programmer wants to access low-level parts of the underlying architecture (such as specific registers) in their code. Small parts of operating system code are often implemented in assembly code for these reasons. However, because C is a portable language and is much higher level than assembly languages, the vast majority of operating system code is written in C, relying on good optimizing compilers to produce machine code that performs well.</p>&#13;
<p class="noindentt">Although most systems programmers rarely write assembly code, being able to read and understand a program’s assembly code is an important skill for obtaining a deeper understanding of what a program does and how it gets executed. It can also help with understanding a program’s performance and with discovering and understanding security vulnerabilities in programs.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_18">2.10 Summary</h3>&#13;
<p class="noindent">In this chapter, we covered the C programming language in depth and discussed some advanced C programming topics, as well. In the next chapter, we present two very helpful C debugging tools: the GNU GDB debugger for general-purpose C program debugging, and the Valgrind memory debugger for finding memory access errors in C programs. Equipped with these programming tools and knowledge of the core C programming language presented in this chapter, a C programmer can design powerful, efficient, and robust software.</p>&#13;
<h3 class="h3" id="lev1_19">Notes</h3>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_1" id="fn2_1">1.</a> <em><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf">http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_2" id="fn2_2">2.</a> <em><a href="https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c">https://diveintosystems.org/book/C2-C_depth/_attachments/strtokexample.c</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_3" id="fn2_3">3.</a> <em><a href="http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html">http://www.cs.swarthmore.edu/~newhall/unixhelp/man.html</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_4" id="fn2_4">4.</a> <em><a href="https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c">https://diveintosystems.org/book/C2-C_depth/_attachments/commandlineargs.c</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_5" id="fn2_5">5.</a> <em><a href="https://wikipedia.org/wiki/Executable_and_Linkable_Format">https://wikipedia.org/wiki/Executable_and_Linkable_Format</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_6" id="fn2_6">6.</a> <em><a href="http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html">http://www.cs.swarthmore.edu/~newhall/unixhelp/compilecycle.html</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_7" id="fn2_7">7.</a> <em><a href="https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html">https://www.cs.swarthmore.edu/~newhall/unixhelp/howto<sub>m</sub>akefiles.html</a></em></p>&#13;
<p class="fnote"><a href="ch02.xhtml#rfn2_8" id="fn2_8">8.</a> <em><a href="https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h">https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h</a></em></p>&#13;
</body></html>