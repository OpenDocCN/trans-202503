- en: '23'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CURVES, SURFACES, AND VOLUMES
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Electrodynamics is a geometric subject. Curves, surfaces, and volumes play a
    dual role in electromagnetic theory. They serve as the places where electric charge
    and current can reside, and they play an essential role in the formulation of
    the Maxwell equations, the modern expression of how electric and magnetic fields
    are created and how they evolve in time.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can explore the Maxwell equations, we’ll need data types for curves,
    surfaces, and volumes—we’ll build them in this chapter. A curve can be specified
    by giving a function from a single real parameter to a position in space. A surface
    can be specified as a function from a pair of real numbers to a position in space.
    A volume can be specified as a function from a triple of numbers to a position
    in space. These mathematical parameterizations lead naturally to data type definitions.
    We’ll package the parameterizations with appropriate boundaries to form the types
    `Curve`, `Surface`, and `Volume`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with some introductory code.
  prefs: []
  type: TYPE_NORMAL
- en: Introductory Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 23-1](ch23.xhtml#ch23list1) shows the introductory code for the `Geometry`
    module we’ll develop in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 23-1: Opening lines of code for the Geometry module*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the type `Position` and the related functions we defined in the `CoordinateSystems`
    module in [Chapter 22](ch22.xhtml), so we’ve imported these and a few types and
    functions from the `SimpleVec` module of [Chapter 10](ch10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Our first geometric objects are one-dimensional curves embedded in three-dimensional
    space.
  prefs: []
  type: TYPE_NORMAL
- en: Curves
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Curves have two distinct uses in electromagnetic theory. First, we use them
    to describe the place that electric charge and current live. Current in a wire
    can flow along a curve. Static charge can also be placed along a curve.
  prefs: []
  type: TYPE_NORMAL
- en: The second place we use them is in Ampere’s law, which asserts a relationship
    between the magnetic field along a closed curve in space (a loop) and the electric
    current that flows through a surface with the closed curve as its boundary. This
    second use of curves is more abstract since the curve doesn’t need to be the location
    of any actual material, but it’s also more important for a deep understanding
    of modern electromagnetic theory.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing Curves
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'How can we describe a curve in space? We can parameterize the curve so there’s
    a real number associated with each point on the curve and then give (by way of
    a function) the position in space associated with each value of the parameter.
    For example, a line along the y-axis could be parameterized with the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/450equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A circle with radius 2 in the xy-plane centered at the origin could be parameterized
    with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/450equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In these functions, *t* serves only as the name of a parameter (we could have
    chosen *s* or any convenient symbol) and has nothing to do with time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A parameterized curve therefore requires a function with type `R ->` `Position`
    sending a parameter `t :: R` along the curve to a point `r :: Position` in space.
    But we also need starting and ending points for our curve. For example, the circle
    in the xy-plane with radius 2 centered at the origin can be specified with the
    function'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/451equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: as well as the starting parameter *t[a]* = 0 and the ending parameter *t[b]*
    = 2*π*. If we use the same function and starting parameter but change the ending
    parameter to *t[b]* = *π*, we get a semicircle (the half circle above the x-axis).
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting and ending points can be specified by a starting parameter `startingCurveParam
    :: R` (which we called *t[a]* earlier) and an ending parameter `endingCurveParam
    :: R` (which we called *t[b]*). Thus, we specify a curve with three pieces of
    data: a function, a starting parameter, and an ending parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: A data type can be used to combine pieces of data that really belong together.
    For the curve, it will be very convenient to have a single type `Curve` that contains
    the function, the starting point, and the ending point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The data type `Curve` has a single data constructor that is also called `Curve`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of Curves
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s encode the example of the circle with radius 2 in the xy-plane centered
    at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’re naming our curve circle2 to remind us of the radius 2\. The parameterization
    23.1 is given as the first argument to the data constructor `Curve`, followed
    by the starting and ending curve parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A circle in the xy-plane centered at the origin is easier to express in cylindrical
    coordinates than in Cartesian. In cylindrical coordinates, our circle has the
    constant values *s* = 2 and *z* = 0\. Only the *ϕ* coordinate changes from 0 to
    2*π*. This suggests that we use the *ϕ* coordinate as our parameter for the curve.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We use the cyl function to specify the curve in cylindrical coordinates. The
    curve `circle2'` is the same as the curve circle2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the definition for a unit circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are families of curves for which we need to provide additional information
    before we’ve defined a specific curve. A straight line segment is such a curve.
    We need to provide both a starting position and an ending position, which is the
    perfect job for a higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We define the local name `d` to be the displacement vector pointing from position
    `r1` to position `r2`. We also define a local function `f` as our curve function
    by using the `shiftPosition` function to pick out the position that is shifted
    from `r1` by the displacement vector `t *^ d`. The curve parameter `t` runs from
    `0` to `1`, so `t *^ d` is a scaled version of the displacement vector `d` that
    runs from length 0 to the full length of `d`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how to talk about one-dimensional curves in Haskell. Now let’s move
    up a dimension and talk about surfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Surfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Surfaces have two distinct uses in electromagnetic theory. We use them to describe
    the place that electric charge and current live. Current can flow along a surface.
    Static charge can also be placed on a surface.
  prefs: []
  type: TYPE_NORMAL
- en: We also use them in Gauss’s law, which asserts a relationship between the electric
    field on a closed surface in space and the electric charge inside that surface.
    This second use of surfaces is more abstract since the surface need not be the
    location of any actual material, but it’s also more important for a deep understanding
    of modern electromagnetic theory.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing Surfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A surface is a parameterized function from two parameters to space. For example,
    we can parameterize the unit sphere with two parameters, *θ* and *ϕ*, as the function
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/452equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and the ranges 0 ≤ *θ* ≤ *π* and 0 ≤ *ϕ* ≤ 2*π*.
  prefs: []
  type: TYPE_NORMAL
- en: For a second example, suppose we want to parameterize the surface that lies
    in the xy-plane, bounded by the parabola *y* = *x*² and the line *y* = 4\. This
    surface is shown in [Figure 23-1](ch23.xhtml#ch23fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/453fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-1: A parameterized surface*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, it makes sense to use *x* and *y* as the parameters. The parameterized
    function for the surface is not very exciting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/453equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The interesting part about this surface is the specification of the boundary.
    There’s a lower curve of *y* = *x*² that gives the bottom boundary, an upper curve
    of *y* = 4 that gives the top boundary, a lower limit of *x* = –2 that specifies
    the left boundary, and an upper limit of *x* = 2 that specifies the right boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a general surface, we will call our two parameters *s* and *t*. (This parameter
    *s* is unrelated to the *s* of cylindrical coordinates discussed in [Chapter 22](ch22.xhtml).)
    To specify a general surface, we must give five pieces of data: a parameterizing
    function of two variables, a lower curve, an upper curve, a lower limit, and an
    upper limit. Here’s the data type definition for a general surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function surfaceFunc is the parameterizing function that maps (*s*,*t*)
    into a `Position`. The lower curve is given as a function *t[l]*(*s*) that gives
    the lowest value of *t* on the surface for each value of the parameter *s*. The
    upper curve is given as a function *t[u]*(*s*) that gives the highest value of
    *t* on the surface for each value of the parameter *s*. The lower limit *s[l]*
    is the lowest value of *s* on the surface, and the upper limit *s[u]* is the largest
    value of *s* on the surface.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of Surfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To encode the unit sphere we discussed earlier, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we want constant functions for the lower and upper curves, so
    we use the const function to turn a number into a constant function and the `$`
    operator to avoid the need for parentheses around `2*pi`.
  prefs: []
  type: TYPE_NORMAL
- en: Unsurprisingly, it’s easier to specify a unit sphere in spherical coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In spherical coordinates, we use the same parameters (*θ*,*ϕ*), the same lower
    and upper curves, and the same limits. Only the parameterizing function changes.
    The surface `unitSphere'` is the same surface as unitSphere.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s encode our parabolic surface from [Figure 23-1](ch23.xhtml#ch23fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We use anonymous functions to specify both the surface parameterization and
    the parabolic lower boundary curve.
  prefs: []
  type: TYPE_NORMAL
- en: What about a sphere centered at an arbitrary position with an arbitrary radius?
    We could parameterize it by hand, but instead let’s define a function that shifts
    the location of any surface. That seems like a useful function to have around.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `shiftSurface` function doesn’t change the limits of the parameters being
    used. Instead, it shifts the positions that the parameterizing function `g` was
    providing by the displacement vector `d`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define a centered sphere with an arbitrary radius.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we define a sphere with an arbitrary center and arbitrary radius.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the northern hemisphere of the unit sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a disk in the xy-plane, centered at the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'I don’t think the term “unit cone” is standard terminology, but here is a cone
    in which the circular boundary of the base lies on a unit sphere, with the vertex
    of the cone at the center of the sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These surfaces, or ones you write, can be used in [Chapter 24](ch24.xhtml) to
    form a charge distribution in which charge is distributed across a surface, or
    in [Chapter 26](ch26.xhtml) to form a current distribution in which current flows
    across a surface. Closed surfaces, such as spheres, can be used with Gauss’s law.
  prefs: []
  type: TYPE_NORMAL
- en: Orientation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our surfaces are oriented surfaces. An *orientation* is a choice of which direction
    (perpendicular to the surface) to consider “positive.” If ![Image](Images/scap.jpg)
    is a unit vector pointing in the direction of increasing *s*, and ![Image](Images/tcap.jpg)
    is a unit vector pointing in the direction of increasing *t*, then the positive
    direction for orientation is ![Image](Images/455equ01.jpg). (The parameter *s*
    used in specifying a surface and its associated unit vector ![Image](Images/scap.jpg)
    are unrelated to the cylindrical coordinate *s* and its associated unit vector
    ![Image](Images/scap.jpg). Context should make clear which is meant.) The orientation
    of a surface is important in a flux integral, which is used to calculate electric
    flux, magnetic flux, and current flowing through a surface.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s determine the orientation for the `unitSphere`. We used spherical coordinates
    to parameterize this surface, with the first parameter (in general called *s*)
    being *θ* for the unit sphere and the second parameter (in general called *t*)
    being *ϕ* for the unit sphere. Therefore, as shown in [Figure 23-2](ch23.xhtml#ch23fig2),
    the orientation of the unit sphere is positive in the ![Image](Images/455equ04.jpg)
    direction. In spherical coordinates, ![Image](Images/455equ03.jpg), meaning that
    “outward” is the positive direction of orientation for the unit sphere.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/456fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-2: When the first parameter s is *θ* and the second parameter t
    is *ϕ*, the direction of orientation is ![Image](Images/455equ04.jpg), which is
    the same as ![Image](Images/rcap.jpg), so the orientation is outward.*'
  prefs: []
  type: TYPE_NORMAL
- en: We could make a unit sphere with “inward” as the orientation, but we would need
    to parameterize it differently from the `unitSphere`. If we take *ϕ* as the first
    parameter and *θ* as the second, the orientation is inward.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we have a charge that’s distributed throughout a volume, we’ll use a volume
    charge density to describe it; therefore, we’ll need a new data type to describe
    a volume. We need to specify seven pieces of data to describe a volume:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. A parameterizing function from three parameters (*s*,*t*,*u*) into space
  prefs: []
  type: TYPE_NORMAL
- en: 2\. A lower surface *u[l]*(*s*,*t*) describing the lowest value of *u* for each
    (*s*,*t*)
  prefs: []
  type: TYPE_NORMAL
- en: 3\. An upper surface *u[u]*(*s*,*t*) describing the highest value of *u* for
    each (*s*,*t*)
  prefs: []
  type: TYPE_NORMAL
- en: 4\. A lower curve *t[l]*(*s*) describing the lowest value of *t* for each value
    of *s*
  prefs: []
  type: TYPE_NORMAL
- en: 5\. An upper curve *t[u]*(*s*) describing the highest value of *t* for each
    value of *s*
  prefs: []
  type: TYPE_NORMAL
- en: 6\. A lower limit *s[l]* describing the lowest value of *s*
  prefs: []
  type: TYPE_NORMAL
- en: 7\. An upper limit *s[u]* describing the highest value of *s*
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the definition of the `Volume` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The volumeFunc for a given `Volume` has type `(R,R,R) -> Position`. Recall from
    [Chapter 22](ch22.xhtml) that this type is the same as `CoordinateSystem`. We’ll
    often want to use cartesian, cylindrical, or spherical as our volumeFunc, although
    it’s possible to invent your own coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a unit ball, centered at the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For the volumeFunc, we use spherical, which means that the parameters (*s*,*t*,*u*)
    are the spherical coordinates (*r*,*θ*,*ϕ*). We must provide a lower limit *r[l]*,
    an upper limit *r[u]*, a lower curve *θ[l]*(*r*), an upper curve *θ[u]*(*r*),
    a lower surface *ϕ[l]*(*r*,*θ*), and an upper surface *ϕ[u]*(*r*,*θ*). For a ball,
    we should pick the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/457equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that *θ[l]* is the function *r* ↦ 0 (in Haskell notation `\r -> 0` or
    `\_ -> 0`). This the same as the constant function that returns 0 for any input
    (in Haskell notation const 0). The function *ϕ[l]* takes *two* inputs and returns
    0 (in Haskell notation `\_ _ -> 0`).
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a cylinder with a circular base centered at the origin and circular top
    in the plane *z* = *h*. We give the radius and height of the cylinder as inputs
    to the function `centeredCylinder`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These volumes, or ones you write, can be used in [Chapter 24](ch24.xhtml) to
    form a charge distribution in which charge is distributed throughout a volume,
    or in [Chapter 26](ch26.xhtml) to form a current distribution in which current
    flows throughout a volume.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we developed the data types `Curve`, `Surface`, and `Volume`
    for describing geometric objects. We defined some particular geometric objects,
    such as `unitCircle`, `sphere`, and `unitBall`. These curves, surfaces, and volumes
    will become objects we integrate over to calculate electric fields, and they will
    also serve as the abstract settings for Gauss’s law and Ampere’s law. The next
    chapter discusses charge distributions in preparation for the following chapter
    on electric fields.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 23.1.** Replace the undefined r radius below with a definition that
    will take a center position and radius and produce a circle parallel to the xy-plane.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 23.2.** A helix can be parameterized most easily in cylindrical
    coordinates. In cylindrical coordinates (*s*,*ϕ*,*z*), a helix with radius 1 can
    be parameterized as'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/458equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Define a `Curve` for this helix. Choose end points so that the helix makes five
    loops around.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 23.3.** A square has four sides. Let’s make a `Curve` to represent
    a square with vertices (–1,–1,0), (1,–1,0), (1,1,0), and (–1,1,0). Make the orientation
    of the curve counterclockwise. Fill in the parts that are `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 23.4.** Define a `Surface` for a cone with height *h* and radius
    *r*. Do not include the surface of the base of the cone. Position and orient the
    cone however it’s convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 23.5.** Replace the undefined that follows with a definition of
    an upper-half ball (*z* ≥ 0) with unit radius, centered at the origin.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 23.6.** Replace the `undefined` that follows with a definition of
    a ball with given a radius centered at the origin. (The `R` is the type of the
    radius, and you may want to put a variable for the radius on the left of the equal
    sign.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 23.7.** What is the type of `shiftPosition d` in the definition
    of `shift` `Surface` given earlier?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 23.8.** Define a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: that takes a displacement vector and a volume as input and returns a shifted
    volume as output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 23.9.** Define a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: that takes a radius as input and gives a `Curve` as output corresponding to
    [Figure 23-3](ch23.xhtml#ch23fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/459fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-3: A curve representing the boundary of a quarter disk*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 23.10.** Define a `Surface` for the rectangular region that is shown
    in [Figure 23-4](ch23.xhtml#ch23fig4). Choose your parameterization so that the
    orientation is in the ![Image](Images/icap.jpg) direction (the positive x-direction).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/460fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-4: A surface in the yz-plane*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 23.11.** Define a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: that takes a height *h* and radius *R* as input and gives a `Volume` as output
    corresponding to [Figure 23-5](ch23.xhtml#ch23fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/460fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 23-5: A volume representing a quarter cylinder*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 23.12.**'
  prefs: []
  type: TYPE_NORMAL
- en: (a) Define a `Surface` for a torus with major radius 3 and minor radius 0.5.
  prefs: []
  type: TYPE_NORMAL
- en: (b) Define a `Volume` for the space inside the torus of part (a).
  prefs: []
  type: TYPE_NORMAL
