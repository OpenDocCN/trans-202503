- en: '**H  Unsorted Attacks**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**H.1 PIC16C84 PicBuster**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third chapter of McCormac (1996) describes a few firmware extraction exploits
    from the early days of TV piracy. Of particular interest is a trick against the
    PIC16C84, the very first PIC to include electrically erasable EEPROM memory rather
    than OTP ROM or UV erasable EPROM. Like the PICs we saw in [Chapter 19](ch19.xhtml#ch19),
    a protection fuse is implemented with the same floating gate transistor as the
    EEPROM bits.
  prefs: []
  type: TYPE_NORMAL
- en: The trick involves the difference between the supply voltage VDD and the programming
    voltage on the !MCLR pin. In normal operation, VDD should be less than 7.5V and
    !MCLR should be less than 14V, relative to ground on VSS. This technique does
    not work against earlier chips, which lacked an electrical erase feature.
  prefs: []
  type: TYPE_NORMAL
- en: To exploit the PIC16C84, the chip is electrically mass erased at the wrong voltage.
    The VDD pin is held at 13.5V, just 0.5V less than VPP. VDD is then dropped to
    the standard 5V and switched off for ten to twenty seconds before being powered
    back on, allowing data to be read.
  prefs: []
  type: TYPE_NORMAL
- en: '**H.2 PIC Checksums**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PIC microcontrollers implement a checksum that leaks information from locked
    chips, and in some cases you can clear—but not set—bits by performing a second
    programming. Kaljević (1997) documents the checksum algorithm and a technique
    for zeroing coefficients of that checksum to reveal specific bits of the source
    program.
  prefs: []
  type: TYPE_NORMAL
- en: On 14-bit models like the PIC16, Kaljević begins by the checksum algorithm,
    ![image](../images/f0394-01.jpg) where *a* is the higher seven bits and *b* the
    lower seven bits of a 14-bit instruction word. ![image](../images/f0394-02.jpg)
    is the XNOR operator, ∽ is inversion, and ⊕ is the XOR operator. *s* is freely
    readable from the chip over the normal ICSP protocol, and the game is to reveal
    the unknown bits in *a* and *b*.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing *s*, he points out that overwriting the word with `0b11-111110000000`
    to zero *b* will give us ![image](../images/f0394-03.jpg), or just the inverse
    of *a*. It follows that *s* = *ã* ⊕ b = *s*[1] ⊕ *b*.
  prefs: []
  type: TYPE_NORMAL
- en: Then we can declare that *b* = (*s* ⊕ *s*[1]) & `0x7f` and also that ![image](../images/f0394-03a.jpg)
    & `0x7f`. The fully reconstructed word from *s* and *s*[1] is easily computed
    for 14-bit PICs such as the PIC16C61, 62, 64, 65, 71, 73, 74, and 84.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0394-03b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For 12-bit parallel programmed chips in the PIC12 series, the checksum algorithm
    is different. Here, *s* = *a* ⊕ *b* ⊕ *c* where *a* is the upper nybble, *b* the
    middle nybble, and *c* the lower nybble of the instruction word.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of one write, as in the 14-bit chips, two writes are performed. After
    the first write of `0x0ff0` zeroes *c*, we see *s*[1] = *a* ⊕ *b*. We can then
    make a second write of `0x0f00` to zero *b*, leaving *s*[2] = *a*. Tying it all
    together, for twelve bit chips with observations of *s*, *s*[1] and *s*[2], our
    original instruction word is revealed with *a* = *s*[2], *b* = *s*[2] ⊕ *s*[1],
    and *c* = *s*[1] ⊕ *s*.
  prefs: []
  type: TYPE_NORMAL
- en: '*w* = (*s*[2] & `0xf00`) + ((*s*[2] ⊕ *s*[1]) & `0xf0`) + ((*s*[1] ⊕ *s*) &
    `0xf`)'
  prefs: []
  type: TYPE_NORMAL
- en: As for performing the writes, the paper becomes a little hard to follow. On
    the PIC16C71 and 61 models, the first 64 words of memory can simply be overwritten.
    *b* is zeroed and the algorithm for recovery gives those words with no ambiguity,
    but the rest of memory cannot be written so easily.
  prefs: []
  type: TYPE_NORMAL
- en: To program an already-locked chip in order to clear bits, he recommends over-volting
    the chip, then if that fails, overheating it, and if even that is not enough,
    also giving it a limited exposure to ultraviolet light. The voltage trick—perhaps
    related to the one in [Chapter H.1](app08.xhtml#app08_1)—is to power the chip
    at between six and nine volts while strictly limiting current to 100mA. Failing
    that, he suggests holding the temperature at 110 ^°C, being careful never to go
    above 140 ^°C.
  prefs: []
  type: TYPE_NORMAL
- en: If that is insufficient, he proposes exposing the die and calibrating the UV
    light power such that it takes ten minutes to erase a PIC. Then, at 110 ^°C, running
    thirty second exposures until the protection bit becomes set, allowing writes.
    `0x3f80` is then written to every word of memory, and the chip slowly cooled down
    to −20 ^°C. At this point, the protection bit will fall back to zero. Writes will
    no longer be allowed, but the cleared bits from the writes will also be zero.
    *s*[1] can then be read out of the locked chip.
  prefs: []
  type: TYPE_NORMAL
- en: One further trick is described only in x86 assembly code to write `0b11111111000000`,
    which sets *b* to either `0x40` or `0x00`. This leaves a puzzle in decoding, and
    some helpful notes are given as to which of two possible instruction words would
    be the right guess.
  prefs: []
  type: TYPE_NORMAL
- en: '**H.3 ESP32 TOCTOU for XIP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ESP32 series from Espressif supports an execute-in-place (XiP) mode, in
    which instructions are fetched directly from SPI flash without first being copied
    into internal SRAM. This allows more RAM to be used by the application, at the
    cost of a slower execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: Code is validated and a signature checked before execution, but Magesh (2023)
    describes a time-of-check to time-of-use (TOCTOU) attack against the signature
    validation by swapping between two SPI flash chips at runtime. This allows the
    signed code to be successfully measured before the unsigned code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Magesh notes that this trick does not work when flash encryption (AES XTS) is
    enabled, but he expects that an attacker might still exploit an encrypted image
    by randomizing a single page until a needed behavior is found, keeping all other
    pages intact.
  prefs: []
  type: TYPE_NORMAL
- en: '**H.4 DS5002 Chosen Ciphertext**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DS5002 from Dallas Semiconductor is an early and creative attempt at code
    readout protection. Code is held encrypted in external memory, with the key held
    internally in battery backed SRAM. This creates an awkward situation for arcade
    game repairs, as the batteries in existing devices will eventually die. Without
    an exploit, the code needed to run the game will die with it.
  prefs: []
  type: TYPE_NORMAL
- en: This chip’s instruction set is 8051\. Encryption occurs one byte at a time,
    independent of all other bytes but unique to that address. The transformation
    is the same for both opcodes and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to encryption, the DS5002 also performs dummy reads during cycles
    when the memory bus might otherwise be idle. The values fetched from these addresses
    are not used for anything; they only exist to confuse us.
  prefs: []
  type: TYPE_NORMAL
- en: The DS5002 is also available as a module in sealed epoxy with a battery back-up.
    [Figures H.1](app08.xhtml#chHfig1) and [H.2](app08.xhtml#chHfig2) show this module
    in surface microscopy and X-ray.
  prefs: []
  type: TYPE_NORMAL
- en: Kuhn (1996) and Kuhn (1998) presented a cryptographic attack against the chip,
    by first backing up a copy of the external SRAM and then feeding guesses into
    the CPU, watching the address change in response.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you might make a guess that a particular instruction is a branch.
    Because the addresses are scrambled, you can’t know that your guess is right just
    from the next address fetched. But if you change a parameter byte, almost every
    value will branch the addresses into a different direction.
  prefs: []
  type: TYPE_NORMAL
- en: The point of the attack is to take that little piece of information, then use
    it to wedge apart many bytes of chosen ciphertext with known content, allowing
    us to execute arbitrary code.
  prefs: []
  type: TYPE_NORMAL
- en: You should also understand that bytes are encrypted individually and that they
    don’t impact later bytes. We don’t quite know how a byte will be scrambled, but
    for any specific address we can build up a table of bytes. The table is a unique
    mapping of a cipher byte to a clear byte, and the table does not change when the
    preceding byte in memory changes. As you’ll soon see, we don’t much care about
    the address that holds each byte. Instead, we care about forcing those bytes to
    known values and building lookup tables that let us choose the right ciphertext
    for specific plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: Wilhelmsen and Kirkegaard (2017) presents a more modern implementation of the
    same attack, and being written in a less academic style, it’s easier to follow.
    They describe a number of complications, with far less math.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0398-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure H.1: Dallas DS5002'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0399-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure H.2: Dallas DS5002 Module in X-ray'
  prefs: []
  type: TYPE_NORMAL
- en: Many 8051 instructions take a few clock cycles to execute after being fetched.
    The DS5002 fetches unrelated instructions during this time to confuse an outside
    observer, making my earlier description a bit oversimplified.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the interrupt table is held in internal SRAM so the attacker can’t know
    when interrupts have been fired. This matters a lot at reset time.
  prefs: []
  type: TYPE_NORMAL
- en: It’s necessary to know when the first real instruction is fetched, because the
    first observed access might be a dummy read. They do this by attempting all 256
    values at that address, and if none of those values change the subsequent memory
    accesses, they then know that the byte is a dummy and might freely be ignored.
    This is repeated until they’ve identified the first real instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Having identified the location of the first instruction byte, they next need
    to produce some bytes of their own to fit there. Because the DS5002 sets Port
    3 to `FF` at reset, they can brute-force 05 b0 (`inc p3`) as the first two instruction
    bytes to flip Port 3 back to `00`. And I mean that they brute-force it; there
    are only 65,536 combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, they have one ciphertext/plaintext mapping of the first two
    bytes but don’t yet have other mappings, so they can’t arbitrarily change them.
    To get a mapping for the third byte, they brute-force the first byte until they
    get `75`, the opcode for `mov iram addr, #data`, at which point they can run `75
    b0 xx` to write all 256 values of cleartext into Port 3\. Now the third byte is
    completely cracked, even though only two values are mapped for the first byte
    and just one value for the second byte.'
  prefs: []
  type: TYPE_NORMAL
- en: They then adjust the first byte until it becomes anything like a `nop` and adjust
    the second byte until it becomes `75`. Then they can scan every value of the fourth
    byte just as they did the third! Repeating this gives them a few bytes of shellcode
    that they can force into the chip, preceded by two `nop` bytes that don’t much
    matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, they insert little bits of shellcode. This one gives them the boundary
    between code and data memories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0401-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This one dumps the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0401-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And this one dumps the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0401-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a lot of resets involved in this attack, but they report just two
    minutes to brute-force the first range of instructions and just four minutes to
    dump 32 kilobytes of firmware.
  prefs: []
  type: TYPE_NORMAL
- en: '**H.5 SAMA5 CMAC, SPA, Keys**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Janushkevich (2020) describes three vulnerabilities in the Microchip (née Atmel)
    SAMA5 series of secure microcontrollers.
  prefs: []
  type: TYPE_NORMAL
- en: This series contains a boot monitor called SAM Boot Assistance (SAM-BA) that
    allows authenticated and encrypted applets to be uploaded and then executed. These
    applets are often used as drivers, implementing support for new memory devices
    in RAM-loadable modules to keep the bootloader small, while relying upon cipher-based
    message authentication code (CMAC) authentication to keep things secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note well: CMAC authentication is often thought of as a fast alternative to
    public-key signatures. When things go well, CMAC offers authentication in far
    less time than public-key signatures. Unlike signatures, things can go quite poorly
    because CMAC depends upon a shared secret key that either party can leak. Think
    of it like a letter: if we were writing to one another with public-key cryptography,
    my signature would guarantee that the letter came from someone with a key that
    only I should have access to and that only I might leak to a third-party. But
    if we use CMAC to authenticate our letters, you *and* I have access to the authentication
    key. *Either* of us might leak that key to a third-party.'
  prefs: []
  type: TYPE_NORMAL
- en: Some chips include SAM-BA in ROM. Others have no ROM and instead link the boot
    assistance monitor to flash memory. A GPIO pin configures the bootloader entry,
    and SAM-BA supports both UART and USB communications to the host computer. The
    standard procedure is that when the configuration pin is low at reset or the application’s
    reset vector is `0xffffffff`, the boot-loader will first attempt enumeration over
    USB and then fall back to a UART console.
  prefs: []
  type: TYPE_NORMAL
- en: SAM-BA has a fancy GUI client and TCL scripting library, but for the first bug,
    we’ll stick to the text protocol of the UART variant. Microchip documents loading
    a secure applet with the following transactions, where `applet.cip` is an encrypted
    and signed applet binary that is 9,870 bytes in size.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0402-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: During this procedure, the `SAPT` command handler loads the applet to `0x220000`
    in SRAM, checks the CMAC authentication, and decrypts the applet in place. The
    result of the authentication check is placed in a global variable. If the CMAC
    were wrong, the latter `CACK` message would include an error code and the global
    variable would indicate a bad authentication.
  prefs: []
  type: TYPE_NORMAL
- en: After the applet is loaded, the `SMBX` command is used to load the mailbox.
    `mailbox.bin` is neither encrypted nor signed, and it loads to the mailbox area
    within the application image at `0x22-0004`. A matching command, `RMBX`, will
    retrieve the mailbox after execution, to allow for bidirectional communication.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0403-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that the applet is loaded, the `EAPP` command can be used to execute the
    applet against the mailbox message. In addition to the mailbox, `SFIL` and `RFIL`
    commands exit to send or receive a file from the device.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0403-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve covered the basics of the tutorial, let’s peek at the first exploitable
    bug. Janushkevich first notes that the `RMBX` command allows the mailbox to be
    retrieved even when it has not been loaded. Because the mailbox and the applet
    overlap, this allows him to read back part of the applet from memory.
  prefs: []
  type: TYPE_NORMAL
- en: He then tried first a signed, encrypted applet and an unsigned, unencrypted
    applet. `RMBX` returned pieces of the first applet in cleartext, showing that
    it was decrypted to memory before being executed. The unsigned applet also had
    pieces returned from the mailbox without corruption, implying that when CMAC validation
    fails, the unvalidated message remains in memory without being scrambled by decryption.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, he tried executing the applet with `EAPP`, `SFIL`, and `RFIL`. All
    three—I shit you not—executed the unencrypted, unsigned applet without complaint.
    It seems that the `SAPT` command records that the authentication failed, but the
    commands that execute the applet do not bother to check that variable. This is
    tracked as CVE-2020-12787.
  prefs: []
  type: TYPE_NORMAL
- en: As a second attack, he attached a ChipWhisperer to a modified SAMA5D2-XULT dev
    kit to take a look at the power consumption when that chip performs CMAC authentication.
    By identifying a point in time when power traces wildly diverge based upon a carry-in
    subtraction of a provided CMAC word from the computed word, he is able to leak
    bits of the correct CMAC of the message, starting from the most significant bit
    and working his way down to the least. In 1,300 power measurements or twenty minutes,
    this lets him forge a CMAC authentication for bootstrapping an image, loading
    a SAM-BA applet, or installing a key. This is tracked as CVE-2020-12788.
  prefs: []
  type: TYPE_NORMAL
- en: 'His third attack against this series is simple but brutal: the CMAC keys used
    by this bootloader are hardcoded and can be dumped by an applet using the vulnerabilities
    we’ve already discussed. These keys were verified by decrypting published applets,
    allowing for their reverse engineering and, perhaps someday, their exploitation.
    CVE-2020-12789.'
  prefs: []
  type: TYPE_NORMAL
