- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: CONTAINER IMAGES AND RUNTIME LAYERS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像和运行时层
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: To run a process, we need storage. One of the great advantages of containerized
    software is the ability to bundle an application for delivery together with its
    dependencies. As a result, we need to store the executable for the program and
    any shared libraries it uses. We also need to store configuration files, logs,
    and any data managed by the program. All of this storage must be isolated so that
    a container can’t interfere with the host system or with other containers. Altogether,
    this represents a large need for storage, and it means container engines must
    provide some unique features to be efficient in the use of disk space and bandwidth.
    In this chapter, we’ll explore how the use of a layered filesystem makes container
    images efficient to download and containers efficient to start.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个进程，我们需要存储空间。容器化软件的一个显著优势之一是能够将应用程序与其依赖项捆绑在一起进行交付。因此，我们需要存储程序的可执行文件以及其使用的任何共享库。我们还需要存储配置文件、日志和程序管理的任何数据。所有这些存储都必须隔离，以防容器干扰主机系统或其他容器。总的来说，这对存储需求很大，这意味着容器引擎必须提供一些独特的功能，以有效利用磁盘空间和带宽。在本章中，我们将探讨分层文件系统如何使容器镜像下载高效，并使容器启动高效。
- en: Filesystem Isolation
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统隔离
- en: In [Chapter 2](ch02.xhtml#ch02), we saw how we could use a *chroot* environment
    to create a separate, isolated part of the filesystem that contained only the
    binaries and libraries we needed to run a process. Even to run a simple `ls` command,
    we needed the binary and several libraries. A more fully featured container, such
    as one running the NGINX web server, needs quite a bit more—a complete set of
    files for a Linux distribution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第二章](ch02.xhtml#ch02) 中，我们看到如何使用 *chroot* 环境创建文件系统的一个独立隔离部分，该部分只包含我们运行进程所需的二进制文件和库。即使是运行简单的
    `ls` 命令，我们也需要这个二进制文件和几个库。一个更完整功能的容器，比如运行 NGINX web 服务器的容器，需要更多——一个完整的 Linux 发行版的文件集。
- en: In the chroot example, we built the isolated filesystem from the host system
    when we were ready to use it. That approach would be impractical for containers.
    Instead, the isolated filesystem is packaged in a *container image*, which is
    a ready-to-use bundle that includes all files and metadata, such as environment
    variables and the default executable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 chroot 示例中，当我们准备好使用它时，我们从主机系统构建了隔离的文件系统。对于容器而言，这种方法是不实际的。相反，隔离的文件系统被打包在一个
    *容器镜像* 中，这是一个包含所有文件和元数据（如环境变量和默认可执行文件）的即用包。
- en: Container Image Contents
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 容器镜像内容
- en: Let’s take a quick look inside an NGINX container image. For this chapter, we’ll
    be running commands using Docker because it’s still the most common tool for building
    container images.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看一个 NGINX 容器镜像的内部。在本章中，我们将使用 Docker 运行命令，因为它仍然是构建容器镜像的最常用工具。
- en: '**NOTE**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The example repository for this book is at* [https://github.com/book-of-kubernetes/examples](https://github.com/book-of-kubernetes/examples).
    *See “Running Examples” on [page xx](ch00.xhtml#ch00lev1sec2) for details on getting
    set up.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书示例的示例存储库位于* [https://github.com/book-of-kubernetes/examples](https://github.com/book-of-kubernetes/examples)。*请参阅
    [第 xx 页](ch00.xhtml#ch00lev1sec2) 上的“运行示例”获取设置详细信息。*'
- en: 'Run the following command on *host01* from this chapter’s examples to download
    the image:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，从 *host01* 运行以下命令下载镜像：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `docker pull` command downloads an image from an *image registry*. An image
    registry is a web server that implements an API for downloading and publishing
    container images. We can see the image we’ve downloaded by listing images with
    `docker images`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker pull` 命令会从 *镜像仓库* 下载一个镜像。镜像仓库是一个实现下载和发布容器镜像 API 的 Web 服务器。我们可以通过 `docker
    images` 命令列出已下载的镜像：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This image is 133MB and has a unique identifier of `f0b8a9a54136`. (Your identifier
    will be different, as new NGINX container images are built every day.) This image
    includes not only the NGINX executables and required libraries but also a Linux
    distribution based on Debian. We saw this briefly in [Chapter 1](ch01.xhtml#ch01)
    when we demonstrated a Rocky Linux container on an Ubuntu host and kernel, but
    let’s look at it in a little more detail. Start by running an NGINX container:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个镜像大小为 133MB，并具有唯一标识符 `f0b8a9a54136`。（你的标识符将不同，因为每天都会构建新的 NGINX 容器镜像。）该镜像不仅包含
    NGINX 可执行文件和所需的库，还包括基于 Debian 的 Linux 发行版。我们在 [第一章](ch01.xhtml#ch01) 中简要看到了这一点，当时我们在
    Ubuntu 主机和内核上演示了 Rocky Linux 容器，但让我们稍微详细地看一下。首先，运行一个 NGINX 容器：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `--name` flag gives the container a friendly name that we can use for future
    commands, whereas the `-d` flag sends it to the background.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`--name` 标志为容器指定了一个友好的名称，未来我们可以在命令中使用这个名称，而 `-d` 标志则将容器发送到后台运行。'
- en: 'Now, let’s explore the filesystem of our running container:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索一下运行中容器的文件系统：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From here, we can see the various libraries needed for NGINX to work:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 NGINX 工作所需的各种库：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All of these libraries are part of the container image we downloaded, so our
    NGINX container does not need (and cannot see) any files from the host system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些库都是我们下载的容器镜像的一部分，因此我们的 NGINX 容器不需要（也无法访问）主机系统中的任何文件。
- en: 'Not only do we have a healthy number of libraries present, but we have typical
    configuration files in */etc* that we would expect for a Debian system:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅拥有了大量必要的库，而且在 */etc* 目录下还有典型的配置文件，这是我们期望在 Debian 系统中找到的：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This listing shows that the filesystem even includes directories that aren’t
    really needed for a container, like the */etc/systemd* directory. (Remember, a
    container is just a set of related processes run under isolation, so a container
    almost never runs a system service manager like systemd.) This full filesystem
    is included for a couple reasons. First, many processes were written to expect
    the usual set of files to be present. Second, it’s just easier to build container
    images starting from a typical Linux distribution.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表显示了文件系统中甚至包含了一些对容器来说并不真正需要的目录，比如 */etc/systemd* 目录。（记住，容器只是以隔离方式运行的一组相关进程，所以容器几乎从不运行像
    systemd 这样的系统服务管理器。）这个完整的文件系统被包含进来有几个原因。首先，许多进程被设计成预期通常的文件集合会存在。其次，从一个典型的 Linux
    发行版开始构建容器镜像要更容易一些。
- en: 'The separate filesystem for our container is writable as well. While we have
    this shell open, let’s send some random data to a file in the container so that
    we can inspect that storage from the host. We can then exit the shell:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们容器的独立文件系统也是可写的。既然我们已经打开了这个 shell，让我们向容器中的一个文件发送一些随机数据，以便稍后从主机上检查这个存储。然后我们可以退出
    shell：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `dd` command wrote a 10MB file into the */tmp* directory. Even though we
    exited the shell, the container is still running, so we can use `docker inspect`
    to see the amount of disk space this container is using:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd` 命令将一个 10MB 的文件写入了 */tmp* 目录。尽管我们退出了 shell，容器仍然在运行，因此我们可以使用 `docker inspect`
    查看该容器使用的磁盘空间：'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-s` flag tells `docker inspect` to report the size of the container. Because
    `docker inspect` produces a huge JSON output, we use the JSON query tool `jq`
    to choose the field we want.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`-s` 标志告诉 `docker inspect` 输出容器的大小。由于 `docker inspect` 生成了庞大的 JSON 输出，我们使用
    JSON 查询工具 `jq` 来选择我们需要的字段。'
- en: The reported size is just about 10MB, suggesting that the container is consuming
    only the amount of read-write storage required for the file we wrote, plus any
    files written by NGINX. We’ll explore this in more detail as we continue in this
    chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的大小大约是 10MB，表明容器只消耗了写入的文件所需的读写存储空间，加上 NGINX 写入的任何文件。我们将在本章的后续部分更详细地探讨这一点。
- en: Image Versions and Layers
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 镜像版本与层
- en: 'The ability to quickly download a prepackaged filesystem to run a process is
    only one of the advantages of container images. Another is the ability to tag
    different versions of an image to allow for rapid upgrading. Let’s explore this
    by pulling and running two different versions of Redis, the popular in-memory
    key–value database:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 快速下载一个预先打包好的文件系统以运行一个进程，仅仅是容器镜像的一个优点。另一个优点是能够标记镜像的不同版本，以便于快速升级。让我们通过拉取并运行两个不同版本的
    Redis，这个流行的内存键值数据库，来探索一下这一点：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The data after the colon is the *image tag* and acts as a version identifier.
    Previously, when we left this off, Docker defaulted to *latest*, which is a tag
    like any other, but it is used by convention to refer to the latest published
    image. By specifying the version, we can ensure that even as newer versions of
    Redis are released, we will continue to run the same version until we are ready
    to upgrade. The tag can contain any characters, and it is common to add extra
    information after a hyphen. In this case, the `-alpine` at the end of the tag
    indicates that this image is based on Alpine Linux, a lightweight Linux distribution
    that is popular for making container images because of its small size.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号后的数据是*镜像标签*，作为版本标识符。之前，当我们省略这个标签时，Docker 默认为*latest*，它是一个像其他标签一样的标签，但根据约定，用于指代最新发布的镜像。通过指定版本，我们可以确保即使发布了更新的
    Redis 版本，我们仍然会继续运行相同的版本，直到我们准备好升级为止。标签可以包含任何字符，通常在连字符后添加额外的信息。在这个例子中，标签末尾的 `-alpine`
    表示这个镜像基于 Alpine Linux，这是一个轻量级的 Linux 发行版，因为其小巧的体积，它在制作容器镜像时非常流行。
- en: One other interesting item of note is the fact that when we downloaded the second
    version of Redis, some of the content ➋ was flagged as `Already exists`. Looking
    at the first Redis download, we see the same unique identifiers are present there
    ➊. This is because a container image is made up of layers, and these identifiers
    uniquely describe a layer. If a layer we’ve already downloaded is used by another
    image, we don’t need to download it again, saving download time. Additionally,
    each layer needs to be stored only once on disk, saving disk space.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的有趣事项是，当我们下载 Redis 的第二个版本时，其中一些内容 ➋ 被标记为 `已存在`。查看第一个 Redis 下载，我们可以看到相同的唯一标识符也出现在那里
    ➊。这是因为一个容器镜像是由多个层组成的，这些标识符唯一地描述了一个层。如果我们已经下载的层被另一个镜像使用，我们就不需要再次下载它，从而节省了下载时间。此外，每个层只需要在磁盘上存储一次，从而节省了磁盘空间。
- en: 'We now have two different versions of Redis downloaded:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经下载了两个不同版本的 Redis：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Although Docker is reporting that each image has a size of about 30MB, that
    is the total size of all the layers and doesn’t account for the storage savings
    that come from shared layers. The actual storage on disk is less, as we can see
    by examining Docker’s use of disk space:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Docker 报告每个镜像的大小大约为 30MB，但这是所有层的总大小，并未考虑共享层所带来的存储节省。实际存储在磁盘上的空间更少，正如我们通过检查
    Docker 使用磁盘空间的情况所看到的：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The two Redis images are sharing almost 7MB of base layers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 Redis 镜像共享了将近 7MB 的基础层。
- en: 'These two versions of Redis can be run separately:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本的 Redis 可以分别运行：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that both images are running, we can confirm that our containers have exactly
    the version of Redis we want, independent of what version might be the latest
    release and independent of the versions available for our host server:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两个镜像都在运行，我们可以确认我们的容器中有我们想要的确切版本的 Redis，与最新发布的版本无关，也不受主机服务器上可用版本的影响：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a big advantage for building reliable systems. We can test our application
    thoroughly with one version of the software and be sure that version will continue
    to be used until we choose to upgrade. We can also easily test our software against
    a new version without having to upgrade a host system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于构建可靠系统来说是一个很大的优势。我们可以使用一个版本的软件彻底测试我们的应用程序，并确保在我们选择升级之前，该版本会继续使用。我们还可以轻松地将软件与新版本进行测试，而不需要升级主机系统。
- en: Building Container Images
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: In the preceding example, we saw how we could reduce the download and disk requirements
    for container images by sharing layers. This layer sharing can be used with any
    container image, not just two different versions of the same software.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到通过共享层来减少容器镜像的下载和磁盘需求。这种层共享可以与任何容器镜像一起使用，而不仅仅是同一软件的两个不同版本。
- en: The layers in a container image come from the way it is built. A container image
    build starts with a *base image*. For example, both of our two Redis versions
    started with the same exact Alpine Linux base image, which is why those layers
    were shared in that image. Starting from the base image, each step in the build
    process can produce a new layer. This new layer contains only the changes to the
    filesystem that came from that build step.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像中的层来自于它的构建方式。容器镜像的构建从一个*基础镜像*开始。例如，我们的两个 Redis 版本都是从相同的 Alpine Linux 基础镜像开始的，这也是为什么这些层在该镜像中得以共享的原因。从基础镜像开始，构建过程中的每个步骤都会产生一个新的层。这个新层仅包含来自该构建步骤的文件系统变化。
- en: A base image must also come from somewhere, and, ultimately, there must be an
    initial layer, which is typically a minimal Linux filesystem created from some
    Linux distribution, transferred into an empty container image, and then expanded
    to become an initial layer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 基础镜像也必须来自某个地方，最终必须有一个初始层，这通常是从某个 Linux 发行版创建的最小 Linux 文件系统，转移到一个空的容器镜像中，然后扩展成为初始层。
- en: Using a Dockerfile
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Dockerfile
- en: 'There are many different ways to build container images, but the most popular
    is to create a file known as a *Dockerfile* or *Containerfile* that specifies
    the commands and configuration for the image. Here’s a simple *Dockerfile* that
    adds web content to an NGINX image:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器镜像有许多不同的方法，但最流行的方法是创建一个名为 *Dockerfile* 或 *Containerfile* 的文件，指定镜像的命令和配置。以下是一个简单的
    *Dockerfile*，它将 web 内容添加到 NGINX 镜像中：
- en: '*Dockerfile*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dockerfile*'
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each line in a *Dockerfile* starts with a command that is followed by parameters.
    Blank lines and content after a `#` are ignored, and a backslash at the end of
    a line continues that command onto the next line. There are many possible commands;
    here are the most common:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行 *Dockerfile* 中都以一个命令开始，后面跟着参数。空行和 `#` 后的内容会被忽略，行末的反斜杠表示该命令会延续到下一行。命令有很多种，以下是最常见的几种：
- en: FROM Specify the base image for this build.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: FROM 指定此构建的基础镜像。
- en: RUN Run a command inside the container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: RUN 在容器内运行命令。
- en: COPY Copy files into the container.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: COPY 将文件复制到容器中。
- en: ENV Specify an environment variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ENV 指定一个环境变量。
- en: ENTRYPOINT Configure the initial process for the container.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ENTRYPOINT 配置容器的初始进程。
- en: CMD Set default parameters for the initial process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: CMD 设置初始进程的默认参数。
- en: Docker provides the `docker build` command to build an image from a *Dockerfile*.
    The `docker build` command creates a new image by running each command in the
    *Dockerfile*, one at a time. [Listing 5-1](ch05.xhtml#ch05list1) illustrates how
    to run `docker build`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了 `docker build` 命令来从 *Dockerfile* 构建镜像。`docker build` 命令通过逐一运行 *Dockerfile*
    中的每个命令来创建一个新镜像。[列表 5-1](ch05.xhtml#ch05list1) 说明了如何运行 `docker build`。
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 5-1: Docker build*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1: Docker 构建*'
- en: The `-t` switch tells `docker build` to store the image from the build process
    under the name `hello`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t` 开关告诉 `docker build` 将构建过程中的镜像存储为名称为 `hello` 的镜像。'
- en: Examining the steps in this build process will help clarify how container images
    are made. First, Docker sends the *build context* to the Docker daemon ➊. The
    build context is a directory and all of its files and subdirectories. In this
    case, we specified the build context as the current directory when we added `.`
    to the end of the `docker build` command. The actual container image build happens
    inside the daemon, so the only files that would be available for a `COPY` command
    are those that are in the build context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 审查构建过程中的各个步骤将有助于澄清容器镜像是如何创建的。首先，Docker 将*构建上下文*发送到 Docker 守护进程 ➊。构建上下文是一个目录及其所有文件和子目录。在这种情况下，当我们在
    `docker build` 命令末尾添加 `.` 时，我们指定了当前目录作为构建上下文。实际的容器镜像构建是在守护进程内进行的，因此只有构建上下文中的文件才能用于
    `COPY` 命令。
- en: Second, Docker identifies our base image, in this case `nginx`. The unique identifier
    it displays ➋ matches the one displayed earlier for our NGINX image when we ran
    `docker images`. Third, Docker executes the command we specified in the `RUN`
    step. This command is actually run inside a container based on our NGINX base
    image ➌, which means that only the commands installed in the container image are
    available to run. If we need other commands to be available, we might need to
    create a `RUN` step that installs them before we can use them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，Docker 确定了我们的基础镜像，在本例中是 `nginx`。它显示的唯一标识符 ➋ 与我们运行 `docker images` 时之前显示的
    NGINX 镜像相同。第三，Docker 执行了我们在 `RUN` 步骤中指定的命令。该命令实际上是在基于我们的 NGINX 基础镜像 ➌ 创建的容器内运行的，这意味着只有容器镜像中安装的命令才能运行。如果我们需要其他命令可用，可能需要创建一个
    `RUN` 步骤来安装它们，才能使用。
- en: 'After all of the build steps are complete, Docker “tags” the new container
    image with the name we provided using the `-t` flag. As before, we didn’t specify
    a version, so `latest` is used as a default. We now can see this image in the
    list of available images:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有构建步骤完成后，Docker 使用 `-t` 标志用我们提供的名称为新容器镜像打标签。如前所述，我们没有指定版本，因此默认使用 `latest`。现在我们可以在可用镜像列表中看到该镜像：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The unique identifier for this image matches the output from the end of [Listing
    5-1](ch05.xhtml#ch05list1). This image is shown as 133MB because it has all of
    the layers from the NGINX image in addition to the new small HTML file we added.
    As before, the shared layers are stored only once, so the extra storage required
    to build this image was very small.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个镜像的唯一标识符与[Listing 5-1](ch05.xhtml#ch05list1)结尾处的输出匹配。这个镜像显示为 133MB，因为它包含了所有来自
    NGINX 镜像的层，外加我们添加的新小 HTML 文件。和之前一样，共享层只存储一次，因此构建这个镜像所需的额外存储非常小。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you try this example yourself, the unique identifier displayed for your
    “hello” image will be different, even though the Dockerfile has the same content
    for the HTML file. The identifier for each layer is based not only on the layer’s
    file content but also on the identifier for the layer above it. As a result, if
    two images have the same identifier, we can be confident that the contents are
    exactly the same, even if they were built separately.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你自己尝试这个例子时，显示的“hello”镜像的唯一标识符会有所不同，即使 Dockerfile 中的 HTML 文件内容相同。每一层的标识符不仅基于该层的文件内容，还基于其上层的标识符。因此，如果两个镜像的标识符相同，我们可以确定它们的内容完全相同，即使它们是分开构建的。*'
- en: 'We can run a container based on this new image just as we would any other image:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像运行其他镜像一样运行基于这个新镜像的容器：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As described in [Chapter 1](ch01.xhtml#ch01), the `-p` flag forwards a host
    port into the container, enabling us to access the NGINX server from the host
    even though it is running in a separate network namespace. We then can use `curl`
    to see that our container has the content we provided.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](ch01.xhtml#ch01)所述，`-p`标志将主机端口转发到容器，使我们即使容器运行在一个独立的网络命名空间中，仍然可以从主机访问
    NGINX 服务器。然后我们可以使用`curl`来查看我们的容器是否包含我们提供的内容。
- en: Tagging and Publishing Images
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 镜像标记与发布
- en: The image is ready to run locally, but we’re not ready yet to publish it to
    a registry. To publish to a registry, we need to give it a name that includes
    the full host and path for the registry location to ensure that when we refer
    to an image, we are getting exactly what we expect.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像已经可以在本地运行，但我们还没有准备好将其发布到注册表。要发布到注册表，我们需要给镜像一个名称，该名称包含注册表位置的完整主机和路径，以确保我们在引用镜像时能获取到我们期望的内容。
- en: 'To demonstrate, let’s pull multiple BusyBox images from different registries.
    We’ll start with a BusyBox image from *quay.io*, an alternative container image
    registry:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，让我们从不同的注册表拉取多个 BusyBox 镜像。我们将从*quay.io*开始，*quay.io*是一个替代的容器镜像注册表：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This image name specifies both the host `quay.io` and the location of the image
    within that host, `quay/busybox`. As before, because we didn’t specify a version,
    `latest` is used as a default. We are able to pull a version called `latest` because
    someone has explicitly published a `latest` version of the image to this registry.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个镜像名称指定了主机`quay.io`以及该主机内镜像的位置`quay/busybox`。和之前一样，因为我们没有指定版本，`latest`被用作默认版本。我们能够拉取名为`latest`的版本，因为有人明确将`latest`版本的镜像发布到了这个注册表。
- en: 'The BusyBox image we get using this command is different from the one we get
    if we just pull `busybox`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个命令获取的 BusyBox 镜像与直接拉取`busybox`时获得的镜像不同：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we use the plain name `busybox`, Docker defaults to pulling the image from
    `docker.io/library`. This registry is known as *Docker Hub*, which you can browse
    at *[https://hub.docker.com](https://hub.docker.com)*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用简单名称`busybox`时，Docker 默认从`docker.io/library`拉取镜像。这个注册表被称为*Docker Hub*，你可以在*[https://hub.docker.com](https://hub.docker.com)*浏览它。
- en: Similarly, when we used the plain name `hello` to build our image, Docker sees
    it as belonging to `docker.io/library`. That path is for official Docker images,
    and, of course, we don’t have the right to publish images there.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们使用简单名称`hello`构建镜像时，Docker 会将其视为属于`docker.io/library`。这个路径是官方 Docker 镜像的路径，当然，我们没有权限将镜像发布到这里。
- en: 'The automated setup for this chapter includes running a local container registry,
    which means that we can publish this image to that local registry if we name it
    correctly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的自动化设置包括运行一个本地容器注册表，这意味着如果我们正确命名镜像，我们可以将其发布到该本地注册表：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The same image now exists under two different names, providing an extra advantage
    of the way images are stored by layer. It’s cheap to add an extra name for an
    image. Of course, we could also have used the full name in the first place when
    we ran `docker build`, but it is convenient to use shorter names when building
    and using images locally.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，同一个镜像在两个不同的名称下存在，利用镜像按层存储的方式提供了额外的优势。为镜像添加额外的名称是很便宜的。当然，我们本来也可以在最初运行`docker
    build`时使用完整的名称，但在构建和本地使用镜像时，使用较短的名称更为方便。
- en: 'Now that we have named the image correctly, we can publish it using `docker
    push`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确命名了镜像，我们可以使用`docker push`将其发布：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our local registry starts out empty, so this command uploads all of the layers,
    but if we push any future images that include some of the same layers, they won’t
    be uploaded again. Similarly, if we were to delete an image tag from the registry,
    that would not remove the layer data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的本地注册表一开始是空的，因此此命令会上传所有的层，但如果我们推送任何包含相同层的未来镜像，它们不会被再次上传。同样，如果我们从注册表中删除一个镜像标签，层数据并不会被删除。
- en: 'This ability to publish images is not limited to images that we build ourselves.
    We can tag and push the BusyBox image we just downloaded from Docker Hub:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 发布镜像的能力不限于我们自己构建的镜像。我们可以标记并推送刚刚从Docker Hub下载的BusyBox镜像：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Retagging an image so that we can upload it to a private registry is a common
    practice that can help an application start faster and avoid being dependent on
    an internet registry.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重新标记一个镜像，以便我们可以将其上传到私有注册表，这是一个常见的做法，它有助于应用程序更快启动并避免依赖于互联网注册表。
- en: The last command (`cd`) takes us back to our home directory, given that we’re
    finished in */opt/hello*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个命令（`cd`）将我们带回到我们的主目录，因为我们在*/opt/hello*中已经完成操作。
- en: Image and Container Storage
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜像和容器存储
- en: As mentioned previously, using individual layers to build up a container image
    has multiple advantages, including reduced download size, reduced disk space,
    and the ability to re-tag an image with a new name without using any additional
    space. The additional disk space needed by a running container is limited to just
    the files that we write while the container is running. Finally, all of the examples
    have shown how fast a new container starts up. All of these features together
    demonstrate why layers must be shared, not only for images but also for new containers.
    To make the best use of this layered approach in building efficient images, it
    helps to understand how this layered filesystem works.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用单独的层来构建容器镜像有多个优势，包括减少下载大小、减少磁盘空间，并且可以在不使用额外空间的情况下为镜像重新标记新名称。运行中的容器所需的额外磁盘空间仅限于我们在容器运行时写入的文件。最后，所有的示例都展示了新容器启动的速度有多快。所有这些特性加在一起，说明为什么层必须共享，不仅仅是镜像，还有新的容器。为了更好地利用这种分层方法来构建高效的镜像，了解这种分层文件系统是如何工作的非常重要。
- en: Overlay Filesystems
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 覆盖文件系统
- en: When we run a container, we are presented with what looks like a single filesystem,
    with all the layers merged together and with the ability to make changes to any
    file. If we run multiple containers from the same image, we see an independent
    filesystem in each one, so that changes in one do not affect the other. How does
    this work without having to copy the entire filesystem every time we start a container?
    The answer is an *overlay filesystem*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行容器时，我们看到的是一个看似单一的文件系统，所有层都被合并在一起，并且可以对任何文件进行更改。如果我们从同一个镜像运行多个容器，我们会在每个容器中看到一个独立的文件系统，这样一个容器中的更改不会影响到另一个容器。那么，为什么在每次启动容器时不需要复制整个文件系统呢？答案就是*覆盖文件系统*。
- en: An overlay filesystem has three main parts. The *lower directory* is where the
    “base” layer exists. (There may be multiple lower directories.) The *upper* directory
    has the “overlay” layer, and the *mount* directory is where the unified filesystem
    is made available for use. A directory listing in the mount directory reflects
    all of the files from all of the layers, in priority order. Any changes made to
    the mount directory are really written to the upper directory by copying the changed
    file to the upper directory from a lower one, and then updating it—a process known
    as *copy on write*. Deletions are also written to the upper directory as metadata,
    so the lower directory can remain unmodified. This means that multiple users can
    share the lower directory without conflict because it is only read from, never
    written to.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Overlay 文件系统有三个主要部分。*lower 目录* 是“基础”层所在的位置。（可能有多个 lower 目录。）*upper* 目录包含“覆盖”层，*mount*
    目录是将统一文件系统提供给用户的地方。挂载目录中的目录列表反映了所有层的文件，按优先顺序排列。对挂载目录所做的任何更改，实际上是通过从 lower 目录将更改的文件复制到
    upper 目录并更新它来写入上层目录——这一过程称为 *写时复制*。删除操作也会作为元数据写入 upper 目录，因此 lower 目录保持不变。这意味着多个用户可以共享
    lower 目录而不会发生冲突，因为它仅供读取，从不写入。
- en: An overlay filesystem is useful for more than just container images and containers.
    It is also useful for embedded systems, such as a network router, for which a
    read-only filesystem is written in firmware, making it possible for the device
    to be safely rebooted to a known state every time. It is also useful for virtual
    machines, enabling multiple virtual machines to be started from the same image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Overlay 文件系统不仅对容器镜像和容器有用，它还对嵌入式系统有用，例如网络路由器，对于这种设备，固件中写入只读文件系统，使得设备每次重新启动时都能安全地回到已知状态。它对于虚拟机也有用，可以使多个虚拟机从同一镜像启动。
- en: 'Overlay filesystems are provided by a Linux kernel module, enabling very high
    performance. We can easily create an overlay filesystem. The first step is to
    create the necessary directories:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Overlay 文件系统是由 Linux 内核模块提供的，能提供非常高的性能。我们可以轻松创建一个 Overlay 文件系统。第一步是创建必要的目录：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `mkdir` command creates four separate directories in */tmp*. We’ve already
    discussed the *lower* directory, *upper* directory, and *mount* directory. The
    *work* directory is an extra empty directory that the overlay filesystem uses
    as temporary space to ensure that changes in the mount directory appear atomic—that
    is, to ensure that they appear all at once.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkdir` 命令在 */tmp* 目录中创建了四个独立的目录。我们已经讨论过 *lower* 目录、*upper* 目录和 *mount* 目录。*work*
    目录是一个额外的空目录，Overlay 文件系统使用它作为临时空间，确保挂载目录中的更改是原子性的——也就是说，确保它们一次性出现。'
- en: 'Let’s put some content into the lower and upper directories:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向 lower 目录和 upper 目录中添加一些内容：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we just mount the overlay filesystem:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要挂载 Overlay 文件系统：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The */tmp/mount* directory now contains the merged content of both the upper
    and lower directories:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*/tmp/mount* 目录现在包含了上层和下层目录的合并内容：'
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Any changes that we make are shown in the mount location but are actually made
    in the upper directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的任何更改都会显示在挂载位置，但实际上是在上层目录中进行的：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Additionally, even deleting files does not affect the lower directory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使删除文件，也不会影响 lower 目录：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `c` next to the listing for `hello1` in the upper directory ➊ indicates
    that this is a *character special file*. Its purpose is to indicate that this
    file was deleted in the upper directory. As a result, it does not show up in the
    mounted filesystem, even though it still exists in the lower directory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello1` 在上层目录 ➊ 的列表旁边的 `c` 表明这是一个 *字符特殊文件*。它的作用是表示该文件在上层目录中已被删除。因此，尽管它仍然存在于
    lower 目录中，但在挂载的文件系统中并未显示出来。'
- en: 'Thanks to this approach, we can reuse the lower directory with an independent
    overlay, similar to how we can run multiple independent containers from the same
    image:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这种方法，我们可以使用独立的 Overlay 重新使用 lower 目录，类似于我们可以从同一镜像运行多个独立容器的方式：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Not only does the “deleted” file from the lower directory appear, but none of
    the content from the first upper directory shows up because it’s not part of this
    new overlay.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅来自 lower 目录的“已删除”文件会出现，来自第一个上层目录的任何内容也不会出现，因为它不是这个新 Overlay 的一部分。
- en: Understanding Container Layers
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解容器层
- en: 'Armed with this information about overlay filesystems, we can explore the filesystem
    of our running NGINX container:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有了关于 Overlay 文件系统的信息，我们可以探索正在运行的 NGINX 容器的文件系统：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As before, we use `jq` to choose just the field we want; in this case, it’s
    the path to the *merged* directory for the container’s filesystem. This merged
    directory is the mount point for an overlay filesystem:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用 `jq` 只选择我们想要的字段；在这种情况下，它是容器文件系统的 *merged* 目录路径。这个合并目录是 overlay 文件系统的挂载点：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `tr` command transforms colons and commas to newlines to make the output
    more readable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr` 命令将冒号和逗号转换为换行符，以使输出更加易读。'
- en: The `mount` command shows seven separate entries for `lowerdir`, one for each
    of the layers in the NGINX container image. All seven of these directories, plus
    the `upperdir`, are merged together in the overlay filesystem.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount` 命令显示了 `lowerdir` 的七个单独条目，每个条目对应 NGINX 容器镜像中的一层。这七个目录，加上 `upperdir`，在
    overlay 文件系统中合并在一起。'
- en: 'We can see the 10MB data file we created earlier in both the mount directory
    and the upper directory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在挂载目录和上层目录中看到我们之前创建的 10MB 数据文件：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The actual file is stored in the upper directory *diff*, whereas the mount directory
    *merged* is just a view generated by the overlay filesystem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的文件存储在上层目录 *diff* 中，而挂载目录 *merged* 只是 overlay 文件系统生成的视图。
- en: Usually, we don’t need to delve into the container filesystem from the host,
    because we can just run commands from within the container to explore its files.
    However, this technique can be useful for pulling files from a container for cases
    in which the container engine is not behaving correctly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不需要从宿主机深入容器文件系统，因为我们可以直接从容器内运行命令来探索其文件。然而，这种技术在容器引擎行为不正常时拉取容器文件会非常有用。
- en: Practical Image Building Advice
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实用的镜像构建建议
- en: Some important practical implications result from the way that overlay filesystems
    are used with container images. First, because an overlay filesystem can have
    multiple lower directories, and merging is performant, breaking our container
    image into multiple layers causes very little performance penalty. It allows us
    to be very modular when building container images, enabling reuse of layers. For
    example, we might start with a base image and then build an image on top that
    installs some common dependencies, and then another image that adds specialized
    dependencies for some of our application components, and finally yet another image
    that adds a specific application. Assembling application container images using
    a layered approach can result in very efficient image transfer and storage, as
    the base layers are shared between components where possible.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器镜像时，overlay 文件系统的方式带来了一些重要的实际影响。首先，由于 overlay 文件系统可以有多个下层目录，且合并操作具有高效性，因此将容器镜像分为多个层几乎不会带来性能损失。这使得我们在构建容器镜像时能够非常模块化，方便复用各层。例如，我们可以从一个基础镜像开始，然后在其上构建一个安装了常用依赖的镜像，再构建另一个镜像，加入一些特定应用组件的依赖，最后构建另一个镜像，添加特定的应用程序。使用分层的方法组装应用容器镜像可以实现非常高效的镜像传输和存储，因为基础层可以在各个组件之间共享。
- en: 'Second, because a deletion in an upper layer does not actually remove the file
    from a lower layer, we need to be careful with how we handle large temporary files
    and also in how we store secrets while building images. In both cases, if we finish
    a layer while the file is still present, it will be there forever, causing us
    to waste bandwidth and space, or worse, leak secret information to anyone who
    downloads the image. In general, you should assume that every line of a *Dockerfile*
    makes a new layer, and you should also make the assumption that all of the information
    associated with each command is stored in the image metadata. As a result:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，因为在上层删除一个文件并不会真正删除下层的文件，我们需要小心如何处理大型临时文件，以及在构建镜像时如何存储机密信息。在这两种情况下，如果在文件仍然存在时完成了一层构建，它将永远存在，从而浪费带宽和空间，甚至更糟，泄露机密信息给下载镜像的任何人。一般来说，你应该假设每一行
    *Dockerfile* 都会生成一个新的层，而且你应该假设每个命令相关的所有信息都会存储在镜像的元数据中。因此：
- en: Perform multiple steps in a single `RUN` line, and make sure every `RUN` command
    cleans up after itself.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个 `RUN` 行中执行多个步骤，并确保每个 `RUN` 命令在执行后自行清理。
- en: Don’t use `COPY` to transfer large files or secrets into the image, even if
    you clean them up in a later `RUN` step.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用 `COPY` 命令将大文件或机密信息转移到镜像中，即使你在后续的 `RUN` 步骤中清理它们。
- en: Don’t use `ENV` to store secrets, because the resulting values become part of
    the image metadata.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用 `ENV` 存储机密信息，因为最终生成的值会成为镜像元数据的一部分。
- en: Open Container Initiative
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开放容器倡议
- en: A container image is more than just the set of layers that make up the overlay
    filesystem. It also includes important metadata, such as the initial command for
    the container and any environment variables for that command. The Open Container
    Initiative (OCI) provides a standard format for storing image information. It
    ensures that container images built by one tool can be used by any other tool
    and provides a standard way to transfer images layer by layer or in a complete
    package.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容器镜像不仅仅是构成覆盖文件系统的层集合。它还包括重要的元数据，如容器的初始命令以及该命令的任何环境变量。开放容器倡议（OCI）提供了存储图像信息的标准格式。它确保由一个工具构建的容器镜像可以被任何其他工具使用，并提供了逐层或完整包裹传输图像的标准方式。
- en: 'To demonstrate the OCI format, let’s extract a BusyBox container image from
    Docker and store it in OCI format using Skopeo, a program designed to move container
    images around between repositories and formats. The first step is to extract the
    image:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 OCI 格式，让我们从 Docker 中提取一个 BusyBox 容器镜像，并使用 Skopeo 将其存储为 OCI 格式，Skopeo 是一个设计用于在仓库和格式之间移动容器镜像的程序。第一步是提取镜像：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This command tells Skopeo to fetch the image from the Docker engine’s storage
    and write it out in OCI format. We now have a *busybox* directory that contains
    the image:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这条命令告诉 Skopeo 从 Docker 引擎的存储中获取镜像，并以 OCI 格式输出。现在我们有一个包含该镜像的 *busybox* 目录：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The *oci-layout* file specifies the OCI version used for this image:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*oci-layout* 文件指定了用于此镜像的 OCI 版本：'
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The *index.json* file tells us about the image:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.json* 文件告诉我们有关该镜像的信息：'
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `manifests` property is an array that allows us to store multiple images
    in a single OCI directory or package. The actual filesystem content is stored
    by layer in the *blobs* directory, with each layer as a separate *.tar* file,
    so any shared layers are stored only once.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*manifests* 属性是一个允许我们在单个 OCI 目录或包中存储多个镜像的数组。实际的文件系统内容按层存储在 *blobs* 目录中，每个层作为单独的
    *.tar* 文件，因此任何共享层只存储一次。'
- en: 'This BusyBox image has only a single layer. To look at its contents, we’ll
    need to work through the *index.json* and image manifest to find the path to its
    *.tar* file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 BusyBox 镜像只有一个单独的层。要查看其内容，我们需要通过 *index.json* 和镜像清单找到其 *.tar* 文件的路径：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The files in the *blobs* directory are named using the SHA-256 digest calculated
    from the file contents. We start by using `jq` to get the digest for the BusyBox
    image’s manifest, stripping off the `sha256:` part at the front to get the name
    of the manifest file. We then read the manifest to find the first (and only) layer.
    We now can see the content of this layer:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*blobs* 目录中的文件使用从文件内容计算得出的 SHA-256 摘要命名。我们首先使用 `jq` 获取 BusyBox 镜像清单的摘要，去掉前面的
    `sha256:` 部分以获取清单文件的名称。然后读取清单以找到第一个（也是唯一的）层。现在我们可以看到这一层的内容：'
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Passing `tvf` to the `tar` command tells it to list a table of contents from
    the file we specify, which is the BusyBox image layer in this case. This layer
    contains a complete Linux filesystem, with BusyBox acting as the single executable
    for most of the standard Linux commands.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `tar` 命令传递 `tvf` 告诉它列出我们指定的文件的内容表，这里是 BusyBox 镜像层。该层包含一个完整的 Linux 文件系统，其中
    BusyBox 作为大多数标准 Linux 命令的单个可执行文件。
- en: Using this *busybox* directory, we can also package up the container image,
    move it to a separate system, and then pull it into another container engine.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 *busybox* 目录，我们还可以将容器镜像打包起来，移动到另一个系统，然后在另一个容器引擎中拉取它。
- en: Final Thoughts
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结思路
- en: When we run a container, we get what appears to be a separate, isolated filesystem
    that we can modify as desired. Underneath, the container engine is using the overlay
    filesystem to merge together multiple container image layers and a writeable directory
    that stores all the changes we make. Not only does the use of an overlay filesystem
    make a new container fast to start, but it also means that we can run multiple
    containers from the same image without waiting for file copy to complete, and
    we can reduce the required disk space by sharing image layers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行容器时，我们会得到一个看起来是独立的、隔离的文件系统，可以按需修改。在底层，容器引擎使用覆盖文件系统将多个容器镜像层合并到一起，并使用可写目录存储我们所做的所有更改。使用覆盖文件系统不仅使新容器快速启动，还意味着我们可以从同一镜像运行多个容器而无需等待文件复制完成，并且可以通过共享镜像层来减少所需的磁盘空间。
- en: Now that we’ve looked at process isolation, resource limits, network isolation,
    and container storage, we’ve covered the main features of containers that make
    them so valuable for packaging, distributing, updating, and running application
    components. It’s time to move on to the critical features that we can get only
    from a container orchestration environment like Kubernetes. We’ll do that in [Part
    II](part02.xhtml#part02).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了进程隔离、资源限制、网络隔离和容器存储，这些都是容器在打包、分发、更新和运行应用组件时非常有价值的主要特性。接下来，我们将讨论只有在像Kubernetes这样的容器编排环境中才能获得的关键特性。我们将在[第二部分](part02.xhtml#part02)中进行讨论。
