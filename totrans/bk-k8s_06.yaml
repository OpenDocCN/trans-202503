- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CONTAINER IMAGES AND RUNTIME LAYERS
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To run a process, we need storage. One of the great advantages of containerized
    software is the ability to bundle an application for delivery together with its
    dependencies. As a result, we need to store the executable for the program and
    any shared libraries it uses. We also need to store configuration files, logs,
    and any data managed by the program. All of this storage must be isolated so that
    a container can’t interfere with the host system or with other containers. Altogether,
    this represents a large need for storage, and it means container engines must
    provide some unique features to be efficient in the use of disk space and bandwidth.
    In this chapter, we’ll explore how the use of a layered filesystem makes container
    images efficient to download and containers efficient to start.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem Isolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml#ch02), we saw how we could use a *chroot* environment
    to create a separate, isolated part of the filesystem that contained only the
    binaries and libraries we needed to run a process. Even to run a simple `ls` command,
    we needed the binary and several libraries. A more fully featured container, such
    as one running the NGINX web server, needs quite a bit more—a complete set of
    files for a Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: In the chroot example, we built the isolated filesystem from the host system
    when we were ready to use it. That approach would be impractical for containers.
    Instead, the isolated filesystem is packaged in a *container image*, which is
    a ready-to-use bundle that includes all files and metadata, such as environment
    variables and the default executable.
  prefs: []
  type: TYPE_NORMAL
- en: Container Image Contents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take a quick look inside an NGINX container image. For this chapter, we’ll
    be running commands using Docker because it’s still the most common tool for building
    container images.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The example repository for this book is at* [https://github.com/book-of-kubernetes/examples](https://github.com/book-of-kubernetes/examples).
    *See “Running Examples” on [page xx](ch00.xhtml#ch00lev1sec2) for details on getting
    set up.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command on *host01* from this chapter’s examples to download
    the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker pull` command downloads an image from an *image registry*. An image
    registry is a web server that implements an API for downloading and publishing
    container images. We can see the image we’ve downloaded by listing images with
    `docker images`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This image is 133MB and has a unique identifier of `f0b8a9a54136`. (Your identifier
    will be different, as new NGINX container images are built every day.) This image
    includes not only the NGINX executables and required libraries but also a Linux
    distribution based on Debian. We saw this briefly in [Chapter 1](ch01.xhtml#ch01)
    when we demonstrated a Rocky Linux container on an Ubuntu host and kernel, but
    let’s look at it in a little more detail. Start by running an NGINX container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `--name` flag gives the container a friendly name that we can use for future
    commands, whereas the `-d` flag sends it to the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s explore the filesystem of our running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we can see the various libraries needed for NGINX to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All of these libraries are part of the container image we downloaded, so our
    NGINX container does not need (and cannot see) any files from the host system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only do we have a healthy number of libraries present, but we have typical
    configuration files in */etc* that we would expect for a Debian system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This listing shows that the filesystem even includes directories that aren’t
    really needed for a container, like the */etc/systemd* directory. (Remember, a
    container is just a set of related processes run under isolation, so a container
    almost never runs a system service manager like systemd.) This full filesystem
    is included for a couple reasons. First, many processes were written to expect
    the usual set of files to be present. Second, it’s just easier to build container
    images starting from a typical Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The separate filesystem for our container is writable as well. While we have
    this shell open, let’s send some random data to a file in the container so that
    we can inspect that storage from the host. We can then exit the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dd` command wrote a 10MB file into the */tmp* directory. Even though we
    exited the shell, the container is still running, so we can use `docker inspect`
    to see the amount of disk space this container is using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-s` flag tells `docker inspect` to report the size of the container. Because
    `docker inspect` produces a huge JSON output, we use the JSON query tool `jq`
    to choose the field we want.
  prefs: []
  type: TYPE_NORMAL
- en: The reported size is just about 10MB, suggesting that the container is consuming
    only the amount of read-write storage required for the file we wrote, plus any
    files written by NGINX. We’ll explore this in more detail as we continue in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Image Versions and Layers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ability to quickly download a prepackaged filesystem to run a process is
    only one of the advantages of container images. Another is the ability to tag
    different versions of an image to allow for rapid upgrading. Let’s explore this
    by pulling and running two different versions of Redis, the popular in-memory
    key–value database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The data after the colon is the *image tag* and acts as a version identifier.
    Previously, when we left this off, Docker defaulted to *latest*, which is a tag
    like any other, but it is used by convention to refer to the latest published
    image. By specifying the version, we can ensure that even as newer versions of
    Redis are released, we will continue to run the same version until we are ready
    to upgrade. The tag can contain any characters, and it is common to add extra
    information after a hyphen. In this case, the `-alpine` at the end of the tag
    indicates that this image is based on Alpine Linux, a lightweight Linux distribution
    that is popular for making container images because of its small size.
  prefs: []
  type: TYPE_NORMAL
- en: One other interesting item of note is the fact that when we downloaded the second
    version of Redis, some of the content ➋ was flagged as `Already exists`. Looking
    at the first Redis download, we see the same unique identifiers are present there
    ➊. This is because a container image is made up of layers, and these identifiers
    uniquely describe a layer. If a layer we’ve already downloaded is used by another
    image, we don’t need to download it again, saving download time. Additionally,
    each layer needs to be stored only once on disk, saving disk space.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have two different versions of Redis downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Although Docker is reporting that each image has a size of about 30MB, that
    is the total size of all the layers and doesn’t account for the storage savings
    that come from shared layers. The actual storage on disk is less, as we can see
    by examining Docker’s use of disk space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The two Redis images are sharing almost 7MB of base layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two versions of Redis can be run separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that both images are running, we can confirm that our containers have exactly
    the version of Redis we want, independent of what version might be the latest
    release and independent of the versions available for our host server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is a big advantage for building reliable systems. We can test our application
    thoroughly with one version of the software and be sure that version will continue
    to be used until we choose to upgrade. We can also easily test our software against
    a new version without having to upgrade a host system.
  prefs: []
  type: TYPE_NORMAL
- en: Building Container Images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding example, we saw how we could reduce the download and disk requirements
    for container images by sharing layers. This layer sharing can be used with any
    container image, not just two different versions of the same software.
  prefs: []
  type: TYPE_NORMAL
- en: The layers in a container image come from the way it is built. A container image
    build starts with a *base image*. For example, both of our two Redis versions
    started with the same exact Alpine Linux base image, which is why those layers
    were shared in that image. Starting from the base image, each step in the build
    process can produce a new layer. This new layer contains only the changes to the
    filesystem that came from that build step.
  prefs: []
  type: TYPE_NORMAL
- en: A base image must also come from somewhere, and, ultimately, there must be an
    initial layer, which is typically a minimal Linux filesystem created from some
    Linux distribution, transferred into an empty container image, and then expanded
    to become an initial layer.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Dockerfile
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are many different ways to build container images, but the most popular
    is to create a file known as a *Dockerfile* or *Containerfile* that specifies
    the commands and configuration for the image. Here’s a simple *Dockerfile* that
    adds web content to an NGINX image:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dockerfile*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line in a *Dockerfile* starts with a command that is followed by parameters.
    Blank lines and content after a `#` are ignored, and a backslash at the end of
    a line continues that command onto the next line. There are many possible commands;
    here are the most common:'
  prefs: []
  type: TYPE_NORMAL
- en: FROM Specify the base image for this build.
  prefs: []
  type: TYPE_NORMAL
- en: RUN Run a command inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: COPY Copy files into the container.
  prefs: []
  type: TYPE_NORMAL
- en: ENV Specify an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: ENTRYPOINT Configure the initial process for the container.
  prefs: []
  type: TYPE_NORMAL
- en: CMD Set default parameters for the initial process.
  prefs: []
  type: TYPE_NORMAL
- en: Docker provides the `docker build` command to build an image from a *Dockerfile*.
    The `docker build` command creates a new image by running each command in the
    *Dockerfile*, one at a time. [Listing 5-1](ch05.xhtml#ch05list1) illustrates how
    to run `docker build`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-1: Docker build*'
  prefs: []
  type: TYPE_NORMAL
- en: The `-t` switch tells `docker build` to store the image from the build process
    under the name `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the steps in this build process will help clarify how container images
    are made. First, Docker sends the *build context* to the Docker daemon ➊. The
    build context is a directory and all of its files and subdirectories. In this
    case, we specified the build context as the current directory when we added `.`
    to the end of the `docker build` command. The actual container image build happens
    inside the daemon, so the only files that would be available for a `COPY` command
    are those that are in the build context.
  prefs: []
  type: TYPE_NORMAL
- en: Second, Docker identifies our base image, in this case `nginx`. The unique identifier
    it displays ➋ matches the one displayed earlier for our NGINX image when we ran
    `docker images`. Third, Docker executes the command we specified in the `RUN`
    step. This command is actually run inside a container based on our NGINX base
    image ➌, which means that only the commands installed in the container image are
    available to run. If we need other commands to be available, we might need to
    create a `RUN` step that installs them before we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all of the build steps are complete, Docker “tags” the new container
    image with the name we provided using the `-t` flag. As before, we didn’t specify
    a version, so `latest` is used as a default. We now can see this image in the
    list of available images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The unique identifier for this image matches the output from the end of [Listing
    5-1](ch05.xhtml#ch05list1). This image is shown as 133MB because it has all of
    the layers from the NGINX image in addition to the new small HTML file we added.
    As before, the shared layers are stored only once, so the extra storage required
    to build this image was very small.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you try this example yourself, the unique identifier displayed for your
    “hello” image will be different, even though the Dockerfile has the same content
    for the HTML file. The identifier for each layer is based not only on the layer’s
    file content but also on the identifier for the layer above it. As a result, if
    two images have the same identifier, we can be confident that the contents are
    exactly the same, even if they were built separately.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run a container based on this new image just as we would any other image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As described in [Chapter 1](ch01.xhtml#ch01), the `-p` flag forwards a host
    port into the container, enabling us to access the NGINX server from the host
    even though it is running in a separate network namespace. We then can use `curl`
    to see that our container has the content we provided.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging and Publishing Images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The image is ready to run locally, but we’re not ready yet to publish it to
    a registry. To publish to a registry, we need to give it a name that includes
    the full host and path for the registry location to ensure that when we refer
    to an image, we are getting exactly what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, let’s pull multiple BusyBox images from different registries.
    We’ll start with a BusyBox image from *quay.io*, an alternative container image
    registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This image name specifies both the host `quay.io` and the location of the image
    within that host, `quay/busybox`. As before, because we didn’t specify a version,
    `latest` is used as a default. We are able to pull a version called `latest` because
    someone has explicitly published a `latest` version of the image to this registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The BusyBox image we get using this command is different from the one we get
    if we just pull `busybox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When we use the plain name `busybox`, Docker defaults to pulling the image from
    `docker.io/library`. This registry is known as *Docker Hub*, which you can browse
    at *[https://hub.docker.com](https://hub.docker.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when we used the plain name `hello` to build our image, Docker sees
    it as belonging to `docker.io/library`. That path is for official Docker images,
    and, of course, we don’t have the right to publish images there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The automated setup for this chapter includes running a local container registry,
    which means that we can publish this image to that local registry if we name it
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The same image now exists under two different names, providing an extra advantage
    of the way images are stored by layer. It’s cheap to add an extra name for an
    image. Of course, we could also have used the full name in the first place when
    we ran `docker build`, but it is convenient to use shorter names when building
    and using images locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have named the image correctly, we can publish it using `docker
    push`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Our local registry starts out empty, so this command uploads all of the layers,
    but if we push any future images that include some of the same layers, they won’t
    be uploaded again. Similarly, if we were to delete an image tag from the registry,
    that would not remove the layer data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This ability to publish images is not limited to images that we build ourselves.
    We can tag and push the BusyBox image we just downloaded from Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Retagging an image so that we can upload it to a private registry is a common
    practice that can help an application start faster and avoid being dependent on
    an internet registry.
  prefs: []
  type: TYPE_NORMAL
- en: The last command (`cd`) takes us back to our home directory, given that we’re
    finished in */opt/hello*.
  prefs: []
  type: TYPE_NORMAL
- en: Image and Container Storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, using individual layers to build up a container image
    has multiple advantages, including reduced download size, reduced disk space,
    and the ability to re-tag an image with a new name without using any additional
    space. The additional disk space needed by a running container is limited to just
    the files that we write while the container is running. Finally, all of the examples
    have shown how fast a new container starts up. All of these features together
    demonstrate why layers must be shared, not only for images but also for new containers.
    To make the best use of this layered approach in building efficient images, it
    helps to understand how this layered filesystem works.
  prefs: []
  type: TYPE_NORMAL
- en: Overlay Filesystems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we run a container, we are presented with what looks like a single filesystem,
    with all the layers merged together and with the ability to make changes to any
    file. If we run multiple containers from the same image, we see an independent
    filesystem in each one, so that changes in one do not affect the other. How does
    this work without having to copy the entire filesystem every time we start a container?
    The answer is an *overlay filesystem*.
  prefs: []
  type: TYPE_NORMAL
- en: An overlay filesystem has three main parts. The *lower directory* is where the
    “base” layer exists. (There may be multiple lower directories.) The *upper* directory
    has the “overlay” layer, and the *mount* directory is where the unified filesystem
    is made available for use. A directory listing in the mount directory reflects
    all of the files from all of the layers, in priority order. Any changes made to
    the mount directory are really written to the upper directory by copying the changed
    file to the upper directory from a lower one, and then updating it—a process known
    as *copy on write*. Deletions are also written to the upper directory as metadata,
    so the lower directory can remain unmodified. This means that multiple users can
    share the lower directory without conflict because it is only read from, never
    written to.
  prefs: []
  type: TYPE_NORMAL
- en: An overlay filesystem is useful for more than just container images and containers.
    It is also useful for embedded systems, such as a network router, for which a
    read-only filesystem is written in firmware, making it possible for the device
    to be safely rebooted to a known state every time. It is also useful for virtual
    machines, enabling multiple virtual machines to be started from the same image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overlay filesystems are provided by a Linux kernel module, enabling very high
    performance. We can easily create an overlay filesystem. The first step is to
    create the necessary directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `mkdir` command creates four separate directories in */tmp*. We’ve already
    discussed the *lower* directory, *upper* directory, and *mount* directory. The
    *work* directory is an extra empty directory that the overlay filesystem uses
    as temporary space to ensure that changes in the mount directory appear atomic—that
    is, to ensure that they appear all at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put some content into the lower and upper directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we just mount the overlay filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The */tmp/mount* directory now contains the merged content of both the upper
    and lower directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Any changes that we make are shown in the mount location but are actually made
    in the upper directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, even deleting files does not affect the lower directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `c` next to the listing for `hello1` in the upper directory ➊ indicates
    that this is a *character special file*. Its purpose is to indicate that this
    file was deleted in the upper directory. As a result, it does not show up in the
    mounted filesystem, even though it still exists in the lower directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to this approach, we can reuse the lower directory with an independent
    overlay, similar to how we can run multiple independent containers from the same
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Not only does the “deleted” file from the lower directory appear, but none of
    the content from the first upper directory shows up because it’s not part of this
    new overlay.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Container Layers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Armed with this information about overlay filesystems, we can explore the filesystem
    of our running NGINX container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we use `jq` to choose just the field we want; in this case, it’s
    the path to the *merged* directory for the container’s filesystem. This merged
    directory is the mount point for an overlay filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `tr` command transforms colons and commas to newlines to make the output
    more readable.
  prefs: []
  type: TYPE_NORMAL
- en: The `mount` command shows seven separate entries for `lowerdir`, one for each
    of the layers in the NGINX container image. All seven of these directories, plus
    the `upperdir`, are merged together in the overlay filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the 10MB data file we created earlier in both the mount directory
    and the upper directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The actual file is stored in the upper directory *diff*, whereas the mount directory
    *merged* is just a view generated by the overlay filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we don’t need to delve into the container filesystem from the host,
    because we can just run commands from within the container to explore its files.
    However, this technique can be useful for pulling files from a container for cases
    in which the container engine is not behaving correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Practical Image Building Advice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some important practical implications result from the way that overlay filesystems
    are used with container images. First, because an overlay filesystem can have
    multiple lower directories, and merging is performant, breaking our container
    image into multiple layers causes very little performance penalty. It allows us
    to be very modular when building container images, enabling reuse of layers. For
    example, we might start with a base image and then build an image on top that
    installs some common dependencies, and then another image that adds specialized
    dependencies for some of our application components, and finally yet another image
    that adds a specific application. Assembling application container images using
    a layered approach can result in very efficient image transfer and storage, as
    the base layers are shared between components where possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, because a deletion in an upper layer does not actually remove the file
    from a lower layer, we need to be careful with how we handle large temporary files
    and also in how we store secrets while building images. In both cases, if we finish
    a layer while the file is still present, it will be there forever, causing us
    to waste bandwidth and space, or worse, leak secret information to anyone who
    downloads the image. In general, you should assume that every line of a *Dockerfile*
    makes a new layer, and you should also make the assumption that all of the information
    associated with each command is stored in the image metadata. As a result:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform multiple steps in a single `RUN` line, and make sure every `RUN` command
    cleans up after itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t use `COPY` to transfer large files or secrets into the image, even if
    you clean them up in a later `RUN` step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t use `ENV` to store secrets, because the resulting values become part of
    the image metadata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Container Initiative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A container image is more than just the set of layers that make up the overlay
    filesystem. It also includes important metadata, such as the initial command for
    the container and any environment variables for that command. The Open Container
    Initiative (OCI) provides a standard format for storing image information. It
    ensures that container images built by one tool can be used by any other tool
    and provides a standard way to transfer images layer by layer or in a complete
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the OCI format, let’s extract a BusyBox container image from
    Docker and store it in OCI format using Skopeo, a program designed to move container
    images around between repositories and formats. The first step is to extract the
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This command tells Skopeo to fetch the image from the Docker engine’s storage
    and write it out in OCI format. We now have a *busybox* directory that contains
    the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The *oci-layout* file specifies the OCI version used for this image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The *index.json* file tells us about the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `manifests` property is an array that allows us to store multiple images
    in a single OCI directory or package. The actual filesystem content is stored
    by layer in the *blobs* directory, with each layer as a separate *.tar* file,
    so any shared layers are stored only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'This BusyBox image has only a single layer. To look at its contents, we’ll
    need to work through the *index.json* and image manifest to find the path to its
    *.tar* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The files in the *blobs* directory are named using the SHA-256 digest calculated
    from the file contents. We start by using `jq` to get the digest for the BusyBox
    image’s manifest, stripping off the `sha256:` part at the front to get the name
    of the manifest file. We then read the manifest to find the first (and only) layer.
    We now can see the content of this layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Passing `tvf` to the `tar` command tells it to list a table of contents from
    the file we specify, which is the BusyBox image layer in this case. This layer
    contains a complete Linux filesystem, with BusyBox acting as the single executable
    for most of the standard Linux commands.
  prefs: []
  type: TYPE_NORMAL
- en: Using this *busybox* directory, we can also package up the container image,
    move it to a separate system, and then pull it into another container engine.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we run a container, we get what appears to be a separate, isolated filesystem
    that we can modify as desired. Underneath, the container engine is using the overlay
    filesystem to merge together multiple container image layers and a writeable directory
    that stores all the changes we make. Not only does the use of an overlay filesystem
    make a new container fast to start, but it also means that we can run multiple
    containers from the same image without waiting for file copy to complete, and
    we can reduce the required disk space by sharing image layers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at process isolation, resource limits, network isolation,
    and container storage, we’ve covered the main features of containers that make
    them so valuable for packaging, distributing, updating, and running application
    components. It’s time to move on to the critical features that we can get only
    from a container orchestration environment like Kubernetes. We’ll do that in [Part
    II](part02.xhtml#part02).
  prefs: []
  type: TYPE_NORMAL
